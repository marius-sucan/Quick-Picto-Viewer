; Original script details:
;   Name:     AHK Picture Viewer
;   Version:  1.0.0 on Oct 4, 2010 by SBC
;   Platform: Windows XP or later
;   Author:   SBC - http://sites.google.com/site/littlescripting/
;   Found on: https://autohotkey.com/board/topic/58226-ahk-picture-viewer/
;
; New script details:
;   Name:     Quick Picto Viewer
;   Version:  [see change logs file]
;   Platform: Windows 7 or later, preferred is Windows 10.
;   Author:   Marius Șucan - http://marius.sucan.ro/
;   GitHub:   https://github.com/marius-sucan/Quick-Picto-Viewer
;   Requires: AHK-H v1.1.32.
;
; Quick Picto Viewer can run on Windows 7 and even on XP, but various features
; might not work. To this end, you may have to copy all the DLL files found
; in the .\optional-DLL-files-x64\ folder to the same folder where the QPV
; binary is. If you are running it uncompiled, you must place them in the
; folder where the AutoHotkey binary resides. The required DLLs for x64
; are bundled since version 5.7.5 in the ZIP package and can also be found
; in the Github repository.
;
; The following DLLs are already located in the main Quick Picto Viewer folder:
; FreeImage.dll
; msvcr100.dll
; sqlite3.dll
; ucrtbase.dll
; vcomp140.dll
; vcruntime140.dll
;
; QPV main functionalities:
; Display images, edit images, organize and create slideshows using GDI+ 
; and the FreeImage library.
; 85 supported image formats: jpeg, jpg, bmp, png, gif, tif, emf
; hdr, exr, webp, raw and many more...
;
; Original Licence: GPL. Please reffer to this page for more information. http://www.gnu.org/licenses/gpl.html
; Current licence: I do not know, I do not care. Licences are for obedient entities.
;
;@Ahk2Exe-AddResource LIB Lib\module-interface.ahk
;@Ahk2Exe-AddResource LIB Lib\module-fim-thumbs.ahk
;@Ahk2Exe-SetName Quick Picto Viewer
;@Ahk2Exe-SetDescription Quick Picto Viewer
;@Ahk2Exe-SetVersion 5.7.4
;@Ahk2Exe-SetCopyright Marius Şucan (2019-2021)
;@Ahk2Exe-SetCompanyName marius.sucan.ro
;@Ahk2Exe-SetMainIcon qpv-icon.ico
;
;___________ Auto Execute Section ____

#NoEnv
#NoTrayIcon
#MaxHotkeysPerInterval, 950
#HotkeyInterval, 50
#MaxThreads, 255
#MaxThreadsPerHotkey, 1
#MaxThreadsBuffer, Off
#MaxMem, 9924
#IfTimeout, 35
#SingleInstance, off
#UseHook, Off
DetectHiddenWindows, On
CoordMode, Mouse, Screen
CoordMode, ToolTip, Screen
CoordMode, Menu, Screen
SetWorkingDir, %A_ScriptDir%
#Include Lib\Gdip_All.ahk           ; graphics display interface plus v1.1, extended compilation editon
#Include Lib\Gdi.ahk                ; graphics display interface written by Marius Șucan
#Include Lib\SGdiPrint.ahk
#Include Lib\freeimage-wrapper.ahk  ; used to load exotic file formats ; written by Marius Șucan
#Include Lib\MCI.ahk                ; media controller interface [ used for audio annotations/files associated with images ] - by Fincs
#Include Lib\wia.ahk                ; windows image acquisition ; used for acquiring images from scanners 
#Include Lib\Class_SQLiteDB.ahk     ; used for slideshow databases and maintaining a list of viewed images [if activated] - by just-me
#Include Lib\Class_CtlColors.ahk    ; used for dark mode - by just-me
#Include Lib\msgbox2.ahk
#Include Lib\tvh.ahk                ; Functions for TreeView controls. by just-me
#Include Lib\LV_EX.ahk                ; Functions for list views. by just-me
#Include Lib\shell-stuff.ahk
#Include Lib\hashtable.ahk          ; super-fast and capable arrays; by Helgef
#Include Lib\file-get-prop-lib.ahk  ; used to get file properties on Alt+Enter [ File Information panel ]

SetWinDelay, 1
SetBatchLines, -1

Global PVhwnd := 1, hGDIwin := 1, hGDIthumbsWin := 1, pPen4 := "", pPen5 := "", pPen6 := "", unCompiledExePath := "", pBrushZ := ""
   , glPG := "", glOBM := "", glHbitmap := "", glHDC := "", pPen1 := "", pPen1d, pPen2 := "", pPen3 := ""
   , pBrushHatch := "", pBrushWinBGR := "", pBrushA := "", pBrushB := "", pBrushC := "", pBrushD := "", currentPixFmt := ""
   , pBrushE := "", pBrushHatchLow, hGuiTip := 1, hSetWinGui := 1, undoSelLevelsArray := [], QPVerrJournal := []
   , prevFullThumbsUpdate := 1, winGDIcreated := 0, ThumbsWinGDIcreated := 0, currentFilesListModified := 0
   , hPicOnGui1 := "", scriptStartTime := A_TickCount, lastEditRHChange :=1, doubleBlurPreviewArea := 0
   , newStaticFoldersListCache := [], lastEditRWChange := 1, QPVjournal := [], pPen7 := "", hQPVtoolbar
   , mainCompiledExe := "", mainCompiledPath := "", wasInitFIMlib := 0, hGDIselectWin, allowNextSlide := 1
   , filteredMap2mainList := [], thumbsCacheFolder := A_ScriptDir "\thumbs-cache", hSNDsong, lastZeitOpenWin := 1
   , resultedFilesList := [], currentFileIndex := "", maxFilesIndex := 0, gdiBitmapIDentire := 0
   , appTitle := "Quick Picto Viewer", FirstRun := 1, hSNDmediaFile := "", mouseToolTipWinCreated := 0
   , bckpResultedFilesList := [], bckpMaxFilesIndex := 0, DynamicFoldersList := "", lastPointerUseZeit := 1
   , animGIFplaying := 0, startPageIndex := 0, RandyIMGids := [], IMGdecalageY := 1, IMGdecalageX := 1
   , RandyIMGnow := 0, GDIPToken := "", gdiBitmapSmall := "", hSNDmedia := "", imgIndexEditing := 0
   , AprevGdiBitmap := "", BprevGdiBitmap := "", msgDisplayTime := 3000, gdiBitmapIDcall := "", LVitemsPerPage := 5100
   , slideShowRunning := 0, CurrentSLD := "", markedSelectFile := 0, IMGlargerViewPort := 0, thisPanelTab := 1
   , ResolutionWidth := "", ResolutionHeight := "", prevStartIndex := 1, mustReloadThumbsList := 0
   , gdiBitmap := "", mainSettingsFile := "quick-picto-viewer.ini", mainRecentsFile := "quick-picto-viewer-recents.ini"
   , mustOpenStartFolder := "", mainFavesFile := "quick-picto-viewer-favourites.ini", miniFavesFile := "quick-picto-viewer-minifaves.ini"
   , RegExAllFilesPattern := "ico|dib|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif|webp"
   , RegExFilesPattern := "i)^(.\:\\).*(\.(" RegExAllFilesPattern "))$"
   , RegExFIMformPtrn := "i)(.\\*\.(DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f))$"
   , RegExWICfmtPtrn := "i)(.\\*\.(place-holder|webp|bmp|dib|jpg|jpeg|tif|tiff|png))$"
   , saveTypesRegEX := "i)(.\.(bmp|j2k|j2c|jp2|jxr|wdp|hdp|png|tga|tif|tiff|webp|gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|xpm))$"
   , saveTypesFriendly := ".BMP, .GIF, .HDP, .J2K, .JFIF, .JIF, .JNG, .JP2, .JPE, .JPG, .JXR, .PNG, .PPM, .TGA, .TIF, .WDP, .WEBP or .XPM"
   , saveAlphaTypesRegEX := "i)(.\.(j2k|j2c|jp2|jxr|wdp|hdp|png|tga|tif|tiff|webp))$", userJpegQuality := 90
   , openFptrn1 := "*.png;*.bmp;*.gif;*.jpg;*.tif;*.tga;*.webp;*.jpeg", prevLoadedImageIndex := 0
   , openFptrn2 := "*.dds;*.emf;*.exr;*.g3;*.hdp;*.iff;*.j2c;*.j2k;*.jbg;*.jif;*.jng;*.jp2;*.jxr;*.koa;*.lbm;*.mng;*.pbm;*.pcd;*.pct;*.pcx;*.pfm;*.pgm;*.pic;*.ppm;*.psd;*.ras;*.sgi;*.wap;*.wbm;*.wbmp;*.wdp;*.wmf;*.xbm;*.xpm"
   , openFptrn3 := "*.3fr;*.arw;*.bay;*.bmq;*.cap;*.cine;*.cr2;*.crw;*.cs1;*.dc2;*.dcr;*.drf;*.dsc;*.erf;*.fff;*.hdr;*.ia;*.iiq;*.k25;*.kc2;*.kdc;*.mdc;*.mef;*.mos;*.mrw;*.nef;*.nrw;*.orf;*.pef;*.ptx;*.pxn;*.qtk;*.raf;*.raw;*.rdc;*.rw2;*.rwz;*.sr2;*.srf;*.x3f"
   , openFptrn4 := "*.tiff;*.targa;*.jpe;*.dib;*.pict;*.rle", openFptrnWIC := "", forceLiveAlphaPreviewMode := 0
   , dialogSaveFptrn := "HD Photo (*.hdp)|JNG Jpeg (*.jng)|JPEG Common (*.jpg;*.jpeg)|JPEG 2000 (*.jp2;*.j2k)|JPEG File Interchange Format (*.jfif)|JPEG-XR (*.jxr)|Non-animated Compuserve GIF (*.gif)|Portable Network Graphics (*.png)|Portable PixelMap (*.ppm)|Tagged Image File Format (*.tif;*.tiff)|TrueVision Targa (*.tga)|WDP (*.wdp)|WebP (*.webp)|Windows Bitmap (*.bmp)|XPM (*.xpm)"
   , dialogSaveIndexes := {1:"hdp", 2:"jng", 3:"jpg", 4:"jp2", 5:"jfif", 6:"jxr", 7:"gif", 8:"png", 9:"ppm", 10:"tif", 11:"tga", 12:"wdp", 13:"webp", 14:"bmp", 15:"xpm"}
   , userPossibleWriteFMTs := ".BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM"
   , saveImgFormatsList := {1:"bmp", 2:"gif", 3:"hdp", 4:"j2k", 5:"jfif", 6:"jng", 7:"jp2", 8:"jpg", 9:"jxr", 10:"png", 11:"ppm", 12:"tga", 13:"tif", 14:"wdp", 15:"webp", 16:"xpm"}
   , LargeUIfontValue := 14, AnyWindowOpen := 0, toolTipGuiCreated := 0, panelWinCollapsed :=0, brushAclrAlpha := "ffFFff"
   , PrefsLargeFonts := 0, OSDbgrColor := "252525", OSDtextColor := "FEFDFC", initialCustomShapeCoords := ""
   , PasteFntSize := 35, OSDfontSize := 23, OSDFontName := "Arial", prevOpenFolderPath := "", brushBclrAlpha := "010101"
   , mustGenerateStaticFolders := 1, lastWinDrag := 1, img2resizePath := "", colorPickerModeNow := 0
   , prevFileMovePath := "", lastGIFdestroy := 1, prevAnimGIFwas := "", prevFilesSortMode, bruAchClrAlpha := ""
   , thumbsW := 300, thumbsH := 300, thumbsDisplaying := 0, userSeenSessionImagesArray := new hashtable()
   , othumbsW := 300, othumbsH := 300, VPselRotation := 0, hEditMenuSearch := "", prevOmniBoxFolder := ""
   , CountFilesFolderzList := 0, imgSelLargerViewPort := 0, dynamicLiveObjVisible := 1
   , UsrMustInvertFilter := 0, userActionConflictingFile := 1, LastWasFastDisplay := 0, hEditA := 0
   , prevFileSavePath := "", imgHUDbaseUnit := Round(OSDfontSize*2.5), lastLongOperationAbort := 1
   , lastOtherWinClose := 1, UsrCopyMoveOperation := 2, editingSelectionNow := 0, EntryMarkedMoveIndex := 0
   , ForceNoColorMatrix := 0, prevFastDisplay := 1, hSNDmediaDuration, lastMenuBarUpdated := 1
   , imgSelX1 := 0, imgSelY1 := 0, imgSelX2 := -1, imgSelY2 := -1, adjustNowSel := 0, hasHamDistCached := 0
   , prevImgSelX1 := 0, prevImgSelY1 := 0, prevImgSelX2 := -1, prevImgSelY2 := -1, prevSelDotX := "", prevSelDotY := "", prevSelDotAx := "", prevSelDotAy := ""
   , selDotX := "", selDotY := "", selDotAx := "", selDotAy := "", selDotBx := "", selDotBy := "", selDotCx := "", selDotCy := "", selDotDx := "", selDotDy := ""
   , prcSelX1 := 0, prcSelX2 := 0.5, prcSelY1 := 0, prcSelY2 := 0.5, pBrushF := "", lastWasLowQuality := 0
   , SelDotsSize := imgHUDbaseUnit//4, ViewPortBMPcache := "", startZeitIMGload := 0, cachedAllSessionsSeen := new hashtable()
   , imageLoading := 0, PrevGuiSizeEvent := 0, imgSelOutViewPort := 0, prevGUIresize := 1, prevLastImg := []
   , imgEditPanelOpened := 0, jpegDoCrop := 0, jpegDesiredOperation := 1, copyMoveDoLastOption := 0
   , rDesireWriteFMT := "jpg", FIMfailed2init := 0, prevMaxSelX := "", prevMaxSelY := "", prevDestPosX := "", prevDestPosY := ""
   , CCLVO := "gInvokeStandardDialogColorPicker -E0x200 +Border -Hdr -Multi +ReadOnly Report AltSubmit ", FontList := []
   , totalFramesIndex := 0, pVwinTitle := "", AprevImgCall := "", BprevImgCall := "", prevSetWinPosX := "", prevSetWinPosY := ""
   , coreIMGzeitLoad := 0, desiredFrameIndex := 0, prevDrawingMode := 0, sqlFailedInit := 0, currentImgModified := 0
   , currIMGdetails := [], AbackupIMGdetails := [], BbackupIMGdetails := [], mainLoadedIMGdetails := [], lastSelPrinterName := ""
   , diffIMGdecX := 0, diffIMGdecY := 0, oldZoomLevel := 0, fullPath2exe := "", hasMemThumbsCached := 0
   , scrollBarHy := 0, scrollBarVx := 0, HistogramBMP := "", internalColorDepth := 0, printerDevModeOptions := ""
   , drawModeBzeit := 1, drawModeAzeit := 1, drawModeCzeit := 1, prevColorAdjustZeit := 1, AutoCropBordersSize := 15
   , GDIfadeVPcache := "", executingCanceableOperation := 1, hCropCornersPic, UserMemBMP := "", userSearchString := ""
   , systemCores := 1, realSystemCores := 1, hasInitSpecialMode := 0, CountGIFframes := 0, prevSlideShowStop := 1
   , prevTryThumbsUpdate := 1, thumbsSizeQuality := 245, prevFullIndexThumbsUpdate := -1, userClipBMPpaste
   , UserNewWidth := 0, UserNewHeight := 0, UserNewDPI := 0, viewportStampBMP := "", tinyPrevAreaCoordY := 1
   , ThumbsStatusBarH := 0, activeSQLdb := "", SLDtypeLoaded := 0, sldsPattern := "i)(.\.(sld|sldb))$"
   , imgThumbsCacheIDsArray := [], imgThumbsCacheArray := [], viewportIDstampBMP := 0, qpvMainDll, sqlDBrowID := 1
   , prevVPselRotation, prevrotateSelBoundsKeepRatio, prevEllipseSelectMode, currentSelUndoLevel := 1, liveDrawingBrushTool := 0
   , seenImagesDB := "", mustRecordSeenImgs := 0, hEditField := "", gdiBMPvPsize := "", maxGDIbmpSize := 533654021
   , GDIcacheSRCfileA := "", idGDIcacheSRCfileA := "", GDIcacheSRCfileB := "", idGDIcacheSRCfileB := "", prevOpenedWindow := []
   , startLongOperation := 1, thisIMGisDownScaled := 0, simpleOpRotationAngle := 1, UserTextArea := ""
   , runningLongOperation := 0, hasReachedMaxUndoLevels := 0, GIFframesPlayied := 0, allImagesWereSeen := 0
   , 2NDglHbitmap := "", 2NDglHDC := "", 2NDglOBM := "", 2NDglPG := "", mainThreadHwnd := "", imgDecLX := "", imgDecLY := ""
   , undoLevelsArray := [], currentUndoLevel := 0, maxUndoLevels := 50, undoLevelsRecorded := 0, hGDIinfosWin := ""
   , zeitSillyPrevent := 1, PrintPosX, PrintPosY, PrintPosW, PrintPosH, tinyPrevAreaCoordX := 1, UsrEditFileDestination := ""
   , hLVmainu := 0, tempBtnVisible := "null", tempBtnGuiBtnArray := [], lastRenameUndo := [], userMultiCoresLimit := 100
   , drawingShapeNow := 0, customShapePoints := [], prevResizedVPimgW := "", prevResizedVPimgH := "", PenuDrawLive := ""
   , initialDrawingStartCoords := [], drawingVectorLiveMode := 0, cardinalCurveCustomShape := 0, openingPanelNow := 0
   , closedLineCustomShape := 1, tensionCurveCustomShape := 0.5, userDefinedSelCoords := 0, thisSearchString := ""
   , SelectionCoordsType := 1, alphaMaskRefBMP := 1, infoBoxGdiCached := "", watchFolderDetails := "", isNowFakeWinOpen := 0
   , FilteruMinRange, FilteruMaxRange, userFilterSizeProperty := 1, qpvCanvasHasInit := 0, coreDesiredPixFmt := "0xE200B"
   , FilteruDateMinRange, FilteruDateMaxRange, InternalFilterString, userFilterProperty := 1, userFindDupePresets := 1
   , HUDobjNavBoxu := [], HUDobjHistoBoxu := [], globalhFIFimg := 0, userAddedFavesCount := 0, bckpCurrentFileIndex := 0
   , maxFavesEntries := 987654, gdipLastError := 0, hasDrawnImageMap := 0, hasDrawnHistoMap := 0, lastZeitFileSelect := 1
   , isWinXP := (A_OSVersion="WIN_XP" || A_OSVersion="WIN_2003" || A_OSVersion="WIN_2000") ? 1 : 0, mustSnapLiveDrawPoints := 0
   , QPVpid := GetCurrentProcessId(), preventUndoLevels := 0, maxMemUndoLevels := 979394, delayiedHUDmsg := "", hamLowLim := 0, hamUppLim := 0
   , delayiedHUDperc := 0, delayedfunc2exec := 0, lastOSDtooltipInvoked := 1, lastTimeToggleThumbs := 1, dupesStringFilter := ""
   , CurrentPanelTab := 0, debugModa := !A_IsCompiled, createdGDIobjsArray := [], countGDIobjects := 0
   , oldCustomShapePoints := [], TVlistFolders, hfdTreeWinGui, folderTreeWinOpen := 0, VPstampBMPx := 0, VPstampBMPy := 0
   , reviewSelectedIndexes := [], toBeExcludedIndexes := [], fimMultiPage := 0, fimMultiBMP := 0, staticListViewFilteru
   , listViewReviewFilteru := "", IMGentirelylargerThanVP := 0, mustPreventMenus := 0, hQuickMenuSearchWin := 0
   , VisibleQuickMenuSearchWin := 0, userQuickMenusEdit := "", preventHUDelements := 0, OSDwinFadedBrushBGR := 0
   , gdiAmbientalTexBrush := "", GDIbrushWinBGR := "", GDIbrushHatch := "", vpImgPanningNow := 0, viewportDynamicOBJcoords := []
   , mustCaptureCloneBrush := 0, hCropCornersPic2, globalWinStates := [], userAlphaMaskBmpPainted := "", lastPaintEventID := 1
   , prevImgEditZeit := 1, hudBTNfuncu, hudBTNtypeFuncu, hudBTNheightFuncu, hudBTNwidthFuncu, TouchToolbarGUIcreated := 0
   , tlbrIconzList := [], ToolBarBtnWidth := 45, UserToolbarY := 60, UserToolbarX := 200, currentKbdBTNtlbr := 1
   , ToolbarWinW := 0, ToolbarWinH := 0, isToolbarKBDnav := 0, lastZeitIMGsaved := [], lastZeitUndoRecorded := 0
   , vpSymmetryPointX := 0, vpSymmetryPointY := 0, CustomShapeSymmetry := 0, CustomShapeLockedSymmetry := 0
   , vpSymmetryPointXdp := 0, vpSymmetryPointYdp := 0, userSeenSessionImagesIndex := 0, FloodFillSelectionAdj := 0
   , createdQuickMenuSearchWin := 0, lastUserRclickVPx := 0, lastUserRclickVPy := 0, vpFreeformShapeOffset := []
   , customShapeHasSelectedPoints := 0, currentVectorUndoLevel := 1, undoVectorShapesLevelsArray := []
   , mseUppLim := 0, mseLowLim := 0, userHamDistStringStringPos := 1, userHamDistStringFilterWhat := 1
   , thisBMPdummy := 0, dummyGu := 9, whileLoopExec := 0, WICmoduleHasInit := 0, dupesDCTcoeffsInit := 0
   , resultsDupesArray := [], hTVlistFolders := "", SearchedStringz := "", dupesPixelData := []
   , dupesHashesData := [], dbVersion := 0, dbExpectedVersion := 2, userPrevAlphaMaskBmpPainted := ""
   , clrGradientOffX := 0, clrGradientOffY := 0, userAllowClrGradientRecenter := 0, TabsPerWindow := []
   , darkWindowColor := 0x202020, darkControlColor := 0xEDedED, allowWICloader := 1, allowFIMloader := 1

Global previnnerSelectionCavityX := 0, previnnerSelectionCavityY := 0, prevNameSavedVectorShape := ""
   , postVectorWinOpen := 0, isWelcomeScreenu := 0, prevVectorShapeSymmetryMode := [], AllowDarkModeForWindow := ""
   , iduStaticFoldersListCache := 0, lastFilterEditSearch := "", additionalLVrows := 1, uLVr := 12
   , omniBoxMode := 0, hLVquickSearchMenus := "", hotkate, vk_hwnd, lastInfoBoxBMP := []
   , userFriendlyPrevImgSelAction, keywordsListArray := new hashtable(), keywrdLVfilter, wasVPfxBefore := 0
   , lastLclickX, lastLclickY, lastTlbrClicked := 0, uiLVoffset := 0, repositionedWindow := 0
   , selDotMaX, selDotMaY, selDotMbX, selDotMbY, selDotMcX, selDotMcY, selDotMdX, selDotMdY
   , lastInfoBoxZeitToggle := 1, prevHistoBoxString := "", menuHotkeys, whichMainDLL
   , QPVregEntry := "HKEY_CURRENT_USER\SOFTWARE\Quick Picto Viewer"
   , appVersion := "5.7.4", vReleaseDate := "23/06/2022"

 ; User settings
   , askDeleteFiles := 1, enableThumbsCaching := 1, OnConvertKeepOriginals := 1, usrAutoCropGenerateSelection := 0
   , thumbsAratio := 3, thumbsZoomLevel := 1, zatAdjust := 0, lummyAdjust := 0, doSlidesTransitions := 0
   , specialColorFXmode := 1, uiColorCurveFXmode := 2, uiColorCurveFXchannel := 4, FloodFillTolerance := 0
   , WindowBgrColor := "141414", slideShowDelay := 3000, userMultiDelChoice := 2, ambiTexBrushSize := 150
   , IMGresizingMode := 1, SlideHowMode := 1, TouchScreenMode := 1, screenSaverMode := 0, userSearchPos := 1
   , lumosAdjust := 1, GammosAdjust := 0, userimgQuality := 0, imgFxMode := 1, FlipImgH := 0, FlipImgV := 0
   , filesFilter := "", isAlwaysOnTop := 0, IntensityAlphaChannel := 1, zoomLevel := 1
   , skipDeadFiles := 0, userHQraw  := 0, isTitleBarVisible := 1, lumosGrayAdjust := 0, imageAligned := 5
   , MustLoadSLDprefs := 0, animGIFsSupport := 1, move2recycler := 1, deleteFileActAfter := 1
   , SLDcacheFilesList := 1, autoRemDeadEntry := 0, ResizeWithCrop := 1, ResizeMustPerform := 1
   , easySlideStoppage := 1, ResizeInPercentage := 0, usrAdaptiveThreshold := 1, autoPlaySlidesAudio := 0
   , ResizeKeepAratio := 1, ResizeQualityHigh := 1, ResizeRotationUser := "Rotate: 0°", satAdjust := 1
   , ResizeApplyEffects := 1, autoAdjustMode := 1, doSatAdjusts := 1, SimpleOperationsScaleXImgFactor := "100 %"
   , ResizeDestFolder, ResizeUseDestDir := 0, chnRdecalage := 0.0, chnGdecalage := 0.0
   , chnBdecalage := 0.0, alwaysOpenwithFIM := 0, bwDithering := 0, showHistogram := 0,  FloodFillModus := 0
   , userUnsprtWriteFMT := 1, userDesireWriteFMT := 9, hueAdjust := 0, syncSlideShow2Audios := 0
   , DisplayTimeUser := 3, OSDfontBolded := 1, OSDfontItalica := 0, showInfoBoxHUD := 0, usrAutoCropDeviation := 0
   , usrTextureBGR := 0, realGammos := 1, imgThreshold := 0, relativeImgSelCoords := 1, hCurrTab := ""
   , vpIMGrotation := 0, usrTextAlign := "Left", autoPlaySNDs := 0, usrAutoCropDeviationSnap := 1
   , ResizeCropAfterRotation := 1, usrColorDepth := 1, ColorDepthDithering := 1, mediaSNDvolume := 80
   , borderAroundImage := 0, performAutoCropNow := 0, usrAutoCropColorTolerance := 5, usrAutoCropImgThreshold := 0.005 
   , SimpleOperationsDoCrop := 0, SimpleOperationsRotateAngle := 1, SimpleOperationsScaleYImgFactor := "100 %"
   , SimpleOperationsNoPromptOnSave := 0, SimpleOperationsFlipV := 0, SimpleOperationsFlipH := 0
   , usrAutoCropDeviationPixels := 0, multilineStatusBar := 0, AutoCropAdaptiveMode := 1, allowGIFsPlayEntirely := 0
   , allowMultiCoreMode := 0, AutoDownScaleIMGs := 0, minimizeMemUsage := 0, GIFspeedDelay := 35
   , maxMemThumbsCache := 300, resetImageViewOnChange := 0, FillAreaRemBGR := 0, blurAreaPixelizeMethod := 1
   , EraseAreaFader := 0, EraseAreaOpacity := 190, blurAreaOpacity := 250, blurAreaAmount := 10
   , FillAreaOpacity := 250, FillAreaColor := OSDbgrColor, FillAreaShape := 1, FillAreaInverted := 0
   , PasteInPlaceAlignment := 3, PasteInPlaceOpacity := 255, PasteInPlaceAdaptMode := 1, PasteInPlaceQuality := 1
   , PasteInPlaceOrientation := 1, showImgAnnotations := 0, blurAreaSoftEdges := 1, blurAreaInverted := 0
   , PasteInPlaceBlurAmount := 0, PasteInPlaceCropSel := 1, PasteInPlaceCropAngular := 0, globalMenuOptions := 0

Global PasteInPlaceGamma := 0, PasteInPlaceSaturation := 0, PasteInPlaceHue := 0, PasteInPlaceLight := 0
   , EllipseSelectMode := 0, thumbsListViewMode := 1, userimgGammaCorrect := 0, FillAreaGradientAngle := 0
   , adjustCanvasCentered := 1, adjustCanvasMode := 1, adjustCanvasNoBgr := 1, LimitSelectBoundsImg := 1, FillAreaDoContour := 0
   , DrawLineAreaColor := "ff3366", DrawLineAreaDashStyle := 1, DrawLineAreaContourAlign := 1, DrawLineAreaKeepBounds := 1
   , DrawLineAreaContourThickness := 20, DrawLineAreaOpacity := 255, DrawLineAreaBorderTop := 1, DrawLineAreaBorderBottom := 0
   , DrawLineAreaBorderLeft := 1, DrawLineAreaBorderRight := 0, DrawLineAreaBorderCenter := 1, DrawLineAreaBorderArcA := 0
   , DrawLineAreaBorderArcC := 0, DrawLineAreaBorderArcD := 1, DrawLineAreaCapsStyle := 1, DrawLineAreaDoubles := 0
   , PasteInPlaceEraseInitial := 1, doImgEditLivePreview := 1, DrawLineAreaBorderArcB := 0, EraseAreaInvert := 0
   , PasteInPlaceToolMode := 0, NewDocUseColor := 1, PredefinedDocsSizes := 1, NewImageReverseDimensions := 0, FillAreaGlassy := 1
   , FillAreaColorMode := 1, FillAreaColorReversed := 0, FillArea2ndColor := "FF2211", FillArea2ndOpacity := 200
   , FillAreaGradientPosA := 5, FillAreaGradientPosB := 100, FillAreaGradientScale := 100, FillAreaGradientWrapped := 1
   , TextInAreaFontName := "Arial", TextInAreaFontSize := 15, TextInAreaBorderSize := 5, GammosGrayAdjust := 0
   , TextInAreaFontBold := 0, TextInAreaFontItalic := 0, TextInAreaFontUline := 0, TextInAreaAlign := 1, TextInAreaBgrUnified := 0
   , TextInAreaFontColor := "eeFFaa", TextInAreaFontOpacity := 250, TextInAreaRoundBoxBgr := 1, TextInAreaValign := 1
   , TextInAreaBgrColor := "229933", TextInAreaBgrOpacity := 100, TextInAreaOnlyBorder := 0, TextInAreaBlurAmount := 0
   , TextInAreaBorderOut := 1, TextInAreaBorderColor := "334400", TextInAreaBorderOpacity := 200, TextInAreaCharSpacing := 0
   , TextInAreaUsrMarginz := 0, TextInAreaBlurBorderAmount := 0, TextInAreaDoBlurs := 0, TextInAreaLineAngle := 0
   , TextInAreaFontLineSpacing := 0, TextInAreaCutOutMode := 0, TextInAreaBgrEntire := 0, TextInAreaFontStrike := 0
   , showMainMenuBar := 1, markSearchMatches := 1, showSelectionGrid := 0, blurAreaTwice := 0, TextInAreaFlipV := 0
   , allowRecordHistory := 1, TextInAreaPaintBgr := 1, rotateSelBoundsKeepRatio := 1, TextInAreaFlipH := 0
   , highlightAlreadySeenImages := 1, useCachedSLDdata := 1, PreserveDateTimeOnSave := 0, PrintAdaptToFit := 1
   , PrintDimensionsXYWH := "0|0|50|50", PrintColorMode := 0, PrintOrientation := 0, PrintUseViewportColors := 1
   , userAllowWindowDrag := 0, FillAreaClosedPath := 1, FillAreaCustomShape := "", alphaMaskingMode := 1
   , alphaMaskClrAintensity := 0, alphaMaskClrBintensity := 255, closeEditPanelOnApply := 1, FillAreaCurveTension := 2
   , alphaMaskOffsetX := 0, alphaMaskOffsetY := 0, alphaMaskReplaceMode := 0, alphaMaskBMPchannel := 5
   , blurAreaMode := 1, FillAreaBlendMode := 1, PasteInPlaceApplyColorFX := 0, blurAreaPixelizeAmount := 0
   , dynamicThumbsColumns := 0, thumbsColumns := 8, TextInAreaAutoWrap := 1, histogramMode := 2, cmrRAWtoneMapParamB := 0
   , showHUDnavIMG := 0, HUDnavBoxSize := 75, PrintTxtSize := 300, cmrRAWtoneMapAlgo := 1, cmrRAWtoneMapParamA := 1.85
   , mainWinPos := 0, mainWinMaximized := 2, mainWinSize := 0, UserExternalApp := "", UserExternalEditApp := ""
   , lockSelectionAspectRatio := 1, desiredSelAspectRatio := 0, adjustingSelDotNow := 0, cycleFavesOpenIMG := 0
   , slidesFXrandomize := 0, IDedgesCenterAmount := 1, IDedgesXuAmount := 2, IDedgesYuAmount := 1, IDedgesInvert := 0
   , IDedgesEmphasis := 0, IDedgesContrast := 0, IDedgesBlendMode := 0, IDedgesOpacity := 255, IDedgesAfterBlur := 1
   , IDedgesEmbossLvl := 1, UserAddNoiseIntensity := 35, UserAddNoiseMode := 0, reverseOrderOnSort := 0
   , userSearchWhat := 1, OnSortdoFilesCheck := 0, QuickFileActFolder1 := "", QuickFileActFolder2 := ""
   , QuickFileActFolder3 := "", QuickFileActFolder4 := "", QuickFileActFolder5 := "", QuickFileActAfter1 := 1
   , QuickFileActAfter2 := 1, QuickFileActAfter3 := 1, QuickFileActAfter4 := 1, QuickFileActAfter5 := 1
   , QuickFileActAfter6 := 1, QuickFileActFolder6 := "", userFilterWhat := 1, userFilterStringPos := 1
   , userFilterStringIsNot := 0, userFilterDoString := 1, UsrEditFilter, QuickFileActConflict := 4
   , preventDBentryRemoval := 0, findDupesPrecision := 5, DesatureAreaAmount := 100, PrintPaperOrient := 1
   , DesatureAreaHue := 0, DesatureAreaAlternate := 0, skipSeenImageSlides := 0, blurAreaSoftLevel := 2
   , BlurAreaBlendMode := 1, PasteInPlaceBlurEdgesSoft := 0, preventDeleteMatchingSearch := 0
   , protectedFolderPath := "", preventDeleteFromProtectedPath := 0, preventDeleteFromProtectedSubPaths := 0
   , excludePreviousDupesFromList := 0, userFindDupesHamDistLvl := 1, userFindDupesFilterHamDist := 1
   , userFilterInvertThis := 0, UserHamDistStringFilter := "", UserHamDistCacheFilterMonoGroups := 1
   , UserHamDistStringInvert := 0, lockZoomLevel := 0, showViewPortGrid := 0, vpGridColor := "998899"
   , vpGridAlpha := 150, vpGridThickness := 1, vpGridSize := 35, vpGridStepu := 4, vpGridFixedSize := 0
   , PasteInPlaceAutoExpandIMG := 0, SlidesMusicSong := "", PrintStrechedSize := 0, brushToolSize := 50
   , BrushToolAopacity := 200, BrushToolBopacity := 120, BrushToolAcolor := "ff9900", BrushToolBcolor := "3399FF"
   , BrushToolSoftness := 60, BrushToolWetness := 0, BrushToolDryingRate := 0, BrushToolType := 1
   , BrushToolUseSecondaryColor := 0, BrushToolAspectRatio := 0, BrushToolAngle := 0, BrushToolOutsideSelection := 1
   , BrushToolBlurStrength := 0, brushToolStepping := 0, brushToolDoubleSize := 0, BrushToolOverDraw := 1
   , BrushToolDynamicCloner := 0, BrushToolEraserRestore := 0, BrushToolRandomSize := 0, BrushToolRandomSoftness := 0
   , BrushToolRandomAspectRatio := 0, BrushToolRandomAngle := 0, BrushToolRandomPosX := 0, BrushToolRandomPosY := 0
   , BrushToolRandomHue := 0, BrushToolRandomSat := 0, BrushToolRandomLight := 0, BrushToolRandomDark := 0 
   , BrushToolTexture := 1, BrushToolAutoAngle := 1, ShowAdvToolbar := 1, ToolbarOpacity := 255, findFlippedDupes := 0
   , BrushToolSymmetryX := 0, BrushToolSymmetryY := 0, BrushToolSymmetryPointX := 0.5, BrushToolSymmetryPointY := 0.5
   , BrushToolApplyColorFX := 0, PasteInPlaceBlendMode := 1, PasteInPlaceGlassy := 1, ToolbarScaleFactor := 1
   , ToolbarBgrColor := "212121", TLBRverticalAlign := 1, TLBRtwoColumns := 1, FillAreaApplyColorFX := 0
   , UserGIFsDelayu := 30, FloodFillCartoonMode := 0, FloodFillDynamicOpacity := 0, FloodFillAltToler := 1
   , FloodFillEightWays := 0, maxVectorUndoLevels := 30, showNewVectorPointPreview := 1, hamDistInterpolation := 0
   , allowUserQuickFileActions := 0, userAllowsGradientRecentering := 0, TextInAreaCaseTransform := 1
   , customZoomAdaptMode := 0, allowFreeIMGpanning := 0, lockToolbar2Win := 1, showFilesListMap := 0
   , showFolderTreeDetails := 0, userSaveBitsDepth := 1, uiUseDarkMode := 0, uiPreferedFileStats := 1
   , hamDistLBorderCrop := 0, hamDistRBorderCrop := 0, userpHashMode := 0, graylevelCompressor := 1
   , findInvertedDupes := 0, PerformMSDonDupes := 0, userFindDupesMSElvl := 50, FloodFillColor := "aa0099"
   , dupesApplyBlur := 0, BreakDupesGroups := 0, fadeOtherDupeGroups := 1, TextInAreaFillSelArea := 0
   , keepUserPaintAlphaMask := 0, alphaMaskColorReversed := 0, alphaMaskGradientScale := 100
   , alphaMaskGradientPosA := 0, alphaMaskGradientPosB := 100, alphaMaskGradientWrapped := 0
   , FillBehindClrOpacity  := 200, FillBehindOpacity := 255, FillBehindColor := "ff4400"
   , alphaMaskGradientAngle := 0, DesaturateAreaChannel := 1, FloodFillClrOpacity := 255
   , FloodFillOpacity := 205, FloodFillBlendMode := 1, TextInAreaBlendMode := 1, BlurAreaAlphaMask := 0
   , UserAddNoiseBlurAmount := 0, UserAddNoIsePixelizeAmount := 2, FillBehindInvert := 0
   , alphaMaskPreviewOpacity := 255, FloodFillUseAlpha := 0, EraseAreaUseAlpha := 0, bezierSplineCustomShape := 0
   , innerSelectionCavityX := 0, innerSelectionCavityY := 0, ResizeEnforceCanvas := 0
   , ResizeFillCanvasMode := 1, ShowToolTipsToolbar := 1, userPrivateMode := 0, thresholdKeywords := 1
   , minKeywordLength := 2, LangKeywordsFilter := 0, mergeKeywordRows := 1, limitSearchReplaceSelected := 0
   , autoReflectVectorAnchors := 0, shearImgX := 0, shearImgY := 0, zoomBlurAreaYamount := 1
   , zoomBlurAreaXamount := 1, zoomBlurMode := 1, DesaturateAreaLevels := 1, DesaturateAreaDither := 0
   , BlurAreaHue := 0, BlurAreaSaturation := 0, BlurAreaLight := 0, BlurAreaGamma := 0

EnvGet, realSystemCores, NUMBER_OF_PROCESSORS
addJournalEntry("Application started: PID " QPVpid ".`nCPU cores identified: " realSystemCores ".")

If (realSystemCores>8)
   realSystemCores := 8

RegRead, InitCheckReg, %QPVregEntry%, Running
RegRead, InitTimeReg, %QPVregEntry%, LastStartTime
If (Abs(A_TickCount - InitTimeReg)<600 && IsNumber(InitTimeReg) && InitCheckReg=1 && InitTimeReg>1)
{
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}

If !A_IsCompiled
   Try Menu, Tray, Icon, qpv-icon.ico

OnExit, doCleanup
initCompiled(A_IsCompiled)
thisGDIPversion := Gdip_LibrarySubVersion()
GDIPToken := Gdip_Startup()
If (!GDIPToken || thisGDIPversion<1.92)
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+...`n`nThe program will now exit.`n`nRequired GDI+ library wrapper: v1.92 - extended compilation edition.
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}

; RegRead, initArgu, %QPVregEntry%, initArgu
If (InitCheckReg=2)
{
   initExternalCoreMode()
   Return
}

RegWrite, REG_SZ, %QPVregEntry%, Running, 1
RegWrite, REG_SZ, %QPVregEntry%, LastStartTime, % A_TickCount
IniRead, FirstRun, % mainSettingsFile, General, FirstRun, @
If (FirstRun!=0)
{
   realSystemCores := systemCores := 2
   writeMainSettingsApp()
   FirstRun := 0
   IniWrite, % FirstRun, % mainSettingsFile, General, FirstRun
} Else readMainSettingsApp(0)

OnMessage(0x201, "WM_LBUTTONdown")
OnMessage(0x202, "WM_LBUTTONup")
OnMessage(0x200, "WM_MOUSEMOVE")
OnMessage(0x203, "OnLButtonDblClk")
OnMessage(0x20A, "adjustWheelNumbersEditFields") ; WM_MOUSEWHEEL
; Loop, 9
;     OnMessage(255+A_Index, "PreventKeyPressBeep")   ; 0x100 to 0x108
OnMessage(0x100, "WM_KEYDOWN")
OnMessage(0x104, "WM_KEYDOWN")

Global interfaceThread
If !A_IsCompiled
   interfaceThread := ahkthread("#Include *i Lib\module-interface.ahk")
Else If (sz := GetRes(data, 0, "MODULE-INTERFACE.AHK", "LIB"))
   interfaceThread := ahkThread(StrGet(&data, sz, "utf-8"))

; the interface is a separate thread to allow users 
; enjoy a more responsive user interface when the main thread
; is busy processing
externObj := WindowBgrColor "$" isAlwaysOnTop "$" mainCompiledPath "$" isTitleBarVisible "$" TouchScreenMode "$" userAllowWindowDrag "$" mainWinPos "$" mainWinSize "$" mainWinMaximized "$" IMGresizingMode
externObj .= "$" OSDbgrColor "$" OSDtextColor "$" OSDfontSize "$" PrefsLargeFonts "$" OSDFontName "$" OSDfontBolded
initGUI := interfaceThread.ahkFunction("BuildGUI", externObj)
fnOutputDebug("extern UI HWNDs: " initGUI)
If !InStr(initGUI, "|")
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize the interface. The application will now exit...
   hasInitSpecialMode := 1
   ForceExitNow()
   Return
} Else
{
   handleUIhwnd(initGui)
   externObj := ""
}

createGDIPcanvas()
InitGDIpStuff()

Global multiCoreThumbsInitGood := "n", thumbThread1,thumbThread2,thumbThread3,thumbThread4
,thumbThread5,thumbThread6,thumbThread7,thumbThread8,thumbThread9,thumbThread10

If (A_PtrSize=4)
{
   allowMultiCoreMode := 0
   minimizeMemUsage := 1
   maxUndoLevels := 2
   coreDesiredPixFmt := "0x21808"
}

; OnMessage(0x205, "WM_RBUTTONUP")
TriggerMenuBarUpdate()
addJournalEntry("Finished initialization of " appTitle " v" appVersion ".")
If (qpvCanvasHasInit=1)
   doWelcomeNow := initializeAppWithGivenArguments()

; MsgBox, % A_TickCount - scriptStartTime
If (doWelcomeNow=1 && qpvCanvasHasInit=1)
{
   drawWelcomeImg()
   interfaceThread.ahkPostFunction("uiAccessWelcomeView")
}

If (A_Is64bitOS=1 && A_PtrSize!=8)
   SetTimer, giveWarningX64, -500

If (uiUseDarkMode=1)
{
   setMenusTheme(uiUseDarkMode)
   setDarkWinAttribs(PVhwnd, uiUseDarkMode)
}

SetTimer, createGUItoolbar, -100
; initQPVmainDLL()
; createDummyTestGui()
Return

;_____________________________________ Hotkeys _________________
; the hotkeys are registered since v5.4.5 in
; interfaceThread / module-interface.ahk

identifyThisWin() {
  Static prevR, lastInvoked := 1
  If (A_TickCount - lastInvoked < 50)
     Return prevR

  Az := WinActive("A")
  prevR := (Az=PVhwnd || Az=hGDIwin || Az=hGDIthumbsWin || Az=hGDIinfosWin || Az=hGDIselectWin) ? 1 : 0
  lastInvoked := A_TickCount
  Return prevR
}

HKifs(q:=0, whichWin:=-1) {
   whichBitmap := (useGdiBitmap() && resultedFilesList[currentFileIndex, 1]) ? 1 : 0
   If (q="imgEditSolo")
      r := (!AnyWindowOpen && openingPanelNow!=1 && !CurrentSLD && whichBitmap=1 && thumbsDisplaying!=1) ? 1 : 0
   Else If (q="imgsLoaded")
      r := (!AnyWindowOpen && openingPanelNow!=1 && CurrentSLD && maxFilesIndex>0) ? 1 : 0
   Else If (q="liveEdit")
      r := (AnyWindowOpen && openingPanelNow!=1 && imgEditPanelOpened=1 && whichBitmap=1 && thumbsDisplaying!=1) ? 1 : 0
   Else If (q="general")
      r := (!AnyWindowOpen && imgEditPanelOpened!=1) ? 1 : 0

   If (drawingShapeNow=1 || whileLoopExec=1 || whichWin=AnyWindowOpen)
      r := 0

   Return r
}

constructKbdKey(vk_shift, vk_ctrl, vk_alt, vk_code) {
   Static vkList := {8:"BACKSPACE", 9:"TAB", C:"NUMPADCLEAR", D:"ENTER", 14:"CAPSLOCK", 1B:"ESCAPE", 20:"SPACE", 21:"PGUP", 22:"PGDN", 23:"END", 24:"HOME", 25:"LEFT", 26:"UP", 27:"RIGHT", 28:"DOWN", 2D:"INSERT", 2E:"DELETE", 5B:"SCROLLLOCK", 5D:"APPSKEY", 60:"NUMPAD0", 61:"NUMPAD1", 62:"NUMPAD2", 63:"NUMPAD3", 64:"NUMPAD4", 65:"NUMPAD5", 66:"NUMPAD6", 67:"NUMPAD7", 68:"NUMPAD8", 69:"NUMPAD9", 6A:"NUMPADMULT", 6B:"NUMPADADD", 6D:"NUMPADSUB", 6E:"NUMPADDOT", 6F:"NUMPADDIV", 70:"F1", 71:"F2", 72:"F3", 73:"F4", 74:"F5", 75:"F6", 76:"F7", 77:"F8", 78:"F9", 79:"F10", 7A:"F11", 7B:"F12", 90:"NUMLOCK", AD:"VOLUME_MUTE", AE:"VOLUME_DOWN", AF:"VOLUME_UP", B0:"MEDIA_NEXT", B1:"MEDIA_PREV", B2:"MEDIA_STOP", B3:"MEDIA_PLAY_PAUSE", FF:"PAUSE", 1:"LBUTTON", 2:"RBUTTON", 3:"BREAK", 4:"MBUTTON", 5:"XBUTTON1", 6:"XBUTTON2", 10:"SHIFT", 11:"CONTROL", 12:"ALT", 13:"PAUSE", 15:"KANA/HANGUL", 17:"JUNJA", 18:"IME_FINAL", 19:"HANJA/KANJI", 16:"IME_ON", 1A:"IME_OFF", 1C:"IME_CONVERT", 1D:"IME_NON_CONVERT", E5:"IME_PROCESSKEY", 1E:"IME_ACCEPT", 1F:"IME_MODECHANGE", 2F:"HELP", 29:"SELECT", 2A:"PRINT", 2B:"EXECUTE", 2C:"PRINT_SCREEN", 5F:"SLEEP", 7C:"F13", 7D:"F14", 7E:"F15", 7F:"F16", 80:"F17", 81:"F18", 82:"F19", 83:"F20", 84:"F21", 85:"F22", 86:"F23", 87:"F24", A6:"BROWSER_BACK", A7:"BROWSER_FORWARD", A8:"BROWSER_REFRESH", A9:"BROWSER_STOP", AA:"BROWSER_SEARCH", AB:"BROWSER_FAVORITES", AC:"BROWSER_HOME", B4:"LAUNCH_MAIL", B5:"LAUNCH_MEDIA_SELECT", B6:"LAUNCH_APP1", B7:"LAUNCH_APP2", F6:"ATTN", F7:"CrSEL", F8:"ExSEL", F9:"ERASE_EOF", FA:"PLAY", FB:"ZOOM", FD:"PA1", A0:"LSHIFT", A1:"RSHIFT", A2:"LCTRL", A3:"RCTRL", A4:"LALT", A5:"RALT", 5B:"LWIN", 5C:"RWIN"}
        , vkExtraList := {30:"00.1", 31:"1", 32:"2", 33:"3", 34:"4", 35:"5", 36:"6", 37:"7", 38:"8", 39:"9", 41:"A", 42:"B", 43:"C", 44:"D", 45:"E", 46:"F", 47:"G", 48:"H", 49:"I", 4A:"J", 4B:"K", 4C:"L", 4D:"M", 4E:"N", 4F:"O", 50:"P", 51:"Q", 52:"R", 53:"S", 54:"T", 55:"U", 56:"V", 57:"W", 58:"X", 59:"Y", 5A:"Z", BB:"PLUS", BC:"COMMA", BD:"MINUS", BE:"PERIOD"}
        ; , BA:"OEM_1", BF:"OEM_2", C0:"OEM_3", DB:"OEM_4", DC:"OEM_5", DD:"OEM_6", DE:"OEM_7", DF:"OEM_8", E2:"OEM_102", E1:"OEM_9", E3:"OEM_11", E4:"OEM_12", E6:"OEM_13", FE:"OEM_CLEAR", 92:"OEM_14", 93:"OEM_15", 94:"OEM_16", 95:"OEM_17", 96:"OEM_18"}
   ; vk list based on https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes

   newkate := ""
   If vk_shift
      newkate .= "+"
   If vk_ctrl
      newkate .= "^"
   If vk_alt
      newkate .= "!"

   If (vkExtraList[vk_code]!="")
      newkate .= vkExtraList[vk_code]
   Else
      newkate .= vkList[vk_code] ? vkList[vk_code] : "vk" vk_code
   Return newkate
}

PreProcessKbdKey() {
   Static lastInvoked := 1, counter := 0, prevKey

   Awin := WinActive("A")
   If (A_TickCount - lastOtherWinClose<300) || (Awin=PVhwnd) || (Awin!=vk_hwnd)
   {
      lastInvoked := 1, counter := 0, prevKey := 0
      Return
   }

   ; ToolTip, % hotkate , , , 2
   If (A_TickCount - lastInvoked>250)
      counter := 0

   ; addJournalEntry(A_ThisFunc "(): " thisWin "|" hotkate)
   If (A_TickCount - lastInvoked>30) && (whileLoopExec=0 && runningLongOperation=0)
   {
      lastInvoked := A_TickCount
      abusive := (counter>25) ? 1 : 0
      thisHwnd := identifyParentWind() ? "parentu" : Awin
      KeyboardResponder(hotkate, thisHwnd, abusive)
      If (hotkate=prevKey)
         counter++
      Else 
         counter := 0

      prevKey := hotkate
   } Else If (hotkate=prevKey)
      counter++
   Else 
      counter := 0
}

decideBlockKbdKeys(Az, givenKey) {
   blockKey := 0
   If (Az=hQPVtoolbar)
   {
      blockKey := 1
   } Else If (givenKey="^a" && Az=hSetWinGui && (AnyWindowOpen=2 || AnyWindowOpen=60))
   {
      GuiControlGet, OutputVar, SettingsGUIA: Focus
      If InStr(OutputVar, "ListView")
         blockKey := 1
   } Else If (Az=hQuickMenuSearchWin && VisibleQuickMenuSearchWin=1 && givenKey!="Tab")
   {
      GuiControlGet, OutputVar, QuickMenuSearchGUIA: Focus
      If (InStr(OutputVar, "edit") && (givenKey="Up" || givenKey="Down"))
      || (isVarEqualTo(givenKey, "^Up", "!Up", "!Left", "!BackSpace", "^x", "^c") && omniBoxMode=1)
         blockKey := 1

   } Else If (Az=hSetWinGui && isVarEqualTo(givenKey, "Up", "Down"))
   {
      GuiControlGet, OutputVname, SettingsGUIA: FocusV
      GuiControlGet, hVar, SettingsGUIA: hwnd, % OutputVname
      WinGetClass, pClass, ahk_id %hVar%
      isOkay := (SubStr(OutputVname, 1, 5)!="editF" && StrLen(OutputVname)>1 && !InStr(pClass, "_updown") && !InStr(pClass, "ComboBox")) ? 1 : 0
      If isOkay
      {
         GuiControlGet, OutputVar, SettingsGUIA: Focus
         GuiControlGet, OutputVal, SettingsGUIA:, % OutputVname
         GuiControlGet, OutputEnable, SettingsGUIA: Enabled, % OutputVname
         If (isNumber(OutputVal) && InStr(OutputVar, "edit") && OutputEnable=1)
            blockKey := 1
      }
   } Else If (givenKey="^F4")
   {
      If (imgEditPanelOpened=1 || AnyWindowOpen>0) && (Az=hSetWinGui) && (A_TickCount - lastOtherWinClose>150)
         BtnCloseWindow()
   } Else If (givenKey="AppsKey") || (givenKey="Enter" && (A_TickCount - lastOtherWinClose>300))
   {
      If (imgEditPanelOpened=1 || AnyWindowOpen>0) && (Az=hSetWinGui)
         blockKey := externalinvokedSettingsContextMenu(givenKey, 1)
   }
   Return blockKey
}

WM_KEYDOWN(wParam, lParam, msg, ctrlHwnd) {
    vk_code := Format("{1:x}", wParam)
    Awin := WinActive("A")
    If (whileLoopExec=1 || runningLongOperation=1) && (vk_code!="1B") 
    || (A_TickCount - lastOtherWinClose<300) || (Awin=PVhwnd)
       Return 0

    vk_shift := DllCall("GetKeyState","Int", 0x10, "short") >> 16
    vk_ctrl := DllCall("GetKeyState","Int", 0x11, "short") >> 16
    vk_alt := (msg=260) ? -1 : DllCall("GetKeyState","Int", 0x12, "short") >> 16
    hotkate := constructKbdKey(vk_shift, vk_ctrl, vk_alt, vk_code)
    vk_hwnd := Awin

    If (vk_code!=10 && vk_code!=11 && vk_code!=12)
    {
       SetTimer, PreProcessKbdKey, -25
       If decideBlockKbdKeys(Awin, hotkate)
          Return 0
    }

    ; TulTip(0, "|   ", wParam, vk_shift, vk_ctrl, vk_alt, msg, "main thread", lParam>>16 & 0xffff)
}

KeyboardResponder(givenKey, thisWin, abusive) {
   ; SoundBeep 
   Az := WinActive("A")
   ; addJournalEntry(A_ThisFunc "(): " az "=" thisWin "|" givenKey)
   If (VisibleQuickMenuSearchWin && Az!=hQuickMenuSearchWin && omniBoxMode=0)
   {
      lastTimeToggleThumbs := A_TickCount 
      closeQuickSearch()
      Return
   } Else If (imgEditPanelOpened=1 && panelWinCollapsed=1 && Az=hSetWinGui)
   {
      If (mustCaptureCloneBrush!=1 && colorPickerModeNow!=1) || (givenKey="Escape") 
         toggleImgEditPanelWindow()
      Return
   }

   If (thisWin="parentu")
   {
      If (givenKey="^a" && Az=hSetWinGui && (AnyWindowOpen=2 || AnyWindowOpen=60))
      {
         GuiControlGet, OutputVar, SettingsGUIA: Focus
         If InStr(OutputVar, "ListView")
            BTNreviewLVselAll()
      } Else If (Az=hQuickMenuSearchWin && VisibleQuickMenuSearchWin=1 && givenKey!="Tab")
      {
         GuiControlGet, OutputVar, QuickMenuSearchGUIA: Focus
         If (InStr(OutputVar, "edit") && (givenKey="Up" || givenKey="Down"))
         {
            changeOptionQuickSearch(givenKey)
            SetTimer, highlightActiveArrowsCtrl, -50
         } Else If (InStr(OutputVar, "edit") && (givenKey="home" || givenKey="end"))
         {
            Static lastSilly :=1
            lastSilly := !lastSilly
            If lastSilly
               highlightActiveCtrl()
            Else
               highlightActiveArrowsCtrl()
         } Else If (InStr(OutputVar, "edit") && omniBoxMode=1)
         {
            If (givenKey="F2")
               omniBoxFolderRename()
            Else If (givenKey="F3")
               omniBoxFolderImport()
            Else If (givenKey="F5")
               SetTimer, PopulateQuickMenuSearch, -150
            Else If (givenKey="F7")
               omniBoxFolderCreateNew()
            Else If (givenKey="F8")
               omniBoxFolderDelete()
            Else If (givenKey="F12")
               omniBoxFolderProperties()
         } Else If (InStr(OutputVar, "edit") && givenKey="F1")
         {
            btnHelpQuickSearchMenus()
         } Else If (InStr(OutputVar, "edit") && givenKey="F8")
         {
            closeQuickSearch()
            SetTimer, openPreviousPanel, -200
         }

         If (isVarEqualTo(givenKey, "^Up", "!Up", "!Left", "!BackSpace") && omniBoxMode=1)
         {
            GoQuickSearchAction(0, "yes", "!OmniNavigateUpFolder")
            highlightActiveArrowsCtrl()
         }
   
         If (omniBoxMode=1 && givenKey="^x")
            omniBoxFolderCutCopy("cut")
         Else If (omniBoxMode=1 && givenKey="^c")
            omniBoxFolderCutCopy("copy")
      } Else If (givenKey="Tab" || givenKey="+Tab")
      {
         SetTimer, highlightActiveCtrl, -50
      } Else If isVarEqualTo(givenKey, "Up", "Down", "Left", "Right")
      {
         GuiControlGet, OutputVar, SettingsGUIA: Focus
         If (Az=hSetWinGui && (givenKey="Up" || givenKey="Down"))
         {
            GuiControlGet, OutputVname, SettingsGUIA: FocusV
            GuiControlGet, hVar, SettingsGUIA: hwnd, % OutputVname
            WinGetClass, pClass, ahk_id %hVar%
            isOkay := (SubStr(OutputVname, 1, 5)!="editF" && StrLen(OutputVname)>1 && !InStr(pClass, "_updown") && !InStr(pClass, "ComboBox")) ? 1 : 0
            ; ToolTip, % isOkay "==" pClass , , , 2
            If isOkay
            {
               GuiControlGet, OutputVar, SettingsGUIA: Focus
               GuiControlGet, OutputVal, SettingsGUIA:, % OutputVname
               GuiControlGet, OutputEnable, SettingsGUIA: Enabled, % OutputVname
               If (isNumber(OutputVal) && InStr(OutputVar, "edit") && OutputEnable=1)
                  GuiControl, SettingsGUIA:, % OutputVname, % (givenKey="Up") ? OutputVal + 1 : OutputVal - 1
            }
         }
         SetTimer, highlightActiveArrowsCtrl, -50
      } Else If (givenKey="^F4")
      {
         If (imgEditPanelOpened=1 || AnyWindowOpen>0) && (Az=hSetWinGui) && (A_TickCount - lastOtherWinClose>150)
            BtnCloseWindow()
      } Else If (givenKey="AppsKey" || givenKey="Enter" && (A_TickCount - lastOtherWinClose>300))
      {
         If (imgEditPanelOpened=1 || AnyWindowOpen>0) && (Az=hSetWinGui)
            externalinvokedSettingsContextMenu(givenKey)
      } Else If (givenKey="F8" || givenKey="F11")
      {
         If (imgEditPanelOpened=1 || AnyWindowOpen>0) && (Az=hSetWinGui)
            toggleImgEditPanelWindow()
      } Else If (givenKey="Space")
         highlightActiveCtrl(givenKey)
      Else If (givenKey="RButton")
         highlightActiveCtrl(givenKey)
   
      If (folderTreeWinOpen=1 && Az=hfdTreeWinGui && givenKey="^x")
         folderTreeCutCopyFolder("cut")
      Else If (folderTreeWinOpen=1 && Az=hfdTreeWinGui && givenKey="^c")
         folderTreeCutCopyFolder("copy")
   } Else If (thisWin=hQPVtoolbar && ShowAdvToolbar=1 && Az=thisWin)
   {
       If isVarEqualTo(givenKey, "+Tab", "Tab", "Escape", "AppsKey")
       {
          ; currentKbdBTNtlbr := 0
          isToolbarKBDnav := 0
          WinActivate, ahk_id %PVhwnd%
          displayNowToolbarHelp(3)
       } Else If (givenKey="h" || givenKey="F1")
       {
          displayNowToolbarHelp(1)
       } Else If isVarEqualTo(givenKey, "Left", "BackSpace", "Up")
       {
          moveMouseToolbar(-1, 1)
       } Else If isVarEqualTo(givenKey, "Right", "Delete", "Down")
       {
          moveMouseToolbar(1, 1)
       } Else If (givenKey="PgUp")
       {
          moveMouseToolbar(-1, 4)
       } Else If (givenKey="Home")
       {
          currentKbdBTNtlbr := 0
          moveMouseToolbar(1, 1)
       } Else If (givenKey="PgDn" || givenKey="End")
       {
          moveMouseToolbar(1, 4)
       } Else If (givenKey="Space" || givenKey="Enter")
       {
          invokeKbdToolbarAct(0)
       } Else If (givenKey="+Space" || givenKey="+Enter")
       {
          invokeKbdToolbarAct("right")
       } Else If (isInRange(givenKey, 0, 9) && isNumber(givenKey))
       {
          currentKbdBTNtlbr := 0
          v := givenKey ? givenKey : 10
          moveMouseToolbar(1, v)
       }
   } Else If (thisWin=PVhwnd && identifyThisWin()=1)
   {
       ; ToolTip, % givenKey "==" thisWin , , , 2
       If (givenKey="^o")
       {
           If HKifs("general")
              OpenDialogFiles()
       } Else If (givenKey="o")
       {
           imgPath := getIDimage(currentFileIndex)
           If (isImgEditingNow()=1 && drawingShapeNow=1)
              toggleOpenClosedLineCustomShape()
           Else If HKifs("imgsLoaded")
              OpenThisFileMenu()
           Else If ((HKifs("general") && (!CurrentSLD || StrLen(gdiBitmap)<3)) && !FileRexists(imgPath))
              OpenDialogFiles()
       } Else If (givenKey="w")
       {
           ; w ; to-do
           If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1 && thumbsDisplaying!=1)
              flipSelectionWH()
           Else If (thumbsDisplaying=1 && maxFilesIndex>10 && CurrentSLD && !z)
              invokeFilesListMapNow()
          ; testHistoDLL()
          ; testLhashalgo()
              ; reorderStoredHash("010110000010101011111001111101010111", "1001011011111111010010010101")
             ; ToolTip, % extractSQLqueryFromFilter() , , , 2
                     ; PanelChangeHamDistThreshold()
            ; ; testWICresizeSpeed()
             Sleep, 1
       } Else If (givenKey="+^n")
       {
           If HKifs("general")
              OpenNewQPVinstance()
       } Else If (givenKey="^n")
       {
           If HKifs("general")
              PanelNewImage()
       } Else If (givenKey="+vkC0")
       {
           If HKifs("general")
              PanelJournalWindow()
       } Else If (givenKey="F12")
       {
           If HKifs("general")
              PanelPrefsWindow()
       } Else If (givenKey="p")
       {
           If (isImgEditingNow()=1 && drawingShapeNow=1)
             togglePreviewVectorNewPoint()
           Else If (liveDrawingBrushTool=1 && isImgEditingNow()=1 && AnyWindowOpen=64)
             toggleBrushDeformers()
           Else If (HKifs("imgEditSolo") || HKifs("liveEdit", 64) || HKifs("imgsLoaded"))
             PanelBrushTool()
       } Else If (givenKey="!p")
       {
           If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
              MenuStartDrawingLines()
       } Else If (givenKey="+p")
       {
           If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
              MenuStartDrawingShapes()
       } Else If (givenKey="^p")
       {
           If (imageLoading!=1 && (HKifs("imgEditSolo") || HKifs("imgsLoaded")))
              PanelPrintImage()
       } Else If (givenKey="vkBA")
       {
           PanelQuickSearchMenuOptions()
       } Else If (givenKey="+vkBA")
       {
           invokeOmniBoxCurrentFile()
       } Else If InStr(givenKey, "^Numpad")
       {
           alignImgSelection(givenKey)
       } Else If (givenKey="^NumpadAdd" || givenKey="^plus")
       {
           changeOSDfontSize(1)
       } Else If (givenKey="^NumpadSub" || givenKey="^minus")
       {
           changeOSDfontSize(-1)
       } Else If (givenKey="+o")
       {
           If HKifs("general")
              OpenFolders()
       } Else If (givenKey="^F10" || givenKey="+F10" || givenKey="+!F10")
       {
           toggleAppToolbar()
       } Else If (givenKey="!F10" || givenKey="F10") && (drawingShapeNow!=1)
       {
           ToggleQuickBaru()
       } Else If (givenKey="^AppsKey" || givenKey="+AppsKey") && (drawingShapeNow!=1)
       {
           BuildSecondMenu("tlbr")
       } Else If (givenKey="#AppsKey" || givenKey="!AppsKey" || givenKey="AppsKey" || givenKey="RButton")
       {
           InitGuiContextMenu(givenKey)
       } Else If (givenKey="Insert")
       {
           If (HKifs("general") && imageLoading!=1)
              addNewFile2list()
       } Else If (givenKey="^v")
       {
           If (HKifs("general") && imageLoading!=1)
              PasteClipboardIMG()
       } Else If (givenKey="+Escape")
       {
           restartAppu()
       } Else If (givenKey="F1")
       {
           showQuickHelp()
       } Else If (givenKey="F9")
       {
          If (HKifs("imgsLoaded") && folderTreeWinOpen=1)
             FolderTreeFindActiveFile()
       } Else If (givenKey="^F4")
       {
          If (drawingShapeNow=1)
             stopDrawingShape()
          Else If AnyWindowOpen
             CloseWindow()
          Else If (thumbsDisplaying=1)
             MenuReturnIMGedit()
          Else
             closeDocuments()
       } Else If (givenKey="d")
       {
           If (HKifs("liveEdit") && liveDrawingBrushTool=1)
              ResetColorsToBW()
           Else If (HKifs("liveEdit") && AnyWindowOpen!=10)
              toggleLiveEditObject()
       } Else If (givenKey="l")
       {
           If ((HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1 || showViewPortGrid=1) && thumbsDisplaying!=1)
              toggleLimitSelection()
           Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
              toggleListViewModeThumbs()
       } Else If (givenKey="+^v")
       {
           If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
              PanelPasteInPlace()
       } Else If (givenKey="^d")
       {
           If (isImgEditingNow()=1 && drawingShapeNow=1)
              MenuSelNoVectorPoints()
           Else If (HKifs("imgsLoaded") && ((thumbsDisplaying=1) || (editingSelectionNow!=1 && markedSelectFile)))
              dropFilesSelection()
           Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
              resetImgSelection()
       } Else If (givenKey="^c")
       {
           If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
              MenuExplorerCopyFiles()
           Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
              CopyImage2clip()
       } Else If (givenKey="^x")
       {
           If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
              MenuExplorerCutFiles()
           Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
              CutSelectedArea()
       } Else If (givenKey="^z")
       {
           allowLoop := 1
           If (isImgEditingNow()=1 && drawingShapeNow=1)
              ImgVectorUndoAct()
           Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
              ImgUndoAction()
       } Else If (givenKey="z")
       {
           If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ToggleImgNavBox()
       } Else If (givenKey="^y")
       {
          allowLoop := 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             ImgVectorRedoAct()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ImgRedoAction()
       } Else If (givenKey="+^z")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ImgSelUndoAct()
       } Else If (givenKey="+^y")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ImgSelRedoAct()
       } Else If (givenKey="^!z")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ImgUndoAction("j")
       } Else If (givenKey="^!y")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ImgRedoAction("j")
       } Else If (givenKey="e")
       {
          If (isVarEqualTo(AnyWindowOpen, 64, 66, 12, 10) && imgEditPanelOpened=1) ; Brush, Fill and Jpeg Crop
             ToggleEditImgSelection()
          Else If (thumbsDisplaying=1)
             QuickSelectFilesSameFolder()
          Else If (HKifs("liveEdit") && AnyWindowOpen!=10)
             livePreviewsImageEditing(1, 1)
          Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          {
             ToggleEditImgSelection()
             If (editingSelectionNow=1)
                CreateGuiButton("Selection options,,invokeSelectionAreaMenu", 0, msgDisplayTime//1.5 + 500)
          }
       } Else If (givenKey="+e")
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1 && currentFileIndex>0 && maxFilesIndex>2)
          {
             activateFilesListFilterBasedOnFolder(currentFileIndex)
          } Else
          {
             If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
                MenuCycleSelectionShapes()
          }
       } Else If (givenKey="!e")
       {
          If ((HKifs("imgEditSolo") || HKifs("imgsLoaded") || HKifs("liveEdit")) && editingSelectionNow=1)
             PanelIMGselProperties()
          Else If HKifs("imgsLoaded")
             OpenQPVfileFolder()
       } Else If (givenKey="^s")
       {
          If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
             PanelSaveImg()
       } Else If (givenKey="^l")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit", 65) || HKifs("imgsLoaded"))
             PanelDrawShapesInArea()
       } Else If (givenKey="+l")
       {
          If (HKifs("liveEdit") && EllipseSelectMode=2 && editingSelectionNow=1
          && isVarEqualTo(AnyWindowOpen, 74, 68, 66, 65, 64, 55, 25, 23, 10))
             MenuResumeDrawingShapes()
          Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded")) && (thumbsDisplaying!=1)
          {
             If (editingSelectionNow!=1 || EllipseSelectMode!=2)
                MenuStartDrawingSelectionArea()
             Else
                MenuResumeDrawingShapes()
          }
       } Else If (givenKey="!l")
       {
          If HKifs("imgsLoaded" && thumbsDisplaying=1)
             CalculateSelectedFilesSizes()
       } Else If (givenKey="!BackSpace")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             tlbrFillShape()          ; PanelFillSelectedArea()
       } Else If (givenKey="!y")
       {
          If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
            PanelImgAutoCrop()
       } Else If (givenKey="y")
       {
          If ((liveDrawingBrushTool=1 || drawingShapeNow=1) && isImgEditingNow()=1)
             toggleBrushSymmetryModes()
       } Else If (givenKey="+y")
       {
          If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
             BtnSetBrushSymmetryCoords()
       } Else If (givenKey="i")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ToggleInfoBoxu()
       } Else If (givenKey="vkDB")
       {
          allowLoop := 1 
          If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
             changeBrushSize(-1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ChangeLumos(-1)
       } Else If (givenKey="vkDD")
       {
          allowLoop := 1 
          If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
             changeBrushSize(1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ChangeLumos(1)
       } Else If (givenKey="+vkDB")
       {
          allowLoop := 1 
          If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
             changeBrushSoftness(-1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ChangeGammos(-1)
       } Else If (givenKey="+vkDD")
       {
          allowLoop := 1 
          If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
             changeBrushSoftness(1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ChangeGammos(1)
       } Else If (givenKey="^vkDB")
       {
          allowLoop := 1 
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ChangeSaturation(-1)
       } Else If (givenKey="^vkDD")
       {
          allowLoop := 1 
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ChangeSaturation(1)
       } Else If (givenKey="!vkDB")
       {
          allowLoop := 1 
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ChangeRealGamma(-1)
       } Else If (givenKey="!vkDD")
       {
          allowLoop := 1 
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ChangeRealGamma(1)
       } Else If (givenKey="vkDC")
       {
          If (HKifs("liveEdit") && (AnyWindowOpen=10 || AnyWindowOpen=74))
             BtnToggleNoColorsFX()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ResetImageView()
       } Else If (givenKey="^vkDC")
       {
          If (HKifs("liveEdit") && AnyWindowOpen=10)
             btnResetImageView()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             HardResetImageView()
       } Else If (givenKey="+vkDC")
       {
          If HKifs("liveEdit")
          {
             If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
                resetSelectionAreaCavity()
             Else
                resetSelectionRotation()
          } Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          {
             If (innerSelectionCavityX>0 && innerSelectionCavityY>0 && editingSelectionNow=1)
                resetSelectionAreaCavity()
             Else If (editingSelectionNow=1 && VPselRotation>0)
                resetSelectionRotation()
             Else
                toggleColorAdjustments()
          }
       } Else If (givenKey="vkBF" || givenKey="NumpadDiv") ; /
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow()) && (thumbsDisplaying!=1)
          {
             IMGresizingMode := 0
             ToggleImageSizingMode()
          }
       } Else If (givenKey="NumpadMult" || givenKey="^vkBF") ; Ctrl+/
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow()) && (thumbsDisplaying!=1)
             toggleCustomZLmodes()
       } Else If (givenKey="+NumpadAdd" || givenKey="+plus")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             changeSelectZoom(1)
       } Else If (givenKey="+NumpadSub" || givenKey="+minus")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             changeSelectZoom(-1)
       } Else If (givenKey="!minus")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
             changeGridSize(-1)
       } Else If (givenKey="!plus")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
             changeGridSize(1)
       } Else If (givenKey="NumpadAdd" || givenKey="plus")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
             ChangeZoom(1)
       } Else If (givenKey="NumpadSub" || givenKey="minus")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
             ChangeZoom(-1)
       } Else If (givenKey="g")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ToggleImgHistogram(1)
       } Else If (givenKey="+g")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ToggleImgHistogram(-1)
       } Else If (givenKey="!g")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ToggleHistogramMode()
       } Else If (givenKey="^r")
       {
          If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
             PanelEditorImgResize()
          Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
             PanelSimpleResizeRotate()
       } Else If (givenKey="!r")
       {
          If (HKifs("imgEditSolo") || HKifs("imgsLoaded")) && (!AnyWindowOpen)
             ResizeIMGviewportSelection()
       } Else If (givenKey="r")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1 && bezierSplineCustomShape=1)
             toggleAutoReflectAnchors()
          Else If (HKifs("liveEdit") && (liveDrawingBrushTool=1 || AnyWindowOpen=64))
             toggleBrushTypeEraser()
          Else If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile)
             PanelReviewSelectedFiles()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             makeSquareSelection()
       } Else If (givenKey="+r")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             MenuSelRotation()
       } Else If (givenKey="^t")
       {
          If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
             PanelTransformSelectedArea()
       } Else If (givenKey="+t")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit", 32) || HKifs("imgsLoaded"))
             PanelInsertTextArea()
       } Else If (givenKey="+i")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             MenuSelInvertVectorPoints()
          Else If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile>1)
             invertFilesSelection()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             InvertSelectedArea()
       } Else If (givenKey="^g")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit", 55) || HKifs("imgsLoaded"))
             PanelDesatureSelectedArea()
       } Else If (givenKey="+b")
       {
          If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
             PanelBlurSelectedArea()
       } Else If (givenKey="b")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             MenuToggleBezierMode()
          Else If (HKifs("liveEdit") && (liveDrawingBrushTool=1 || AnyWindowOpen=64))
             toggleBrushTypes()
          Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
             ToggleImgFavourites(0, 0, 1)
       } Else If (givenKey="^h")
       {
          If (HKifs("imgsLoaded") && maxFilesIndex>1)
             PanelSearchAndReplaceIndex()
       } Else If (givenKey="h")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          {
             If (EllipseSelectMode=2 && editingSelectionNow=1)
                flipWHcustomShape("h")
             Else
                VPflipImgH()
          }
       } Else If (givenKey="v")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          {
             If (EllipseSelectMode=2 && editingSelectionNow=1)
                flipWHcustomShape("V")
             Else
                VPflipImgV()
          }
       } Else If (givenKey="+h")
       {
          If (HKifs("liveEdit") && isNowAlphaPainting()=1)
             FlipHalphaMask()
          Else If (HKifs("liveEdit") && (AnyWindowOpen=31 || AnyWindowOpen=24))
             FlipHtransformedIMGpanel()
          Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
             filesListFlipHimage()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             FlipSelectedAreaH()
       } Else If (givenKey="+v")
       {
          If (HKifs("liveEdit") && isNowAlphaPainting()=1)
             FlipValphaMask()
          Else If (HKifs("liveEdit") && (AnyWindowOpen=31 || AnyWindowOpen=24))
             FlipVtransformedIMGpanel()
          Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
             filesListFlipVimage()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             FlipSelectedAreaV()
       } Else If (givenKey="u")
       {
          If (HKifs("liveEdit") && (AnyWindowOpen=31 || AnyWindowOpen=24))
             togglePasteInPlaceColorsFX()
          Else If (HKifs("imgsLoaded") && thumbsDisplaying=1 && thumbsListViewMode=1)
             PanelSetThumbColumnOptions()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             PanelColorsAdjusterImage()
       } Else If (givenKey="+u")
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1)
             filesListApplyColors()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             PanelColorsAdjusterWindow()
       } Else If (givenKey="+^u")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ApplyColorAdjustsSelectedArea()
       } Else If (givenKey="f")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
             ToggleImgFX(1)
       } Else If (givenKey="+f")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
             ToggleImgFX(-1)
       } Else If (givenKey="+q")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (liveDrawingBrushTool!=1)
             ToggleImgColorDepth(-1)
       } Else If (givenKey="q")
       {
          If (HKifs("liveEdit") && (liveDrawingBrushTool=1 || AnyWindowOpen=64))
             toggleBrushTypeFX()
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             ToggleImgColorDepth(1)
       } Else If (givenKey="Delete")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             MenuRemSelVectorPoints()
          Else If ((HKifs("imgEditSolo") || HKifs("liveEdit", 25)) && thumbsDisplaying!=1 && editingSelectionNow=1)
             PanelEraseSelectedArea()
          Else If HKifs("imgsLoaded")
             deleteKeyAction()
       } Else If (givenKey="!Delete")
       {
          If (HKifs("imgsLoaded") && maxFilesIndex>1 && currentFileIndex>0)
             singleInListEntriesRemover()
       } Else If (givenKey="+Delete")
       {
          If HKifs("imgsLoaded")
          {
             DeleteActivePicture()
             Sleep, 350
             If (maxFilesIndex>1 && currentFileIndex>0)
                singleInListEntriesRemover()
          }
       } Else If (givenKey="a")
       {
          If HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || (AnyWindowOpen>1) || (isImgEditingNow()=1 && drawingShapeNow=1)
             ToggleIMGalign()
       } Else If (givenKey="+a")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             toggleImgSelectionAspectRatio()
       } Else If (givenKey="+^a")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             toggleImgSelectLockedRatio()
       } Else If (givenKey="!a")
       {
          If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
             PanelAdjustImageCanvasSize()
       } Else If (givenKey="^a")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             MenuSelAllVectorPoints()
          Else If HKifs("liveEdit")
             selectEntireImage()
          Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          {
             If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
                selectAllFiles()
             Else
                selectEntireImage()
          }
       } Else If (givenKey="+9")
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          {
             filesListFlipRotateMinus()
          } Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1)
          {
             changeSelRotation(-1)
             allowLoop := 1
          }
       } Else If (givenKey="8")
       {
          allowLoop := 1
          If (HKifs("liveEdit") && liveDrawingBrushTool=1)
             changeBrushOpacity(givenKey, 1)
       } Else If (givenKey="9")
       {
          allowLoop := 1
          If (HKifs("liveEdit") && liveDrawingBrushTool=1)
             changeBrushOpacity(givenKey, 1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             changeImgRotationInVP(-1)
       } Else If (givenKey="!9")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             changeLittleImgRotationInVP(-1)
       } Else If (givenKey="+00.1")
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          {
             filesListFlipRotatePlus()
          } Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1)
          {
             changeSelRotation(1)
             allowLoop := 1
          }
       } Else If (givenKey="00.1")
       {
          allowLoop := 1
          If (HKifs("liveEdit") && liveDrawingBrushTool=1)
             changeBrushOpacity(givenKey, 1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             changeImgRotationInVP(1)
       } Else If (givenKey="!00.1")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             changeLittleImgRotationInVP(1)
       } Else If (givenKey="Up" || givenKey="+Up")
       {
          If ((isImgEditingNow()=1 && drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
             PanIMGonScreen("U", givenKey)
          Else If HKifs("imgsLoaded")
             ThumbsNavigator("Upu", givenKey)
       } Else If (givenKey="Down" || givenKey="+Down")
       {
          If ((isImgEditingNow()=1 && drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
             PanIMGonScreen("D", givenKey)
          Else If HKifs("imgsLoaded")
             ThumbsNavigator("Down", givenKey)
       } Else If (givenKey="^WheelUp")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || isImgEditingNow()=1 && drawingShapeNow=1)
             ChangeZoom(1, "WheelUp")
       } Else If (givenKey="^WheelDown")
       {
          allowLoop := 1
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || isImgEditingNow()=1 && drawingShapeNow=1)
             ChangeZoom(-1, "WheelDown")
       } Else If (givenKey="!Left")
       {
          allowLoop := 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             arrowKeysAdjustPrevPointPath(-1, 1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             arrowKeysAdjustSelectionArea(-1, 1)
       } Else If (givenKey="!Right")
       {
          allowLoop := 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             arrowKeysAdjustPrevPointPath(1, 1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             arrowKeysAdjustSelectionArea(1, 1)
       } Else If (givenKey="!Up")
       {
          allowLoop := 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             arrowKeysAdjustPrevPointPath(-2, 1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             arrowKeysAdjustSelectionArea(-2, 1)
       } Else If (givenKey="!Down")
       {
          allowLoop := 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             arrowKeysAdjustPrevPointPath(2, 1)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             arrowKeysAdjustSelectionArea(2, 1)
       } Else If (givenKey="+!Left")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             arrowKeysAdjustPrevPointPath(-1, 2)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             arrowKeysAdjustSelectionArea(-1, 2)
       } Else If (givenKey="+!Right")
       {
          allowLoop := 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             arrowKeysAdjustPrevPointPath(1, 2)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             arrowKeysAdjustSelectionArea(1, 2)
       } Else If (givenKey="+!Up")
       {
          allowLoop := 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             arrowKeysAdjustPrevPointPath(-2, 2)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             arrowKeysAdjustSelectionArea(-2, 2)
       } Else If (givenKey="+!Down")
       {
          allowLoop := 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             arrowKeysAdjustPrevPointPath(2, 2)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
             arrowKeysAdjustSelectionArea(2, 2)
       } Else If (givenKey="F8")
       {
          If HKifs("liveEdit")
             toggleImgEditPanelWindow()
          Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
             openPreviousPanel()
       } Else If (givenKey="Space")
       {
          If (HKifs("imgsLoaded") && drawingShapeNow!=1)
          {
             If ((thumbsDisplaying=1 || markedSelectFile) && slideShowRunning!=1)
                markThisFileNow()
             Else If (slideShowRunning=1)
                dummyInfoToggleSlideShowu("stop")
             Else If (A_TickCount - lastOtherWinClose>350) && (A_TickCount - prevSlideShowStop>950) ; && (drawingShapeNow!=1)
                InfoToggleSlideShowu()
          } Else if (!CurrentSLD && !maxFilesIndex && StrLen(UserMemBMP)<3)
             toggleScreenSaverMode()
       } Else If (givenKey="+n")
       {
          If HKifs("imgsLoaded")
             PanelEditImgCaption()
       } Else If (givenKey="n")
       {
          If (HKifs("liveEdit") && (isAlphaMaskWindow()=1 || isAlphaMaskPartialWin()=1))
             toggleInvertAlphaMask()
          Else If (HKifs("imgsLoaded") && thumbsDisplaying!=1)
             ToggleImgCaptions()
       } Else If (SubStr(givenKey, 1, 1)="^" && isInRange(SubStr(givenKey, 2, 1), 0, 8))
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          {
             If (givenKey="^1")
                SetTimer, ActSortName, -150
             Else If (givenKey="^2")
                SetTimer, ActSortPath, -150
             Else If (givenKey="^3")
                SetTimer, ActSortFileName, -150
             Else If (givenKey="^4")
                SetTimer, ActSortSize, -150
             Else If (givenKey="^5")
                SetTimer, ActSortModified, -150
             Else If (givenKey="^6")
                SetTimer, ActSortCreated, -150
             Else If (givenKey="^7")
                SetTimer, PanelResolutionSorting, -50
             Else If (givenKey="^8")
                SetTimer, PanelHistogramSorting, -50
             Else If (givenKey="^00.1")
                SetTimer, ReverseListNow, -150
          }
       } Else If (givenKey="j")
       {
          If (liveDrawingBrushTool=1 || AnyWindowOpen=64) && HKifs("liveEdit")
             toggleBrushTypeCloner()
          Else If HKifs("imgsLoaded")
             PanelJump2index()
       } Else If (givenKey="+Insert")
       {
          If HKifs("imgsLoaded")
             addNewFolder2list()
       } Else If (givenKey="Tab")
       {
           mainWinTabResponse()
       } Else If (givenKey="+Tab")
       {
          ; currentKbdBTNtlbr := 0
          If (ShowAdvToolbar=1 && hQPVtoolbar)
          {
             isToolbarKBDnav := 1
             WinActivate, ahk_id %hQPVtoolbar%
             ; moveMouseToolbar(1, 1)
             displayNowToolbarHelp(2)
          }
       } Else If (givenKey="^Tab")
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile>1)
             filterToFilesSelection()
       } Else If (givenKey="F11")
       {
          If HKifs("liveEdit")
             toggleImgEditPanelWindow()
          Else If !AnyWindowOpen
             ToggleFullScreenMode()
       } Else If (givenKey="+Enter")
       {
          If HKifs("liveEdit")
             applyIMGeditKeepWin()
          Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded")) && (!AnyWindowOpen)
             CropImageInViewPortToSelection()
       } Else If (givenKey="^Enter")
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1)
             OpenWithNewQPVinstance()
          Else If HKifs("imgsLoaded")
             SoloNewQPVinstance()
       } Else If (givenKey="Enter")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             stopDrawingShape()
          Else If HKifs("liveEdit")
             applyIMGeditFunction()
          Else If (HKifs("imgsLoaded") && (A_TickCount - lastOtherWinClose>250))
             ToggleThumbsMode()
       } Else If (givenKey="!Enter")
       {
          If HKifs("imgsLoaded")
             PanelImageInfos()
       } Else If (givenKey="c")
       {
          If HKifs("liveEdit")
             changeBrushColorPicker()
          Else If HKifs("imgsLoaded")
             InvokeCopyFiles()
       } Else If (givenKey="^u")
       {
          If HKifs("imgsLoaded")
             PanelStaticFolderzManager()
       } Else If (givenKey="!u")
       {
          If HKifs("imgsLoaded")
             PanelDynamicFolderzWindow()
       } Else If (givenKey="^k")
       {
          If (HKifs("liveEdit") && (AnyWindowOpen=64 || AnyWindowOpen=66 || isAlphaMaskWindow()=1))
             toggleAlphaPaintingMode()
          Else If HKifs("imgsLoaded")
             PanelFileFormatConverter()
       } Else If (givenKey="k")
       {
          If (HKifs("imgsLoaded") || HKifs("liveEdit") || HKifs("imgEditSolo"))
             PanelFloodFillTool()
       } Else If (givenKey="+k")
       {
          If (imgEditPanelOpened=1 && liveDrawingBrushTool=1 || AnyWindowOpen=64 || AnyWindowOpen=66)
             toggleBrushDrawInOutModes()
       } Else If (givenKey="+j")
       {
          If (HKifs("imgsLoaded") && !AnyWindowOpen)
          {
             If (RegExMatch(getIDimage(currentFileIndex), "i)(.\.(jpg|jpeg))$") || markedSelectFile)
                PanelJpegPerformOperation()
          }
       } Else If (givenKey="+c")
       {
          If HKifs("imgsLoaded")
             CopyImagePath()
       } Else If (givenKey="^e")
       {
          If HKifs("imgsLoaded")
             OpenThisFileFolder()
       } Else If (givenKey="^f")
       {
          If HKifs("imgsLoaded")
             PanelEnableFilesFilter()
       } Else If (givenKey="s")
       {
           If (HKifs("liveEdit") && liveDrawingBrushTool=1)
           {
              If (AnyWindowOpen=64 && BrushToolType=3)
                 BtnSetClonerBrushSource()
          } Else If (HKifs("liveEdit") && AnyWindowOpen=23 && FillAreaColorMode=6)
          {
             BtnSetTextureSource()
          } Else If HKifs("imgsLoaded")
          {
             If (thumbsDisplaying=1)
                keepSelectedDupeInGroup()
             Else
                ToggleSlideshowModes()
          }
       } Else If (givenKey="+s")
       {
          If (HKifs("liveEdit") && liveDrawingBrushTool=1)
             toggleBrushDoubleSize()
          Else If (HKifs("imgsLoaded") && mustRecordSeenImgs=1 && thumbsDisplaying=1)
             ToggleSeenIMGstatus()
       } Else If (givenKey="+^s")
       {
          If HKifs("imgsLoaded")
             PanelSaveSlideShowu()
       } Else If (givenKey="t")
       {
          If (liveDrawingBrushTool=1)
          {
             toggleBrushAirMode()
          } Else If (isImgEditingNow()=1 && drawingShapeNow=1)
          {
             togglePathCurveTension()
          } Else If HKifs("imgsLoaded")
          {
             If (thumbsDisplaying=1)
                ToggleThumbsAratio()
             Else
                ToggleImageSizingMode()
          }
       } Else If (givenKey="+Space")
       {
          If HKifs("imgsLoaded")
          {
             If (thumbsDisplaying=1)
                dropFilesSelection()
             Else If (slideShowRunning=1)
                dummyInfoToggleSlideShowu("stop")
             Else If (A_TickCount - prevSlideShowStop>950)
                dummyInfoToggleSlideShowu()
          }
       } Else If (givenKey="^Space")
       {
          If HKifs("imgsLoaded")
          {
             If (slideShowRunning=1)
                dummyInfoToggleSlideShowu("stop")
             Else If StrLen(filesFilter)>1
                MenuRemFilesListFilter()
          }
       } Else If (givenKey="BackSpace")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
            reduceCustomShapelength()
          Else If HKifs("imgsLoaded")
            PrevRandyPicture()
       } Else If (givenKey="+BackSpace")
       {
          If HKifs("imgsLoaded")
          {
             resetSlideshowTimer(0)
             RandomPicture()
          }
       } Else If (givenKey="^BackSpace")
       {
          If HKifs("imgsLoaded")
             jumpPreviousImage()
       } Else If (givenKey="!period")
       {
          allowLoop := 1
          If (HKifs("imgsLoaded") && animGIFsSupport=1)
             changeGIFsDelayu(1)
       } Else If (givenKey="+period")
       {
          allowLoop := 1
          If (liveDrawingBrushTool=1)
             changeBrushWetness(1)
          Else
             ChangeVolume(1)
       } Else If (givenKey="period")
       {
          allowLoop := 1
          If (liveDrawingBrushTool=1)
             changeBrushOpacity(-1, 0)
          Else If HKifs("imgsLoaded")
             IncreaseSlideSpeed()
       } Else If (givenKey="comma")
       {
          allowLoop := 1
          If (liveDrawingBrushTool=1)
             changeBrushOpacity(1, 0)
          Else If HKifs("imgsLoaded")
             DecreaseSlideSpeed()
       } Else If (givenKey="!comma")
       {
          allowLoop := 1
          If (HKifs("imgsLoaded") && animGIFsSupport=1)
             changeGIFsDelayu(-1)
       } Else If (givenKey="+comma")
       {
          allowLoop := 1
          If (liveDrawingBrushTool=1)
             changeBrushWetness(-1)
          Else
             ChangeVolume(-1)
       } Else If (givenKey="+vkBF") ; Shift+/
       {
          If HKifs("imgsLoaded")
             PanelDefineEntireSlideshowLength()
       } Else If (givenKey="F5")
       {
          If HKifs("imgsLoaded") || (liveDrawingBrushTool=1 && AnyWindowOpen=64)
             RefreshImageFileAction()
       } Else If (givenKey="!F5")
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1)
             DeepRefreshThumbsNow()
       } Else If (givenKey="+F5")
       {
          If HKifs("imgsLoaded")
             RefreshFilesList()
       } Else If (givenKey="^F5")
       {
          If HKifs("imgsLoaded")
             invertCurrentFolderRecursiveness()
       } Else If (givenKey="F2")
       {
          If HKifs("imgsLoaded")
             PanelRenameThisFile()
       } Else If (givenKey="+F2")
       {
          If HKifs("imgsLoaded")
             SingularRenameFile()
       } Else If (givenKey="^F2")
       {
          If HKifs("imgsLoaded")
             PanelUpdateThisFileIndex()
       } Else If (givenKey="m")
       {
          If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && ((editingSelectionNow=1 || AnyWindowOpen=66) && thumbsDisplaying!=1 && AnyWindowOpen!=70)
             ViewAlphaMaskNow()
          Else If HKifs("imgsLoaded")
             PanelMoveCopyFiles()
       } Else If (givenKey="^q")
       {
          If (HKifs("imgsLoaded") && AutoDownScaleIMGs=1)
             ToggleImgDownScaling()
       } Else If (givenKey="x")
       {
          If HKifs("liveEdit")
          {
             ToggleBrushColors()
          } Else If HKifs("imgsLoaded")
          {
             If (animGIFplaying=1)
                DestroyGIFuWin()
             Else If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0)
                moveMarkedEntryNow(currentFileIndex)
             Else
                PlayAudioFileAssociatedNow()
          }
       } Else If (givenKey="+x")
       {
          If HKifs("imgsLoaded")
          {
             If (animGIFplaying=1)
                DestroyGIFuWin()
             Else If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0 && markedSelectFile>1)
                regroupSelectedFiles()
             Else If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0)
                moveMarkedEntryNow(currentFileIndex, "move")
             Else
                StopMediaPlaying()
          }
       } Else If ((isInRange(givenKey, 1, 7) && isNumber(givenKey))
              || (SubStr(givenKey, 1, 1)="+" && isInRange(SubStr(givenKey, 2, 1), 1, 7)))
       {
          If (HKifs("liveEdit") && liveDrawingBrushTool=1)
          {
             allowLoop := 1
             changeBrushOpacity(givenKey, 1)
          } Else If (HKifs("imgsLoaded") && !InStr(givenKey, "8"))
             triggerQuickFileAction(givenKey)
       } Else If (givenKey="^Left")
       {
          If HKifs("imgsLoaded")
             navSelectedFiles(-1)
       } Else If (givenKey="^Right")
       {
          If HKifs("imgsLoaded")
             navSelectedFiles(1)
       } Else If (givenKey="F3")
       {
          If HKifs("imgsLoaded")
             searchNextIndex(1)
       } Else If (givenKey="+F3")
       {
          If HKifs("imgsLoaded")
             searchNextIndex(-1)
       } Else If (givenKey="^F3")
       {
          If HKifs("imgsLoaded")
             PanelSearchIndex()
       } Else If (givenKey="F4")
       {
          ; If HKifs("imgsLoaded")
          PanelFoldersTree()
       } Else If (givenKey="+F4")
       {
          If HKifs("imgsLoaded")
             invokeFoldersListerMenu()
       } Else If (givenKey="WheelUp")
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1)
             ThumbsNavigator("Down", givenKey)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || isImgEditingNow()=1 && drawingShapeNow=1) && (IMGresizingMode=4 && thumbsDisplaying!=1)
             ChangeZoom(1, "WheelUp")
          Else If (HKifs("imgsLoaded"))
             PreviousPicture("key-" givenKey)
       } Else If (givenKey="WheelDown")
       {
          If (HKifs("imgsLoaded") && thumbsDisplaying=1)
             ThumbsNavigator("Upu", givenKey)
          Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || isImgEditingNow()=1 && drawingShapeNow=1) && (IMGresizingMode=4 && thumbsDisplaying!=1)
             ChangeZoom(-1, "WheelDown")
          Else If (HKifs("imgsLoaded"))
             NextPicture("key-" givenKey)
       } Else If (givenKey="Right" || givenKey="+Right")
       {
          If HKifs("imgsLoaded")
          {
             If ((IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
             {
                PanIMGonScreen("R", givenKey)
             } Else
             {
                resetSlideshowTimer(0)
                If (thumbsDisplaying=1)
                   ThumbsNavigator("Right", givenKey)
                Else
                   NextPicture("key-" givenKey)
            }
          } Else If ((isImgEditingNow()=1 && drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
            PanIMGonScreen("R", givenKey)
       } Else If (givenKey="Left" || givenKey="+Left")
       {
          If HKifs("imgsLoaded")
          {
             If ((IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
             {
                PanIMGonScreen("L", givenKey)
             } Else
             {
                resetSlideshowTimer(0)
                If (thumbsDisplaying=1)
                   ThumbsNavigator("Left", givenKey)
                Else
                   PreviousPicture("key-" givenKey)
            }
          } Else If ((isImgEditingNow()=1 && drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
            PanIMGonScreen("L", givenKey)
       } Else If (givenKey="PgDn")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
          {
             allowLoop := 1
             adjustCustomShapePositionLive(-1)
          } Else If (HKifs("liveEdit") && editingSelectionNow=1)
          {
             allowLoop := 1
             arrowKeysAdjustSelectionArea(-1, 1)
             arrowKeysAdjustSelectionArea(-1, 2)
          } Else If HKifs("imgsLoaded")
          {
             resetSlideshowTimer(0)
             If (thumbsDisplaying=1)
             {
                allowLoop := 1
                ThumbsNavigator("PgDn", givenKey)
             } Else NextPicture()
          }
       } Else If (givenKey="PgUp")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
          {
             allowLoop := 1
             adjustCustomShapePositionLive(1)
          } Else If (HKifs("liveEdit") && editingSelectionNow=1)
          {
             allowLoop := 1
             arrowKeysAdjustSelectionArea(1, 1)
             arrowKeysAdjustSelectionArea(1, 2)
          } Else If HKifs("imgsLoaded")
          {
             resetSlideshowTimer(0)
             If (thumbsDisplaying=1)
             {
                allowLoop := 1
                ThumbsNavigator("PgUp", givenKey)
             } Else PreviousPicture()
          }
       } Else If (givenKey="+PgDn")
       {
          If HKifs("imgsLoaded")
          {
             resetSlideshowTimer(0)
             If (thumbsDisplaying=1)
             {
                allowLoop := 1
                ThumbsNavigator("PgDn", givenKey)
             } Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
                changeDesiredFrame(-1)
          }
       } Else If (givenKey="+PgUp")
       {
          ; ToolTip, % totalFramesIndex "===" thumbsDisplaying , , , 2
          If HKifs("imgsLoaded")
          {
             resetSlideshowTimer(0)
             If (thumbsDisplaying=1)
             {
                allowLoop := 1
                ThumbsNavigator("PgUp", givenKey)
             } Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
                changeDesiredFrame(1)
          }
       } Else If (givenKey="^PgUp")
       {
          allowLoop := 1
          If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
             FileExploreUpDownLevel(-1)
       } Else If (givenKey="^PgDn")
       {
          allowLoop := 1
          If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
             FileExploreUpDownLevel(1)
       } Else If (givenKey="!PgUp")
       {
          allowLoop := 1
          If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
             FileExploreSiblingsNav(-1)
       } Else If (givenKey="!PgDn")
       {
          allowLoop := 1
          If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
             FileExploreSiblingsNav(1)
       } Else If (givenKey="^Home")
       {
          If HKifs("imgsLoaded")
             jumpToFilesSelBorder(-1)
       } Else If (givenKey="^End")
       {
          If HKifs("imgsLoaded")
             jumpToFilesSelBorder(1)
       } Else If (givenKey="Home" || givenKey="+Home")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
          {
             allowLoop := 1
             adjustCustomShapePositionLive(2)
          } Else If (HKifs("liveEdit") && editingSelectionNow=1)
          {
             allowLoop := 1
             arrowKeysAdjustSelectionArea(-2, 1)
             arrowKeysAdjustSelectionArea(-2, 2)
          } Else If HKifs("imgsLoaded")
          {
             If (thumbsDisplaying=1)
             {
                allowLoop := 1
                ThumbsNavigator("Home", givenKey)
             } Else FirstPicture()
          }
       } Else If (givenKey="End" || givenKey="+End")
       {
          If (isImgEditingNow()=1 && drawingShapeNow=1)
          {
             allowLoop := 1
             adjustCustomShapePositionLive(-2)
          } Else If (HKifs("liveEdit") && editingSelectionNow=1)
          {
             allowLoop := 1
             arrowKeysAdjustSelectionArea(2, 1)
             arrowKeysAdjustSelectionArea(2, 2)
          } Else If HKifs("imgsLoaded")
          {
             If (thumbsDisplaying=1)
             {
                allowLoop := 1
                ThumbsNavigator("End", givenKey)
             } Else LastPicture()
         }
       } Else If (InStr(menuHotkeys, givenKey "|") && showMainMenuBar=1 && InStr(givenKey, "!") && StrLen(givenKey)=2)
       {
          n := 0
          Loop, Parse, menuHotkeys, |
          {
             If (A_LoopField=givenKey)
             {
                n := A_Index - 1
                Break
             }
          }
          If n
             interfaceThread.ahkPostFunction("invokeGivenMenuBarPopup", n)
       }
   }

   If (abusive=1 && allowLoop=1)
   {
      KeyboardResponder(givenKey, thisWin, 0)
   } Else If (totalFramesIndex>2 && CountGIFframes>2)
   {
      animGIFplaying := interfaceThread.ahkgetvar.animGIFplaying
      If (animGIFplaying=-1)
      {
         imgPath := getIDimage(currentFileIndex)
         animGIFplaying := 1
         interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
         setGIFframesDelay()
         autoChangeDesiredFrame("start", imgPath)
         SetTimer, autoChangeDesiredFrame, % GIFspeedDelay
      }
   }
} ; // KeyboardResponder()


;____________ Functions __________________

initQPVmainDLL() {
   Static attempts := 0

   If (qpvMainDll || attempts>2)
      Return

   attempts++
   whichMainDLL := (A_OSVersion="WIN_7" || isWinXP=1) ? "qpv_main_win7.dll" : "qpvmain.dll"
   DllPath := FreeImage_FoxGetDllPath(whichMainDLL)
   If !DllPath
      Return

   If (InStr(A_ScriptDir, "sucan twins") && !A_IsCompiled)
   {
      If (A_PtrSize=8)
         DllPath := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\qpv-main\x64\Release\qpvmain.dll"
      Else
         DllPath := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\qpv-main\Release\qpvmain.dll"
   }

   qpvMainDll := DllCall("LoadLibraryW", "WStr", DllPath, "UPtr")
   addJournalEntry("INIT main QPV dll: " A_LastError "==" qpvMainDll "==" DllPath)

   thisFunc := (A_PtrSize=8) ? "calculateDCTcoeffs" : "_calculateDCTcoeffs@4"
   dupesDCTcoeffsInit := DllCall(whichMainDLL "\" thisFunc, "int", 32)

   thisFunc := (A_PtrSize=8) ? "initWICnow" : "_initWICnow@8"
   WICmoduleHasInit := DllCall(whichMainDLL "\" thisFunc, "int", 1, "int", 0)
   ; MsgBox, % r "=" WICmoduleHasInit
   If WICmoduleHasInit
   {
      CLSIDlist := ""
      extensionsList := ""
      Loop, Reg, HKEY_CLASSES_ROOT\CLSID\{7ED96837-96F0-4812-B211-F13C24117ED3}\Instance, KVR
      {
         If (InStr(A_LoopRegName, "{") && InStr(A_LoopRegName, "}") && ST_Count(A_LoopRegName, "-")>2)
            CLSIDlist .= A_LoopRegName "`n"
      }

      Sort, CLSIDlist, UD`n
      Loop, Parse, CLSIDlist, `n
      {
         If !A_LoopField
            Continue

         Loop, Reg, HKEY_CLASSES_ROOT\CLSID\%A_loopField%, KV
         {
            RegRead, value
            If InStr(A_LoopRegName, "FileExtension")
               extensionsList .= Trimmer(value) ","
         }
      }

      extensionsList := StrReplace(extensionsList, ",", "|")
      extensionsList := StrReplace(extensionsList, ".", "|")
      extensionsList := StrReplace(extensionsList, "||", "|")
      Sort, extensionsList, UD|
      extensionsList := Trimmer(extensionsList, "|")
      RegExWICfmtPtrn := StrReplace(RegExWICfmtPtrn, "place-holder", extensionsList)
      RegExAllFilesPattern := StrReplace(RegExAllFilesPattern, "|dib|", "|" extensionsList "|")
      Sort, RegExAllFilesPattern, UD|
      extensionsList := Trimmer(RegExAllFilesPattern, "|")
      RegExFilesPattern := "i)^(.\:\\).*(\.(" RegExAllFilesPattern "))$"
      ; msgbox, % RegExFilesPattern
      allFormats := "*.jpeg;*.ico;" openFptrn3 openFptrn1 openFptrn2 openFptrn4 ";"
      Loop, Parse, extensionsList, |
      {
         If !InStr(allFormats, "*." A_LoopField ";")
            openFptrnWIC .= "*." A_LoopField ";"
      }
      openFptrnWIC := Trimmer(openFptrnWIC, ";")
   }

   ; MsgBox, % WICmoduleHasInit "==" CLSIDlist "`n" extensionsList
   ; ToolTip, % WICmoduleHasInit " | " A_LastError "==" qpvMainDll "`n" DllPath , , , 2
}

initializeAppWithGivenArguments() {
   thisCounter := folderOpened := sldOpened := doWelcomeNow := 0
   disCount := A_Args.Count()
   Loop, % disCount
   {
      If (A_Index>=950)
      {
         doWelcomeNow := 1
         Break
      } Else If (RegExMatch(A_Args[A_Index], sldsPattern) && RegExMatch(A_Args[A_Index], "i)^(.\:\\..*)") && !sldOpened)
      {
         If FileExist(A_Args[A_Index])
            sldOpened := A_Args[A_Index]
      } Else If (RegExMatch(A_Args[A_Index], "i)^(fd\=\|?.\:\\..*)") && !folderOpened)
      {
         paramSet := SubStr(A_Args[A_Index], 4)
         If FolderExist(StrReplace(paramSet, "|"))
            folderOpened := paramSet
      } Else If (RegExMatch(A_Args[A_Index], RegExFilesPattern) && !folderOpened && !sldOpened)
      {
         filesListu .= A_Args[A_Index] "`n"
         thisCounter++
      } Else If RegExMatch(A_Args[A_Index], "i)^(.?qpv-debug)")
      {
         debugModa := 1
      } Else If RegExMatch(A_Args[A_Index], "i)^(set\_..*\=..*)")
      {
         paramSet := SubStr(A_Args[A_Index], 5, InStr(A_Args[A_Index], "=") - 5)
         paramSetValue := SubStr(A_Args[A_Index], InStr(A_Args[A_Index], "=") + 1)
         If (paramSet && paramSetValue!="")
            %paramSet% := paramSetValue
      } Else If RegExMatch(A_Args[A_Index], "i)^(call\_..*\(\))")
      {
         func2exec := SubStr(A_Args[A_Index], 6, InStr(A_Args[A_Index], "(") - 6)
         If (IsFunc(func2exec)=1 && StrLen(func2exec)>2)
            delayedfunc2exec := func2exec
      }
   }
   ; ToolTip, % "l=" disCount , , , 2
   If sldOpened
   {
      OpenSLD(sldOpened)
   } Else If folderOpened
   {
      If InStr(folderOpened, "|")
         tryOpenGivenFolder(folderOpened, 0)
      Else
         OpenFolders(folderOpened)
   } Else If (thisCounter=1 && !sldOpened && !folderOpened)
      OpenArgFile(Trimmer(filesListu))
   Else If (thisCounter>1 && !sldOpened && !folderOpened)
      GuiDroppedFiles(filesListu, nona, none, thisCounter, 0)
   Else Return 1

   If delayedfunc2exec
      SetTimer, runDelayedfunc2exec, -950

   Return doWelcomeNow
}

runDelayedfunc2exec() {
   If IsFunc(delayedfunc2exec)
      %delayedfunc2exec%()
}

OpenSLD(fileNamu, dontStartSlide:=0) {
  mustOpenStartFolder := ""
  If !FileExist(fileNamu)
  {
     showTOOLtip("ERROR: Failed to load files list")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  PopulateIndexFilesStatsInfos("kill")
  If (SLDtypeLoaded=3)
  {
     SLDtypeLoaded := 0
     activeSQLdb.CloseDB()
  }

  mustRemQuotes := 1
  setImageLoading()
  renewCurrentFilesList()
  newStaticFoldersListCache := []
  DynamicFoldersList := CurrentSLD := filesFilter := ""
  zPlitPath(fileNamu, 0, OutFileName, OutDir)
  showTOOLtip("Loading slideshow, please wait`n" OutFileName "`n" OutDir "\")
  setWindowTitle("Loading slideshow, please wait", 1)
  If RegExMatch(fileNamu, "i)(.\.sldb)$")
  {
     r := OpenSLDBdataBase(fileNamu)
     If (maxFilesIndex>0 && r!=-1)
     {
        SLDcacheFilesList := 1
        mustGenerateStaticFolders := 0
        GenerateRandyList()
        SetTimer, ResetImgLoadStatus, -50
        CurrentSLD := fileNamu
        RecentFilesManager(CurrentSLD)
        SLDtypeLoaded := 3
        prevOpenFolderPath := OutDir
        INIaction(1, "prevOpenFolderPath", "General")
        RandomPicture()
        InfoToggleSlideShowu()
     } Else resetMainWin2Welcome()
     SetTimer, createGUItoolbar, -100
     SetTimer, TriggerMenuBarUpdate, -90
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  SlidesMusicSong := ""
  FileReadLine, firstLine, % fileNamu, 1
  If InStr(firstLine, "[General]") 
  {
     mustRemQuotes := 0
     IniRead, SlidesMusicSong, % fileNamu, General, SlidesMusicSong, @
     ; If FileExist(SlidesMusicSong)
        IniRead, autoPlaySlidesAudio, % fileNamu, General, autoPlaySlidesAudio, @

     IniRead, testStaticFolderz, % fileNamu, Folders, Fi1, @
     IniRead, tstSLDcacheFilesList, % fileNamu, General, SLDcacheFilesList, @
     IniRead, testDynaFolderz, % fileNamu, DynamicFolderz, DF1, @
     If StrLen(testDynaFolderz)>4
        DynamicFoldersList := "|hexists|"
       ; DynamicFoldersList := coreLoadDynaFolders(fileNamu)

     If (tstSLDcacheFilesList=1 || tstSLDcacheFilesList=0)
        SLDcacheFilesList := tstSLDcacheFilesList
  }

  mustGenerateStaticFolders := (InStr(firstLine, "[General]") && StrLen(testStaticFolderz)>8) ? 0 : 1
  If (tstSLDcacheFilesList=0)
     mustGenerateStaticFolders := 0

  If (SLDcacheFilesList=1 && InStr(firstLine, "[General]")) || !InStr(firstLine, "[General]")
     res := sldGenerateFilesList(fileNamu, 0, mustRemQuotes)

  currentFilesListModified := 0
  interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
  prevOpenFolderPath := OutDir
  INIaction(1, "prevOpenFolderPath", "General")
  If (res="abandoned")
  {
     closeDocuments()
     showDelayedTooltip("Files list operation aborted by user")
     SoundBeep , 300, 100
     Return
  }

  If InStr(firstLine, "[General]") 
  {
     If (maxFilesIndex<3 && DynamicFoldersList="|hexists|")
        ReloadDynamicFolderz(fileNamu)

     If (MustLoadSLDprefs=1)
        readSlideSettings(fileNamu, 0)
  }

  GenerateRandyList()
  CurrentSLD := fileNamu
  SLDtypeLoaded := 2
  currentFileIndex := 1
  currentFilesListModified := 0
  RecentFilesManager(CurrentSLD)
  SetTimer, createGUItoolbar, -100
  SetTimer, TriggerMenuBarUpdate, -90
  If (dontStartSlide=1)
  {
     SetTimer, RemoveTooltip, % -msgDisplayTime
     ResetImgLoadStatus()
     Return
  }

  ResetImgLoadStatus()
  If (maxFilesIndex>2)
  {
     RandomPicture()
     InfoToggleSlideShowu()
  } Else If (maxFilesIndex>0)
  {
     currentFileIndex := 1
     IDshowImage(1)
  } Else resetMainWin2Welcome()

  SetTimer, RemoveTooltip, % -msgDisplayTime
}

endCaptureCloneBrush() {
   mustCaptureCloneBrush := 0
   interfaceThread.ahkassign("mustCaptureCloneBrush", mustCaptureCloneBrush)
   SetTimer, createGUItoolbar, -150
}

resetMainWin2Welcome() {
     Critical, on
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
     { 
        seenImagesDB.Exec("COMMIT TRANSACTION;")
        Sleep, -1
        seenImagesDB.Exec("BEGIN TRANSACTION;")
     }

     SLDtypeLoaded := 0
     hasDrawnImageMap := hasDrawnHistoMap := editingSelectionNow := thumbsDisplaying := 0
     userAllowClrGradientRecenter := userAllowsGradientRecentering := 0
     endCaptureCloneBrush()
     renewCurrentFilesList()
     activeSQLdb.CloseDB()
     newStaticFoldersListCache := []
     bckpResultedFilesList := []
     filteredMap2mainList := []
     toBeExcludedIndexes := []
     resultsDupesArray := []
     dupesHashesData := []
     dupesPixelData := []
     RandyIMGids := []
     calcScreenLimits()
     updateUIctrl()
     SlidesMusicSong := DynamicFoldersList := CurrentSLD := ""
     filesFilter := EntryMarkedMoveIndex := mustOpenStartFolder := ""
     createGDIPcanvas()
     ToggleVisibilityWindow("show", hGDIwin)
     interfaceThread.ahkassign("thumbsDisplaying", 0)
     interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
     Gdip_GraphicsClear(glPG, "0x00" WindowBgrColor)
     doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC, 1)
     doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC, 1)
     doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, glHDC, 1)
     doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, glHDC, 1)
     ToggleVisibilityWindow("hide", hGDIthumbsWin)
     gdiBitmapIDcall := viewportIDstampBMP := AprevImgCall := BprevImgCall := ""
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
     corePasteInPlaceActNow("kill")
     livePreviewInsertTextinArea("kill")
     coreFillSelectedArea("kill")
     livePreviewFillBehindArea("kill")
     coreCreateVPnavBox("kill")
     LoadCachableBitmapFromFile("kill")
     createGradientBrushBitmap("kill", 0, 0, 0, 0)
     createClonedBrushBitmap("kill", 0, 0, 0, 0)
     viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
     gdipObjectsStats(1, "QPV_ShowThumbnails")
     gdipObjectsStats(1)
     ForceRefreshNowThumbsList()
     prevOpenedWindow := ""
     SetTimer, createGUItoolbar, -100
     drawWelcomeImg()
     interfaceThread.ahkPostFunction("uiAccessWelcomeView")
     SetTimer, TriggerMenuBarUpdate, -90
     SetTimer, ResetImgLoadStatus, -50
}

deleteKeyAction() {
    If !getIDimage(currentFileIndex)
       Return

    If (thumbsDisplaying!=1 && editingSelectionNow=1)
       PanelEraseSelectedArea()
    Else
       DeletePicture()
}

activateFilesListFilterBasedOnFolder(thisIndex) {
   If askAboutFileSave(" and the files list will be filtered to the current image containing folder")
      Return

   r := getIDimage(thisIndex)
   zPlitPath(r, 0, OutFileName, OutDir)
   userFilterProperty := userFilterDoString := 1
   userFilterWhat := 2
   userFilterStringPos := 3
   userFilterInvertThis := userFilterStringIsNot := 0
   UsrEditFilter := OutDir
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   showDelayedTooltip("Files list filtered to current image file path:`n" OutDir "\", 0, 325)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(100)
}

mainWinTabResponse() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked>200)
   {
      If HKifs("liveEdit")
         toggleImgEditPanelWindow()
      Else If HKifs("imgsLoaded")
         markThisFileNow()
      lastInvoked := A_TickCount
   }
}

GenerateRandyList() {
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   RandyIMGids := []
   RandyIMGnow := -1
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
}

coreGenerateRandomList() {
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   RandyIMGids := []
   Loop, % maxFilesIndex
       RandyIMGids[A_Index] := A_Index
   RandyIMGids := Random_ShuffleArray(RandyIMGids)
   RandyIMGnow := 1
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
}

OpenThisFilePropFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    resultu := StrReplace(getIDimage(currentFileIndex), "||")
    If resultu
    {
       zPlitPath(resultu, 0, fileNamu, folderu)
       invokeStandardFolderProperties(folderu)
    }
}

OpenThisFileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    resultu := StrReplace(getIDimage(currentFileIndex), "||")
    If resultu
    {
       zPlitPath(resultu, 0, fileNamu, folderu)
       Try Run, "%folderu%"
       Catch wasError
       {
          If !AnyWindowOpen
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu "\", 0, 0, "error")
       }
    }
}

OpenQPVfileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
    If !FolderExist(folderu)
    {
       showTOOLtip("ERROR: Folder not found or access denied`n" folderu "\")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If askAboutFileSave(" and the containing folder of the selected image will be opened")
       Return

    If askAboutSlidesListSave()
       Return

    If imgPath
    {
       renewCurrentFilesList()
       mustOpenStartFolder := folderu
       currentFileIndex := 1
       resultedFilesList[1, 1] := imgPath
       currentFileIndex := doOpenStartFolder()
       dummyTimerDelayiedImageDisplay(50)
    }
}

setImageWallpaper() {
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If !RegExMatch(imgPath, "i)(.\.(bmp|jpg|jpeg|png|tif))$")
   {
      showTOOLtip("Converting Image file format for desktop wallpaper into JPEG")
      file2save := mainCompiledPath "\wallpaper-" OutNameNoExt ".jpg"
      r := coreConvertImgFormat(imgPath, file2save)
      If !r
         imgPath := file2save
      ResetImgLoadStatus()
   }

   GetPhysicalCursorPos(mainX, mainY)
   ActiveMon := MWAGetMonitorMouseIsIn(mainX, mainY)
   If !ActiveMon
      ActiveMon := 1

   dw := new IDesktopWallpaper
   dw.GetMonitorDevicePathAt(ActiveMon - 1, MonitorID)
   dw.SetWallpaper(MonitorID, imgPath)
   dw := Delete IDesktopWallpaper
   showTOOLtip("Image file is now set as desktop wallpaper`n" fileNamu "`n" folderu "\")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

OpenThisFileMenu() {
  Static lastInvoked := 1

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, Ext)
  labelu := "QPVimage." Ext
  RegRead, regEntryA, HKEY_CLASSES_ROOT\.%Ext%
  If (regEntryA=labelu)
     testA := 1

  RegRead, regEntryB, HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.%Ext%\UserChoice, ProgId
  If (regEntryB=labelu)
     testB := 1

  If (slideShowRunning=1)
     ToggleSlideShowu()

  DestroyGIFuWin()
  isAssociated := (testA=1 && testB=1) ? 1 : 0
  newInstanceOption := (A_IsCompiled) ? 1 : 0
  InvokeOpenWithMenu(imgPath, newInstanceOption)
}

SoloNewQPVinstance() {
   OpenWithNewQPVinstance("single")
}

OpenWithNewQPVinstance(dummy:=0, givenList:=0, givenCount:=0) {
   filesElected := getSelectedFiles(0, 1)
   markedSelectFile := filesElected
   If (givenList && givenCount && isNumber(givenCount))
      filesElected := givenCount

   ; ToolTip, % givenCount "--" dummy "--" filesElected "--" givenList , , , 2
   If (filesElected>25 && dummy!="single")
   {
      msgBoxWrapper(appTitle ": WARNING", "You are not allowed to spawn in one go more than 25 instances of " appTitle ".", 0, 0, "error")
      Return
   }

   If (filesElected>5 && dummy!="single")
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " groupDigits(filesElected) " files. Please confirm you want to spawn so many new instances of " appTitle ".", 4, 0, "question")
      If (msgResult="Yes")
         allGood := 1
   } Else allGood := 1

   maxLoops := (givenList && givenCount) ? givenCount + 2 : maxFilesIndex
   If (givenList && givenCount>0 && isNumber(givenCount) && dummy!="single" && allGood=1)
   {
      Loop, Parse, givenList, `n
      {
         imgPath := Trimmer(A_LoopField)
         If StrLen(imgPath)>4
         {
            Sleep, (A_Index>1) ? 700 : 300
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (markedSelectFile && filesElected>1 && dummy!="single" && allGood=1)
   {
      thisIndex := 0
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         thisIndex++
         imgPath := resultedFilesList[A_Index, 1]
         If StrLen(imgPath)>4
         {
            Sleep, (thisIndex>1) ? 700 : 300
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (!markedSelectFile || dummy="single")
   {
      imgPath := getIDimage(currentFileIndex)
      OpenNewQPVinstance(imgPath)
   }
}

OpenNewQPVinstance(imgPath:="") {
   imgPath := StrReplace(imgPath, "||")
   If FolderExist(imgPath)
      imgPath := "fd=" imgPath
   Else If !FileRexists(imgPath)
      imgPath := ""

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening a new instance of " appTitle ".", 0, 0, "error")
}

OpenWithDefaultApp() {
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    If !FileRexists(imgPath)
       informUserFileMissing()
    Sleep, 25
    If imgPath
    {
       Try Run, "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the default application.", 0, 0, "error")
    }
}

OpenFileProperties() {
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    If !FileRexists(imgPath)
       informUserFileMissing()

    Sleep, 25
    If imgPath
    {
       Try Run, Properties "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the system file properties.", 0, 0, "error")
    }
}

InvokeOpenWithMenu(imgPath, newInstanceOption) {
    Try Menu, OpenWithMenu, Delete
    Global lastWinDrag := 1
    Global lastOtherWinClose := 1
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    CurrentSLD := Trimmer(StrReplace(CurrentSLD, "|"))
    CreateOpenWithMenu(imgPath)
    Menu, OpenWithMenu, Add,
    If (AnyWindowOpen!=60)
    {
       IniAction(0, "UserExternalApp", "General", 6)
       pathu := "&X. " PathCompact(UserExternalApp, 28)
       If StrLen(Trimmer(UserExternalApp))<6
          pathu := "NONE CHOSEN"

       IniAction(0, "UserExternalEditApp", "General", 6)
       pathu2 := "&Y. " PathCompact(UserExternalEditApp, 28)
       If StrLen(Trimmer(UserExternalEditApp))<6
          pathu2 := "NONE CHOSEN"

       If !markedSelectFile
          Menu, OpenWithMenu, Add, &0. Open file(s) in a new QPV instance, SoloNewQPVinstance
       Menu, OpenWithMenu, Add, &1. Open with default application, OpenWithDefaultApp
       Menu, OpenWithMenu, Add, &2. System «Open with» dialog, MenuInvokeSHopenWith
       Menu, OpenWithMenu, Add, &4. Explore containing folder`tCtrl+E, OpenThisFileFolder
       If (CurrentSLD!=OutDir)
          Menu, OpenWithMenu, Add, &5. Open containing folder in QPV`tAlt+E, OpenQPVfileFolder
       Menu, OpenWithMenu, Add,
       Menu, OpenWithMenu, Add, &Choose external application, browseExternalApp
       Menu, OpenWithMenu, Add, %pathu%, OpenImgWithUserExternApp
       Menu, OpenWithMenu, Add, &Choose external editor application, browseExternalEditApp
       Menu, OpenWithMenu, Add, %pathu2%, OpenImgWithUserEditExternApp
       If (!pathu || pathu="none chosen")
          Menu, OpenWithMenu, Disable, %pathu%
       If (!pathu2 || pathu2="none chosen")
          Menu, OpenWithMenu, Disable, %pathu2%
       Menu, OpenWithMenu, Add,
    }

    Menu, OpenWithMenu, Add, &Cancel, dummy
    showThisMenu("OpenWithMenu", 1)
}

browseExternalApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalApp := imgPath
      IniAction(1, "UserExternalApp", "General")
      OpenImgWithUserExternApp()
   }
}

browseExternalEditApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalEditApp := imgPath
      IniAction(1, "UserExternalEditApp", "General")
      OpenImgWithUserEditExternApp()
   }
}

OpenImgWithUserEditExternApp() {
   destroyGDIfileCache()
   OpenImgWithUserExternApp("editor")
}

OpenImgWithUserExternApp(dummy:=0) {
   ; IniAction(0, "UserExternalApp", "General", 6)
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   thisAPPpath := (dummy="editor") ? UserExternalEditApp : UserExternalApp
   If !FileExist(thisAPPpath)
   {
      zPlitPath(thisAPPpath, 0, fileNamu, folderu, OutNameNoExt)
      showTOOLtip("ERROR: The file of the external application does not seem to exist anymore`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   Try Run, %thisAPPpath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the external application.", 0, 0, "error")
}

incDecSlidesSpeed(direction) {
   If (direction=1)
      IncreaseSlideSpeed()
   Else
      DecreaseSlideSpeed()
}

resetSlideshowTimer(dummy:=0, ignoreEasyStop:=0) {
   ; DestroyGIFuWin()
   If (slideShowRunning!=1)
      Return

   If (easySlideStoppage=1 && slideShowRunning=1 && ignoreEasyStop=0)
      ToggleSlideShowu("stop", 0)
   Else If (slideShowRunning=1)
      ToggleSlideShowu("start", 1)
}

showSlideShowInfosNow(showProgress) {
   friendly := (slideShowRunning=1) ? "RUNNING" : "STOPPED"
   delayu := DefineSlidesRate()
   etaTime := "Estimated time: " EstimateSlideShowLength()
   proggy := (showProgress=1) ? slideShowDelay/59125 : 0
   showTOOLtip("Slideshow speed: " delayu "`nTotal files: " groupDigits(maxFilesIndex) "`n" etaTime "`nSlideshow: " friendly, "incDecSlidesSpeed", 2, proggy)
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

IncreaseSlideSpeed() {
   If (slideShowDelay<1000)
   {
      slideShowDelay += 300
   } Else
   {
      slideShowDelay += 1000
      If (slideShowDelay>59000)
         slideShowDelay := 59000
   }

   resetSlideshowTimer(0, 1)
   showSlideShowInfosNow(1)
   INIaction(1, "slideShowDelay", "General")
   Sleep, 5
}

DecreaseSlideSpeed() {
   If (slideShowDelay<1001)
   {
      slideShowDelay -= 300
      If (slideShowDelay<200)
         slideShowDelay := 100
   } Else
   {
      slideShowDelay -= 1000
   }

   resetSlideshowTimer(0, 1)
   showSlideShowInfosNow(1)
   INIaction(1, "slideShowDelay", "General")
   Sleep, 5
}

fileSizeFrienly(bytez) {
  totalSize := Round(bytez/1024, 2)
  If (totalSize>1023)
  {
     totalSize := Round(totalSize/1024, 1)
     If (totalSize>1023.9)
        totalSize := Round(totalSize/1024, 1) " GB"
     Else totalSize := totalSize " MB"

  } Else totalSize := Round(totalSize) " KB"

  Return totalSize
}

CalculateSelectedFilesSizes() {
  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  getSelectedFiles(0, 1)
  If !markedSelectFile
  {
     showTOOLtip("WARNING: No files currently selected to calculate the total size for")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  showTOOLtip("Calculating total size for selected file entries, please wait")
  prevMSGdisplay := A_TickCount
  startOperation := A_TickCount
  doStartLongOpDance()
  maxCdate := maxMdate := maxSizeu := 0
  minCdate := minMdate := minSizeu := 99999999999999
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  Loop, % maxFilesIndex
  {
     isSelected := resultedFilesList[A_Index, 2]
     If (isSelected!=1)
        Continue

     executingCanceableOperation := A_TickCount
     If (determineTerminateOperation()=1)
     {
        abandonAll := 1
        Break
     }

     countFiles++
     If (A_TickCount - prevMSGdisplay>1000)
     {
        etaTime := ETAinfos(countFiles, markedSelectFile, startOperation)
        If failedFiles
           etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

        showTOOLtip("Calculating total files size, please wait" etaTime, 0, 0, countFiles/markedSelectFile)
        prevMSGdisplay := A_TickCount
     }

     fileInfos := GetFileAttributesEx(resultedFilesList[A_Index, 1])
     If !fileInfos.size
     {
        failedFiles++
        Continue
     }

     totalSize += fileInfos.size
     minSizeu := min(minSizeu, fileInfos.size)
     maxSizeu := max(maxSizeu, fileInfos.size)
     minMdate := min(minMdate, fileInfos.wtime)
     maxMdate := max(maxMdate, fileInfos.wtime)
     minCdate := min(minCdate, fileInfos.ctime)
     maxCdate := max(maxCdate, fileInfos.ctime)
  }
  ; ToolTip, % minCdate , , , 2
  totalSize := fileSizeFrienly(totalSize)
  minSizeu := fileSizeFrienly(minSizeu)
  maxSizeu := fileSizeFrienly(maxSizeu)
  CurrentSLD := backCurrentSLD
  Try FormatTime, minCdate, % minCdate, dd/MM/yyyy, HH:mm
  Try FormatTime, maxCdate, % maxCdate, dd/MM/yyyy, HH:mm
  Try FormatTime, minMdate, % minMdate, dd/MM/yyyy, HH:mm
  Try FormatTime, maxMdate, % maxMdate, dd/MM/yyyy, HH:mm
  If (abandonAll=1)
     someErrors := "Operation aborted by user`n"
  showTOOLtip(someErrors "Details for " groupDigits(countFiles) " selected files:`nTotal size: " totalSize "`nFile sizes range: " minSizeu " - " maxSizeu "`nDate modified: " minMdate " - " maxMdate "`nDate created: " minCdate " - " maxCdate)
  SetTimer, ResetImgLoadStatus, -200
  SetTimer, RemoveTooltip, % -msgDisplayTime * 2
}

CopyImageFileNames() {
   CopyImagePath("files")
}

CopyImageFolderPaths() {
   CopyImagePath("dirs")
}

CopyImagePath(modus:=0, extras:=0) {
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   getSelectedFiles(0, 1)
   If !markedSelectFile
   {
      imgPath := getIDimage(currentFileIndex)
      If (!imgPath || !currentFileIndex)
         Return
 
      imgPath := StrReplace(imgPath, "||")
      zPlitPath(imgPath, 0, fileNamu, folderu)
      If (modus="dirs")
         Try Clipboard := folderu
      Else If (modus="files")
         Try Clipboard := fileNamu
      Else
         Try Clipboard := imgPath
      Catch wasError
          Sleep, 1
 
      folderu := PathCompact(folderu, "a", 1, OSDfontSize)
      thisu := (modus="dirs") ? folderu "\" : fileNamu "`n" folderu "\"
      If (modus="files")
         thisu := fileNamu

      If (userPrivateMode=1)
         thisu := "****************"

      infoText := wasError ? "ERROR: Failed to copy to clipboard as text the active entry" : "The active entry was copied to clipboard as text"
      showTOOLtip(infoText "`n" thisu)
      If InStr(infoText, "error: failed")
         SoundBeep 300, 100 

      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   counter := 0
   listu := ""
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalSelected := markedSelectFile
   itemsList := new hashtable()
   Loop, % maxFilesIndex
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(counter, totalSelected, startOperation)
          showTOOLtip("Processing the list to copy selected index entries" etaTime, 0, 0, counter/totalSelected)
          prevMSGdisplay := A_TickCount
       }
       
       If !resultedFilesList[A_Index, 2]
          Continue

       imgPath := StrReplace(resultedFilesList[A_Index, 1], "||")
       If imgPath
       {
          If (modus="dirs")
             zPlitPath(imgPath, 1, OutFileName, imgPath)
          Else If (modus="files")
             zPlitPath(imgPath, 1, imgPath, OutDir)

          If (modus="dirs" || modus="files")
          {
             t := Format("{:L}", imgPath)
             If itemsList[t]
                Continue

             itemsList[t] := 1
          }

          counter++
          listu .= imgPath "`n"
       }
   }

    itemsList := ""
    If !listu
       Return
 
    friendly := (modus="dirs") ? "containing folders" : "complete paths"
    If (modus="files")
       friendly := "file names"

    Try Clipboard := listu
    Catch wasError
          Sleep, 1

    If wasError
    {
       showTOOLtip("Failed to copy to clipboard as text the " friendly)
       SoundBeep , 300, 100
    } Else showTOOLtip(groupDigits(counter) " selected " friendly " copied to clipboard as text")

    SetTimer, RemoveTooltip, % -msgDisplayTime
    ResetImgLoadStatus()
}

MenuExplorerCopyFiles() {
    CopyMoveFilesExplorer("copy")
}

MenuExplorerCutFiles() {
    destroyGDIfileCache()
    CopyMoveFilesExplorer("cut")
}

MenuExplorerCopyContainFolder() {
    CopyMoveFilesExplorer("copy", "folderu")
}

MenuExplorerCutContainFolder() {
    destroyGDIfileCache()
    CopyMoveFilesExplorer("cut", "folderu")
}

CopyMoveFilesExplorer(userOption:="copy", onWhat:=0) {
  userOption := (userOption="cut") ? "CUT" : "COPY"
  If (currentFileIndex=0)
     Return

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  friendly := (onWhat="folderu") ? "folder" : "file"
  showTOOLtip("Copying " friendly "(s) to clipboard")
  getSelectedFiles(0, 1)
  newFilesList := []
  countTFilez := 0
  If (markedSelectFile>1)
  {
     itemsList := new hashtable()
     Loop, % maxFilesIndex
     {
        If !resultedFilesList[A_Index, 2]
           Continue

        imgPath := StrReplace(resultedFilesList[A_Index, 1], "||")
        If StrLen(imgPath)<4
           Continue

        If (onWhat="folderu")
        {
           imgPath := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
           t := Format("{:L}", imgPath)
           If itemsList[t]
              Continue

           itemsList[t] := 1
        }

        countTFilez++
        newFilesList[countTFilez] := imgPath
     }

     If countTFilez
     {
        modus := (onWhat="folderu") ? 1 : 0
        dataHandle := ClipboardSetFiles(newFilesList, userOption, modus)
        Sleep, 5
        testClipType := IsClipboardFormatAvailable(15)
        infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to store the selected " friendly "s into the clipboard" : userOption " was applied on " groupDigits(countTFilez) A_Space friendly "s.`nThese can now be pasted in any file manager or in QPV."
        showTOOLtip(infoText)
        SoundBeep, % InStr(infoText, "error") ? 300 : 900, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     } Else markedSelectFile := 0
  }

  imgPath := Trimmer(StrReplace(getIDimage(currentFileIndex), "||"))
  If (!imgPath || !currentFileIndex)
     Return

  zPlitPath(imgPath, 0, fileNamu, folderu)
  If (onWhat="folderu")
     newFilesList[1] := folderu
  Else
     newFilesList[1] := imgPath

  modus := (onWhat="folderu") ? 1 : 0
  dataHandle := ClipboardSetFiles(newFilesList, userOption, modus)
  Sleep, 5
  Try testClipType := IsClipboardFormatAvailable(15)
  infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to set " friendly " to clipboard" : userOption " [Explorer] was applied on the " friendly " `n"
  showTOOLtip(infoText fileNamu "`n" folderu "\")
  SoundBeep, % InStr(infoText, "error") ? 300 : 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

throwErrorNoImageLoaded(noMSG:=0, stringent:=1) {
   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   stringent := (stringent=1) ? 0 : FileRexists(imgPath)
   If (StrLen(whichBitmap)<3 && !stringent || !imgPath)
   {
      If (noMSG=0)
      {
         showTOOLtip("WARNING: No image file is currently loaded")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime//2
      }
      Return "fail"
   }
}

CopyImage2clip() {
  If (thumbsDisplaying=1)
     Return "fail"

  If throwErrorNoImageLoaded()
     Return "fail"

  whichBitmap := useGdiBitmap()
  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  friendly := (editingSelectionNow=1) ? " selected area" : ""
  If (editingSelectionNow=1 && StrLen(whichBitmap)>2)
  {
     If throwErrorSelectionOutsideBounds(whichBitmap)
        Return "fail"
  }

  setImageLoading()
  If StrLen(whichBitmap)>2
  {
     showTOOLtip("Copying image" friendly " to clipboard, please wait")
     If (editingSelectionNow=1)
        zBitmap := getSelectedImageArea(whichBitmap, 1, 0, 2, 0)
     Else
        zBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, whichBitmap)))

     If StrLen(zBitmap)>2
     {
        hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, zBitmap)
        r := hBitmap ? Gdip_SetBitmapToClipboard(zBitmap, hBitmap) : addJournalEntry("get_last_err")
        ; If (zBitmap!=whichBitmap)
           trGdip_DisposeImage(zBitmap, 1)
     } Else r := "fail"
  } Else r := "fail"

  SetTimer, ResetImgLoadStatus, -100
  If r
     showTOOLtip("Failed to copy the image to clipboard`nError code: " r)
  Else
     showTOOLtip("Image" friendly " copied to clipboard")

  SoundBeep, % r ? 300 : 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return r
}

ViewAlphaMaskNow() {
   Static lastInvoked := 1
   If (thumbsDisplaying=1)
      Return

   If (!(isAlphaMaskWindow()=1 || isAlphaMaskPartialWin()=1) && imgEditPanelOpened=1 && AnyWindowOpen)
   {
      showTOOLtip("WARNING: The current tool does not support alpha masks")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (isNowAlphaPainting() && isAlphaMaskWindow() && AnyWindowOpen!=70)
   {
      forceLiveAlphaPreviewMode := !forceLiveAlphaPreviewMode
      corelivePreviewsImageEditing()
      Return
   }

   SetTimer, RemoveTooltip, Off
   If (A_TickCount - lastInvoked<350)
   {
      SetTimer, dummyViewAlphaMaskNow, Off
      SetTimer, PanelSoloAlphaMasker, -200
      lastInvoked := A_TickCount
      Return
   }
   lastOSDtooltipInvoked := A_TickCount
   SetTimer, dummyViewAlphaMaskNow, -70
   lastInvoked := A_TickCount
}

ResizeAlphaMask2sel() {
   If StrLen(userAlphaMaskBmpPainted)<2
   {
      showTOOLtip("WARNING: There is no user painted alpha mask available")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   If (imgSelW<5 || imgSelH<5 || !imgSelW || !imgSelH)
   {
      showTOOLtip("ERROR: Invalid selection area")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, userAlphaMaskBmpPainted, imgSelW, imgSelH, 0, 7, -1)
   If StrLen(alphaMaskGray)>2
   {
      userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted, 1)
      userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
      userAlphaMaskBmpPainted := alphaMaskGray
      UItriggerBrushUpdate(1, 5)
      showTOOLtip("Alpha mask bitmap resized to:`n" groupDigits(imgSelW) " x " groupDigits(imgSelH) " (" Round(imgSelW/imgSelH, 2) ")")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      showTOOLtip("ERROR: Failed to resize the alpha mask bitmap")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

FlipHalphaMask() {
   coreFlipuAlphaMask(4)
}

FlipValphaMask() {
   coreFlipuAlphaMask(6)
}

coreFlipuAlphaMask(modus) {
   If StrLen(userAlphaMaskBmpPainted)<2
   {
      showTOOLtip("WARNING: There is no user painted alpha mask available")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   Gdip_ImageRotateFlip(userAlphaMaskBmpPainted, modus)
   UItriggerBrushUpdate(1, 5)
   showTOOLtip("Alpha mask bitmap flipped")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyViewAlphaMaskNow() {
   If (thumbsDisplaying=2)
      Return

   infoMask := defineCurrentAlphaMask()
   If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
   {
      showDelayedTooltip("WARNING: No alpha mask has been defined")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   SetTimer, RemoveTooltip, Off
   lastOSDtooltipInvoked := A_TickCount
   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
   ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
   toolTipGuiCreated := 2
   SkeletDrawSelectionBox(1)
   Gdip_ResetWorldTransform(2NDglPG)
   lastOSDtooltipInvoked := A_TickCount
   toolTipGuiCreated := 2
}

RasterizeAlphaMaskNow(allowAsk:="yes") {
   CopyAlphaMask2clippy("rasterize", allowAsk)
}

CopyAlphaMask2clippy(modus:=0, allowAsk:=0) {
  If (thumbsDisplaying=1)
     Return

  If throwErrorNoImageLoaded()
     Return 

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  infoMask := defineCurrentAlphaMask()
  If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
  {
     showTOOLtip("WARNING: There is no defined alpha mask")
     SoundBeep 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  If InStr(infoMask, "user painted")
  {
     Gdip_GetImageDimensions(userAlphaMaskBmpPainted, vPimgSelW, vPimgSelH)
  } Else If InStr(infoMask, "main image")
  {
     Gdip_GetImageDimensions(useGdiBitmap(), vPimgSelW, vPimgSelH)
  } Else If InStr(infoMask, "transformed")
  {
     Gdip_GetImageDimensions(userClipBMPpaste, vPimgSelW, vPimgSelH)
  } Else
  {
     If (editingSelectionNow!=1)
     {
        ToggleEditImgSelection()
        If (modus="rasterize")
           SetTimer, RasterizeAlphaMaskNow, -250
        Else
           SetTimer, CopyAlphaMask2clippy, -250
        Return
     }

     vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
     vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
  }

  alphaMaskGray := generateAlphaMaskBitmap(0, 0, vPimgSelW, vPimgSelH, 0, 0, 0, 1)
  If StrLen(alphaMaskGray)>2
  {
     pEffectGray := Gdip_CreateEffect(6, 0, -100, 0)
     pEffectInvert := Gdip_CreateEffect(7, 0, 0, 100)
     If (alphaMaskingMode=5 && alphaMaskBMPchannel!=5)
        Gdip_BitmapApplyEffect(alphaMaskGray, pEffectGray)
     If (alphaMaskColorReversed=1)
        Gdip_BitmapApplyEffect(alphaMaskGray, pEffectInvert)

     If (modus="rasterize")
     {
        userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
        userPrevAlphaMaskBmpPainted := userAlphaMaskBmpPainted
        r := 1
        If (StrLen(userAlphaMaskBmpPainted)>2 && allowAsk!="no-ask")
           r := PanelOfferAlphaMaskMerger(userAlphaMaskBmpPainted, alphaMaskGray)
        Else
           userAlphaMaskBmpPainted := alphaMaskGray

        If (r=1)
        {
           alphaMaskingMode := 5
           alphaMaskClrAintensity := 128
           keepUserPaintAlphaMask := alphaMaskBMPchannel := alphaMaskRefBMP := alphaMaskGradientScale := 1
           alphaMaskClrBintensity := alphaMaskGradientAngle := alphaMaskReplaceMode := alphaMaskColorReversed := 0
           If (isAlphaMaskWindow()=1 && imgEditPanelOpened=1)
           {
              GuiControl, SettingsGUIA:, alphaMaskClrAintensity, 128
              GuiControl, SettingsGUIA:, alphaMaskClrBintensity, 0
              GuiControl, SettingsGUIA:, alphaMaskGradientScale, 1
              GuiControl, SettingsGUIA:, alphaMaskGradientAngle, 0
              GuiControl, SettingsGUIA:, alphaMaskColorReversed, 0
              GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 5
              GuiControl, SettingsGUIA: Choose, alphaMaskRefBMP, 1
              GuiControl, SettingsGUIA: Choose, alphaMaskBMPchannel, 1
              realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
              generateAlphaMaskBitmap("kill", 0)
              UItriggerBrushUpdate(1)
           }
        }
     } Else
     {
        hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, alphaMaskGray)
        r := (hBitmap!="") ? Gdip_SetBitmapToClipboard(alphaMaskGray, hBitmap) : addJournalEntry("get_last_err")
     }

     Gdip_DisposeEffect(pEffectGray)
     Gdip_DisposeEffect(pEffectInvert)
  } Else r := (modus="rasterize") ? "" : "unknown error"

  generateAlphaMaskBitmap("kill", 0)
  SetTimer, ResetImgLoadStatus, -100
  If (modus="rasterize")
  {
     If (r=2)
        showTOOLtip("The alpha mask was not changed. User abandoned the procedure.")
     Else If !r
        showTOOLtip("Failed to rasterize the alpha mask")
     Else
        showTOOLtip("Alpha mask rasterized as user painted bitmap`nOriginal mask type: " infoMask)
     SoundBeep, % !r ? 300 : 900, 100
  } Else
  {
     If r
        showTOOLtip("Failed to copy the alpha mask bitmap to clipboard`nError code: " r)
     Else
        showTOOLtip("Alpha mask copied to clipboard`nMask type: " infoMask)
     SoundBeep, % r ? 300 : 900, 100
  }

  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return r
}

PanelOfferAlphaMaskMerger(oldBitmap, newBitmap) {
   Static blends := {1:0, 2:2, 3:3, 4:6, 5:7, 6:10, 7:16}

   widthu := (PrefsLargeFonts=1) ? 900 : 600
   msgResult := msgBoxWrapper("Merge alpha masks: " appTitle, "It seems you already have a user painted bitmap as alpha mask. Would you like to blend it with the new generated bitmap or just replace it?", "&Proceed|&Cancel", 1, "image", nullCheckBox, 0, "", "" ,, 1, widthu, "Replace bitmap (no blending)`f`fDarken (substractive)`fMultiply (substractive)`fLighten (additive)`fScreen (additive)`fOverlay (mixed)`fExclusion (mixed)", 2)
   If InStr(msgResult.btn, "proceed")
   {
      thisu := blends[msgResult.2ndlist]
      If !thisu
      {
         userAlphaMaskBmpPainted := newBitmap
         Return 1
      }

      Gdip_GetImageDimensions(newBitmap, w, h)
      Gdip_GetImageDimensions(oldBitmap, w2, h2)
      If (w2!=w || h2!=h) && (w && h && w2 && h2)
         zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oldBitmap, w, h, 0, 3)
      Else
         zBitmap := trGdip_CloneBitmap(A_ThisFunc, oldBitmap)

      ; fnOutputDebug(A_ThisFunc "() " w "=" w2 "||" h "=" h2)
      ; fnOutputDebug(A_ThisFunc "(): l=" thisu " | " msgResult.2ndlist)
      QPV_BlendBitmaps(zBitmap, newBitmap, thisu, 0)
      userAlphaMaskBmpPainted := zBitmap
      trGdip_DisposeImage(newBitmap, 1)
      Return 1
   } Else
   {
      userAlphaMaskBmpPainted := userPrevAlphaMaskBmpPainted
      userPrevAlphaMaskBmpPainted := ""
      Return 2
   }
}

SetImageAsAlphaMask() {
  If (thumbsDisplaying=1)
     Return

  If throwErrorNoImageLoaded()
     Return 

  If throwErrorSelectionOutsideBounds()
     Return

  whichBitmap := useGdiBitmap()
  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  r := 1
  friendly := (editingSelectionNow=1) ? " selected area " : ""
  setImageLoading()
  If StrLen(whichBitmap)>2
  {
     obju := []
     obju[1] := [VPselRotation, EllipseSelectMode, innerSelectionCavityX, innerSelectionCavityY]
     VPselRotation := EllipseSelectMode := innerSelectionCavityX := innerSelectionCavityY :=  0
     showTOOLtip("Processing image" friendly ", please wait")
     If (editingSelectionNow=1)
     {
        zBitmap := getSelectedImageArea(whichBitmap, 0, 0, 1, 0)
        ; flipBitmapAccordingToViewPort(zBitmap)
     } Else zBitmap := applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, whichBitmap))

     EllipseSelectMode := obju[1, 1]
     VPselRotation := obju[1, 2]
     innerSelectionCavityX := obju[1, 3]
     innerSelectionCavityY := obju[1, 4]
     If StrLen(zBitmap)>2
     {
        Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
        isOutside := (imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH)
        userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
        userPrevAlphaMaskBmpPainted := userAlphaMaskBmpPainted
        If (currIMGdetails.HasAlpha=1 || isOutside=1)
        {
           ; eliminate transparency
           Gdip_BitmapConvertFormat(zBitmap, 0x21808, 2, 1, 0, 0, 0, 0, 0)
           Gdip_BitmapConvertFormat(zBitmap, 0xE200B, 2, 1, 0, 0, 0, 0, 0)
        }

        If StrLen(userAlphaMaskBmpPainted)>2
           z := PanelOfferAlphaMaskMerger(userAlphaMaskBmpPainted, zBitmap)
        Else
           userAlphaMaskBmpPainted := zBitmap

        r := 0
        If (z!=2)
           keepUserPaintAlphaMask := 1
     } Else r := "fail"
  } Else r := "fail"

  SetTimer, ResetImgLoadStatus, -100
  friendly := (editingSelectionNow=1) ? "selected area " : ""
  If (z=2)
  {
     showTOOLtip("The alpha mask was not changed. User abandoned the procedure.")
  } Else If (r || StrLen(userAlphaMaskBmpPainted)<3)
  {
     showTOOLtip("Failed to set image " friendly "as alpha mask")
  } Else
  {
     alphaMaskRefBMP := alphaMaskGradientScale := 1
     alphaMaskingMode := alphaMaskBMPchannel := 5
     alphaMaskColorReversed := 0
     alphaMaskClrAintensity := 128
     alphaMaskClrBintensity := alphaMaskGradientAngle := alphaMaskReplaceMode := 0
     If (isAlphaMaskWindow()=1 && imgEditPanelOpened=1)
     {
        GuiControl, SettingsGUIA:, alphaMaskClrAintensity, 128
        GuiControl, SettingsGUIA:, alphaMaskClrBintensity, 0
        GuiControl, SettingsGUIA:, alphaMaskGradientScale, 1
        GuiControl, SettingsGUIA:, alphaMaskGradientAngle, 0
        GuiControl, SettingsGUIA:, alphaMaskReplaceMode, 0
        GuiControl, SettingsGUIA:, alphaMaskColorReversed, 0
        GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 5
        GuiControl, SettingsGUIA: Choose, alphaMaskRefBMP, 1
        GuiControl, SettingsGUIA: Choose, alphaMaskBMPchannel, 5
        UItriggerBrushUpdate(1)
        realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
        livePreviewsImageEditing()
     }

     generateAlphaMaskBitmap("kill", 0)
     Gdip_GetImageDimensions(userAlphaMaskBmpPainted, w, h)
     showTOOLtip("Image " friendly "is set as alpha mask`nDimensions: " groupDigits(w) " x " groupDigits(h) " (" Round(w/h, 2) ")")
  }

  SoundBeep, % r ? 300 : 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return r
}

invertCurrentFolderRecursiveness() {
   If (RegExMatch(CurrentSLD, sldsPattern) || !CurrentSLD)
      Return

   isPipe := InStr(CurrentSLD, "|") ? 1 : 0
   CurrentSLD := StrReplace(CurrentSLD, "|")
   DynamicFoldersList := StrReplace(DynamicFoldersList, "|")
   If (isPipe!=1)
   {
      CurrentSLD := "|" CurrentSLD
      DynamicFoldersList := "|" DynamicFoldersList
   }

   RefreshFilesList()
}

MenuRemFilesListFilter() {
   remFilesListFilter()
   ; SetTimer, RandomPicture, -150
   dummyTimerDelayiedImageDisplay(50)
}

remFilesListFilter(dummy:=0) {
   If (dummy="simple")
   {
      addJournalEntry("Removing files list filter:`n" filesFilter)
      prevFilter := filesFilter
      filesFilter := ""
      resultsDupesArray := []
      FilterFilesIndex(0, 0, prevFilter)
      currentFileIndex := clampInRange(bckpCurrentFileIndex, 1, maxFilesIndex)
   } Else coreEnableFiltru("")
}


dummyTimerReloadThisPicture(timeru:=0) {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If (timeru>1)
     SetTimer, extraDummyReloadThisPicture, % -timeru, 950
}

extraDummyReloadThisPicture() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyReloadThisPicture, -15
     Return
  }
  ReloadThisPicture()
}

determineLClickstate() {
   If (slideShowRunning=1)
      Return 0

   LbtnDwn := interfaceThread.ahkgetvar.LbtnDwn
   If (GetKeyState("LButton") || LbtnDwn=1)
      Return 1
   Else
      Return 0
}

ReloadThisPicture() {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
  {
     delayu := (A_TickCount - prevFastDisplay < 500) ? 90 : 550
     If (determineLClickstate()=1 || GetKeyState("Space", "P"))
     {
        dummyTimerReloadThisPicture(delayu)
        Return
     }

     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing(1)
  }
}

coreReloadThisPicture() {
  If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
  {
     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing(1)
  }
}

FirstPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := 1
   dummyTimerDelayiedImageDisplay(50)
}

LastPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=maxFilesIndex)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := maxFilesIndex
   dummyTimerDelayiedImageDisplay(50)
}

SettingsGUIAGuiClose:
SettingsGUIAGuiEscape:
   CloseWindow()
Return

OSDguiToolbarGuiClose:
   WinGetPos, X, Y, Width, Height, ahk_id %hQPVtoolbar%
   If (x && y)
   {
      UserToolbarX := x
      UserToolbarY := y
   }

   toggleAppToolbar()
Return

doCleanup:
   TrueCleanup()
Return

TrueCleanup(mustExit:=1) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 900) || (hasInitSpecialMode=1)
      Return

   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
      seenImagesDB.Exec("COMMIT TRANSACTION;")

   activeSQLdb.CloseDB()
   seenImagesDB.CloseDB()
   If AnyWindowOpen
      BtnCloseWindow()

   Sleep, 10
   WinSet, Region, 0-0 w1 h1, ahk_id %PVhwnd%
   RegWrite, REG_SZ, %QPVregEntry%, Running, 0

   lastInvoked := A_TickCount
   RemoveTooltip()
   DestroyGIFuWin()
   Sleep, 1
   If (wasInitFIMlib=1)
      FreeImage_FoxInit(0) ; Unload Dll

   disposeCacheIMGs()
   destroyGDIfileCache()
   discardViewPortCaches()
   terminateIMGediting()
   trGdip_DisposeImage(userAlphaMaskBmpPainted)
   trGdip_DisposeImage(userPrevAlphaMaskBmpPainted)
   Gdip_DeleteBrush(pBrushWinBGR)
   Gdip_DeleteBrush(pBrushHatch)
   Gdip_DeleteBrush(pBrushHatchLow)
   Gdip_DeleteBrush(pBrushA)
   Gdip_DeleteBrush(pBrushB)
   Gdip_DeleteBrush(pBrushC)
   Gdip_DeleteBrush(pBrushD)
   Gdip_DeleteBrush(pBrushE)
   Gdip_DeleteBrush(pBrushF)
   Gdip_DeleteBrush(pBrushZ)
   Gdip_DeleteBrush(OSDwinFadedBrushBGR)
   Gdi_DeleteObject(gdiAmbientalTexBrush)
   Gdi_DeleteObject(GDIbrushWinBGR)
   Gdip_DeletePen(pPen1d)
   Loop, 7
      Gdip_DeletePen(pPen%A_Index%)

   mainGdipWinThumbsGrid(1)
   destroyGDIPcanvas()
   Sleep, 1
   GDIPToken := Gdip_Shutdown(GDIPToken)
   lastInvoked := A_TickCount
   ; If (mustExit=1)
   ;    writeMainSettings()
   lastInvoked := A_TickCount
   fnOutputDebug("Proper exit. Main thread. PID=" QPVpid)
   ForceExitNow("yay")
}

ForceExitNow(dummy:=0) {
   If GDIPToken
      Gdip_Shutdown(GDIPToken)  
   Sleep, 5
   If (dummy!="yay")
      fnOutputDebug("Forced exit. Main thread. PID=" QPVpid)
   Process, Close, % QPVpid
   ExitApp
}

dummySetWindowTitle() {
    setWindowTitle("lol", 0, 1)
}

setWindowTitle(msg, forceThis:=0, useLast:=0) {
    Static prevSet, prevMsg, lastInvoked := 1
    If (A_TickCount - zeitSillyPrevent<200) || (drawingShapeNow=1)
       Return

    msg := StrReplace(msg, "`n", " | ")
    If (userPrivateMode=1)
    {
       msg := RegExReplace(msg, "im)(\|.*\|)", "|")
       msg := RegExReplace(msg, "im)(\].*\|)", "|")
    }

    If (useLast!=1)
       addJournalEntry("WinTitle: " msg)

    infoSlideDelay := (slideShowRunning=1 && slideShowDelay<2950) ? 1 : 0
    thisMsg := (useLast=1 && StrLen(prevMsg)>3) ? prevMsg : msg
    If (useLast!=1)
       prevMsg := msg

    If (A_TickCount - lastInvoked<200) && (useLast!=1 && forceThis!=1)
    {
       SetTimer, dummySetWindowTitle, -350
       Return
    }

    If (prevSet!=thisMsg && runningLongOperation!=1 && infoSlideDelay=0 && animGIFplaying!=1 && hasInitSpecialMode!=1) || (forceThis=1)
    {
       prevSet := thisMsg
       WinSetTitle, ahk_id %PVhwnd%,, % thisMsg " | QPV"
       ; fnOutputDebug("WinTitle: " thisMsg)
       lastInvoked := A_TickCount
    }
}

TulTip(debugger, sep, params*) {
    str := ""
    For index,param in params
        str .= "[" A_Index "]" param . sep
    
    If debugger
       fnOutputDebug(debugger ": " str)
    Else
       ToolTip, % str , , , 2
}

fnOutputDebug(msg) {
   Static prevMsg

   If (debugModa=1)
   {
      If (prevMsg!=msg && slideShowRunning!=1 && slideShowDelay>300)
      {
         If (InStr(msg, "Thumb") && thumbsDisplaying=1)
            Return

         prevMsg := msg
         msg := StrReplace(msg, "User journal: wintitle:", "WinTitle:")
         msg := StrReplace(msg, "User journal: dialog box:", "Dialog box:")
         msg := StrReplace(msg, "User journal: osd:", "OSD:")
         OutputDebug, % "QPV: " Trim(msg)
      }
   }
}

MenuDummyToggleThumbsMode() {
   lastOtherWinClose := 5
   ToggleThumbsMode()
}

initAHKhThumbThreads() {
    Static multiCoreInit := 0

    If (multiCoreInit=1 || allowMultiCoreMode!=1 || minimizeMemUsage=1)
       Return

    addJournalEntry("Attempting to initialize " realSystemCores " threads for thumbnails generation")
    initFIMGmodule()
    If (FIMfailed2init=1)
    {
       addJournalEntry("Failed to initialize the auxiliary threads because FreeImage failed to initialize")
       multiCoreThumbsInitGood := 0
    } Else
    {
       ; SoundBeep 300, 100
       If A_IsCompiled
          r := GetRes(dataFile, 0, "MODULE-FIM-THUMBS.AHK", "LIB")

       Loop, % realSystemCores
       {
           If IsObject(thumbThread%A_Index%)
              Continue

           If !A_IsCompiled
              thumbThread%A_Index% := ahkthread("#Include *i Lib\module-fim-thumbs.ahk")
           Else If r
              thumbThread%A_Index% := ahkThread(StrGet(&dataFile, r, "utf-8"))

           Sleep, 1
       }

       Loop, % realSystemCores
       {
           goodInit += thumbThread%A_Index%.ahkFunction("initThisThread", GDIPToken "|" mainCompiledPath "|" imgQuality "|" A_Index "|" WICmoduleHasInit)
           Sleep, 1
       }

       multiCoreThumbsInitGood := (goodInit = realSystemCores) ? 1 : 0
       If (multiCoreThumbsInitGood=1)
          addJournalEntry("Succesfully initialized " goodInit " threads.")
       Else
          addJournalEntry("Failed to initialize the auxiliary threads (unknown cause).")
    }

    multiCoreInit := 1
}

getFolderDetails(pathu) {
   FileGetTime, fileMdate, % pathu, M
   FileGetTime, fileCdate, % pathu, C
   FileGetAttrib, fileAttribs, % pathu
   thisFolderDetails := "\" fileMdate "\" fileCdate "\" fileAttribs "\" pathu
   Return thisFolderDetails
}

ToggleThumbsMode() {
   Static multiCoreInit := 0, lastInvoked := 1, prevIndexu
   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (A_TickCount - lastInvoked<190) || (A_TickCount - lastOtherWinClose<190)
   {
      lastInvoked := A_TickCount
      Return
   }

   interfaceThread.ahkPostFunction("mouseTurnOFFtooltip", 1)
   If (StrLen(mustOpenStartFolder)>3 && !ar)
   {
      currentFileIndex := doOpenStartFolder(didSomething)
      If !didSomething
         Return
   } Else If (thumbsDisplaying=1 && currentFileIndex!=imgIndexEditing)
   {
      ar := askAboutFileSave(" and another image will be loaded", 1, 0, "yes")
      If ar
      {
         If (ar=1)
         {
            SetTimer, PanelSaveImg, -350
            currentFileIndex := imgIndexEditing
         } Else Return
      }
   }

   If (SLDtypeLoaded=1 && FolderExist(StrReplace(CurrentSLD, "|")) && watchFolderDetails && maxFilesIndex>1 && thumbsDisplaying!=1)
   {
      thisFolderDetails := getFolderDetails(StrReplace(CurrentSLD, "|"))
      IF (thisFolderDetails!=watchFolderDetails && !markedSelectFile)
      {
         msgResult := msgBoxWrapper(appTitle ": Folder changed", "The folder currently opened seems to have been changed. Would you like to reload it?", 4, 0, "question")
         If InStr(msgResult, "yes")
            RefreshFilesList()
      }
      watchFolderDetails := thisFolderDetails
   }

   lastInvoked := A_TickCount
   If (maxFilesIndex<1 && thumbsDisplaying!=1)
   {
      showTOOLtip("WARNING: Insufficient indexed files to activate the list view mode")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   interfaceThread.ahkassign("lastCloseInvoked", 0)
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   thisIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIselectWin)
   If (thumbsDisplaying=1)
   {
      lastTimeToggleThumbs := A_TickCount
      fnOutputDebug("Deactivating thumbs mode")
      If (thisIndexu!=prevIndexu)
         FadeMainWindow()

      thumbsDisplaying := 0
      Global lastOtherWinClose := A_TickCount
      ; fnOutputDebug("Showing hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("show", hGDIwin)
      uiPanelOpenCloseEvent()
      ; fnOutputDebug("Hiding hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("hide", hGDIthumbsWin)
      fnOutputDebug("Image view initialized")
      dummyTimerDelayiedImageDisplay(50)
      interfaceThread.ahkPostFunction("uiAccessUpdateUiStatusBar", 0, 0, "image")
      If hSNDmediaFile
         MCI_Resume(hSNDmedia)
      lastTimeToggleThumbs := A_TickCount
   } Else If (CurrentSLD && maxFilesIndex>0)
   {
      initQPVmainDLL()
      SetTimer, extraDummyReloadThisPicture, Off
      SetTimer, extraDummyDelayiedImageDisplay, Off
      lastTimeToggleThumbs := A_TickCount
      fnOutputDebug("Initializing thumbnails/list view mode")
      prevLoadedImageIndex := currentFileIndex
      If (prevIndexu!=thisIndexu && thumbsListViewMode=1)
         CreateOSDinfoLine("Generating thumbnails, please wait", 0, 1)

      prevIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
      If (thumbsListViewMode=1 && !isWinXP)
         initAHKhThumbThreads()

      If (getCaptionStyle(PVhwnd)=1)
         ToggleTitleBaruNow()
      If hSNDmediaFile
         MCI_Pause(hSNDmedia)

      ; fnOutputDebug("Hiding hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("hide", hGDIwin)
      ; fnOutputDebug("Showing hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("show", hGDIthumbsWin)
      thumbsDisplaying := 1
      uiPanelOpenCloseEvent()
      ; fnOutputDebug("Recalculating thumbnail sizes")
      recalculateThumbsSizes()
      interfaceThread.ahkFunction("uiAccessUpdateUiStatusBar", 0, 0, "list", 0, OSDfontSize, maxFilesIndex)
      UpdateThumbsScreen()
      ; fnOutputDebug("hGDIinfosWin cleaned... " hGDIinfosWin "  -- G= " 2NDglPG "  -- hDC= " 2NDglHDC " ")
      clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
      RemoveTooltip()
      lastTimeToggleThumbs := A_TickCount
   }
   SetTimer, createGUItoolbar, -125
   SetTimer, TriggerMenuBarUpdate, -90
   lastInvoked := A_TickCount
}

TriggerMenuBarUpdate(modus:=0) {
   If (showMainMenuBar!=1 && modus!="forced")
      Return

   modus := (StrLen(UserMemBMP)>2 || (maxFilesIndex>0 && CurrentSLD)) ? modus : "welcome"
   If (drawingShapeNow=1)
      modus := "freeform"

   lastMenuBarUpdated := A_TickCount
   ; fnOutputDebug("Updating menu bar")
   ; interfaceThread.ahkassign("thumbsDisplaying", thumbsDisplaying)
   interfaceThread.ahkPostFunction("UpdateMenuBar", modus)
}

defineThumbsAratio() {
  friendly := (thumbsAratio=1) ? "Wide (1.81)" : "Tall (0.48)"
  If (thumbsAratio=3)
     friendly := "Square (1.00)"

  Return friendly
}

recalculateThumbsSizes() {
   Static theString := "WAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAW"
   , prevDimensions, columnsPossible, txtResH

   If (thumbsAratio=1)
   {
      othumbsW := 300
      othumbsH := 165
   } Else If (thumbsAratio=2)
   {
      othumbsW := 144
      othumbsH := 300
   } Else If (thumbsAratio=3)
   {
      othumbsW := 300
      othumbsH := 300
   }
 
   If (thumbsZoomLevel<0.35)
     thumbsZoomLevel := 0.35
   Else If (thumbsZoomLevel>3)
     thumbsZoomLevel := 3
 
   thumbsH := Round(othumbsH*thumbsZoomLevel)
   thumbsW := Round(othumbsW*thumbsZoomLevel)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If (thumbsH>mainHeight || thumbsW>mainWidth)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//2 - 16, mainHeight//2 - 16, ResizedW, ResizedH)
      If ResizedH
         thumbsH := ResizedH
      If ResizedW
         thumbsW := ResizedW
   }

   If (thumbsColumns>0 && dynamicThumbsColumns=0)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//thumbsColumns, mainHeight, ResizedW, ResizedH)
      z := Round(mainHeight/ResizedH)
      If z
         thumbsH := mainHeight//z
      If ResizedW
         thumbsW := ResizedW

      thumbsW := clampInRange(thumbsW, 80 + Round(OSDfontSize/9), 2048)
      thumbsH := clampInRange(thumbsH, 80 + Round(OSDfontSize/9), 2048)
   }

   If isInRange(max(thumbsW, thumbsH), 0, 150)
      thumbsSizeQuality := 125
   Else If isInRange(max(thumbsW, thumbsH), 151, 290)
      thumbsSizeQuality := 245
   Else If (max(thumbsW, thumbsH)>650)
      thumbsSizeQuality := 755
   Else
      thumbsSizeQuality := 500

   If (thumbsListViewMode>1)
   {
      theseDimensions := "a" mainWidth mainHeight OSDfontSize OSDFontName imgHUDbaseUnit thumbsListViewMode
      If (prevDimensions!=theseDimensions)
      {
         borderSize := imgHUDbaseUnit//5
         txtOptions := "x" borderSize " y" borderSize A_Space " Left cEE090909 r1 s" OSDfontSize//1.25
         thisString := theString "`n" theString
         If (thumbsListViewMode>2)
            thisString .= "`n" theString

         dimensions := Gdip_TextToGraphics(2NDglPG, thisString, txtOptions, OSDFontName, mainWidth, mainHeight, 1, 0)
         txtRes := StrSplit(dimensions, "|")
         txtResW := Ceil(txtRes[3]) + borderSize*2
         txtResH := Ceil(txtRes[4]) + borderSize*2.1
         columnsPossible := Round(mainWidth/txtResW)
         prevDimensions := theseDimensions
      }

      thumbsW := mainWidth//columnsPossible - 5
      thumbsH := Round(txtResH)
   }
}

ToggleThumbsAratio() {
  If (thumbsDisplaying!=1)
     Return

  If (thumbsListViewMode>1)
  {
     ToggleImgNavSizeBox()
     Return
  }

  thumbsAratio++
  If (thumbsAratio>3)
     thumbsAratio := 1

  recalculateThumbsSizes()
  showTOOLtip("Thumbnails intended aspect ratio: " defineThumbsAratio() "`nSize: " thumbsW " x " thumbsH " pixels (" Round(thumbsW/thumbsH, 2) ")" , A_ThisFunc, 1, thumbsAratio/3)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  INIaction(1, "thumbsAratio", "General")
  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(90)
}

ToggleTDupesGroupsFading() {
  If (thumbsDisplaying!=1)
     Return

  recalculateThumbsSizes()
  fadeOtherDupeGroups := !fadeOtherDupeGroups
  friendly := (fadeOtherDupeGroups=2) ? "ACTIVATED" : "DEACTIVATED" 
  showTOOLtip("Fade images not in the active group of duplicates:`n" friendly, A_ThisFunc, 1)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  INIaction(1, "fadeOtherDupeGroups", "General")
  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(90)
}

thumbsInfoYielder(ByRef maxItemsW, ByRef maxItemsH, ByRef maxItemsPage, ByRef maxPages, ByRef startIndex, ByRef mainWidth, ByRef mainHeight) {
   Static prevRealThumbsIndex := -1
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0) ; global vars:
   maxItemsW := mainWidth//thumbsW               ;    prevStartIndex
   If (maxItemsW<4 && thumbsListViewMode=1)
      maxItemsW := mainWidth//Round(thumbsW*0.95)

   maxItemsH := mainHeight//thumbsH              ;    startPageIndex
   If (maxItemsH<7 && thumbsListViewMode=1)
      maxItemsH := mainHeight//Round(thumbsH*0.95)

   If (maxItemsW<2)                                   ;    currentFileIndex ---
      maxItemsW := 1
   If (maxItemsH<2)
      maxItemsH := 1
 
   maxItemsPage := maxItemsW*maxItemsH
   maxPages := Ceil(maxFilesIndex/maxItemsPage)
   If (maxItemsH=1 && maxItemsW>1)
   {
      hasReversed := 1
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   maxItemsLine := maxItemsW ; *maxItemsH
   maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
   If (maxItemsW=1)
   {
      startIndex := Floor(currentFileIndex/maxItemsLine) * maxItemsLine
      If (startIndex<2)
         startIndex := 1

      ; ToolTip, % startIndex  " -- " prevRealThumbsIndex " || " maxItemsW " -- " maxItemsH , , , 2
      If isInRange(startIndex, prevRealThumbsIndex + maxItemsPage*2, prevRealThumbsIndex - maxItemsPage)
      {
         If isInRange(startIndex, prevRealThumbsIndex, prevRealThumbsIndex + maxItemsPage - maxItemsW)
            startIndex := prevRealThumbsIndex
         Else
            startIndex := (startIndex<prevRealThumbsIndex) ? startIndex : startIndex - maxItemsPage + maxItemsW
      } Else startIndex := Floor(currentFileIndex/maxItemsPage) * maxItemsPage

      maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      prevRealThumbsIndex := startIndex
   } Else
   {
      If (prevRealThumbsIndex=-1)
         prevRealThumbsIndex := currentFileIndex - maxItemsPage//2

      minIndex := prevRealThumbsIndex
      minIndex := ((minIndex//maxItemsLine) * maxItemsLine) + 1
      If (prevRealThumbsIndex != minIndex)
         prevRealThumbsIndex := minIndex
      
      maxIndex := prevRealThumbsIndex + maxItemsPage - 1
      ; DebugMsg("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; DebugMsg("diff check: " Abs(currentFileIndex - minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex - maxIndex) " / " maxItemsLine)
      ; fnOutputDebug("min/max Index: " minIndex " / " maxIndex)
      ; fnOutputDebug("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; fnOutputDebug("diff check: " Abs(currentFileIndex - minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex - maxIndex) " / " maxItemsLine)
      If (Abs(currentFileIndex - minIndex) <= maxItemsLine) || (Abs(currentFileIndex - maxIndex) <= maxItemsLine) || (currentFileIndex>=minIndex && currentFileIndex<=maxIndex)
      { ; just scrolling
          If (currentFileIndex<minIndex)     ; scrolling up
          {
             startIndex := prevRealThumbsIndex-maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("1: startIndex: " startIndex)
          } Else If (currentFileIndex>maxIndex) ; scrolling down
          {
             startIndex := prevRealThumbsIndex+maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("2: startIndex: " startIndex)
          } Else  ; when changing img index but not changing pages
          {
             startIndex := prevRealThumbsIndex
             ; fnOutputDebug("3: startIndex: " startIndex)
          }
      } Else ; this is for a jump
      {
         thisIndexu := currentFileIndex/maxFilesIndex
         startIndex := Floor(maxTotalLines*thisIndexu)*maxItemsW
         ; startIndex := ((currentFileIndex//maxItemsLine) * maxItemsLine) + 1
         prevRealThumbsIndex := startIndex
         ; fnOutputDebug("4: startIndex: " startIndex)
      }

      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      ; maxuStartIndex := (maxFilesIndex>maxItemsPage) ? maxFilesIndex - maxItemsPage + 1 : maxFilesIndex - 1
      ; fnOutputDebug(startIndex  "s -- " prevRealThumbsIndex "p -- " maxuStartIndex " || " maxItemsW "w -- h" maxItemsH)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      prevRealThumbsIndex := clampInRange(prevRealThumbsIndex, 1, maxuStartIndex)
   }
   If (hasReversed=1)
   {
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   ; DebugMsg("basics:`r`nmaxItemsPage: " maxItemsPage "`r`nmaxItemsLine: " maxItemsLine "`r`nmin: " minIndex "`r`nmax: " maxIndex "`r`ncurrentFileIndex : " currentFileIndex "`r`n")
   Return "a" startIndex maxItemsW maxItemsH maxItemsPage
}

DeepRefreshThumbsNow() {
   If (thumbsDisplaying!=1 || maxFilesIndex<3)
      Return

   If (markedSelectFile>1)
      setForceRefreshThumbsFilesIndex(1)
   Else
      setForceRefreshThumbsFilesIndex(0)

   dummyTimerDelayiedImageDisplay(50)
}

RefreshThumbsList() {
   mustReloadThumbsList := 1
   dummyTimerDelayiedImageDisplay(50)
}

ForceRefreshNowThumbsList() {
   ; mustReloadThumbsList := 1
   prevStartIndex := -1 ; this will trigger a refresh of the painted thumbnails in the window
   ; dummyTimerDelayiedImageDisplay(50)
}

determineNavKeysDown() {
   If GetKeyState("Up", "P")
      Return 1
   Else If GetKeyState("Down", "P")
      Return 1
   Else If GetKeyState("PgUp", "P")
      Return 1
   Else If GetKeyState("PgDn", "P")
      Return 1
   Else Return 0
}

UpdateThumbsScreen(forceReload:=0) {
   Critical, on
   Static lastInvoked := 1, lastInvokeReload := 1
   If (thumbsDisplaying!=1)
      Return

   SetTimer, dummyTimerDelayiedImageDisplay, Off
   SetTimer, dummyTimerReloadThisPicture, Off
   Gdip_ResetClip(glPG)
   startPageIndex := thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
   createGDIPcanvas(mainWidth, mainHeight)
   Gdip_ResetWorldTransform(glPG)
   IMGlargerViewPort := IMGentirelylargerThanVP := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   moda := modus := 0
   ;  ToolTip, % lastInvokeReload , , , 2
   If ((A_TickCount - prevTryThumbsUpdate<230)) && (mustReloadThumbsList!=1 && startPageIndex!=prevFullIndexThumbsUpdate)
   {
      ; lastInvokeReload++
      modus := (thumbsListViewMode>1) ? 2 : 1
      moda := (thumbsListViewMode>2) ? 1 : 0
      ; If (startPageIndex!=prevFullIndexThumbsUpdate)
      prevFullThumbsUpdate := A_TickCount
      If determineNavKeysDown()
      {
         prevTryThumbsUpdate := A_TickCount
         SetTimer, RefreshThumbsList, -650
      } Else
         SetTimer, RefreshThumbsList, -300
   }

   If (thumbsListViewMode>1 && modus>0)
      QPV_listThumbnailsGridMode(moda, glPG, glHDC, hGDIthumbsWin)

   mainGdipWinThumbsGrid(0, modus)
   If (modus=0 && (prevStartIndex!=startPageIndex || mustReloadThumbsList=1 || forceReload=1))
   {
      r := QPV_ShowThumbnails()
      If r
         prevFullIndexThumbsUpdate := startPageIndex
      
      mustReloadThumbsList := 0
   } ; Else r := 1

   prevStartIndex := startPageIndex
   ; prevRealThumbsIndex := startIndex
   lastInvoked := A_TickCount
}

GDIwindowsPosCorrections(whichHwnd:="") {
    Static lastInvoked := 1
    If (A_OSVersion="WIN_7" || isWinXP=1) && (A_TickCount - lastInvoked>150) || (isWinXP=1 && editingSelectionNow=1)
    {
       GetPhysicalCursorPos(mainX, mainY)
       JEE_ClientToScreen(hPicOnGui1, 1, 1, mainX, mainY)
       If whichHwnd
       {
          WinMove, ahk_id %whichHwnd%,, %mainX%, %mainY%
       } Else
       {
          WinMove, ahk_id %hGDIwin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIthumbsWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIselectWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIinfosWin%,, %mainX%, %mainY%
       }
       lastInvoked := A_TickCount
    } Else If (A_OSVersion="WIN_7" || isWinXP=1)
       SetTimer, GDIwindowsPosCorrections, -50
}

panIMGonScrollBar(doX, doY) {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   ; GetMouseCoord2wind(PVhwnd, oX, oY)
   If (allowFreeIMGpanning=1)
   {
      simplePanIMGonClick("scroll", doX, doY)
      Return
   }
   
   oDx := IMGdecalageX
   oDy := IMGdecalageY
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
   thisIndex := 0
   prevState := "a"
   imgPath := getIDimage(currentFileIndex)
   setwhileLoopExec(1)
   While, (determineLClickstate()=1)
   {
      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      prcW := nprcW := mX/mainWidth
      prcH := nprcH := mY/mainHeight
      If (imageAligned=5)
      {
         nprcW := (prcW>0.5) ? prcW - 0.5 : 0.5 - prcW
         nprcH := (prcH>0.5) ? prcH - 0.5 : 0.5 - prcH
      } Else
      {
         If (FlipImgH=1)
            prcW := nprcW := 1 - prcW
         If (FlipImgV=1)
            prcH := nprcH := 1 - prcH
      }

      decX := Round((imgW*nprcW) * zoomLevel)
      decY := Round((imgH*nprcH) * zoomLevel)
      If ((prcW>0.5 || imageAligned=1) && (FlipImgH=0))
      || (prcW>0.5 && imageAligned=5 && FlipImgH=1)
         decX := -decX

      If ((prcH>0.5 || imageAligned=1) && (FlipImgV=0))
      || (prcH>0.5 && imageAligned=5 && FlipImgV=1)
         decY := -decY

      If (doX=1)
      {
         newDecX := (FlipImgH=1) ? -decX : decX
         IMGdecalageX := (A_Index=1) ? (newDecX + oDx)//2 : newDecX
         diffIMGdecX := mX - oX + 2
      } Else
      {
         newDecY := (FlipImgV=1) ? -decY : decY
         IMGdecalageY := (A_Index=1) ? (newDecY + oDy)//2 : newDecY
         diffIMGdecY := mY - oY + 2
      }

      thisState := "a" IMGdecalageX IMGdecalageY diffIMGdecX diffIMGdecY imgPath currentFileIndex
      If (prevState!=thisState)
      {
         thisIndex++
         prevState := thisState
         dummyResizeImageGDIwin()
      }
      If (A_Index<3)
        Sleep, 50
   }

   setwhileLoopExec(0)
   vpImgPanningNow := 0
   diffIMGdecX := diffIMGdecY := 0
   ; If (thisIndex>10) || (lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
}

invokeFilesListMapNow() {
   ToolTip, Please wait - generating list map
   listMap := generateFilesListMap("auto")
   ToolTip
   mainGdipWinThumbsGrid(0, modus, listMap[1])
   trGdip_DisposeImage(listMap[1])
   thisVal := listMap[2]
   If (thisVal=2)
      friendly := "SELECTED FILES"
   Else If (thisVal=3)
      friendly := "ALREADY SEEN IMAGES"
   Else If (thisVal=5)
      friendly := "ADDED TO FAVOURITES"
   Else
      friendly := "NONE"

   showDelayedTooltip("Files list map: " friendly)
}

MenuDrawFilesListMap() {
   SetTimer, RemoveTooltip, Off
   lastOSDtooltipInvoked := A_TickCount
   SetTimer, invokeFilesListMapNow, -150
}

ThumbsScrollbar() {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   prevFileIndex := currentFileIndex
   prevu := lastu := -2
   If (showFilesListMap=1 && markedSelectFile>1 && maxFilesIndex>10 && minimizeMemUsage!=1)
   {
      ToolTip, Please wait - generating list map
      listMap := generateFilesListMap()
      ToolTip
   }

   setwhileLoopExec(1)
   While, (determineLClickstate()=1)
   {
      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mYperc := ((mY-15)/mainHeight)*100
      newIndex := clampInRange(Ceil((maxFilesIndex/100)*mYperc), 1, maxFilesIndex)
      ; mapOffset := - clampInRange(mY * 2, 0, mainHeight*2 - 1)
      If (lastu!=newIndex)
      {
         lastu := newIndex
         currentFileIndex := newIndex
         thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
         modus := (thumbsListViewMode>1) ? 2 : 1
         moda := (thumbsListViewMode>2) ? 1 : 0
         If (startIndex!=prevu)
         {
            prevu := startIndex
            If (thumbsListViewMode>1)
               QPV_listThumbnailsGridMode(moda, glPG, glHDC, hGDIthumbsWin)
            Else
               filterDelayiedImageDisplay()
         }
         mainGdipWinThumbsGrid(0, modus, listMap[1], "scroll", listMap[3])
      }
   }

   setwhileLoopExec(0)
   trGdip_DisposeImage(listMap[1])
   If (GetKeyState("Shift", "P"))
   {
      keyu := (currentFileIndex>prevFileIndex) ? "Down" : "Home"
      thumbsSelector(keyu, "+Shift", prevFileIndex)
   }
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(250)
}

setwhileLoopExec(val) {
   whileLoopExec := val
   interfaceThread.ahkassign("whileLoopExec", val)
}

simplePanIMGonClick(dummy:=0, doX:=1, doY:=1) {
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If (dummy="scroll")
      JEE_ClientToScreen(hPicOnGui1, lastLclickX, lastLclickY, oX, oY)
   Else
      GetPhysicalCursorPos(oX, oY)

   oDx := IMGdecalageX, oDy := IMGdecalageY
   minTopCornerX := (allowFreeIMGpanning=1) ? mainWidth : 0
   minTopCornerY := (allowFreeIMGpanning=1) ? mainHeight : 0
   lastInvoked := A_TickCount
   normalModeZeit := thisZeit := 1
   vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
   prevMX := oX, prevMY := oY
   prevState := thisIndex := 0
   thisZL := (zoomLevel>8) ? 8 : 0.8 + zoomLevel
   ; ToolTip, % "l=" thisZL , , , 2
   setwhileLoopExec(1)
   If (dummy="scroll")
      wrapResizeImageGDIwin()

   While, (determineLClickstate()=1)
   {
      If (allowFreeIMGpanning=1 && dummy="scroll")
         GetMouseCoord2wind(PVhwnd, mX, mY)
      Else
         GetPhysicalCursorPos(mX, mY)
      moX := (FlipImgH=1) ? mainWidth - mX : mX
      moY := (FlipImgV=1) ? mainHeight - mY : mY
      calculateScrollBars(prevResizedVPimgW, prevResizedVPimgH, prevDestPosX, prevDestPosY, mainWidth, mainHeight, knobW, knobH, knobX, knobY)
      scrolly := (doX=1) ? isInRange(moX, knobX, knobX + knobW) : isInRange(moY, knobY, knobY + knobH)
      thisState := mX "=" mY "=" prevResizedVPimgW "=" prevResizedVPimgH
      If (thisState!=prevState && allowFreeIMGpanning=1 && dummy="scroll" && scrolly=0 && (A_TickCount - normalModeZeit>250))
      {
         prevState := thisState
         oDx := IMGdecalageX, oDy := IMGdecalageY
         prevMX := oX := mX, prevMY := oY := mY
         If (FlipImgH=1)
         {
            If (doX=1 && moX<knobX)
               PanIMGonScreen("R", "-")
            Else If (doX=1) && (moX>knobX+knobW)
               PanIMGonScreen("L", "-")
         } Else
         {
            If (doX=1 && moX<knobX)
               PanIMGonScreen("L", "-")
            Else If (doX=1) && (moX>knobX+knobW)
               PanIMGonScreen("R", "-")
         }

         If (FlipImgV=1)
         {
            If (doY=1 && moY<knobY)
               PanIMGonScreen("D", "-")
            Else If (doY=1) && (moY>knobY+knobH)
               PanIMGonScreen("U", "-")
         } Else
         {
            If (doY=1 && moY<knobY)
               PanIMGonScreen("U", "-")
            Else If (doY=1) && (moY>knobY+knobH)
               PanIMGonScreen("D", "-")
         }
   
         ; If thisIndex
            dummyResizeImageGDIwin()
         Sleep, 2
         thisIndex := !thisIndex
         lastInvoked := A_TickCount
      } Else If (allowFreeIMGpanning=1 && dummy="scroll")
      {
         Sleep, 2
      } Else
      {
         If (scrolly=1)
            normalModeZeit := A_TickCount
         diffIMGdecX := Dx := Ceil((mX - oX)*thisZL)
         diffIMGdecY := Dy := Ceil((mY - oY)*thisZL)
         If (dummy="navBox")
         {
            Dx := -3*Dx * (zoomLevel//2 + 1)
            Dy := -3*Dy * (zoomLevel//2 + 1)
         } Else If (dummy="scroll")
         {
            Dx := -1*Dx
            Dy := -1*Dy
         }

         If (doX=1)
            IMGdecalageX := (FlipImgH=1) ? oDx - Dx : oDx + Dx
         If (doY=1)
            IMGdecalageY := (FlipImgV=1) ? oDy - Dy : oDy + Dy

         limitPanningDist(oDx, oDy, minTopCornerX, minTopCornerY)
         If (!isDotInRect(mX, mY, prevMX - 5, prevMX + 5, prevMY - 5, prevMY + 5) && (A_TickCount - thisZeit>15))
         {
            thisIndex++
            zeitSillyPrevent := A_TickCount
            dummyResizeImageGDIwin()
            prevMX := mX
            prevMY := mY
            thisZeit := A_TickCount
         }
/*
         ; ToolTip, % diffIMGdecX " == " diffIMGdecY , , , 2
         MouseGetPos,,, Az
         isOkay := (Az=PVhwnd || Az=hGDIwin || Az=hGDIthumbsWin || Az=hGDIinfosWin || Az=hGDIselectWin || Az=hGuiTip && mouseToolTipWinCreated=1 || Az=hquickMenuSearchWin && VisibleQuickMenuSearchWin=1 || Az=hQPVtoolbar && ShowAdvToolbar=1 || Az=hfdTreeWinGui && folderTreeWinOpen=1) ? 1 : 0
         ; ToolTip, % isOkay " | " Az , , , 2
         If (isOkay!=1)
         {
            If (A_TickCount - lastInvoked>1550)
               Break
         } Else lastInvoked := A_TickCount
*/
      }
   }

   setwhileLoopExec(0)
   vpImgPanningNow := diffIMGdecX := diffIMGdecY := 0
   If (thisIndex>10 || lastWasLowQuality=1 || allowFreeIMGpanning=1 || dummy="scroll")
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
}

limitPanningDist(ByRef oDx, ByRef oD, minTopCornerX, minTopCornerY) {
   If (imageAligned=5 && allowFreeIMGpanning=0)
   {
      If (oDx>0 && Abs(oDx)>Abs(imgDecLX//2))
         oDx := -imgDecLX//2
      Else If (oDx<0 && Abs(oDx)>Abs(imgDecLX//2))
         oDx := imgDecLX//2

      If (oDy>0 && Abs(oDy)>Abs(imgDecLY//2))
         oDy := -imgDecLY//2
      Else If (oDy<0 && Abs(oDy)>Abs(imgDecLY//2))
         oDy := imgDecLY//2
   } Else
   {
      If (oDx>=minTopCornerX)
         oDx := minTopCornerX
      Else If (oDx<imgDecLX)
         oDx := imgDecLX

      If (oDy>=minTopCornerY)
         oDy := minTopCornerY
      Else If (oDy<imgDecLY)
         oDy := imgDecLY
   }
}

panAltIMGonClick(dummy:=0) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If isWinXP
   {
      simplePanIMGonClick(dummy)
      Return
   }

   ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Sleep, 0
   GetPhysicalCursorPos(oX, oY)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   minTopCornerX := (allowFreeIMGpanning=1) ? mainWidth : 0
   minTopCornerY := (allowFreeIMGpanning=1) ? mainHeight : 0
   newPosZeit := A_TickCount
   oDx := IMGdecalageX, oDy := IMGdecalageY
   zX := oX, zY := oY
   thisZeit := A_TickCount
   vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
   imgPath := getIDimage(currentFileIndex)
   thisIndex := 0
   setwhileLoopExec(1)
   While, (determineLClickstate()=1)
   {
      Sleep, 1
      GetPhysicalCursorPos(mX, mY)
      skipLoop := (isInRange(mX, zX - 5, zX + 5) && isInRange(mY, zY - 5, zY + 5)) ? 1 : 0
      diffIMGdecX := Dx := mX - oX + 2
      diffIMGdecY := Dy := mY - oY + 2
      ; ToolTip, % diffIMGdecX "==" diffIMGdecY , , , 2
      If (dummy="navBox")
      {
         Dx := -3*Dx * (zoomLevel//2 + 1)
         Dy := -3*Dy * (zoomLevel//2 + 1)
      }

      gIMGdecalageX := (FlipImgH=1) ? oDx - Dx : oDx + Dx
      gIMGdecalageY := (FlipImgV=1) ? oDy - Dy : oDy + Dy
      ; ToolTip, % diffIMGdecX "--" diffIMGdecY " || " IMGdecalageX "--" IMGdecalageY " || " odX "--" odY , , , 2
      If (A_TickCount - newPosZeit>950) || (mX=oX && mY=oY)
      {
         newPosZeit := A_TickCount
         zX := mX, zY := mY
         If (skipLoop=1)
            Continue
      } Else If (skipLoop=1)
         Continue

      If (dummy!="navBox")
         MouseMove, % oX, % oY, 0

      oDx := gIMGdecalageX, oDy := gIMGdecalageY
      limitPanningDist(oDx, oDy, minTopCornerX, minTopCornerY)
      If (A_TickCount - thisZeit>15) ; || (drawModeAzeit<100) || (drawModeBzeit<100)
      {
         thisIndex++
         zeitSillyPrevent := A_TickCount
         IMGdecalageX := gIMGdecalageX
         IMGdecalageY := gIMGdecalageY
         dummyResizeImageGDIwin()
         thisZeit := A_TickCount
      }
   }

   setwhileLoopExec(0)
   vpImgPanningNow := diffIMGdecX := diffIMGdecY := 0
   If (thisIndex>10) || (lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
}

winSwipeAction(thisCtrlClicked, mainParam) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   didSomething := 1
   infoImgEditingMode := (editingSelectionNow=1 || imgEditPanelOpened=1) ? 1 : 0
   infoPannable := ((IMGlargerViewPort=1 || allowFreeIMGpanning=1) && thumbsDisplaying!=1 && IMGresizingMode=4) ? 1 : 0
   If (infoPannable=1 && thisCtrlClicked="PicOnGUI2b")
   || (infoPannable=1 && (thisCtrlClicked="PicOnGUI3" || thisCtrlClicked="PicOnGUI1") && infoImgEditingMode=1)
   {
      SetTimer, simplePanIMGonClick, -5
      Return 0
   }

   startZeit := A_TickCount
   ; GetPhysicalCursorPos(oX, oY)
   JEE_ClientToScreen(hPicOnGui1, lastLclickX, lastLclickY, oX, oY)
   SelDotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
   dotSize := Round(SelDotsSize*2.5)
   lowerLimitRatio := (IMGresizingMode=4) ? 0.4 : 0.4
   GetPhysicalCursorPos(mX, mY)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   setwhileLoopExec(1)
   While, (determineLClickstate()=1)
   {
      GetPhysicalCursorPos(mX, mY)
      diffx := snapToValues(Abs(mX - oX), 1, mainWidth, 10, 0)
      diffy := snapToValues(Abs(mY - oY), 1, mainHeight, 10, 0)
      dirX := (mX - oX) < 0 ? -1 : 1
      dirY := (mY - oY) < 0 ? -1 : 1
      ratioDiffs := diffx/diffy
      If (diffx>45 || diffy>45) && (ratioDiffs<lowerLimitRatio || ratioDiffs>3)
      {
         Sleep, 1
         zeitSillyPrevent := A_TickCount
         swipeAct := (ratioDiffs<lowerLimitRatio) ? 1 : 2
         If (ratioDiffs="")
            swipeAct := 0
      } Else swipeAct := 0 ;  Tooltip
      ; Sleep, 5
      ; ToolTip, % swipeAct " - " thisCtrlClicked " - " ratioDiffs "`n" diffx "==" diffy "`n" dirX "==" dirY

      stepFactor := 1
      doNextSlide := doPrevSlide := doZoomChange := doFrameChange := 0
      If (!swipeAct && isDotInRect(mX, mY, oX - dotSize, oX + dotSize, oY - dotSize, oY + dotSize))
      {
         zeitSillyPrevent := 1
         If (thisCtrlClicked="PicOnGUI3")
         {
            If (infoImgEditingMode!=1)
               doNextSlide := 1
         } Else If (thisCtrlClicked="PicOnGUI1" )
         {
            If (infoImgEditingMode!=1)
               doPrevSlide := 1
         } Else If (thisCtrlClicked="PicOnGUI2a")
         {
            doZoomChange := 1
         } Else If (thisCtrlClicked="PicOnGUI2c")
         {
            doZoomChange := -1
         }
      } Else If (swipeAct=1)
      {
         stepFactor := (diffy/mainHeight)*10 + 1.25
         ; ToolTip, % stepFactor " = " dirY , , , 2
         doZoomChange := dirY
         ;  ChangeZoom(dirY, 0, stepFactor)
      } Else If (swipeAct=2 && infoImgEditingMode!=1)
      {
         If (dirX=1)
            doNextSlide := 1
         Else If (dirX=-1)
            doPrevSlide := 1
      }

      If ((doNextSlide || doPrevSlide) && totalFramesIndex>1)
      {
         If (mY>mainHeight*0.75)
         {
            doFrameChange := (doNextSlide=1) ? 1 : -1
            doNextSlide := doPrevSlide := 0
         }
      }

      If (A_TickCount - startZeit>350 && InStr(mainParam, "pen-") && !swipeAct)
         doNextSlide := doPrevSlide := doZoomChange := doFrameChange := 0

      If doFrameChange
      {
         friendly := (doFrameChange=1) ? "Next" : "Previous"
         showTOOLtip(friendly " frame")
      } Else If (doNextSlide || doPrevSlide)
      {
         friendly := (doNextSlide=1) ? "Next" : "Previous"
         showTOOLtip(friendly " slide")
      } Else If doZoomChange
      {
         friendly := (doZoomChange=1) ? "in" : "out"
         zl := decideNewVPzoomLevel(zoomLevel, 0, doZoomChange, stepFactor)
         showTOOLtip("Zoom " friendly ": " Round(zl*100) "%")
      } Else 
      {
         toolTipGuiCreated := 0
         interfaceThread.ahkassign("toolTipGuiCreated", 0)
         clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
      }
   }

   setwhileLoopExec(0)
   didSomething := 1
   If doFrameChange
      changeDesiredFrame(doFrameChange)
   Else If doNextSlide
      GoNextSlide()
   Else If doPrevSlide
      GoPrevSlide()
   Else If doZoomChange
      changeZoom(doZoomChange, 0, stepFactor)
   Else 
      didSomething := 0

   If !didSomething
      zeitSillyPrevent := 1

   Return didSomething
}

GetMouseCoord2wind(hwnd, ByRef nX, ByRef nY) {
    ; CoordMode, Mouse, Screen
    MouseGetPos, oX, oY
    JEE_ScreenToClient(hwnd, oX, oY, nX, nY)
}

doLayeredWinUpdate(funcu, hwnd, HDCu, opacity:=255) {
  Static xPox := 0, yPos := 0
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  If (A_OSVersion="WIN_7" || isWinXP=1)
  {
     ; GetPhysicalCursorPos(mainX, mainY)
     JEE_ClientToScreen(hPicOnGui1, 1, 1, xPos, yPos)
     ; WinMove, ahk_id %whichHwnd%,, %mainX%, %mainY%
  }

  If (debugModa=1)
  {
     ; If (hwnd=hGDIselectWin)
     ;    opacity := 120

     If (hwnd=hGDIwin)
        nameHwnd := "hGDIwin"
     Else If (hwnd=hGDIthumbsWin)
        nameHwnd := "hGDIthumbsWin"
     Else If (hwnd=hGDIselectwin)
        nameHwnd := "hGDIselectwin"
     Else If (hwnd=hGDIinfosWin)
        nameHwnd := "hGDIinfosWin"
     Else
        nameHwnd := "unknownWin"

     If (HDCu=2NDglHDC)
        nameDCu := "2NDglHDC"
     Else If (HDCu=glHDC)
        nameDCu := "glHDC"
     Else
        nameDCu := "unknownHDC"

     fnOutputDebug(A_ThisFunc "(): " funcu " = " nameHwnd " = " nameDCu)
  }
  ; If !globalWinStates["a" hwnd]
  ;    ToggleVisibilityWindow("show", hwnd)

  Return UpdateLayeredWindow(hwnd, HDCu, xPos, yPos, mainWidth, mainHeight, opacity)
}

BtnSetBrushSymmetryCoords() {
   If (BrushToolType>3)
   {
      showTOOLtip("WARNING: Symmetry painting not available for the current brush type")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (AnyWindowOpen!=64 || !isImgEditingNow())
      Return

   BrushToolSymmetryX .= "c"
   liveDrawingBrushTool := 1
   showTOOLtip("Please click inside the image area to set the symmetry axis")
   ; SetTimer, RemoveTooltip, % -msgDisplayTime//2
   mustCaptureCloneBrush := 1
   interfaceThread.ahkassign("mustCaptureCloneBrush", mustCaptureCloneBrush)
   createGUItoolbar()
   If (panelWinCollapsed=0)
      toggleImgEditPanelWindow()
   dummyTimerDelayiedImageDisplay(50)
}

setNewBrushSymmetryPoints() {
   whichBitmap := useGdiBitmap()
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   thisZeit := kX := kY := 0
   BrushToolSymmetryX := SubStr(BrushToolSymmetryX, 1, 1)
   setwhileLoopExec(1)
   While, (determineLClickstate()=1)
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
      ; tinyPrevAreaCoordX := kX, tinyPrevAreaCoordY := kY
      showTOOLtip("Symmetry point coordinates set to`n" kX " / " kY)
      BrushToolSymmetryPointX := Round(kX/imgW, 5)
      BrushToolSymmetryPointY := Round(kY/imgH, 5)
      If (A_TickCount - thisZeit>90)
      {
         dummyRefreshImgSelectionWindow()
         thisZeit := A_TickCount
      }
   }

   If (BrushToolSymmetryX=0 && BrushToolSymmetryY=0)
   {
      BrushToolSymmetryX := 1
      GuiControl, SettingsGUIA:, BrushToolSymmetryX, 1
   }

   setwhileLoopExec(0)
   endCaptureCloneBrush()
   If (panelWinCollapsed=1)
      toggleImgEditPanelWindow()

   SoundBeep , 900, 100
   dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

MouseDelta(X1,Y1,X2,Y2) {
   ; from Bugz000
   return round((dllcall("msvcrt\atan2", "Double", (y2 - y1), "Double", (x2-x1), "CDECL Double") * (180/3.14159265358979323846264338327950288419716939937)),3)
}

MouseMoveResponder(actu:=0) {
  Static prevState := "C", prevMouseCoords := [], lastInvoked := 1, prevDotu := -1
  If (actu="rem")
  {
     prevDotu := prevState := "-"
     prevMouseCoords := []
     clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
     Return
  }

  If (toolTipGuiCreated=2)
  {
     SetTimer, RemoveTooltip, % -msgDisplayTime*4
     Return
  }

  If (A_TickCount - lastOSDtooltipInvoked<625)
  {
     SetTimer, MouseMoveResponder, -350
     Return
  }

  brushingMode := (liveDrawingBrushTool=1 && AnyWindowOpen=64) || (FloodFillSelectionAdj!=1 && AnyWindowOpen=66) ? 1 : 0
  If (editingSelectionNow=1 && thumbsDisplaying=0 && actu="krill" && drawingShapeNow!=1)
  {
     Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
     ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
     SkeletDrawSelectionBox()
     Gdip_ResetWorldTransform(2NDglPG)
     If identifyThisWin()
        SetTimer, dummyRefreshImgSelectionWindow, -150
  } Else If (drawingShapeNow=1)
  {
     ; Sleep, -1
     ; dummyRefreshImgSelectionWindow()
     SetTimer, dummyRefreshImgSelectionWindow, -2
  } Else If (liveDrawingBrushTool=1 && AnyWindowOpen)
  {
     brushSize := (brushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
     thisSize := (AnyWindowOpen=64) ? brushSize * zoomLevel : brushSize * viewportDynamicOBJcoords.zl
     Gdip_ResetClip(2NDglPG)
     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
     If (GetKeyState("CapsLock", "T") || mustCaptureCloneBrush=1 || whileLoopExec=1)
     {
        r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
        Return
     }

     setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
     If (thisSize>10)
     {
        ; Gdip_SetClipRect(2NDglPG, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgh, 0)
        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight, 0)
        If (BrushToolOutsideSelection>1 && AnyWindowOpen=64 && editingSelectionNow=1)
        {
           ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, prevMaxSelX, prevMaxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
           ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
           modus := (BrushToolOutsideSelection=3) ? 4 : 1
           Gdip_SetClipPath(2NDglPG, ImgSelPath, modus)
        }

        GetMouseCoord2wind(hGDIwin, mX, mY)
        If (A_TickCount - lastInvoked > 90) && (AnyWindowOpen=64 && BrushToolAutoAngle=1)
        {
           If (prevMouseCoords[1] && prevMouseCoords[2]
           && !isDotInRect(mX, mY, prevMouseCoords[1] - 10, prevMouseCoords[1] + 10, prevMouseCoords[2] - 10, prevMouseCoords[2] + 10))
           {
              newAngle := onewAngle := MouseDelta(prevMouseCoords[1], prevMouseCoords[2], mX, mY)
              If (newAngle<0)
                 newAngle := 360 - Abs(newAngle)
              If (prevMouseCoords[3]<90 && newAngle>270)
                 prevMouseCoords[3] := 360 + prevMouseCoords[3]
              If (prevMouseCoords[3]!="")
                 newAngle := (newAngle + prevMouseCoords[3] + prevMouseCoords[3])/3
              If (newAngle>360)
                 newAngle -= 360

              prevMouseCoords[3] := newAngle
           }

           prevMouseCoords[1] := mX, prevMouseCoords[2] := mY
           lastInvoked := A_TickCount
           If (newAngle && !determineLClickstate())
              BrushToolAngle := Round(newAngle)
        }
        mX := (FlipImgH=1) ? mainWidth - mX : mX
        mY := (FlipImgV=1) ? mainHeight - mY : mY
        tmpPath := createBrushShapePath(thisSize, mX, mY, BrushToolAspectRatio, BrushToolAngle)
        Gdip_SetPenWidth(pPen1d, SelDotsSize/3 + 1)
        Gdip_SetPenWidth(pPen2, SelDotsSize/5 + 1)
        Gdip_DrawPath(2NDglPG, pPen2, tmpPath)
        Gdip_DrawPath(2NDglPG, pPen1d, tmpPath)
        Gdip_DeletePath(tmpPath)
        ; ToolTip, % BrushToolAngle " == " newAngle " == " onewAngle , , , 2

        brushSofty := (100 - BrushToolSoftness)/100
        brushSize := (brushSize*brushSofty)*zoomLevel
        If (BrushToolType!=1 && isInRange(BrushToolSoftness, 2, 98) && brushSize>9)
        {
           tmpPath2 := createBrushShapePath(brushSize, mX, mY, BrushToolAspectRatio, BrushToolAngle)
           ; Gdip_DrawPath(2NDglPG, pPen2, tmpPath2)
           Gdip_DrawPath(2NDglPG, pPen1d, tmpPath2)
           Gdip_DeletePath(tmpPath2)
        }

        Gdip_ResetClip(2NDglPG)
        If ImgSelPath
           Gdip_DeletePath(ImgSelPath)
     }
     Gdip_ResetWorldTransform(2NDglPG)
     r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
  } Else If (editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1 && drawingShapeNow!=1 && brushingMode!=1)
  {
     ; ToolTip, % SelDotsSize , , , 2
     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     GetMouseCoord2wind(hGDIwin, mX, mY)
     dotActiveObj := determineSelAreaClickRect(mX, mY, SelDotsSize, mainWidth, mainHeight, 1)
     If !identifyThisWin()
        dotActiveObj.n := 0

     Gdip_SetPenWidth(pPen7, SelDotsSize)
     If (dotActiveObj.n=9)
        thisState := "A"
     Else If (dotActiveObj.n=0)
        thisState := "C"
     Else
        thisState := "B"

     If (thisState="B" && dotActiveObj.n!=prevDotu) ; && prevState!=thisState)
     {
        SetTimer, dummyAutoClearSelectionHighlight, Off
        prevDotu := dotActiveObj.n
        ; changeMcursor("finger")
        prevState := thisState
        Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
        Gdip_SetPenWidth(pPen1d, SelDotsSize/2)
        If (dotActiveObj.n=9)
        {
           Gdip_DrawRectangle(2NDglPG, pPen1d, dotActiveObj.gx + SelDotsSize/2, dotActiveObj.gy + SelDotsSize/2, dotActiveObj.w, dotActiveObj.h)
        } Else
        {
           If InStr(dotActiveObj.line, "|")
           {
              Gdip_DrawLines(2NDglPG, pPen1d, dotActiveObj.line)
              Gdip_FillEllipse(2NDglPG, pBrushC, dotActiveObj.cx2 - SelDotsSize, dotActiveObj.cy2 - SelDotsSize, SelDotsSize*2, SelDotsSize*2)
           } Else
              Gdip_DrawLine(2NDglPG, pPen1d, dotActiveObj.line, dotActiveObj.cy1, dotActiveObj.cx2, dotActiveObj.cy2)
        }
        r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
     } Else If (thisState="A" && prevState!=thisState)
     {
        ; changeMcursor("move")
        prevState := "A"
        prevDotu := dotActiveObj.n
        Gdip_SetPenWidth(pPen1d, SelDotsSize/2)
        Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
        selX := dotActiveObj.gx + SelDotsSize/2
        selY := dotActiveObj.gy + SelDotsSize/2
        selW := dotActiveObj.w
        selH := dotActiveObj.h
        ; ToolTip, % selX "=" selY "`n" selW "=" selH , , , 2
        Gdip_FillEllipse(2NDglPG, pBrushD, selX + selW/2 - SelDotsSize/3, selY + selH/2 - SelDotsSize/3, SelDotsSize*0.7, SelDotsSize*0.7)
        Gdip_FillRectangle(2NDglPG, pBrushF, selX, selY, selW, selH)
        Gdip_DrawRectangle(2NDglPG, pPen1d, selX, selY, selW, selH)
        r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
        SetTimer, dummyAutoClearSelectionHighlight, -150
     } Else If (thisState="C" && prevState!=thisState)
     {
        SetTimer, dummyAutoClearSelectionHighlight, Off
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevDotu := dotActiveObj.n
        prevState := "C"
     }
  } Else
  {
     prevDotu := dotActiveObj.n
     If (prevState!="C")
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
     prevState := "C"
  }
}

dummyAutoClearSelectionHighlight() {
  MouseGetPos, , , OutputVarWin
  ; ToolTip, % OutputVarWin "===" PVhwnd , , , 2
  If (OutputVarWin!=PVhwnd)
     MouseMoveResponder("rem")
  Else If (editingSelectionNow=1)
     SetTimer, dummyAutoClearSelectionHighlight, -150
}

applyIMGeditKeepWin() {
   o := closeEditPanelOnApply
   closeEditPanelOnApply := 0
   GuiControl, SettingsGUIA:, closeEditPanelOnApply, 0
   applyIMGeditFunction()
   Sleep, 2
   CreateGuiButton("Undo action,,ImgUndoAction||Reopen panel,,openPreviousPanel", 0, msgDisplayTime//1.5 + 500)
   closeEditPanelOnApply := o
   GuiControl, SettingsGUIA:, closeEditPanelOnApply, % o
}

applyIMGeditFunction() {
    ; recordSelUndoLevelNow()
    If isNowAlphaPainting()
    {
       toggleAlphaPaintingMode()
       Return
    }

    If (AnyWindowOpen=24 || AnyWindowOpen=31)
       BtnPasteInSelectedArea()
    Else If (AnyWindowOpen=30)
       BtnDrawLinesSelectedArea()
    Else If (AnyWindowOpen=32)
       BtnInsertTextSelectedArea()
    Else If (AnyWindowOpen=23)
       BtnFillSelectedArea()
    Else If (AnyWindowOpen=25)
       BtnEraseSelectedArea()
    Else If (AnyWindowOpen=68)
       BtnFillBehindSelectedArea()
    Else If (AnyWindowOpen=55)
       BtnGraySelectedArea()
    Else If (AnyWindowOpen=65)
       BtnDrawShapeSelectedArea()
    Else If (AnyWindowOpen=74)
       BtnAdjustColorsImgSelectedArea()
    Else If (AnyWindowOpen=12)
       BtnPerformJpegOp()
    Else
       BtnCloseWindow()
    SetTimer, RemoveTooltip, -300
}

LivePreviewAlphaMaskPasteInPlace() {
    Critical, on
    G2 := 2NDglPG
    Gdip_ResetClip(G2)

    obju := corePasteInPlaceActNow(0, 0, 1)
    hasRotated := obju[1]
    whichBitmap := obju[2]
    zBitmap := obju[3]

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, prevMaxSelX, prevMaxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
    Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    Gdip_GetImageDimensions(userAlphaMaskBmpPainted, zImgW, zImgH)
    PasteInPlaceCalcObjSize(1, hasRotated, oImgW, oImgH, imgSelW, imgSelH, VPselRotation, ResizedW, ResizedH)
    PasteInPlaceCalcObjCoords(imgSelW, imgSelH, ResizedW, ResizedH, imgSelPx, imgSelPy)
    imgSelW := ResizedW, imgSelH := ResizedH
    viewportDynamicOBJcoords.x := imgSelPx, viewportDynamicOBJcoords.y := imgSelPy
    viewportDynamicOBJcoords.w := imgSelW,  viewportDynamicOBJcoords.h := imgSelH
    viewportDynamicOBJcoords.zl := (imgSelW/zImgW + imgSelH/zImgH)/2 + 0.0001
    thisOpacity := (PasteInPlaceOpacity>255) ? (PasteInPlaceOpacity - 245)/10 : PasteInPlaceOpacity/255
    If (oImgW!=zImgW || oImgH!=zImgH)
    {
       alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, userAlphaMaskBmpPainted, oimgW, oimgH, 0, 5, -1)
       hasResized := 1
    } Else alphaMaskGray := userAlphaMaskBmpPainted

    clipBMP := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    QPV_SetAlphaChannel(clipBMP, alphaMaskGray, alphaMaskColorReversed, alphaMaskReplaceMode, alphaMaskBMPchannel)
    vPobju := testSelectionLargerThanViewport()
    Gdip_SetClipRect(G2, 0, 0, vPobju.mainWidth, vPobju.mainHeight, 0)
    If (PasteInPlaceCropSel>1)
    {
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, PasteInPlaceCropSel - 1, VPselRotation + PasteInPlaceCropAngular, rotateSelBoundsKeepRatio)
       Gdip_SetClipPath(G2, pPath, 1)
    }

    bgrBMP := obju[4]
    If (userimgGammaCorrect=1 && StrLen(bgrBMP)>2)
    {
       trGdip_DrawImage(A_ThisFunc, G2, bgrBMP, imgSelPx, imgSelPy, ResizedW, ResizedH)
       Gdip_SetCompositingQuality(G2, 2)
    }

    If (PasteInPlaceEraseInitial=1 && PasteInPlaceBlendMode=1)
       PasteInPlaceEraseArea(G2, 1)

    trGdip_DisposeImage(bgrBMP)
    ; ToolTip, % imgSelPx "," imgSelPy "," imgSelW "," imgSelH , , , 2
    r1 := trGdip_DrawImage(A_ThisFunc, G2, clipBMP, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, oimgW, oimgH, thisOpacity)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)

    If (PasteInPlaceEraseInitial=1 && PasteInPlaceBlendMode>1)
       PasteInPlaceEraseArea(G2, 1)

    trGdip_DisposeImage(clipBMP, 1)
    trGdip_DisposeImage(zBitmap, 1)
    If hasResized
       trGdip_DisposeImage(alphaMaskGray, 1)
    Gdip_DeletePath(pPath)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, 2NDglHDC)
}

livePreviewPasteInPlace() {
   If (forceLiveAlphaPreviewMode=1 && liveDrawingBrushTool=1)
      livePreviewAlphaMasking("live")
   Else If (liveDrawingBrushTool=1)
      LivePreviewAlphaMaskPasteInPlace()
   Else
      corePasteInPlaceActNow(0, 0)
}

livePreviewFillSelectedArea() {
   If (forceLiveAlphaPreviewMode=1 && liveDrawingBrushTool=1)
      livePreviewAlphaMasking("live")
   Else
      coreFillSelectedArea(1, -1, liveDrawingBrushTool)
}

dummyLivePreviewsDelayer() {
   livePreviewsImageEditing(0, 0, "joke")
}

livePreviewsImageEditing(modus:=0, hideHUD:=0, doTimer:=0, hwnd:=0, eventu:=0) {
   ; function meant to filter out repeated calls
   Static prev := -1
   WinGetClass, WinClass, ahk_id %hwnd%
   If (StrLen(doTimer)>2 && InStr(WinClass, "_trackbar"))
   {
      okay := (prev=5 && eventu=4) ? 0 : 1
      ; fnOutputDebug("slider:" hwnd " = " eventu "=" okay)
      If (eventu!="normal" && okay=1)
         SetTimer, dummyLivePreviewsDelayer, -25
      prev := eventu
   } Else
   {
      ; fnOutputDebug("weeeeeeeeeeeeeee: " doTimer)
      corelivePreviewsImageEditing(modus, hideHUD)
   }
}

corelivePreviewsImageEditing(modus:=0, hideHUD:=0) {
   Critical, on
   If (imgEditPanelOpened!=1)
      Return

   If (toolTipGuiCreated=2 && WinActive("A")!=PVhwnd)
      RemoveTooltip()

   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   createGDIPcanvas(mainWidth, mainHeight)
   If (modus!="live-selection")
      setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)

   If (modus="coords")
   {
      createDefaultSizedSelectionArea(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, prevMaxSelX, prevMaxSelY, mainWidth, mainHeight)
      ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, prevMaxSelX, prevMaxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   }

   If (vpImgPanningNow!=1)
   {
      If (dynamicLiveObjVisible=0)
         toggleLiveEditObject()

      okayu := (A_TickCount - prevImgEditZeit>350) ? 1 : 0
      If (AnyWindowOpen=24 || AnyWindowOpen=31)
         livePreviewPasteInPlace()
      Else If (AnyWindowOpen=30 && okayu=1)
         coreDrawLinesSelectionArea()
      Else If (AnyWindowOpen=23 && (okayu=1 || liveDrawingBrushTool=1))
         livePreviewFillSelectedArea()
      Else If (AnyWindowOpen=70 && (okayu=1 || liveDrawingBrushTool=1))
         livePreviewAlphaMasking("live")
      Else If (AnyWindowOpen=32 && (okayu=1 || liveDrawingBrushTool=1))
         livePreviewInsertTextinArea(0, liveDrawingBrushTool)
      Else If (AnyWindowOpen=25 && okayu=1)
         livePreviewEraseArea()
      Else If (AnyWindowOpen=68 && okayu=1)
         livePreviewFillBehindArea()
      Else If (AnyWindowOpen=55 && okayu=1)
         livePreviewDesaturateArea()
      Else If (AnyWindowOpen=74)
         livePreviewAdjustColorsArea()
      Else If (AnyWindowOpen=65 && okayu=1)
         coreDrawShapesSelectionArea()
   }

   fnOutputDebug("redraw: " A_ThisFunc)
   If (showViewPortGrid=1 && imgEditPanelOpened=1)
      drawVPgridsNow(mainWidth, mainHeight, prevResizedVPimgW, prevResizedVPimgH, prevDestPosX, prevDestPosY, 2NDglPG)

   If (modus!="live-selection")
      Gdip_ResetWorldTransform(2NDglPG)

   If (scrollBarHy>0)
   {
      Gdip_SetClipRect(2NDglPG, 0, mainHeight - scrollBarHy, mainWidth, scrollBarHy)
      Gdip_GraphicsClear(2NDglPG)
   }

   If (scrollBarVx>0)
   {
      Gdip_SetClipRect(2NDglPG, mainWidth - scrollBarVx, 0, scrollBarVx, mainHeight)
      Gdip_GraphicsClear(2NDglPG)
   }

   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, 2NDglHDC)
   If (scrollBarHy>0 || scrollBarVx>0)
      Gdip_ResetClip(2NDglPG)
}

SkeletDrawSelectionBox(paintAlphaMask:=0) {
   dotsSize := SelDotsSize
   vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
   vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
   vPimgSelX := min(selDotX, selDotAx) + dotsSize//2
   vPimgSelY := min(selDotY, selDotAy) + dotsSize//2
 
   If (VPselRotation!=0)
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)

   If (imgEditPanelOpened=1)
   {
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)
      Gdip_FillEllipse(2NDglPG, pBrushA, SelDotDx + 5, SelDotDy + 5, dotsSize, dotsSize)
   }

   thisThick := dotsSize//5 + 1
   Gdip_SetPenWidth(pPen4, thisThick)
   Gdip_SetPenWidth(pPen1d, thisThick)
   decideLiveSelectionBasedOnWindow(angleu, isAngleu)
   If (paintAlphaMask=1)
   {
      ImgSelPath := Gdip_CreatePath()
      Gdip_AddPathRectangle(ImgSelPath, vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH)
   } Else ImgSelPath := createImgSelPath(vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio, 0, 1, isAngleu, innerSelectionCavityX, innerSelectionCavityY)

   If isAngleu
      Gdip_DrawPath(2NDglPG, pPen4, ImgSelPath)

   Gdip_DrawRectangle(2NDglPG, pPen4, vPimgSelX + thisThick//3, vPimgSelY + thisThick//3, vPimgSelW, vPimgSelH)
   Gdip_DrawPath(2NDglPG, pPen1d, ImgSelPath)
   Gdip_DrawRectangle(2NDglPG, pPen4, vPimgSelX + thisThick//2, vPimgSelY + thisThick//2, vPimgSelW, vPimgSelH)
   If (paintAlphaMask=1 && AnyWindowOpen!=70)
   {
      livePreviewAlphaMasking()
      generateAlphaMaskBitmap("kill", 0)
   }

   thisWin := (paintAlphaMask=1) ? hGDIinfosWin : hGDIselectWin
   r2 := doLayeredWinUpdate(A_ThisFunc, thisWin, 2NDglHDC)
   Gdip_DeletePath(ImgSelPath)
}

defineCurrentAlphaMask() {
   az := StrLen(userClipBMPpaste)>2 ? "(referenced bitmap)" : "(inexistent reference)"
   bz := StrLen(useGdiBitmap())>2 ? "(referenced bitmap)" : "(inexistent reference)"
   cz := StrLen(userAlphaMaskBmpPainted)>2 ? "(effects may apply)" : "(inexistent reference)"
   If (alphaMaskingMode=6)
      friendly := "custom shape (generated)"
   Else If (alphaMaskingMode=2)
      friendly := "linear gradient (generated)"
   Else If (alphaMaskingMode=3)
      friendly := "radial gradient (generated)"
   Else If (alphaMaskingMode=4)
      friendly := "box gradient (generated)"
   Else If (alphaMaskingMode=5 && alphaMaskRefBMP=1)
      friendly := "user painted bitmap " cz
   Else If (alphaMaskingMode=5 && alphaMaskRefBMP=2)
      friendly := "main image " bc
   Else If (alphaMaskingMode=5 && alphaMaskRefBMP=3)
      friendly := "transformed image object " az
   Else
      friendly := "none"

   Return friendly
}

selectFileLongTap() {
   If (thumbsDisplaying=1 && determineLClickstate()=1 && (A_TickCount - lastOtherWinClose>350) && (A_TickCount - lastTimeToggleThumbs>350))
      markThisFileNow(currentFileIndex)
}

isDotInRect(mX, mY, x1, x2, y1, y2, modus:=0) {
   If (modus=1)
      r := (isInRange(mX, y1 - x1, y1 + x2) && isInRange(mY, y2 - x1, y2 + x2)) ? 1 : 0
   Else
      r := (isInRange(mX, x1, x2) && isInRange(mY, y1, y2)) ? 1 : 0
   Return r
}

determineSelAreaClickRect(mX, mY, dotsSize, mainWidth, mainHeight, doFlips) {
; selection areas that are clickable, their IDs
; selection points highlighted with brackets
; [1]---5---[11]---5---[3]
;  |                    |
;  |                    |
;  7                    8
;  |                    |
;  |                    |
; [14]      [10]      [12]
;  |                    |
;  |                    |
;  7                    8
;  |                    |
;  |                    |
; [4]---6---[13]---6---[2]
; 

   If (showHUDnavIMG=1 && hasDrawnImageMap=1 && IMGlargerViewPort=1
   && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
      Return

   If ((IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1) && thumbsDisplaying!=1)
   {
      ; handle clicks on the H/V scrollbars for images larger than the viewport
      knobSize := imgHUDbaseUnit//3
      If (scrollBarHy>1 && mY>(mainHeight - knobSize))
      || (scrollBarVx>1 && mX>(mainWidth - knobSize))
         Return
   }

   nSelDotX  := selDotX,    nSelDotY  := selDotY    ; [1]
   nSelDotAx := selDotAx,   nSelDotAy := selDotAy   ; [2]
   nSelDotBx := selDotBx,   nSelDotBy := selDotBy   ; [3]
   nSelDotCx := selDotCx,   nSelDotCy := selDotCy   ; [4]
   nSelDotDx := selDotDx,   nSelDotDy := selDotDy   ; [10]
   nSelDotMaX := selDotMaX, nSelDotMaY := selDotMaY ; [11]
   nSelDotMbX := selDotMbX, nSelDotMbY := selDotMbY ; [12]
   nSelDotMcX := selDotMcX, nSelDotMcY := selDotMcY ; [13]
   nSelDotMdX := selDotMdX, nSelDotMdY := selDotMdY ; [14]
   dotActive := 0

   If (FlipImgH=1 && doFlips=1)
   {
      nSelDotX := mainWidth - selDotX - dotsSize
      nSelDotAx := mainWidth - selDotAx - dotsSize
      nSelDotBx := mainWidth - selDotBx - dotsSize
      nSelDotCx := mainWidth - selDotCx - dotsSize
      nSelDotDx := mainWidth - selDotDx - dotsSize
      nSelDotMaX := mainWidth - selDotMaX - dotsSize
      nSelDotMbX := mainWidth - selDotMbX - dotsSize
      nSelDotMcX := mainWidth - selDotMcX - dotsSize
      nSelDotMdX := mainWidth - selDotMdX - dotsSize
   }

   If (FlipImgV=1 && doFlips=1)
   {
      nSelDotY := mainHeight - selDotY - dotsSize
      nSelDotAy := mainHeight - selDotAy - dotsSize
      nSelDotBy := mainHeight - selDotBy - dotsSize
      nSelDotCy := mainHeight - selDotCy - dotsSize
      nSelDotDy := mainHeight - selDotDy - dotsSize
      nSelDotMaY := mainHeight - selDotMaY - dotsSize
      nSelDotMbY := mainHeight - selDotMbY - dotsSize
      nSelDotMcY := mainHeight - selDotMcY - dotsSize
      nSelDotMdY := mainHeight - selDotMdY - dotsSize
   }

   d := dotsSize//2
   transformTool := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
   If isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotX, nSelDotY, 1)
   {
      ; top-left corner
      line := nSelDotBx + d "," nSelDotBy + d "|"
      line .= nSelDotX + d "," nSelDotY + d "|"
      line .= nSelDotCx + d "," nSelDotCy + d
      cX1 := nSelDotX
      cY1 := nSelDotY
      cX2 := nSelDotX + d
      cY2 := nSelDotY + d
      dotActive := 1
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotAx, nSelDotAy, 1)
   {
      ; bottom-right corner
      line := nSelDotBx + d "," nSelDotBy + d "|"
      line .= nSelDotAx + d "," nSelDotAy + d "|"
      line .= nSelDotCx + d "," nSelDotCy + d
      cX1 := nSelDotAx
      cY1 := nSelDotAy
      cX2 := nSelDotAx + d
      cY2 := nSelDotAy + d
      dotActive := 2
      DotPosX := imgSelX2
      DotPosY := imgSelY2
   } Else If isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotCx, nSelDotCy, 1)
   {
      ; bottom-left corner
      line := nSelDotX + d "," nSelDotY + d "|"
      line .= nSelDotCx + d "," nSelDotCy + d "|"
      line .= nSelDotAx + d "," nSelDotAy + d
      cX1 := nSelDotCx
      cY1 := nSelDotCy
      cX2 := nSelDotCx + d
      cY2 := nSelDotCy + d
      dotActive := 4
      DotPosX := imgSelX1
      DotPosY := imgSelY2
   } Else If isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotBx, nSelDotBy, 1)
   {
      ; top-right corner
      line := nSelDotX + d "," nSelDotY + d "|"
      line .= nSelDotBx + d "," nSelDotBy + d "|"
      line .= nSelDotAx + d "," nSelDotAy + d 
      cX1 := nSelDotBx
      cY1 := nSelDotBy
      cX2 := nSelDotBx + d
      cY2 := nSelDotBy + d
      dotActive := 3
      DotPosX := imgSelX2
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotDx, nSelDotDx + dotsSize, nSelDotDy, nSelDotDy + dotsSize)
   {
      ; click the center dot of the selection area
      cX1 := nSelDotDx
      cY1 := nSelDotDy
      cX2 := nSelDotDx + d
      cY2 := nSelDotDy + d
      dotActive := 10
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If (transformTool=1 && isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotMaX, nSelDotMaY, 1))
   {
      ; mid-top edge
      cX1 := nSelDotMaX
      cY1 := nSelDotMaY
      cX2 := nSelDotMaX + d
      cY2 := nSelDotMaY + d
      dotActive := 11
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If (transformTool=1 && isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotMbX, nSelDotMbY, 1))
   {
      ; mid-right edge
      cX1 := nSelDotMbX
      cY1 := nSelDotMbY
      cX2 := nSelDotMbX + d
      cY2 := nSelDotMbY + d
      dotActive := 12
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If (transformTool=1 && isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotMcX, nSelDotMcY, 1))
   {
      ; mid-bottom edge
      cX1 := nSelDotMcX
      cY1 := nSelDotMcY
      cX2 := nSelDotMcX + d
      cY2 := nSelDotMcY + d
      dotActive := 13
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If (transformTool=1 && isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotMdX, nSelDotMdY, 1))
   {
      ; mid-left edge
      cX1 := nSelDotMdX
      cY1 := nSelDotMdY
      cX2 := nSelDotMdX + d
      cY2 := nSelDotMdY + d
      dotActive := 14
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotX, nSelDotBx, nSelDotY, nSelDotY + dotsSize)
   {
      ; top edge
      cX1 := nSelDotX
      cX2 := nSelDotBx
      cY1 := nSelDotY + d
      cY2 := nSelDotY + d
      dotActive := 5
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotCx, nSelDotBx, nSelDotCy, nSelDotCy + dotsSize)
   {
      ; bottom edge
      cX1 := nSelDotCx
      cX2 := nSelDotBx
      cY1 := nSelDotCy + d
      cY2 := nSelDotCy + d
      dotActive := 6
      DotPosX := imgSelX1
      DotPosY := imgSelY2
   } Else If isDotInRect(mX, mY, nSelDotX, nSelDotX + dotsSize, nSelDotY, nSelDotCy)
   {
      ; left edge
      cX1 := nSelDotX + d
      cX2 := nSelDotX + d
      cY1 := nSelDotY
      cY2 := nSelDotCy
      dotActive := 7
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotBx, nSelDotBx + dotsSize, nSelDotAy, nSelDotBy + dotsSize)
   {
      ; right edge
      cX1 := nSelDotBx + d
      cX2 := nSelDotBx + d
      cY1 := nSelDotAy
      cY2 := nSelDotBy
      dotActive := 8
      DotPosX := imgSelX2
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotX, nSelDotBx, nSelDotBy, nSelDotAy)
   {
      ; click anywhere within the selection
      cX1 := nSelDotX
      cX2 := nSelDotBx
      cY1 := nSelDotBy
      cY2 := nSelDotAy
      dotActive := 9
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   }
   ; z := nSelDotX "=" nSelDotY "`n" nSelDotAx "=" nSelDotAy "`n" nSelDotBx "=" nSelDotBy
   ; ToolTip, % "d=" y "=l=" dotActive "`n" z "`n" mX "=" mY , , , 2
   obju := []
   obju.n := dotActive
   obju.x := DotPosX
   obju.y := DotPosY
   obju.w := max(cx2, cx1) - min(cx2, cx1)
   obju.h := max(cy2, cy1) - min(cy2, cy1)
   obju.gX := (FlipImgH=1 && doFlips=1) ? cX1 - obju.w : cX1
   obju.gY := (FlipImgV=1 && doFlips=1) ? cY1 - obju.h : cY1
   obju.cX1 := cX1
   obju.cX2 := cX2
   obju.cY1 := cY1
   obju.cY2 := cY2
   obju.line := line ? line : cX1

   Return obju
}

createContextMenuCustomShapeDrawing(mX, mY, dontAddPoint, indexu, bK, givenCoords:=0) {
   deleteMenus()
   If (indexu)
   {
      fr := (bK!=1 && bezierSplineCustomShape=1) ? "P'" : "P"
      mX := Round(customShapePoints[indexu, 1]),
      mY := Round(customShapePoints[indexu, 2])
      kMenu("PVnav", "Add", fr "[" indexu "] = X: " mX " Y: " mY, "dummy")
      kMenu("PVnav", "Disable", fr "[" indexu "] = X: " mX " Y: " mY, "dummy")
   } Else
   {
      kMenu("PVnav", "Add", "X: " mX " Y: " mY, "dummy")
      kMenu("PVnav", "Disable", "X: " mX " Y: " mY, "dummy")
   }

   undos := undoVectorShapesLevelsArray.Count()
   If (currentVectorUndoLevel>1 || undos>1)
   {
      kMenu("PVnav", "Add", "&Undo`tCtrl+Z", "ImgVectorUndoAct")
      kMenu("PVnav", "Add", "&Redo`tCtrl+Y", "ImgVectorRedoAct")
      Menu, PVnav, Add
   }

   If (dontAddPoint=1)
   {
      kMenu("PVnav", "Add", "&Divide point`tDbl-Click", "MenuSplitVectorPoint")
      If (bk=1 && bezierSplineCustomShape=1)
      {
         kMenu("PVnav", "Add", "E&xpand anchors`tAlt-Click", "MenuExpandVectorPointAnchors")
         kMenu("PVnav", "Add", "&Collapse anchors", "MenuCollapseVectorPoint")
      } Else If (bk!=1 && bezierSplineCustomShape=1)
         kMenu("PVnav", "Add", "Separate &fused anchors`tAlt-Click", "MenuExpandVectorPointAnchors")

      canReflect := 0
      If (k!=1 && isInRange(thisIndex, 3, totalCount - 3))
      {
         canReflect := 1
         whichIndex := (k=2) ? thisIndex - 1 : thisIndex + 1
         If (whichIndex=prevVectorShapeSymmetryMode[1, 1])
            canReflect := 0
      }

      If (bk!=1 && bezierSplineCustomShape=1 && canReflect=1)
         kMenu("PVnav", "Add", "&Reflect anchor", "MenuReflectAnchorVectorPoint")
      labelu := (bk=1 && bezierSplineCustomShape=1 || bezierSplineCustomShape!=1) ? "&Remove point" : "Collapse &anchor"
      kMenu("PVnav", "Add", labelu "`tCtrl+Click", "MenuRemVectorPoint")
      kMenu("PVnav", "Add", "S&elect point`tShift+Click", "MenuSelVectorPoint")
      If (!CustomShapeSymmetry && !CustomShapeLockedSymmetry)
      {
         If (bezierSplineCustomShape!=1)
            kMenu("PVnav", "Add", "Paste points here", "MenuPasteVectorPoints")

         kMenu("PVnav", "Add", "Set as sta&rt point", "MenuSetStartVectorPoint")
         kMenu("PVnav", "Add", "Set as symmetry on X axis", "MenuSetVectorShapeSymmetryXPoint")
         kMenu("PVnav", "Add", "Set as symmetry on Y axis", "MenuSetVectorShapeSymmetryYPoint")
      }
   }

   Menu, PVnav, Add
   kMenu("PVnav", "Add", "Select all points`tCtrl+A", "MenuSelAllVectorPoints")
   If (customShapeHasSelectedPoints=1)
   {
      If (bezierSplineCustomShape!=1)
         kMenu("PVnav", "Add", "Cop&y points", "MenuCopyVectorPoints")

      kMenu("PVnav", "Add", "Deselect points`tCtrl+D", "MenuSelNoVectorPoints")
      kMenu("PVnav", "Add", "In&vert points selection`tShift+I", "MenuSelInvertVectorPoints")
      kMenu("PVnav", "Add", "&Delete selected points`tDelete", "MenuRemSelVectorPoints")
      If (bezierSplineCustomShape=1)
      {
         kMenu("PVnav", "Add", "&Collapse anchors for selected points", "MenuCollapseSelectedAnchorPoints")
         kMenu("PVnav", "Add", "&Expand anchors for selected points", "MenuExpandSelectedAnchorPoints")
      }
   }

   If (dontAddPoint!=1)
   {
      Menu, PVnav, Add
      kMenu("PVnav", "Add", "&Done`tEnter", "stopDrawingShape")
      kMenu("PVnav", "Add", "&Cancel / exit pen tool`tEscape", "cancelDrawingShape")
      Menu, PVnav, Add
      kMenu("PVnav", "Add", "&Remove last point`tBackspace", "reduceCustomShapelength")
      If (customShapePoints.Count()<2)
      {
         kMenu("PVnav", "Add", "C&ycle symmetry modes`tY", "toggleBrushSymmetryModes")
      } Else If (CustomShapeLockedSymmetry)
      {
         kMenu("PVnav", "Add/Uncheck", "Toggle symmetry mode`tY", "toggleBrushSymmetryModes")
         If CustomShapeSymmetry
            kMenu("PVnav", "Check", "Toggle symmetry mode`tY")
      } 

      ; kMenu("PVnav", "Add", "Make the shape symmetrical", "MenuCreateShapeSymmetricalVectorShape")
      createMenuSelectShapeTension()
      kMenu("PVnav", "Add", "&Smoothness level", ":PVshapeTension")
      If (bezierSplineCustomShape!=1)
      {
         kMenu("PVnav", "Add/Uncheck", "&Preview new point`tP", "togglePreviewVectorNewPoint")
         If (showNewVectorPointPreview=1)
            kMenu("PVnav", "Check", "&Preview new point`tP")
      } Else
      {
         kMenu("PVnav", "Add/Uncheck", "Auto-reflect anchors`tR", "toggleAutoReflectAnchors")
         If (autoReflectVectorAnchors=1)
            kMenu("PVnav", "Check", "Auto-reflect anchors`tR")
      }

      kMenu("PVnav", "Add/Uncheck", "Show viewport &grid`tAlt+=", "toggleViewPortGridu")
      If (showViewPortGrid=1)
         kMenu("PVnav", "Check", "Show viewport &grid`tAlt+=")

      kMenu("PVnav", "Add/UnCheck", "&Show toolbar`tShift+F10", "toggleAppToolbar")
      If (ShowAdvToolbar=1)
         kMenu("PVnav", "Check", "&Show toolbar`tShift+F10")

      kMenu("PVnav", "Add/Uncheck", "&Open ended path`tO", "toggleOpenClosedLineCustomShape", "opened closed vector")
      If (closedLineCustomShape=0)
         kMenu("PVnav", "Check", "&Open ended path`tO")

      createMenuImgSizeAdapt("bonus")
      kMenu("PVnav", "Add", "Vie&wport options", ":PvImgAdapt")
   }

   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVnav") : givenCoords
   showThisMenu("PVnav")
}

MenuSplitVectorPoint() {
  lastOtherWinClose := 1
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  addNewVectorShapePoints(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "DoubleClick", 0, 0)
}

MenuRemVectorPoint() {
  lastOtherWinClose := 1
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  addNewVectorShapePoints(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "remClick", 0, 0)
}

MenuSelAllVectorPoints() {
   Loop, % initialDrawingStartCoords.Count()
       initialDrawingStartCoords[A_Index, 3] := 1

   customShapeHasSelectedPoints := 1
   lastZeitFileSelect := A_TickCount
   showTOOLtip("Selected all " groupDigits(customShapePoints.count()) " path points")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuSelNoVectorPoints() {
   Loop, % initialDrawingStartCoords.Count()
       initialDrawingStartCoords[A_Index, 3] := 0

   customShapeHasSelectedPoints := 0
   lastZeitFileSelect := A_TickCount
   showTOOLtip("Deselected all " groupDigits(customShapePoints.count()) " path points")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuSetVectorShapeSymmetryXPoint() {
   configVectorShapeSymmetryPoint("x", 0, 0)
}

MenuSetVectorShapeSymmetryYPoint() {
   configVectorShapeSymmetryPoint("y", 0, 0)
}

configVectorShapeSymmetryPoint(modus, silentu, givenIndex) {
   If (bezierSplineCustomShape=1)
      autoDeactivateClosedBezier()

   totalLoops := customShapePoints.Count()
   If (totalLoops<3)
      Return

   lastOtherWinClose := 1
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If givenIndex
      thisIndex := givenIndex
   Else
      thisIndex := addNewVectorShapePoints(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "setStart", 0, 1)

   getVPcoordsVectorPoint(thisIndex, gX, gY)
   If (bezierSplineCustomShape=1)
   {
      ignorePoints := []
      listuArray := getPointsSameCoordsVectorPath(totalLoops, thisIndex, gX, gY)
      Loop, % listuArray.Count()
      {
         p := listuArray[A_Index, 1]
         ignorePoints[p] := 1
      }
   }

   ; ToolTip, % totalLoops "=" modus "=" silentu "=" givenIndex , , , 2
   uneven := (totalLoops//2 != totalLoops/2) ? 1 : 0
   leftSideXH := rightSideXH := 0
   topSideYV := bottomSideYV := 0
   Loop, % totalLoops
   {
      If (uneven=1 && thisIndex=A_Index) || (ignorePoints[A_Index]=1 && bezierSplineCustomShape=1)
         Continue

      getVPcoordsVectorPoint(A_Index, xu, yu)
      If (modus="x")
      {
         If (xu<gX)
            leftSideXH++
         Else
            rightSideXH++
      } Else
      {
         If (yu<gY)
            topSideYV++
         Else
            bottomSideYV++
      }
   }

   getVPcoordsVectorPoint(1, fxu, fyu)
   getVPcoordsVectorPoint(totalLoops, exu, eyu)
   If (modus="x")
   {
      If (fxu<gX && exu<gX) || (fxu>gX && exu>gX)
         errMsgNow := "ERROR: The start point and the end point are on the same side of the designated symmetry.`nPlease change the start point to have the X axis of symmetry split the end points."
   } Else
   {
      If (fyu<gY && eyu<gY) || (fyu>gY && eyu>gY)
         errMsgNow := "ERROR: The start point and the end point are on the same side of the designated symmetry.`nPlease change the start point to have the Y axis of symmetry split the end points."
   }

   ; fnOutputDebug(A_ThisFunc "(" modus "," silentu ", " givenIndex "): " thisIndex " | " kX "=" kY " || " fX "=" fY)
   If (modus="x" && !errMsgNow)
   {
      If (leftSideXH!=rightSideXH)
         errMsgNow := "ERROR: The number of points do not correspond.`nLeft side: " leftSideXH "`nRight side: " rightSideXH "`nPlease choose another point."
   } Else If !errMsgNow
   {
      If (topSideYV!=bottomSideYV)
         errMsgNow := "ERROR: The number of points do not correspond.`nTop side: " topSideYV "`nBottom side: " bottomSideYV "`nPlease choose another point."
   }

   If (silentu!=1 && errMsgNow)
   {
      showTOOLtip(errMsgNow)
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime*2
      Return
   } Else If errMsgNow
   {
      addJournalEntry(A_ThisFunc "(): " errMsgNow)
      Return
   }

   cA := customShapePoints[thisIndex]
   fX := prevResizedVPimgW/initialDrawingStartCoords[thisIndex, 4]
   fY := prevResizedVPimgH/initialDrawingStartCoords[thisIndex, 5]
   vpSymmetryPointX := cA[1]*fX
   vpSymmetryPointY := cA[2]*fY
   vpSymmetryPointXdp := initialDrawingStartCoords[thisIndex, 1]
   vpSymmetryPointYdp := initialDrawingStartCoords[thisIndex, 2]
   thisu := (modus="x") ? 1 : 2
   CustomShapeSymmetry := CustomShapeLockedSymmetry := thisu
   ; vpFreeformShapeOffset := []
   prevVectorShapeSymmetryMode[1] := [thisIndex, thisu]
   SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuExpandSelectedAnchorPoints() {
    k := 0
    totalCount := customShapePoints.Count()
    canDoSymmetry := isNowSymmetricVectorShape()
    Loop, % totalCount
    {
        thisIndex := A_Index
        selu := initialDrawingStartCoords[thisIndex, 3]
        c := customShapePoints[thisIndex]
        k := clampInRange(k + 1, 1, 3, 1)
        If (c[1]="" || c[2]="" || selu!=1 || lol[thisIndex]=1 || k!=1)
           Continue

        oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
        expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, c[1], c[2])
    }
    If (preventUndoLevels!=1)
       recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())

    lastZeitFileSelect := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuCollapseSelectedAnchorPoints() {
    k := hasFoundDot := 0
    totalCount := customShapePoints.Count()
    canDoSymmetry := isNowSymmetricVectorShape()
    lol := []
    Loop, % totalCount
    {
        thisIndex := A_Index
        selu := initialDrawingStartCoords[thisIndex, 3]
        c := customShapePoints[thisIndex]
        k := clampInRange(k + 1, 1, 3, 1)
        If (c[1]="" || c[2]="" || selu!=1 || lol[thisIndex]=1)
           Continue

        oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
        collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
        lol[thisIndex] := 1
        If (k!=1)
        {
           ; collapse anchors on «delete»
           initialDrawingStartCoords[thisIndex, 3] := 0
           If (oppoIndex!=thisIndex && canDoSymmetry=1)
           {
              lol[oppoIndex] := 1
              initialDrawingStartCoords[oppoIndex, 3] := 0
           }
        } Else
        {
           A := B := 0
           collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
           getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
           If A
           {
              lol[a] := 1
              initialDrawingStartCoords[A, 3] := 1
           }

           If B
           {
              lol[b] := 1
              initialDrawingStartCoords[B, 3] := 1
           }

           If (oppoIndex!=thisIndex && canDoSymmetry=1 && a!=thisIndex && b!=thisIndex && a!=oppoIndex && b!=oppoIndex)
           {
              za := totalCount - a + 1
              zb .= totalCount - b + 1
              If (a!=za && za!=zb && a)
              {
                 initialDrawingStartCoords[za, 3] := 1
                 lol[za] := 1
              }

              If (b!=zb && za!=zb && b)
              {
                 initialDrawingStartCoords[zb, 3] := 1
                 lol[zb] := 1
              }
           }
        }
    }

    customShapeHasSelectedPoints := 0
    Loop, % totalCount
    {
        If initialDrawingStartCoords[A_Index, 3]
        {
           customShapeHasSelectedPoints := 1
           Break
        }
    }
    If (preventUndoLevels!=1)
       recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())

    lastZeitFileSelect := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuReflectAnchorVectorPoint() {
  lastOtherWinClose := 1
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  lastZeitFileSelect := A_TickCount
  addNewVectorShapePoints(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "reflectAnchor", 0, 0, 0)
  SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuRemSelVectorPoints() {
    If (bezierSplineCustomShape=1)
    {
       k := hasFoundDot := 0
       totalCount := customShapePoints.Count()
       canDoSymmetry := isNowSymmetricVectorShape()
       lol := []
       Loop, % totalCount
       {
           thisIndex := A_Index
           selu := initialDrawingStartCoords[thisIndex, 3]
           c := customShapePoints[thisIndex]
           k := clampInRange(k + 1, 1, 3, 1)
           If (c[1]="" || c[2]="" || selu!=1 || lol[thisIndex]=1)
              Continue

           oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
           If (k!=1)
           {
              ; collapse anchors on «delete»
              collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
              initialDrawingStartCoords[thisIndex, 3] := 0
              lol[thisIndex] := 1
              If (oppoIndex!=thisIndex && canDoSymmetry=1)
              {
                 lol[oppoIndex] := 1
                 initialDrawingStartCoords[oppoIndex, 3] := 0
              }
           } Else
           {
              ; select anchors of selected main/key points and below, they all get removed
              A := B := 0
              hasFoundDot := 1
              nextK := getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
              If A
              {
                 lol[a] := 1
                 initialDrawingStartCoords[A, 3] := 1
              }

              If B
              {
                 lol[b] := 1
                 initialDrawingStartCoords[B, 3] := 1
              }

              If (oppoIndex!=thisIndex && canDoSymmetry=1 && a!=thisIndex && b!=thisIndex && a!=oppoIndex && b!=oppoIndex)
              {
                 za := totalCount - a + 1
                 zb .= totalCount - b + 1
                 If (a!=za && za!=zb && a)
                 {
                    initialDrawingStartCoords[za, 3] := 1
                    lol[za] := 1
                 }
 
                 If (b!=zb && za!=zb && b)
                 {
                    initialDrawingStartCoords[zb, 3] := 1
                    lol[zb] := 1
                 }
              }
           }
       }

       If !hasFoundDot
       {
          ; if no main/key points were selected, collapsing anchors is sufficient
          If (preventUndoLevels!=1)
             recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())

          lastZeitFileSelect := A_TickCount
          customShapeHasSelectedPoints := 0
          SetTimer, dummyRefreshImgSelectionWindow, -10
          Return
       }
    }

    newArrayu := []
    newuArrayu := []
    thisIndex := thePoint := 0
    If CustomShapeSymmetry
    {
       hasSymmetry := 1
       thePoint := prevVectorShapeSymmetryMode[1, 1]
       ; initial := thePoint
    }

    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       selu := initialDrawingStartCoords[A_Index, 3]
       If (c[1]="" || c[2]="" || selu=1)
       {
          If (A_Index<thePoint && thePoint)
             thePoint--

          Continue
       }

       thisIndex++
       newuArrayu[thisIndex] := initialDrawingStartCoords[A_Index]
       newArrayu[thisIndex] := c
    }

    If hasSymmetry
       prevVectorShapeSymmetryMode[1, 1] := thePoint
    Else
       CustomShapeLockedSymmetry := 0

    ; nz := prevVectorShapeSymmetryMode[1, 1]
    ; ToolTip, % initial "=l=" thePoint "=" nz , , , 2
    customShapePoints := newArrayu.Clone()
    initialDrawingStartCoords := newuArrayu.Clone()
    customShapeHasSelectedPoints := 0

    If (preventUndoLevels!=1)
       recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())

    lastZeitFileSelect := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuPasteVectorPoints() {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   thisIndex := addNewVectorShapePoints(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "setStart", 0, 1)
   MenuCopyVectorPoints("paste", thisIndex)
}

MenuCopyVectorPoints(modus:=0, givenIndex:=0) {
    Static clipVectorPoints := []
         , clipVectorCoords := []

    thisIndex := 0
    If (modus="paste")
    {
       If !isNumber(givenIndex)
          Return

       Loop, % initialDrawingStartCoords.Count()
             initialDrawingStartCoords[A_Index, 3] := 0
       If (preventUndoLevels!=1)
          recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())

       Loop, % clipVectorPoints.Count()
       {
          c := clipVectorPoints[A_Index].Clone()
          z := clipVectorCoords[A_Index].Clone()
          z[3] := 1
          c[1] += SelDotsSize*2
          c[2] += SelDotsSize*2
          thisIndex++
          customShapePoints.InsertAt(givenIndex, c)
          initialDrawingStartCoords.InsertAt(givenIndex, z)
       }
       customShapeHasSelectedPoints := 1
       If (preventUndoLevels!=1)
          recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())

       showTOOLtip(groupDigits(thisIndex) " points were pasted at P[" givenIndex "]")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       lastZeitFileSelect := A_TickCount
       SetTimer, dummyRefreshImgSelectionWindow, -10
       Return
    }

    nVpoints := []
    nVcoords := []
    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       selu := initialDrawingStartCoords[A_Index, 3]
       If (c[1] && c[2] && selu=1)
       {
          thisIndex++
          nVpoints[thisIndex] := c
          nVcoords[thisIndex] := initialDrawingStartCoords[A_Index]
       }
    }

    If (nVpoints.Count()>2)
    {
       clipVectorPoints := nVpoints.Clone()
       clipVectorCoords := nVcoords.Clone()
       showTOOLtip(groupDigits(thisIndex) " points were copied to private clipboard")
    } Else
    {
       showTOOLtip("WARNING: At least 3 points need to be selected to copy to clipboard")
       SoundBeep 300, 100
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime
    lastZeitFileSelect := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuSelInvertVectorPoints() {
   customShapeHasSelectedPoints := 1
   thisCounter := 0
   Loop, % initialDrawingStartCoords.Count()
   {
       initialDrawingStartCoords[A_Index, 3] := !initialDrawingStartCoords[A_Index, 3]
       If initialDrawingStartCoords[A_Index, 3]
       {
          thisCounter++
          customShapeHasSelectedPoints := 1
       }
   }

   customShapeHasSelectedPoints := thisCounter ? 1 : 0
   lastZeitFileSelect := A_TickCount
   SetTimer, dummyRefreshImgSelectionWindow, -10
   showTOOLtip("Points selection inverted`nTotal: " groupDigits(customShapePoints.count()) "`nSelected: " groupDigits(thisCounter))
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

MenuSelVectorPoint() {
  lastOtherWinClose := 1
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  lastZeitFileSelect := A_TickCount
  addNewVectorShapePoints(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "selClick", 0, 1)
  SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuCollapseVectorPoint() {
  lastOtherWinClose := 1
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  lastZeitFileSelect := A_TickCount
  addNewVectorShapePoints(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "collapseClick", 0, 0, 0)
  SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuExpandVectorPointAnchors() {
  lastOtherWinClose := 1
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  lastZeitFileSelect := A_TickCount
  addNewVectorShapePoints(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "expandClick", 0, 0, 0)
  SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuReverseVectorPoints() {
    MenuSetStartVectorPoint(initialDrawingStartCoords.Count() //2 + 1, "yes")
}

MenuSetStartVectorPoint(given:=0, isGiven:=0) {
  wasGiven := (given>0 && isGiven="yes") ? 1 : 0
  If (CustomShapeLockedSymmetry && wasGiven=0)
  {
     showTOOLtip("WARNING: Symmetry is currently activated. `nIt is not allowed to change the start point.")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  totalLoops := initialDrawingStartCoords.Count()
  If (totalLoops<3)
     Return

  lastOtherWinClose := 1
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  If (wasGiven=1)
     newStartPoint := given
  Else
     newStartPoint := addNewVectorShapePoints(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "setStart", 0, 1)

  newStartCoords := []
  Loop, % totalLoops - newStartPoint
      newStartCoords[A_Index] := initialDrawingStartCoords[A_Index + newStartPoint - 1]
  Loop, % newStartPoint - 1
      newStartCoords[A_Index + totalLoops - newStartPoint] := initialDrawingStartCoords[A_Index]
  newStartCoords.InsertAt(1 + totalLoops - newStartPoint, initialDrawingStartCoords[totalLoops])

  newArrayu := []
  totalLoops := customShapePoints.Count()
  Loop, % totalLoops - newStartPoint
      newArrayu[A_Index] := customShapePoints[A_Index + newStartPoint - 1]
  Loop, % newStartPoint - 1
      newArrayu[A_Index + totalLoops - newStartPoint] := customShapePoints[A_Index]
  newArrayu.InsertAt(1 + totalLoops - newStartPoint, customShapePoints[totalLoops])

  ; r := totalLoops - newStartPoint
  ; d := newStartPoint - 1
  ; e := 1 + totalLoops - newStartPoint
  ; f := d + totalLoops - newStartPoint
  ; newu := newArrayu.Count()
  ; ToolTip, % totalLoops "==" newu "|" r "|" d "|" e "|" f , , , 2
  initialDrawingStartCoords := newStartCoords.Clone()
  customShapePoints := newArrayu.Clone()
  If (preventUndoLevels!=1)
     recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())

  lastZeitFileSelect := A_TickCount
  SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuToggleBezierMode() {
   bezierSplineCustomShape := !bezierSplineCustomShape
   FillAreaCurveTension := (bezierSplineCustomShape=1) ? 5 : 3
   friendly := (bezierSplineCustomShape=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Bézier path mode: " friendly, A_ThisFunc, 1)
   performBezierAutoFixNow()
   decideCustomShapeStyle()
   RegAction(1, "FillAreaCurveTension")
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()

   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(100)
}

performBezierAutoFixNow() {
   PointsCount := customShapePoints.Count()
   If (bezierSplineCustomShape=1 && PointsCount>0)
   {
      r := mod(PointsCount, 3)
      ; ToolTip, % "r=" r, , , 2
      c := customShapePoints[PointsCount]
      d := initialDrawingStartCoords[PointsCount]
      loops := (r=2) ? 2 : 1
      If (r=1)
         loops := 0

      Loop, % loops
      {
         customShapePoints.Push(c.Clone())
         initialDrawingStartCoords.Push(d.Clone())
      }
      ; ToolTip, % "l=" loops , , , 2
   }
}

addNewVectorShapePoints(mX, mY, mainWidth, mainHeight, mainParam, ctrlState, shiftState, altState:=0) {
; the following array is used when editing the vector shape to hold details about viewport conditions when user added/modified points:
   ; initialDrawingStartCoords[A_Index] := [prevDestPosX, prevDestPosY, isSelected, prevResizedVPimgW, prevResizedVPimgH]

; the main array is:
   ; customShapePoints[A_Index] := [x, y]
   ; it holds the actual coords of the points, the data is held in pixels units when user edits the shape; when not, the values are relative to a rect bound box [0 to 1]

   Critical, on
   Static lastInvoked := A_TickCount, lastIndex
   ; If (A_tickcount - lastInvoked<50)
   ;    Return
   If (mainParam="setStart") || (A_TickCount - lastOtherWinClose<250)
      Return lastIndex

   ; fnOutputDebug(A_ThisFunc "(): " lastIndex " | " mX "=" mY " || " mainParam)
   If (mainParam="rClick")
   {
      lastUserRclickVPx := mX
      lastUserRclickVPy := mY
   }

   If !IsObject(customShapePoints)
      customShapePoints := []

   gmX := (FlipImgH=1) ? mainWidth - mX : mX
   gmY := (FlipImgV=1) ? mainHeight - mY : mY
   selu := oppoIndex := doSpecialAct := dontAddPoint := dotRemoved := 0
   hasFoundDot := k := thisIndex := thisState := prevState := 0
   totalCount := customShapePoints.Count()
   canDoSymmetry := isNowSymmetricVectorShape()
   startOperation := A_TickCount
   sl := SelDotsSize//2 + 1
   Loop, % totalCount
   {
       ; determine user clicked point from the entire path
       thisIndex := A_Index
       oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
       c := customShapePoints[thisIndex]
       selu := initialDrawingStartCoords[thisIndex, 3]
       getVPcoordsVectorPoint(thisIndex, xu, yu)
       If (bezierSplineCustomShape=1)
          k := clampInRange(k + 1, 1, 3, 1)

       If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
       {
          hasFoundDot := 1
          If (k!=1 && bezierSplineCustomShape=1)
          {
             ; if an anchor point, determine if other points in the array proximity share the same coordinates
             ; if they do, then set the next key point [q point thats not an anchor] as the point that was clicked
             ; this prevents users from clicking on anchors when they click on «key» points

             ; TulTip(0, "|    ", k, thisIndex, a, b, nextK)
             nextK := getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
             If (isDotInRect(c[1], c[2], sl, sl, customShapePoints[A, 1], customShapePoints[A, 2], 1)
             || isDotInRect(c[1], c[2], sl, sl, customShapePoints[B, 1], customShapePoints[B, 2], 1)
             || isDotInRect(c[1], c[2], sl, sl, customShapePoints[nextK, 1], customShapePoints[nextK, 2], 1))
             {
                thisIndex := nextK
                oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
                If !selu
                   selu := initialDrawingStartCoords[thisIndex, 3]
                getVPcoordsVectorPoint(thisIndex, xu, yu)
                k := 1
             }
          }
          dontAddPoint := 1
          Break
       }
   }

   If hasFoundDot
   {
      ; perform action[s] on thisIndex point from customShapePoints
      If (mainParam="DoubleClick" && totalCount>2 && shiftState=0 && ctrlState=0 && altState=0)
      {
         dontAddPoint := 1
         splitPointGivenInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
      } Else If (shiftState=1 || mainParam="selClick")
      {
         dontAddPoint := 1
         lastZeitFileSelect := A_TickCount
         selectGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, mainParam, gmX, gmY)
      } Else If (mainParam="collapseClick")
      {
         doSpecialAct := dontAddPoint := 1
         collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
      } Else If (mainParam="reflectAnchor")
      {
         doSpecialAct := dontAddPoint := 1
         reflectGivenAnchorInPath(k, totalCount, thisIndex, canDoSymmetry)
      } Else If (mainParam="expandClick") || (altState=1 && mainParam="DoubleClick" && bezierSplineCustomShape=1 && k=1)
      {
         doSpecialAct := dontAddPoint := 1
         expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
      } Else If (ctrlState=1 || mainParam="remClick")
      {
         dotRemoved := 1
         removeGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
      } Else If (mainParam!="remClick" && mainParam!="rClick" && ctrlState=0 && altState=0 && shiftState=0)
      {
         If (customShapeHasSelectedPoints=1 && selu=1)
         {
            ; drag/move selected points
            moveSelectedPointsInVectorPath(gmX, gmY)
            dontAddPoint := doSpecialAct := 1
         } Else
         { 
            dontAddPoint := 1
            mustRem := moveOnePointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY, altState)
         }
      }
   } Else thisIndex := 0

   If (dontAddPoint && thisIndex)
      lastIndex := thisIndex

   If (mustRem=1)
      RemoveTooltip()

   If (mainParam="rClick" && dotRemoved!=1)
   {
      createContextMenuCustomShapeDrawing(mX, mY, dontAddPoint, thisIndex, k)
      Return lastIndex
   }

   If (customShapeHasSelectedPoints=1 && doSpecialAct!=1 && dotRemoved!=1 && dontAddPoint!=1 && !InStr(mainParam, "pen-") && ctrlState=0 && altState=0)
   {
      dontAddPoint := 1
      If (mainParam="DoubleClick" && customShapeHasSelectedPoints=1)
         SetTimer, MenuSelNoVectorPoints, -50
      Else
         rescaleSelectedVectorPoints()
   }

   ; If (FlipImgH=1 || FlipImgV=1)
      ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If (doSpecialAct!=1 && dotRemoved!=1 && dontAddPoint!=1 && mainParam!="DoubleClick" && !InStr(mainParam, "pen-") && ctrlState=0 && altState=0)
   {
      ; actually add new point[s] to path, if nothing else happened before ^_^ 
      If (mustSnapLiveDrawPoints=1 && thisIndex)
      {
         gmX := VPstampBMPx,   gmY := VPstampBMPy
      }

      hasSymmetry := 0
      mustSnapLiveDrawPoints := 0
      If (CustomShapeSymmetry=1 && vpSymmetryPointX)
      {
          hasSymmetry := 1
          vpSymX := Round(vpSymmetryPointX) - (vpSymmetryPointXdp - prevDestPosX)
          gmXa := vpSymX - (gmX - vpSymX)
          If (gmX<vpSymX)
          {
             ; I do not know why it works, I do not understand it. I do not remember its logic ^_^ 
             gmc := gmX,  gmd := gmXa
             gmXa := gmX, gmX := gmd
          }
          pushAtGivenVectorPoint(1, gmXa, gmY)
      } Else If (CustomShapeSymmetry=2 && vpSymmetryPointY)
      {
          hasSymmetry := 1
          vpSymY := Round(vpSymmetryPointY) - (vpSymmetryPointYdp - prevDestPosY)
          gmYa := vpSymY - (gmY - vpSymY)
          If (gmY<vpSymY)
          {
             ; I do not know why it works, I do not understand it. I do not remember its logic ^_^ 
             gmc := gmY,  gmd := gmYa
             gmYa := gmY, gmY := gmd
          }
          pushAtGivenVectorPoint(1, gmX, gmYa)
      } Else CustomShapeLockedSymmetry := 0

      thisIndex := pushEndNewVectorPoint(gmX, gmY)
      If (customShapePoints.Count()=3 && CustomShapeSymmetry)
         prevVectorShapeSymmetryMode[1, 1] := 2 
      ; klp := prevVectorShapeSymmetryMode[1, 1]
      ; ToolTip, % "klp =" klp , , , 2
      If (bezierSplineCustomShape=1 && thisIndex>2)
      {
         fn := Func("adjustAnchorPointsCustomShape").Bind(thisIndex + 1)
         SetTimer, % fn, -20
      } Else If (hasSymmetry!=1 && shiftState=0 && bezierSplineCustomShape=0)
         SetTimer, addFluidPointsCustomShape, -200
   }

   If (preventUndoLevels!=1)
      recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())

   lastInvoked := A_TickCount
   SetTimer, dummyRefreshImgSelectionWindow, -5
}

autoDeactivateClosedBezier() {
   r := testIsBezierPathClosed()
   If (r=1)
   {
      closedLineCustomShape := 0
      reduceCustomShapelength()
      If (testIsBezierPathClosed()=1)
         reduceCustomShapelength()

      RegAction(1, "closedLineCustomShape")
      If (drawingShapeNow=1)
         showQuickActionButtonsDrawingShape()
   }
}

pushEndNewVectorPoint(gmX, gmY, noCloseTest:=0) {
   If (bezierSplineCustomShape=1 && noCloseTest=0)
      autoDeactivateClosedBezier()

   customShapePoints.Push([gmX, gmY])
   prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] + 1
   thisIndex := customShapePoints.MaxIndex()
   initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH, 0]
   If (bezierSplineCustomShape=1)
   {
      customShapePoints.Push([gmX, gmY])
      initialDrawingStartCoords[thisIndex + 1] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH, 1]
      prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] + 1
      If (thisIndex>4)
      {
         customShapePoints.Push([gmX, gmY])
         initialDrawingStartCoords[thisIndex + 2] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH, 1]
         prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] + 1
      }
   }
   Return thisIndex
}

pushAtGivenVectorPoint(givenIndex, gmX, gmY) {
   pushed := 1
   customShapePoints.InsertAt(givenIndex, [gmX, gmY])
   initialDrawingStartCoords.InsertAt(givenIndex, [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH, 0])
   thisIndex := customShapePoints.MaxIndex()
   If (bezierSplineCustomShape=1)
   {
      customShapePoints.InsertAt(givenIndex, [gmX, gmY])
      initialDrawingStartCoords.InsertAt(givenIndex, [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH, 1])
      pushed++
      If (thisIndex>4)
      {
         pushed++
         customShapePoints.InsertAt(givenIndex, [gmX, gmY])
         initialDrawingStartCoords.InsertAt(givenIndex, [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH, 1])
      }
   }
   Return pushed
}

splitPointGivenInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY) {
   If (bezierSplineCustomShape=1)
   {
      endsConnected := ((thisIndex<=2 || thisIndex>=(totalCount - 1)) && testIsBezierPathClosed()=1) ? 1 : 0
      If endsConnected
      {
         expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
         expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY, "no")
         closedLineCustomShape := 0
         RegAction(1, "closedLineCustomShape")
         If (drawingShapeNow=1)
            showQuickActionButtonsDrawingShape()
         Return
      }
   }

   Random, slx, % SelDotsSize//2 + 1, SelDotsSize*3
   Random, sly, % SelDotsSize//2 + 1, SelDotsSize*3
   Random, r1, -1, 1
   Random, r2, -1, 1
   slx := (r1<0) ? -1*slx : slx
   sly := (r2<0) ? -1*sly : sly

   selu := initialDrawingStartCoords[thisIndex, 3]
   customShapePoints[thisIndex] := [gmX, gmY]
   initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY, selu, prevResizedVPimgW, prevResizedVPimgH]
   If (k=3 && bezierSplineCustomShape=1 || bezierSplineCustomShape!=1)
      pushAtGivenVectorPoint(thisIndex, gmX - slx, gmY - sly)
   Else If (k=1 && bezierSplineCustomShape=1 && thisIndex!=1)
      pushAtGivenVectorPoint(thisIndex - 1, gmX - slx, gmY - sly)
   Else If (k=2 && bezierSplineCustomShape=1)
      pushAtGivenVectorPoint(thisIndex + 1, gmX - slx, gmY - sly)

   If (oppoIndex!=thisIndex && canDoSymmetry=1)
   {
      hasSymmetry := calculateSymmetricVectorPoint(gmX, gmY, nX, nY)
      If (thisIndex < oppoIndex)
         oppoIndex++

      customShapePoints[oppoIndex] := [nX, nY]
      initialDrawingStartCoords[oppoIndex] := [prevDestPosX, prevDestPosY, selu, prevResizedVPimgW, prevResizedVPimgH]

      hasSymmetry := calculateSymmetricVectorPoint(gmX - slx, gmY - sly, nX, nY)
      If (k=3 && bezierSplineCustomShape=1 || bezierSplineCustomShape!=1)
         pushed := pushAtGivenVectorPoint(oppoIndex, nX, nY)
      Else If (k=1 && bezierSplineCustomShape=1 && thisIndex!=1)
         pushed := pushAtGivenVectorPoint(oppoIndex - 1, nX, nY)
      Else If (k=2 && bezierSplineCustomShape=1)
         pushed := pushAtGivenVectorPoint(oppoIndex + 1, nX, nY)

      prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] + pushed
   } Else If (CustomShapeLockedSymmetry && oppoIndex=-1)
   {
      prevVectorShapeSymmetryMode[1, 2] := 0
      CustomShapeLockedSymmetry := 0
   }
   dummyRefreshImgSelectionWindow()
}

expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY, dummy:=0) {
   endsConnected := ((thisIndex=1 || thisIndex=totalCount) && testIsBezierPathClosed()=1) ? 1 : 0
   If (endsConnected=1 && dummy!="no")
   {
      w := getPointsSameCoordsVectorPath(totalCount, 1, gmX, gmY)
      g := getPointsSameCoordsVectorPath(totalCount, totalCount - 2, gmX, gmY)
      Loop, % w.Count()
         g.Push(w[A_Index])

      auxiliaryPoints := []
      Loop, % g.Count()
      {
         thisIndex := g[A_Index, 1]
         If (thisIndex!=1 && thisIndex!=totalCount)
            auxiliaryPoints.Push(g[A_Index])
      }
      nextK := totalCount
   } Else
   {
      nextK := getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
      auxiliaryPoints := getPointsSameCoordsVectorPath(totalCount, thisIndex, gmX, gmY)
   }

   If (auxiliaryPoints.Count()<1 && endsConnected=1 || !endsConnected || dummy="no")
      auxiliaryPoints2 := getPointsSameCoordsVectorPath(totalCount, nextK, customShapePoints[nextK, 1], customShapePoints[nextK, 2])

   initial := auxiliaryPoints.Count()
   Loop, % auxiliaryPoints2.Count()
      auxiliaryPoints.Push(auxiliaryPoints2[A_Index])

   hasFoundDot := 0
   Loop, % auxiliaryPoints.Count()
   {
      If (auxiliaryPoints[A_Index, 1]=thisIndex)
         Continue

      isOkay := (auxiliaryPoints[A_Index, 1]=A || auxiliaryPoints[A_Index, 1]=B) ? 1 : 0
      If !isOkay
         Continue

      hasFoundDot := 1
   }

   Loop, % auxiliaryPoints.Count()
   {
      If (auxiliaryPoints[A_Index, 1]=thisIndex)
         Continue

      isOkay := (auxiliaryPoints[A_Index, 1]=A || auxiliaryPoints[A_Index, 1]=B) ? 1 : 0
      If (!isOkay && hasFoundDot=1)
      || (hasFoundDot=0 && A_Index>initial)
         Continue

      Random, slx, % SelDotsSize//1.5 + 1, SelDotsSize*3
      Random, sly, % SelDotsSize//1.5 + 1, SelDotsSize*3
      Random, r1, -1, 1
      Random, r2, -1, 1
      slx := (r1<0) ? -1*slx : slx
      sly := (r2<0) ? -1*sly : sly
      customShapePoints[auxiliaryPoints[A_Index, 1]] := [gmX + slx, gmY + sly]
      initialDrawingStartCoords[auxiliaryPoints[A_Index, 1]] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
      If (oppoIndex!=thisIndex && canDoSymmetry=1)
      {
         calculateSymmetricVectorPoint(gmX + slx, gmY + sly, nX, nY)
         customShapePoints[auxiliaryPoints[A_Index, 2]] := [nX, nY]
         initialDrawingStartCoords[auxiliaryPoints[A_Index, 2]] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
      }
   } 
   lastZeitFileSelect := A_TickCount
   SetTimer, dummyRefreshImgSelectionWindow, -50
}

reflectGivenAnchorInPath(k, totalCount, thisIndex, canDoSymmetry, forceIT:=0) {
   ; this assumes drawingShapeNow = 1
   If (k!=1 && isInRange(thisIndex, 2, totalCount - 1))
   {
      If (thisIndex=2 || thisIndex=(totalCount - 1))
      {
         r := testIsBezierPathClosed()
         If (r!=1)
            Return
      }

      whichIndex := (k=2) ? thisIndex - 1 : thisIndex + 1
      If (whichIndex=prevVectorShapeSymmetryMode[1, 1] && canDoSymmetry && forceIT!=1)
         Return

      ; whichIndex = key point , to which the anchors belong to
      getVPcoordsVectorPoint(whichIndex, xA, yA)

      ; thisIndex = anchor to be reflected
      getVPcoordsVectorPoint(thisIndex, xB, yB)
      w := max(xA, xB) - min(xA, xB)
      h := max(yA, yB) - min(yA, yB)
      gmX := (xA<xB) ? xA - w : xA + w
      gmY := (yA<yB) ? yA - h : yA + h

      ; indexu = «destination» anchor for the reflected whichIndex anchor
      indexu := (k=2) ? thisIndex - 2 : thisIndex + 2
      If (r=1)
         indexu := (k=2) ? totalCount - 1 : 2

      customShapePoints[indexu] := [gmX, gmY]
      customShapePoints[thisIndex] := [xB, yB]
      ; ToolTip, % k "A[" whichIndex "]=" cA[1] "|" cA[2] "`nB[" thisIndex "]=" cB[1] "|" cB[2] "`nC[" indexu "]" gmX "|" gmY  , , , 2
      
      selu := initialDrawingStartCoords[thisIndex, 3]
      z := [prevDestPosX, prevDestPosY, selu, prevResizedVPimgW, prevResizedVPimgH]
      initialDrawingStartCoords[thisIndex] := z.Clone()
      initialDrawingStartCoords[indexu] := z.Clone()

      If (oppoIndex!=thisIndex && canDoSymmetry=1 && !r)
      {
         oppoIndex := totalCount - indexu + 1
         calculateSymmetricVectorPoint(gmX, gmY, nX, nY)
         customShapePoints[oppoIndex] := [nX, nY]
         initialDrawingStartCoords[oppoIndex] := z.Clone()
      
         oppoIndex := totalCount - thisIndex + 1
         calculateSymmetricVectorPoint(xB, yB, gX, gY)
         initialDrawingStartCoords[oppoIndex] := z.Clone()
         customShapePoints[oppoIndex] := [gX, gY]
      }
   }
}

reflectGivenAnchorInAltPath(ByRef PointsList, thisIndex, indexu, whichIndex) {
   ; this assumes drawingShapeNow = 0
   ; whichIndex = key point , to which the anchors belong to
   xA := PointsList[whichIndex*2 - 1], yA := PointsList[whichIndex*2]

   ; thisIndex = anchor to be reflected
   xB := PointsList[thisIndex*2 - 1], yB := PointsList[thisIndex*2]

   w := max(xA, xB) - min(xA, xB)
   h := max(yA, yB) - min(yA, yB)
   gmX := (xA<xB) ? xA - w : xA + w
   gmY := (yA<yB) ? yA - h : yA + h

   ; indexu = «destination» anchor for the reflected whichIndex anchor
   PointsList[indexu*2 - 1] := gmX
   PointsList[indexu*2] := gmY
   ; ToolTip, % k "A[" whichIndex "]=" xA "|" yA "`nB[" thisIndex "]=" xB "|" yB "`nC[" indexu "]=" gmX "|" gmY  , , , 2
}

getVPcoordsVectorPoint(whichIndex, ByRef X, ByRef Y) {
   cA := customShapePoints[whichIndex]
   fX := prevResizedVPimgW/initialDrawingStartCoords[whichIndex, 4]
   fY := prevResizedVPimgH/initialDrawingStartCoords[whichIndex, 5]
   x := cA[1]*fX - (initialDrawingStartCoords[whichIndex, 1]*fX - prevDestPosX)
   y := cA[2]*fY - (initialDrawingStartCoords[whichIndex, 2]*fY - prevDestPosY)
}

collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry) {
   If (k=2)
   {
      c := customShapePoints[thisIndex - 1]
      customShapePoints[thisIndex] := [c[1], c[2]]
      z := initialDrawingStartCoords[thisIndex - 1]
      initialDrawingStartCoords[thisIndex] := z.Clone()
      If (oppoIndex!=thisIndex && canDoSymmetry=1)
      {
         c := customShapePoints[totalCount - (thisIndex - 1) + 1]
         customShapePoints[oppoIndex] := [c[1], c[2]]
         z := initialDrawingStartCoords[totalCount - (thisIndex - 1) + 1]
         initialDrawingStartCoords[oppoIndex] := z.Clone()
      }
   } Else If (k=3)
   {
      c := customShapePoints[thisIndex + 1]
      customShapePoints[thisIndex] := [c[1], c[2]]
      z := initialDrawingStartCoords[thisIndex + 1]
      initialDrawingStartCoords[thisIndex] := z.Clone()
      If (oppoIndex!=thisIndex && canDoSymmetry=1)
      {
         c := customShapePoints[totalCount - (thisIndex + 1) + 1]
         customShapePoints[oppoIndex] := [c[1], c[2]]
         z := initialDrawingStartCoords[totalCount - (thisIndex + 1) + 1]
         initialDrawingStartCoords[oppoIndex] := z.Clone()
      }
   } Else If (k=1)
   {
      endsConnected := ((thisIndex=1 || thisIndex=totalCount) && testIsBezierPathClosed()=1) ? 1 : 0
      If endsConnected
      {
         z := initialDrawingStartCoords[1]
         c := customShapePoints[1]
         customShapePoints[2] := [c[1], c[2]]
         initialDrawingStartCoords[2] := z.Clone()
         customShapePoints[totalCount - 1] := [c[1], c[2]]
         initialDrawingStartCoords[totalCount - 1] := z.Clone()
      } Else
      {
         z := initialDrawingStartCoords[thisIndex]
         c := customShapePoints[thisIndex]
         If (thisIndex + 1<=totalCount)
         {
            customShapePoints[thisIndex + 1] := [c[1], c[2]]
            initialDrawingStartCoords[thisIndex + 1] := z.Clone()
         }

         If (thisIndex - 1>=1)
         {
            customShapePoints[thisIndex - 1] := [c[1], c[2]]
            initialDrawingStartCoords[thisIndex - 1] := z.Clone()
         }
      }

      oppoIndex := totalCount - thisIndex + 1
      If (oppoIndex!=thisIndex && canDoSymmetry=1 && !endsConnected)
      {
         z := initialDrawingStartCoords[oppoIndex]
         c := customShapePoints[oppoIndex]
         If (oppoIndex + 1 <= totalCount)
         {
            customShapePoints[oppoIndex + 1] := [c[1], c[2]]
            initialDrawingStartCoords[oppoIndex + 1] := z.Clone()
         }

         If (oppoIndex - 1>=1)
         {
            customShapePoints[oppoIndex - 1] := [c[1], c[2]]
            initialDrawingStartCoords[oppoIndex - 1] := z.Clone()
         }
      }
   }
   lastZeitFileSelect := A_TickCount
   SetTimer, dummyRefreshImgSelectionWindow, -50
}

rescaleSelectedVectorPoints() {
   thisState := prevState := 0
   GetMouseCoord2wind(PVhwnd, omX, omY)
   newArrayu := customShapePoints.Clone()
   setwhileLoopExec(1)
   minX := minY := 8823893348934389
   maxX := maxY := -8823893348934389
   If GetKeyState("Shift", "P")
      lockedAR := 1

   Loop, % customShapePoints.Count()
   {
      c := newArrayu[A_Index]
      selu := initialDrawingStartCoords[A_Index, 3]
      If (c[1]="" || c[2]="" || selu!=1)
         Continue

      minX := min(minX, c[1])
      minY := min(minY, c[2])
      maxX := max(maxX, c[1])
      maxY := max(maxY, c[2])
   }

   avgX := (minX + maxX)//2
   avgY := (minY + maxY)//2

   startOperation := A_TickCount
   While, (determineLClickstate()=1)
   {
      If (A_TickCount - startOperation<125)
         Continue

      If (A_TickCount - startOperation<1025)
      {
         If GetKeyState("Shift", "P")
            lockedAR := 1
      }

      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      gmX := omX/mX
      gmY := omY/mY
      If (lockedAR=1)
         gmX := gmY := max(gmX, gmY)

      thisState := "a" gmX "=" gmY
      If (thisState!=prevState)
      {
         prevState := thisState
         Loop, % customShapePoints.Count()
         {
            c := newArrayu[A_Index]
            selu := initialDrawingStartCoords[A_Index, 3]
            If (c[1]="" || c[2]="" || selu!=1)
               Continue

            diffX := avgX - avgX * gmX
            diffY := avgY - avgY * gmY
            xu := c[1] * gmX + diffX
            yu := c[2] * gmY + diffY
            customShapePoints[A_Index] := [xu, yu]
         }
         showTOOLtip("Scale selected points:`nX=" Round(gmX, 3) ", Y=" Round(gmY, 3))
         dummyRefreshImgSelectionWindow()
      }
      Sleep, 5
   }

   setwhileLoopExec(0)
   RemoveTooltip()
   newArrayu := []
   Return 1
}

moveOnePointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY, altState) {
   soX := soY := doX := doY := poX := poY := hasLooped := mustRem := 0
   mustSnapLiveDrawPoints := 0
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   c := customShapePoints[thisIndex]
   setwhileLoopExec(1)
   startOperation := A_TickCount

   While, (determineLClickstate()=1)
   {
        If (A_TickCount - startOperation<150)
           Continue

        If (hasLooped=0)
        {
           hasLooped := 1
           If (k=1 && autoReflectVectorAnchors=1 && bezierSplineCustomShape=1)
              endsConnected := ((thisIndex=1 || thisIndex=totalCount) && testIsBezierPathClosed()=1) ? 1 : 0

           getVPcoordsVectorPoint(thisIndex, soX, soY)
           If (endsConnected=1)
           {
              getVPcoordsVectorPoint(2, poX, poY)
              getVPcoordsVectorPoint(totalCount - 1, doX, doY)
           } Else
           {
              getVPcoordsVectorPoint(thisIndex + 1, poX, poY)
              getVPcoordsVectorPoint(thisIndex - 1, doX, doY)
           }

           If (k=1 && autoReflectVectorAnchors=1 && bezierSplineCustomShape=1)
           {
              If (thisIndex + 1 <= totalCount)
                 initialDrawingStartCoords[thisIndex + 1] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
              If (thisIndex - 1 >= 1)
                 initialDrawingStartCoords[thisIndex - 1] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
           }

           initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
           If ((CustomShapeSymmetry=1 && vpSymmetryPointX) || (CustomShapeSymmetry=1 && vpSymmetryPointX)) && (altState=0)
              initialDrawingStartCoords[oppoIndex] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]

           If (bezierSplineCustomShape=1)
           {
              auxiliaryPoints := getPointsSameCoordsVectorPath(totalCount, thisIndex, gmX, gmY)
              ; ToolTip, % auxiliaryPoints[1, 1] "==" auxiliaryPoints.Count() , , , 2
              Loop, % auxiliaryPoints.Count()
              {
                  initialDrawingStartCoords[auxiliaryPoints[A_Index, 1]] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
                  If (altState=0 && canDoSymmetry=1)
                     initialDrawingStartCoords[auxiliaryPoints[A_Index, 2]] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
              }
           }
        }

        zeitSillyPrevent := A_TickCount
        GetMouseCoord2wind(PVhwnd, mX, mY)
        gmX := (FlipImgH=1) ? mainWidth - mX : mX
        gmY := (FlipImgV=1) ? mainHeight - mY : mY
        If GetKeyState("Shift", "P")
        {
           snapPointsAtAngles(gmX, gmY, c[1], c[2], gmX, gmY)
           gmX := Round(gmX),  gmY := Round(gmY)
           VPstampBMPx := c[1], VPstampBMPy := c[2]
           mustSnapLiveDrawPoints := 2
        }

        diffX := gmX - soX, diffY := gmY - soY
        If (k=1 && autoReflectVectorAnchors=1 && bezierSplineCustomShape=1)
        {
           ; drag anchors as well 
           If (endsConnected=1)
           {
              customShapePoints[2] := [poX + diffX, poY + diffY]
              customShapePoints[totalCount - 1] := [doX + diffX, doY + diffY]
           } Else
           {
              If (thisIndex + 1 <= totalCount)
                 customShapePoints[thisIndex + 1] := [poX + diffX, poY + diffY]

              If (thisIndex - 1 >= 1)
                 customShapePoints[thisIndex - 1] := [doX + diffX, doY + diffY]

              thisu := (thisIndex + 1 <= totalCount) ? thisIndex + 1 : thisIndex - 1
              tK := (thisIndex + 1 <= totalCount) ? 2 : 3
              If ((thisu<totalCount || thisu>1) && canDoSymmetry
              && thisu!=2 && thisu!=(totalCount - 1))
                 reflectGivenAnchorInPath(tK, totalCount, thisu, canDoSymmetry)
           }
        }

        mustRem := 1
        customShapePoints[thisIndex] := [gmX, gmY]
        If (bezierSplineCustomShape=1)
        {
           Loop, % auxiliaryPoints.Count()
               customShapePoints[auxiliaryPoints[A_Index, 1]] := [gmX, gmY]
        }

        If (oppoIndex!=thisIndex && canDoSymmetry=1 && altState=0)
        {

           hasSymmetry := calculateSymmetricVectorPoint(gmX, gmY, nX, nY)
           customShapePoints[oppoIndex] := [nX, nY]
           Loop, % auxiliaryPoints.Count()
               customShapePoints[auxiliaryPoints[A_Index, 2]] := [nX, nY]

           ; initialDrawingStartCoords[oppoIndex] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
           If (thisIndex=1)
           {
              hasSymmetry := calculateSymmetricVectorPoint(customShapePoints[2, 1], customShapePoints[2, 2], pnX, pnY)
              customShapePoints[totalCount - 1] := [pnX, pnY]
           } Else If (thisIndex=totalCount)
           {
              hasSymmetry := calculateSymmetricVectorPoint(customShapePoints[totalCount - 1, 1], customShapePoints[totalCount -1, 2], pnX, pnY)
              customShapePoints[2] := [pnX, pnY]
           }
        }
        If (autoReflectVectorAnchors=1 && k!=1 && bezierSplineCustomShape=1)
           reflectGivenAnchorInPath(k, totalCount, thisIndex, canDoSymmetry)

        thisState := "a" gmX gmY mX mY
        If (thisState!=prevState)
        {
           If (oppoIndex!=thisIndex && canDoSymmetry=1)
              otheru := ", " oppoIndex
           prevState := thisState
           fr := (k!=1 && bezierSplineCustomShape=1) ? "P'" : "P"
           showTOOLtip(fr "[" thisIndex otheru "] = (" gmX ", " gmY ")")
           dummyRefreshImgSelectionWindow()
        }
        Sleep, 2
   }
   setwhileLoopExec(0)
   Return mustRem
}

removeGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY) {
   If (k!=1 && bezierSplineCustomShape=1)
   {
      collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
      Return
   }

   listu := thisIndex "|"
   If (bezierSplineCustomShape=1 && k=1 && thisIndex=1)
   {
      a := 3, b := 2
      listu .= "2|3|"
   } Else If (bezierSplineCustomShape=1 && k=1 && thisIndex=totalCount)
   {
      a := totalCount - 1, b := totalCount - 2
      listu .= a "|" b "|"
   } Else If (bezierSplineCustomShape=1 && k=1)
   {
      ; identify associated points to be deleted - the anchors
      nextK := getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
      If a
         listu .= a "|"
      If b
         listu .= b "|"
      ; ToolTip, % "nextK=" nextK, , , 2
      nextKcoords := customShapePoints[nextK]
   }

   If (oppoIndex!=thisIndex && canDoSymmetry=1 && a!=thisIndex && b!=thisIndex && a!=oppoIndex && b!=oppoIndex)
   {
      listu .= oppoIndex "|"
      If (bezierSplineCustomShape=1)
      {
         za := totalCount - a + 1
         zb := totalCount - b + 1
         If za
            listu .= za "|"
         If zb
            listu .= zb "|"
      }
   }


   lista := Trim(listu, "|")
   Sort, lista, R U N D|
   ; ToolTip, % listu "`n" lista , , , 2
   ; ToolTip, % anchorPa "=" anchorPb "=" anchorPc , , , 2
   Loop, Parse, lista, |
   {
      If !A_LoopField
         Continue

      customShapePoints.RemoveAt(A_LoopField)
      initialDrawingStartCoords.RemoveAt(A_LoopField)
      If (A_LoopField < prevVectorShapeSymmetryMode[1, 1])
         prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] - 1
   }

   auxiliaryPoints := getPointsSameCoordsVectorPath(totalCount, thisIndex, gmX, gmY)
   Loop, % auxiliaryPoints.Count()
   {
      If auxiliaryPoints[A_Index, 1]
         customShapePoints[auxiliaryPoints[A_Index, 1]]  := [nextKcoords[1], nextKcoords[2]]
   }

   ; ToolTip, % "l=" CustomShapeLockedSymmetry "=" thisIndex "=" oppoIndex , , , 2
   If (oppoIndex!=thisIndex && canDoSymmetry=1)
   {
      Sleep, 0
   } Else If (CustomShapeLockedSymmetry && oppoIndex=-1)
   {
      prevVectorShapeSymmetryMode[1, 2] := 0
      CustomShapeLockedSymmetry := 0
   }
}

getPointsSameCoordsVectorPath(totalCount, givenIndex, gmX, gmY, mainParam:=0) {
   newArrayu := []
   loops := (mainParam="DoubleClick") ? totalCount : 7
   If (mainParam="DoubleClick")
      givenIndex := 6

   Loop, % loops
   {
       ; determine user clicked point from the entire path
       thisIndex := givenIndex - 6 +  A_Index
       If (!IsObject(customShapePoints[thisIndex]) || thisIndex=givenIndex)
          Continue

       oppoIndex := totalCount - thisIndex + 1
       getVPcoordsVectorPoint(thisIndex, xu, yu)
       If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
          newArrayu.Push([thisIndex, oppoIndex])
    }

    If (givenIndex<=2 || givenIndex>=(totalCount - 1))
    {
       Loop, 2
       {
           ; determine user clicked point from the entire path
           thisIndex := A_Index
           If (!IsObject(customShapePoints[thisIndex]) || thisIndex=givenIndex)
              Continue
 
           oppoIndex := totalCount - thisIndex + 1
           getVPcoordsVectorPoint(thisIndex, xu, yu)
           If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
              newArrayu.Push([thisIndex, oppoIndex])
       }

       Loop, 3
       {
           ; determine user clicked point from the entire path
           thisIndex := totalCount - 3 + A_Index
           If (!IsObject(customShapePoints[thisIndex]) || thisIndex=givenIndex)
              Continue
 
           oppoIndex := totalCount - thisIndex + 1
           getVPcoordsVectorPoint(thisIndex, xu, yu)
           If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
              newArrayu.Push([thisIndex, oppoIndex])
       }
    }

    Return newArrayu
}

moveSelectedPointsInVectorPath(gmX, gmY) {
   thisState := prevState := 0
   GetMouseCoord2wind(PVhwnd, omX, omY)
   newArrayu := customShapePoints.Clone()
   setwhileLoopExec(1)
   startOperation := A_TickCount
   While, (determineLClickstate()=1)
   {
      If (A_TickCount - startOperation<150)
         Continue

      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      gmX := omX - mX
      gmY := omY - mY
      thisState := "a" gmX "=" gmY
      If (thisState!=prevState)
      {
         prevState := thisState
         Loop, % customShapePoints.Count()
         {
            c := newArrayu[A_Index]
            selu := initialDrawingStartCoords[A_Index, 3]
            If (c[1]="" || c[2]="" || selu!=1)
               Continue

            ; fX := prevResizedVPimgW/initialDrawingStartCoords[A_Index, 4]
            ; fY := prevResizedVPimgH/initialDrawingStartCoords[A_Index, 5]
            xu := c[1] - gmX ; *fX
            yu := c[2] - gmY ; *fY
            customShapePoints[A_Index] := [xu, yu]
         }
         showTOOLtip("Move selected points:`nX=" -1*gmX ", Y=" -1*gmY)
         dummyRefreshImgSelectionWindow()
      }
      Sleep, 2
   }
   setwhileLoopExec(0)
   RemoveTooltip()
   newArrayu := []
}

selectGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, mainParam, gmX, gmY) {
    Static lastAmount := 0
    actu := !initialDrawingStartCoords[thisIndex, 3]
    listu := thisIndex "|"
    If (bezierSplineCustomShape=1 && (mainParam="selclickAnchors" || mainParam="DoubleClick"))
    {
       If (bezierSplineCustomShape=1)
          endsConnected := ((thisIndex<=2 || thisIndex>=(totalCount - 1)) && testIsBezierPathClosed()=1) ? 1 : 0

       If (endsConnected=1)
          listu .= "1|2|" totalCount "|" totalCount - 1 "|"

       nextK := getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
       If a
          listu .= a "|"
       If b
          listu .= b "|"
       ; ToolTip, % "nextK=" nextK, , , 2
    }

    ; ToolTip, % " k = " k , , , 2
    If (bezierSplineCustomShape=1 || mainParam="DoubleClick")
       auxiliaryPoints := getPointsSameCoordsVectorPath(totalCount, thisIndex, gmX, gmY, mainParam)

    If (oppoIndex!=thisIndex && canDoSymmetry=1 && a!=thisIndex && b!=thisIndex && a!=oppoIndex && b!=oppoIndex)
    {
       listu .= oppoIndex "|"
       If (bezierSplineCustomShape=1)
       {
          za := totalCount - a + 1
          zb .= totalCount - b + 1
          If (a!=za && za!=zb && a)
             listu .= za "|"
          If (b!=zb && za!=zb && b)
             listu .= zb "|"
          Loop, % auxiliaryPoints.Count()
             listu .= auxiliaryPoints[A_Index, 2] "|"
       }
    }

    Loop, % auxiliaryPoints.Count()
       listu .= auxiliaryPoints[A_Index, 1] "|"

   lista := Trim(listu, "|")
   ; ToolTip, % lista , , , 2
   newArrayu := StrSplit(lista, "|")
   If (bezierSplineCustomShape=1 && (mainParam="selclickAnchors" || mainParam="DoubleClick"))
   {
      If (newArrayu[2]!=thisIndex && newArrayu[2])
         actu := !initialDrawingStartCoords[newArrayu[2], 3]
      Else If (newArrayu[3]!=thisIndex && newArrayu[3])
         actu := !initialDrawingStartCoords[newArrayu[3], 3]
   }

   If (lastAmount!=newArrayu.Count() && mainParam="DoubleClick")
      actu := 1

   Loop, % newArrayu.Count()
   {
      If !newArrayu[A_Index]
         Continue

      initialDrawingStartCoords[newArrayu[A_Index], 3] := actu
   }

   lastAmount := newArrayu.Count()
   If (newArrayu.Count()>2)
   {
      fr := actu ? "" : "de"
      showTOOLtip(newArrayu.Count() - 1 " points were " fr "selected")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
   dummyRefreshImgSelectionWindow()
}

getAssociatedBezierPoints(k, totalCount, thisIndex, ByRef A, ByRef B) {
    If (k=1)
    {
       If (thisIndex<totalCount)
          a := thisIndex + 1
       If (thisIndex>1)
          b := thisIndex - 1
       Return thisIndex + 3
    } Else If (k=2)
    {
       a := thisIndex - 1
       If (thisIndex - 2>1)
          b := thisIndex - 2
       Return thisIndex + 2
    } Else If (k=3)
    {
       a := thisIndex + 1
       If (thisIndex + 2<totalCount)
          b := thisIndex + 2
       Return thisIndex + 1
    }
}

calculateSymmetricVectorPoint(gmX, gmY, ByRef mX, ByRef mY) {
   hasSymmetry := 0
   If (CustomShapeSymmetry=1 && vpSymmetryPointX)
   {
       vpSymX := Round(vpSymmetryPointX) - (vpSymmetryPointXdp - prevDestPosX)
       gmXa := (gmX<vpSymX) ? vpSymX*2 - gmX : vpSymX - (gmX - vpSymX)
       mX := gmXa
       mY := gmY
       hasSymmetry := 1
   } Else If (CustomShapeSymmetry=2 && vpSymmetryPointY)
   {
       vpSymY := Round(vpSymmetryPointY) - (vpSymmetryPointYdp - prevDestPosY)
       gmYa := vpSymY - (gmY - vpSymY)
       mX := gmX
       mY := gmYa
       hasSymmetry := 1
   }

   ; fnOutputDebug(A_ThisFunc "(): " gmX "=" gmY " | " mX "=" mY " | " vpSymX "=" vpSymY)
   Return hasSymmetry
}

isNowSymmetricVectorShape() {
   hasSymmetry := 0
   If (CustomShapeSymmetry=1 && vpSymmetryPointX)
      hasSymmetry := 1
   Else If (CustomShapeSymmetry=2 && vpSymmetryPointY)
      hasSymmetry := 1

   Return hasSymmetry
}

thumbsListClickResponder(mX, mY, mainWidth, mainHeight, mainParam, ctrlState, shiftState, altState) {
   Static lastInvoked := 1, doNotAskAgain := 0
   If (A_TickCount - lastInvoked<50)
      Return "none"

   scrollXpos := mainWidth - imgHUDbaseUnit//2
   statusBarYpos := Round(mainHeight - ThumbsStatusBarH)
   If (mX>scrollXpos)
   {
      If (markedSelectFile>1 && maxFilesIndex>4 && altState=1 && mainParam="normal")
      {
         mYperc := ((mY - 15)/mainHeight)*100
         newIndex := clampInRange(Ceil((maxFilesIndex/100)*mYperc), 1, maxFilesIndex)
         currentFileIndex := newIndex
         regroupSelectedFiles()
         Return "none"
      } Else If (mainParam!="rclick")
         SetTimer, ThumbsScrollbar, -25
      Return "scrollbar"
   } Else If (mY>statusBarYpos)
   {
      If (markedSelectFile>1 && maxFilesIndex>4 && altState=1 && mainParam="normal")
         filterToFilesSelection()
      Else If (mainParam="rclick")
         Return "statusBar"
      Else If !InStr(mainParam, "pen-")
         ToggleMultiLineStatus()
      Return
   }

   If InStr(mainParam, "pen-")
      Return

   oIndex := currentFileIndex
   thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
   rowIndex := 0, columnIndex := -1
   Loop, % maxItemsPage*2
   {
      columnIndex++
      If (columnIndex>=maxItemsW)
      {
         rowIndex++
         columnIndex := 0
      }
      DestPosX := thumbsW*columnIndex + thumbsW
      DestPosY := thumbsH*rowIndex + thumbsH
      If (DestPosX>mX && DestPosY>mY)
      {
         newIndex := startIndex + A_Index - 1
         Break
      }
   }

   maxWidu := maxItemsW*thumbsW - 1
   maxHeitu := maxItemsH*thumbsH  - 1
   If newIndex
   {
      If (mainParam="rClick")
      {
         ; currentFileIndex := newIndex
         ; mainGdipWinThumbsGrid()
         If (newIndex=oIndex)
            Return "FsoloMenu"
         Else
            Return
      }

      startClick := A_TickCount
      longTapDelay := markedSelectFile ? 350 : 750
      newIndex := clampInRange(newIndex, 1, maxFilesIndex)
      If (ctrlState=1)
      {
         markThisFileNow(newIndex)
      } Else If (altState=1 && (omniBoxMode=1 && VisibleQuickMenuSearchWin=1 || folderTreeWinOpen=1))
      {
         If (omniBoxMode=1 && VisibleQuickMenuSearchWin=1)
         {
            Gui, QuickMenuSearchGUIA: Default
            GuiControlGet, userQuickMenusEdit
            edithu := Trimmer(userQuickMenusEdit)
            edithu := Trimmer(StrReplace(edithu, "\\", "\"), "\")
         }

         func2exec := r := info := ""
         prevMSGdisplay := 1
         currentFileIndex := newIndex
         UpdateThumbsScreen()
         While, determineLClickstate()
         {
            ; drag and drop
            info := defineWindowUnderMouse()
            If InStr(info, "tooltip")
            {
               interfaceThread.ahkFunction("showOSDinfoLineNow", 500)
               Continue
            } Else If (InStr(info, "main") && markedSelectFile>1)
            {
               GetMouseCoord2wind(PVhwnd, nX, nY)
               If (nY > statusBarYpos)
                  friendly := "`nFilter the files list to selected items"
               Else If (nX > scrollXpos - 50)
                  friendly := "`nRegroup selected files at this scrollbar location"
               Else
                  friendly := "`nNo action associated to this pointer location"
            
               nc := nY
               thisFolder := r := dc := ""
               r := friendly
            } Else If InStr(info, "tree")
            {
               thisFolder := r := dc := nc := ""
               LV_Modify(initialRow, "select")
               friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
               GetMouseCoord2wind(hTVlistFolders, nX, nY)
               nc := TVH_HitTest(hTVlistFolders, cr, nX, nY)
               If nc
               {
                  Gui, fdTreeGuia: Default
                  Gui, fdTreeGuia: TreeView, TVlistFolders
                  TV_GetText(thisFolder, nc)
                  TV_Modify(nc)
               }
               friendly .= "`nDestination: ." thisFolder "\"
               r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
               friendly .= A_Space r
            } Else If InStr(info, "omnibox list")
            {
               thisFolder := r := dc := nc := ""
               GetMouseCoord2wind(hLVquickSearchMenus, nX, nY)
               dc := LV_EX_ItemHitTest(hLVquickSearchMenus, kp, nX, nY)
               thisFolder := OmniBoxGetSelectedFolder(dc, "yes", edithu)
               LV_Modify(dc, "select")
               restu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
               friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
               r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
               friendly2 := "`nDestination: ." restu "\ " r
               friendly .= thisFolder ? friendly2 : "`nNo folder is currently underneath."
               ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
            } Else 
            {
               func2exec := r := dc := nc := ""
               friendly := "`nNo action associated to this pointer location"
            }

            If (A_TickCount - prevMSGdisplay>100)
            {
               externToolTiput(info friendly)
               prevMSGdisplay := A_TickCount
            }
         }

         If (InStr(info, "main") && r)
         {
            If InStr(r, "filter")
            {
               func2exec := "filterToFilesSelection"
            } Else If InStr(r, "regroup")
            {
               mYperc := ((nc - 15)/mainHeight)*100
               newIndex := clampInRange(Ceil((maxFilesIndex/100)*mYperc), 1, maxFilesIndex)
               currentFileIndex := newIndex
               func2exec := "regroupSelectedFiles"
            }
         } Else If (InStr(info, "omnibox") && dc && thisFolder)
         {
            externTooltiput("-hide-")
            dest := OmniBoxGetSelectedFolder(dc, "yes", edithu)
            rDest := SubStr(dest, InStr(dest, "\", 0, -1) + 1)
            If (doNotAskAgain=0 && InStr(dest, ":\") && r)
            {
               msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action from the main window into the omnibox: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: selected files`nDestination: .\" rDest "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
               If !InStr(msgResult.btn, "Yes")
               {
                  SetTimer, PopulateQuickMenuSearch, -200
                  Return 1
               } Else doNotaskAgain := msgResult.check
            }

            If (InStr(r, "_") && InStr(dest, ":\"))
            {
               externTooltiput("Please wait - performing action")
               If InStr(r, "copy")
                  func2exev := "omniBoxFolderCopyFiles"
               Else If InStr(r, "move")
                  func2exev := "omniBoxFolderMoveFiles"
            }
            externTooltiput("-hide-")
         } Else If (InStr(info, "tree") && r && nc)
         {
            externTooltiput("-hide-")
            dest := folderTreeGetSelectedPath(nc)
            If (doNotAskAgain=0 && InStr(dest, ":\") && r)
            {
               msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action from the main window into the folders tree panel: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: selected files`nDestination: ." dest "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
               If !InStr(msgResult.btn, "Yes")
               {
                  SetTimer, folderTreeInfoStatusLineUpdater, -125
                  Return 1
               } Else doNotaskAgain := msgResult.check
            }

            externTooltiput("Please wait - performing folder action")
            If (InStr(r, "_") && InStr(dest, ":\"))
            {
               If InStr(r, "copy")
                  func2exec := "FolderTreeMenuCopyFiles"
               Else If InStr(r, "move")
                  func2exec := "FolderTreeMenuMoveFiles"
            }
         }
         externTooltiput("-hide-")
         prevent := 1
         If func2exec
            SetTimer, % func2exec, -500
      } Else If (altState=1)
      {
         moveMarkedEntryNow(newIndex)
      } Else If (shiftState=1)
      {
         clickAct := "S"
      } Else
      {
         While, (determineLClickstate()=1 && (A_TickCount - startClick<longTapDelay+150))
         {
            Sleep, 1
         }

         If (A_TickCount - startClick<longTapDelay) && (newIndex=currentFileIndex)
         {
            ToggleThumbsMode()
            Return
         } Else If (A_TickCount - startClick>longTapDelay)
            markThisFileNow(newIndex)
      }

      If (clickAct="S")
      {
         keyu := (newIndex>currentFileIndex) ? "Down" : "Upu"
         prevFileIndex := currentFileIndex
         currentFileIndex := newIndex
         thumbsSelector(keyu, "+Shift", prevFileIndex)
      } Else currentFileIndex := newIndex

      dummyTimerDelayiedImageDisplay(25)
   }

   lastInvoked := A_TickCount
}

WinClickAction(winEventu:=0, thisCtrlClicked:=0, mX:=0, mY:=0) {
   Critical, on
   Static thisZeit := 1, prevTippu := 1, anotherZeit := 1, ignoreRclick := 0, ignoreNclick := 0
        , lastInvoked := 1, lastInvoked2 := 1, lastInvokedSwipe := 1

   lastLclickX := mX,  lastLclickY := mY
   If (VisibleQuickMenuSearchWin=1 && omniBoxMode=0)
   {
      lastTimeToggleThumbs := A_TickCount 
      closeQuickSearch()
      Return "none"
   }

   displayingImageNow := (thumbsDisplaying!=1 && useGdiBitmap()) ? 1 : 0
   If isVarEqualTo(AnyWindowOpen, 1, 33, 39, 59, 48, 61)
   {
      ; auto-close windows
      lastTimeToggleThumbs := A_TickCount 
      BtnCloseWindow()
      Return
   } Else If ((InStr(winEventu, "normal") || InStr(winEventu, "DoubleClick")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && displayingImageNow=1 && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1) && thumbsDisplaying!=1)
   {
      ; handle clicks on the H/V scrollbars for images larger than the viewport
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      knobSize := imgHUDbaseUnit//3
      If (scrollBarHy>1 && mY>(mainHeight - knobSize))
      {
         RemoveTooltip()
         fn := Func("panIMGonScrollBar").Bind(1,0)
         SetTimer, % fn, -25
         Return
      } Else If (scrollBarVx>1 && mX>(mainWidth - knobSize))
      {
         RemoveTooltip()
         fn := Func("panIMGonScrollBar").Bind(0,1)
         SetTimer, % fn, -25
         Return
      }
   }
 
   If (IsFunc(hudBTNfuncu) && hudBTNfuncu && hudBTNheightFuncu && mY<hudBTNheightFuncu)
   {
      If (mX<hudBTNwidthFuncu && hudBTNtypeFuncu=1)
      {
         lastTimeToggleThumbs := A_TickCount 
         hudBTNtypeFuncu := 0
         %hudBTNfuncu%()
         Return
      } Else If (hudBTNtypeFuncu=2)
      {
         hudBTNtypeFuncu := 0
         lastTimeToggleThumbs := A_TickCount 
         GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
         If (mX<mainWidth//2)
            %hudBTNfuncu%(-1)
         Else
            %hudBTNfuncu%(1)
         Return
      }
   } Else If (AnyWindowOpen=64 && liveDrawingBrushTool=1`&& mustCaptureCloneBrush=1)
   {
      If StrLen(BrushToolSymmetryX)>1
      {
         setNewBrushSymmetryPoints()
      } Else
      {
         tinyPrevAreaCoordX := tinyPrevAreaCoordY := "C"
         createClonedBrushBitmap(mX, mY, 0, 0, 0)
      }
      lastTimeToggleThumbs := A_TickCount 
      Return
   } Else If (AnyWindowOpen=23 && FillAreaColorMode=6`&& mustCaptureCloneBrush=1)
   {
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      setwhileLoopExec(1)
      While, (determineLClickstate()=1)
      {
         GetMouseCoord2wind(PVhwnd, mX, mY)
         mX := (FlipImgH=1) ? mainWidth - mX : mX
         mY := (FlipImgV=1) ? mainHeight - mY : mY
         MouseCoords2Image(mX, mY, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
         tinyPrevAreaCoordX := kX, tinyPrevAreaCoordY := kY
         showTOOLtip("Texture source set to`n" kX " / " kY)
         If (A_TickCount - thisZeit>90)
         {
            dummyRefreshImgSelectionWindow()
            thisZeit := A_TickCount
         }
      }

      setwhileLoopExec(0)
      endCaptureCloneBrush()
      If (panelWinCollapsed=1)
         toggleImgEditPanelWindow()

      SoundBeep , 900, 100
      dummyRefreshImgSelectionWindow()
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      ; SetTimer, updateUIfillPanel, -350
      lastTimeToggleThumbs := A_TickCount 
      Return
   } Else If isVarEqualTo(AnyWindowOpen, 69, 43, 44, 26)
   {
      ; respond to clicks in viewport for panels with region based previews
      setwhileLoopExec(1)
      While, (determineLClickstate()=1)
      {
         updateTinyPreviewArea(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, 1)
         dummyRefreshImgSelectionWindow()
      }
      setwhileLoopExec(0)
      lastTimeToggleThumbs := A_TickCount 
      Return
   }

   ; ToolTip, % winEventu " -- " thisCtrlClicked,,,2
   If (A_TickCount - lastLongOperationAbort < 550) || (A_TickCount - lastTimeToggleThumbs < 450) || (A_TickCount - executingCanceableOperation < 550)
   || (A_TickCount - lastWinDrag < 250) 
      Return "none"

   If (imgEditPanelOpened!=1 && AnyWindowOpen)
   {
      ; handle clicks in the viewport when a panel unrelated to image editing  is open
      SoundPlay, *-1
      WinActivate, ahk_id %hSetWinGui%
      Return
   }

   If (imageLoading=1 && thumbsDisplaying=1)
      Return "none"

   If (toolTipGuiCreated=1)
      RemoveTooltip()

   ;  ToolTip, % HUDobjHistoBoxu[3] "==" HUDobjHistoBoxu[1] "==" mX "`n" HUDobjHistoBoxu[4] "==" HUDobjHistoBoxu[2] "==" mY , , , 2
   If (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1 && thumbsDisplaying!=1
   && isDotInRect(mX, mY, HUDobjNavBoxu[3], HUDobjNavBoxu[1] + HUDobjNavBoxu[3], HUDobjNavBoxu[4], HUDobjNavBoxu[2] + HUDobjNavBoxu[4]))
   {
      If (winEventu="DoubleClick")
         ToggleImgNavSizeBox()
      Else
         SetTimer, ImageNavBoxClickResponder, -25
      Return
   } Else If (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1
   && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
   {
      If (winEventu="DoubleClick")
         ToggleImgNavSizeBox()
      Return
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If (thumbsDisplaying!=1 && drawingShapeNow!=1)
   {
      If (editingSelectionNow=1 && adjustNowSel=0)
         dotActiveObj := determineSelAreaClickRect(mX, mY, SelDotsSize, mainWidth, mainHeight, 1)

      If (winEventu="DoubleClick" && (dotActiveObj.n>0 || imgSelLargerViewPort=1) && editingSelectionNow=1 && adjustNowSel=0)
      {
         ctrlState := GetKeyState("Ctrl", "P") ? 1 : 0
         shiftState := GetKeyState("Shift", "P") ? 1 : 0
         If (dotActiveObj.n>0 || imgSelLargerViewPort=1)
         {
            If (dotActiveObj.n>0 && imgSelLargerViewPort!=1 && EllipseSelectMode=2 && (ctrlState=1 || shiftState=1))
               MenuResumeDrawingShapes()
            Else If (imgEditPanelOpened=1 && !liveDrawingBrushTool)
               BuildImgLiveEditMenu()
            Else If !liveDrawingBrushTool
               invokeSelectionAreaMenu("DoubleClick")
            Return
         }
      } Else If (showHistogram>1 && imgEditPanelOpened!=1 && hasDrawnHistoMap=1 && !dotActiveObj.n
      && isDotInRect(mX, mY, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3], HUDobjHistoBoxu[4], HUDobjHistoBoxu[6] + HUDobjHistoBoxu[4]))
      {
         ToggleHistogramMode()
         Return
      } Else If (showHistogram>1 && hasDrawnHistoMap=1 && !dotActiveObj.n
      && isDotInRect(mX, mY, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3], HUDobjHistoBoxu[4], HUDobjHistoBoxu[2] + HUDobjHistoBoxu[4]))
      {
         If (showHistogram=6)
            showHistogram := 1

         ToggleImgHistogram(1)
         Return
      } 
   }

   ctrlState := GetKeyState("Ctrl", "P") ? 1 : 0
   shiftState := GetKeyState("Shift", "P") ? 1 : 0
   altState := GetKeyState("Alt", "P") ? 1 : 0
   If (thumbsDisplaying=1 && maxFilesIndex>0 && winEventu!="DoubleClick")
   {
      ; handle clicks on thumbnails and the vertical scrollbar
      r := thumbsListClickResponder(mX, mY, mainWidth, mainHeight, winEventu, ctrlState, shiftState, altState)
      Return r
   }

   spaceState := GetKeyState("Space", "P") ? 1 : 0
   If (isAlphaMaskWindow()=1 && spaceState!=1 && imgEditPanelOpened=1 && liveDrawingBrushTool=1)
   {
      ; respond to clicks when drawing with the brush tools
      SetTimer, ActDrawAlphaMaskBrushNow, -5
      Return
   } Else If (AnyWindowOpen=64 && spaceState!=1 && imgEditPanelOpened=1 && liveDrawingBrushTool=1)
   {
      ; respond to clicks when drawing with the brush tools
      SetTimer, ActPaintBrushNow, -5
      Return
   } Else If (AnyWindowOpen=66 && spaceState!=1 && imgEditPanelOpened=1 && FloodFillSelectionAdj=0)
   {
      ActFloodFillNow()
      Return
   } Else If (drawingShapeNow=1 && spaceState!=1)
   {
      ; respond to clicks when drawing freeform polygonal shapes
      addNewVectorShapePoints(mX, mY, mainWidth, mainHeight, winEventu, ctrlState, shiftState, altState)
      Return
   }

   If ((editingSelectionNow!=1) || (imgSelOutViewPort=1 && editingSelectionNow=1) || (imgSelLargerViewPort=1 && editingSelectionNow=1))
   && (displayingImageNow=1 && getCaptionStyle(PVhwnd)!=1 && InStr(winEventu,"normal") && shiftState=1)
   {
      ; activate selection on single click + shift
      MouseCoords2Image(mX - 200, mY - 200, LimitSelectBoundsImg, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
      MouseCoords2Image(mX + 200, mY + 200, LimitSelectBoundsImg, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
      Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
      defineRelativeSelCoords(rImgW, rImgH)
      ToggleEditImgSelection("show-edit")
      dummyTimerDelayiedImageDisplay(50)
      Return
   }

   If (InStr(winEventu, "normal") && editingSelectionNow=1 && spaceState!=1 && displayingImageNow=1)
   {
      ; handle clicks on the image selection rectangle in the viewport
      dotsSize := SelDotsSize
      zL := (zoomLevel>1) ? zoomLevel : 1/zoomLevel
      If !IsObject(dotActiveObj)
         dotActiveObj := determineSelAreaClickRect(mX, mY, dotsSize, mainWidth, mainHeight, 1)

      DotPosX := dotActiveObj.x
      DotPosY := dotActiveObj.y
      dotActive := dotActiveObj.n
      If (dotActive=10)       ; click the center dot of the selection area
         anotherZeit := A_TickCount

      If (dotActive && imgSelOutViewPort=1)
      {
         dotActive := 9 ;       ; anywhere within the selection [makes the entire selection draggable]
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      }
 
      If (InStr(winEventu, "pen-") && (dotActive=9 || !dotActive))
         Return
 
      ; ToolTip, % "l=" dotActive , , , 2
      oVPselRotation := VPselRotation
      tDotPosX := DotPosX
      tDotPosY := DotPosY

      Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
      SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
      MouseCoords2Image(prevDestPosX + SelDotsSize + 1, prevDestPosY + SelDotsSize + 1, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, snapSizeX, snapSizeY)
      ; snapSizeX := (xKx>rImgW*0.3) ? Ceil(rImgW*0.005) + 1 : xKx
      ; snapSizeY := (xKy>rImgH*0.3) ? Ceil(rImgH*0.005) + 1 : xKy
      ; ToolTip, % xKx "=" xKy "`n" snapSizeX "=" snapSizeY , , , 2
      nImgSelX1 := tImgSelX1 := imgSelX1
      nImgSelY1 := tImgSelY1 := imgSelY1
      nImgSelX2 := tImgSelX2 := imgSelX2
      nImgSelY2 := tImgSelY2 := imgSelY2
      timgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      timgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      tavg := (timgSelW + timgSelH)//2
      timgSelX2 := tImgSelX1 + tavg
      timgSelY2 := tImgSelY1 + tavg
      otimgSelX2 := nImgSelX2
      otimgSelY2 := nImgSelY2
      timgSelRatio := timgSelW/timgSelH
      thisZeit := zX := zY := adjustNowSel := 1
      o_imageLoading := imageLoading

      If dotActive
      {
         If (lockSelectionAspectRatio>1 && desiredSelAspectRatio && altState!=1 && isInRange(dotActive, 1, 8) && ctrlState!=1)
            shiftState := 1

         drawImgSelectionOnWindow("init", 0, 0, 0, mainWidth, mainHeight)
         If isInRange(dotActive, 1, 8)
            adjustingSelDotNow := dotActive
      }

      newPosZeit := A_TickCount
      oldPosZeit := A_TickCount
      o_alphaMaskOffsetX := alphaMaskOffsetX,   o_alphaMaskOffsetY := alphaMaskOffsetY
      o_clrGradientOffX := clrGradientOffX,     o_clrGradientOffY := clrGradientOffY
      o_shearImgX := shearImgX,                 o_shearImgY := shearImgY
      o_innerSelectionCavityX := innerSelectionCavityX
      o_innerSelectionCavityY := innerSelectionCavityY
      adjustSkewImg := adjustGradientOffset := adjustSelCavity := 0
      If (isInRange(dotActive, 11, 14) && ctrlState!=1 && shiftState!=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
      {
         adjustSkewImg := 1
      } Else If (dotActive=9 && AnyWindowOpen=23 && ctrlState!=1 && shiftState!=1 && userAllowClrGradientRecenter=1)
      {
         If isInRange(FillAreaColorMode, 2, 4)
            adjustGradientOffset := 2
      } Else If (dotActive=9 && ctrlState=1)
      {
         adjustSelCavity := 1
      } Else If (dotActive=9 && isAlphaMaskWindow()=1 && ctrlState!=1 && shiftState!=1 && userAllowsGradientRecentering=1)
      {
         If (alphaMaskingMode>1 && alphaMaskingMode!=5)
            adjustGradientOffset := 1
      }

      setwhileLoopExec(0)
      JEE_ClientToScreen(hPicOnGui1, mX, mY, mXo, mYo)
      While, (determineLClickstate()=1 && o_imageLoading!=1 && dotActive)
      {
          MouseGetPos, mX, mY, thisWind
          skipLoop := isDotInRect(mX, mY, zX - 3, zX + 3, zY - 3, zY + 3) ? 1 : 0
          If (A_TickCount - newPosZeit>750) ; || (mX=oX && mY=oY)
          {
             newPosZeit := A_TickCount
             zX := mX, zY := mY
             If (skipLoop=1)
                Continue
          } Else If (skipLoop=1)
             Continue

          zeitSillyPrevent := A_TickCount
          changePosX := (zoomLevel>1) ? Round((mX - mXo)/zL) : Round((mX - mXo)*zL)
          changePosY := (zoomLevel>1) ? Round((mY - mYo)/zL) : Round((mY - mYo)*zL)
          If (dotActive=10)
          {
             ; center dot - selection rotation
             tW := (A_TickCount - oldPosZeit)/2150 + 0.0001
             If (tW>=1)
                tW := 1

             rotAmount := (changePosX/(mainWidth*0.9))*tW
             rotAmount := rotAmount * 360
             nVPselRotation := Round(oVPselRotation + rotAmount, 2)
             If (nVPselRotation<0 || nVPselRotation>360)
                nVPselRotation := 360 - Abs(nVPselRotation)
             VPselRotation := nVPselRotation
             ; ToolTip, % TW " -- " rotAmount " -- " nVPselRotation " -- " oVPselRotation " -- " VPselRotation  , , , 2
             If (shiftState=1)
                VPselRotation := oVPselRotation + 45
             Else If (altState=1)
                VPselRotation := 0

             VPselRotation := snapToValues(VPselRotation, 90, 180, 2, 0)
             VPselRotation := snapToValues(VPselRotation, 270, 360, 2, 0)
             VPselRotation := snapToValues(VPselRotation, 0, 360, 2, 0)
             VPselRotation := clampInRange(VPselRotation, 0, 360)
          } Else If (dotActive=9 && ctrlState=1 && adjustSelCavity=1)
          {
             coords := 10
             movX := (FlipImgH=1) ? - changePosX/(mainWidth*1.2) : changePosX/(mainWidth*1.2)
             movY := (FlipImgV=1) ? - changePosY/(mainHeight*1.2) : changePosY/(mainHeight*1.2)
             innerSelectionCavityX := clampInRange(o_innerSelectionCavityX + movX , 0.01, 0.48)
             innerSelectionCavityY := clampInRange(o_innerSelectionCavityY + movY , 0.01, 0.48)
          } Else If (adjustSkewImg=1)
          {
             coords := 10
             movX := (FlipImgH=1) ? - changePosX/(mainWidth*1.2) : changePosX/(mainWidth*1.2)
             movY := (FlipImgV=1) ? - changePosY/(mainHeight*1.2) : changePosY/(mainHeight*1.2)
             If (dotActive=11)
                shearImgX := snapToValues(clampInRange(o_shearImgX - movX*2, -9.9, 9.9), -9 0, 0, 0.05, 0)
             Else If (dotActive=13)
                shearImgX := snapToValues(clampInRange(o_shearImgX + movX*2, -9.9, 9.9), -9 0, 0, 0.05, 0)
             Else If (dotActive=12)
                shearImgY := snapToValues(clampInRange(o_shearImgY + movY*2, -9.9, 9.9), -9 0, 0, 0.05, 0)
             Else If (dotActive=14)
                shearImgY := snapToValues(clampInRange(o_shearImgY - movY*2, -9.9, 9.9), -9 0, 0, 0.05, 0)
          } Else If (dotActive=9 && adjustGradientOffset>0)
          {
             ; anywhere within selection click
             coords := 10
             movX := (FlipImgH=1) ? - changePosX/(mainWidth*1.2) : changePosX/(mainWidth*1.2)
             movY := (FlipImgV=1) ? - changePosY/(mainHeight*1.2) : changePosY/(mainHeight*1.2)
             If (adjustGradientOffset=1)
             {
                alphaMaskOffsetX := clampInRange(o_alphaMaskOffsetX + movX, -0.9, 0.9)
                alphaMaskOffsetY := clampInRange(o_alphaMaskOffsetY + movY, -0.9, 0.9)
                If (altState=1)
                   alphaMaskOffsetX := alphaMaskOffsetY := o_alphaMaskOffsetX := o_alphaMaskOffsetY := 0
             } Else If (adjustGradientOffset=2)
             {
                clrGradientOffX := clampInRange(o_clrGradientOffX + movX, -0.9, 0.9)
                clrGradientOffY := clampInRange(o_clrGradientOffY + movY, -0.9, 0.9)
                If (altState=1)
                   clrGradientOffX := clrGradientOffY := o_clrGradientOffX := o_clrGradientOffY := 0
             }
          }

          If (shiftState=1 && dotActive=9 && adjustGradientOffset=0)
          {
             ; drag selection
             snapAxisX := dotActiveObj.cx1 + SelDotsSize//2
             snapAxisY := dotActiveObj.cy1 + SelDotsSize//2
             changePosX := snapToValues(changePosX, 0, rImgW//2, snapSizeX, 0)
             changePosY := snapToValues(changePosY, 0, rImgW//2, snapSizeX, 0)
             maxPos := max(Abs(changePosX), Abs(changePosY))
             If (maxPos=Abs(changePosX))
                changePosY := 0
             Else If (maxPos=Abs(changePosY))
                changePosX := 0
          } Else If (adjustGradientOffset=0 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; changePosX := Round(changePosX*timgSelRatio)
             If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -33000, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, 33000)
             } Else If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -33000, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, 33000)
             } Else If (dotActive=3)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -timgSelH + 2, 33000) : clampInRange(changePosY, -33000, timgSelH - 2)
             } Else If (dotActive=4)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -timgSelH + 2, 33000) : clampInRange(changePosY, -33000, timgSelH - 2)
             }
          }
 
          newSelDotX := (FlipImgH=1) ? tDotPosX - changePosX : tDotPosX + changePosX
          newSelDotY := (FlipImgV=1) ? tDotPosY - changePosY : tDotPosY + changePosY
          If (showSelectionGrid=1 && shiftState!=1 && lockSelectionAspectRatio<2)
          {
             newSelDotX := snapToValues(newSelDotX, 0, rImgW//2, snapSizeX, 0)
             newSelDotY := snapToValues(newSelDotY, 0, rImgH//2, snapSizeY, 0)
          }

          If (shiftState!=1 && lockSelectionAspectRatio<2)
          {
             newSelDotX := snapToValues(newSelDotX, 0, rImgW, snapSizeX, 0)
             newSelDotY := snapToValues(newSelDotY, 0, rImgH, snapSizeY, 0)
          }

          If (dotActive=1)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=2)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=3)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=4)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=5)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=6)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=7)
          {
             coords := 2
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=8)
          {
             coords := 2
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=9 && adjustGradientOffset=0 && adjustSelCavity=0)
          {
             coords := 10
             imgSelX1 := (FlipImgH=1) ? nImgSelX1 - changePosX : nImgSelX1 + changePosX
             imgSelY1 := (FlipImgV=1) ? nImgSelY1 - changePosY : nImgSelY1 + changePosY
             imgSelX2 := (FlipImgH=1) ? nImgSelX2 - changePosX : nImgSelX2 + changePosX
             imgSelY2 := (FlipImgV=1) ? nImgSelY2 - changePosY : nImgSelY2 + changePosY
          }

          If (nImgSelX1>nImgSelX2 || nImgSelY1>nImgSelY2) && (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY2
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY1
          } Else If (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY1
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY2
          }

          If (imgSelX1=imgSelX2)
             imgSelX2 += 2
          If (imgSelY1=imgSelY2)
             imgSelY2 += 2

          imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
          imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          If (adjustGradientOffset=0 && altState=1 && (dotActive=1 || dotActive=2 || dotActive=9))
          {
             ; rectangular selection mode
             avg := (imgSelW+imgSelH)//2
             If (dotActive=9)
             {
                cAvg := (changePosX+changePosY)//2
                imgSelX2 := timgSelX2 + cAvg
                imgSelY2 := timgSelY2 + cAvg
                imgSelX1 := timgSelX1 - cAvg
                imgSelY1 := timgSelY1 - cAvg
             } Else If (dotActive=2)
             {
                imgSelX2 := imgSelX1 + avg
                imgSelY2 := imgSelY1 + avg
             } Else
             {
                imgSelX1 := imgSelX2 - avg
                imgSelY1 := imgSelY2 - avg

             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          } Else If (adjustGradientOffset=0 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; keep aspect ratio mode
             cAvg := (changePosX+changePosY)//2
             diffu := (timgSelRatio>1) ? min(timgSelW, timgSelH) : max(timgSelW, timgSelH)
             If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                imgSelX2 := clampInRange(timgSelX1 + Round((diffu + cAvg)*timgSelRatio), timgSelX1 + 5, 33000)
                imgSelY2 := clampInRange(timgSelY1 + (diffu + cAvg), timgSelY1 + 5, 33000)
                If (dotActive=6)
                   ImgSelY1 := nImgSelY1
                Else If (dotActive=8)
                   ImgSelX1 := nImgSelX1
             } Else If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                cAvg := -cAvg
                imgSelX1 := clampInRange(otimgSelX2 - Round((diffu + cAvg)*timgSelRatio), -33000, otimgSelX2 + 5)
                imgSelY1 := clampInRange(otimgSelY2 - (diffu + cAvg), -33000, otimgSelY2 + 5)
             } Else If (dotActive=3)
             {
                cAvg := -cAvg
                imgSelX2 := timgSelX1 + Round((diffu+cAvg)*timgSelRatio)
                imgSelY1 := otimgSelY2 - diffu - cAvg
             } Else If (dotActive=4)
             {
                ; cAvg := -cAvg
                imgSelY2 := timgSelY1 + diffu + cAvg
                imgSelX1 := otimgSelX2 - Round((diffu+cAvg)*timgSelRatio)
             }

             ; TulTip(0, "=", changePosX, changePosX, tDotPosX, tDotPosY, imgSelW, imgSelH, imgSelX1, "lol " imgSelY1, nImgSelX1, nImgSelY1, newSelDotX, newSelDotY, dotActive)
             If (LimitSelectBoundsImg=1)
             {
                imgSelX1 := clampInRange(imgSelX1, 0, prevMaxSelX)
                imgSelY1 := clampInRange(imgSelY1, 0, prevMaxSelY)
                imgSelX2 := clampInRange(imgSelX2, 0, prevMaxSelX)
                imgSelY2 := clampInRange(imgSelY2, 0, prevMaxSelY)
             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          }

          ; ToolTip, % cAvg "=" dotActive "|" changePosX "|" changePosY "|" timgSelW "|" timgSelH , , , 2
          If (A_TickCount - thisZeit>25)
          {
             If (isInRange(dotActive, 1, 4) && minimizeMemUsage!=1)
             {
                ARGBdec := Gdip_GetPixel(gdiBitmap, newSelDotX, newSelDotY)
                Gdip_FromARGB(ARGBdec, cA, cR, cG, cB)
                pixelColor := cR ", " cG ", " cB ", " cA
                addMsg := "`n `nCorner coordinates`nX / Y: " Round(newSelDotX) ", " Round(newSelDotY) "`nColor: " pixelColor
             }

             theRatio := (lockSelectionAspectRatio>1) ? "`nLocked aspect ratio: " Round(desiredSelAspectRatio, 2) : " (" Round(imgSelW/imgSelH, 2) ")"
             ; If (imgEditPanelOpened=1)
                theRatio .= "`nRotation: " Round(VPselRotation, 2) "° "

             theMsg := "X / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) "`nW / H: " Round(imgSelW) ", " Round(imgSelH) theRatio addMsg
             If (adjustGradientOffset=1)
                theMsg := "Alpha mask gradient center offset`nX / Y: " Round(alphaMaskOffsetX * 100, 2) "%, " Round(alphaMaskOffsetY * 100, 2) "%`nGradient angle: " Round(alphaMaskGradientAngle) "°"
             Else If (adjustSkewImg=1)
                theMsg := "Skew image object`nX / Y: " Round(shearImgX * 10, 2) "%, " Round(shearImgY * 10, 2) "%"
             Else If (adjustGradientOffset=2)
                theMsg := "Color gradient center offset`nX / Y: " Round(clrGradientOffX * 100, 2) "%, " Round(clrGradientOffY * 100, 2) "%`nGradient angle: " Round(FillAreaGradientAngle) "°"
             Else If (adjustSelCavity=1)
                theMsg := "Selection exclusion area`nX / Y:" Round(innerSelectionCavityX*100, 2) "%, " Round(innerSelectionCavityY*100, 2) "%"

             ; ToolTip, % theMsg, % mainX + 10, % mainY + 10
             drawImgSelectionOnWindow("live", theMsg, ARGBdec, dotActive, mainWidth, mainHeight, 0, 0, 0, 0, snapAxisX, snapAxisY)
             thisZeit := A_TickCount
          }
      }

      setwhileLoopExec(0)
      adjustingSelDotNow := adjustNowSel := 0
      If dotActive
         drawImgSelectionOnWindow("end")

      ToolTip
      If (dotActive && imgEditPanelOpened=1)
         anotherZeit := A_TickCount

      If (dotActive=9 && isInRange(Abs(changePosY), 0, 2) && isInRange(Abs(changePosX), 0, 2))
      {
         If (A_TickCount - anotherZeit<300) && (imgEditPanelOpened!=1)
            thisZeit := dotActive := ctrlState := 0
         anotherZeit := A_TickCount
      }

      If (dotActive || (A_TickCount - thisZeit<150)) && (ctrlState=0)
         Return
   }

   If (winEventu="DoubleClick" && thumbsDisplaying!=1 && displayingImageNow=1 && spaceState!=1) && (A_TickCount - lastInvokedSwipe>500) && (A_TickCount - anotherZeit>600)
   {
      ; handle double clicks in the viewport when an image is being displayed
      If (editingSelectionNow=1 && imgEditPanelOpened!=1)
      {
         lastInvoked := A_TickCount
         ToggleEditImgSelection()
         Return
      }

      lastInvoked := A_TickCount
      If (slideShowRunning=1)
         InfoToggleSlideShowu()
      Else
         ToggleViewModeTouch()
   } Else If ((displayingImageNow=1 || mustOpenStartFolder) && winEventu!="DoubleClick") && (A_TickCount - thisZeit>950)
   ; } Else If ((maxFilesIndex>1 || mustOpenStartFolder) && CurrentSLD && winEventu!="DoubleClick") && (A_TickCount - thisZeit>950)
   {
      ; handle single clicks in the viewport when multiple files are loaded
      didSomething := 0
      If (TouchScreenMode=0 || spaceState=1) && ((IMGlargerViewPort=1 || allowFreeIMGpanning=1 || spaceState=1) && IMGresizingMode=4 && thumbsDisplaying!=1)
         SetTimer, simplePanIMGonClick, -15
      Else If (TouchScreenMode=1 && drawingShapeNow!=1)
         didSomething := winSwipeAction(thisCtrlClicked, winEventu)
      Else didSomething := 0

      lastInvoked := A_TickCount
      If didSomething
         lastInvokedSwipe := A_TickCount
   } Else If (!CurrentSLD || maxFilesIndex<1) && (A_TickCount - thisZeit>450)
   {
      ; when no image is loaded, on click, open files dialog
      lastInvoked := A_TickCount
      If StrLen(UserMemBMP)>2
         Return

      SetTimer, drawWelcomeImg, Off
      Sleep, 5
      If (A_TickCount - lastWinDrag>300)
         OpenDialogFiles()
   }
   lastInvoked := A_TickCount
} ; /// WinClickAction()

JEE_ScreenToWindow(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472

  VarSetCapacity(RECT, 16, 0)
  DllCall("user32\GetWindowRect", "UPtr", hWnd, "UPtr", &RECT)
  vWinX := NumGet(&RECT, 0, "Int")
  vWinY := NumGet(&RECT, 4, "Int")
  vPosX2 := vPosX - vWinX
  vPosY2 := vPosY - vWinY
  RECT := ""
}

JEE_ScreenToClient(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472
  VarSetCapacity(POINT, 8, 0)
  NumPut(vPosX, &POINT, 0, "Int")
  NumPut(vPosY, &POINT, 4, "Int")
  DllCall("user32\ScreenToClient", "UPtr", hWnd, "UPtr", &POINT)
  vPosX2 := NumGet(&POINT, 0, "Int")
  vPosY2 := NumGet(&POINT, 4, "Int")
  POINT := ""
}

ToggleImageSizingMode(dummy:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50)
       Return

    o_friendly := DefineImgSizing()
    If (drawingShapeNow=1)
    {
       If (CustomShapeSymmetry || CustomShapeLockedSymmetry) && (vpSymmetryPointX || vpSymmetryPointY)
          MouseCoords2Image(vpSymmetryPointX, vpSymmetryPointY, 0, vpSymmetryPointXdp, vpSymmetryPointYdp, prevResizedVPimgW, prevResizedVPimgH, newVPx, newVPy, 0, 0)
       ; customShapePoints := convertCustomShape2relativeCoords(customShapePoints)
    }

    lastInvoked := A_TickCount
    resetSlideshowTimer(0)
    If (dummy="cus-w")
    {
       IMGdecalageX := IMGdecalageY := 1
       lockZoomLevel := 0
       IMGresizingMode := 4
       customZoomAdaptMode := 1
    } Else If (dummy="cus-h")
    {
       IMGdecalageX := IMGdecalageY := 1
       lockZoomLevel := 0
       customZoomAdaptMode := 2
       IMGresizingMode := 4
    } Else If (dummy="cus-tom")
    {
       IMGdecalageX := IMGdecalageY := zoomLevel := 1
       IMGresizingMode := 4
       customZoomAdaptMode := 0
    } Else If (imgEditPanelOpened=1 || drawingShapeNow=1 && editingSelectionNow=1)
    {
       IMGresizingMode := (IMGresizingMode=1) ? 4 : 1
       If (IMGresizingMode=4)
          zoomLevel := 1
    } Else 
    {
       IMGdecalageX := IMGdecalageX := 1
       IMGresizingMode := clampInRange(IMGresizingMode + 1, 1, 5, 1)
       If (IMGresizingMode=3)
       {
          zoomLevel := 1
          IMGresizingMode := 4
       }

       If (IMGresizingMode=5 && editingSelectionNow=1)
          ToggleEditImgSelection()
    }

    If (IMGresizingMode=4)
       moreInfos := "`nImages can be panned in this mode."

    friendly := DefineImgSizing()
    If InStr(dummy, "cus-")
       showTOOLtip("Adapt to window mode:`n" friendly moreInfos, "toggleCustomZLmodes", 1, (customZoomAdaptMode + 1.01)/3.02)
    Else
       showTOOLtip("Adapt to window mode:`n" friendly moreInfos, A_ThisFunc, 1, (IMGresizingMode - 0.99)/4)

    If (allowFreeIMGpanning=1 && imageAligned=5 && IMGresizingMode=4 && o_friendly!=friendly2)
    {
       IMGdecalageX := IMGdecalageY := 1
       PrintPosX := "X"
    }

    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "zoomLevel", "General")
    INIaction(1, "lockZoomLevel", "General")
    uiPanelOpenCloseEvent()
    SetTimer, RemoveTooltip, % -msgDisplayTime
    If (drawingShapeNow=1)
    {
       adaptCustomShapeNewZoomLevel(0)
       If (newVPx!="" && newVPy!="")
       {
          ImageCoords2Window(newVPx, newVPy, prevDestPosX, prevDestPosY, 0, vpSymmetryPointX, vpSymmetryPointY, 0)
          vpSymmetryPointXdp := prevDestPosX
          vpSymmetryPointYdp := prevDestPosY
       }
       Return
    }

    SetTimer, coreReloadThisPicture, -50
    ; dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, uiIMGresizingMode, % IMGresizingMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

DefineImgSizing() {
   friendly := (IMGresizingMode=1) ? "ADAPT ALL INTO VIEW" : "ADAPT ONLY LARGE IMAGES"
   If (IMGresizingMode=3)
      friendly := "NONE (FIXED TO ORIGINAL SIZE)"
   Else If (IMGresizingMode=5)
      friendly := "STRETCHED TO WINDOW"
   Else If (IMGresizingMode=4)
   {
      friendly := "CUSTOM ZOOM " Round(zoomLevel * 100) "%"
      If (customZoomAdaptMode>0)
         friendly := (customZoomAdaptMode=1) ? "Adapt to window width" : "Adapt to window height"
   }

   Return friendly
}

VPimgFXrandomizer() {
    Static lastFX, FXmodes := {1:1, 2:2, 3:3, 4:4, 5:10}
    Random, OutputVar, 1, 5
    imgFxMode := FXmodes[OutputVar]
    If (imgFxMode=lastFX && lastFX=10)
    {
       Random, OutputVar, 1, 5
       imgFxMode := FXmodes[OutputVar]
    }

    Random, OutputVar, 1, 200
    satAdjust := OutputVar/100

    Random, OutputVar, 0.1, 0.9
    bwDithering := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 0.1, 0.9
    usrTextureBGR := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 0.1, 0.9
    FlipImgH := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 1, 7
    If (OutputVar=2)
       OutputVar := 1
    usrColorDepth := OutputVar
}

dummyInfoToggleSlideShowu(actu:=0) {
  Static lastInvoked := 1
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()

  GIFframesPlayied := 0
  r := ToggleSlideShowu(actu)
  If (r="lulz")
     Return

  If (slideShowRunning!=1 || actu="stop")
  {
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     ; userSeenSlideImages := (userSeenSlideImages>maxFilesIndex - 1) ? maxFilesIndex : userSeenSlideImages
     showTOOLtip("Slideshow: STOPPED`nImages seen in this session: " groupDigits(userSeenSlideImages))
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  } Else ;  If (A_TickCount - lastInvoked > 450)
  {
     delayu := DefineSlidesRate()
     friendly := DefineSlideShowType()
     etaTime := "`nEstimated time: " EstimateSlideShowLength()
     If (slidesFXrandomize=1)
        etaTime .= "`nViewport colour effects are randomized for each image."

     If (skipSeenImageSlides=1)
        etaTime .= "`nAlready seen images will be skipped."

     showTOOLtip("Started " friendly " slideshow`nSpeed: " delayu "`nTotal files: " groupDigits(maxFilesIndex) etaTime)
     SetTimer, RemoveTooltip, % -msgDisplayTime, 900
     If (slideShowDelay < 900)
     {
        Sleep, 550
        RemoveTooltip()
     } Else SetTimer, RemoveTooltip, % -msgDisplayTime, 900
  } ; Else  SetTimer, dummyInfoToggleSlideShowu, Off
}

InfoToggleSlideShowu() {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 350) && (slideShowRunning!=1) || (maxFilesIndex<3 && StrLen(mustOpenStartFolder)<4)
   {
     lastInvoked := A_TickCount
     Return
   }

   lastInvoked := A_TickCount
   If !(IMGlargerViewPort=1 && IMGresizingMode=4)
      SetTimer, dummyInfoToggleSlideShowu, -80
   Return
}

preventScreenOff() {
  ; if the user is idle ;-)
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 10500) || (slideShowRunning!=1)
     Return

  lastInvoked := A_TickCount
  If (!GetKeyState("Space", "P") && slideShowRunning=1 && WinActive("A")=PVhwnd)
  {
     MouseMove, 2, 0, 2, R
     MouseMove, -2, 0, 2, R
     ; SendEvent, {Up}
  }
  ; z := DllCall("user32\SetCursor", "Ptr", hCursBusy)
  ; ToolTip, % "L=" z , , , 2
}

ToggleSlideShowu(actu:=0, resetMode:=0) {
  If (maxFilesIndex<3 && slideShowRunning!=1)
  {
     showTOOLtip("WARNING: Insufficient indexed files to start a slideshow")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "lulz"
  }

  If askAboutFileSave(" and the slideshow will begin")
     Return "lulz"
  Else
     terminateIMGediting()

  If (RandyIMGnow=-1 || !RandyIMGids.Count()) && (SlideHowMode=1)
     coreGenerateRandomList()

  interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
  interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
  interfaceThread.ahkassign("slidesFXrandomize", slidesFXrandomize)
  If (slideShowRunning=1 || actu="stop") && (actu!="start")
  {
     If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
     {
        WinSet, Region,, ahk_id %hQPVtoolbar%
        WinSet, Transparent, % ToolbarOpacity, ahk_id %hQPVtoolbar%
     }
     If (StrLen(SlidesMusicSong)>3 && hSNDsong && resetMode!=1)
        StopMediaPlaying(1)

     slideShowRunning := 0
     ; ResetImgLoadStatus()
     ; SetTimer, theSlideShowCore, Off
     prevSlideShowStop := A_TickCount
     interfaceThread.ahkFunction("slideshowsHandler", 0, "stop", SlideHowMode)
     SetTimer, ResetImgLoadStatus, -150
  } Else If (thumbsDisplaying!=1 || actu="start")
  {
     If (A_TickCount - prevSlideShowStop<500) && (actu!="start")
        Return

     If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
     {
        WinSet, Region, 0-0 w5 h5, ahk_id %hQPVtoolbar%
        WinSet, Transparent, 120, ahk_id %hQPVtoolbar%
     }
     If (editingSelectionNow=1)
        ToggleEditImgSelection()

     ResetImgLoadStatus()
     If (StrLen(SlidesMusicSong)>3 && autoPlaySlidesAudio=1 && resetMode!=1)
        startSlidesMusicNow()

     slideShowRunning := 1
     interfaceThread.ahkassign("allowNextSlide", 1)
     If (hSNDmediaFile && hSNDmediaDuration && hSNDmedia)
        milisec := MCI_Length(hSNDmedia) 

     thisSlideSpeed := (milisec>slideShowDelay) ? milisec : slideShowDelay
     msgu := "Slideshow is running. Direction: " DefineSlideShowType() ". Speed: " DefineSlidesRate() "."
     If (slidesFXrandomize=1)
        msgu .= "`nViewport colour effects are randomized for each image."

     If (skipSeenImageSlides=1)
        msgu .= "`nAlready seen images will be skipped."

     msgu .= "`nPress Escape or click to stop the slideshow."
     interfaceThread.ahkFunction("slideshowsHandler", thisSlideSpeed, "start", SlideHowMode, msgu)
     ; SetTimer, theSlideShowCore, % thisSlideSpeed
  }
  Return
}

theSlideShowCore() {
   If (slideShowRunning=1 && slidesFXrandomize=1)
      VPimgFXrandomizer()

   If (SlideHowMode=1)
     RandomPicture()
   Else If (SlideHowMode=2)
     PreviousPicture()
   Else If (SlideHowMode=3)
     NextPicture()
   Return
}

GoNextSlide() {
  Sleep, 15
  If GetKeyState("LButton")
  {
     SetTimer, GoNextSlide, -100
     Return
  }

  resetSlideshowTimer(0)
  If (SlideHowMode=1)
     RandomPicture()
  Else
     NextPicture()
}

GoPrevSlide() {
  Sleep, 15
  If GetKeyState("LButton")
  {
     SetTimer, GoPrevSlide, -100
     Return
  }

  resetSlideshowTimer(0)
  If (SlideHowMode=1)
     PrevRandyPicture()
  Else
     PreviousPicture()
}

coreSecToHHMMSS(Seco, ByRef Hrs, ByRef Min, ByRef Sec) {
  OldFormat := A_FormatFloat
  SetFormat, Float, 2.00
  Hrs := Seco//3600/1
  Min := Mod(Seco//60, 60)/1
  SetFormat, Float, %OldFormat%
  Sec := Round(Mod(Seco, 60), 2)
}

SecToHHMMSS(Seco) {
  coreSecToHHMMSS(Seco, Hrs, Min, Sec)
  If (hrs>26)
     dayz := Round(hrs/24, 2)
  If (dayz>=1.1)
  {
     If (dayz>32)
        Return "about " Round(dayz/30.5, 2) " months"
     r := dayz " days"
  } Else  r := (Hrs ? Hrs "h " : "") Min "m " Sec "s"

  If (!min && !hrs)
  {
     r := StrReplace(r, "0m ")
     r := Trimmer(r, "0")
  }
  r := StrReplace(r, ".00s", "s")
  If (min || hrs)
     r := RegExReplace(r, "\...s", "s")
  r := StrReplace(r, " 0s")
  r := StrReplace(r, "  ", A_Space)
  r := Trimmer(r)

  Return r
}

DefineSlideShowType() {
   friendly := (SlideHowMode=1) ? "RANDOM" : "BACKWARD"
   If (SlideHowMode=3)
      friendly := "FORWARD"
   Return friendly
}

ToggleSlideshowModes() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1)
      Return

   lastInvoked := A_TickCount
   SlideHowMode++
   If (SlideHowMode>3)
      SlideHowMode := 1

   resetSlideshowTimer(0, 1)
   friendly := DefineSlideShowType() "`nCurrently "
   friendly .= (slideShowRunning=1) ? "running" : "stopped"
   showTOOLtip("Slideshow direction: " friendly, A_ThisFunc, 1, SlideHowMode/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "SlideHowMode", "General")
}

DefineVPselAreaMode() {
   If (EllipseSelectMode=2)
      friendly := (bezierSplineCustomShape=1) ?  "FREEFORM BÉZIER" : "FREEFORM - T" FillAreaCurveTension
   Else If (EllipseSelectMode=1)
      friendly := "ELLIPTICAL"
   Else
      friendly := "RECTANGULAR"

   If ((AnyWindowOpen=23 || AnyWindowOpen=65) && EllipseSelectMode=0)
   {
      Gui, SettingsGUIA: Default
      GuiControlGet, hwnd, hwnd, FillAreaShape
      ControlGetText, info,, ahk_id %hwnd%
      info := Format("{:U}", info)
      Return info
   }
   Return friendly
}

DefineFXmodes() {
   Static FXmodesLabels := {1:"ORIGINAL", 2:"PERSONALIZED", 3:"AUTO-ADJUSTED", 4:"GRAYSCALE", 5:"RED CHANNEL", 6:"GREEN CHANNEL", 7:"BLUE CHANNEL", 8:"ALPHA CHANNEL", 9:"INVERTED COLORS", 10:"SEPIA"}
        , otherFXLabels := {1:"ADAPTIVE", 2:"BRIGHTNESS", 3:"CONTRAST"}

   If FXmodesLabels.HasKey(imgFxMode)
      friendly := FXmodesLabels[imgFxMode]
   Else
      friendly := "Colors FX: " imgFxMode
   If (imgFxMode=3)
      friendly .= A_Space otherFXLabels[autoAdjustMode]

   If (bwDithering=1 && imgFxMode=4)
      friendly := "BLACK/WHITE DITHERED"

   If (imgFxMode=1 && isInRange(usrColorDepth, 2, 10))
      friendly := "ALTERED COLOR DEPTH"

   Return friendly
}

ToggleImgColorDepth(dir:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 && thumbsListViewMode>1)
       Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   If (imgFxMode=4 && bwDithering=1)
   {
      imgFxMode := 1
      Return
   }

   good2go := (imgFxMode=1 || imgFxMode=2 || imgFxMode=3 || imgFxMode=8) ? 1 : 0
   If (good2go!=1)
      imgFxMode := 1

   If (dir=1)
      usrColorDepth++
   Else
      usrColorDepth--

   usrColorDepth := clampInRange(usrColorDepth, 1, 9, 1)
   ForceRefreshNowThumbsList()
   infoColorDepth := (usrColorDepth>1) ? defineColorDepth() : "NONE"
   showTOOLtip("Image color depth simulated:`n" infoColorDepth, A_ThisFunc, 2, (usrColorDepth - 0.999)/8)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "usrColorDepth", "General")
   INIaction(1, "imgFxMode", "General")
   SetTimer, RefreshImageFile, -50

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, usrColorDepth, % usrColorDepth
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineColorDepth() {
   Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:16}

   internalColorDepth := bitsOptions[usrColorDepth]
   r := internalColorDepth " bits [" 2**internalColorDepth " colors]"
   If (r<1)
      r := currIMGdetails.PixelFormat
   Else If (ColorDepthDithering=1)
      r .= " | DITHERED"

   If !r
      r := "NONE"
   Return r
}

ToggleImgFX(dir:=0) {
   Static lastInvoked := 1, moreFX := {1:"None", 2:"Brightness / Contrast", 3:"Hue / Saturation / Lightness", 4:"Levels adjust [High / Mid / Low]", 5:"Color tint [Hue / Amount]", 6:"Colors balance", 7:"Color curve per channel"}
        , curvesFX := {1:"Brightness (density)", 2:"Contrast", 3:"Highlights", 4:"Shadows", 5:"Midtones", 6:"White saturation", 7:"Black saturation"}
        , curvesChannels := {1:"Red", 2:"Green", 3:"Blue", 4:"All"}

   If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 && showHUDnavIMG!=1)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=1)
      imgFxMode++
   Else
      imgFxMode--

   prevColorAdjustZeit := A_TickCount
   If (imgFxMode=3 && thumbsDisplaying=1)
   {
      If (dir=1)
         imgFxMode++
      Else
         imgFxMode--
   }

   imgFxMode := clampInRange(imgFxMode, 1, 10, 1)
   friendly := DefineFXmodes()
   If (imgFxMode=4)
      friendly .= "`nBrightness: " Round(lumosGrayAdjust, 3) "`nContrast: " Round(GammosGrayAdjust, 3)
   Else If (imgFxMode=2)
      friendly .= "`nBrightness: " Round(lumosAdjust, 3) "`nContrast: " Round(GammosAdjust, 3) "`nSaturation: " Round(satAdjust*100) "%"

   If isVarEqualTo(imgFxMode, 2, 4, 9)
      friendly .= "`nGamma: " Round(realGammos, 3)
   
   If (isVarEqualTo(imgFxMode, 2, 3, 9, 10) || (imgFxMode=4 && !bwDithering)) && (IntensityAlphaChannel!=1)
      friendly .= "`nAlpha channel: ALTERED"

   If (specialColorFXmode>1 && isVarEqualTo(imgFxMode, 2, 3, 4, 9))
   {
      friendly .= "`n" moreFX[specialColorFXmode]
      If (specialColorFXmode=7)
         friendly .= " [" curvesFX[uiColorCurveFXmode] "]: "  Round(lummyAdjust) " - " curvesChannels[uiColorCurveFXchannel]
      Else
         friendly .= ":`n" Round(hueAdjust) " / " Round(zatAdjust) " / " Round(lummyAdjust)
   }

   bonus := (usrColorDepth>1 && imgFxMode=1) ? 0.5 : 0
   If (usrColorDepth>1 && imgFxMode=1)
      friendly .= "`nSimulated color depth: " defineColorDepth()

   If (imgFxMode=4 || imgFxMode=3 || imgFxMode=2)
      friendly .= "`n `nPress U to adjust colors display options."

   showTOOLtip("Image colors: " friendly, A_ThisFunc, 2, (imgFxMode - 0.999 + bonus)/9)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()

   If (imgFxMode=3 && thumbsDisplaying!=1)
   {
      imgPath := getIDimage(currentFileIndex)
      AdaptiveImgLight(useGdiBitmap(), imgPath, 1, 1)
   }

   INIaction(1, "imgFxMode", "General")
   If (o_bwDithering=0)
      o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0

   If (o_bwDithering=1 && thumbsDisplaying!=1)
      RefreshImageFile()
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, imgFxMode, % imgFxMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineImgAlign() {
   modes := {1:"Top-left corner", 2:"Top-center", 3:"Top-right corner", 4:"Left-center", 5:"Center", 6:"Right-center", 7:"Bottom-left corner", 8:"Bottom-center", 9:"Bottom-right corner"}
   ; thisAlign := (IMGresizingMode=4) ? 5 : imageAligned
   r := modes[imageAligned]
   StringUpper, r, r
   Return r
}

ToggleIMGalign() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (!useGdiBitmap() && thumbsDisplaying!=1)
      Return

   resetSlideshowTimer(0, 1)
   imageAligned := (imageAligned=5) ? 1 : 5
   showTOOLtip("Image alignment: " defineImgAlign(), A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "imageAligned", "General")
   If (drawingShapeNow=1)
   {
      If (CustomShapeSymmetry || CustomShapeLockedSymmetry) && (vpSymmetryPointX || vpSymmetryPointY)
         MouseCoords2Image(vpSymmetryPointX, vpSymmetryPointY, 0, vpSymmetryPointXdp, vpSymmetryPointYdp, prevResizedVPimgW, prevResizedVPimgH, newVPx, newVPy, 0, 0)
      
      ; customShapePoints := convertCustomShape2relativeCoords(customShapePoints)
      adaptCustomShapeNewZoomLevel(zoomLevel)
      If (newVPx!="" && newVPy!="")
      {
         ImageCoords2Window(newVPx, newVPy, prevDestPosX, prevDestPosY, 0, vpSymmetryPointX, vpSymmetryPointY, 0)
         vpSymmetryPointXdp := prevDestPosX
         vpSymmetryPointYdp := prevDestPosY
      }
      Return
   }

   IMGdecalageX := IMGdecalageY := 1
   If (allowFreeIMGpanning=1 && IMGresizingMode=4)
      PrintPosX := "X"

   dummyTimerReloadThisPicture(50)
   uiPanelOpenCloseEvent()
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   } Else if (thumbsDisplaying=1)
   {
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(50)
   }
}

toggleColorAdjustments(modus:=0) {
   Static lastInvoked := 1, prevImgAlphaChn := 1, prevFXmode := 1
   If (modus="backup")
   {
      IntensityAlphaChannel := (ForceNoColorMatrix=1) ? 1 : prevImgAlphaChn
      imgFxMode := (ForceNoColorMatrix=1) ? 1 : prevFXmode
      Return
   }

   If (A_TickCount - lastInvoked < 50)
      Return

  lastInvoked := A_TickCount
  If (imgFxMode!=1 && thumbsDisplaying!=1)
  {
     prevColorAdjustZeit := A_TickCount
     resetSlideshowTimer(0)
     If (!ForceNoColorMatrix && modus!="backup")
     {
        prevFXmode := imgFxMode
        prevImgAlphaChn := IntensityAlphaChannel
     }

     ForceNoColorMatrix := !ForceNoColorMatrix
     If (modus=0)
        AnyWindowOpen := (ForceNoColorMatrix=1) ? 10 : 0
     IntensityAlphaChannel := (ForceNoColorMatrix=1) ? 1 : prevImgAlphaChn
     imgFxMode := (ForceNoColorMatrix=1) ? 1 : prevFXmode
     dummyTimerDelayiedImageDisplay(50)
     If (modus=0)
     {
        AnyWindowOpen := 10
        SetTimer, resetClrMatrix, -1500
     }
  }
}

resetClrMatrix() {
   resetSlideshowTimer(0)
   AnyWindowOpen := ForceNoColorMatrix := 0
   toggleColorAdjustments("backup")
   dummyTimerDelayiedImageDisplay(50)

}

ResetImageView() {
   Critical, on
   If throwErrorNoImageLoaded()
      Return

   ChangeLumos(2)
}

HardResetImageView() {
   Critical, on
   DestroyTempBtnGui("now")
   If (!useGdiBitmap() && !CurrentSLD)
      Return

   ChangeLumos(2, "k")
   If (AnyWindowOpen=40 && thumbsDisplaying=1)
      updateUIthumbsView()
}

coreResetIMGview(dummy:=0) {
  If (imgFxMode=4 && lumosGrayAdjust=1 && GammosGrayAdjust=0)
     mustResetFxMode := 1

  If (dummy="k")
  {
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0
     imgThreshold := bwDithering := hueAdjust := zatAdjust := lummyAdjust := 0
     IntensityAlphaChannel := specialColorFXmode := 1
  }

  If (imgFxMode=4)
  {
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
  } Else If (imgFxMode=2)
  {
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || dummy="k")
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0

  realGammos := 1
  If (imgFxMode=1 || dummy="k")
  {
     zoomLevel := 1
     FlipImgH := FlipImgV := 0
     If (thumbsDisplaying!=1)
       vpIMGrotation := 0
  }

  If (dummy="k")
  {
     ; bwDithering := 0
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
     vpIMGrotation := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || imgFxMode>4 || mustResetFxMode=1)
     imgFxMode := 1

  If (thumbsDisplaying=1)
  {
     thumbsZoomLevel := 1
     thumbsColumns := 7
     recalculateThumbsSizes()
     ; thumbsH := othumbsH + 1
     ; thumbsW := othumbsW + 1
     ForceRefreshNowThumbsList()
  }

  interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
  If (dummy="k")
     usrColorDepth := internalColorDepth := 1
}

ChangeLumos(dir, dummy:=0) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer(0)
   If (imgFxMode!=2 && imgFxMode!=4 && dir!=2)
      imgFxMode := 2

   showHardReset := 0
   If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
      showHardReset := 1

   prevColorAdjustZeit := A_TickCount
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=2)
   {
      coreResetIMGview(dummy)
      SetTimer, WriteSettingsColorAdjustments, -95
   } Else If (imgFxMode=4)
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosGrayAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosGrayAdjust += stepu
      Else
         lumosGrayAdjust -= stepu

      lumosGrayAdjust := clampInRange(lumosGrayAdjust, 0.001, 25)
   } Else
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosAdjust += stepu
      Else
         lumosAdjust -= stepu

      lumosAdjust := clampInRange(lumosAdjust, 0.001, 25)
   }

   value2show := (imgFxMode=4) ? Round(lumosGrayAdjust, 3) : Round(lumosAdjust, 3)
   If (dir=2)
   {
      If (imgFxMode=4)
         addMsg := DefineFXmodes()
      If (imgFxMode=1 && usrColorDepth>1)
         addMsg .= "`nImage color depth: ALTERED [ " defineColorDepth() " ]"
      If (vpIMGrotation>0)
         addMsg .= "`nImage rotated: " vpIMGrotation "° degrees."
      If (thisIMGisDownScaled=1)
         addMsg .= "`nImage dimensions DOWNSCALED to screen resolution."

      addMsg .= defineIMGmirroring()
      If (dummy!="k" && showHardReset=1)
      {
         addMore := "`nReset all adjustments to defaults with Ctrl + \"
         CreateGuiButton("Reset all adjustments,,HardResetImageView", 0, msgDisplayTime//1.5 + 100)
      }
      showTOOLtip("Image display: UNALTERED " addMsg addMore)
   } Else showTOOLtip("Image brightness: " value2show, A_ThisFunc, 2, value2show / 25)

   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues && dir!=2)
      Return

   If (dir!=2)
      SetTimer, dummySaveLumGammos, -70

   prevValues := newValues
   If (o_bwDithering=1 || otherFX=1) ; && (thumbsDisplaying!=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If ((AnyWindowOpen=10 || AnyWindowOpen=74) && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

WriteSettingsColorAdjustments() {
    INIaction(1, "autoAdjustMode", "General")
    INIaction(1, "bwDithering", "General")
    INIaction(1, "chnBdecalage", "General")
    INIaction(1, "chnGdecalage", "General")
    INIaction(1, "chnRdecalage", "General")
    INIaction(1, "ColorDepthDithering", "General")
    INIaction(1, "doSatAdjusts", "General")
    INIaction(1, "FlipImgH", "General")
    INIaction(1, "FlipImgV", "General")
    INIaction(1, "GammosAdjust", "General")
    INIaction(1, "GammosGrayAdjust", "General")
    INIaction(1, "histogramMode", "General")
    INIaction(1, "hueAdjust", "General")
    INIaction(1, "imgFxMode", "General")
    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "imgThreshold", "General")
    INIaction(1, "IntensityAlphaChannel", "General")
    INIaction(1, "lummyAdjust", "General")
    INIaction(1, "lumosAdjust", "General")
    INIaction(1, "lumosGrayAdjust", "General")
    INIaction(1, "realGammos", "General")
    INIaction(1, "satAdjust", "General")
    INIaction(1, "showHistogram", "General")
    INIaction(1, "specialColorFXmode", "General")
    INIaction(1, "uiColorCurveFXchannel", "General")
    INIaction(1, "uiColorCurveFXmode", "General")
    INIaction(1, "userimgQuality", "General")
    INIaction(1, "usrAdaptiveThreshold", "General")
    INIaction(1, "usrColorDepth", "General")
    INIaction(1, "usrTextureBGR", "General")
    INIaction(1, "vpIMGrotation", "General")
    INIaction(1, "zatAdjust", "General")
    INIaction(1, "zoomLevel", "General")
}

defineIMGmirroring() {
    If (FlipImgH=1 || FlipImgV=1)
    {
       infoMirroring := "`nImage mirroring: "
       If (FlipImgV=1 && FlipImgH=0)
          infoMirroring :=  infoMirroring "VERTICAL"
       Else If (FlipImgV=0 && FlipImgH=1)
          infoMirroring := infoMirroring "HORIZONTAL"
       Else If (FlipImgV=1 && FlipImgH=1)
          infoMirroring := infoMirroring "VERTICAL, HORIZONTAL"
    }
    Return infoMirroring
}

defineFilesListType() {
    If (SLDtypeLoaded=1)
    {
       infou := !InStr(CurrentSLD, "|") ? "FOLDER RECURSIVELY" : "FOLDER"
    } Else If (SLDtypeLoaded=2)
    {
       infou := "PLAIN-TEXT | cached list"
       If (currentFilesListModified=1)
          infou .= " | unsaved changes"
    } Else If (SLDtypeLoaded=3)
       infou := "SQLITE DATABASE | cached list"
       
    Return infou
}

ChangeThumbsZoom(dir) {
   If (thumbsListViewMode>1)
   {
      changeOSDfontSize(dir)
      Return
   }

   If (dynamicThumbsColumns=1)
   {
      If (dir=1)
         thumbsZoomLevel += 0.1
      Else
         thumbsZoomLevel -= 0.1
   } Else
   {
      If (dir=1)
         thumbsColumns += 1
      Else
         thumbsColumns -= 1
   }

   thumbsZoomLevel := clampInRange(thumbsZoomLevel, 0.35, 3)
   thumbsColumns := clampInRange(thumbsColumns, 2, 100)
   ForceRefreshNowThumbsList()
   recalculateThumbsSizes()
   If (thumbsListViewMode=1)
      ForceRefreshNowThumbsList()
   INIaction(1, "thumbsZoomLevel", "General")
   INIaction(1, "thumbsColumns", "General")
   ; INIaction(1, "dynamicThumbsColumns", "General")
   If (dynamicThumbsColumns=1)
      showTOOLtip("Thumbnails zoom level: " Round(thumbsZoomLevel*100) "%`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", A_ThisFunc, 2, thumbsZoomLevel/3)
   Else
      showTOOLtip("Thumbnails columns: " thumbsColumns "`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", A_ThisFunc, 2, thumbsColumns/100)

   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(95)
}

decideNewVPzoomLevel(zl, key, dir, stepFactor) {
   If (zl<=0.1 && dir!=1)
      changeFactor := 0.01
   Else If (zl<0.1 && dir=1)
      changeFactor := 0.01
   Else
      changeFactor := 0.05

   If (zl>5)
      changeFactor := 0.50
   Else If (zl>1)
      changeFactor := 0.15
   Else If (zl<0.01)
      changeFactor := 0.005

   If InStr(key, "wheel")
      changeFactor *= 2

   If (dir=1)
      zl += changeFactor * stepFactor
   Else
      zl -= changeFactor * stepFactor

   If isInRange(zl, 0.1, 0.12)
      zl := 0.1
   Else If isInRange(zl, 0.99, 1.01)
      zl := 1
   Else If isInRange(zl, 1.98, 2.02)
      zl := 2
   Else If isInRange(zl, 9.90, 10.10)
      zl := 10

   zl := clampInRange(zl, 0.01, 20)
   Return zl 
}

ChangeZoom(dir, key:=0, stepFactor:=1, forceUpdate:=0) {
   Static prevValues, lastInvoked := 1, lastInvoked2 := 1

   If InStr(key, "wheel")
   {
      MouseGetPos, , , OutputVarWin
      If (OutputVarWin!=PVhwnd)
         Return
   }

   resetSlideshowTimer(0)
   If (thumbsDisplaying=1)
   {
      ChangeThumbsZoom(dir)
      Return
   }

   If (drawingShapeNow=1)
   {
      If (CustomShapeSymmetry || CustomShapeLockedSymmetry) && (vpSymmetryPointX || vpSymmetryPointY)
         MouseCoords2Image(vpSymmetryPointX, vpSymmetryPointY, 0, vpSymmetryPointXdp, vpSymmetryPointYdp, prevResizedVPimgW, prevResizedVPimgH, newVPx, newVPy, 0, 0)
      ; customShapePoints := convertCustomShape2relativeCoords(customShapePoints)
   }

   oldZoomLevel := zoomLevel
   zoomLevel := decideNewVPzoomLevel(zoomLevel, key, dir, stepFactor)
   o_IMGresizingMode := IMGresizingMode
   IMGresizingMode := 4
   customZoomAdaptMode := 0
   If (allowFreeIMGpanning=1 && imageAligned=5 && IMGresizingMode=4)
      PrintPosX := (o_IMGresizingMode=IMGresizingMode) ? "W" : "C"

   If (zoomLevel>3 && thisIMGisDownScaled=1 && AutoDownScaleIMGs=1)
   {
      imgPath := getIDimage(currentFileIndex)
      op := GetImgFileDimension(imgPath, Wi, He)
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      xu := (imgW*zoomLevel)/Wi
      hasThisChangedYo := 1
      zoomLevel := xu
      AutoDownScaleIMGs := 2
   }

   If (o_IMGresizingMode!=IMGresizingMode)
      uiPanelOpenCloseEvent()

   MouseGetPos, , , OutputVarWin
   If (OutputVarWin=PVhwnd && InStr(key, "wheel"))
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      prcW := mX/mainWidth
      prcH := mY/mainHeight

      prcW := (prcW>0.5) ? prcW - 0.5 : 0.5 - prcW
      prcH := (prcH>0.5) ? prcH - 0.5 : 0.5 - prcH
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      decX := Round(((imgW)*prcW) * zoomLevel)
      decY := Round(((imgH)*prcH) * zoomLevel)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (prcW>0.5 || imageAligned=1)
         decX := -decX
      If (prcH>0.5 || imageAligned=1)
         decY := -decY

      IMGdecalageX := IMGdecalageX + decX//35
      IMGdecalageY := IMGdecalageY + decY//35
   }

   ; tooltip, % IMGdecalageX " -- " IMGdecalageY "`n" decX " -- " decY "`n"prcW " -- " prcH
   If (A_TickCount - lastInvoked2<150)
   {
      zeitSillyPrevent := A_TickCount
      SetTimer, dummyDisplayZoomImgInfo, -80
   } Else
   {
      dummyDisplayZoomImgInfo()
      lastInvoked2 := A_TickCount
   }

   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")

   imgPath := getIDimage(currentFileIndex)
   If (drawingShapeNow=1)
   {
      newValues := "a"
      adaptCustomShapeNewZoomLevel(zoomLevel)
      If (newVPx!="" && newVPy!="")
      {
         ImageCoords2Window(newVPx, newVPy, prevDestPosX, prevDestPosY, 0, vpSymmetryPointX, vpSymmetryPointY, 0)
         vpSymmetryPointXdp := prevDestPosX
         vpSymmetryPointYdp := prevDestPosY
      }
      ; ToolTip, % customShapePoints.Count() "=l=" drawingVectorLiveMode , , , 2
      Return
   }

   newValues := "a" zoomLevel thumbsZoomLevel IMGresizingMode imageAligned imgPath gdiBitmap UserMemBMP
   If (prevValues=newValues && hasThisChangedYo!=1)
      Return

   prevValues := newValues
   ; If (drawModeBzeit>150 && (A_TickCount - lastInvoked < 10) && (LastWasFastDisplay!=1)) || (hasThisChangedYo=1)
   ;    GdipCleanMain(6)

   Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
   lastInvoked := A_TickCount
   If (forceUpdate=1)
   {
      dummyResizeImageGDIwin()
      dummyTimerDelayiedImageDisplay(600)
   } Else If (AutoDownScaleIMGs=2 && hasThisChangedYo=1)
   {
      SetTimer, RefreshImageFileAction, -150
   } Else 
   {
      SetTimer, dummyResizeImageGDIwin, -10
      dummyTimerDelayiedImageDisplay(600)
   }
}

adaptCustomShapeNewZoomLevel(thisZL) {
   dummyResizeImageGDIwin()
   SetTimer, dummyRefreshImgSelectionWindow, -150
   Return
}

dummyResizeImageGDIwin() {
   startZeitIMGload := A_TickCount
   imgPath := StrReplace(getIDimage(currentFileIndex), "||")
   ResizeImageGDIwin(imgPath, 0, 0)
}

dummyDisplayZoomImgInfo() {
   If (thisIMGisDownScaled=1)
      friendly := "`nThe image is downscaled.`nPress F5 or increase zoom above 300%`nto load the original file."

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, uiIMGresizingMode, % IMGresizingMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }

   showTOOLtip("Zoom level: " Round(zoomLevel*100) "%" friendly, 0, 0, zoomLevel/20)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ; SetTimer, ResetImgLoadStatus, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

ChangeGammos(dir) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer(0)
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (imgFxMode!=2 && imgFxMode!=4)
      imgFxMode := 2

   value2Adjust := (imgFxMode=4) ? GammosGrayAdjust : GammosAdjust
   value2AdjustB := (imgFxMode=4) ? lumosGrayAdjust : lumosAdjust
   stepu := (A_tickcount - lastInvoked<300) && (value2Adjust<-2) ? 0.06 : 0.03
   If (dir=1)
   {
      value2Adjust += stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB -= stepu
   } Else
   {
      value2Adjust -= stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB += stepu
   }

   value2Adjust := clampInRange(value2Adjust, -25, 1)
   value2AdjustB := clampInRange(value2AdjustB, 0.001, 25)
   If (imgFxMode=4)
   {
      GammosGrayAdjust := value2Adjust
      lumosGrayAdjust := value2AdjustB
   } Else
   {
      GammosAdjust := value2Adjust
      lumosAdjust := value2AdjustB
   }

   prevColorAdjustZeit := A_TickCount
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image contrast: " Round(value2Adjust, 3), A_ThisFunc, 2, Abs(value2Adjust - 1)/26)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues)
      Return

   SetTimer, dummySaveLumGammos, -70
   prevValues := newValues
   If (o_bwDithering=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If ((AnyWindowOpen=10 || AnyWindowOpen=74) && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

dummySaveLumGammos() {
   INIaction(1, "GammosAdjust", "General")
   INIaction(1, "GammosGrayAdjust", "General")
   INIaction(1, "lumosAdjust", "General")
   INIaction(1, "lumosGrayAdjust", "General")
   INIaction(1, "imgFxMode", "General")
   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")
}

ChangeSaturation(dir) {
   Static prevValues
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer(0)
   If (imgFxMode=4)
      satAdjust := 0

   imgFxMode := 2
   prevColorAdjustZeit := A_TickCount
   value2Adjust := satAdjust
   If (dir=1)
      value2Adjust += 0.05
   Else
      value2Adjust -= 0.05

   value2Adjust := clampInRange(value2Adjust, 0, 3)
   satAdjust := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image saturation: " Round(value2Adjust*100) "%", A_ThisFunc, 2, value2Adjust/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" satAdjust imgFxMode currentFileIndex
   If (prevValues=newValues)
      Return

   INIaction(1, "satAdjust", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)
   If ((AnyWindowOpen=10 || AnyWindowOpen=74) && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

ChangeRealGamma(dir) {
   Static prevValues
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer(0)
   prevColorAdjustZeit := A_TickCount
   imgFxMode := 2
   value2Adjust := realGammos
   If (value2Adjust>2)
      stepu := 0.2
   Else If (value2Adjust<0.1)
      stepu := 0.01
   Else
      stepu := 0.05

   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   value2Adjust := clampInRange(value2Adjust, 0.01, 10)
   realGammos := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image gamma: " Round(value2Adjust*100) "%", A_ThisFunc, 2, value2Adjust/8)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" realGammos imgFxMode
   If (prevValues=newValues)
      Return

   INIaction(1, "realGammos", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)

   If ((AnyWindowOpen=10 || AnyWindowOpen=74) && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

ChangeVolume(dir) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (thumbsDisplaying=1)
      Return

   resetSlideshowTimer(0, 1)
   value2Adjust := mediaSNDvolume
   If (dir=1)
      value2Adjust += 5
   Else
      value2Adjust -= 5

   value2Adjust := clampInRange(value2Adjust, 1, 100)
   If (hSNDmedia && hSNDmediaFile)
   {
      zPlitPath(hSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      milisec := MCI_Length(hSNDmedia)
      hSNDmediaDuration := MCI_ToHHMMSS(milisec)
      infoMedia := "`nAudio annotation playing:`n" OutFileName " ( " hSNDmediaDuration " )"
   }

   If (hSNDsong && StrLen(SlidesMusicSong)>3)
   {
      zPlitPath(SlidesMusicSong, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      milisec := MCI_Length(hSNDsong)
      lenghtu := MCI_ToHHMMSS(milisec)
      infoMedia .= "`nBackground slideshow music playing:`n" OutFileName " ( " lenghtu " )"
   }

   If !infoMedia
      infoMedia := "`nNo audio is playing through QPV"

   mediaSNDvolume := value2Adjust
   INIaction(1, "mediaSNDvolume", "General")
   SetVolume(mediaSNDvolume)
   showTOOLtip("Audio volume: " value2Adjust "%" infoMedia, A_ThisFunc, 2, value2Adjust/100)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

changeGIFsDelayu(dir) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (thumbsDisplaying=1 || !isImgEditingNow() || animGIFsSupport!=1)
      Return

   resetSlideshowTimer(0, 1)
   value2Adjust := UserGIFsDelayu
   If (dir=1)
      value2Adjust += 15
   Else
      value2Adjust -= 15

   value2Adjust := clampInRange(value2Adjust, -300, 300, 1)
   UserGIFsDelayu := value2Adjust
   setGIFframesDelay()
   INIaction(1, "UserGIFsDelayu", "General")
   showTOOLtip("GIFs playback delay: " value2Adjust " ms", A_ThisFunc, 2, (value2Adjust+300)/600)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

changeTlbrSelRotation(dir) {
   changeSelRotation(dir, 15)
}

changeSelRotation(dir, stepu:=1) {
   If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
      Return

   value2Adjust := VPselRotation
   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   value2Adjust := clampInRange(value2Adjust, 0, 360 - 1, 1)
   VPselRotation := value2Adjust
   dummyRefreshImgSelectionWindow()
   userFriendlyPrevImgSelAction := (dir=1) ? "SELECTION ROTATION +" stepu "°" : "SELECTION ROTATION -" stepu "°"
   dummyShowSelCoordsInfos()
}

isImgSizeTooLarge(imgW, imgH) {
   r := (imgW*imgH>maxGDIbmpSize) || (imgW>32500) || (imgH>32500) ? 1 : 0
   Return r
}

changeLittleImgRotationInVP(dir) {
   changeImgRotationInVP(dir, 1)
}

changeImgRotationInVP(dir, stepu:=15, doReset:=0) {
   If (thumbsDisplaying=1 || liveDrawingBrushTool=1)
      Return

   whichBitmap := useGdiBitmap()
   If StrLen(whichBitmap)>3
   {
      Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
      Gdip_GetRotatedDimensions(imgW, imgH, 45, ResizedW, ResizedH)
      If (isImgSizeTooLarge(ResizedW, ResizedH) && vpIMGrotation=0)
      {
         vpIMGrotation := 0
         SoundBeep, 300, 100
         showTOOLtip("ERROR: The document dimensions exceed the maximum limits`nThe image cannot be rotated.")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   } Else Return

   resetSlideshowTimer(0)
   value2Adjust := vpIMGrotation
   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   If (doReset=1)
      value2Adjust := 0
   Else
      value2Adjust := clampInRange(value2Adjust, 0, 360 - stepu, 1)
   vpIMGrotation := value2Adjust
   dummyChangeVProtation()
   SetTimer, RefreshImageFile, -750
}

dummyChangeVProtation() {
   showTOOLtip("Image rotation: " vpIMGrotation "° ", "changeImgRotationInVP", 2, vpIMGrotation/360)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "vpIMGrotation", "General")
   GdipCleanMain(4)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, vpIMGrotation, % vpIMGrotation
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

nextDesiredFrame() {
    changeDesiredFrame(1)
}

prevDesiredFrame() {
    changeDesiredFrame(-1)
}

changeDesiredFrame(dir:=1) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 || !totalFramesIndex)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If askAboutFileSave(" and the current image frame will be changed")
      Return

   DestroyGIFuWin()
   resetSlideshowTimer(0)
   value2Adjust := desiredFrameIndex
   If (dir=1)
      value2Adjust++
   Else
      value2Adjust--

   If (dir=-1 && value2Adjust<1)
      value2Adjust := 0

   value2Adjust := clampInRange(value2Adjust, 0, totalFramesIndex, 1)
   desiredFrameIndex := value2Adjust
   If (A_TickCount - lastInvoked > 350) || (dir=-1 || drawModeCzeit>450)
   {
      infoShowCurrentFrameIndex()
      lastInvoked := A_TickCount
   } Else SetTimer, infoShowCurrentFrameIndex, -400

   newValues := "a" value2Adjust currentFileIndex totalFramesIndex
   If (prevValues!=newValues)
   {
      ; ToolTip, % drawModeCzeit "==" drawModeAzeit "==" drawModeBzeit , , , 2
      If (drawModeAzeit>450)
         SetTimer, RefreshImageFile, -450
      Else
         SetTimer, RefreshImageFile, % (dir=-1) ? -95 : -5
      prevValues := newValues
   }
}

DestroyGIFuWin() {
    Critical, on
    If (slideShowRunning=1 || animGIFplaying=1)
       SetTimer, ResetImgLoadStatus, -15

    interfaceThread.ahkassign("animGIFplaying", 0)
    SetTimer, autoChangeDesiredFrame, Off
    autoChangeDesiredFrame("stop")
}

restartGIFplayback() {
   If (CountGIFframes>1 && !AnyWindowOpen && animGIFsSupport=1, totalFramesIndex>1 && thumbsDisplaying!=1)
   {
      autoChangeDesiredFrame("stop", 0)
      Sleep, 5
      setGIFframesDelay()
      autoChangeDesiredFrame("start", getIDimage(currentFileIndex))
      SetTimer, autoChangeDesiredFrame, % GIFspeedDelay
   }
}

autoChangeDesiredFrame(act:=0, imgPath:=0) {
   Critical, on
   Static prevImgPath, lastInvoked := 1, lastFrameChange := 1
   If (thumbsDisplaying=1 || act="stop" || AnyWindowOpen || animGIFsSupport!=1 || !maxFilesIndex || !CurrentSLD)
   {
      If (animGIFplaying=1)
      {
         SetTimer, autoChangeDesiredFrame, Off
         SetTimer, ResetImgLoadStatus, -50
         prevAnimGIFwas := prevImgPath
         prevImgPath := ""
         Global lastGIFdestroy := A_TickCount
         lastFrameChange := A_TickCount
         animGIFplaying := 0
         ; lastInvoked := A_TickCount
         interfaceThread.ahkassign("animGIFplaying", 0)
         ResetImgLoadStatus()
         ; dummyTimerDelayiedImageDisplay(50)
      }
      Return
   }

   If (prevImgPath!=imgPath && StrLen(imgPath)>2)
      lastInvoked := A_TickCount

   If (act="start" && imgPath && prevImgPath!=imgPath)
   {
      SetTimer, ResetImgLoadStatus, -15
      lastFrameChange := A_TickCount
      prevImgPath := imgPath
      allowNextSlide := 0
      animGIFplaying := 1
      interfaceThread.ahkassign("animGIFplaying", 1)
      interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
      Return
   } Else
   {
      Sleep, -1
      animGIFplaying := interfaceThread.ahkgetvar.animGIFplaying
      ; mustHalt := interfaceThread.ahkgetvar.mustProcessKeys
      If (animGIFplaying<=0)
      {
         SetTimer, ResetImgLoadStatus, -10
         SetTimer, autoChangeDesiredFrame, Off
         animGIFplaying := 0
         allowNextSlide := 1
         interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
         prevImgPath := ""
         If (animGIFplaying=0)
         {
            interfaceThread.ahkassign("animGIFplaying", 0)
            prevAnimGIFwas := prevImgPath
            lastFrameChange := A_TickCount
            Global lastGIFdestroy := A_TickCount
         }
         Return
      }
   }

   allowNextSlide := 0
   desiredFrameIndex++
   GIFframesPlayied++
   If (allowGIFsPlayEntirely=1 && GIFframesPlayied>totalFramesIndex-1) || (totalFramesIndex<3) || (allowGIFsPlayEntirely!=1)
      allowNextSlide := 1
   ; ToolTip, % allowGIFsPlayEntirely "--" allowNextSlide , , , 2
   prevAnimGIFwas := ""
   desiredFrameIndex := clampInRange(desiredFrameIndex, 0, totalFramesIndex, 1)
   totalZeit := A_TickCount - startZeitIMGload
   thisFrameDelay := (totalZeit>25 && totalFramesIndex>20) ? GIFspeedDelay//2 : GIFspeedDelay
   If (totalZeit>70 && totalFramesIndex>15) || (totalZeit>25 && totalFramesIndex>180)
      thisFrameDelay := 10
   If (thisFrameDelay<12 && totalZeit<40 && totalFramesIndex<14)
      thisFrameDelay := 11
   If (totalZeit>100 && totalFramesIndex>95)
      thisFrameDelay := 1

   If (thumbsDisplaying=1 || liveDrawingBrushTool=1 || drawingShapeNow=1)
      allowNextSlide := 0

   If (slideShowRunning=1 && (A_TickCount - lastInvoked>slideShowDelay + 1) && allowNextSlide=1)
   {
      ; allowNextSlide := 0
      lastInvoked := A_TickCount
      prevImgPath := ""
      interfaceThread.ahkPostFunction("theSlideShowCore", "force")
      ; theSlideShowCore()
      invokeExternalSlideshowHandler()
   } Else If (A_TickCount - lastFrameChange > thisFrameDelay)
   {
      lastFrameChange := A_TickCount
      SetTimer, RefreshImageFile, -1
   }
   interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
}

infoShowCurrentFrameIndex() {
    showTOOLtip("Image frame index: " desiredFrameIndex " / " totalFramesIndex, "changeDesiredFrame", 2, desiredFrameIndex/totalFramesIndex)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

VPflipImgV() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   ForceRefreshNowThumbsList()
   FlipImgV := !FlipImgV
   friendly := (FlipImgV=1) ? "ON" : "off"
   showTOOLtip("Vertical mirroring: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgV", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgV, % FlipImgV
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

setMainCanvasTransform(W, H, G:=0, forceH:=0, forceV:=0) {
    If (thumbsDisplaying=1)
       Return

    If !G
       G := glPG

    If (FlipImgH=1 && forceH=0) || (forceH=1)
    {
       Gdip_ScaleWorldTransform(G, -1, 1)
       Gdip_TranslateWorldTransform(G, -W, 0)
    }

    If (FlipImgV=1 && forceV=0) || (forceV=1)
    {
       Gdip_ScaleWorldTransform(G, 1, -1)
       Gdip_TranslateWorldTransform(G, 0, -H)
    }
}

VPflipImgH() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   ForceRefreshNowThumbsList()
   FlipImgH := !FlipImgH
   friendly := (FlipImgH=1) ? "ON" : "off"
   showTOOLtip("Horizontal mirroring: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgH", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgH, % FlipImgH
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

doOpenStartFolder(ByRef didSomething:=0) {
   didSomething := 0
   If StrLen(mustOpenStartFolder)>3
   {
      startIndex := currentFileIndex ? currentFileIndex : 1
      If askAboutFileSave(" and files found in " mustOpenStartFolder "\ will be indexed")
         Return currentFileIndex
 
      didSomething := "yes"
      SLDtypeLoaded := 1
      imgPath := getIDimage(currentFileIndex)
      coreOpenFolder("|" mustOpenStartFolder, 0)
      If FileRexists(imgPath)
         startIndex := detectFileID(imgPath)
      Else
         startIndex := clampInRange(startIndex, 1, maxFilesIndex)
      SetTimer, TriggerMenuBarUpdate, -90
      SetTimer, createGUItoolbar, -110
   } Else
   {
      startIndex := currentFileIndex ? currentFileIndex : 1
   }
   Return startIndex
}

coreNextPrevImage(direction, startIndex, randomMode) {
   Static countSeen, prevStatus
   If (thumbsDisplaying!=1 && maxFilesIndex>1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return currentFileIndex
   }

   If StrLen(mustOpenStartFolder)>3
   {
      startIndex := doOpenStartFolder()
      currentFileIndex := startIndex
      ; Return currentFileIndex
   }

   thisState := "a" maxFilesIndex CurrentSLD SLDtypeLoaded
   If (thisState!=prevStatus || countSeen>maxFilesIndex)
      countSeen := 0

   prevStatus := thisState
   If (startIndex>=maxFilesIndex && direction=1 && thumbsDisplaying=1 && randomMode!=1)
      Return maxFilesIndex
   Else If (startIndex<2 && direction=-1 && thumbsDisplaying=1 && randomMode!=1)
      Return 1

   startZeit := A_TickCount
   If (startIndex=1 && direction=-1)
      startIndex := maxFilesIndex + 1
   Else If (startIndex=maxFilesIndex && direction=1)
      startIndex := 0

   delayu := (slideShowDelay>3500) ? Round(slideShowDelay*0.25) : Round(slideShowDelay*0.5)
   ; canResetSeen := 0
   Loop, % maxFilesIndex + 1
   {
        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        If (thisIndex>maxFilesIndex)
           thisIndex -= maxFilesIndex
        Else If (thisIndex<1)
           thisIndex := startIndex + Abs(thisIndex)

        newIndex := thisIndex
        If (randomMode=1)
        {
           z := RandyIMGids[thisIndex]
           r := getIDimage(z)
        } Else r := getIDimage(thisIndex)
        If !r
           Continue

        If (A_TickCount - startZeit>delayu)
           Break

        r := StrReplace(r, "||")
        If (mustRecordSeenImgs=1 && skipSeenImageSlides=1 && slideShowRunning=1 && allImagesWereSeen!=1)
        {
           If retrieveSeenImageDBentry(r, thisIndex)
           {
              countSeen++
              Continue
           }
        }

        ignoreFileCheck := (InStr(AprevImgCall, r) || InStr(BprevImgCall, r)) ? 1 : 0
        If (skipDeadFiles=1 && thumbsDisplaying!=1 && ignoreFileCheck!=1)
        {
           If !FileRexists(r)
              Continue
           Else
              Break
        } Else Break
   }

   ; ToolTip, % thisIndex "==" countSeen "==" delayu , , , 2
   If newIndex
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)

   If (countSeen >= maxFilesIndex - 1) || (!newIndex) ; || (allImagesWereSeen=1)
   {
      allImagesWereSeen := 1
      newIndex := (direction=-1) ? startIndex - 1 : startIndex + 1
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)
   }

   If (randomMode=1)
   {
      RandyIMGnow := newIndex
      newIndex := RandyIMGids[RandyIMGnow]
      if (newIndex>maxFilesIndex)
      {
         Random, thisIndex, 1, % maxFilesIndex
         RandyIMGids[RandyIMGnow] := thisIndex
         newIndex := thisIndex
      }
   }
   If (!newIndex && startIndex)
      Return startIndex

   Return newIndex
}

PreviousPicture(dummy:=0, inLoop:=0, selForbidden:=0) {
   If (StrLen(UserMemBMP)>2 && editingSelectionNow=1 && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && thumbsDisplaying!=1 && slideShowRunning!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(-1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Left", "+Left", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

NextPicture(dummy:=0, inLoop:=0, selForbidden:=0) {
   If (StrLen(UserMemBMP)>2 && editingSelectionNow=1 && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && slideShowRunning!=1 && thumbsDisplaying!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Right", "+Right", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

Fnt_GetMultilineStringSizeDT(hFont, p_String, NoWrap, l_Width, ByRef r_Width, ByRef r_Height) {
    Static Dummy64026703
          ,DEFAULT_GUI_FONT:=17
          ,HWND_DESKTOP    :=0
          ,OBJ_FONT        :=6
          ,SIZE

          ;-- DrawText format
          ,DT_NOCLIP:=0x100
                ;-- Draws without clipping.  DrawText is somewhat faster when
                ;   DT_NOCLIP is used.

          ,DT_CALCRECT:=0x400
                ;-- Determines the width and height of the rectangle.  The text
                ;   is not drawn.

          ,DT_NOPREFIX:=0x800
                ;-- Turns off processing of prefix characters.

          ,DT_WORDBREAK:=0x10

    If (NoWrap=1)
       s_DTFormat:=DT_NOCLIP|DT_CALCRECT|DT_NOPREFIX
    Else
       s_DTFormat:=DT_NOCLIP|DT_CALCRECT|DT_NOPREFIX|DT_WORDBREAK

    r_Width := r_Height := 0
    ;-- If needed, get the handle to the default GUI font
    if (Gdi_GetObjectType(hFont)!="FONT")
       hFont := Gdi_GetStockObject(DEFAULT_GUI_FONT)

    ;-- Select the font into the device context for the desktop
    hDC      := Gdi_GetDC(HWND_DESKTOP)
    old_hFont:= Gdi_SelectObject(hDC, hFont)
    If !l_Width
       l_Width := 0

    ;-- Calculate the size of the string
    VarSetCapacity(RECT, 16, 0)
    NumPut(l_Width,RECT,8,"Int")                       ;-- right
    ; Gdi_SetTextCharSpacing(hDC, TextInAreaCharSpacing)
    E := DllCall("DrawText"
        ,"Ptr",hDC                                      ;-- hdc [in]
        ,"Str",p_String                                 ;-- lpchText [in, out]
        ,"Int",StrLen(p_String)                         ;-- cchText [in]
        ,"Ptr",&RECT                                    ;-- lprc [in, out]
        ,"UInt",s_DTFormat)                             ;-- uFormat [in]

    ;-- Release the objects needed by the DrawText function
    Gdi_SelectObject(hDC, old_hFont)
        ;-- Necessary to avoid memory leak

    Gdi_ReleaseDC(hDC, HWND_DESKTOP)
    r_Width := NumGet(RECT,8,"Int")
    r_Height := NumGet(RECT,12,"Int")
    Return E
}

drawInPlaceTextInBox(Gu, theString, txtOptions) {
    ; startZeit := A_TickCount
    ; pBr0 := Gdip_BrushCreateSolid(bgrColor)
    ; ToolTip, % mainObju.hfnt "`n" mainObju.hStrFmt "`n" mainObju.hBrush , , , 2

    ;  TextuToGraphics(Gu, theString, nul, txtOptions.fontu, "measure", 0, mainObju)
   Return TextuToGraphics(Gu, theString, txtOptions, txtOptions.fontu, "draw2", 0, mainObju)
    ; ToolTip, % dims.w "--" dims.h "--" _E , , , 2
    ; fnOutputDebug("draw text in box: " A_TickCount - startZeit " ms")
}

drawTextInBox(theString, fntName, theFntSize, maxW, maxH, txtColor, bgrColor, NoWrap, flippable:=0, thisTextAlign:=0, BGRopacity:="0xDD", borderu:=0) {
    startZeit := A_TickCount
    ; pBr0 := Gdip_BrushCreateSolid(bgrColor)
    If (OSDfontBolded=1)
       txtStyle .= " Bold"
    If (OSDfontItalica=1 && NoWrap=0)
       txtStyle .= " Italic"

    If !thisTextAlign
       thisTextAlign := (flippable=1 && FlipImgH=1) ? "Right" : "Left"
    Else
       thisTextAlign := Trimmer(thisTextAlign)

    borderSize := (NoWrap=1) ? Floor(theFntSize*1.2) : Floor(theFntSize*1.5)
    borderSize := borderu ? borderu : borderSize//3
    txtOptions := []
    txtOptions.x := borderSize
    txtOptions.y := borderSize
    txtOptions.w := maxW - borderSize*2
    txtOptions.h := maxH - borderSize*2
    txtOptions.Styles := txtStyle
    txtOptions.Align := thisTextAlign
    txtOptions.Color := "0xEE" txtColor
    txtOptions.Size := theFntSize
    mainObju := TextuToGraphics(G, "initing", txtOptions, fntName, "begin", 0, 0, NoWrap)
    ; ToolTip, % mainObju.hfnt "`n" mainObju.hStrFmt "`n" mainObju.hBrush , , , 2

    dims := TextuToGraphics(2NDglPG, theString, nul, fntName, "measure", 0, mainObju)
    dimsFw := clampInRange(dims.w + borderSize*2, 5, maxW)
    dimsFh := clampInRange(dims.h + borderSize*2, 5, maxH)

    clipBMPa := trGdip_CreateBitmap(A_ThisFunc, dimsFw, dimsFh, coreDesiredPixFmt)
    If clipBMPa
       G := trGdip_GraphicsFromImage(A_ThisFunc, clipBMPa, 5, 1)

    If (!G || !clipBMPa)
    {
       trGdip_DisposeImage(clipBMPa, 1)
       Return
    }

    fontQuality := (theFntSize>90) ? 2 : 3
    If (theFntSize<20)
       fontQuality := 4

    Gdip_SetTextRenderingHint(G, fontQuality)
    trGdip_GraphicsClear(A_ThisFunc, G, BGRopacity bgrColor)
    ; Gdip_FillRectangle(G, pBr0, -2, -2, dimsFw + 3, dimsFh + 3)
    _E := TextuToGraphics(G, theString, txtOptions, fntName, "draw", 0, mainObju)
    ; ToolTip, % dims.w "--" dims.h "--" _E , , , 2
    If (flippable=1)
       flipBitmapAccordingToViewPort(clipBMPa, 1)

    Gdip_DeleteGraphics(G)
    ; fnOutputDebug("draw text in box: " A_TickCount - startZeit " ms")
    Return clipBMPa
}

TextuToGraphics(pGraphics, Text, OptionsObj, Font:="Arial", initMode:=0, Unit:=0, inObj:=0, NoWrap:=0) {

   Static Styles := "Regular|Bold|Italic|BoldItalic|Underline|Strikeout"
        , Alignments := "Near|Left|Centre|Center|Far|Right"
        , prevfontFam, hFontFamily, prevFontu, hFont, prevColor, pBrushu
        , prevFmtStyle, hStringFormat

   If (initMode="begin")
   {
      xpos := OptionsObj.x,  ypos := OptionsObj.y
      Width := OptionsObj.w, Height := OptionsObj.h
      Size := OptionsObj.Size

      If (prevfontFam!=Font || !hFontFamily)
      {
         If hFontFamily
         {
            Gdip_DeleteFontFamily(hFontFamily)
            hFontFamily := ""
         }

         prevfontFam := Font
         hFontFamily := Gdip_FontFamilyCreate(Font)
         If !hFontFamily
            hFontFamily := Gdip_FontFamilyCreateGeneric(1)
      }

      thisFontu := "a" hFontFamily Font OptionsObj.Styles Size Unit
      If (thisFontu!=prevFontu || !hFont)
      {
         If hFont
         {
            Gdip_DeleteFont(hFont)
            hFont := ""
         }

         Styleu := 0
         For eachStyle, valStyle in StrSplit(Styles, "|")
         {
            If RegExMatch(OptionsObj.Styles, "\b" valStyle)
               Styleu |= (valStyle != "StrikeOut") ? (A_Index - 1) : 8
         }

         ; ToolTip, % options "`n" size " == " colour , , , 2
         hFont := Gdip_FontCreate(hFontFamily, Size, Styleu, Unit)
         If hFont
            prevFontu := thisFontu
      }

      thisFmtStyle := "a" NoWrap OptionsObj.Align
      If (thisFmtStyle!=prevFmtStyle || !hStringFormat)
      {
         If hStringFormat
         {
            Gdip_DeleteStringFormat(hStringFormat)
            hStringFormat := ""
         }

         FormatStyle := (NoWrap=1) ? 0x4000 | 0x1000 : 0x4000
         hStringFormat := Gdip_StringFormatCreate(FormatStyle)
         If !hStringFormat
            hStringFormat := Gdip_StringFormatGetGeneric(1)

         If hStringFormat
         {
            Align := 0
            prevFmtStyle := thisFmtStyle
            For eachAlignment, valAlignment in StrSplit(Alignments, "|")
            {
               If RegExMatch(OptionsObj.Align, "\b" valAlignment)
                  Align |= A_Index//2.1   ; 0|0|1|1|2|2
            }

            Gdip_SetStringFormatAlign(hStringFormat, Align)
            If InStr(OptionsObj.Styles, "autotrim")
               Gdip_SetStringFormatTrimming(hStringFormat, 3)
         }
      }

      If (OptionsObj.Color!=prevColor || !pBrushu)
      {
         pBrushu := Gdip_BrushCreateSolid(OptionsObj.Color)
         If pBrushu
            prevColor := OptionsObj.Color
      }

      If !(hFontFamily && hFont && hStringFormat && pBrushu)
      {
         E := !pGraphics ? -2 : !hFontFamily ? -3 : !hFont ? -4 : !hStringFormat ? -5 : !pBrushu ? -6 : 0
         If pBrushu
         {
            Gdip_DeleteBrush(pBrushu)
            pBrushu := ""
         }

         If hStringFormat
         {
            Gdip_DeleteStringFormat(hStringFormat)
            hStringFormat := ""
         }

         If hFont
         {
            Gdip_DeleteFont(hFont)
            hFont := ""
         }

         If hFontFamily
         {
            Gdip_DeleteFontFamily(hFontFamily)
            hFontFamily := ""
         }
         return E
      }


      obju := []
      obju.x := xpos,  obju.y := ypos
      obju.w := width, obju.h := height
      ; ToolTip, % hfont "`n" hStringFormat "`n" pBrush , , , 2
      Return obju
   }

   If (initMode="measure")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ; TOOLTIP, % inObj.x "--" inObj.y "--" inObj.w "--" inObj.h , , , 2
      ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
      val := StrSplit(ReturnRC, "|")
      measure := []
      measure.x := Floor(val[1]), measure.y := Floor(val[2])
      measure.w := Ceil(val[3]), measure.h := Ceil(val[4])
      Return measure
   }

   If (initMode="draw")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
      ReturnRCtest := StrSplit(ReturnRC, "|")
      testX := Floor(ReturnRCtest[1]) - 2
      If (testX>xpos) ; error correction for different text alignments
      {
         nxpos := Floor(inObj.x - (testX - inObj.x))
         CreateRectF(RC, nxpos, inObj.y, inObj.w, inObj.h)
         ; ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
         ; MsgBox, % nxpos "--" xpos "--" ypos "`n" width "--" height "`n" ReturnRC
      }

      _E := Gdip_DrawString(pGraphics, Text, hFont, hStringFormat, pBrushu, RC)
      Return _E
   } Else if (initMode="draw2")
   {
      CreateRectF(RC, OptionsObj.x, OptionsObj.y, OptionsObj.w, OptionsObj.h)
      ; Gdip_SetClipRect(pGraphics, OptionsObj.x, OptionsObj.y, OptionsObj.w, OptionsObj.h)
      _E := Gdip_DrawString(pGraphics, Text, hFont, hStringFormat, pBrushu, RC)
      Return _E
   }

   return _E ? _E : ReturnRC
}

HardWrapTextFontBased(TextToWrap, hFont, maxW, maxH, lineHeight) {
   ; Critical, on
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
        , maxCharsInWidth := 2048

   if (StrLen(TextToWrap)<=2)
      return TextToWrap

   TextToWrap := Trimmer(TextToWrap)
   thisIndex := thisH := linez := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   hDC := Gdi_GetDC()
   old_hFont := Gdi_SelectObject(hDC, hFont)
   maxLinez := Round(maxH/lineHeight) - 1
   thisCharSpacing := (TextInAreaCharSpacing>0) ? TextInAreaCharSpacing : 0
   Loop, Parse, TextToWrap
   {
       If (maxLinez<linez && linez>1)
          Break

       thisIndex++
       thisLineu .= A_LoopField
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
       {
          linez++
          thisLineu := ""
          thisIndex := hasMatchedRegEx := 0
          Continue
       }

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
          whereHasMatchedinLine := thisIndex
       }

       ; thisObj := Gdi_TruncateStringToFitWidth(hFont, A_Space thisLineu A_Space, maxW - TextInAreaCharSpacing * (StrLen(thisLineu) + 1))
       E := Gdi_GetTextExtentExPoint(hDC, A_Space thisLineu A_Space, maxW - thisCharSpacing * (StrLen(thisLineu) + 1), fitLength, w, h)
       ; ToolTip, % thisObj.fitLength "==" thisObj.width "==" thisObj.height "==" thisObj.stringLength "`n" thisLineu, , , 2
       stringLength := StrLen(thisLineu) + 1
       If (hasMatchedRegEx=1 && (stringLength>fitLength || stringLength>maxCharsInWidth))
       {
          linez++
          offsetu++
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          hasMatchedRegEx := 0
          If (thisLineu=A_Space)
             thisLineu := ""
          thisLineu := SubStr(thisLineu, whereHasMatchedinLine)
          thisIndex := StrLen(thisLineu)
       } Else If (stringLength>fitLength || stringLength>maxCharsInWidth)
       {
          linez++
          thisLineu := ""
          newLinez .= "`n"
          thisIndex := hasMatchedRegEx := 0
       }
   }
   w := Gdi_SelectObject(hDC, old_hFont)
   g := Gdi_ReleaseDC(hDC, 0)
   ; ToolTip, % w "|" g "." foundPos "==" startPos, , , 2
   return newLinez
}

SimpleHardWrapText(TextToWrap, LengthLim) {
; function no longer used
; superseded by HardWrapTextFontBased()
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
   LengthLim := Round(LengthLim)
   if (LengthLim<2)
      return TextToWrap
   if (StrLen(TextToWrap) <= LengthLim + 1)
      return TextToWrap

   thisIndex := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   
   Loop, Parse, TextToWrap
   {
       thisIndex++
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
          thisIndex := hasMatchedRegEx := 0

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
       }

       If (thisIndex=LengthLim && hasMatchedRegEx=1)
       {
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          offsetu++
          thisIndex := hasMatchedRegEx := 0
       } Else If (thisIndex=LengthLim)
       {
          newLinez .= "`n"
          thisIndex := hasMatchedRegEx := 0
       }
   }

   ; ToolTip, % foundPos "==" startPos, , , 2
   return newLinez
}

Gdi_DrawTextInBox(theString, hFont, maxW, maxH, txtColor, bgrColor, borderSize:=0, NoWrap:=1, scaleuPreview:=1, doFlipH:=0, doFlipV:=0) {
    startZeit := A_TickCount
    ; dimsu := otherGetStringSize(fntName, theFntSize, 0, theString, NoWrap, maxW)
    ; ToolTip, % dimsu.w "--" dimsu.h " == " NoWrap "`n" theString , , , 2
    thisCharSpacing := Round(TextInAreaCharSpacing / scaleuPreview)
    Gdi_MeasureString(hFont, theString, 1, oW, oH)
    ; Fnt_GetMultilineStringSizeDT(hFont, theString, 1, 0, oW, oH)
    reAdjustWtxtspacing := (Abs(thisCharSpacing)//2) * StrLen(theString)
    reAdjustWtxtspacing := clampInRange(reAdjustWtxtspacing, 1, oW - 5)
    If (thisCharSpacing<0)
       oW := oW - reAdjustWtxtspacing
    Else
       oW := oW + thisCharSpacing * StrLen(theString)

    ; ToolTip, % oW "==" oH "==" reAdjustWtxtspacing , , , 2
    Gdip_GetRotatedDimensions(oW, oH, TextInAreaLineAngle/10, rWidth, rHeight)
    scaleu := Abs(TextInAreaLineAngle/900)
    scaleu2 := Abs((TextInAreaLineAngle*scaleu)/900)
    r_Width := rWidth + borderSize*2
    r_Height := rHeight + borderSize*2
    offsetY := (TextInAreaLineAngle<0) ? r_Width//2 - rWidth//2 : r_Height//2 - rHeight//2 + clampInRange(Floor(rHeight*(scaleu*1.9)), - rHeight*5, rHeight)
    offsetX := (TextInAreaLineAngle<0) ? r_Height//2 - rHeight//2 + Floor(rWidth*scaleu2)  : r_Width//2 - rWidth//2
    If (offsetY<(rHeight - oH + borderSize) && TextInAreaLineAngle>0)
       offsetY := Abs(rHeight - oH + borderSize)

    If (offsetX<borderSize)
       offsetX := borderSize

    If (TextInAreaOnlyBorder!=1 || TextInAreaBorderOut=1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDc, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), "0x" rgb2bgr(bgrColor))
       pBitmap := trGdip_CreateBitmapFromHBITMAP(hbm)
       Gdi_SelectObject(hDc, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hdc)
    }

    If (TextInAreaBorderSize>0 && TextInAreaBorderOut>1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDC, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextOutline(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), Round(TextInAreaBorderSize/scaleuPreview))
       If (TextInAreaBorderOut=3)
          Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x000000")
       pBitmap2 := trGdip_CreateBitmapFromHBITMAP(hbm)
       Gdi_SelectObject(hDC, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hDC)
    }
    If (StrLen(pBitmap)>2 && doFlipH=1)
       Gdip_ImageRotateFlip(pBitmap, 4)

    If (StrLen(pBitmap2)>2 && doFlipH=1)
       Gdip_ImageRotateFlip(pBitmap2, 4)

    If (StrLen(pBitmap)>2 && doFlipV=1)
       Gdip_ImageRotateFlip(pBitmap, 6)

    If (StrLen(pBitmap2)>2 && doFlipV=1)
       Gdip_ImageRotateFlip(pBitmap2, 6)

    ; Gdip_GetImageDimensions(pBitmap, imgW, imgH)
     ; ToolTip, % r_width "=" r_height "`n" hbm "==" hdc "==" obm "`n" imgW "==" imgH, , , 2
    ; fnOutputDebug("draw text in box with GDI: " A_TickCount - startZeit " ms")
    Return [pBitmap, pBitmap2, r_Width, r_Height]
}

coreInsertTextInAreaBox(theString, maxW, maxH, previewMode) {
    Static OBJ_FONT := 6, testString := "This is going to a test", klop := 0
         , leetSpeakDict := {"A":"4", "B":"8", "C":"¢", "D":"Ð", "E":"3", "F":"F", "G":"6", "H":"#", "I":"1", "J":"J", "K":"K", "L":"£", "M":"M", "N":"Π", "O":"0", "P":"P", "Q":"Q", "R":"Я", "S":"5", "T":"7", "U":"µ", "V":"W", "W":"V", "X":"χ", "Y":"¥", "Z":"2", "1":"I", "2":"Z", "3":"E", "4":"A", "5":"S", "6":"G", "7":"T", "8":"B", "9":"9", "0":"O", "?":"¿", "!":"¡"}

    If (TextInAreaCaseTransform=2)
       StringUpper, theString, % theString
    Else If (TextInAreaCaseTransform=3)
       StringLower, theString, % theString
    Else If (TextInAreaCaseTransform=4)
       StringUpper, theString, % theString, T
    Else If (TextInAreaCaseTransform=5)
    {
       For Key, Value in leetSpeakDict
          theString := StrReplace(theString, key, value)
    }

    Gdip_FromARGB("0xFF" TextInAreaFontColor, A, R, G, B)
    txtColor := Gdip_ToARGB(TextInAreaFontOpacity, R, G, B)
    Gdip_FromARGB("0xFF" TextInAreaBgrColor, A, R, G, B)
    bgrColor := Gdip_ToARGB(TextInAreaBgrOpacity, R, G, B)
    Gdip_FromARGB("0xFF" TextInAreaBorderColor, A, R, G, B)
    borderColor := Gdip_ToARGB(TextInAreaBorderOpacity, R, G, B)

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    fntQuality := (previewMode=1) ? 1 : 4
    fntWeight := (TextInAreaFontBold=1) ? 800 : 400

    thisFactor := (zoomLevel<1) ? 1 - zoomLevel*2 + 1.25 : zoomLevel/2
    thisFactor += TextInAreaFontSize/80
    thisFactor := clampInRange(thisFactor, 1.3, 13)
    ; ToolTip, % "z=" thisFactor , , , 2

    thisLineAngle := (TextInAreaLineAngle<0) ? 3600 + TextInAreaLineAngle : TextInAreaLineAngle
    If !isNumber(thisLineAngle)
       thisLineAngle := 0

    hFontPreview := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize//thisFactor, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    hFont := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    If (Gdi_GetObjectType(hFont)!="FONT")
       Return "fail"

    thisBlurAmount := max(TextInAreaBlurAmount, TextInAreaBlurBorderAmount) // 2
    obs := borderSize := (TextInAreaUsrMarginz>0) ? TextInAreaUsrMarginz : TextInAreaBorderSize//2 + thisBlurAmount
    Gdi_MeasureString(hFont, testString, 1, testWa, testHa)
    Gdi_MeasureString(hFontPreview, testString, 1, testWb, testHb)
    theString := StrReplace(theString, "`n`n", "`n┘")
    If (TextInAreaAutoWrap=1)
       theString := Trimmer(HardWrapTextFontBased(theString, hFont, maxW - borderSize * 2, maxH + 2, clampInRange(testHa + TextInAreaFontLineSpacing, 2, maxH + 10)))
    Else
       theString := Trimmer(theString)

    scaleuPreview := (previewMode=1) ? testWa/testWb : 1
    If (previewMode=1)
       borderSize := Round(borderSize/scaleuPreview)

    scaleuBlrPreview := (previewMode=1) ? (borderSize*4 + testWb + testHb)/(obs*4 + testWa + testHa) : 1
    ; ToolTip, % thisFactor "==" scaleuPreview , , , 2
    ; ToolTip, % testWa "==" testHa "`n" testWb "==" testHb "`n" testWa/testWb , , , 2
    maxW := Round(maxW / scaleuPreview) ; + Round(5*TextInAreaFontSize*scaleuPreview)
    maxH := Round(maxH / scaleuPreview) ; + TextInAreaFontSize*2
    mainBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, coreDesiredPixFmt)
    If warnUserFatalBitmapError(mainBMP, A_ThisFunc)
       Return "fail"

    thisBlur := Round(TextInAreaBlurAmount * scaleuBlrPreview)
    If (thisBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
       pEffect := Gdip_CreateEffect(1, thisBlur, 0, 0)

    ; ToolTip, % thisBlur "`n" scaleuBlrPreview "`n" scaleuPreview , , , 2
    thisBorderBlur := Round(TextInAreaBlurBorderAmount * scaleuBlrPreview)
    If (thisBorderBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
       zEffect := Gdip_CreateEffect(1, thisBorderBlur, 0, 0)

    zBrush := Gdip_BrushCreateSolid(bgrColor)
    thisQuality := (previewMode=1) ? 5 : 7
    G := trGdip_GraphicsFromImage(A_ThisFunc, mainBMP, thisQuality)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G, 2)

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1 && pEffect)
    {
       o_txtColor := txtColor
       txtColor := "0xFFffFFff"
       trGdip_GraphicsClear(A_ThisFunc, G, "0xFF000000")
    }

    thisY := thisX := 0
    maxedW := maxedH := 0
    minedX := maxW, minedY := maxH
    doConturDraw := (TextInAreaBorderSize>0 && TextInAreaBorderOut>1) ? 1 : 0

    thisHFont := (previewMode=1) ? hFontPreview : hFont
    rescaleWidthCharSpacing := (TextInAreaCharSpacing<0) ? (100 - Abs(TextInAreaCharSpacing))/90 : 1
    threads := (previewMode=1) ? realSystemCores : 0
    Loop, Parse, theString, `n
    {
       If !Trimmer(A_LoopField)
          Continue

       thisuString := StrReplace(A_LoopField, "┘", " `n")
       objBMPs := Gdi_DrawTextInBox(thisuString, thisHFont, maxW, maxH, "FFffFF", "000000", borderSize, 1, scaleuPreview, TextInAreaFlipH, TextInAreaFlipV)
       imgW := objBMPs[3], imgH := objBMPs[4]
       pBitmap := (doConturDraw=1 && TextInAreaOnlyBorder=1 && objBMPs[2]) ? objBMPs[2] : objBMPs[1]
       If (doConturDraw=1 && objBMPs[1] && TextInAreaOnlyBorder=1)
          trGdip_DisposeImage(objBMPs[1])

       pBitmapContours := objBMPs[2]
       If (pEffect && (TextInAreaBgrUnified!=1 || TextInAreaPaintBgr!=1))
       {
          If (previewMode!=1 || userimgQuality=1)
             ApplySpecialFixedBlur(A_ThisFunc, pBitmap, thisBlur, pEffect)
          Else
             Gdip_BitmapApplyEffect(pBitmap, pEffect)
       }

       thisBMP := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
       If StrLen(thisBMP)<3
       {
          fattalErr := 1
          trGdip_DisposeImage(pBitmap, 1)
          Break
       }

       G2 := trGdip_GraphicsFromImage(A_ThisFunc, thisBMP)
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G2, 2)

       If (TextInAreaCutOutMode=1 && TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1)
       {
          ; trGdip_GraphicsClear(A_ThisFunc, G2)
          Gdip_FillRectangle(G2, zBrush, 0, 0, imgW, imgH)
          QPV_SetAlphaChannel(thisBMP, pBitmap, 1, 0, 1, threads)
          thisOpacity := 1 ; TextInAreaBgrOpacity/255
       } Else
       {
          thisColor := (TextInAreaOnlyBorder=1) ? borderColor : txtColor
          trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
          QPV_SetAlphaChannel(thisBMP, pBitmap, 0, 0, 1, threads)
          thisOpacity := 1
       }

       forceW := (imgW>=maxW) ? maxW : imgW
       thisXbonus := (imgW>maxW) ? imgW - maxW : 0
       If (rescaleWidthCharSpacing<1)
       {
          phorceW := Round(forceW*rescaleWidthCharSpacing)
          forceW -= (forceW - phorceW)//2.5
       }

       If (TextInAreaAlign=2)
          thisX := Round(maxW/2 - imgW/2 + thisXbonus/2)
       Else If (TextInAreaAlign=3)
          thisX := maxW - imgW + thisXbonus

       isOkay := (thisuString=" `n" && TextInAreaPaintBgr=1 && TextInAreaBgrEntire=0 && TextInAreaBgrUnified=0) ? 0 : 1
       If (TextInAreaBgrUnified!=1 && TextInAreaPaintBgr=1)
       {
          If (TextInAreaCutOutMode!=1 && isOkay=1)
             Gdip_FillRectangle(G, zBrush, thisX, thisY, imgW, imgH)

          If (TextInAreaBgrEntire=1)
          {
             Gdip_SetClipRect(G, 0, thisY, maxW, imgH)
             Gdip_SetClipRect(G, thisX, thisY, imgW, imgH, 4)
             Gdip_FillRectangle(G, zBrush, 0, thisY, maxW, imgH)
             Gdip_ResetClip(G)
          }
       }

       If (doConturDraw=1 && TextInAreaOnlyBorder!=1 && pBitmapContours)
       {
          If zEffect
          {
             If (previewMode!=1 || userimgQuality=1)
                ApplySpecialFixedBlur(A_ThisFunc, pBitmapContours, thisBorderBlur, zEffect)
             Else
                Gdip_BitmapApplyEffect(pBitmapContours, zEffect)
          }

          thizBMP := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
          G5 := trGdip_GraphicsFromImage(A_ThisFunc, thizBMP)
          If (userimgGammaCorrect=1)
             Gdip_SetCompositingQuality(G5, 2)

          trGdip_GraphicsClear(A_ThisFunc, G5, borderColor)
          QPV_SetAlphaChannel(thizBMP, pBitmapContours, 0, 0, 1, threads)
          trGdip_DrawImage(A_ThisFunc, G, thizBMP, thisX, thisY, forceW, imgH,,,,, thisOpacity)
          trGdip_DisposeImage(pBitmapContours, 1)
          trGdip_DisposeImage(thizBMP, 1)
          Gdip_DeleteGraphics(G5)
       }

       maxedW := max(forceW, maxedW)
       maxedH := max(thisY + imgH, maxedH)
       minedX := min(thisX, minedX)
       minedY := min(thisY, minedY)
       If isOkay
          drawFail := trGdip_DrawImage(A_ThisFunc, G, thisBMP, thisX, thisY, forceW, imgH,,,,, thisOpacity)

       If (previewMode=1)
          thisY += imgH + Round(TextInAreaFontLineSpacing / scaleuPreview)
       Else
          thisY += imgH + TextInAreaFontLineSpacing

       trGdip_DisposeImage(pBitmap, 1)
       trGdip_DisposeImage(thisBMP, 1)
       Gdip_DeleteGraphics(G2)
       If (drawFail="fail")
       {
          fattalErr := 1
          Break
       }
    }

    If (fattalErr=1)
       warnUserFatalBitmapError("no-gdip", A_ThisFunc)

    Gdi_DeleteObject(hFont)
    Gdi_DeleteObject(hFontPreview)
    minedX := clampInRange(minedX, 0, maxW)
    minedY := clampInRange(minedY, 0, maxH)
    maxedW := clampInRange(maxedW, 1, maxW)
    maxedH := clampInRange(maxedH, 1, maxH)
    ; ToolTip, % maxedW "==" maxedH " = " minedX "==" minedY , , , 2
    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
    {
       newBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, coreDesiredPixFmt)
       warnUserFatalBitmapError(newBMP, A_ThisFunc)
    }

    Gdip_DeleteGraphics(G)
    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1 && StrLen(newBMP)>2)
    {
       If pEffect
       {
          If (previewMode!=1 || userimgQuality=1)
             ApplySpecialFixedBlur(A_ThisFunc, mainBMP, thisBlur, pEffect)
          Else
             Gdip_BitmapApplyEffect(mainBMP, pEffect)

          fBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH)
          G7 := trGdip_GraphicsFromImage(A_ThisFunc, fBMP)
          trGdip_GraphicsClear(A_ThisFunc, G7, o_txtColor)
          Gdip_DeleteGraphics(G7)
          QPV_SetAlphaChannel(fBMP, mainBMP, 0, 0, 1, threads)
          trGdip_DisposeImage(mainBMP)
          mainBMP := fBMP
       }

       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBMP)
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G3, 2)

       If (TextInAreaRoundBoxBgr=1)
       {
          radius := Round(((maxedW + borderSize*2 + maxedH)//2.5)*0.1) + 1
          kPath := Gdip_CreatePath()
          Gdip_AddPathRoundedRectangle(kPath, minedX, minedY, maxedW, maxedH, radius)
          Gdip_SetClipPath(G3, kPath)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
          Gdip_DeletePath(kPath)
       } Else
       {
          Gdip_SetClipRect(G3, minedX, minedY, maxedW, maxedH)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
       }
       Gdip_ResetClip(G3)
       trGdip_DrawImage(A_ThisFunc, G3, mainBMP, 0, 0)
       ; QPV_SetAlphaChannel(newBMP, mainBMP, TextInAreaCutOutMode)
       trGdip_DisposeImage(mainBMP, 1)
       Gdip_DeleteGraphics(G3)
       mainBMP := newBMP
    }

    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    Gdip_DeleteBrush(zBrush)
    obju := [mainBMP, minedX, minedY, maxedW, maxedH, scaleuPreview]
    Return obju
}

drawHistogram(dataArray, graphFocus, LengthX, Scale, fgrColor, bgrColor, borderSize, infoBoxBMP, barWidth:=2) {
    Static graphHeight := 300 ; graph height
    stylu := (showHistogram=6) ? 3 : 2
    ; ToolTip, % maxYlimit " || " LengthX  , , , 2
    plotBMP := BarChart(dataArray, lol, Round(296*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:0, BarHeight:" Scale*1.5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,TextSize:0,AutoCalculateHeight:1, BarColorDirection:" stylu ", BarPeaksColor:eeFFffFF, BgrStyle:3, BarBorderColor:0, MaxPercentValue:" graphFocus ", BarColorA:" fgrColor ", ChartBackColorA:dd" bgrColor)
    If !plotBMP
       Return

    Gdip_ImageRotateFlip(plotBMP, 5)
    Gdip_ImageRotateFlip(plotBMP, 6)
    Gdip_GetImageDimensions(plotBMP, imgW, imgH)
    If infoBoxBMP
       Gdip_GetImageDimensions(infoBoxBMP, imgW2, imgH2)

    clipBMP := trGdip_CreateBitmap(A_ThisFunc, imgW + borderSize * 2, imgH + Round(imgH2) + Round(borderSize*1.25), coreDesiredPixFmt)
    If StrLen(clipBMP)<2
    {
       trGdip_DisposeImage(plotBMP, 1)
       Return
    }

    G3 := Gdip_GraphicsFromImage(clipBMP)
    If G3
    {
       Gdip_GetImageDimensions(clipBMP, maxW, maxH)
       lineThickns := Round(borderSize/15)
       Gdip_SetPenWidth(pPen1d, lineThickns)
       Gdip_GraphicsClear(G3, "0xEE" bgrColor)
       ; Gdip_FillRectangle(G3, pBr0, -2, -2, maxW + borderSize*2+12, maxH + borderSize*3)
       ; Gdip_FillRectangle(G3, pBrushE, borderSize/2, borderSize/2, imgW + borderSize, imgH + borderSize)
       Gdip_DrawRectangle(G3, pPen1d, borderSize/2 - lineThickns, borderSize/2 - lineThickns, imgW + lineThickns*2 + borderSize, imgH + lineThickns*2 + borderSize//2)
       HUDobjHistoBoxu[5] := imgW + lineThickns*2 + borderSize
       HUDobjHistoBoxu[6] := imgH + lineThickns*2 + borderSize
       Gdip_DrawImage(G3, plotBMP, borderSize, borderSize)
       If infoBoxBMP
          Gdip_DrawImage(G3, infoBoxBMP, borderSize//5, imgH + lineThickns*2 + borderSize)
       ; infoBoxBMP is disposed by the caller
       Gdip_DeleteGraphics(G3)
    }

    trGdip_DisposeImage(plotBMP, 1)
    ; ToolTip, % clipBMPa  "`n" clipBMP , , , 2
    ; tooltip, % maxYlimit ", " LengthX " || "  maxW "," maxH  ;  `n" PointsList
    Return clipBMP
}

performAutoExpandCanvas(imgW, imgH, ByRef whichBitmap) {
    nImgSelX1 := imgSelX1, nImgSelY1 := imgSelY1
    nimgSelX2 := imgSelX2, nimgSelY2 := imgSelY2
    If (imgSelX1>=0)
       imgSelX1 := 0
    Else
       zImgSelX1 := Abs(imgSelX1)

    If (imgSelY1>0)
       imgSelY1 := 0
    Else
       zImgSelY1 := Abs(imgSelY1)

    If (imgSelX2<imgW)
       imgSelX2 := imgW
    If (imgSelY2<imgH)
       imgSelY2 := imgH

    obju := []
    obju[1] := [EllipseSelectMode, VPselRotation, innerSelectionCavityX, innerSelectionCavityY]
    VPselRotation := EllipseSelectMode := innerSelectionCavityX := innerSelectionCavityY :=  0
    CropImageInViewPortToSelection("simplex")
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    prevImgSelX1 += Round(zimgSelX1)
    prevImgSelY1 += Round(zimgSelY1)
    prevImgSelX2 += Round(zimgSelX1)
    prevImgSelY2 += Round(zimgSelY1)
    VPstampBMPx += Round(zimgSelX1)
    VPstampBMPy += Round(zimgSelY1)
    imgSelX1 := nimgSelX1 + Round(zimgSelX1)
    imgSelY1 := nimgSelY1 + Round(zimgSelY1)
    imgSelX2 := nimgSelX2 + Round(zimgSelX1)
    imgSelY2 := nimgSelY2 + Round(zimgSelY1)
    EllipseSelectMode := obju[1, 1]
    VPselRotation := obju[1, 2]
    innerSelectionCavityX := obju[1, 3]
    innerSelectionCavityY := obju[1, 4]
    editingSelectionNow := 1
    Return 1
}

PasteInPlaceNow() {
    allowOutside := 0
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If ((imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH) && PasteInPlaceAutoExpandIMG=1 && whichBitmap && imgW && imgH)
       allowOutside := 1

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 1, 0, allowOutside)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       corePasteInPlaceActNow("kill")
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    If (allowOutside=1)
       hasRanExpand := performAutoExpandCanvas(imgW, imgH, whichBitmap)

    startZeit := A_TickCount
    If (UserMemBMP!=whichBitmap && whichBitmap)
    {
       fnOutputDebug(A_ThisFunc ": cloning GDI+ bitmap: " whichBitmap)
       whichBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)
       wasClone := whichBitmap
    } Else If warnUserFatalBitmapError(whichBitmap, A_ThisFunc)
       whichBitmap := ""

    thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    If StrLen(whichBitmap)>2
    {
       fnOutputDebug(A_ThisFunc ": create graphics")
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, thisImgQuality, 4,, compositingQuality)
    }

    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(wasClone, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    recordUndoLevelNow("init", 0)
    ; setImageLoading()
    r1 := corePasteInPlaceActNow(G2, whichBitmap)
    If (PasteInPlaceEraseInitial=1)
       currIMGdetails.HasAlpha := 1

    Gdip_DeleteGraphics(G2)
    corePasteInPlaceActNow("kill")
    If (r1!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "(): transformations ended. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    RefreshImageFile()
    If (hasRanExpand=1)
    {
       totalSelUndos := Round(undoSelLevelsArray.Count())
       currentSelUndoLevel := clampInRange(totalSelUndos, 1, totalSelUndos)
       restorePreviousSelections(currentSelUndoLevel)
       SetTimer, dummyRefreshImgSelectionWindow, -125
    }
}

determineSizeRotateSkew(whichBitmap, Angle, shearX, shearY, ellipseModus) {
   If IsObject(whichBitmap)
   {
      imgW := whichBitmap[1]
      imgH := whichBitmap[2]
   } Else
      Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

   pPath := Gdip_CreatePath()
   If (ellipseModus=1)
      Gdip_AddPathEllipse(pPath, 0, 0, imgW, imgH)
   Else
      Gdip_AddPathRectangle(pPath, 0, 0, imgW, imgH)

   pMatrix := Gdip_CreateMatrix()
   Gdip_ShearMatrix(pMatrix, shearX, shearY)
   Gdip_RotateMatrix(pMatrix, Angle)
   Gdip_TransformPath(pPath, pMatrix)

   If (ellipseModus=1)
      pb := getAccuratePathBounds(pPath, 2)
   Else
      pb := Gdip_GetPathWorldBounds(pPath)

   transX := -(pb.x),    transY := -(pb.y)
   pb.imgW := imgW,      pb.imgH := imgH
   pb.obj := pMatrix
   Gdip_TranslateMatrix(pMatrix, transX, transY, 1)
   ; Gdip_SetWorldTransform(2NDglPG, pMatrix)
   ; Gdip_DrawImage(2NDglPG, whichBitmap, 0, 0, imgW, imgH, , , , , 0.7)
   ; ToolTip, % "l=" a , , , 2
   Gdip_DeletePath(pPath)
   Return pb
}

RotateAndSkewBitmap(whichBitmap, Angle, shearX, shearY, ellipseModus, InterpolationMode) {
    If !whichBitmap
       Return

    If (!Angle && !shearX && !shearY)
       Return Gdip_CloneBitmap(whichBitmap)

    pb := determineSizeRotateSkew(whichBitmap, Angle, shearX, shearY, ellipseModus)
    If (pb.w*pb.h>536848912) || (pb.w>32100) || (pb.h>32100)
    {
       addJournalEntry("ERROR: the bitmap resolution is too big. It exceeds the GDI+ limits. " A_ThisFunc "()")
       Return
    }

    newBitmap := Gdip_CreateBitmap(pb.w, pb.h, "0xE200B")
    If StrLen(newBitmap)>1
       G := Gdip_GraphicsFromImage(newBitmap, InterpolationMode, 4)

    If (!newBitmap || !G)
    {
       Gdip_DisposeImage(newBitmap, 1)
       Gdip_DeleteGraphics(G)
       Return
    }

    Gdip_SetWorldTransform(G, pb.obj)
    r := Gdip_DrawImage(G, whichBitmap, 0, 0, pb.imgW, pb.imgH)
    If r
    {
       Gdip_DisposeImage(newBitmap, 1)
       newBitmap := ""
    }

    Gdip_DeleteGraphics(G)
    Gdip_DeleteMatrix(pb.obj)
    Return newBitmap
}

realtimePasteInPlaceRotator(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState, hasRotated
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation VPselRotation prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex PasteInPlaceBlurEdgesSoft previnnerSelectionCavityX previnnerSelectionCavityY shearImgX shearImgY
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return hasRotated
    }

    hasRotated := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return 0

    Gdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    Gdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := JimgW/vpImgW
    ellipseModus := (prevEllipseSelectMode=1 && PasteInPlaceToolMode=1) ? 1 : 0

    Gdip_GetImageDimensions(clipBMP, eImgW, eImgH)
    If (PasteInPlaceOrientation=2)
       ER := Gdip_ImageRotateFlip(clipBMP, 4)
    Else If (PasteInPlaceOrientation=3)
       ER := Gdip_ImageRotateFlip(clipBMP, 6)
    Else If (PasteInPlaceOrientation=4)
       ER := Gdip_ImageRotateFlip(clipBMP, 2)

    If ((VPselRotation>0 || shearImgX!=0 || shearImgY!=0) && !ER)
    {
       setWindowTitle("Rotating image at " VPselRotation "°")
       xBitmap := RotateAndSkewBitmap(clipBMP, VPselRotation, shearImgX, shearImgY, ellipseModus, thisImgQuality)
       If StrLen(xBitmap)>3
       {
          hasRotated := 1
          clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
    }

    If (prevEllipseSelectMode=1 && PasteInPlaceToolMode=1 && hasRotated=1)
    {
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       pb := determineSizeRotateSkew([eImgW, eImgH], VPselRotation, shearImgX, shearImgY, ellipseModus)
       gFx := pB.w/rimgW
       gFy := pB.h/rimgH
       zwImgW := Round(rImgW * gFx)
       zwImgH := Round(rImgH * gFy)
       dX := (rImgW - zwImgW)//2
       dY := (rImgH - zwImgH)//2
       xBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP, dX, dY, zwImgW, zwImgH)
       Gdip_DeleteMatrix(pb.obj)
       If StrLen(xBitmap)>3
       {
          clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
       ; ToolTip, % gFx " --- " gFy "`n" zwImgW " --- " zwImgH "`n" rImgW " --- " rImgH "`n" dX " --- " dY "`n" clipBMP , , , 2
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    Return hasRotated
}

createSelectionBlurryMask() {
    wPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    pB := GetPathRelativeBounds(wPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h
    Gdip_DeletePath(wPath)
    bRa := (EllipseSelectMode>0 || VPselRotation>0) ? blurAreaAmount*2 : blurAreaAmount
    gImgselPx := imgSelPx - bRa
    gImgselPy := imgSelPy - bRa
    gImgSelW := imgSelW + bRa * 2
    gImgselH := imgSelH + bRa * 2
}

realtimePasteInPlaceBlurrator(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState
    newBitmap := ""

    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" userClipBMPpaste PasteInPlaceBlurEdgesSoft viewportStampBMP previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex PasteInPlaceAdaptMode previnnerSelectionCavityX previnnerSelectionCavityY
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return
    }

    fnOutputDebug("redraw: " A_ThisFunc)
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    clipBMP := trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return "fail"

    Gdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    Gdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := (vpImgW + vpImgH) / (JimgW + JimgH)
    thisAmount := (previewMode=1) ? Round(PasteInPlaceBlurAmount * fScale) : PasteInPlaceBlurAmount
    If (thisAmount>1)
    {
       If (previewMode!=1)
          QPV_SetGivenAlphaLevel(clipBMP, 1, 1)
       Else If (previewMode!=1)
          setWindowTitle("Applying blur filter on image")

       ; ToolTip, % thisAmount "=" fScale  , , , 2
       pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, clipBMP, thisAmount, pEffect, previewMode)
       Gdip_DisposeEffect(pEffect)
    }

    If (PasteInPlaceToolMode=1) ; && (prevVPselRotation>0 || prevEllipseSelectMode>0))
    {
       ; when used with the transform tool
       eimgW := max(prevImgSelX1, prevImgSelX2) - min(prevImgSelX1, prevImgSelX2)
       eimgH := max(prevImgSelY1, prevImgSelY2) - min(prevImgSelY1, prevImgSelY2)
       decX := prevImgSelX1 - VPstampBMPx
       decY := prevImgSelY1 - VPstampBMPy
       If (previewMode=1)
       {
          Gdip_GetImageDimensions(clipBMP, wImgW, wImgH)
          Gdip_GetImageDimensions(userClipBMPpaste, gImgW, gImgH)
          scaleu := gImgW/wImgW
          eimgW := Round(eimgW/scaleu)
          eimgH := Round(eimgH/scaleu)
          decX := Round(decX/scaleu)
          decY := Round(decY/scaleu)
       }

       pPath := createImgSelPath(0, 0, eImgW, eImgH, prevEllipseSelectMode, prevVPselRotation, prevrotateSelBoundsKeepRatio, 0, 1, 1, previnnerSelectionCavityX, previnnerSelectionCavityY)
       If pPath
       {
          carvePathFromBitmap(clipBMP, pPath, -decX, -decY, 4, PasteInPlaceBlurEdgesSoft + 1, thisAmount)
          Gdip_DeletePath(pPath)
       }
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    Return
}

realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlphaBMP, rImgW, rImgH, thisImgQuality:=0) {
    Static prevBMPu, prevState
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisBMP := userAlphaBMP
    thisState := "a" previewMode alphaMaskRefBMP getIDimage(currentFileIndex) currentFileIndex alphaMaskGradientAngle lastPaintEventID VPselRotation rImgW rImgH
    If (thisState=prevState && prevBMPu)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       trGdip_DisposeImage(thisBMP, 1)
       Return newBitmap
    }

    fnOutputDebug("redraw: " A_ThisFunc)
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)

    thisImgQuality := (PasteInPlaceQuality=1 && previewMode!=1) ? 7 : 5
    If (alphaMaskGradientAngle>0 && thisBMP)
    {
       changeMcursor()
       thisMono := (alphaMaskColorReversed!=1) ? "0xFF000000" : "0xFFFFFFFF"
       thisMonoBrush := Gdip_BrushCreateSolid(thisMono)
       xMask := trGdip_RotateBitmapAtCenter(A_ThisFunc, thisBMP, alphaMaskGradientAngle, thisMonoBrush, thisImgQuality)
       If StrLen(xMask)>2
       {
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := xMask
       } Else ER := "fail"
       Gdip_DeleteBrush(thisMonoBrush)
    } Else If !thisBMP
       ER := "fail"

    If ER
    {
       trGdip_DisposeImage(thisBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(thisBMP, zImgW, zImgH)
    If (zImgW!=rImgW || zImgH!=rImgH)
       alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, thisBMP, rImgW, rImgH, 0, thisImgQuality, -1)
    Else
       alphaMaskGray := trGdip_CloneBitmap(A_ThisFunc, thisBMP)

    trGdip_DisposeImage(thisBMP, 1)
    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : alphaMaskGray
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? alphaMaskGray : trGdip_CloneBitmap(A_ThisFunc, alphaMaskGray)
    Return newBitmap
}

useGdiBitmap(doConvertPARG:=0) {
   If StrLen(gdiBitmap)>3
   {
      If (doConvertPARG="yes")
         thisPixFmt := Gdip_GetImagePixelFormat(gdiBitmap, 1)
      If (thisPixFmt!="0xE200B" && thisPixFmt)
      {
          newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, gdiBitmap)
          trGdip_DisposeImage(gdiBitmap, 1)
          gdiBitmap := newBitmap
      }
      Return gdiBitmap
   } Else If StrLen(UserMemBMP)>3
   {
      If (doConvertPARG="yes")
         thisPixFmt := Gdip_GetImagePixelFormat(UserMemBMP, 1)
      If (thisPixFmt!="0xE200B" && thisPixFmt)
      {
          newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, UserMemBMP)
          trGdip_DisposeImage(UserMemBMP, 1)
          UserMemBMP := newBitmap
      }
      Return UserMemBMP
   }
   Else Return
}

LoadCachableBitmapFromFile(imgPath) {
   Static prevBMPu, prevState
   If (imgPath="kill")
   {
      prevState := 0
      prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
      Return
   }

   thisState := "a" generateThumbName(imgPath, 1) "=-=b"
   If (thisState=prevState && prevBMPu && FileRexists(imgPath))
   {
      newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
      Return newBitmap
   }

   fnOutputDebug("redraw: " A_ThisFunc)
   prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
   pBitmap := LoadBitmapFromFileu(imgPath)
   If StrLen(pBitmap)>2
   {
      zBitmap := cloneGDItoMem(A_ThisFunc, pBitmap)
      If StrLen(zBitmap)>2
      {
         trGdip_DisposeImage(pBitmap, 1)
         pBitmap := zBitmap
      }
   } Else
   {
      addJournalEntry(A_ThisFunc "() failed: unable to load image file")
      Return
   }

   prevBMPu := (minimizeMemUsage=1) ? 0 : pBitmap
   prevState := (pBitmap && minimizeMemUsage!=1) ? thisState : 0
   If StrLen(pBitmap)>2
      newBitmap := (minimizeMemUsage=1) ? pBitmap : trGdip_CloneBitmap(A_ThisFunc, pBitmap)
   Return newBitmap
}

QPV_SetAlphaChannel(pBitmap, pBitmapMask, invertAlphaMask:=0, replaceSourceAlphaChannel:=0, whichChannel:=1, threads:=0) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmapMask, w2, h2)
  If (w2!=w || h2!=h || !pBitmap || !pBitmapMask)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  E2 := Gdip_LockBits(pBitmapMask, 0, 0, w, h, stride, mScan, mData, 1)
  func2exec := (A_PtrSize=8) ? "SetAlphaChannel" : "_SetAlphaChannel@32"
  If (!E1 && !E2)
     r := DllCall(whichMainDLL "\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", invertAlphaMask, "Int", replaceSourceAlphaChannel, "Int", whichChannel, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmapMask, mData)
  ; ToolTip, % "qpv_alpha " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_FloodFill(pBitmap, x, y, newColor, fillOpacity) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !pBitmap || !isInRange(x, 0, w) || !isInRange(y, 0, h))
     Return 0

  ; If (fillOpacity<254)
  ; {
  ;    oldColorHex := Gdip_GetPixelColor(pBitmap, x, y, 1)
  ;    ; ToolTip, % oldColorHex "`n" newColor , , , 2
  ;    newColor := MixARGB(oldColorHex, newColor, fillOpacity/255)
  ; }

  Gdip_FromARGB(newColor, A, R, G, B)
  newColor := Gdip_ToARGB(A, R, G, B)
  if (FloodFillTolerance<3)
     FloodFillCartoonMode := 0

  ; oldColor := Gdip_GetPixel(pBitmap, x, y)
  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  tolerance := (FloodFillAltToler=1) ? Ceil(FloodFillTolerance*0.7) + 1 : FloodFillTolerance
  func2exec := (A_PtrSize=8) ? "FloodFyll" : "_FloodFyll@56"
  If !E1
     r := DllCall(whichMainDLL "\" func2exec, "UPtr", iScan, "Int", FloodFillModus, "Int", w, "Int", h, "Int", x, "Int", y, "Int", newColor, "int", tolerance, "int", fillOpacity, "int", FloodFillDynamicOpacity, "int", FloodFillBlendMode - 1, "int", FloodFillCartoonMode, "int", FloodFillAltToler, "int", FloodFillEightWays)
  ; ToolTip, % A_PtrSize "=" A_LastError "==" r "=" func2exec "=" SecToHHMMSS(Round(zeitOperation/1000, 3)) , , , 2

  If !E1
     Gdip_UnlockBits(pBitmap, iData)

  zeitOperation := A_TickCount - thisStartZeit
  return r
}

QPV_ConvertToGrayscale(pBitmap, modus) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !pBitmap)
     Return 0

  ; oldColor := Gdip_GetPixel(pBitmap, x, y)
  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  func2exec := (A_PtrSize=8) ? "ConvertToGrayScale" : "_ConvertToGrayScale@16"
  If !E1
     r := DllCall(whichMainDLL "\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "int", modus)

  ; ToolTip, % A_PtrSize "=" A_LastError "==" r "=" func2exec "=" SecToHHMMSS(Round(zeitOperation/1000, 3)) , , , 2
  If !E1
     Gdip_UnlockBits(pBitmap, iData)

  zeitOperation := A_TickCount - thisStartZeit
  return r
}

QPV_EraserBrush(pBitmap, pBitmapMask, invertAlphaMask, replaceMode, levelAlpha, offsetX, offsetY, clonescu) {
  ; thisStartZeit := A_TickCount
  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmapMask, w2, h2)
  If (!pBitmap || !pBitmapMask)
     Return 0

  w3 := (offsetX<0) ? w2 - Abs(offsetX) : w2
  h3 := (offsetY<0) ? h2 - Abs(offsetY) : h2
  offX := (offsetX<0) ? Abs(offsetX) : 0
  offY := (offsetY<0) ? Abs(offsetY) : 0
  offsetX := (offsetX<0) ? 0 : offsetX
  offsetY := (offsetY<0) ? 0 : offsetY
  If (offsetX + w3>=w)
     w3 -= (offsetX + w3 - w)
  If (offsetY + h2>=h)
     h3 -= (offsetY + h3 - h)

  initQPVmainDLL()
  If (w3<1 || h3<1 || !qpvMainDll)
     Return 0

  E1 := Gdip_LockBits(pBitmap, offsetX, offsetY, w3, h3, strideA, iScan, iData)
  E2 := Gdip_LockBits(pBitmapMask, offX, offY, w3, h3, strideB, mScan, mData, 1)
  If clonescu
     E3 := Gdip_LockBits(clonescu, offsetX, offsetY, w3, h3, strideC, cScan, cData)

  If (!E1 && !E2)
  {
     useClone := (!E3 && clonescu) ? 1 : 0
     func2exec := (A_PtrSize=8) ? "EraserBrush" : "_EraserBrush@36"
     r := DllCall(whichMainDLL "\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w3, "Int", h3, "Int", invertAlphaMask, "Int", replaceMode, "Int", levelAlpha, "UPtr", cScan, "int", useClone)
     ; klop := Gdip_GetImagePixelFormat(gdiBitmap, 2)
     ; klopa := Gdip_GetImagePixelFormat(UserMemBMP, 2)
     ; kloxa := Gdip_GetImagePixelFormat(pBitmapMask, 2)
     ; ToolTip, % r "=" ErrorLevel "=" A_LastError "`n" klop "`n" klopa "`n" kloxa "`n" "=" iScan "=" mScan "=" w2 "=" h2 "=" invertAlphaMask "=" replaceMode "=" levelAlpha "=" countClicks , , , 2
   }

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmapMask, mData)
  If (!E3 && clonescu)
     Gdip_UnlockBits(clonescu, cData)
  ; ToolTip, % "qpv_" r "=" e1 "=" e "`n" offsetX "=" offsetY "`n" w2 "=" h2, , , 2
  return r
}

QPV_SetGivenAlphaLevel(pBitmap, givenLevel, fillMissingOnly, threads:=0) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If isWinXP
     Return

  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV .dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !pBitmap)
  {
     addJournalEntry(A_ThisFunc "(): failed - possibly malformed pBitmap given: " pBitmap)
     Return 0
  }

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  func2exec := (A_PtrSize=8) ? "SetGivenAlphaLevel" : "_SetGivenAlphaLevel@24"
  If !E1
     r := DllCall(whichMainDLL "\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", givenLevel, "Int", fillMissingOnly, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  ; ToolTip, % "qpv_alpha " A_TickCount - thisStartZeit, , , 2
  return r
}


QPV_FillBitmapHoles(pBitmap, newColor) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If isWinXP
     Return

  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !pBitmap)
  {
     addJournalEntry(A_ThisFunc "(): failed - possibly malformed pBitmap given: " pBitmap)
     Return 0
  }

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  func2exec := (A_PtrSize=8) ? "FillImageHoles" : "_FillImageHoles@16"
  If !E1
     r := DllCall(whichMainDLL "\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "UInt", newColor)
  fnOutputDebug(A_ThisFunc ": " func2exec "=r" r "=e" E1 "|" A_LastError)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  return r
}

QPV_BlendBitmaps(pBitmap, pBitmap2Blend, blendMode, threads) {
  initQPVmainDLL()
  If (!qpvMainDll || isWinXP=1)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return ; Gdip_BlendBitmaps(pBitmap, pBitmap2Blend, clampInRange(blendMode, 1, 18))
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmap2Blend, w2, h2)
  ; fnOutputDebug(A_ThisFunc "() " w "=" w2 "||" h "=" h2)
  If (w2!=w || h2!=h || !pBitmap || !pBitmap2Blend || !w ||)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  E2 := Gdip_LockBits(pBitmap2Blend, 0, 0, w, h, stride, mScan, mData, 1)
  func2exec := (A_PtrSize=8) ? "BlendBitmaps" : "_BlendBitmaps@24"
  If (!E1 && !E2)
     r := DllCall(whichMainDLL "\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", blendMode, "Int", threads)
  ; fnOutputDebug(A_ThisFunc "() " A_LastError " r=" r "=" func2exec "=" A_TickCount - thisStartZeit "|" blendMode)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmap2Blend, mData)
  return r
}

QPV_CreateBitmapNoise(W, H, intensity, doGray, threads) {
  initQPVmainDLL()
  If (!qpvMainDll || isWinXP=1)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BlendBitmaps(pBitmap, pBitmap2Blend, clampInRange(blendMode, 1, 18))
  }

  thisStartZeit := A_TickCount
  If (!w || !h)
     Return 0

  pBitmap := trGdip_CreateBitmap(A_ThisFunc, W, H, "0x26200A")
  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  func2exec := (A_PtrSize=8) ? "RandomNoise" : "_RandomNoise@24"
  If !E1
     r := DllCall(whichMainDLL "\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", intensity, "Int", doGray, "Int", threads)

  ; ToolTip, % E1 "==" r " == " pBitmap "==" W "x" H, , , 2
  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  ; ToolTip, % "r=" r " ; qpv == " A_TickCount - thisStartZeit, , , 2
  return pBitmap
}

generateAlphaMaskBitmap(clipBMP, previewMode, offX:=0, offY:=0, offW:=0, offH:=0, sizeIDu:=0, doGrayScale:=0) {
    Static prevBMPu, prevState
    If (clipBMP="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    If (offX>2 && offY>2 && !offW && !offH)
    {
       rImgW := offX
       rImgH := offY
       offX := offY := 0
    } Else Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
    ; fnOutputDebug(A_ThisFunc "(): " offX "=" offY "|" offW "=" offH  "|" rImgW "=" rImgH)

    If (!offW || !offH)
    {
       offX := offY := 0
       offW := rImgW
       offH := rImgH
    }

    If (alphaMaskRefBMP=1)
       thisAlphaFile := userAlphaMaskBmpPainted
    Else If (alphaMaskRefBMP=2)
       thisAlphaFile := useGdiBitmap()
    Else If (alphaMaskRefBMP=3 && (AnyWindowOpen=24 || AnyWindowOpen=31))
       thisAlphaFile := (previewMode=1) ? viewportStampBMP : userClipBMPpaste

    sizeIDu := sizeIDu ? sizeIDu : "a" rImgW rImgH
    externBMP := (alphaMaskingMode=5 && StrLen(thisAlphaFile)>2) ? 1 : 0
    thisState := "a" externBMP previewMode thisAlphaFile alphaMaskRefBMP alphaMaskingMode alphaMaskClrAintensity alphaMaskClrBintensity alphaMaskGradientAngle alphaMaskGradientScale alphaMaskOffsetX alphaMaskOffsetY alphaMaskGradientWrapped alphaMaskColorReversed alphaMaskReplaceMode alphaMaskBMPchannel VPselRotation lastPaintEventID alphaMaskGradientPosA alphaMaskGradientPosB sizeIDu getVPselIDs("saiz-vpos") userAlphaMaskBmpPainted userPrevAlphaMaskBmpPainted
    If (thisState=prevState && StrLen(prevBMPu)>2)
       Return prevBMPu

    prevState := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    fnOutputDebug("redraw: " A_ThisFunc)
    allGood := 0
    ; ToolTip, % paintedImage "/" externBMP "l" alphaMaskingMode "|" thisAlphaFile "|c=" clipBMP "|f=" alphaMaskRefBMP, , , 2
    If (externBMP!=1)
    {
       alphaMaskGray := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
       If warnUserFatalBitmapError(alphaMaskGray, A_ThisFunc)
          Return
    }

    If (externBMP=1)
    {
       userAlpha := trGdip_CloneBitmap(A_ThisFunc, thisAlphaFile)
       Gdip_GetImageDimensions(userAlpha, testImgW, testImgH)
       msize := (testImgW + testImgH)//2
       threads := (previewMode=1) ? realSystemCores : 0
       If (StrLen(userAlpha)>2 && testImgW>1 && testImgH>1)
       {
          brLvl := Round(alphaMaskClrAintensity/255*510 - 255)
          contrLvl := Round(alphaMaskClrBintensity/255*100)

          thisImgQuality := (PasteInPlaceQuality=1 && previewMode!=1) ? 7 : 5
          alphaMaskGray := realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlpha, rImgW, rImgH, thisImgQuality)
          rsize := (rImgW + rimgH)//2
          If StrLen(alphaMaskGray)<3
          {
             addJournalEntry(A_ThisFunc ": failed to rotate alpha mask")
             Return
          }

          If (AnyWindowOpen=70 && previewMode=1 || doGrayScale=1)
             QPV_ConvertToGrayscale(alphaMaskGray, alphaMaskBMPchannel)
          Else If (alphaMaskBMPchannel=5 || doGrayScale=1)
             QPV_ConvertToGrayscale(alphaMaskGray, alphaMaskBMPchannel)
             ; pEffectGray := Gdip_CreateEffect(6, 0, -100, 0)
             ; Gdip_BitmapApplyEffect(thisBMP, pEffectGray)
             ; Gdip_DisposeEffect(pEffectGray)

          ; Gdip_GetImageDimensions(alphaMaskGray, zImgW, zImgH)
          ; ToolTip, % testImgW "=" testImgH "`n" rImgW "=" rimgH "`n" zImgW "=" zimgH "`n" thisAlphaFile "--" userAlpha , , , 2
          If (brLvl!=1 || contrLvl!=0)
          {
             pEffect := Gdip_CreateEffect(5, brLvl, contrLvl)
             Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
             Gdip_DisposeEffect(pEffect)
          }

          thisAlphaBlur := Round((alphaMaskGradientScale - 1)/302 * 255)
          If (previewMode=1)
             thisAlphaBlur := Round(thisAlphaBlur * (rsize / msize))

          If (thisAlphaBlur>1)
          {
             pBlurEffect := Gdip_CreateEffect(1, thisAlphaBlur, 0)
             ApplySpecialFixedBlur(A_ThisFunc, alphaMaskGray, thisAlphaBlur, pBlurEffect, 0)
             Gdip_DisposeEffect(pBlurEffect)
          }
          allGood := 1
          ; ToolTip, % clipBMP "--" alphaMaskGray "--" userAlpha "=" brLvl "=" contrLvl , , , 2
       } Else 
       {
          trGdip_DisposeImage(userAlpha, 1)
          addJournalEntry(A_ThisFunc ": failed to retrieve alpha mask image.")
       }
    } Else If (alphaMaskingMode=6 && customShapePoints.Count()>1)
    {
       pEffect := Gdip_CreateEffect(1, alphaMaskClrAintensity, 0)
       alphaPath := Gdip_CreatePath()
       fAgScal := (alphaMaskGradientScale + 2)/100
       tempArray := StrSplit(initialCustomShapeCoords, "|")
       calcIMGdimensions(tempArray[3], tempArray[4], rImgW, rImgH, rW, rH)
       tRimgW := (tempArray[3]>1) ? Round(rW*fAgScal) : Round(rImgW*fAgScal)
       tRimgH := (tempArray[4]>1) ? Round(rH*fAgScal) : Round(rImgH*fAgScal)
       offX := rImgW - tRimgW + Round((rImgW*alphaMaskOffsetX)*(fAgScal+1))
       offY := rImgH - tRimgH + Round((rImgH*alphaMaskOffsetY)*(fAgScal+1))
       doDeduping := (alphaMaskClrBintensity>250) ? 0 : 1
       PointsList := convertCustomShape2givenArea(customShapePoints, 1 + offX//2, 1 + offY//2, tRimgW - 2, tRimgH - 2, 1, doDeduping)
       tensionLvl := Round(alphaMaskClrBintensity/255, 2)
       If (alphaMaskClrBintensity>250 && alphaPath)
          Gdip_AddPathBeziers(alphaPath, PointsList)
       Else If (alphaMaskClrBintensity<15 && alphaPath)
          Gdip_AddPathPolygon(alphaPath, PointsList)
       Else If alphaPath
          Gdip_AddPathClosedCurve(alphaPath, PointsList, tensionLvl)

       If (alphaMaskGradientAngle>0 && alphaPath)
          trGdip_RotatePathAtCenter(alphaPath, alphaMaskGradientAngle, 1, 0, 1, 1)

       G4 := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray, 7, 4)
       trGdip_GraphicsClear(A_ThisFunc, G4, "0xFF000000")
       If G4
       {
          BrushB := Gdip_BrushCreateSolid("0xFFFFFFFF")
          Gdip_SetClipRect(G4, 0, 0, rImgW, rImgH)
          Gdip_FillPath(G4, BrushB, alphaPath)
          Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
          Gdip_DeleteBrush(BrushB)
          allGood := 1
       }
       Gdip_DisposeEffect(pEffect)
       Gdip_DeletePath(alphaPath)
       ; Gdip_DeleteBrush(BrushA)
       Gdip_DeleteGraphics(G4)
    } Else If isInRange(alphaMaskingMode, 2, 4)
    {
       zpw := alphaMaskClrAintensity
       zpu := alphaMaskClrBintensity
       thisColorA := Gdip_ToARGB("0xFF", zpw, zpw, zpw)
       thisColorB := Gdip_ToARGB("0xFF", zpu, zpu, zpu)
       ; ToolTip, % thisColorA "`n" thisColorB, , , 2
       brImgSelW := rImgW*(alphaMaskGradientScale/100)
       brImgSelH := rImgH*(alphaMaskGradientScale/100)
       brimgSelPx := 0 - (brImgSelW - rImgW)//2
       brimgSelPy := 0 - (brImgSelH - rImgH)//2
       gradientWrapMode := (alphaMaskGradientWrapped=1) ? 3 : 4
       If (alphaMaskingMode=2)
       {
          gradBrush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + Round(brImgSelW*alphaMaskOffsetX), brimgSelPy + Round(brImgSelH*alphaMaskOffsetY), brimgSelW, brimgSelH, thisColorA, thisColorB, 1, alphaMaskGradientWrapped)
          If gradBrush
          {
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, [alphaMaskGradientPosA/100, alphaMaskGradientPosB/100], [thisColorA, thisColorB])
             Gdip_RotateLinearGrBrushAtCenter(gradBrush, Mod(Round(alphaMaskGradientAngle + VPselRotation), 360), 1)
             Gdip_SetLinearGrBrushWrapMode(gradBrush, gradientWrapMode)
          }
       } Else If (alphaMaskingMode=3 || alphaMaskingMode=4)
       {
          grpPath := Gdip_CreatePath()
          If (alphaMaskingMode=3 && grpPath)
             Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
          Else If grpPath
             Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

          If grpPath
             gradBrush := Gdip_PathGradientCreateFromPath(grpPath)

          If gradBrush
          {
             Gdip_PathGradientSetCenterPoint(gradBrush, 0 + rImgW//2 + Round(rImgW*alphaMaskOffsetX), 0 + rImgH//2 + Round(rImgH*alphaMaskOffsetY))
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, [alphaMaskGradientPosA/100, alphaMaskGradientPosB/100], [thisColorA, thisColorB])
             Gdip_RotatePathGradientAtCenter(gradBrush, Mod(Round(alphaMaskGradientAngle + VPselRotation), 360), 1)
             Gdip_PathGradientSetWrapMode(gradBrush, gradientWrapMode)
          }

          Gdip_DeletePath(grpPath)
       }

       Ga := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray)
       If Ga
       {
          trGdip_GraphicsClear(A_ThisFunc, Ga, thisColorB)
          Gdip_SetClipRect(Ga, offX, offY, offW, offH)
          ; ToolTip, % offX "=" offY "|" offW "=" offH  "|" rImgW "=" rImgH , , , 2
          Gdip_FillRectangle(Ga, gradBrush, 0, 0, rImgW, rImgH)
          Gdip_DeleteGraphics(Ga)
          allGood := 1
       }

       Gdip_DeletePath(pPath)
       Gdip_DeleteBrush(gradBrush)
    }

    If (allGood=1)
    {
       prevState := (minimizeMemUsage=0 && previewMode=1) ? thisState : 0
       prevBMPu := (minimizeMemUsage=0 && previewMode=1) ? alphaMaskGray : 0
       Return alphaMaskGray
    } Else prevState := 0

    trGdip_DisposeImage(alphaMaskGray, 1)
}

realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, givenID, ByRef newBitmap, offX:=0, offY:=0, offW:=0, offH:=0) {
    Static prevBMPu, prevState
    If (previewMode="kill")
    {
       prevState := 0
       realtimePasteInPlaceAlphaMaskRotator("kill", 0, 0, 0)
       generateAlphaMaskBitmap("kill", 0)
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    If (coreDesiredPixFmt="0x21808")
       Return

    newBitmap := ""
    Gdip_GetImageDimensions(clipBMP, oImgW, oImgH)
    thisState := givenID oImgW oImgH
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return
    }

    prevState := 0
    If (previewMode!=1)
       setWindowTitle("Applying alpha mask to image")

    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    newBitmap := trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    If StrLen(newBitmap)<3
       Return

    paintedImage := (InStr(alphaMaskRefBMP, "user-painted") && alphaMaskingMode=5) ? 1 : 0
    alphaMaskGray := generateAlphaMaskBitmap(newBitmap, previewMode, offX, offY, offW, offH)
    If StrLen(alphaMaskGray)>2
       QPV_SetAlphaChannel(newBitmap, alphaMaskGray, alphaMaskColorReversed, alphaMaskReplaceMode, alphaMaskBMPchannel, threads)

    If (previewMode!=1)
    {
       trGdip_DisposeImage(alphaMaskGray, 1)
       SetTimer, ResetImgLoadStatus, -100
    }
    fnOutputDebug("redraw: " A_ThisFunc)
    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : trGdip_CloneBitmap(A_ThisFunc, newBitmap)
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    Return
}

addBorder2Bitmap(ByRef pBitmap, aX, aY, bgrColor:=0) {
    ; unused function
    Gdip_GetImageDimensions(pBitmap, imgW, imgH)
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW + aX*2, imgH + aY*2, coreDesiredPixFmt)
    If newBitmap
    {
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
       {
          If bgrColor
             trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor, 1)

          r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap, 0, 0, imgW + aX*2, imgH + aY*2)
          r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap, aX, aY)
          If (r2!="fail")
          {
             trGdip_DisposeImage(pBitmap, 1)
             pBitmap := newBitmap
             Return 1
          }
          Gdip_DeleteGraphics(G3)
       }
    }
}

applyPersonalizedColorsBMP(clipBMP, doBlur, blurStrength, applyColorFX) {
    canApplyFX := (PasteInPlaceHue!=0 || PasteInPlaceSaturation!=0) ? 1 : 0
    If (!isWinXP && canApplyFX=1 && applyColorFX=1)
    {
       If (BrushToolRandomHue>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomHue
          gR := Randomizer(-gR, gR, 2, 10)
          H := clampInRange(PasteInPlaceHue + gR, -180, 180)
       } Else H := PasteInPlaceHue
 
       If (BrushToolRandomSat>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomSat
          gR := Randomizer(-gR, gR, 2, 11)
          S := clampInRange(PasteInPlaceSaturation + gR, -100, 100)
       } Else S := PasteInPlaceSaturation

       zEffect := Gdip_CreateEffect(6, H, S, 0)
       Gdip_BitmapApplyEffect(clipBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    canApplyFX := (PasteInPlaceLight!=0 || PasteInPlaceGamma!=0) ? 1 : 0
    If (!isWinXP && canApplyFX=1 && applyColorFX=1)
    {
       If (BrushToolRandomLight>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomLight
          gR := Randomizer(-gR, gR, 8, 8)
          L := clampInRange(PasteInPlaceLight + gR, -255, 255)
          ; ToolTip, % gR "===" gRz "`n" startToolColor "`n" o_startToolColor , , , 2
       } Else L := PasteInPlaceLight

       If (BrushToolRandomDark>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomDark
          gR := Randomizer(-gR, gR, 8, 9)
          D := clampInRange(PasteInPlaceGamma + gR, -100, 100)
       } Else D := PasteInPlaceGamma

       zEffect := Gdip_CreateEffect(5, L, D)
       Gdip_BitmapApplyEffect(clipBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (blurStrength>2 && doBlur=1)
    {
       pEffect := Gdip_CreateEffect(1, blurStrength, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, clipBMP, blurStrength, pEffect, 0)
       Gdip_DisposeEffect(pEffect)
    }
}

corePasteInPlaceActNow(G2:=0, whichBitmap:=0, brushingMode:=0) {
    Critical, on
    Static prevImgCall, prevClipBMP, eImgW, eImgH, hasRotated, thisHasRan
         , lastInvoked := 1, blr := {0:0, 1:0, 2:15, 3:50, 4:120, 5:180, 6:254}

    If (G2="kill" && thisHasRan=1)
    {
       ; fnOutputDebug("remove transform tool caches")
       thisHasRan := 0
       LoadCachableBitmapFromFile("kill")
       realtimePasteInPlaceRotator("kill", 2, lol)
       realtimePasteInPlaceBlurrator("kill", 2, lol)
       realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
       getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
       If (keepUserPaintAlphaMask!=1)
          userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted, 1)
       viewportIDstampBMP := ""
       Return
    }

    If (doImgEditLivePreview!=1 && !G2) || (G2="kill")
       Return

    If (G2)
    {
       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       If (userClipBMPpaste && PasteInPlaceBlurAmount>1 && PasteInPlaceToolMode=0)
          QPV_SetGivenAlphaLevel(userClipBMPpaste, 1, 1)
       ; Else If (userClipBMPpaste && PasteInPlaceBlurAmount>1 && PasteInPlaceToolMode=1)
       ;    rz := addBorder2Bitmap(userClipBMPpaste, PasteInPlaceBlurAmount, PasteInPlaceBlurAmount)

       clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)
       If StrLen(clipBMP)<3
          Return "fail"

       If (PasteInPlaceToolMode!=1)
          flipBitmapAccordingToViewPort(clipBMP, 1)

       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
       previewMode := 0
    } Else
    {
       ; If (A_TickCount - lastInvoked < 60)
       ;    Return
       lastInvoked := A_TickCount
       G2 := 2NDglPG
       thisImgQuality := 5
       previewMode := 1
       Gdip_ResetClip(G2)
       ; trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, prevMaxSelX, prevMaxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
       thisImgCall := "a" getIDimage(currentFileIndex) currentFileIndex viewportStampBMP viewportIDstampBMP PasteInPlaceOrientation VPselRotation PasteInPlaceBlurAmount alphaMaskingMode alphaMaskClrAintensity alphaMaskClrBintensity alphaMaskColorReversed alphaMaskReplaceMode alphaMaskGradientScale alphaMaskGradientPosA alphaMaskGradientPosB alphaMaskGradientWrapped alphaMaskGradientAngle alphaMaskRefBMP alphaMaskOffsetX alphaMaskOffsetY PasteInPlaceLight PasteInPlaceHue PasteInPlaceSaturation PasteInPlaceGamma PasteInPlaceApplyColorFX PasteInPlaceBlendMode alphaMaskBMPchannel PasteInPlaceBlurEdgesSoft lastPaintEventID liveDrawingBrushTool brushingMode shearImgX shearImgY
       If (prevImgCall=thisImgCall && StrLen(prevClipBMP)>2)
       {
          hasCached := 1
          clipBMP := prevClipBMP
          If (brushingMode=1)
             Return [hasRotated, clipBMP]
       } Else
       {
          prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
          clipBMP := trGdip_CloneBitmap(A_ThisFunc, viewportStampBMP)
       }
    }
 
    thisHasRan := 1
    If (hasCached!=1)
    {
       fnOutputDebug("redraw: " A_ThisFunc)
       If (PasteInPlaceBlurAmount>0) || (PasteInPlaceToolMode=1 && (prevVPselRotation>0 || prevEllipseSelectMode>0 || previnnerSelectionCavityX>0.01 && previnnerSelectionCavityY>0.01))
       {
          realtimePasteInPlaceBlurrator(previewMode, clipBMP, newBitmap)
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       If (PasteInPlaceOrientation>1 || VPselRotation>0 || shearImgX!=0 || shearImgY!=0)
       {
          hasRotated := realtimePasteInPlaceRotator(previewMode, clipBMP, newBitmap)
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       } Else hasRotated := 0

       If (alphaMaskingMode>1 && brushingMode!=1)
       {
          ; thisStartZeit := A_TickCount
          thisIDu := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation VPselRotation alphaMaskClrAintensity alphaMaskClrBintensity alphaMaskingMode alphaMaskRefBMP alphaMaskReplaceMode alphaMaskGradientWrapped alphaMaskColorReversed alphaMaskGradientScale alphaMaskGradientAngle alphaMaskGradientPosA alphaMaskGradientPosB alphaMaskOffsetX alphaMaskOffsetY alphaMaskBMPchannel lastPaintEventID
          realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, thisIDu, newBitmap, 0, 0, 0, 0)
          ; ToolTip, % A_TickCount - thisStartZeit, , , 2
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       applyPersonalizedColorsBMP(clipBMP, 0, 0, PasteInPlaceApplyColorFX)
    }

    Gdip_GetImageDimensions(clipBMP, oImgW, oImgH)
    PasteInPlaceCalcObjSize(previewMode, hasRotated, oImgW, oImgH, imgSelW, imgSelH, VPselRotation, ResizedW, ResizedH)
    If (PasteInPlaceEraseInitial=1 && brushingMode!=1)
       PasteInPlaceEraseArea(G2, previewMode)

    Gdip_ResetClip(G2)
    vPobju := testSelectionLargerThanViewport()
    If (previewMode=1 && brushingMode!=1)
       Gdip_SetClipRect(G2, 0, 0, vPobju.mainWidth, vPobju.mainHeight, 0)

    If (PasteInPlaceCropSel>1 && brushingMode!=1)
    {
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, PasteInPlaceCropSel - 1, VPselRotation + PasteInPlaceCropAngular, rotateSelBoundsKeepRatio)
       Gdip_SetClipPath(G2, pPath, 1)
    }

    PasteInPlaceCalcObjCoords(imgSelW, imgSelH, ResizedW, ResizedH, imgSelPx, imgSelPy)
    If (PasteInPlaceBlendMode>1 && isNumber(PasteInPlaceBlendMode)) || (userimgGammaCorrect=1 && previewMode=1 && PasteInPlaceEraseInitial=0)
       o_bgrBMP := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, ResizedW, ResizedH, 0, ResizedW, ResizedH)

    If (PasteInPlaceBlendMode>1 && isNumber(PasteInPlaceBlendMode))
    {
       thisImgTempQuality := (userimgQuality=1 && previewMode!=1) ? 3 : 5
       If (oImgW!=ResizedW || oImgH!=ResizedH)
       {
          ; fnOutputDebug("blend mode resizing")
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, clipBMP, ResizedW, ResizedH, 0, thisImgQuality, 0, 0)
          If StrLen(tempBMP)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := tempBMP
          }

          Gdip_GetImageDimensions(clipBMP, oImgW, oImgH)
       }

       If StrLen(o_bgrBMP)>2
          Gdip_GetImageDimensions(o_bgrBMP, dgimgW, dgimgH)

       If (dgImgW!=ResizedW || dgImgH!=ResizedH)
       {
          ; fnOutputDebug("o_bgr resizing")
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, o_bgrBMP, ResizedW, ResizedH, 0, thisImgQuality, 0, 0)
          If StrLen(tempBMP)>2
          {
             trGdip_DisposeImage(o_bgrBMP, 1)
             o_bgrBMP := tempBMP
          }
       }

       BlurAmount := blr[PasteInPlaceGlassy]
       If (imgSelOutViewPort=1 || vPobju.isLarger=1)
       {
          BlurAmount := 0
       } Else If (previewMode=1)
       {
          MouseCoords2Image(imgSelPx, imgSelPx, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX1, kY1)
          MouseCoords2Image(imgSelPx + ResizedW, imgSelPy + ResizedH, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX2, kY2)
          kimgSelW := max(kX1, kX2) - min(kX1, kX2)
          kimgSelH := max(kY1, kY2) - min(kY1, kY2)
          msize := (kimgSelW + kimgSelH)//2
          rsize := (ResizedW + ResizedH)//2
          BlurAmount := Round(BlurAmount * (rsize / msize))
       }

       thisFXstate := "a" whichBitmap getVPselIDs("saiz-vpos") previewMode BlurAmount "a" imgSelPx imgSelPy imgSelW imgSelH currentFileIndex getIDimage(currentFileIndex) oImgW oImgH  currentUndoLevel currentSelUndoLevel FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode undoLevelsRecorded UserMemBMP ViewPortBMPcache getIDvpFX()
       ; bgrBMP := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, ResizedW, ResizedH, BlurAmount)
       If (StrLen(o_bgrBMP)>2 && BlurAmount>1)
          bgrBMP := applyVPeffectsAdvOnBMP(o_bgrBMP, previewMode, thisFXstate, 0, 0, BlurAmount, 0)
       Else If StrLen(o_bgrBMP)>2
          bgrBMP := trGdip_CloneBitmap(A_ThisFunc, o_bgrBMP)

       If StrLen(bgrBMP)>2
       {
          ; fnOutputDebug("blend mode calculations")
          If (previewMode!=1)
             setWindowTitle("Applying blending mode")
          thisStartZeit := A_TickCount
          factoru := (previewMode=1) ? 2 : 3
          delayu := (previewMode=1) ? -1 : 2
          threads := (previewMode=1) ? realSystemCores : 0
          zr := QPV_BlendBitmaps(bgrBMP, clipBMP, PasteInPlaceBlendMode - 1, threads)
       }
    }

    ; Gdip_GetImageDimensions(clipBMP, gimgW, gimgH)
    ; Gdip_GetImageDimensions(bgrBMP, wgimgW, wgimgH)
    ; Gdip_BlendBitmaps(bgrBMP, clipBMP, PasteInPlaceBlendMode - 1)
    ; fnOutputDebug("[" clipBMP "] " gImgW "==" gImgH " | [" bgrBMP "] "  wgImgW "==" wgImgH " | [" o_bgrBMP "] " dgImgW "==" dgImgH " | [target] " ResizedW "==" ResizedH)
    thisBMP := (StrLen(bgrBMP)>2 && PasteInPlaceBlendMode>1) ? bgrBMP : clipBMP
    If (brushingMode=1 && previewMode=1)
    {
       prevImgCall := ""
       prevClipBMP := clipBMP
       ; trGdip_DisposeImage(o_bgrBMP, 1)
       Return [hasRotated, thisBMP, bgrBMP, o_bgrBMP]
    }

    If (userimgGammaCorrect=1 && previewMode=1 && PasteInPlaceEraseInitial=0)
    {
       ; fnOutputDebug("gamma correct: " A_ThisFunc)
       ; bgrBMPu := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, ResizedW, ResizedH, 0, ResizedW, ResizedH)
       If o_bgrBMP
       {
          trGdip_DrawImage(A_ThisFunc, G2, o_bgrBMP, imgSelPx, imgSelPy, ResizedW, ResizedH)
          Gdip_SetCompositingQuality(G2, 2)
       }
    }

    setWindowTitle("Scaling image to selection area")
    thisOpacity := (PasteInPlaceOpacity>255) ? (PasteInPlaceOpacity - 245)/10 : PasteInPlaceOpacity/255
    If (thisBMP && G2)
       r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, ResizedW, ResizedH, , , , , thisOpacity)

    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)
    trGdip_DisposeImage(o_bgrBMP, 1)

    Gdip_ResetClip(G2)
    trGdip_DisposeImage(bgrBMP, 1)
    If (bgrBMP=thisBMP && PasteInPlaceEraseInitial=1)
       PasteInPlaceEraseArea(G2, previewMode)

    setWindowTitle(pVwinTitle, 1)
    If (previewMode=1)
    {
       If (PasteInPlaceCropSel>1)
       {
          Gdip_SetPenWidth(pPen1d, imgHUDbaseUnit//11)
          Gdip_DrawPath(G2, pPen1d, pPath)
       }

       lastInvoked := A_TickCount
       thisImgQuality := (userimgQuality=1) ? 7 : 5
       prevImgCall := thisImgCall
       prevClipBMP := clipBMP
       ; trGdip_DisposeImage(clipBMP, 1)
       ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
    } Else
    {
       trGdip_DisposeImage(clipBMP, 1)
       ; userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       ; viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    }

    Gdip_DeletePath(pPath)
}

PasteInPlaceCalcObjCoords(imgSelW, imgSelH, ResizedW, ResizedH, ByRef imgSelPx, ByRef imgSelPy) {
    If (PasteInPlaceAlignment=2)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
    } Else If (PasteInPlaceAlignment=3)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)//2
       imgSelPy := imgSelPy + (imgSelH - ResizedH)//2
    } Else If (PasteInPlaceAlignment=4)
    {
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    } Else If (PasteInPlaceAlignment=5)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    }

    imgSelPx := Round(imgSelPx)
    imgSelPy := Round(imgSelPy)
}

PasteInPlaceCalcObjSize(previewMode, hasRotated, oImgW, oImgH, imgSelW, imgSelH, anglu, ByRef ResizedW, ByRef ResizedH) {
    calcIMGdimensions(oImgW, oImgH, imgSelW, imgSelH, ResizedW, ResizedH)
    If (previewMode=1)
    {
       Gdip_GetImageDimensions(userClipBMPpaste, qImgW, qImgH)
       If (anglu>0 && hasRotated=1)
       {
          If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
             Gdip_GetRotatedEllipseDimensions(qImgW, qImgH, anglu, qImgW, qImgH)
          Else
             Gdip_GetRotatedDimensions(qImgW, qImgH, anglu, qImgW, qImgH)
       }
    }

    If (PasteInPlaceAdaptMode=3)
    {
       ResizedW := oImgW
       ResizedH := oImgH
       If (previewMode=1)
       {
          If (PasteInPlaceAdaptMode=3)
          {
             ; fnOutputDebug("hello9")
             Gdip_GetImageDimensions(userClipBMPpaste, ResizedW, ResizedH)
             If (anglu>0 && hasRotated=1)
             {
                If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
                   Gdip_GetRotatedEllipseDimensions(ResizedW, ResizedH, anglu, ResizedW, ResizedH)
                Else
                   Gdip_GetRotatedDimensions(ResizedW, ResizedH, anglu, ResizedW, ResizedH)
             }
          }
          ResizedW := ResizedW * zoomLevel
          ResizedH := ResizedH * zoomLevel
       }
    } Else If (PasteInPlaceAdaptMode=2)
    {
       ResizedW := imgSelW
       ResizedH := imgSelH
    }

    If isImgSizeTooLarge(ResizedW, ResizedH)
       calcIMGdimensions(ResizedW, ResizedH, 32500, 32500, ResizedW, ResizedH)

     ResizedW := Round(ResizedW), ResizedH := Round(ResizedH)
}

getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, imgSelW, imgSelH, BlurAmount:=0, fimgW:=0, fimgH:=0) {
    Static prevBMPu, prevBlurredBMP, prevState, prevFXid
    If (previewMode="kill")
    {
       prevState := prevFXid := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
       Return
    }

    If (previewMode=1)
    {
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       thisFXid := decideGDIPimageFX(matrix, imageAttribs, pEffect)
       ; ToolTip, % thisFXid "`n" matrix , , , 2
       thisFXid .= (BlurAmount>1) ? "." BlurAmount zoomLevel : "."
       thisFXid .= "Z" FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode fImgW fImgH

       ; zPx := (selDotX<0 && selDotAx>mainWidth) ? 0 : imgSelPx
       ; zPy := (selDotY<0 && selDotAy>mainHeight) ? 0 : imgSelPy
       thisState := "a" imgSelPx imgSelPy imgSelW imgSelH fImgW fImgH currentFileIndex getIDimage(currentFileIndex) oImgW oImgH   currentUndoLevel currentSelUndoLevel FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode undoLevelsRecorded UserMemBMP ViewPortBMPcache
       ; ToolTip, % thisState , , , 2
       If (thisFXid=prevFXid && thisState=prevState && StrLen(prevBMPu)>2)
       {
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeImageAttributes(imageAttribs)
          newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
          Return newBitmap
       }

       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       If (thisFXid!=prevFXid || StrLen(prevBlurredBMP)<3)
       {
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
          If StrLen(ViewPortBMPcache)>2
          {
             prevBlurredBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          } Else
          {
             Gdip_DisposeEffect(pEffect)
             Gdip_DisposeImageAttributes(imageAttribs)
             prevFXid := prevState := ""
             Return
          }

          If (pEffect && prevBlurredBMP)
          {
             Gdip_BitmapApplyEffect(prevBlurredBMP, pEffect)
             Gdip_DisposeEffect(pEffect)
          }

          If (imageAttribs && prevBlurredBMP)
          {
             G2 := trGdip_GraphicsFromImage(A_ThisFunc, prevBlurredBMP, 3)
             If G2
                r1 := trGdip_DrawImage(A_ThisFunc, G2, prevBlurredBMP,,,,,,,,,,, imageAttribs)
             Gdip_DeleteGraphics(G2)
             Gdip_DisposeImageAttributes(imageAttribs)
          }

          If (BlurAmount>1 && prevBlurredBMP)
          {
             BlurAmount := Round(BlurAmount*zoomLevel)
             zEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, prevBlurredBMP, BlurAmount, zEffect, 1)
             Gdip_DisposeEffect(zEffect)
          }
          prevFXid := thisFXid
       } Else
       {
          Gdip_DisposeImageAttributes(imageAttribs)
          Gdip_DisposeEffect(pEffect)
       }

       thisBMP := prevBlurredBMP
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0,1)
       If (minimizeMemUsage=1 && StrLen(prevBlurredBMP)>2)
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
       ; ToolTip, % zBitmap "==" imgSelPx "==" imgSelPy "`n" imgSelW "--" imgSelH , , , 2
       thisImgTempQuality := (userimgQuality=1) ? 3 : 5
       Gdip_GetImageDimensions(zBitmap, w, h)
       ; ToolTip, % w "=" h "`n" fImgW "=" fImgH "`n" imgSelW "=" imgSelH , , , 2

       If ((fImgW!=w || fImgH!=h) && zBitmap && fImgW>1 && fImgH>1)
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, fImgW, fImgH, 0, thisImgQuality, 0, 0)
       Else If ((oImgW!=imgSelW || oImgH!=imgSelH) && zBitmap && (!fImgW || !fImgH))
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, oImgW, oImgH, 0, thisImgQuality, 0, 0)

       If StrLen(tempBMP)>2
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := tempBMP
       }

       fnOutputDebug("redraw: " A_ThisFunc)
       ; SoundBeep 400,90
       prevState := (minimizeMemUsage=1) ? 0 : thisState
       prevBMPu := (minimizeMemUsage=1) ? 0 : trGdip_CloneBitmap(A_ThisFunc, zBitmap)
       Return zBitmap
    }

    whichBitmap := StrLen(UserMemBMP)>3 ? UserMemBMP : useGdiBitmap()
    If (imgFxMode>1)
       whichBitmap := useGdiBitmap()

    If !whichBitmap
    {
       SoundBeep , 300, 100
       addJournalEntry(A_ThisFunc "(): ERROR. No bitmap to process.")
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, aimgW, aimgH)
    MouseCoords2Image(imgSelPx, imgSelPy, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX1, imgY1)
    MouseCoords2Image(imgSelPx + imgSelW, imgSelPy + imgSelH, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX2, imgY2)

    ; givenCoords := imgSelPx//zoomLevel "|" imgSelPy//zoomLevel "|" Round((imgSelPx + imgSelW)/zoomLevel) "|" Round((imgSelPy + imgSelH)/zoomLevel)
    givenCoords := imgX1 "|" imgY1 "|" imgX2 "|" imgY2 
    calcImgSelection2bmp(1, aimgW, aimgH, Round(aimgW*zoomLevel), Round(aimgH*zoomLevel), dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0)
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, oImgW, oImgH, coreDesiredPixFmt)
    If warnUserFatalBitmapError(newBitmap, A_ThisFunc)
       Return

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1)
    QPV_SetGivenAlphaLevel(zBitmap, 2, 1)

    If (pEffect && zBitmap)
       Gdip_BitmapApplyEffect(zBitmap, pEffect)

    Gdip_DisposeEffect(pEffect)
    Gdip_GetImageDimensions(zBitmap, gimgW, gimgH)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 3)
    If G2
       r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0, oImgW, oImgH, 0, 0, gimgW, gimgH,,, imageAttribs)

    trGdip_DisposeImage(zBitmap, 1)
    Gdip_DisposeImageAttributes(imageAttribs)
    Gdip_DeleteGraphics(G2)
    If (!G2 || !zBitmap)
    {
       trGdip_DisposeImage(newBitmap, 1)
       Return
    }

    If (BlurAmount>1 && G2)
    {
       BlurAmount := Round(BlurAmount)
       zEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, newBitmap, BlurAmount, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    prevState := 0
    Return newBitmap
}

destroyGDIfileCache(remAll:=1, makeBackup:=0) {
    If (remAll=0)
    {
       imgPath := StrReplace(getIDimage(currentFileIndex), "||")
       MD5name := generateThumbName(imgPath, 1)
       If InStr(gdiBitmapIDcall, "a1" MD5name imgPath)
       {
          If (makeBackup=1)
          {
             mainCall := SubStr(gdiBitmapIDcall, 3)
             gdiBitmapIDcall := "a0" . mainCall
             gdiBitmap := cloneGDItoMem(A_ThisFunc, gdiBitmap)
             gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
             gdiBitmap := xBitmap
             gdiBitmapIDentire := gdiBitmapIDcall xBitmap
          } Else gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
       }

       If InStr(BprevImgCall, "1" MD5name imgPath)
       {
          BprevImgCall := ""
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       }

       If InStr(AprevImgCall, "1" MD5name imgPath)
       {
          AprevImgCall := ""
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       }

       If (!AprevImgCall && mainCall && makeBackup=1)
       {
          AprevImgCall := gdiBitmapIDcall
          AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       } Else If (!BprevImgCall && mainCall && makeBackup=1)
       {
          BprevImgCall := gdiBitmapIDcall
          BprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       }

       If InStr(idGDIcacheSRCfileA, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileA := ""
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       }

       If InStr(idGDIcacheSRCfileB, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileB := ""
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       }
    } Else
    {
       If (SubStr(idGDIcacheSRCfileA, 1, 1)=1)
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       If (SubStr(idGDIcacheSRCfileB, 1, 1)=1)
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       If (SubStr(BprevImgCall, 1, 1)=1)
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       If (SubStr(AprevImgCall, 1, 1)=1)
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       If (SubStr(gdiBitmapIDcall, 1, 1)=1)
          gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)

       idGDIcacheSRCfileA := idGDIcacheSRCfileB := ""
       BprevImgCall := AprevImgCall := ""
       GDIcacheSRCfileA := GDIcacheSRCfileB := gdiBitmapIDcall := ""
    }
}

discardSRCfileCaches() {
    prevMD5nameA := prevMD5nameB := ""
    GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
    GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
    idGDIcacheSRCfileA := idGDIcacheSRCfileB := ""
    GDIcacheSRCfileA := GDIcacheSRCfileB := 
}

discardViewPortCaches() {
    ; GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
    ; GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
    AprevImgCall := BprevImgCall := ""
    BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
    AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
}

disposeCacheIMGs(dummy:=0) {
    gdiBitmapIDcall := ""
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
    If (dummy!="soft")
       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)

    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
    infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
}

MenuReturnIMGedit() {
   If (StrLen(UserMemBMP)>2 && imgIndexEditing>0)
      currentFileIndex := imgIndexEditing
   Else If prevLastImg[1, 1]
      currentFileIndex := clampInRange(prevLastImg[1, 1], 1, maxFilesIndex)

   MenuDummyToggleThumbsMode()
}

recordSelUndoLevelNow() {
   selectionCoords := Round(imgSelX1) "|" Round(imgSelY1) "|" Round(imgSelX2) "|" Round(imgSelY2) "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" VPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid "|" innerSelectionCavityX "|" innerSelectionCavityY
   totalSelUndos := Round(undoSelLevelsArray.Count())
   currentSelUndoLevel := clampInRange(currentSelUndoLevel, 0, totalSelUndos)
   newArray := []
   Loop, % currentSelUndoLevel
       newArray[A_Index] := undoSelLevelsArray[A_Index]
   
   totalSelUndos := Round(newArray.Count())
   If (newArray[totalSelUndos]!=selectionCoords)
   {
      newArray[totalSelUndos + 1] := selectionCoords
      currentSelUndoLevel := totalSelUndos + 1
      totalSelUndos++
   }
   undoSelLevelsArray := []
   undoSelLevelsArray := newArray.Clone()
   newArray := []
   ; ToolTip, % currentSelUndoLevel  " = l" , , , 2
}

decideUndoLevelsAccepted(imgW, imgH) {
   If (A_PtrSize!=4) 
      Return

   pixelz := imgW*imgH
   memUsage := (coreDesiredPixFmt="0x21808") ? pixelz*3 : pixelz*4
   memUsage := memUsage//1000
   preventUndoLevels := (memUsage*5>maxMemUndoLevels) ? 1 : 0
   ; ToolTip, % preventUndoLevels " = mem = " memUsage , , , 2
}

recordUndoLevelNow(actionu, recordedBitmap, dX:=0, dY:=0, forceAlpha:="x") {
   Static prevAct, lastInvoked := 1
   If (preventUndoLevels=1)
      Return

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   thisAct := actionu recordedBitmap whichBitmap minimizeMemUsage currentFileIndex getIDimage(currentFileIndex)
   if (prevAct=thisAct)
   {
      ; SoundBeep, 900, 900
      addJournalEntry(A_ThisFunc "(" actionu "): already recorded undo state")
      Return
   }

   HasAlpha := (forceAlpha!="x") ? forceAlpha : currIMGdetails.HasAlpha
   selectionCoords := imgSelX1 "|" imgSelY1 "|" imgSelX2 "|" imgSelY2 "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" VPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid
   If (StrLen(undoLevelsArray[1, 1])<3 && StrLen(whichBitmap)>2 && minimizeMemUsage!=1)
   {
      thisBMP := trGdip_CloneBitmap(A_ThisFunc "(init)", whichBitmap)
      If thisBMP
      {
         prevAct := thisAct
         recordSelUndoLevelNow()
         undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
         currentUndoLevel := 1
         If (undoLevelsRecorded=0)
            undoLevelsRecorded := 1
      }
   }

   If (actionu="init")
   {
      setImageLoading()
      If (minimizeMemUsage=1)
      {
         trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
         thisBMP := trGdip_CloneBitmap(A_ThisFunc "(init)", whichBitmap)
         If thisBMP
         {
            prevAct := thisAct
            currentUndoLevel := 1
            If (undoLevelsRecorded=0)
               undoLevelsRecorded := 1
            undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
         }
      }

      lastInvoked := A_TickCount
      Return
   }

   prevAct := 0
   HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
   If (A_PtrSize=8 && undoLevelsRecorded>3)
   {
      systemMemInfo := GlobalMemoryStatusEx()
      mamUsage := GetProcessMemoryUsage(QPVpid)
      thisMemoryLoad := Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
      If isWinXP
         thisMemoryLoad := 99

      If (thisMemoryLoad<85 && systemMemInfo.MemoryLoad<85 && hasReachedMaxUndoLevels=0)
         maxUndoLevels := 100
      Else
         maxUndoLevels := hasReachedMaxUndoLevels := undoLevelsRecorded
   }

   ; currentSelUndoLevel := totalSelUndos := Round(undoSelLevelsArray.Count() + 1)
   ; undoSelLevelsArray[totalSelUndos] := selectionCoords
   recordSelUndoLevelNow()
   imgIndexEditing := currentFileIndex
   ; ToolTip, % currentSelUndoLevel " = p" , , , 2
   If (minimizeMemUsage=1)
   {
      currentUndoLevel := 2
      undoLevelsRecorded := 2
      trGdip_DisposeImage(undoLevelsArray[2, 1], 1)
      undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(L2)", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
   } Else
   {
      If (currentUndoLevel>=maxUndoLevels)
      {
         trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
         undoLevelsArray.RemoveAt(1)
         undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(Lmax)", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
      } Else
      {
         currentUndoLevel++
         undoLevelsRecorded++
         If (undoLevelsRecorded>currentUndoLevel)
            undoLevelsRecorded := currentUndoLevel

         undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(Lx" currentUndoLevel ")", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
         Loop, % maxUndoLevels + 1 - currentUndoLevel
         {
             trGdip_DisposeImage(undoLevelsArray[currentUndoLevel + A_Index, 1], 1)
             undoLevelsArray[currentUndoLevel + A_Index, 1] := ""
         }
      }
   }

   currentImgModified := 1
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, TriggerMenuBarUpdate, -50
   If (A_TickCount - lastInvoked>950) && (liveDrawingBrushTool=0 && AnyWindowOpen!=66)
      SoundBeep , 900, 100
}

terminateIMGediting() {
   lastZeitIMGsaved := []
   If (StrLen(UserMemBMP)<3 && undoLevelsRecorded>0 && currentFileIndex!=imgIndexEditing && minimizeMemUsage=1)
   {
      UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
      userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
      viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
      viewportIDstampBMP := ""
      Loop, 3
      {
          trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
          undoLevelsArray[A_Index, 1] := ""
      }

      gdipObjectsStats(1, "recordUndoLevelNow")
      currentImgModified := 0
      undoSelLevelsArray := []
      currentSelUndoLevel := 1
      undoVectorShapesLevelsArray := []
      currentVectorUndoLevel := 1
      customShapeHasSelectedPoints := 0
      currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
      interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
      interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
      SetTimer, TriggerMenuBarUpdate, -50
      Return
   }

   If (StrLen(UserMemBMP)<3 && undoLevelsRecorded<1) || (currentFileIndex=imgIndexEditing && undoLevelsRecorded>1 && currentImgModified=2)
      Return

   currentImgModified := 0
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
   viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
   viewportIDstampBMP := ""
   imgIndexEditing := 0

   Loop, 200
   {
       trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
       undoLevelsArray[A_Index, 1] := ""
   }

   gdipObjectsStats(1, "recordUndoLevelNow")
   fnOutputDebug(A_ThisFunc "(): undo/redo levels purged")
   currentSelUndoLevel := 1
   undoSelLevelsArray := []
   currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   SetTimer, TriggerMenuBarUpdate, -50
   maxUndoLevels := (A_PtrSize=8) ? 100 : 2
}

isAlphaMaskPartialWin() {
   Return isVarEqualTo(AnyWindowOpen, 74, 66, 55, 25)
}

isAlphaMaskWindow() {
   Return isVarEqualTo(AnyWindowOpen, 23, 24, 31, 32, 70)
}

isNowAlphaPainting() {
   Return (isAlphaMaskWindow()=1 && liveDrawingBrushTool=1 && isImgEditingNow()=1) ? 1 : 0
}

performUndoAlphaPainting() {
   If StrLen(userPrevAlphaMaskBmpPainted)>2
   {
      z := userAlphaMaskBmpPainted
      userAlphaMaskBmpPainted := userPrevAlphaMaskBmpPainted
      userPrevAlphaMaskBmpPainted := z
      realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
      SetTimer, livePreviewsImageEditing, -100
   }
}

ImgUndoAction(dummy:=0) {
   Critical, on
   If (isNowAlphaPainting()=1)
   {
      performUndoAlphaPainting()
      Return
   } Else If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1)
      Return

   If (StrLen(undoLevelsArray[currentUndoLevel - 1, 1])<3) || (imageLoading=1)
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not recorded`n" : ""
      showTOOLtip(friendly "Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel - howFar, 1, undoLevelsRecorded)
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, undoLevelsArray[currentUndoLevel, 1])
   currIMGdetails.HasAlpha := undoLevelsArray[currentUndoLevel, 5]
   ; restorePreviousSelections(undoLevelsArray[currentUndoLevel, 4])

   SetTimer, RefreshImageFile, -325
   showTOOLtip("Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgSelUndoAct(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
      Return

   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (StrLen(undoSelLevelsArray[currentSelUndoLevel - 1])<3 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   ; currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel - howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", A_ThisFunc, 1, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgSelRedoAct(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
      Return

   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (StrLen(undoSelLevelsArray[currentSelUndoLevel + 1])<3 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   ; currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel + howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", A_ThisFunc, 1, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgVectorRedoAct() {
   Critical, on
   If (drawingShapeNow!=1)
      Return

   totalUndos := Round(undoVectorShapesLevelsArray.Count())
   If !IsObject(undoVectorShapesLevelsArray[currentVectorUndoLevel + 1])
   {
      showTOOLtip("Shape redo [ " currentVectorUndoLevel " / " totalUndos " ]", 0, 0, currentVectorUndoLevel/totalUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentVectorUndoLevel := clampInRange(currentVectorUndoLevel + 1, 1, totalUndos)
   restoreGivenVectorUndoLevel(currentVectorUndoLevel)
   showTOOLtip("Shape redo [ " currentVectorUndoLevel " / " totalUndos " ]", A_ThisFunc, 1, currentVectorUndoLevel/totalUndos)
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, -25
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgVectorUndoAct() {
   Critical, on
   If (drawingShapeNow!=1)
      Return

   totalUndos := Round(undoVectorShapesLevelsArray.Count())
   If !IsObject(undoVectorShapesLevelsArray[currentVectorUndoLevel - 1])
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not recorded`n" : ""
      showTOOLtip(friendly "Shape undo [ " currentVectorUndoLevel " / " totalUndos " ]", 0, 0, currentVectorUndoLevel/totalUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentVectorUndoLevel := clampInRange(currentVectorUndoLevel - 1, 1, totalUndos)
   restoreGivenVectorUndoLevel(currentVectorUndoLevel)
   showTOOLtip("Shape undo [ " currentVectorUndoLevel " / " totalUndos " ]", A_ThisFunc, 1, currentVectorUndoLevel/totalUndos)
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, -25
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

recordVectorUndoLevels(mainArray, VPcoordsArray) {
   If (preventUndoLevels=1)
      Return

   undos := undoVectorShapesLevelsArray.Count()
   bonus := 0
   If (currentVectorUndoLevel<undos && undos>0)
   {
      bonus := 2
      Loop, % maxVectorUndoLevels
      {
         undos--
         undoVectorShapesLevelsArray.Pop()
         If (undos<currentVectorUndoLevel + 1)
            Break
      }
   }

   currentVectorUndoLevel := undoVectorShapesLevelsArray.Count()
   If (currentVectorUndoLevel>maxVectorUndoLevels)
      undoVectorShapesLevelsArray.RemoveAt(1)

   symmetryPointIndex := prevVectorShapeSymmetryMode[1, 1]
   newArrayu := [mainArray, VPcoordsArray, zoomLevel, IMGdecalageX, IMGdecalageY, imageAligned, IMGresizingMode, CustomShapeSymmetry, vpSymmetryPointX, vpSymmetryPointXdp, vpSymmetryPointY, vpSymmetryPointYdp, CustomShapeLockedSymmetry, customShapeHasSelectedPoints, symmetryPointIndex, bezierSplineCustomShape]
   undoVectorShapesLevelsArray.Push(newArrayu)
   currentVectorUndoLevel := undoVectorShapesLevelsArray.Count()
   ; ToolTip, % "l=" currentVectorUndoLevel , , , 2
}

restoreGivenVectorUndoLevel(levelu) {
   If !IsObject(undoVectorShapesLevelsArray[levelu])
      Return

   a := undoVectorShapesLevelsArray[levelu, 1]
   b := undoVectorShapesLevelsArray[levelu, 2]
   customShapePoints := a.Clone()
   initialDrawingStartCoords := b.Clone()
   zoomLevel := undoVectorShapesLevelsArray[levelu, 3]
   IMGdecalageX := undoVectorShapesLevelsArray[levelu, 4]
   IMGdecalageY := undoVectorShapesLevelsArray[levelu, 5]
   imageAligned := undoVectorShapesLevelsArray[levelu, 6]
   IMGresizingMode := undoVectorShapesLevelsArray[levelu, 7]
   CustomShapeSymmetry := undoVectorShapesLevelsArray[levelu, 8]
   vpSymmetryPointX := undoVectorShapesLevelsArray[levelu, 9]
   vpSymmetryPointXdp := undoVectorShapesLevelsArray[levelu, 10]
   vpSymmetryPointY := undoVectorShapesLevelsArray[levelu, 11]
   vpSymmetryPointYdp := undoVectorShapesLevelsArray[levelu, 12]
   CustomShapeLockedSymmetry := undoVectorShapesLevelsArray[levelu, 13]
   customShapeHasSelectedPoints := undoVectorShapesLevelsArray[levelu, 14]
   prevVectorShapeSymmetryMode[1, 1] := undoVectorShapesLevelsArray[levelu, 15]
   bezierSplineCustomShape := undoVectorShapesLevelsArray[levelu, 16]
   dummyTimerDelayiedImageDisplay(100)
   ; stuffu := undoVectorShapesLevelsVPdataArray[levelu]
   ; adaptCustomShapeNewZoomLevel(0)
}

restorePreviousSelections(thisLevel) {
   selectionCoords := undoSelLevelsArray[thisLevel]
   ; ToolTip, % thisLevel " = k" , , , 2
   If !selectionCoords
      Return

   selectionPrefsArray := StrSplit(selectionCoords, "|")
   imgSelX1 := selectionPrefsArray[1], imgSelY1 := selectionPrefsArray[2]
   imgSelX2 := selectionPrefsArray[3], imgSelY2 := selectionPrefsArray[4]
   prcSelX1 := selectionPrefsArray[5], prcSelY1 := selectionPrefsArray[6]
   prcSelX2 := selectionPrefsArray[7], prcSelY2 := selectionPrefsArray[8]
   VPselRotation := selectionPrefsArray[9]
   rotateSelBoundsKeepRatio := selectionPrefsArray[10]
   EllipseSelectMode := selectionPrefsArray[11]
   LimitSelectBoundsImg := selectionPrefsArray[12]
   showSelectionGrid := selectionPrefsArray[13]
   innerSelectionCavityX := selectionPrefsArray[14]
   innerSelectionCavityY := selectionPrefsArray[15]
   currentSelUndoLevel := thisLevel
   ; currentImgModified := 1
}

ImgRedoAction(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1)
      Return

   If (isNowAlphaPainting()=1)
   {
      performUndoAlphaPainting()
      Return
   } Else If (StrLen(undoLevelsArray[currentUndoLevel + 1, 1])<3) || (imageLoading=1)
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not recorded, to limit memory usage`n" : ""
      showTOOLtip(friendly "Redo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel + howFar, 1, undoLevelsRecorded)
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, undoLevelsArray[currentUndoLevel, 1])
   currIMGdetails.HasAlpha := undoLevelsArray[currentUndoLevel, 5]
   ; restorePreviousSelections(undoLevelsArray[currentUndoLevel, 4])
   SetTimer, RefreshImageFile, -325
   showTOOLtip("Redo [ "  currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ToggleCorePixFmt() {
   friendly := (A_PtrSize=4 && A_is64BitOS) ? "`n`nPlease use the 64-bits edition of this application to enjoy a better experience for image editing and image viewing." : ""
   friendly .= "`n`nUpon application restart, the 32-bits RGBA mode will no longer be activated."
   coreDesiredPixFmt := (coreDesiredPixFmt="0x21808") ? "0xE200B" : "0x21808"
   If (A_PtrSize=4 && coreDesiredPixFmt="0xE200B")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now activated. " appTitle " will now have an increased memory usage. The maximum amount of usable memory on your system is 2 GB." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=4 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. " appTitle " will use less memory, but various image editing options are disabled." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=8 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. Please note, various image editing options are disabled in 24-bits RGB mode, including proper alpha channel support.`n`nUpon application restart, the 32-bits RGBA mode will be reactivated. This option is only meant help reduce memory usage for old systems.", 0, 0, "exclamation")

   RefreshImageFileAction()
}

alertReduceColorDepth() {
   If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1 && StrLen(UserMemBMP)<3)
      msgBoxWrapper(appTitle ": WARNING" , "PLEASE NOTE! The image you are about to edit is downscaled by " appTitle ". Press F5 to reload the original and then begin again to edit the image, at its original dimensions.`n`nTo disabled altogether downscaling, press Ctrl+Q in the main window.", 0, 0, "exclamation")

   pixFmt := currIMGdetails.PixelFormat  " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      r := msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel.", "&OK|&Activate 32-RGBA", 1, "exclamation")
   
   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit is at an unsupported color depth for editing: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost.", 0, 0, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", 0, 0, "exclamation")

   If InStr(r, "activate")
   {
      coreDesiredPixFmt := "0x26200A"
      If !undoLevelsRecorded
         RefreshImageFileAction()
   }

   If (currIMGdetails.TooLargeGDI=1 && StrLen(UserMemBMP)<3)
   {
      infoRes := "`nOriginal resolution: " currIMGdetails.Width " x " currIMGdetails.Height " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " imgW " x " imgH " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will edit it now at an automatically downscaled resolution:" newRes, 0, 0, "exclamation")
   }
}

alertReduceSaveColorDepth() {
   msgResult := "continue"
   If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1 && StrLen(UserMemBMP)<3)
      msgResult := msgBoxWrapper(appTitle ": WARNING" , "PLEASE NOTE! The image you are about to save is downscaled by " appTitle ". Press F5 to reload the original and then save the modified image, at original dimensions.`n`nTo disabled altogether downscaling, press Ctrl+Q in the main window.", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   pixFmt := currIMGdetails.PixelFormat  " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel before editing or saving the image.", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave is originally at an unsupported color depth: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost. ", "&Continue|C&ancel", 1, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (currIMGdetails.TooLargeGDI=1 && StrLen(UserMemBMP)<3)
   {
      infoRes := "`nOriginal resolution: " currIMGdetails.Width " x " currIMGdetails.Height " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " imgW " x " imgH " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will be saving an automatically downscaled resolution:" newRes, "&Continue|C&ancel", 1, "exclamation")
   }
   If !InStr(msgResult, "continue")
      Return 1
}

mergeViewPortEffectsImgEditing(funcu:=0, recordUndoAfter:=1, applyOnArea:=0, allowOutside:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    funcuInfo := funcu ? "`n" funcu "()" : ""
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1)
    {
       addJournalEntry(A_ThisFunc "() error - invoked by " funcu "() operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return 1
    }

    If (editingSelectionNow=1)
    {
       If testSelectOutsideImgEntirely(whichBitmap)
       {
          If (allowOutside!=1)
          {
             SoundBeep, 300, 100
             showDelayedTooltip("WARNING: Invalid image selection area. It seems to be entirely outside the image boundaries." funcuInfo, 0, 450)
             Return 1
          }
          selOutsideEntirely := 1
       }
    }

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    If isImgSizeTooLarge(imgW, imgH)
    {
       SoundBeep, 300, 100
       showDelayedTooltip("ERROR: Image editing is disabled`nThe document size is too large" funcuInfo, 0, 450)
       Return 1
    }

    alertReduceColorDepth()
    ; mustOpenStartFolder := ""
    imgIndexEditing := currentFileIndex
    currentImgModified := 1
    setImageLoading()
    showTOOLtip("Processing image, please wait" funcuInfo)
    ; If markedSelectFile
    ;    dropFilesSelection()

    discardViewPortCaches()
    ; msgbox % UserMemBMP "---" gdiBitmap
    If StrLen(gdiBitmap)>2
    {
       UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
       UserMemBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, gdiBitmap)
    } 

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If (pEffect || imageAttribs)
       recordUndoLevelNow("init", 0)

    Gdip_GetImageDimensions(UserMemBMP, imgW, imgH)
    If (editingSelectionNow=1 && applyOnArea=1 && selOutsideEntirely!=1)
    {
       nImgSelX1 := min(imgSelX1, imgSelX2)
       nImgSelY1 := min(imgSelY1, imgSelY2)
       kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
       kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
       isEntire := (kimgSelW=imgW && kimgSelH=imgH && nImgSelX1=0 && nImgSelY1=0) ? 1 : 0
       allowOnArea := !isEntire
    }

    If (allowOnArea=1)
    {
       calcImgSelection2bmp(1, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       pPath := createImgSelPath(1, 0, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
       If pPath
       {
          pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
          dummyBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, UserMemBMP, pB.xa, pB.ya, pB.w, pB.h, 0, 0, 1)
       }

       If dummyBMP
       {
          dummyBMP := applyVPeffectsOnBMP(dummyBMP)
          carvePathFromBitmap(dummyBMP, pPath, pB.x, pB.y, 4)
          carvePathFromBitmap(UserMemBMP, pPath, pB.x, pB.y, 0)
          G4 := trGdip_GraphicsFromImage(A_ThisFunc, UserMemBMP)
          r1 := trGdip_DrawImage(A_ThisFunc, G4, dummyBMP, pB.xa, pB.ya)
          Gdip_DeleteGraphics(G4)
          trGdip_DisposeImage(dummyBMP, 1)
       } Else r1 := "fail"

       Gdip_DeletePath(pPath)
    } Else UserMemBMP := applyVPeffectsOnBMP(UserMemBMP)
   
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeImageAttributes(imageAttribs)
    If ((pEffect || imageAttribs) && StrLen(UserMemBMP)>2 && recordUndoAfter!=0 && r1!="fail")
    {
       recordUndoLevelNow(0, UserMemBMP)
       disposeCacheIMGs("soft")
       ; gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, UserMemBMP)
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime//2
    usrColorDepth := imgFxMode := 1
    vpIMGrotation := 0 ; FlipImgH := FlipImgV := 0
}

CutSelectedArea() {
   If (thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   r := CopyImage2clip()
   If r
      Return

   Sleep, 350
   EraseAreaFader := 0
   EraseSelectedArea()
}

ApplyColorAdjustsSelectedArea(modus:=0) {
    Static prevFXmode := "n"
    If InStr(modus, "outside")
       modus := "outside"

    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    o_imgFxMode := imgFxMode
    If (imgFxMode>1)
       prevFXmode := imgFxMode
    Else If (prevFXmode!="n")
       imgFxMode := prevFXmode

    If (imgFxMode=1)
    {
       showTOOLtip("No viewport color adjustments to be applied on image`n`nPress F to cycle through modes`nor press U to open color adjustments panel")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisMode := (modus="outside") ? 0 : 1
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 0, thisMode)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       imgFxMode := o_imgFxMode
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(-1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       imgFxMode := o_imgFxMode
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    If !pPath
    {
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area`nUnable to create selection path")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    If (!gdiBitmap && preventUndoLevels=1)
    {
       hasCloned := 1
       o_gdiBitmap := Gdip_CloneBmpPargbArea(funcu, UserMemBMP)
    } Else o_gdiBitmap := gdiBitmap

    thisMode := (modus="outside") ? 0 : 4
    Gdip_SetClipPath(G2, pPath, thisMode)
    zBitmap := o_gdiBitmap ? o_gdiBitmap : undoLevelsArray[currentUndoLevel, 1] 
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    If (r0!="fail" && r1!="fail" && G2)
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    If hasCloned
       trGdip_DisposeImage(o_gdiBitmap, 1)

    SetTimer, RefreshImageFile, -25
    Return r1
}

AdjustColorsSelectedArea(prevFXmode:=0) {
    Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:16}
    thisBitsDepth := bitsOptions[DesaturateAreaLevels]

    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    If (prevFXmode<2 || !isNumber(prevFXmode))
    {
       showTOOLtip("No color adjustments to be applied on image`n`nPress U to open the color adjustments panel")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    o_imgFxMode := imgFxMode
    imgFxMode := 1
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 0, 0)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       imgFxMode := o_imgFxMode
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    calcImgSelection2bmp(-1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4, compositingQuality)
    If !G2
    {
       imgFxMode := o_imgFxMode
       showTOOLtip("Failed to apply the color adjustments to the image selected area")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    If !pPath
    {
       imgFxMode := o_imgFxMode
       showTOOLtip("Failed to apply the color adjustments to the image selected area`nUnable to create selection path")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h
    If (EraseAreaInvert=1)
    {
       imgSelPx := 0,     imgSelPy := 0
       imgSelW  := imgW,  imgSelH  := imgH
    }

    imgFxMode := prevFXmode
    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    thisOpacity := EraseAreaOpacity/255
    allowAlphaMasking := decideAlphaMaskingFeaseable(EraseAreaUseAlpha)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    thisMode := (EraseAreaInvert=1) ? 4 : 0
    Gdip_SetClipPath(G2, pPath, thisMode)
    If (EraseAreaOpacity>253 && allowAlphaMasking!=1)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    zBitmap := applyVPeffectsOnBMP(zBitmap)
    If (thisBitsDepth>1 && DesaturateAreaLevels>1 && imgFxMode>1)
    {
       E := Gdip_BitmapSetColorDepth(zBitmap, thisBitsDepth, DesaturateAreaDither)
       Gdip_BitmapSetColorDepth(zBitmap, 32)
    }

    If (allowAlphaMasking=1)
    {
       realtimePasteInPlaceAlphaMasker(0, zBitmap, "lol", newBitmap, 0, 0, 0, 0)
       If StrLen(newBitmap)>2
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := newBitmap
       }
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, imgSelPx, imgSelPy,,,,,,, thisOpacity)
    Gdip_DeleteGraphics(G2)
    Gdip_DeletePath(pPath)
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    If (r0!="fail" && r1!="fail" && G2)
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    trGdip_DisposeImage(zBitmap, 1)
    wasVPfxBefore := 0
    imgFxMode := o_imgFxMode
    SetTimer, RefreshImageFile, -25
    Return r1
}

InsertTextSelectedArea() {
    allowOutside := 0
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If ((imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH) && PasteInPlaceAutoExpandIMG=1 && whichBitmap && imgW && imgH)
       allowOutside := 1

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 1, 0, allowOutside)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 ||!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    If (allowOutside=1)
       hasRanExpand := performAutoExpandCanvas(imgW, imgH, whichBitmap)

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    startOperation := A_TickCount
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4,, compositingQuality)
    If !G2
    {
       showTOOLtip(A_ThisFunc "(): Failed to perform action. Graphics object error.")
       SoundBeep , 300, 100
       Return
    }

    o_imgSelPx := imgSelPx, o_imgSelPy := imgSelPy
    o_imgSelW := imgSelW, o_imgSelH := imgSelH

    Gdip_FromARGB("0xFF" TextInAreaBgrColor, A, R, G, B)
    bgrColor := Gdip_ToARGB(TextInAreaBgrOpacity, R, G, B)
    zBrush := Gdip_BrushCreateSolid(bgrColor)

    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 0)
    If obju[1]
    {
       textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
       trGdip_DisposeImage(obju[1], 1)
    }

    coreDesiredPixFmt := o_coreFmt
    Gdip_GetImageDimensions(textBoxu, zImgW, zImgH)
    Gdip_GetRotatedDimensions(zImgW, zImgH, VPselRotation, rnImgW, rnImgH)
    If (TextInAreaAlign=3)
       imgSelPx := X2 - rnImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx + imgSelW//2 - rnImgW//2

    If (TextInAreaValign=3)
       imgSelPy := Y2 - rnImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + imgSelH//2 - rnImgH//2

    If (VPselRotation>0)
    {
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, VPselRotation, ".")
       If StrLen(xBitmap)>3
       {
          trGdip_DisposeImage(textBoxu, 1)
          textBoxu := xBitmap
          Gdip_GetImageDimensions(textBoxu, zimgW, zimgH)
       }
    }

    tX := min(o_imgSelPx, imgSelPx)
    tY := min(o_imgSelPy, imgSelPy)
    wX := max(o_imgSelPx + o_imgSelW, imgSelPx + zImgW)
    hY := max(o_imgSelPy + o_imgSelH, imgSelPy + zImgH)
    tW := wX - tX
    tH := hY - tY
    ; fnOutputDebug(A_ThisFunc "(): " tX "," tY "," wX "," hY "," tW "," tH)
    If (TextInAreaBlendMode>1 || alphaMaskingMode>1)
    {
       bgrBMPu := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, tX, tY, tW, tH, 0, 0, 1)
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, tW, tH)
       Gr := Gdip_GraphicsFromImage(newBitmap)
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(Gr, 2)

       If (TextInAreaBlendMode=1)
          r1 := trGdip_DrawImage(A_ThisFunc, Gr, bgrBMPu)

       If (TextInAreaRoundBoxBgr=1 && TextInAreaFillSelArea=1)
          Gdip_FillRoundedRectanglePath(Gr, zBrush, 0, 0, tW, tH, min(tW, tH)//6)
       Else If (TextInAreaFillSelArea=1)
          Gdip_FillRectangle(Gr, zBrush, 0, 0, tW, tH)

       r1 := trGdip_DrawImage(A_ThisFunc, Gr, textBoxu, imgSelPx - tX, imgSelPy - tY, zimgW, zimgH)
       Gdip_DeleteGraphics(Gr)
       If (TextInAreaBlendMode>1)
          zr := QPV_BlendBitmaps(bgrBMPu, newBitmap, TextInAreaBlendMode - 1, 0)

       If (alphaMaskingMode>1)
       {
          thisIDu := "a" previewMode
          fBitmap := (TextInAreaBlendMode>1) ? bgrBMPu : newBitmap
          realtimePasteInPlaceAlphaMasker(0, fBitmap, thisIDu, maskedBitmap)
       }

       gBitmap := (StrLen(maskedBitmap)>2) ? maskedBitmap : bgrBMPu
       If (TextInAreaBlendMode=1)
       {
          Gdip_SetClipRect(G2, tX, tY, tW, tH)
          Gdip_GraphicsClear(G2)
          Gdip_ResetClip(G2)
       }

       r2 := trGdip_DrawImage(A_ThisFunc, G2, gBitmap, tX, tY)
       ; fnOutputDebug(A_ThisFunc "(): " r1 "=" r2 "=" zr)
       trGdip_DisposeImage(newBitmap, 1)
       trGdip_DisposeImage(bgrBMPu, 1)
       trGdip_DisposeImage(maskedBitmap, 1)
    } Else
    {
       If (TextInAreaRoundBoxBgr=1 && TextInAreaFillSelArea=1)
          Gdip_FillRoundedRectanglePath(G2, zBrush, tX, tY, tW, tH, min(tW, tH)//6)
       Else If (TextInAreaFillSelArea=1)
          Gdip_FillRectangle(G2, zBrush, tX, tY, tW, tH)
       r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, zimgW, zimgH)
    }

    livePreviewInsertTextinArea("kill")
    trGdip_DisposeImage(textBoxu, 1)
    Gdip_DeleteGraphics(G2)
    Gdip_DeleteBrush(zBrush)
    zeitOperation := A_TickCount - startOperation
    If (r1!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    etaTime := SecToHHMMSS(Round(zeitOperation/1000, 3))
    addJournalEntry("Text drawn on image in: " etaTime)
    RefreshImageFile()
    If (hasRanExpand=1)
    {
       totalSelUndos := Round(undoSelLevelsArray.Count())
       currentSelUndoLevel := clampInRange(totalSelUndos, 1, totalSelUndos)
       restorePreviousSelections(currentSelUndoLevel)
       SetTimer, dummyRefreshImgSelectionWindow, -125
    }
}

livePreviewInsertTextinArea(actionu:=0, brushingMode:=0) {
    Critical, on
    Static lastInvoked := 1, prevBMPu, prevState, scaleuPreview := 1
    If (actionu="kill")
    {
       realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
       prevState := 0
       If StrLen(prevBMPu)>2
          prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    If (doImgEditLivePreview!=1 && brushingMode=0 || !AnyWindowOpen)
       Return

    If (forceLiveAlphaPreviewMode=1 && liveDrawingBrushTool=1)
    {
       livePreviewAlphaMasking("live")
       Return
    }

    ; setImageLoading()
    G2 := 2NDglPG
    Gdip_ResetClip(G2)
    ; trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)

    thisState := "a" UserTextArea TextInAreaAlign TextInAreaValign TextInAreaDoBlurs TextInAreaBlurAmount TextInAreaBlurBorderAmount TextInAreaUsrMarginz TextInAreaBgrColor TextInAreaBgrEntire TextInAreaBgrUnified TextInAreaCutOutMode TextInAreaBgrOpacity TextInAreaBorderSize TextInAreaBorderOut TextInAreaBorderColor TextInAreaBorderOpacity TextInAreaFontBold TextInAreaFontColor TextInAreaFontItalic TextInAreaFontName TextInAreaFontLineSpacing TextInAreaFontOpacity TextInAreaFontSize TextInAreaFontStrike TextInAreaFontUline TextInAreaOnlyBorder TextInAreaPaintBgr TextInAreaRoundBoxBgr imgSelW imgSelH mainWidth mainHeight TextInAreaLineAngle TextInAreaCharSpacing TextInAreaAutoWrap TextInAreaCaseTransform TextInAreaFlipH TextInAreaFlipV userimgGammaCorrect
    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    If (A_TickCount - lastInvoked < 50) || (thisState=prevState)
    {
       textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       If (thisState!=prevState)
          mustGoTimer := 1
    } Else
    {
       obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 1)
       If obju[1]
       {
          prevState := thisState
          trGdip_DisposeImage(prevBMPu, 1)
          textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
          trGdip_DisposeImage(obju[1], 1)
          scaleuPreview := obju[6]
          prevBMPu := textBoxu
          textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       }
    }

    startZeit := A_TickCount
    coreDesiredPixFmt := o_coreFmt
    Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight)
    o_imgSelPx := imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
    o_imgSelPy := imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
    o_imgSelW := imgSelW := max(X1, X2) - min(X1, X2)
    o_imgSelH := imgSelH := max(Y1, Y2) - min(Y1, Y2)

    Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
    zImgW := Round((nImgW*zoomLevel)*scaleuPreview)
    zImgH := Round((nImgH*zoomLevel)*scaleuPreview)

    Gdip_GetRotatedDimensions(zImgW, zImgH, VPselRotation, rnImgW, rnImgH)
    If (TextInAreaAlign=3)
       imgSelPx := X2 - rnImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx + imgSelW//2 - rnImgW//2

    If (TextInAreaValign=3)
       imgSelPy := Y2 - rnImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + imgSelH//2 - rnImgH//2

    If (VPselRotation>0)
    {
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, VPselRotation, "-", 5)
       If StrLen(xBitmap)>2
       {
          trGdip_DisposeImage(textBoxu, 1)
          textBoxu := xBitmap
       }
       Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
       zImgW := Round((nImgW*zoomLevel)*scaleuPreview)
       zImgH := Round((nImgH*zoomLevel)*scaleuPreview)
    }

    tX := min(o_imgSelPx, imgSelPx)
    tY := min(o_imgSelPy, imgSelPy)
    wX := max(o_imgSelPx + o_imgSelW, imgSelPx + zImgW)
    hY := max(o_imgSelPy + o_imgSelH, imgSelPy + zImgH)
    tW := wX - tX
    tH := hY - tY
    If (userimgGammaCorrect=1 || TextInAreaBlendMode>1 || alphaMaskingMode>1)
       bgrBMPu := getImgSelectedAreaEditMode(1, tX, tY, tW, tH, tW, tH, 0, tW, tH)

    If (StrLen(bgrBMPu)>2 && userimgGammaCorrect=1)
    {
       trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, tX, tY, tW, tH)
       Gdip_SetCompositingQuality(G2, 2)
    }

    Gdip_FromARGB("0xFF" TextInAreaBgrColor, A, R, G, B)
    bgrColor := Gdip_ToARGB(TextInAreaBgrOpacity, R, G, B)
    zBrush := Gdip_BrushCreateSolid(bgrColor)
    If (TextInAreaBlendMode>1 || alphaMaskingMode>1)
    {
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, tW, tH)
       Gr := Gdip_GraphicsFromImage(newBitmap)
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(Gr, 2)

       If (TextInAreaBlendMode=1)
          r1 := trGdip_DrawImage(A_ThisFunc, Gr, bgrBMPu)

       If (TextInAreaRoundBoxBgr=1 && TextInAreaFillSelArea=1)
          Gdip_FillRoundedRectanglePath(Gr, zBrush, 0, 0, tW, tH, min(tW, tH)//6)
       Else If (TextInAreaFillSelArea=1)
          Gdip_FillRectangle(Gr, zBrush, 0, 0, tW, tH)

       r1 := trGdip_DrawImage(A_ThisFunc, Gr, textBoxu, imgSelPx - tX, imgSelPy - tY, zimgW, zimgH, 0, 0, nimgW, nimgH)
       Gdip_DeleteGraphics(Gr)
       If (TextInAreaBlendMode>1)
          zr := QPV_BlendBitmaps(bgrBMPu, newBitmap, TextInAreaBlendMode - 1, realSystemCores)

       fBitmap := (TextInAreaBlendMode>1) ? bgrBMPu : newBitmap
       If (alphaMaskingMode>1 && brushingMode=1)
       {
          Gdip_GetImageDimensions(userAlphaMaskBmpPainted, zImgW, zImgH)
          viewportDynamicOBJcoords.x := tX,  viewportDynamicOBJcoords.y := tY
          viewportDynamicOBJcoords.w := tW,  viewportDynamicOBJcoords.h := tH
          viewportDynamicOBJcoords.zl := (tW/zImgW + tH/zImgH)/2 + 0.0001
          Gdip_GetImageDimensions(fBitmap, oImgW, oImgH)
          If (oImgW!=zImgW || oImgH!=zImgH)
          {
             alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, userAlphaMaskBmpPainted, oimgW, oimgH, 0, 5, -1)
             hasResized := 1
          } Else alphaMaskGray := userAlphaMaskBmpPainted
          QPV_SetAlphaChannel(fBitmap, alphaMaskGray, alphaMaskColorReversed, alphaMaskReplaceMode, alphaMaskBMPchannel, 3)
          If hasResized
             trGdip_DisposeImage(alphaMaskGray, 1)
       } Else If (alphaMaskingMode>1)
       {
          thisIDu := "a" previewMode alphaMaskingMode alphaMaskRefBMP alphaMaskClrAintensity alphaMaskClrBintensity alphaMaskGradientAngle alphaMaskGradientScale alphaMaskOffsetX alphaMaskOffsetY alphaMaskGradientWrapped alphaMaskColorReversed alphaMaskReplaceMode alphaMaskBMPchannel VPselRotation lastPaintEventID alphaMaskGradientPosA alphaMaskGradientPosB zoomLevel imgFxMode ForceNoColorMatrix FlipImgH FlipImgV getIDvpFX() tinyPrevAreaCoordX tinyPrevAreaCoordY getVPselIDs("saiz-vpos") FillAreaApplyColorFX PasteInPlaceHue PasteInPlaceSaturation PasteInPlaceLight PasteInPlaceGamma clrGradientOffX clrGradientOffY TextInAreaFlipV TextInAreaFlipV TextInAreaAlign TextInAreaLineAngle TextInAreaCharSpacing TextInAreaBlendMode TextInAreaValign TextInAreaBlurAmount TextInAreaBlurBorderAmount TextInAreaUsrMarginz TextInAreaBgrColor TextInAreaBgrEntire TextInAreaBgrUnified TextInAreaFillSelArea TextInAreaCutOutMode TextInAreaBgrOpacity TextInAreaBorderSize TextInAreaBorderOut TextInAreaBorderColor TextInAreaBorderOpacity TextInAreaFontBold TextInAreaFontColor TextInAreaFontItalic TextInAreaFontName TextInAreaFontLineSpacing TextInAreaFontOpacity TextInAreaFontSize TextInAreaFontStrike TextInAreaFontUline TextInAreaOnlyBorder TextInAreaPaintBgr TextInAreaRoundBoxBgr TextInAreaAutoWrap TextInAreaCaseTransform userimgGammaCorrect undoLevelsRecorded currentUndoLevel useGdiBitmap()
          realtimePasteInPlaceAlphaMasker(previewMode, fBitmap, thisIDu, maskedBitmap)
       }

       gBitmap := (StrLen(maskedBitmap)>2) ? maskedBitmap : bgrBMPu
       If (alphaMaskingMode>1 && brushingMode=1)
          gBitmap := fBitmap
       r2 := trGdip_DrawImage(A_ThisFunc, G2, gBitmap, tX, tY)
       ; fnOutputDebug(A_ThisFunc "(): " r1 "=" r2 "=" zr)
       trGdip_DisposeImage(newBitmap, 1)
       If (gBitmap=maskedBitmap && brushingMode=0 && alphaMaskingMode>1)
          trGdip_DisposeImage(maskedBitmap, 1)
    } Else
    {
       If (TextInAreaRoundBoxBgr=1 && TextInAreaFillSelArea=1)
          Gdip_FillRoundedRectanglePath(G2, zBrush, tX, tY, tW, tH, min(tW, tH)//6)
       Else If (TextInAreaFillSelArea=1)
          Gdip_FillRectangle(G2, zBrush, tX, tY, tW, tH)
       r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, zimgW, zimgH, 0, 0, nimgW, nimgH)
    }

    trGdip_DisposeImage(textBoxu, 1)
    bgrBMPu := trGdip_DisposeImage(bgrBMPu, 1)
    Gdip_DeleteBrush(zBrush)
    Gdip_ResetClip(G2)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)

    ; SkeletDrawSelectionBox()
    ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
    ; If (A_TickCount - startZeit<65) && (mustGoTimer=1)
    ;    livePreviewsImageEditing()
    If (mustGoTimer=1 && brushingMode=0)
       SetTimer, livePreviewsImageEditing, -100
    ; Else
       ; SetTimer, ResetImgLoadStatus, -200
    lastInvoked := A_TickCount
}

FillSelectedArea() {
    If (FillAreaInverted=1)
       PasteInPlaceAutoExpandIMG := 0

    allowOutside := 0
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If ((imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH) && PasteInPlaceAutoExpandIMG=1 && whichBitmap && imgW && imgH)
       allowOutside := 1

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 1, 0, allowOutside)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    If (allowOutside=1)
       hasRanExpand := performAutoExpandCanvas(imgW, imgH, whichBitmap)

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (X1<4)
       X1MarginSnap := 1
    If (X2>imgW - 4)
       X2MarginSnap := 1
    If (Y1<4)
       Y1MarginSnap := 1
    If (Y2>imgH - 4)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && FillAreaShape=1 && FillAreaInverted=1 && VPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelFillSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    startZeit := A_TickCount
    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       whichBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)

    r := coreFillSelectedArea("no", whichBitmap)
    If (FillAreaRemBGR=1)
       currIMGdetails.HasAlpha := 1

    If (r="fail")
       Return "fail"

    UserMemBMP := whichBitmap
    coreFillSelectedArea("kill", 0)
    recordUndoLevelNow(0, UserMemBMP)
    zeitOperation := A_TickCount - startZeit
    addJournalEntry("Fill selected area operation. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    RefreshImageFile()
    If (hasRanExpand=1)
    {
       totalSelUndos := Round(undoSelLevelsArray.Count())
       currentSelUndoLevel := clampInRange(totalSelUndos, 1, totalSelUndos)
       restorePreviousSelections(currentSelUndoLevel)
       dummyRefreshImgSelectionWindow()
       ; ToolTip, % totalSelUndos "=" currentSelUndoLevel , , , 2
    }

    If (FillAreaDoContour=1)
    {
       fn := Func("DrawLinesInSelectedArea").Bind(2)
       SetTimer, % fn, -150
    }
}

dummyInnerCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, shape, pPath) {
    If (shape=1) ; rect
    {
       Gdip_AddPathRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (shape=2) ; rounded rect
    {
       radius := Round(((imgSelW + imgSelH)//2)*0.1) + 1
       Gdip_AddPathRoundedRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, radius)
    } Else If (shape=3) ; ellipse
    {
       Gdip_AddPathEllipse(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (shape=4) ; triangle
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, [cX1, cY1, cX2, cY2, cX3, cY3])
    } Else If (shape=5) ; right triangle
    {
       cX1 := imgSelPx
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, [cX1, cY1, cX2, cY2, cX3, cY3])
    } Else If (shape=6) ; rhombus
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH//2
       cX3 := imgSelPx + imgSelW//2
       cY3 := imgSelPy + imgSelH
       cX4 := imgSelPx + imgSelW
       cY4 := imgSelPy + imgSelH//2
       Gdip_AddPathPolygon(pPath, [cX1, cY1, cX2, cY2, cX3, cY3, cX4, cY4])
    } Else If (shape=7)
    {
       PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx + 1, imgSelPy + 1, imgSelW, imgSelH, 1, !bezierSplineCustomShape)
       createPathVectorCustomShape(pPath, PointsList, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, 0)
    }
}

coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, shape, angleu:=0, keepBounds:=0, allowSelectionCenter:=1) {
    pPath := Gdip_CreatePath()
    dummyInnerCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, shape, pPath)
    If (innerSelectionCavityX>0.01 && innerSelectionCavityY>0.01)
    {
       zX := imgSelW * innerSelectionCavityX
       zY := imgSelH * innerSelectionCavityY
       nimgSelPx := imgSelPx + zX , nimgSelPy := imgSelPy + zY
       nimgSelW := imgSelW - zX*2 , nimgSelH := imgSelH - zY*2
       If (shape=4)
          nimgSelPy += zY//2

       dummyInnerCreateFillAreaShape(nimgSelPx, nimgSelPy, nimgSelW, nimgSelH, shape, pPath)
    } 

    If (angleu && pPath)
       trGdip_RotatePathAtCenter(pPath, angleu, 1, 1, keepBounds, 1)

    If ((shape=7 || shape=5 || shape=4) && pPath && allowSelectionCenter=1)
       centerPath2bounds(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
 
    Return pPath
}

trGdip_RotatePathAtCenter(pPath, Angle, MatrixOrder:=1, withinBounds:=0, withinBkeepRatio:=1, highAccuracy:=0) {
; modified by Marius Șucan - added withinBounds option
; and highAccuracy option

  If (highAccuracy=1)
     Rect := getAccuratePathBounds(pPath)
  Else
     Rect := Gdip_GetPathWorldBounds(pPath)

  cX := Rect.x + (Rect.w / 2)
  cY := Rect.y + (Rect.h / 2)
  pMatrix := Gdip_CreateMatrix()
  Gdip_TranslateMatrix(pMatrix, -cX , -cY)
  Gdip_RotateMatrix(pMatrix, Angle, MatrixOrder)
  Gdip_TranslateMatrix(pMatrix, cX, cY, MatrixOrder)
  E := Gdip_TransformPath(pPath, pMatrix)
  Gdip_DeleteMatrix(pMatrix)

  If (withinBounds=1 && !E && Angle!=0)
  {
     If (highAccuracy=1)
        nRect := getAccuratePathBounds(pPath)
     Else
        nRect := Gdip_GetPathWorldBounds(pPath)

     ncX := nRect.x + (nRect.w / 2)
     ncY := nRect.y + (nRect.h / 2)
     pMatrix := Gdip_CreateMatrix()
     Gdip_TranslateMatrix(pMatrix, -ncX , -ncY)
     sX := Rect.w / nRect.w
     sY := Rect.h / nRect.h
     If (withinBkeepRatio=1)
     {
        sX := min(sX, sY)
        sY := min(sX, sY)
     }
     Gdip_ScaleMatrix(pMatrix, sX, sY, MatrixOrder)
     Gdip_TranslateMatrix(pMatrix, ncX, ncY, MatrixOrder)
     If (sX!=0 && sY!=0)
        E := Gdip_TransformPath(pPath, pMatrix)
     Gdip_DeleteMatrix(pMatrix)
  }

  Return E
}

testSelectionLargerThanViewport() {
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    obju := []
    obju.mainWidth := mainWidth
    obju.mainHeight := mainHeight
    vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx) + SelDotsSize//2
    vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy) + SelDotsSize//2
    VPmpx := Round((vPimgSelW*vPimgSelH)/1000000, 3)
    MAINmpx := Round((mainWidth*mainHeight)/1000000, 3) + 0.01
    obju.isLarger := (MAINmpx<VPmpx) ? 1 : 0
    Return obju
}

testSelectionLargerThanGiven(imgW, imgH) {
    nImgSelX1 := min(imgSelX1, imgSelX2)
    nImgSelY1 := min(imgSelY1, imgSelY2)
    nimgSelX2 := max(imgSelX1, imgSelX2)
    nimgSelY2 := max(imgSelY1, imgSelY2)
    If (nImgSelX1<0 || nImgSelY1<0 || nImgSelX2>imgW || nImgSelY2>imgH)
       Return 1
    Return 0
}

trGdip_DrawImage(funcu, pGraphics, pBitmap, dx:="", dy:="", dw:="", dh:="", sx:="", sy:="", sw:="", sh:="", Matrix:=1, Unit:=2, ImageAttr:=0) {
  If (!pGraphics || !pBitmap)
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() using pG=" pGraphics ", pBMP=" pBitmap)
     Return "fail"
  }

  r := Gdip_DrawImage(pGraphics, pBitmap, dx, dy, dw, dh, sx, sy, sw, sh, Matrix, Unit, ImageAttr)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to draw the processed image in the internal graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics " and pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(r, baseMsg)
     Return "fail"
  }
}

trGdip_GraphicsFromImage(funcu, pBitmap, InterpolationMode:="", SmoothingMode:="", PageUnit:="", CompositingQuality:="") {
  If !pBitmap
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() for pBitmap = " pBitmap)
     Return
  }

  r := Gdip_GraphicsFromImage(pBitmap, InterpolationMode, SmoothingMode, PageUnit, CompositingQuality)
  If (!r || gdipLastError)
  {
     baseMsg := "Unable to create virtual graphics object required for processing the image... Error occured in " A_ThisFunc "() invoked by " funcu "() for pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(gdipLastError, baseMsg)
     Return
  } Else Return r
}

trGdip_DrawImageFX(funcu, pGraphics, pBitmap, dX:="", dY:="", sX:="", sY:="", sW:="", sH:="", matrix:="", pEffect:="", ImageAttr:=0, hMatrix:=0, Unit:=2) {
  If (!pGraphics || !pBitmap)
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() using " pGraphics ", " pBitmap)
     Return "fail"
  }

  r := Gdip_DrawImageFX(pGraphics, pBitmap, dX, dY, sX, sY, sW, sH, matrix, pEffect, ImageAttr, hMatrix, Unit)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to modify the image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "(). "
     generalInternalErrorMsgBox(r, baseMsg)
     Return "fail"
  }
}

trGdip_GraphicsClear(funcu, pGraphics, coloru:=0x00ffFFff, silentMode:=0) {
  If !pGraphics
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() on graphics = " pGraphics ". ")
     Return "fail"
  }

  r := Gdip_GraphicsClear(pGraphics, coloru)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to apply operations on image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics ". "
     generalInternalErrorMsgBox(r, baseMsg, silentMode)
     Return "fail"
  }
}

QPV_SaveImageFile(funcu, pBitmap, file2save, jpegQuality, depthLevel:=1) {
   Static dephtus := {1:32, 2:24, 3:16, 4:8}
   fileEXTpos := InStr(file2save, ".", 0, -1) ; RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
   If fileEXTpos
      fileEXT := SubStr(file2save, fileEXTpos + 1)

   If (dephtus[depthLevel]>1 && depthLevel!=1 && RegExMatch(fileEXT, "^(?i:BMP|DIB|RLE|TIF|TIFF|PNG)$"))
      Gdip_BitmapSetColorDepth(pBitmap, dephtus[depthLevel], 1)

   r := Gdip_SaveBitmapToFile(pBitmap, file2save, jpegQuality)
   If (r=-5)
      r := Gdip_ErrorHandler(gdipLastError, 0)
   Else If r
      r .= " / " A_LastError

   If r
   {
      addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with GDI+: " file2save "`nError code: " r)
      zr := SaveFIMfile(file2save, pBitmap, dephtus[depthLevel], fileEXT)
      If (!zr && wasInitFIMlib=1)
         r := zr
      Else If (wasInitFIMlib=1)
         addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with FreeImage: " file2save "`nError code: " zr)
   }

   Return r
}

warnUserFatalBitmapError(pBitmap, funcu) {
    If (StrLen(pBitmap)<3 || pBitmap="err" || pBitmap="fail")
    {
       r := (pBitmap="no-gdip") ? 0 : gdipLastError
       baseMsg := "Unable to create internal bitmap to apply operations on image... Error occured in Gdip_CreateBitmap() invoked by " funcu  "(). "
       generalInternalErrorMsgBox(r, baseMsg)
       Return "fail"
    }
}

getVPselIDs(what) {
   kImgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   kImgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   If InStr(what, "csize")
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

   MouseCoords2Image(1, 1, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, nimgSelX1, nimgSelY1)
   MouseCoords2Image(mainWidth, mainHeight, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, nimgSelX2, nimgSelY2)
   MouseCoords2Image(1, 1, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, zimgSelX1, zimgSelY1)
   MouseCoords2Image(mainWidth, mainHeight, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, zimgSelX2, zimgSelY2)
   koffX := (imgSelX1 < nimgSelX1) ? imgSelX1 : 0
   koffY := (imgSelY1 < nimgSelY1) ? imgSelY1 : 0
   zW := (ImgSelX2 < zImgSelX2) ? ImgSelX2 : kImgSelW
   zH := (ImgSelY2 < zImgSelY2) ? ImgSelY2 : kImgSelH
   If InStr(what, "saiz")
      r .= "a" kImgSelW kImgSelH
   If InStr(what, "vpos") ; clamped
      r .= "a" koffX koffY
   If InStr(what, "vsize") ; clamped
      r .= "a" zW zH "|"
   Return r
}

coreFillSelectedArea(previewMode, whichBitmap:=0, brushingMode:=0) {
   Critical, on
   Static prevW, prevH, prevState, prevBMP, prevVPid
        , blr := {0:0, 1:0, 2:15, 3:50, 4:120, 5:180, 6:254}

   If (previewMode="kill")
   {
      LoadCachableBitmapFromFile("kill")
      realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
      drawFillSelGradient("kill", 0, 0, 0, 0, 0, 0, 0)
      applyVPeffectsAdvOnBMP("kill")
      getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
      coredrawWelcomeImg("kill", 0, 0, 0, 0, 0, 0, 0, 0)
      userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
      If (keepUserPaintAlphaMask!=1)
         userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted, 1)
      Return
   }

   previewMode := (previewMode="no") ? 0 : 1
   If (previewMode=0)
   {
      G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap)
   } Else
   {
      G2 := 2NDglPG
      whichBitmap := useGdiBitmap()
   }

   ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
   imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
   imgSelW := max(X1, X2) - min(X1, X2)
   imgSelH := max(Y1, Y2) - min(Y1, Y2)
   If (previewMode!=1)
      calcImgSelection2bmp(!LimitSelectBoundsImg, oimgW, oimgH, oimgW, oimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)

   VPmpx := Round((imgSelW * imgSelH)/1000000, 3)
   MAINmpx := Round((mainWidth * mainHeight)/1000000, 3) + 0.01
   thisVPid := "a" oImgW oImgH MAINmpx currentFileIndex
   If (FillAreaInverted=1)
   {
      pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)
      imgSelPx := (previewMode=1) ? prevDestPosX : 0
      imgSelPy := (previewMode=1) ? prevDestPosY : 0
      imgSelW := (previewMode=1) ? prevResizedVPimgW : oimgW
      imgSelH := (previewMode=1) ? prevResizedVPimgH : oimgH
      prevVPid := ""
   } Else If (previewMode=1)
   {
      If (imgSelH>mainHeight && imgSelPy<0 && prevH && prevVPid=thisVPid)
         imgSelH := prevH
      Else
         prevH := imgSelH

      If (imgSelW>mainWidth && imgSelPx<0 && prevW && prevVPid=thisVPid)
         imgSelW := prevW
      Else
         prevW := imgSelW
      prevVPid := thisVPid
   }

   ; ToolTip, % imgSelW "=" imgSelH "`n" zImgSelW "=" zImgSelH "`n" qImgSelW "=" qImgSelH  , , , 2
   if (FillAreaInverted=0)
      pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)

   offX := (previewMode=1 && imgSelPx<0) ? Abs(imgSelPx) : 0
   offY := (previewMode=1 && imgSelPy<0) ? Abs(imgSelPy) : 0
   offW := (previewMode=1) && (offX + imgSelW > mainWidth) ? imgSelW - (offX + imgSelW - mainWidth) + offX : imgSelW
   offH := (previewMode=1) && (offY + imgSelH > mainHeight) ? imgSelH - (offY + imgSelH - mainHeight) + offY : imgSelH
   gradientsBMP := drawFillSelGradient(pPath, imgSelW, imgSelH, previewMode, offX, offY, offW, offH)
   Gdip_GetImageDimensions(gradientsBMP, imgSelW, imgSelH)

   If (FillAreaApplyColorFX=1 && FillAreaColorMode>4)
      applyPersonalizedColorsBMP(gradientsBMP, 0, 0, FillAreaApplyColorFX)

   modus := (FillAreaInverted=1) ? 4 : 0
   Gdip_ResetClip(G2)
   Gdip_SetClipPath(G2, pPath, modus)
   opacityLevels := (FillAreaColorMode=1 && FillAreaOpacity<253) || (FillAreaColorMode>1 && (FillAreaOpacity<253 || FillArea2ndOpacity<253)) ? 1 : 0
   BlurAmount := blr[FillAreaGlassy]
   kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   msize := (kImgSelW + kImgSelH)//2
   rsize := (ImgSelW + ImgSelH)//2
   If (previewMode=1)
      BlurAmount := (Round(BlurAmount * (rsize / msize)))

   If (FillAreaRemBGR=1)
   {
      If (previewMode=1)
      {
         If (FillAreaInverted=1)
            Gdip_FillRectangle(G2, useHatchedBrush(), imgSelPx, imgSelPy, imgSelW, imgSelH)
         Else
            Gdip_FillPath(G2, useHatchedBrush(), pPath)
      } Else Gdip_GraphicsClear(G2)
      ; ToolTip, % previewMode "=" pPath "=" g2 "`n" imgSelPx "=" imgSelPy "=" imgSelW "=" imgSelH "=" FillAreaShape "=" VPselRotation "=" rotateSelBoundsKeepRatio , , , 2
   } Else If (FillAreaGlassy>1 && opacityLevels=1 && BlurAmount>1 || FillAreaBlendMode>1)
   {
      thisQuality := (previewMode=1) ? 5 : 3
      canBlur := (previewMode=1 && doImgEditLivePreview=1 || previewMode=0) ? 1 : 0
      dropSpecialFX := (MAINmpx<VPmpx && previewMode=1) ? 1 : 0
      ; MsgBox, % "a" canBlur "=" mustRemBackground "=" FillAreaGlassy "=" opacityLevels
      If (canBlur=1 && dropSpecialFX!=1 && !testSelectOutsideImgEntirely(whichBitmap))
      {
         thisFXstate := "a" whichBitmap getVPselIDs("saiz-vpos") previewMode BlurAmount "a" imgSelPx imgSelPy imgSelW imgSelH currentFileIndex getIDimage(currentFileIndex) oImgW oImgH currentUndoLevel undoLevelsRecorded currentSelUndoLevel FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode UserMemBMP ViewPortBMPcache getIDvpFX()
         bgrBMPu := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0, imgSelW, imgSelH) 
         Gdip_GetImageDimensions(bgrBMPu, zImgW, zImgH)
         sizeu := (imgSelW=zImgW && imgSelH=zImgH) ? 1 : 0
         doFX := ((FillAreaGlassy>1 && opacityLevels=1 || FillAreaBlendMode>1) && BlurAmount>1) ? 1 : 0
         If (StrLen(bgrBMPu)>2 && (doFX=1 || sizeu!=1))
            glassBitmap := applyVPeffectsAdvOnBMP(bgrBMPu, previewMode, thisFXstate, imgSelW, imgSelH, BlurAmount, 0)
         Else If StrLen(bgrBMPu)>2
            glassBitmap := trGdip_CloneBitmap(A_ThisFunc, bgrBMPu)

         ; ToolTip, % sizeu "=" doFX "=" glassBitmap , , , 2
         threads := (previewMode=1) ? realSystemCores : 0
         If (FillAreaBlendMode>1)
         {
            o_glass := trGdip_CloneBitmap(A_ThisFunc, glassBitmap)
            QPV_BlendBitmaps(glassBitmap, gradientsBMP, FillAreaBlendMode - 1, threads)
         }

         If (FillAreaApplyColorFX=1 && FillAreaColorMode<5)
            applyPersonalizedColorsBMP(glassBitmap, 0, 0, FillAreaApplyColorFX)

         If (FillAreaBlendMode=1)
         {
            G5 := Gdip_GraphicsFromImage(glassBitmap)
            If (userimgGammaCorrect=1)
               Gdip_SetCompositingQuality(G5, 2)

            Gdip_DrawImage(G5, gradientsBMP)
            Gdip_DeleteGraphics(G5)
         } Else If (FillAreaGlassy>1 && (FillAreaOpacity<254 || FillArea2ndOpacity<254))
         {
            thisOpacity := (FillAreaColorMode>4) ? FillAreaOpacity/255 : 1
            zBitmap := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH)
            If StrLen(zBitmap)>2
            {
               G5 := Gdip_GraphicsFromImage(zBitmap)
               If (userimgGammaCorrect=1)
                  Gdip_SetCompositingQuality(G5, 2)

               Gdip_DrawImage(G5, o_glass, 0, 0, imgSelW, imgSelH, , , , , thisOpacity/2)
               Gdip_DrawImage(G5, glassBitmap, 0, 0, imgSelW, imgSelH)
               Gdip_DeleteGraphics(G5)
               trGdip_DisposeImage(glassBitmap, 1)
               glassBitmap := zBitmap
            }
         }
         trGdip_DisposeImage(o_glass, 1)
         gradientsBMP := trGdip_DisposeImage(gradientsBMP, 1)
      }
   }

   If (userimgGammaCorrect=1 && StrLen(bgrBMPu)<3 && previewMode=1 && FillAreaRemBGR=0)
      bgrBMPu := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0, imgSelW, imgSelH)

   If (userimgGammaCorrect=1 && StrLen(bgrBMPu)>2 && previewMode=1)
      trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH)

   bgrBMPu := trGdip_DisposeImage(bgrBMPu, 1)
   If (userimgGammaCorrect=1)
      Gdip_SetCompositingQuality(G2, 2)

   fBitmapA := StrLen(glassBitmap)>1 ? glassBitmap : gradientsBMP
   fBitmapB := StrLen(glassBitmap)>1 ? gradientsBMP : glassBitmap
   ; ToolTip, % "lol=" brushingMode , , , 2
   If (alphaMaskingMode>1 && brushingMode=1)
   {
      Gdip_GetImageDimensions(userAlphaMaskBmpPainted, zImgW, zImgH)
      viewportDynamicOBJcoords.x := imgSelPx, viewportDynamicOBJcoords.y := imgSelPy
      viewportDynamicOBJcoords.w := imgSelW,  viewportDynamicOBJcoords.h := imgSelH
      viewportDynamicOBJcoords.zl := (imgSelW/zImgW + imgSelH/zImgH)/2 + 0.0001
      Gdip_GetImageDimensions(fBitmapA, oImgW, oImgH)
      If (oImgW!=zImgW || oImgH!=zImgH)
      {
         alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, userAlphaMaskBmpPainted, oimgW, oimgH, 0, 5, -1)
         hasResized := 1
      } Else alphaMaskGray := userAlphaMaskBmpPainted
      QPV_SetAlphaChannel(fBitmapA, alphaMaskGray, alphaMaskColorReversed, alphaMaskReplaceMode, alphaMaskBMPchannel, 3)
      If hasResized
         trGdip_DisposeImage(alphaMaskGray, 1)
   } Else If (alphaMaskingMode>1)
   {
      moreStuff := (FillAreaGlassy>1 || FillAreaBlendMode>1) ? "a" imgSelPx imgSelPy : ""
      thisIDu := "a" previewMode FillAreaRemBGR FillAreaInverted userimgGammaCorrect FillAreaGlassy FillAreaBlendMode FillAreaColor FillAreaColorMode FillArea2ndColor FillAreaOpacity FillArea2ndOpacity FillAreaGradientWrapped FillAreaGradientAngle FillAreaGradientPosB FillAreaGradientPosA FillAreaColorReversed FillAreaGradientScale alphaMaskingMode alphaMaskRefBMP alphaMaskClrAintensity alphaMaskClrBintensity alphaMaskGradientAngle alphaMaskGradientScale alphaMaskOffsetX alphaMaskOffsetY alphaMaskGradientWrapped alphaMaskColorReversed alphaMaskReplaceMode alphaMaskBMPchannel VPselRotation lastPaintEventID alphaMaskGradientPosA alphaMaskGradientPosB zoomLevel imgFxMode ForceNoColorMatrix FlipImgH FlipImgV getIDvpFX() tinyPrevAreaCoordX tinyPrevAreaCoordY getVPselIDs("saiz-vpos") moreStuff FillAreaApplyColorFX PasteInPlaceHue PasteInPlaceSaturation PasteInPlaceLight PasteInPlaceGamma clrGradientOffX clrGradientOffY undoLevelsRecorded currentUndoLevel useGdiBitmap()
      realtimePasteInPlaceAlphaMasker(previewMode, fBitmapA, thisIDu, newBitmap, offX, offY, offW, offH)
      If StrLen(newBitmap)>2
      {
         trGdip_DisposeImage(fBitmapA, 1)
         fBitmapA := newBitmap
      }
   }

   thisOpacity := (FillAreaColorMode>4) ? FillAreaOpacity/255 : 1
   ; ToolTip, % "g2=" g2 " bmp="  fBitmapA " g=" gradientsBMP " o=" thisOpacity " p=" pPath , , , 2
   trGdip_DrawImage(A_ThisFunc, G2, fBitmapA, imgSelPx, imgSelPy, imgSelW, imgSelH, , , , , thisOpacity)
   If (userimgGammaCorrect=1)
      Gdip_SetCompositingQuality(G2, 1)

   If (previewMode!=1)
      Gdip_DeleteGraphics(G2)
   Gdip_ResetClip(G2)
   trGdip_DisposeImage(fBitmapA, 1)
   trGdip_DisposeImage(fBitmapB, 1)
   If (FillAreaDoContour=1 && previewMode=1)
      coreDrawShapesSelectionArea()
}

drawFillSelGradient(pPath, imgSelW, imgSelH, previewMode, offX, offY, offW, offH) {
    Static prevBMPu, prevState
    If (pPath="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" previewMode getVPselIDs("saiz-vpos") FillAreaInverted userimgGammaCorrect FillAreaColor FillAreaColorMode FillArea2ndColor FillAreaOpacity FillArea2ndOpacity FillAreaGradientWrapped FillAreaGradientAngle FillAreaGradientPosB FillAreaGradientPosA FillAreaColorReversed FillAreaGradientScale tinyPrevAreaCoordX tinyPrevAreaCoordY clrGradientOffX clrGradientOffY VPselRotation prevDestPosX prevDestPosY zoomLevel
    ; ToolTip, % thisState , , , 2
    If (thisState=prevState && StrLen(prevBMPu)>2)
       Return trGdip_CloneBitmap(A_ThisFunc, prevBMPu)

    ; ToolTip, % offX "=" offY "=" offW "=" offH "=" imgselW "=" imgSelH , , , 2
    prevState := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH)
    If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
       Return

    fnOutputDebug("redraw: " A_ThisFunc)
    ; prepare the brush
    Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
    this1stOpacity := (FillAreaColorMode=5) ? clampInRange(FillAreaOpacity, 1, 215) : FillAreaOpacity
    thisColorA := Gdip_ToARGB(this1stOpacity, R, G, B)
 
    Gdip_FromARGB("0xFF" FillArea2ndColor, A, R, G, B)
    this2ndOpacity := (FillAreaColorMode=5) ? clampInRange(FillArea2ndOpacity, 1, 215) : FillArea2ndOpacity
    thisColorB := Gdip_ToARGB(this2ndOpacity, R, G, B)
    If (FillAreaColorReversed=1 && isInRange(FillAreaColorMode, 2, 4))
    {
       tempu := thisColorA
       thisColorA := thisColorB
       thisColorB := tempu
       tempu := this1stOpacity
       this1stOpacity := this2ndOpacity
       this2ndOpacity := tempu
    }

    imgSelPx := imgSelPy := 0
    brImgSelW := Round(ImgSelW*(FillAreaGradientScale/100))
    brImgSelH := Round(ImgSelH*(FillAreaGradientScale/100))
    brimgSelPx := imgSelPx - (brImgSelW - imgSelW)//2
    brimgSelPy := imgSelPy - (brImgSelH - imgSelH)//2
    If (FillAreaColorMode=1)
    {
       ; solid color
       Brush := Gdip_BrushCreateSolid(thisColorA)
    } Else If (FillAreaColorMode=2)
    {
       ; linear gradient
       cX := Round(brImgSelW * clrGradientOffX)
       cY := Round(brImgSelH * clrGradientOffY)
       Brush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + cX, brimgSelPy + cY, brimgSelW, brimgSelH, thisColorA, thisColorB, 1, FillAreaGradientWrapped)
       Gdip_RotateLinearGrBrushAtCenter(Brush, Mod(Round(FillAreaGradientAngle + VPselRotation), 360), 1)
       Gdip_SetLinearGrBrushGammaCorrection(Brush, userimgGammaCorrect)
       Gdip_SetLinearGrBrushPresetBlend(Brush, [FillAreaGradientPosA/100, FillAreaGradientPosB/100], [thisColorA, thisColorB])
    } Else If (FillAreaColorMode=3 || FillAreaColorMode=4)
    {
       cX := Round(imgSelW/2 + imgSelW * clrGradientOffX)
       cY := Round(imgSelH/2 + imgSelH * clrGradientOffY)
       ; radial or box gradient
       grpPath := Gdip_CreatePath()
       whichFunc := (FillAreaColorMode=3) ? "Ellipse" : "Rectangle"
       Gdip_AddPath%whichFunc%(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
       Brush := Gdip_PathGradientCreateFromPath(grpPath)
       Gdip_PathGradientSetCenterPoint(Brush, cX, cY)
       Gdip_SetLinearGrBrushGammaCorrection(Brush, userimgGammaCorrect)
       Gdip_SetLinearGrBrushPresetBlend(Brush, [FillAreaGradientPosA/100, FillAreaGradientPosB/100], [thisColorA, thisColorB])
       Gdip_RotatePathGradientAtCenter(Brush, Mod(Round(FillAreaGradientAngle + VPselRotation), 360), 1)
       Gdip_PathGradientSetWrapMode(Brush, FillAreaGradientWrapped - 1)
       Gdip_DeletePath(grpPath)
    } Else If (FillAreaColorMode=5)
    {
       ; welcome screens patterns
       iterations := Round(100*(FillAreaGradientScale/300)) + 1
       modelu := Round(7*(FillAreaGradientPosB/100))
       moduz := Round(9*(FillAreaGradientPosA/100))
       sweepRand := Round(9*(FillAreaGradientAngle/360))
       Brush := Gdip_BrushCreateSolid(thisColorB)
       w := (previewMode=1) ? imgSelW // 2 : imgSelW
       h := (previewMode=1) ? imgSelH // 2 : imgSelH
       zBitmap := coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, w, h, 5, 5, 0, previewMode, !previewMode)
       ; Gdip_DeleteBrush(bruA)
    } Else If (FillAreaColorMode=6)
    {
       ; texture mode
       If (!isNumber(tinyPrevAreaCoordX) || !isNumber(tinyPrevAreaCoordY))
          tinyPrevAreaCoordX := tinyPrevAreaCoordY := 2

       Gdip_GetImageDimensions(useGdiBitmap(), kklimgW, kklimgH)
       maxSizeX := kklimgW - tinyPrevAreaCoordX - 2
       maxSizeY := kklimgH - tinyPrevAreaCoordY - 2
       texSize := clampInRange(3 * FillAreaGradientScale, 2, maxSizeX)
       texSize2 := texSize + Round(texSize * (FillAreaGradientPosB/100))
       texSize2 := clampInRange(texSize2, 2, maxSizeY)
       texScaleX := imgSelW/kklimgW
       texScaleX := texScaleX * (FillAreaGradientPosA / 100)
       texScaleY := texScaleX
       If (FillAreaColorReversed=1 && FillAreaGradientWrapped=1)
          tilingMode := 3
       Else If (FillAreaColorReversed=1 && FillAreaGradientWrapped=0)
          tilingMode := 2
       Else If (FillAreaColorReversed=0 && FillAreaGradientWrapped=1)
          tilingMode := 1
       Else
          tilingMode := 0

       Brush := Gdip_CreateTextureBrush(useGdiBitmap(), tilingMode, tinyPrevAreaCoordX, tinyPrevAreaCoordY, texSize, texSize2,, texScaleX, texScaleY, FillAreaGradientAngle, 0)
    }

    If StrLen(Brush)<2
    {
       trGdip_DisposeImage(pBitmap)
       Return
    }

    G2 := Gdip_GraphicsFromImage(pBitmap)
    Gdip_SetClipRect(G2, offX, offY, offW, offH)
    Gdip_FillRectangle(G2, Brush, 0, 0, imgSelW, imgSelH)

    If ((FillAreaColorMode=4 || FillAreaColorMode=3) && (FillAreaGradientScale>=99 || FillAreaGradientWrapped!=1))
    {
       QPV_FillBitmapHoles(pBitmap, thisColorB)
/*
       sBrush := Gdip_BrushCreateSolid(thisColorB)
       grpPath := Gdip_CreatePath()
       If (sBrush && grpPath)
       {
          If (FillAreaColorMode=3)
             Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
          Else
             Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

          trGdip_RotatePathAtCenter(grpPath, Mod(Round(FillAreaGradientAngle + VPselRotation), 360), 1, 0, 1, 1)
          Gdip_ResetClip(G2)
          Gdip_SetClipPath(G2, grpPath, 4)
          Gdip_FillRectangle(G2, sBrush, 0, 0, imgSelW, imgSelH)
          Gdip_ResetClip(G2)
       }
       Gdip_DeletePath(grpPath)
       Gdip_DeleteBrush(sBrush)
*/
    } Else If (FillAreaColorMode=3 && FillAreaGradientScale<99 && FillAreaGradientWrapped=1)
    {
       QPV_FillBitmapHoles(pBitmap, thisColorB)
    }

    If StrLen(zBitmap)>2
    {
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G2, 2)
       trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0, imgSelW, imgSelH)
       trGdip_DisposeImage(zBitmap, 1)
    }

    Gdip_DeleteGraphics(G2)
    Gdip_DeleteBrush(Brush)
    prevState := (minimizeMemUsage=0) ? thisState : 0
    prevBMPu := (minimizeMemUsage=0) ? trGdip_CloneBitmap(A_ThisFunc, pBitmap) : 0
    Return pBitmap
}

carvePathFromBitmap(ByRef pBitmap, pPath, cX, cY, modus, safeWay:=0, blurLevel:=0, doBorder:=1) {
    If (safeWay=2 && blurLevel>1)
    {
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
       r2 := trGdip_GraphicsClear(A_ThisFunc, G3, "0xFFFFFFFF")

       zPath := Gdip_ClonePath(pPath)
       pMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(pMatrix, -cX , -cY)
       ; Gdip_TranslateMatrix(pMatrix, blurLevel , blurLevel)
       E := Gdip_TransformPath(zPath, pMatrix)
       Gdip_SetClipPath(G3, zPath, modus)

       BrushB := Gdip_BrushCreateSolid("0xFF000000")
       r3 := Gdip_FillRectangle(G3, BrushB, 0, 0, imgW, imgH)
       Gdip_ResetClip(G3)
       Gdip_SetClipRect(G3, blurLevel, blurLevel, imgW - blurLevel*2, imgH - blurLevel*2, 4)
       If (doBorder=1)
          r3 := Gdip_FillRectangle(G3, BrushB, 0, 0, imgW, imgH)

       Gdip_DeleteGraphics(G3)
       thisAmount := clampInRange(blurLevel, 1, 255)
       pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, newBitmap, thisAmount, pEffect, 0)
       Gdip_DisposeEffect(pEffect)
       If (blurLevel>257)
       {
          thisAmount := clampInRange(blurLevel - 255, 1, 255)
          pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
          ApplySpecialFixedBlur(A_ThisFunc, newBitmap, thisAmount, pEffect, 0)
          Gdip_DisposeEffect(pEffect)
       }
       r0 := QPV_SetAlphaChannel(pBitmap, newBitmap)
       Gdip_DeletePath(zPath)
       Gdip_DeletePath(wPath)
       Gdip_DeleteBrush(BrushB)
       Gdip_DeleteMatrix(pMatrix)
       trGdip_DisposeImage(newBitmap, 1)
       ; ToolTip, % newBitmap "==" G3 "==" BrushB "`n" r2 "==" r3 "==" r0 , , , 2
       Return
    } Else safeWay := 0

    If (safeWay=1)
    {
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0x26200A")
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
    } Else
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)

    If (G3 && (newBitmap || safeWay!=1))
    {
       ; Gdip_GetImageDimensions(pBitmap, qImgW, qImgH)
       zPath := Gdip_ClonePath(pPath)
       pMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(pMatrix, -cX , -cY)
       E := Gdip_TransformPath(zPath, pMatrix)
       If (safeWay=1)
       {
          Gdip_SetCompositingQuality(G3, 4)
          Gdip_SetCompositingMode(G3, 1)
          Gdip_SetPixelOffsetMode(G3, 4)
          thinBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, pBitmap,,,,, "0x26200A")
          pEffect := Gdip_CreateEffect(5, -25, 0, 0)
          Gdip_BitmapApplyEffect(thinBMP, pEffect)

          QPV_SetGivenAlphaLevel(thinBMP, 1, 0)
          trGdip_DrawImage(A_ThisFunc, G3, thinBMP) ; ,,,,,,,,,10)
          modus := (modus=4) ? 0 : 4
       }

       Gdip_SetClipPath(G3, zPath, modus)
       If (safeWay!=1)
          r1 := trGdip_GraphicsClear(A_ThisFunc, G3)

       r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap)
       Gdip_DeletePath(zPath)
       Gdip_DeleteMatrix(pMatrix)
       Gdip_DeleteGraphics(G3)
       If (safeWay=1)
       {
          trGdip_DisposeImage(thinBMP, 1)
          If !r2
          {
             trGdip_DisposeImage(pBitmap, 1)
             pBitmap := newBitmap
          } Else Return "Fail"
       }
    }

    If (!G3 || r1="fail")
       Return "fail"
}

GraySelectedArea() {
   EraseOrInvertOrGraySelectedArea("desaturate", A_ThisFunc)
}

InvertSelectedArea() {
   EraseOrInvertOrGraySelectedArea("invert", A_ThisFunc)
}

EraseSelectedArea() {
   EraseOrInvertOrGraySelectedArea("erase", A_ThisFunc)
}

FlipSelectedAreaH() {
    EraseOrInvertOrGraySelectedArea("flip-h", A_ThisFunc)
}

FlipSelectedAreaV() {
    EraseOrInvertOrGraySelectedArea("flip-v", A_ThisFunc)
}

FillBehindSelectedArea() {
    EraseOrInvertOrGraySelectedArea("behind", A_ThisFunc)
}

EraseOrInvertOrGraySelectedArea(actionu, funcu) {
    Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8}

    If (editingSelectionNow!=1 && thumbsDisplaying!=1 && actionu!="erase")
       selectEntireImage("r")

    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(funcu)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!LimitSelectBoundsImg, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (X1<4)
       X1MarginSnap := 1
    If (X2>imgW - 4)
       X2MarginSnap := 1
    If (Y1<4)
       Y1MarginSnap := 1
    If (Y2>imgH - 4)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && EraseAreaInvert=1 && actionu="erase" && EllipseSelectMode=0 && VPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelEraseSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    infoFriendly := InStr(actionu, "flip-") ? actionu : actionu " the colours in"
    G2 := trGdip_GraphicsFromImage(funcu, whichBitmap, 7, 4)
    If !G2
    {
       showTOOLtip("Failed to " infoFriendly " the selected area")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    recordUndoLevelNow("init", 0)
    If (!gdiBitmap && preventUndoLevels=1)
    {
       hasCloned := 1
       o_gdiBitmap := Gdip_CloneBmpPargbArea(funcu, UserMemBMP)
    } Else o_gdiBitmap := gdiBitmap

    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    If !pPath
    {
       showTOOLtip("Failed to " infoFriendly " the selected area`nUnable to create selection path")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    ha := currIMGdetails.HasAlpha
    modus := (EraseAreaInvert=1 && (actionu="desaturate" || actionu="erase")) ? 4 : 0
    If (actionu!="behind")
    {
       Gdip_SetClipPath(G2, pPath, modus)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
       If !r0
          currIMGdetails.HasAlpha := 1
    }

    If (actionu="erase")
    {
       clrMatrix := (EraseAreaFader=1) ? EraseAreaOpacity / 255 : 0
    } Else If (actionu="behind")
    {
       thisOpacity := (FillBehindOpacity>255) ? (FillBehindOpacity - 245)/10 : FillBehindOpacity/255
       clrMatrix := (FillBehindOpacity!=255) ? thisOpacity : 1
       If (clrMatrix<1)
          ha := 1

       Gdip_FromARGB("0xFF" FillBehindColor, A, R, G, B)
       thisColorA := Gdip_ToARGB(FillBehindClrOpacity, R, G, B)
       thisBrush := Gdip_BrushCreateSolid(thisColorA)
       If (FillBehindInvert=1)
       {
          Gdip_ResetClip(G2)
          Gdip_SetClipPath(G2, pPath, 4)
          If (FillBehindOpacity>1)
             r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

          Gdip_FillRectangle(G2, thisBrush, 0, 0, imgW, imgH)
       } Else
       {
          Gdip_ResetClip(G2)
          If (FillBehindOpacity>1)
             Gdip_SetClipPath(G2, pPath, 0)

          r0 := trGdip_GraphicsClear(A_ThisFunc, G2, 0)
          Gdip_FillPath(G2, thisBrush, pPath)
       }

       Gdip_DeleteBrush(thisBrush)
    } Else If (actionu="invert")
    {
       clrMatrix := GenerateColorMatrix(6, 1, 0, 1)
    } Else If (actionu="desaturate")
    {
       thisBitsDepth := bitsOptions[DesaturateAreaLevels]
       coreDesatureAreaFX(clrMatrix, pEffect)
    } Else If InStr(actionu, "flip")
    {
       clrMatrix := 1
       thisW := imgSelW + imgSelPx*2
       thisH := imgSelH + imgSelPy*2
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
       If (actionu="flip-h")
       {
          Gdip_ScaleWorldTransform(G2, -1, 1)
          Gdip_TranslateWorldTransform(G2, -thisW, 0)
       } Else If (actionu="flip-v")
       {
          Gdip_ScaleWorldTransform(G2, 1, -1)
          Gdip_TranslateWorldTransform(G2, 0, -thisH)
       }
    }

    zBitmap := o_gdiBitmap ? o_gdiBitmap : undoLevelsArray[currentUndoLevel, 1]
    allowAlphaMasking := decideAlphaMaskingFeaseable(EraseAreaUseAlpha)
    If (actionu="desaturate" && thisBitsDepth>1 && allowAlphaMasking!=1)
       Gdip_BitmapSetColorDepth(zBitmap, thisBitsDepth, DesaturateAreaDither)

    If (allowAlphaMasking=1 && (actionu="erase" || actionu="desaturate"))
    {
       If (editingSelectionNow=1 && EraseAreaInvert=0)
          gBitmap := Gdip_CloneBmpPargbArea(funcu, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

       fBitmap := StrLen(gBitmap)>2 ? gBitmap : zBitmap
       If (actionu="desaturate" && thisBitsDepth>1)
       {
          clipBMP := trGdip_CloneBitmap(A_ThisFunc, fBitmap)
          Gdip_BitmapSetColorDepth(clipBMP, thisBitsDepth, DesaturateAreaDither)
          Gdip_BitmapSetColorDepth(clipBMP, 32)
       }

       kBitmap := StrLen(clipBMP)>2 ? clipBMP : fBitmap
       realtimePasteInPlaceAlphaMasker(0, kBitmap, "lol", newBitmap, 0, 0, 0, 0)
       If StrLen(clipBMP)>2
          trGdip_DisposeImage(clipBMP)
       If StrLen(newBitmap)>2
       {
          If (actionu="erase")
             clrMatrix := (EraseAreaFader=1) ? EraseAreaOpacity / 255 : 1

          If StrLen(gBitmap)>2
          {
             wBitmap := Gdip_CloneBmpPargbArea(funcu, zBitmap)
             G3 := trGdip_GraphicsFromImage(funcu, wBitmap)
             Gdip_SetClipRect(G3, imgSelPx, imgSelPy, imgSelW, imgSelH)
             r0 := trGdip_GraphicsClear(funcu, G3)
             Gdip_ResetClip(G3)
             r2 := trGdip_DrawImage(funcu, G3, newBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
             Gdip_DeleteGraphics(G3)
             ; ToolTip, % imgSelPx "," imgSelPy "," imgSelW "," imgSelH , , , 2
             If (actionu="desaturate")
                r2 := trGdip_DrawImage(funcu, G2, gBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
             r1 := dummyDrawImage(pEffect, clrMatrix, wBitmap, G2, funcu)
             trGdip_DisposeImage(wBitmap)
          } Else
          {
             If (actionu="desaturate")
                r2 := trGdip_DrawImage(funcu, G2, fBitmap)
             r1 := dummyDrawImage(pEffect, clrMatrix, newBitmap, G2, funcu)
          }
          trGdip_DisposeImage(newBitmap)
          done := 1
       }
       trGdip_DisposeImage(gBitmap, 1)
    }

    If !done
       r1 := dummyDrawImage(pEffect, clrMatrix, zBitmap, G2, funcu)
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    Gdip_DeletePath(pPath)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeleteGraphics(G2)
    If hasCloned
       trGdip_DisposeImage(o_gdiBitmap, 1)

    If (r0!="fail" && r1!="fail" && G2)
    {
       currIMGdetails.HasAlpha := 0
       isInside := (imgSelX1>=0 && imgSelY1>=0 && imgSelX2<=imgW && imgSelY2<=imgH) ? 1 : 0
       If (actionu="behind")
          currIMGdetails.HasAlpha := ha
       Else If (actionu="erase") || (InStr(actionu, "flip") && isInside=0)
          currIMGdetails.HasAlpha := 1

       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    SetTimer, RefreshImageFile, -25
}

dummyDrawImage(pEffect, clrMatrix, zBitmap, G2, funcu) {
   If !pEffect
      r1 := trGdip_DrawImage(funcu, G2, zBitmap, 0, 0,,,,,,, clrMatrix)
   Else
      r1 := trGdip_DrawImageFX(funcu, G2, zBitmap,,,,,,, clrMatrix, pEffect)
   Return r1
}

ResizeIMGviewportSelection() {
    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 ||!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    thisQuality := (userimgQuality=1) ? 7 : 5
    pargbPixFmt := (coreDesiredPixFmt="0xE200B") ? -1 : 0
    newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgSelW, imgSelH, 0, thisQuality, pargbPixFmt)
    If StrLen(newBitmap)<2
    {
       SetTimer, ResetImgLoadStatus, -150
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    UserMemBMP := newBitmap

    editingSelectionNow := 0
    vpIMGrotation := 0
    updateUIctrl()
    MouseMoveResponder()
    recordUndoLevelNow(0, newBitmap)
    SetTimer, RefreshImageFile, -25
    SetTimer, dummyInfoImgResizeVP, -125
}

dummyInfoImgResizeVP() {
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW*imgH)/1000000, 2)
   showTOOLtip("Image resized to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px | " Round(imgW/imgH, 2) " | " mpx " MPx" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

DrawLinesInSelectedArea(modus) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    allowOutside := 0
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    tk := (DrawLineAreaContourAlign=1 || PasteInPlaceAutoExpandIMG!=1) ? 0 : DrawLineAreaContourThickness
    o_imgSelX1 := imgSelX1
    o_imgSelY1 := imgSelY1
    o_imgSelX2 := imgSelX2
    o_imgSelY2 := imgSelY2
    imgSelX1 := imgSelX1 - tk//2
    imgSelY1 := imgSelY1 - tk//2
    imgSelX2 := imgSelX2 + tk//2
    imgSelY2 := imgSelY2 + tk//2
    offX := (imgSelX1<0) ? abs(imgSelX1) : 0
    offY := (imgSelY1<0) ? abs(imgSelY1) : 0
    If ((imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH) && PasteInPlaceAutoExpandIMG=1 && whichBitmap && imgW && imgH)
       allowOutside := 1

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 1, 0, allowOutside)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    If (allowOutside=1)
       hasRanExpand := performAutoExpandCanvas(imgW, imgH, whichBitmap)

    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4,, compositingQuality)
    If !G2
    {
       SoundBeep , 300, 100
       addJournalEntry(A_ThisFunc "(): error - failed to create graphics object for main image")
       Return
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    If (hasRanExpand=1)
    {
       imgSelX1 := o_imgSelX1 + offX
       imgSelY1 := o_imgSelY1 + offY
       imgSelX2 := o_imgSelX2 + offX
       imgSelY2 := o_imgSelY2 + offY
    }

    If (modus=1)
       coreDrawLinesSelectionArea(G2, whichBitmap)
    Else
       coreDrawShapesSelectionArea(G2, whichBitmap)

    Gdip_DeleteGraphics(G2)
    UserMemBMP := whichBitmap
    recordUndoLevelNow(0, UserMemBMP)
    RefreshImageFile()
    If (hasRanExpand=1)
    {
       totalSelUndos := Round(undoSelLevelsArray.Count())
       currentSelUndoLevel := clampInRange(totalSelUndos, 1, totalSelUndos)
       restorePreviousSelections(currentSelUndoLevel)
       dummyRefreshImgSelectionWindow()
       ; ToolTip, % totalSelUndos "=" currentSelUndoLevel , , , 2
    }
}

coreDrawLinesSelectionArea(G2:=0, whichBitmap:=0) {
    If (G2)
    {
       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       maxLength := (imgSelW + imgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : DrawLineAreaContourThickness
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G2, 2)
    } Else
    {
       G2 := 2NDglPG
       Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
       calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
       imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
       imgSelW := max(X1, X2) - min(X1, X2)
       imgSelH := max(Y1, Y2) - min(Y1, Y2)
       maxLength := (qimgSelW + qimgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : DrawLineAreaContourThickness
       thisThick := thisThick*zoomLevel
       tk := (DrawLineAreaContourAlign=2) ? tk//2 : tk
       If (DrawLineAreaContourAlign=1)
          tk := 0

       If (userimgGammaCorrect=1)
       {
          bgrBMPu := getImgSelectedAreaEditMode(1, imgSelPx - tk, imgSelPy - tk, imgSelW + tk * 2, imgSelH + tk * 2, imgSelW + tk * 2, imgSelH + tk * 2, 0, imgSelW + tk * 2, imgSelH + tk * 2)
          trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx - tk, imgSelPy - tk, imgSelW + tk * 2, imgSelH + tk * 2)
          Gdip_SetCompositingQuality(G2, 2)
          trGdip_DisposeImage(bgrBMPu)
       }
    }

    dR := (DrawLineAreaContourAlign=3) ? thisThick//2 : 0
    If (DrawLineAreaContourAlign=1)
       dR := -thisThick//2

    imgSelPx -= dR
    imgSelPy -= dR
    imgSelW += dR*2
    imgSelH += dR*2
    x1 -= dR
    y1 -= dR
    x2 += dR
    y2 += dR

    pPathArcs := Gdip_CreatePath()
    If (DrawLineAreaBorderArcA=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 180, 90)

    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcB=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 270, 90)

    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcC=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 90, 90)

    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcD=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 0, 90)

    pPathBrders := Gdip_CreatePath()
    If (DrawLineAreaBorderTop=1)
       Gdip_AddPathLine(pPathBrders, x1, y1, x2, y1)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderBottom=1)
       Gdip_AddPathLine(pPathBrders, x1, y2, x2, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderLeft=1)
       Gdip_AddPathLine(pPathBrders, x1, y1, x1, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderRight=1)
       Gdip_AddPathLine(pPathBrders, x2, y1, x2, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=2 || DrawLineAreaBorderCenter=7)
       Gdip_AddPathLine(pPathBrders, x1 + imgSelW//2, y1, x1 + imgSelW//2, y2)
    
    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=3 || DrawLineAreaBorderCenter=7)
       Gdip_AddPathLine(pPathBrders, x1, y1 + imgSelH//2, x2, y1 + imgSelH//2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=4 || DrawLineAreaBorderCenter=6)
       Gdip_AddPathLine(pPathBrders, x1, y2, x2, y1)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=5 || DrawLineAreaBorderCenter=6)
       Gdip_AddPathLine(pPathBrders, x1, y1, x2, y2)

    Gdip_FromARGB("0xFF" DrawLineAreaColor, A, R, G, B)
    thisColor := Gdip_ToARGB(DrawLineAreaOpacity, R, G, B)
    thisPen := Gdip_CreatePen(thisColor, thisThick)
    Gdip_SetPenDashStyle(thisPen, DrawLineAreaDashStyle - 1)
    If (DrawLineAreaCapsStyle=1)
       Gdip_SetPenLineCaps(thisPen, 2, 2, 2)

    Static compoundArray := "0.0|0.33|0.67|1.0"
    If (DrawLineAreaDoubles=1)
       Gdip_SetPenCompoundArray(thisPen, compoundArray)

    applyLimits := Gdip_GetPathPointsCount(pPathBrders)>2 ? 1 : 0
    trGdip_RotatePathAtCenter(pPathBrders, VPselRotation, 1, applyLimits, DrawLineAreaKeepBounds, 1)
    trGdip_RotatePathAtCenter(pPathArcs, VPselRotation, 1, 1, DrawLineAreaKeepBounds, 1)
    Gdip_DrawPath(G2, thisPen, pPathBrders)
    Gdip_DrawPath(G2, thisPen, pPathArcs)
    Gdip_DeletePath(pPathBrders)
    Gdip_DeletePath(pPathArcs)
    Gdip_DeletePen(thisPen)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)
}

coreDrawShapesSelectionArea(G2:=0, whichBitmap:=0) {
    If (G2)
    {
       Gdip_GetImageDimensions(whichBitmap, oimgW, oimgH)
       calcImgSelection2bmp(!LimitSelectBoundsImg, oimgW, oimgH, oimgW, oimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       maxLength := min(imgSelW, imgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.05) ? maxLength//1.05 : DrawLineAreaContourThickness
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G2, 2)
    } Else
    {
       G2 := 2NDglPG
       ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
       Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
       calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
       imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
       imgSelW := max(X1, X2) - min(X1, X2)
       imgSelH := max(Y1, Y2) - min(Y1, Y2)
       maxLength := min(qimgSelW, qimgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.05) ? maxLength//1.05 : DrawLineAreaContourThickness
       thisThick := thisThick*zoomLevel
       tk := (DrawLineAreaContourAlign=2) ? tk//2 : tk
       If (DrawLineAreaContourAlign=1)
          tk := 0
       If (userimgGammaCorrect=1 && AnyWindowOpen!=23)
       {
          bgrBMPu := getImgSelectedAreaEditMode(1, imgSelPx - tk, imgSelPy - tk, imgSelW + tk * 2, imgSelH + tk * 2, imgSelW + tk * 2, imgSelH + tk * 2, 0, imgSelW + tk * 2, imgSelH + tk * 2)
          trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx - tk, imgSelPy - tk, imgSelW + tk * 2, imgSelH + tk * 2)
          Gdip_SetCompositingQuality(G2, 2)
          trGdip_DisposeImage(bgrBMPu)
       }
    }

    Gdip_FromARGB("0xFF" DrawLineAreaColor, A, R, G, B)
    thisColor := Gdip_ToARGB(DrawLineAreaOpacity, R, G, B)
    thisPen := Gdip_CreatePen(thisColor, thisThick)
    Gdip_SetPenDashStyle(thisPen, DrawLineAreaDashStyle - 1)
    If (DrawLineAreaCapsStyle=1)
       Gdip_SetPenLineCaps(thisPen, 2, 2, 2)

    Static compoundArray := "0.0|0.33|0.67|1.0"
    If (DrawLineAreaDoubles=1)
       Gdip_SetPenCompoundArray(thisPen, compoundArray)

    pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)
    modus := (DrawLineAreaContourAlign=1) ? 0 : 4
    If (DrawLineAreaContourAlign!=2)
    {
       Gdip_ResetClip(G2)
       Gdip_SetClipPath(G2, pPath, modus)
    }

    Gdip_DrawPath(G2, thisPen, pPath)
    If (DrawLineAreaContourAlign!=2)
       Gdip_ResetClip(G2)

    Gdip_DeletePath(pPath)
    Gdip_DeletePen(thisPen)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)
}

ChangeImageCanvasSize(userW, userH, userAddT, userAddB, userAddL, userAddR, userAddC, vpMode) {
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If (vpMode=1)
    {
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       newW := imgSelW, newH := imgSelH
       If isImgSizeTooLarge(newW, newH)
       {
          calcIMGdimensions(imgSelW, imgSelH, 32500, 32500, newW, newH)
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": WARNING", "Image canvas too large: " imgSelW " x " imgSelH ".`nImage dimensions capped to: " newW " x " newH ".", 0, 0, "exclamation")
       }

       If (isInRange(imgSelW, imgW - 2, imgW + 2) && isInRange(imgSelH, imgH - 2, imgH + 2) && !imgSelPx && !imgSelPy)
          Return

       imgSelPx := - imgSelPx
       imgSelPy := - imgSelPy
       editingSelectionNow := 0
       updateUIctrl()
       MouseMoveResponder()
    } Else If (adjustCanvasMode=1)
    {
       newW := userAddL + userAddR + userAddC + imgW
       newH := userAddT + userAddB + userAddC + imgH
       imgSelPx := userAddL + (userAddC + 1)//2
       imgSelPy := userAddT + (userAddC + 1)//2
    } Else
    {
       newW := userW
       newH := userH
       imgSelPx := (adjustCanvasCentered=1) ? newW//2 - imgW//2 : 0
       imgSelPy := (adjustCanvasCentered=1) ? newH//2 - imgH//2 : 0
    }

    xBitmap := trGdip_CreateBitmap(A_ThisFunc, newW, newH, coreDesiredPixFmt)
    If warnUserFatalBitmapError(xBitmap, A_ThisFunc)
    {
       ResetImgLoadStatus()
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap, 7, 4)
    If !G2
    {
       ResetImgLoadStatus()
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    currIMGdetails.HasAlpha := 1
    If (adjustCanvasNoBgr!=1)
    {
       Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
       thisColor := Gdip_ToARGB(FillAreaOpacity, R, G, B)
       Gdip_SetClipRect(G2, 0, 0, newW, newH, 0)
       Gdip_SetClipRect(G2, imgSelPx, imgSelPy, imgW, imgH, 4)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       If r0
          addJournalEntry(A_ThisFunc "(): failed to set background color through trGdip_GraphicsClear()")
       Gdip_ResetClip(G2)
    }
    ; MsgBox, % newW "--" newH "--" imgSelPx "--" imgSelPy
    ; r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, imgSelPx, imgSelPy, imgW, imgH, 0, 0, imgW, imgH)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, imgSelPx, imgSelPy)
    If (vpMode=1)
       pPath := createImgSelPath(0, 0, newW, newH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)

    If pPath
    {
       Gdip_SetClipPath(G2, pPath, 4)
       Gdip_DeletePath(pPath)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    }

    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(whichBitmap, 1)
    If (r1!="fail")
    {
       UserMemBMP := xBitmap
       recordUndoLevelNow(0, UserMemBMP)
    } Else trGdip_DisposeImage(xBitmap, 1)
    SetTimer, RefreshImageFile, -25
}

ApplySpecialFixedBlur(funcu, zBitmap, radius, pEffect, previewMode:=0) {
    Static offsets := {20:18, 19:16, 18:14, 17:12, 16:10, 15:8, 14:6, 13:4, 12:2, 11:1, 10:2, 9:2, 8:2, 7:2, 6:2, 5:2, 4:2, 3:2, 2:1, 1:1, 0:2}
    If (!pEffect || !zBitmap)
    {
       addJournalEntry("Internal error: " A_ThisFunc "() has failed: " pEffect " | " zBitmap ". Caller: " funcu "()")
       Return
    }

    radius := clampInRange(radius, 1, 509)
    nr := clampInRange(radius - 255, 0, 255)
    If (nr>2 && radius>255 && !InStr(funcu, "ApplySpecialFixedBlur"))
    {
       zA := Gdip_CreateEffect(1, 255, 0, 0)
       Gdip_BitmapApplyEffect(zBitmap, zA)
       Gdip_DisposeEffect(zA)

       zB := Gdip_CreateEffect(1, radius - 255, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, zBitmap, nr, zB, previewMode)
       Gdip_DisposeEffect(zB)
       Return
    } Else If (radius>20 || previewMode=1)
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Return
    }

    If offsets[radius]
       radius += offsets[radius]

    zA := Gdip_CreateEffect(1, radius//2, 0, 0)
    zB := Gdip_CreateEffect(1, radius//2, 0, 0)
    Gdip_ImageRotateFlip(zBitmap, 1)
    Gdip_BitmapApplyEffect(zBitmap, zA)
    Gdip_ImageRotateFlip(zBitmap, 3)
    Gdip_BitmapApplyEffect(zBitmap, zB)
    Gdip_DisposeEffect(zA)
    Gdip_DisposeEffect(zB)
}

applyBlurColorsFX(zBitmap) {
    If (BlurAreaHue!=0 || BlurAreaSaturation!=0)
    {
       zEffect := Gdip_CreateEffect(6, BlurAreaHue, BlurAreaSaturation, 0)
       Gdip_BitmapApplyEffect(zBitmap, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (BlurAreaLight!=0 || BlurAreaGamma!=0)
    {
       zEffect := Gdip_CreateEffect(5, BlurAreaLight, BlurAreaGamma)
       Gdip_BitmapApplyEffect(zBitmap, zEffect)
       Gdip_DisposeEffect(zEffect)
    }
}

BlurSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    allowAlphaMasking := decideAlphaMaskingFeaseable(BlurAreaAlphaMask)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    extendedClone := 1 ; testSelectionLargerThanGiven(imgW, imgH)
    decXbr := (X1<0) ? Abs(X1) : 0
    decYbr := (Y1<0) ? Abs(Y1) : 0
    If (X1<5)
       X1MarginSnap := 1
    If (X2>imgW - 5)
       X2MarginSnap := 1
    If (Y1<5)
       Y1MarginSnap := 1
    If (Y2>imgH - 5)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && blurAreaInverted=1 && EllipseSelectMode=0 && VPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelBlurSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    } Else If (blurAreaAmount<2 && blurAreaPixelizeAmount<2)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "You have set both pixelize amount and blur amount to zero. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelBlurSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h

    If (blurAreaSoftEdges!=1 && pPath)
    {
       modus := (blurAreaInverted=1) ? 4 : 0
       If (blurAreaInverted=1 && pPath)
          Gdip_SetClipPath(G2, pPath, 4)
       Else If (pPath!="")
          Gdip_SetClipPath(G2, pPath, modus)
    }

    If (blurAreaInverted=1)
    {
       imgSelPx := imgSelPy := 0
       imgSelW := imgW
       imgSelH := imgH
    }

    thisOpacity := blurAreaOpacity/255
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    QPV_SetGivenAlphaLevel(zBitmap, 1, 1)

    If (blurAreaPixelizeAmount>1 && blurAreaPixelizeMethod>1)
    {
       thisAmount := blurAreaPixelizeAmount
       thisImgW := (blurAreaPixelizeAmount>1) ? Ceil(imgSelW/blurAreaPixelizeAmount) : imgSelW
       thisImgH := (blurAreaPixelizeAmount>1) ? Ceil(imgSelH/blurAreaPixelizeAmount) : imgSelH
       setWindowTitle("PIXELIZING IMAGE, please wait", 1)
       thisPixiQuality := (blurAreaPixelizeMethod=2) ? 5 : 7
       pixiBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, thisImgW, thisImgH, 0, thisPixiQuality)
       If StrLen(pixiBMP)>2
          newBitmap := trGdip_ResizeBitmap(A_ThisFunc, pixiBMP, imgSelW, imgSelH, 0, 5)

       If (newBitmap && StrLen(pixiBMP)>2)
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := newBitmap
       }
       trGdip_DisposeImage(pixiBMP, 1)
    } Else If (blurAreaPixelizeAmount>1)
    {
       setWindowTitle("PIXELIZING IMAGE, please wait", 1)
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH, coreDesiredPixFmt)
       If warnUserFatalBitmapError(pixiBMP, A_ThisFunc)
       {
          SetTimer, ResetImgLoadStatus, -100
          trGdip_DisposeImage(zBitmap, 1)
          Gdip_DeletePath(pPath)
          Gdip_DeleteGraphics(G2)
          Return "fail"
       }

       thisStartZeit := A_TickCount
       QPV_PixelateBitmap(zBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, min(imgSelW, imgSelH)))
       ; ToolTip, % A_TickCount - thisStartZeit , , , 2
       trGdip_DisposeImage(zBitmap, 1)
       zBitmap := pixiBMP
    }

    thisBlurMode := blurAreaMode
    pEffect := Gdip_CreateEffect(1, blurAreaAmount, 0, 0)
    If (blurAreaTwice=1)
    {
       setWindowTitle("EXTRA-BLURRING IMAGE, please wait", 1)
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, imgSelW//2, imgSelH//2, 1, 3, -1)
       If StrLen(xBitmap)>2
       {
          trGdip_DisposeImage(zBitmap, 1)
          dhMatrix := Gdip_CreateMatrix()
          Gdip_ScaleMatrix(dhMatrix, 2, 2, 1)
          Gdip_TranslateMatrix(dhMatrix, imgSelPx, imgSelPy, 1)
          If (thisBlurMode=3)
          {
             QPV_BoxBlurBitmap(xBitmap, Round(blurAreaAmount/2))
          } Else If (thisBlurMode=2)
          {
             gBitmap := trGdip_BlurBitmap(xBitmap, blurAreaAmount/2.5, 1, 6)
             If !isWinXP
                ApplySpecialFixedBlur(A_ThisFunc, xBitmap, blurAreaAmount, pEffect)

             Gu := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
             If (Gu && gBitmap)
             {
                trGdip_DrawImage(A_ThisFunc, Gu, gBitmap)
                Gdip_DeleteGraphics(Gu)
             }
             trGdip_DisposeImage(gBitmap, 1)
          } Else If (thisBlurMode=1)
             ApplySpecialFixedBlur(A_ThisFunc, xBitmap, blurAreaAmount, pEffect)

          ; trGdip_DisposeImage(zBitmap, 1)
          zBitmap := trGdip_ResizeBitmap(A_ThisFunc, xBitmap, imgSelW, imgSelH, 1, 3, -1)
          trGdip_DisposeImage(xBitmap, 1)
       }
    }

    If (blurAreaAmount<2)
       thisBlurMode := 0
    Else
       setWindowTitle("BLURRING IMAGE, please wait", 1)

    If (thisBlurMode=3) ; box blur
    {
       QPV_BoxBlurBitmap(zBitmap, Round(blurAreaAmount/2))
       gEffect := Gdip_CreateEffect(5, Round(blurAreaAmount/2.5), blurAreaAmount//6)
       If gEffect  ; light readjustments
          Gdip_BitmapApplyEffect(zBitmap, gEffect)

       Gdip_DisposeEffect(gEffect)
    } Else If (thisBlurMode=2)  ; alternate mode
    {
       ; gBitmap := Gdip_BlurNewBitmap(zBitmap, blurAreaAmount, 1, 0)
       gBitmap := trGdip_BlurBitmap(zBitmap, blurAreaAmount/2.5, 1, 6)
       If (!isWinXP && pEffect)
          ApplySpecialFixedBlur(A_ThisFunc, zBitmap, blurAreaAmount, pEffect)

       Gu := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
       If (Gu && gBitmap)
       {
          trGdip_DrawImage(A_ThisFunc, Gu, gBitmap)
          Gdip_DeleteGraphics(Gu)
       }
       trGdip_DisposeImage(gBitmap, 1)
    } Else If (thisBlurMode=1) ; high quality
       ApplySpecialFixedBlur(A_ThisFunc, zBitmap, blurAreaAmount, pEffect)

    If (BlurAreaBlendMode>1 || allowAlphaMasking=1)
       bgrBMPu := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

    If (blurAreaOpacity>252 && blurAreaSoftEdges!=1)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    If (blurAreaSoftEdges=1)
    {
       setWindowTitle("APPLYING SOFT EDGES MASK, please wait", 1)
       thisAmount := (blurAreaTwice=1) ? blurAreaAmount*2 : blurAreaAmount
       thisAmount := (blurAreaSoftLevel>3) ? Round(thisAmount*(blurAreaSoftLevel - 1)) : Round(thisAmount*(blurAreaSoftLevel/3))
       modus := (blurAreaInverted!=1) ? 4 : 0
       carvePathFromBitmap(zBitmap, pPath, imgSelPx , imgSelPy, modus, 2, thisAmount, !blurAreaInverted)
    }

    If (BlurAreaBlendMode>1)
    {
       setWindowTitle("APPLYING BLENDING MODE, please wait", 1)
       If (allowAlphaMasking=1)
          ou := trGdip_CloneBitmap(A_ThisFunc, bgrBMPu)

       applyBlurColorsFX(zBitmap)
       rz := QPV_BlendBitmaps(bgrBMPu, zBitmap, BlurAreaBlendMode - 1, 0)
       If (allowAlphaMasking=1)
          trGdip_DisposeImage(zBitmap)
       Else
          ou := zBitmap
       zBitmap := bgrBMPu
       bgrBMPu := ou
    }

    If (allowAlphaMasking=1 && StrLen(bgrBMPu)>2)
    {
       realtimePasteInPlaceAlphaMasker(0, zBitmap, "lol", newBitmap, 0, 0, 0, 0)
       If StrLen(newBitmap)>2
       {
          r2 := trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH)
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := newBitmap
       }
    }
    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    Gdip_DeleteMatrix(dhMatrix)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    If (r1!="fail" && r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

zoomBlurSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    allowAlphaMasking := decideAlphaMaskingFeaseable(BlurAreaAlphaMask)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    extendedClone := 1 ; testSelectionLargerThanGiven(imgW, imgH)
    decXbr := (X1<0) ? Abs(X1) : 0
    decYbr := (Y1<0) ? Abs(Y1) : 0
    If (X1<5)
       X1MarginSnap := 1
    If (X2>imgW - 5)
       X2MarginSnap := 1
    If (Y1<5)
       Y1MarginSnap := 1
    If (Y2>imgH - 5)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && blurAreaInverted=1 && EllipseSelectMode=0 && VPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelZoomBlurSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h

    If pPath
    {
       modus := (blurAreaInverted=1) ? 4 : 0
       Gdip_SetClipPath(G2, pPath, modus)
    }

    If (blurAreaInverted=1)
    {
       imgSelPx := imgSelPy := 0
       imgSelW := imgW
       imgSelH := imgH
    }

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    QPV_SetGivenAlphaLevel(zBitmap, 1, 1)

    If (BlurAreaBlendMode>1 || allowAlphaMasking=1)
       bgrBMPu := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

    If (blurAreaOpacity>252 && blurAreaSoftEdges!=1)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    setWindowTitle("BLURRING IMAGE, please wait", 1)
    thisOpacity := blurAreaOpacity/255
    startOpacity := thisOpacity/6
    thisBlurAmount := clampInRange(5 + Round(zoomBlurAreaXamount/2) - 2, 5, 20) ; A_Index * thisBlur
    pEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
    gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    G3 := trGdip_GraphicsFromImage(A_ThisFunc, gBitmap, 3, 4)
    thisO := 0.85
    dimgSelPx := imgSelPx, dimgSelPy := imgSelPy
    dimgSelW := imgSelW, dimgSelH := imgSelH

    prcX := (clampInRange(tinyPrevAreaCoordX, imgSelPx, imgSelW) - imgSelPx)/imgSelW
    prcY := (clampInRange(tinyPrevAreaCoordY, imgSelPy, imgSelH) - imgSelPy)/imgSelH
    b := zoomBlurAreaXamount*2
    If isInRange(zoomBlurMode, 1, 3)
    {
       Loop
       {
          thisO -= 0.1 ; thisOpacity - (A_Index - 1) * startOpacity
          If (thisO<0)
             Break

          showTOOLtip("Zoom blur: step " A_Index,, , (1 - thisO)/1)
          ; fnOutputDebug(thisBlurAmount "=" thisO)
          ApplySpecialFixedBlur(A_ThisFunc, zBitmap, thisBlurAmount, pEffect)
          If (zoomBlurMode=1 || zoomBlurMode=2)
             dimgSelW += A_Index * b
          If (zoomBlurMode=1 || zoomBlurMode=3)
             dimgSelH += A_Index * b

          If (zoomBlurMode=1 || zoomBlurMode=2)
             dimgSelPx := 0 - (dimgSelW - imgSelW)*prcX
          If (zoomBlurMode=1 || zoomBlurMode=3)
             dimgSelPy := 0 - (dimgSelH - imgSelH)*prcY

          r1 := trGdip_DrawImage(A_ThisFunc, G3, zBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH,,,,, thisO)
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := trGdip_CloneBitmap(A_ThisFunc, gBitmap)
       }
    } Else
    {
       f := zoomBlurAreaXamount*8
       ff := (zoomBlurAreaXamount*8)/2
       If (zoomBlurMode=4)
       {
          wbitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, imgSelW//ff, imgSelH, 0, 5)
          rbitmap := trGdip_ResizeBitmap(A_ThisFunc, wBitmap, imgSelW//f, imgSelH, 0, 7)
       } Else
       {
          wbitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, imgSelW, imgSelH//ff, 0, 5)
          rbitmap := trGdip_ResizeBitmap(A_ThisFunc, wBitmap, imgSelW, imgSelH//f, 0, 7)
       }

       fbitmap := trGdip_ResizeBitmap(A_ThisFunc, rBitmap, imgSelW, imgSelH, 0, 7)
       r1 := trGdip_DrawImage(A_ThisFunc, G3, fBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
       trGdip_DisposeImage(wBitmap)
       trGdip_DisposeImage(rBitmap)
       trGdip_DisposeImage(fBitmap)
    }

    Gdip_DeleteGraphics(G3)
    If (BlurAreaBlendMode>1)
    {
       setWindowTitle("APPLYING BLENDING MODE, please wait", 1)
       applyBlurColorsFX(gBitmap)
       If (allowAlphaMasking=1)
          ou := trGdip_CloneBitmap(A_ThisFunc, bgrBMPu)

       rz := QPV_BlendBitmaps(bgrBMPu, gBitmap, BlurAreaBlendMode - 1, 0)
       If (allowAlphaMasking=1)
          trGdip_DisposeImage(gBitmap)
       Else
          ou := gBitmap
       gBitmap := bgrBMPu
       bgrBMPu := ou
    }

    If (allowAlphaMasking=1 && StrLen(bgrBMPu)>2)
    {
       realtimePasteInPlaceAlphaMasker(0, gBitmap, "lol", newBitmap, 0, 0, 0, 0)
       If StrLen(newBitmap)>2
       {
          r2 := trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH)
          trGdip_DisposeImage(gBitmap, 1)
          gBitmap := newBitmap
       }
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, gBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    Gdip_DisposeEffect(pEffect)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    If (r1!="fail" && r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

detectEdgesSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    thisCount := (isNumber(IDedgesEmbossLvl) && IDedgesBlendMode>1) ? clampInRange(IDedgesEmbossLvl, 1, 10) : 1
    Loop, % thisCount
    {
       setWindowTitle("DETECTING EDGES - iteration " A_Index "/" thisCount ", please wait", 1)
       r0 := coreDetectEdgesSelectedArea(whichBitmap, 0, G2)
       If r0
          Break
    }

    Gdip_DeleteGraphics(G2)
    If (r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

coreDetectEdgesSelectedArea(whichBitmap, previewMode, Gu:=0) {
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (previewMode!=1)
    {
       G2 := Gu
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelPx := pB.x,  imgSelPy := pB.y
       imgSelW  := pB.w,  imgSelH  := pB.h
    } Else
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
       {
          SetTimer, ResetImgLoadStatus, -100
          Return "fail"
       }
       imgSelPx := imgSelPy := 0
       imgSelW := imgW, imgSelH := imgH
    }

    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    fBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    If (IDedgesBlendMode>1)
       gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)

    If (IDedgesCenterAmount>1)
    {
       pEffect := Gdip_CreateEffect(1, IDedgesCenterAmount, 0, 0)
       If pEffect
          ApplySpecialFixedBlur(A_ThisFunc, zBitmap, IDedgesCenterAmount, pEffect)

       Gdip_DisposeEffect(pEffect)
    }

    G3 := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
    r0 := trGdip_DrawImage(A_ThisFunc, G3, zBitmap, IDedgesXuAmount, IDedgesYuAmount)
    QPV_BlendBitmaps(fBitmap, zBitmap, 16, 0) ; difference mode

    zEffect := Gdip_CreateEffect(6, 0, -100, 0)  ; desaturate image
    If zEffect
       Gdip_BitmapApplyEffect(fBitmap, zEffect)
    Gdip_DisposeEffect(zEffect)

    If (IDedgesEmphasis!=0 || IDedgesContrast!=0)
       wEffect := Gdip_CreateEffect(5, IDedgesEmphasis, IDedgesContrast, 0)

    If wEffect
       Gdip_BitmapApplyEffect(fBitmap, wEffect)

    Gdip_DisposeEffect(wEffect)
    If (IDedgesInvert=1)
    {
       zEffect := Gdip_CreateEffect(7, 0, 0, 100)
       If zEffect
          Gdip_BitmapApplyEffect(fBitmap, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (IDedgesAfterBlur>1)
    {
       pEffect := Gdip_CreateEffect(1, IDedgesAfterBlur*2, 0, 0)
       If pEffect
          ApplySpecialFixedBlur(A_ThisFunc, fBitmap, IDedgesAfterBlur*2, pEffect)

       Gdip_DisposeEffect(pEffect)
    }

    If (IDedgesBlendMode>1)
    {
       QPV_BlendBitmaps(gBitmap, fBitmap, IDedgesBlendMode - 1, 0)
       If (previewMode!=1 && IDedgesOpacity>253)
          r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    }

    thisOpacity := IDedgesOpacity/255
    thisBMP := (IDedgesBlendMode>1 && gBitmap) ? gBitmap : fBitmap
    If (previewMode!=1)
       carvePathFromBitmap(thisBMP, pPath, pB.x, pB.y, 4)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(fBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G3)
    If (previewMode=1)
       Gdip_DeleteGraphics(G2)
    er := r1 ? r1 : r0
    Return er
}

addNoiseSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4,, compositingQuality)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    setWindowTitle("ADDING NOISE, please wait", 1)
    r0 := coreAddNoiseSelectedArea(whichBitmap, 0, G2)

    Gdip_DeleteGraphics(G2)
    If (r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

coreAddNoiseSelectedArea(whichBitmap, previewMode, Gu:=0) {
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (previewMode!=1)
    {
       G2 := Gu
       allowAlphaMasking := decideAlphaMaskingFeaseable(BlurAreaAlphaMask)
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelPx := pB.x,  imgSelPy := pB.y
       imgSelW  := pB.w,  imgSelH  := pB.h
    } Else
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
       {
          SetTimer, ResetImgLoadStatus, -100
          Return "fail"
       }
       imgSelPx := imgSelPy := 0
       imgSelW := imgW, imgSelH := imgH
    }

    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    thisPixelize := (doubleBlurPreviewArea=1 && previewMode=1) ? UserAddNoIsePixelizeAmount/2 : UserAddNoIsePixelizeAmount
    thisImgW := (thisPixelize>1) ? Ceil(imgSelW/thisPixelize) : imgSelW
    thisImgH := (thisPixelize>1) ? Ceil(imgSelH/thisPixelize) : imgSelH
    noiseBMP := QPV_CreateBitmapNoise(thisImgW, thisImgH, UserAddNoiseIntensity, UserAddNoiseMode, 1)
    If (thisPixelize>1)
    {
       newBitmap := trGdip_ResizeBitmap(A_ThisFunc, noiseBMP, imgSelW, imgSelH, 0, 5)
       If StrLen(newBitmap)>2
       {
          trGdip_DisposeImage(noiseBMP, 1)
          noiseBMP := newBitmap
       }
    }

    fBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    thisBlurAmount := (doubleBlurPreviewArea=1 && previewMode=1) ? UserAddNoiseBlurAmount//2 : UserAddNoiseBlurAmount
    If (thisBlurAmount>1)
    {
       pEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, noiseBMP, thisBlurAmount, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If (IDedgesEmphasis!=0 || IDedgesContrast!=0)
       wEffect := Gdip_CreateEffect(5, IDedgesEmphasis, IDedgesContrast, 0)

    If wEffect
       Gdip_BitmapApplyEffect(noiseBMP, wEffect)

    Gdip_DisposeEffect(wEffect)
    If (IDedgesInvert=1)
    {
       zEffect := Gdip_CreateEffect(7, 0, 0, 100)
       If zEffect
          Gdip_BitmapApplyEffect(noiseBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (IDedgesBlendMode>1)
    {
       gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
       If StrLen(gBitmap)>2
          QPV_BlendBitmaps(gBitmap, noiseBMP, IDedgesBlendMode - 1, 0)
    }

    ; r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    thisOpacity := IDedgesOpacity/255
    thisBMP := (IDedgesBlendMode>1 && StrLen(gBitmap)>2) ? gBitmap : noiseBMP
    If (previewMode!=1)
       carvePathFromBitmap(thisBMP, pPath, pB.x, pB.y, 4)

    If (allowAlphaMasking=1 && StrLen(fBitmap)>2 && previewMode!=1)
    {
       realtimePasteInPlaceAlphaMasker(0, thisBMP, "lol", newBitmap, 0, 0, 0, 0)
       If StrLen(newBitmap)>2
       {
          r2 := trGdip_DrawImage(A_ThisFunc, G2, fBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := newBitmap
       }
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    trGdip_DisposeImage(fBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    trGdip_DisposeImage(newBitmap, 1)
    trGdip_DisposeImage(noiseBMP, 1)
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    Gdip_DeletePath(pPath)
    If (previewMode=1)
       Gdip_DeleteGraphics(G2)

    er := r1 ? r1 : r0
    Return er
}

livePreviewsPanelNoEffects() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    Gdip_DeleteGraphics(G)

    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
 }

livePreviewIDedges() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    Gdip_DeleteGraphics(G)

    thisCount := (isNumber(IDedgesEmbossLvl) && IDedgesBlendMode>1) ? clampInRange(IDedgesEmbossLvl, 1, 10) : 1
    Loop, % thisCount
    {
       r0 := coreDetectEdgesSelectedArea(cornersBMP, 1)
       If r0
          Break
    }

    flipBitmapAccordingToViewPort(cornersBMP, 1)
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
}

livePreviewAddNoiser() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)

    Gdip_DeleteGraphics(G)
    r0 := coreAddNoiseSelectedArea(cornersBMP, 1)
    flipBitmapAccordingToViewPort(cornersBMP, 1)
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
}

QPV_BoxBlurBitmap(pBitmap, passes) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BoxBlurBitmap(pBitmap, passes)
  }

  If !pBitmap
     Return 0

  Gdip_GetImageDimensions(pBitmap, w, h)
  If (w<1 || h<1)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  If E1
     Return 0

  func2exec := (A_PtrSize=8) ? "BoxBlurBitmap" : "_BoxBlurBitmap@20"
  r := DllCall(whichMainDLL "\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", stride, "Int", passes)
  Gdip_UnlockBits(pBitmap, iData)
  ; DllCall("GlobalFree", "ptr", mCodeFunc)
  return r
}

QPV_PixelateBitmap(pBitmap, ByRef pBitmapOut, BlockSize) {
   initQPVmainDLL()
   If !qpvMainDll
   {
      addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
      Return ; Gdip_PixelateBitmap(pBitmap, pBitmapOut, BlockSize)
   }

   if (!pBitmap || !pBitmapOut)
      return -3

   Gdip_GetImageDimensions(pBitmap, Width, Height)
   If (width<1 || height<1)
      Return 0

   if (Width!=Gdip_GetImageWidth(pBitmapOut) || Height!=Gdip_GetImageHeight(pBitmapOut))
      return -1

   if (BlockSize>Width || BlockSize>Height)
      return -2

   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1, 1)
   E2 := Gdip_LockBits(pBitmapOut, 0, 0, Width, Height, Stride2, Scan02, BitmapData2)

   func2exec := (A_PtrSize=8) ? "PixelateBitmap" : "_PixelateBitmap@24"
   if (!E1 && !E2)
      r := DllCall(whichMainDLL "\" func2exec, "UPtr", Scan01, "UPtr", Scan02, "int", Width, "int", Height, "int", Stride1, "int", BlockSize)
   
   If !E1
      Gdip_UnlockBits(pBitmap, BitmapData1)

   If !E2
      Gdip_UnlockBits(pBitmapOut, BitmapData2)
   return r
}

applyVPeffectsOnBMP(zBitmap) {
    Gdip_GetImageDimensions(zBitmap, imgW, imgH)
    r := decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If pEffect
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If (imageAttribs && matrix && !InStr(r, "moreThanClrMatrix"))
    {
       CreateColourMatrix(matrix, datau)
       pEffect := Gdip_CreateEffect(3, matrix, 0)
       If pEffect
       {
          Gdip_BitmapApplyEffect(zBitmap, pEffect)
          Gdip_DisposeEffect(pEffect)
       }
    } Else If imageAttribs
    {
       bluba := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
       If StrLen(bluba)>2
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, bluba)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap,,,,,,,,,,, imageAttribs)
          Gdip_DeleteGraphics(G2)
          If (r1!="fail" && G2)
          {
             trGdip_DisposeImage(zBitmap, 1)
             zBitmap := bluba
          }
       }
    }
    Return zBitmap
}

applyVPeffectsAdvOnBMP(zBitmap, allowCache:=0, givenID:=0, gImgW:=0, gImgH:=0, BlurAmount:=0, applyVPfx:=1) {
    Static prevState, prevBMP
    If (zBitmap="kill")
    {
       prevState := 0
       prevBMP := trGdip_DisposeImage(prevBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(zBitmap, imgW, imgH)
    If (applyVPfx=1)
       r := decideGDIPimageFX(matrix, imageAttribs, pEffect)
    Else
       r := 1

    thisState := "a" r gImgW gImgH imgW imgH givenID
    If (allowCache=1 && thisState=prevState)
    {
       Gdip_DisposeImageAttributes(imageAttribs)
       Gdip_DisposeEffect(pEffect)
       Return trGdip_CloneBitmap(A_ThisFunc, prevBMP)
    }

    prevState := 0
    prevBMP := trGdip_DisposeImage(prevBMP, 1)
    If (imgW!=gImgW || imgH!=gImgH) && (gImgW>1 && gImgH>1)
       nBitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, gImgW, gImgH, 0, 3)
    Else
       nBitmap := trGdip_CloneBitmap(A_ThisFunc, zBitmap)

    If pEffect
    {
       Gdip_BitmapApplyEffect(nBitmap, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If (imageAttribs && matrix && !InStr(r, "moreThanClrMatrix"))
    {
       CreateColourMatrix(matrix, datau)
       pEffect := Gdip_CreateEffect(3, matrix, 0)
       If pEffect
       {
          Gdip_BitmapApplyEffect(nBitmap, pEffect)
          Gdip_DisposeEffect(pEffect)
       }
    } Else If imageAttribs
    {
       bluba := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
       If StrLen(bluba)>2
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, bluba)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, nBitmap,,,,,,,,,,, imageAttribs)
          Gdip_DeleteGraphics(G2)
          If (r1!="fail" && G2)
          {
             trGdip_DisposeImage(nBitmap, 1)
             nBitmap := bluba
          }
       }
    }

    fnOutputDebug("redraw: " A_ThisFunc)
    If (BlurAmount>1)
    {
       pEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, nBitmap, BlurAmount, pEffect, 0)
       Gdip_DisposeEffect(pEffect)
    }

    Gdip_DisposeImageAttributes(imageAttribs)
    prevState := (allowCache=1 && minimizeMemUsage=0) ? thisState : 0
    prevBMP := (allowCache=1 && minimizeMemUsage=0) ? trGdip_CloneBitmap(A_ThisFunc, nBitmap) : 0
    Return nBitmap
}

GetPathRelativeBounds(pPath, imgSelPx, imgSelPy) {
    pB := getAccuratePathBounds(pPath)
    pB.xa := Round(imgSelPx + pB.x)
    pB.ya := Round(imgSelPy + pB.y)
    pB.w := Round(pB.w)
    pB.h := Round(pB.h)
    Return pB
}

getSelectedImageArea(whichBitmap, doCarving, limitBounds, applyVPfx, fakeBGR) {
    If StrLen(whichBitmap)<3
    {
       addJournalEntry(A_ThisFunc "(): failed; no bitmap given")
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!limitBounds, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    pPath := createImgSelPath(0, 0, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    If pPath
    {
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       pBxa := (limitBounds=1) ? imgSelPx : pB.xa
       pBya := (limitBounds=1) ? imgSelPy : pB.ya
       pBw := (limitBounds=1) ? imgSelW : pB.w
       pBh := (limitBounds=1) ? imgSelH : pB.h
       ; pBw := (limitBounds=1) ? pBzw a + 1) : pB.w
       ; pBh := (limitBounds=1) ? pBzh a + 1) : pB.h
       ; ToolTip, % imgSelPx "===" imgSelPy "`n" pBw "===" pBh , , , 2
       ; extendedClone := !limitBounds ; (A_PtrSize=8) ? 1 : 0
       dummyBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, pBxa, pBya, pBw, pBh, 0, 0, 1, 0)
       If (applyVPfx>0)
          dummyBMP := applyVPeffectsOnBMP(dummyBMP)

       If (doCarving=1 && dummyBMP)
          carvePathFromBitmap(dummyBMP, pPath, pB.x, pB.y, 4, fakeBGR)

       If (applyVPfx=2)
          flipBitmapAccordingToViewPort(dummyBMP)

       ; QPV_SetGivenAlphaLevel(dummyBMP, 1, 1)
       Gdip_DeletePath(pPath)
       Return dummyBMP
    } Else addJournalEntry(A_ThisFunc "(): failed to create GDI+ object path")
}

CropImageInViewPortToSelection(modus:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    whichBitmap := useGdiBitmap()
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If throwErrorSelectionOutsideBounds(whichBitmap)
       Return

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (UserMemBMP=whichBitmap)
       xBitmap := UserMemBMP

    If (modus!="simplex" && EllipseSelectMode=0 && isInRange(imgSelW, imgW - 2, imgW + 2) && isInRange(imgSelH, imgH - 2, imgH + 2) && !imgSelPx && !imgSelPy)
    {
       MouseMoveResponder()
       SetTimer, RefreshImageFile, -25
       Return
    }

    dummyBMP := getSelectedImageArea(whichBitmap, 1, 0, 0, 0)
    If StrLen(dummyBMP)>1
    {
       recordUndoLevelNow("init", 0)
       If (EllipseSelectMode>0 || VPselRotation>0 || X1<0 || Y1<0 || X2>imgW || Y2>ImgH) || (innerSelectionCavityX>0.01 && innerSelectionCavityY>0.01)
          currIMGdetails.HasAlpha := 1
       UserMemBMP := dummyBMP
       recordUndoLevelNow(0, UserMemBMP)
       trGdip_DisposeImage(xBitmap, 1)
    } Else
    {
       showTOOLtip("Failed to crop image to selected area")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (modus="simplex")
       Return

    editingSelectionNow := 0
    vpIMGrotation := 0
    updateUIctrl()
    MouseMoveResponder()
    SetTimer, RefreshImageFile, -25
    SetTimer, dummyInfoImgCropVP, -125
}

dummyInfoImgCropVP() {
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW*imgH)/1000000, 2)
   showTOOLtip("Image canvas size set to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px | " Round(imgW/imgH, 2) " | " mpx " MPx" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

MenuPasteHDropFiles() {
   r := PasteHDropFiles(1)
   If !r
   {
      showTOOLtip("No image files identified in the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PasteHDropFiles(allowFilesPaste) {
   Try testClipTypeImgA := IsClipboardFormatAvailable(8)
   Try testClipTypeImgB := IsClipboardFormatAvailable(2)
   If (testClipTypeImgA=1 || testClipTypeImgB=1)
      Return

   Try testClipType := IsClipboardFormatAvailable(15)
   Try imgsListu := Clipboard
   If (testClipType!=1)
   {
      filesFound := 0
      Loop, Parse, imgsListu, `n,`r
      {
           If FileExist(Trimmer(A_LoopField))
              filesFound := 1
      } Until (A_Index>5)

      If (filesFound!=1)
      {
         ResetImgLoadStatus()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   If (testClipType=1 || filesFound=1) && (allowFilesPaste=0)
   {
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }

   countFiles := ST_Count(Trimmer(imgsListu), "`n")
   If (countFiles>0 && StrLen(imgsListu)>4)
   {
      showTOOLtip("Files identified in the clipboard")
      msgResult := msgBoxWrapper(appTitle ": Paste files", "You have " countFiles " file entries stored in the clipboard by your file explorer or manager.`n`nWould you like to import the image files (if any) into the files list of " appTitle "?", 4, 0, "question", "Select newly inserted index entries")
   }

   If InStr(msgResult.btn, "yes")
   {
      initialIndex := maxFilesIndex
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir, msgResult.check)
      If (initialIndex!=maxFilesIndex)
      {
         currentFileIndex := maxFilesIndex - 1
         GenerateRandyList()
         dummyTimerDelayiedImageDisplay(50)
         ForceRefreshNowThumbsList()
         newFiles := max(initialIndex, maxFilesIndex) - min(initialIndex, maxFilesIndex)
         showTOOLtip("Finished adding " groupDigits(newFiles) " files to the current list from the clipboard")
      } Else showTOOLtip("No image files identified in the clipboard`nFiles list unchanged.")
   } Else RemoveTooltip()

   ResetImgLoadStatus()
   createGUItoolbar()
   SetTimer, TriggerMenuBarUpdate, -90
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return 1
}

corePasteClipboardImg(modus, imgW, imgH, allowFilesPaste) {
    clipBMP := Gdip_CreateBitmapFromClipboard()
    If StrLen(clipBMP)>2
       createdGDIobjsArray["x" clipBMP] := [clipBMP, "bmp", 1, A_ThisFunc]

    If (isInRange(Abs(clipBMP), 1, 5) || !clipBMP)
    {
       If PasteHDropFiles(allowFilesPaste)
          Return

       Try toPaste := Trimmer(Clipboard)
       If StrLen(toPaste)>2
       {
          textMode := 1
          toPaste := SubStr(toPaste, 1, 9500)
          clipBMP := drawTextInBox(toPaste, OSDFontName, PasteFntSize, imgW, imgH, OSDtextColor, OSDbgrColor, 0, 0, usrTextAlign, "0xFF")
          If (modus=1)
             showTOOLtip("Text clipboard content rendered as image`nOSD font and colors used")
          SetTimer, RemoveTooltip, % -msgDisplayTime
       } Else
       {
          Tooltip
          showTOOLtip("ERROR: Unable to retrieve image from clipboard")
          SetTimer, ResetImgLoadStatus, -25
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    }

    ; disposeCacheIMGs()
    If StrLen(clipBMP)<3
       Return

    If (!InStr(Gdip_GetImagePixelFormat(clipBMP, 1), "0xE200") && coreDesiredPixFmt="0xE200B")
    {
       krpBmp := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
       If krpBmp
       {
          trGdip_DisposeImage(clipBMP, 1)
          clipBMP := krpBmp
       }
    }
    ; MsgBox, % Gdip_GetImagePixelFormat(clipBMP, 1)
    Return clipBMP
}

tlbrPasteClipboardIMG() {
   If (isImgEditingNow()=1 && editingSelectionNow=1)
      PanelPasteInPlace()
   Else
      PasteClipboardIMG()
}

PasteClipboardIMG(modus:=0, clipBMP:=0) {
    Critical, on
    Static clippyCount := 0

    If (AnyWindowOpen>0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    ; If askAboutFileSave(" and the clipboard image or files entries are going to be pasted")
    ;    Return

    setImageLoading()
    changeMcursor()
    calcScreenLimits()
    imgPath := getIDimage(currentFileIndex)
    If (modus!="scanner")
    {
       showTOOLtip("Retrieving clipboard, please wait")
       If PasteHDropFiles(1)
          Return

       clipBMP := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 1)
    }

    If !clipBMP
    {
       ResetImgLoadStatus()
       SetTimer, RemoveTooltip, -500
       Return
    }

    isImgOpen := 1
    If isImgEditingNow()
       isImgOpen := 2
    Else If (!currentFileIndex || !CurrentSLD || !maxFilesIndex || !imgPath)
       isImgOpen := 0

    ; terminateIMGediting()
    If (isImgOpen=2)
       recordUndoLevelNow("init", 0)

    clippyCount++
    UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    If (editingSelectionNow=1)
       ToggleEditImgSelection()

    discardViewPortCaches()
    UserMemBMP := clipBMP
    If (isImgOpen=0)
    {
       maxFilesIndex := currentFileIndex := 0
       labelu := (modus="scanner") ? "WIA-Acquired-" : "Clipboard-"
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\" labelu "-" clippyCount ".img"
    }
    
    If (modus!="scanner")
    {
       currIMGdetails.HasAlpha := 1
       isUniform := Gdip_TestBitmapUniformity(clipBMP, 7, maxLevelIndex)
       If (isUniform=1 && isInRange(maxLevelIndex, 252, 255))
          currIMGdetails.HasAlpha := 0
    } Else currIMGdetails.HasAlpha := 0

    ; ToolTip, % currIMGdetails.HasAlpha " = lol" , , , 2
    imgIndexEditing := currentFileIndex
    vpIMGrotation := FlipImgH := FlipImgV := 0
    currentImgModified := usrColorDepth := imgFxMode := 1
    defineColorDepth()
    dropFilesSelection(1)
    RemoveTooltip()
    INIaction(1, "FlipImgH", "General")
    INIaction(1, "FlipImgV", "General")
    INIaction(1, "usrColorDepth", "General")
    INIaction(1, "imgFxMode", "General")
    If (isImgOpen=2)
       recordUndoLevelNow(0, UserMemBMP)
    RefreshImageFile()
    SetTimer, createGUItoolbar, -100
    SetTimer, ResetImgLoadStatus, -55
    SetTimer, TriggerMenuBarUpdate, -95
}

thumbsSelector(keyu, aKey, prevFileIndex) {
  Static lastInvoked := 1

  ; ToolTip, % prevFileIndex "--" markedSelectFile 
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Upu" || keyu="Home") && prevFileIndex<=1)
  || (InStr(aKey, "+") && (keyu="Right" || keyu="Down" || keyu="End") && prevFileIndex>=maxFilesIndex)
     Return

  selA := resultedFilesList[currentFileIndex, 2]
  selB := resultedFilesList[prevFileIndex, 2]
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Right"))
  {
     testIndex := (keyu="Left") ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (keyu="Left") ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
        markedSelectFile++
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 1
     } Else If (selA=1 && selB=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 0
        markedSelectFile -= 2
     }

     markedSelectFile++
     lastZeitFileSelect := A_TickCount
  } Else If InStr(aKey, "+") ; && (keyu="Upu" || keyu="Down"))
  {
     direction := (keyu="Down" || keyu="PgDn" || keyu="End") ? 1 : 0
     testIndex := (direction!=1) ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (direction!=1) ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
        lastZeitFileSelect := A_TickCount
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 1)
        lastZeitFileSelect := A_TickCount
     } Else If (selA=1 && selB=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 0)
        resultedFilesList[currentFileIndex, 2] := 1
        lastZeitFileSelect := A_TickCount
        markedSelectFile++
     }
  }

  If (markedSelectFile=1 && InStr(aKey, "+"))
  {
     markedSelectFile := 0
     lastZeitFileSelect := A_TickCount
     resultedFilesList[currentFileIndex, 2] := 0
  }
}

generateNumberRangeString(pA, pB) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
        stringRange .= "," mA + A_Index - 1 "|"

    Return stringRange
}

selectFilesRange(pA, pB, sel) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
    {
        oSel := resultedFilesList[mA + A_Index - 1, 2]
        resultedFilesList[mA + A_Index - 1, 2] := sel
        If (sel=1 && oSel!=1)
           markedSelectFile++
        Else If (sel!=1 && oSel=1)
           markedSelectFile--
    }
    lastZeitFileSelect := A_TickCount
    Return rangeC
}

jumpSelectRangeGiven(pA, pB) {
   mB := max(pA, pB)
   mA := min(pA, pB)
   rangeC := mB - mA + 1
   changeMcursor()
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection. The given range is: " mA " - " mB, "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel" || InStr(msgResult, "win_close"))
      {
         SetTimer, RemoveTooltip, -250
         Return
      }
   }

   If (msgResult="replace" || !msgResult)
   {
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   Loop, % rangeC
      resultedFilesList[mA + A_Index - 1, 2] := (msgResult="add" || !msgResult) ? 1 : 0

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ResetImgLoadStatus()
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   Return rangeC
}

ThumbsNavigator(keyu, aKey) {
  resetSlideshowTimer(0)
  If (thumbsDisplaying!=1 && maxFilesIndex>1)
  {
     If askAboutFileSave(" and another image will be loaded")
        Return
  }

  prevFileIndex := currentFileIndex
  thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
  If (keyu="Down")
  {
     currentFileIndex := currentFileIndex + maxItemsW - 1
     NextPicture(0, 0, 1)
  } Else If (keyu="Upu")
  {
     currentFileIndex := currentFileIndex - maxItemsW + 1
     PreviousPicture(0, 0, 1)
  } Else If (keyu="PgUp")
  {
     currentFileIndex := currentFileIndex - maxItemsPage + 1
     PreviousPicture()
  } Else If (keyu="PgDn")
  {
     Loop, % maxItemsH
     {
        currentFileIndex := currentFileIndex + maxItemsW - 1
        NextPicture(0, 0, 1)
        thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
     }
     ; currentFileIndex := currentFileIndex + maxItemsPage - 1
     ; NextPicture()
  } Else If (keyu="Left")
     PreviousPicture()
  Else If (keyu="Right")
     NextPicture()
  Else If (keyu="End")
     LastPicture()
  Else If (keyu="Home")
     FirstPicture()

  thumbsSelector(keyu, aKey, prevFileIndex)
  If (thumbsDisplaying!=1 && InStr(aKey, "+"))
     dummyTimerDelayiedImageDisplay(50)
}

PanIMGonScreen(direction, thisKey) {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   fastMode := (InStr(thisKey, "+") || InStr(thisKey, "-")) ? 1 : 0
   If (fastMode=1)
      zL := clampInRange(zoomLevel, 0.8, 3.2)
   Else
      zL := clampInRange(zoomLevel, 0.7, 2.1)

   stepu := InStr(thisKey, "+") ? 0.35 * zL : 0.1 * zL
   stepu := Round(mainHeight*stepu + mainWidth*stepu)//2 + 1
   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY + stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX + stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX - stepu

   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      diffIMGdecY := stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      diffIMGdecY := - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      diffIMGdecX := stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      diffIMGdecX := - stepu

   If (thisKey!="-")
      dummyTimerDelayiedImageDisplay(5)
}

dummyTimerDelayiedImageDisplay(timeru:=0) {
  If (timeru>1)
     SetTimer, extraDummyDelayiedImageDisplay, % -timeru ; , 950
}

extraDummyDelayiedImageDisplay() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -15
     Return
  }
  DelayiedImageDisplay()
}

filterDelayiedImageDisplay() {
  Static lastInvoked := 1
  If (A_tickcount - lastInvoked < 60)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -50
     Return
  }
  lastInvoked := A_TickCount
  DelayiedImageDisplay()
  lastInvoked := A_TickCount
}

DelayiedImageDisplay() {
   If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
   {
      r := IDshowImage(currentFileIndex)
      If !r
         informUserFileMissing(1)
   }
}

DonateNow() {
   Try Run, https://www.paypal.me/MariusSucan/10
}

openSettingsDir() {
   Try Run, % mainCompiledPath
}

DeleteAllSettings() {
    SoundBeep, 300, 300
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete ALL personalized settings?`n`n" appTitle " will automatically restart if you choose to do so. This action is irreversible.", "&Restore defaults|&Cancel", 2, "exclamation")
    If (msgResult="restore defaults")
    {
       RegDelete, % QPVregEntry "\PanelOptions"
       FileSetAttrib, -R, % mainSettingsFile
       FileDelete, % mainSettingsFile
       terminateIMGediting()
       restartAppu()
    }
}

externalinvokedSettingsContextMenu(keyu:=0, simulated:=0) {
    Static listu := {3:1,2:1,60:1,3:1,2:1,48:1,59:1,60:1,39:1,71:1}
    hwndA := WinActive("ahk_id " hSetWinGui)
    hwndB := WinActive("ahk_id " MsgBox2hwnd)
    hwnd := ((hwndA=hSetWinGui || hwndB=MsgBox2hwnd) && AnyWindowOpen) ? 1 : 0
    If (hwnd!=1)
       Return 0

    If (AnyWindowOpen && MsgBox2hwnd=hwndB && hwndB && MsgBox2InputHook)
       GuiControlGet, OutputVar, WinMsgBox: Focus
    Else If AnyWindowOpen
       GuiControlGet, OutputVar, SettingsGUIA: Focus
    ; ToolTip, % OutputVar , , , 2
    If !InStr(OutputVar, "listview")
       Return 0

    If (simulated=1 && listu[AnyWindowOpen]=1)
       Return 1

    If (AnyWindowOpen=3 && inStr(keyu, "appskey"))
       invokePanelDynaFoldersContextMenu()
    Else If (AnyWindowOpen=2 && inStr(keyu, "appskey"))
       invokePanelStaticFoldersContextMenu()
    Else If (AnyWindowOpen=60 && inStr(keyu, "appskey"))
       invokePanelReviewSelContextMenu()
    Else If ((AnyWindowOpen=3 || AnyWindowOpen=2) && inStr(keyu, "enter"))
       BtnPanelStaticJumpFirst()
    Else If ((AnyWindowOpen=48 || AnyWindowOpen=59) && inStr(keyu, "enter"))
       IndexStatsLVaction(0, "DoubleClick")
    Else If (AnyWindowOpen=60 && inStr(keyu, "enter"))
       BTNreviewPaneLV("menu-mode", "DoubleClick", 0)
    Else If (AnyWindowOpen=39 && inStr(keyu, "enter"))
       SeenStatsLVaction(hwnd, "DoubleClick")
    Else If (AnyWindowOpen=71 && inStr(keyu, "enter"))
       LVkeywordResponder(hwnd, "RightClick", "enter")
    Else If (AnyWindowOpen && inStr(keyu, "AppsKey"))
       invokePrefsPanelsContextMenu()
}

SettingsGUIAGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1

    If (GuiHwnd!=hSetWinGui)
       Return

    If (AnyWindowOpen=3 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelDynaFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen=2 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelStaticFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen=60 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelReviewSelContextMenu()
       Return
    } Else If (AnyWindowOpen && !InStr(A_GuiControl, "lview") && IsRightClick=1) 
    {
       If SettingsToolTips()
          Return
    }

    If (CtrlHwnd && IsRightClick=1) || ((A_TickCount - lastInvoked>250) && IsRightClick=0) ; || (mouseToolTipWinCreated=1)
    {
       lastInvoked := A_TickCount
       Return
    }

    lastInvoked := A_TickCount
    invokePrefsPanelsContextMenu()
    Return
}

QuickMenuSearchGUIAGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1

    If (GuiHwnd!=hQuickMenuSearchWin)
       Return

    addBonus := 0
    folderPath := OmniBoxGetSelectedFolder()
    If folderPath
    {
       If FolderExist(folderPath)
       {
          createOmniBoxFoldersContextMenu(folderPath)
          Return
       } Else addBonus := 1
    }

    lastInvoked := A_TickCount
    invokePrefsPanelsContextMenu(1, addBonus)
}

OmniBoxGetSelectedFolder(givenRow:=0, isGiven:=0, givenPath:=0) {
    Gui, QuickMenuSearchGUIA: Default
    Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
    If (givenRow>0 && isGiven="yes" && InStr(givenPath, ":\"))
    {
       edithu := givenPath
       RowNumber := givenRow
    } Else
    {
       GuiControlGet, userQuickMenusEdit
       edithu := Trimmer(userQuickMenusEdit)
       edithu := Trimmer(StrReplace(edithu, "\\", "\"), "\")
       RowNumber := LV_GetNext(0, "F")
    }

    LV_GetText(funcu, RowNumber, 6)
    LV_GetText(folderu, RowNumber, 2)
    If InStr(funcu, "!OmniNavigateFilteredFolders")
       edithu := SubStr(edithu, 1, InStr(edithu, "\", 0, -1))

    If (SubStr(edithu, 2, 2)=":\" && (InStr(funcu, "!OmniNavigateFolder") || InStr(funcu, "!OmniNavigateFilteredFolders")))
       Return edithu folderu
}

omniBoxFolderImport(dummy:=0, isGiven:=0) {
   If (maxFilesIndex<1 || !CurrentSLD)
      omniBoxFolderOpen()
   Else
      folderPath := OmniBoxGetSelectedFolder()

   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   changeMcursor()
   If ((dummy="not" || dummy="recursively") && isGiven="yes")
      addNewFolder2list(folderPath, "yes", dummy)
   Else If GetKeyState("Shift", "P")
      addNewFolder2list(folderPath, "yes", "recursive")
   Else
      addNewFolder2list(folderPath, "yes")

   ResetImgLoadStatus()
   currentFileIndex := maxFilesIndex - 1
   dummyTimerDelayiedImageDisplay(50)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
}

omniBoxFolderExplorerOpen() {
   folderPath := OmniBoxGetSelectedFolder()
   Try Run, "%folderPath%"
   Catch wasError
   {
      If !AnyWindowOpen
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderPath, 0, 0, "error")
   }
}

omniBoxFolderOpen() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   If askAboutFileSave(" and the selected folder will be opened")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("discard it")
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   tryOpenGivenFolder(folderPath, CurrentSLD)
   FileExploreSiblingsNav("reset")
   userQuickMenusEdit := folderPath
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
}

omniBoxFolderNewInstance() {
   folderPath := OmniBoxGetSelectedFolder()
   If folderPath
      OpenNewQPVinstance(folderPath)
}

omniBoxFolderProperties() {
   folderPath := OmniBoxGetSelectedFolder()
   If folderPath
      invokeStandardFolderProperties(folderPath)
}

omniBoxFolderSetProtected() {
   folderPath := OmniBoxGetSelectedFolder()
   If folderPath
      setContaintFolderAsProtected(folderPath)
}

omniBoxFolderCreateNew() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := UIcoreFolderNew(folderPath, newFileName)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
   If r
   {
      prevOmniBoxFolder := newFileName
      SetTimer, PopulateQuickMenuSearch, -150
   }
}

omniBoxFolderCutCopy(a) {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   UIcoreFolderCutCopyExplorer(a, folderPath)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()
}

omniBoxFoldersPaste() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := UIcoreFolderPasteFoldersInto(folderPath)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
   If (r=2)
      PopulateQuickMenuSearch("resel")
}

omniBoxFolderRename() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := UIcoreFolderRename(folderPath, newFileName)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
   If r
   {
      prevOmniBoxFolder := newFileName
      SetTimer, PopulateQuickMenuSearch, -150
   }
}

omniBoxFolderDelete() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return "-"

   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(funcu, RowNumber - 1, 6)
   If (InStr(funcu, "!OmniNavigateFolder") || InStr(funcu, "!OmniNavigateFilteredFolders"))
      LV_GetText(folderu, RowNumber - 1, 2)

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := UIcoreFolderDelete(folderPath)
   If (r="deleted" && InStr(folderu, "\"))
      prevOmniBoxFolder := StrReplace(folderu, "\")

   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   If (r="deleted")
      SetTimer, PopulateQuickMenuSearch, -100

   WinActivate, ahk_id %hQuickMenuSearchWin%
   SetTimer, ResetImgLoadStatus, -100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

omniBoxFolderPasteClippy() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := PasteFilesIntoGivenFolder(folderPath)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
}

omniBoxFolderCopyFiles() {
   triggerQuickFileAction("vk38", 1)
}

omniBoxFolderMoveFiles() {
   triggerQuickFileAction("+vk38", 1)
}

omniBoxFolderCopyPath() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   Try Clipboard := folderPath
   Catch wasError
       Sleep, 1

   If !wasError
   {
      showTOOLtip("Folder path copied to the clipboard:`n" folderPath)
   } Else
   {
      showTOOLtip("ERROR: Failed to copy folder path to the clipboard:`n" folderPath)
      SoundBeep 300, 100
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createOmniBoxFoldersContextMenu(folderPath) {
   deleteMenus()
   Try Menu, PVopenF, Delete
   Try Menu, PVfomni, Delete
   kMenu("PVopenF", "Add", "Open folder now`tCtrl+Enter", "omniBoxFolderOpen")
   kMenu("PVopenF", "Add", "In Explorer", "omniBoxFolderExplorerOpen")
   kMenu("PVopenF", "Add", "With a new QPV instance", "omniBoxFolderNewInstance")

   kMenu("PVfomni", "Add", "Open", ":PVopenF")
   kMenu("PVfomni", "Add", "&Import images into the list`tF3", "omniBoxFolderImport")
   Menu, PVfomni, Add
   kMenu("PVfomni", "Add", "&Create new folder`tF7", "omniBoxFolderCreateNew")
   kMenu("PVfomni", "Add", "C&ut folder (Explorer mode)`tCtrl+X", "omniBoxFolderCutCopy")
   kMenu("PVfomni", "Add", "C&opy folder (Explorer mode)`tCtrl+C", "omniBoxFolderCutCopy")
   kMenu("PVfomni", "Add", "Copy folder path as te&xt", "omniBoxFolderCopyPath")
   kMenu("PVfomni", "Add", "&Paste folder(s) into...", "omniBoxFoldersPaste")
   kMenu("PVfomni", "Add", "&Rename folder`tF2", "omniBoxFolderRename")
   kMenu("PVfomni", "Add", "&Delete folder`tF8", "omniBoxFolderDelete")
   kMenu("PVfomni", "Add/UnCheck", "Se&t as the protected folder", "omniBoxFolderSetProtected")
   If (protectedFolderPath=folderPath && preventDeleteFromProtectedPath=1)
      kMenu("PVfomni", "Check", "Se&t as the protected folder")

   kMenu("PVfomni", "Add", "Folder properties (E&xplorer)`tF12", "omniBoxFolderProperties")
   Menu, PVfomni, Add
   kMenu("PVfomni", "Add", "Paste clip&board file(s) into...", "omniBoxFolderPasteClippy")
   kMenu("PVfomni", "Add", "Cop&y selected file(s) into...", "omniBoxFolderCopyFiles")
   kMenu("PVfomni", "Add", "&Move selected file(s) into...", "omniBoxFolderMoveFiles")
   showThisMenu("PVfomni", 1)
}

invokePrefsPanelsContextMenu(modus:=0, addBonus:=0) {
    Menu, ContextMenu, UseErrorLevel
    Try Menu, ContextMenu, Delete
    Sleep, 5

    If (modus=1)
    {
       If (addBonus=1)
       {
          kMenu("ContextMenu", "Add", "Selected folder is inexistent", "dummy")
          kMenu("ContextMenu", "Disable", "Selected folder is inexistent")
          Menu, ContextMenu, Add, 
       }
       kMenu("ContextMenu", "Add", "&Close panel`tEscape", "QuickMenuSearchGUIAGuiClose")
    } Else
       kMenu("ContextMenu", "Add", "&Close panel`tEscape", "CloseWindow")

    If (!isWinXP && A_OSVersion!="WIN_7")
    {
       kMenu("ContextMenu", "Add/UnCheck", "Dar&k mode", "ToggleDarkModus")
       If (uiUseDarkMode=1)
          kMenu("ContextMenu", "Check", "Dar&k mode")
    }

    kMenu("ContextMenu", "Add/UnCheck", "&Large UI fonts", "ToggleLargeUIfonts")
    If (imgEditPanelOpened=1 && modus!=1)
       kMenu("ContextMenu", "Add/UnCheck", "C&ollapse panel`tF8", "toggleImgEditPanelWindow")
    Menu, ContextMenu, Add, 
    If (PrefsLargeFonts=1)
       kMenu("ContextMenu", "Check", "&Large UI fonts")

    kMenu("ContextMenu", "Add", "O&pen QPV settings folder", "openSettingsDir")
    kMenu("ContextMenu", "Add", "Restore ALL defaults", "DeleteAllSettings")
    Menu, ContextMenu, Add
    kMenu("ContextMenu", "Add", "&Visit official site", "OpenGitHub")
    kMenu("ContextMenu", "Add", "&Make a donation", "DonateNow")
    Menu, ContextMenu, Add
    kMenu("ContextMenu", "Add", "&New instance", "OpenNewQPVinstance")
    kMenu("ContextMenu", "Add", "&Restart " appTitle, "restartAppu")
    If (modus=1)
    {
       Menu, ContextMenu, Add
       kMenu("ContextMenu", "Add", "&Help`tF1", "btnHelpQuickSearchMenus")
    }

    showThisMenu("ContextMenu", 1)
}

btnHelpQuickSearchMenus() {
   msgBoxWrapper(appTitle ": HELP", "This panel allows users to search the available menu options based on the current context. It also allows users to:`n`n- navigate through folders; just type or paste a folder path`n`n- open or import folders and image files`n`n- manage folders using common actions: copy, paste, delete, rename, et cetera`n`n- jump to a given index in the list; type a number beginning with @`n `nDrag and drop is supported between listed folders, and between this panel and the main window or the folders tree panel.", -1, 0, 0)
   WinActivate, ahk_id %hQuickMenuSearchWin%
}

WinMsgBoxGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1

    ; isFakeWin := (isNowFakeWinOpen=1 && AnyWindowOpen>0) ? 1 : 0
    If (!MsgBox2hwnd || !isNowFakeWinOpen)
       Return

    If (isRightClick=1)
    {
       If SettingsToolTips()
          Return
       Else If AnyWindowOpen
          invokePrefsPanelsContextMenu()
    }

    lastInvoked := A_TickCount
    Return
}

identifyParentWind() {
    uz := WinActive("A")
    Az := DllCall("GetParent", "UPtr", uz, "UPtr")
    r := (Az=hSetWinGui || Az=PVhwnd || Az=hGDIwin || Az=hGDIthumbsWin || Az=hGDIinfosWin) ? 1 : 0
    If (uz=PVhwnd || uz=hQPVtoolbar && ShowAdvToolbar=1)
       r := 0
    Return r
}

SettingsToolTips() {
   ActiveWin := WinActive("A")
   ; bActiveWin := WinExist("A")
   thisHwndGood := (ActiveWin=hSetWinGui || ActiveWin=MsgBox2hwnd) ? 1 : 0
   ;  ToolTip, % isNowFakeWinOpen "==" ActiveWin "==" thisHwndGood "==" PVhwnd "==" hSetWinGui "==" MsgBox2hwnd , , , 2
   If (thisHwndGood!=1 && ActiveWin!=PVhwnd)
      Return

   If (ActiveWin=MsgBox2hwnd)
   {
      Gui, WinMsgBox: Default
   } Else
   {
      If (panelWinCollapsed=1)
      {
         toggleImgEditPanelWindow()
         Return
      }

      Gui, SettingsGUIA: Default
   }

   GuiControlGet, value, , %A_GuiControl%
   ; MouseGetPos, , , , hwnd, 1 ; |2|3]
   GuiControlGet, hwnd, hwnd, %A_GuiControl%
   ControlGetText, info,, ahk_id %hwnd%
   ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
   ControlGet, ctrlActiveState, Enabled,,, ahk_id %hwnd%
   If (info=value)
      info := ""
   If StrLen(info)>0
      info .= "`n"

   If (posuk := InStr(value, "&"))
      hotkeyu := "`nAlt+" SubStr(value, posuk + 1, 1)
   Else If (posuk := InStr(A_GuiControl, "&"))
      hotkeyu := "`nAlt+" SubStr(A_GuiControl, posuk + 1, 1)
   
   StringUpper, hotkeyu, hotkeyu
   value := StrReplace(value, "&")
   ctrlu := StrReplace(A_GuiControl, "&")
   If (ctrlu=value)
      value := ""
   Else If (ctrlu=SubStr(value, 1, StrLen(ctrlu)))
      ctrlu := ""

   ; btnType := GetButtonType(hwnd)
   If (StrLen(value)>0 && ctrlu!="")
   {
      thisValueNumber := isNumber(Trimmer(value))
      value .= " = "
   }

   ; ToolTip, % info "`n" value "`n" ctrlu , , , 2
   MouseGetPos, , , id, controla, 2
   If !hwnd
      ControlGetText, info, , ahk_id %controla%

   If !hotkeyu
   {
      If (posuk := InStr(info, "&"))
         hotkeyu := "`nAlt+" SubStr(info, posuk + 1, 1)
   }

   info := StrReplace(info, "&")
   WinGetClass, OutputVar, ahk_id %hwnd%
   If OutputVar
   {
      If InStr(OutputVar, "_trackbar")
      {
         SendMessage, 0x0401,,,, ahk_id %hwnd%   ; TBM_GETRANGEMIN
         minu := ErrorLevel
         SendMessage, 0x0402,,,, ahk_id %hwnd%   ; TBM_GETRANGEMAX
         maxu := ErrorLevel
         OutputVar := "Slider: " minu "; " maxu
      } Else If (InStr(OutputVar, "Button") && thisValueNumber=1 && InStr(value, "="))
         OutputVar := "Checkbox"
      Else If InStr(OutputVar, "_updown")
      {
         SendMessage, 0x0400+102,,,, ahk_id %hwnd%   ; UDM_GETRANGE
         UDM_GETRANGE := ErrorLevel
         minu := UDM_GETRANGE >> 16
         maxu := UDM_GETRANGE & 0xFFFF
         OutputVar := "Up/Down range: " minu "; " maxu
      } Else If InStr(OutputVar, "edit")
      {
         OutputVar := "Edit field"
      } Else If (InStr(OutputVar, "static") && value && ctrlu)
      {
         OutputVar := "Maybe clickable" ; value  " - " ctrlu
         controlType := "`n[" OutputVar "]"
      }
      If !InStr(OutputVar, "static")
         controlType := "`n[" OutputVar "]"
   }

   msg2show := info value ctrlu controlType hotkeyu
   ; ToolTip, % A_DefaultGUI "===" msg2show , , , 2
   ; If (ctrlActiveState!=1 && StrLen(msg2show)>2 && btnType)
   ;    msg2show .= "`n[CONTROL DISABLED]"
   If StrLen(listBoxOptions)>3
   {
      countListBoxOptions := ST_Count(listBoxOptions, "`n") + 1
      If (countListBoxOptions>10)
         listBoxOptions := "[too many to list]"
      msg2show .= "`n`nLIST OPTIONS: " countListBoxOptions "`n" listBoxOptions
   }

   ; If (!value && btnType)
   ;    msg2show .= "`n`nCONTROL TYPE:`n" btnType
   If InStr(msg2show, "lib\") || InStr(msg2show, "a href=")
      Return

   thisSize := (PrefsLargeFonts=1) ? Round(LargeUIfontValue*1.55) : LargeUIfontValue
   interfaceThread.ahkFunction("mouseCreateOSDinfoLine", msg2show, thisSize)
   Return msg2show
}

ST_Count(Haystack, searchFor) {
    StrReplace(Haystack, searchFor,, OutputVarCount)
    Return OutputVarCount
}

SetParentID(Window_ID, theOther) {
  r := DllCall("SetParent", "uint", theOther, "uint", Window_ID) ; success = handle to previous parent, failure =null 
  Return r
}

CreateGuiButton(btnList, killWin:=0, delayu:=950) {
    Critical, On
    Static lastCreated := 1, bgrColor := 112288, txtColor := "ddeeFF", thisOpacity := 200
         , prevBtnList := "z"
    Global BtnTemp1, BtnTemp2
    
    If (killWin=1)
    {
       prevBtnList := ""
       Gui, TempBtnGui: Destroy
       tempBtnVisible := "null"
       interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
       Return
    }

    If (prevBtnList=btnList && tempBtnVisible!="null" && killWin!=1)
       Return

    If (TouchScreenMode!=1 && killWin!="force") ; || MsgBox2hwnd
       Return
 
    thisFntSize := Round(OSDfontSize*0.45)
    If (thisFntSize<9)
       thisFntSize := 9

    Gui, TempBtnGui: Destroy
    Sleep, 25
    Gui, TempBtnGui: -DPIScale -Caption +ToolWindow +E0x8000000 +hwndhGuiBtn +Owner%PVhwnd%
    Gui, TempBtnGui: Margin, % thisFntSize + 10, % thisFntSize
    Gui, TempBtnGui: Color, c%bgrColor%
    Gui, TempBtnGui: Font, s%thisFntSize% Bold Q5, Arial
    btnArray := StrSplit(btnList, "||")
    tempBtnGuiBtnArray := []
    Loop, % btnArray.Count()
    {
        thisBtnArr := StrSplit(btnArray[A_Index], ",,")
        ; ToolTip, % thisBtnArr[1] "==" thisBtnArr[2] , , , 2
        If (A_Index=1)
           Gui, TempBtnGui: Add, Text, c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
        Else If thisBtnArr[1]
           Gui, TempBtnGui: Add, Text, x+%OSDfontSize% c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
 
        tempBtnGuiBtnArray[A_Index] := thisBtnArr[2]
    }

    tempBtnVisible := hGuiBtn
    RepositionTempBtnGui()
    If InStr(btnList, ",,")
       prevBtnList := btnList
    interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
    SetTimer, DestroyTempBtnGui, % - delayu
    lastCreated := A_TickCount
}

RepositionTempBtnGui() {
    If (tempBtnVisible="null")
       Return

    thisFntSize := Round(OSDfontSize*0.45)
    If (thisFntSize<9)
       thisFntSize := 9

    hGuiBtn := tempBtnVisible
    WinGetPos, winPosX, winPosY, Wid, Heig, ahk_id %PVhwnd%
    Gui, TempBtnGui: Default
    Gui, TempBtnGui: Show, NoActivate AutoSize Hide x%winPosX% y%winPosY%, QPVGuiActionBtn
    WinGetPos,,, gWid, gHeig, ahk_id %hGuiBtn%
    If (gWid>Wid - thisFntSize*2.2)
       gWid := Wid - Round(thisFntSize * 2.25) - 5
    If (gWid<5)
       gWid := 5

    offsetuY := scrollBarHy ? scrollBarHy : 0
    Final_y := winPosY + Heig - thisFntSize * 2 - gHeig - offsetuY//2
    hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
    tlbrBonusX := (hasTrans=1 && (winPosX + ToolbarWinH - 10 > Final_y)) ? ToolbarWinW : 0
    Final_x := winPosX + thisFntSize * 2 + tlbrBonusX
    WinSet, Transparent, 231, ahk_id %hGuiBtn%
    ; WinSet, AlwaysOnTop, On, ahk_id %hGuiBtn%
    roundedCsize := Round(thisFntSize/1.7) + 15
    WinSet, Region, 0-0 R%roundedCsize%-%roundedCsize% w%gWid% h%gHeig%, QPVGuiActionBtn
    Gui, TempBtnGui: Show, NoActivate AutoSize x%Final_x% y%Final_y%, GuiActionBtn
}

tempGuiBtnCall1() {
    coretempGuiBtnCalls(1)
}

tempGuiBtnCall2() {
    coretempGuiBtnCalls(2)
}

tempGuiBtnCall3() {
    coretempGuiBtnCalls(3)
}

tempGuiBtnCall4() {
    coretempGuiBtnCalls(4)
}

tempGuiBtnCall5() {
    coretempGuiBtnCalls(5)
}

tempGuiBtnCall6() {
    coretempGuiBtnCalls(6)
}

coretempGuiBtnCalls(indexu) {
    Static listu := ",reduceCustomShapelength,ImgVectorUndoAct,togglePathCurveTension,toggleOpenClosedLineCustomShape,"
    thisFunc := tempBtnGuiBtnArray[indexu]
    z := InStr(listu, "," thisFunc ",")
    If !z
       SetTimer, DestroyTempBtnGui, -950

    If (WinActive("A")!=PVhwnd)
       WinActivate, ahk_id %PVhwnd%
    ; ToolTip, % thisfunc "===" indexu , , , 2
    If IsFunc(thisFunc)
       %thisFunc%()
    Else
       addJournalEntry("ERROR " A_ThisFunc "(): no such function to call: " thisFunc)

    If (drawingShapeNow!=1 && !z)
       SetTimer, DestroyTempBtnGui, -950
}

DestroyTempBtnGui(dummy:=0) {
    Critical, On
    MouseGetPos, , , OutputVarWin
    thisWin := WinActive("A")
    okay := (thisWin=PVhwnd || thisWin=hSetWinGui) ? 1 : 0
    ; ToolTip, % OutputVarWin , , , 2
    If (OutputVarWin!=tempBtnVisible) || (okay!=1) || (dummy="now")
       CreateGuiButton("Die dummy", 1)  ;   ;-)
    Else
       SetTimer, DestroyTempBtnGui, -950
}

openPreviousPanel(mode:="") {
   thisFunc := prevOpenedWindow[2]
   allowReopen := prevOpenedWindow[3]
   If (IsFunc(thisfunc) && thisFunc && allowReopen=1) || (thisFunc && mode="forced")
   {
      %thisFunc%()
   } Else
   {
      showTOOLtip("No previously opened panel")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

mouseTurnOFFtooltip() {
   ; If (mouseToolTipWinCreated=1)
      interfaceThread.ahkPostFunction("mouseTurnOFFtooltip", 1)
      ; Gui, mouseToolTipGuia: Destroy
   ; mouseToolTipWinCreated := 0
}

createSettingsGUI(IDwin, thisCaller:=0, allowReopen:=1, isImgLiveEditor:=0) {
    Critical, on
    lastZeitOpenWin := A_TickCount
    lastFilterEditSearch := ""
    If (thumbsDisplaying=1 && isImgLiveEditor=1)
    {
       openingPanelNow := 0
       Return
    }
 
    If (IDwin=AnyWindowOpen && imgEditPanelOpened=1)
    {
       openingPanelNow := 0
       addJournalEntry(A_ThisFunc "(): ERROR: You cannot reopen the same window while it is opened. Close and reopen it :-).")
       Return
    }

    If (isImgLiveEditor=1)
    {
       If throwErrorNoImageLoaded()
       {
          openingPanelNow := 0
          Return
       }
    }

    If isNowAlphaPainting()
    {
       openingPanelNow := 0
       toggleAlphaPaintingMode()
       Return
    }

    If AnyWindowOpen
    {
       rz := CloseWindow()
       If rz
          Return
    }

    thisBtnHeight := (PrefsLargeFonts=1) ? 34 : 24
    setLVrowsCount()
    If (slideShowRunning=1)
       ToggleSlideShowu()

    mouseTurnOFFtooltip()
    ; If (editingSelectionNow=1 && imgEditPanelOpened!=1)
    ;    ToggleEditImgSelection()

    endCaptureCloneBrush() 
    forceLiveAlphaPreviewMode := userAllowClrGradientRecenter := userAllowsGradientRecentering := liveDrawingBrushTool := panelWinCollapsed := 0
    imgEditPanelOpened := isImgLiveEditor
    o_ImgQuality := userimgQuality
    If (imgEditPanelOpened=1)
    {
       ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
       ToggleVisibilityWindow("show", hGDIthumbsWin)
       ForceRefreshNowThumbsList()
       ; dummyTimerDelayiedImageDisplay(150) ; probably needed in some cases ; I do not know 
       initQPVmainDLL()
       recordSelUndoLevelNow()
       If (closeEditPanelOnApply=-1)
          INIaction(0, "closeEditPanelOnApply", "General", 1)

       ; interfaceThread.ahkassign("AnyWindowOpen", IDwin)
       ; TriggerMenuBarUpdate()
       If AnyWindowOpen
          Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%
       ; coreDesiredPixFmt := "0x26200A" ; 32-ARGB
       DestroyGIFuWin()
       Gui, SettingsGUIA: Destroy
       Sleep, 5
       clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       drawImgSelectionOnWindow("faker", "-", "-", "-", mainWidth, mainHeight)
    } ; Else CloseWindow()
    If (folderTreeWinOpen=1)
       fdTreeClose()

    Sleep, 15
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: -MaximizeBox +Border +Owner%PVhwnd% +hwndhSetWinGui 
    Gui, SettingsGUIA: Margin, 14, 14
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    If (uiUseDarkMode=1)
    {
       Gui, Color, % darkWindowColor, % darkWindowColor
       Gui, Font, c%darkControlColor%
       setDarkWinAttribs(hSetWinGui)
    }

    AnyWindowOpen := IDwin
    thisPanelTab := TabsPerWindow[AnyWindowOpen] ? TabsPerWindow[AnyWindowOpen] : 1
    uiPanelOpenCloseEvent()
    TriggerMenuBarUpdate()
    If (allowReopen=1)
    {
       prevOpenedWindow := []
       prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 0, o_ImgQuality]
    }

    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    lastZeitOpenWin := A_TickCount
    Return thisBtnHeight
}

setLVrowsCount() {
   uLVr := (PrefsLargeFonts=1) ? 11 + additionalLVrows : 15 + Ceil(additionalLVrows*1.25)
}

PanelSeenStats() {
    Global LViewMetaD, LViewMetaM, LViewMetaH, infoLine
    showTOOLtip("Generating statistics, please wait")
    thisBtnHeight := createSettingsGUI(39, A_ThisFunc)
    btnWid := 105
    txtWid := 150
    lstWid := 199
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := lstWid - 25
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3, gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Daily|Monthly|Hourly|Options
    Gui, Tab, 1 ; Daily
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaD AltSubmit -multi gSeenStatsLVaction, #|Date|Images|`%
    Gui, Tab, 2 ; Monthly
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaM AltSubmit -multi gSeenStatsLVaction, #|Date|Images|`%
    Gui, Tab, 3 ; Hourly
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid -multi vLViewMetaH, #|Hour|Images|`%
    Gui, Tab, 4 ; Options
    Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% gCleanDeadFilesSeenImagesDB, &Purge records of inexistent files
    Gui, Add, Button, y+5 hp geraseSeenIMGsDB, &Erase the entire list
    Gui, Add, Button, y+5 hp gBtnCopySeenStats, &Copy statistics to clipboard
    Gui, Add, Button, y+5 hp gBtnALLviewedImages2List, &Retrieve list of recorded seen images
    Gui, Add, Text, y+5 hp +0x200, Charts:
    Gui, Add, Button, x+5 hp gPlotSeenHourStatsNow, &Hours
    Gui, Add, Button, x+2 hp gPlotSeenMonthsStatsNow, &Months
    Gui, Add, Button, x+2 hp gPlotSeenDaysToggleStatsNow, &Days
    Gui, Add, Text, xs+15 y+35 w%txtWid%, To retrieve the images seen on a given day or month`, double click on the date in the list.
    Gui, Add, GroupBox, xp-15 yp-20 wp+30 hp+30, TIP
    Gui, Add, Text, y+10 h%thisBtnHeight% +0x200 w%txtWid% vinfoLine, Please wait...

    Gui, Tab
    Gui, Add, Button, xp y+5 h%thisBtnHeight% w1 h1 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Images seen statistics: " appTitle)
    PopulateSeenStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
}

PanelIndexedImagesStats() {
    Global LViewMetaD, LViewMetaG, LViewMetaU, LViewMetaM, LViewMetaY, LViewMetaS, LViewMetaT, LViewMetaA, LViewMetaI
         , LViewMetaR, StatsUIhistoThingy := 1

    showTOOLtip("Generating image files statistics, please wait")
    thisBtnHeight := createSettingsGUI(48, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%thisPanelTab% hwndhCurrTab, Megapixels|Aspect ratios|DPI|Frames|Pixel formats|Histogram
    Gui, Tab, 1
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaD -multi AltSubmit gIndexStatsLVaction, #|MPx|Images|`%
    Gui, Tab, 2
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaY -multi AltSubmit gIndexStatsLVaction, #|W/H|Images|`%
    Gui, Tab, 3
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaU -multi AltSubmit gIndexStatsLVaction, #|DPI|Images|`%
    Gui, Tab, 4
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaM -multi AltSubmit gIndexStatsLVaction, #|Frames|Images|`%
    Gui, Tab, 5
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaS -multi AltSubmit gIndexStatsLVaction, #|Formats|Images|`%
    Gui, Tab, 6
    Gui, Add, DropDownList, y+15 w%lstWid% AltSubmit Choose1 gSwitchUIdlHistoStats vStatsUIhistoThingy, Averages|Medians|Peak (range)|Minimum (range)|Total (range)
    Gui, Add, ListView, y+10 w%lstWid% r6 Grid vLViewMetaG -multi AltSubmit gIndexStatsLVaction, #|Medians|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaA -multi AltSubmit gIndexStatsLVaction, #|Max|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaI -multi AltSubmit gIndexStatsLVaction, #|Min|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaT -multi AltSubmit gIndexStatsLVaction, #|Avg|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaR -multi AltSubmit gIndexStatsLVaction, #|Range|Images|`%

    Gui, Tab
    Gui, Add, Button, xp Section y+5 h%thisBtnHeight% w2 gBtnCloseWindow, &Close
    Gui, Add, Button, x+5 hp gPanelWrapperFilesStats, &Back
    Gui, Add, Button, x+2 yp hp gBtnCopyImageFileStats, Cop&y all to clipboard
    Gui, Add, Text, xs y+2 hp w%lstWid% vinfoLine +0x200 -wrap, Please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Indexed images statistics: " appTitle)
    ; If (SLDtypeLoaded=3)
    ;    PopulateIndexSQLFilesStatsInfos()
    ; Else
       PopulateImagesIndexStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
    SetTimer, SwitchUIdlHistoStats, -300
}

SwitchUIdlHistoStats() {
   If (AnyWindowOpen=48)
   {
      GuiControlGet, StatsUIhistoThingy
      If (StatsUIhistoThingy=1)
      {
         GuiControl, SettingsGUIA: Show, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=2)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Show, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=3)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Show, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=4)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Show, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=5)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Show, LViewMetaR
      }
   }
}

PanelIndexedFilesStats() {
    Global LViewMetaD, LViewMetaM, LViewMetaY, LViewMetaS, LViewMetaT
    showTOOLtip("Generating statistics, please wait")
    RegAction(0, "uiPreferedFileStats",, 1)
    thisBtnHeight := createSettingsGUI(59, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%thisPanelTab% hwndhCurrTab, Days|Months|Years|Sizes|Types
    Gui, Tab, 1 ; Daily
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaD -multi AltSubmit gIndexStatsLVaction, #|Date|Images|`%
    Gui, Tab, 2 ; Monthly
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaM -multi AltSubmit gIndexStatsLVaction, #|Date|Images|`%
    Gui, Tab, 3 ; Yearly
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaY -multi AltSubmit gIndexStatsLVaction, #|Year|Images|`%
    Gui, Tab, 4 ; Sizes
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaS -multi AltSubmit gIndexStatsLVaction, #|File size ranges|Total size [MB]|Images|`%
    Gui, Tab, 5 ; Types
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid vLViewMetaT -multi AltSubmit gIndexStatsLVaction, #|File types|Images|`%
    friendly := (uiPreferedFileStats=1) ? "modified" : "created"
    Gui, Tab
    Gui, Add, Button, xp Section y+5 h%thisBtnHeight% w2 gBtnCloseWindow, &Close
    Gui, Add, Button, x+2 h%thisBtnHeight% gPanelWrapperFilesStats, &Back
    Gui, Add, Button, x+2 yp wp hp gBtnCopyFileStats, Cop&y
    Gui, Add, Text, x+5 yp hp +0x200 -wrap, Statistics based on the %friendly% file date.
    Gui, Add, Text, xs w%lstWid% vinfoLine +0x200, Please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Indexed files statistics: " appTitle)
    If (SLDtypeLoaded=3)
       PopulateIndexSQLFilesStatsInfos()
    Else
       PopulateIndexFilesStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
}

ToggleFileStatsDating() {
    Gui, SettingsGUIA: Default
    GuiControlGet, uiPreferedFileStats
    ; ToolTip, % "l=" uiPreferedFileStats , , , 2
    RegAction(1, "uiPreferedFileStats")
}

UIeditHammingInterpolation() {
    Gui, SettingsGUIA: Default
    GuiControlGet, hamDistInterpolation

    ; hamDistInterpolation := (editFr=1) ? 6 : 5
    ; ToolTip, % "l=" hamDistInterpolation , , , 2
    ; IniAction(1, "hamDistInterpolation", "General")
    If (SLDtypeLoaded=3)
       IniSLDBWrite("hamDistInterpolation", hamDistInterpolation)
}

PanelWrapperFilesStats() {
    thisBtnHeight := createSettingsGUI(58, A_ThisFunc)
    btnWid := 105
    txtWid := 370
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 165
       Gui, Font, s%LargeUIfontValue%
    }

    RegAction(0, "uiPreferedFileStats",, 1)
    ; Gui, Tab, 1
    Gui, Add, Text, x15 y15 w%txtWid%, The statistics panel allows users to filter the indexed files to various criteria by double-clicking on list view entries. It is meant to facilitate the identification of small files, low resolution images, low key or high key, or washed out images in your collection.
    Gui, Add, Text, y+15 Section, File details: size, date modified, type and more.
    Gui, Add, Button, xp+15 y+5 h%thisBtnHeight% gPanelIndexedFilesStats, Open &file statistics panel
    Gui, Add, Button, x+5 hp gBtnCollectFileInfos, &Collect data
    Gui, Add, Checkbox, xs+15 y+5 Checked%uiPreferedFileStats% vuiPreferedFileStats gToggleFileStatsDating, &Generate date statistics based on modified date.
    Gui, Add, Text, xs y+35 Section, Image properties: resolution, frames and more.
    Gui, Add, Button, xp+15 y+5 h%thisBtnHeight% gPanelIndexedImagesStats, Open &images statistics panel
    ; Gui, Add, Button, x+5 h%thisBtnHeight% gPanelFindDupes, Find &duplicates panel
    Gui, Add, Button, xs+15 y+10 hp gBtnCollectImageInfos, Collect image &properties and file details
    If (SLDtypeLoaded=3)
       Gui, Add, Button, xs y+30 h%thisBtnHeight% gOpenFileDupesPanel, Collect fingerprints and &histogram details options
    Else
       Gui, Add, Button, xs y+30 h%thisBtnHeight% gBtnCollectHistoInfos, Collect image properties and &histogram details
    ; Gui, Add, Button, x+5 h%thisBtnHeight% gOpenFileDupesPanel, &Options
    ; Gui, Add, Checkbox, xs+15 y+5 hp Checked%hamDistInterpolation% vhamDistInterpolation gUIeditHammingInterpolation, High-quality resampling (not recommended)

    ; Gui, Tab
    Gui, Add, Button, xs y+35 h%thisBtnHeight% gPanelEnableFilesFilter, C&reate custom filter
    If (SLDtypeLoaded=3)
    {
       Gui, Add, Button, x+5 hp gBtnPurgeCachedSQLdata, Pur&ge caches
       Gui, Add, Button, x+5 hp gPanelStateOFsqlNation, Caches &overview
    }

    wu := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 w%wu% hp Default gBtnCloseWindow, C&lose

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Statistics: " appTitle)
}

OpenFileDupesPanel() {
   BtnCloseWindow()
   Sleep, 25
   PanelFindDupes(3)
}

BtnPurgeCachedSQLdata() {
   BtnCloseWindow()
   AnyWindowOpen := 49
   PanelPurgeCachedSQLdata()
}

SeenStatsLVaction(CtrlHwnd:=0, b:=0, c:=0) {
    Static cl := {1:"D", 2:"M"}
    Gui, SettingsGUIA: Default
    GuiControlGet, CurrentPanelTab
    x := cl[CurrentPanelTab]
    If !x
       Return

    Gui, SettingsGUIA: ListView, LViewMeta%x%
    isOkay := (b="k" && c=32) || (b="DoubleClick") ? 1 : 0
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(dateu, RowNumber, 2)

    ; ToolTip, % A_GuiEvent "=" A_EventInfo , , , 2
    If (StrLen(dateu)<3  || !isOkay)
       Return

    BtnALLviewedImages2List(dateu "|filteru|")
    prevOpenedWindow := [39, "PanelSeenStats", 1, 0, 0, userimgQuality]
}

IndexStatsLVaction(CtrlHwnd:=0, b:=0, c:=0) {
    GuiControlGet, varu, SettingsGUIA: FocusV
    isOkay := (b="k" && c=32) || (b="DoubleClick") ? 1 : 0
    If (!InStr(varu, "LViewMeta") || !isOkay)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, % varu
    GuiControlGet, CurrentPanelTab
    ; MouseGetPos, , , OutputVarWin, OutputVarControl, 3
    RowNumber := LV_GetNext()
    LV_GetText(dateu, RowNumber, 2)
    If (StrLen(dateu)<1 || dateu="date" || InStr(dateu, "file"))
       Return

    r := BtnIndexStatsToList(RowNumber, dateu, varu, 0)
    If (SLDtypeLoaded!=3 && r)
    {
       coreEnableFiltru(r)
       currentFileIndex := maxFilesIndex
       dummyTimerDelayiedImageDisplay(100)
    }
}

BtnIndexStatsToList(RowNumber, dateu, LVvaru, givenQuery) {
   Static minz := {1:0, 2:4999, 3:10002, 4:25002, 5:50002, 6:100002, 7:250002, 8:500002, 9:1000002, 10:2500002, 11:5000002, 12:10000002, 13:25000002, 14:50000002, 15:100000002, 16:250000002}
        , maxz := {1:4998, 2:10001, 3:25001, 4:50001, 5:100001, 6:250001, 7:500001, 8:1000001, 9:2500001, 10:5000001, 11:10000001, 12:25000001, 13:50000001, 14:100000001, 15:250000001, 16:500000001}

   ; ToolTip, % RowNumber "==" dateu "==" LVvaru , , , 2
   winOpen := AnyWindowOpen
   If (AnyWindowOpen && LVvaru!="none")
      BtnCloseWindow()

   If askAboutFileSave(" and the files list will be filtered to given criteria")
      Return -1

   setImageLoading()
   If (LVvaru="none" && SLDtypeLoaded=3)
   {
      showTOOLtip("Retrieving entire files list SQL index, please wait")
   } Else
   {
      showTOOLtip("Gathering entries matching " dateu ", please wait")
      setWindowTitle("Gathering entries matching " dateu ", please wait...", 1)
      If (InStr(LVvaru, "metaT") && winOpen!=48)
      {
         If (SLDtypeLoaded=3)
         {
            givenQuery := "WHERE imgfile LIKE '%." dateu "'"
            LVvaru := "custom"
         } Else
         {
            UsrEditFilter := "(\." dateu ")$"
            userFilterInvertThis := 0
            userFilterStringPos := 4
            userFilterProperty := userFilterWhat := userFilterDoString := 1
            coreEnableFiltru("\>" UsrEditFilter)
            Return
         }
      }
   }

   oDateu := dateu
   arDateu := StrSplit(oDateu, "-")
   RecordSet := ""
   If (winOpen!=48)
      dateu := StrReplace(dateu, "-")

   minRange := (winOpen=48) ? arDateu[1] : minz[RowNumber]
   maxRange := (winOpen=48) ? arDateu[2] : maxz[RowNumber]
   ftableu := (uiPreferedFileStats=1) ? "fmodified" : "Fcreated"

   If !dataColumn
      dataColumn := InStr(LVvaru, "metaS") ? "fsize" : ftableu

   sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
   reorder := StrLen(prevFilesSortMode)>3 ? " ORDER BY " prevFilesSortMode sortMode ";" : " ORDER BY imgidu;"
   k := 14 - StrLen(dateu)
   If (LVvaru="custom")
   {
      theQuery := givenQuery
      theQueryNonDB := givenQuery
   } Else If (LVvaru="none")
   {
      theQuery := ""
      theQueryNonDB := ""
   } Else If (winOpen=48)
   {
      If InStr(LVvaru, "metaM")
      {
         userFilterProperty := 9
         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := FilteruMaxRange := Round(dateu)
         theQuery := "WHERE imgframes='" dateu "'"
         theQueryNonDB := "QPV::query::imgframes::" dateu ":: " dateu
      } Else If InStr(LVvaru, "metaS")
      {
         userFilterDoString := 0
         theQuery := "WHERE imgpixfmt LIKE '" dateu "'"
         theQueryNonDB := "QPV::query::imgpixfmt::" dateu "::" dateu
      } Else If InStr(LVvaru, "metaD")
      {
         userFilterProperty := 5
         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := Floor(dateu)
         FilteruMAxRange := Ceil(dateu)
         theQuery := "WHERE Round(imgmegapix, 1) BETWEEN " dateu " AND " dateu
         theQueryNonDB := "QPV::query::imgmegapix::" dateu "::" dateu
      } Else If InStr(LVvaru, "metaU")
      {
         userFilterProperty := 10
         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := FilteruMAxRange := Round(dateu)
         theQuery := "WHERE imgdpi='" dateu "'"
         theQueryNonDB := "QPV::query::imgdpi::" dateu "::" dateu
      } Else If InStr(LVvaru, "metaY")
      {
         userFilterInvertThis := userFilterProperty := 8
         FilteruMinRange := Round(dateu*10)
         FilteruMAxRange := Round(dateu*10)
         theQuery := "WHERE Round(imgwhratio, 1) BETWEEN " dateu " AND " dateu
         theQueryNonDB := "QPV::query::imgwhratio::" dateu ":: " dateu
      } Else If (InStr(LVvaru, "metaA") || InStr(LVvaru, "metaR") || InStr(LVvaru, "metaI") || InStr(LVvaru, "metaT") || InStr(LVvaru, "metaG"))
      {
         If InStr(LVvaru, "metaA")
         {
            userFilterProperty := 13
            dataColumn := "imghpeak"
         } Else If InStr(LVvaru, "metaI")
         {
            userFilterProperty := 14
            dataColumn := "imghlow"
         } Else If InStr(LVvaru, "metaR")
         {
            userFilterProperty := 15
            dataColumn := "imghrange"
         } Else If InStr(LVvaru, "metaT")
         {
            userFilterProperty := 11
            dataColumn := "imgavg"
         } Else If InStr(LVvaru, "metaG")
         {
            userFilterProperty := 12
            dataColumn := "imgmedian"
         }

         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := Round(minRange)
         FilteruMaxRange := Round(maxRange)
         minRange := Round((minRange + 1)/256, 3)
         maxRange := Round((maxRange + 1)/256, 3)
         theQuery := "WHERE Round(" dataColumn ", 2) BETWEEN " minRange " AND " maxRange
         theQueryNonDB := "QPV::query::" dataColumn "::" minRange "::" maxRange
      }
   } Else
   {
      If (InStr(LVvaru, "metaD") || InStr(LVvaru, "metaM") || InStr(LVvaru, "metaY") || InStr(LVvaru, "LIKE"))
      {
         userFilterProperty := 3
         userFilterInvertThis := userFilterDoString := 0
         FilteruDateMaxRange := FilteruDateMinRange := Format("{1}{2:" k "}", dateu, 0)
         theQuery := "WHERE " dataColumn " LIKE '" dateu "%'"
         theQueryNonDB := "QPV::query::" dataColumn "::" FilteruDateMinRange "::" FilteruDateMaxRange
         theQueryNonDB := StrReplace(theQueryNonDB, A_Space, 0)
      } Else If (InStr(LVvaru, "metaS") || InStr(LVvaru, "BETWEEN"))
      {
         userFilterProperty := 2
         userFilterSizeProperty := 1
         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := Round(minRange/1024)
         FilteruMaxRange := Round(maxRange/1024)
         theQuery := "WHERE " dataColumn " BETWEEN " minRange " AND " maxRange
         theQueryNonDB := "QPV::query::" dataColumn "::" minRange "::" maxRange
      }
   }

   If (SLDtypeLoaded=3)
   {
      If !getMaxRowIDsqlDB()
         Return -1

      If !RegExMatch(prevFilesSortMode, "i)(fsize|fmodified|fcreated|imgfile|imgfolder)")
         moreCol := StrLen(prevFilesSortMode)>3 ? ", " prevFilesSortMode : ""
      SQLstr := "SELECT imgidu, fullPath" moreCol " FROM images " theQuery reorder
      ; ToolTip, % SQLstr , , , 2
      If !InitSQLgetTable(SQLstr, activeSQLdb._Handle, errMsg, Rows, Cols, hTable)
      {
         showTOOLtip("ERROR: Failed to open the SQL database:`n" errMsg)
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return -1
      }
   } Else Return theQueryNonDB

   If (Rows<1)
   {
      showTOOLtip("WARNING: No records found in the database matching the query:`n" SQLstr)
      disposeSQLgetTableHandle(hTable)
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   markedSelectFile := 0
   startOperation := A_TickCount
   ; ToolTip, % filesFilter , , , 2
   If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:") && LVvaru!="none")
      remFilesListFilter("simple")

   If (StrLen(filesFilter)<2 && LVvaru!="none")
   {
      bckpResultedFilesList := []
      bckpResultedFilesList := resultedFilesList.Clone()
      bckpMaxFilesIndex := maxFilesIndex
   }

   If (LVvaru!="none")
      showTOOLtip("Generating files list index for " oDateu)

   renewCurrentFilesList()
   performSQLgetTable(Rows, Cols, hTable)
   disposeSQLgetTableHandle(hTable)
   newStaticFoldersListCache := []
   If (LVvaru!="none")
      filesFilter := "SQL:query:" theQuery
   ;  MsgBox, % maxFilesIndex " --- " RecordSet.RowCount
   ForceRefreshNowThumbsList()
   GenerateRandyList()
   CurrentSLD := backCurrentSLD
   If (LVvaru!="none")
   {
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, -500
      SetTimer, ResetImgLoadStatus, -50
      RandomPicture()
   }
}

PlotSeenHourStatsNow() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaH
   LV_ModifyCol(2, "SortDesc")
   widthu := maxValu := maxKvalu := aR := aC := totalu := 0
   dataArray := []
   namesLabel:= new hashtable()
   Loop, 24
   {
       dataArray[A_Index] := 1
       namesLabel[A_Index] := A_Index < 10 ? "0" . A_Index : A_Index
    }

   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }

       LV_GetText(valu, aR, aC)
       If (isNumber(valu) && aC=3)
       {
          LV_GetText(oindexu, aR, 2)
          oindexu := SubStr(oindexu, 1, 2)
          indexu := LTrim(oindexu, 0)
          thisu := max(maxValu, valu)
          If (thisu!=maxValu)
          {
             maxValu := thisu
             maxKvalu := oindexu
          }

          totalu += valu
          dataArray[indexu] := valu ? valu : 1
          namesLabel[indexu] := oindexu
       }
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   itemz := LV_GetCount()
   avgu := groupDigits(Floor(totalu/24))
   GetWinClientSize(W, H, PVhwnd, 0)
   Gdip_GraphicsClear(2NDglPG)
   textu := "Seen images chart: HOURS.`nRange: 01:00 to 24:00.`nAverage: " avgu ". Peak at " maxKvalu "h: " groupDigits(maxValu)
   infoBoxBMP := drawTextInBox(textu, OSDFontName, OSDfontSize, w, h, OSDtextColor, OSDbgrColor, 1, 0)
   Scale := imgHUDbaseUnit/40

   hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
   tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
   tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
   borderSizeX := imgHUDbaseUnit//10 + tlbrBonusX
   borderSizeY := imgHUDbaseUnit//10 + tlbrBonusY
   plotBMP := BarChart(dataArray, namesLabel, Round(196*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:2, BarHeight:" Scale*3.5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,TextSize:" OSDfontSize//2+1 " BarTextColor:ff999999, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)
   Gdip_GetImageDimensions(plotBMP, imgW, imgH)
   Gdip_GetImageDimensions(infoBoxBMP, boxW, boxH)

   If (imgH>H - boxH - borderSizeY*2)
   {
      newBitmap := trGdip_ResizeBitmap(A_ThisFunc, plotBMP, imgW, H - boxH - borderSizeY*2, 1, 7)
      If StrLen(newBitmap)>2
      {
         trGdip_DisposeImage(plotBMP)
         plotBMP := newBitmap
         Gdip_GetImageDimensions(plotBMP, imgW, imgH)
      }
   }

   pBrush := Gdip_BrushCreateSolid("0xee" OSDbgrColor)
   Gdip_FillRectangle(2NDglPG, pBrush, 0, 0, max(imgW, boxW) + borderSizeX, imgH + borderSizeY)
   Gdip_DrawImage(2NDglPG, plotBMP, borderSizeX, borderSizeY)
   Gdip_DrawImage(2NDglPG, infoBoxBMP, tlbrBonusX, imgH + borderSizeY)
   trGdip_DisposeImage(infoBoxBMP, 1)
   trGdip_DisposeImage(plotBMP, 1)
   ResetImgLoadStatus()
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   toolTipGuiCreated := 2
   ; ToolTip, % maxValu "=" widthu , , , 2
}

PlotSeenMonthsStatsNow() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaM
   LV_ModifyCol(2, "SortDesc")
   widthu := maxValu := maxKvalu := aR := aC := totalu := 0
   dataArray := []
   namesLabel:= []
   dataSkipped := new hashtable()
   counter := 0
   LV_GetText(endPeriod, 1, 2)
   LV_GetText(startPeriod, LV_GetCount(), 2)
   nYear := SubStr(startPeriod, 1, 4)
   nMon:= LTrim(SubStr(startPeriod, 6, 2), "0")
   Loop
   {
      If (nMon>12)
      {
         nMon := 0
         nYear++
      }

      nMon++
      If (nMon=13)
         Continue

      thisM := (nMon<10) ? "0" . nMon : nMon
      dateu := nYear "-" thisM
      If (dateu=endPeriod)
         Break

      If (nYear thisM>=202004)
         dataSkipped[dateu] := 1
   }

   ; ToolTip, % startPeriod "`n" endPeriod , , , 2
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }

       LV_GetText(valu, aR, aC)
       If (isNumber(valu) && aC=3)
       {
          LV_GetText(oindexu, aR, 2)
          ; oindexu := SubStr(oindexu, 1, 2)
          thisu := max(maxValu, valu)
          If (thisu!=maxValu)
          {
             maxValu := thisu
             maxKvalu := oindexu
          }

          totalu += valu
          dataArray[counter] := valu ? valu : 1
          namesLabel[counter] := oindexu
          dataSkipped[oindexu] := valu ? 0 : 1
          counter++
       }
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   countSkipped := 0
   For Key, Value in dataSkipped
   {
      If (Value=1)
         countSkipped++
   }

   lacking := (countSkipped>0) ? groupDigits(countSkipped) " months lack data." : ""
   itemz := LV_GetCount()
   avgu := groupDigits(Floor(totalu/counter))
   GetWinClientSize(W, H, PVhwnd, 0)
   Gdip_GraphicsClear(2NDglPG)
   textu := "Seen images chart: MONTHS`nTotal: " groupDigits(counter) " months. " lacking "`nRange: " startPeriod " - " endPeriod "`nAverage: " avgu ". Peak on " maxKvalu "=" groupDigits(maxValu)
   infoBoxBMP := drawTextInBox(textu, OSDFontName, OSDfontSize, w, h, OSDtextColor, OSDbgrColor, 1, 0)
   Scale := imgHUDbaseUnit/40

   hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
   tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
   tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
   borderSizeX := imgHUDbaseUnit//10 + tlbrBonusX
   borderSizeY := imgHUDbaseUnit//10 + tlbrBonusY
   If (counter>20)
      plotBMP := BarChart(dataArray, namesLabel, Round(106*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:0, BarHeight:" Scale*5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,TextSize:0, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)
   Else
      plotBMP := BarChart(dataArray, namesLabel, Round(196*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:2, BarHeight:" Scale*3.5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,BarTextColor:ff999999, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)

   Gdip_GetImageDimensions(plotBMP, imgW, imgH)
   Gdip_GetImageDimensions(infoBoxBMP, boxW, boxH)

   If (imgH>H - boxH - borderSizeY*2)
   {
      newBitmap := trGdip_ResizeBitmap(A_ThisFunc, plotBMP, imgW, H - boxH - borderSizeY*2, 0, 7)
      If StrLen(newBitmap)>2
      {
         trGdip_DisposeImage(plotBMP)
         plotBMP := newBitmap
         Gdip_GetImageDimensions(plotBMP, imgW, imgH)
      }
   }

   pBrush := Gdip_BrushCreateSolid("0xee" OSDbgrColor)
   Gdip_FillRectangle(2NDglPG, pBrush, 0, 0, max(imgW, boxW) + borderSizeX, imgH + borderSizeY)

   Gdip_DrawImage(2NDglPG, plotBMP, borderSizeX, borderSizeY)
   Gdip_DrawImage(2NDglPG, infoBoxBMP, tlbrBonusX, imgH + borderSizeY)
   trGdip_DisposeImage(infoBoxBMP, 1)
   trGdip_DisposeImage(plotBMP, 1)
   ResetImgLoadStatus()
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   toolTipGuiCreated := 2
   ; ToolTip, % maxValu "=" widthu , , , 2
}

JEE_DateIsValid(vDate) {
   FormatTime, vDate, % vDate, d
   return vDate ? 1 : 0
}

aidAvgHCalc(arrayu, indexu) {
   Static lastValue := 0
   If (arrayu[indexu]="")
      Return lastValue

   lastValue := arrayu[indexu]
   Return lastValue
}

PlotSeenDaysToggleStatsNow() {
   Static lastInvoked := 0
   If !lastInvoked
      PlotSeenDaysStatsNow(0)
   Else If (lastInvoked=1)
      PlotSeenDaysStatsNow("avg-7")
   Else If (lastInvoked=2)
      PlotSeenDaysStatsNow("avg-15")
   Else If (lastInvoked=3)
      PlotSeenDaysStatsNow("avg-30")
   Else
      PlotSeenDaysStatsNow("avg-60")

   lastInvoked := clampInRange(lastInvoked + 1, 0, 4, 1)
}

PlotSeenDaysStatsNow(modus:=0) {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaD
   LV_ModifyCol(2, "SortDesc")
   widthu := maxValu := maxKvalu := aR := aC := totalu := 0
   dataArray := []
   dataAvg := []
   dataSkipped := new hashtable()
   counter := 0
   LV_GetText(endPeriod, 1, 2)
   LV_GetText(startPeriod, LV_GetCount(), 2)
   nYear := SubStr(startPeriod, 1, 4)
   nMon:= LTrim(SubStr(startPeriod, 6, 2), "0")
   nDay:= LTrim(SubStr(startPeriod, 9, 2), "0")
   Loop
   {
      nDay++
      thisM := (nMon<10) ? "0" . nMon : nMon
      thisD := (nDay<10) ? "0" . nDay : nDay
      If !JEE_DateIsValid(nYear . thisM . thisD)
      {
         nMon++
         nDay := 1
         thisM := (nMon<10) ? "0" . nMon : nMon
         thisD := (nDay<10) ? "0" . nDay : nDay
      }

      If (nMon>12)
      {
         nMon := 1
         nDay := 0
         thisM := (nMon<10) ? "0" . nMon : nMon
         thisD := (nDay<10) ? "0" . nDay : nDay
         nYear++
      }

      dateu := nYear "-" thisM "-" thisD
      If (nYear thisM>20200401)
         dataSkipped[dateu] := 1

      If (dateu=endPeriod)
         Break
   }

   avgLevel := InStr(modus, "avg-") ? SubStr(modus, 5, 2) : 0 
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }

       LV_GetText(valu, aR, aC)
       If (isNumber(valu) && aC=3)
       {
          LV_GetText(oindexu, aR, 2)
          If InStr(oindexu, "1999-")
             Continue
          ; oindexu := SubStr(oindexu, 1, 2)
          thisu := max(maxValu, valu)
          If (thisu!=maxValu)
          {
             maxValu := thisu
             maxKvalu := oindexu
          }

          counter++
          totalu += valu
          dataSkipped[oIndexu] := valu ? 0 : 1
          dataArray[counter] := valu ? valu : 1
          If (counter=1)
             aidAvgHCalc(dataArray, 1)

          If InStr(modus, "avg-")
          {
             sumu := 0
             Loop, % avgLevel
                 sumu += aidAvgHCalc(dataArray, counter - A_Index)
             dataAvg[counter] := (dataArray[counter] + sumu)/(avgLevel + 1)
          }
       }
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   countSkipped := 0
   For Key, Value in dataSkipped
   {
      If (Value=1)
         countSkipped++
   }

   lacking := (countSkipped>0) ? groupDigits(countSkipped) " days lack data." : ""
   itemz := LV_GetCount()
   avgu := groupDigits(Floor(totalu/counter))
   GetWinClientSize(W, H, PVhwnd, 0)
   Gdip_GraphicsClear(2NDglPG)
   friendly := InStr(modus, "avg-") ? avgLevel " DAYS AVERAGED" : "DAYS"
   textu := "Seen images chart: " friendly "`nTotal: " groupDigits(counter) " days. " lacking "`nRange: " startPeriod " - " endPeriod "`nAverage: " avgu ". Peak on: " maxKvalu "=" groupDigits(maxValu)
   infoBoxBMP := drawTextInBox(textu, OSDFontName, OSDfontSize, w, h, OSDtextColor, OSDbgrColor, 1, 0)
   Scale := imgHUDbaseUnit/40
   hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
   tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
   tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
   borderSize := (counter>200) ? imgHUDbaseUnit/60 : imgHUDbaseUnit/10
   borderSizeX := borderSize + tlbrBonusX
   borderSizeY := borderSize + tlbrBonusY

   If (counter>(avgLevel*2 + 1) && InStr(modus, "avg-"))
      plotBMP := BarChart(dataAvg, namesLabel, Round(106*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:0, BarHeight:" Scale*5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,TextSize:0, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)
   Else If (counter>20)
      plotBMP := BarChart(dataArray, namesLabel, Round(106*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:0, BarHeight:" Scale*5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,TextSize:0, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)
   Else
      plotBMP := BarChart(dataArray, namesLabel, Round(196*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:2, BarHeight:" Scale*3.5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,BarTextColor:ff999999, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)

   Gdip_GetImageDimensions(plotBMP, imgW, imgH)
   Gdip_GetImageDimensions(infoBoxBMP, boxW, boxH)
   If (imgH>H - boxH - borderSizeY*2)
   {
      newBitmap := trGdip_ResizeBitmap(A_ThisFunc, plotBMP, imgW, H - boxH - borderSizeY*2, 0, 7)
      If StrLen(newBitmap)>2
      {
         trGdip_DisposeImage(plotBMP)
         plotBMP := newBitmap
         Gdip_GetImageDimensions(plotBMP, imgW, imgH)
         newBitmap := ""
      }
   }

   pBrush := Gdip_BrushCreateSolid("0xee" OSDbgrColor)
   Gdip_FillRectangle(2NDglPG, pBrush, 0, 0, max(imgW, boxW) + borderSizeX, imgH + borderSizeY)
   Gdip_DrawImage(2NDglPG, plotBMP, borderSizeX, borderSizeY)
   Gdip_DrawImage(2NDglPG, infoBoxBMP, tlbrBonusX, imgH + borderSizeY)
   trGdip_DisposeImage(infoBoxBMP, 1)
   trGdip_DisposeImage(plotBMP, 1)
   ResetImgLoadStatus()
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   toolTipGuiCreated := 2
   ; ToolTip, % maxValu "=" widthu , , , 2
}

BtnCopySeenStats() {
   textu .= "`nMONTHLY SEEN IMAGES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaM", 4)
   textu .= "`nDAILY SEEN IMAGES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaD", 4)
   textu .= "`nHOURLY SEEN IMAGES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaH", 4)

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Failed to copy to clipboard")
         SoundBeep , 300, 100
      } Else showTOOLtip("Images seen statistics copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

getListViewData(guiu, lvu, cols, delim:=" | ") {
   Gui, %guiu%: Default
   Gui, %guiu%: ListView, %lvu%

   aR := aC := 0
   textu := ""
   Loop
   {
       aC++
       If (aC>cols)
       {
          aR++
          aC := 1
       }

       LV_GetText(valu, aR, aC)
       delimu := (aC!=cols) ? " | " : "`n"
       If (valu!="")
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }
   Return textu
}

BtnCopyFileStats() {
   friendly := (uiPreferedFileStats=1) ? "MODIFIED" : "CREATED"
   textu .= "`nFILES " friendly ": DAYS:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaD", 4)
   textu .= "`nFILES " friendly ": MONTHS:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaM", 4)
   textu .= "`nFILES " friendly ": YEARS:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaY", 4)
   textu .= "`nFILE TYPES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaT", 4)
   textu .= "`nFILE SIZES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaS", 5)

   Gui, SettingsGUIA: Default
   GuiControlGet, infoLine
   textu .= "`n" infoLine "`n"

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Failed to copy to clipboard")
         SoundBeep , 300, 100
      } Else showTOOLtip("Image file properties statistics copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BtnCopyImageFileStats() {
   Gui, SettingsGUIA: Default
   GuiControlGet, infoLine
   textu := "`n" infoLine "`n"

   textu .="This text file contains data about these images detailing the prevalence of megapixels, aspect ratios, DPI, frames, pixel formats and histograms main data points.`n"

   textu .= "`nIMAGES: MEGAPIXELS`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaD", 4)
   textu .= "`nIMAGES: ASPECT RATIOS`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaY", 4)
   textu .= "`nIMAGES: DPIs`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaU", 4)
   textu .= "`nIMAGES: FRAMES`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaM", 4)
   textu .= "`nIMAGES: PIXEL FORMATS`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaS", 4)

   textu .= "`nIMAGES: HISTOGRAM - AVERAGES`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaG", 4)
   textu .= "`nIMAGES: HISTOGRAM - MEDIANS`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaA", 4)
   textu .= "`nIMAGES: HISTOGRAM - PEAK (RANGE)`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaI", 4)
   textu .= "`nIMAGES: HISTOGRAM - MINIMUM (RANGE)`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaT", 4)
   textu .= "`nIMAGES: HISTOGRAM - TOTAL (RANGE)`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaR", 4)

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Failed to copy to clipboard")
         SoundBeep , 300, 100
      } Else showTOOLtip("Image file properties statistics copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateSeenStatsInfos() {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  entriesCount := 0
  RecordSet := ""
  SQL := "SELECT imgViewDate, COUNT(*) FROM images GROUP BY imgViewDate;"
  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entriesD := []
  entriesM := []
  entriesH := []
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[1]
      {
         dateuD := "z" StrReplace(SubStr(Rowu[1], 1, 10), "-")
         dateuM := "z" StrReplace(SubStr(Rowu[1], 1, 7), "-")
         dateuH := "z" StrReplace(SubStr(Rowu[1], 12, 2), "-")
         entriez%dateuD% += Rowu[2]
         entriez%dateuM% += Rowu[2]
         entriez%dateuH% += Rowu[2]
         entriesCount += Rowu[2]
         entriesD[dateuD] := [entriez%dateuD%, SubStr(Rowu[1], 1, 10)]
         entriesM[dateuM] := [entriez%dateuM%, SubStr(Rowu[1], 1, 7)]
         entriesH[dateuH] := [entriez%dateuH%, SubStr(Rowu[1], 12, 2)]
      }
  }

  RecordSet.Free()
  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaD
  GuiControl, -Redraw, LViewMetaD
  GuiControl, -Redraw, LViewMetaM
  GuiControl, -Redraw, LViewMetaH
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesD
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaH
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesH
      LV_Add(A_Index, A_Index, Value[2] ":00", Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  GuiControl, +Redraw, LViewMetaD
  GuiControl, +Redraw, LViewMetaM
  GuiControl, +Redraw, LViewMetaH
  entriesCount := groupDigits(entriesCount)
  GuiControl, SettingsGUIA:, infoLine, Total seen images: %entriesCount%
}

QPV_FileGetSizeTime(imgPath, type, imgIndex, b:=0) {
    Switch type
    {
       Case "S":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 6] : resultedFilesList[imgIndex, 6]
       Case "M":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 7] : resultedFilesList[imgIndex, 7]
       Case "C":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 8] : resultedFilesList[imgIndex, 8]
       Case "R":
          r := 0
    }

    If !r
    {
       obju := GetFileAttributesEx(imgPath)
       updateFilesListByID(imgIndex, 6, obju.size, b)
       updateFilesListByID(imgIndex, 7, obju.wTime, b)
       updateFilesListByID(imgIndex, 8, obju.cTime, b)
       Switch type
       {
          Case "S":
             r := obju.size
          Case "M":
             r := obju.wTime
          Case "C":
             r := obju.cTime
       }
    }
    Return r
}

GetFileAttributesEx(inFile) {
; https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesexw
; coded by TheArkive and modified by Marius Șucan
; https://www.autohotkey.com/boards/viewtopic.php?t=83269
; https://github.com/TheArkive
; THANK YOU VERY MUCH @ TheArkive

    If (StrLen(inFile)>32766 || StrLen(inFile)<4)
       return

    Static GetFileExInfoStandard := 0, GetFileExMaxInfoLevel := 1 ; https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ne-minwinbase-get_fileex_info_levels
    Static attr := { Archive:0x20 ; https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants
            , Compressed:0x800, Device:0x40, Directory:0x10, Encrypted:0x4000, Hidden:0x2, integ_stream:0x8000, Normal:0x80, NotContentIndexed:0x2000
            , NoScrubData:0x20000, Offline:0x1000, ReadOnly:0x1, RecallOnDataAccess:0x400000, RecallOnOpen:0x40000, ReparsePoint:0x400, SparseFile:0x200
            , System:0x4, Temporary:0x100, Virtual:0x10000}
    
    VarSetCapacity(bFileAttribs,((A_PtrSize=8)?40:36),0) ; AHK v1
    p2 := &bFileAttribs
    r := DllCall("GetFileAttributesExW", "Str", "\\?\" inFile,"Int", 0, "Ptr", p2)
/*
    iAttribs := NumGet(bFileAttribs,"UInt")
    AttrList := []
    For attrib, value in attr
    {
        If (value & iAttribs)
           AttrList[A_Index] := attrib
    }
*/

    cTime := FileTimeToSystemTime(p2+4)  ;   CreationTimePtr
    wTime := FileTimeToSystemTime(p2+20) ;   LastWriteTime
    ; aTime := FileTimeToSystemTime(p2+12)
    
    ; sizeHigh << 32 | sizeLow 
    fileSize := (NumGet(bFileAttribs, 28, "UInt") << 32) | NumGet(bFileAttribs, 32, "UInt")
    return {attr:AttrList, cTime:cTime, aTime:aTime, wTime:wTime, size:fileSize}
}

FileTimeToSystemTime(ptr) {         
    VarSetCapacity(SYSTEMTIME, 16, 0)
    r := DllCall("FileTimeToSystemTime","Ptr",ptr,"Ptr",&SYSTEMTIME)

    VarSetCapacity(SYSTIME2, 16, 0)
    r := DllCall("SystemTimeToTzSpecificLocalTime","Ptr",0,"Ptr",&SYSTEMTIME,"Ptr",&SYSTIME2) ; https://docs.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltime

    ; dayOfWeek := NumGet(SYSTIME2,4,"UShort")
    ; mil := NumGet(SYSTIME2,14,"UShort")
    
    year := NumGet(SYSTIME2,0,"UShort")
    month := Format("{:02d}", NumGet(SYSTIME2,2,"UShort"))
    day := Format("{:02d}", NumGet(SYSTIME2,6,"UShort"))
    hour := Format("{:02d}", NumGet(SYSTIME2,8,"UShort"))
    minute := Format("{:02d}", NumGet(SYSTIME2,10,"UShort"))
    second := Format("{:02d}", NumGet(SYSTIME2,12,"UShort"))

    return year month day hour minute second
    ; return {year:year, month:month, day:day, dayOfWeek:dayOfWeek, hour:hour, minute:minute, second:second, mil:mil}
}

ETAinfos(countTFilez, filesElected, startOperation) {
   Static prevTick := 0, prevStartu, prevTimes := [], prevCountTFilez := 0, prevAvg := 0, prevZeit := 0, prevTotal
   If (prevStartu!=startOperation || countTFilez<prevCountTFilez || prevTotal!=filesElected)
   {
      prevTimes := []
      prevZeit := prevCountTFilez := prevTick := prevAvg := 0
   }

   prevTick++
   thisAmount := countTFilez - prevCountTFilez
   prevTimes.Push([thisAmount, A_TickCount])
   If (prevTick=5)
      prevTimes.RemoveAt(1)

   prevCountTFilez := countTFilez
   theSum := 0
   loops := prevTimes.Count()
   Loop, % loops
       theSum += Round(prevTimes[A_Index, 1])

   theAvg := Round(theSum/loops, 6)
   If prevAvg
      theAvg := Round((prevAvg+theAvg)/2, 6)

   prevAvg := theAvg
   prevTotal := filesElected
   intervalA := Round(prevTimes[2, 2] - prevTimes[1, 2])
   intervalB := Round(prevTimes[3, 2] - prevTimes[2, 2])
   intervalC := Round(prevTimes[4, 2] - prevTimes[3, 2])
   interval := Round((1 + intervalA + intervalB + intervalC)/3, 6)
   zeitLeftA := Round(((filesElected - countTFilez)/theAvg)*interval)
   ; ToolTip, % loops " == " prevTick " == " theSum " == " theAvg , , , 2

   prevTick := clampInRange(prevTick, 1, 4)
   prevStartu := startOperation

   zeitOperation := A_TickCount - startOperation
   percDone := " ( " Round((countTFilez / filesElected) * 100, 1) "% )"
   percLeft := (1 - countTFilez / filesElected) * 100
   zeitLeftB := (zeitOperation/countTFilez) * filesElected - zeitOperation
   etaTime := "`n" groupDigits(countTFilez) " / " groupDigits(filesElected) percDone
   If (A_TickCount - startOperation<2500)
      zeitC := (zeitLeftA+zeitLeftB)/2
   If (A_TickCount - startOperation<5000)
      zeitC := (zeitLeftA+zeitLeftA+zeitLeftB)/3
   Else If (A_TickCount - startOperation<9500)
      zeitC := (zeitLeftA+zeitLeftA+zeitLeftA+zeitLeftB)/4
   Else
      zeitC := zeitLeftA

   zeitF := prevZeit ? (Round(zeitC) + Round(prevZeit))/2 : zeitC
   If !zeitF
      zeitF := zeitLeftB
   prevZeit := zeitC
   etaTime .= "`nEstimated time left: " SecToHHMMSS(Round(zeitF/1000, 3))
   ; etaTime .= "`nEstimated B time left: " SecToHHMMSS(Round(zeitLeft2/1000, 3))
   etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
   Return etaTime
}

collectImageInfosNow(queryString:=0, modus:=0, simple:=0) {
    ; If StrLen(filesFilter)>1
    ;    remFilesListFilter("simple")

    doStartLongOpDance()
    If (simple=1)
    {
       backCurrentSLD := CurrentSLD
       CurrentSLD := ""
    }

    showTOOLtip("Collecting image details, please wait`n0 / " groupDigits(maxFilesIndex))
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
    isFilter := StrLen(filesFilter)>2 ? 1 : 0
    failedFiles := abandonAll := 0
    zEffect := (modus=11) ? Gdip_CreateEffect(6, 0, -100, 0) : 0
    Loop, % thisMaxCount
    {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
          If failedFiles
             etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

          showTOOLtip("Collecting image details, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
          prevMSGdisplay := A_TickCount
       }

       If (modus=9)
          testThis := !isFilter ? resultedFilesList[A_Index, 9] : bckpResultedFilesList[A_Index, 9]
       Else
          testThis := !isFilter ? resultedFilesList[A_Index, 11] : bckpResultedFilesList[A_Index, 11]

       If testThis
          Continue

       imgPath := !isFilter ? resultedFilesList[A_Index, 1] : bckpResultedFilesList[A_Index, 1]
       If queryString
       {
          If !coreSearchIndex(imgPath, queryString, userFilterWhat, userFilterStringIsNot)
             Continue
       }

       thisIndex := A_Index
       If (modus=9)
       {
          r := GetCachableImgFileDetails(imgPath, A_Index, 0, 0, isFilter)
       } Else
       {
          fileInfos := GetFileAttributesEx(imgPath)
          updateFilesListByID(A_Index, 6, fileInfos.size, isFilter)
          updateFilesListByID(A_Index, 7, fileInfos.wTime, isFilter)
          updateFilesListByID(A_Index, 8, fileInfos.cTime, isFilter)
          r := GetCachableHistogramFile(imgPath, A_Index, 0, 0, 1, isFilter, zEffect)
       }

       If !r
          failedFiles++
       ; ; ToolTip, % s "`n" m "`n" , , , 2
       ; Sleep, 200
    }
    ; k := resultedFilesList[3, 7]
    ; ToolTip, % k , , , 2

    Gdip_DisposeEffect(zEffect)
    PopulateIndexFilesStatsInfos("kill")
    SetTimer, ResetImgLoadStatus, -150
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    If (abandonAll!=1)
       SoundBeep, 900, 100

    If (simple=1)
    {
       CurrentSLD := backCurrentSLD
       percDone := " ( " Round((thisIndex / thisMaxCount) * 100, 1) "% )"
       If failedFiles
          percDone .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

       If (abandonAll=1)
       {
          showTOOLtip("Operation abandoned. " groupDigits(thisIndex) " / " groupDigits(thisMaxCount)) percDone
          SoundBeep, 300, 100
       } Else If (abandonAll=1)
          showTOOLtip("Finished collecting data for " groupDigits(thisMaxCount)) " files"

       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -150
       Return
    }
    Return abandonAll
}

collectFileInfosNow(queryString:=0) {
    ; If StrLen(filesFilter)>1
    ;    remFilesListFilter("simple")

    doStartLongOpDance()
    showTOOLtip("Collecting file details, please wait`n0 / " groupDigits(maxFilesIndex))
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
    isFilter := StrLen(filesFilter)>2 ? 1 : 0
    abandonAll := 0
    Loop, % thisMaxCount
    {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
          showTOOLtip("Collecting file details, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
          prevMSGdisplay := A_TickCount
       }

       testThis := !isFilter ? resultedFilesList[A_Index, 6] : bckpResultedFilesList[A_Index, 6]
       If testThis
          Continue

       If queryString
       {
          r := !isFilter ? resultedFilesList[A_Index, 1] : bckpResultedFilesList[A_Index, 1]
          If !coreSearchIndex(r, queryString, userFilterWhat, userFilterStringIsNot)
             Continue
       }

       If !isFilter
          obju := GetFileAttributesEx(resultedFilesList[A_Index, 1])
       Else
          obju := GetFileAttributesEx(bckpResultedFilesList[A_Index, 1])

       updateFilesListByID(A_Index, 6, obju.size ? obju.size : 1, isFilter)
       updateFilesListByID(A_Index, 7, obju.wTime, isFilter)
       updateFilesListByID(A_Index, 8, obju.cTime, isFilter)
       ; ; ToolTip, % s "`n" m "`n" , , , 2
       ; Sleep, 200
    }

    ; k := resultedFilesList[3, 7]
    ; ToolTip, % k , , , 2
    PopulateIndexFilesStatsInfos("kill")
    SetTimer, ResetImgLoadStatus, -150
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    If (abandonAll!=1)
       SoundBeep, 900, 100

    Return abandonAll
}

PopulateIndexFilesStatsInfos(dummy:=0) {
  Static entriesD, entriesM, entriesY, entriesT, prevState, entriesCount, totalSizeu
      , sizer1, sizeTr1, sizer2, sizeTr2, sizer3, sizeTr3, sizer4, sizeTr4
      , sizer5, sizeTr5, sizer6, sizeTr6, sizer7, sizeTr7, sizer8, sizeTr8
      , sizer9, sizeTr9, sizer10, sizeTr10, sizer11, sizeTr11, sizer12, sizer16
      , sizeTr12, sizer13, sizeTr13, sizer14, sizeTr14, sizer15, sizeTr15, sizeTr16

  startZeit := A_TickCount
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  isFilter := StrLen(filesFilter)>2 ? 1 : 0

  If (dummy!="kill")
  {
     doStartLongOpDance()
     showTOOLtip("Generating statistics, please wait`n" groupDigits(thisMaxCount) " files")
     setImageLoading()
     thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  } Else prevState := ""

  If (thisState!=prevState || dummy="kill")
  {
     entriesCount := 0, sizer1:=0, sizeTr1:=0, sizer2:=0, sizeTr2:=0, sizer3:=0, sizeTr3:=0, sizer4:=0, sizeTr4:=0
     sizer5:=0, sizeTr5:=0, sizer6:=0, sizeTr6:=0, sizer7:=0, sizeTr7:=0, sizer8:=0, sizeTr8:=0, sizer9:=0, sizeTr9:=0
     sizer10:=0, sizeTr10:=0, sizer11:=0, sizeTr11:=0, sizer12:=0, sizeTr12:=0, sizer13:=0, sizeTr13:=0, sizer14:=0
     sizeTr14:=0, sizer15:=0, sizeTr15:=0, sizer16:=0, sizeTr16:=0, totalSizeu := 0

     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     If (dummy="kill")
     {
        ; bckpResultedFilesList := []
        ; filteredMap2mainList := []
        ; filesFilter := ""
        ; bckpMaxFilesIndex := 0
        prevState := ""
        PopulateIndexSQLFilesStatsInfos(dummy)
        PopulateImagesIndexStatsInfos(dummy)
        Return
     }

     whichDate := (uiPreferedFileStats=1) ? 7 : 8
     prevMSGdisplay := A_TickCount
     Loop, % thisMaxCount
     {
         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(A_Index, thisMaxCount, startZeit)
            showTOOLtip("Generating statistics, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }

         If (isFilter=1)
         {
            imgPath := bckpResultedFilesList[A_Index, 1]
            dateu := bckpResultedFilesList[A_Index, whichDate]
            sizeu := bckpResultedFilesList[A_Index, 6]
         } Else
         {
            imgPath := resultedFilesList[A_Index, 1]
            dateu := resultedFilesList[A_Index, whichDate]
            sizeu := resultedFilesList[A_Index, 6]
         }

         ; ToolTip, % imgPath "`n" dateu "`n" sizeu , , , 2
         foundPos := InStr(imgPath, ".", 0, -1)
         If foundPos
         {
            fileEXT := SubStr(imgPath, foundPos + 1)
            entriez%fileEXT%++
            entriesT[fileEXT] := [entriez%fileEXT%, fileEXT]
         }

         If dateu
         {
            dateuD := "z" SubStr(dateu, 1, 8)
            dateuM := "z" SubStr(dateu, 1, 6)
            dateuY := "z" SubStr(dateu, 1, 4)
            entriez%dateuD%++
            entriez%dateuM%++
            entriez%dateuY%++
            entriesD[dateuD] := [entriez%dateuD%, dateuD]
            entriesM[dateuM] := [entriez%dateuM%, dateuM]
            entriesY[dateuY] := [entriez%dateuY%, dateuY]
         }

         If (sizeu>0)
         {
            entriesCount++
            totalSizeu += Round(sizeu/(1024**2), 4)
            If (sizeu<=5000001)
            {
               If isInRange(sizeu, 0, 4998)
               {
                  sizeTr1 += sizeu
                  sizer1++
               } Else If isInRange(sizeu, 4999, 10001)
               {
                  sizeTr2 += sizeu
                  sizer2++
               } Else If isInRange(sizeu, 10002, 25001)
               {
                  sizeTr3 += sizeu
                  sizer3++
               } Else If isInRange(sizeu, 25002, 50001)
               {
                  sizeTr4 += sizeu
                  sizer4++
               } Else If isInRange(sizeu, 50002, 100001)
               {
                  sizeTr5 += sizeu
                  sizer5++
               } Else If isInRange(sizeu, 100002, 250001)
               {
                  sizeTr6 += sizeu
                  sizer6++
               } Else If isInRange(sizeu, 250002, 500001)
               {
                  sizeTr7 += sizeu
                  sizer7++
               } Else If isInRange(sizeu, 500002, 1000001)
               {
                  sizeTr8 += sizeu
                  sizer8++
               } Else If isInRange(sizeu, 1000002, 2500001)
               {
                  sizeTr9 += sizeu
                  sizer9++
               } Else If isInRange(sizeu, 2500002, 5000001)
               {
                  sizeTr10 += sizeu
                  sizer10++
               }
            } Else
            {
               If isInRange(sizeu, 5000002, 10000001)
               {
                  sizeTr11 += sizeu
                  sizer11++
               } Else If isInRange(sizeu, 10000002, 25000001)
               {
                  sizeTr12 += sizeu
                  sizer12++
               } Else If isInRange(sizeu, 25000002, 50000001)
               {
                  sizeTr13 += sizeu
                  sizer13++
               } Else If isInRange(sizeu, 50000002, 100000001)
               {
                  sizeTr14 += sizeu
                  sizer14++
               } Else If isInRange(sizeu, 100000002, 250000001)
               {
                  sizeTr15 += sizeu
                  sizer15++
               } Else If isInRange(sizeu, 250000002, 500000001)
               {
                  sizeTr16 += sizeu
                  sizer16++
               }
            }
         }

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            prevState := ""
            Break
         }
     }
     If (abandonAll!=1)
        prevState := thisState
  }

  entriesCount := StrReplace(entriesCount, A_Space)
  ; msgBox, % entriesCount "=" thisMaxCount
  If (entriesCount<Round(thisMaxCount - 1)) && (abandonAll!=1)
  {
     msgResult := msgBoxWrapper(appTitle ": Statistics", appTitle " has not yet indexed the files' details. These are required to populate this panel with statistics. Would you like to collect the data now? This may take awhile...", 4, 0, "question")
     If (msgResult="Yes")
     {
        prevState := ""
        RemoveTooltip()
        BtnCloseWindow()
        r := collectFileInfosNow()
        If !r
           SetTimer, PanelIndexedFilesStats, -250
        Return
     }
  }

  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     executingCanceableOperation := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }
 
  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaD
  GuiControl, -Redraw, LViewMetaD
  GuiControl, -Redraw, LViewMetaM
  GuiControl, -Redraw, LViewMetaY
  GuiControl, -Redraw, LViewMetaS
  GuiControl, -Redraw, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
  {
      stringu := ST_Insert("-", SubStr(Value[2], 2), 5)
      stringu := ST_Insert("-", stringu, 8)
      If (Value[1]>1)
         LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
  {
      stringu := ST_Insert("-", SubStr(Value[2], 2), 5)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, SubStr(Value[2], 2), Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  showTOOLtip("Generating statistics, please wait", 0, 0, 3/10)
  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  LV_Add(1, 1, "<5 KB", Round(sizeTr1/(1024**2), 1), sizer1, Round((sizer1/thisMaxCount)*100, 1))
  LV_Add(2, 2, "5-10 KB", Round(sizeTr2/(1024**2), 1), sizer2, Round((sizer2/thisMaxCount)*100, 1))
  LV_Add(3, 3, "10-25 KB", Round(sizeTr3/(1024**2), 1), sizer3, Round((sizer3/thisMaxCount)*100, 1))
  LV_Add(4, 4, "25-50 KB", Round(sizeTr4/(1024**2), 1), sizer4, Round((sizer4/thisMaxCount)*100, 1))
  LV_Add(5, 5, "50-100 KB", Round(sizeTr5/(1024**2), 1), sizer5, Round((sizer5/thisMaxCount)*100, 1))
  LV_Add(6, 6, "100-250 KB", Round(sizeTr6/(1024**2), 1), sizer6, Round((sizer6/thisMaxCount)*100, 1))
  LV_Add(7, 7, "250-500 KB", Round(sizeTr7/(1024**2), 1), sizer7, Round((sizer7/thisMaxCount)*100, 1))
  LV_Add(8, 8, "0.5-1.0 MB", Round(sizeTr8/(1024**2), 1), sizer8, Round((sizer8/thisMaxCount)*100, 1))
  LV_Add(9, 9, "1.0-2.5 MB", Round(sizeTr9/(1024**2), 1), sizer9, Round((sizer9/thisMaxCount)*100, 1))
  LV_Add(10, 10, "2.5-5.0 MB", Round(sizeTr10/(1024**2), 1), sizer10, Round((sizer10/thisMaxCount)*100, 1))
  LV_Add(11, 11, "5-10 MB", Round(sizeTr11/(1024**2), 1), sizer11, Round((sizer11/thisMaxCount)*100, 1))
  LV_Add(12, 12, "10-25 MB", Round(sizeTr12/(1024**2), 1), sizer12, Round((sizer12/thisMaxCount)*100, 1))
  LV_Add(13, 13, "25-50 MB", Round(sizeTr13/(1024**2), 1), sizer13, Round((sizer13/thisMaxCount)*100, 1))
  LV_Add(14, 14, "50-100 MB", Round(sizeTr14/(1024**2), 1), sizer14, Round((sizer14/thisMaxCount)*100, 1))
  LV_Add(15, 15, "100-250 MB", Round(sizeTr15/(1024**2), 1), sizer15, Round((sizer15/thisMaxCount)*100, 1))
  LV_Add(16, 16, "250-500 MB", Round(sizeTr16/(1024**2), 1), sizer16, Round((sizer16/thisMaxCount)*100, 1))

  Loop, 5
     LV_ModifyCol(A_Index, "AutoHdr Center")

  GuiControl, +Redraw, LViewMetaD
  GuiControl, +Redraw, LViewMetaM
  GuiControl, +Redraw, LViewMetaY
  GuiControl, +Redraw, LViewMetaS
  GuiControl, +Redraw, LViewMetaT
  entriesCount := groupDigits(entriesCount)
  totalFsize := Round(totalSizeu/1024, 1)
  GuiControl, SettingsGUIA:, infoLine, Total images: %entriesCount% [%totalFsize% GB]
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

retrieveGroupSQLimgInfos(which, thisGroup, totalgroups, constrain:="imgwidth") {
   showTOOLtip("Retrieving statistics from the database, please wait`n" thisGroup " / " totalgroups " ( " which " )", 0, 0, thisGroup/totalgroups)
   SQL := "SELECT " which ", Count(*) FROM images WHERE " constrain " IS NOT NULL GROUP BY " which ";"
   If activeSQLdb.GetTable(SQL, RecordSet)
   {
      newArrayu := []
      Loop, % RecordSet.RowCount
      {
         Rowu := RecordSet.Rows[A_Index]
         If (Rowu[1]!="")
            newArrayu[A_Index] := [Rowu[2], Rowu[1]]
      }

      RecordSet.Free()
      Return newArrayu
   }
}

retrieveHistoGroupSQLimgInfos(which, thisGroup, totalgroups, constrain:="imgavg") {
   showTOOLtip("Retrieving statistics from the database, please wait`n" thisGroup " / " totalgroups " ( " which " )", 0, 0, thisGroup/totalgroups)
   SQL := "SELECT Round(" which "*256), Count(*) FROM images WHERE " constrain " IS NOT NULL GROUP BY " which ";"
   entriezHM1 := entriezHM2 := entriezHM3 := entriezHM4 := entriezHM5 := 0
   If activeSQLdb.GetTable(SQL, RecordSet)
   {
      entriesG := []
      Loop, % RecordSet.RowCount
      {
         Rowu := RecordSet.Rows[A_Index]
         If (Rowu[1]!="")
         {
            hmed := Rowu[1]
            If isInRange(hmed, 0, 50)
            {
               entriezHM1 := entriezHM1 + Rowu[2]
               entriesG[1] := [entriezHM1, "0-50"]
            } Else If isInRange(hmed, 50, 100)
            {
               entriezHM2 := entriezHM2 + Rowu[2]
               entriesG[2] := [entriezHM2, "50-100"]
            } Else If isInRange(hmed, 100, 150)
            {
               entriezHM3 := entriezHM3 + Rowu[2]
               entriesG[3] := [entriezHM3, "100-150"]
            } Else If isInRange(hmed, 150, 200)
            {
               entriezHM4 := entriezHM4 + Rowu[2]
               entriesG[4] := [entriezHM4, "150-200"]
            } Else If isInRange(hmed, 200, 258)
            {
               entriezHM5 := entriezHM5 + Rowu[2]
               entriesG[5] := [entriezHM5, "200-255"]
            }
         }
      }

      RecordSet.Free()
      Return entriesG
   }
}

PopulateImagesIndexStatsInfos(dummy:=0) {
  Static entriesR, entriesD, entriesS, entriesU, entriesM, entriesY, entriesT, entriesA, entriesI, entriesG, prevState, entriesCount, prevMaxu

  startZeit := A_TickCount
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  isFilter := StrLen(filesFilter)>2 ? 1 : 0
  If (dummy!="kill")
  {
     doStartLongOpDance()
     showTOOLtip("Generating statistics on images details, please wait`n" groupDigits(thisMaxCount) " files")
     setImageLoading()
     thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  } Else prevState := ""

  If (thisState!=prevState || dummy="kill")
  {
     entriesCount := totalSizeu := entriezHM1 := entriezHM2 := entriezHM3 := entriezHM4 := entriezHM5 := prevMaxu := 0
     entriezHL1 := entriezHP1 := entriezHA1 := entriezHL2 := entriezHP2 := entriezHA2 := entriezHL3 := entriezHP3 := entriezHA3 := entriezHL4 := entriezHP4 := entriezHA4 := entriezHL5 := entriezHP5 := entriezHA5 := 0

     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     entriesA := []
     entriesG := []
     entriesU := []
     entriesI := []
     entriesR := []
     If (dummy="kill")
     {
        prevState := ""
        Return
     }

     If (SLDtypeLoaded=3)
     {
        prevMaxu := getTotalIMGsSQLdb()
        ; prevMaxu := getTotalIMGsSQLdb("WHERE imgwidth IS NOT NULL")
        thisMaxCount := prevMaxu
        If !prevMaxu
           Return 0

        entriesS := retrieveGroupSQLimgInfos("imgpixfmt", 2, 12)
        entriesM := retrieveGroupSQLimgInfos("imgframes", 3, 12)
        entriesU := retrieveGroupSQLimgInfos("imgdpi", 4, 12)
        entriesD := retrieveGroupSQLimgInfos("Round(imgmegapix, 1)", 5, 12)
        entriesY := retrieveGroupSQLimgInfos("Round(imgwhratio, 1)", 6, 12)
        entriesT := retrieveHistoGroupSQLimgInfos("imgavg", 7, 12)
        entriesG := retrieveHistoGroupSQLimgInfos("imgmedian", 8, 12)
        entriesA := retrieveHistoGroupSQLimgInfos("imghpeak", 9, 12)
        entriesI := retrieveHistoGroupSQLimgInfos("imghlow", 10, 12)
        entriesR := retrieveHistoGroupSQLimgInfos("imghrange", 11, 12)
     }

     prevMSGdisplay := A_TickCount
     Loop, % thisMaxCount
     {
         If (SLDtypeLoaded=3)
            Break

         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(A_Index, thisMaxCount, startZeit)
            showTOOLtip("Generating statistics, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }

         entriesCount++
         If (isFilter=1)
         {
            mgpx := bckpResultedFilesList[A_Index, 17]
            frames := bckpResultedFilesList[A_Index, 9]
            ratio := bckpResultedFilesList[A_Index, 16]
            pixfmt := bckpResultedFilesList[A_Index, 15]
            havg := bckpResultedFilesList[A_Index, 18]
            hmed := bckpResultedFilesList[A_Index, 19]
            hpeak := bckpResultedFilesList[A_Index, 20]
            hlow := bckpResultedFilesList[A_Index, 21]
            dpiu := bckpResultedFilesList[A_Index, 22]
            hrange := bckpResultedFilesList[A_Index, 25]
         } Else
         {
            mgpx := resultedFilesList[A_Index, 17]
            frames := resultedFilesList[A_Index, 9]
            ratio := resultedFilesList[A_Index, 16]
            pixfmt := resultedFilesList[A_Index, 15]
            havg := resultedFilesList[A_Index, 18]
            hmed := resultedFilesList[A_Index, 19]
            hpeak := resultedFilesList[A_Index, 20]
            hlow := resultedFilesList[A_Index, 21]
            dpiu := resultedFilesList[A_Index, 22]
            hrange := resultedFilesList[A_Index, 25]
         }

         havg := Round(256*havg)
         hmed := Round(256*hmed)
         hpeak := Round(256*hpeak)
         hlow := Round(256*hlow)
         hrange := Round(256*hrange)
         If isInRange(havg, 0, 50)
         {
            entriezHA1++
            entriesT[1] := [entriezHA1, "0-50"]
         } Else If isInRange(havg, 50, 100)
         {
            entriezHA2++
            entriesT[2] := [entriezHA2, "50-100"]
         } Else If isInRange(havg, 100, 150)
         {
            entriezHA3++
            entriesT[3] := [entriezHA3, "100-150"]
         } Else If isInRange(havg, 150, 200)
         {
            entriezHA4++
            entriesT[4] := [entriezHA4, "150-200"]
         } Else If isInRange(havg, 200, 258)
         {
            entriezHA5++
            entriesT[5] := [entriezHA5, "200-255"]
         }

         If isInRange(hmed, 0, 50)
         {
            entriezHM1++
            entriesG[1] := [entriezHM1, "0-50"]
         } Else If isInRange(hmed, 50, 100)
         {
            entriezHM2++
            entriesG[2] := [entriezHM2, "50-100"]
         } Else If isInRange(hmed, 100, 150)
         {
            entriezHM3++
            entriesG[3] := [entriezHM3, "100-150"]
         } Else If isInRange(hmed, 150, 200)
         {
            entriezHM4++
            entriesG[4] := [entriezHM4, "150-200"]
         } Else If isInRange(hmed, 200, 258)
         {
            entriezHM5++
            entriesG[5] := [entriezHM5, "200-255"]
         }

         If isInRange(hpeak, 0, 50)
         {
            entriezHP1++
            entriesA[1] := [entriezHP1, "0-50"]
         } Else If isInRange(hpeak, 50, 100)
         {
            entriezHP2++
            entriesA[2] := [entriezHP2, "50-100"]
         } Else If isInRange(hpeak, 100, 150)
         {
            entriezHP3++
            entriesA[3] := [entriezHP3, "100-150"]
         } Else If isInRange(hpeak, 150, 200)
         {
            entriezHP4++
            entriesA[4] := [entriezHP4, "150-200"]
         } Else If isInRange(hpeak, 200, 258)
         {
            entriezHP5++
            entriesA[5] := [entriezHP5, "200-255"]
         }

         If isInRange(hlow, 0, 50)
         {
            entriezHL1++
            entriesI[1] := [entriezHL1, "0-50"]
         } Else If isInRange(hlow, 50, 100)
         {
            entriezHL2++
            entriesI[2] := [entriezHL2, "50-100"]
         } Else If isInRange(hlow, 100, 150)
         {
            entriezHL3++
            entriesI[3] := [entriezHL3, "100-150"]
         } Else If isInRange(hlow, 150, 200)
         {
            entriezHL4++
            entriesI[4] := [entriezHL4, "150-200"]
         } Else If isInRange(hlow, 200, 258)
         {
            entriezHL5++
            entriesI[5] := [entriezHL5, "200-255"]
         }

         If isInRange(hRange, 0, 50)
         {
            entriezHR1++
            entriesR[1] := [entriezHR1, "0-50"]
         } Else If isInRange(hRange, 50, 100)
         {
            entriezHR2++
            entriesR[2] := [entriezHR2, "50-100"]
         } Else If isInRange(hRange, 100, 150)
         {
            entriezHR3++
            entriesR[3] := [entriezHR3, "100-150"]
         } Else If isInRange(hRange, 150, 200)
         {
            entriezHR4++
            entriesR[4] := [entriezHR4, "150-200"]
         } Else If isInRange(hRange, 200, 258)
         {
            entriezHR5++
            entriesR[5] := [entriezHR5, "200-255"]
         }

         mgpx := Round(mgpx, 1)
         ratio := Round(ratio, 1)
         pixu := "z" StringToASC(pixfmt)
         ratiou := StrReplace(ratio, ".", "q")
         mgpxu := StrReplace(mgpx, ".", "q")
         entriez%ratiou%++
         entriez%pixu%++
         entriezMP%mgpxu%++
         entriezFram%frames%++
         entriezU%dpiu%++
         entriesD[mgpxu] := [entriezMP%mgpxu%, mgpx]
         entriesS[pixu] := [entriez%pixu%, pixFmt]
         entriesY[ratiou] := [entriez%ratiou%, ratio]
         entriesM["z" frames] := [entriezFram%frames%, frames]
         entriesU["z" dpiu] := [entriezU%dpiu%, dpiu]

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            prevState := ""
            Break
         }
     }
     If (SLDtypeLoaded=3)
        RecordSet.Free()

     If (abandonAll!=1)
        prevState := thisState
  }

  If (SLDtypeLoaded=3 && prevMaxu)
     thisMaxCount := prevMaxu

  If (SLDtypeLoaded=3)
  {
     entriesCount := 0
     Loop, % entriesD.Count()
        entriesCount += entriesD[A_Index, 1]
  }

  entriesCount := StrReplace(entriesCount, A_Space)
  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     executingCanceableOperation := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaD
  GuiControl, -Redraw, LViewMetaD
  GuiControl, -Redraw, LViewMetaM
  GuiControl, -Redraw, LViewMetaU
  GuiControl, -Redraw, LViewMetaY

  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  Loop, 4
     LV_ModifyCol(A_Index, "Integer")

  For Key, Value in entriesM
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaU
  Loop, 4
     LV_ModifyCol(A_Index, "Integer")

  For Key, Value in entriesU
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaA
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesA
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaG
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesG
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  Gui, SettingsGUIA: ListView, LViewMetaR
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesR
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")
  Gui, SettingsGUIA: ListView, LViewMetaI
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesI
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")
  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesS
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 5
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")

  GuiControl, +Redraw, LViewMetaD
  GuiControl, +Redraw, LViewMetaM
  GuiControl, +Redraw, LViewMetaU
  GuiControl, +Redraw, LViewMetaY
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  percDone := " (" Round((entriesCount / thisMaxCount) * 100, 1) "%)"
  entriesCount := groupDigits(entriesCount)
  thisMaxCount := groupDigits(thisMaxCount)
  GuiControl, SettingsGUIA:, infoLine, Indexed images: %entriesCount% / %thisMaxCount%%percDone%
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

PopulateIndexSQLFilesStatsInfos(dummy:=0) {
  Static entriesD, entriesM, entriesY, entriesT, prevState, entriesCount

  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount uiPreferedFileStats
  startZeit := A_TickCount
  If (thisState!=prevState || dummy="kill")
  {
     cachedMode := entriesCount := 0
     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     zr := uiFileIndexStatsRetrieveSizeRangeDB(1, q, 1, ":-)", 0, 1)
     If (dummy="kill")
     {
        prevState := ""
        Return 0
     }

     If (sqlFailedInit=1)
     {
        prevState := ""
        Return 0
     }

     RecordSet := ""
     tableu := (uiPreferedFileStats=1) ? "fmodified" : "Fcreated"
     SQL := "SELECT substr(" tableu ", 1, 8), COUNT(*) FROM images GROUP BY substr(" tableu ", 1, 8);"
     If !activeSQLdb.GetTable(SQL, RecordSet)
     {
        throwSQLqueryDBerror(A_ThisFunc)
        prevState := ""
        Return 0
     }

     doStartLongOpDance()
     showTOOLtip("Generating statistics, please wait", 0, 0, 0.4/10)
     setImageLoading()

     Loop, % RecordSet.RowCount
     {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[1]
         {
            dateuD := "z" Rowu[1] ; SubStr(Row[1], 1, 8)
            dateuM := "z" SubStr(Rowu[1], 1, 6)
            dateuY := "z" SubStr(Rowu[1], 1, 4)
            entriez%dateuD% += Rowu[2]
            entriez%dateuM% += Rowu[2]
            entriez%dateuY% += Rowu[2]
            entriesCount += Rowu[2]
            entriesD[dateuD] := [entriez%dateuD%, Rowu[1]] ; SubStr(Row[1], 1, 8)]
            entriesM[dateuM] := [entriez%dateuM%, SubStr(Rowu[1], 1, 6)]
            entriesY[dateuY] := [entriez%dateuY%, SubStr(Rowu[1], 1, 4)]
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }
         }
     }
     prevState := (abandonAll!=1) ? thisState : ""
     RecordSet.Free()
  } Else cachedMode := 1

  entriesCount := StrReplace(entriesCount, A_Space)
  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  showTOOLtip("Generating statistics, please wait", 0, 0, 1.5/10)
  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaD
  GuiControl, -Redraw, LViewMetaD
  GuiControl, -Redraw, LViewMetaM
  GuiControl, -Redraw, LViewMetaY
  GuiControl, -Redraw, LViewMetaS
  GuiControl, -Redraw, LViewMetaT

  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
  {
      stringu := ST_Insert("-", Value[2], 5)
      stringu := ST_Insert("-", stringu, 8)
      If (Value[1]>1)
         LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(2, "SortDesc")
  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
  {
      stringu := ST_Insert("-", Value[2], 5)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(2, "SortDesc")
  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  isFilter := StrLen(filesFilter)>2 ? 1 : 0
  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  showTOOLtip("Generating statistics, please wait", 0, 0, 3/10)
  Loop, % thisMaxCount
  {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (isFilter=1)
         imgPath := bckpResultedFilesList[A_Index, 1]
      Else
         imgPath := resultedFilesList[A_Index, 1]

      foundPos := InStr(imgPath, ".", 0, -1)
      If foundPos
      {
         fileEXT := SubStr(imgPath, foundPos + 1)
         entriez%fileEXT%++
         entriesT[fileEXT] := [entriez%fileEXT%, fileEXT]
      }
  }

  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  If (abandonAll=1 || determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastOtherWinClose := A_TickCount
     interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  zr := (cachedMode=1) ? "c" : 0
  j := 0
  showTOOLtip("Generating statistics, please wait", 0, 0, 4/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 1, "<5 KB", 0, 4998)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 2, "5-10 KB", 4999, 10001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 3, "10-25 KB", 10002, 25001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 4, "25-50 KB", 25002, 50001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 6/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 5, "50-100 KB", 50002, 100001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 6, "100-250 KB", 100002, 250001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 7, "250-500 KB", 250002, 500001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 8, "0.5-1.0 MB", 500002, 1000001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 8/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 9, "1.0-2.5 MB", 1000002, 2500001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 10, "2.5-5.0 MB", 2500002, 5000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 11, "5-10 MB", 5000002, 10000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 12, "10-25 MB", 10000002, 25000001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 9/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 13, "25-50 MB", 25000002, 50000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 14, "50-100 MB", 50000002, 100000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 15, "100-250 MB", 100000002, 250000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 16, "250-500 MB", 250000002, 500000001)
  Loop, 5
     LV_ModifyCol(A_Index, "AutoHdr Center")

  entriesCount := groupDigits(entriesCount)
  totalFsize := Round(j/1024, 1)
  GuiControl, +Redraw, LViewMetaD
  GuiControl, +Redraw, LViewMetaM
  GuiControl, +Redraw, LViewMetaY
  GuiControl, +Redraw, LViewMetaS
  GuiControl, +Redraw, LViewMetaT
  GuiControl, SettingsGUIA:, infoLine, Total images: %entriesCount% [%totalFsize% GB]
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

uiFileIndexStatsRetrieveSizeRangeDB(zr, ByRef totalSizeu, indexu, labelu, minu, maxu) {
  Static cacheInfos := []

  thisCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  If (zr=1)
  {
     cacheInfos := []
     Return
  } Else If (zr="c")
  {
     LV_Add(indexu, indexu, labelu, cacheInfos[indexu, 1], cacheInfos[indexu, 2], Round((cacheInfos[indexu, 2]/thisCount)*100, 1))
     totalSizeu += cacheInfos[indexu, 1]
     Return "c"
  }

  SQL := "SELECT sum(fsize), COUNT(*) FROM images WHERE fsize BETWEEN " minu " AND " maxu ";"
  If activeSQLdb.GetTable(SQL, RecordSet)
  {
     abandonAll := thisSizeFiles := thisTotalSizeRange := 0
     Loop, % RecordSet.RowCount
     {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[1]
         {
            thisSizeFiles := Rowu[2]
            thisTotalSizeRange := Rowu[1]
            ; thisSizeFiles++
            ; thisTotalSizeRange += Row[1]
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }
         }
     }
     RecordSet.Free()
     totalSizeu += Round(thisTotalSizeRange/(1024**2), 4)
     cacheInfos[indexu] := [Round(thisTotalSizeRange/(1024**2), 1), thisSizeFiles]
     LV_Add(indexu, indexu, labelu, Round(thisTotalSizeRange/(1024**2), 1), thisSizeFiles, Round((thisSizeFiles/thisCount)*100, 1))
  }

  Return abandonAll
}

PanelImageInfos() {
    Global LViewMetaD, LViewMetaOthers
    If (thumbsDisplaying=1)
       MenuDummyToggleThumbsMode()

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, fileNamu, folderu)
    If !FileRexists(imgPath)
    {
       fileMsg := (userPrivateMode=1) ? "" : "`n" fileNamu "`n" folderu "\"
       showTOOLtip("ERROR: File not found or access denied" fileMsg)
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(5, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 230
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Tab3,, General|Others
    Gui, Tab, 1 ; general
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid -multi vLViewMetaD, Property|Data
    Gui, Tab, 2 ; general
    Gui, Add, ListView, x+15 y+15 w%lstWid% +LV0x10000 r%uLVr% Grid -multi vLViewMetaOthers, Property|Data
    Gui, Tab

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w40 gInfoBtnPrevImg +hwndhBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gInfoBtnNextImg +hwndhBtnNextImg, >>
    ToolTip2ctrl(hBtnNextImg, "Next image")
    ToolTip2ctrl(hBtnPrevImg, "Previous image")

    Gui, Add, Button, x+15 hp w%btnWid% gcopyIMGinfos2clip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid% gOpenThisFileFolder, &Explore folder
    Gui, Add, Button, x+5 hp w%btnWid% gOpenFileProperties, &File properties
    Gui, Add, Button, x+5 hp w90 Default gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file details: " appTitle)
    PopulateImgInfos()
}

MenuPanelFoldersTree() {
   If (folderTreeWinOpen=1)
      fdTreeClose()
   Else
      PanelFoldersTree()
}

PanelFoldersTree() {
    Static hasRan, prevSize := 0
    Global fdTreeInfoLine
    If MsgBox2hwnd
       Return

    mouseTurnOFFtooltip()
    thisSize := 300 + PrefsLargeFonts + uiUseDarkMode
    If (hasRan=1 && prevSize!=thisSize)
    {
       hasRan := 0
       Gui, fdTreeGuia: Destroy
    }

    If (userPrivateMode=1)
       msgBoxWrapper(appTitle ": WARNING", "QPV is currently in private mode, hiding all file paths and images, for privacy.`n `nWARNING: The folders tree panel DOES NOT WORK in private mode. Proceed with care.", 0, 0, "exclamation")

    If (hasRan=1)
    {
       Gui, fdTreeGuia: Show
       folderTreeWinOpen := 1
       interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
       Return
    }

    INIaction(0, "showFolderTreeDetails", "General", 1)
    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: +Resize -DPIScale -MaximizeBox -MinimizeBox +Owner%PVhwnd% +hwndhfdTreeWinGui +ToolWindow
    Gui, fdTreeGuia: Margin, 1, 1
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    If (uiUseDarkMode=1)
    {
       Gui, Color, % darkWindowColor, % darkWindowColor
       Gui, Font, c%darkControlColor%
       setDarkWinAttribs(hfdTreeWinGui)
    }

    prevSize := thisSize
    thisBtnHeight := (PrefsLargeFonts=1) ? 45 : 35
    btnWid := 105
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 230
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, TreeView, r10 vTVlistFolders AltSubmit +hwndhTVlistFolders gFolderTreeResponder
    Gui, Add, Button, xp y+1 w%thisBtnHeight% h%thisBtnHeight% gfolderTreeMiniBtn vbtnFldr, .\
    Gui, Add, Text, x+2 vfdTreeInfoLine +0x200 gfolderTreeCopyPath -wrap +TabStop, Folder tree status bar...
    Gui, Add, Button, x+1 y+1 w1 h1 -wantTab -TabStop Default gfolderTreeDefaultAction, &Default

    winPos := (prevSetWinPosY && prevSetWinPosX) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("fdTreeGuia", hfdTreeWinGui, 0, "Folders tree view: " appTitle, winPos)
    folderTreeWinOpen := 1
    interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
    interfaceThread.ahkassign("hfdTreeWinGui", hfdTreeWinGui)
    hasRan := 1
    SetTimer, FolderTreeRepopulate, -100
    fdTreeGuiaGuiSize()
}

folderTreeMiniBtn() {
   r := invokeFoldersListerMenu()
   If (r="err")
      folderTreeContextMenu()
}

folderTreeCopyPath(dummy:=0) {
   Static lastInvoked := 0
   If (A_TickCount - lastInvoked<356) || (dummy="forced")
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      folderPath := folderTreeGetSelectedPath(c)
      If !folderPath
         Return

      Try Clipboard := folderPath
      Catch wasError
          Sleep, 1

      If !wasError
      {
         showTOOLtip("Folder path copied to the clipboard:`n" folderPath)
      } Else
      {
         showTOOLtip("ERROR: Failed to copy folder path to the clipboard:`n" folderPath)
         SoundBeep 300, 100
      }
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else lastInvoked := A_TickCount
}

folderTreeSetFolderProtected() {
   folderTreeDefaultAction("protect", "yo")
}

folderTreeOpenInExplorer() {
   folderTreeDefaultAction("explorer", "yo")
}

folderTreeOpenInNewInstance() {
   folderTreeDefaultAction("anew", "yo")
}

folderTreePropertiesFolder() {
   folderTreeDefaultAction("properties", "yo")
}

folderTreeDefaultAction(modus:=0, g:=0) {
   z := 0
   If (modus="protect" && g="yo")
      z := 4
   Else If (modus="properties" && g="yo")
      z := 3
   Else If GetKeyState("Shift", "P") || (modus="anew" && g="yo") 
      z := 2
   Else If GetKeyState("Ctrl", "P") || (modus="explorer" && g="yo")
      z := 1

   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   folderPath := folderTreeGetSelectedPath(c)
   If (z=1 && folderPath)
   {
      Try Run, "%folderPath%"
      Catch wasError
      {
         If !AnyWindowOpen
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderPath, 0, 0, "error")
      }
   } Else If (z=2 && folderPath)
   {
      OpenNewQPVinstance(folderPath)
   } Else If (z=3 && folderPath)
   {
      invokeStandardFolderProperties(folderPath)
   } Else If (z=4 && folderPath)
   {
      setContaintFolderAsProtected(folderPath)
   } Else If folderPath
   {
      If askAboutFileSave(" and the selected folder will be opened")
         Return

      If askAboutSlidesListSave()
         Return

      If askAboutFilesSelect("discard it")
         Return

      tryOpenGivenFolder(folderPath, CurrentSLD)
      FileExploreSiblingsNav("reset")
      Sleep, 1
      WinActivate, ahk_id %hfdTreeWinGui%
   }
}

fdTreeGuiaGuiSize() {
   Critical, on
   Static hasRan := 0, lastState := -1
   If (lastState!=PrefsLargeFonts)
   {
      hasRan := 0
      lastState := PrefsLargeFonts
   }

   GetWinClientSize(Width, Height, hfdTreeWinGui, 0)
   If (!width || !height || folderTreeWinOpen!=1)
      Return

   ; GuiControlGet, hBtn, fdTreeGuia: hwnd, btnFldr
   GuiControlGet, hText, fdTreeGuia: hwnd, fdTreeInfoLine
   GetControlPosGui(hfdTreeWinGui, hText, ex, ey, ew, eh)
   f := (PrefsLargeFonts=1) ? 1.5 : 1.7
   b := hasRan ? eh : Round(eh*f)
   height -= b
   GuiControl, fdTreeGuia: Move, TVlistFolders, w%width% h%height%
   width -= b + b//3
   yPos := height + 2
   x := b + b//3
   bf := b - 2
   hasRan++
   GuiControl, fdTreeGuia: Move, fdTreeInfoLine, x%x% y%yPos% w%width% h%b%
   GuiControl, fdTreeGuia: Move, btnFldr, y%yPos% w%b% h%bf%
   ; SoundBeep , 900, 100
   If determineLClickstate()
      SetTimer, fdTreeGuiaGuiSize, -300
}

fdTreeClose() {
   lastTimeToggleThumbs := A_TickCount 
   lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   Gui, fdTreeGuia: Hide
   folderTreeWinOpen := 0
   interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
}

fdTreeGuiaGuiClose:
fdTreeGuiaGuiEscape:
   fdTreeClose()
Return

FolderTreeResponder(a, b, c) {
   Static lastInvoked, prevCu, doNotAskAgain := 0
   ; ToolTip, % "a=" a " b=" b "|" A_DefaultTreeView "| c=" c , , , 2
   If (b="Normal" && StrLen(c)>3)
   {
      TV_Modify(c)
      zeit := A_TickCount - lastInvoked
      ; ToolTip, % zeit "==" prevCu "==" c , , , 2
      If (zeit<1234 && prevCu=c)
      {
         If TV_Get(c, "Expand")
            TV_Modify(c, "-Expand")
         Else
            TV_Modify(c, "+Expand")
      }
      lastInvoked := A_TickCount
      prevCu := c
   } Else If (b="K" && c=115) ; F4
   {
      WinActivate, ahk_id %PVhwnd%
   } Else If (b="K" && c=116) ; F5
   {
      FolderTreeRepopulate()
   } Else If (b="K" && c=112) ; F1
   {
      btnHelpFolderTree()
   } Else If (b="K" && c=113) ; F2
   {
      folderTreeRenameFolder()
   } Else If (b="K" && c=114) ; F3
   {
      folderTreeAppendFiles()
   } Else If (b="K" && c=186) ; F3
   {
      fromFolderTreeToOmniBox()
   } Else If (b="K" && c=118) ; F7
   {
      folderTreeCreateFolder()
   } Else If (b="K" && (c=119 || c=46)) ; F8 / Delete
   {
      folderTreeDeleteFolder()
   } Else If (b="K" && c=120) ; F9
   {
      FolderTreeFindActiveFile()
      folderTreeInfoStatusLineUpdater()
      prevent := 1
   } Else If (b="K" && c=123) ; F12
   {
      folderTreePropertiesFolder()
   } Else If (b="DoubleClick")
   {
      TV_Modify(c)
      folderTreeDefaultAction()
   } Else If (b="RightClick") || (b="K" && c=93) ; Apps/Menu key
   {
      If (b!="K")
         TV_Modify(c)

      folderTreeContextMenu()
   } Else If (b="K" && c=32) ; Space
   {
      If (b="K")
         c := TV_GetSelection()
      TV_Modify(c)
      folderTreeScanSubbies("no")
      folderTreeInfoStatusLineUpdater("forced")
      prevent := 1
   } Else If (b="d") ; drag'n drop
   {
      thisFolder := dc := nc := r := info := ""
      TV_Modify(c)
      prevMSGdisplay := 1
      While, determineLClickstate()
      {
         Gui, fdTreeGuia: Default
         Gui, fdTreeGuia: TreeView, TVlistFolders
         info := defineWindowUnderMouse()

         If InStr(info, "tooltip")
         {
            interfaceThread.ahkFunction("showOSDinfoLineNow", 500)
            Continue
         } Else If InStr(info, "tree")
         {
            friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
            GetMouseCoord2wind(hTVlistFolders, nX, nY)
            nc := TVH_HitTest(hTVlistFolders, cr, nX, nY)
            If (nc=c)
               thisFolder := nc := ""

            If nc
            {
               TV_GetText(thisFolder, nc)
               TV_Modify(nc)
            }

            r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
            If thisFolder
               friendly .= "`nDestination: ." thisFolder "\ " r

         } Else If InStr(info, "main")
         {
            r := nc := ""
            TV_Modify(c)
            r := GetKeyState("Shift", "P") ? "`nFolder is to be RECURSIVELY scanned." : "`nHold SHIFT for recursive scanning."
            friendly := "`nDrop folder here to import it into the current list." r
            ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
         } Else If InStr(info, "omnibox window")
         {
            r := dc := nc := ""
            friendly := "`nDrop folder here to begin navigate it using the omnibox."
         } Else If InStr(info, "omnibox list")
         {
            TV_Modify(c)
            r := dc := nc := ""
            GetMouseCoord2wind(hLVquickSearchMenus, nX, nY)
            dc := LV_EX_ItemHitTest(hLVquickSearchMenus, kp, nX, nY)
            Gui, QuickMenuSearchGUIA: Default
            Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
            If dc
               LV_Modify(dc, "select focus vis")

            thisFolder := OmniBoxGetSelectedFolder()
            If !thisFolder
               dc := thisFolder := ""

            restu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
            friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
            friendly .= "`nDestination: ." restu "\"
            r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
            friendly .= A_Space r
            If !thisFolder
               friendly := "`nDrop folder here to begin navigate it using the omnibox."

            ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
         } Else 
         {
            r := nc := ""
            TV_Modify(c)
            friendly := "No action associated to this pointer location."
         }

         If (A_TickCount - prevMSGdisplay>100)
         {
            externToolTiput(info friendly)
            prevMSGdisplay := A_TickCount
         }
      }

      If InStr(info, "main")
      {
         z := InStr(r, "scanned") ? "recursive" : "not"
         externTooltiput("Importing folder - please wait")
         folderTreeAppendFiles(z)
      } Else If (InStr(info, "omnibox") && dc && thisFolder)
      {
         externTooltiput("-hide-")
         src := folderTreeGetSelectedPath(c)
         dest := OmniBoxGetSelectedFolder()

         If (doNotAskAgain=0 && src!=dest && InStr(src, ":\") && InStr(dest, ":\") && r)
         {
            msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action from the folders tree panel into the omnibox: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: ." src "\`nDestination: ." dest "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
            If !InStr(msgResult.btn, "Yes")
            {
               SetTimer, PopulateQuickMenuSearch, -200
               Return 1
            } Else doNotaskAgain := msgResult.check
         }

         If (InStr(r, "_") && src!=dest && InStr(src, ":\") && InStr(dest, ":\"))
         {
            externTooltiput("Please wait - performing folder action")
            r := UIcoreFolderPasteFoldersInto(0, "given", r, src, dest)
         }
         externToolTiput("-hide-")
      } Else If InStr(info, "omnibox")
      {
         fromFolderTreeToOmniBox()
      } Else If (InStr(info, "tree") && r && nc)
      {
         externTooltiput("-hide-")
         src := folderTreeGetSelectedPath(c)
         dest := folderTreeGetSelectedPath(nc)
         If (TV_GetParent(nc) = TV_GetParent(c))
         {
            TV_GetText(sr, nc)
            TV_GetText(dst, c)
         } Else
         {
            sr := src
            dst := dest
         }

         If (doNotAskAgain=0 && src!=dest && InStr(src, ":\") && InStr(dest, ":\") && r)
         {
            msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action inside the folders tree: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: ." sr "\`nDestination: ." dst "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
            If !InStr(msgResult.btn, "Yes")
            {
               SetTimer, folderTreeInfoStatusLineUpdater, -125
               Return 1
            } Else doNotaskAgain := msgResult.check
         }

         If (InStr(r, "_") && src!=dest && InStr(src, ":\") && InStr(dest, ":\"))
         {
            externTooltiput("Please wait - performing folder action")
            r := UIcoreFolderPasteFoldersInto(0, "given", r, src, dest)
            If (r=2)
               folderTreeScanSubbies()
         }
      }
      externToolTiput("-hide-")
      prevent := 1
   }

   If !prevent
      SetTimer, folderTreeInfoStatusLineUpdater, -125
   ; ToolTip, % a "==" b "==" c "`n" folderPath , , , 2
}

defineWindowUnderMouse() {
   MouseGetPos, OutputVarX, OutputVarY, OutputVarWin, hwnd, 2
   WinGetClass, OutputType, ahk_id %hwnd%
   If (OutputVarWin=hfdTreeWinGui && InStr(OutputType, "systree") && folderTreeWinOpen=1)
      info := "Folders tree list"
   Else If (OutputVarWin=PVhwnd)
      info := "Main window"
   Else If (OutputVarWin=hQuickMenuSearchWin && hwnd=hLVquickSearchMenus && VisibleQuickMenuSearchWin=1)
      info := "Omnibox list"
   Else If (OutputVarWin=hQuickMenuSearchWin && VisibleQuickMenuSearchWin=1)
      info := "Omnibox window"
   Else If (OutputVarWin=hGuiTip)
      info := "Tooltip"
   Return info
}

btnHelpFolderTree() {
   msgBoxWrapper(appTitle ": HELP", "The folder tree panel facilitates management of files and folders. Common file and folders actions are available: create, cut, copy, paste, delete, rename. Drag and drop is supported between folders, and between this panel and the main window or the omnibox / quick menu search panel.", -1, 0, 0)
}

getFolderInfos(givenDir, ByRef filez:=0, ByRef folderz:=0, ByRef fileSizu:=0, doRecursive:="DF") {
     doStartLongOpDance()
     abandonAll := folderz := filez := fileSizu := 0
     Loop, Files, %givenDir%\*, %doRecursive%
     {
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         fullPath := Trimmer(A_LoopFileFullPath)
         If InStr(A_LoopFileAttrib, "D")
         {
            folderz++
         } Else If (RegExMatch(fullPath, RegExFilesPattern) && A_LoopFileSize>120)
         {
            fileSizu := fileSizu + A_LoopFileSize
            filez++
         }
     }
     Return abandonAll
}

folderTreeInfoStatusLineUpdater(modus:=0) {
    If (folderTreeWinOpen!=1)
       Return

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    c := TV_GetSelection()

    If c
       thisFolder := folderTreeGetSelectedPath(c)
    ; ToolTip, % thisFolder , , , 2
    If (showFolderTreeDetails=1 || modus="forced")
    {
       thisVfolder := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1))
       GuiControl, fdTreeGuia:, fdTreeInfoLine, %thisVfolder% | Gathering folder details...
       getFolderInfos(thisFolder, itemz, dirs, sizu)
       ResetImgLoadStatus()
    }

    If (dirs || sizu)
    {
       fbytes := fileSizeFrienly(sizu) " | " groupDigits(itemz) " images | " groupDigits(dirs) " folders"
       GuiControl, fdTreeGuia:, fdTreeInfoLine, % thisVFolder " | " fbytes
       SetTimer, fdTreeGuiaGuiSize, -50
       Return
    }

    thisfolder := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1))
    If (!thisFolder && c)
       TV_GetText(OutputVar, c)
    Else If !thisFolder
       thisFolder := driveInfo "Folder tree: " TV_GetCount() " elements"

    If InStr(OutputVar, ":\")
    {
       Try DriveGet, info, Label, %OutputVar%
       Try DriveGet, size, Capacity, %OutputVar%
       Try DriveSpaceFree, FreeSpace, %OutputVar%
       perc := Round((FreeSpace/size)*100, 1) "%"
       driveInfo .= info " - " perc " free | "
       thisFolder := driveInfo "Folder tree: " TV_GetCount() " elements"
    }
    GuiControl, fdTreeGuia:, fdTreeInfoLine, % fbytes thisFolder
    SetTimer, fdTreeGuiaGuiSize, -50
}

folderTreeGetSelectedPath(c) {
   If StrLen(c)<2
      Return

   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   TV_GetText(folderPath, c)
   r := c
   Loop
   {
      r := TV_GetParent(r)
      If !r
         Break
      TV_GetText(thisu, r)
      folderPath := thisu folderPath
   }

   folderPath := StrReplace(folderPath, "\\", "\")
   If StrLen(folderPath)<5
      folderPath := ""

   Return folderPath
}

FolderTreeFindActiveFile(givenPath:=0) {
    modus := (StrLen(UserMemBMP)>2 || (maxFilesIndex>0 && CurrentSLD)) ? modus : "welcome"
    If (modus="welcome" && (!givenPath || InStr(givenPath, "`tF9")))
       Return

    If (userPrivateMode=1)
    {
       showTOOLtip("WARNING: Private mode is activated. Access to this feature is denied,`nbecause it would be a breach of privacy.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    showTOOLtip("Scanning folders, please wait")
    z := 0 ; TV_GetNext()
    oimgPath := StrReplace(getIDimage(currentFileIndex), "||")
    imgPath := SubStr(oimgPath, 1, InStr(oimgPath, "\", 0, -1) - 1)
    If FolderExist(givenPath)
    {
       imgPath := givenPath
       wasGiven := 1
    }

    sliced := StrSplit(imgPath, "\")
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...

    g := iterateFDtreeView(1, 0, sliced)
    lvl := g[1]
    z := g[2] ? g[2] : 0
    hasAdded := 0
    ; ToolTip, % lvl "=" gu , , , 2
    Loop, % sliced.Count()
    {
          thisIndex := A_Index - 1 + lvl
          If !sliced[thisIndex]
             Continue

          hasAdded := 1
          If (thisIndex=1)
             z := TV_Add(sliced[thisIndex] "\", z, "Expand Select VisFirst")
          Else
             z := TV_Add("\" sliced[thisIndex], z, "Expand Select VisFirst")
    }

    If (hasAdded!=1 && z)
       TV_Modify(z, "Expand Select VisFirst")

    initialSibling := SubStr(imgPath, InStr(imgPath, "\", 0, -1) + 1)
    If z
       w := TV_GetParent(z)
    ; ToolTip, % initialSibling , , , 2
    mustSkip := new hashtable()
    mustDelete := new hashtable()
    If (w && !wasGiven)
    {
       r := w
       r := TV_GetChild(w)
       Loop
       {
          If (A_Index>1)
             r := TV_GetNext(r)

          If r
             x := TV_GetChild(r)
          Else
             x := ""

          If !r
             Break

          If x
          {
             labelu := ""
             TV_GetText(labelu, r)
             If (Trimmer(labelu, "\")!=initialSibling)
             {
                h := Trimmer(labelu, "\")
                mustSkip[h] := 1
                Continue
             }
          }
 
          mustDelete[r] := 1
       }
    }

    If !wasGiven
    {
       For Key, Value in mustDelete
          TV_Delete(Key)
    }
    setImageLoading()
    doStartLongOpDance()
    mustDelete := ""
    subPath := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
    If (FolderExist(subPath) && w && !wasGiven)
    {
       Loop, Files, % subPath "\*", DF
       {
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }

          If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
          {
             If mustSkip.hasKey(A_LoopFileName)
                Continue

             P%A_Index% := TV_Add("\" A_LoopFileName, w)
             If (A_LoopFileName=initialSibling)
                subsParent := P%A_Index%
          }
       }
    }

    mustSkip := ""
    ResetImgLoadStatus()
    If (subsParent && !wasGiven)
    {
       TV_Modify(subsParent, "Select VisFirst")
       folderTreeScanSubbies()
    }

    TV_Modify(w, "Sort")
    If !wasGiven
    {
       GuiControl, fdTreeGuia: +Redraw, TVlistFolders
       SetTimer, folderTreeInfoStatusLineUpdater, -100
       SetTimer, RemoveTooltip, -100
    }
}

iterateFDtreeView(lvl, z, sliced) {
    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders

    Loop
    {
       labelu := ""
       If z
          TV_GetText(labelu, z)

       If (Trimmer(labelu, "\")=sliced[lvl] && labelu)
       {
          lvl++
          gu := z
          r := TV_GetChild(z)
          If (r!=0)
          {
             g := iterateFDtreeView(lvl, r, sliced)
             lvl := g[1]
             If g[2]
                gu := g[2]
          }
       }

       r := TV_GetNext(z)
       If (r=0)
          Break

       z := r
    }
    Return [lvl, gu]
}

FolderTreeRepopulate(dummy:=0, listuGiven:=0) {
    If (dummy="given" && listuGiven)
    {
       PanelFoldersTree()
       Try SetTimer, FolderTreeRepopulate, Off
    }

    If (userPrivateMode=1)
       Return

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...

    If (!HKifs("imgsLoaded") || (dummy="given" && listuGiven))
    {
       If (dummy="given" && listuGiven)
       {
          aListu := listuGiven
          TV_Delete()
       } Else
       {
          aListu := readRecentEntries(0, 0)
          aListu .= readRecentFileDesties()
          If FolderExist(prevFileSavePath)
             aListu .= "`n" prevFileSavePath "`n"
          If FolderExist(prevFileMovePath)
             aListu .= "`n" prevFileMovePath "`n"
          If FolderExist(prevOpenFolderPath)
             aListu .= "`n" prevOpenFolderPath "`n"

          Sort, aListu, UD`n
       }

       Loop, Parse, aListu, `n
       {
          countItemz++
          testThis := StrReplace(A_LoopField, "|")
          If (StrLen(A_LoopField)<4 || !FileExist(testThis))
             Continue
 
          If RegExMatch(testThis, sldsPattern)
             testThis := SubStr(testThis, 1, InStr(testThis, "\", 0, -1) - 1)
 
          bListu .= testThis "`n"
       }
 
       Loop, Parse, bListu, `n
       {
          If A_LoopField
             FolderTreeFindActiveFile(A_LoopField)
       }
       TV_Modify(0, "Select VisFirst")
       folderTreeExpandCollapseAll("collapse")
       GuiControl, fdTreeGuia: +Redraw, TVlistFolders
       SetTimer, folderTreeInfoStatusLineUpdater, -100
       SetTimer, RemoveTooltip, -100
       Return
    }

    z := TV_GetNext()
    If z
       TV_Delete(z)

    showTOOLtip("Scanning folders, please wait")
    parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
    parentsLevels := parentsObj.Count()
    ; ToolTip, % parentsLevels " == " currentParent , , , 2
    Loop, % parentsLevels
    {
       If (A_Index>currentParent)
          Continue
   
       If (A_Index=1 && !InStr(parentsObj[1], ":"))
          Break

       pu := A_Index - 1
       If (A_Index=1)
          P1 := TV_Add(parentsObj[A_Index] "\",, "Expand")
       Else If (A_Index!=currentParent)
          P%A_Index% := TV_Add("\" parentsObj[A_Index], P%pu%, "Expand")

       If (A_Index=currentParent)
          siblingsParent := P%pu%
    }

    sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
    Loop, % sibsObj.Count()
    {
       If !siblingsParent
          Continue

       pu := A_Index - 1
       If (A_Index=currentSib)
          subsParent := TV_Add("\" sibsObj[A_Index], siblingsParent, "Expand Bold")
       Else
          P%A_Index% := TV_Add("\" sibsObj[A_Index], siblingsParent)
    }

    If siblingsParent
       TV_Modify(siblingsParent, "Expand Sort")

    doStartLongOpDance()
    hasAddedSubs := 0
    thisFolder := StrReplace(Trimmer(CurrentSLD), "|")
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", DF
       {
          If determineTerminateOperation()
             Break

          If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
          {
             P%A_Index% := TV_Add("\" A_LoopFileName, subsParent)
             hasAddedSubs := 1
          }
       }
    }

    ResetImgLoadStatus()
    If subsParent
       TV_Modify(subsParent, "Expand Sort")

    countu := TV_GetCount()
    If !countu
       FolderTreeFindActiveFile()

    GuiControl, fdTreeGuia: +Redraw, TVlistFolders
    SetTimer, folderTreeInfoStatusLineUpdater, -100
    SetTimer, RemoveTooltip, -100
}

folderTreeContextMenu() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   If c
      TV_GetText(labelu, c)

   Try Menu, PVfdTree, Delete
   kMenu("PVfdTree", "Add", "Re&generate tree view`tF5", "FolderTreeRepopulate")
   kMenu("PVfdTree", "Add", "&Highlight the focused file location`tF9", "FolderTreeFindActiveFile")
   If c
      kMenu("PVfdTree", "Add", "&Scan for sub-folders`tSpace", "folderTreeScanSubbies")

   If (c && !InStr(labelu, ":"))
   {
      folderPath := folderTreeGetSelectedPath(c)
      If FolderExist(folderPath)
      {
         Try Menu, PVopenF, Delete
         kMenu("PVopenF", "Add", "Open folder now`tEnter", "folderTreeDefaultAction")
         kMenu("PVopenF", "Add", "In Explorer`tShift+Enter", "folderTreeOpenInExplorer")
         kMenu("PVopenF", "Add", "With a new QPV instance`tCtrl+Enter", "folderTreeOpenInNewInstance")
         Menu, PVfdTree, Add
         kMenu("PVfdTree", "Add", "Open", ":PVopenF")
         kMenu("PVfdTree", "Add", "&Import images into the list`tF3", "folderTreeAppendFiles")
         Menu, PVfdTree, Add
         kMenu("PVfdTree", "Add", "&Create new folder`tF7", "folderTreeCreateFolder")
         kMenu("PVfdTree", "Add", "C&ut folder (Explorer mode)`tCtrl+X", "folderTreeCutCopyFolder")
         kMenu("PVfdTree", "Add", "C&opy folder (Explorer mode)`tCtrl+C", "folderTreeCutCopyFolder")
         kMenu("PVfdTree", "Add", "&Paste folder(s) into...", "folderTreePasteFoldersInto")
         kMenu("PVfdTree", "Add", "&Rename folder`tF2", "folderTreeRenameFolder")
         kMenu("PVfdTree", "Add", "&Delete folder`tDelete", "folderTreeDeleteFolder")
         kMenu("PVfdTree", "Add/UnCheck", "Se&t as the protected folder", "folderTreeSetFolderProtected")
         If (protectedFolderPath=folderPath && preventDeleteFromProtectedPath=1)
            kMenu("PVfdTree", "Check", "Se&t as the protected folder")

         kMenu("PVfdTree", "Add", "Folder properties (E&xplorer)`tF12", "folderTreePropertiesFolder")
         Menu, PVfdTree, Add
         kMenu("PVfdTree", "Add", "Paste clip&board file(s) into...", "folderTreePasteClippy")
         If (maxFilesIndex>0 && CurrentSLD)
         {
            kMenu("PVfdTree", "Add", "Cop&y selected file(s) into...`t7", "FolderTreeMenuCopyFiles")
            kMenu("PVfdTree", "Add", "&Move selected file(s) into...`tShift+7", "FolderTreeMenuMoveFiles")
         }
      } Else
      {
         Menu, PVfdTree, Add
         kMenu("PVfdTree", "Add", "Selected folder is inexistent", "dummy")
         kMenu("PVfdTree", "Disable", "Selected folder is inexistent")
         Menu, PVfdTree, Delete, &Scan for sub-folders`tSpace
         Menu, PVfdTree, Add
         addBonus := 1
      }
   } Else addBonus := 1

   If (addBonus=1)
   {
      kMenu("PVfdTree", "Add/UnCheck", "Large UI fonts", "folderTreeToggleLargeUIfonts")
      kMenu("PVfdTree", "Add/UnCheck", "Dar&k mode", "folderTreeToggleDarkie")
      kMenu("PVfdTree", "Add", "Close panel`tEscape", "fdTreeClose")
      If (uiUseDarkMode=1)
         kMenu("PVfdTree", "Check", "Dar&k mode")
      If (PrefsLargeFonts=1)
         kMenu("PVfdTree", "Check", "Large UI fonts")
   }
   showThisMenu("PVfdTree")
}

folderTreeToggleLargeUIfonts() {
    ToggleLargeUIfonts()
    PanelFoldersTree()
}

folderTreeToggleDarkie() {
    ToggleDarkModus()
    PanelFoldersTree()
}

FolderTreeMenuCopyFiles() {
   triggerQuickFileAction("vk37", 1)
}

FolderTreeMenuMoveFiles() {
   triggerQuickFileAction("+vk37", 1)
}

UIcoreFolderNew(thisFolder, ByRef newFileName) {
   msgResult := msgBoxWrapper("Create new folder: " appTitle, "Create new folder in:`n" thisFolder "\`n`nPlease type the new folder name.", "&Create folder|C&ancel", 1, "modify-file", 0, 0, 0, "limit9050", "")
   If InStr(msgResult.btn, "Create")
   {
      newFileName := Trimmer(msgResult.edit)
      If FolderExist(thisFolder "\" newFileName)
      {
         showTOOLtip("WARNING: A folder with the given name already exists:`n" thisFolder "\`n" newFileName "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      newFileName := filterFileName(newFileName)
      If !newFileName
      {
         showTOOLtip("WARNING: Incorrect folder name given.")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      FileCreateDir, %thisFolder%\%newFileName%
      If !ErrorLevel
      {
         Return 1
      } Else
      {
         showTOOLtip("ERROR: An unknown error occured creating the new folder in:`n" thisFolder "\")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

folderTreeCreateFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If !FolderExist(thisFolder)
   {
      If StrLen(thisFolder)>4
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected folder seems to no longer exist:`n`n" thisFolder "\`n`nWould you like to recreate it? By choosing yes, you will be able to create a new folder inside it.", 4, 0, "question")

      If (msgResult="Yes")
      {
         FileCreateDir, %thisFolder%
         If ErrorLevel
         {
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n`n" thisFolder "\`n`nPossibly access denied.", 0, 0, "error")
            Return
         }
      } Else Return
   }

   r := UIcoreFolderNew(thisFolder, newFileName)
   If r
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      TV_Add("\" newFileName, c)
      TV_Add(c, "Expand Sort")
      GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   }
}

UIcoreFolderDelete(thisFolder) {
   If FolderExist(thisFolder)
   {
      baseu := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1))
      itemu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1))

      msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected: " itemu "`n`nFound in:`n" baseu "`n`nPlease confirm you want to entirely DELETE this folder.", "&Delete|&Cancel", 2, "question")
      If (msgResult="delete")
      {
         destroyGDIfileCache()
         showTOOLtip("Deleting folder, please wait`n" thisFolder "\*")
         changeMcursor()
         ; FileRemoveDir, % thisFolder, 1
         r := ShellFileOperation("FO_DELETE", thisFolder "\", nona, "FOF_ALLOWUNDO|FOF_NOCONFIRMMKDIR", PVhwnd)
         If (!r["error"] && !r["aborted"])
         {
            SoundBeep , 900, 100
            allGood := "deleted"
         } Else If (r["error"] || r["aborted"])
         {
            If r["error"]
            {
               showTOOLtip("Failed to delete selected folder:`n" thisFolder "\")
               allGood := "error"
            } Else
            {
               showTOOLtip("Operation aborted: delete folder`n" thisFolder "\")
               allGood := "abort"
            }
            SoundBeep , 300, 100
         }
      }
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist:`n" thisFolder "\")
      SoundBeep 300, 100
      allGood := "deleted"
   }
   Return allGood
}

folderTreeDeleteFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   r := UIcoreFolderDelete(thisFolder)
   If (r="deleted")
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      RemoveTooltip()
      TV_Delete(c)
      GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   }

   SetTimer, ResetImgLoadStatus, -100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

folderTreePasteFoldersInto(dummy:="", gactu:="", fSrc:="", fDest:="") {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   r := UIcoreFolderPasteFoldersInto(thisFolder)
   If (r=1 || r=2)
      WinActivate, ahk_id %hfdTreeWinGui%

   If (r=2)
      folderTreeScanSubbies()
}

UIcoreFolderPasteFoldersInto(thisFolder, dummy:="", gactu:="", fSrc:="", fDest:="") {
   If (dummy="given" && InStr(gactu, "_") && InStr(fSrc, ":\") && InStr(fDest, ":\"))
   {
      quickMode := 1
      msgResult := gactu
      thisFolder := fDest
      listu := fSrc "`n"
   }

   If !FolderExist(thisFolder)
   {
      friendly_name := (quickMode!=1) ? "paste the folder(s) inside it" : "perform the intended folder action"
      If StrLen(thisFolder)>4
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Destination folder: " thisFolder "\`n`nIt seems to no longer exist. Would you like to recreate it? By choosing yes, QPV will " friendly_name, 4, 0, "question")

      If (msgResult="Yes")
      {
         FileCreateDir, %thisFolder%
         If ErrorLevel
         {
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n`n" thisFolder "\`n`nPossibly access denied.", 0, 0, "error")
            Return
         }
      } Else Return
   }

   If (quickMode!=1)
   {
      showTOOLtip("Importing clipboard content...")
      Try listu := Clipboard
      SetTimer, RemoveTooltip, -200
   }

   If StrLen(listu)<5
   {
      showTOOLtip("WARNING: Found no folders in the clipboard")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
   
   If (quickMode!=1)  
   {
      isExplorerModeA := IsClipboardFormatAvailable(15)
      msgResult := msgBoxWrapper(appTitle ": Paste folders", "The folders from the clipboard will be pasted into the selected folder. Please choose what operation to perform. Destination folder:`n`n" thisFolder "\", "&Copy|&Move|C&ancel", 1, "question")
      SetTimer, RemoveTooltip, -200
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   If InStr(msgResult, "Copy")
   {
      friendly := "COPYING"
      filesActu := "FO_COPY"
   } Else If InStr(msgResult, "Move")
   {
      friendly := "MOVING"
      filesActu := "FO_MOVE"
   } Else
   {
      Return 1
   }

   destroyGDIfileCache()
   changeMcursor()
   line := ""
   zr := loopsCount := 0
   Loop, Parse, listu, `n,`r
   {
        line := Trimmer(Trimmer(A_LoopField), "\")
        If FolderExist(line)
        {
           loopsCount++
           r := ShellFileOperation(filesActu, line "\", thisFolder "\", "FOF_ALLOWUNDO|FOF_NOCONFIRMMKDIR", PVhwnd)
           If (r["aborted"] || r["error"])
           {
              zr := r["error"] ? 1 : 2
              Break
           }
        }
   }

   folderTreeScanSubbies()
   If zr
   {
      friendly2 := InStr(msgResult, "Copy") ? "COPY" : "MOVE"
      If (zr=1)
         showTOOLtip("Failed to " friendly2 " folder:`n" line "\")
      Else
         showTOOLtip("Operation aborted while " friendly " the folder:`n" line "\")
      SoundBeep , 300, 100
   } Else
   {
      isExplorerModeB := IsClipboardFormatAvailable(15)
      If (filesActu="FO_MOVE" && isExplorerModeA=1 && isExplorerModeB=1 && quickMode!=1)
         Try Clipboard := ""
      
      friendly2 := (quickMode!=1) ? "from the clipboard " : ""
      showTOOLtip("Finished " friendly " folder " friendly2 "into:`n" thisFolder "\")
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   ResetImgLoadStatus()
   Return 2
}

folderTreeCutCopyFolder(a) {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   UIcoreFolderCutCopyExplorer(a, thisFolder)
}

UIcoreFolderCutCopyExplorer(a, thisFolder) {
   userOption := InStr(StrReplace(a, "&"), "cut") ? "CUT" : "COPY"
   If FolderExist(thisFolder)
   {
      destroyGDIfileCache()
      dataHandle := ClipboardSetFiles([thisFolder], userOption, 1)
      Sleep, 5
      testClipType := IsClipboardFormatAvailable(15)
      infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to set the clipboard" : userOption " action: the folder can now be pasted in any file manager or in QPV`n" thisFolder "\"
      showTOOLtip(infoText)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist:`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

folderTreeRenameFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   r := UIcoreFolderRename(thisFolder, newFileName)
   If r
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      TV_Modify(c, "Select Vis Sort", "\" newFileName)
      GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   }
}

UIcoreFolderRename(thisFolder, ByRef newFileName) {
   If !FolderExist(thisFolder)
   {
      showTOOLtip("WARNING: The folder seems to no longer exist:`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   baseu := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1))
   restu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
   msgResult := msgBoxWrapper("Rename folder: " appTitle, "Please type the new folder name for \" restu "`n`nFolder found in:`n" baseu, "&Rename folder|C&ancel", 1, "modify-file", 0, 0, 0, "limit9050", restu)
   If InStr(msgResult.btn, "Rename")
   {
      newFileName := Trimmer(msgResult.edit)
      If !newFileName
         Return

      newFileName := filterFileName(newFileName)
      If !newFileName
      {
         showTOOLtip("WARNING: Incorrect folder name given")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If FolderExist(thisFolder "\" newFileName)
      {
         showTOOLtip("WARNING: A folder with the given name already exists:`n" thisFolder "\`n" newFileName "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      oldPath := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1) - 1)
      FileMoveDir, % thisFolder, % oldPath "\" newFileName, R
      If !ErrorLevel
      {
         Return 1
      } Else
      {
         showTOOLtip("ERROR: An unknown error occured renaming the folder:`n" thisFolder "\")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

invokeOmniBoxCurrentFile(modus:=0,pathu:=0) {
   fromFolderTreeToOmniBox("thisFile", resultedFilesList[currentFileIndex, 1])
}

fromFolderTreeToOmniBox(modus:=0,imgPath:=0) {
   If (modus="thisFile" && InStr(imgPath, ":\"))
   {
      linea := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
   } Else
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      linea := folderTreeGetSelectedPath(c)
   } 

   If (!linea || !FolderExist(linea))
      Return

   If (VisibleQuickMenuSearchWin!=1)
      PanelQuickSearchMenuOptions()

   newLabelu := userQuickMenusEdit := Trim(StrReplace(linea, "\\", "\"), "\")
   len := StrLen(newLabelu)
   ; ToolTip, % newLabelu "=" len "`n" userQuickMenusEdit , , , 2
   GuiControl, QuickMenuSearchGUIA:, userQuickMenusEdit, % newLabelu
   GuiControl, QuickMenuSearchGUIA: Focus, userQuickMenusEdit
   EM_SETSEL(hEditMenuSearch, len, len)
   SetTimer, PopulateQuickMenuSearch, -150
}

folderTreeAppendFiles(modus:="") {
   If (maxFilesIndex<1 || !CurrentSLD)
   {
      folderTreeDefaultAction()
      Return
   }

   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   linea := folderTreeGetSelectedPath(c)
   If (!linea || !FolderExist(linea) || InStr(DynamicFoldersList, linea "`n"))
      Return

   changeMcursor()
   If GetKeyState("Shift", "P")
      addNewFolder2list(linea, "yes", "recursive")
   Else
      addNewFolder2list(linea, "yes", modus)
   ; SoundBeep 900, 100
   ResetImgLoadStatus()
   currentFileIndex := maxFilesIndex - 1
   dummyTimerDelayiedImageDisplay(50)
}

folderTreeExpandCollapseAll(forceMode:=0) {
   Static prevState := 1
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetNext()
   If !c
      Return

   If (forceMode="collapse")
      prevState := 1
   Else If (forceMode="expand")
      prevState := 0

   act := (prevState=1) ? "-Expand" : "Expand"
   friendly := (prevState=1) ? "COLLAPSED" : "EXPANDED"
   c := TV_Modify(c, act)
   Loop
   {
       c := TV_GetNext(c, "F")
       TV_Modify(c, act)
       If !c
          Break
   }

   c := TV_GetNext()
   c := TV_Modify(c, "VisFirst Select")
   prevState := !prevState
   showTOOLtip("Folder tree: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

folderTreeScanSubbies(prevent:="") {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   ; c := prevTVelement

   If !c
      Return

   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
   {
      TV_GetText(thisFolder, c)
      thisFolder := Trimmer(thisFolder, "\")
   }

   If !thisFolder
      Return

    showTOOLtip("Scanning folders, please wait")
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...
    ; ToolTip, % A_DefaultTreeView "==" A_DefaultGUI "==" c , , , 2
    changeMcursor()
    mustSkip := new hashtable()
    mustDelete := new hashtable()
    r := c
    r := TV_GetChild(c)
    Loop
    {
       If (A_Index>1)
          r := TV_GetNext(r)

       If r
          x := TV_GetChild(r)
       Else
          x := ""

       If !r
          Break

       If x
       {
          labelu := ""
          TV_GetText(labelu, r)
          If (Trimmer(labelu, "\") && FolderExist(thisFolder labelu))
          {
             h := Trimmer(labelu, "\")
             mustSkip[h] := 1
             Continue
          }
       }

       mustDelete[r] := 1
    }

    For Key, Value in mustDelete
       TV_Delete(Key)

   mustDelete := ""
   hasAddedSubs := 0
   doStartLongOpDance()
   If FolderExist(thisFolder)
   || (StrLen(thisFolder)=2 && InStr(thisFolder, ":"))
   {
      Loop, Files, % thisFolder "\*", DF
      {
         If determineTerminateOperation()
            Break

         If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
         {
            If mustSkip.hasKey(A_LoopFileName)
               Continue

            P%A_Index% := TV_Add("\" A_LoopFileName, c)
            hasAddedSubs := 1
         }
      }
   }

   ResetImgLoadStatus()
   mustSkip := ""
   RemoveTooltip()
   TV_Modify(c, "Expand Vis Select Sort")
   GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   If (prevent!="no")
      SetTimer, folderTreeInfoStatusLineUpdater, -100
   SetTimer, ResetImgLoadStatus, -125
}

folderTreePasteClippy() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   If !c
      Return

   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   r := PasteFilesIntoGivenFolder(thisFolder)
   If r
      WinActivate, ahk_id %hfdTreeWinGui%
}

PasteFilesIntoGivenFolder(folderPath) {
   If !FolderExist(folderPath)
   {
      showTOOLtip("WARNING: The folder seems to no longer exist:`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }

   showTOOLtip("Importing clipboard content...")
   Try listu := Clipboard
   SetTimer, RemoveTooltip, -200
   If StrLen(listu)<5
   {
      showTOOLtip("WARNING: Found no files in the clipboard")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
   
   msgResult := msgBoxWrapper(appTitle ": Paste files", "The files from the clipboard will be pasted into the selected folder. Please choose what operation to perform. Destination folder:`n`n" folderPath "\", "&Copy|&Move|C&ancel", 1, "question")
   SetTimer, RemoveTooltip, -200
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   If InStr(msgResult, "Copy")
   {
      friendly := "Copying"
      filesActu := 1
   } Else If InStr(msgResult, "Move")
   {
      friendly := "Moving"
      filesActu := 2
   } Else
   {
      Sleep, 1
      Return 1
   }

   isExplorerModeA := IsClipboardFormatAvailable(15)
   foundFiles := ST_Count(listu, "`n")
   finalDest := folderPath
   filezMoved := countTFilez := 0
   doStartLongOpDance()
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   Loop, Parse, listu, `n,`r
   {
      If !A_LoopField
         Continue

      file2rem := A_LoopField
      zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
      countTFilez++
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If (OldOutDir=finalDest)
      {
         skippedFiles++
         Continue
      }

      FileGetTime, originalMtime, % file2rem, M
      FileGetTime, originalCtime, % file2rem, C
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, foundFiles, startOperation)
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"
         If (failedFiles>0)
            etaTime .= "`nFailed to perform action on " groupDigits(failedFiles) " files"

         showTOOLtip(friendly " files to`n" finalDest "\" etaTime, 0, 0, countTFilez/foundFiles)
         prevMSGdisplay := A_TickCount
      }

      file2save := finalDest "\" OldOutFileName
      thisFileExists := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
      {
         thisFileExists := 1
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, 0, performOverwrite)
      }
  
      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }
  
      If (thisFileExists=1)
      {
         If (performOverwrite=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 2
            FileRecycle, %file2save%
            Sleep, 2
            mustPerformOperation := 1
         } Else If (performOverwrite!=2)
         {
            skippedFiles++
            Continue
         } Else mustPerformOperation := 1
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (filesActu=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
         }

         filezMoved++
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped"
   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " failedFiles " files"

   If (filesActu=2)
   {
      isExplorerModeB := IsClipboardFormatAvailable(15)
      If (abandonAll!=1 && isExplorerModeA=1 && isExplorerModeB=1)
         Try Clipboard := ""

      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BtnCloseWindow() {
   Critical, on
   If isNowAlphaPainting()
   {
      CloseWindow()
      Return
   }

   CloseWindow("yes")
   If AnyWindowOpen
      BtnCloseWindow()
}

InfoBtnNextImg() {
  If ((maxFilesIndex<2 || !maxFilesIndex) && StrLen(mustOpenStartFolder)<3)
     Return

  NextPicture()
  Sleep, 1
  SetTimer, PopulateImgInfos, -150
}

InfoBtnPrevImg() {
  If ((maxFilesIndex<2 || !maxFilesIndex) && StrLen(mustOpenStartFolder)<3)
     Return

  PreviousPicture()
  Sleep, 1
  SetTimer, PopulateImgInfos, -150
}

copyIMGinfos2clip() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaD
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>2)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1) ? ": " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>95)
          Break
   }

   textu := Trimmer(textu) "`NOTHER DETAILS:`n"
   Gui, SettingsGUIA: ListView, LViewMetaOthers
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>2)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1) ? ": " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>99)
          Break
   }

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Unable to copy to clipboard file details")
         SoundBeep , 300, 100
      } Else showTOOLtip("File details copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateImgInfos() {
   If (AnyWindowOpen!=5)
      Return

   resultu := getIDimage(currentFileIndex)
   If !FileExist(resultu)
   {
      informUserFileMissing()
      Return
   }

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaOthers
   LV_Delete()
   zPlitPath(resultu, 0, fileNamu, folderu)
   Try PropList := FGP_List(resultu)            ; Gets all of a file's non-blank properties.
   Loop, Parse, % PropList.CSV,`n
   {
       If !A_LoopField
          Continue
       lineArru := StrSplit(A_LoopField, ",")
       If (lineArru[3]!=fileNamu && lineArru[3]!=folderu)
          LV_Add(A_Index, lineArru[2], lineArru[3])
   }

   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")

   Gui, SettingsGUIA: ListView, LViewMetaD
   LV_Delete()
   FileGetSize, FileSizu, % resultu, K
   FileGetTime, FileDateM, % resultu, M
   FileGetTime, FileDateC, % resultu, C
   FormatTime, FileDateM, % FileDateM, dddd, d MMMM yyyy, HH:mm:ss
   FormatTime, FileDateC, % FileDateC, dddd, d MMMM yyyy, HH:mm:ss

   zoomu := Round(zoomLevel*100)
   If (thisIMGisDownScaled=1)
      infoDownScale := " [DOWNSCALED] "

   Gdip_GetImageDimensions(useGdiBitmap(), Width, Height)
   If (currIMGdetails.TooLargeGDI=1)
      infoRes := "`nOriginal resolution (W x H)||" groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " (in pixels)"

   friendlyLabel := (userPrivateMode=1) ? "" : "File name||" fileNamu "`nLocation||" folderu "\`n"
   generalInfos := friendlyLabel "File size||" groupDigits(fileSizu) " kilobytes`nDate created||" FileDateC "`nDate modified||" FileDateM infoRes "`nResolution (W x H)||" groupDigits(Width) " x " groupDigits(Height) " (in pixels)`nCurrent zoom level||" zoomu " % (" DefineImgSizing() infoDownScale ")"
   Loop, Parse, generalInfos, `n
   {
       lineArru := StrSplit(A_LoopField, "||")
       LV_Add(A_Index, lineArru[1], lineArru[2])
   }

   LV_Add(A_Index, "Colors display mode", DefineFXmodes())
   Gdip_GetHistogram(useGdiBitmap(), 2, ArrChR, ArrChG, ArrChB)
   Loop, 256
   {
       sumTotalR += ArrChR[A_Index] * A_Index
       sumTotalG += ArrChG[A_Index] * A_Index
       sumTotalB += ArrChB[A_Index] * A_Index
   }

   diffRGBtotal := max(sumTotalR, sumTotalG, sumTotalB) - min(sumTotalR, sumTotalG, sumTotalB)
   diffRGBtotal := diffRGBtotal/max(sumTotalR, sumTotalG, sumTotalB)
   If (diffRGBtotal<0.0001 || diffRGBtotal="")
      LV_Add(A_Index, "Grayscale image", 1)
   Else
      LV_Add(A_Index, "Grayscale image", 0)

   LV_Add(A_Index, "Image file format", currIMGdetails.RawFormat)
   LV_Add(A_Index, "Image pixel format", currIMGdetails.PixelFormat)

   CountFrames := currIMGdetails.Frames
   If (CountFrames>1)
      LV_Add(A_Index, "Embedded frames", CountFrames)

   If (currIMGdetails.OpenedWith="GDI+")
   {
      thumbBMP := trGdip_CreateBitmapFromFile(getIDimage(currentFileIndex))
      If StrLen(thumbBMP)>2
         MoreProperties := Gdip_GetAllPropertyItems(thumbBMP)
      For ID, Val In MoreProperties
      {
         If ID Is Integer
         {
            PropName := Gdip_GetPropertyTagName(ID)
            PropType := Gdip_GetPropertyTagType(Val.Type)
            If (val.value && StrLen(PropName)>1 && PropName!="unknown" && PropType!="undefined" && PropType!="byte")
            {
               If (InStr(PropName, "nancetable") || InStr(PropName, "jpeg") || InStr(PropName, "thumbnail")
               || InStr(PropName, "printflag") || InStr(PropName, "strip") || InStr(PropName, "chromatic"))
                  Continue
 
               If (PropName="frame delay") || (PropName="bits per sample")
               {
                  valu := SubStr(Val.Value, 1, InStr(Val.Value, A_Space))
                  LV_Add(A_Index, PropName, valu)
               } Else LV_Add(A_Index, PropName, Val.Value)
            }
         }
      }
      trGdip_DisposeImage(thumbBMP, 1)
   }

   LV_Add(A_Index, "Image loaded with ", currIMGdetails.OpenedWith)
   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")
}

Trimmer(string, whatTrim:="") {
   If (whatTrim!="")
      string := Trim(string, whatTrim)
   Else
      string := Trim(string, "`r`n `t`f`v`b")
   Return string
}

FileRexists(filePath) {
   obju := GetFileAttributesEx(filePath)
   ; MsgBox, % fileAttribs "`n" fileSizu "`nA" filePath "A"
   If (obju.size<120 || !obju.size)
      Return 0
   Else
      Return 1
}

hFindIsFolder(ByRef fileInfos) {
   Static FILE_ATTRIBUTE_DIRECTORY := 0x10
   Return NumGet(&fileInfos,0,"UInt") & FILE_ATTRIBUTE_DIRECTORY
}

hFindGetName(ByRef fileInfos) {
   cFileName := StrGet(&fileInfos + 44, 260, "UTF-16")
   If (cFileName="." || cFileName="..")
      cFileName := ""
   Return cFileName
}

testGetFile(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 1512, 0)
    hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")
    cFileName := hFindGetName(Win32FindData)
    If (hFindIsFolder(Win32FindData) && cFileName)
    {
    ;  MsgBox, folderrr
       testGetFile(filePath "\" cFileName)
    } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
    {
       maxFilesIndex++
       resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
    }

   ; MsgBox, % filePath "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError


 ;   instance.nFileSizeHigh := NumGet(&Win32FindData, 28,  "UInt")
;    instance.nFileSizeLow := NumGet(&Win32FindData, 32,  "UInt")

    While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData))
    {
          cFileName := hFindGetName(Win32FindData)
          If hFindIsFolder(Win32FindData) && cFileName
          {
             testGetFile(filePath "\" cFileName)
          } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
          {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
          }
    ; MsgBox, % filePath "`n" r "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
    }

   ; maxFilesIndex := resultedFilesList.Length()
    ; SoundBeep 
    Return
}

testGetFile2(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 318+1024, 0)
    if (hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")) {
        cFileName := StrGet(&Win32FindData + 44, 260, "UTF-16")
        cAlternateFileName := StrGet(&Win32FindData + 564, 14, "UTF-16")
        
        MsgBox, %  hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
        While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData))
        {
            cFileNamea := StrGet(&Win32FindData + 44, 260, "UTF-16")
            cAlternateFileNamea := StrGet(&Win32FindData + 564, 14, "UTF-16")
            MsgBox, %  r "`n" cFileNameA "`n" cAlternateFileNameA "`n" ErrorLevel "`n" A_LastError
        }
    }
    Return
}

testFileExistence(imgPath) {
  ; https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-getfilesize
  ; H := DllCall("kernel32\GetFileAttributesW", "Str", imgPath)
  ; H := DllCall("shlwapi.dll\PathFileExistsW", "Str", imgPath)
  ; If (h>0)
  ;    Return 256
  VarSetCapacity(dummy, 1024, 0)
  H := DllCall("kernel32\FindFirstFileW", "Str", imgPath, "Ptr", &dummy, "Ptr")
  Return H
}

informUserFileMissing(clearScreen:=0) {
   Critical, on
   If (clearScreen=1)
      clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIwin)

   If (userPrivateMode=1)
   {
      showTOOLtip("ERROR: File not found or access denied")
      winTitle := "[*] " currentFileIndex "/" maxFilesIndex
   } Else
   {
      imgPath := getIDimage(currentFileIndex)
      zPlitPath(imgPath, 0, fileNamu, folderu)
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      winTitle := "[*] " currentFileIndex "/" maxFilesIndex " | " fileNamu " | " folderu
   }

   setWindowTitle(winTitle, 1)
   SoundBeep, 300, 100
   If (autoRemDeadEntry=1)
      remCurrentEntry(1)
   If (thumbsDisplaying=1 && maxFilesIndex>0)
      mainGdipWinThumbsGrid()

   SetTimer, RemoveTooltip, % -msgDisplayTime
}

JEE_StrRegExLiteral(vText) {
  Loop, Parse, vText
  {
    If InStr("\.+[{()^$", A_LoopField)
      vOutput .= "\" A_LoopField
    Else If InStr("?*", A_LoopField)
      vOutput .= "." A_LoopField
    Else
      vOutput .= A_LoopField
  }

  Return vOutput
}

FiltersComboAction() {
  If (A_GuiControlEvent="DoubleClick")
     BtnApplyFilesFilter()
}


readRecentFiltersEntries() {
   Loop, 20
   {
       IniRead, newEntry, % mainRecentsFile, RecentFilters, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (InStr(entriesList, newEntry "`n") || !newEntry)
          Continue

       addSel := (newEntry=testFilteru) ? "`n" : ""
       If StrLen(newEntry)>1
          entriesList .= newEntry "`n" addSel
   }

   Return entriesList
}

EraseFilterzHisto() {
  IniDelete, % mainRecentsFile, RecentFilters
  CloseWindow()
  Sleep, 50
  PanelEnableFilesFilter()
}

InitialFilterSettingsPanel(modus) {
    Static o_userFilterDoString, o_userFilterStringPos
         , o_userFilterStringIsNot, o_userFilterInvertThis
         , o_userFilterProperty, o_userFilterWhat
         , o_UsrEditFilter, o_FilteruMaxRange
         , o_FilteruMinRange, o_userFilterSizeProperty

    If (modus=1)
    {
       o_userFilterDoString := userFilterDoString
       o_userFilterStringPos := userFilterStringPos
       o_userFilterStringIsNot := userFilterStringIsNot
       o_userFilterInvertThis := userFilterInvertThis
       o_userFilterProperty := userFilterProperty
       o_userFilterWhat := userFilterWhat
       o_UsrEditFilter := UsrEditFilter
       o_FilteruMaxRange := FilteruMaxRange
       o_FilteruMinRange := FilteruMinRange
       o_userFilterSizeProperty := userFilterSizeProperty
    } Else
    {
       userFilterDoString := o_userFilterDoString
       userFilterStringPos := o_userFilterStringPos
       userFilterStringIsNot := o_userFilterStringIsNot
       userFilterInvertThis := o_userFilterInvertThis
       userFilterProperty := o_userFilterProperty
       userFilterWhat := o_userFilterWhat
       UsrEditFilter := o_UsrEditFilter
       FilteruMaxRange := o_FilteruMaxRange
       FilteruMinRange := o_FilteruMinRange
       userFilterSizeProperty := o_userFilterSizeProperty
    }
}

PanelEnableFilesFilter() {
    Global FilterTypeu := 0

    If (maxFilesIndex<3 && !filesFilter)
       Return

    If (testIsDupesList() && InStr(resultedFilesList[currentFileIndex, 23], "_"))
    {
       showTOOLtip("WARNING: The files list is already filtered.`nThe list displays duplicate image pairs filtered by Hamming distance.")
       ; SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, PanelChangeHamDistThreshold, -50
       Return
    }

    thisBtnHeight := createSettingsGUI(6, A_ThisFunc)
    btnWid := 80
    txtWid := 360
    EditWid := 390
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 200
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    If !filesFilter
    {
       userFilterProperty := 1 
       userFilterDoString := 0
    }

    InitialFilterSettingsPanel(1)
    listu := readRecentFiltersEntries()
    If (!InStr(listu, "`n`n") && StrLen(UsrEditFilter)>0 && userFilterDoString=1 && StrLen(filesFilter)>1)
       listu := UsrEditFilter "`n`n" listu

    Gui, +Delimiter`n
    Gui, Add, Tab3,, Text`nFile and image
    Gui, Tab, 1
    Gui, Add, Checkbox, x+15 y+15 Section w%txtWid% gupdateUIFiltersPanel Checked%userFilterDoString% vuserFilterDoString, Filter files list with given string
    Gui, Add, ComboBox, y+7 w%EditWid% gUIgenericComboAction vUsrEditFilter, % listu
    Gui, Add, DropDownList, y+7 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterStringPos% vuserFilterStringPos, Anywhere`nBegins with`nEnds with`nRegEx
    Gui, Add, DropDownList, x+2 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterWhat% vuserFilterWhat, Full path`nFolder path`nFile name`nParent folder
    Gui, Add, Checkbox, xs y+7 gupdateUIFiltersPanel Checked%userFilterStringIsNot% vuserFilterStringIsNot, &Must not contain the given string
    Gui, Add, Button, xs y+7 vbtnFldr h%thisBtnHeight% w%btnWid% gEraseFilterzHisto, Erase &history
    Gui, Add, Text, xs y+15 vbtnFldr2 w%txtWid%, TIP: You can use | for OR and the *, ? wildcards in the filter to match more files.
    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 Section w%txtWid%, Please choose the type of criteria and set minimum and maximum range.
    Gui, Add, DropDownList, xs y+7 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterProperty% vuserFilterProperty, None`nFile size`nModified date`nCreated date`nMegapixels`nWidth`nHeight`nAspect ratio`nFrames`nDPI`nAverage`nMedian`nPeak range`nMinimum range`nTotal range`nMode`nMinimum`nRoot-mean suqare`nSelected files`nAlready seen
    Gui, Add, Text, x+5 wp vFilterTypeu, 
    Gui, Add, Edit, xs y+7 wp number limit5 +hwndhEditA gupdateUIFiltersPanel vFilteruMinRange, % FilteruMinRange
    Gui, Add, Edit, x+5 wp number limit5 +hwndhEditB gupdateUIFiltersPanel vFilteruMaxRange, % FilteruMaxRange
    Gui, Add, DropDownList, x+5 wp gupdateUIFiltersPanel AltSubmit Choose%userFilterSizeProperty% vuserFilterSizeProperty, Kilobytes`nMegabytes
    Gui, Add, DateTime, xs y+7 wp gupdateUIFiltersPanel vFilteruDateMinRange, yyyy/MM/dd
    Gui, Add, DateTime, x+5 wp gupdateUIFiltersPanel vFilteruDateMaxRange, yyyy/MM/dd
    Gui, Add, Checkbox, xs y+7 gupdateUIFiltersPanel Checked%userFilterInvertThis% vuserFilterInvertThis, &Invert filter
    Gui, Tab
    Gui, Add, Edit, xs y+10 w%EditWid% r2 +0x0800 vInternalFilterString, % filesFilter
    ; Gui, Add, Text, y+7 w%txtWid%, Tip: you can begin the string with \> to use RegEx.

    btnWid := (PrefsLargeFonts=1) ? btnWid - 15 : btnWid - 5
    Gui, Add, Button, xs+0 y+10 h%thisBtnHeight% w%btnWid% Default gBtnApplyFilesFilter, &Apply filter
    If StrLen(filesFilter)>1
       Gui, Add, Button, x+5 hp wp+20 gBTNuiremFilesListFilter, &Remove filters
    btnWid := (PrefsLargeFonts=1) ? 85 : 65
    Gui, Add, Button, x+5 hp w%btnWid% gPanelWrapperFilesStats, S&tats
    Gui, Add, Button, x+5 hp wp gPanelSearchIndex, &Search
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Files list filtering: " appTitle)
    EM_SETCUEBANNER(hEditA, "Minimum")
    EM_SETCUEBANNER(hEditB, "Maximum")
    ; EM_SETCUEBANNER(hEditC, "String to match")
    SetTimer, updateUIFiltersPanel, -300
}

BTNuiremFilesListFilter() {
   InitialFilterSettingsPanel(1)
   BtnCloseWindow()
   remFilesListFilter()
   SetTimer, RandomPicture, -90
}

SQLescapeStr(str, likeu:=0) {
   str := StrReplace(str, "'", "''")
   If (likeu=1)
   {
      str := StrReplace(str, "_", ">_")
      str := StrReplace(str, "%", ">%")
      str := StrReplace(str, "[", ">[")
   }
   Return str
}

updateUIFiltersPanel(dummy:=0) {
   Static columnsList := {2:"fsize", 3:"fmodified", 4:"fcreated", 5:"imgmegapix", 6:"imgwidth", 7:"imgheight", 8:"imgwhratio", 9:"imgframes", 10:"imgdpi", 11:"imgavg", 12:"imgmedian", 13:"imghpeak", 14:"imghlow", 15:"imghrange", 16:"imghmode", 17:"imghminu", 18:"imghrms"}

   If (dummy!="external")
   {
      If (AnyWindowOpen!=6)
         Return

      Gui, SettingsGUIA: Default
      GuiControlGet, UsrEditFilter
      GuiControlGet, userFilterDoString
      GuiControlGet, userFilterStringIsNot
      GuiControlGet, userFilterStringPos
      GuiControlGet, userFilterWhat
      GuiControlGet, userFilterProperty
      GuiControlGet, userFilterSizeProperty
      GuiControlGet, userFilterInvertThis
      GuiControlGet, FilteruMinRange
      GuiControlGet, FilteruMaxRange
      GuiControlGet, FilteruDateMaxRange
      GuiControlGet, FilteruDateMinRange

      If (userFilterStringPos!=4)
      {
         Loop, Parse, % "<>/"
            UsrEditFilter := StrReplace(UsrEditFilter, A_LoopField)

         If (userFilterWhat=3)
         {
            Loop, Parse, % ":\"
               UsrEditFilter := StrReplace(UsrEditFilter, A_LoopField)
         }
         UsrEditFilter := StrReplace(UsrEditFilter, "||")
      }

      actu := (userFilterDoString=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, userFilterWhat
      GuiControl, % actu, userFilterStringPos
      GuiControl, % actu, userFilterStringIsNot
      GuiControl, % actu, UsrEditFilter
      GuiControl, % actu, btnFldr
      GuiControl, % actu, btnFldr2

      actu := (userFilterProperty=1 || userFilterProperty=19) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, userFilterInvertThis

      actu := (userFilterProperty=2) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, userFilterSizeProperty

      actu := (userFilterProperty=3 || userFilterProperty=4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, FilteruDateMaxRange
      GuiControl, % actu, FilteruDateMinRange

      actu := (userFilterProperty=2 || isInRange(userFilterProperty, 5, 18)) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, FilteruMinRange
      GuiControl, % actu, FilteruMaxRange

      If isInRange(userFilterProperty, 2, 4)
      {
         GuiControl, SettingsGUIA:, FilterTypeu, File property
      } Else If isInRange(userFilterProperty, 5, 10)
      {
         GuiControl, SettingsGUIA:, FilterTypeu, Image property
      } Else If isInRange(userFilterProperty, 11, 18)
      {
         ; FilteruMaxRange := Round(FilteruMaxRange*1.05)
         ; FilteruMinRange := Round(FilteruMinRange*1.05)
         GuiControl, SettingsGUIA:, FilterTypeu, Histogram details
      } Else
      {
         GuiControl, SettingsGUIA:, FilterTypeu, -
      }
   }

   ; testRegEx := SubStr(UsrEditFilter, 1, 2)
   thisStringFilter := ""
   If (userFilterDoString=1 && SLDtypeLoaded=3)
   {
      thisStringFilter := SQLescapeStr(UsrEditFilter, 1)
      If (userFilterStringPos=4 && thisStringFilter)
         thisStringFilter := thisStringFilter
      Else If (userFilterStringPos=3 && thisStringFilter) 
         thisStringFilter := "%" thisStringFilter
      Else If (userFilterStringPos=2 && thisStringFilter)
         thisStringFilter := thisStringFilter "%"
      Else If (UsrEditFilter!="")
         thisStringFilter := "%" thisStringFilter "%"

      thisStringFilter := StrReplace(thisStringFilter, "?", "_")
      thisStringFilter := StrReplace(thisStringFilter, "*", "_")
      thisStringFilter := StrReplace(thisStringFilter, "|")
   } Else If (userFilterDoString=1)
   {
      If (userFilterStringPos=4 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)" UsrEditFilter
      Else If (userFilterStringPos=3 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")$"
      Else If (userFilterStringPos=2 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)^(" JEE_StrRegExLiteral(UsrEditFilter) ")"
      Else If (UsrEditFilter!="")
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")"
   }

   columnu := columnsList[userFilterProperty]
   minRange := min(FilteruMinRange, FilteruMaxRange)
   maxRange := max(FilteruMinRange, FilteruMaxRange)
   minDrange := min(FilteruDateMinRange, FilteruDateMaxRange)
   maxDrange := max(FilteruDateMinRange, FilteruDateMaxRange)
   If (userFilterProperty>1 && minRange!="")
   {
      If (userFilterProperty=2)
      {
         minRange := (userFilterSizeProperty=2) ? minRange*(1024**2) : minRange*1024
         maxRange := (userFilterSizeProperty=2) ? maxRange*(1024**2) : maxRange*1024
      } Else If (userFilterProperty=3 || userFilterProperty=4)
      {
         minRange := SubStr(minDrange, 1, 8) "010101"
         maxRange := SubStr(maxDrange, 1, 8) "010101"
      } Else If (userFilterProperty=8)
      {
         minRange := Round(minRange/10, 1)
         maxRange := Round(maxRange/10, 1)
      } Else If (userFilterProperty>10)
      {
         minRange := Round(clampInRange(minRange, 1, 256)/256, 5)
         maxRange := Round(clampInRange(maxRange, 1, 256)/256, 5)
      }

      If (SLDtypeLoaded=3)
      {
         isOrNot := (userFilterStringIsNot=1) ? " NOT " : ""
         2ndColumn := (userFilterWhat=1) ? "fullPath" : "imgfolder"
         If (userFilterProperty=8)
            columnu := "Round(imgwhratio, 1)"
         If (userFilterProperty=5)
            columnu := "Round(imgmegapix)"

         If (userFilterWhat=3)
            2ndColumn := "imgfile"

         If (userFilterInvertThis=1)
            invertor := " NOT "

         finalFilteru := "SQL:query:WHERE " columnu invertor " BETWEEN " minRange " AND " maxRange
         If thisStringFilter
            finalFilteru .= " AND " 2ndColumn isOrNot " LIKE '" thisStringFilter "' ESCAPE '>'"
      } Else
      {
         finalFilteru := "QPV::query::" columnu "::" minRange "::" maxRange
         If thisStringFilter
            finalFilteru .= "::" thisStringFilter
      }
   } Else
   {
      If (SLDtypeLoaded=3 && thisStringFilter)
      {
         isOrNot := (userFilterStringIsNot=1) ? " NOT " : ""
         2ndColumn := (userFilterWhat=1) ? "fullPath" : "imgfolder"
         If (userFilterWhat=3)
            2ndColumn := "imgfile"
         finalFilteru := "SQL:query:WHERE " 2ndColumn isOrNot " LIKE '" thisStringFilter "' ESCAPE '>'"
      } Else If thisStringFilter
         finalFilteru := "\>" thisStringFilter
   }

   newFilter := Trimmer(finalFilteru)
   newFilter := StrReplace(newFilter, "||", "|")
   newFilter := Trimmer(newFilter, "|")
   If (userFilterProperty=19)
      newFilter := (SLDtypeLoaded=3) ? "SQL:query:||Prev-Files-Selection||" : "||Prev-Files-Selection||"
   Else If (userFilterProperty=20)
      newFilter := "||Already-Seen-Images||"

   If (dummy!="external")
      GuiControl, SettingsGUIA:, InternalFilterString, % newFilter

   Return newFilter
}

quickFindUnseenImages(dummy:=0) {
   quickFindSeenImages("unseen")
}

quickFindSeenImages(dummy:=0) {
   UsrEditFilter := "||Already-Seen-Images||"
   userFilterDoString := 0
   userFilterProperty := 20
   userFilterInvertThis := (dummy="unseen") ? 1 : 0
   updateUIFiltersPanel("external")
   retrieveAlreadySeenImageFromCurrentList()
   InitialFilterSettingsPanel(1)
}

BtnApplyFilesFilter() {
   Gui, SettingsGUIA: Default
   GuiControlGet, UsrEditFilter
   GuiControlGet, userFilterInvertThis
   newFilter := updateUIFiltersPanel()
   Gui, SettingsGUIA: Submit, NoHide
   If !newFilter
   {
      SoundBeep , 300, 100
      showTOOLtip("WARNING: No filter has been defined")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (userFilterProperty=19)
   {
      getSelectedFiles(0, 1)
      If !markedSelectFile
      {
         msgBoxWrapper(appTitle ": WARNING", "You currently have no selected image in the files list. The filter is therefore inapplicable.", 0, 0, "warning")
         Return
      } Else userFilterDoString := 0
   } Else If (userFilterProperty=20)
   {
      InitialFilterSettingsPanel(1)
      BtnCloseWindow()
      retrieveAlreadySeenImageFromCurrentList()
      Return
   }

   InitialFilterSettingsPanel(1)
   BtnCloseWindow()
   If askAboutFileSave(" and the files list will be renewed based on the provided filter criteria")
   {
      userFilterDoString := 0
      userFilterProperty := 1
      UsrEditFilter := ""
      Return
   }

   If (userFilterDoString=1 && UsrEditFilter)
      RecentFiltersManager(UsrEditFilter)

   coreEnableFiltru(newFilter)
   dummyTimerDelayiedImageDisplay(50)
}

RecentFiltersManager(entry2add) {
  If (userPrivateMode=1)
     Return

  entry2add := Trimmer(entry2add)
  mainListu := readRecentFiltersEntries()
  If (StrLen(entry2add)<3 || InStr(entry2add, "{ no filter }"))
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>20)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentFilters, E%countItemz%
  }
}

msgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, checkBoxuCaption:="", checkState:=0, dropListu:="",edithu:="", edithuDef:="", listEditMode:=0, setWidth:=0, 2ndDropListu:=0, 2ndlistEditMode:=0) {
    Static msgBoxed := 0

    mouseTurnOFFtooltip()
    If (msgBoxed=1 && MsgBox2hwnd)
       Return

    msgBoxed := 1
    setWinCloseZeit()
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", iconz)

    panelMode := 0
    fontSize := (PrefsLargeFonts=1) ? LargeUIfontValue : 0
    hwnd := (AnyWindowOpen>0 && panelWinCollapsed!=-1) ? hSetWinGui : PVhwnd
    If (InStr(winTitle, "panelu|") && AnyWindowOpen>0 && isNowFakeWinOpen=1)
    {
       winTitle := StrReplace(winTitle, "panelu|")
       panelMode := 1
       hwnd := PVhwnd
    } Else DestroyTempBtnGui("now")

    hasDisabled := []
    If (folderTreeWinOpen=1)
    {
       hasDisabled[1] := 1
       WinSet, Disable,, ahk_id %hfdTreeWinGui%
    }

    If (VisibleQuickMenuSearchWin=1)
    {

       hasDisabled[2] := 1
       WinSet, Disable,, ahk_id %hQuickMenuSearchWin%
    }

    If (imgEditPanelOpened=1 && Hwnd!=PVhwnd)
    {
       hasDisabled[3] := 1
       WinSet, Disable,, ahk_id %PVhwnd%
    }

    oc := A_IsCritical 
    Critical, off
    zr := MsgBox2(msg, winTitle, buttonz, defaultBTN, iconz, nullFnt, PrefsLargeFonts, fontSize, hwnd, hwnd, checkBoxuCaption, checkState, dropListu, edithu, edithuDef, listEditMode, setWidth, 2nddropListu, 2ndlistEditMode)
    Critical, %oc%
    r := zr.btn

    If hasDisabled[3]
       WinSet, Enable,, ahk_id %PVhwnd%

    If hasDisabled[2]
       WinSet, Enable,, ahk_id %hQuickMenuSearchWin%

    If hasDisabled[1]
       WinSet, Enable,, ahk_id %hfdTreeWinGui%

    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    If (buttonz!=-1)
       addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
    Else
       addJournalEntry("HELP BOX CLOSED: " winTitle)

    If (panelMode=1) ; fake window panel
    {
       AnyWindowOpen := isNowFakeWinOpen := 0
       interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    }
    createGUItoolbar()
    lastLongOperationAbort := A_TickCount
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", "normal")

    ; SetTimer, setWinCloseZeit, -200, 900
    msgBoxed := 0
    Return (checkBoxuCaption || dropListu || edithu || 2ndDropListu) ? zr : r
}

simpleMsgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, modality:=0, optionz:=0) {
   ; Buttonz options:
   ; 0 = OK (that is, only an OK button is displayed)
   ; 1 = OK/Cancel
   ; 2 = Abort/Retry/Ignore
   ; 3 - Yes/No/Cancel
   ; 4 = Yes/No
   ; 5 = Retry/Cancel
   ; 6 = Cancel/Try Again/Continue

   ; Iconz options:
   ; 16 = Icon Hand (stop/error)
   ; 32 = Icon Question
   ; 48 = Icon Exclamation
   ; 64 = Icon Asterisk (info)

   ; Modality options:
   ; 4096 = System Modal (always on top)
   ; 8192 = Task Modal
   ; 262144 = Always-on-top (style WS_EX_TOPMOST - like System Modal but omits title bar icon)

   If AnyWindowOpen
   {
      If (defaultBTN=2)
         defaultBTN := 255
      Else If (defaultBTN=3)
         defaultBTN := 512
      Else
         defaultBTN := 0
 
      If (iconz=1 || iconz="hand" || iconz="error" || iconz="stop")
         iconz := 16
      Else If (iconz=2 || iconz="question")
         iconz := 32
      Else If (iconz=3 || iconz="exclamation")
         iconz := 48
      Else If (iconz=4 || iconz="info")
         iconz := 64
      Else
         iconz := 0
 
      theseOptionz := buttonz + iconz + defaultBTN + modality
      If optionz
         theseOptionz := optionz
 
      Gui, SettingsGUIA: +OwnDialogs
      MsgBox, % theseOptionz, % winTitle, % msg
      IfMsgBox, Yes
           r := "Yes"
      IfMsgBox, No
           r := "No"
      IfMsgBox, OK
           r := "OK"
      IfMsgBox, Cancel
           r := "Cancel"
      IfMsgBox, Abort
           r := "Abort"
      IfMsgBox, Ignore
           r := "Ignore"
      IfMsgBox, Retry
           r := "Retry"
      IfMsgBox, Continue
           r := "Continue"
      IfMsgBox, TryAgain
           r := "TryAgain"
   } Else r := interfaceThread.ahkFunction("msgBoxWrapper", winTitle, msg, buttonz, defaultBTN, iconz, modality, optionz)

   ; addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
   ; lastLongOperationAbort := A_TickCount
   Return r
}

coreEnableFiltru(stringu, noStringProcessing:=0) {
  startOperation := A_TickCount
  prevFilter := filesFilter
  If (stringu="\>")
     stringu := filesFilter := ""

  backCurrentSLD := CurrentSLD
  userSearchString := CurrentSLD := ""
  friendly := (StrLen(stringu)>1) ? "Applying filter on the list of files, please wait`n" stringu : "Deactivating the files list filter, please wait..."
  showTOOLtip(friendly)
  setImageLoading()

  If StrLen(filesFilter)<2
  {
     thereWasFilter := 0
     bckpResultedFilesList := []
     bckpResultedFilesList := resultedFilesList.Clone()
     bckpCurrentFileIndex := currentFileIndex
     bckpMaxFilesIndex := maxFilesIndex
  } Else thereWasFilter := 1

  If (stringu="||Already-Seen-Images||")
  {
     CurrentSLD := backCurrentSLD
     retrieveAlreadySeenImageFromCurrentList()
     Return
  }

  If (noStringProcessing=0)
  {
     testRegEx := SubStr(stringu, 1, 2)
     If (InStr(stringu, "QPV::query") || InStr(stringu, "SQL:query"))
        filesFilter := stringu
     Else If (testRegEx!="\>")
        filesFilter := JEE_StrRegExLiteral(stringu)
     Else
        filesFilter := SubStr(stringu, 3)
  } Else filesFilter := stringu

  FilterFilesIndex(thereWasFilter, doExactFolderMatch, prevFilter)
  If (maxFilesIndex<1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "No files matched your filtering criteria:`n" stringu "`n`nQPV will now restore the complete list of files.", 0, 1, "exclamation")
     filesFilter := ""
     FilterFilesIndex(0, 0, 0)
  } Else If (A_TickCount - startOperation>1500)
     SoundBeep, 900, 100

  CurrentSLD := backCurrentSLD
  If !filesFilter
  {
     bckpResultedFilesList := []
     filteredMap2mainList := []
     toBeExcludedIndexes := []
     resultsDupesArray := []
     dupesHashesData := []
     dupesPixelData := []
     ; ToolTip, haha , , , 2
     currentFileIndex := clampInRange(bckpCurrentFileIndex, 1, maxFilesIndex)
     If (maxFilesIndex>0 && doRandom=1)
        dummyTimerDelayiedImageDisplay(50)
  } Else If (maxFilesIndex>0 && doRandom=1)
  {
     ; SoundBeep 1200, 100
     currentFileIndex := 1
     dummyTimerDelayiedImageDisplay(50)
     ; RandomPicture()
  }

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, TriggerMenuBarUpdate, -50
  SetTimer, createGUItoolbar, -100
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

FilterFilesIndex(thereWasFilter:=0, doExactFolderMatch:=0, prevFilter:="") {
   If (InStr(prevFilter, "SQL:query:") && !InStr(filesFilter, "SQL:query:"))
   {
      BtnIndexStatsToList(0, 0, "none", 0) 
      If StrLen(filesFilter)<2
         Return
   }

   startZeit := A_TickCount
   selectedFiles := newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   mustDoQuery := 0
   If InStr(filesFilter, "QPV::query::")
   {
      queryObj := StrSplit(filesFilter, "::")
      queryType := queryObj[3]
      If (queryObj[5]="")
         queryObj[5] := queryObj[4]

      If (queryType="imgpixfmt" && queryObj[4])
      {
         queryMin := queryMax := queryObj[4]
         mustDoQuery := 1
      } Else If (queryType && !isNumber(queryType) && isNumber(queryObj[4]) && isNumber(queryObj[5]))
      {
         queryMin := min(Abs(queryObj[4]), Abs(queryObj[5]))
         queryMax := max(Abs(queryObj[4]), Abs(queryObj[5]))
         mustDoQuery := 1
      }

      queryString := Trimmer(queryObj[6])
      userFilterDoString := StrLen(queryString)>0 ? 1 : 0
      If (userFilterDoString!=1)
         queryString := 0

      If (mustDoQuery=1)
      {
         If RegExMatch(queryType, "i)(fsize|fmodified|fcreated)")
            r := collectFileInfosNow(queryString)
         Else If RegExMatch(queryType, "i)(imgpixfmt|imgwidth|imgheight|imgwhratio|imgmegapix|imgframes|imgdpi)")
            r := collectImageInfosNow(queryString, 9, 0)
         Else If RegExMatch(queryType, "i)(imgavg|imgmedian|imghpeak|imghlow|imghminu|imghmode|imghrms|imghrange)")
            r := collectImageInfosNow(queryString, 11, 0)

         If (r=1)
         {
            resultedFilesList := []
            resultedFilesList := bckpResultedFilesList.Clone()
            bckpResultedFilesList := []
            filesFilter := ""
            SoundBeep, 300, 100
            showTOOLtip("Operation abandoned. The files list was not filtered, because data collection did not complete.")
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }
      ; ToolTip, % queryType "=" queryMin "=" queryMax , , , 2
   }

   ; ToolTip, % filesFilter " = " userFilterWhat " = " userFilterStringIsNot , , , 2
   If (InStr(filesFilter, "SQL:query:WHERE") && SLDtypeLoaded=3)
   {
      If isInRange(userFilterProperty, 2, 4)
         collectSQLFileInfosNow("fsize", 0, 1, 0)
      Else If isInRange(userFilterProperty, 5, 10)
         collectSQLFileInfosNow("imgmegapix", 0, 1, 0)
      Else If isInRange(userFilterProperty, 11, 18)
         collectSQLFileInfosNow("imgmedian", 0, 1, 0)

      markedSelectFile := 0
      filteredMap2mainList := []
      extraFilter := extractSQLqueryFromFilter()
      r := BtnIndexStatsToList(0, extraFilter, "custom", extraFilter)
      If (r=-1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": WARNING", "No files matched the provided filter options:`n" filesFilter "`n`nThe application will now restore the complete list of files.", 0, 1, "exclamation")
         remFilesListFilter("simple")
      } Else bckpResultedFilesList := []
      Return
   } Else If InStr(filesFilter, "||Prev-Files-Selection||")
   {
      Loop, % maxFilesIndex + 1
      {
            r := resultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            If (resultedFilesList[A_Index, 2]!=1) ; is selected ?
               Continue

            newFilesIndex++
            newFilesList[newFilesIndex] := resultedFilesList[A_Index]
            If resultedFilesList[A_Index, 2]
               selectedFiles++

            If (thereWasFilter=1)
            {
               oldIndex := filteredMap2mainList[A_Index]
               newMappingList[newFilesIndex] := oldIndex
            } Else newMappingList[newFilesIndex] := A_Index
      }
   } Else
   {
      isStrFilter := StrLen(filesFilter)>1 ? 1 : 0
      Loop, % bckpMaxFilesIndex + 1
      {
            r := bckpResultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            thisIndex++
            If (mustDoQuery=1)
            {
               If (userFilterDoString=1)
               {
                  If !coreSearchIndex(r, queryString, userFilterWhat, userFilterStringIsNot)
                     Continue
               }

               Switch queryType
               {
                  Case "fmodified":
                     valu := bckpResultedFilesList[A_Index, 7]
                  Case "fcreated":
                     valu := bckpResultedFilesList[A_Index, 8]
                  Case "fsize":
                     valu := bckpResultedFilesList[A_Index, 6]
                  Case "imgmegapix":
                     valu := Round(bckpResultedFilesList[A_Index, 17], 1)
                  Case "imgwidth":
                     valu := bckpResultedFilesList[A_Index, 13]
                  Case "imgheight":
                     valu := bckpResultedFilesList[A_Index, 14]
                  Case "imgpixfmt":
                     valu := bckpResultedFilesList[A_Index, 15]
                  Case "imgdpi":
                     valu := bckpResultedFilesList[A_Index, 22]
                  Case "imgframes":
                     valu := bckpResultedFilesList[A_Index, 9]
                  Case "imgwhratio":
                     valu := Round(bckpResultedFilesList[A_Index, 16], 1)
                  Case "imgmedian":
                     valu := bckpResultedFilesList[A_Index, 19]
                  Case "imgavg":
                     valu := bckpResultedFilesList[A_Index, 18]
                  Case "imghpeak":
                     valu := bckpResultedFilesList[A_Index, 20]
                  Case "imghlow":
                     valu := bckpResultedFilesList[A_Index, 21]
                  Case "imghrms":
                     valu := bckpResultedFilesList[A_Index, 24]
                  Case "imghrange":
                     valu := bckpResultedFilesList[A_Index, 25]
                  Case "imghmode":
                     valu := bckpResultedFilesList[A_Index, 26]
                  Case "imghminu":
                     valu := bckpResultedFilesList[A_Index, 27]
               }

               zuza := isInRange(valu, queryMin, queryMax)
               If (userFilterInvertThis=1)
                  zuza := !zuza

               If !zuza
                  Continue
            } Else If (isStrFilter=1)
            {
               If !coreSearchIndex(r, filesFilter, userFilterWhat, userFilterStringIsNot)
                  Continue
            }

            newFilesIndex++
            newFilesList[newFilesIndex] := bckpResultedFilesList[A_Index]
            If bckpResultedFilesList[A_Index, 2]
               selectedFiles++

            If (isStrFilter=1)
               newMappingList[newFilesIndex] := A_Index
      }
   }

   filteredMap2mainList := []
   renewCurrentFilesList()
   If StrLen(filesFilter)>1
      filteredMap2mainList := newMappingList.Clone()
   resultedFilesList := newFilesList.Clone()
   markedSelectFile := selectedFiles
   maxFilesIndex := newFilesIndex
   newFilesList := []
   newMappingList := []
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
   GenerateRandyList()
}

throwMSGwriteError() {
  Static lastInvoked := 1
  If (ErrorLevel=1) && (A_TickCount - lastInvoked>45100)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the settings files: permission denied.", 0, 0, "error")
     lastInvoked := A_TickCount
  }
}

updateFilesListByID(indexu, indexProperty, value, isFilter) {
   if isFilter
      bckpResultedFilesList[indexu, indexProperty] := value
   else
      resultedFilesList[indexu, indexProperty] := value
}

updateMainUnfilteredList(indexu, indexProperty, value) {
   If (SLDtypeLoaded=3 && hasHamDistCached!=1)
   {
      If InStr(filesFilter, "SQL:query:")
         Return
   }

   If StrLen(filesFilter)>1
   {
      currentFilesListModified := 1
      oldIndex := filteredMap2mainList[indexu]
      If oldIndex
         bckpResultedFilesList[oldIndex, indexProperty] := value
      Return oldIndex
   }
}

singleInListEntriesRemover() {
   InListMultiEntriesRemover("single")
}

InListMultiEntriesRemover(dummy:=0, dontAsk:=0) {
   filesElected := getSelectedFiles(0, 1)
   If (markedSelectFile>1)
      itMultiFiles := 1

   If (itMultiFiles!=1 || dummy="single")
   {
      remCurrentEntry(0)
      Return
   }

   If (filesElected>500 && dontAsk!="y")
   {
      msgResult := msgBoxWrapper(appTitle, "Are you sure you want to remove " groupDigits(filesElected) " entries from the slideshow files list?", 4, 0, "question")
      If (msgResult!="yes")
         Return
   }

   startOperation := A_TickCount
   showTOOLtip("Removing " groupDigits(filesElected) " index entries, please wait")
   prevMSGdisplay := A_TickCount
   ForceRefreshNowThumbsList()
   countTFilez := 0
   doStartLongOpDance()
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   updateMainu := (StrLen(filesFilter)>1 && (!InStr(filesFilter, "SQL:query:") || hasHamDistCached=1)) ? 1 : 0
   Loop, % maxFilesIndex + 1
   {
      thisFileIndex := A_Index ; - countTFilez
      isSelected := resultedFilesList[thisFileIndex, 2]
      imgPath := resultedFilesList[thisFileIndex, 1]
      If (preventDeleteMatchingSearch=1 && imgPath && userSearchString)
      {
         If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
            isSelected := 0
      }

      If (preventDeleteFromProtectedPath=1 && protectedFolderPath)
      {
         If (preventDeleteFromProtectedSubPaths=1)
            OutDir := InStr(imgPath, protectedFolderPath "\") ? protectedFolderPath : 0
         Else
            zPlitPath(imgPath, 0, OutFileName, OutDir)

         If (protectedFolderPath=OutDir)
            isSelected := 0
      }

      If (isSelected!=1 && imgPath)
      {
         newFilesIndex++
         newFilesList[newFilesIndex] := resultedFilesList[thisFileIndex]
         If (updateMainu=1)
            newMappingList[newFilesIndex] := filteredMap2mainList[thisFileIndex]

         Continue
      } Else If !imgPath
         Continue

      If (SLDtypeLoaded=3 && preventDBentryRemoval!=1)
         deleteSQLdbEntry(StrReplace(imgPath, "||"), resultedFilesList[thisFileIndex, 12])

      countTFilez++
      If (updateMainu=1)
         updateMainUnfilteredList(thisFileIndex, 1, "")

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If !startPoint
         startPoint := thisFileIndex
   }

   resultedFilesList := []
   resultedFilesList := newFilesList.Clone()
   maxFilesIndex := newFilesIndex
   newFilesList := []
   filteredMap2mainList := []
   If (updateMainu=1)
      filteredMap2mainList := newMappingList.Clone()

   newMappingList := []
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   } Else currentFilesListModified := 1

   GenerateRandyList()
   getSelectedFiles(0, 1)
   zeitOperation := A_TickCount - startOperation
   etaTime := "Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countTFilez " index entries were removed until now`n" etaTime)
   Else
      showTOOLtip(countTFilez " index entries removed`n" etaTime)

   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         changeMcursor()
         ; showTOOLtip("Removing files list index filter, please wait")
         remFilesListFilter("simple")
         dummyTimerDelayiedImageDisplay(50)
      } Else handleEmptyFilesList(CurrentSLD, "", 1)
   } Else
   {
      startPoint--
      If (startPoint<2)
         startPoint := 1
      currentFileIndex := startPoint
      dummyTimerDelayiedImageDisplay(50)
   }

   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

remCurrentEntry(silentus:=0, whichIndex:=0) {
   Critical, on
   thisFileIndex := !whichIndex ? currentFileIndex : whichIndex
   If (!thisFileIndex || thisFileIndex<0)
      Return

   imgPath := resultedFilesList[thisFileIndex, 1]
   dbIndex := resultedFilesList[thisFileIndex, 12]
   file2remZ := resultedFilesList.RemoveAt(thisFileIndex)
   ; file2remA := file2remZ[1]
   If StrLen(filesFilter)>1
   {

      ; If (resultedFilesList[thisFileIndex, 5]=1)
      ; {
      ;    resultedFilesList[thisFileIndex, 5] := 0
      ;    updateMainUnfilteredList(thisFileIndex, 5, 0)
      ; }
      ; oldIndex :=  filteredMap2mainList[thisFileIndex]
      oldIndex := updateMainUnfilteredList(thisFileIndex, 1, 0)
      file2remC := filteredMap2mainList.RemoveAt(thisFileIndex)
      ; file2remB := bckpResultedFilesList[oldIndex, 1]
      ; Sleep, 200
      ; ToolTip, % thisFileIndex " | " file2remC " | " oldIndex " a " file2remB "`n" file2remA, , , 2
   }

   If (SLDtypeLoaded=3 && preventDBentryRemoval!=1)
      deleteSQLdbEntry(StrReplace(imgPath, "||"), dbIndex)

   maxFilesIndex--
   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (silentus!=1)
   {
      If (thumbsDisplaying!=1)
         Sleep, 50

      zPlitPath(StrReplace(imgPath, "||"), 1, OutFileName, OutDir)
      showDelayedTooltip("Index entry removed: " groupDigits(thisFileIndex) "`n" OutFileName "`n" OutDir "\", 0, 250)
   }

   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         ; showTOOLtip("Removing files list index filter, please wait")
         remFilesListFilter("simple")
         dummyTimerDelayiedImageDisplay(50)
         ; RandomPicture()
      } Else handleEmptyFilesList(CurrentSLD, "", 1)
   } Else 
   {
      currentFileIndex--
      NextPicture()
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

addSQLdbEntry(fileNamu, imgPath, fileSizu, fileMdate, fileCdate, simple:=0, factCheck:=1) {
   Static prevIDu := 0
   fileMdate := SubStr(fileMdate, 1, 12)
   fileCdate := SubStr(fileCdate, 1, 12)
   If (simple=1)
      SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder) VALUES (" sqlDBrowID ", 0, '" fileNamu "', '" imgPath "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
   Else
      SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder, fsize, fmodified, fcreated) VALUES (" sqlDBrowID ", 0, '" fileNamu "', '" imgPath "', '" fileSizu "', '" fileMdate "', '" fileCdate "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"

      ; ToolTip, % activeSQLdb.ErrorMsg " === " sqlDBrowID , , , 2
   If !activeSQLdb.Exec(SQLStr)
   {
      If InStr(activeSQLdb.ErrorMsg, "constraint failed")
         Return "err"

      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      If (simple=1)
         SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder) VALUES (" sqlDBrowID ", 0, " fileNamu ", " imgPath ") ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
      Else
         SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder, fsize, fmodified, fcreated) VALUES (" sqlDBrowID ", 0, " fileNamu ", " imgPath ", '" fileSizu "', '" fileMdate "', '" fileCdate "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
 
      If !activeSQLdb.Exec(SQLStr)
         Return "err"
   }

   If (factCheck=1)
   {
      activeSQLdb.LastInsertRowID(alolu)
      thisIDu := alolu CurrentSLD
      ; ToolTip, % prevIDu "==" thisIDu "==" sqlDBrowID , , , 2
      If (thisIDu!=prevIDu && alolu)
      {
         prevIDu := thisIDu
         sqlDBrowID++
      } Else Return "err"
   } Else sqlDBrowID++
}

updateSQLdbEntryImgRes(fullPath, imgResu, fileInfos, dbIndex, indexu:=0) {
   If (imgResu=1 || imgResu=2)
      thisPart := A_Space getImgPropsValuesSet(indexu, imgResu)
   Else
      thisPart := " imgdpi='" imgResu.dpi "', imgpixfmt='" imgResu.pixFmt "', imgframes='" imgResu.frames "', imgwidth='" imgResu.w "', imgheight='" imgResu.h "'"

   If (fileInfos=1 || fileInfos=2)
      thisPart .= ", " getImgFileValuesSet(indexu, fileInfos)
   Else If IsObject(fileInfos)
      thisPart .= ", fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      ; ToolTip, % A_ThisFunc "() failed to update l=" dbIndex , , , 2
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         addJournalEntry(A_ThisFunc "() - failed commit in database: " fullPath "`n" SQLStr)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)

   Return 1
}

updateSQLdbEntryFileInfos(fullPath, ByRef fileInfos, dbIndex) {
   thisPart := " fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"
   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      ; ToolTip, % A_ThisFunc "() failed to update l=" dbIndex , , , 2
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         addJournalEntry(A_ThisFunc "() - failed commit in database: " fullPath "`n" SQLstr)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)
   Return 1
}

getValueFilesList(indexu, value, modus) {
   If (modus=1)
      Return resultedFilesList[indexu, value]
   Else If (modus=2)
      Return bckpResultedFilesList[indexu, value]
}

getImgFileValuesSet(indexu, m) {
   Return "fsize='" getValueFilesList(indexu, 6, m) "', fmodified='" SubStr(getValueFilesList(indexu, 7, m), 1, 12) "', fcreated='" SubStr(getValueFilesList(indexu, 8, m), 1, 12) "'"
}

getImgPropsValuesSet(indexu, m) {
   Return "imgpixfmt='" getValueFilesList(indexu, 15, m) "', imgframes='" getValueFilesList(indexu, 9, m) "', imgdpi='" getValueFilesList(indexu, 22, m) "', imgwidth='" getValueFilesList(indexu, 13, m) "', imgheight='" getValueFilesList(indexu, 14, m) "'"
}

getImgHistoValuesSet(indexu, m) {
   Return "imgmedian='" getValueFilesList(indexu, 19, m) "', imgavg='" getValueFilesList(indexu, 18, m) "', imghpeak='" getValueFilesList(indexu, 20, m) "', imghlow='" getValueFilesList(indexu, 21, m) "', imghrms='" getValueFilesList(indexu, 24, m) "', imghrange='" getValueFilesList(indexu, 25, m) "',  imghmode='" getValueFilesList(indexu, 26, m) "', imghminu='" getValueFilesList(indexu, 27, m) "', pixelzFsmall='" getValueFilesList(indexu, 29, m) "', pixelzFbig='" getValueFilesList(indexu, 30, m) "', HpixelzFsmall='" getValueFilesList(indexu, 31, m) "', HpixelzFbig='" getValueFilesList(indexu, 32, m) "'"
}

updateSQLdbEntryImgHisto(fullPath, obju, imgResu, fileInfos, dbIndex, indexu:=0) {
   If (obju=1 || obju=2)
      thisPart := A_Space getImgHistoValuesSet(indexu, obju)
   Else
      thisPart := " imgmedian='" obju.median "', imgavg='" obju.avg "', imghpeak='" obju.peak "', imghlow='" obju.low "', imghrms='" obju.rms "', imghrange='" obju.range "',  imghmode='" obju.mode "', imghminu='" obju.minu "', pixelzFsmall='" obju.entireSmall  "', pixelzFbig='" obju.entireBig  "', HpixelzFsmall='" obju.HentireSmall "', HpixelzFbig='" obju.HentireBig "'"

   If (imgResu=1 || imgResu=2)
      thisPart .= ", " getImgPropsValuesSet(indexu, imgResu)
   Else If IsObject(imgResu)
      thisPart .= ", imgdpi='" imgResu.dpi "', imgpixfmt='" imgResu.pixFmt "', imgframes='" imgResu.frames "', imgwidth='" imgResu.W "', imgheight='" imgResu.H "'"

   If (fileInfos=1 || fileInfos=2)
      thisPart .= ", " getImgFileValuesSet(indexu, fileInfos)
   Else If IsObject(fileInfos)
      thisPart .= ", fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         addJournalEntry(A_ThisFunc "() - failed commit in database: " fullPath "`n" SQLstr)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)

   Return 1
}

updateSQLdbEntryCaption(imgPath, txtData, whatSet) {
   activeSQLdb.EscapeStr(imgPath)
   activeSQLdb.EscapeStr(txtData)
   SQLstr := "INSERT INTO imagesData (imgfile) VALUES (" imgPath ");"
   activeSQLdb.Exec(SQLStr)
   SQLstr := "UPDATE imagesData SET " whatSet "=" txtData " WHERE imgfile=" imgPath " COLLATE NOCASE;"
   If !activeSQLdb.Exec(SQLStr)
      Return -1
}

retrieveSQLdbEntryCaption(imgPath, whatRetrieve) {
  If (SLDtypeLoaded!=3)
     Return

  RecordSet := ""
  activeSQLdb.EscapeStr(imgPath)
  SQL := "SELECT " whatRetrieve " FROM imagesData WHERE imgfile=" imgPath " COLLATE NOCASE;"
  If !activeSQLdb.GetTable(SQL, RecordSet)
     Return

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      entries .= Rowu[1] A_Space
  }

  RecordSet.Free()
  Return Trimmer(entries)
}

retrieveSQLdbEntryImgInfos(fullPath, imgIndex, dbIndex, modus) {
   Critical, on
   If (SLDtypeLoaded!=3)
      Return 0

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
   SQL := "SELECT imgwidth, imgheight, imgframes, imgpixfmt, imgmedian, imgavg, imghpeak, imghlow, imgdpi FROM images" wherePart
   yay := RecordSet := ""

   If !activeSQLdb.GetTable(SQL, RecordSet)
   {
      addJournalEntry(A_ThisFunc "() - failed to query the database: " fullPath "`n" SQL)
      Return 0
   }
   ; ToolTip, % "l= " RecordSet.RowCount , , , 2
   If !RecordSet.RowCount
      Return 0

   Loop, % RecordSet.RowCount
   {
     Rowu := RecordSet.Rows[A_Index]
     If (Rowu[5] || Rowu[6] || Rowu[7])
     {
        countLoops++
        resultedFilesList[imgIndex, 19] := Rowu[5]
        resultedFilesList[imgIndex, 18] := Rowu[6]
        resultedFilesList[imgIndex, 20] := Rowu[7]
        resultedFilesList[imgIndex, 21] := Rowu[8]
     }

     ; ToolTip, % Row[1] " = " Row[5] , , , 2
     If (Rowu[1] && Rowu[2])
     {
        countLoops++
        resultedFilesList[imgIndex, 13] := Rowu[1]
        resultedFilesList[imgIndex, 14] := Rowu[2]
        resultedFilesList[imgIndex, 15] := Rowu[4]
        resultedFilesList[imgIndex, 9] := Rowu[3]
        resultedFilesList[imgIndex, 22] := Rowu[9]
     }
   }

  RecordSet.Free()
  If !countLoops
     fnOutputDebug(A_ThisFunc "() - no cache in database: " fullPath)

  Return yay
}

updateSQLdbEntry(oldEntry, newEntry, updateDates, dbIndex) {
   If (updateDates=1)
      obju := GetFileAttributesEx(newEntry)

   If !dbIndex
      activeSQLdb.EscapeStr(oldEntry)

   zPlitPath(newEntry, 1, newFileName, newFilePath)
   extra := (updateDates=1) ? ", fmodified=" SubStr(obju.wTime, 1, 12) ", fcreated=" SubStr(obju.cTime, 1, 12) ", fsize=" obju.size : ""
   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" oldEntry " COLLATE NOCASE;"
   SQLstr := "UPDATE images SET isDeleted=0, imgfile='" SQLescapeStr(newFileName) "', imgfolder='" SQLescapeStr(newFilePath) "'" extra wherePart
   If !activeSQLdb.Exec(SQLstr)
   {
      zPlitPath(oldEntry, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      activeSQLdb.EscapeStr(newFileName)
      activeSQLdb.EscapeStr(newFilePath)
      SQLstr := "UPDATE images SET isDeleted=0, imgfile=" newFileName ", imgfolder=" newFilePath extra " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
         Return 0
   }
   Return 1
}

SQLdeleteEntriesMarked() {
    If (SLDtypeLoaded!=3)
       Return

    SQLstr := "DELETE FROM images WHERE isDeleted=1;"
    If !activeSQLdb.Exec(SQLStr)
       throwSQLqueryDBerror(A_ThisFunc)
    Else
       getMaxRowIDsqlDB()
}

deleteSQLdbEntry(fullPath, dbIndex) {
  If !dbIndex
     activeSQLdb.EscapeStr(fullPath)

  wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
  SQLstr := "DELETE FROM images" wherePart
  If !activeSQLdb.Exec(SQLStr)
  {
     zPlitPath(fullPath, 1, fileNamu, imgPath)
     activeSQLdb.EscapeStr(fileNamu)
     activeSQLdb.EscapeStr(imgPath)
     SQLstr := "DELETE FROM images WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
     activeSQLdb.Exec(SQLStr)
  }
}

openFileDialogWrapper(p_Type, optionz, startPath, msg, pattern, ByRef n_FilterIndex:="", chooseFilterIndex:=1, defaultEditField:="") {
   setWinCloseZeit()
   thisHwnd := (AnyWindowOpen) ? hSetWinGui : PVhwnd
   ; If (p_type="o")
   ;    pattern .= "|All files (*.*)"

   If FolderExist(startPath)
      pathSymbol := "\"

   If !chooseFilterIndex
      chooseFilterIndex := 1

   optionz .= " NoChangeDir HideReadOnly"
   If InStr(p_type, "o")
   {
      entriesList := defaultu "`n" recentOpenedFolders()
      If (p_type="o1")
      {
         thisCombo := "Open selected file only"
         thisCombo .= "`nOpen in a new QPV instance"
         thisCombo .= "`nIndex all images in current folder as well"
         thisCombo .= "`nPerform recursive folder(s) scan to index images"
         thisGroup := "Open mode"
      }

      FileMustExist := InStr(optionz, "FileMustExist") ? 1 : 0
      zr := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, thisCombo, 1, thisGroup, entriesList, 0, pattern, chooseFilterIndex, FileMustExist, defaultEditField)
      r := zr.SelectedDir
      n_FilterIndex := zr.SelectedCombo
   } Else
   {
      If InStr(p_type, "m")
         p_Type := "o"

      r := Dlg_OpenSaveFile(p_Type, thisHwnd, msg, pattern, chooseFilterIndex, startPath pathSymbol, "", optionz)
      n_FilterIndex := NumGet(optionz, (A_PtrSize=8) ? 44:24,"UInt")
      optionz := ""
   }
   r := Trimmer(r)
   If StrLen(r)<4
      r := ""

   SetWorkingDir, % mainCompiledPath
   SetTimer, setWinCloseZeit, -150, 900
   lastLongOperationAbort := A_TickCount
   Return r
}

WritePrefsIntoSLD() {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   startPath := !CurrentSLD ? prevOpenFolderPath : CurrentSLD
   file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save slideshow settings into file...", "Slideshow plain-text (*.sld)")
   If file2save
   {
      If !RegExMatch(file2save, sldsPattern)
         file2save .= ".sld"

      FileReadLine, firstLine, % file2save, 1
      If InStr(firstLine, "[General]")
      {
         Sleep, 10
         writeSlideSettings(file2save)
      } Else 
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgBoxWrapper(appTitle ": ERROR", "The selected file appears not to have the correct file format.`nPlease select a .SLD file already saved by this application.`n`n" OutFileName, 0, 0, "error")
      }
   }
}

recreateDynaFoldersSQLdbList(saveDynaFolders) {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM dynamicfolders;")
   Loop, Parse, saveDynaFolders, `n
   {
       If StrLen(A_LoopField)>2
          addDynamicFolderSQLdb(Trimmer(A_LoopField), 0, "dynamicfolders")
   }

   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

saveSlideSettingsInDB() {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM settings;")
   IniSLDBWrite("SLDcacheFilesList", 1)
   IniSLDBWrite("IMGresizingMode", IMGresizingMode)
   IniSLDBWrite("imgFxMode", imgFxMode)
   IniSLDBWrite("SlideHowMode", SlideHowMode)
   IniSLDBWrite("slideShowDelay", slideShowDelay)
   IniSLDBWrite("slidesFXrandomize", slidesFXrandomize)
   IniSLDBWrite("zoomLevel", zoomLevel)
   IniSLDBWrite("vpIMGrotation", vpIMGrotation)
   IniSLDBWrite("doSlidesTransitions", doSlidesTransitions)
   IniSLDBWrite("WindowBgrColor", WindowBgrColor)
   IniSLDBWrite("FlipImgH", FlipImgH)
   IniSLDBWrite("FlipImgV", FlipImgV)
   IniSLDBWrite("usrColorDepth", usrColorDepth)
   IniSLDBWrite("ColorDepthDithering", ColorDepthDithering)
   IniSLDBWrite("lumosAdjust", lumosAdjust)
   IniSLDBWrite("GammosAdjust", GammosAdjust)
   IniSLDBWrite("lumosGrayAdjust", lumosGrayAdjust)
   IniSLDBWrite("GammosGrayAdjust", GammosGrayAdjust)
   IniSLDBWrite("satAdjust", satAdjust)
   IniSLDBWrite("imageAligned", imageAligned)
   IniSLDBWrite("doSatAdjusts", doSatAdjusts)
   IniSLDBWrite("autoAdjustMode", autoAdjustMode)
   IniSLDBWrite("chnRdecalage", chnRdecalage)
   IniSLDBWrite("chnGdecalage", chnGdecalage)
   IniSLDBWrite("chnBdecalage", chnBdecalage)
   IniSLDBWrite("IntensityAlphaChannel", IntensityAlphaChannel)
   IniSLDBWrite("usrAdaptiveThreshold", usrAdaptiveThreshold)
   IniSLDBWrite("TouchScreenMode", TouchScreenMode)
   IniSLDBWrite("skipDeadFiles", skipDeadFiles)
   IniSLDBWrite("isAlwaysOnTop", isAlwaysOnTop)
   IniSLDBWrite("bwDithering", bwDithering)
   IniSLDBWrite("zatAdjust", zatAdjust)
   IniSLDBWrite("hueAdjust", hueAdjust)
   IniSLDBWrite("realGammos", realGammos)
   IniSLDBWrite("imgThreshold", imgThreshold)
   IniSLDBWrite("isTitleBarVisible", isTitleBarVisible)
   IniSLDBWrite("animGIFsSupport", animGIFsSupport)
   IniSLDBWrite("thumbsAratio", thumbsAratio)
   IniSLDBWrite("thumbsZoomLevel", thumbsZoomLevel)
   IniSLDBWrite("easySlideStoppage", easySlideStoppage)
   IniSLDBWrite("appVersion", appVersion)
   IniSLDBWrite("usrTextureBGR", usrTextureBGR)
   IniSLDBWrite("syncSlideShow2Audios", syncSlideShow2Audios)
   IniSLDBWrite("autoPlaySNDs", autoPlaySNDs)
   IniSLDBWrite("mediaSNDvolume", mediaSNDvolume)
   IniSLDBWrite("reverseOrderOnSort", reverseOrderOnSort)
   IniSLDBWrite("borderAroundImage", borderAroundImage)
   IniSLDBWrite("resetImageViewOnChange", resetImageViewOnChange)
   IniSLDBWrite("showImgAnnotations", showImgAnnotations)
   IniSLDBWrite("allowGIFsPlayEntirely", allowGIFsPlayEntirely)
   IniSLDBWrite("prevFilesSortMode", prevFilesSortMode)
   IniSLDBWrite("autoPlaySlidesAudio", autoPlaySlidesAudio)
   IniSLDBWrite("SlidesMusicSong", SlidesMusicSong)
   IniSLDBWrite("hamDistInterpolation", hamDistInterpolation)
   IniSLDBWrite("userpHashMode", userpHashMode)
   IniSLDBwrite("dbVersion", dbVersion)
   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

IniSLDBwrite(what, value, whichTable:="settings") {
    SQLstr := "INSERT INTO " whichTable " (paramz, valuez) VALUES ('" what "', '" value "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       activeSQLdb.EscapeStr(value)
       activeSQLdb.EscapeStr(what)
       SQLstr := "UPDATE " whichTable " SET valuez=" value " WHERE paramz=" what " COLLATE NOCASE;"
       z := activeSQLdb.Exec(SQLStr)
       fnOutputDebug(A_ThisFunc "(): " SQLStr " | " z)
    }
}

IniSLDBreadAll(givenFilter:="", whichTable:="settings") {
  startOperation := A_TickCount
  SQL := "SELECT paramz, valuez FROM " whichTable ";"
  RecordSet := ""

  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "(): failed to read settings from SQL database")
     Return -1
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If StrLen(Rowu[1])>2
      {
         paramu := Rowu[1]
         valu := Rowu[2]
         If (StrLen(valu)>0 && (MustLoadSLDprefs=1 || paramu=givenFilter))
            %paramu% := valu
      }
  }

  If (isWinXP=1 || minimizeMemUsage=1)
     doSlidesTransitions := 0

  RecordSet.Free()
}

SQLdbGenerateStaticFolders() {
   If AnyWindowOpen
      BtnCloseWindow()
 
   Sleep, 5
   activeSQLdb.Exec("DELETE FROM staticfolders;")
   SQL := "SELECT DISTINCT imgfolder FROM images;"
   RecordSet := ""
   If !activeSQLdb.GetTable(SQL, RecordSet)
   {
      SoundBeep, 300, 100
      addJournalEntry("Failed to execute SQL command in order to generate the static folders list from the indexed files.")
      Return
   }

   activeSQLdb.Exec("BEGIN TRANSACTION;")
   foldersListArray := new hashtable()
   Loop, % RecordSet.RowCount
   {
       Rowu := RecordSet.Rows[A_Index]
       thisFolder := Trimmer(Rowu[1])
       z := Format("{:L}", thisFolder)
       If (StrLen(thisFolder)>2 && foldersListArray[z]!=1)
       {
          foldersListArray[z] := 1
          addDynamicFolderSQLdb(thisFolder, 0, "staticfolders")
       }
   }
   foldersListArray := ""
   RecordSet.Free()
   If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      throwSQLqueryDBerror(A_ThisFunc)
}

getDynamicFoldersList(fileu:=0) {
   If !fileu
      fileu := RegExMatch(CurrentSLD, sldsPattern) ? CurrentSLD : ""

   listu := (fileu && FileExist(fileu) && (InStr(DynamicFoldersList, "|hexists|") || SLDtypeLoaded=3)) ? coreLoadDynaFolders(fileu) : DynamicFoldersList
   listu := StrReplace(listu, "|hexists|")
   Sort, listu, UD`n
   listu := cleanDynamicFoldersList(listu "`n")
   Return listu
}

rebuildDBfilesList() {
   If StrLen(filesFilter)>1
      MenuRemFilesListFilter()

   If !activeSQLdb.CloseDB()
   {
      showTOOLtip("Failed to close active database")
      SoundBeep 300, 100
      Return
   }

   SLDtypeLoaded := 2
   SaveDBfilesList(CurrentSLD)
}

SaveDBfilesList(enforceFile:=0) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (maxFilesIndex>1)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save files list - database", "The files list is filtered down to " groupDigits(maxFilesIndex) " files from " groupDigits(bckpMaxFilesIndex) ".`n`nTo save the entire list of indexed files, you have to deactivate the filter [Ctrl + Space].`n`nPlease choose how to proceed...", "&Deactivate filter|&Save list as is|&Cancel", 0, "info")
         If InStr(msgResult, "deactivate")
         {
            MenuRemFilesListFilter()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         } Else If InStr(msgResult, "save")
         {
            Sleep, 50
         } Else
         {
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }

      If !FileRexists(enforceFile)
      {
         fileWasGiven := 0
         zPlitPath(CurrentSLD, 0, OutFileName, OutDir, OutFileNameNoExt)
         file2save := openFileDialogWrapper("S", "PathMustExist", OutDir "\" OutFileNameNoExt, "Save files list as SQL slideshow database...", "Slideshow database (*.sldb)")
         If (!RegExMatch(file2save, "i)(.\.sldb)$") && file2save)
            file2save .= ".sldb"
      } Else
      {
         fileWasGiven := 1
         file2save := enforceFile
      }
   } Else Return

   If !file2save
      Return

   If AnyWindowOpen
      BtnCloseWindow()

   Sleep, 10
   If (file2save && SLDtypeLoaded=3 && dbVersion!=dbExpectedVersion && maxFilesIndex>1 && CurrentSLD)
   {
      msgResult := msgBoxWrapper(appTitle ": WARNING", "This database was saved by an older version of " appTitle ". The entire index structure needs to be rebuilt. QPV will now recreate this database with the new structure.`n`nPlease note: all the cached data pertaining to the indexed images will be lost.", "&Continue|C&ancel", 2, "exclamation")
      If !InStr(msgResult, "continue")
         Return

      SLDtypeLoaded := 2
   }

   startOperation := A_TickCount
   If (SLDtypeLoaded!=3 && file2save)
   {
      activeSQLdb.CloseDB()
      If FileExist(file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The destination file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult="Yes")
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            Try FileDelete, %file2save%
            Catch wasErrorB
                  Sleep, 1
         } Else
         {
            SetTimer, PanelSaveSlideShowu, -200
            Return
         }

         If wasErrorB
         {
            msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file: " OutFileName ". Permission denied.`n`nLocation:`n" OutDir "\", 0, 0, "error")
            SetTimer, PanelSaveSlideShowu, -200
            Return
         }
      }

      err := SLDbInitSQLdb(file2save)
      If err
      {
         msgBoxWrapper(appTitle ": ERROR", "Unable to create SQL database file. Fatal error. Please choose the plain-text format to save the files list (slideshow).`n`nError details: " err, 0, 0, "error")
         SetTimer, PanelSaveSlideShowu, -200
         Return
      }

      setImageLoading()
      dbVersion := dbExpectedVersion
      setWindowTitle("Saving SQL files list database, please wait", 1)
      showTOOLtip("Saving the list of folders into the SQL database`n" file2save "`nPlease wait")
      saveDynaFolders := getDynamicFoldersList()
      recreateDynaFoldersSQLdbList(saveDynaFolders)
      saveSlideSettingsInDB()
      IniSLDBwrite("dbVersion", dbExpectedVersion)

      currentFilesListModified := 0
      If (SLDtypeLoaded!=3)
      {
         populatedStaticFolders := 1
         LoadStaticFoldersCached(CurrentSLD, countStaticFolders, "f")
         SQLDBdumpStaticFoldersList()
      }

      doStartLongOpDance()
      showTOOLtip("Saving " groupDigits(maxFilesIndex) " entries in the SQL database`n" file2save "`nPlease wait", 0, 0, 3/100)
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      prevMSGdisplay := A_TickCount
      sqlDBrowID := 1
      failedFiles := 0
      Loop, % maxFilesIndex
      {
         imgPath := resultedFilesList[A_Index, 1]
         If InStr(imgPath, "\\")
         {
            imgPath := StrReplace(imgPath, "\\", "\")
            resultedFilesList[A_Index, 1] := imgPath
         }

         zPlitPath(imgPath, 1, OutFileName, OutDir)
         ; fileInfos := GetFileAttributesEx(imgPath)
         If (resultedFilesList[A_Index, 6] && resultedFilesList[A_Index, 7])
            z := addSQLdbEntry(OutFileName, OutDir, resultedFilesList[A_Index, 6], resultedFilesList[A_Index, 7], resultedFilesList[A_Index, 8], 0)
         Else
            z := addSQLdbEntry(OutFileName, OutDir, 0, 0, 0, 1, 0)

         If z
            failedFiles++

         resultedFilesList[A_Index, 12] := sqlDBrowID
         If (resultedFilesList[A_Index, 11] && resultedFilesList[A_Index, 13])
         {
            updateSQLdbEntryImgHisto(imgPath, 1, 1, 0, sqlDBrowID, A_Index)
         } Else
         {
            If resultedFilesList[A_Index, 11]
               updateSQLdbEntryImgHisto(imgPath, 1, 0, 0, sqlDBrowID, A_Index)
            If resultedFilesList[A_Index, 13]
               updateSQLdbEntryImgRes(imgPath, 1, 0, sqlDBrowID, A_Index)
         }

         If (A_TickCount - prevMSGdisplay>1500)
         {
            etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
            If failedFiles
               someErrors := "`nFailed to insert " groupDigits(failedFiles) " entries"

            showTOOLtip("Inserting entries into the SQL database`n" file2save someErrors etaTime, 0, 0, A_Index/maxFilesIndex)
            prevMSGdisplay := A_TickCount
         }

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
      }

      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)

      ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
      If (populatedStaticFolders!=1)
         SQLdbGenerateStaticFolders()

      If (abandonAll!=1)
      {
         getMaxRowIDsqlDB()
         CurrentSLD := file2save
         SLDtypeLoaded := 3
      } Else activeSQLdb.CloseDB()

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      dummyTimerDelayiedImageDisplay(50)
      RemoveTooltip()
   } Else If (CurrentSLD=file2save && SLDtypeLoaded=3)
   {
      showTOOLtip("Saving SQL files list database, please wait")
      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      getMaxRowIDsqlDB()
      showTOOLtip("Slideshow database saved")
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else If (CurrentSLD!=file2save && SLDtypeLoaded=3)
   {
      activeSQLdb.CloseDB()
      Sleep, 5
      FileCopy, % CurrentSLD, % file2save, 1
      Sleep, 5
      activeSQLdb := new SQLiteDB
      If !activeSQLdb.OpenDB(file2save)
      {
         showTOOLtip("ERROR: Failed to save the slideshow database")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return -1
      }

      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      CurrentSLD := file2save
      getMaxRowIDsqlDB()
      showTOOLtip("Slideshow database saved")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }

   etaTime := "Elapsed time to save the SQL database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

SaveFilesList(enforceFile:=0) {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (!CurrentSLD || maxFilesIndex<2)
   {
      showTOOLtip("WARNING: No files are presently indexed")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (maxFilesIndex>0)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save files list - plain text", "The files list is filtered down to " groupDigits(maxFilesIndex) " files from " groupDigits(bckpMaxFilesIndex) ".`n`nTo save the entire list of indexed files, you have to deactivate the filter [Ctrl + Space].`n`nPlease choose how to proceed...", "&Deactivate filter|&Save list as is|&Cancel", 0, "info")
         If InStr(msgResult, "deactivate")
         {
            MenuRemFilesListFilter()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         } Else If InStr(msgResult, "save")
         {
            Sleep, 5
         } Else
         {
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }

      If !FileRexists(enforceFile)
      {
         fileWasGiven := 0
         zPlitPath(CurrentSLD, 0, OutFileName, OutDir, OutFileNameNoExt)
         file2save := openFileDialogWrapper("S", "PathMustExist", OutDir "\" OutFileNameNoExt, "Save files list as plain-text slideshow...", "Slideshow plain-text (*.sld)|All (*.*)", 1, 1)
         ; MsgBox, % A_ThisFunc "()`n" file2save
         If (!RegExMatch(file2save, "i)(.\.sld)$") && file2save)
            file2save .= ".sld"
      } Else
      {
         fileWasGiven := 1
         file2save := enforceFile
      }
   } Else
   {
      showTOOLtip("WARNING: Insufficient files added to index")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir)
      If FileExist(file2save)
      {
         If !fileWasGiven
            msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")

         If (msgResult="Yes" || fileWasGiven=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            If (file2save=CurrentSLD)
            {
               newTmpFile := file2save "-bkcp"
               Try FileMove, %file2save%, %newTmpFile%, 1
               Catch wasErrorA
                     Sleep, 1
            } Else
            {
               Try FileDelete, %file2save%
               Catch wasErrorB
                     Sleep, 1
            }

            If (wasErrorA || wasErrorB)
            {
               msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file. Permission denied or another error occured.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
               Return
            }
         } Else Return
      }

      Sleep, 2
      BtnCloseWindow()
      writeSlideSettings(file2save)
      mainFile := FileOpen(file2save, "a", "UTF-16")
      If !IsObject(mainFile)
      {
         msgBoxWrapper(appTitle ": ERROR", "Unable to write file in the given location. Permission denied or another error occured.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
         Return
      }

      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setImageLoading()
      Sleep, 10
      setWindowTitle("Saving files list index, please wait", 1)
      If (SLDcacheFilesList=1)
         showTOOLtip("Saving list of " groupDigits(maxFilesIndex) " entries into`n" file2save "`nPlease wait")
      Else
         showTOOLtip("Saving folders index in`n" file2save "`nPlease wait")

      thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
      ; ToolTip, % thisTmpFile "=" , , , 2

      saveDynaFolders := getDynamicFoldersList(thisTmpFile)
      mainFile.Write("`n[DynamicFolderz]`n")
      Loop, Parse, saveDynaFolders, `n
      {
          fileTest := StrReplace(A_LoopField, "|")
          If !FolderExist(fileTest)
             Continue

          countDynas++
          mainFile.Write("DF" countDynas "=" A_LoopField "`n")
          changeMcursor()
      }

      changeMcursor()
      mainFile.Write("`n[Folders]`n")
      If (SLDcacheFilesList=1)
      {
         thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
         LoadStaticFoldersCached(thisTmpFile, countStaticFolders, "f")
         Loop, % countStaticFolders
               mainFile.Write("Fi" A_Index "=" newStaticFoldersListCache[A_Index, 2] "*&*" newStaticFoldersListCache[A_Index, 1] "`n")
      }

      mainFile.Write("`n[FilesList]`n")
      If (SLDcacheFilesList=1)
      {
         Loop, % maxFilesIndex
         {
            r := resultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            If InStr(r, "\\")
            {
               r := StrReplace(r, "\\", "\")
               resultedFilesList[A_Index, 1] := r
            }

            mainFile.Write(r "`n")
         }
      }

      mainFile.Close()
      SLDtypeLoaded := 2
      FileDelete, % newTmpFile
      currentFilesListModified := 0
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      CurrentSLD := file2save
      DynamicFoldersList := "|hexists|"
      mustGenerateStaticFolders := 0
      etaTime := "Elapsed time to save plain-text files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
      addJournalEntry(etaTime)
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % wasErrorC ? 300 : 900, 100
      If wasErrorC
         msgBoxWrapper(appTitle ": ERROR", "Errors occured when writing the files list to disk. Permission denied or not enough disk space.", 0, 0, "error")
      dummyTimerDelayiedImageDisplay(50)
   }
}

LoadStaticFoldersCached(fileNamu, ByRef countStaticFolders, allowAsk:=0) {
    countStaticFolders := newStaticFoldersListCache.MaxIndex()
    ths := newStaticFoldersListCache.Count()
    If (StrLen(newStaticFoldersListCache[1, 1])>4 && countStaticFolders>0 && ths>0)
       Return

    countStaticFolders := 0
    hash := new hashtable()
    If (SLDtypeLoaded=3 && (fileNamu=CurrentSLD || allowAsk="f"))
    {
       SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
       If !activeSQLdb.GetTable(SQL, RecordSet)
       {
          throwSQLqueryDBerror(A_ThisFunc)
          Return 0
       }

       newStaticFoldersListCache := []
       Loop, % RecordSet.RowCount
       {
           Rowu := RecordSet.Rows[A_Index]
           z := Format("{:L}", Rowu[1])
           If (StrLen(Rowu[1])>3 && hash[z]!=1)
           {
              hash[z] := 1
              countStaticFolders++
              newStaticFoldersListCache[countStaticFolders] := [Rowu[1], Rowu[2]]
           }
       }

       RecordSet.Free()
       hash := ""
       iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
       Return
    }

    FileRead, tehFileVar, %fileNamu%
    newStaticFoldersListCache := []
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(Fi[0-9].*\=.{14}\*\&\*[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
       {
          lineArru := StrSplit(line, "*&*")
          folderu := lineArru[2]
          oldDateu := lineArru[1]
          oldDateu := SubStr(oldDateu, InStr(oldDateu, "=")+1)
          z := Format("{:L}", folderu)
          If (StrLen(folderu)>3 && StrLen(oldDateu)>3 && hash[z]!=1)
          {
             hash[z] := 1
             countStaticFolders++
             newStaticFoldersListCache[countStaticFolders] := [folderu, oldDateu]
             changeMcursor()
          }
       }
    }

    hash := ""
    If (!countStaticFolders && (allowAsk=1 || allowAsk="f"))
    {
       If (allowAsk!="f")
          msgResult := msgBoxWrapper(appTitle ": Confirmation", "This folders list was not yet generated. Would you like to generate it now?", 4, 0, "question")

       If (msgResult="yes" || allowAsk="f")
       {
          If (StrLen(filesFilter)>2 && msgResult="yes")
             MenuRemFilesListFilter()
          GenerateStaticFoldersListNow()
          countStaticFolders := newStaticFoldersListCache.MaxIndex()
       }
    }

    iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
    changeMcursor("normal")
}

regenerateStaticFoldersList() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
   {
      zr := SQLdbGenerateStaticFolders()
      If !zr
      {
         addJournalEntry("ERROR: Failed to regenerate the static folders list in the database")
         Return
      }

      lastFilterEditSearch := StaticListViewFilteru := ""
      newStaticFoldersListCache := []
      PanelStaticFolderzManager()
      Return
   }

   If StrLen(filesFilter)>2
      MenuRemFilesListFilter()

   lastFilterEditSearch := StaticListViewFilteru := ""
   GenerateStaticFoldersListNow()
   changeMcursor("normal")
   PanelStaticFolderzManager()
}

countFilesDiskPerStaticFolders() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(folderu, RowNumber, 1)
    folderu := newStaticFoldersListCache[folderu, 1]
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    counter := indexu := RowNumber := 0
    total := LV_GetCount()
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    indexList := []
    Loop, % total
    {
       RowNumber := LV_GetNext(RowNumber)
       If !RowNumber
          Break

       LV_GetText(indexu, RowNumber, 1)
       If !indexu
          Continue

       folderu := newStaticFoldersListCache[indexu, 1]
       If folderu
       {
          counter++
          indexList[counter] := [indexu, RowNumber]
       }
    }

    doStartLongOpDance()
    prevMSGdisplay := A_TickCount
    startOperation := A_TickCount
    total := indexList.Count()
    Loop, % total
    {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>2000)
       {
          prevMSGdisplay := A_TickCount
          showTOOLtip("Gathering folders data, please wait`n" groupDigits(total) " selected folders", 0, 0, A_Index/total)
       }

       indexu := indexList[A_Index, 1]
       folderu := newStaticFoldersListCache[indexu, 1]
       If FolderExist(folderu)
       {
          RowNumber := indexList[A_Index, 2]
          filez := folderz := fileSizu := 0
          z := getFolderInfos(folderu, filez, folderz, fileSizu)
          newStaticFoldersListCache[indexu, 5] := filez
          newStaticFoldersListCache[indexu, 6] := fileSizu
          LV_Modify(RowNumber, "Col8", filez)
          If newStaticFoldersListCache[indexu, 3]
             LV_Modify(RowNumber, "Col9", filez - newStaticFoldersListCache[indexu, 3])
          LV_Modify(RowNumber, "Col10", Round(Round(fileSizu/1024, 1)/1024, 1))
          If z
             Break
       }
    }

    CurrentSLD := backCurrentSLD
    ResetImgLoadStatus()
    RemoveTooltip()
}

BTNcountFilesDiskDynaFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_GetNext()
    LV_GetText(folderu, RowNumber, 3)
    LV_GetText(isR, RowNumber, 2)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If !thisIndex
       thisIndex := BTNcountFilesDynaFolders()

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    doStartLongOpDance()
    startOperation := A_TickCount
    If FolderExist(folderu)
    {
       friendly := isR ? "recursively " : ""
       showTOOLtip("Scanning folder " friendly "for image files`n" folderu "\")
       onDisk := folderz := fileSizu := 0
       z := getFolderInfos(folderu, onDisk, folderz, fileSizu, "DF" isR)
       diffu := (onDisk!="" && thisIndex!="") ? onDisk - thisIndex : 0
       LV_Modify(RowNumber, "Col7", onDisk)
       LV_Modify(RowNumber, "Col8", diffu)
       LV_Modify(RowNumber, "Col9", Round(Round(fileSizu/1024, 1)/1024, 1))
       RemoveTooltip()
    } Else
    {
       showTOOLtip("ERROR: The folder no longer exists or access denied`n" folderu "\")
    }

    CurrentSLD := backCurrentSLD
    ResetImgLoadStatus()
}

GenerateStaticFoldersListNow() {
   foldersListArray := new hashtable()
   prevMSGdisplay := A_TickCount
   mustGenerateStaticFolders := 0
   startOperation := A_TickCount
   getSelectedFiles(0, 1)
   foldersSelListArray := new hashtable()
   Loop, % maxFilesIndex + 1
   {
        imgPath := resultedFilesList[A_Index, 1]
        If (InStr(imgPath, "||") || !imgPath)
           Continue

        changeMcursor()
        OutDir := Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1))
        foldersListArray[OutDir] := Round(foldersListArray[OutDir]) + 1
        If markedSelectFile
        {
           If resultedFilesList[A_Index, 2]
              foldersSelListArray[OutDir] := Round(foldersSelListArray[OutDir]) + 1
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
           showTOOLtip("Generating folders list based on the indexed files" etaTime, 0, 0, A_Index/maxFilesIndex)
           prevMSGdisplay := A_TickCount
        }
   }

   counter := 0
   newStaticFoldersListCache := []
   totalLoops := foldersListArray.Count()
   For folderu, Value in foldersListArray
   {
       If !folderu
          Continue

       counter++
       FileGetTime, dirDate, % folderu, M
       selVal := foldersSelListArray[folderu]
       newStaticFoldersListCache[counter] := [folderu, dirDate, Value, selVal]
       ; changeMcursor()
       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalLoops, startOperation)
          showTOOLtip("Collecting folders data" etaTime, 0, 0, A_Index/totalLoops)
          prevMSGdisplay := A_TickCount
       }
   }

   RemoveTooltip()
   iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
   foldersListArray := ""
}

determineTerminateOperation() {
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 200)
     Return 0

  lastInvoked := A_TickCount
  theEnd := interfaceThread.ahkgetvar.mustAbandonCurrentOperations
  If theEnd
     lastLongOperationAbort := A_TickCount
  Return theEnd
}

doStartLongOpDance() {
     startLongOperation := A_TickCount
     imageLoading := runningLongOperation := 1
     interfaceThread.ahkassign("mustAbandonCurrentOperations", 0)
     interfaceThread.ahkassign("lastCloseInvoked", 0)
     interfaceThread.ahkassign("imageLoading", 1)
     interfaceThread.ahkassign("runningLongOperation", 1)
     interfaceThread.ahkassign("executingCanceableOperation", A_TickCount)
     interfaceThread.ahkPostFunction("setTaskbarIconState", "anim")
}

cleanDeadFilesList(dummy:=0) {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (maxFilesIndex>1)
   {
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      startOperation := A_TickCount
      friendlyLabel := (dummy="noFilesCheck") ? "Removing duplicate entries" : "Scanning for missing files"
      friendlyLabel2 := (dummy="noFilesCheck") ? "duplicate entries" : "dead files"
      setWindowTitle(friendlyLabel ", please wait", 1)
      showTOOLtip(friendlyLabel ", please wait")
      prevMSGdisplay := A_TickCount
      doStartLongOpDance()
      If (InStr(backCurrentSLD, "\QPV\viewed-images-history-") && !InStr(backCurrentSLD, "-viewed-images-history-current-session"))
         CleanDeadFilesSeenImagesDB("yesu", StrReplace(backCurrentSLD, "\QPV\", "\"))
      Else If (SLDtypeLoaded=3)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      countTFilez := deadFiles := newFilesIndex := 0
      newFilesList := []
      newMappingList := []
      hash := new hashtable(maxFilesIndex)
      updateMainu := (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:")) ? 1 : 0
      skipDuplicatesCheck := (SLDtypeLoaded=3) ? 1 : 0
      Loop, % maxFilesIndex
      {
            imgPath := resultedFilesList[A_Index, 1]
            If !imgPath
               Continue

            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               skipDuplicatesCheck := 1
               abandonAll := 1
               Break
            }

            If (A_TickCount - prevMSGdisplay>1500)
            {
               etaTime := ETAinfos(countTFilez + deadFiles, maxFilesIndex, startOperation)
               thisPath := PathCompact(SubStr(imgPath, 1, InStr(imgPath, "\", 0, 0) - 1), 45)
               showTOOLtip(friendlyLabel ", please wait`n" thisPath etaTime "`nFound " groupDigits(deadFiles) A_Space friendlyLabel2, 0, 0, (countTFilez+deadFiles)/maxFilesIndex)
               prevMSGdisplay := A_TickCount
            }

            If (skipDuplicatesCheck!=1)
            {
               z := Format("{:L}", imgPath)
               w := hash[z]
            }

            If ((w!=1 || skipDuplicatesCheck=1) && !InStr(imgPath, "||"))
            {
               If (skipDuplicatesCheck!=1 && w!=1)
                  hash[z] := 1

               If (dummy="noFilesCheck")
                  okayu := 1
               Else
                  okayu := (abandonAll=1) ? -2 : FileRexists(imgPath)

               If (okayu=-2 || okayu=1)
               {
                  countTFilez++
                  newFilesList[countTFilez] := resultedFilesList[A_Index]
                  If (updateMainu=1)
                     newMappingList[countTFilez] := filteredMap2mainList[A_Index]
                  Continue
               } Else deadFiles++
            } Else deadFiles++

            If (SLDtypeLoaded=3)
               deleteSQLdbEntry(StrReplace(imgPath, "||"), resultedFilesList[A_Index, 12])

            If (updateMainu=1)
               updateMainUnfilteredList(A_Index, 1, "")

            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               skipDuplicatesCheck := 1
               abandonAll := 1
               Break
            }
      }

      hash := ""
      If (abandonAll!=1)
      {
         If deadFiles
            currentFilesListModified := 1

         resultedFilesList := []
         resultedFilesList := newFilesList.Clone()
         maxFilesIndex := countTFilez
         newFilesList := []
         filteredMap2mainList := []
         If (updateMainu=1)
            filteredMap2mainList := newMappingList.Clone()

         newMappingList := []
         GenerateRandyList()
      }

      If (SLDtypeLoaded=3)
      {
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            throwSQLqueryDBerror(A_ThisFunc)
      }

      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(deadFiles) " index entries were removed until now" etaTime)
      Else
         showTOOLtip(groupDigits(deadFiles) " index entries removed" etaTime)

      If (maxFilesIndex<1 && StrLen(filesFilter)>1)
      {
         remFilesListFilter("simple")
      } Else If (maxFilesIndex<1 && StrLen(filesFilter)<2)
      {
         ForceRefreshNowThumbsList()
         CurrentSLD := backCurrentSLD
         handleEmptyFilesList(backCurrentSLD, "", 1)
         Return
      }

      ForceRefreshNowThumbsList()
      getSelectedFiles(0, 1)
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      CurrentSLD := backCurrentSLD
      currentFileIndex := clampInRange(currentFileIndex, 1, maxFilesIndex)
      dummyTimerDelayiedImageDisplay(50)
      ; RandomPicture()
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

handleEmptyFilesList(thisSLD, extraInfo:="", modus:=0){
   FadeMainWindow()
   SoundBeep, 300, 100
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
   foldersCount := (DynamicFoldersList, "`n")
   If (modus=1)
      bonusBtn := "|Re&generate list"
   Else If (modus=2)
      bonusBtn := "|&Ignore"

   showButtons := (foldersCount>1) || ((RegExMatch(thisSLD, sldsPattern) && FileExist(thisSLD)) || FolderExist(thisSLD) || InStr(thisSLD, "\QPV\favourite-images-list.SLD")) ? "&Begin from scratch|&Reload current list" bonusBtn : 0
   If showButtons
      info := "`n`nCurrent files list:`n" thisSLD

   msgResult := msgBoxWrapper(appTitle ": WARNING", "No files left in the index of " appTitle ", please load a files list or folder." info extraInfo, showButtons, 0, "info")
   If InStr(msgResult, "reload")
   {
      CurrentSLD := thisSLD
      currentFilesListModified := 0
      RefreshFilesList()
   } Else If InStr(msgResult, "ignore")
   {
      Sleep, 1
      Return "ignore"
   } Else If InStr(msgResult, "regenerate")
   {
      SetTimer, RegenerateEntireList, -150
   } Else If InStr(msgResult, "scratch")
   {
      currentFilesListModified := 0
      ; ToggleThumbsMode()
      ; FadeMainWindow()
      closeDocuments()
      ; resetMainWin2Welcome()
   }
}

removeFilesListFavouritedImages() {
   removeFilesListSeenImages("faves")
}

removeFilesListSeenImages(modus:=0) {
   ; Critical, on
   Static hasAskedFilter := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   countSeen := 0
   friendlyLabel := (modus="faves") ? "favourite" : "already seen"
   WnoFilesCheck := (noFilesCheck=2) ? 2 : 0
   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and " friendlyLabel " images will be removed from the files list")
         Return

      If (StrLen(filesFilter)>1 && hasAskedFilter=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Remove " friendlyLabel " images from index", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nOnly the files matched by current filter will be scanned.`n`nTo scan all the image files from the index, deactivcate the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel" || InStr(msgResult, "win_close"))
            Return
         Else hasAskedFilter := 1
      }

      remFromDb := 1
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setWindowTitle("Removing " friendlyLabel " images, please wait", 1)
      showTOOLtip("Removing " friendlyLabel " images`nGathering data, please wait")
      setImageLoading()
      If (modus="faves")
         seenEntries := retrieveFavesAsArray(totalSeenIMGs)
      Else
         seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)

      If (totalSeenIMGs<3)
      {
         seenEntries := ""
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         CurrentSLD := backCurrentSLD
         If (SLDtypeLoaded=3)
         {
            If !activeSQLdb.Exec("COMMIT TRANSACTION;")
               throwSQLqueryDBerror(A_ThisFunc)
         }
         dummyTimerDelayiedImageDisplay(50)
         etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
         showTOOLtip("Finished removing " friendlyLabel " images`nNo image was removed from the files list" etaTime)
         SetTimer, RemoveTooltip, % -msgDisplayTime//2
         Return
      }

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      showTOOLtip("Removing " friendlyLabel " images, please wait" etaTime)
      doStartLongOpDance()
      newArrayu := []
      newFilesIndex := 0
      If (SLDtypeLoaded=3)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      Loop, % maxFilesIndex + 1
      {
          r := getIDimage(A_Index)
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Checking for " friendlyLabel " images, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          If (seenEntries[Format("{:L}", r)]=1)
          {
             If (SLDtypeLoaded=3 && remFromDb=1)
                deleteSQLdbEntry(r, resultedFilesList[A_Index, 12])

             If StrLen(filesFilter)>1
                updateMainUnfilteredList(A_Index, 1, "")

             countSeen++
             Continue
          }

          newFilesIndex++
          newArrayu[newFilesIndex] := resultedFilesList[A_Index]
          If resultedFilesList[A_Index, 2]
             selectedFiles++

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (!activeSQLdb.Exec("COMMIT TRANSACTION;") && SLDtypeLoaded=3)
         throwSQLqueryDBerror(A_ThisFunc)

      If (abandonAll=1)
      {
         If (SLDtypeLoaded=3)
            showTOOLtip("Operation aborted. " groupDigits(countSeen) " already removed until now from the database.")
         Else
            showTOOLtip("Operation aborted. Files list left unchanged, no index entries removed.")

         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         newArrayu := ""
         ; dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         Return
      }

      If (newFilesIndex<1)
      {
         friendly := (modus="faves") ? "All images seem to have been added to favourites." : "It seems all the images were viewed."
         showTOOLtip("WARNING: " friendly "`nTherefore, the files list is left unchanged.")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         ; dummyTimerDelayiedImageDisplay(50)
         SetTimer, ResetImgLoadStatus, -150
         Return
      }

      ; renewCurrentFilesList()
      currentFilesListModified := 1
      maxFilesIndex := newFilesIndex
      resultedFilesList := newArrayu.Clone()
      markedSelectFile := selectedFiles
      ForceRefreshNowThumbsList()
      newArrayu := ""
      GenerateRandyList()
      getSelectedFiles(0, 1)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      RandomPicture()
      showDelayedTooltip("Finished removing " friendlyLabel " images`n" groupDigits(countSeen) " images were removed from the files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

SelectFilesFavourited() {
   findFavesInList("faves", "yes")
}

SelectFilesAlreadySeen() {
   findFavesInList("seen", "yes")
}

findFavesInList(modus:=0, doSel:=0) {
   ; Critical, on
   Static hasAskedFilter := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   countSeen := 0
   setImageLoading()
   friendlyLabel := (modus="faves") ? "favourite" : "already seen"
   friendly2 := (modus="faves") ? "added to favourites" : "seen"
   WnoFilesCheck := (noFilesCheck=2) ? 2 : 0
   If (maxFilesIndex>1)
   {
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setImageLoading()
      showTOOLtip("Marking files already " friendly2 "`nGathering data, please wait")
      If (modus="seen")
      {
            seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)
         idIndex := 3
      } Else
      {
         seenEntries := retrieveFavesAsArray(totalSeenIMGs)
         idIndex := 5
      }

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      doStartLongOpDance()
      Loop, % maxFilesIndex + 1
      {
          r := getIDimage(A_Index)
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Identifying files already " friendly2 "`nGathering data, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          If (seenEntries[Format("{:L}", r)]=1)
          {
             If StrLen(filesFilter)>1
                updateMainUnfilteredList(A_Index, idIndex, 1)

             resultedFilesList[A_Index, idIndex] := 1
             If (doSel="yes")
                resultedFilesList[A_Index, 2] := 1
             countSeen++
          } Else
          {
             If StrLen(filesFilter)>1
                updateMainUnfilteredList(A_Index, idIndex, 0)
             resultedFilesList[A_Index, idIndex] := 0
          }

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (abandonAll=1)
      {
         showTOOLtip("Operation aborted. " groupDigits(countSeen) " already marked until now")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         ForceRefreshNowThumbsList()
         ; dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         dummyTimerDelayiedImageDisplay(100)
         Return
      }

      ; renewCurrentFilesList()
      ForceRefreshNowThumbsList()
      GenerateRandyList()
      updateFilesSelectionInfos()
      dummyTimerDelayiedImageDisplay(100)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      dummyTimerDelayiedImageDisplay(100)
      If (modus="seen")
         showDelayedTooltip("Finished identifying already seen images`n" groupDigits(countSeen) " images were identified in this files list" etaTime)
      Else
         showDelayedTooltip("Finished identifying favourited images`n" groupDigits(countSeen) " images were identified in this files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

retrieveAlreadySeenImageFromCurrentList() {
   ; Critical, on

   If (slideShowRunning=1)
      ToggleSlideShowu()

   initSeenImagesListDB()
   If (sqlFailedInit=1)
   {
      showTOOLtip("ERROR: Failed to initialize the SQL database engine.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 0
   }

   If (userFilterDoString=1)
   {
      If (userFilterStringPos=4 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)" UsrEditFilter
      Else If (userFilterStringPos=3 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")$"
      Else If (userFilterStringPos=2 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)^(" JEE_StrRegExLiteral(UsrEditFilter) ")"
      Else If (UsrEditFilter!="")
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")"
   }

   If (maxFilesIndex>1)
   {
      friendly2 := (userFilterInvertThis=1) ? "never seen" : "already seen"
      If askAboutFileSave(" and the " friendly2 " images list, from the current list, will be retrieved")
         Return

      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      showTOOLtip("Retrieving " friendly2 " images matching this entire files list`nPlease wait")
      setImageLoading()
      seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)
      If (totalSeenIMGs<2)
      {
         userFilterDoString := 0
         userFilterProperty := 1
         filesFilter := ""
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         CurrentSLD := backCurrentSLD
         dummyTimerDelayiedImageDisplay(50)
         etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
         showTOOLtip("No records found matching the criteria" etaTime)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If (StrLen(filesFilter)>1) ; && filesFilter!="||Already-Seen-Images||") I do not know why i had this extra condition...
         remFilesListFilter("simple")

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      doStartLongOpDance()
      newFilesList := []
      newMappingList := []
      countSeen := selectedFiles := newFilesIndex := 0
      Loop, % maxFilesIndex + 1
      {
          r := resultedFilesList[A_Index, 1]
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Checking for " friendly2 " images, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          zuza := seenEntries[Format("{:L}", r)]
          If (userFilterInvertThis=1)
             zuza := !zuza

          If (zuza=1 && userFilterDoString=1 && thisStringFilter!="")
          {
             If !coreSearchIndex(getIDimage(A_Index), thisStringFilter, userFilterWhat, userFilterStringIsNot)
                zuza := 0
          }

          If (zuza=1)
          {
             newFilesIndex++
             newFilesList[newFilesIndex] := resultedFilesList[A_Index]
             If resultedFilesList[A_Index, 2]
                selectedFiles++
 
             newMappingList[newFilesIndex] := A_Index
             countSeen++
          }

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (abandonAll=1 || countSeen<2)
      {
         If (abandonAll=1)
            showTOOLtip("Operation aborted. Files list left unchanged, no filter applied.")
         Else
            showTOOLtip("No seen images identified. Files list left unchanged, no filter applied.")

         SoundBeep, 300, 100
         userFilterDoString := 0
         userFilterProperty := 1
         filesFilter := ""
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         newFilesList := []
         newMappingList := []
         dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         Return
      }

      ; renewCurrentFilesList()
      filteredMap2mainList := newMappingList.Clone()
      bckpResultedFilesList := resultedFilesList.Clone()
      resultedFilesList := newFilesList.Clone()
      If !filesFilter
         bckpMaxFilesIndex := maxFilesIndex

      maxFilesIndex := newFilesIndex
      markedSelectFile := selectedFiles
      filesFilter := "||Already-Seen-Images||"
      userFilterProperty := 20
      ForceRefreshNowThumbsList()
      newFilesList := []
      newMappingList := []
      GenerateRandyList()
      getSelectedFiles(0, 1)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      RandomPicture()
      showDelayedTooltip("Finished the identification process of " friendly2 " images`n" groupDigits(countSeen) " images were found in the initial files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

extractSQLqueryFromFilter() {
    If InStr(filesFilter, "SQL:query:WHERE")
    {
       extraFilter := StrReplace(filesFilter, "`n", A_Space)
       extraFilter := SubStr(extraFilter, InStr(extraFilter, ":WHERE ") + 1)
       If InStr(extraFilter, " ORDER BY ")
          extraFilter := SubStr(extraFilter, 1, InStr(extraFilter, " ORDER BY "))
       Return extraFilter
    }
}

PanelStateOFsqlNation(){
   If AnyWindowOpen
      BtnCloseWindow()

   backCurrentSLD := CurrentSLD
   CurrentSLD := ""

   setImageLoading()
   showTOOLtip("Gathering database information: total number", 0, 0, 0.1/13)
   totalz := getTotalIMGsSQLdb()
   showTOOLtip("Gathering database information: ignored files", 0, 0, 1/13)
   ignored := getTotalIMGsSQLdb("WHERE isDeleted=1 ")
   showTOOLtip("Gathering database information: file details", 0, 0, 2/13)
   fsize := totalz - getTotalIMGsSQLdb("WHERE ifnull(fsize, '')='' ")
   showTOOLtip("Gathering database information: image details", 0, 0, 3/13)
   imgmegapix := totalz - getTotalIMGsSQLdb("WHERE ifnull(imgmegapix, '')='' ")
   showTOOLtip("Gathering database information: image histograms", 0, 0, 4/13)
   imgmedian := totalz - getTotalIMGsSQLdb("WHERE ifnull(imgmedian, '')='' ")
   showTOOLtip("Gathering database information: pixel data", 0, 0, 5/13)
   pixelzFsmall := totalz - getTotalIMGsSQLdb("WHERE ifnull(pixelzFsmall, '')='' ")
   showTOOLtip("Gathering database information: pixel data (flipped)", 0, 0, 6/13)
   HpixelzFsmall := totalz - getTotalIMGsSQLdb("WHERE ifnull(HpixelzFsmall, '')='' ")
   showTOOLtip("Gathering database information: image hashes", 0, 0, 7/13)
   dHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(dHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes", 0, 0, 8/13)
   pHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(pHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes", 0, 0, 9/13)
   lHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(lHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes (flipped)", 0, 0, 10/13)
   hdHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(hdHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes (flipped)", 0, 0, 11/13)
   hpHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(hpHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes (flipped)", 0, 0, 12/13)
   hlHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(hlHash, '')='' ")

   showTOOLtip("Gathering database information: finishing", 0, 0, 13/13)
   ignored := "Ignored or known deleted files: " groupDigits(ignored) " ( " Round(ignored / totalz * 100, 2) "% )"
   fsize := "File details: " groupDigits(fsize) " ( " Round(fsize / totalz * 100, 2) "% )"
   imgmegapix := "Image details: " groupDigits(imgmegapix) " ( " Round(imgmegapix / totalz * 100, 2) "% )"
   imgmedian := "Image histogram details: " groupDigits(imgmedian) " ( " Round(imgmedian / totalz * 100, 2) "% )"
   pixelzFsmall := "Pixels data (8x8, 32x32): " groupDigits(pixelzFsmall) " ( " Round(pixelzFsmall / totalz * 100, 2) "% )"
   HpixelzFsmall := "Flipped pixels data (8x8, 32x32): " groupDigits(HpixelzFsmall) " ( " Round(HpixelzFsmall / totalz * 100, 2) "% )"
   dHash := " `nImage hashes:`ndHash (8x8): " groupDigits(dHash) " ( " Round(dHash / totalz * 100, 2) "% )"
   pHash := "pHash (32x32): " groupDigits(pHash) " ( " Round(pHash / totalz * 100, 2) "% )"
   lHash := "lHash (8x8): " groupDigits(lHash) " ( " Round(lHash / totalz * 100, 2) "% )"
   hdHash := " `ndHash (8x8, flipped): " groupDigits(hdHash) " ( " Round(hdHash / totalz * 100, 2) "% )"
   hpHash := "pHash (32x32, flipped): " groupDigits(hpHash) " ( " Round(hpHash / totalz * 100, 2) "% )"
   hlHash := "lHash (8x8, flipped): " groupDigits(hlHash) " ( " Round(hlHash / totalz * 100, 2) "% )"
   SetTimer, RemoveTooltip, -150
   SetTimer, ResetImgLoadStatus, -50
   CurrentSLD := backCurrentSLD
   infou := (dbVersion!=dbExpectedVersion) ? " (outdated)" : ""
   msgu := "Database version: " dbVersion infou "`nTotal indexed files: " groupDigits(totalz) "`n" ignored "`n" fsize "`n" imgmegapix "`n" imgmedian "`n" pixelzFsmall "`n" HpixelzFsmall "`n" dHash "`n" pHash "`n" lHash "`n" hdHash "`n" hpHash "`n" hlHash 
   widthu := (PrefsLargeFonts=1) ? 1150 : 660
   msgResult := msgBoxWrapper("Database overview: " appTitle, "This is an overview of how much data was collected pertaining to the indexed files.`n`n" msgu, "&Back|C&lose", 1, 0, 0, 0, "", "", 0, 0, widthu)
   If InStr(msgResult, "back")
      PanelWrapperFilesStats()
}

collectSQLFileInfosNow(scu, modus, asku, doFilterExtra:=1, showInfos:=1, stringu:=0, mustNotHave:=0, strPosu:=0, whatu:=0) {
   Static noQuestion := 0
   If (asku=1 && noQuestion=1)
   {
      addJournalEntry(A_ThisFunc "(): user chose to never be asked to collect data in this session.")
      Return 0
   }

   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   If (doFilterExtra=1)
   {
      extraFilter := extractSQLqueryFromFilter()
   } Else If (doFilterExtra=2 && stringu)
   {
      stringu := processSQLsearchIndexString(stringu, strPosu, whatu)
      extraFilter := (mustNotHave=1) ? " WHERE " whatu " NOT LIKE '" stringu "'" : " WHERE " whatu " LIKE '" stringu "'"
   }

   friendly := extraFilter ? "`nCurrent files list filter:`n" extraFilter : ""
   ; If showInfos
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait" friendly)

   If RegExMatch(scu, "i)(imgmedian|imgavg|imghpeak|imghlow|imghmode|imghminu|imghrange|imghrms|lHash|dHash|pHash|pixelzFsmall|pixelzFbig)")
      adaptedSortCriteria := 3
   Else If RegExMatch(scu, "i)(imgmegapix|imgdpi|imgwidth|imgframes|imgpixfmt|imgheight|imgwhratio)")
      adaptedSortCriteria := 2
   Else If RegExMatch(scu, "i)(fcreated|fmodified|fsize|kbfsize)")
      adaptedSortCriteria := 1
   Else
      adaptedSortCriteria := 0

   ; MsgBox, % scu "=" extraFilter
   failedFiles := failedSQLfiles := 0
   If adaptedSortCriteria
   {
      addJournalEntry("Must collect files data in mode: " adaptedSortCriteria " | " scu)
      If !getMaxRowIDsqlDB()
      {
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      thisWhere := extraFilter ? extraFilter " AND ifnull(" scu ", '')='' AND isDeleted=0" : "WHERE ifnull(" scu ", '')='' AND isDeleted=0"
      SQLstr := "SELECT imgidu, fullPath FROM images " thisWhere " ORDER BY fullPath;"
      ; addJournalEntry(SQLstr)
      If !activeSQLdb.GetTable(SQLstr, RecordSet)
      {
         throwSQLqueryDBerror(A_ThisFunc)
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      failedFiles := countTFilez := 0
      filesToBeSorted := RecordSet.RowCount
      thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
      alreadySorted := thisMaxCount - filesToBeSorted
      o_noQuestion := noQuestion
      If (alreadySorted<5)
         noQuestion := 1

      ; MsgBox, % strPosu "=" whatu "`n" SQLstr 
      zEffect := (adaptedSortCriteria=3 && filesToBeSorted>0) ? Gdip_CreateEffect(6, 0, -100, 0) : 0
      If (asku=1 && noQuestion=0 && filesToBeSorted>10)
      {
         thisFriendly := (SLDtypeLoaded=3) ? "`n`nThe data will be automatically cached in the database and you can stop and resume this process at anytime." : ""
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected to perform an operation that relies on collected file and image details. " appTitle " needs to scan " groupDigits(filesToBeSorted) " out of " groupDigits(thisMaxCount) " files. By refusing to the collect data, the operation you chose (sort, filter, generate statistics or find duplicates) will likely give incomplete or erroneous results." thisFriendly, "Collect &data now|&Continue with incomplete data", 0, "question", "&Do not collect file data and never ask again in this session", 0)

         If (InStr(msgResult.btn, "incomplete") || msgResult.Check=1)
         {
            noQuestion := msgResult.Check
            CurrentSLD := backCurrentSLD
            SetTimer, RemoveTooltip, % -msgDisplayTime
            SetTimer, ResetImgLoadStatus, -200
            Return 0
         }
      } Else o_noQuestion := noQuestion

      If (filesToBeSorted>0)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      prevMSGdisplay := A_TickCount
      prevSaveData := A_TickCount
      Loop, % RecordSet.RowCount
      {
          Row := RecordSet.Rows[A_Index]
          If Row[2]
          {
             okay := rs := 1
             countTFilez++
             fInfos := GetFileAttributesEx(Row[2])
             If (!fInfos.size || fInfos.size<3)
             {
                failedFiles++
                okay := 0
             }

             If (adaptedSortCriteria=1 && okay=1)
             {
                ; file properties
                rs := updateSQLdbEntryFileInfos(Row[2], fInfos, Row[1])
             } Else If (adaptedSortCriteria=2 && okay=1)
             {
                ; image properties and file properties
                objul := GetCachableImgFileDetails(Row[2], Row[1], 0, 1)
                If IsObject(objul)
                   rs := updateSQLdbEntryImgRes(Row[2], objul, fInfos, Row[1])
                Else
                   failedFiles++
             } Else If (adaptedSortCriteria=3 && okay=1)
             {
                ; gather histogram main points and pixel data
                objul := GetCachableHistogramFile(Row[2], Row[1], 0, 1, 1, 0, zEffect)
                If IsObject(objul[1])
                   rs := updateSQLdbEntryImgHisto(Row[2], objul[1], objul[2], fInfos, Row[1])
                Else
                   failedFiles++
             } Else
                markSQLdbEntryDeleted(Row[1], 1)

             If !rs
                failedSQLfiles++
          }

          If (A_TickCount - prevSaveData>300100)
          {
             prevSaveData := A_TickCount
             If !activeSQLdb.Exec("COMMIT TRANSACTION;")
             {
                SoundBeep 300, 100
                ErrorMsgS := "ERROR: Failed to commit collected data to the SQL database`n" activeSQLdb.ErrorMsg "`n"
             } Else
                activeSQLdb.Exec("BEGIN TRANSACTION;")
          }

          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
             thisPath := PathCompact(SubStr(Row[2], 1, InStr(Row[2], "\", 0, 0) - 1), 45)
             If (failedFiles>0)
                etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"
             If (failedSQLfiles>0)
                etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

             showTOOLtip(ErrorMsgS "Gathering files information, please wait`n" thisPath etaTime, 0, 0, countTFilez / filesToBeSorted)
             prevMSGdisplay := A_TickCount
             If (A_TickCount - prevSaveData>9000)
                ErrorMsgS := ""
          }

          executingCanceableOperation := A_TickCount
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      Gdip_DisposeEffect(zEffect)
      RecordSet.Free()
      If (filesToBeSorted>0)
      {
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            ErrorMsg := "ERROR: failed to commit collected data to the SQL database`n" activeSQLdb.ErrorMsg "`n"
      }
   }

   PopulateIndexFilesStatsInfos("kill")
   CurrentSLD := backCurrentSLD
   someErrors := ""
   If (failedFiles>0)
      someErrors .= "`nFailed to collect data for " groupDigits(failedFiles) " files"
   If (failedSQLfiles>0)
      someErrors .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      If (modus=1)
         showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone "`nFiles list not sorted, because data collection did not complete.")
      Else
         showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   If (modus!=1 && filesToBeSorted>1)
   {
      showTOOLtip(ErrorMsg "Finished collecting data for " groupDigits(filesToBeSorted) " files`nFor " groupDigits(alreadySorted) " files the data was already collected" someErrors)
      SoundBeep 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
   } Else
      addJournalEntry(ErrorMsg "Finished collecting data for " groupDigits(filesToBeSorted) " files`nFor " groupDigits(alreadySorted) " files the data was already collected" someErrors)

   Return 0
}

calcPHashAlgo(givenArray, size:=32, compareMethod:=1) {
   ; givenArray is the pixels fingerprint
   ; calculte DCT for rows
   trow := [] ; current/this row
   rows := []
   x := y := 0
   Loop, % size ; y
   {
      trow := []
      y := A_Index - 1
      Loop, % size ; x
         trow[A_Index - 1] := givenArray[A_Index - 1 + size*y]

      rows[y] := calculateDCT(trow.Clone(), size)
   }

   ; calculte DCT for columns
   x := y := 0
   matrix := []
   col  := []
   Loop, % size
   {
      col := []
      x := A_Index - 1
      Loop, % size
      {
          y := A_Index - 1
          col[y] := rows[y, x]
      }
      matrix[x] := calculateDCT(col.Clone(), size)
   }

   ; extract the top 8x8 pixels from the DCT matrix
   x := y := thisIndex := 0
   fpexels := []
   Loop, 8
   {
      y := A_Index - 1
      Loop, 8
      {
          If (matrix[y, A_Index - 1]!="")
          {
             thisIndex++
             fpexels[thisIndex] := matrix[y, A_Index - 1]
          }
      }
   }

   ; Calculate hash
   bits := ""
   compareTerm := calcArrayAvgMedian(fpexels, compareMethod, thisIndex)
   ; fnOutputDebug("ahk DCT compareTerm=" compareTerm "|" thisIndex) ; "=fpexels" printArrayStr(fpexels)
   Loop, % thisIndex
       bits .= (fpexels[A_Index] > compareTerm) ? 1 : 0

   return bits
}

calcDLLpHashAlgo(arrayChars, ByRef givenArray, modus) {
    ; givenArray holds the 32x32 image pixels, grayscale
    static runs := 0
    ; stringu := ""
    Loop, % arrayChars.Count() ; 1024 ; 32*32
    ; {
    ;     stringu .= Ord(arrayChars[A_Index]) - 161 ","
        NumPut(arrayChars[A_Index], givenArray, A_Index - 1, "char")
    ; }
    ; runs++
    ; FileAppend, % Trim(stringu, ","), % mainCompiledPath "\lib\gray-imgs-" runs ".txt"

    thisFunc := (A_PtrSize=8) ? "calcPHashAlgo" : "_calcPHashAlgo@12"
    r := DllCall(whichMainDLL "\" thisFunc, "UPtr", &givenArray, "uint", 32, "Int", modus, "INT64")
    if (r!="")
    {
       hashu := ConvertBase(10, 16, r)
       ; hashu := ""
       ; Loop, 64
          ; hashu .= NumGet(resultsArray, A_Index - 1, "char")
       ; fnOutputDebug("phash=" hashu)
    }
    return hashu
}

calcArrayAvgMedian(o_givenArray, modus, size) {
    if (modus=1) ; median
    {
        thisCount := size / 2
        givenArray := numericSortArray(o_givenArray)
        if (thisCount=Round(thisCount))
        {
            value := givenArray[Round(thisCount) - 1] + givenArray[Round(thisCount / 2)]
            return (value / 2)
        }
        return givenArray[Round(thisCount)]
    } else
    {
        ; Calculate the average value from top 8x8 pixels, except for the first one.
        thisSum := 0
        Loop, % size
        {
           ; If (A_Index>1)
              thisSum += o_givenArray[A_Index]
        }

        return (thisSum / size)
    }
}

numericSortArray(givenArray, forMode:=0) {
   listu := printArrayStr(givenArray, "|", forMode)
   Sort, listu, ND|
   newArray := StrSplit(Trim(listu, "|"), "|")
   Return newArray
}

calculateDCT(matrix, size) {
     Static hasRan := 0, pi := 3.141592653
          , z := 0.70710678 ; 1 / sqrt(2)
          , coeffsArray := []

     transformed := []
     g := (size=32) ? 0.25 : sqrt(2 / size)
     thisIndex := 0

     If (hasRan!=size)
     {
        hasRan := size
        Loop, % size
        {
            i := A_Index - 1
            Loop, % size
            {
                j := A_Index - 1
                thisIndex++
                coeffsArray[thisIndex] := cos(i * pi * (j + 0.5) / size)
            }
        }
        thisIndex := 0
     }

     Loop, % size
     {
         i := A_Index - 1
         sum := 0
         Loop, % size
         {
             j := A_Index - 1
             thisIndex++
             ; sum += matrix[j] * cos(i * pi * (j + 0.5) / size)
             sum += matrix[j] * coeffsArray[thisIndex]
         }

         sum *= g
         if (i=0)
             sum *= z
         
         transformed[i] := sum
         ; fnOutputDebug("ahk matrix[" i "] DCT = " matrix[i])
     }
     ; msgbox, % A_ThisFunc "=" printArrayStr(transformed,,1)
     return transformed
}

calcLhashAlgo(pixArray) {
    ; ToolTip, % RecordSet.RowCount "|" countTFilez "=" whichHashu "==" arrayChars.Count()  , , , 2
    summo := 0
    ; pixArray := []
    linezArray := []
    colsArray := []
    cols := linez := thisIndex := 1
    Loop, % pixArray.Count()
    {
       If (thisIndex>8)
       {
          thisIndex := 1
          linezArray[linez] := summo/8
          ; fnOutputDebug(A_Index "summo[" linez "]=" Round(summo/16))
          summo := 0
          linez++
       }

       ; pixArray[A_Index] := discretizeValue(Ord(arrayChars[A_Index]) - 161, graylevelCompressor)
       col%thisIndex% += pixArray[A_Index]
       summo += pixArray[A_Index]
       thisIndex++
       If (A_Index=64)
       {
          Loop, 8
             colsArray[A_Index] := col%A_Index%/8
       }
    }

    hashu := ""
    allIndex := 0
    Loop, 8
    {
       thisIndex := 0
       mainIndexu := A_Index
       Loop, 8
       {
          allIndex++
          thisIndex := A_Index
          avg := Round((colsArray[mainIndexu] + linezArray[thisIndex])/2)
          hashu .= pixArray[allIndex] > avg ? 1 : 0
          ; hashu .= (avg>linezArray[mainIndexu, 17]) ? 1 : 0
          ; fnOutputDebug("avg[" mainIndexu ", " thisIndex "]=" avg)
       }
    }

    Return hashu
}

flipImgArray(arrayChars, b) {
   newArray := []
   allIndex := 0
   If (b=0)
   {
      size := 1024
      Loop, % size
      {
         mindex := A_Index 
         Loop, % size
         {
            allIndex++
            thisIndex := mindex*size - A_Index + 1
            newArray[allIndex] := arrayChars[thisIndex]
            ; fnOutputDebug(allIndex "==" thisIndex)
         }
      }
   } Else
   {
      Loop, 8
      {
         mindex := A_Index 
         Loop, 9
         {
            allIndex++
            thisIndex := mindex*8 - A_Index + mindex + 1
            newArray[allIndex] := arrayChars[thisIndex]
            ; fnOutputDebug(allIndex "==" thisIndex)
         }
      }
   }
   Return newArray
}

discretizeValue(valu, levelu) {
   Return (levelu!=1) ? Round(valu/levelu) * levelu : valu
}

processPixArrayCharsAsSTR(ByRef arrayChars) {
   newStr := ""
   newArray := StrSplit(arrayChars)
   If (graylevelCompressor!=1)
   {
      Loop, % newArray.Count()
          newStr .= discretizeValue(Ord(newArray[A_index]) - 161, graylevelCompressor) "|"
   } Else
   {
      Loop, % newArray.Count()
          newStr .= Ord(newArray[A_index]) - 161 "|"
   }
   Return newStr
}

processPixArrayChars(ByRef arrayChars) {
   newArray := StrSplit(arrayChars)
   If (graylevelCompressor!=1)
   {
      Loop, % newArray.Count()
          newArray[A_Index] := discretizeValue(Ord(newArray[A_Index]) - 161, graylevelCompressor)
   } Else
   {
      Loop, % newArray.Count()
          newArray[A_Index] := Ord(newArray[A_Index]) - 161
   }
   Return newArray
}

generateSQLimageFingerPrintHash(O_whichHashu, flippedModus, stringu, mustHave, strPos, whatu) {
   Static noQuestion := 0, userFriendly := {1:"NONE", 2:"dHash", 3:"pHash", 4:"lHash"}
   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   If (flippedModus=1)
      moreInfo := " (flipped)"

   showTOOLtip("Generating images " userFriendly[o_whichHashu] moreInfo " hashes for " groupDigits(maxFilesIndex) " files, please wait" friendly)
   failedFiles := failedSQLfiles := 0
   If !getMaxRowIDsqlDB()
   {
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   whichHashu := userFriendly[o_whichHashu]
   If (flippedModus=1)
   {
      sH := "h" ; the silent H ;-) - horizontally flipped
      whichHashu := "H" whichHashu
   }

   stringu := processSQLsearchIndexString(stringu, strPosu, whatu)
   If stringu
      containsT := (mustNotHave=1) ? " AND " whatu " NOT LIKE '" stringu "'" : " AND " whatu " LIKE '" stringu "'"

   If (InStr(whichHashu, "dHash") || InStr(whichHashu, "lHash"))
   {
      b := 1
      SQLstr := "SELECT imgidu, " sH "pixelzFsmall, " whichHashu " FROM images WHERE isDeleted=0 AND ifnull(" sH "pixelzFsmall, '')!='' AND " whichHashu " IS NULL" containsT ";"
   } Else If InStr(whichHashu, "pHash")
   {
      b := 0
      SQLstr := "SELECT imgidu, " sH "pixelzFbig, " whichHashu " FROM images WHERE isDeleted=0 AND ifnull(" sH "pixelzFbig, '')!='' AND " whichHashu " IS NULL" containsT ";"
   }

   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   If InStr(whichHashu, "pHash")
      VarSetCapacity(givenArray, 4 * 1024 + 1)

   failedFiles := countTFilez := 0
   filesToBeSorted := RecordSet.RowCount
   If (filesToBeSorted>0)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   ; ToolTip, % RecordSet.RowCount "==" whichHashu "==" SQLstr , , , 2
   ; MsgBox, % RecordSet.RowCount "===" findFlippedDupes "=" SQLstr
   prevMSGdisplay := A_TickCount
   prevSaveData := A_TickCount
   ErrorMsgS := ""
   Loop, % RecordSet.RowCount
   {
       Row := RecordSet.Rows[A_Index]
       If Row[1]
       {
          hashu := ""
          countTFilez++
          arrayChars := processPixArrayChars(Row[2])
          If (o_whichHashu=4) ; lHash
          {
             hashu := calcLhashAlgo(arrayChars)
             hash := ConvertBase(2, 16, hashu)
          } Else If (o_whichHashu=2)
          {
             ; ToolTip, % RecordSet.RowCount "|" countTFilez "=" whichHashu "==" arrayChars.Count()  , , , 2
             Loop, % arrayChars.Count() ; 8x9 = 72
             {
                thisIndex++
                If (thisIndex=9)
                {
                   thisIndex := 0
                   Continue
                }
                hashu .= (arrayChars[A_Index] < arrayChars[A_Index + 1]) ? 1 : 0
             }

             hash := ConvertBase(2, 16, hashu)
          } Else If (o_whichHashu=3)
          {
             hash := calcDLLpHashAlgo(arrayChars, givenArray, userpHashMode + 1)
             ; pixelsArray := []
             ; Loop, % arrayChars.Count() ; 1024 ; 32*32
             ;    pixelsArray[A_Index - 1] := Ord(arrayChars[A_Index]) - 161
             ; hashu := calcPHashAlgo(pixelsArray, 32, userpHashMode + 1)
          }

          if (hash!="")
          {
             SQLstr := "UPDATE images SET " whichHashu "='" hash "' WHERE imgidu=" Row[1] ";"
             If !activeSQLdb.Exec(SQLstr)
                failedSQLfiles++
          }
       }

       If (A_TickCount - prevSaveData>300100)
       {
          prevSaveData := A_TickCount
          If !activeSQLdb.Exec("COMMIT TRANSACTION;")
          {
             SoundBeep 300, 100
             ErrorMsgS := "ERROR: Failed to commit generated hashes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
          } Else
             activeSQLdb.Exec("BEGIN TRANSACTION;")
       }

       If (A_TickCount - prevMSGdisplay>2000)
       {
          etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
          If (failedSQLfiles>0)
             etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

          showTOOLtip(ErrorMsgS "Generating image " whichHashu moreInfo " fingerprints, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
          prevMSGdisplay := A_TickCount
          If (A_TickCount - prevSaveData>9000)
             ErrorMsgS := ""
       }

       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }
   }

   givenArray := resultsArray := ""
   RecordSet.Free()
   If (filesToBeSorted>0)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      {
         ErrorMsg := "ERROR: failed to commit generated hashes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
         addJournalEntry(A_ThisFunc "(): " ErrorMsg)
      }
   }

   someErrors := ""
   If (failedSQLfiles>0)
   {
      someErrors .= "`nFailed to commit to database " groupDigits(failedSQLfiles) " hashes"
      addJournalEntry(A_ThisFunc "(): " someErrors)
   }

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   CurrentSLD := backCurrentSLD
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   ; showTOOLtip(ErrorMsg "Finished generating hashes for " groupDigits(filesToBeSorted) " files" someErrors)
   ; SoundBeep, 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -200
   Return 0
}

BtnCollectFileInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
   {
      collectSQLFileInfosNow("fsize", 0, 0)
      PopulateIndexSQLFilesStatsInfos("kill")
   } Else
   {
      collectFileInfosNow()
      PopulateIndexFilesStatsInfos("kill")
   }

   PanelWrapperFilesStats()
}

BtnCollectImageInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow("imgmegapix", 0, 0)
   Else
      collectImageInfosNow(0, 9, 1)

   PopulateImagesIndexStatsInfos("kill")
   PanelWrapperFilesStats()
}

BtnCollectHistoInfos() {
   scu :=  (dummy="dupes" && findFlippedDupes=1) ? "HpixelzFsmall" : "pixelzFsmall"
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow(scu, 0, 0)
   Else
      collectImageInfosNow(0, 11, 1)

   PopulateImagesIndexStatsInfos("kill")
   openPreviousPanel()
}

dbSortingCached(SortCriterion) {
   If (maxFilesIndex>0)
   {
      If (testIsDupesList() && InStr(resultedFilesList[currentFileIndex, 23], "_"))
      {
         showTOOLtip("WARNING: Files list sorting not allowed.`nThe files list is comprised of duplicate image pairs filtered by Hamming distance.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If AnyWindowOpen
         BtnCloseWindow()

      If askAboutFileSave(" and the files list will be sorted")
         Return

      abandonAll := collectSQLFileInfosNow(SortCriterion, 1, 1)
      If (!getMaxRowIDsqlDB() || abandonAll=1)
      {
         SetTimer, ResetImgLoadStatus, -200
         Return
      }

      sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
      prevFilesSortMode := SortCriterion
      IniSLDBWrite("prevFilesSortMode", SortCriterion)
      setWindowTitle("Sorting files list by " SortCriterion ", please wait", 1)
      If testIsDupesList()
      {
         retrieveDupesByProperties(0, 0, SortCriterion)
         Return
      }

      setImageLoading()
      doStartLongOpDance()
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait")
      extraFilter := extractSQLqueryFromFilter()

      If !RegExMatch(prevFilesSortMode, "i)(fsize|fmodified|fcreated|imgfile|imgfolder)")
         moreCol := StrLen(prevFilesSortMode)>3 ? ", " prevFilesSortMode : ""

      SQLstr := "SELECT imgidu, fullPath" moreCol " FROM images " extraFilter " ORDER BY " SortCriterion sortMode ";"
      addJournalEntry("Database query used to sort the files list: " SQLstr)
      If !InitSQLgetTable(SQLstr, activeSQLdb._Handle, errMsg, Rows, Cols, hTable)
      {
         showTOOLtip("ERROR: Failed to retrieve the sorted images list from the SQL database:`n" errMsg)
         SoundBeep, 300, 100
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      If !Rows
      {
         CurrentSLD := backCurrentSLD
         showTOOLtip("No image records found in the database matching:`n" SQLstr)
         disposeSQLgetTableHandle(hTable)
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      newStaticFoldersListCache := []
      previmgPath := getIDimage(currentFileIndex)
      If StrLen(filesFilter)>1
         backFilesFilter := filesFilter

      showTOOLtip("Generating sorted files list index")
      If (markedSelectFile>1)
      {
         newArray := []
         Loop, % maxFilesIndex
         {
            If (resultedFilesList[A_Index, 2]=1)
            {
               z := resultedFilesList[A_Index, 12]
               newArray[z] := 1
            }
         }
      }

      markedSelectFile := 0
      renewCurrentFilesList()
      performSQLgetTable(Rows, Cols, hTable)
      disposeSQLgetTableHandle(hTable)
      If IsObject(newArray)
      {
         thisIndex := 0
         Loop, % maxFilesIndex
         {
            z := resultedFilesList[A_Index, 12]
            If (newArray[z]=1)
            {
               thisIndex++
               resultedFilesList[A_Index, 2] := 1
            }
         }
         markedSelectFile := thisIndex
      }

      ForceRefreshNowThumbsList()
      If extraFilter
         filesFilter := "SQL:query:" extraFilter

      CurrentSLD := backCurrentSLD
      If (StrLen(backfilesFilter)>1 && !extraFilter && !InStr(backFilesFilter, "SQL:query:JOIN"))
         coreEnableFiltru(backFilesFilter, 1)
      Else
         GenerateRandyList()

      zeitOperation := A_TickCount - startOperation
      addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 25
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      IDshowImage(currentFileIndex)
      ; MsgBox, % maxFilesIndex "=" CurrentSLD
  }
  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}

ActSortName() {
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder, imgfile")
   Else
      SortFilesList("name-entire")
}

ActSortSize() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fsize")
   Else
      SortFilesList("size")
   etaTime := "Elapsed time to sort files list by file size: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortPath() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder")
   Else
      SortFilesList("name-folder")
   etaTime := "Elapsed time to sort files list by folder name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortDupeGroups() {
   startOperation := A_TickCount
   If testIsDupesList()
      retrieveDupesByProperties(0, 0, 1)

   etaTime := "Elapsed time to sort files list by duplicates image group IDs: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortFileName() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfile")
   Else
      SortFilesList("name-file")
   etaTime := "Elapsed time to sort files list by file name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortModified() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fmodified")
   Else
      SortFilesList("modified")
   etaTime := "Elapsed time to sort files list by file modified date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortCreated() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fcreated")
   Else
      SortFilesList("created")
   etaTime := "Elapsed time to sort files list by file created date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortHistogram(modus) {
   Static listuA := {1:"imgavg", 2:"imgmedian", 3:"imghpeak", 4:"imghlow", 5:"imghrange", 6:"imghmode", 7:"imghminu", 8:"imghrms"}
        , listuB := {1:"avg", 2:"median", 3:"peak", 4:"low", 5:"range", 6:"mode", 7:"minu", 8:"hrms"}

   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1 && listuA[modus])
      dbSortingCached(listuA[modus])
   Else If listuB[modus]
      SortFilesList("histogram-" listuB[modus])

   etaTime := "Elapsed time to sort files list by histogram mode " modus ": " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortImageProperties(modus) {
   Static listuA := {1:"imgmegapix", 2:"imgwidth", 3:"imgheight", 4:"imgwhratio", 5:"imgdpi", 6:"imgframes"}
        , listuB := {1:"resolution", 2:"width", 3:"height", 4:"wh-ratio", 5:"dpi", 6:"frames"}

   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1 && listuA[modus])
      dbSortingCached(listuA[modus])
   Else If listuB[modus]
      SortFilesList("image-" listuB[modus])

   etaTime := "Elapsed time to sort files list by image properties mode " modus ": " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

warnXPhistoSort() {
   If isWinXP
   {
      msgBoxWrapper(appTitle ": ERROR", "There is no support in GDI+ for extracting histogram data from images on your system... Therefore, you cannot sort the images by histogram.", 0, 0, "error")
      Return 1
   }
}

SortFilesList(SortCriterion) {
   ; Critical, on
   Static hasAskedFilter := 0

   If AnyWindowOpen
      BtnCloseWindow()

   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and the files list will be sorted")
         Return

      filesToBeSorted := maxFilesIndex
      If (StrLen(filesFilter)>1 && hasAskedFilter=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Sort operation", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nOnly the files matched by current filter will be sorted, not all the files.`n`nTo sort all files, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel" || InStr(msgResult, "win_close"))
            Return
         Else
            hasAskedFilter := 1
      }

      startOperation := A_TickCount
      setImageLoading()
      previmgPath := getIDimage(currentFileIndex)
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait")
      setWindowTitle("Sorting files list, please wait", 1)
      backCurrentSLD := CurrentSLD
      CurrentSLD := filterBehaviour := ""
      newIndex :=  := 0
      If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:"))
      {
         filterBehaviour := 1
         showTOOLtip("Preparing the files list, please wait")
         Loop, %maxFilesIndex%   ; marking index entries to be sorted
             updateMainUnfilteredList(A_Index, 10, 1)

         backfilesFilter := filesFilter
         remFilesListFilter("simple")
         Sleep, 25
         RemoveTooltip()
      }

      newFilesList := []
      prevMSGdisplay := A_TickCount
      adaptedSortCriteria := StrReplace(SortCriterion, "image-")
      adaptedSortCriteria := StrReplace(adaptedSortCriteria, "histogram-")

      sortPages := sortedFiles := 0
      unSortPages := unSortedFiles := 0
      If ((OnSortdoFilesCheck=1 || InStr(SortCriterion, "image-") || InStr(SortCriterion, "histogram-")) && SLDtypeLoaded=3)
      {
         activeSQLdb.Exec("BEGIN TRANSACTION;")
         If InStr(SortCriterion, "histogram")
            zEffect := Gdip_CreateEffect(6, 0, -100, 0)
      }

      countTFilez := 0
      ; doFilesCheck := InStr(SortCriterion, "name-") ? 0 : OnSortdoFilesCheck
      doStartLongOpDance()
      Loop, % maxFilesIndex + 1
      {
          r := resultedFilesList[A_Index, 1]
          If (InStr(r, "||") || !r)
             Continue

          If (filterBehaviour=1 || filterBehaviour=2)
          {
             If !resultedFilesList[A_Index, 10]
             {
                ; building the sorted new files list array; this is the unsorted section
                newIndex++
                newFilesList[newIndex] := resultedFilesList[A_Index]
                Continue
             }
          }

          changeMcursor()
          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
             If (failedFiles>0)
                etaTime .= "`nFailed to sort " groupDigits(failedFiles) " files"

             showTOOLtip("Gathering files information, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
             prevMSGdisplay := A_TickCount
          }

          If (OnSortdoFilesCheck=1)
          {
             If !FileRexists(r)
             {
                resultedFilesList[A_Index, 10] := 0
                If (SLDtypeLoaded=3)
                   deleteSQLdbEntry(r, resultedFilesList[A_Index, 12])

                failedFiles++
                Continue
             }
          }

          If (SortCriterion="size")
          {
             SortBy := QPV_FileGetSizeTime(r, "S", A_Index)
          } Else If (SortCriterion="modified")
          {
             SortBy := QPV_FileGetSizeTime(r, "M", A_Index)
          } Else If (SortCriterion="created")
          {
             SortBy := QPV_FileGetSizeTime(r, "C", A_Index)
          } Else If (SortCriterion="name-folder")
          {
             zPlitPath(r, 1, OutFileName, OutDir)
             SortBy := OutDir
          } Else If (SortCriterion="name-file")
          {
             zPlitPath(r, 1, OutFileName, OutDir)
             SortBy := OutFileName
          } Else If (SortCriterion="name-entire")
          {
             SortBy := r
          } Else If InStr(SortCriterion, "image-")
          {
             If !resultedFilesList[A_Index, 9]
                GetCachableImgFileDetails(r, A_Index)

             If resultedFilesList[A_Index, 13]
             {
                If (SLDtypeLoaded=3)
                   updateSQLdbEntryImgRes(r, 1, 1, resultedFilesList[A_Index, 12], A_Index)

                Switch adaptedSortCriteria
                {
                   Case "resolution":
                      SortBy := resultedFilesList[A_Index, 17]
                   Case "width":
                      SortBy := resultedFilesList[A_Index, 13]
                   Case "height":
                      SortBy := resultedFilesList[A_Index, 14]
                   Case "wh-ratio":
                      SortBy := resultedFilesList[A_Index, 16]
                   Case "dpi":
                      SortBy := resultedFilesList[A_Index, 22]
                   Case "frames":
                      SortBy := resultedFilesList[A_Index, 9]
                }
             } Else
             {
                failedFiles++
                SortBy := 0
             }
          } Else If InStr(SortCriterion, "histogram")
          {
             If !resultedFilesList[A_Index, 11]
                GetCachableHistogramFile(r, A_Index, 0, 0, 1, 0, zEffect)

             If (resultedFilesList[A_Index, 11])
             {
                If (SLDtypeLoaded=3)
                {
                   fInfos := GetFileAttributesEx(r)
                   updateSQLdbEntryImgHisto(r, 1, 1, fInfos, resultedFilesList[A_Index, 12], A_Index)
                }

                Switch adaptedSortCriteria
                {
                   Case "median":
                      SortBy := resultedFilesList[A_Index, 19]
                   Case "avg":
                      SortBy := resultedFilesList[A_Index, 18]
                   Case "peak":
                      SortBy := resultedFilesList[A_Index, 20]
                   Case "low":
                      SortBy := resultedFilesList[A_Index, 21]
                   Case "hrms":
                      SortBy := resultedFilesList[A_Index, 24]
                   Case "range":
                      SortBy := resultedFilesList[A_Index, 25]
                   Case "mode":
                      SortBy := resultedFilesList[A_Index, 26]
                   Case "minu":
                      SortBy := resultedFilesList[A_Index, 27]
                }
             } Else
             {
                failedFiles++
                SortBy := 0
             }
          }

          executingCanceableOperation := A_TickCount
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }

          sortedFiles++
          filesListu%sortPages% .= SortBy "|!\!|" A_Index "`n"
          If (sortedFiles>3102)
          {
             sortedFiles := 0
             sortPages++
          }
      }

      If ((OnSortdoFilesCheck=1 || InStr(SortCriterion, "image-") || InStr(SortCriterion, "histogram-")) && SLDtypeLoaded=3)
      {
         Gdip_DisposeEffect(zEffect)
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            addJournalEntry(A_ThisFunc "() failed to commit transactions to SQL database")
      }

      If (abandonAll=1)
      {
         If errorOccured
            msgInfos := "`nErrors occured. Multi-threading error."
         If (failedFiles && SLDtypeLoaded=3 && OnSortdoFilesCheck=1)
            msgInfos .= "`n" failedFiles " inexistent files were removed from the SQL database index"

         If StrLen(backfilesFilter)>1
         {
            ; rebuilding the filtered files list index, as it was
            thisIndex := 0
            newFilesList := []
            newMappingList := []
            filesFilter := backfilesFilter
            Loop, % maxFilesIndex + 1
            {
               r := resultedFilesList[A_Index, 1]
               If (InStr(r, "||") || !r)
                  Continue

               If resultedFilesList[A_Index, 10]
               {
                  thisIndex++
                  newFilesList[thisIndex] := resultedFilesList[A_Index]
                  newMappingList[thisIndex] := A_Index
                  If resultedFilesList[A_Index, 2]
                     selectedFiles++
               }
            }

            filteredMap2mainList := []
            filteredMap2mainList := newMappingList.Clone()
            newMappingList := []
            bckpResultedFilesList := resultedFilesList.Clone()
            resultedFilesList := newFilesList.Clone()
            newFilesList := []
            bckpMaxFilesIndex := maxFilesIndex
            maxFilesIndex := thisIndex
            markedSelectFile := selectedFiles
         }

         showTOOLtip("Operation aborted. Files list unchanged. " msgInfos)
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         lastLongOperationAbort := A_TickCount
         SetTimer, ResetImgLoadStatus, -50
         Return
      }

      showTOOLtip("Preparing gathered data`n" unSortPages " / " sortPages)
      prevMSGdisplay := A_TickCount
      changeMcursor()
      Loop, % sortPages + 1
      {
         thisIndex := A_Index - 1
         entireString .= filesListu%thisIndex%
      }

      showTOOLtip("Sorting gathered data")
      sortMode := (reverseOrderOnSort=1) ? "R" : ""
      If InStr(SortCriterion, "name-")
         Sort, entireString, %sortMode% D`n
      Else
         Sort, entireString, %sortMode% N D`n

      If (A_TickCount - prevMSGdisplay>1500)
         showTOOLtip("Generating sorted files list index")

      2ndnewIndex := 0
      2ndnewFilesList := []
      newMappingList := []
      histoObj := []
      prevMSGdisplay := A_TickCount
      Loop, Parse, entireString,`n,`r
      {
          If !A_LoopField
             Continue

          2ndnewIndex++
          line := StrSplit(A_LoopField, "|!\!|")
          2ndnewFilesList[2ndnewIndex] := resultedFilesList[line[2]]
          If filterBehaviour
          {
             2ndnewFilesList[2ndnewIndex, 10] := 0
             newMappingList[2ndnewIndex] := A_Index
          }

          If (A_TickCount - prevMSGdisplay>1500)
          {
             changeMcursor()
             etaTime := ETAinfos(A_Index, countTFilez, startOperation)
             showTOOLtip("Generating sorted files list index" etaTime, 0, 0, A_Index/countTFilez)
             prevMSGdisplay := A_TickCount
          }
      }

      ; and now build the final files list array with sorted and unsorted sections of the initial array
      finalNewList := []
      Loop, % 2ndnewIndex   ; the sorted section
         finalNewList[A_Index] := 2ndnewFilesList[A_Index]

      If filterBehaviour
      {
         Loop, % newIndex    ; the unsorted section
            finalNewList[A_Index + 2ndnewIndex] := newFilesList[A_Index]

         filteredMap2mainList := newMappingList.Clone()
         bckpResultedFilesList := finalNewList.Clone()
         bckpMaxFilesIndex := newIndex + 2ndnewIndex
      }

      maxFilesIndex := 2ndnewIndex
      resultedFilesList := 2ndnewFilesList.Clone()
      newFilesList := []
      2ndnewFilesList := []
      finalNewList := []
      ForceRefreshNowThumbsList()
      If StrLen(backfilesFilter)>1
         filesFilter := backfilesFilter

      GenerateRandyList()
      entireString := entireNotSortedString := ""
      currentFilesListModified := 1
      zeitOperation := A_TickCount - startOperation
      addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 5
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      If (maxFilesIndex<1 && StrLen(filesFilter)>1)
         remFilesListFilter("simple")
      Else If (maxFilesIndex<1)
         handleEmptyFilesList(CurrentSLD, "", 1)
      Else
         IDshowImage(currentFileIndex)
   }
}

getSelectedFilesListString(maxList, ByRef countTFilez, ByRef filesListu) {
  trenchSize := maxList//systemCores
  countTFilez := 0
  filesListu := []
  selectedFilesArray := []
  showTOOLtip("Preparing workload for multi-threaded processing")

  Loop, % maxFilesIndex
  {
      isSelected := resultedFilesList[A_Index, 2]
      If !isSelected
         Continue

      r := resultedFilesList[A_Index, 1]
      If (InStr(r, "||") || !r)
         Continue

      countTFilez++
      selectedFilesArray[countTFilez] := A_Index "?" r "`n"
  }

  maxList := selectedFilesArray.Count()
  trenchSize := maxList//systemCores
  r := 0
  Loop, % systemCores - 1
  {
      thisIndex := A_Index
      Loop, % trenchSize
      {
          realIndex := trenchSize*(thisIndex - 1) + A_Index
          line := selectedFilesArray[realIndex]
          If !line
             Continue

          filesListu[thisIndex] .= line
      }
  }

  Loop, % maxList - trenchSize*(systemCores - 1)
  {
      realIndex := trenchSize*(systemCores - 1) + A_Index
      line := selectedFilesArray[realIndex]
      If !line
         Continue

      filesListu[systemCores] .= line
  }
}

WorkLoadMultiCoresJpegLL(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-jpegll||" jpegDesiredOperation "=" jpegDoCrop "=" relativeImgSelCoords "=" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  setForceRefreshThumbsFilesIndex(1)
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }
            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to process " groupDigits(failedFiles) " files"
            If (skippedFiles>0)
               etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image files processing, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Performing JPEG lossless operations, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

   Loop, % systemCores
       FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt

   processedFiles := skippedFiles := failedFiles := 0
   Loop, % systemCores
   {
      RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
      filesStatusArr := StrSplit(filesStatus, "/")
      If (filesStatusArr[1]>0)
         processedFiles += filesStatusArr[1]
      If (filesStatusArr[2]>0)
         failedFiles += filesStatusArr[2]
      If (filesStatusArr[3]>0)
         skippedFiles += filesStatusArr[3]
   }

   zeitOperation := A_TickCount - startOperation
   someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
   If (failedFiles>0)
      someErrors .= "`nFailed to process " groupDigits(failedFiles) " files"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"
    
  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. JPEG lossless processing aborted. `n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countFilez) " selected files were processed until now." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  CurrentSLD := backCurrentSLD
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " groupDigits(markedSelectFile) " selected files were processed until now" someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected JPEG files were processed" someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  Return r
}

testProcessExists(pid) {
   If StrLen(pid)<2
      Return 0

   Process, Exist, % pid
   R := (ErrorLevel=pid) ? 1 : 0
   Return R
}

WorkLoadMultiCoresConvertFormat(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-fmtconv"
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := theseFailures := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  theseFailures += filesStatusArr[3]
               If (filesStatusArr[4]>0)
                  skippedFiles += filesStatusArr[4]
            }

            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to convert " groupDigits(failedFiles) " files"
            If (theseFailures>0)
               etaTime .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
            If (skippedFiles>0)
               etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image file formats conversion, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Converting to ." rDesireWriteFMT " format, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := theseFailures := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        theseFailures += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  Loop, Parse, theFinalList,`n,`r
  {
       If StrLen(A_LoopField)>2
       {
          lineArr := StrSplit(A_LoopField, "?")
          thisIndex := lineArr[1]
          imgPath := lineArr[2]
          If (imgPath && thisIndex)
             resultedFilesList[thisIndex, 1] := imgPath
       }
  }

  zeitOperation := A_TickCount - startOperation
  percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFailed to convert " groupDigits(failedFiles) " files"
  If (theseFailures>0)
     someErrors .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
  If (skippedFiles>0)
     someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

  If (fatalError=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     ; RemoveTooltip()
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image file formats conversion aborted.`n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countFilez) " selected files were processed until now." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " markedSelectFile " selected files were converted to ." rDesireWriteFMT " until now" someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were converted to ." rDesireWriteFMT someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  CurrentSLD := backCurrentSLD
  Return r
}

WorkLoadMultiCoresSimpleImgProcessing(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-simpleimgproc||" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2 "=" editingSelectionNow "=" simpleOpRotationAngle
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
         ; sleep, 450
         ; ToolTip, % jobsRunning "//" jobDone "//" threadsCrashed "//" totalEnded , , , 2
         ; ToolTip, % thisThreadStatus " // " isPIDalive , , , 2
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }

            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to process " groupdigits(failedFiles) " files"
            If (skippedFiles>0)
               etaTime .= "`n" groupdigits(skippedFiles) " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image files processing, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Processing image files, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := skippedFiles := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        skippedFiles += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
  zeitOperation := A_TickCount - startOperation
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFailed to process " groupDigits(failedFiles) " files"
  If (skippedFiles>0)
     someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image processing aborted. `n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were processed until now..." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " groupDigits(markedSelectFile) " selected files were processed until now." someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were processed" someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  CurrentSLD := backCurrentSLD
  Return r
}

multiCoresJpegLL(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  jpegOperation := argumentsArray[1]
  mustCrop := argumentsArray[2]
  relativeImgSelCoords := argumentsArray[3]
  imgSelX1 := argumentsArray[4]
  imgSelX2 := argumentsArray[5]
  imgSelY1 := argumentsArray[6]
  imgSelY2 := argumentsArray[7]
  prcSelX1 := argumentsArray[8]
  prcSelX2 := argumentsArray[9]
  prcSelY1 := argumentsArray[10]
  prcSelY2 := argumentsArray[11]
  failedFiles := skippedFiles := countFilez := operationDone := 0
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       If !RegExMatch(imgPath, "i)(.\.(jpeg|jpg|jpe))$")
       {
          skippedFiles++
          Continue
       }

       r := coreJpegLossLessAction(imgPath, jpegOperation, mustCrop)
       If !r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

multiCoresSimpleImgProcessing(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  ReadSettingsImageProcessing()
  imgSelX1 := argumentsArray[1]
  imgSelX2 := argumentsArray[2]
  imgSelY1 := argumentsArray[3]
  imgSelY2 := argumentsArray[4]
  prcSelX1 := argumentsArray[5]
  prcSelX2 := argumentsArray[6]
  prcSelY1 := argumentsArray[7]
  prcSelY2 := argumentsArray[8]
  editingSelectionNow := argumentsArray[9]
  simpleOpRotationAngle := argumentsArray[10]
  skippedFiles := failedFiles := countFilez := operationDone := 0
  thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       imgPath := StrReplace(imgPath, "||")
       If !RegExMatch(imgPath, thisRegEX)
       {
          skippedFiles++
          Continue
       }

       zPlitPath(imgPath, 0, OutFileName, OutDir)
       destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
       file2save := destImgPath "\" OutFileName
       If (ResizeUseDestDir=1)
       {
          If (FileExist(file2save) && !FolderExist(file2save))
             file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)
       }

       If !file2save
       {
          skippedFiles++
          Continue
       }

       r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
       If r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

ReadSettingsFormatConvert() {
    coreReadSettingsImageProcessing(0)
}

ReadSettingsImageProcessing() {
    coreReadSettingsImageProcessing(0)
}

coreReadSettingsImageProcessing(act) {
    RegAction(act, "OnConvertKeepOriginals",, 1)
    RegAction(act, "PreserveDateTimeOnSave",, 1)
    RegAction(act, "ResizeApplyEffects",, 1)
    RegAction(act, "ResizeCropAfterRotation",, 1)
    RegAction(act, "ResizeDestFolder",, 6)
    RegAction(act, "ResizeInPercentage",, 1)
    RegAction(act, "ResizeKeepAratio",, 1)
    RegAction(act, "ResizeMustPerform",, 1)
    RegAction(act, "ResizeQualityHigh",, 1)
    RegAction(act, "ResizeRotationUser",, 2, 0, 359)
    RegAction(act, "ResizeUseDestDir",, 1)
    RegAction(act, "ResizeWithCrop",, 1)
    RegAction(act, "SimpleOperationsDoCrop",, 1)
    RegAction(act, "SimpleOperationsFlipH",, 1)
    RegAction(act, "SimpleOperationsFlipV",, 1)
    RegAction(act, "SimpleOperationsRotateAngle",, 2, 1, 4)
    RegAction(act, "SimpleOperationsScaleXimgFactor",, 2, 1, 32500)
    RegAction(act, "SimpleOperationsScaleYimgFactor",, 2, 1, 32000)
    RegAction(act, "userActionConflictingFile",, 2, 1, 3)
    RegAction(act, "userDesireWriteFMT",, 2, 1, 16)
    RegAction(act, "userJpegQuality",, 2, 1, 100)
    IniAction(act, "userHQraw", "General", 1)
    If (act=0)
    {
       cleanResizeUserOptionsVars()
       rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
    }
}

multiCoresFormatConvert(coreThread, filesList) {
  resultsList := ""
  failedFiles := theseFailures := countFilez := operationDone := 0
  ; FileRead, filesList, %thumbsCacheFolder%\tempList%coreThread%.txt
  ReadSettingsFormatConvert()
  initFIMGmodule()
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

      If (RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") || InStr(imgPath, "||") || !imgPath)
      {
         skippedFiles++
         Continue
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT

      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         countFilez++

      wasSucces := r ? 0 : 1
      If (OnConvertKeepOriginals!=1 && !r)
      {
         FileSetAttrib, -R, %imgPath%
         Sleep, 2
         FileRecycle, %imgPath%
         If ErrorLevel
            theseFailures++

         If (wasSucces=1)
            resultsList .= lineArr[1] "?" file2save "`n"
      }

      RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   }

   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   If resultsList
      Try FileAppend, % resultsList, %thumbsCacheFolder%\tempList%coreThread%.txt, UTF-16
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

readSlideSettings(readThisFile, act) {
     IniAction(act, "allowGIFsPlayEntirely", "General", 1,0,0,, readThisFile)
     IniAction(act, "ambiTexBrushSize", "General", 2, 25, 950,, readThisFile)
     IniAction(act, "animGIFsSupport", "General", 1,0,0,, readThisFile)
     IniAction(act, "UserGIFsDelayu", "General", 2,-300,300,, readThisFile)
     IniAction(act, "autoAdjustMode", "General", 2,1,3,, readThisFile)
     IniAction(act, "autoPlaySlidesAudio", "General", 1,0,0,, readThisFile)
     IniAction(act, "autoPlaySNDs", "General", 1,0,0,, readThisFile)
     IniAction(act, "borderAroundImage", "General", 1,0,0,, readThisFile)
     IniAction(act, "bwDithering", "General", 1,0,0,, readThisFile)
     IniAction(act, "chnBdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "chnGdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "chnRdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "ColorDepthDithering", "General", 1,0,0,, readThisFile)
     IniAction(act, "doSatAdjusts", "General", 1,0,0,, readThisFile)
     IniAction(act, "doSlidesTransitions", "General", 1,0,0,, readThisFile)
     IniAction(act, "easySlideStoppage", "General", 1,0,0,, readThisFile)
     IniAction(act, "FlipImgH", "General", 1,0,0,, readThisFile)
     IniAction(act, "FlipImgV", "General", 1,0,0,, readThisFile)
     IniAction(act, "GammosAdjust", "General", 2,-25,1,, readThisFile)
     IniAction(act, "GammosGrayAdjust", "General", 2,-25,1,, readThisFile)
     IniAction(act, "hueAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "imageAligned", "General", 2,1,5,, readThisFile)
     IniAction(act, "imgFxMode", "General", 2,1,10,, readThisFile)
     IniAction(act, "IMGresizingMode", "General", 2,1,5,, readThisFile)
     IniAction(act, "imgThreshold", "General", 2,0,1,, readThisFile)
     IniAction(act, "IntensityAlphaChannel", "General", 2,1,30,, readThisFile)
     IniAction(act, "isAlwaysOnTop", "General", 1,0,0,, readThisFile)
     IniAction(act, "isTitleBarVisible", "General", 1,0,0,, readThisFile)
     IniAction(act, "lummyAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "lumosAdjust", "General", 2,0.001,25,, readThisFile)
     IniAction(act, "lumosGrayAdjust", "General", 2,0.001,25,, readThisFile)
     IniAction(act, "mediaSNDvolume", "General", 2,1,100,, readThisFile)
     IniAction(act, "realGammos", "General", 2,0.01,10,, readThisFile)
     IniAction(act, "resetImageViewOnChange", "General", 1,0,0,, readThisFile)
     IniAction(act, "satAdjust", "General", 2,0,3,, readThisFile)
     IniAction(act, "showHUDnavIMG", "General", 1,0,0,, readThisFile)
     IniAction(act, "showImgAnnotations", "General", 1,0,0,, readThisFile)
     IniAction(act, "skipDeadFiles", "General", 1,0,0,, readThisFile)
     IniAction(act, "SLDcacheFilesList", "General", 1,0,0,, readThisFile)
     IniAction(act, "SlideHowMode", "General", 2,1,3,, readThisFile)
     IniAction(act, "slidesFXrandomize", "General", 1,0,0,, readThisFile)
     IniAction(act, "slideShowDelay", "General", 2,90,25000,, readThisFile)
     IniAction(act, "SlidesMusicSong", "General", 0,0,0,, readThisFile)
     IniAction(act, "specialColorFXmode", "General", 2,1,7,, readThisFile)
     IniAction(act, "syncSlideShow2Audios", "General", 1,0,0,, readThisFile)
     IniAction(act, "TouchScreenMode", "General", 1,0,0,, readThisFile)
     IniAction(act, "uiColorCurveFXchannel", "General", 2,1,4,, readThisFile)
     IniAction(act, "uiColorCurveFXmode", "General", 2,1,7,, readThisFile)
     IniAction(act, "usrAdaptiveThreshold", "General", 2,-9500,9500,, readThisFile)
     IniAction(act, "usrColorDepth", "General", 2,0,9,, readThisFile)
     IniAction(act, "usrTextureBGR", "General", 1,0,0,, readThisFile)
     IniAction(act, "vpIMGrotation", "General", 2,0,359,, readThisFile)
     IniAction(act, "WindowBgrColor", "General", 3,0,0,, readThisFile)
     IniAction(act, "zatAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "zoomLevel", "General", 2,0.01,20,, readThisFile)

     If (act=0)
     {
        If (isWinXP=1 || minimizeMemUsage=1)
           doSlidesTransitions := 0

        If (imageAligned!=1)
           imageAligned := 5

        If (scriptInit=1)
           interfaceThread.ahkFunction("updateWindowColor")

        defineColorDepth()
        recalculateThumbsSizes()
    } Else
    {
       IniAction(1, "appVersion", "General", 0,0,0,, readThisFile)
    }
}

writeMainSettingsApp() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 350)
    {
       lastInvoked := A_TickCount
       SetTimer, writeMainSettingsApp, -500
       Return
    }

    readMainSettingsApp(1)
    lastInvoked := A_TickCount
}

readMainSettingsApp(act) {
    EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
    If (thisSystemCores>8)
       thisSystemCores := 3

    readSlideSettings(mainSettingsFile, act)
    IniAction(act, "allowFreeIMGpanning", "General", 1)
    IniAction(act, "allowMultiCoreMode", "General", 1)
    IniAction(act, "allowRecordHistory", "General", 1)
    IniAction(act, "allowUserQuickFileActions", "General", 1)
    IniAction(act, "alwaysOpenwithFIM", "General", 1)
    IniAction(act, "askDeleteFiles", "General", 1)
    IniAction(act, "AutoDownScaleIMGs", "General", 1)
    IniAction(act, "autoRemDeadEntry", "General", 1)
    IniAction(act, "closeEditPanelOnApply", "General", 1)
    IniAction(act, "cmrRAWtoneMapAlgo", "General", 2, 1, 3)
    IniAction(act, "cmrRAWtoneMapParamA", "General", 2, -8, 10)
    IniAction(act, "cmrRAWtoneMapParamB", "General", 2, -8, 10)
    IniAction(act, "cycleFavesOpenIMG", "General", 1)
    IniAction(act, "deleteFileActAfter", "General", 2, 1, 3)
    IniAction(act, "DisplayTimeUser", "General", 2, 1, 99)
    ; IniAction(act, "EllipseSelectMode", "General", 1)
    IniAction(act, "enableThumbsCaching", "General", 1)
    IniAction(act, "OSDfontBolded", "General", 1)
    IniAction(act, "OSDfontItalica", "General", 1)
    IniAction(act, "highlightAlreadySeenImages", "General", 1)
    IniAction(act, "histogramMode", "General", 2, 1, 3)
    IniAction(act, "LimitSelectBoundsImg", "General", 1)
    IniAction(act, "lockZoomLevel", "General", 1)
    IniAction(act, "maxMemThumbsCache", "General", 2, 6, 950)
    IniAction(act, "minimizeMemUsage", "General", 1)
    IniAction(act, "multilineStatusBar", "General", 1)
    IniAction(act, "MustLoadSLDprefs", "General", 1)
    IniAction(act, "mustRecordSeenImgs", "General", 1)
    IniAction(act, "additionalLVrows", "General", 2, 0, 15)
    IniAction(act, "OnSortdoFilesCheck", "General", 1)
    IniAction(act, "OSDbgrColor", "General", 3)
    IniAction(act, "OSDfontSize", "General", 2, 10, 350)
    IniAction(act, "OSDFontName", "General", 5)
    IniAction(act, "OSDtextColor", "General", 3)
    IniAction(act, "PasteFntSize", "General", 2, 10, 350)
    IniAction(act, "PrefsLargeFonts", "General", 1)
    IniAction(act, "prevFileMovePath", "General", 6)
    IniAction(act, "prevFileSavePath", "General", 6)
    IniAction(act, "prevOpenFolderPath", "General", 6)
    IniAction(act, "reverseOrderOnSort", "General", 1)
    IniAction(act, "rotateSelBoundsKeepRatio", "General", 1)
    IniAction(act, "ShowAdvToolbar", "General", 1)
    IniAction(act, "showFilesListMap", "General", 1)
    IniAction(act, "showHistogram", "General", 2, 1, 6)
    IniAction(act, "showInfoBoxHUD", "General", 2, 0, 2)
    IniAction(act, "showMainMenuBar", "General", 1)
    IniAction(act, "showSelectionGrid", "General", 1)
    IniAction(act, "skipSeenImageSlides", "General", 1)
    IniAction(act, "thumbsColumns", "General", 2, 2, 100)
    IniAction(act, "thumbsAratio", "General", 2, 1, 3)
    IniAction(act, "thumbsZoomLevel", "General", 2, 0.35, 3)
    IniAction(act, "thumbsListViewMode", "General", 2, 1, 4)
    IniAction(act, "uiUseDarkMode", "General", 1)
    IniAction(act, "useCachedSLDdata", "General", 1)
    IniAction(act, "userAllowWindowDrag", "General", 1)
    IniAction(act, "userHQraw", "General", 1)
    IniAction(act, "userimgGammaCorrect", "General", 1)
    IniAction(act, "userimgQuality", "General", 1)
    IniAction(act, "userMultiCoresLimit", "General", 2, 8, thisSystemCores)
    IniAction(act, "usrTextAlign", "General", 5)
    IniAction(act, "preventDeleteFromProtectedPath", "General", 1)
    IniAction(act, "protectedFolderPath", "General", 6)
    RegAction(act, "mainWinMaximized",, 1)
    RegAction(act, "mainWinPos",, 5)
    RegAction(act, "mainWinSize",, 5)
    RegAction(act, "HUDnavBoxSize",, 2, 75, 250)

    If (act=0)
    {
       If (isWinXP || A_OSVersion="WIN_7")
          uiUseDarkMode := 0

       If (LimitSelectBoundsImg=1)
          lockSelectionAspectRatio := 1

       If (cmrRAWtoneMapAlgo=1)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, 0, 9.9)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, -8, 8)
       } Else If (cmrRAWtoneMapAlgo=2)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, -8, 8)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, 0, 1)
       } Else If (cmrRAWtoneMapAlgo=3)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, 0, 1)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, 0, 1)
       }

       If !InStr(mainWinPos, "|")
          mainWinPos := ""
       If !InStr(mainWinSize, "|")
          mainWinSize := ""

       imgQuality := (userimgQuality=1) ? 6 : 5
       isTxtAlignOkay := (usrTextAlign="Left" || usrTextAlign="Right" || usrTextAlign="Center") ? 1 : 0
       If !isTxtAlignOkay
          usrTextAlign := "Left"

       If !prevOpenFolderPath
          prevOpenFolderPath := A_WorkingDir

       If !ResizeDestFolder
       {
          If prevOpenFolderPath
             ResizeDestFolder := prevOpenFolderPath
          Else
             ResizeDestFolder := A_WorkingDir
       }

       realSystemCores := userMultiCoresLimit
       SetVolume(mediaSNDvolume)
       calcHUDsize()
       msgDisplayTime := DisplayTimeUser*1000
    }
    setLVrowsCount()
}

calcHUDsize() {
   imgHUDbaseUnit := (PrefsLargeFonts=1) ? Round(OSDfontSize*2.5) : Round(OSDfontSize*2)
}

writeSlideSettings(file2save) {
    readSlideSettings(file2save, 1)
    ; throwMSGwriteError()
}

readRecentEntries(forceNewList:=0, doFiltering:=1) {
   Static lastInvoked := 1, historyList

   If (StrLen(forceNewList)>4)
   {
      historyList := forceNewList
      lastInvoked := A_TickCount
      Return
   }

   If (StrLen(historyList)>4 && (A_TickCount - lastInvoked<5500))
   {
      lastInvoked := A_TickCount
      Return historyList
   }

   historyList := ""
   Loop, 10
   {
       IniRead, newEntry, % mainRecentsFile, RecentOpen, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>4 && doFiltering=1)
          historyList .= newEntry "`n"
       Else If (doFiltering!=1)
          historyList .= newEntry "`n"
   }
  
   List_MakeUnique(historyList, "`n", 0, 1)
   lastInvoked := A_TickCount
   Return historyList
}

List_MakeUnique(ByRef oList, Delimiter:="`n", Case_Sensitive:=0, keepAsEmpty:=0) {
; By [VxE], removes duplicate entries from a list. Special thanks to SKAN.
; SOURCE: https://autohotkey.com/board/topic/34715-removing-duplicates-from-the-list-without-sorting-it/page-2
; modified by Marius Șucan

   ; VarSetCapacity( New_List, StrLen( List ) )
   New_List := Delimiter
   entriesCount := 0
   Loop, Parse, oList, % Delimiter
   {
      If (keepAsEmpty!=1 && !A_LoopField)
         Continue

      If (!InStr(New_List, Delimiter . A_LoopField . Delimiter, !!Case_Sensitive))
         New_List .= A_LoopField . Delimiter
      Else If (keepAsEmpty=1)
         New_List .= A_Space . Delimiter

      entriesCount++
   }
   oList := SubStr(New_List, 2, -1)
   Return entriesCount
}

readMiniFavesEntries() {
   Static lastInvoked := 1, prevList, prevCall

   fileInfos := GetFileAttributesEx(mainFavesFile)
   thisCall := "zzz" fileInfos.size "=" fileInfos.wTime "=" fileInfos.cTime
   If (thisCall!=prevCall || !prevList)
   {
      FileRead, contentu, % miniFavesFile
      Loop, Parse, contentu, `n, `r
      {
           If RegExMatch(A_LoopField, RegExFilesPattern)
           {
              thisIndex++
              historyList .= A_LoopField "`n"
           }

           If (thisIndex>16)
              Break
      }

      prevList := historyList
      prevCall := thisCall
      ; FileRead, historyList, % mainFavesFile
   } Else historyList := prevList

   lastInvoked := A_TickCount
   Return historyList
}

RecentFilesManager(entry2add) {
  If (StrLen(entry2add)<5 || !allowRecordHistory || userPrivateMode=1)
     Return

  historyList := readRecentEntries()
  historyList := entry2add "`n" historyList
  List_MakeUnique(historyList, "`n", 0, 0)
  Loop, Parse, historyList, `n, `r
  {
      If (A_Index>11)
         Break

      If (StrLen(A_LoopField)<5 || !FileExist(StrReplace(A_LoopField, "|")))
         Continue

      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentOpen, E%countItemz%
      newHistoryList .= A_LoopField "`n"
  }

  readRecentEntries(newHistoryList)
}

ToggleImgFavourites(thisImg:=0, actu:=0, directCall:=0) {
  Static lastInvoked := 1, prevImg, prevRemSpeed := 1
  imgPath := thisImg ? thisImg : getIDimage(currentFileIndex)
  isPipe := InStr(imgPath, "||")
  imgPath := StrReplace(imgPath, "||")
  If (A_TickCount - lastInvoked<550) && (directCall=1 && prevImg=imgPath) || !imgPath
     Return

  If (!FileRexists(imgPath) && actu!="rem")
  {
     showTOOLtip("ERROR: The file seems to not exist.`nYou cannot add to favourites inexistent files")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  resetSlideshowTimer(0, 1)
  prevImg := imgPath
  isFaved := isPipe ? 0 : resultedFilesList[currentFileIndex, 5]
  If (!isFaved && actu!="rem")
  {
     If !userAddedFavesCount
        IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)

     If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
     {
        userAddedFavesCount++
        resultedFilesList[currentFileIndex, 5] := 1
        resultedFilesList[currentFileIndex, 1] := imgPath
        updateMainUnfilteredList(currentFileIndex, 5, 1)
        zPlitPath(imgPath, 0, OutFileName, OutDir)
        If (userPrivateMode=1)
        {
           OutFileName := "*******.***"
           OutDir := "*:\******\*****"
        } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

        IniAction(1, "userAddedFavesCount", "General")
        showTOOLtip("Image ADDED back to favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(userAddedFavesCount), 0, 0, userAddedFavesCount/maxFavesEntries)
        currentFilesListModified := 1
        dummyTimerDelayiedImageDisplay(50)
        lastInvoked := A_TickCount
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If (userAddedFavesCount>maxFavesEntries - 1)
     {
        showTOOLtip("WARNING: You have reached the maximum allowed favourite images: " maxFavesEntries " entries.")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime//2
        Return
     }

     lastInvoked := A_TickCount
     whichFile := (userAddedFavesCount>19) ? mainFavesFile : miniFavesFile
     FileAppend, % imgPath "`n", % whichFile, UTF-8
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list`nThe image was not added to favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     whichFiled := (userAddedFavesCount>19) ? miniFavesFile : mainFavesFile
     If !FileExist(whichFiled)
        FileAppend, % "`n", % whichFiled, UTF-8

     userAddedFavesCount++
     IniAction(1, "userAddedFavesCount", "General")
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     If (userPrivateMode=1)
     {
        OutFileName := "*******.***"
        OutDir := "*:\******\*****"
     } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)
     showTOOLtip("Image ADDED to favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(userAddedFavesCount), 0, 0, userAddedFavesCount/maxFavesEntries)
     resultedFilesList[currentFileIndex, 5] := 1
     updateMainUnfilteredList(currentFileIndex, 5, 1)
     If !thisImg
     {
        resultedFilesList[currentFileIndex, 1] := imgPath
        updateMainUnfilteredList(currentFileIndex, 1, imgPath)
     }

     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  } Else
  {
     If (!thisImg && InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
     {
        If !userAddedFavesCount
           IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)

        userAddedFavesCount--
        resultedFilesList[currentFileIndex, 5] := 0
        resultedFilesList[currentFileIndex, 1] := "||" imgPath
        updateMainUnfilteredList(currentFileIndex, 5, 0)
        zPlitPath(imgPath, 0, OutFileName, OutDir)
        IniAction(1, "userAddedFavesCount", "General")
        If (userPrivateMode=1)
        {
           OutFileName := "*******.***"
           OutDir := "*:\******\*****"
        } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

        showTOOLtip("Image REMOVED from favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(userAddedFavesCount), 0, 0, userAddedFavesCount/maxFavesEntries)
        currentFilesListModified := 1
        dummyTimerDelayiedImageDisplay(50)
        lastInvoked := A_TickCount
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     ToolTip, Please wait...
     startZeit := A_TickCount
     lastInvoked := A_TickCount
     IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)
     FileRead, historyList, % mainFavesFile
     FileRead, miniList, % miniFavesFile
     If ErrorLevel
     {
        Tooltip
        showTOOLtip("Failed to read the favourites list file`nUnable to remove image from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     historyList := StrReplace(miniList, imgPath) "`n" StrReplace(historyList, imgPath)
     hash := new hashtable()
     arrayList := []
     doDeduplication := (prevRemSpeed<765 && userAddedFavesCount<12345) ? 1 : 0
     miniF:= fileOpen(miniFavesFile, "w")
     If IsObject(miniF)
        mainF:= fileOpen(mainFavesFile, "w", "UTF-8")

     If (!IsObject(miniF) || !IsObject(mainF))
     {
        Tooltip
        showTOOLtip("Failed to read and write the favourites list file`nUnable to remove image from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If !thisImg
     {
        resultedFilesList[currentFileIndex, 5] := 0
        If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
           resultedFilesList[currentFileIndex, 1] := "||" imgPath

        updateMainUnfilteredList(currentFileIndex, 5, 0)
     }

     ; ToolTip, % doDeduplication "==" prevRemSpeed , , , 2
     Loop, Parse, historyList,`n,`r
     {
         If (realCount>maxFavesEntries)
            Break

         If !RegExMatch(A_LoopField, RegExFilesPattern)
            Continue

         If (doDeduplication=1)
         {
            z := Format("{:L}", A_LoopField)
            w := hash[z]
         }

         If (w!=1)
         {
            realCount++
            If (doDeduplication=1)
               hash[z] := 1

            lineu := A_LoopField "`n"
            If (realCount<20)
               miniF.Write(lineu)
            Else
               mainF.Write(lineu)
         }
     }

     mainF.Close()
     miniF.Close()
     hash := ""
      ; List_MakeUnique(historyList, "`n", 0, 0)
     userAddedFavesCount := realCount
     IniAction(1, "userAddedFavesCount", "General")
     Tooltip
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list file`nThe image was not succesfully removed from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If (doDeduplication=1)
        prevRemSpeed := A_TickCount - startZeit

     zPlitPath(imgPath, 0, OutFileName, OutDir)
     If (userPrivateMode=1)
     {
        OutFileName := "*******.***"
        OutDir := "*:\******\*****"
     } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

     showTOOLtip("Image REMOVED from favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(realCount), 0, 0, realCount/maxFavesEntries)
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  }

  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

retrieveFavesAsArray(ByRef countItemz) {
    FileRead, historyList, % mainFavesFile
    FileRead, miniList, % miniFavesFile
    historyList := miniList "`n" historyList
    hash := new hashtable(userAddedFavesCount+50)
    Loop, Parse, historyList, `n,`r
    {
       imgu := Trimmer(A_LoopField)
       If (StrLen(imgu)<4 || !RegExMatch(imgu, RegExFilesPattern))
          Continue

       posu := InStr(imgu, ":\", 0, -1)
       If (posu>4)
       {
          oimgu := imgu
          imgu := SubStr(imgu, 1, posu - 2)
          bonus := SubStr(oimgu, posu - 1)
          If (StrLen(bonus)>4 && RegExMatch(bonus, RegExFilesPattern))
             hash[Format("{:L}", bonus)] := 1
       }

       hash[Format("{:L}", imgu)] := 1
    }

    countItemz := hash.Count()
    Return hash
}

retrieveFavesAsList(dummy:=0) {
    If GetKeyState("Ctrl", "P")
       ctrlState := 1

    If askAboutFileSave(". The current files list will be discarded as well")
       Return
 
    If AnyWindowOpen
       BtnCloseWindow()

    If askAboutSlidesListSave()
       Return

    If askAboutFilesSelect("discard it")
       Return

    showTOOLtip("Loading favourites list, please wait")
    FileRead, historyList, % mainFavesFile
    FileRead, miniList, % miniFavesFile
    historyList := miniList "`n" historyList
    thisList := []
    IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)
    doDeduplication := (userAddedFavesCount<12345) ? 1 : 0
    hash := new hashtable(userAddedFavesCount+50)
    If !ctrlState
       ctrlState := (GetKeyState("Ctrl", "P") || userAddedFavesCount<20101) ? 1 : 0

    ; ToolTip, % "f=" userAddedFavesCount , , , 2
    mustRenewList := countItemz := thisIndexu := 0
    ;  realCount := List_MakeUnique(historyList, "`n", 0, 0)
    Loop, Parse, historyList, `n,`r
    {
       imgu := Trimmer(A_LoopField)
       If InStr(imgu, "\\")
          imgu := StrReplace(imgu, "\\", "\")

       If (StrLen(imgu)<4 || !RegExMatch(imgu, RegExFilesPattern))
       {
          If A_LoopField
             mustRenewList := 1
          Continue
       }

       posu := InStr(imgu, ":\", 0, -1)
       If (posu>4)
       {
          oimgu := imgu
          imgu := SubStr(imgu, 1, posu - 2)
          bonus := SubStr(oimgu, posu - 1)
          thisIndexu++
          thisList[thisIndexu] := [bonus]
          thisList[thisIndexu, 5] := 1
       }

       If (doDeduplication=1)
       {
         z := Format("{:L}", imgu)
         w := hash[z]
       }

       If (w!=1)
       {
          thisIndexu++
          thisList[thisIndexu] := [imgu]
          thisList[thisIndexu, 5] := 1
          ; If (ctrlState=1)
          If (doDeduplication=1)
             hash[z] := 1
       } Else mustRenewList := 1
    }

   hash := ""
   If (thisIndexu> maxFavesEntries - 1)
      msgBoxWrapper(appTitle ": WARNING", "Please take note, you have exceeded the limit of favourite image entries: " maxFavesEntries ".", 0, 0, "exclamation")

   userAddedFavesCount := thisIndexu
   IniAction(1, "userAddedFavesCount", "General")
   If (thisIndexu<2)
   {
      showTOOLtip("WARNING: Found insufficient favourite images")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   If (SLDtypeLoaded=3)
   {
      SLDtypeLoaded := 0
      activeSQLdb.CloseDB()
   }

   PopulateIndexFilesStatsInfos("kill")
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := "\QPV\favourite-images-list.SLD"
   resultedFilesList := thisList.Clone()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SLDtypeLoaded := 2
   maxFilesIndex := thisList.Count()
   currentFileIndex := (isNumber(dummy)=1 && dummy>0) ? dummy : clampInRange(maxFilesIndex - 1, 1, maxFilesIndex)
   seenEntries := []
   If (mustRenewList=1 || !miniList)
      renewFavesListBasedOnIndexList()

   currentFilesListModified := 0
   INIaction(0, "SlidesMusicSong", "General")
   INIaction(0, "autoPlaySlidesAudio", "General", 1)
   If (thumbsDisplaying!=1 && !isNumber(dummy))
      MenuDummyToggleThumbsMode()

   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   GenerateRandyList()
   dummyTimerDelayiedImageDisplay(50)
   SetTimer, createGUItoolbar, -100
   SetTimer, TriggerMenuBarUpdate, -90
   showDelayedTooltip("Favourites list loaded`nTotal entries: " groupDigits(maxFilesIndex), 0, 200)
   ; RandomPicture()
}

renewFavesListBasedOnIndexList() {
   ; If StrLen(filesFilter)>1
   ;    Return
   newListu := ""
   realCount := 0
   setImageLoading()
   changeMcursor()
   showTOOLtip("Saving favourites list, please wait")
   If StrLen(filesFilter)>1
   {
      lastInvoked := A_TickCount
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "The current files list has " groupDigits(maxFilesIndex) " images indexed. It is the result of a filter applied on the favourite images list.`n`nPlease confirm you want to save the favourites list as is, filtered. The total of " groupdigits(bckpMaxFilesIndex) " favourited images will no longer be retrievable.", "&Deactivate filter|&Save list|&Cancel", 0, "question")
      If InStr(msgResult, "deactivate")
      {
         MenuRemFilesListFilter()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -150
         Return
      } Else If InStr(msgResult, "save")
      {
         If (A_TickCount - lastInvoked<950)
         {
            showTOOLtip("WARNING: The destructive option was chosen too fast.`nPlease elaborate allow yourself at least one second to read the message box.")
            SoundBeep , 300, 100
            SetTimer, RemoveTooltip, % -msgDisplayTime
            SetTimer, ResetImgLoadStatus, -150
            Return
         }
         Sleep, 100
      } Else
      {
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -150
         Return
      }
   }

   Loop, % maxFilesIndex
   {
       ; isFaved := resultedFilesList[currentFileIndex, 5]
       ; If !isFaved
       ;    Continue

       If (realCount>maxFavesEntries)
          Break

       ; If StrLen(filesFilter)>1
       ;    thisImg := bckpResultedFilesList[filteredMap2mainList[A_Index], 1]
       ; Else
          thisImg := resultedFilesList[A_Index, 1]

       If (StrLen(thisImg)>3 && !InStr(thisImg, "||"))
       {
          realCount++
          If (A_Index<20)
             miniList .= thisImg "`n"
          Else
             newListu .= thisImg "`n"
       }
   }

   FileDelete, % mainFavesFile
   FileDelete, % miniFavesFile
   Sleep, 150
   ; realCount := List_MakeUnique(newListu, "`n", 0, 0)
   userAddedFavesCount := realCount
   IniAction(1, "userAddedFavesCount", "General")
   FileAppend, % newListu "`n", % mainFavesFile, UTF-8
   FileAppend, % miniList "`n", % miniFavesFile, UTF-8
   If ErrorLevel
   {
      showTOOLtip("ERROR: Unable to save the favourites list file. Unknown cause.")
      SoundBeep, 300, 100
   } Else
   {
      showTOOLtip("Favourites list saved")
      SoundBeep, 900, 100
   }

   currentFilesListModified := 0
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -150
}

eraseAllFavedIMGs() {
  Static lastInvoked := 1
  lastInvoked := A_TickCount
  msgResult := msgBoxWrapper(appTitle ": Favourites", "Are you sure you want to remove all the entries from the favourites list?", 4, 0, "question")
  If !InStr(msgResult, "yes")
     Return

  If (A_TickCount - lastInvoked<950)
  {
     showTOOLtip("ERROR: User answered the message box too quickly.`nPlease read the message before confirming action.")
     SoundBeep 300, 100
     Return
  }

  FileDelete, % mainFavesFile
  FileDelete, % miniFavesFile
  userAddedFavesCount := 0
  IniAction(1, "userAddedFavesCount", "General")
  showTOOLtip("All entries from the favourites list were removed.")
  SetTimer, RemoveTooltip, % -msgDisplayTime//2
  SetTimer, ResetImgLoadStatus, -150
}

RandomPicture(dummy:=0, inLoop:=0) {
   ; Static inLoop := 0
   If (maxFilesIndex=0 || maxFilesIndex="") && (!CurrentSLD)
      Return

   ; resetSlideshowTimer(0)
   If (RandyIMGnow=-1 || !RandyIMGids.Count())
      coreGenerateRandomList()

   currentFileIndex := coreNextPrevImage(1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

PrevRandyPicture(dummy:=0, inLoop:=0) {
   If (maxFilesIndex=0 || maxFilesIndex="") && (!CurrentSLD)
      Return

   resetSlideshowTimer(0)
   If (RandyIMGnow=-1 || !RandyIMGids.Count())
      coreGenerateRandomList()

   currentFileIndex := coreNextPrevImage(-1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

getSelectedFiles(getItem:=0, forceSort:=0) {
   Critical, on
   Static firstItem, lastItem, lastIDcount := 0

   If (getItem=0 && forceSort=0)
      Return markedSelectFile
   Else If (getItem=1 && markedSelectFile)
      Return firstItem
   Else If (getItem="L" && markedSelectFile)
      Return lastItem

   If (forceSort=1 && getItem=0)
   {
      thisIDcount := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded filesFilter maxFilesIndex bckpMaxFilesIndex markedSelectFile lastZeitFileSelect
      If (lastIDcount=thisIDcount)
         Return markedSelectFile

      Sleep, 1
      ; ToolTip, % thisIDcount "`n" lastIDcount , , , 2
      lastIDcount := thisIDcount
      firstItem := lastItem := markedSelectFile := 0
      changeMcursor()
      startZeit := A_TickCount
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]=1)
         {
            markedSelectFile++
            lastItem := A_Index
            If !firstItem
               firstItem := A_Index
         }
      }

      If (markedSelectFile=1)
      {
         markedSelectFile := 0
         resultedFilesList[firstItem, 2] := 0
         lastZeitFileSelect := A_TickCount
         If (thumbsDisplaying=1)
            mainGdipWinThumbsGrid()
      }
      changeMcursor("normal")
      Return markedSelectFile
   }
}

filterToFilesSelection() {
   userFilterProperty := 19
   userFilterInvertThis := userFilterDoString := 0
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   dummyTimerDelayiedImageDisplay(50)
}

invertFilesSelection(silentMode:=0) {
   If (thumbsDisplaying!=1 || maxFilesIndex<3)
      Return

   markedSelectFile := 0
   Loop, % maxFilesIndex
   {
       sel := resultedFilesList[A_Index, 2]
       resultedFilesList[A_Index, 2] := !sel
       If (sel!=1)
          markedSelectFile++
   }

   lastZeitFileSelect := A_TickCount
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)

   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
   showTOOLtip("Files selection inverted`n" groupDigits(markedSelectFile) " files are now selected")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dropFilesSelection(silentMode:=0) {
   If (!markedSelectFile && silentMode=1)
      Return

   EntryMarkedMoveIndex := markedSelectFile := 0
   Loop, % maxFilesIndex
       resultedFilesList[A_Index, 2] := 0

   updateFilesSelectionInfos()
   ; selectAllFiles("none")
   ; ToolTip, % A_TickCount - startZeit, , , 2
   If (silentMode!=1)
   {
      showTOOLtip("Files selection dropped")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (thumbsDisplaying=1)
         mainGdipWinThumbsGrid()
      Else
         dummyTimerDelayiedImageDisplay(50)
   }
}

MenuMarkThisFileNow() {
   markThisFileNow()
}

markThisFileNow(thisFileIndex:=0) {
  If (currentFileIndex=0 || maxFilesIndex<2 || AnyWindowOpen>0)
     Return

  If !thisFileIndex
     thisFileIndex := currentFileIndex

  DestroyGIFuWin()
  oSel := resultedFilesList[thisFileIndex, 2]
  sel := oSel ? 0 : 1
  resultedFilesList[thisFileIndex, 2] := sel
  ; sel := (oSel && !sel) ? 0 : 1
  If (oSel!=sel)
  {
     If sel
        markedSelectFile++
     Else
        markedSelectFile--
  }

  lastZeitFileSelect := A_TickCount
  If (markedSelectFile<0)
     getSelectedFiles(0, 1)
  Else If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
  Else
     dummyTimerDelayiedImageDisplay(25)

  interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
  interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
}

jumpToFilesSelBorderFirst() {
   jumpToFilesSelBorder(-1)
}

jumpToFilesSelBorderLast() {
   jumpToFilesSelBorder(1)
}

jumpToFilesSelBorder(destination) {
  Static prevImgIndex, prevIndexu

  If (slideShowRunning=1)
     ToggleSlideShowu()

  totalCount := getSelectedFiles(0, 1)
  If !totalCount
     Return

  theFirst := getSelectedFiles(1)
  theLast := getSelectedFiles("L")
  currentFileIndex := (destination=-1) ? theFirst : theLast
  FriendlyName := (destination=-1) ? "First" : "Last"
  dummyTimerDelayiedImageDisplay(50)
  showTOOLtip(FriendlyName " selected element index: " groupDigits(currentFileIndex) "`n" groupDigits(markedSelectFile) " total images selected")
  interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
  interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

navSelectedFilesNext() {
   navSelectedFiles(1)
}

navSelectedFilesPrev() {
   navSelectedFiles(1)
}

navSelectedFiles(direction) {
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   changeMcursor()

   If !markedSelectFile
   {
      getSelectedFiles(0, 1)
      If !markedSelectFile
      {
         changeMcursor("normal")
         CurrentSLD := backCurrentSLD
         showTOOLtip("No files are currently selected")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   startIndex := currentFileIndex
   newIndex := 0
   Loop, % maxFilesIndex
   {
        thisIndex := (direction=-1) ? currentFileIndex - A_Index : currentFileIndex + A_Index
        r := getIDimage(thisIndex)
        isSelected := resultedFilesList[thisIndex, 2]
        If (isSelected!=1 || !r || InStr(r, "||"))
           Continue

        If (skipDeadFiles=1)
        {
           If !FileRexists(r)
           {
              Continue
           } Else
           {
              newIndex := thisIndex
              Break
           }
        } Else
        {
           newIndex := thisIndex
           Break
        }
   }

   CurrentSLD := backCurrentSLD
   changeMcursor("normal")
   If (!newIndex && direction=-1)
   {
      jumpToFilesSelBorderLast()
      Return
   } Else If (!newIndex && direction=1)
   {
      jumpToFilesSelBorderFirst()
      Return
   }

   currentFileIndex := (newIndex) ? newIndex : startIndex
   dummyTimerDelayiedImageDisplay(25)
}

coreSearchIndex(imgPath, givenRegEx, whatu, invertu:=0) {
   If !givenRegEx
      Return

   ; ToolTip, % imgPath "`n" givenRegEx , , , 2
   If (whatu=1)
   {
      stringu := imgPath
   } Else ; If (userSearchWhat=1)
   {
      parentu := zPlitPath(imgPath, 1, OutFileName, OutDir)
      If (whatu=2)
         stringu := OutDir
      Else If (whatu=3)
         stringu := OutFileName
      Else If (whatu=4)
         stringu := parentu
   }

   ; ToolTip, % stringu "`n" thisSearchString "`n" z , , , 2
   If !invertu
      Return RegExMatch(stringu, givenRegEx)
   Else
      Return RegExMatch(stringu, givenRegEx) ? 0 : 1
}

processSearchIndexString(inputu) {
   testRegEx := SubStr(inputu, 1, 2)
   If (testRegEx="\>" && StrLen(inputu)>2)
   {
      thisFilter := SubStr(inputu, 3)
   } Else If (InStr(inputu, ">") && StrLen(inputu)>1)
   {
      thisFilter := StrReplace(inputu, ">")
      If thisFilter
         thisFilter := "i)(" JEE_StrRegExLiteral(thisFilter) ")$"
   } Else If (InStr(inputu, "/") && StrLen(inputu)>1)
   {
      thisFilter := StrReplace(inputu, "/")
      If (thisFilter!="")
         thisFilter := "i)^(" JEE_StrRegExLiteral(thisFilter) ")"
   } Else If (inputu!="")
      thisFilter := "i)(" JEE_StrRegExLiteral(inputu) ")"

   Return thisFilter
}

processSQLsearchIndexString(inputu, strPosu, ByRef whatu) {
   If (whatu=2)
      whatu := "imgfolder"
   Else If (whatu=3)
      whatu := "imgfile"
   Else ; If (whatu=1)
      whatu := "fullPath"

   inputu := StrReplace(inputu, "'")
   inputu := StrReplace(inputu, "_", "\_")
   inputu := StrReplace(inputu, "%", "_")
   inputu := StrReplace(inputu, "*", "_")
   inputu := StrReplace(inputu, "?", "_")
   inputu := StrReplace(inputu, "|", "_")
   inputu := StrReplace(inputu, "\>")
   inputu := StrReplace(inputu, "/")

   If (strPosu=3 && StrLen(inputu)>1)
   {
      thisFilter := "%" inputu
   } Else If (strPosu=2 && StrLen(inputu)>1)
   {
      thisFilter := inputu "%"
   } Else If inputu
      thisFilter := "%" inputu "%"

   Return thisFilter
}

searchNextIndex(direction, inLoop:=0) {
   thisFilter := processSearchIndexString(userSearchString)
   If (thisFilter="")
   {
      thisSearchString := userSearchString := ""
      SetTimer, PanelSearchIndex, -100
      Return
   }

   thisSearchString := thisFilter
   friendly := (direction=-1) ? "previous" : "next"
   showTOOLtip("Searching " friendly " in index matching:`n" userSearchString)
   originalIndex := startIndex := currentFileIndex
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""

   newIndex := 0
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalLoops := (direction=1 && inLoop!=1) ? maxFilesIndex - startIndex + 1 : startIndex + 1
   If (inLoop=1)
      startIndex := (direction=1) ? 0 : maxFilesIndex + 1

   Loop, % totalLoops
   {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>1000)
        {
           etaTime := ETAinfos(A_Index, totalLoops, startOperation)
           showTOOLtip("Searching in index, please wait" etaTime, 0, 0, A_Index/totalLoops)
           prevMSGdisplay := A_TickCount
        }

        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        imgPath := getIDimage(thisIndex)
        If (!coreSearchIndex(imgPath, thisSearchString, userSearchWhat) || !imgPath)
           Continue

        If (skipDeadFiles=1 && thumbsDisplaying!=1)
        {
           If !FileExist(imgPath)
           {
              Continue
           } Else
           {
              newIndex := thisIndex
              Break
           }
        } Else
        {
           newIndex := thisIndex
           Break
        }
   }

   ResetImgLoadStatus()
   CurrentSLD := backCurrentSLD
   If (abandonAll=1)
   {
      showTOOLtip("Search abandoned by user")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep , 300, 100
      Return
   }

   If (!newIndex && inLoop!=1)
   {
      searchNextIndex(direction, 1)
      Return
   }

   If (!newIndex && inLoop=1)
   {
      showTOOLtip("WARNING: No indexed file matched the search criteria:`n" userSearchString)
      userSearchString := ""
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep , 900, 100
      Return
   }

   RemoveTooltip()
   currentFileIndex := newIndex ? newIndex : originalIndex
   dummyTimerDelayiedImageDisplay(25)
}

setContaintFolderAsProtected(givenPath:=0) {
     If (givenPath=protectedFolderPath && preventDeleteFromProtectedPath=1)
     {
        preventDeleteFromProtectedPath := 0
        IniAction(1, "preventDeleteFromProtectedPath", "General")
        showTOOLtip("The files in the folder are no longer protected:`n" protectedFolderPath "\")
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     imgPath := FolderExist(givenPath) ? givenPath : getIDimage(currentFileIndex)
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     protectedFolderPath := OutDir
     preventDeleteFromProtectedPath := 1
     IniAction(1, "protectedFolderPath", "General")
     IniAction(1, "preventDeleteFromProtectedPath", "General")
     showTOOLtip("The protected folder path is now:`n" OutDir "\")
     SetTimer, RemoveTooltip, % -msgDisplayTime
}

UItoggleMultiDelProtectFolder() {
    If (AnyWindowOpen!=16)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, preventDeleteFromProtectedPath
    GuiControlGet, preventDeleteFromProtectedSubPaths

    IniAction(1, "preventDeleteFromProtectedPath", "General")
    IniAction(1, "preventDeleteFromProtectedSubPaths", "General")
    actu := preventDeleteFromProtectedPath ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, preventDeleteFromProtectedSubPaths
    GuiControl, % actu, btnFldr
}

PanelMultiFileDelete() {
    Static lastInvoked := 1

    filesElected := getSelectedFiles(0, 1)
    thisBtnHeight := createSettingsGUI(16, A_ThisFunc, 0)
    btnWid := 130
    txtWid := 290
    If (PrefsLargeFonts=1)
    {
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    IniAction(0, "userMultiDelChoice", "General", 2, 1, 3)
    IniAction(0, "preventDeleteFromProtectedPath", "General", 1)
    IniAction(0, "preventDeleteFromProtectedSubPaths", "General", 1)
    IniAction(0, "protectedFolderPath", "General", 6)
    If (A_TickCount - lastInvoked>10500)
       move2recycler := 1 

    If !userSearchString
       preventDeleteMatchingSearch := 0

    If !protectedFolderPath
       preventDeleteFromProtectedSubPaths := preventDeleteFromProtectedPath := 0

    lastInvoked := A_TickCount
    thisInfo := protectedFolderPath ? protectedFolderPath "\" : "NONE"
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please choose what to remove:
    Gui, Add, DropDownList, y+10 wp gTglMultiDelChoice AltSubmit Choose%userMultiDelChoice% vuserMultiDelChoice, Delete selected files|Remove file entries from the list|Do both: remove files and the index entries
    Gui, Add, Checkbox, y+10 gTglOptionMove2recycler Checked%move2recycler% vmove2recycler, Move to Recycle Bin the deleted files
    Gui, Add, Checkbox, y+10 Checked%preventDBentryRemoval% vpreventDBentryRemoval, Do not remove the entries from the database 
    Gui, Add, Checkbox, y+10 Checked%preventDeleteMatchingSearch% vpreventDeleteMatchingSearch, Skip the files that match the files list search criteria
    Gui, Add, Checkbox, y+10 gUItoggleMultiDelProtectFolder Checked%preventDeleteFromProtectedPath% vpreventDeleteFromProtectedPath, Skip the files found in the protected folder:
    Gui, Add, Text, xp+15 y+10 w%txtWid% vbtnFldr, % thisInfo
    Gui, Add, Checkbox, y+10 Checked%preventDeleteFromProtectedSubPaths% vpreventDeleteFromProtectedSubPaths, Skip files found in its sub-folders as well 
    Gui, Font, Bold
    Gui, Add, Text, xs y+20, % "Selected entries: " groupDigits(filesElected) "." 
    Gui, Font, Normal
    If (SLDtypeLoaded!=3 || userMultiDelChoice=1)
       GuiControl, Disable, preventDBentryRemoval

    If (userMultiDelChoice=2)
       GuiControl, Disable, move2recycler

    If !protectedFolderPath
    {
       GuiControl, Disable, preventDeleteFromProtectedPath
       GuiControl, Disable, preventDeleteFromProtectedSubPaths
       GuiControl, Disable, btnFldr
    }

    If !userSearchString
       GuiControl, Disable, preventDeleteMatchingSearch

    Gui, Add, Button, xs y+15 h%thisBtnHeight% w%btnWid% gBTNactiveFileDel, &Delete focused file only
    Gui, Add, Button, x+5 hp w95 gBTNmultiDel Default, &Proceed
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Delete files: " appTitle)
    SetTimer, UItoggleMultiDelProtectFolder, -100
}

BTNactiveFileDel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, preventDBentryRemoval

   BtnCloseWindow()
   DeleteActivePicture()
   getSelectedFiles(0, 1)
   preventDBentryRemoval := 0
}

DeleteActivePicture() {
   DeletePicture("single")
   getSelectedFiles(0, 1)
}

BTNmultiDel() {
   ; Critical, on
   If !AnyWindowOpen
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, preventDBentryRemoval
   GuiControlGet, preventDeleteMatchingSearch
   GuiControlGet, preventDeleteFromProtectedPath
   GuiControlGet, preventDeleteFromProtectedSubPaths
   GuiControlGet, userMultiDelChoice
   IniAction(1, "preventDeleteFromProtectedPath", "General")
   IniAction(1, "preventDeleteFromProtectedSubPaths", "General")
   Sleep, 10
   dontAlterIndex := (userMultiDelChoice=3) ? "yes" : 0
   TglOptionMove2recycler()
   filesElected := getSelectedFiles(0, 1)
   If (filesElected<2)
      Return

   If (userMultiDelChoice=3 || userMultiDelChoice=1)
   {
      If (filesElected>50 && move2recycler!=1) || (filesElected>95 && move2recycler=1)
      {
         msgInfos := (move2recycler=1) ? " " : "`n`nThe files will be PERMANENTLY deleted."
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete " groupDigits(filesElected) " files?" msgInfos, 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      BtnCloseWindow()
      r := batchFileDelete(dontAlterIndex)
   } Else r := 0

   If (userMultiDelChoice=3 || userMultiDelChoice=2) && (r=0)
   {
      If AnyWindowOpen
         BtnCloseWindow()
      Sleep, 500
      InListMultiEntriesRemover(0, "y")
   }

   preventDBentryRemoval := 0
   If AnyWindowOpen
      BtnCloseWindow()
}

TglMultiDelChoice() {
   TglOptionMove2recycler()
}

TglOptionMove2recycler() {
  Gui, SettingsGUIA: Default
  GuiControlGet, move2recycler
  GuiControlGet, userMultiDelChoice
  If (SLDtypeLoaded=3)
  {
     GuiControlGet, preventDBentryRemoval
     actu := (userMultiDelChoice=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
     GuiControl, % actu, preventDBentryRemoval
  }

  INIaction(1, "userMultiDelChoice", "General")
  actu := (userMultiDelChoice=1 || userMultiDelChoice=3) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
  GuiControl, % actu, move2recycler
}

batchFileDelete(dontAlterIndex:=0) {
   If (userPrivateMode=1)
   {
      showTOOLtip("WARNING: You are not allowed to delete images when private mode is enabled")
      SoundBeep 300, 100
      Return
   }

   BtnCloseWindow()
   filesElected := markedSelectFile
   friendly := (move2recycler=1) ? "Moving to recycle bin" : "Permanently deleting"
   showTOOLtip(friendly A_Space groupDigits(filesElected) " files, please wait")
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   destroyGDIfileCache()
   doStartLongOpDance()
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   filesRemoved := abandonAll := failedFiles := skippedFiles := 0
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If failedFiles
            etaTime .= "`nFailed to remove " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip(friendly " selected files, please wait" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      thisFileIndex := A_Index
      file2rem := StrReplace(getIDimage(thisFileIndex), "||")
      If (preventDeleteMatchingSearch=1 && file2rem && userSearchString)
      {
         If coreSearchIndex(file2rem, thisSearchString, userSearchWhat)
         {
            skippedFiles++
            Continue
         }
      }

      If (preventDeleteFromProtectedPath=1 && protectedFolderPath)
      {
         If (preventDeleteFromProtectedSubPaths=1)
            OutDir := InStr(file2rem, protectedFolderPath "\") ? protectedFolderPath : ""
         Else
            zPlitPath(file2rem, 0, OutFileName, OutDir)

         If (protectedFolderPath=OutDir)
         {
            skippedFiles++
            Continue
         }
      }

      If (move2recycler=1)
         FileRecycle, %file2rem%
      Else
         FileDelete, %file2rem%

      If ErrorLevel
      {
         Try FileSetAttrib, -R, %file2rem%
         Sleep, 0

         If (move2recycler=1)
            FileRecycle, %file2rem%
         Else
            FileDelete, %file2rem%
      }

      If !ErrorLevel
      {
         If (SLDtypeLoaded=3)
            markSQLdbEntryDeleted(resultedFilesList[thisFileIndex, 12], 1)

         filesRemoved++
         If (dontAlterIndex!="yes")
         {
            resultedFilesList[thisFileIndex, 1] := "||" file2rem
            ; resultedFilesList[thisFileIndex, 2] := 1
            updateMainUnfilteredList(thisFileIndex, 1, "||" file2rem)
         }
      } Else failedFiles++
   }

   currentFilesListModified := 1
   If failedFiles
      someErrors := "Failed to delete " groupDigits(failedFiles) " files`n"
   If skippedFiles
      someErrors .= groupDigits(skippedFiles) " files were skipped`n"

   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      {
         someErrors .= "Failed to update the database"
         throwSQLqueryDBerror(A_ThisFunc)
      }
   }

   watchFolderDetails := ""
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   If (abandonAll=1)
   {
      SoundBeep, 300, 100
      showTOOLtip(someErrors "Operation aborted. " groupDigits(filesRemoved) " out of " groupDigits(countTFilez) " selected files deleted until now")
   } Else
   {
      SoundBeep, 900, 100
      showTOOLtip(someErrors groupDigits(filesRemoved) " out of " groupDigits(countTFilez) " selected files deleted")
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return abandonAll
}

DeletePicture(dummy:=0) {
  Static lastInvoked := 1, prevDelFileIndex := -1
  getSelectedFiles(0, 1)
  If (markedSelectFile>1 && thumbsDisplaying!=1 && dummy!="single")
  {
     dummy := "single"   
  } Else If (markedSelectFile>1 && dummy!="single")
  {
     PanelMultiFileDelete()
     Return
  }

  If (slideShowRunning=1)
  {
     ToggleSlideShowu()
     Return
  }

  If (A_TickCount - lastInvoked<200) && (askDeleteFiles!=1)
  {
     lastInvoked := A_TickCount
     Return
  }

  file2rem := getIDimage(currentFileIndex)
  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir)
  If (askDeleteFiles=1 && dummy!="single") || (editingSelectionNow=1 && thumbsDisplaying!=1)
  {
     msgTimer := A_TickCount
     fakeWinCreator(37, A_ThisFunc, 1)
     msgResult := msgBoxWrapper("panelu|Delete confirmation: " appTitle, "Please confirm you want to delete this image file.`n`n" OutFileName "`n`n" OutDir "\", "&Remove index entry|&Delete|&Cancel", 3, "trash", "Permanently delete file, do not move to recycle bin", 0, "Always prompt before file delete`f`fNo longer prompt before file delete in this session`fNever prompt before file delete")
     If InStr(msgResult.btn, "Delete")
     {
        good2go := 1
     } Else If InStr(msgResult.btn, "remove index")
     {
        remCurrentEntry(0)
        Return
     }

     If (A_TickCount - msgTimer < 550) && InStr(msgResult.btn, "Delete")
     {
        showTOOLtip("Operation aborted. User answered affirmatively too quickly.")
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }
  } Else good2go := 1

  If (msgResult.list>1 && good2go=1 && msgResult.check!=1)
  {
     askDeleteFiles := 0
     If (msgResult.list=3)
        INIaction(1, "askDeleteFiles", "General")
  }

  If (good2go!=1) || (imageLoading=1 && animGIFplaying!=1)
  {
     SetTimer, ResetImgLoadStatus, -50
     Return
  }

  Sleep, 2
  If (animGIFplaying=1)
  {
     DestroyGIFuWin()
     showDelayedTooltip("GIF animation stopped", 0, 250)
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  If (userPrivateMode=1)
  {
     showTOOLtip("WARNING: You are not allowed to delete images when private mode is enabled")
     SoundBeep 300, 100
     Return
  }

  Sleep, 2
  if (!UserMemBMP && thumbsDisplaying!=1)
  {
     prevDelFileIndex := currentFileIndex
     UserMemBMP := cloneGDItoMem(A_ThisFunc, gdiBitmap)
  }

  destroyGDIfileCache(0, 1)
  FileGetSize, OutputVar, % file2rem
  If (OutputVar>2)
  {
     fileMsg := "`nFile size: " fileSizeFrienly(OutputVar)
     FileDateM := QPV_FileGetSizeTime(file2rem, "M", thisFileIndex)
     FileDateC := QPV_FileGetSizeTime(file2rem, "C", thisFileIndex)
     Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
     Try FormatTime, FileDateC, % FileDateC, dd/MM/yyyy, HH:mm
     fileMsg .= "`nDate created: " FileDateC "`nDate modified: " FileDateM
  }

  Try FileSetAttrib, -R, %file2rem%
  Sleep, 1

  If (userPrivateMode!=1)
     OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

  shiftState := (GetKeyState("Shift", "P") && askDeleteFiles!=1) ? 1 : 0
  If (msgResult.check=1) || (shiftState=1)
     FileDelete, %file2rem%
  Else
     FileRecycle, %file2rem%

  If ErrorLevel
  {
     If (thumbsDisplaying=1 && !FileExist(file2rem))
     {
        If (prevDelFileIndex=currentFileIndex)
           terminateIMGediting()

        remCurrentEntry(0)
     } Else
     {
        fileMsg := (userPrivateMode=1) ? "" : "`n" OutFileName "`n" OutDir "\"
        showTOOLtip("ERROR: File already deleted or access denied" fileMsg)
        SoundBeep, 300, 100
     }
  } Else
  {
     If (SLDtypeLoaded=3)
        markSQLdbEntryDeleted(resultedFilesList[currentFileIndex, 12])

     If (resultedFilesList[currentFileIndex, 5]=1)
     {
        ToggleImgFavourites(file2rem, "rem")
        resultedFilesList[currentFileIndex, 5] := 0
        updateMainUnfilteredList(currentFileIndex, 5, 0)
     }

     resultedFilesList[currentFileIndex, 1] := "||" file2rem
     updateMainUnfilteredList(currentFileIndex, 1, "||" file2rem)
     currentFilesListModified := 1
     fileMsg := (userPrivateMode=1) ? "" : "`n" groupDigits(currentFileIndex) " | " OutFileName "`n" OutDir "\" fileMsg
     If (msgResult.check=1) || (shiftState=1)
        showTOOLtip("File permanently deleted" fileMsg)
     Else
        showTOOLtip("File moved to recycle bin" fileMsg)

     lastOSDtooltipInvoked := 1
     If (deleteFileActAfter=2)
        NextPicture(0, 0, 1)
     Else If (deleteFileActAfter=3)
        PreviousPicture(0, 0, 1)
  }

  preventDBentryRemoval := 0
  Sleep, 2
  watchFolderDetails := ""
  lastInvoked := A_TickCount
  SetTimer, RemoveTooltip, % -msgDisplayTime
  SetTimer, ResetImgLoadStatus, -50
  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

readRecentMultiRenameEntries() {
   entriesList := ""
   If (userPrivateMode=1)
      Return

   Loop, 35
   {
       IniRead, newEntry, % mainRecentsFile, RecentMultiRename, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>1 && !InStr(entriesList, newEntry "`n"))
          entriesList .= newEntry "`n"
   }
   Return entriesList
}

PanelMultiRenameFiles() {
    Global UsrEditNewFileName
    getSelectedFiles(0, 1)
    If (maxFilesIndex<2 || markedSelectFile<2)
       Return

    thisBtnHeight := createSettingsGUI(8, A_ThisFunc)
    btnWid := 100
    txtWid := 390
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       txtWid := txtWid + 220
       Gui, Font, s%LargeUIfontValue%
    }

    RegAction(0, "PreserveDateTimeOnSave",, 1)
    thisu := groupDigits(markedSelectFile)
    listu := readRecentMultiRenameEntries()
    uiLVoffset := 0
    Gui, +Delimiter`n
    Gui, Add, Text, x15 y15 w%txtWid% Section, Selected files: %thisu%. Type a pattern to rename the files.
    Gui, Add, ComboBox, y+10 w%EditWid% gUIgenericComboAction vUsrEditNewFileName, % listu
    Gui, Add, ListView, xp y+1 wp -multi +LV0x10000 +LV0x400 r%uLVr% Grid AltSubmit vLViewOthers gUIlvMultiRenameResponder, Original file name`nNew file name`nFolder path`n#
    ml := (PrefsLargeFonts=1) ? 40 : 30
    sml := (PrefsLargeFonts=1) ? 35 : 25
    Gui, Add, Button, y+5 h%thisBtnHeight% w%ml% gUImultiRenameChangeLVoffset, <<
    Gui, Add, Button, x+1 h%thisBtnHeight% w%sml% gUImultiRenameChangeLVoffset, <
    Gui, Add, Button, x+1 hp wp gUImultiRenameChangeLVoffset, >
    Gui, Add, Button, x+1 hp w%ml% gUImultiRenameChangeLVoffset, >>
    Gui, Add, Checkbox, x+10 hp Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Text, xs y+10, In case of file name collisions, you will be prompted.

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gcoreBatchMultiRenameFiles, &Rename files
    Gui, Add, Button, x+5 hp w%btnWid% gEraseMultiRenameHisto, Erase &history
    Gui, Add, Button, x+5 hp w85 gBtnHelpMultiRename, H&elp
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Rename multiple files: " appTitle)
}

UImultiRenameChangeLVoffset(a:=0, b:=0, c:=0) {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   GuiControlGet, UsrEditNewFileName
   If (!InStr(a, ">") && !InStr(a, "<"))
      ControlGetText, info, , ahk_id %a%

   totalListed := LV_GetCount()
   If (totalListed<1 || StrLen(UsrEditNewFileName)<1 || userPrivateMode=1)
   {
      If (userPrivateMode=1)
         showTOOLtip("WARNING: Nothing to preview at the moment.`nPrivate mode is activated")
      Else
         showTOOLtip("WARNING: Nothing to preview at the moment.`nPlease ensure you provided a renaming pattern.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   totalIndex := markedSelectFile
   If (totalListed>=totalIndex)
   {
      showTOOLtip("All selected entries are listed and previewed in the table")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (info="<<")
      uiLVoffset := 0
   Else If (info="<")
      uiLVoffset := clampInRange(uiLVoffset - totalListed, 0, totalIndex)
   Else If (info=">")
      uiLVoffset := clampInRange(uiLVoffset + totalListed, 0, totalIndex - uLVr*2)
   Else If (info=">>")
      uiLVoffset := clampInRange(totalIndex - uiLVoffset, 0, totalIndex - uLVr*2)
   ; ToolTip, % a "=" b "=" c "=" info , , , 2
   SetTimer, PopulateLVmultiRename, -250
}

BtnHelpMultiRename() {
    GuiControlGet, PreserveDateTimeOnSave
    RegAction(1, "PreserveDateTimeOnSave")
    msgBoxWrapper(appTitle ": HELP", "File extensions remain unchanged regardless of the pattern used.`nPatterns available to rename the Files:`n`na) Whatever file prefix [this] or suffix with tokens`n[this] - file name`n[pfdname] - parent folder name`n[fDateM] or [fDateC] - file modified/created date`n[counter] - count all files, regardless of their location`ntrim{X,Y} - X and Y designate how many letters to trim from the beginning and/or end of the original file name`ncase{U} - change letters to {U}pper, {L}ower or {T}itle case`n`nb) Replace given string//with this one`nUse // to perform search and replace in file names. Begin with \> to use RegEx. Trim function and the tokens mentioned earlier can be used only after //.`n`nc) abcdefgh01234>>any string`nEvery enumerated character before >> will be replaced with a single character or a string specified after >>. The tokens from a) can be used after >>.`n`nd) any file name without tokens`nThe files will be counted according to their containing folder. This is to avoid naming conflicts and applies only if [this], >> and // are not used.", -1, 0, 0)
}

UIgenericComboAction(a:=0, b:=0, c:=0) {
   hwnd := Format("{1:#x}", a) 
   GuiControlGet, thisV, %A_Gui%:, %A_GuiControl%
   z := GetComboBoxInfo(hwnd)
   hwnd := Format("{1:#x}", z[1])
   allowCtrlBkspEdit(hwnd, thisV)
   If (AnyWindowOpen=8)
      SetTimer, PopulateLVmultiRename, -450
   Else If (AnyWindowOpen=61)
      SetTimer, dummyPopulateAboutKbdShortcutsList, -200
   Else If (AnyWindowOpen=6)
      SetTimer, updateUIFiltersPanel, -150
}

dummyPopulateAboutKbdShortcutsList() {
   PopulateAboutKbdShortcutsList(1)
}

decideMultiRename(ByRef OriginalNewFileName) {
   obju := []
   obju.renamingCount := 0
   obju.TrimmingMode := 0
   obju.rechecherRemplaceMode := 0
   obju.charsRemplaceMode := 0
   obju.regExRemplaceMode := 0
   obju.caseChange := 0
   obju.IndexModeCount := 0
   obju.forceCaseChange := 0

   If RegExMatch(OriginalNewFileName, "i)(case\{.\})")
   {
      If InStr(OriginalNewFileName, "case{U}")
         obju.caseChange := 1
      Else If InStr(OriginalNewFileName, "case{L}")
         obju.caseChange := 2
      Else If InStr(OriginalNewFileName, "case{T}")
         obju.caseChange := 3

      OriginalNewFileName := StrReplace(OriginalNewFileName, "case{U}")
      OriginalNewFileName := StrReplace(OriginalNewFileName, "case{L}")
      OriginalNewFileName := StrReplace(OriginalNewFileName, "case{T}")
      If !Trimmer(OriginalNewFileName)
         obju.forceCaseChange := 1
   }
 
   If (Trimmer(OriginalNewFileName)="[counter]")
      OriginalNewFileName := "[this] ([counter])"
   Else If (obju.forceCaseChange=1)
      OriginalNewFileName := "[this]"
 
   matchFoundPosA := RegExMatch(OriginalNewFileName, "i)trim\{..?.?\, ?..?.?\}", matchedStringu)
   If InStr(OriginalNewFileName, "//")
      strArr := StrSplit(OriginalNewFileName, "//")
   Else If InStr(OriginalNewFileName, "\\")
      strArr := StrSplit(OriginalNewFileName, "\\")
   Else If InStr(OriginalNewFileName, ">>")
      chrStrArr := StrSplit(OriginalNewFileName, ">>")
   Else If (!InStr(OriginalNewFileName, "[this]") && !matchedStringu)
      obju.renamingCount := 1
 
   If (InStr(OriginalNewFileName, "[counter]") ) ; && obju.renamingCount!=1)
   {
      obju.IndexModeCount := 1
      obju.renamingCount := 0
   }
 
   If (IsObject(strArr) && obju.renamingCount!=1)
   {
      testRegEx := SubStr(strArr[1], 1, 2)
      If (testRegEx="\>")
      {
         obju.regExRemplaceMode := 1
         obju.strArrA := SubStr(strArr[1], 3)
         obju.strArrB := strArr[2]
      } Else
      {
         obju.strArrA := strArr[1]
         If (strArr[2]=A_Space || strArr[2]=0 || strArr[2]="  ")
            obju.strArrB := strArr[2]
         Else
            obju.strArrB := (filterFileName(strArr[2])!="") ? strArr[2] : ""
      }
 
      If (obju.strArrA="")
         Return "err"
      ; If (obju.strArrB="" && StrLen(obju.strArr[2])>0)
      ;    Return "err"
 
      obju.rechecherRemplaceMode := 1 
   } Else If (IsObject(chrStrArr) && obju.renamingCount!=1)
   {
      obju.strArrA := chrStrArr[1]
      If (chrStrArr[2]=A_Space || chrStrArr[2]=0 || chrStrArr[2]=" ")
         obju.strArrB := chrStrArr[2]
      Else
         obju.strArrB := filterFileName(chrStrArr[2]) ? chrStrArr[2] : ""
 
      If (obju.strArrA="")
         Return "err"
 
      obju.charsRemplaceMode := 1 
   } Else obju.newName := filterFileName(OriginalNewFileName)
 
   If (obju.renamingCount!=1)
   {
      obju.origMatchedStringu := matchedStringu
      matchedStringu := StrReplace(matchedStringu, A_Space)
      matchedStringu := StrReplace(matchedStringu, A_Space)
      matchedStringu := StrReplace(matchedStringu, .)
      matchedStringu := StrReplace(matchedStringu, "trim{")
      matchedStringu := StrReplace(matchedStringu, "}")
      If InStr(matchedStringu, ",")
      {
         trimuObj := StrSplit(matchedStringu, ",")
         obju.leftTrimu := trimuObj[1]
         obju.righttTrimu := trimuObj[2]
         obju.TrimmingMode := (isNumber(obju.leftTrimu) && isNumber(obju.righttTrimu)) ? 1 : 0
      }
      ; ToolTip, % obju.origMatchedStringu "`n" matchedStringu "`n" trimuObj[1] "==" trimuObj[2] , , , 2
   }
 
   Return obju
}

ChrReplace(string, chars, replacer) {
   If (chars!="")
   {
      Loop, Parse, chars
           string := StrReplace(string, A_LoopField, replacer)
   }

   Return string
}

decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez, parentFolderName, imgPath, obju) {
   If (obju.regExRemplaceMode=1)
      newFileName := RegExReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.rechecherRemplaceMode=1)
      newFileName := StrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.charsRemplaceMode=1)
      newFileName := ChrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (!InStr(OriginalNewFileName, "[this]") && obju.TrimmingMode!=1 && obju.IndexModeCount!=1)
      newFileName := OriginalNewFileName " (" countFilez ")"
   Else ; If (obju.TrimmingMode=1)
      newFileName := OriginalNewFileName

   If (InStr(newFileName, "[pfdname]") && InStr(OriginalNewFileName, "[pfdname]"))
      newFileName := StrReplace(newFileName, "[pfdname]", parentFolderName)

   If (InStr(newFileName, "[counter]") && InStr(OriginalNewFileName, "[counter]") && obju.IndexModeCount=1)
      newFileName := StrReplace(newFileName, "[counter]", countFilez)

   If (InStr(newFileName, "[fDateM]") && InStr(OriginalNewFileName, "[fDateM]"))
   {
      FileGetTime, dateu, % imgPath, M
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateM]", dateu)
   }

   If (InStr(newFileName, "[fDateC]") && InStr(OriginalNewFileName, "[fDateC]"))
   {
      FileGetTime, dateu, % imgPath, C
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateC]", dateu)
   }

   If (InStr(newFileName, "[this]") && InStr(OriginalNewFileName, "[this]"))
      newFileName := StrReplace(newFileName, "[this]", fileNamuNoEXT)

   If (obju.TrimmingMode=1 && obju.origMatchedStringu && obju.renamingCount!=1)
   {
      clampedL := clampInRange(obju.leftTrimu + 1, 0, StrLen(fileNamuNoEXT) - 1)
      trimmedFileName := SubStr(fileNamuNoEXT, clampedL)
      clampedR := clampInRange(obju.righttTrimu, 1, StrLen(trimmedFileName) - 1)
      If (obju.righttTrimu>0)
         trimmedFileName := SubStr(trimmedFileName, 1, StrLen(trimmedFileName) - clampedR)
      newFileName := StrReplace(newFileName, obju.origMatchedStringu, trimmedFileName)
      ; ToolTip, % clampedL "==" clampedR "`n" trimmedFileName "`n" newFileName , , , 2
   }
   ; ToolTip, % obju.TrimmingMode "==" obju.origMatchedStringu "==" obju.renamingCount , , , 2

   If (obju.caseChange=1)
      newFileName := Format("{:U}", StrReplace(newFileName, "case{U}"))
   Else If (obju.caseChange=2)
      newFileName := Format("{:L}", StrReplace(newFileName, "case{L}"))
   Else If (obju.caseChange=3)
      newFileName := Format("{:T}", StrReplace(newFileName, "case{T}"))

   Return newFileName
}

UIlvMultiRenameResponder(a, b, c) {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(indexu, RowNumber, 4)
   If !indexu
   {
      If (b="RightClick")
         invokePrefsPanelsContextMenu()
      Return
   }

   ; If (b="k")
   ;    ToolTip, % b "=" c , , , 2

   focusEdit := (b="k" && (isInRange(c, 33, 40) || isInRange(c, 48, 59)  || isInRange(c, 65, 90))) ? 0 : 1
   bfocusEdit := RegExMatch(b, "i)^(normal|s|f|i|c|d|a|colclick|right)") ? 1 : 0
   If (b="k" && c=112) ; F1
   {
      BtnHelpMultiRename()
   } Else If (b="k" && c=120) ; F9
   {
      UImultiRenameChangeLVoffset("<<")
   } Else If (b="k" && c=121) ; F10
   {
      UImultiRenameChangeLVoffset("<")
   } Else If (b="k" && c=122) ; F11
   {
      UImultiRenameChangeLVoffset(">")
   } Else If (b="k" && c=123) ; F12
   {
      UImultiRenameChangeLVoffset(">>")
   } Else If (b="DoubleClick")
   {
      currentFileIndex := indexu
      dummyTimerDelayiedImageDisplay(50)
   } Else If (b="RightClick")
   {
      invokePrefsPanelsContextMenu()
   } Else If (bfocusEdit!=1 && focusEdit=1)
   {
      GuiControl, SettingsGUIA: Focus, UsrEditNewFileName
      highlightActiveCtrl()
   }
}

PopulateLVmultiRename() {
  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewOthers
  GuiControlGet, UsrEditNewFileName
  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  If (OriginalNewFileName="[this]" || OriginalNewFileName="")
  {
     LV_Delete()
     GuiControl, +Redraw, LViewOthers
     Return
  }

  OriginalNewFileName := UsrEditNewFileName
  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName
  
  If (objuTemp="err" || StrLen(OriginalNewFileName)<2)
  {
     LV_Delete()
     GuiControl, +Redraw, LViewOthers
     Return
  }

  loopzu := 0
  startOperation := A_TickCount
  If (StrLen(OriginalNewFileName)>1)
  {
     GuiControl, -Redraw, LViewOthers
     LV_Delete()
     filesElected := getSelectedFiles(0, 1)
     If (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"

     counterFilez := new hashtable()
     selCounter := 0
     maxItems := (userPrivateMode=1) ? 100 : 9100
     Loop, % maxFilesIndex
     {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         selCounter++
         If (A_Index<uiLVoffset)
            Continue

         thisFileIndex := A_Index
         imgPath := resultedFilesList[A_Index, 1]
         parentFolderName := zPlitPath(imgPath, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)
         If (userPrivateMode=1)
         {
            newFileName := "*********."
            OutFileName := "********." fileEXTu
            OutDir := "*:\******\*******"
         } Else
         {
            If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
            {
               OutDirAsc := (objuTemp.IndexModeCount=1) ? "a" : OutDir
               counterFilez[OutDirAsc] := Round(counterFilez[OutDirAsc]) + 1
            }

            If (objuTemp.IndexModeCount=1)
               counterFilez[OutDirAsc] := selCounter

            newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, counterFilez[OutDirAsc], parentFolderName, imgPath, objuTemp)
         }

         file2save := OutDir "\" newFileName "." fileEXTu
         If (file2save==imgPath || newFileName="" || newFileName=A_Space || newFileName="  " || newFileName=".")
            Continue

         loopzu++
         LV_Add(A_Index, OutFileName, newFileName "." fileEXTu, OutDir "\", A_Index)
         ; ToolTip, % A_Index , , , 2
         If ((loopzu>=maxItems) || (loopzu>15 && (A_TickCount - startOperation>1000)))
            Break
     }
     LV_ModifyCol(3, "AutoHdr Left")
     LV_ModifyCol(4, "AutoHdr Left")

     counterFilez := ""
     GuiControl, +Redraw, LViewOthers
  }
}

coreBatchMultiRenameFiles() {
  Critical, on
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditNewFileName
  GuiControlGet, PreserveDateTimeOnSave

  RegAction(1, "PreserveDateTimeOnSave")
  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  If (OriginalNewFileName="[this]" || OriginalNewFileName="")
  {
     showTOOLtip("WARNING: Incorrect multi-rename pattern provided")
     SoundBeep 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  OriginalNewFileName := UsrEditNewFileName
  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName
  
  If (objuTemp="err" || StrLen(OriginalNewFileName)<2)
  {
     showTOOLtip("WARNING: Incorrect multi-rename pattern provided")
     SoundBeep 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  If (StrLen(OriginalNewFileName)>1)
  {
     filesElected := getSelectedFiles(0, 1)
     If (filesElected>100)
     {
        msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to rename the selected files.`n`nYou have selected " filesElected " files to be renamed...", 4, 0, "question")
        If (msgResult!="Yes")
           Return
     }

     BtnCloseWindow()
     showTOOLtip("Renaming " filesElected " files, please wait`nPattern: " OriginalNewFileName)
     startOperation := A_TickCount
     prevMSGdisplay := A_TickCount
     destroyGDIfileCache()
     RecentMultiRenamesManager(OriginalNewFileName)
     doStartLongOpDance()
     If (SLDtypeLoaded=3)
        activeSQLdb.Exec("BEGIN TRANSACTION;")

     filezRenamed := countFilez := 0
     countTFilez := skippedFiles := failedFiles := overwrittenFiles := 0
     nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
     if (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"

     counterFilez := new hashtable()
     BtnCloseWindow()
     Loop, % maxFilesIndex
     {
         wasError := 0
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         changeMcursor()
         thisFileIndex := A_Index
         file2rem := getIDimage(thisFileIndex)
         parentFolderName := zPlitPath(file2rem, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)
         countTFilez++
         If !FileExist(file2rem)
         {
            failedFiles++
            Continue
         }

         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            someErrors := ETAinfos(countTFilez, filesElected, startOperation)
            If (failedFiles>0)
               someErrors .= "`n" groupDigits(failedFiles) " files failed to rename"
            If (skippedFiles>0)
               someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"
            If (overwrittenFiles>0)
               someErrors .= "`n" groupDigits(overwrittenFiles) " files were overwritten"

            showTOOLtip("Renaming selected files, please wait`nPattern: " OriginalNewFileName someErrors, 0, 0, countTFilez/filesElected)
            prevMSGdisplay := A_TickCount
         }

         If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
         {
            OutDirAsc := (objuTemp.IndexModeCount=1) ? "a" : OutDir
            counterFilez[OutDirAsc] := Round(counterFilez[OutDirAsc]) + 1
         }

         If (objuTemp.IndexModeCount=1)
            counterFilez[OutDirAsc] := countTFilez

         newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, counterFilez[OutDirAsc], parentFolderName, file2rem, objuTemp)
         file2save := OutDir "\" newFileName "." fileEXTu
         If (file2save==file2rem || newFileName="" || newFileName=A_Space || newFileName="." || newFileName="  ")
         {
            skippedFiles++
            Continue
         }

         thisFileExists := 0
         If (PreserveDateTimeOnSave=1)
         {
            FileGetTime, originalMtime, %file2save%, M
            FileGetTime, originalCtime, %file2save%, C
         }

         If (FileExist(file2save) && !FolderExist(file2save))
         {
            thisFileExists := 1
            file2save := askAboutFileCollision(file2rem, file2save, 1, 0, 0, performOverwrite)
            If !file2save
            {
               skippedFiles++
               Continue
            } Else If (file2save="abort")
            {
               abandonAll := 1
               Break
            }
         }

         If (thisFileExists=1)
         {
            If (performOverwrite=1 && objuTemp.renamingCount!=1)
            {
               overwrittenFiles++
               FileSetAttrib, -R, %file2save%
               Sleep, 1
               FileRecycle, %file2save%
               If ErrorLevel
                  wasError++
               Sleep, 1
            } Else If (performOverwrite!=2)
            {
               skippedFiles++
               Continue
            }
         }

         FileSetAttrib, -R, %file2rem%
         Sleep, 1
         FileMove, %file2rem%, %file2save%
         If ErrorLevel
         {
            failedFiles++
            wasError++
         } Else
         {
            updateDates := 1
            If (originalMtime && PreserveDateTimeOnSave=1)
            {
               Sleep, 0
               FileSetTime, % originalMtime, % file2save, M
               FileSetTime, % originalCtime, % file2save, C
               updateDates := 0
            } 

            filezRenamed++
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[thisFileIndex, 12])

            resultedFilesList[thisFileIndex, 1] := file2save
            ; resultedFilesList[thisFileIndex, 2] := 1
            updateMainUnfilteredList(thisFileIndex, 1, file2save)
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }

     counterFilez := ""
     someErrors := ""
     If (SLDtypeLoaded=3)
     {
        If !activeSQLdb.Exec("COMMIT TRANSACTION;")
           someErrors .= "Failed to commit changes to the SQL database`n"
     }

     If (failedFiles>0)
        someErrors .= "`n" groupDigits(failedFiles) " files failed to rename"
     If (skippedFiles>0)
        someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"
     If (overwrittenFiles>0)
        someErrors .= "`n" groupDigits(overwrittenFiles) " files were overwritten"

     watchFolderDetails := ""
     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(100)
     If (abandonAll=1)
        showTOOLtip("Operation aborted. " groupDigits(filezRenamed) " out of " groupDigits(filesElected) " selected files were renamed" someErrors)
     Else
        showTOOLtip("Finished renaming " groupDigits(filezRenamed) " out of " groupDigits(filesElected) " selected files" someErrors)
     SetTimer, ResetImgLoadStatus, -50
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
  }
}

RecentMultiRenamesManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentMultiRenameEntries()
  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>35)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentMultiRename, E%countItemz%
  }
}

EraseMultiRenameHisto() {
  IniDelete, % mainRecentsFile, RecentMultiRename
  CloseWindow()
  Sleep, 1
  PanelRenameThisFile()
}

PanelfolderThanEraseThumbsCache() {
   If AnyWindowOpen
      Return

   fakeWinCreator(11, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Clear cached thumbnails: " appTitle, "Erase thumbnails cached older than... (in days)", "&Clean old cache|&Empty entire cache|C&ancel", 3, "trash", "&Always cache generated thumbnails", enableThumbsCaching, 0, "limit3 number -multi", 0)
   remCacheOldDays := Trimmer(msgResult.edit)
   If InStr(msgResult.btn, "old")
   {
      enableThumbsCaching := msgResult.check
      If !remCacheOldDays
         SetTimer, PanelfolderThanEraseThumbsCache, -150 ; allows for this execution line to cease peacefully ^_^ 
      Else
         EraseThumbsCache("daysITis", remCacheOldDays)
   } Else If InStr(msgResult.btn, "entire")
   {
      enableThumbsCaching := msgResult.check
      EraseThumbsCache()
   }
}

defineSQLdbSort() {
   reorder := StrLen(prevFilesSortMode)>3 ? "z" prevFilesSortMode ";" : ";"
   If InStr(reorder, "fsize")
      defaultSort := "File size"
   Else If InStr(reorder, "imgfolder, imgfile;")
      defaultSort := "Path and name"
   Else If InStr(reorder, "imgfolder;")
      defaultSort := "Folder path"
   Else If InStr(reorder, "zimgfile;")
      defaultSort := "File name"
   Else If InStr(reorder, "fmodified")
      defaultSort := "Modified date"
   Else If InStr(reorder, "fcreated")
      defaultSort := "Created date"
   Else If InStr(reorder, "imgwidth")
      defaultSort := "Image width"
   Else If InStr(reorder, "imgheight")
      defaultSort := "Image height"
   Else If InStr(reorder, "imgmegapix")
      defaultSort := "Megapixels"
   Else If InStr(reorder, "imgframes")
      defaultSort := "Frames"
   Else If InStr(reorder, "imgwhratio")
      defaultSort := "Aspect ratio [W/H]"
   Else If InStr(reorder, "imgdpi")
      defaultSort := "Image DPI"
   Else If InStr(reorder, "imgavg")
      defaultSort := "Histogram average"
   Else If InStr(reorder, "imgmedian")
      defaultSort := "Histogram median"
   Else If InStr(reorder, "imghrms")
      defaultSort := "Histogram RMS"
   Else If InStr(reorder, "imghmode")
      defaultSort := "Histogram mode"
   Else If InStr(reorder, "imghpeak")
      defaultSort := "Histogram max [range]"
   Else If InStr(reorder, "imghlow")
      defaultSort := "Histogram min [range]"
   Else If InStr(reorder, "imghrange")
      defaultSort := "Histogram range"
   Else If InStr(reorder, "imghminu")
      defaultSort := "Histogram minimum"
   Else If (StrLen(prevFilesSortMode)>2 && !Instr(reorder, "imgidu"))
      defaultSort := prevFilesSortMode
   Else 
      defaultSort := "None/manual"

   Return defaultSort
}

MenuMoveMarkedEntries() {
    EntryMarkedMoveIndex := 1
    moveMarkedEntryNow(currentFileIndex, "move")
}

moveMarkedEntryNow(indexu, modus:=0) {
   If StrLen(filesFilter)>1
   {
      showTOOLtip("WARNING: Index entries cannot be reordered when the files list is filtered.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (thumbsDisplaying!=1 || maxFilesIndex<2)
      Return

   If !isNumber(indexu)
      indexu := currentFileIndex

   If !EntryMarkedMoveIndex
   {
      EntryMarkedMoveIndex := indexu
   } Else If (EntryMarkedMoveIndex=indexu)
   {
      EntryMarkedMoveIndex := 0
   } Else If isNumber(EntryMarkedMoveIndex)
   {
      If (modus="move")
         reorderIndexEntryManually(EntryMarkedMoveIndex, indexu)
      Else
         switchIndexEntries(EntryMarkedMoveIndex, indexu)

      ; currentFileIndex := EntryMarkedMoveIndex
      EntryMarkedMoveIndex := 0
   }

   mainGdipWinThumbsGrid()
}

reorderIndexEntryManually(oldIndex, newFileIndex)  {
   Static countu := 0
   getSelectedFiles(0, 1)
   If markedSelectFile
   {
      newArrayu := []
      Loop, % maxFilesIndex
      {
          If resultedFilesList[A_Index, 2]
          {
             thisCounter++
             newArrayu[thisCounter] := resultedFilesList[A_Index]
          }
      }

      finalArrayu := []
      mainIndex := thisIndex := firstu := 0
      Loop, % maxFilesIndex
      {
          If (A_Index=newFileIndex)
          {
             Loop, % newArrayu.Count()
             {

                thisIndex++
                mainIndex++
                finalArrayu[mainIndex] := newArrayu[thisIndex]
                If !firstu
                   firstu := mainIndex
             }
          }

          If !resultedFilesList[A_Index, 2]
          {
             mainIndex++
             finalArrayu[mainIndex] := resultedFilesList[A_Index]
          }
      }

      resultedFilesList := []
      resultedFilesList := finalArrayu.Clone()
      currentFileIndex := firstu ? firstu : newFileIndex
   } Else
   {
      old := resultedFilesList.RemoveAt(oldIndex)
      resultedFilesList.InsertAt(newFileIndex, old)
      currentFileIndex := newFileIndex
   }

   ; prevLastImg[2] := prevLastImg[1]
   prevLastImg[2] := [oldIndex, resultedFilesList[oldIndex, 1]]
   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (SLDtypeLoaded=3 && countu<5)
   {
      countu++
      showTOOLtip("Reordering of index entries is temporary.`nThe changes are not saved in the database.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

switchIndexEntries(newFileIndex, oldIndex) {
   If (SLDtypeLoaded=3)
   {
      SQLstr := "UPDATE images SET imgidu=999999999 WHERE imgidu=" newFileIndex ";"
      If activeSQLdb.Exec(SQLStr)
      {
         SQLstr := "UPDATE images SET imgidu=" newFileIndex " WHERE imgidu=" oldIndex ";"
         If activeSQLdb.Exec(SQLStr)
         {
            SQLstr := "UPDATE images SET imgidu=" oldIndex " WHERE imgidu=999999999;"
            If !activeSQLdb.Exec(SQLStr)
            {
               addJournalEntry("Failed to change index entry position in the SQL database.")
               Return
            } ; Else ToggleDBdefaultSQLsort()
         }
      }
   }

   tempA := resultedFilesList[oldIndex, 1]
   tempB := resultedFilesList[newFileIndex, 1]
   ; ToolTip, % tempA "`n" tempB "`n" oldIndex "===" newFileIndex , , , 2
   resultedFilesList[oldIndex, 1] := tempB
   resultedFilesList[newFileIndex, 1] := tempA
   ; If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:"))
   ; {
   ;    tempA := bckpResultedFilesList[filteredMap2mainList[oldIndex], 1]
   ;    tempB := bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1]
   ;    bckpResultedFilesList[filteredMap2mainList[oldIndex], 1] := tempB
   ;    bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1] := tempA
   ; }

   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   currentFileIndex := oldIndex
   ; prevLastImg[2] := prevLastImg[1]
   prevLastImg[2] := [newFileIndex, resultedFilesList[newFileIndex, 1]]
   dummyTimerDelayiedImageDisplay(100)
}

PanelUpdateThisFileIndex(dummy:=0) {
    Global newFileName
    If (currentFileIndex=0)
       Return

   imgPath := getIDimage(currentFileIndex)
   fakeWinCreator(21, A_ThisFunc, 1)
   sqlSort := defineSQLdbSort()
   friendlyIndex := (maxFilesIndex>1) ? currentFileIndex "|" : ""
   If (!InStr(sqlSort, "none") && SLDtypeLoaded=3)
      friendlyIndex := ""

   If friendlyIndex
      msgInfos := "`n`nYou can type a new index number before | to move this entry elsewhere in the list."

   typeu := (userPrivateMode=1) ? " Password " : ""
   msgResult := msgBoxWrapper("panelu|Update files list index entry: " appTitle, "Please type the new file path and name.`nCurrent index: " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) "." msgInfos, "&Update entry|&Erase entry|&Browse file|C&ancel", 1, "modify-entry", 0, 0, 0, "limit9050" typeu, friendlyIndex imgPath)
   If InStr(msgResult.btn, "update")
   {
      newFileName := Trimmer(msgResult.edit)
      If (newFileName=imgPath) || (newFileName=currentFileIndex "|" imgPath)
         Return

      If askAboutFileSave(" and the current index entry will be updated")
         Return

      If (posu := InStr(newFileName, "|"))
      {
         newFileIndex := SubStr(newFileName, 1, posu - 1)
         newFileIndex := StrReplace(newFileIndex, ".")
         newFileIndex := StrReplace(newFileIndex, ",")
         If !isNumber(newFileIndex)
            newFileIndex := 0
         Else
            newFileIndex := clampInRange(newFileIndex, 1, maxFilesIndex)
 
         If (newFileIndex=currentFileIndex || maxFilesIndex<2)
            newFileIndex := 0
 
         newFileName := SubStr(newFileName, posu + 1)
         newFileName := Trimmer(newFileName)
      }

      If (!newFileName && maxFilesIndex>1)
      {
         remCurrentEntry(0)
         Return
      } Else If (newFileName!=imgPath && newFileName)
         r := UpdateIndexBTNaction(newFileName, currentFileIndex)

      If (!r && newFileName!=imgPath && newFileName)
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      } Else If (newFileIndex!=currentFileIndex && newFileIndex && friendlyIndex && !filesFilter)
         switchIndexEntries(newFileIndex, currentFileIndex)
   } Else If (InStr(msgResult.btn, "erase") && maxFilesIndex>1)
   {
      If askAboutFileSave(" and the current index entry will be erased")
         Return

      remCurrentEntry(0)
   } Else If InStr(msgResult.btn, "browse")
      BrowseReplaceIndexEntry()
   Else If (dummy="reopen")
      PanelRenameThisFile()
   If (dummy="reviewer")
      PanelReviewSelectedFiles()
}

PanelBrowseAudioAnnotation() {
    If (currentFileIndex=0 || SLDtypeLoaded!=3 || AnyWindowOpen)
       Return

   fakeWinCreator(38, A_ThisFunc, 1)
   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
   AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
   editFieldAudioFileu := StrLen(AudioFileu)>3 ? AudioFileu : OutDir "\" OutNameNoExt ". WAV or MP3 or WMA"

   msgResult := msgBoxWrapper("panelu|Associate audio file with image: " appTitle, "Please type or browse the file path of an audio file to associate with the current image.", "&Update entry|&Browse file|&Disassociate|C&ancel", 1, "audio-file", 0, 0, 0, "limit9050", editFieldAudioFileu)
   If InStr(msgResult.btn, "update")
   {
      AudioFileu := Trimmer(msgResult.edit)
      ; If InStr(AudioFileu, OutDir "\" OutNameNoExt ".") || !FileExist(AudioFileu)
      If !FileExist(AudioFileu)
      {
         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         showTOOLtip("ERROR: Incorrect file path, inexistent audio file or access denied:`n" OutFileName "`n" OutDir "\")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelBrowseAudioAnnotation, -150
         Return
      }

      updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
   } Else If InStr(msgResult.btn, "disassociate")
   {
      updateSQLdbEntryCaption(imgPath, "", "imgAudio")
   } Else If InStr(msgResult.btn, "browse")
   {
      patternObj := {}
      patternObj["Supported audio file formats"] := "*.wav;*.mp3;*.wma"
      startPath := AudioFileu ? AudioFileu : imgPath
      AudioFileu := openFileDialogWrapper("O", "FileMustExist", startPath, "Browse sound file", patternObj, chosenOption, 2)
      AudioFileu := Trimmer(AudioFileu)
      If StrLen(AudioFileu)>3
      {
         If AnyWindowOpen
            BtnCloseWindow()
         Sleep, 25
         updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
      }
      SetTimer, PanelBrowseAudioAnnotation, -150
   }
}

UIeditQuickMenuSearchTrigger() {
   delayu := (omniBoxMode=1) ? -250 : -50
   SetTimer, PopulateQuickMenuSearch, % delayu
}

PanelQuickSearchMenuOptions() {
    Global LVsearchMenus, StatusLineQuickSearch
    Static lastState := 0
    If (drawingShapeNow=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    mouseTurnOFFtooltip()
    thisState := "a" uiUseDarkMode PrefsLargeFonts
    If (createdQuickMenuSearchWin=1 && thisState=lastState && VisibleQuickMenuSearchWin=1)
    {
       WinActivate, ahk_id %hQuickMenuSearchWin%
       Return
    } Else If (createdQuickMenuSearchWin=1 && thisState=lastState)
    {
       Gui, QuickMenuSearchGUIA: Show
       EM_SETSEL(hEditMenuSearch, 0, StrLen(userQuickMenusEdit))
       VisibleQuickMenuSearchWin := 1
       interfaceThread.ahkassign("VisibleQuickMenuSearchWin", VisibleQuickMenuSearchWin)
       PopulateQuickMenuSearch("resel")
       SetTimer, updateUistatusLineQuickSearch, -50
       Return
    }

    Gui, QuickMenuSearchGUIA: Destroy
    Sleep, 25
    mr := (PrefsLargeFonts=1) ? 10 : 5
    Gui, QuickMenuSearchGUIA: Default
    Gui, QuickMenuSearchGUIA: -MaximizeBox -DPIScale +Resize +ToolWindow -MinimizeBox +Owner%PVhwnd% hwndhQuickMenuSearchWin
    Gui, QuickMenuSearchGUIA: Margin, % mr, % mr
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    If (uiUseDarkMode=1)
    {
       Gui, Color, % darkWindowColor, % darkWindowColor
       Gui, Font, c%darkControlColor%
       setDarkWinAttribs(hQuickMenuSearchWin)
    }

    thisBtnHeight := (PrefsLargeFonts=1) ? 34 : 24
    btnWid := 105
    txtWid := 360
    lstWid := 550
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 240
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Edit, x15 y15 Section -multi w%lstWid% gUIeditQuickMenuSearchTrigger vuserQuickMenusEdit +hwndhEditMenuSearch, % userQuickMenusEdit
    Gui, Add, Button, x+2 yp+0 w2 hp h%thisBtnHeight% -TabStop Default gBTNquickSearchHidden, &Execute
    Gui, Add, ListView, xs y+20 w%lstWid% +LV0x10000 +LV0x400 r%uLVr% -multi gLVquickSearchMenusResponder vLVsearchMenus +hwndhLVquickSearchMenus AltSubmit, X|Action|Shortcut|Menu|Keywords|Function|#|Score
    Gui, Add, Text, xs y+2 wp vStatusLineQuickSearch +0x200 h%thisBtnHeight% -wrap, Status bar...

    ; Gui, Add, Button, x+5 wp hp gBtnCloseWindow, C&lose
    VisibleQuickMenuSearchWin := 1
    createdQuickMenuSearchWin := 1
    interfaceThread.ahkassign("VisibleQuickMenuSearchWin", VisibleQuickMenuSearchWin)
    interfaceThread.ahkassign("hQuickMenuSearchWin", hQuickMenuSearchWin)
    lastState := thisState
    repositionWindowCenter("QuickMenuSearchGUIA", hQuickMenuSearchWin, PVhwnd, "Quick actions search")
    QuickMenuSearchGUIAGuiSize()
    PopulateQuickMenuSearch()
}

LVquickSearchMenusResponder(a:=0, b:=0, c:=0) {
   Critical, on
   Static lastInvoked := 1, doNotaskAgain := 0

   ; If (b="k")  
   ; ToolTip, % b "|" c , , , 2
   If (b="a" || b="i" || b="f") || (A_TickCount - zeitSillyPrevent<350) && (b!="DoubleClick" && b!="d")
      Return

   focusEdit := (b="k" && isInRange(c, 33, 40)) ? 0 : 1
   bfocusEdit := RegExMatch(b, "i)^(normal|s|f|i|c|d|a|colclick|right)") ? 1 : 0
   If (b="K" && c=112) ; f1
   {
      btnHelpQuickSearchMenus()
   } Else If (b="K" && c=113) ; F2
   {
      omniBoxFolderRename()
   } Else If (b="K" && c=114) ; F3
   {
      omniBoxFolderImport()
   } Else If (b="K" && c=116) ; F5
   {
      SetTimer, PopulateQuickMenuSearch, -150
   } Else If (b="K" && c=118) ; F7
   {
      omniBoxFolderCreateNew()
   } Else If (b="K" && c=45) ; Insert
   {
      omniBoxFolderOpen()
   } Else If (b="K" && c=119) ; F8
   {
      r := omniBoxFolderDelete()
      If (r="-" && omniBoxMode!=1)
      {
         closeQuickSearch()
         SetTimer, openPreviousPanel, -200
      }
   } Else If (b="K" && c=32) || (b="DoubleClick") ; enter
   {
      actu := (b="DoubleClick") ? "forced" : ""
      BTNquickSearchHidden(actu)
   } Else If (b="K" && c=93) ; appskey
   {
      QuickMenuSearchGUIAGuiContextMenu(hQuickMenuSearchWin, 0, "RightClick", 1, 0, 0)
   } Else If (b="D" && omniBoxMode=1) ; drag'n drop
   {
      Gui, QuickMenuSearchGUIA: Default
      GuiControlGet, userQuickMenusEdit
      edithu := Trimmer(userQuickMenusEdit)
      edithu := Trimmer(StrReplace(edithu, "\\", "\"), "\")
      r := info := ""
      initialRow := c
      initialFolder := OmniBoxGetSelectedFolder(c, "yes", edithu)
      prevMSGdisplay := 1
      While, determineLClickstate()
      {
         info := defineWindowUnderMouse()
         If InStr(info, "tooltip")
         {
            interfaceThread.ahkFunction("showOSDinfoLineNow", 500)
            Continue
         } Else If InStr(info, "tree")
         {
            LV_Modify(initialRow, "select")
            friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
            GetMouseCoord2wind(hTVlistFolders, nX, nY)
            nc := TVH_HitTest(hTVlistFolders, cr, nX, nY)
            If nc
            {
               Gui, fdTreeGuia: Default
               Gui, fdTreeGuia: TreeView, TVlistFolders
               TV_GetText(thisFolder, nc)
               TV_Modify(nc)
            }

            friendly .= "`nDestination: ." thisFolder "\"
            r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
            friendly .= A_Space r
         } Else If InStr(info, "main")
         {
            r := dc := nc := ""
            LV_Modify(initialRow, "select")
            r := GetKeyState("Shift", "P") ? "`nFolder is to be RECURSIVELY scanned." : "`nHold SHIFT for recursive scanning."
            friendly := "`nDrop folder here to import it into the current list." r
            ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
         } Else If InStr(info, "omnibox list")
         {
            thisFolder := r := dc := nc := ""
            GetMouseCoord2wind(hLVquickSearchMenus, nX, nY)
            dc := LV_EX_ItemHitTest(hLVquickSearchMenus, kp, nX, nY)
            thisFolder := OmniBoxGetSelectedFolder(dc, "yes", edithu)
            If (dc=initialRow || !thisFolder || thisFolder=initialFolder)
            {
               dc := thisFolder := ""
               LV_Modify(initialRow, "select")
            } Else
            {
               ; Gui, QuickMenuSearchGUIA: Default
               ; Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
               LV_Modify(dc, "select")
            }

            restu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
            friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
            r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
            friendly2 := "`nDestination: ." restu "\ " r
            friendly .= thisFolder ? friendly2 : "`nNo folder is currently underneath."
            ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
         } Else 
         {
            r := dc := nc := ""
            friendly := "No action associated to this pointer location"
         }

         If (A_TickCount - prevMSGdisplay>100)
         {
            externToolTiput(info friendly)
            prevMSGdisplay := A_TickCount
         }
      }

      If InStr(info, "main")
      {
         z := InStr(r, "scanned") ? "recursive" : "not"
         externTooltiput("Importing folder - please wait")
         omniBoxFolderImport(z, "yes")
      } Else If (InStr(info, "omnibox") && dc && thisFolder)
      {
         externTooltiput("-hide-")
         src := OmniBoxGetSelectedFolder(initialRow, "yes", edithu)
         dest := OmniBoxGetSelectedFolder(dc, "yes", edithu)
         rSrc := SubStr(src, InStr(src, "\", 0, -1) + 1)
         rDest := SubStr(dest, InStr(dest, "\", 0, -1) + 1)

         If (doNotAskAgain=0 && src!=dest && InStr(src, ":\") && InStr(dest, ":\") && r)
         {
            msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action inside the omnibox: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: .\" rSrc "\`nDestination: .\" rDest "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
            If !InStr(msgResult.btn, "Yes")
            {
               SetTimer, PopulateQuickMenuSearch, -200
               Return 1
            } Else doNotaskAgain := msgResult.check
         }

         If (InStr(r, "_") && src!=dest && InStr(src, ":\") && InStr(dest, ":\"))
         {
            externTooltiput("Please wait - performing folder action")
            r := UIcoreFolderPasteFoldersInto(0, "given", r, src, dest)
         }
         externTooltiput("-hide-")
      } Else If (InStr(info, "tree") && r && nc)
      {
         externTooltiput("-hide-")
         src := OmniBoxGetSelectedFolder(initialRow, "yes", edithu)
         dest := folderTreeGetSelectedPath(nc)
         If (doNotAskAgain=0 && src!=dest && InStr(src, ":\") && InStr(dest, ":\") && r)
         {
            msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action from the omnibox to the folders tree panel: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: ." src "\`nDestination: ." dest "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
            If !InStr(msgResult.btn, "Yes")
            {
               SetTimer, folderTreeInfoStatusLineUpdater, -125
               Return 1
            } Else doNotaskAgain := msgResult.check
         }

         externTooltiput("Please wait - performing folder action")
         If (InStr(r, "_") && src!=dest && InStr(src, ":\") && InStr(dest, ":\"))
         {
            r := UIcoreFolderPasteFoldersInto(0, "given", r, src, dest)
            If (r=2)
               folderTreeScanSubbies()
         }
      }
      externTooltiput("-hide-")
      prevent := 1
   } Else If (b="k" && c=8 && omniBoxMode=1) ; backspace
   {
      GoQuickSearchAction(0, "yes", "!OmniNavigateUpFolder")
   } Else If (bfocusEdit!=1 && focusEdit=1)
   {
      GuiControl, QuickMenuSearchGUIA: Focus, userQuickMenusEdit
      highlightActiveCtrl()
   }

   SetTimer, updateUistatusLineQuickSearch, -50
   zeitSillyPrevent := A_TickCount
   ; fnOutputDebug(a "=" b "=" c)
}

BTNquickSearchHidden(actu) {
   Gui, QuickMenuSearchGUIA: Default
   GuiControlGet, userQuickMenusEdit
   userQuickMenusEdit := Trimmer(userQuickMenusEdit)
   testu := SubStr(userQuickMenusEdit, 1, 1)

   If (testu=":")
   {
      thisu := StrReplace(userQuickMenusEdit, ":")
      If IsObject(thisu)
      {
         listu := ""
         For Key, Value in %thisu%
         {
             If (A_Index>15)
                Break
             listu .= Key "," Value "`n"
         }
      } If IsFunc(thisu)
      {
         funcu := 1
         %thisu%()
      } Else 
      {
         listu := %thisu%
         listu := thisu " = " listu
      }

      If !funcu
      {
         showTOOLtip("Result:`n" listu)
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   } Else If ((userQuickMenusEdit=";o" || userQuickMenusEdit=".\o"))
      fromFolderTreeToOmniBox("thisFile", prevOpenFolderPath)
   Else If ((userQuickMenusEdit=";f" || userQuickMenusEdit=".\f") && folderTreeWinOpen=1)
      fromFolderTreeToOmniBox()
   Else If (userQuickMenusEdit=";" || userQuickMenusEdit=".\")
      invokeOmniBoxCurrentFile()
   Else If GetKeyState("Alt", "P")
      omniBoxFolderImport()
   Else If (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P"))
      omniBoxFolderOpen()
   Else
      GoQuickSearchAction(actu)
}

updateUistatusLineQuickSearch() {
   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   RowNumber := LV_GetNext(0, "F")
   If !RowNumber
   {
      If (SubStr(userQuickMenusEdit, 2, 2)=":\")
         GuiControl, QuickMenuSearchGUIA:, StatusLineQuickSearch, % AnyWindowOpen ? "You cannot navigate through folders while a panel is opened." : "The provided folder path does not exist."
      Else
         GuiControl, QuickMenuSearchGUIA:, StatusLineQuickSearch, No results found matching the provided query.
      Return
   }

   LV_GetText(kbd, RowNumber, 3)
   LV_GetText(manu, RowNumber, 4)
   LV_GetText(funcu, RowNumber, 6)

   kbdu .= kbd!="" ? kbd : "NONE"
   kbdu := StrReplace(kbdu, "○", "Accelerator: ")
   If (omniBoxMode=1)
   {
      LV_GetText(kbdu, RowNumber, 7)
      If (kbdu>0)
         kbdu := kbdu " images"
   }

   manu := manu!="" ? " | " manu : " | ---"
   GuiControl, QuickMenuSearchGUIA:, StatusLineQuickSearch, % kbdu manu " | " funcu "()"
}

changeOptionQuickSearch(keyu) {
   Static lastInvoked := 1
   If (A_TickCount - zeitSillyPrevent<250)
      Return

   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   RowNumber := LV_GetNext(0, "F")
   totals := LV_GetCount()
   If !totals
      Return

   stepu := (A_TickCount - lastInvoked<100) ? 3 : 1
   okayu := (stepu=1) ? 1 : 0
   If InStr(keyu, "down")
      RowNumber := clampInRange(RowNumber + stepu, 1, totals, okayu)
   Else
      RowNumber := clampInRange(RowNumber - stepu, 1, totals, okayu)

   LV_Modify(RowNumber, "Select Focus Vis")
   lastInvoked := A_TickCount
   SetTimer, updateUistatusLineQuickSearch, -50
}

GoQuickSearchAction(dummy:="", isGiven:=0, ef:=0) {
   If (A_TickCount - zeitSillyPrevent<350) && (dummy!="forced")
      Return

   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   GuiControlGet, userQuickMenusEdit

   userQuickMenusEdit := Trimmer(userQuickMenusEdit)
   userQuickMenusEdit := Trimmer(StrReplace(userQuickMenusEdit, "\\", "\"), "\")
   RowNumber := LV_GetNext(0, "F")
   If !RowNumber
      Return

   LV_GetText(funcu, RowNumber, 6)
   If (isGiven="yes" && ef)
      funcu := ef

   If InStr(funcu, "!")
   {
      If !InStr(funcu, "!OmniNavigate")
         closeQuickSearch()

      prevOmniBoxFolder := ""
      If (funcu="!IndexJump")
      {
         currentFileIndex := clampInRange(StrReplace(userQuickMenusEdit, "@"), 1, maxFilesIndex)
         dummyTimerDelayiedImageDisplay(50)
      } Else If (funcu="!OmniOpenRfolder")
      {
         OpenFolders(userQuickMenusEdit)
      } Else If (funcu="!OmniNavigateFolder")
      {
         LV_GetText(OutputVar, RowNumber, 2)
         newLabelu := userQuickMenusEdit "\" Trim(Trimmer(OutputVar), "\")
      } Else If (funcu="!OmniNavigateFilteredFolders")
      {
         LV_GetText(OutputVar, RowNumber, 2)
         newLabelu := SubStr(userQuickMenusEdit, 1, InStr(userQuickMenusEdit, "\", 0, -1))
         newLabelu .= "\" Trim(Trimmer(OutputVar), "\")
      } Else If (funcu="!OmniNavigateUpFolder")
      {
         prevOmniBoxFolder := Trim(Trimmer(SubStr(userQuickMenusEdit, InStr(userQuickMenusEdit, "\", 0, -1) + 1)), "\")
         newLabelu := SubStr(userQuickMenusEdit, 1, InStr(userQuickMenusEdit, "\", 0, -1))
      } Else If (funcu="!OmniOpenFolder")
      {
         OpenFolders("|" userQuickMenusEdit)
      } Else If (funcu="!OmniImportFolder")
      {
         addNewFolder2list(userQuickMenusEdit, "yes", "not")
         ResetImgLoadStatus()
         currentFileIndex := maxFilesIndex - 1
         dummyTimerDelayiedImageDisplay(50)
      } Else If (funcu="!OmniImportRfolder")
      {
         addNewFolder2list(userQuickMenusEdit, "yes", "recursive")
         ResetImgLoadStatus()
         currentFileIndex := maxFilesIndex - 1
         dummyTimerDelayiedImageDisplay(50)
         SetTimer, TriggerMenuBarUpdate, -90
         SetTimer, createGUItoolbar, -100
      } Else If (funcu="!OmniNewInstance")
      {
         If (RegExMatch(userQuickMenusEdit, RegExFilesPattern) && FileExist(userQuickMenusEdit))
            OpenWithNewQPVinstance(0, userQuickMenusEdit, 2)
         Else
            OpenNewQPVinstance(userQuickMenusEdit)
      } Else If (funcu="!OmniOpenSLD")
      {
         OpenSLD(userQuickMenusEdit)
      } Else If (funcu="!OmniImportSLD")
      {
         If askAboutFileSave(" and the selected files list will be imported to the list")
            Return

         If StrLen(SelectedDir)>3
         {
            zPlitPath(userQuickMenusEdit, 1, fileu, SelectedDir)
            prevOpenFolderPath := SelectedDir
            INIaction(1, "prevOpenFolderPath", "General")
         }

         If (RegExMatch(userQuickMenusEdit, "i)(.\.sldb)$") && SLDtypeLoaded!=3)
            importSLDBintoPlainText(userQuickMenusEdit)
         Else If (RegExMatch(userQuickMenusEdit, "i)(.\.sldb)$") && SLDtypeLoaded=3)
            importSLDBintoSLDB(userQuickMenusEdit)
         Else If RegExMatch(userQuickMenusEdit, "i)(.\.sld)$")
            importSLDplainText(userQuickMenusEdit)
         currentFilesListModified := 1
         SetTimer, TriggerMenuBarUpdate, -90
         SetTimer, createGUItoolbar, -100
         SetTimer, ResetImgLoadStatus, -200
      } Else If (funcu="!OmniOpenImage")
      {
         If (allowRecordHistory=1)
            IniWrite, % userQuickMenusEdit, % mainSettingsFile, General, LastOpenedImg
         MenuOpenLastImg(userQuickMenusEdit)
      } Else If (funcu="!OmniImportImage")
      {
         zPlitPath(userQuickMenusEdit, 1, fileu, SelectedDir)
         mustOpenStartFolder := ""
         coreAddNewFiles(userQuickMenusEdit, 1, SelectedDir)
         GenerateRandyList()
         currentFilesListModified := 1
         currentFileIndex := maxFilesIndex
         ForceRefreshNowThumbsList()
         ResetImgLoadStatus()
         dummyTimerDelayiedImageDisplay(50)
         SetTimer, TriggerMenuBarUpdate, -90
         SetTimer, createGUItoolbar, -100
      }

      If InStr(funcu, "!OmniNavigate")
      {
         newLabelu := userQuickMenusEdit := StrReplace(newLabelu, "\\", "\")
         len := StrLen(newLabelu)
         ; ToolTip, % newLabelu "=" len "`n" userQuickMenusEdit , , , 2
         GuiControl, QuickMenuSearchGUIA:, userQuickMenusEdit, % newLabelu
         ; GuiControl, QuickMenuSearchGUIA: Focus, userQuickMenusEdit
         EM_SETSEL(hEditMenuSearch, len, len)
         SetTimer, PopulateQuickMenuSearch, -250
      }
   } Else If IsFunc(funcu)
   {
      closeQuickSearch()
      Sleep, 5
      %funcu%()
   } Else If IsLabel(funcu)
   {
      closeQuickSearch()
      Sleep, 5
      Gosub, %funcu%
   } Else
   {
      showTOOLtip("ERROR: Found no such function in the code to execute:`n" funcu "()")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

closeQuickSearch() {
   Critical, on
   lastTimeToggleThumbs := A_TickCount 
   Gui, QuickMenuSearchGUIA: Hide
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   ; hQuickMenuSearchWin := ""
   VisibleQuickMenuSearchWin := 0
   interfaceThread.ahkassign("VisibleQuickMenuSearchWin", VisibleQuickMenuSearchWin)
}

QuickMenuSearchGUIAGuiClose:
QuickMenuSearchGUIAGuiEscape:
   closeQuickSearch()
Return

QuickMenuSearchGUIAGuiSize() {     
   Critical, on
   ; (GuiHwnd, EventInfo, Width, Height)
   GetWinClientSize(Width, Height, hQuickMenuSearchWin, 0)
   If (!width || !height || VisibleQuickMenuSearchWin!=1)
      Return

   GetControlPosGui(hQuickMenuSearchWin, hEditMenuSearch, ex, ey, ew, eh)
   GetControlPosGui(hQuickMenuSearchWin, hLVquickSearchMenus, lx, ly, lw, lh)
   ; ToolTip, % eh "==" ey  , , , 2
   lvh := height - ly - eh
   lvy := ex + eh + 2
   yPos := lvy + lvh
   width -= 30
   GuiControl, QuickMenuSearchGUIA: Move, userQuickMenusEdit, w%width% 
   GuiControl, QuickMenuSearchGUIA: Move, LVsearchMenus, w%width% h%lvh% y%lvy%
   GuiControl, QuickMenuSearchGUIA: Move, StatusLineQuickSearch, y%yPos% w%width% h%eh%
   ; SoundBeep , 900, 100
   If determineLClickstate()
      SetTimer, QuickMenuSearchGUIAGuiSize, -300
}

GetControlPosGui(WinID, ctrlID, byref x, byref y, byref w, byref h) {
   ControlGetPos, exx, eyy, w, h, , ahk_id %ctrlID%
   GetClientPos(WinID, ex, ey, eww, ehh)
   x := exx - ex,   y := eyy - ey
   ; ToolTip, % y "==" eyy "==" ey , , , 2
}

MenuIncGIFspeed() {
   changeGIFsDelayu(1)
}

MenuDecGIFspeed() {
   changeGIFsDelayu(-1)
}

buildQuickSearchMenus() {
   mustPreventMenus := 1
   BuildMainMenu("forced")
   If (imgEditPanelOpened=1)
   {
      If (!isWinXP && A_OSVersion!="WIN_7")
      {
         kMenu("PVmenu", "Add/Uncheck", "Dar&k mode", "ToggleDarkModus", "disability handicap eyes eyesight black display")
         If (uiUseDarkMode=1)
            kMenu("PVmenu", "Check", "Dar&k mode")
      }

      kMenu("PVmenu", "Add/Uncheck", "&Large UI fonts", "ToggleLargeUIfonts", "disability handicap eyes eyesight large display")
      kMenu("PVmenu", "Add", "Increase viewport text size`t+", "MenuChangeZoomPlus", "disability handicap eyes eyesight large")
      kMenu("PVmenu", "Add", "Decrease viewport text size`t-", "MenuChangeZoomMinus", "disability handicap eyes eyesight large")
      keyword := (showMainMenuBar=1) ? " hide" : " display"
      kMenu("PVmenu", "Add/Uncheck", "Show &menu bar`tF10", "ToggleQuickBaru", "toolbar" keyword)
      If (showMainMenuBar=1)
         kMenu("PVmenu", "Check", "Show &menu bar`tF10")

      keyword := (ShowAdvToolbar=1) ? "hide" : "display"
      kMenu("PVmenu", "Add/Uncheck", "Show &toolbar`tShift+F10", "toggleAppToolbar", keyword)
      If (ShowAdvToolbar=1)
         kMenu("PVmenu", "Check", "Show &toolbar`tShift+F10", "toggleAppToolbar")

      kMenu("PVmenu", "Add", "&New QPV instance`tCtrl+Shift+N", "OpenNewQPVinstance")
      kMenu("PVmenu", "Add", "Cop&y file path(s) as text`tShift+C", "CopyImagePath", "clipboard")
      kMenu("PVmenu", "Add", "Open file in a new &QPV instance`tCtrl+Enter", "SoloNewQPVinstance")
      kMenu("PVmenu", "Add", "&Explore the containing folder`tCtrl+E", "OpenThisFileFolder", "external")
      kMenu("PVmenu", "Add/Uncheck", "&Apply gamma correction", "toggleImgEditGammaCorrect")
      If (userimgGammaCorrect=1)
         kMenu("PVmenu", "Check", "&Apply gamma correction")
      If (PrefsLargeFonts=1)
         kMenu("PVmenu", "Check", "&Large UI fonts")
   } Else If !AnyWindowOpen
   {
      If (maxFilesIndex>1 && CurrentSLD)
         kMenu("PVmenu", "Add", "&Identify favourited images in the list", "findFavesInList", "faved faves stared")

      kMenu("PVmenu", "Add", "O&pen QPV settings folder", "openSettingsDir")
      kMenu("PVmenu", "Add", "&Visit official QPV site", "OpenGitHub")
      kMenu("PVmenu", "Add", "&Make a donation via PayPal", "DonateNow")
      kMenu("PVmenu", "Add", "&Close everything`tCtrl+F4", "closeDocuments")
      If (thumbsDisplaying=1)
      {
         kMenu("PVmenu", "Add/Uncheck", "&Two lines status bar", "ToggleMultiLineStatus", "statusbar info")
         If (multilineStatusBar=1)
            kMenu("PVmenu", "Check", "&Two lines status bar")
      }

      kMenu("PVmenu", "Add/Uncheck", "Allow WIC loader", "ToggleWICloader")
      If (allowWICloader=1)
         kMenu("PVmenu", "Check", "Allow WIC loader")

      kMenu("PVmenu", "Add/Uncheck", "Allow FreeImage loader", "ToggleFIMloader")
      kMenu("PVmenu", "Add/Uncheck", "Private mode UI", "TogglePrivateMode")
      If (userPrivateMode=1)
         kMenu("PVmenu", "Check", "Private mode UI")
      If (allowFIMloader=1)
         kMenu("PVmenu", "Check", "Allow FreeImage loader")
      If (isImgEditingNow()=1 && animGIFsSupport=1)
      {
         kMenu("PVmenu", "Add", "&Increase GIFs playback speed`Alt+.", "MenuIncGIFspeed")
         kMenu("PVmenu", "Add", "&Decrease GIFs playback speed`Alt+,", "MenuDecGIFspeed")
      }
   }

   zeitSillyPrevent := A_TickCount
   BuildSecondMenu()
}

PopulateQuickMenuSearch(a:=0, b:=0, c:=0) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<350) && (a!="resel")
   {
      SetTimer, PopulateQuickMenuSearch, -150
      SetTimer, updateUistatusLineQuickSearch, -200
      Return
   }

   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   GuiControlGet, userQuickMenusEdit
   userQuickMenusEdit := Trimmer(userQuickMenusEdit)
   userQuickMenusEdit := allowCtrlBkspEdit(hEditMenuSearch, userQuickMenusEdit)
   userQuickMenusEdit := Trimmer(StrReplace(userQuickMenusEdit, "\\", "\"), "\")
   RowNumber := LV_GetNext(0, "F")
   initialCount := LV_GetCount()
   omniBoxMode := 0
   interfaceThread.ahkassign("omniBoxMode", omniBoxMode)
   GuiControl, -Redraw, LVsearchMenus
   prevEditu := userQuickMenusEdit
   mustReselect := 0
   LV_Delete()
   allowMenuSearch := 1
   If (SubStr(userQuickMenusEdit, 1, 1)="@" && maxFilesIndex>1 && CurrentSLD && !AnyWindowOpen)
   {
      IndexJump := 1
      userQuickMenusEdit := StrReplace(userQuickMenusEdit, "@")
   } Else If (SubStr(userQuickMenusEdit, 2, 2)=":\" && !AnyWindowOpen)
   {
      pathModus := 1
      allowMenuSearch := 0
   }

   OutDir := SubStr(userQuickMenusEdit, 1, InStr(userQuickMenusEdit, "\", 0, -1))
   If (isNumber(userQuickMenusEdit) && IndexJump=1)
   {
      allowMenuSearch := 0
      labelu := PathCompact(resultedFilesList[userQuickMenusEdit, 1], 50)
      xu := resultedFilesList[userQuickMenusEdit, 2] ? "■" : "○"
      If labelu
         LV_Add(1, xu, labelu, "-", "Files list index", "", "!IndexJump", 1, 1)
   } Else If ((FolderExist(OutDir) || FolderExist(userQuickMenusEdit)) && pathModus=1 && !RegExMatch(userQuickMenusEdit, RegExFilesPattern))
   {
      hasAddedItems := 0
      allowMenuSearch := 0
      If FolderExist(userQuickMenusEdit)
      {
         hasAddedItems += 2
         labelu1 := "Open folder"
         labelu2 := "Open folder recursively"
         LV_Add(1, xu, labelu1, "-", "-", "", "!OmniOpenFolder", 1, 8)
         LV_Add(1, xu, labelu2, "-", "-", "", "!OmniOpenRfolder", 1, 9)
         If (CurrentSLD && maxFilesIndex>1)
         {
            hasAddedItems += 2
            labelu3 := "Import folder into list"
            labelu4 := "Import folder recursively into list"
            LV_Add(1, xu, labelu3, "-", "-", "", "!OmniImportFolder", 1, 1)
            LV_Add(1, xu, labelu4, "-", "-", "", "!OmniImportRfolder", 1, 5)
         }
      }

      startOperation := A_TickCount
      setImageLoading()
      doStartLongOpDance()
      abandonAll := hasAddedSubs := 0
      showTOOLtip("Scanning for files and folders in`n" userQuickMenusEdit "\")
      GuiControl, QuickMenuSearchGUIA:, StatusLineQuickSearch, Scanning folder content...
      omniBoxMode := 1
      interfaceThread.ahkassign("omniBoxMode", omniBoxMode)
      hasAddedItems++
      filesFound := 0
      LV_Add(A_Index, xu, "...\", "-", "Folder: up-one level", "", "!OmniNavigateUpFolder", 0, 0)
      Loop, Files, % Trimmer(userQuickMenusEdit, "\") "\*", DF
      {
         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         If InStr(A_LoopFileAttrib, "D")
         {
            hasAddedSubs++
            hasAddedItems++
            LV_Add(A_Index, xu, "\" A_LoopFileName, "-", "Change folder", "", "!OmniNavigateFolder", 0, 0)
            If (A_LoopFileName=prevOmniBoxFolder && prevOmniBoxFolder)
               mustReselect := hasAddedItems
         } Else If RegExMatch(A_LoopFileFullPath, RegExFilesPattern)
            filesFound++
      }

      LV_Modify(1, "Col7", filesFound)
      LV_Modify(2, "Col7", ">" filesFound)
      If (CurrentSLD && maxFilesIndex>1)
      {
         LV_Modify(3, "Col7", filesFound)
         LV_Modify(4, "Col7", ">" filesFound)
      }

      If (!hasAddedSubs && userPrivateMode!=1 && abandonAll!=1)
      {
         restu := SubStr(userQuickMenusEdit, InStr(userQuickMenusEdit, "\", 0, -1) + 1)
         OutDir := SubStr(userQuickMenusEdit, 1, InStr(userQuickMenusEdit, "\", 0, -1))
         Loop, Files, % Trimmer(OutDir, "\") "\*", DF
         {
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
               Break

            If (InStr(A_LoopFileAttrib, "D") && InStr(A_LoopFileName, restu) && restu!=A_LoopFileName)
               LV_Add(A_Index, xu, "\" A_LoopFileName, "-", "Change folder", "", "!OmniNavigateFilteredFolders", 0, 0)
         }
      }
      RemoveTooltip()
      ResetImgLoadStatus()
   } Else If (FileRexists(userQuickMenusEdit) && pathModus=1 && RegExMatch(userQuickMenusEdit, RegExFilesPattern))
   {
      allowMenuSearch := 0
      labelu1 := "Open image"
      labelu3 := "Open image in a new instance of QPV"
      LV_Add(1, xu, labelu1, "-", "-", "", "!OmniOpenImage", 1, 7)
      LV_Add(1, xu, labelu3, "-", "-", "", "!OmniNewInstance", 1, 3)
      If (CurrentSLD && maxFilesIndex>1)
      {
         labelu2 := "Import image into list"
         LV_Add(1, xu, labelu2, "-", "-", "", "!OmniImportImage", 1, 9)
      }
   } Else If (FileRexists(userQuickMenusEdit) && pathModus=1 && RegExMatch(userQuickMenusEdit, sldsPattern))
   {
      allowMenuSearch := 0
      labelu1 := "Open files list file"
      LV_Add(1, xu, labelu1, "-", "-", "", "!OmniOpenSLD", 1, 7)
      If (CurrentSLD && maxFilesIndex>1)
      {
         labelu2 := "Import files list"
         LV_Add(1, xu, labelu2, "-", "-", "", "!OmniImportSLD", 1, 9)
      }
   }

   zeitSillyPrevent := A_TickCount
   If (allowMenuSearch=1)
   {
      omniBoxMode := 0
      interfaceThread.ahkassign("omniBoxMode", omniBoxMode)
      deleteMenus()
      buildQuickSearchMenus()
      objs := kMenu(0, "give", 0)
      userQuery := fuzzifyString(prevEditu)
      userQuery := StrSplit(userQuery, A_Space)
      matches := score := 0
      mainList := objs[1]
      groups := objs[3]
      thisList := new hashtable()
      fzgrupu := zgrupu := accels := ""
      Loop, % mainList.Count()
      {
         score := 0
         groupu := mainList[A_Index, 6]
         fgroupu := mainList[A_Index, 12]
         zgrupu := Trimmer(groups[groupu, 1])
         fzgrupu := Trimmer(groups[groupu, 3])
         accels := groups[groupu, 4]
         If (zgrupu && groups[groupu, 2])
         {
            zkl := groups[groupu, 2]
            If (zkl && groups[zkl, 1])
            {
               zgrupu :=  Trimmer(groups[zkl, 1]) " \ " zgrupu
               fzgrupu .= A_Space groups[zkl, 3]
               accels := (accels && groups[zkl, 4]) ? accels ", " groups[zkl, 4] : ""
               xkl := groups[zkl, 2]
               If (xkl && groups[xkl, 2])
               {
                  zgrupu := Trimmer(groups[xkl, 1]) " \ " zgrupu
                  fzgrupu .= A_Space groups[xkl, 3]
                  accels := (accels && groups[xkl, 4]) ? accels ", " groups[xkl, 4] : ""
               }
            }
         }

         groupu := zgrupu ? " \ " zgrupu : " \ " groupu
         groupu := StrReplace(groupu, " \ PVmenu")
         fgroupu := fzgrupu ? fzgrupu : fgroupu
         fgroupu := StrReplace(fgroupu, "PVmenu")
         labelu := Trimmer(mainList[A_Index, 1])
         flabelu := mainList[A_Index, 9]
         keywords := mainList[A_Index, 3]
         fkwds := mainList[A_Index, 10]
         funcu := mainList[A_Index, 2]
         ffuncu := mainList[A_Index, 11]
         zlu := (mainList[A_Index, 4]=1 && funcu!="dummy") ? flabelu A_Space fgroupu A_Space fkwds A_Space ffuncu : ""
         ; fnOutputDebug(editF2 "===" zlu)
         haystacku := StrSplit(zlu, A_Space)
         If userQuickMenusEdit
         {
            offsetu := 0
            userCountWords := userQuery.Count()
            Loop, % userCountWords
            {
               thisUserWord := userQuery[A_Index]
               If !thisUserWord
                  Continue

               matches := 0
               If StrLen(thisUserWord)<3
               {
                  If (thisUserWord= haystacku[A_Index])
                     score += 10
                  score += ST_Count(zlu, thisUserWord)
               } Else
               {
                  If InStr(haystacku[A_Index], thisUserWord)
                     score += 15

                  Loop, % haystacku.Count()
                  {
                     haysWord := haystacku[A_Index]
                     If !haysWord
                        Continue

                     offsetu += 0.006
                     score += fuzzybit(thisUserWord, haysWord, 0.85 + offsetu, exactMatch)
                     matches += exactMatch
                  }

                  If (matches>=userCountWords)
                     score += matches*2
               }
            }
            If (score<1.1)
               Continue
         }

         If (mainList[A_Index, 4] && funcu!="dummy")
         {
            kbdu := mainList[A_Index, 7]
            If (!kbdu && mainList[A_Index, 8])
               kbdu := "○" mainList[A_Index, 8]

            If !thisList[funcu labelu]
            {
               xu := (mainList[A_Index, 5]=1) ? "■" : ""
               If (mainList[A_Index, 5]=-1)
                  xu := "○"

               thisList[funcu labelu] := 1
               LV_Add(A_Index, xu, labelu, kbdu, StrReplace(groupu, " \ ", "\"), keywords, funcu, A_Index, Round(score*100))
            }
         }
      }
   }

   groups := thisList := mainList := ""
   mustPreventMenus := 0
   Loop, 8
       LV_ModifyCol(A_Index, "AutoHdr Left")

   LV_ModifyCol(7, "Integer")
   LV_ModifyCol(8, "Integer")
   LV_ModifyCol(8, "SortDesc")
   If (allowMenuSearch=0 && pathModus=1 && mustReselect>0 && prevOmniBoxFolder)
      LV_Modify(mustReselect, "Focus Select Vis")
   Else If (a="resel" && LV_GetCount()=initialCount && RowNumber)
      LV_Modify(RowNumber, "Focus Select Vis")
   Else 
      LV_Modify(1, "Focus Select Vis")

   ; prevOmniBoxFolder := ""
   mustReselect := 0
   GuiControl, +Redraw, LVsearchMenus
   zeitSillyPrevent := A_TickCount
   lastInvoked := A_TickCount
   SetTimer, updateUistatusLineQuickSearch, -50
}

fuzzifyString(toFuzz) {
   master := RegExReplace(toFuzz, "i)(e|i)", "e")
   master := RegExReplace(master, "i)(o|u)", "o")
   master := StrReplace(master, "ou", "o")
   master := StrReplace(master, "ee", "e")
   master := StrReplace(master, "oo", "o")
   master := StrReplace(master, "pp", "p")
   master := StrReplace(master, "dd", "d")
   master := StrReplace(master, "ll" , "l")
   master := StrReplace(master, "ss" , "s")
   master := StrReplace(master, "yi", "y")
   master := StrReplace(master, "  ", " ")
   Return master
}

fuzzybit(fuzz, master, limitu, ByRef exactMatch) {
/*
Name: fuzzybit
Version 1.0 (Thursday, April 23, 2020)
Created: Thursday, April 23, 2020
Author: tidbit

Description:
   a loose fuzzy search. 

   fuzz   = string to look for, in order
   master = where to look in
   
   returns a percentage. if half of the letters we found in the proper order, returns 0.5
   fuzzybit("abc", "abc") = 1.0
   fuzzybit("aac", "abc") = 0.6667 ; contains the 'a' and 'c' in proper order, but no 'b'
   fuzzybit("bac", "abc") = 0.6667 ; all the letters exist, but not in a proper order

out:="abc `t abc`t=`t" fuzzybit("abc", "abc")
. "`nalffp `t A_LoopFileFullPath`t=`t" fuzzybit("alffp", "A_LoopFileFullPath")
. "`nalffd `t A_LoopFileFullPath`t=`t" fuzzybit("alffd", "A_LoopFileFullPath")
msgbox % fuzzybit("aloo", "A_LoopFileFullPath")
msgbox % fuzzybit("aloog", "A_LoopFileFullPath")
msgbox % fuzzybit("alog", "A_LoopFileFullPath")
; modified by Marius Șucan   
*/

   ; ToolTip, % master "=" fuzz , , , 2
   score := 0, posu := 1
   exactMatch := 0
   If (StrLen(master)<2)
   {
      Return 0
   } Else If (StrLen(fuzz)=1)
   {
      Return (ST_Count(master, fuzz)+1)/StrLen(master)
   } Else If (master=fuzz)
   {
      exactMatch := 5
      score := 20
   } Else If RegExMatch(master, "i)^(" fuzz ")")
   {
      exactMatch := 0.1
      score := 15
   } Else If InStr(master, fuzz)
   {
      score := 6.5
   }

   If (ST_Count(master, fuzz)>1)
      score += 0.2

   If (exactMatch=5 || score>7)
      Return score

   hasFound :=0
   ; ToolTip, % "s=" score , , , 2
   for k, char in StrSplit(fuzz)
   {
      segment := substr(master, posu)
      foundPos := inStr(segment, char)
      if (foundPos>0)
      {
         hasFound := 1
         master := segment
         score += 1
         posu := foundPos + 1
         continue ; we found a match, check the next letter to find
      }
   }
   If !hasFound
      score -= 4

   r := score/strLen(fuzz)
   If (r<limitu)
      r := 0
 
   return r
}

PanelSetSlidesMusic() {
   If !CurrentSLD
      Return

   fakeWinCreator(67, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Associate song with slideshow: " appTitle, "Please type or browse the file path of an audio file to associate with the current slideshow / files list. The selected file will be played during the slideshow.", "&Update|&Browse file|&Disassociate|&Test|&Close", 1, "audio-file", 0, 0, 0, "limit9050", SlidesMusicSong)
   AudioFileu := Trimmer(msgResult.edit)
   If (InStr(msgResult.btn, "update") && audioFileu)
   {
      If !FileExist(AudioFileu)
      {
         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         msgBoxWrapper(appTitle ": ERROR", "ERROR: Incorrect file path, inexistent audio file or access denied:`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
         ; SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelSetSlidesMusic, -150
         Return
      }
      If (SlidesMusicSong!=AudioFileu)
         currentFilesListModified := 1

      zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      SlidesMusicSong := AudioFileu
      autoPlaySlidesAudio := 1
      saveMusicSlideInfos()
      showTOOLtip("Slideshow music is now set to`n" OutFileName "`n" OutDir "\")
   } Else If (InStr(msgResult.btn, "disassociate") || (InStr(msgResult.btn, "update") && !audioFileu))
   {
      If StrLen(SlidesMusicSong)>3
         currentFilesListModified := 1
      SlidesMusicSong := ""
      autoPlaySlidesAudio := 0
      saveMusicSlideInfos()
      showTOOLtip("Slideshow music set to: NONE")
   } Else If (InStr(msgResult.btn, "test") && StrLen(SlidesMusicSong)>3)
   {
      zPlitPath(SlidesMusicSong, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      startSlidesMusicNow()
      If hSNDsong
      {
         milisec := MCI_Length(hSNDsong)
         lenghtu := MCI_ToHHMMSS(milisec)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Currently playing: " OutFileName " ( " lenghtu " ).`n`nPlease confirm you can hear the audio file.", 4, 0, "question")
         StopMediaPlaying(1)
         If (msgResult="no")
         {
            SlidesMusicSong := ""
            autoPlaySlidesAudio := 0
            saveMusicSlideInfos()
            SetTimer, PanelSetSlidesMusic, -120
            Return
         }
      } Else msgBoxWrapper(appTitle ": ERROR", "ERROR: Unable to properly decode the audio file.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
      SetTimer, PanelSetSlidesMusic, -120
   } Else If InStr(msgResult.btn, "browse")
   {
      patternObj := {}
      patternObj["Supported audio file formarts"] := "*.wav;*.mp3;*.wma"
      startPath := StrLen(SlidesMusicSong)>3 ? SlidesMusicSong : CurrentSLD
      AudioFileu := openFileDialogWrapper("O", "FileMustExist", startPath, "Browse music file", patternObj, chosenOption, 2)
      AudioFileu := Trimmer(AudioFileu)
      If StrLen(AudioFileu)>3
      {
         If (SlidesMusicSong!=AudioFileu)
            currentFilesListModified := 1

         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         If AnyWindowOpen
            BtnCloseWindow()
         Sleep, 25
         SlidesMusicSong := AudioFileu
         autoPlaySlidesAudio := 1
         saveMusicSlideInfos()
         showTOOLtip("Slideshow music is now set to`n" OutFileName "`n" OutDir "\")
      }
      SetTimer, PanelSetSlidesMusic, -150
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

saveMusicSlideInfos() {
   If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
   {
      INIaction(1, "SlidesMusicSong", "General")
      INIaction(1, "autoPlaySlidesAudio", "General")
      currentFilesListModified := 0
   } Else If (SLDtypeLoaded=3)
   {
      IniSLDBWrite("autoPlaySlidesAudio", autoPlaySlidesAudio)
      IniSLDBWrite("SlidesMusicSong", SlidesMusicSong)
      currentFilesListModified := 0
   } Else currentFilesListModified := 1
}

fileImgFormatsOpenDialog(modus:=0) {
    patternObj := []
    patternObj["All files"] := "*.*"
    patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
    patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.ico"
    patternObj["JPEGs"] := "*.jpg;*.j2k;*.jfif;*.jng;*.jp2;*.jif;*.jxr;*.jpe;*.jpeg"
    patternObj["TIFFs"] := "*.tif;*.tiff"
    patternObj["Windows BMP"] := "*.bmp"
    patternObj["PNG"] := "*.png"
    patternObj["HDR / OpenEXR"] := "*.hdr;*.exr"
    patternObj["GDI+ supported"] := "*.bmp;*.dib;*.rle;*.jpg;*.jpeg;*.jfif;*.gif;*.tif;*.tiff;*.png;*.ico;*.wmf;*.emf"
    If (WICmoduleHasInit=1 && InStr(openFptrnWIC, "*."))
       patternObj["WIC-only supported"] := openFptrnWIC
    If (modus=1)
       patternObj["QPV slideshows"] := "*.sld;*.sldb"
    Return patternObj
}

BrowseReplaceIndexEntry() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   ; pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn3 ")"
   ; pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
   patternObj := fileImgFormatsOpenDialog(0)
   imgPath := openFileDialogWrapper("O", "FileMustExist", prevOpenFolderPath, "Replace index entry...", patternObj, chosenOption, 3)
   imgPath := Trimmer(imgPath)
   If !imgPath
   {
      SetTimer, PanelUpdateThisFileIndex, -150
      Return "cancel"
   }

   If AnyWindowOpen
      BtnCloseWindow()
   Sleep, 25
   If StrLen(imgPath)>3
   {
      zPlitPath(imgPath, 0, OutFileName, SelectedDir)
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      If askAboutFileSave(" and the current index entry will be updated")
         Return

      r := UpdateIndexBTNaction(imgPath, currentFileIndex)
      If !r
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      }
   }
   ResetImgLoadStatus()
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

SingularRenameFile() {
   PanelRenameThisFile("single")
}

askAboutFileCollision(srcFile, destFile, allowSkip, doLastOption, forceOption, ByRef performOverwrite) {
   Static lastOption, useLastOption := 0

   If (doLastOption=3)
   {
      lastOption := useLastOption := 0
      Return
   }

   zPlitPath(srcFile, 0, sOutFileName, sOutDir)
   zPlitPath(destFile, 0, dOutFileName, dOutDir, dfileNamuNoEXT, dFileExt)
   If (doLastOption=2)
      useLastOption := 1
   Else If (doLastOption=1)
      useLastOption := 0

   skipBtn := (allowSkip=1) ? "&Skip file|" : ""
   checkBtn := (allowSkip=1) ? "&Do not prompt again, apply the same option for all the subsequent conflicts" : ""
   If (useLastOption=1 && lastOption)
   {
      msgResult := lastOption
   } Else If !isInRange(forceOption, 1, 3)
   {
      FileGetSize, destFileSizu, % destFile, K
      FileGetSize, srcFileSizu, % srcFile, K
      FileGetTime, srcFileDateM, % srcFile, M
      FileGetTime, destFileDateM, % destFile, M
      FormatTime, srcFileDateM, % srcFileDateM, dddd, d MMMM yyyy, HH:mm
      FormatTime, destFileDateM, % destFileDateM, dddd, d MMMM yyyy, HH:mm
      msgResult := msgBoxWrapper(appTitle ": File name conflict", "SOURCE FILE:`n" sOutFileName "`n" groupDigits(srcFileSizu) " Kilobytes (" srcFileDateM ")`n" sOutDir "\`n`nFile name conflict. Do you want to overwrite the destination file?`n`nDESTINATION FILE:`n" dOutFileName "`n" groupDigits(destFileSizu) " Kilobytes (" destFileDateM ")`n" dOutDir "\", "&Overwrite|&Auto-rename|" skipBtn "C&ancel", 2, "question", checkBtn, doLastOption)
   }

   If IsObject(msgResult)
      useLastOption := msgResult.check

   If (forceOption=1)
      msgResult := "skip"
   Else If (forceOption=2)
      msgResult := "auto-rename"
   Else If (forceOption=3)
      msgResult := "overwrite"

   performOverwrite := 0
   msgR := IsObject(msgResult) ? msgResult.btn : msgResult
   If InStr(msgR, "rename")
   {
      performOverwrite := 2
      Loop
      {
          r := dOutDir "\" dfileNamuNoEXT " [" A_Index "]." dFileExt
          If !FileExist(r)
             Break
      } Until (A_Index>9500)
   } Else If InStr(msgR, "overwrite")
   {
      performOverwrite := 1
      r := destFile
   } Else If InStr(msgR, "skip")
      r := ""
   Else If InStr(msgR, "cancel" || InStr(msgR, "win_close"))
      r := "abort"
   Else
      lastOption := r := msgR := ""

   lastOption := (r="abort") ? "" : msgR
   Return r
}

PanelRenameThisFile(dummy:=0) {
    Global newFileName
    Static doLastOption := 0
    If (currentFileIndex=0)
       Return

    getSelectedFiles(0, 1)
    If (markedSelectFile>1 && dummy!="single")
    {
       PanelMultiRenameFiles()
       Return
    }

    Sleep, 2
    file2rem := StrReplace(getIDimage(currentFileIndex), "||")
    zPlitPath(file2rem, 0, OutFileName, OutDir)
    resultedFilesList[currentFileIndex, 1] := file2rem
    If !FileExist(file2rem)
    {
       showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Sleep, 900
       PanelUpdateThisFileIndex()
       Return
    }

   fakeWinCreator(7, A_ThisFunc, 1)
   undoBtn := FileExist(lastRenameUndo[2]) ? "&Undo previous|" : ""
   fileMsg := (userPrivateMode=1) ? "" : "File location:`n" OutDir "\`n`n"
   typeu := (userPrivateMode=1) ? " Password " : ""
   msgResult := msgBoxWrapper("panelu|Rename file: " appTitle, fileMsg "Please type the new file name.", "&Rename file|" undoBtn "&Modify index entry|C&ancel", 1, "modify-file", "On file name collision, use previously given answer", doLastOption, 0, "limit9050" typeu, OutFileName)
   If InStr(msgResult.btn, "Rename")
   {
      doLastOption := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      file2rem := getIDimage(currentFileIndex)
      zPlitPath(file2rem, 0, OutFileName, OutDir)
      If ((Trimmer(OutFileName)=newFileName) || !newFileName)
         Return

      If askAboutFileSave(" and the current file will be renamed and reloaded")
         Return

      r := RenameBTNaction(Trimmer(msgResult.edit), file2rem, doLastOption + 1)
      If !r 
      {
         Sleep, 100
         PanelRenameThisFile(dummy)
      } Else
      {
         file2rem := getIDimage(currentFileIndex)
         If (resultedFilesList[currentFileIndex, 5]=1)
            ToggleImgFavourites(file2rem, "rem")

         resultedFilesList[currentFileIndex, 5] := 0
         updateMainUnfilteredList(currentFileIndex, 5, 0)
         CreateGuiButton("Undo rename,,undoFileRenameAction", 0, msgDisplayTime//1.5 + 500)
      }
   } Else If InStr(msgResult.btn, "modify")
      PanelUpdateThisFileIndex("reopen")
    Else If InStr(msgResult.btn, "undo")
      undoFileRenameAction()
}

PanelSetThumbColumnOptions() {
    If (thumbsDisplaying!=1 || thumbsListViewMode>1 && thumbsDisplaying=1)
    {
       If (thumbsDisplaying!=1)
          PanelColorsAdjusterWindow()
       Return
    }

    thisBtnHeight := createSettingsGUI(40, A_ThisFunc)
    btnWid := 100, btnHeight := 25
    txtWid := slideWid := 210
    txtWid2 := txtWid + 80
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 135
       txtWid2 := txtWid2 + 195
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "fadeOtherDupeGroups", "General", 1)
    ReadSettingsVPgrid()
    slideWid2 := txtWid//2 + 10
    Global UIthumbsAratio, UIvpImgAlignCenter
    UIvpImgAlignCenter := (imageAligned=5) ? 1 : 0
    UIthumbsAratio := thumbsAratio + 1
    thisW := (PrefsLargeFonts=1) ? 90 : 65
    Gui, Add, Text, x15 y15 Section w%txtWid2%, Please note, most of the options listed here are shared with the full image view.
    Gui, Add, Text, xs y+15 w%slideWid2%, Flip thumbnails:
    Gui, Add, Checkbox, x+10 wp-15 gupdateUIthumbsView Checked%FlipImgH% vFlipImgH, &horizontally
    Gui, Add, Checkbox, x+10 gupdateUIthumbsView Checked%FlipImgV% vFlipImgV, &vertically
    Gui, Add, Text, xs y+15 w%slideWid2%, Highlight images:
    Gui, Add, Checkbox, x+10 wp-15 gupdateUIthumbsView Checked%highlightAlreadySeenImages% vhighlightAlreadySeenImages, &already seen
    Gui, Add, Checkbox, x+10 gupdateUIthumbsView Checked%markSearchMatches% vmarkSearchMatches, &matching search query
    Gui, Add, DropDownList, xs y+15 w%txtWid% gupdateUIthumbsView AltSubmit Choose%imgFxMode% vimgFxMode, Original image colors|Personalized colors|-|Grayscale|Red channel|Green channel|Blue channel|-|Inverted colors|Sepia
    Gui, Add, Button, x+5  w%thisW% hp vbtnFldr1 gHardResetImageView, &Reset
    Gui, Add, DropDownList, xs y+5 w%txtWid% gupdateUIthumbsView AltSubmit Choose%usrColorDepth% vusrColorDepth, Simulate color depth|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]
    Gui, Add, Checkbox, x+5 hp gupdateUIthumbsView Checked%ColorDepthDithering% vColorDepthDithering, Dithering
    Gui, Add, DropDownList, xs y+5 w%slideWid2% AltSubmit gupdateUIthumbsView Choose%UIthumbsAratio% vUIthumbsAratio, Aspect ratios|Wide (1.81)|Tall (0.48)|Square (1.00)
    Gui, Add, Checkbox, x+10 hp gupdateUIthumbsView Checked%UIvpImgAlignCenter% vUIvpImgAlignCenter, &Centered alignment
    Gui, Add, Checkbox, xs y+10 gupdateUIthumbsView Checked%fadeOtherDupeGroups% vfadeOtherDupeGroups, Fade the other groups of image duplicates
    Gui, Add, Checkbox, xs y+10 gupdateUIthumbsView Checked%multilineStatusBar% vmultilineStatusBar, Two lines status bar
    Gui, Add, Text, xs y+15 hp +0x200 w%slideWid2%, Thumbnail columns:
    Gui, Add, Edit, x+10 w70 gupdateUIthumbsView number -multi limit3 veditF5, % thumbsColumns
    Gui, Add, UpDown, gupdateUIthumbsView vthumbsColumns Range2-99, % thumbsColumns
    Gui, Add, Text, xs+15 y+7 w%txtWid2%, You can press the + / - keys or Ctrl + Wheel Up / Down to increase or decrease the number of columns.

    If !testIsDupesList()
       GuiControl, SettingsGUIA: Disable, fadeOtherDupeGroups

    If (mustRecordSeenImgs!=1)
       GuiControl, SettingsGUIA: Disable, highlightAlreadySeenImages

    If StrLen(userSearchString)<2
       GuiControl, SettingsGUIA: Disable, markSearchMatches

    If (minimizeMemUsage=1)
       GuiControl, SettingsGUIA: Disable, imgFxMode

    Gui, Add, Button, xs y+25 w%thisW% h%thisBtnHeight% Default gBtnCloseWindow, &Close
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Thumbnails options: " appTitle, winPos)
}

updateUIthumbsView() {
   If (AnyWindowOpen!=40)
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   GuiControlGet, UIvpImgAlignCenter
   GuiControlGet, UIthumbsAratio
   act := (usrColorDepth>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, ColorDepthDithering
   act := (imgFxMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, btnFldr1

   ; thumbsColumns := editF5
   imageAligned := (UIvpImgAlignCenter=1) ? 5 : 1
   thumbsAratio := clampInRange(UIthumbsAratio - 1, 1, 3)
   defineColorDepth()
   recalculateThumbsSizes()
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   ; SetTimer, DeepRefreshThumbsNow, -50
   SetTimer, WriteThumbnailsSettingsPanel, -200
}

WriteThumbnailsSettingsPanel() {
   INIaction(1, "ColorDepthDithering", "General")
   INIaction(1, "fadeOtherDupeGroups", "General")
   INIaction(1, "FlipImgH", "General")
   INIaction(1, "FlipImgV", "General")
   INIaction(1, "highlightAlreadySeenImages", "General")
   INIaction(1, "imageAligned", "General")
   INIaction(1, "imgFxMode", "General")
   INIaction(1, "markSearchMatches", "General")
   INIaction(1, "multilineStatusBar", "General")
   INIaction(1, "thumbsAratio", "General")
   INIaction(1, "thumbsColumns", "General")
   INIaction(1, "usrColorDepth", "General")
}

PanelSetSystemCores() {
   EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
   fakeWinCreator(41, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Multi-threading options: " appTitle, "Please specify the number of threads to use when generating thumbnails or batch processing files. Maximum allowed threads on this system is " thisSystemCores ".`n`nAfter changing this value, a restart of QPV might be necessary.", "&Apply|&Cancel", 1, "gear", "Allow multi-threaded processing [experimental]", allowMultiCoreMode, 0, "limit2 number", userMultiCoresLimit)
   If InStr(msgResult.btn, "apply")
   {
      allowMultiCoreMode := msgResult.check
      userMultiCoresLimit := Trimmer(msgResult.edit)
      userMultiCoresLimit := clampInRange(userMultiCoresLimit, 2, thisSystemCores)
      INIaction(1, "allowMultiCoreMode", "General")
      INIaction(1, "userMultiCoresLimit", "General")
      realSystemCores := userMultiCoresLimit
      If (thumbsDisplaying=1 && thumbsListViewMode=1 && multiCoreThumbsInitGood="n")
         initAHKhThumbThreads()
      ; dummyTimerDelayiedImageDisplay(50)
   }
}

PanelSaveSlideShowu() {
    Global usePrevSaveFolder := 0, userDesiredSlideFMT := 1

    If (maxFilesIndex<2)
    {
       showTOOLtip("WARNING: Insufficient image files are indexed")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    thisBtnHeight := createSettingsGUI(36, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 360
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    showSave := (SLDtypeLoaded>1 && FileRexists(CurrentSLD)) || InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") ? 1 : 0
    INIaction(0, "prevFileSavePath", "General", 6)
    userDesiredSlideFMT := (SLDtypeLoaded=3) ? 2 : 1
    If (SLDtypeLoaded=3)
       SLDcacheFilesList := 1

    dlWid := editWid - btnWid2
    Gui, Add, Text, x15 y15 Section, Slideshow format for save as:
    Gui, Add, DropDownList, xs y+5 w%dlWid% gUItoggleSLDformat AltSubmit Choose%userDesiredSlideFMT% vuserDesiredSlideFMT, .SLD - Plain-text format|.SLDB - SQLite Database format (file details cached)
    If (showSave=1)
       Gui, Add, Button, x+1 hp w%btnWid2% gBTNsaveSlideshowPanel, Save &as

    Gui, Add, Checkbox, xs y+10 Checked%SLDcacheFilesList% vSLDcacheFilesList, Cache files list (ensures rapid slideshow loading)`nIf this is left unchecked, only the dynamic folders list will be saved.
    If (SLDtypeLoaded=3)
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList

    ; Gui, Add, Checkbox, xs y+10 Checked%ForceRegenStaticFolders% vForceRegenStaticFolders, Regenerate static folders list`nThe static folders list enables partial files list later updates
    Gui, Add, Text, xs y+10 w%EditWid%, Regardless of the chosen format, the current %appTitle% settings will be stored.
    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
       infoThisSLD := "Currently opened: «Favourite images list» (plain-text)."
    Else If (SLDtypeLoaded=2)
       infoThisSLD := "Currently opened: plain-text files list`n" CurrentSLD
    Else If (SLDtypeLoaded=3)
       infoThisSLD := "Currently opened: SQLite database files list`nMost actions applied on the files index are automatically saved. Under rare circumstances resaving is required.`n" CurrentSLD
    Else
       infoThisSLD := "No saved files list currently opened."

    If (SLDtypeLoaded=2 && currentFilesListModified=1)
       infoThisSLD .= "`nFiles list has been modified. The changes are unsaved."

    btnWid3 := InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") ? 2 : btnWid
    Gui, Add, Text, xs y+20 w%EditWid%, % infoThisSLD
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid3% gBTNopenPanelDynamicFolderzWindow, &Manage folders

    If (showSave=1)
       Gui, Add, Button, x+5 hp w%btnWid2% Default gBTNsaveCurrentSlideshow, &Save
    Else
       Gui, Add, Button, x+5 hp w%btnWid2% Default gBTNsaveSlideshowPanel, Save &as

    If (maxFilesIndex>1 && CurrentSLD && dbVersion!=dbExpectedVersion && SLDtypeLoaded=3)
       Gui, Add, Button, x+5 hp w%btnWid2% gBTNrebuildDBpanel, &Rebuild

    Gui, Add, Button, x+15 hp w%btnWid2% gBTNhelpSlideshows, &Help
    Gui, Add, Button, x+5 hp wp-5 gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save indexed files list: " appTitle)
    checkDLLfiles()
}

BTNrebuildDBpanel() {
    msgResult := msgBoxWrapper(appTitle ": WARNING", "This database was saved by an older version of " appTitle ". The entire index structure needs to be rebuilt. QPV will now recreate this database with the new structure.`n`nPlease note: all the cached data pertaining to the indexed images will be lost.", "&Continue|C&ancel", 2, "exclamation")
    If !InStr(msgResult, "continue")
       Return

    BtnCloseWindow()
    rebuildDBfilesList()
}

BTNhelpSlideshows() {
    msgBoxWrapper(appTitle ": HELP", "In the plain-text SLD format QPV can store:`n- the settings pertaining to the viewport and slideshow`n- a folders list [so-called «main» folders list]; this is the source of the files list and can be [re]scanned at any time.`n- the actual files list. If it is not cached / present when the SLD is opened, the main folders list will be scanned for images to populate the files list index.`n- a «static» folders list; this list is automatically generated when the SLD is saved based on the indexed files' paths - only if the user chooses to cache the files list. In later sessions, one can rescan any of these folders, allowing users to selectively update the files list whenever needed.`n`nIn addition to all of the above, the SQL-Lite database SLDB format can store:`n- image captions [no need for external text files] and also allows users to attach audio files to image files without the constraint of having them located in the same folder(s) with the image(s).`n- file and image details cache: file size, file date created, modified, image information (resolution, pixel format, histogram details and so on)`n`nThe caching of data facilitates management of large image collections, because files list sorting, image and file statistics are performed MUCH faster once the data is cached. The cached data is stored and reused between sessions and can be generated gradually in multiple QPV sessions.", -1, 0, 0)
}

BTNopenPanelDynamicFolderzWindow() {
    PanelDynamicFolderzWindow("reopen")
}

BTNsaveCurrentSlideshow() {
    BtnCloseWindow()
    Sleep, 1
    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
       renewFavesListBasedOnIndexList()
    Else If (SLDtypeLoaded=2 && FileRexists(CurrentSLD) && maxFilesIndex>0)
       SaveFilesList(CurrentSLD)
    Else If (SLDtypeLoaded=3 && FileRexists(CurrentSLD) && maxFilesIndex>0)
       SaveDBfilesList(CurrentSLD)
    Else If (maxFilesIndex>1 && CurrentSLD)
       PanelSaveSlideShowu()
    ; BtnCloseWindow()
}

UItoggleSLDformat() {
    GuiControlGet, userDesiredSlideFMT
    If (userDesiredSlideFMT=1)
    {
       GuiControl, SettingsGUIA: Enable, SLDcacheFilesList
    } Else
    {
       SLDcacheFilesList := 1
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList
       GuiControl, , SLDcacheFilesList, 1
    }
}

BTNsaveSlideshowPanel() {
    Gui, SettingsGUIA: Default
    GuiControlGet, SLDcacheFilesList
    GuiControlGet, userDesiredSlideFMT
    If (userDesiredSlideFMT=1)
       SaveFilesList()
    Else
       SaveDBfilesList()

    RecentFilesManager(CurrentSLD)
}

FolderExist(filePath) {
   If StrLen(filePath)<4
      Return

   Return InStr(FileExist(filePath), "D")
}

PanelSaveImg() {
    Global userDestinationFolder, editF5, UserCropOnSave, usePrevSaveFolder := 0

    If (thumbsDisplaying=1)
    {
       PanelSaveSlideShowu()
       Return
    }

    If throwErrorNoImageLoaded()
       Return

    thisBtnHeight := createSettingsGUI(35, A_ThisFunc)
    btnWid := 100
    txtWid := 330
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := (PrefsLargeFonts=1) ? btnWid - 40 : btnWid - 25
    RegAction(0, "userDesireWriteFMT",, 2, 1, 16)
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)

    INIaction(0, "prevFileSavePath", "General", 6)
    RegAction(0, "usePrevSaveFolder",, 1)
    RegAction(0, "PreserveDateTimeOnSave",, 1)
    RegAction(0, "userJpegQuality",, 2, 1, 100)

    ; Gui, Add, Text,, Default destination format:
    ; Gui, Add, DropDownList, x+10 w85 gTglDesiredSaveFormat AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, % userPossibleWriteFMTs
    entriesList := StrReplace(recentOpenedFolders(), "`n", "|")
    delim := InStr(entriesList, prevFileSavePath "|") ? "|" : ""
    entriesList := StrReplace(entriesList, prevFileSavePath delim, prevFileSavePath "||")
    If StrLen(entriesList)<4
    {
       usePrevSaveFolder := 0
       GuiControl, Disable, usePrevSaveFolder
    } Else If !InStr(entriesList, "||")
       entriesList .= "|"

    UserCropOnSave := 0
    imgPath := getIDimage(currentFileIndex)
    If (InStr(imgPath, "\temporary memory object\") || !imgPath)
    {
       fileStatus := imgPath "`n`nImage bitmap unsaved to disk."
    } Else
    {
       fileStatus := PathCompact(imgPath, 47)
       If !FileExist(imgPath)
          fileStatus .= "`n`nThe image file no longer seems to exist. It will be recreated on save."
       Else If (currentImgModified=1)
          fileStatus .= "`n`nThe image has been modified."
       Else If (currentImgModified=2)
          fileStatus .= "`n`nThe image changes have been saved."
       Else
          fileStatus .= "`n`nThe image has not been modified."
    }

    oldTimes := lastZeitIMGsaved[1]
    FormatTime, timea, % oldTimes , HH:mm
    If oldTimes
       InfosPreviousSave := "Last time saved: " timea "`n" PathCompact(lastZeitIMGsaved[5] "\" lastZeitIMGsaved[4], 47) "`nUndo levels state: " lastZeitIMGsaved[2] "/" lastZeitIMGsaved[3]

    QPV_FileGetSizeTime(imgPath, "R", currentFileIndex)
    ofileSizu := resultedFilesList[currentFileIndex, 6]
    fileSizu := (ofileSizu>15) ? fileSizeFrienly(ofileSizu) : "N/A"
    If (ofileSizu>15)
    {
       FileDateM := QPV_FileGetSizeTime(imgPath, "M", currentFileIndex)
       yday += -1, days
       Try formattime, yday, %yday%, dd/MM/yyyy
       Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
       Try FormatTime, nowDate, % A_Now, dd/MM/yyyy
       If InStr(FileDateM, yday)
          FileDateM := "Yesterday, " FileDateM
       Else If InStr(FileDateM, nowDate)
          FileDateM := "Today, " FileDateM
       FileDateM := "`nLast modified: " FileDateM
    }

    depthChoice := (currIMGdetails.HasAlpha=1) ? 1 : 2
    thisWid := (PrefsLargeFonts=1) ? 70 : 45
    ; Gui, Add, Checkbox, Checked%UserCropOnSave% vUserCropOnSave, C&rop image to selected area on save
    Gui, Add, Checkbox, x15 y15 Section gTglUsePrevSaveFoderu Checked%usePrevSaveFolder% vusePrevSaveFolder, &Open file dialog in a previous location
    Gui, Add, DropDownList, xp+15 y+7 wp+135 vuserDestinationFolder, % entriesList
    Gui, Add, Text, xs y+10 hp +0x200, Save options
    ; Gui, Add, Text, xs y+0 wp h2 +0x1007, 
    Gui, Add, Checkbox, xp+15 y+10 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Text, y+7 hp +0x200, Quality `%:
    Gui, Add, Edit, x+5 w%thisWid% number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    thisWid := (PrefsLargeFonts=1) ? 145 : 115
    Gui, Add, DropDownList, x+10 w%thisWid% AltSubmit Choose%depthChoice% vuserSaveBitsDepth, 32 bits RGBA|24 bits RGB|16 bits RGB|8 bits RGB [256 colors]
    Gui, Add, Button, x+5 w40 hp gbtnHelpSaveImgPanel , ?
    Gui, Add, Text, xs y+10, Image file status
    ; Gui, Add, Text, xs y+0 wp h2 +0x1007, 
    Gui, Add, Text, xp+15 y+7 w%txtWid% -wrap, % "File size: " fileSizu FileDateM "`n" fileStatus
    If oldTimes
    {
       Gui, Add, Text, xs y+10, Previous file saved:
       Gui, Add, Text, xp+15 y+7 w%txtWid% +wrap, % InfosPreviousSave
    }

    If (editingSelectionNow!=1 || testSelectOutsideImgEntirely(useGdiBitmap()))
       GuiControl, Disable, UserCropOnSave

    If !usePrevSaveFolder
       GuiControl, Disable, userDestinationFolder

    btnWid2 := (PrefsLargeFonts=1) ? btnWid - 40 : btnWid - 25
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBTNsaveImgPanel, &Save image
    Gui, Add, Button, x+0 h%thisBtnHeight% w35 gBTNsaveBrowseImgPanel, &AS
    Gui, Add, Button, x+15 hp w%btnWid% gBtnCopyImageClip, &Copy to clipboard
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save image file: " appTitle)
}

btnHelpSaveImgPanel() {
   msgBoxWrapper(appTitle ": HELP", "Quality level applies only for JPG, JP2, J2K, JXR and WEBP files.`n`nThe color depth option is not applicable to all of the  supported image file formats.", -1, 0, 0)
}

PanelBrushTool(dummy:=0, modus:=0) {
    Static userWasWarned := 0
    initQPVmainDLL()
    If (dupesDCTcoeffsInit!=1 && userWasWarned=0)
    {
       userWasWarned := 1
       msgBoxWrapper(appTitle ": WARNING", appTitle " has failed to initialize the main DLL file: qpvmain.dll. Options within this panel and others will likely not function properly.", 0, 0, "error")
    }

    openingPanelNow := 1
    If !(thisBtnHeight := createSettingsGUI(64, A_ThisFunc, 1, 1))
       Return

    btnWid := 100
    EditWid := 395
    txtWid := 285, slideWid := 155
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 60
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    slideWid2 := slideWid//2
    Global infoBrushAopacity, infoBrushBopacity, infoBrushSize, infoBrushAngle, infoBrushDrying, infoBrushBlurel
    , infoBrushAspectRatio, infoBrushSoftness, infoBrushWetness, PickuBrushToolAcolor, PickuBrushToolBcolor
    , infoBrushStepping, UIbtnBrushColorA, UIbtnBrushColorB, uiBtnSetCloner, infoPasteHue, infoPasteSat
    , infoPasteLight, infoPasteGamma, infoBrushRandomSize, infoBrushRandomSoftness, infoBrushRandomAspectRatio
    , infoBrushRandomAngle, infoBrushRandomPosX, infoBrushRandomPosY, infoBrushRandomHue, infoBrushRandomSat
    , infoBrushRandomLight, infoBrushRandomDark, infoSymmetryLabel, BTNuiSetLabelSymmetry

    ReadSettingsBrushPanel()
    FloodFillSelectionAdj := 0
    liveDrawingBrushTool := 1
    interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
    thisOpacity := Round((BrushToolAopacity / 255) * 100)
    this2ndOpacity := Round((BrushToolBopacity / 255) * 100)
    If (modus="e" && isNumber(dummy))
    {
       BrushToolType := dummy
       If (BrushToolType=2)
          BrushToolWetness := 0
    } Else If (modus="w" && dummy=2)
    {
       ; wet soft brush
       If (BrushToolWetness<3)
          BrushToolWetness := 10
       BrushToolType := dummy
    } Else If (modus="b" && dummy=5)
    {
       ; blur FX brush
       BrushToolApplyColorFX := 0
       If (BrushToolBlurStrength<5)
          BrushToolBlurStrength := 25
       BrushToolType := dummy
    } Else If (modus="fx" && dummy=5)
    {
       ; colors FX brush
       BrushToolApplyColorFX := 1 
       BrushToolBlurStrength := 0
       BrushToolType := dummy
    }

    sml := (PrefsLargeFonts=1) ? 30 : 20
    Gui, Add, Tab3, AltSubmit Choose%thisPanelTab% vCurrentPanelTab gBtnTabsInfoUpdate hwndhCurrTab, General|Effects options|Randomize
    Gui, Tab, 1 ; general
    Gui, Add, DropDownList, x+15 y+15 w%slideWid% Section AltSubmit gupdateUIbrushTool Choose%BrushToolType% vBrushToolType, Simple solid color|Soft edges brush|Cloner|Eraser|Effects|Smudge|Pinch|Bulge
    ; Gui, Add, Checkbox, x+5 hp gupdateUIbrushTool Checked%BrushToolUseSecondaryColor% vBrushToolUseSecondaryColor , &Use secondary color
    Gui, Add, Checkbox, x+5 hp gupdateUIbrushTool Checked%BrushToolEraserRestore% vBrushToolEraserRestore , Restore pixels opacity
    Gui, Add, Button, xp yp hp wp gBtnSetClonerBrushSource vuiBtnSetCloner, &Define cloner source
    Gui, Add, Text, xs y+10 hp w%sml% +0x200 Center gBtnToggleBrushColors vUIbtnBrushColorA +TabStop +hwndhBtnTglClrA, [X]
    ToolTip2ctrl(hBtnTglClrA, "Toggle active color")
    Gui, Add, Slider, Center x+5 w%slideWid% gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolAopacity Range1-255, % BrushToolAopacity
    Gui, Add, Button, x+5 hp w%sml% gStartPickingColor vPickuBrushToolAcolor +hwndhBtnPickClrA, P
    ToolTip2ctrl(hBtnPickClrA, "Pick color A from the viewport")
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%BrushToolAcolor% vBrushToolAcolor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp +0x200 +Tabstop vinfoBrushAopacity gBtnResetBrushColorAopacity, 1011`%
    Gui, Add, Text, xs y+10 hp w%sml% +0x200 Center gBtnToggleBrushColors vUIbtnBrushColorB +TabStop +hwndhBtnTglClrB, [X]
    ToolTip2ctrl(hBtnTglClrB, "Toggle active color")
    Gui, Add, Slider, Center x+5 w%slideWid% gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolBopacity Range1-255, % BrushToolBopacity
    Gui, Add, Button, x+5 hp w%sml% gStartPickingColor vPickuBrushToolBcolor +hwndhBtnPickClrB, P
    ToolTip2ctrl(hBtnPickClrB, "Pick color B from the viewport")
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%BrushToolBcolor% vBrushToolBcolor hwndhLVfill2ndColor,
    Gui, Add, Text, x+5 hp +0x200 +TabStop vinfoBrushBopacity gBtnResetBrushColorBopacity, 1011`%

    ; Gui, Add, Text, xs y+15 w%slideWid2% vinfoBrushSize, Size: %BrushToolSize%
    Gui, Add, Checkbox, xs y+15 w%slideWid% gupdateUIbrushTool Checked%brushToolDoubleSize% vbrushToolDoubleSize, Diameter: 2000 px
    Gui, Add, Text, x+15 wp vinfoBrushStepping gBTNresetBrushStepu +TabStop, Stepping: %BrushToolStepping%
    Gui, Add, Slider, Center xs y+1 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolSize Range2-950, % BrushToolSize
    Gui, Add, Slider, Center x+15 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolStepping Range0-251, % brushToolStepping

    Gui, Add, Text, xs y+15 wp vinfoBrushAspectRatio gBTNresetBrushAspectRatio  +TabStop, Aspect ratio: %BrushToolAspectRatio%
    ; Gui, Add, Text, x+5 wp vinfoBrushAngle gBTNresetBrushAngle +TabStop, Angle: %BrushToolAngle%° 
    Gui, Add, Checkbox, x+15 wp Checked%BrushToolAutoAngle% vBrushToolAutoAngle gupdateUIbrushTool, Angle: %BrushToolAngle%00° 
    Gui, Add, Slider, Center xs y+1 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolAspectRatio Range-100-100, % BrushToolAspectRatio
    Gui, Add, Slider, Center x+15 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolAngle Range0-359, % BrushToolAngle

    Gui, Add, DropDownList, xs y+10 wp AltSubmit gupdateUIbrushTool Choose%BrushToolTexture% vBrushToolTexture, Soft circle|Texture 1|Texture 2|Texture 3|Texture 4|Texture 5|Texture 6|Texture 7|Texture 8
    ; Gui, Add, Text, xp yp wp vinfoBrushSoftness, Softness: %BrushToolSoftness%
    Gui, Add, Text, x+15 wp hp vinfoBrushDrying gBTNresetBrushDryer +TabStop, Dry-out rate: %BrushToolDryingRate%
    Gui, Add, Slider, Center xs y+2 wp gupdateUIbrushTool NoTicks ToolTip AltSubmit vBrushToolSoftness Range1-100, % BrushToolSoftness
    Gui, Add, Slider, Center x+15 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolDryingRate Range0-20, % BrushToolDryingRate

    Gui, -DPIScale
    Gui, Add, Text, xs y+10 w100 h100 +0x1000 +0xE +hwndhCropCornersPic gPanelsLivePreviewResponder +TabStop, Brush preview
    Gui, +DPIScale
    Gui, Add, Checkbox, x+10 gupdateUIbrushTool Checked%BrushToolOverDraw% vBrushToolOverDraw , &Airbrush mode / deformer option
    Gui, Add, Checkbox, y+10 gupdateUIbrushTool Checked%BrushToolDynamicCloner% vBrushToolDynamicCloner , D&ynamic X/Y source coordinates

    Gui, Tab, 2 ; FX
    Gui, Add, Text, x+15 y+15 Section w%slideWid% gBTNresetBrushBluru vinfoBrushBlurel +TabStop, Blur intensity: %BrushToolBlurStrength%
    Gui, Add, Text, x+5 wp vinfoBrushWetness gBTNresetBrushWet +TabStop, Wetness: %BrushToolWetness%
    Gui, Add, Slider, Center xs y+5 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolBlurStrength Range0-99, % BrushToolBlurStrength
    Gui, Add, Slider, Center x+5 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolWetness Range0-22, % BrushToolWetness

    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetPanelsSpecificControl vinfoPasteHue +TabStop, Hue: %PasteInPlaceHue%°
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIbrushTool vPasteInPlaceHue Range-180-180, % PasteInPlaceHue
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteSat +TabStop, Saturation: %PasteInPlaceSaturation%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIbrushTool vPasteInPlaceSaturation Range-100-100, % PasteInPlaceSaturation
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteLight +TabStop, Brightness: %PasteInPlaceLight%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIbrushTool vPasteInPlaceLight Range-255-255, % PasteInPlaceLight
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteGamma +TabStop, Contrast: %PasteInPlaceGamma%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIbrushTool vPasteInPlaceGamma Range-100-100, % PasteInPlaceGamma
    Gui, -DPIScale
    Gui, Add, Text, xs y+10 w100 h100 +0x1000 +0xE +hwndhCropCornersPic2 gPanelsLivePreviewResponder +TabStop, Brush preview
    Gui, +DPIScale
    sml := (PrefsLargeFonts=1) ? 60 : 40
    Gui, Add, Checkbox, x+10 gupdateUIbrushTool Checked%BrushToolApplyColorFX% vBrushToolApplyColorFX, Apply color adjustments
    Gui, Add, Text, y+10 vinfoSymmetryLabel, Symmetry on: 
    Gui, Add, Checkbox, x+5 w%sml% gupdateUIbrushTool Checked%BrushToolSymmetryX% vBrushToolSymmetryX, X
    Gui, Add, Checkbox, x+5 wp gupdateUIbrushTool Checked%BrushToolSymmetryY% vBrushToolSymmetryY, Y
    Gui, Add, Button, x+5 wp gBtnSetBrushSymmetryCoords vBTNuiSetLabelSymmetry, Set

    Gui, Tab, 3 ; randomize
    Gui, Add, Text, x+15 y+15 w%slideWid% vinfoBrushRandomSize gBtnResetBrushRandomSize +TabStop, Size: %BrushToolRandomSize%
    Gui, Add, Text, x+5 wp vinfoBrushRandomSoftness gBtnResetBrushRandomSoftness +TabStop, Softness: %BrushToolRandomSoftness%
    Gui, Add, Slider, Center xs y+1 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomSize Range0-200, % BrushToolRandomSize
    Gui, Add, Slider, Center x+5 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomSoftness Range0-80, % BrushToolRandomSoftness

    Gui, Add, Text, xs y+10 wp vinfoBrushRandomAspectRatio gBtnResetBrushRandomAspectRatio +TabStop, Aspect ratio: %BrushToolRandomAspectRatio%
    Gui, Add, Text, x+5 wp vinfoBrushRandomAngle gBtnResetBrushRandomAngle +TabStop, Angle: %BrushToolRandomAngle%° 
    Gui, Add, Slider, Center xs y+1 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomAspectRatio Range0-80, % BrushToolRandomAspectRatio
    Gui, Add, Slider, Center x+5 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomAngle Range0-150, % BrushToolRandomAngle

    Gui, Add, Text, xs y+10 wp vinfoBrushRandomPosX gBtnResetBrushRandomPosX +TabStop, Offset X: %BrushToolRandomPosX%
    Gui, Add, Text, x+5 wp vinfoBrushRandomPosY gBtnResetBrushRandomPosY +TabStop, Offset Y: %BrushToolRandomPosY%
    Gui, Add, Slider, Center xs y+1 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomPosX Range0-200, % BrushToolRandomPosX
    Gui, Add, Slider, Center x+5 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomPosY Range0-200, % BrushToolRandomPosY

    Gui, Add, Text, xs y+10 wp vinfoBrushRandomHue gBtnResetBrushRandomHue +TabStop, Hue: %BrushToolRandomHue%
    Gui, Add, Text, x+5 wp vinfoBrushRandomSat gBtnResetBrushRandomSat +TabStop, Saturation: %BrushToolRandomSat%
    Gui, Add, Slider, Center xs y+1 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomHue Range0-180, % BrushToolRandomHue
    Gui, Add, Slider, Center x+5 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomSat Range0-90, % BrushToolRandomSat

    Gui, Add, Text, xs y+10 wp vinfoBrushRandomLight gBtnResetBrushRandomLight +TabStop, Lightness: %BrushToolRandomLight%
    Gui, Add, Text, x+5 wp vinfoBrushRandomDark gBtnResetBrushRandomDark +TabStop, Darkness: %BrushToolRandomDark%
    Gui, Add, Slider, Center xs y+1 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomLight Range0-90, % BrushToolRandomLight
    Gui, Add, Slider, Center x+5 wp gupdateUIbrushTool NoTicks AltSubmit vBrushToolRandomDark Range0-90, % BrushToolRandomDark
    Gui, Add, Text, xs y+10, Please read the help section for more details.

    Gui, Tab 
    btnWid := (PrefsLargeFonts=1) ? 90 : 55
    Gui, Add, Button, xs-5 y+15 h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    Gui, Add, Button, x+5 hp w%btnWid% gBtnHelpBrushes, &Help
    Gui, Add, Button, x+5 hp wp-5 Default gBtnCloseWindow, C&lose
    Gui, Add, DropDownList, x+5 wp+60 gupdateUIbrushTool AltSubmit Choose%BrushToolOutsideSelection% vBrushToolOutsideSelection, Ignore selection|Paint inside|Paint outside
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Brushes tool: " appTitle, winPos)
    SetTimer, updateUIbrushTool, -125
    SetTimer, resetOpeningPanel, -300
}

BtnHelpBrushes() {
   msgBoxWrapper(appTitle ": HELP", "The brushes tool panel offers 8 distinct types of brushes and each customizable in its own ways. You can use keyboard shortcuts to switch brush types or control their settings when the main window is active. Please see the keyboard shortcuts help panel for more details.`n`nPlease note, the deformer brushes (smudge, pinch and bulge) give best results when the brush softness is set to about 45% and opacity 100%. These brushes may yield undesired results in areas with partially opaque pixels.`n`nBy setting stepping option to a low value, the application may freeze at times, while it paints brushes at every given step.`n`nSome of the brush randomize options apply only to some types of brushes. They might apply at the beginning of a brush stroke or continously during painting, based on brush settings.", -1, 0, 0)
}

btnHelpToolbar() {
   msgBoxWrapper(appTitle ": HELP", "The QPV toolbar contains multi-functional buttons that help users perform actions with ease. The associated actions may change depending on the currently active context or tool, even if the icons do not change visually. However, the tooltips will always reflect this. Regardless, the associated actions will always have a similar underlying meaning.`n`nSilder icons`nThe icons can act as sliders. You have to click and drag up or down to decrease the associated value; e.g., brush related parameters or image zoom level.`n`nTwo actions.`nThe tool tips may indicate L or R actions. These are actions associated with the Left and Right click buttons.`n`nThe toolbar can be navigated with the keyboard. To access it, one can press Shift+Tab. Once the toolbar is focused, users can use the arrow keys to navigate between the icons. Enter is associated with the L-click action and Shift+Enter to the R-click one.", -1, 0, 0)
}

ToggleBrushColors() {
   BtnToggleBrushColors("infoz")
}

readableColorFromHEX(given) {
   Gdip_FromARGB("0xFF" given, cA, cR, cG, cB)
   Return pixelColor := cR ", " cG ", " cB
}

BtnToggleBrushColors(dummy:=0) {
   ; If (BrushToolType!=1 && BrushToolType!=2)
   ;    Return

   BrushToolUseSecondaryColor := !BrushToolUseSecondaryColor
   If (AnyWindowOpen=70)
   {
      updateUIalphaMaskerPanel()
   } Else If (AnyWindowOpen=64)
   {
      updateUIbrushTool()
   } Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
   {
      updateUIpastePanel()
   } Else If (AnyWindowOpen=23 && liveDrawingBrushTool=1)
   {
      updateUIfillPanel()
   } Else If (AnyWindowOpen=23)
   {
      thisA := FillArea2ndColor
      thisB := FillAreaColor
      thisAop := FillArea2ndOpacity
      thisBop := FillAreaOpacity
      FillAreaColor := thisA
      FillArea2ndColor := thisB
      FillAreaOpacity := thisAop
      FillArea2ndOpacity := thisBop
      GuiControl, SettingsGUIA: +Background%thisB%, FillArea2ndColor
      GuiControl, SettingsGUIA: +Background%thisA%, FillAreaColor
      GuiControl, SettingsGUIA:, FillArea2ndOpacity, % FillArea2ndOpacity
      GuiControl, SettingsGUIA:, FillAreaOpacity, % FillAreaOpacity
      BrushToolAcolor := (BrushToolUseSecondaryColor=1) ? FillArea2ndColor : FillAreaColor
      BrushToolBcolor := (BrushToolUseSecondaryColor=1) ? FillAreaColor : FillArea2ndColor
      BrushToolAopacity := (BrushToolUseSecondaryColor=1) ? FillArea2ndOpacity : FillAreaOpacity
      BrushToolBopacity := (BrushToolUseSecondaryColor=1) ? FillAreaOpacity : FillArea2ndOpacity
   } Else If (AnyWindowOpen=30 || AnyWindowOpen=65)
   {
      If (BrushToolAcolor!=DrawLineAreaColor && BrushToolBcolor!=DrawLineAreaColor)
      {
         BrushToolAcolor := DrawLineAreaColor
         BrushToolAopacity := DrawLineAreaOpacity
      }
      thisA := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      thisAop := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      GuiControl, SettingsGUIA: +Background%thisA%, DrawLineAreaColor
      GuiControl, SettingsGUIA:, DrawLineAreaOpacity, % thisAop
      DrawLineAreaColor := thisA
      DrawLineAreaOpacity := thisAop
   } Else If (AnyWindowOpen=66) ; flood fill tool
   {
      If (BrushToolAcolor!=FloodFillColor && BrushToolBcolor!=FloodFillColor)
      {
         BrushToolAcolor := FloodFillColor
         BrushToolAopacity := FloodFillClrOpacity
      }
      thisA := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      thisAop := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      GuiControl, SettingsGUIA: +Background%thisA%, FloodFillColor
      GuiControl, SettingsGUIA:, FloodFillClrOpacity, % thisAop
      thisOpacity := Round((thisAop / 255) * 100)
      GuiControl, SettingsGUIA:, infoClrOpacity, %thisOpacity%`%
      FloodFillColor := thisA
      FloodFillClrOpacity := thisAop
   } Else If (AnyWindowOpen=68) ; fill behind tool
   {
      If (BrushToolAcolor!=FillBehindColor && BrushToolBcolor!=FillBehindColor)
      {
         BrushToolAcolor := FillBehindColor
         BrushToolAopacity := FillBehindClrOpacity
      }
      thisA := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      thisAop := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      GuiControl, SettingsGUIA: +Background%thisA%, FillBehindColor
      GuiControl, SettingsGUIA:, FillBehindClrOpacity, % thisAop
      thisOpacity := Round((thisAop / 255) * 100)
      GuiControl, SettingsGUIA:, infoOpacity,  Opacity: %thisOpacity%`%
      FillBehindColor := thisA
      FillBehindClrOpacity := thisAop
   } Else If (AnyWindowOpen=32 && liveDrawingBrushTool=1)
   {
      updateUIInsertTextPanel()
   } Else If (AnyWindowOpen=32)
   {
      thisA := TextInAreaBgrColor
      thisB := TextInAreaFontColor
      TextInAreaFontColor := thisA
      TextInAreaBgrColor := thisB
      thisAop := TextInAreaBgrOpacity
      thisBop := TextInAreaFontOpacity
      TextInAreaFontOpacity := thisAop
      TextInAreaBgrOpacity := thisBop
      GuiControl, SettingsGUIA: +Background%thisA%, TextInAreaFontColor
      GuiControl, SettingsGUIA: +Background%thisB%, TextInAreaBgrColor
      GuiControl, SettingsGUIA:, TextInAreaFontOpacity, % TextInAreaFontOpacity
      GuiControl, SettingsGUIA:, TextInAreaBgrOpacity, % TextInAreaBgrOpacity
      BrushToolAcolor := (BrushToolUseSecondaryColor=1) ? TextInAreaBgrColor : TextInAreaFontColor
      BrushToolBcolor := (BrushToolUseSecondaryColor=1) ? TextInAreaFontColor : TextInAreaBgrColor
      BrushToolAopacity := (BrushToolUseSecondaryColor=1) ? TextInAreaBgrOpacity : TextInAreaFontOpacity
      BrushToolBopacity := (BrushToolUseSecondaryColor=1) ? TextInAreaFontOpacity : TextInAreaBgrOpacity
   }

   If (dummy="infoz")
   {
      labelu := (AnyWindowOpen=64 || isNowAlphaPainting()) ? "Brush" : "Primary"
      thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      thisColorH := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      thisColor := readableColorFromHEX(thisColorH)
      moreInfos .= "`nOpacity: " Round(thisOpacity/255*100) "%"
      showLEDprimaryColor()
      If (BrushToolType>2 && AnyWindowOpen=64)
         showTOOLtip("Opacity: " Round(thisOpacity/255*100) "%`nThe current brush has no color option")
      Else
         showTOOLtip(labelu " color: " thisColor moreInfos, "ToggleBrushColors", 1)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } 

   If (ShowAdvToolbar=1)
   {
      delayedWriteTlbrColors(1)
      updateTlbrColorsSwatch()
   }

   If (imgEditPanelOpened=1 && AnyWindowOpen)
      livePreviewsImageEditing()
}

showLEDprimaryColor() {
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisColorH := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   GetPhysicalCursorPos(pX, pY)
   a := 2 - Round(thisOpacity/128, 2)
   f := Round(2*a, 2) - Round(thisOpacity/256, 2)
   z := Round(thisOpacity*f)
   If (z>192 || thisOpacity>100)
      z := 192 + (thisOpacity - 100)//2.5
   ; ToolTip, % a "=" f "=" z "=" thisOpacity, , , 2
   createLEDgui(imgHUDbaseUnit, clampInRange(z, 2, 255), pX + 2, pY + 2, thisColorH)
   ; showLEDgui(thisColorH, pX + 2, pY + 2)
   SetTimer, StopColorPicker, % -msgDisplayTime//2 + 250
}

updateTlbrColorsSwatch() {
   thisHwnd := tlbrIconzList["BTNcolorsSwatch", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   tlbrSetImageIcon("colorz-swatch", thisHwnd, W, H)
}

distanceBetweenTwoPoints(x1, y1, x2, y2) {
   Return Sqrt((x2 - x1)**2+(y2 - y1)**2)
}

pointsOnCircle(radius, angle, cx, cy) {
    Static pi := 3.14159265
    obj := []
    angle := angle * (pi /180)   ; Convert from Degrees to Radians
    obj.x := cx + radius * sin(angle)
    obj.y := cy + radius * cos(angle)
    return obj
}

getAngleBetweenTwoPoints(x1, y1, x2, y2, mode:=1) {
   ; function from tidbit
   ; based on http://stackoverflow.com/questions/2339487/calculate-angle-of-2-points
   ; returns 0-359.999
  angle := APIatan2(y1-y2, x1-x2)*(180/3.14159)*-1
  if (mode=2)
     angle += (angle<0) ? 360 : 0 ; or should it be 359? whatever.
  return angle
}

APIatan2(y,x) { 
   Return dllcall("msvcrt\atan2","Double",y, "Double",x, "CDECL Double")
}

ResetColorsToBW() {
   If (isNowAlphaPainting()=1 || BrushToolType!=3 && AnyWindowOpen=64)
   {
      showTOOLtip("Colors set to black and white")
      isOkay := (BrushToolAopacity>=254 && BrushToolBopacity>=254) ? 1 : 0
      SetTimer, RemoveTooltip, % -msgDisplayTime//1.5
      showLEDprimaryColor()
      isGood := (BrushToolAcolor="ffFFff" && BrushToolBcolor="000000") || (BrushToolBcolor="ffFFff" && BrushToolAcolor="000000") ? 1 : 0
      ; fnOutputDebug(isGood "." isOkay " opacities now:" BrushToolAopacity " / " BrushToolBopacity)
      If (isOkay=1 && isGood=1)
         Return

      BrushToolAcolor := "ffFFff"
      BrushToolBcolor := "000000"
      GuiControl, SettingsGUIA: +Background%BrushToolAcolor%, BrushToolAcolor
      GuiControl, SettingsGUIA: +Background%BrushToolBcolor%, BrushToolBcolor
      BtnResetBrushColorBopacity()
      BtnResetBrushColorAopacity()
      delayedWriteTlbrColors(1)
      showLEDprimaryColor()
      If (ShowAdvToolbar=1)
         updateTlbrColorsSwatch()
      lastInvoked := A_TickCount
   }
}

BtnSetClonerBrushSource() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<450)
      Return

   If (AnyWindowOpen!=64 || !isImgEditingNow())
      Return

   If (BrushToolType!=3)
      toggleBrushTypeCloner()

   liveDrawingBrushTool := 1
   showTOOLtip("Please click inside the image area to set the cloner brush source")
   ; SetTimer, RemoveTooltip, % -msgDisplayTime//2
   mustCaptureCloneBrush := 1
   interfaceThread.ahkassign("mustCaptureCloneBrush", mustCaptureCloneBrush)
   createGUItoolbar()
   If (panelWinCollapsed=0)
      toggleImgEditPanelWindow()
   lastInvoked := A_TickCount
}

BtnResetGradientCenter() {
   If (alphaMaskingMode>=1 && alphaMaskingMode!=5)
   {
      showTOOLtip("Alpha mask gradient center was reset")
      alphaMaskOffsetX := alphaMaskOffsetY := 0
      SetTimer, updateUIpastePanel, -150
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BtnSetTextureSource() {
   If (FillAreaColorMode!=6)
   {
      showTOOLtip("Color gradient center was reset")
      clrGradientOffX := clrGradientOffY := 0
      If (AnyWindowOpen=23)
         SetTimer, updateUIfillPanel, -150
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   showTOOLtip("Please click inside the image area to set the texture source coordinates")
   ; SetTimer, RemoveTooltip, % -msgDisplayTime//2
   mustCaptureCloneBrush := 1
   interfaceThread.ahkassign("mustCaptureCloneBrush", mustCaptureCloneBrush)
   createGUItoolbar()
   If (panelWinCollapsed=0)
      toggleImgEditPanelWindow()
}

BtnResetBrushRandomSize() {
   BrushToolRandomSize := 0
   GuiControl, SettingsGUIA:, BrushToolRandomSize, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomSoftness() {
   BrushToolRandomSoftness := 0
   GuiControl, SettingsGUIA:, BrushToolRandomSoftness, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomAspectRatio() {
   BrushToolRandomAspectRatio := 0
   GuiControl, SettingsGUIA:, BrushToolRandomAspectRatio, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomAngle() {
   BrushToolRandomAngle := 0
   GuiControl, SettingsGUIA:, BrushToolRandomAngle, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomPosX() {
    BrushToolRandomPosX := 0
    GuiControl, SettingsGUIA:, BrushToolRandomPosX, 0
    SetTimer, updateUIbrushTool, -50
 }

BtnResetBrushRandomPosY() {
    BrushToolRandomPosY := 0
    GuiControl, SettingsGUIA:, BrushToolRandomPosY, 0
    SetTimer, updateUIbrushTool, -50
 }

BtnResetBrushRandomHue() {
   BrushToolRandomHue := 0
   GuiControl, SettingsGUIA:, BrushToolRandomHue, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomSat() {
   BrushToolRandomSat := 0
   GuiControl, SettingsGUIA:, BrushToolRandomSat, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomLight() {
   BrushToolRandomLight := 0
   GuiControl, SettingsGUIA:, BrushToolRandomLight, 0
   SetTimer, updateUIbrushTool, -50
}

BtnResetBrushRandomDark() {
   BrushToolRandomDark := 0
   GuiControl, SettingsGUIA:, BrushToolRandomDark, 0
   SetTimer, updateUIbrushTool, -50
}

updateUIfloodFillPanel() {
   If (AnyWindowOpen!=66)
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide

   thisOpacity := Round((FloodFillClrOpacity / 255) * 100)
   GuiControl, SettingsGUIA:, infoClrOpacity, %thisOpacity%`%
   tolerance := (FloodFillAltToler=1) ? Ceil(FloodFillTolerance*0.7) + 1 : FloodFillTolerance
   If (FloodFillAltToler=3)
      tolerance := Round(FloodFillTolerance/10 + 1, 1)

   thisOpacity := Round((FloodFillOpacity / 255) * 100)
   GuiControl, SettingsGUIA:, infoOpacity, Flooding opacity: %thisOpacity%`%
   GuiControl, SettingsGUIA:, infoFloodFillTolerance, Color similarity tolerance level: %tolerance%

   actu := (FloodFillTolerance<3) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % actu, FloodFillDynamicOpacity
   GuiControl, % actu, FloodFillCartoonMode
   GuiControl, % actu, FloodFillEightWays
   GuiControl, % actu, FloodFillAltToler
   If (FloodFillTolerance<3)
   {
      FloodFillCartoonMode := 0
      GuiControl, SettingsGUIA: , FloodFillCartoonMode, 0
   }

   actu := (FloodFillCartoonMode=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % actu, infoClrOpacity
   GuiControl, % actu, infoOpacity
   GuiControl, % actu, FloodFillDynamicOpacity
   GuiControl, % actu, FloodFillOpacity
   GuiControl, % actu, FloodFillClrOpacity
   GuiControl, % actu, FloodFillBlendMode
   GuiControl, % actu, PickuFillAreaColor
   GuiControl, % actu, FillAreaColor

   If (FloodFillTolerance>1 && FloodFillCartoonMode!=1)
      GuiControl, SettingsGUIA: Enable, FloodFillDynamicOpacity

   actu := (FloodFillModus!=1 && FloodFillTolerance>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, FloodFillEightWays
   ; decideAlphaMaskingFeaseable(FloodFillUseAlpha)

   thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
   %thisOpa% := FloodFillClrOpacity
   SetTimer, dummyRefreshImgSelectionWindow, -150
   SetTimer, WriteSettingsFloodFillPanel, -200
}

ReadSettingsFloodFillPanel(act:=0) {
   RegAction(act, "BrushToolOutsideSelection",, 2, 1, 3)
   RegAction(act, "FloodFillOpacity",, 2, 4, 255)
   RegAction(act, "FloodFillBlendMode",, 2, 1, 21)
   RegAction(act, "FloodFillColor",, 3)
   RegAction(act, "FloodFillClrOpacity",, 2, 1, 255)
   RegAction(act, "FloodFillAltToler",, 2, 1, 3)
   RegAction(act, "FloodFillDynamicOpacity",, 1)
   RegAction(act, "FloodFillModus",, 1)
   RegAction(act, "FloodFillUseAlpha",, 1)
   RegAction(act, "FloodFillTolerance",, 2, 0, 256)
}

WriteSettingsFloodFillPanel() {
   ReadSettingsFloodFillPanel(1)
}

updateUIbrushTool() {
   If (AnyWindowOpen!=64)
      Return

   Gui, SettingsGUIA: Submit, NoHide
   If (BrushToolType>2)
      BrushToolUseSecondaryColor := 0

   liveDrawingBrushTool := 1
   If (CurrentPanelTab=1)
   {
      actuA := (BrushToolUseSecondaryColor=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      actuB := (BrushToolUseSecondaryColor!=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actuB, PickuBrushToolBcolor
      GuiControl, % actuB, BrushToolBopacity
      GuiControl, % actuB, BrushToolBcolor
      GuiControl, % actuB, infoBrushBopacity
      GuiControl, % actuA, PickuBrushToolAcolor
      GuiControl, % actuA, BrushToolAopacity
      GuiControl, % actuA, BrushToolAcolor
      GuiControl, % actuA, infoBrushAopacity
      If (BrushToolUseSecondaryColor=1)
      {
         GuiControl, SettingsGUIA:, UIbtnBrushColorB, [X]
         GuiControl, SettingsGUIA:, UIbtnBrushColorA, [-]
         allGood := 0
      } Else
      {
         GuiControl, SettingsGUIA:, UIbtnBrushColorB, [-]
         GuiControl, SettingsGUIA:, UIbtnBrushColorA, [X]
         allGood := 1
      }


      If (BrushToolType>2)
      {
         GuiControl, SettingsGUIA: Disable, UIbtnBrushColorB
         GuiControl, SettingsGUIA: Disable, UIbtnBrushColorA
         GuiControl, SettingsGUIA: Disable, PickuBrushToolAcolor
         GuiControl, SettingsGUIA: Disable, BrushToolAcolor
      } Else
      {
         GuiControl, SettingsGUIA: Enable, UIbtnBrushColorB
         GuiControl, SettingsGUIA: Enable, UIbtnBrushColorA
         If (allGood=1)
         {
            GuiControl, SettingsGUIA: Enable, PickuBrushToolAcolor
            GuiControl, SettingsGUIA: Enable, BrushToolAcolor
         }
      }

      actu := (BrushToolType>=7) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, infoBrushStepping
      GuiControl, % actu, brushToolStepping

      actu := (BrushToolType=2 || BrushToolType=3) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, BrushToolOverDraw

      tehLabel := (BrushToolType>=6) ? "&Auto-scale deformer" : "&Airbrush mode"
      GuiControl, SettingsGUIA: Text, BrushToolOverDraw, %tehLabel%

      actu := (BrushToolTexture>1 || BrushToolType=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, BrushToolSoftness

      actu := (BrushToolTexture>1 && BrushToolType>1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, infoBrushAspectRatio
      GuiControl, % actu, BrushToolAspectRatio

      actu := (BrushToolType=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, BrushToolTexture

      actu := (BrushToolType=3) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
      GuiControl, % actu, uiBtnSetCloner

      actu := (BrushToolType=3 || BrushToolType=8) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, BrushToolDynamicCloner

      tehLabel := (BrushToolType=8) ? "Bulge out&wards more" : "D&ynamic X/Y source coordinates"
      GuiControl, SettingsGUIA: Text, BrushToolDynamicCloner, %tehLabel%

      actu := (BrushToolType=4) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
      GuiControl, % actu, BrushToolEraserRestore

      thisOpacity := Round((BrushToolAopacity / 255) * 100)
      this2ndOpacity := Round((BrushToolBopacity / 255) * 100)
      theSize := (brushToolDoubleSize!=1) ? "Diameter" : "Radius"
      stepu := (brushToolStepping<=2 || brushToolStepping=251) ? "AUTO" : brushToolStepping
      If (brushToolStepping=0)
         stepu := "NONE"
      GuiControl, SettingsGUIA:, infoBrushAopacity, %thisOpacity%`%
      GuiControl, SettingsGUIA:, infoBrushBopacity, %this2ndOpacity%`%
      GuiControl, SettingsGUIA:, brushToolDoubleSize, %theSize%: %BrushToolSize% px
      ; GuiControl, SettingsGUIA:, infoBrushSoftness, Softness: %BrushToolSoftness%`%
      GuiControl, SettingsGUIA:, infoBrushStepping, Stepping: %stepu%
      GuiControl, SettingsGUIA:, BrushToolAutoAngle, % (BrushToolAutoAngle=1) ? "Automatic rotation" : "Angle: " BrushToolAngle "°"
      GuiControl, SettingsGUIA:, infoBrushAspectRatio, Aspect ratio: %BrushToolAspectRatio%
      GuiControl, SettingsGUIA:, infoBrushDrying, Dry-out rate: %BrushToolDryingRate%

      actu := (BrushToolAutoAngle=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, BrushToolAngle

      If (BrushToolType=1 && BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
         GuiControl, SettingsGUIA: Disable, BrushToolOverDraw
      Else If (BrushToolType=1)
         GuiControl, SettingsGUIA: Enable, BrushToolOverDraw

      SetTimer, WriteSettingsBrushPanel, -300
   } Else If (CurrentPanelTab=2)
   {
      actu := (BrushToolType<=2 || BrushToolType>=6) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, infoBrushWetness
      GuiControl, % actu, BrushToolWetness

      actu := (BrushToolType=3 || BrushToolType=5) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, infoBrushBlurel
      GuiControl, % actu, BrushToolBlurStrength
      GuiControl, % actu, BrushToolApplyColorFX

      actu2 := (BrushToolApplyColorFX=1 && (BrushToolType=3 || BrushToolType=5)) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu2, PasteInPlaceLight
      GuiControl, % actu2, PasteInPlaceGamma
      GuiControl, % actu2, PasteInPlaceHue
      GuiControl, % actu2, PasteInPlaceSaturation
      GuiControl, % actu2, infoPasteLight
      GuiControl, % actu2, infoPasteGamma
      GuiControl, % actu2, infoPasteHue
      GuiControl, % actu2, infoPasteSat

      wetLabel := (BrushToolType>=6) ? "Deform intensity" : "Wetness"
      GuiControl, SettingsGUIA:, infoBrushBlurel, Blur intensity: %BrushToolBlurStrength%`%
      GuiControl, SettingsGUIA:, infoBrushWetness, %wetLabel%: %BrushToolWetness%
      GuiControl, SettingsGUIA:, infoPasteHue, Hue: %PasteInPlaceHue%°
      GuiControl, SettingsGUIA:, infoPasteSat, Saturation: %PasteInPlaceSaturation%`%
      GuiControl, SettingsGUIA:, infoPasteLight, Brightness: %PasteInPlaceLight%
      GuiControl, SettingsGUIA:, infoPasteGamma, Contrast: %PasteInPlaceGamma%`%

      actu := (BrushToolType<4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, infoSymmetryLabel
      GuiControl, % actu, BTNuiSetLabelSymmetry
      GuiControl, % actu, BrushToolSymmetryX
      GuiControl, % actu, BrushToolSymmetryY
      SetTimer, WriteSettingsBrushPanel, -300
   } Else If (CurrentPanelTab=3)
   {
      GuiControl, SettingsGUIA:, infoBrushRandomSize, Size: %BrushToolRandomSize%
      GuiControl, SettingsGUIA:, infoBrushRandomSoftness, Softness: %BrushToolRandomSoftness%
      GuiControl, SettingsGUIA:, infoBrushRandomAspectRatio, Aspect ratio: %BrushToolRandomAspectRatio%
      GuiControl, SettingsGUIA:, infoBrushRandomAngle, Angle: %BrushToolRandomAngle%° 
      GuiControl, SettingsGUIA:, infoBrushRandomPosX, Offset X: %BrushToolRandomPosX%
      GuiControl, SettingsGUIA:, infoBrushRandomPosY, Offset Y: %BrushToolRandomPosY%
      GuiControl, SettingsGUIA:, infoBrushRandomHue, Hue: %BrushToolRandomHue%
      GuiControl, SettingsGUIA:, infoBrushRandomSat, Saturation: %BrushToolRandomSat%
      GuiControl, SettingsGUIA:, infoBrushRandomLight, Lightness: %BrushToolRandomLight%
      GuiControl, SettingsGUIA:, infoBrushRandomDark, Darkness: %BrushToolRandomDark%
   }

   createLivePreviewBrush()
   SetTimer, dummyRefreshImgSelectionWindow, -400
}

BTNresetBrushAngle() {
   BrushToolAngle := 0
   GuiControl, SettingsGUIA:, BrushToolAngle, 0
   UItriggerBrushUpdate()
}

UItriggerBrushUpdate(actu:="noPreview", delayu:=100) {
   If (AnyWindowOpen=32)
   {
      fn := Func("updateUIInsertTextPanel").Bind(actu)
      SetTimer, % fn, % -delayu
   } Else If (AnyWindowOpen=23)
   {
      fn := Func("updateUIfillPanel").Bind(actu)
      SetTimer, % fn, % -delayu
   } Else If (AnyWindowOpen=26)
   {
      SetTimer, updateUIblurPanel, % -delayu
   } Else If (AnyWindowOpen=69)
   {
      SetTimer, updateUIzoomBlurPanel, % -delayu
   } Else If (AnyWindowOpen=70)
   {
      fn := Func("updateUIalphaMaskerPanel").Bind(actu)
      SetTimer, % fn, % -delayu
   } Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
   {
      fn := Func("updateUIpastePanel").Bind(actu)
      SetTimer, % fn, % -delayu
   } Else If (AnyWindowOpen=64)
   {
      SetTimer, updateUIbrushTool, % -delayu
   }
}

BTNresetBrushAspectRatio() {
   BrushToolAspectRatio := 0
   GuiControl, SettingsGUIA:, BrushToolAspectRatio, 0
   UItriggerBrushUpdate()
}

BTNresetBrushStepu() {
   brushToolStepping := 0
   GuiControl, SettingsGUIA:, brushToolStepping, 0
   UItriggerBrushUpdate()
}

BTNresetBrushWet() {
   BrushToolWetness := 0
   GuiControl, SettingsGUIA:, BrushToolWetness, 0
   SetTimer, updateUIbrushTool, -125
}

BTNresetBrushBluru() {
   BrushToolBlurStrength := 0
   GuiControl, SettingsGUIA:, BrushToolBlurStrength, 0
   SetTimer, updateUIbrushTool, -125
}

BTNresetBrushDryer() {
   BrushToolDryingRate := 0
   GuiControl, SettingsGUIA:, BrushToolDryingRate, 0
   UItriggerBrushUpdate()
}

createBrushShapePath(brushSize, tkX, tkY, thisAR, angleu) {
   thisAR := 1 - Abs(thisAR)/105
   brImgSelW := (BrushToolAspectRatio>0) ? brushSize * thisAR : brushSize
   brImgSelH := (BrushToolAspectRatio<0) ? brushSize * thisAR : brushSize
   brimgSelPx := 0 - (brImgSelW - brushSize)/2
   brimgSelPy := 0 - (brImgSelH - brushSize)/2
   tmpMatrix := Gdip_CreateMatrix()
   tmpPath := Gdip_CreatePath()
   Gdip_AddPathEllipse(tmpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
   trGdip_RotatePathAtCenter(tmpPath, angleu)
   Gdip_TranslateMatrix(tmpMatrix, tkX - brushSize/2, tkY - brushSize/2)
   Gdip_TransformPath(tmpPath, tmpMatrix)
   Gdip_DeleteMatrix(tmpMatrix)
   Return tmpPath
}

createLivePreviewBrush() {
    Static imgBoxSize := 100
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, imgBoxSize, imgBoxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GraphicsClear(G, "0xFF888888")
    brushSize := (brushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
    whichBitmap := useGdiBitmap()
    If ((BrushToolType=3 || BrushToolType=5) && CurrentPanelTab=2)
    {
       brushu := createClonedBrushBitmap(brushSize, 101 - BrushToolSoftness, BrushToolAngle, BrushToolAspectRatio, whichBitmap, 0, 0, 1, 1, 1)
       applyPersonalizedColorsBMP(brushu, 1, BrushToolBlurStrength, BrushToolApplyColorFX)
       thisMainOpacity := 1
    } Else If (BrushToolType=3 && CurrentPanelTab=1)
    {
       brushu := createClonedBrushBitmap(brushSize, 101 - BrushToolSoftness, BrushToolAngle, BrushToolAspectRatio, whichBitmap, 0, 0, 1, 0, 1)
       thisMainOpacity := BrushToolAopacity / 255
    } Else
    {
       thisMainOpacity := 1
       If (BrushToolTexture>1)
          thisMainOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity / 255 : BrushToolAopacity / 255

       startToolColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       If (BrushToolType>2)
          startToolColor := "ffFFff"

       thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       thisOpacity := Format("{1:#x}", thisOpacity)
       brushSofty := (BrushToolType=1) ? 99 : 101 - BrushToolSoftness
       brushu := createGradientBrushBitmap(startToolColor, brushSofty, imgBoxSize, BrushToolAngle, BrushToolAspectRatio, thisOpacity)
    }

    Gdip_DrawImage(G, brushu, 2, 2, 95, 95, , , , , thisMainOpacity)
    thisX := (brushToolDoubleSize=1) ? imgBoxSize//2 : 0
    If (BrushToolAngle=0 && BrushToolAspectRatio=0)
       Gdip_FillRectangle(G, pBrushD, thisX, imgBoxSize//2 - 2, imgBoxSize, 4)
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    If (CurrentPanelTab=1)
       SetImage(hCropCornersPic, hBitmap)
    Else If (CurrentPanelTab=2)
       SetImage(hCropCornersPic2, hBitmap)
    Gdi_DeleteObject(hBitmap)
    Gdip_DeleteGraphics(G)
    trGdip_DisposeImage(brushu, 1)
    trGdip_DisposeImage(cornersBMP, 1)
}

PanelChangeHamDistThreshold() {
    Global editFa, editFb, txtline3

    If !testIsDupesList()
       msgu := "WARNING: The files list does not seem to contain pairs of images identified as duplicates"

    If (!InStr(resultedFilesList[currentFileIndex, 23], "_") && !msgu)
       msgu := "WARNING: The files list does not seem to contain pairs of images filtered by Hamming distance"

    If (dupesHashesData.Count()<2 && !msgu)
       msgu := "WARNING: The files list does not seem to have cached data to allow changing the similarity threshold"

    If msgu
    {
       showTOOLtip(msgu)
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       If (SLDtypeLoaded=3)
          SetTimer, PanelFindDupes, -200
       Return
    }

    thisBtnHeight := createSettingsGUI(62, A_ThisFunc)
    btnWid := 70
    txtWid := 260
    If (PrefsLargeFonts=1)
    {
       btnWid := btnWid + 80
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    EditWid := Round(btnWid*2.5)
    If !hamUppLim
       hamUppLim := userFindDupesHamDistLvl

    UserHamDistCacheFilterMonoGroups := 1
    Gui, Add, Text, x15 y15 w%txtWid% Section, Please set the range for the Hamming distance threshold. Lower ranges equate to a stricter criteria - more closely looking images. Cached threshold range: 0 - %userFindDupesHamDistLvl%.
    Gui, Add, Text, y+15 w%btnWid%, Lower limit:
    Gui, Add, Text, x+15 wp, Upper limit:
    Gui, Add, Edit, xs y+5 wp number -multi limit2 veditF5, % hamLowLim
    Gui, Add, UpDown, vhamLowLim Range0-%userFindDupesHamDistLvl%, % hamLowLim

    Gui, Add, Edit, x+15 wp number -multi limit2 veditF6, % hamUppLim
    Gui, Add, UpDown, vhamUppLim Range0-%userFindDupesHamDistLvl%, % hamUppLim

    sml := (PrefsLargeFonts=1) ? 35 : 25
    Gui, Add, Text, xs y+%sml% vtxtLine1, Mean-Squared Difference threshold:
    Gui, Add, Text, y+15 w%btnWid% vtxtLine2, Lower limit:
    Gui, Add, Text, x+15 wp vtxtLine3, Upper limit:
    Gui, Add, Edit, xs y+5 wp number -multi limit3 vEditFa, % mseLowLim
    Gui, Add, UpDown, vmseLowLim Range0-950, % mseLowLim

    Gui, Add, Edit, x+15 wp number -multi limit3 vEditFb, % mseUppLim
    Gui, Add, UpDown, vmseUppLim Range0-950, % mseUppLim
    Gui, Add, Text, xs y+15 wp, String filter:
    Gui, Add, Checkbox, x+15 Checked%UserHamDistStringInvert% vUserHamDistStringInvert, &Must not contain it
    Gui, Add, Edit, xs y+5 w%EditWid% -multi gUIeditsGenericAllowCtrlBksp vUserHamDistStringFilter, % UserHamDistStringFilter
    Gui, Add, Button, x+1 hp w35 gUIstringEditFilterErase, &X
    Gui, Add, DropDownList, xs y+7 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userHamDistStringStringPos% vuserHamDistStringStringPos, Anywhere|Begins with|Ends with|RegEx
    Gui, Add, DropDownList, x+2 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userHamDistStringFilterWhat% vuserHamDistStringFilterWhat, Full path|Folder path|File name
    Gui, Add, Checkbox, xs y+25 Checked%UserHamDistCacheFilterMonoGroups%  vUserHamDistCacheFilterMonoGroups, &Filter out matches without pairs
    Gui, Add, Checkbox, xs y+7 Checked%BreakDupesGroups%  vBreakDupesGroups, &Break the groups based on the similarity index

    If (testWasMSEdupes()!=1)
    {
       GuiControl, SettingsGUIA: Disable, mseUppLim 
       GuiControl, SettingsGUIA: Disable, mseLowLim 
       GuiControl, SettingsGUIA: Disable, editFa 
       GuiControl, SettingsGUIA: Disable, editFb 
       GuiControl, SettingsGUIA: Disable, txtLine1
       GuiControl, SettingsGUIA: Disable, txtLine2
       GuiControl, SettingsGUIA: Disable, txtLine3
    }

    Gui, Add, Button, xs y+25 w%btnWid% h%thisBtnHeight% Default gBtnChangeHamDistThreshold, &Update
    Gui, Add, Button, x+5 hp wp+10 gPanelFindDupes, &Main panel
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Change hashes threshold: " appTitle)
}

BtnChangeHamDistThreshold() {
   Gui, SettingsGUIA: Default
   GuiControlGet, hamUppLim
   GuiControlGet, hamLowLim
   GuiControlGet, mseUppLim
   GuiControlGet, mseLowLim
   GuiControlGet, UserHamDistStringFilter
   GuiControlGet, UserHamDistStringInvert
   GuiControlGet, userHamDistStringFilterWhat
   GuiControlGet, userHamDistStringStringPos
   GuiControlGet, UserHamDistCacheFilterMonoGroups
   GuiControlGet, BreakDupesGroups

   BtnCloseWindow()
   r := changeHdistLevelCached(0, hamLowLim, hamUppLim, mseLowLim, mseUppLim)
   If (r<1)
   {
      showTOOLtip("Found no duplicate images in the specified Hamming distance range.`nFiles list unchanged.")
      SoundBeep 300, 100
      SetTimer, PanelChangeHamDistThreshold, -350
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else 
   {
      currentFileIndex := 1
      dummyTimerDelayiedImageDisplay(150)
   }
}

PanelSearchAndReplaceIndex() {
    Global editF5, editF6, performInSeenDB, performInDynas

    getSelectedFiles(0, 1)
    thisBtnHeight := createSettingsGUI(56, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    If (SLDtypeLoaded=3)
       infos := "`n`nThis action will affect only folder paths."

    If (mustRecordSeenImgs!=1 || performInSeenDB="")
       performInSeenDB := 0

    If (performInSeenDB=1 || performInDynas="")
       performInDynas := 0

    If (markedSelectFile<2 || SLDtypeLoaded=3 || performInSeenDB=1)
       limitSearchReplaceSelected := 0

    imgPath := resultedFilesList[currentFileIndex, 1]
    doPwd := (userPrivateMode=1) ? " password " : ""
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    Gui, Add, Text, x15 y15 w%txtWid% Section, Please type what to search for and what to replace it with. This panel is meant to help you fix broken files lists. e.g., files moved to a different folder. RegEx, tokens or wildcards are not supported. %infos%
    Gui, Add, Text, y+15 wp, Search for:
    Gui, Add, Edit, y+5 wp %doPwd% veditF5 r1 gUIeditsGenericAllowCtrlBksp, % OutDir
    Gui, Add, Text, y+15 wp, Replace with:
    Gui, Add, Edit, y+5 wp %doPwd% veditF6 r1 gUIeditsGenericAllowCtrlBksp,
    Gui, Add, Checkbox, y+15 Checked%performInSeenDB% vperformInSeenDB gUItogglePerformSearchSeenDB, Perform action in seen images database 
    Gui, Add, Checkbox, y+15 Checked%limitSearchReplaceSelected% vlimitSearchReplaceSelected gUItogglePerformSearchSeenDB, Apply action only on the selected files
    Gui, Add, Checkbox, y+15 Checked%performInDynas% vperformInDynas , Perform action over the main folders list as well
    If (mustRecordSeenImgs!=1)
       GuiControl, Disable, performInSeenDB

    If (markedSelectFile<2 || SLDtypeLoaded=3 || performInSeenDB=1)
       GuiControl, Disable, limitSearchReplaceSelected

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBTNperformIndexSearchReplace, &Perform
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Search and replace through the files index: " appTitle)
}

UItogglePerformSearchSeenDB() {
   Gui, SettingsGUIA: Default
   GuiControlGet, performInSeenDB
   GuiControlGet, limitSearchReplaceSelected
   actu := (performInSeenDB=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % actu, performInDynas

   actu := (performInSeenDB=1 || SLDtypeLoaded=3 || markedSelectFile<2) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % actu, limitSearchReplaceSelected
}

BTNperformIndexSearchReplace() {
   Gui, SettingsGUIA: Default
   GuiControlGet, editF5
   GuiControlGet, editF6
   GuiControlGet, limitSearchReplaceSelected
   GuiControlGet, performInSeenDB
   GuiControlGet, performInDynas
   If (editF5="")
   {
      showTOOLtip("WARNING: No search criteria given")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   If (mustRecordSeenImgs=1 && performInSeenDB=1)
   {
      SearchAndReplaceSeenDB(editF5, editF6)
   } Else
   {
      SearchAndReplaceThroughIndex(editF5, editF6, 0, 0)
      If (performInDynas=1)
      {
         listu := getDynamicFoldersList()
         listu := StrReplace(listu, "`n", "\`n")
         listu := StrReplace(listu, editF5, editF6)
         listu := StrReplace(listu, "\\", "\")
         DynamicFoldersList := StrReplace(listu, "\`n", "`n")
         If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
            recreateDynaFoldersSQLdbList(DynamicFoldersList)
      }
   }
}

updateUIquickFileActs(zz:=0) {
   If (zz!="z")
   {
      GuiControlGet, allowUserQuickFileActions
      IniAction(1, "allowUserQuickFileActions", "General")
   }

   actu := (allowUserQuickFileActions=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   Loop, 6
   {
      a := A_Index
      GuiControl, % actu, btnFldr%a%
      GuiControl, % actu, txtLine%a%
      GuiControl, % actu, QuickFileActFolder%a%
      GuiControl, % actu, QuickFileActAfter%a%
   }
}

UIeditsGenericAllowCtrlBksp(a, b, c) {
   hwnd := Format("{1:#x}", a) 
   GuiControlGet, thisV, %A_Gui%:, %A_GuiControl%
   allowCtrlBkspEdit(hwnd, thisV)
   ; TulTip(0, " - ", a, b, c, hwnd, A_GuiControl, thisV, A_Gui)
}

PanelQuickMoveConfigure() {
    Global btnFldr1, btnFldr2, btnFldr3, btnFldr4, btnFldr5, btnFldr6, txtLine5, txtLine6
    Static afterActionsList := "Do nothing after|Go to next image |Go to previous image"

    thisBtnHeight := createSettingsGUI(47, A_ThisFunc)
    btnWid := 60
    txtWid := 395
    EditWid := 305
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 100
       btnWid := btnWid + 30
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    tiny := (PrefsLargeFonts=1) ? 55 : 30
    tiny2 := (PrefsLargeFonts=1) ? 85 : 50
    thisW := (PrefsLargeFonts=1) ? 190 : 120

    ReadSettingsQuickKeysActsPanel()
    Gui, Add, Checkbox, x15 y15 Section w%txtWid% Checked%allowUserQuickFileActions% vallowUserQuickFileActions gupdateUIquickFileActs, Associate the keyboard keys from 1 to 6 to quick actions: move or copy images to user-defined destination folders.
    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine1, [ 1 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder1, % QuickFileActFolder1
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr1, Browse
    Gui, Add, DropDownList, x+5 w%thisW% AltSubmit Choose%QuickFileActAfter1% vQuickFileActAfter1, % afterActionsList

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine2, [ 2 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder2, % QuickFileActFolder2
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr2, Browse
    Gui, Add, DropDownList, x+5 w%thisW% AltSubmit Choose%QuickFileActAfter2% vQuickFileActAfter2, % afterActionsList

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine3, [ 3 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder3, % QuickFileActFolder3
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr3, Browse
    Gui, Add, DropDownList, x+5 w%thisW% AltSubmit Choose%QuickFileActAfter3% vQuickFileActAfter3, % afterActionsList

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine4, [ 4 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder4, % QuickFileActFolder4
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr4, Browse
    Gui, Add, DropDownList, x+5 w%thisW% AltSubmit Choose%QuickFileActAfter4% vQuickFileActAfter4, % afterActionsList

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine5, [ 5 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder5, % QuickFileActFolder5
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr5, Browse
    Gui, Add, DropDownList, x+5 w%thisW% AltSubmit Choose%QuickFileActAfter5% vQuickFileActAfter5, % afterActionsList

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine6, [ 6 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder6, % QuickFileActFolder6
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr6, Browse
    Gui, Add, DropDownList, x+5 w%thisW% AltSubmit Choose%QuickFileActAfter6% vQuickFileActAfter6, % afterActionsList

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny%, [ Del ]
    Gui, Add, Checkbox, x+5 w%EditWid% Checked%askDeleteFiles% vaskDeleteFiles, &Prompt before delete
    Gui, Add, DropDownList, x+5 w%thisW% AltSubmit Choose%deleteFileActAfter% vdeleteFileActAfter, % afterActionsList
    Gui, Add, Text, xs y+15 w%txtWid%, Use Shift to move to given destination folder. Use Alt to open it in Explorer.

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBtnApplyQuickActionsPanel, &Apply
    Gui, Add, Button, x+5 hp wp gBtnHelpCopyMovePanel, Hel&p
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    Gui, Add, Text, x+5 hp +0x200, On file name conflicts:
    Gui, Add, DropDownList, x+5 w%thisW% AltSubmit Choose%QuickFileActConflict% vQuickFileActConflict, Skip files|Auto-rename|Overwrite|Ask user
    updateUIquickFileActs("z")
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Configure quick action keys: " appTitle)
}

BtnApplyQuickActionsPanel() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   WriteSettingsQuickKeysActsPanel()
   BtnCloseWindow()
}

BTNchooseQuickActDestFolder(CtrlHwnd) {
   Static lastFolder
   If !lastFolder
      lastFolder := ResizeDestFolder ? ResizeDestFolder : A_ScriptDir

   GuiControlGet, varu, SettingsGUIA: Name, % CtrlHwnd
   ; ToolTip, % varu "`n" a "|" b "|" c , , , 2

   thisVar := SubStr(varu, 0)
   SelectImg := openFoldersDialogWrapper("S2", lastFolder)
   OutDir := Trimmer(SelectImg)
   If !FolderExist(OutDir)
   {
      WinActivate, ahk_id %hSetWinGui%
   } Else
   {
      lastFolder := SelectImg
      GuiControl, SettingsGUIA:, QuickFileActFolder%thisVar%, % OutDir
   }
}

triggerQuickFileAction(keyu, forceIT:=0) {
   Static hasLoadedSettings := 0, lastInvoked := 1
   If (allowUserQuickFileActions=0 && forceIT=0)
      Return

   If (slideShowRunning=1)
   {
      ToggleSlideShowu()
      Return
   }

   If ((!resultedFilesList[currentFileIndex, 1] || AnyWindowOpen || drawingShapeNow=1)
   || (A_TickCount - lastInvoked<250))
   {
      lastInvoked := A_TickCount
      Return
   }

   If !hasLoadedSettings
   {
      ReadSettingsQuickKeysActsPanel()
      hasLoadedSettings := 1
   }

   thisVar := SubStr(keyu, 0)
   UsrCopyMoveOperation := InStr(keyu, "+") ? 2 : 3   ; 2 = move ; 3 = copy
   UsrEditFileDestination := QuickFileActFolder%thisVar%
   If (thisVar=7)
   {
      If !folderTreeWinOpen
         Return

      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      UsrEditFileDestination := folderTreeGetSelectedPath(c)
      If !UsrEditFileDestination
         Return

      If FolderExist(UsrEditFileDestination)
      {
         prevFileMovePath := UsrEditFileDestination
         INIaction(1, "prevFileMovePath", "General")
         RecentCopyMoveManager(UsrEditFileDestination)
      }
   } Else If (thisVar=8)
   {
      If !VisibleQuickMenuSearchWin
         Return

      UsrEditFileDestination := OmniBoxGetSelectedFolder()
      If !UsrEditFileDestination
         Return

      If FolderExist(UsrEditFileDestination)
      {
         prevFileMovePath := UsrEditFileDestination
         INIaction(1, "prevFileMovePath", "General")
         RecentCopyMoveManager(UsrEditFileDestination)
      }
   }

   If StrLen(UsrEditFileDestination)<5
   {
      PanelQuickMoveConfigure()
      Return
   }

   altState := GetKeyState("Alt", "P")
   ctrlState := GetKeyState("Ctrl", "P")
   lastInvoked := A_TickCount
   If (altState=1 && ctrlState!=1)
   {
      Try Run, "%UsrEditFileDestination%"
      UsrEditFileDestination := ""
      Return
   } Else If (ctrlState=1 && altState=1)
   {
      OpenNewQPVinstance(UsrEditFileDestination)
      UsrEditFileDestination := ""
      Return
   }

   copyMoveDoLastOption := 1
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   afterAct := QuickFileActAfter%thisVar%
   ForceRefreshNowThumbsList()
   r := BtnCopyMoveAction("quick-actu")
   lastInvoked := A_TickCount
   If (afterAct=2 && StrLen(UserMemBMP)<3 && r=1)
      NextPicture(0, 0, 1)
   Else If (afterAct=3 && StrLen(UserMemBMP)<3 && r=1)
      PreviousPicture(0, 0, 1)

   UsrEditFileDestination := ""
   lastInvoked := A_TickCount
}

WriteSettingsQuickKeysActsPanel() {
    ReadSettingsQuickKeysActsPanel(1)
}

ReadSettingsQuickKeysActsPanel(act:=0) {
   Loop, 6
   {
      INIaction(act, "QuickFileActAfter" A_Index, "General", 2, 1, 3)
      INIaction(act, "QuickFileActFolder" A_Index, "General", 5)
   }
   INIaction(act, "deleteFileActAfter", "General", 2, 1, 3)
   INIaction(act, "QuickFileActConflict", "General", 2, 1, 4)
   INIaction(act, "askDeleteFiles", "General", 1)
   INIaction(act, "allowUserQuickFileActions", "General", 1)
}

TglUsePrevSaveFoderu() {
   GuiControlGet, usePrevSaveFolder
   actu := (usePrevSaveFolder=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, userDestinationFolder
   RegAction(1, "usePrevSaveFolder")
}

BTNsaveImgPanel() {
   If (AnyWindowOpen!=35)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   ; GuiControlGet, UserCropOnSave
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality
   GuiControlGet, userDestinationFolder
   GuiControlGet, userSaveBitsDepth
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   RegAction(1, "userJpegQuality")
   RegAction(1, "usePrevSaveFolder")
   RegAction(1, "PreserveDateTimeOnSave")
   imgPath := getIDimage(currentFileIndex)
   If InStr(imgPath, "\temporary memory object\")
      SaveClipboardImage(userDestinationFolder, 0)
   Else
      SaveClipboardImage("current", 0, 1)

   If (minimizeMemUsage=1)
   {
      HardResetImageView()
      SetTimer, RefreshImageFileAction, -125
   }
}

BTNsaveBrowseImgPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   ; GuiControlGet, UserCropOnSave
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality
   GuiControlGet, userDestinationFolder
   GuiControlGet, userSaveBitsDepth
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   RegAction(1, "userJpegQuality")
   RegAction(1, "usePrevSaveFolder")
   RegAction(1, "PreserveDateTimeOnSave")
   imgPath := getIDimage(currentFileIndex)
   If (usePrevSaveFolder=1 || InStr(imgPath, "\temporary memory object\"))
      SaveClipboardImage(userDestinationFolder, 0)
   Else
      SaveClipboardImage("current", 0)
}

BtnCopyImageClip() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   GuiControlGet, userJpegQuality
   GuiControlGet, PreserveDateTimeOnSave
   RegAction(1, "PreserveDateTimeOnSave")
   RegAction(1, "userJpegQuality")
   BtnCloseWindow()
   Sleep, 5
   CopyImage2clip()
}

fakeWinCreator(idWin, thisCaller, allowReopen) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    mouseTurnOFFtooltip()
    AnyWindowOpen := idWin
    interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    prevOpenedWindow := []
    prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 1]
    isNowFakeWinOpen := 1
    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    ; hSetWinGui := PVhwnd
}

PanelAutoSelectDupes() {
   Static SearchdStringz
   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to search for")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If filesFilter
         SetTimer, PanelEnableFilesFilter, -200
      Return
   }

   If !testIsDupesList()
   {
      showTOOLtip("WARNING: The files list does not seem to contain pairs of images identified as duplicates")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (SLDtypeLoaded=3)
         SetTimer, PanelFindDupes, -200
      Return
   }

   fakeWinCreator(50, A_ThisFunc, 1)
   SearchdStringz := Trimmer(SearchdStringz) "`f"
   widthu := (PrefsLargeFonts=1) ? 1060 : 560
   msgResult := msgBoxWrapper("panelu|Auto-select duplicate images " appTitle, "When Automatic mode is selected, the smallest image (in MPx) will be selected. If all dupes in the group have the same resolution, then the smallest file will be selected. If both size and resolution are equal, the images' folder paths that match the string below will NOT be selected.`n`nYou can use | as the OR operator for multiple keywords. Wildcards ? and * are supported as well.`n`nBegin with one of the following symbols to...`n   / match folder paths that begin with given string`n   > match folder paths that end with given string.`n   \> to use Regular Expressions", "&Select files|&Find duplicates|C&ancel", 1, "search", "", 0, SearchdStringz "`f`f", nullEdit,nullEdit, 1, widthu, "Automatic`f`fSmallest files`fSmallest resolution (MPx)", 2)
   If InStr(msgResult.btn, "select")
   {
      thisString := Trimmer(msgResult.list)
      thisString := StrReplace(thisString, "||", "|")
      thisString := Trimmer(thisString, "|")
      thisStringo := processSearchIndexString(thisString)
      If (thisStringo && !InStr(SearchdStringz, thisString "`f"))
         SearchdStringz .= thisString "`f"
      autoSelectDupesInGroups(msgResult.2ndlist, thisStringo)
   } Else If InStr(msgResult.btn, "find")
      PanelFindDupes()
}

SearchIndexSelectAll(modus:="") {
   thisFilter := processSearchIndexString(userSearchString)
   If !thisFilter
   {
      thisSearchString := userSearchString := ""
      SetTimer, PanelSearchIndex, -100
      Return
   }

   showTOOLtip("Searching index for matching files:`n" userSearchString)
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection based on the search criteria.", "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel" || InStr(msgResult, "win_close"))
      {
         SetTimer, RemoveTooltip, -250
         thisSearchString := userSearchString := ""
         Return
      }
   }

   thisSearchString := thisFilter
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   wasReplace := 0
   doStartLongOpDance()
   If (msgResult="replace" || !msgResult)
   {
      wasReplace := 1
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   Loop, % maxFilesIndex
   {
      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := resultedFilesList[A_Index, 1]
      If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
      {
         thisIndex++
         resultedFilesList[A_Index, 2] := (msgResult="add" || !msgResult) ? 1 : 0
      }
   }

   CurrentSLD := backCurrentSLD
   friendly := thisIndex ? "The files selection was altered." : "The files selection is unchanged."
   ResetImgLoadStatus()
   updateFilesSelectionInfos()
   ForceRefreshNowThumbsList()
   If (abandonAll=1)
      showDelayedTooltip("User abandoned the search.`n" friendly)
   Else If !thisIndex
      showDelayedTooltip("No matches found for:`n" userSearchString "`n" friendly)
   Else If (modus!="quick" && wasReplace=1)
      navSelectedFiles(1)

   dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

SelectFilesDead() {

   showTOOLtip("Identifying inexistent files:`n" groupDigits(maxFilesIndex))
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection when the file is inexistent.", "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel" || InStr(msgResult, "win_close"))
      {
         SetTimer, RemoveTooltip, -250
         Return
      }
   }

   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   wasReplace := 0
   doStartLongOpDance()
   If (msgResult="replace" || !msgResult)
   {
      wasReplace := 1
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   thisIndex := 0
   Loop, % maxFilesIndex
   {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }
 
       imgPath := resultedFilesList[A_Index, 1]
       If !FileRexists(imgPath)
       {
          thisIndex++
          resultedFilesList[A_Index, 2] := (msgResult="add" || !msgResult) ? 1 : 0
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
          showTOOLtip("Identifying inexistent image files in the index`nMissing files: " groupDigits(thisIndex) etaTime, 0, 0, A_Index/maxFilesIndex)
          prevMSGdisplay := A_TickCount
       }
   }

   CurrentSLD := backCurrentSLD
   friendly := thisIndex ? "The files selection was altered.`nDead files found: " groupDigits(thisIndex) : "Found no inexistent files to select."
   ResetImgLoadStatus()
   updateFilesSelectionInfos()
   ForceRefreshNowThumbsList()
   If (abandonAll=1)
      showDelayedTooltip("User abandoned the operation.`n" friendly)
   Else
      showDelayedTooltip(friendly)

   dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

QuickSelectFilesSameFolder(modus:=0, external:=0) {
    imgPath := (isNumber(modus) && modus>0 && external="aye") ? modus : getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    If (!OutDir || !currentFileIndex || maxFilesIndex<3)
       Return

    o := markSearchMatches
    oz := userSearchString
    od := userSearchWhat
    og := thisSearchString

    markSearchMatches := 0
    userSearchWhat := 1
    userSearchString := OutDir "\"
    SearchIndexSelectAll("quick")
    userSearchWhat := od
    userSearchString := oz
    markSearchMatches := o
    thisSearchString := og
    dummyTimerDelayiedImageDisplay(50)
}

SelectFilesSearchIndex() {
   PanelSearchIndex("select")
}

EraseSearchEdit() {
   If (AnyWindowOpen=29)
   {
      GuiControlGet, UsrEditFilter
      BtnCloseWindow()
   }

   If StrLen(UsrEditFilter)<2
      SearchedStringz := ""
   userSearchString := ""
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      RefreshThumbsList()
}

PanelSearchIndex(dummy:="") {
    Global editFa, editFb, txtline3
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()
 
    If (maxFilesIndex<2)
    {
       showTOOLtip("WARNING: Insufficient indexed files to search for")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }
 
    If (AnyWindowOpen=6)
       BtnCloseWindow()
    Else If AnyWindowOpen
       Return

    SearchedStringz := Trimmer(SearchedStringz)
    ; ToolTip, % SearchedStringz , , , 2
    thisBtnHeight := createSettingsGUI(29, A_ThisFunc)
    btnWid := 80
    txtWid := 260
    If (PrefsLargeFonts=1)
    {
       txtWid := txtWid + 185
       btnWid := btnWid + 80
       Gui, Font, s%LargeUIfontValue%
    }

    lst := btnWid + 50
    infou := (dummy="select") ? "Please type the string by which to select files" : "Please type the string to search for in the indexed files"

    iconFile := "imageres.dll", iconNum := 169
    this := userSearchString ? userSearchString : A_Space
    Gui, +Delimiter`n
    Gui, Add, Picture, x20 y20 h%thisBtnHeight% Icon%iconNum% w-1, %iconFile%
    Gui, Add, Text, x+20 w%txtWid% Section, %infou%. Use | as the OR operator. Wildcards ? and * are supported as well.

    Gui, Add, ComboBox, y+7 wp gUIgenericComboAction vUsrEditFilter, % SearchedStringz "`n" this "`n`n"
    Gui, Add, Button, x+1 w30 hp gEraseSearchEdit +hwndhTemp, &X
    ToolTip2ctrl(hTemp, "Discard search criteria")
    Gui, Add, ListBox, xs y+7 w%lst% r4 AltSubmit Choose%userSearchPos% vuserSearchPos, Anywhere`nBegins with`nEnds with`nRegEx
    Gui, Add, ListBox, x+2 wp r4 AltSubmit Choose%userSearchWhat% vuserSearchWhat, Full path`nFolder path`nFile name`nParent folder
    Gui, Add, Checkbox, xs y+10 Checked%markSearchMatches% vmarkSearchMatches, &Highlight matching files in the list view mode

    If (dummy="select")
    {
       Gui, Add, Button, xs y+25 w%btnWid% h%thisBtnHeight% gBtnPerformSearchNow, Select &matches
       GuiControl, Disable, markSearchMatches
    } Else
    {
       Gui, Add, Button, xs y+25 w%btnWid% h%thisBtnHeight% Default gBtnPerformSearchNow, &Search next
       Gui, Add, Button, x+5 hp wp+10 gBtnPerformSearchNow, Select &matches
    }

    w := (PrefsLargeFonts=1) ? 85 : 55
    Gui, Add, Button, x+5 hp wp-40 gOpenFilterPanelBTNaction, &Filter list
    Gui, Add, Button, x+5 hp w%w% gBtnCloseWindow, C&ancel
    infou := (dummy="select") ? "Select files by given string" : "Search indexed files"
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, infou ": " appTitle)
}

BtnPerformSearchNow(a, b, c) {
   ; ToolTip, % a "=" b "=" c , , , 2
   If askAboutFileSave(" and the files index search will be performed")
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, markSearchMatches
   GuiControlGet, userSearchWhat
   GuiControlGet, userSearchPos
   GuiControlGet, UsrEditFilter
   ControlGetText, btnText,, ahk_id %a%

   userSearchString := ""
   INIaction(1, "markSearchMatches", "General")
   thisString := StrReplace(UsrEditFilter, "||", "|")
   thisString := Trim(thisString, "|")

   ; fnOutputDebug(A_ThisFunc "(1): " thisString)
   If (thisString!="")
   {
      thisString := StrReplace(thisString, "\>")
      thisString := StrReplace(thisString, "/")
      thisString := StrReplace(thisString, ">")
      If (userSearchPos=2)
         thisString := "/" thisString
      Else If (userSearchPos=3)
         thisString := ">" thisString
      Else If (userSearchPos=4)
         thisString := "\>" thisString
      userSearchString := thisString
      ; givenRegEx := processSearchIndexString(thisString)
   }

   ; fnOutputDebug(A_ThisFunc "(2): " userSearchString)
   If (userSearchString!="")
   {
      If !InStr(SearchedStringz, userSearchString "`n")
      {
         SearchedStringz .= "`n" userSearchString "`n"
         SearchedStringz := StrReplace(SearchedStringz, "`n`n", "`n")
      }

      ; Sort, SearchedStringz, UD`f
      BtnCloseWindow()
      If InStr(btnText, "search")
      {
         searchNextIndex(1)
      } Else If InStr(btnText, "select")
      {
         markSearchMatches := 0
         SearchIndexSelectAll()
      }
   } Else
   {
      showTOOLtip("WARNING: no valid search criteria was given.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

OpenFilterPanelBTNaction() {
   userSearchString := ""
   BtnCloseWindow()
   PanelEnableFilesFilter()
}

PanelEditImgCaption(dummy:=0) {
    Global newFileName, UsrStoreCaptionDB := 1
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If !FileExist(imgPath)
    {
       showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Return
    }

    ; INIaction(0, "UsrStoreCaptionDB", "General", 1)
    If (SLDtypeLoaded=3)
    {
       UsrStoreCaptionDB := 1
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")
    } Else UsrStoreCaptionDB := 0

    If !textFileContent
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       Try FileRead, textFileContent, % textFile
    }

    thisBtnHeight := createSettingsGUI(22, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 w%txtWid%, Please type the caption or annotation you want associated with this image file.
    Gui, Add, Edit, y+7 w%EditWid% r15 gUIeditsGenericAllowCtrlBksp limit2048 -wantTab vnewFileName, % textFileContent
    Gui, Add, Checkbox, y+7 Checked%UsrStoreCaptionDB% vUsrStoreCaptionDB, Store image caption into the SQL database

    thisW := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%thisW% Default gSaveCaptionBTNaction, &Save
    Gui, Add, Button, x+5 hp wp gDeleteCaptionBTNaction, &Delete
    Gui, Add, Button, x+5 hp wp gBTNhelpCaptions, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    If (SLDtypeLoaded!=3)
       GuiControl, Disable, UsrStoreCaptionDB

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Edit image caption: " appTitle)
}

BTNhelpCaptions() {
    msgBoxWrapper(appTitle ": HELP", "Image file captions [annotations] are stored in .TXT files [as plain text], where the image file is located, under the same file name.`n`nFor example:`nC:\example-folder\image-file.jpg`nC:\example-folder\image-file.txt`n`nIf you are using SQLite slideshow databases, you have the option to store the captions in the database, not as individual files for each image. However, please keep in mind, when the files list is renewed or regenerated, the captions or audio annotations might get lost.", -1, 0, 0)
}

DeleteCaptionBTNaction() {
    GuiControlGet, UsrStoreCaptionDB
    ; INIaction(1, "UsrStoreCaptionDB", "General")
    BtnCloseWindow()
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"
    If FileExist(textFile)
       mustShowError := 1

    Try FileDelete, % textFile
    Catch wasError
          Sleep, 2

    If (mustShowError && wasError)
    {
       showTOOLtip("ERROR: Unable to delete text file:`n" OutNameNoExt ".txt`n" OutDir "\")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    If (SLDtypeLoaded=3)
       updateSQLdbEntryCaption(imgPath, "", "imgCaption")

    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

SaveCaptionBTNaction() {
    GuiControlGet, newFileName
    GuiControlGet, UsrStoreCaptionDB
    ; INIaction(1, "UsrStoreCaptionDB", "General")
    newFileName := Trimmer(newFileName)
    If !newFileName
    {
       DeleteCaptionBTNaction()
       Return
    }

    BtnCloseWindow()
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3 && UsrStoreCaptionDB=1)
    {
       updateSQLdbEntryCaption(imgPath, newFileName, "imgCaption")
    } Else
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       FileDelete, % textFile
       Sleep, 2
       Try FileAppend, % newFileName, % textFile, UTF-16
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "Failed to write text file. Permission denied.`n" OutNameNoExt ".txt`n" OutDir "\", 0, 0, "error")
    }

    showImgAnnotations := 1
    If (showImgAnnotations!=1)
       INIaction(1, "showImgAnnotations", "General")

    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

InvokeUpdateIndexPanelBTNaction() {
   CloseWindow()
   Sleep, 1
   PanelUpdateThisFileIndex()
}

filterFileName(ostring) {
  Static forbiddenCharsREGex := "\<|\>|\:|\""|\/|\\|\||\?|\*"
  Static forbiddenNames := "CON|PRN|AUX|NUL|COM1|COM2|COM3|COM4|COM5|COM6|COM7|COM8|COM9|LPT1|LPT2|LPT3|LPT4|LPT5|LPT6|LPT7|LPT8|LPT9"
  string := Trimmer(ostring)
  string := Trim(string, ".")
  string := Trim(string, ",")
  string := StrReplace(string, "/", "\")
  string := RegExReplace(string, "\\{2,}", "\")
  If RegExMatch(string, forbiddenCharsREGex)
     Return

  Loop, Parse, forbiddenNames, |
  {
     If (A_LoopField=string)
        Return
  }

  Return string
}

undoFileRenameAction() {
   RenameBTNaction(lastRenameUndo[1], lastRenameUndo[2], 1)
   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   lastRenameUndo := []
}

RenameBTNaction(newFileName, file2rem, doLastOption) {
  newFileName := filterFileName(newFileName)
  If (StrLen(newFileName)>3)
  {
     zPlitPath(file2rem, 0, OutFileName, OutDir, fileNamuNoEXT, oldEXT)
     If !InStr(newFileName, ".")
        newFileName .= "." oldEXT

     If (Trimmer(OutFileName)=newFileName)
        Return 1

     If !FileExist(file2rem)
        Return 0

     destroyGDIfileCache()
     FileGetTime, originalMtime, % file2rem, M
     FileGetTime, originalCtime, % file2rem, C
     file2save := OutDir "\" newFileName
     thisFileExists := 0
     If (FileExist(file2save) && !FolderExist(file2save))
     {
        thisFileExists := 1
        file2save := askAboutFileCollision(file2rem, file2save, 0, doLastOption + 1, 0, performOverwrite)
     }

     If (file2save="abort" || !file2save)
     {
        SetTimer, SingularRenameFile, -150
        Return
     }

     If (thisFileExists=1)
     {
        If (performOverwrite=1)
        {
           FileSetAttrib, -R, %file2save%
           Sleep, 2
           FileRecycle, %file2save%
           Sleep, 2
        } Else If (performOverwrite!=2)
        {
           showTOOLtip("Rename operation abandoned.`nA file with the provided name already exists.`nFile name conflict`n" newFileName)
           SetTimer, RemoveTooltip, % -msgDisplayTime
           Return 0
        }
     }

     FileSetAttrib, -R, %file2rem%
     Sleep, 2
     FileMove, %file2rem%, %file2save%, 1
     If ErrorLevel
     {
        OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)
        showTOOLtip("ERROR: Access denied... The file could not be renamed.`n" OutFileName "`n" OutDir "\")
        SoundBeep, 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     } Else
     {
        updateDates := 1
        If originalMtime
        {
           Sleep, 0
           FileSetTime, % originalMtime, % file2save, M
           FileSetTime, % originalCtime, % file2save, C
           updateDates := 0
        }

        lastRenameUndo := []
        lastRenameUndo := [OutFileName, file2save]
        If (SLDtypeLoaded=3)
           updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[currentFileIndex, 12])

        currentFilesListModified := 1
        resultedFilesList[currentFileIndex, 1] := file2save
        updateMainUnfilteredList(currentFileIndex, 1, file2save)
        watchFolderDetails := ""
        dummyTimerDelayiedImageDisplay(50)
        If (userPrivateMode=1)
        {
           OutDir := "*:\*******\******"
           newFileName := "******.***"
        } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

        showTOOLtip("File renamed succesfully to:`n" newFileName "`n" OutDir "\")
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 1
     }
  } Else Return 0
}

UpdateIndexBTNaction(newFileName, whichIndex) {
  ; GuiControlGet, newFileName
  newFileName := Trimmer(newFileName)
  newFileName := StrReplace(newFileName, "/", "\")
  newFileName := RegExReplace(newFileName, "\\{2,}", "\")
  allGood := 1
  If !RegExMatch(newFileName, "i)^(.\:\\.)")
     allGood := 0

  strArr := StrSplit(newFileName, "\")
  Loop, % strArr.Count()
  {
      testThis := filterFileName(strArr[A_Index])
      If (!testThis && A_Index>1)
         allGood := 0
  }

  If !RegExMatch(newFileName, RegExFilesPattern)
     allGood := 0

  If !FileRexists(newFileName)
  {
     If (allGood=1)
        fileNotFound := 1
     allGood := 0
  }

  If (StrLen(newFileName)>2 && allGood=1)
  {
     oldFileName := resultedFilesList[whichIndex, 1]
     resultedFilesList[whichIndex, 1] := newFileName
     resultedFilesList[whichIndex, 4] := 1
     If (SLDtypeLoaded=3)
        updateSQLdbEntry(oldFileName, newFileName, 0, resultedFilesList[whichIndex, 12])

     updateMainUnfilteredList(whichIndex, 1, OutDir "\" newFileName)
     ForceRefreshNowThumbsList()
     currentFilesListModified := 1
     dummyTimerDelayiedImageDisplay(150)
     showTOOLtip("File index entry updated: " groupDigits(whichIndex))
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return 1
  } Else If (StrLen(newFileName)>2)
  {
     If (fileNotFound=1)
        showTOOLtip("ERROR: The file index entry was not updated.`nFile not found or access denied`n" newFileName)
     Else
        showTOOLtip("ERROR: The file index entry was not updated.`nIncorrect file name provided:`n" newFileName)
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return 0
  }
}

updateUIpastePanel(actionu:=0, b:=0) {
    Critical, on
    Static lastInvoked := 1
    isWinOpen := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
    If (isWinOpen!=1)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIpastePanel, -150
       Return
    }

    If (coreDesiredPixFmt="0x21808")
    {
       alphaMaskingMode := 1
       GuiControl, Disable, alphaMaskingMode
       GuiControl, Choose, alphaMaskingMode, 1
    }

    If (CurrentPanelTab=1)
    {
       actu := (PasteInPlaceBlurAmount>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, PasteInPlaceBlurEdgesSoft

       actu := (PasteInPlaceAdaptMode=2) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, PasteInPlaceAlignment

       actu := (PasteInPlaceCropSel>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, SettingsGUIA:, infoPasteBlur, Image blur level: %PasteInPlaceBlurAmount% ; (inaccurate live preview)
       GuiControl, % actu, PasteInPlaceCropAngular
       GuiControl, % actu, editF5
       GuiControl, % actu, infoAngleu
    } Else If (CurrentPanelTab=2)
    {
       actu := (PasteInPlaceBlendMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, PasteInPlaceGlassy

       actu2 := (PasteInPlaceApplyColorFX=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, PasteInPlaceLight
       GuiControl, % actu2, PasteInPlaceGamma
       GuiControl, % actu2, PasteInPlaceHue
       GuiControl, % actu2, PasteInPlaceSaturation
       GuiControl, % actu2, infoPasteLight
       GuiControl, % actu2, infoPasteGamma
       GuiControl, % actu2, infoPasteHue
       GuiControl, % actu2, infoPasteSat

       thisOpacity := Round((PasteInPlaceOpacity / 255) * 100)
       GuiControl, SettingsGUIA:, infoPasteOpacity, Image opacity: %thisOpacity%`%
       GuiControl, SettingsGUIA:, infoPasteHue, Hue: %PasteInPlaceHue%°
       GuiControl, SettingsGUIA:, infoPasteSat, Saturation: %PasteInPlaceSaturation%`%
       GuiControl, SettingsGUIA:, infoPasteLight, Brightness: %PasteInPlaceLight%
       GuiControl, SettingsGUIA:, infoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    } Else If (CurrentPanelTab=3)
    {
       updateUIalphaMaskStuff(1)
    } Else If (CurrentPanelTab=4)
       updateUIalphaMaskStuff(2)

    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing(0, 0, A_ThisFunc, actionu, b)

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsPasteInPlacePanel, -350
    SetTimer, WriteSettingsBrushPanel, -350
    SetTimer, WriteSettingsAlphaMaskPanel, -250
}

updateUIalphaMaskStuff(tabu) {
    If (tabu=1)
    {
       If (alphaMaskingMode=5)
       {
          thisAlphaBlur := Round((alphaMaskGradientScale - 1)/305 * 255)
          GuiControl, SettingsGUIA:, infoAlphaMaskGradientScale, Blur amount: %thisAlphaBlur%
       } Else GuiControl, SettingsGUIA:, infoAlphaMaskGradientScale, Scale: %alphaMaskGradientScale%`%

       actu := (alphaMaskingMode>=5 || alphaMaskingMode=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, alphaMaskGradientWrapped

       GuiControl, SettingsGUIA:, infoAlphaMaskSigma, Pos. A: %alphaMaskGradientPosA%`%
       GuiControl, SettingsGUIA:, infoAlphaMaskBlend, Pos. B: %alphaMaskGradientPosB%`%
       GuiControl, SettingsGUIA:, infoAlphaMaskGradientAngle, Angle: %alphaMaskGradientAngle%°

       actu := (alphaMaskingMode>1 && alphaMaskingMode!=5 && alphaMaskingMode!=6) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, alphaMaskReplaceMode
       GuiControl, % actu, infoAlphaMaskSigma
       GuiControl, % actu, infoAlphaMaskBlend
       GuiControl, % actu, alphaMaskGradientPosA
       GuiControl, % actu, alphaMaskGradientPosB
       GuiControl, % actu, alphaMaskColorReversed

       actu := (alphaMaskingMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, infoAlphaMaskGradientScale
       GuiControl, % actu, alphaMaskGradientScale

       actu := (alphaMaskingMode=5) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, alphaMaskRefBMP
       GuiControl, % actu, alphaMaskBMPchannel
       GuiControl, % actu, infoAlphaFile
       If (alphaMaskingMode=6)
       {
          brLvl := alphaMaskClrAintensity
          contrLvl := "Curve tension: " Round(alphaMaskClrBintensity/255, 2)
          If (alphaMaskClrBintensity<15)
             contrLvl := "Polygonal path"
          Else If (alphaMaskClrBintensity>250)
             contrLvl := "Bézier path"

          GuiControl, SettingsGUIA:, infoAlphaClrAint, Blur amount: %brLvl%
          GuiControl, SettingsGUIA:, infoAlphaClrBint, %contrLvl%
       } Else If (alphaMaskingMode=5)
       {
          brLvl := Round(alphaMaskClrAintensity/255*510-255)
          contrLvl := Round(alphaMaskClrBintensity/255*100)
          GuiControl, SettingsGUIA:, infoAlphaClrAint, Brightness: %brLvl%
          GuiControl, SettingsGUIA:, infoAlphaClrBint, Contrast: %contrLvl%
       } Else
       {
          GuiControl, SettingsGUIA:, infoAlphaClrAint, Intensity A: %alphaMaskClrAintensity%
          GuiControl, SettingsGUIA:, infoAlphaClrBint, Intensity B: %alphaMaskClrBintensity%
       }

       actu := (alphaMaskingMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, alphaMaskReplaceMode
       GuiControl, % actu, alphaMaskColorReversed
       GuiControl, % actu, alphaMaskGradientAngle
       GuiControl, % actu, infoAlphaMaskGradientAngle
       GuiControl, % actu, infoAlphaClrAint
       GuiControl, % actu, infoAlphaClrBint
       GuiControl, % actu, alphaMaskClrAintensity
       GuiControl, % actu, alphaMaskClrBintensity
    } Else If (tabu=2)
    {
       actu := (liveDrawingBrushTool=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, BrushToolType
       GuiControl, % actu, infoBrushAopacity
       GuiControl, % actu, infoBrushBopacity
       GuiControl, % actu, brushToolDoubleSize
       GuiControl, % actu, infoBrushSoftness
       GuiControl, % actu, infoBrushStepping
       GuiControl, % actu, infoBrushAngle
       GuiControl, % actu, infoBrushAspectRatio
       GuiControl, % actu, PickuBrushToolBcolor
       GuiControl, % actu, BrushToolBopacity
       GuiControl, % actu, BrushToolBcolor
       GuiControl, % actu, infoBrushBopacity
       GuiControl, % actu, PickuBrushToolAcolor
       GuiControl, % actu, BrushToolAopacity
       GuiControl, % actu, BrushToolAcolor
       GuiControl, % actu, infoBrushAopacity
       GuiControl, % actu, brushToolDoubleSize
       GuiControl, % actu, BrushToolSize
       GuiControl, % actu, BrushToolStepping
       GuiControl, % actu, BrushToolAspectRatio
       GuiControl, % actu, BrushToolAngle
       GuiControl, % actu, BrushToolSoftness
       GuiControl, % actu, BrushToolDryingRate
       GuiControl, % actu, UIbtnBrushColorA
       GuiControl, % actu, UIbtnBrushColorB

       actu := (liveDrawingBrushTool=1 && BrushToolType=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, BrushToolOverDraw

       If (BrushToolType=1)
       {
          GuiControl, SettingsGUIA: Disable, infoBrushSoftness
          GuiControl, SettingsGUIA: Disable, BrushToolSoftness
       } Else If (liveDrawingBrushTool=1)
       {
          GuiControl, SettingsGUIA: Enable, infoBrushSoftness
          GuiControl, SettingsGUIA: Enable, BrushToolSoftness
       }

       thisOpacity := Round((BrushToolAopacity / 255) * 100)
       this2ndOpacity := Round((BrushToolBopacity / 255) * 100)
       theSize := (brushToolDoubleSize!=1) ? "Diameter" : "Radius"
       stepu := (brushToolStepping<=2 || brushToolStepping=251) ? "AUTO" : brushToolStepping
       If (brushToolStepping=0)
          stepu := "NONE"

       GuiControl, SettingsGUIA:, infoBrushAopacity, %thisOpacity%`%
       GuiControl, SettingsGUIA:, infoBrushBopacity, %this2ndOpacity%`%
       GuiControl, SettingsGUIA:, brushToolDoubleSize, %theSize%: %BrushToolSize% px
       GuiControl, SettingsGUIA:, infoBrushSoftness, Softness: %BrushToolSoftness%`%
       GuiControl, SettingsGUIA:, infoBrushStepping, Stepping: %stepu%
       GuiControl, SettingsGUIA:, infoBrushAngle, Angle: %BrushToolAngle%° 
       GuiControl, SettingsGUIA:, infoBrushAspectRatio, Aspect ratio: %BrushToolAspectRatio%
       GuiControl, SettingsGUIA:, infoBrushDrying, Dry-out rate: %BrushToolDryingRate%

       If (BrushToolUseSecondaryColor=1)
       {
          If (liveDrawingBrushTool=1)
          {
             GuiControl, SettingsGUIA: Enable, PickuBrushToolBcolor
             GuiControl, SettingsGUIA: Enable, BrushToolBopacity
             GuiControl, SettingsGUIA: Enable, BrushToolBcolor
             GuiControl, SettingsGUIA: Enable, infoBrushBopacity
          }
          GuiControl, SettingsGUIA: Disable, PickuBrushToolAcolor
          GuiControl, SettingsGUIA: Disable, BrushToolAopacity
          GuiControl, SettingsGUIA: Disable, BrushToolAcolor
          GuiControl, SettingsGUIA: Disable, infoBrushAopacity
          GuiControl, SettingsGUIA:, UIbtnBrushColorB, [X]
          GuiControl, SettingsGUIA:, UIbtnBrushColorA, [-]
       } Else
       {
          GuiControl, SettingsGUIA:, UIbtnBrushColorB, [-]
          GuiControl, SettingsGUIA:, UIbtnBrushColorA, [X]
          If (liveDrawingBrushTool=1)
          {
             GuiControl, SettingsGUIA: Enable, PickuBrushToolAcolor
             GuiControl, SettingsGUIA: Enable, BrushToolAopacity
             GuiControl, SettingsGUIA: Enable, BrushToolAcolor
             GuiControl, SettingsGUIA: Enable, infoBrushAopacity
          }
          GuiControl, SettingsGUIA: Disable, PickuBrushToolBcolor
          GuiControl, SettingsGUIA: Disable, BrushToolBopacity
          GuiControl, SettingsGUIA: Disable, BrushToolBcolor
          GuiControl, SettingsGUIA: Disable, infoBrushBopacity
       }
    }
}

WriteSettingsPasteInPlacePanel() {
   ReadSettingsPasteInPlace(1)
}

throwErrorSelectionOutsideBounds(whichBitmap:=0) {
    whichBitmap := StrLen(whichBitmap)>1 ? whichBitmap : useGdiBitmap()
    If testSelectOutsideImgEntirely(whichBitmap)
    {
       SoundBeep , 300, 100
       showDelayedTooltip("WARNING: Invalid image selection area.`nIt seems to be entirely outside the image boundaries.")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return 1
    }
}

BtnPasteInSelectedArea() {
    If (PasteInPlaceAutoExpandIMG!=1 || PasteInPlaceBlendMode>1)
    {
       If throwErrorSelectionOutsideBounds()
          Return
    }

    updateUIpastePanel("noPreview")
    Sleep, 1
    CloseWindow(0, 0)
    ToggleEditImgSelection("show-edit")
    Sleep, 1
    ; viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    PasteInPlaceNow()
}

importEditGivenImageFile() {
   If !prevLoadedImageIndex
      Return

   imgPath := StrReplace(getIDimage(currentFileIndex), "||")
   If !FileExist(imgPath)
   {
      showTOOLtip("ERROR: The selected image cannot be imported`nFile does not exist or access denied.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   currentFileIndex := prevLoadedImageIndex
   MenuReturnIMGedit()
   Sleep, 2
   If (editingSelectionNow!=1)
      ToggleEditImgSelection()
   ; ToggleEditImgSelection("show-edit")
   Sleep, 2
   PanelPasteInPlace(imgPath)
}

ReadSettingsPasteInPlace(act:=0) {
    RegAction(act, "PasteInPlaceGlassy",, 2, 1, 6)
    RegAction(act, "PasteInPlaceBlendMode",, 2, 1, 21)
    RegAction(act, "PasteInPlaceAdaptMode",, 2, 1, 3)
    RegAction(act, "alphaMaskClrAintensity",, 2, 0, 255)
    RegAction(act, "alphaMaskClrBintensity",, 2, 0, 255)
    RegAction(act, "PasteInPlaceApplyColorFX",, 1)
    RegAction(act, "PasteInPlaceBlurAmount",, 2, 0, 255)
    RegAction(act, "PasteInPlaceBlurEdgesSoft",, 1)
    RegAction(act, "PasteInPlaceAlignment",, 2, 1, 5)
    RegAction(act, "PasteInPlaceCropSel",, 2, 1, 8)
    RegAction(act, "PasteInPlaceCropAngular",, 2, 0, 359)
    RegAction(act, "PasteInPlaceEraseInitial",, 1)
    RegAction(act, "PasteInPlaceGamma",, 2, -100, 100)
    RegAction(act, "PasteInPlaceHue",, 2, -180, 180)
    RegAction(act, "PasteInPlaceLight",, 2, -255, 255)
    RegAction(act, "PasteInPlaceSaturation",, 2, -100, 100)
    RegAction(act, "PasteInPlaceOpacity",, 2, 1, 512)
    RegAction(act, "PasteInPlaceOrientation",, 2, 1, 4)
    RegAction(act, "PasteInPlaceQuality",, 1)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
}

togglePasteInPlaceAdaptModes() {
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceAdaptMode := clampInRange(PasteInPlaceAdaptMode + 1, 1, 3, 1)
      GuiControl, SettingsGUIA: Choose, PasteInPlaceAdaptMode, % PasteInPlaceAdaptMode
      updateUIpastePanel()
   }
}

toggleErasePasteInPlace() {
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceEraseInitial := !PasteInPlaceEraseInitial
      GuiControl, SettingsGUIA:, PasteInPlaceEraseInitial, % PasteInPlaceEraseInitial
      updateUIpastePanel()
   }
}

togglePasteInPlaceColorsFX() {
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceApplyColorFX := !PasteInPlaceApplyColorFX
      GuiControl, SettingsGUIA:, PasteInPlaceApplyColorFX, % PasteInPlaceApplyColorFX
      updateUIpastePanel()
   }
}

togglePasteInPlaceCropShapes() {
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceCropSel := clampInRange(PasteInPlaceCropSel + 1, 1, 8, 1)
      GuiControl, SettingsGUIA: Choose, PasteInPlaceCropSel, % PasteInPlaceCropSel
      updateUIpastePanel()
   }
}


FlipVtransformedIMGpanel() {
   Static kl := {4:2, 3:1, 2:4, 1:3}
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceOrientation := kl[PasteInPlaceOrientation]
      GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, % PasteInPlaceOrientation
      updateUIpastePanel()
   }
}

FlipHtransformedIMGpanel() {
   Static kl := {4:3, 3:4, 2:1, 1:2}
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceOrientation := kl[PasteInPlaceOrientation]
      GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, % PasteInPlaceOrientation
      updateUIpastePanel()
   }
}

PanelTransformSelectedArea() {
   MainPanelTransformArea(0, "transform")
}

PanelPasteInPlace(dummy:="") {
   MainPanelTransformArea(dummy, "paste")
}

BTNresetPasteInPlaceCropAngle() {
   GuiControl, SettingsGUIA:, editF5, 0
   updateUIpastePanel()
}

BTNtoggleAlphaPainting() {
   GuiControlGet, uiPasteInPlaceAlphaDrawMode, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode
   If (!uiPasteInPlaceAlphaDrawMode && liveDrawingBrushTool!=1)
      Return

   updateUIpastePanel()
   toggleAlphaPaintingMode()
   RemoveTooltip()
}

MainPanelTransformArea(dummy:="", toolu:="") {
    userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    imgPath := getIDimage(currentFileIndex)
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || openingPanelNow=1)
       Return

    calcScreenLimits()
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If throwErrorSelectionOutsideBounds()
       Return

    openingPanelNow := 1
    DestroyGIFuWin()
    changeMcursor()
    setImageLoading()
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    If (toolu="transform")
    {
       showTOOLtip("Retrieving image selected area, please wait")
       userClipBMPpaste := getSelectedImageArea(useGdiBitmap(), 0, 0, 1, 1)
       If StrLen(userClipBMPpaste)>2
       {
          Gdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
          Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)
          QPV_SetGivenAlphaLevel(viewportStampBMP, 1, 1)
       }
    } Else If (toolu="paste")
    {
       showTOOLtip("Retrieving clipboard image, please wait")
       If FileRexists(dummy)
       {
          thisPBitmap := LoadBitmapFromFileu(dummy)
          userClipBMPpaste := Gdip_CloneBmpPargbArea(A_ThisFunc, thisPBitmap)
          trGdip_DisposeImage(thisPBitmap, 1)
       } Else
          userClipBMPpaste := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 0)

       If StrLen(userClipBMPpaste)>2
       {
          Gdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
          Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)

          QPV_SetGivenAlphaLevel(viewportStampBMP, 1, 1)
       }
    }

    If (StrLen(userClipBMPpaste)<3 || StrLen(viewportStampBMP)<3)
    {
       openingPanelNow := 0
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       SetTimer, resetOpeningPanel, -200
       showTOOLtip("ERROR: Failed to retrieve and prepare image to perform transformations")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return
    }

    imgEditPanelOpened := 1
    viewportIDstampBMP := A_TickCount
    prevVPselRotation := VPselRotation
    prevrotateSelBoundsKeepRatio := rotateSelBoundsKeepRatio
    prevEllipseSelectMode := EllipseSelectMode
    previnnerSelectionCavityX := innerSelectionCavityX
    previnnerSelectionCavityY := innerSelectionCavityY
    prevImgSelX1 := imgSelX1, prevImgSelX2 := imgSelX2
    prevImgSelY1 := imgSelY1, prevImgSelY2 := imgSelY2
    If (toolu="transform")
    {
       recordSelUndoLevelNow()
       Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelX1 := pB.x, imgSelY1 := pB.y
       imgSelX2 := pB.x + pB.w
       imgSelY2 := pB.y + pB.h
       VPstampBMPx := pB.x, VPstampBMPy := pB.y
       PasteInPlaceToolMode := 1
       dummyRefreshImgSelectionWindow()
       thisBtnHeight := createSettingsGUI(31, "PanelTransformSelectedArea", 1, 1)
    } Else If (toolu="paste")
    {
       PasteInPlaceToolMode := 0
       flipBitmapAccordingToViewPort(viewportStampBMP)
       thisBtnHeight := createSettingsGUI(24, "PanelPasteInPlace", 1, 1)
    }

    shearImgX := shearImgY := innerSelectionCavityX := innerSelectionCavityY := EllipseSelectMode := VPselRotation := 0
    ResetImgLoadStatus()
    ReadSettingsPasteInPlace()
    ReadSettingsBrushPanel()
    ReadSettingsAlphaMaskPanel()
    If !isNumber(PasteInPlaceCropAngular)
       PasteInPlaceCropAngular := 0

    If isWinXP
       PasteInPlaceBlendMode := 1

    If (coreDesiredPixFmt="0x21808")
       alphaMaskingMode := 1

    btnWid := 90,  txtWid := 310
    EditWid := 60, slideWid := 150
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 55
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid2 := txtWid//2
    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (toolu="transform")
       prevModeViewPortSelectionManager(prevDestPosX, prevDestPosY, oImgW, oImgH)

    thisOpacity := Round((PasteInPlaceOpacity / 255) * 100)
    Global infoPasteBlur, infoPasteOpacity, infoPasteHue, infoPasteSat, infoPasteLight, infoPasteGamma, btnReset
         , infoAlphaMaskSigma, infoAlphaMaskBlend, infoAlphaMaskGradientAngle, infoAlphaMaskGradientScale
         , infoAlphaClrAint, infoAlphaClrBint, infoAlphaFile, infoAngleu, uiPasteInPlaceAlphaDrawMode

    Gui, Add, Tab3, gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Main|Adjust colors|Alpha mask|Paint alpha mask
    Gui, Tab, 1 ; general
    fr :=  (toolu="transform") ? "Transformed" : "Clipboard"
    Gui, Add, Text, x+15 y+15 Section w%txtWid%, Canvas: %oImgW% x %oImgH% px.`n%fr% object: %imgW% x %imgH% px.

    sml := (PrefsLargeFonts=1) ? 70 : 55
    Gui, Add, DropDownList, xs y+7 wp gupdateUIpastePanel AltSubmit Choose%PasteInPlaceAdaptMode% vPasteInPlaceAdaptMode, Adjust image to selection|Fill selection area entirely (ignore aspect ratio)|Original image size
    Gui, Add, DropDownList, xs y+7 gupdateUIpastePanel w%txtWid2% AltSubmit Choose%PasteInPlaceOrientation% vPasteInPlaceOrientation, No mirroring|Flip horizontal|Flip vertical|Flip horizontal and vertical
    Gui, Add, DropDownList, x+2 gupdateUIpastePanel wp AltSubmit Choose%PasteInPlaceAlignment% vPasteInPlaceAlignment, Top-left|Top-right|Centered|Bottom-left|Bottom-right
    Gui, Add, DropDownList, xs y+7 wp AltSubmit Choose%PasteInPlaceCropSel% vPasteInPlaceCropSel gupdateUIpastePanel, No cropping|Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape
    Gui, Add, Text, x+2 hp +0x200 vinfoAngleu gBTNresetPasteInPlaceCropAngle +TabStop, Angle:
    Gui, Add, Edit, x+5 w%sml% number -multi limit3 veditF5, % PasteInPlaceCropAngular
    Gui, Add, UpDown, vPasteInPlaceCropAngular Range0-359 gupdateUIpastePanel, % PasteInPlaceCropAngular
    ; If (toolu="transform")
       Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceEraseInitial% vPasteInPlaceEraseInitial, &Erase initially selected area
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceQuality% vPasteInPlaceQuality, &High quality image resampling
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas to fit image object
    Gui, Add, Text, xs y+10 w%txtWid2% gBtnResetPanelsSpecificControl vinfoPasteBlur +TabStop, Image blur level: %PasteInPlaceBlurAmount% ; (inaccurate live preview)
    Gui, Add, Checkbox, x+5 hp gupdateUIpastePanel Checked%PasteInPlaceBlurEdgesSoft% vPasteInPlaceBlurEdgesSoft, &Soft edges
    Gui, Add, Slider, Center xs y+1 gupdateUIpastePanel AltSubmit w%txtWid% vPasteInPlaceBlurAmount Range0-255, % PasteInPlaceBlurAmount
    If (coreDesiredPixFmt="0x21808")
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+10 w%txtWid%, WARNING: 32-bits RGBA mode is not activated. This tool may yield erroneous results.
       Gui, Font, Normal
    }

    Gui, Tab, 2 ; colors
    Gui, Add, Checkbox, x+15 y+15 Section w%txtWid2% gupdateUIpastePanel Checked%PasteInPlaceApplyColorFX% vPasteInPlaceApplyColorFX, Color adjustments
    Gui, Add, DropDownList, x+0 wp-10 gupdateUIpastePanel AltSubmit Choose%PasteInPlaceBlendMode% vPasteInPlaceBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Text, xs y+5 w%txtWid% gBtnResetPanelsSpecificControl vinfoPasteHue +TabStop, Hue: %PasteInPlaceHue%°
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIpastePanel vPasteInPlaceHue Range-180-180, % PasteInPlaceHue
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteSat +TabStop, Saturation: %PasteInPlaceSaturation%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIpastePanel vPasteInPlaceSaturation Range-100-100, % PasteInPlaceSaturation
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteLight +TabStop, Brightness: %PasteInPlaceLight%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIpastePanel vPasteInPlaceLight Range-255-255, % PasteInPlaceLight
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteGamma +TabStop, Contrast: %PasteInPlaceGamma%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIpastePanel vPasteInPlaceGamma Range-100-100, % PasteInPlaceGamma
    Gui, Add, Text, xs y+9 w%txtWid2% gBtnResetPanelsSpecificControl vinfoPasteOpacity  +TabStop, Image opacity: 100`% - ; %thisOpacity%
    Gui, Add, DropDownList, x+0 wp-10 AltSubmit Choose%PasteInPlaceGlassy% vPasteInPlaceGlassy gupdateUIpastePanel, No glass effect|Weak|Mild|Moderate|Strong|Extreme
    Gui, Add, Slider, Center xs y+1 w%txtWid% AltSubmit NoTicks gupdateUIpastePanel vPasteInPlaceOpacity Range1-512, % PasteInPlaceOpacity

    uiADDalphaMaskTabs(3, 4, "updateUIpastePanel")
    Gui, Tab
    ; friendlyBtn := (toolu="paste") ? "&Paste" : "&Transform"
    sml := (PrefsLargeFonts=1) ? 82 : 65
    friendlyTitle := (toolu="paste") ? "Paste in place image: " : "Transform selected area: "
    Gui, Add, Button, xm+0 y+15 Section h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    Gui, Add, Button, x+5 w%sml% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp wp vbtnReset gBtnPasteResetOptions, &Reset
    Gui, Add, Button, x+5 hp wp-5 gBtnHelpTransform, &Help
    Gui, Add, Button, x+5 hp wp+5 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xs y+7 gupdateUIpastePanel Checked%doImgEditLivePreview% vdoImgEditLivePreview, &Live preview (low quality)
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, friendlyTitle appTitle, winPos)
    SetTimer, updateUIpastePanel, -350
    SetTimer, resetOpeningPanel, -300
}

BtnHelpTransform() {
    msgBoxWrapper(appTitle ": HELP", "The transform tool is a multi-functional one. You can clone, crop, resize, rotate, colour adjust and blend images with this tool.`n`nClone image area. Once you have selected an area in the image and opened this panel, deselect «Erase initially selected area» found in the Main tab.`n`nRotate the image. Locate a gray dot with the mouse cursor in the center of the selection area in the viewport, and click 'n drag to adjust the rotation angle.`n`nCrop an image. Set the first drop-down found in the Main tab, to «Original image size», make the selection as small as you need it to be, and set to your preferences the other drop-downs that designate the cropping shape, its angle and the alignment.`n`nAdjust colours and blend images. In the «Adjust colours» tab one can activate the colour adjustments check-box, adjust opacity and choose different blending modes.`n`nWhen alpha masking is activated and the tab pertaining to this is also activated, users can click 'n drag inside the selection area to adjust the mask's gradient center. To reset the position, press Alt+L-Click inside the selection area.", -1, 0, 0)
}

ResetTransformToolPos() {
    VPselRotation := 0
    ImgSelX1 := prevImgSelX1, ImgSelX2 := prevImgSelX2
    ImgSelY1 := prevImgSelY1, ImgSelY2 := prevImgSelY2
    dummyTimerDelayiedImageDisplay(100)
}

BtnResetPanelsSpecificControl(CtrlHwnd, b, c) {
   ; GuiControlGet, varu, SettingsGUIA: FocusV
   If (isAlphaMaskWindow()=1)
      GuiControlGet, modus, SettingsGUIA:, alphaMaskingMode

   GuiControlGet, varu, SettingsGUIA: Name, % CtrlHwnd
   ; ToolTip, % varu "`n" a "|" b "|" c , , , 2
   If (varu="infoPasteBlur")
   {
      PasteInPlaceBlurAmount := 0
      GuiControl, SettingsGUIA:, PasteInPlaceBlurAmount, % PasteInPlaceBlurAmount
   } Else If (varu="infoPasteHue")
   {
      PasteInPlaceHue := 0
      GuiControl, SettingsGUIA:, PasteInPlaceHue, % PasteInPlaceHue
   } Else If (varu="infoPasteSat")
   {
      PasteInPlaceSaturation := 0
      GuiControl, SettingsGUIA:, PasteInPlaceSaturation, % PasteInPlaceSaturation
   } Else If (varu="infoPasteLight")
   {
      PasteInPlaceLight := 0
      GuiControl, SettingsGUIA:, PasteInPlaceLight, % PasteInPlaceLight
   } Else If (varu="infoPasteGamma")
   {
      PasteInPlaceGamma := 0
      GuiControl, SettingsGUIA:, PasteInPlaceGamma, % PasteInPlaceGamma
   } Else If (varu="infoBlurHue")
   {
      BlurAreaHue := 0
      GuiControl, SettingsGUIA:, BlurAreaHue, % BlurAreaHue
   } Else If (varu="infoBlurSat")
   {
      BlurAreaSaturation := 0
      GuiControl, SettingsGUIA:, BlurAreaSaturation, % BlurAreaSaturation
   } Else If (varu="infoBlurLight")
   {
      BlurAreaLight := 0
      GuiControl, SettingsGUIA:, BlurAreaLight, % BlurAreaLight
   } Else If (varu="infoBlurGamma")
   {
      BlurAreaGamma := 0
      GuiControl, SettingsGUIA:, BlurAreaGamma, % BlurAreaGamma
   } Else If (varu="infoPasteOpacity")
   {
      PasteInPlaceOpacity := 255
      GuiControl, SettingsGUIA:, PasteInPlaceOpacity, % PasteInPlaceOpacity
   } Else If (varu="infoAlphaClrAint")
   {
      val := (alphaMaskClrBintensity<3) ? 255 : 0
      alphaMaskClrAintensity := (modus=5) ? 128 : val
      GuiControl, SettingsGUIA:, alphaMaskClrAintensity, % alphaMaskClrAintensity
   } Else If (varu="infoAlphaClrBint")
   {
      val := (alphaMaskClrAintensity<3) ? 255 : 0
      alphaMaskClrBintensity := (modus=5) ? 0 : val
      GuiControl, SettingsGUIA:, alphaMaskClrBintensity, % alphaMaskClrBintensity
   } Else If (varu="infoFillAreaGradientAngle")
   {
      FillAreaGradientAngle := 0
      GuiControl, SettingsGUIA:, FillAreaGradientAngle, % FillAreaGradientAngle
   } Else If (varu="infoFillAreaGradientScale")
   {
      FillAreaGradientScale := (modus=5) ? 1 : 100
      GuiControl, SettingsGUIA:, FillAreaGradientScale, % FillAreaGradientScale
   } Else If (varu="infoFillAreaSigma")
   {
      FillAreaGradientPosA := 0
      GuiControl, SettingsGUIA:, FillAreaGradientPosA, % FillAreaGradientPosA
   } Else If (varu="infoFillAreaBlend")
   {
      FillAreaGradientPosB := 100
      GuiControl, SettingsGUIA:, FillAreaGradientPosB, % FillAreaGradientPosB
   } Else If (varu="infoAlphaMaskGradientAngle")
   {
      alphaMaskGradientAngle := 0
      GuiControl, SettingsGUIA:, alphaMaskGradientAngle, % alphaMaskGradientAngle
   } Else If (varu="infoAlphaMaskGradientScale")
   {
      alphaMaskGradientScale := (modus=5) ? 1 : 100
      GuiControl, SettingsGUIA:, alphaMaskGradientScale, % alphaMaskGradientScale
   } Else If (varu="infoAlphaMaskSigma")
   {
      alphaMaskGradientPosA := 0
      GuiControl, SettingsGUIA:, alphaMaskGradientPosA, % alphaMaskGradientPosA
   } Else If (varu="infoAlphaMaskBlend")
   {
      alphaMaskGradientPosB := 100
      GuiControl, SettingsGUIA:, alphaMaskGradientPosB, % alphaMaskGradientPosB
   }

   UItriggerBrushUpdate(1)
}

BtnPasteResetOptions() {
   If (liveDrawingBrushTool=1)
   {
      toggleAlphaPaintingMode()
      Return
   }

   PasteInPlaceBlurAmount := PasteInPlaceHue := PasteInPlaceSaturation := PasteInPlaceLight := FillAreaGradientAngle := 0
   PasteInPlaceGlassy := PasteInPlaceBlendMode := PasteInPlaceCropSel := PasteInPlaceOrientation := PasteInPlaceAdaptMode := alphaMaskingMode := 1
   PasteInPlaceAlignment := 3
   PasteInPlaceBlurAmount := PasteInPlaceApplyColorFX := PasteInPlaceGamma := 0
   PasteInPlaceOpacity := 255
   GuiControl, SettingsGUIA:, PasteInPlaceHue, % PasteInPlaceHue
   GuiControl, SettingsGUIA:, PasteInPlaceApplyColorFX, % PasteInPlaceApplyColorFX
   GuiControl, SettingsGUIA:, PasteInPlaceSaturation, % PasteInPlaceSaturation
   GuiControl, SettingsGUIA:, PasteInPlaceLight, % PasteInPlaceLight
   GuiControl, SettingsGUIA:, PasteInPlaceGamma, % PasteInPlaceGamma
   GuiControl, SettingsGUIA:, PasteInPlaceOpacity, % PasteInPlaceOpacity
   GuiControl, SettingsGUIA:, PasteInPlaceBlurAmount, % PasteInPlaceBlurAmount
   GuiControl, SettingsGUIA:, FillAreaGradientAngle, % FillAreaGradientAngle
   GuiControl, SettingsGUIA: Choose, PasteInPlaceBlendMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceGlassy, 1
   GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAlignment, 3
   GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAdaptMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceCropSel, 1
   ; WriteSettingsPasteInPlacePanel()
   updateUIpastePanel()
}

ReadSettingsFillAreaPanel(act:=0) {
    If (act=1)
    {
       RegAction(1, "FillAreaCurveTension",, 2, 1, 5)
       If InStr(FillAreaCustomShape, "|")
          RegAction(1, "FillAreaCustomShape")
    }

    RegAction(act, "FillAreaColor",, 3)
    RegAction(act, "FillAreaOpacity",, 2, 1, 255)
    RegAction(act, "FillArea2ndColor",, 3)
    RegAction(act, "FillArea2ndOpacity",, 2, 1, 255)
    RegAction(act, "FillAreaBlendMode",, 2, 1, 21)
    RegAction(act, "FillAreaClosedPath",, 1)
    RegAction(act, "FillAreaColorMode",, 2, 1, 6)
    RegAction(act, "FillAreaColorReversed",, 1)
    RegAction(act, "FillAreaGlassy",, 2, 1, 6)
    RegAction(act, "FillAreaGradientAngle",, 2, 0, 360)
    RegAction(act, "FillAreaGradientPosB",, 2, 0, 100)
    RegAction(act, "FillAreaGradientScale",, 2, 1, 300)
    RegAction(act, "FillAreaGradientPosA",, 2, 0, 100)
    RegAction(act, "FillAreaGradientWrapped",, 1)
    RegAction(act, "FillAreaInverted",, 1)
    RegAction(act, "FillAreaRemBGR",, 1)
    RegAction(act, "FillAreaDoContour",, 1)
    RegAction(act, "FillAreaApplyColorFX",, 1)
    RegAction(act, "DrawLineAreaColor",, 3)
    RegAction(act, "DrawLineAreaOpacity",, 2, 1, 255)
    RegAction(act, "DrawLineAreaCapsStyle",, 1)
    RegAction(act, "DrawLineAreaDoubles",, 1)
    RegAction(act, "DrawLineAreaContourAlign",, 2, 1, 3)
    RegAction(act, "DrawLineAreaDashStyle",, 2, 1, 4)
    RegAction(act, "DrawLineAreaContourThickness",, 2, 1, 450)
    RegAction(act, "PasteInPlaceGamma",, 2, -100, 100)
    RegAction(act, "PasteInPlaceHue",, 2, -180, 180)
    RegAction(act, "PasteInPlaceLight",, 2, -255, 255)
    RegAction(act, "PasteInPlaceSaturation",, 2, -100, 100)
    RegAction(act, "alphaMaskClrAintensity",, 2, 0, 255)
    RegAction(act, "alphaMaskClrBintensity",, 2, 0, 255)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
    IniAction(act, "userimgGammaCorrect", "General", 1)
}

ReadSettingsDrawShapeAreaPanel(act:=0) {
    If (act=0)
    {
       RegAction(0, "initialCustomShapeCoords",, 5)
       If !InStr(FillAreaCustomShape, "|")
          RegAction(0, "FillAreaCustomShape",, 5)

       If (drawingShapeNow!=1)
          RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
    } Else If (act=1)
    {
       RegAction(1, "FillAreaCurveTension",, 2, 1, 5)
       If InStr(FillAreaCustomShape, "|")
          RegAction(1, "FillAreaCustomShape")
    }

    RegAction(act, "DrawLineAreaColor",, 3)
    RegAction(act, "DrawLineAreaOpacity",, 2, 1, 255)
    RegAction(act, "DrawLineAreaCapsStyle",, 1)
    RegAction(act, "DrawLineAreaDoubles",, 1)
    RegAction(act, "DrawLineAreaContourAlign",, 2, 1, 3)
    RegAction(act, "DrawLineAreaDashStyle",, 2, 1, 4)
    RegAction(act, "DrawLineAreaContourThickness",, 2, 1, 450)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
    RegAction(act, "FillAreaClosedPath",, 1)
}

ReadSettingsVPgrid(act:=0) {
    RegAction(act, "vpGridSize",, 2, 10, 350)
    RegAction(act, "vpGridAlpha",, 2, 1, 255)
    RegAction(act, "vpGridColor",, 3)
    RegAction(act, "vpGridFixedSize",, 1)
    RegAction(act, "vpGridStepu",, 2, 2, 20)
    RegAction(act, "vpGridThickness",, 2, 1, 15)
    If (editingSelectionNow!=1 && drawingShapeNow!=1)
       INIaction(act, "LimitSelectBoundsImg", "General", 1)
}

ReadSettingsAlphaMaskPanel(act:=0) {
    If (customShapePoints.Count()<3 && act=0)
    {
       RegAction(0, "FillAreaCustomShape",, 5)
       RegAction(0, "initialCustomShapeCoords",, 5)
       customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
       If (drawingShapeNow!=1)
          RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
    }

    RegAction(act, "alphaMaskReplaceMode",, 1)
    RegAction(act, "alphaMaskColorReversed",, 1)
    RegAction(act, "alphaMaskGradientWrapped",, 1)
    RegAction(act, "alphaMaskGradientScale",, 2, 1, 300)
    RegAction(act, "alphaMaskGradientPosA",, 2, 0, 100)
    RegAction(act, "alphaMaskGradientPosB",, 2, 0, 100)
    RegAction(act, "alphaMaskClrAintensity",, 2, 0, 255)
    RegAction(act, "alphaMaskClrBintensity",, 2, 0, 255)
    RegAction(act, "alphaMaskPreviewOpacity",, 2, 10, 255)
    RegAction(act, "brushAclrAlpha",, 3)
    RegAction(act, "brushBclrAlpha",, 3)
    If (alphaMaskingMode=1 && alphaMaskGradientScale<3)
       alphaMaskGradientScale := 100
}

ReadSettingsBrushPanel(act:=0) {
   If (ShowAdvToolbar=1)
      delayedWriteTlbrColors(act)

   RegAction(act, "brushToolSize",, 2, 2, 950)
   RegAction(act, "brushToolDoubleSize",, 1)
   RegAction(act, "BrushToolSoftness",, 2, 1, 100)
   RegAction(act, "brushToolStepping",, 2, 0, 251)
   RegAction(act, "BrushToolType",, 2, 1, 8)
   RegAction(act, "BrushToolAngle",, 2, 0, 359)
   RegAction(act, "BrushToolAspectRatio",, 2, -100, 100)
   RegAction(act, "BrushToolDryingRate",, 2, 0, 20)
   RegAction(act, "BrushToolOverDraw",, 1)
   If (AnyWindowOpen=64)
   {
      RegAction(act, "BrushToolTexture",, 2, 1, 9)
      RegAction(act, "BrushToolAutoAngle",, 1)
      RegAction(act, "BrushToolBlurStrength",, 2, 0, 99)
      RegAction(act, "BrushToolDynamicCloner",, 1)
      RegAction(act, "BrushToolEraserRestore",, 1)
      RegAction(act, "BrushToolOutsideSelection",, 2, 1, 3)
      RegAction(act, "BrushToolWetness",, 2, 0, 22)
      RegAction(act, "BrushToolApplyColorFX",, 1)
      RegAction(act, "PasteInPlaceGamma",, 2, -100, 100)
      RegAction(act, "PasteInPlaceHue",, 2, -180, 180)
      RegAction(act, "PasteInPlaceLight",, 2, -255, 255)
      RegAction(act, "PasteInPlaceSaturation",, 2, -100, 100)
   }
}

LEDguiGuiClose:
LEDguiGuiEscape:
   StopColorPicker()
Return

createLEDgui(LEDu, thisOpacity:=255, pX:=2, pY:=2, clr:=0) {
   Gui, LEDgui: -DPIScale +AlwaysOnTop -Caption +Owner +ToolWindow +E0x20 +0x800000 +hwndhColorPrev
   Gui, LEDgui: Color, %clr%
   Gui, LEDgui: Add, Text, x1 y1 w%LEDu% h%LEDu% gStopColorPicker, -
   Gui, LEDgui: Show, NoActivate x%pX% y%pY% w%LEDu% h%LEDu%, QPVcolorPicker
   WinSet, AlwaysOnTop, On, ahk_id %hColorPrev%
   If (thisOpacity<253)
      WinSet, Transparent, % thisOpacity, ahk_id %hColorPrev%
   Sleep, 1
   Return hColorPrev
}

showLEDgui(clr, pX, pY) {
   Gui, LEDgui: Color, %clr%
   Gui, LEDgui: Show, NoActivate x%pX% y%pY%
}

StopColorPicker() {
   Critical, on
   colorPickerModeNow := 0
   Gui, LEDgui: Destroy
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("colorPickerModeNow", colorPickerModeNow)
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
}

StartPickingColor(a:=0, b:=0, c:=0, d:=0) {
   ; fnOutputDebug(a "=" b "=" c)
   g := A_Gui, ctrl := A_GuiControl
   If (a="isGiven")
   {
      g := b
      ctrl := c
   }

   ctrl := StrReplace(ctrl, "picku")
   If (isWinXP=1 || A_OSVersion="WIN_7")
   {
      msgBoxWrapper(appTitle ": ERROR", "The color picker functionality is not yet implemented for Windows XP or Windows 7... Please use the color selector associated.", 0, 0, "error")
      Return
   }

   initialColor := %ctrl%
   endCaptureCloneBrush()
   If (editingSelectionNow=1)
      toggleLiveEditObject("hide")
   Sleep, 2
   pBitmap := Gdip_BitmapFromHWND(PVhwnd, 1)
   Gdip_GetImageDimensions(pBitmap, imgW, imgH)
   If StrLen(pBitmap)>2
   {
      createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 1, A_ThisFunc]
   } Else
   {
      showTOOLtip("Failed to capture main window bitmap`n`nPlease try again to pick a color")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   diffH := diffW := 0
   LEDu := imgHUDbaseUnit
   hColorPrev := createLEDgui(LEDu)
   Sleep, 1
   colorPickerModeNow := 1
   interfaceThread.ahkassign("colorPickerModeNow", colorPickerModeNow)
   If (panelWinCollapsed!=1 && AnyWindowOpen)
      toggleImgEditPanelWindow("forced")

   errorOccured := 0
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   setwhileLoopExec(1)
   While, (colorPickerModeNow=1)
   {
      If (errorOccured>700)
         Break

      If (A_Index>1950)
      {
         errorOccured := 750
         Break
      }

      If (determineLClickstate() && hwnd=hColorPrev || GetKeyState("Enter") || GetKeyState("Numpad5"))
         Break

      If (GetKeyState("Escape") || GetKeyState("Space") || GetKeyState("Tab") || GetKeyState("MButton") || GetKeyState("RButton"))
      {
         errorOccured := 750
         Break
      }

      Sleep, -1
      GetMouseCoord2wind(PVhwnd, mX, mY)
      ; hz := Gdi_GetPixelColor(glHDC, mX, mY, 2)
      mX := clampInRange(mX + diffW, 0, imgW)
      mY := clampInRange(mY + diffH, 0, imgH)
      ; ToolTip, % imgW " | " imgH "`n" winW " | " winH "`n" diffW " | " diffH "`n" mX " | " mY , , , 2
      h := Gdip_GetPixelColor(pBitmap, mX, mY, 4)
      ; ToolTip, % "hz=" hz[1] "=" hz[2] "=" hz[3] , , , 2
      If (h="")
      {
         Sleep, 5
         errorOccured++
         Continue
      }

      ; createColorPrevWin(h)
      GetPhysicalCursorPos(pX, pY)
      pX -= LEDu//2, pY -= LEDu//2
      showLEDgui(h, pX, pY)
      Sleep, 5
      hwnd := WinActive("A")
      ; ToolTip, % h "`n" z "`n" w , , , 2
   }

   setwhileLoopExec(0)
   StopColorPicker()
   If (panelWinCollapsed=1 && AnyWindowOpen && d!="leave-it")
      toggleImgEditPanelWindow("forced")

   trGdip_DisposeImage(pBitmap, 1)
   If (errorOccured>690)
      Return

   If (a="isGiven")
      BrushToolWetness := clampInRange(BrushToolWetness, 0, 19)

   If (isNowAlphaPainting()=1 && InStr(ctrl, "brushtool"))
      h := convertColorToGrayscale(h)

   ; https://autohotkey.com/board/topic/43945-fast-pixelgetcolor-workaround-for-aero-windows-7-and-vista/
   o := %ctrl%
   SoundBeep, 900, 100
   ; ToolTip, % r "`n" ctrl "`n" o "`n" h "`n" g "`n" z , , , 2
   %ctrl% := h

   If ctrl
   {
      If (ctrl="WindowBGRcolor")
         INIaction(1, ctrl, "General")
      Else
         RegAction(1, ctrl)
   }

   If (AnyWindowOpen && g && ctrl)
      GuiControl, %g%:+Background%h%, %ctrl%

   If (AnyWindowOpen=63)
   {
      updateUIgridPanel()
   } Else If (imgEditPanelOpened=1 && g)
   {
      SetTimer, fromCurrentPanelToColorsSwatch, -200
      livePreviewsImageEditing()
   }
   Return [h, initialColor]    ; new color, old color 
}

fromCurrentPanelToColorsSwatch() {
   If !ShowAdvToolbar
      Return

   If isNowAlphaPainting()
   {
      updateTlbrColorsSwatch()
   } Else If (AnyWindowOpen=66)
   {
      fromPanelColorsToColorsSwatch("FloodFillColor", FloodFillColor)
   } Else If (AnyWindowOpen=68)
   {
      fromPanelColorsToColorsSwatch("FillBehindColor", FillBehindColor)
   } Else If (AnyWindowOpen=23)
   {
      fromPanelColorsToColorsSwatch("FillAreaColor", FillAreaColor)
      fromPanelColorsToColorsSwatch("FillArea2ndColor", FillArea2ndColor)
   } Else If (AnyWindowOpen=32)
   {
      fromPanelColorsToColorsSwatch("TextInAreaBgrColor", TextInAreaBgrColor)
      fromPanelColorsToColorsSwatch("TextInAreaFontColor", TextInAreaFontColor)
   } Else If (AnyWindowOpen=30 || AnyWindowOpen=65)
   {
      fromPanelColorsToColorsSwatch("DrawLineAreaColor", DrawLineAreaColor)
   } Else 
      updateTlbrColorsSwatch()
}

fromPanelColorsToColorsSwatch(ctrl, newColor) {
   If (ShowAdvToolbar=1)
   {
      If (ctrl="TextInAreaBgrColor")
      {
         BrushToolBcolor := newColor
         BrushToolBopacity := TextInAreaBgrOpacity
      } Else If (ctrl="TextInAreaFontColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := TextInAreaFontOpacity
      } Else If (ctrl="DrawLineAreaColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := DrawLineAreaOpacity
      } Else If (ctrl="FillBehindColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := FillBehindClrOpacity
      } Else If (ctrl="FloodFillColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := FloodFillClrOpacity
      } Else If (ctrl="FillAreaColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := DrawLineAreaOpacity
      } Else If (ctrl="FillArea2ndColor")
      {
         BrushToolBcolor := newColor
         BrushToolBopacity := FillArea2ndOpacity
      }

      updateTlbrColorsSwatch()
      delayedWriteTlbrColors(1)
   }
}

delayedWriteTlbrColors(act) {
   RegAction(act, "BrushToolAcolor",, 3)
   RegAction(act, "BrushToolBcolor",, 3)
   RegAction(act, "BrushToolAopacity",, 2, 1, 255)
   RegAction(act, "BrushToolBopacity",, 2, 1, 255)
   RegAction(act, "BrushToolUseSecondaryColor",, 1)
}

convertColorToGrayscale(hexClr) {
   Gdip_FromARGB("0xFF" hexClr, A, R, G, B)
   R := R * 0.308
   G := G * 0.650
   B := B * 0.095
   Z := Round(snapToValues(R + G + B, 0, 255, 2, 1))
   thisColor := Gdip_ToARGB("0xFF", Z, Z, Z)
   clr := SubStr(Format("{1:#x}", thisColor), 5)
   ; ToolTip, % thisColor "`n" R "=" G "=" B "=" Z , , , 2
   Return clr
}

snapToValues(given, valA, valB, errMargin, clamping) {
   If isInRange(given, valA - errMargin, valA + errMargin)
      Return valA
   Else If isInRange(given, valB - errMargin, valB + errMargin)
      Return valB
   Else If (clamping=1)
      Return clampInRange(given, valA, valB)
   Else
      Return given
}

cancelDrawingShape() {
   stopDrawingShape("cancel")
}

stopDrawingShape(dummy:="") {
    Critical, on
    If (drawingShapeNow!=1)
       Return

    zeitSillyPrevent := A_TickCount
    If (dummy="cancel")
    {
       VPselRotation := vpFreeformShapeOffset[4]
       innerSelectionCavityX := vpFreeformShapeOffset[5]
       innerSelectionCavityY := vpFreeformShapeOffset[6]
       EllipseSelectMode := vpFreeformShapeOffset[7]
       If vpFreeformShapeOffset[8]
          FillAreaCurveTension := vpFreeformShapeOffset[8]
       closedLineCustomShape := vpFreeformShapeOffset[9]
       bezierSplineCustomShape := vpFreeformShapeOffset[10]
       customShapePoints := oldCustomShapePoints.Clone()
    } Else
    {
       prevVectorShapeSymmetryMode[1, 2] := CustomShapeSymmetry
       customShapePoints := convertCustomShape2relativeCoords(customShapePoints)
    }

    ; ToolTip, % "l=" postVectorWinOpen , , , 2
    If (drawingVectorLiveMode=1 || drawingVectorLiveMode=3)
       Gdip_DeletePen(PenuDrawLive)
    Else
       Gdip_DeleteBrush(PenuDrawLive)

    PenuDrawLive := ""
    drawingShapeNow := 0
    DestroyTempBtnGui("now")
    If (customShapePoints.Count()<3)
    {
       If (dummy!="cancel")
       {
          EllipseSelectMode := 0
          If !AnyWindowOpen
             editingSelectionNow := 0
       }

       dummyRefreshImgSelectionWindow()
       showDelayedTooltip("Drawing abandoned")
       ; SetTimer, RemoveTooltip, % -msgDisplayTime
    } Else
    {
       saveVectorShapeInRegistry()
       editingSelectionNow := 1
       EllipseSelectMode := 2
       dummyTimerDelayiedImageDisplay(100)
       noOpen := (dummy="cancel" && InStr(postVectorWinOpen, "c")) ? 1 : 0
       If (!AnyWindowOpen && drawingVectorLiveMode!=3 && noOpen!=1)
          BTNopenPrevPanel(postVectorWinOpen, "yes", "n")
    }

    postVectorWinOpen := 0
    Global zeitSillyPrevent := A_TickCount
    Global lastOtherWinClose := A_TickCount
    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    interfaceThread.ahkassign("drawingShapeNow", 0)
    createGUItoolbar()
    updateUIctrl()
    MouseMoveResponder()
    If (showMainMenuBar=1)
       TriggerMenuBarUpdate()
}

predefinedVectorShapes(whichShape) {
; 1 = right triangle
; 2 = triangle
; 3 = rhombus
; 4 = box callout
; 5 = star-5
; 6 = star-4
; 7 = cross
   Static shape1c := "0.0,0.0|0.0,1.0|1.0,1.0"
        , shape1t := 1
        , shape2c := "0.5,0.0|0.0,1.0|1.0,1.0"
        , shape2t := 1
        , shape3c := "0.5,0.0|1.0,0.5|0.5,1.0|0.0,0.5"
        , shape3t := 1
        , shape4c := "0.0,0.0|1.0,0.0|1.0,0.7|0.7,0.7|0.87,1.0|0.5,0.7|0.0,0.7"
        , shape4t := 1
        , shape5c := "0.5,0.0|0.3,0.4|0.0,0.45|0.25,0.65|0.1,1.0|0.5,0.77|0.9,1.0|0.75,0.65|1.0,0.45|0.7,0.4"
        , shape5t := 1
        , shape6c := "0.5,0.0|0.35,0.35|0.0,0.5|0.35,0.65|0.5,1.0|0.65,0.65|1.0,0.5|0.65,0.35"
        , shape6t := 1
        , shape7c := "0.35,0|0.35,0.20|0,0.20|0,0.35|0.35,0.35|0.35,1|0.65,1|0.65,0.35|1,0.35|1,0.20|0.65,0.20|0.65,0"
        , shape7t := 1

     bezierSplineCustomShape := 0
     If (whichShape=9)
     {
        RegAction(0, "FillAreaCustomShape",, 5)
        RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
     } Else
     {
        thisTension := "shape" whichShape "t"
        thisShape := "shape" whichShape "c"
        FillAreaCurveTension := %thisTension%
        FillAreaCustomShape := %thisShape%
        RegAction(1, "FillAreaCurveTension")
     }

     customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
     decideCustomShapeStyle()
     dummyTimerDelayiedImageDisplay(50)
}

flipWHcustomShape(modus) {
    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       If (modus="h")
          customShapePoints[thisIndex] := [1 - c[1], c[2]]
       Else
          customShapePoints[thisIndex] := [c[1], 1 - c[2]]
    }

    modus := (modus="h") ? "HORIZONTALLY" : "VERTICALLY"
    showDelayedTooltip("Custom shape flipped: " modus)
    decideCustomShapeStyle()
    dummyTimerDelayiedImageDisplay(50)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

addFluidPointsCustomShape() {
   If (drawingShapeNow!=1 || mustSnapLiveDrawPoints=1)
      Return

   lastInvoked := 1
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   newArrayu := new hashtable()
   dotsSize := (FillAreaCurveTension>1) ? SelDotsSize : SelDotsSize//2 + 1
   If (FillAreaCurveTension=3)
      dotsSize := SelDotsSize*2 + 1
   Else If (FillAreaCurveTension=4)
      dotsSize := SelDotsSize*3 + 2

   prevMX := prevMY := 0
   setwhileLoopExec(1)
   While, (determineLClickstate()=1)
   {
      If (mustSnapLiveDrawPoints=1)
         Break

      If (A_TickCount - lastInvoked<50)
         Continue

      GetMouseCoord2wind(PVhwnd, mX, mY)
      ogmX := (FlipImgH=1) ? mainWidth - mX : mX
      ogmY := (FlipImgV=1) ? mainHeight - mY : mY
      If (newArrayu[ogmX ogmY]=1) || isDotInRect(ogmX, ogmY, prevMX - dotsSize, prevMX + dotsSize, prevMY - dotsSize, prevMY + dotsSize)
         Continue

      mustSnapLiveDrawPoints := 0
      customShapePoints.Push([ogmX, ogmY])
      thisIndex := customShapePoints.MaxIndex()
      initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
      lastInvoked := A_TickCount
      newArrayu[ogmX ogmY] := 1
      newArrayu[ogmX + 1 ogmY + 1] := 1
      newArrayu[ogmX - 1 ogmY - 1] := 1
      newArrayu[ogmX + 1 ogmY - 1] := 1
      newArrayu[ogmX - 1 ogmY + 1] := 1
      lastZeitFileSelect := A_TickCount
      prevMX := ogmX
      prevMY := ogmY
      dummyRefreshImgSelectionWindow()
   }

   setwhileLoopExec(0)
   newArrayu := []
   SetTimer, addFluidPointsCustomShape, Off
}

adjustAnchorPointsCustomShape(thisIndex:=0) {
    If (drawingShapeNow!=1 || mustSnapLiveDrawPoints=1)
       Return
 
    lastInvoked := A_TickCount
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
 
    prevState := thisState := prevMX := prevMY := 0
    setwhileLoopExec(1)
    mustSnapLiveDrawPoints := 0
    canDoSymmetry := isNowSymmetricVectorShape()
    totalCount := customShapePoints.Count()
    GetMouseCoord2wind(PVhwnd, mX, mY)
    doFlippuX := (mX<vpSymmetryPointX && CustomShapeSymmetry=1) ? 1 : 0
    doFlippuY := (mY<vpSymmetryPointY && CustomShapeSymmetry=2) ? 1 : 0
    cB := customShapePoints[thisIndex]
    t := (autoReflectVectorAnchors=1 && totalCount>4) ? thisIndex : thisIndex - 1
    thisNode := (doFlippuX || doFlippuY) ? 5 : thisIndex - 3
    thisK := (doFlippuX || doFlippuY) ? 2 : 3

    If (autoReflectVectorAnchors=1 && totalCount=7 && canDoSymmetry)
       reflectGivenAnchorInPath(3, totalCount, 3, canDoSymmetry, 1)
    Else If (autoReflectVectorAnchors=1 && totalCount>3)
       reflectGivenAnchorInPath(thisK, totalCount, thisNode, canDoSymmetry)

    oppoIndex := totalCount - t + 1
    While, (determineLClickstate()=1)
    {
         If (A_TickCount - lastInvoked<100)
            Continue

         zeitSillyPrevent := A_TickCount
         GetMouseCoord2wind(PVhwnd, mX, mY)
         gmX := (FlipImgH=1) ? mainWidth - mX : mX
         gmY := (FlipImgV=1) ? mainHeight - mY : mY
         If (canDoSymmetry && totalCount>2)
            hasSymmetry := calculateSymmetricVectorPoint(gmX, gmY, nX, nY)

         If (doFlippuX || doFlippuY)
         {
            customShapePoints[t] := [nX, nY]
            If (autoReflectVectorAnchors=1)
               customShapePoints[2] := [gmX, gmY]
            Else
               customShapePoints[3] := [gmX, gmY]

            If (thisIndex>4 && autoReflectVectorAnchors=0)
            {
               customShapePoints[2] := [gmX + SelDotsSize, gmY + SelDotsSize]
               calculateSymmetricVectorPoint(gmX + SelDotsSize, gmY + SelDotsSize, nX, nY)
               customShapePoints[totalCount - 2 + 1] := [nX, nY]
            }
            ; ToolTip, % t "=lol" , , , 2
         } Else 
         {
            ; ToolTip, % t "=looooooooool" , , , 2
            customShapePoints[t] := [gmX, gmY]
            If (canDoSymmetry && totalCount>2)
               customShapePoints[oppoIndex] := [nX, nY]

            If (thisIndex>4 && autoReflectVectorAnchors=0)
            {
               customShapePoints[thisIndex] := [gmX + SelDotsSize, gmY + SelDotsSize]
               If (canDoSymmetry && totalCount>2)
               {
                  calculateSymmetricVectorPoint(gmX + SelDotsSize, gmY + SelDotsSize, nX, nY)
                  customShapePoints[totalCount - thisindex + 1] := [nX, nY]
               }
            }
         }

         thisState := "a" gmX gmY mX mY
         If (thisState!=prevState)
         {
            prevState := thisState
            showTOOLtip("P'[" t "] = (" gmX ", " gmY ")")
            dummyRefreshImgSelectionWindow()
         }
         Sleep, 2
    }

    RemoveTooltip()
    setwhileLoopExec(0)
    SetTimer, adjustAnchorPointsCustomShape, Off
}

resumeCustomShapeSelection(thisZL) {
   If !thisZL
      thisZL := zoomLevel

   fX := vpFreeformShapeOffset[1] ? vpFreeformShapeOffset[1] : 0
   fY := vpFreeformShapeOffset[2] ? vpFreeformShapeOffset[2] : 0
   fS := vpFreeformShapeOffset[3] ? vpFreeformShapeOffset[3] : 1
   zImgSelX1 := imgSelX1 * thisZL
   zImgSelY1 := imgSelY1 * thisZL
   zImgSelX2 := imgSelX2 * thisZL
   zImgSelY2 := imgSelY2 * thisZL
   vPimgSelPx := prevDestPosX + min(zImgSelX1, zImgSelX2)
   vPimgSelPy := prevDestPosY + min(zImgSelY1, zImgSelY2)
   vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
   offX := offY := 0
   If (VPselRotation>0)
   {
      If (rotateSelBoundsKeepRatio=0 && FillAreaCurveTension>1)
      {
         doDeduping := (bezierSplineCustomShape=1) ? 0 : 1
         PointsListu := convertCustomShape2givenArea(customShapePoints, vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH, 1, doDeduping)
         pPathA := Gdip_CreatePath()
         pPathB := Gdip_CreatePath()
         Gdip_AddPathPolygon(pPathA, PointsListu)
         If (bezierSplineCustomShape=1)
            Gdip_AddPathBeziers(pPathB, PointsListu)
         Else
            Gdip_AddPathClosedCurve(pPathB, PointsListu, tensionCurveCustomShape)
         withinBounds := !rotateSelBoundsKeepRatio
         withinBkeepRatio := rotateSelBoundsKeepRatio
         scaleUniform := 0
         trGdip_RotatePathAtCenter(pPathA, VPselRotation, 1, withinBounds, withinBkeepRatio, 0)
         trGdip_RotatePathAtCenter(pPathB, VPselRotation, 1, withinBounds, withinBkeepRatio, 0)
         centerPath2bounds(pPathB, vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH, pPathA, 1)
         PointsList := Gdip_GetPathPoints(pPathA)

         pPathC := Gdip_CreatePath()
         If (bezierSplineCustomShape=1)
            Gdip_AddPathBeziers(pPathC, PointsList)
         Else
            Gdip_AddPathClosedCurve(pPathC, PointsList, tensionCurveCustomShape)
         RectA := getAccuratePathBounds(pPathA, 1)
         RectC := getAccuratePathBounds(pPathC, 1)
         RectB := getAccuratePathBounds(pPathB, 1)
         offW := vPimgSelW / RectC.w
         offH := vPimgSelH / RectC.h
         Gdip_ScalePath(pPathA, offW, offH)

         PointsList := Gdip_GetPathPoints(pPathA)
         pPathD := Gdip_CreatePath()
         If (bezierSplineCustomShape=1)
            Gdip_AddPathBeziers(pPathD, PointsList)
         Else
            Gdip_AddPathClosedCurve(pPathD, PointsList, tensionCurveCustomShape)
         RectD := getAccuratePathBounds(pPathD, 1)
         offX := vPimgSelPx - RectD.x
         offY := vPimgSelPy - RectD.y

         ; infoz := Round(vPimgSelPx) "=" Round(vPimgSelPy) " | " Round(vPimgSelW) "=" Round(vPimgSelH)
         ; infoz .= "`n" RectA.X + Round(offX) "=" RectA.Y + Round(offY) " | " RectA.W "=" RectA.H
         ; infoz .= "`n" RectB.X "=" RectB.Y " | " RectB.W "=" RectB.H
         ; infoz .= "`n" RectC.X "=" RectC.Y " | " RectC.W "=" RectC.H
         ; infoz .= "`n" RectD.X "=" RectD.Y " | " RectD.W "=" RectD.H
         ; infoz .= "`n" Round(offX) "=" Round(offY)
         ; ToolTip, % infoz , , , 2
         Gdip_DeletePath(pPathA)
         Gdip_DeletePath(pPathB)
         Gdip_DeletePath(pPathC)
         Gdip_DeletePath(pPathD)
      } Else If (FillAreaCurveTension>1)
      {
         doDeduping := (bezierSplineCustomShape=1) ? 0 : 1
         PointsListu := convertCustomShape2givenArea(customShapePoints, vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH, 1, doDeduping)
         pPathA := Gdip_CreatePath()
         pPathB := Gdip_CreatePath()
         Gdip_AddPathPolygon(pPathA, PointsListu)
         If (bezierSplineCustomShape=1)
            Gdip_AddPathBeziers(pPathB, PointsListu)
         Else
            Gdip_AddPathClosedCurve(pPathB, PointsListu, tensionCurveCustomShape)

         withinBounds := !rotateSelBoundsKeepRatio
         withinBkeepRatio := rotateSelBoundsKeepRatio
         scaleUniform := rotateSelBoundsKeepRatio
         trGdip_RotatePathAtCenter(pPathA, VPselRotation, 1, withinBounds, withinBkeepRatio, 0)
         trGdip_RotatePathAtCenter(pPathB, VPselRotation, 1, withinBounds, withinBkeepRatio, 0)
         centerPath2bounds(pPathB, vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH, pPathA, 1)
         PointsList := Gdip_GetPathPoints(pPathA)

         pPathC := Gdip_CreatePath()
         If (bezierSplineCustomShape=1)
            Gdip_AddPathBeziers(pPathC, PointsList)
         Else
            Gdip_AddPathClosedCurve(pPathC, PointsList, tensionCurveCustomShape)
         RectC := getAccuratePathBounds(pPathC)
         RectB := getAccuratePathBounds(pPathB)
         offX := RectB.x - RectC.x
         offY := RectB.y - RectC.y
         ; ToolTip, % vPimgSelPx "=" vPimgSelPy "`n" RectC.X "=" RectC.Y  "`n" RectB.X "=" RectB.Y , , , 2
         Gdip_DeletePath(pPathA)
         Gdip_DeletePath(pPathB)
         Gdip_DeletePath(pPathC)
      } Else
      {
         pPath := createImgSelPath(vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH, 2, VPselRotation, rotateSelBoundsKeepRatio, 1, 1, 0, 0, 0)
         PointsList := Gdip_GetPathPoints(pPath)
         Gdip_DeletePath(pPath)
      }
   } Else PointsList := convertCustomShape2givenArea(customShapePoints, vPimgSelPx*fS + fX, vPimgSelPy*fS + fY, VPimgSelW*fS, VPimgSelH*fS, 0)

   customShapePoints := convertShapePointsStrToArray(PointsList, offX, offY)
   If (prevVectorShapeSymmetryMode[1, 2]=1)
      configVectorShapeSymmetryPoint("x", 1, prevVectorShapeSymmetryMode[1, 1])
   Else If (prevVectorShapeSymmetryMode[1, 2]=2)
      configVectorShapeSymmetryPoint("y", 1, prevVectorShapeSymmetryMode[1, 1])

   ; ToolTip, % customShapePoints.Count() "===" PointsList , , , 2
}

startDrawingShape(modus, dummy:=0, forcePanel:=0) {
     If !CustomShapeSymmetry
        CustomShapeLockedSymmetry := 0

     vpSymmetryPointX := vpSymmetryPointY := 0
     If (thumbsDisplaying=1 || StrLen(gdiBitmap)<3)
        Return

     If (getCaptionStyle(PVhwnd)=1)
     {
        ToggleTitleBaruNow()
        Return
     }

     If (mustCaptureCloneBrush=1)
     {
        StopCaptureClickStuff(dummy)
        Return
     }

     If isNowAlphaPainting()
     {
        toggleAlphaPaintingMode()
        Return
     }

     If (dummy="resume" && customShapePoints.Count()<3)
        dummy := ""

     If VisibleQuickMenuSearchWin
        closeQuickSearch()

     postVectorWinOpen := 0
     If (AnyWindowOpen && imgEditPanelOpened=1)
     {
        isWinOpen := AnyWindowOpen
        BtnCloseWindow()
        postVectorWinOpen := isWinOpen
        If (dummy="resume")
           modus := (isWinOpen=65) ? "line" : "shape"
     }

     Sleep, 5
     If (editingSelectionNow=1)
        recordSelUndoLevelNow()

     If InStr(forcePanel, "draw")
        postVectorWinOpen := (modus="line") ? "65c" : "23c"

     drawingShapeNow := 1
     If (customShapePoints.Count()>2)
        oldCustomShapePoints := customShapePoints.Clone()

     interfaceThread.ahkassign("drawingShapeNow", 1)
     CustomShapeSymmetry := CustomShapeLockedSymmetry := 0
     If (dummy="resume")
     {
        resumeCustomShapeSelection(zoomLevel)
        performBezierAutoFixNow()
     } Else 
     {
        vpFreeformShapeOffset := []
        vpFreeformShapeOffset := [0, 0, 0, VPselRotation, innerSelectionCavityX, innerSelectionCavityY, EllipseSelectMode, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape]
        prevVectorShapeSymmetryMode := []
        customShapePoints := []
        ToggleEditImgSelection("show-edit")
     }

     RegAction(0, "FillAreaColor",, 3)
     RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
     RegAction(0, "closedLineCustomShape",, 1)
     RegAction(0, "autoReflectVectorAnchors",, 1)
     RegAction(0, "showNewVectorPointPreview",, 1)
     decideCustomShapeStyle()
     If (bezierSplineCustomShape=1)
        closedLineCustomShape := 0

     thisColorA := (modus="line") ? "0xAA" FillAreaColor : "0x88" FillAreaColor
     If (modus="line")
     {
        PenuDrawLive := (isWinOpen=10) ? Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10) : Gdip_CreatePen(thisColorA, imgHUDbaseUnit//7)
        drawingVectorLiveMode := 1
     } Else If (modus="shape")
     {
        If (isWinOpen=55)
           PenuDrawLive := Gdip_CloneBrush(pBrushF)
        Else
           PenuDrawLive := (isWinOpen=25) ? Gdip_CloneBrush(useHatchedBrush()) : Gdip_BrushCreateSolid(thisColorA)
        drawingVectorLiveMode := 2
     } Else If (modus="selection")
     {
        PenuDrawLive := Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10)
        drawingVectorLiveMode := 3
        EllipseSelectMode := 2
        LimitSelectBoundsImg := VPselRotation := innerSelectionCavityX := innerSelectionCavityY := 0
        lockSelectionAspectRatio := 1
        ; closedLineCustomShape :=  1
     }

     customShapeHasSelectedPoints := 0
     initialDrawingStartCoords := []
     Loop, % customShapePoints.Count()
        initialDrawingStartCoords[A_Index] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]

     LabelCurve := defineVectorPathType()
     LabelType := (drawingVectorLiveMode=1) ? "path" : "filled shape"
     If (drawingVectorLiveMode=1)
     {
        LabelOpenLine := (closedLineCustomShape=1) ? "closed " : "open "
     } Else If (drawingVectorLiveMode=3)
     {
        LabelOpenLine := LabelCurve " selection area"
        LabelCurve := LabelType := ""
     }

     If (showMainMenuBar=1)
        TriggerMenuBarUpdate()

     showTOOLtip("Draw freeform " LabelOpenLine LabelCurve A_Space LabelType "`nPress Right Click for the menu options")
     If (dummy="resume")
     {
        If (customShapePoints.Count()>4 && bezierSplineCustomShape=1)
           closedLineCustomShape := testIsBezierPathClosed()
        Else If (bezierSplineCustomShape=1)
           closedLineCustomShape := 0

        recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())
     }

     CreateGuiButton("Die dummy", 1)
     updateUIctrl()
     createGUItoolbar()
     showQuickActionButtonsDrawingShape()
     If (showViewPortGrid=1)
        dummyTimerDelayiedImageDisplay(50)

     ; If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
     ;    WinSet, Transparent, 120, ahk_id %hQPVtoolbar%

     SetTimer, dummyRefreshImgSelectionWindow, -150
     SetTimer, RemoveTooltip, % -msgDisplayTime
}

reduceCustomShapelength() {
   ; foundPos := InStr(customShapePoints, "|", 0, -1)
   ; customShapePoints := SubStr(customShapePoints, 1, foundPos)
   If (preventUndoLevels!=1)
      recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())

   If (bezierSplineCustomShape=1)
      r := testIsBezierPathClosed()

   customShapePoints.Pop()
   initialDrawingStartCoords.Pop()
   If (bezierSplineCustomShape=1)
   {
      If (r=1)
      {
         closedLineCustomShape := 0
         RegAction(1, "closedLineCustomShape")
      }

      customShapePoints.Pop()
      initialDrawingStartCoords.Pop()
      If (customShapePoints.Count()>=4)
      {
         customShapePoints.Pop()
         initialDrawingStartCoords.Pop()
      }
   }

   If CustomShapeSymmetry
   {
      customShapePoints.RemoveAt(1)
      initialDrawingStartCoords.RemoveAt(1)
      prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] - 1
      If (bezierSplineCustomShape=1)
      {
         customShapePoints.RemoveAt(1)
         initialDrawingStartCoords.RemoveAt(1)
         prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] - 1
         If (customShapePoints.Count()>=4)
         {
            customShapePoints.RemoveAt(1)
            initialDrawingStartCoords.RemoveAt(1)
            prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] - 1
         }
      }
   } Else CustomShapeLockedSymmetry := 0

   If (customShapePoints.Count()<3)
      CustomShapeLockedSymmetry := vpSymmetryPointX := vpSymmetryPointY := 0

   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()

   SetTimer, dummyRefreshImgSelectionWindow, -150
}

toggleOpenClosedAnyCustomShape() {
   closedLineCustomShape := !closedLineCustomShape
   RegAction(1, "closedLineCustomShape")
   SetTimer, dummyRefreshImgSelectionWindow, -100
}

toggleOpenClosedLineCustomShape() {
   closedLineCustomShape := !closedLineCustomShape
   RegAction(1, "closedLineCustomShape")
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()

   handleOpenCloseBezier()
   SetTimer, dummyRefreshImgSelectionWindow, -150
}

handleOpenCloseBezier() {
   If (bezierSplineCustomShape!=1)
      Return

   If isNowSymmetricVectorShape()
      toggleBrushSymmetryModes()

   r := testIsBezierPathClosed()
   If (closedLineCustomShape=1 && r=0)
   {
      thisIndex := customShapePoints.Count() - 1
      ; ToolTip, % thisIndex "=l" , , , 2
      getVPcoordsVectorPoint(1, mX, mY)
      pushEndNewVectorPoint(mX, mY, 1)
      reflectGivenAnchorInPath(2, customShapePoints.Count(), 2, 0, 0)
      reflectGivenAnchorInPath(3, customShapePoints.Count(), thisIndex, 0, 0)
   } Else If (closedLineCustomShape=0 && r=1)
   {
      reduceCustomShapelength()
      If (testIsBezierPathClosed()=1)
         reduceCustomShapelength()
   }
   If (preventUndoLevels!=1)
      recordVectorUndoLevels(customShapePoints.Clone(), initialDrawingStartCoords.Clone())
}

testIsBezierPathClosed() {
    ; this assumes drawingShapeNow = 1 ;
    totalz := customShapePoints.Count()
    If (totalz<4)
       Return -1

    getVPcoordsVectorPoint(1, mX, mY)
    getVPcoordsVectorPoint(totalz, nX, nY)
    ; r := isDotInRect(mX, nY, 3, 3, nX, nY, 1) ; too loose
    r := (mX=nX && mY=nY) ? 1 : 0
    Return r
}

testIsBezierAltPathClosed(ByRef PointsList) {
    ; this assumes drawingShapeNow = 0 ;
    totalz := PointsList.Count()//2
    xA := PointsList[1],                  yA := PointsList[2]
    xB := PointsList[totalz*2 - 1],       yB := PointsList[totalz*2]
    ; ToolTip, % xA "==" yA "`n" xB "==" yB "`n" totalz, , , 2
    r := (xA=xB && yA=yB) ? 1 : 0
    Return r
}

toggleAutoReflectAnchors() {
   autoReflectVectorAnchors := !autoReflectVectorAnchors
   RegAction(1, "autoReflectVectorAnchors")
   friendly := (autoReflectVectorAnchors=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Automatically reflect anchors: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

togglePreviewVectorNewPoint() {
   If (bezierSplineCustomShape=1)
   {
      showTOOLtip("WARNING: This option does not apply for Bézier paths")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   showNewVectorPointPreview := !showNewVectorPointPreview
   RegAction(1, "showNewVectorPointPreview")
   friendly := (showNewVectorPointPreview=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Live preview for new point: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, -150
}

defineVectorPathType() {
   labelu := (cardinalCurveCustomShape=1) ? "Curved" : "Polygonal"
   If (bezierSplineCustomShape=1 || FillAreaCurveTension=5)
      labelu := "Bézier"
   Return labelu
}

showQuickActionButtonsDrawingShape() {
  If ((showMainMenuBar=1 || ShowAdvToolbar=1) && tempBtnVisible="null")
     Return

  LabelCurve := defineVectorPathType()
  LabelOpenLine := (closedLineCustomShape=1) ? "Open path" : "Closed path"
  btnOpenLine := "||" LabelOpenLine ",,toggleOpenClosedLineCustomShape"
  If (FillAreaCurveTension=1)
     ll := "Polygonal"
  Else If (FillAreaCurveTension=5)
     ll := "Bézier"
  Else
     ll := "Tension: " tensionCurveCustomShape

  LabelTension := "||" ll ",,togglePathCurveTension"
  CreateGuiButton("Undo,,ImgVectorUndoAct||Cancel,,cancelDrawingShape||Done,,stopDrawingShape" btnOpenLine LabelTension, "Forced", msgDisplayTime*10000)
  SetTimer, DestroyTempBtnGui, Off
}

decideCustomShapeStyle() {
   bezierSplineCustomShape := 0
   If (FillAreaCurveTension=5)
      bezierSplineCustomShape := 1
   Else If (FillAreaCurveTension=4)
      tensionCurveCustomShape := 0.95
   Else If (FillAreaCurveTension=3)
      tensionCurveCustomShape := 0.5
   Else If (FillAreaCurveTension=2)
      tensionCurveCustomShape := 0.2
   Else
      tensionCurveCustomShape := 0.1

   cardinalCurveCustomShape := (FillAreaCurveTension>1) ? 1 : 0
}

togglePathCurveTension() {
   FillAreaCurveTension := clampInRange(FillAreaCurveTension + 1, 1, 5, 1)
   decideCustomShapeStyle()
   If (FillAreaCurveTension=1)
     ll := "Polygonal"
   Else If (FillAreaCurveTension=5)
     ll := "Bézier"
   Else
     ll := "Tension: " tensionCurveCustomShape

   showTOOLtip("Path: " ll)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   RegAction(1, "FillAreaCurveTension")
   If (drawingShapeNow=1)
   {
      performBezierAutoFixNow()
      showQuickActionButtonsDrawingShape()
   }

   SetTimer, dummyRefreshImgSelectionWindow, -150
}

BtnTabsInfoUpdate(dummy:=0,b:=0) {
   If (panelWinCollapsed=1 && dummy!="ignore-panel")
   {
      ; CurrentPanelTab := TabsPerWindow[AnyWindowOpen]
      ; GuiControl, SettingsGUIA: Choose, CurrentPanelTab, % CurrentPanelTab
      toggleImgEditPanelWindow()
      Return
   }

   GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
   labelu := TabCtrl_GetItemText(hCurrTab, CurrentPanelTab)
   If (InStr(labelu, "alpha") && isNowAlphaPainting()=1)
   {
      CurrentPanelTab++
      GuiControl, SettingsGUIA: Choose, CurrentPanelTab, % CurrentPanelTab
   }

   TabsPerWindow[AnyWindowOpen] := CurrentPanelTab
   mouseTurnOFFtooltip()
   UItriggerBrushUpdate("noPreview")
}

UIcycleFillShapes() {
   FillAreaShape := clampInRange(FillAreaShape + 1, 1, 7, 1)
   GuiControl, SettingsGUIA: Choose, FillAreaShape, % FillAreaShape
   If (AnyWindowOpen=65)
      updateUIdrawShapesPanel()
   Else If (AnyWindowOpen=23)
      updateUIfillPanel()
}

BtnResetBlendMode() {
   If (AnyWindowOpen=23)
   {
      FillAreaBlendMode := 1
      GuiControl, SettingsGUIA: Choose, FillAreaBlendMode, % FillAreaBlendMode
      updateUIfillPanel()
   } Else
   {
      BlurAreaBlendMode := 1
      GuiControl, SettingsGUIA: Choose, BlurAreaBlendMode, % BlurAreaBlendMode
      If (AnyWindowOpen=69)
         updateUIzoomBlurPanel()
      Else
         updateUIblurPanel()
   }
}

BtnResetTextBlendMode() {
   TextInAreaBlendMode := 1
   GuiControl, SettingsGUIA: Choose, TextInAreaBlendMode, % TextInAreaBlendMode
   updateUIInsertTextPanel()
}

BtnResetGlassFX() {
   FillAreaGlassy := 1
   GuiControl, SettingsGUIA: Choose, FillAreaGlassy, % FillAreaGlassy
   updateUIfillPanel()
}

WriteSettingsEditorResizePanel() {
   ReadSettingsEditorResizePanel(1)
}

ReadSettingsEditorResizePanel(actu:=0) {
    RegAction(actu, "ResizeKeepAratio",, 1)
    RegAction(actu, "ResizeInPercentage",, 1)
    RegAction(actu, "ResizeQualityHigh",, 1)
    RegAction(actu, "ResizeEnforceCanvas",, 1)
    RegAction(actu, "ResizeFillCanvasMode",, 2, 1, 4)
    RegAction(actu, "adjustCanvasCentered",, 1)
    RegAction(actu, "FillAreaColor",, 3)
    RegAction(actu, "FillAreaOpacity",, 2, 1, 255)
}

PanelEditorImgResize() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight
         , userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter

    If (thumbsDisplaying=1 || AnyWindowOpen)
       Return

    r1 := Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (!oImgH || !oImgH)
    {
       showTOOLtip("ERROR: No image seems to be loaded or it is malformed")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    ReadSettingsEditorResizePanel()
    thisBtnHeight := createSettingsGUI(73, A_ThisFunc)
    btnWid := 90
    txtWid := 265
    editWid := 55
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 37
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    Global InfoResized
    friendly := (isImgEditingNow() && editingSelectionNow=1) ? "Selection area" : ""
    Gui, Add, Text, x15 y15 Section, Original image size: %oImgW% x %oImgH% pixels.
    Gui, Add, Text, xs y+10, Set new dimensions (W x H):
    Gui, Add, DropDownList, xs+15 y+8 wp gupdateUIresizeImgEditPanel AltSubmit vPredefinedDocsSizes, Viewport size|Screen size|Current image size|640x480|800x600|1024x768|HD 480p|HD 720p|HD 1080p|HD 2160p [4K]|A4 @ 300 dpi|A4 @ 150 dpi|Custom dimensions||%friendly%
    Gui, Add, Edit, xp y+5 w%editWid% r1 limit5 -multi number -wrap gupdateUIresizeImgEditPanel vuserEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 wp r1 limit5 -multi number -wrap gupdateUIresizeImgEditPanel vuserEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, Use `% percentages
    Gui, Add, Checkbox, xs+15 y+5 hp gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp Checked%adjustCanvasCentered% vadjustCanvasCentered, Centered image

    Gui, Add, Text, xs y+15 vInfoResized, Resulted dimensions for the resized image `n and canvas
    Gui, Add, Checkbox, xs y+10 hp Checked%ResizeEnforceCanvas% vResizeEnforceCanvas gupdateUIresizeImgEditPanel, Set the given dimensions as canvas size
    Gui, Add, DropDownList, xs+8 y+10 wp-90 AltSubmit Choose%ResizeFillCanvasMode% vResizeFillCanvasMode gupdateUIresizeImgEditPanel, Transparent background|Extend image borders|Solid color|Blurred image
    Gui, Add, Slider, Center xs+15 y+10 NoTicks wp-40 gupdateUIresizeImgEditPanel ToolTip AltSubmit vFillAreaOpacity Range1-255, % FillAreaOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P
    Gui, Add, ListView, x+5 hp w50 %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, Text, x+5 vinfoOpacity hp +0x200 +TabStop gBTNresetFillOpacity, n/a`%

    Gui, Add, Checkbox, xs y+15 hp Checked%ResizeQualityHigh% vResizeQualityHigh gupdateUIresizeImgEditPanel, &High quality image resampling
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% gBTNimgResizeEditor Default, &Proceed
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize image: " appTitle)
    updateUIresizeImgEditPanel()
}

BTNimgResizeEditor() {
    obju := updateUIresizeImgEditPanel("gimme")
    tUserNewWidth := obju[1, 3]
    tUserNewHeight := obju[1, 4]
    imgW := obju[1, 1]
    imgH := obju[1, 2]
    whichBitmap := useGdiBitmap()
    Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    If (oImgW=tUserNewWidth && oImgH=tUserNewHeight)
    {
       showTOOLtip("WARNING: The provided values are identical with the original size")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (imgW<3 || imgH<3 || tUserNewWidth<3 || tUserNewHeight<3)
    || (imgW>32500 || imgH>32500 || tUserNewWidth>32500 || tUserNewHeight>32500)
    {
       showTOOLtip("WARNING: Incorrect values provided to resize image")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    WriteSettingsEditorResizePanel()
    BtnCloseWindow()
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, tUserNewWidth, tUserNewHeight, coreDesiredPixFmt)
    If warnUserFatalBitmapError(newBitmap, A_ThisFunc)
    {
       showTOOLtip("Failed to resize image")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return
    }

    thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, thisImgQuality)
    If !G2
    {
       showTOOLtip("Failed to create the graphics object to resize image")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return
    }

    setImageLoading()
    Gdip_SetPixelOffsetMode(G2, 2)
    dpX := (adjustCanvasCentered=1) ? Round(tUserNewWidth/2 - imgW/2) : 0
    dpY := (adjustCanvasCentered=1) ? Round(tUserNewHeight/2 - imgH/2) : 0
    isOkay := (imgW<tUserNewWidth || imgH<tUserNewHeight) ? 1 : 0
    currIMGdetails.HasAlpha := 1
    ; TulTip(0, "-", ResizeKeepAratio, ResizeEnforceCanvas, ResizeFillCanvasMode, isOkay)
    If (ResizeKeepAratio=1 && ResizeEnforceCanvas=1 && ResizeFillCanvasMode=3 && isOkay=1)
    {
       Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
       thisColor := Gdip_ToARGB(FillAreaOpacity, R, G, B)
       Gdip_SetClipRect(G2, dpX, dpY, imgW, imgH, 4)
       trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       Gdip_ResetClip(G2)
    } Else If (ResizeKeepAratio=1 && ResizeEnforceCanvas=1 && ResizeFillCanvasMode=4 && isOkay=1)
    {
       Gdip_SetClipRect(G2, dpX, dpY, imgW, imgH, 4)
       zBitmap := Gdip_ResizeBitmap(whichBitmap, oImgW//2 + 1, oImgH//2, 0, 5)
       zA := Gdip_CreateEffect(1, 250, 0, 0)
       Gdip_BitmapApplyEffect(zBitmap, zA)
       r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0, tUserNewWidth, tUserNewHeight)
       Gdip_DisposeEffect(zA)
       Gdip_DisposeImage(zBitmap)
       Gdip_ResetClip(G2)
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, dpX, dpY, imgW, imgH)
     If (ResizeKeepAratio=1 && ResizeEnforceCanvas=1 && ResizeFillCanvasMode=2 && isOkay=1)
    {
       Gdip_SetClipRect(G2, dpX + 1, dpY + 1, imgW - 2, imgH - 2, 4)
       If (adjustCanvasCentered!=1)
       {
          dpX := (imgW<tUserNewWidth) ? ImgW - 4 : imgW
          dpY := (imgH<tUserNewHeight) ? ImgH - 4 : imgH
       }

       If (imgW<tUserNewWidth)
       {
          stripA := Gdip_CloneBitmapArea(newBitmap, dpX + 2, 0, 1, ImgH)
          stripB := Gdip_CloneBitmapArea(newBitmap, dpX + ImgW - 2, 0, 1, ImgH)
          lX := (adjustCanvasCentered=1) ? dpX + 1 : tUserNewWidth - dpX
          offX := (adjustCanvasCentered=1) ? 0 : dpX + 3
          Loop, % lX
          {
              r1 := Gdip_DrawImageFast(G2, stripA, offX + A_Index - 1, 0)
              If !offX
                 r1 := Gdip_DrawImageFast(G2, stripB, tUserNewWidth - A_Index, 0)
          }
       } Else
       {
          stripA := Gdip_CloneBitmapArea(newBitmap, 0, dpY + 2, ImgW, 1)
          stripB := Gdip_CloneBitmapArea(newBitmap, 0, dpY + ImgH - 2, ImgW, 1)
          lY := (adjustCanvasCentered=1) ? dpY + 1 : tUserNewHeight - dpY
          offY := (adjustCanvasCentered=1) ? 0 : dpY + 3
          Loop, % lY
          {
              r1 := Gdip_DrawImageFast(G2, stripA, 0, offY + A_Index - 1)
              If !offY
                 r1 := Gdip_DrawImageFast(G2, stripB, 0, tUserNewHeight - A_Index)
          }
       }
       ; TulTip(0, " | ", stripA, stripB, dpX, dpY, modus, oImgW, oImgH)
       Gdip_DisposeImage(stripA)
       Gdip_DisposeImage(stripB)
       Gdip_ResetClip(G2)
    }

    Gdip_DeleteGraphics(G2)
    recordUndoLevelNow("init", 0)
    UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    UserMemBMP := newBitmap

    updateUIctrl()
    MouseMoveResponder()
    recordUndoLevelNow(0, newBitmap)

    imgIndexEditing := currentFileIndex
    usrColorDepth := 1
    vpIMGrotation := 0
    dropFilesSelection(1)
    RemoveTooltip()
    RefreshImageFile()
    SetTimer, createGUItoolbar, -100
    SetTimer, TriggerMenuBarUpdate, -90
    SetTimer, ResetImgLoadStatus, -50

}

updateUIresizeImgEditPanel(dummy:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=73) || (A_TickCount - lastInvoked<50)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, ResizeFillCanvasMode
    GuiControlGet, ResizeEnforceCanvas
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, adjustCanvasCentered
    GuiControlGet, userEditWidth
    GuiControlGet, userEditHeight
    GuiControlGet, FillAreaOpacity
    GuiControlGet, PredefinedDocsSizes

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoOpacity, %thisOpacity%`%

    actu2 := (ResizeFillCanvasMode=3 && ResizeEnforceCanvas=1 && ResizeKeepAratio=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, PickuFillAreaColor
    GuiControl, % actu2, FillAreaColor
    GuiControl, % actu2, FillAreaOpacity
    GuiControl, % actu2, infoOpacity

    actu1 := (ResizeKeepAratio=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu1, ResizeEnforceCanvas

    actu1 := (ResizeEnforceCanvas=1 && ResizeKeepAratio=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu1, ResizeFillCanvasMode

    actu := (PredefinedDocsSizes=13) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    If (PredefinedDocsSizes!=13)
    {
       ResizeInPercentage := 0
       GetPresetDocSizes(PredefinedDocsSizes, userEditWidth, userEditHeight, nulli)
       GuiControl, SettingsGUIA:, userEditWidth, % userEditWidth
       GuiControl, SettingsGUIA:, userEditHeight, % userEditHeight
       GuiControl, SettingsGUIA:, ResizeInPercentage, 0
    }
    GuiControl, % actu, userEditWidth
    GuiControl, % actu, userEditHeight
    GuiControl, % actu, ResizeInPercentage

    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
    thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
    canvasWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
    canvasHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
    If (ResizeKeepAratio=1)
       calcIMGdimensions(oImgW, oImgH, thisWidth, thisHeight, thisWidth, thisHeight)

    If (ResizeEnforceCanvas=1 && ResizeKeepAratio=1)
    {
       friendly := "`nCanvas size: " groupDigits(Round(canvasWidth)) " x " groupDigits(Round(canvasHeight)) " px"
    } Else
    {
       canvasWidth := thisWidth
       canvasHeight := thisHeight
    }

    lastInvoked := A_TickCount    
    GuiControl, SettingsGUIA:, infoResized, % "Image will be resized to: " groupDigits(Round(thisWidth)) " x " groupDigits(Round(thisHeight)) " px" friendly
    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := FillAreaOpacity
    If (dummy="gimme")
    {
       obju := []
       obju[1] := [thisWidth, thisHeight, canvasWidth, canvasHeight]
       Return obju
    }
}

PanelManageVectorShapes(dummy:=0) {
    Static LViewDynas
    If (imgEditPanelOpened=1 && AnyWindowOpen && thumbsDisplaying=0)
       postVectorWinOpen := AnyWindowOpen

    zz := postVectorWinOpen
    thisBtnHeight := createSettingsGUI(72, A_ThisFunc)
    postVectorWinOpen := zz
    btnWid := 120
    txtWid := 360
    lstWid := 535
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 175
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15, Freeform vector shapes already saved
    Gui, Add, ListView, y+10 w%lstWid% +LV0x10000 r%uLVr% Grid +LV0x400 gBTNlvCustomShapes -multi AltSubmit vLViewDynas +hwndhLVmainu, #|Name|Date

    btnWid2 := (PrefsLargeFonts=1) ? 95 : 60
    Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w%btnWid2% Default gBTNloadCustomShape, &Load
    If !postVectorWinOpen
    {
       If (EllipseSelectMode=2)
          Gui, Add, Button, x+5 hp wp gPanelSaveVectorShape, &Save
       Gui, Add, Button, x+5 hp wp+10 gBTNrenameCustomShape, &Rename
       Gui, Add, Button, x+5 hp wp gBTNdeleteCustomShape, &Delete
       Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    } Else  Gui, Add, Button, x+5 hp wp gBTNopenPrevPanel, &Back

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Manage vector shapes: " appTitle)
    Sleep, 25
    PopulateCustomVectorShapesList()
}

BTNlvCustomShapes(a, b, c) {
   If (b="DoubleClick")
      BTNloadCustomShape()
}

BTNdeleteCustomShape() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(givenName, RowNumber, 2)
   LV_GetText(datu, RowNumber, 3)
   If (datu="-")
      Return

   If (StrLen(givenName)<2 || !FileExist(mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"))
      Return

   msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected to DELETE the vector shape named: " givenName ". Please confirm with Yes you want to remove it.", 4, 0, "exclamation")
   If (msgResult="Yes")
   {
      FileRecycle, % mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"
      BtnCloseWindow()
      showTOOLtip("Vector shape file moved to recycle bin:`n " givenName ".vqpv")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, PanelManageVectorShapes, -250
   }
}

BTNrenameCustomShape() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(givenName, RowNumber, 2)
   LV_GetText(datu, RowNumber, 3)
   If (datu="-")
      Return

   If (StrLen(givenName)<2 || !FileExist(mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"))
   {
      showTOOLtip("ERROR: The file no longer seems to exist: " givenName ".vqpv`n" mainCompiledPath "\resources\vector-shapes\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   oldName := givenName
   Static forbiddenChars := "<`~@>:""/\|?*.,;"
   widthu := (PrefsLargeFonts=1) ? 950 : 460
   msgResult := msgBoxWrapper("Rename vector shape: " appTitle, "Please type the new name for: " givenName ".", "&Rename|&Cancel", 1, "modify-file", 0, 0, 0, "limit350", prevNameSavedVectorShape, 0, widthu)
   If InStr(msgResult.btn, "rename")
   {
      BtnCloseWindow()
      givenName := msgResult.edit
      Loop, Parse, forbiddenChars
          givenName := StrReplace(givenName, A_LoopField)

      givenName := filterFileName(givenName)
      If StrLen(givenName)>1
      {
         If FileExist(mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv")
         {
            showTOOLtip("ERROR: Another vector shape exists with the provided name: " givenName "`nOperation abandoned.")
            SoundBeep 300, 100
         } Else
         {
            FileMove, % mainCompiledPath "\resources\vector-shapes\" oldName ".vqpv", % mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"
         }
      } Else
      {
         showTOOLtip("WARNING: Incorrect name provided for the rename")
         SoundBeep 300, 100
      }
      SetTimer, PanelManageVectorShapes, -250
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

saveVectorShapeInRegistry() {
    FillAreaCustomShape := convertShapePointsArrayToStr(customShapePoints)
    RegAction(1, "FillAreaCustomShape")
    RegAction(1, "FillAreaCurveTension")
    RegAction(1, "closedLineCustomShape")
}

BTNloadCustomShape() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetNext(0)
   If !RowNumber
      Return

   LV_GetText(givenName, RowNumber, 2)
   LV_GetText(datu, RowNumber, 3)
   LV_GetText(whichShape, RowNumber, 1)
   mustOpenWin := postVectorWinOpen
   If (datu="-")
   {
      BtnCloseWindow()
      If (editingSelectionNow!=1)
         ToggleEditImgSelection()

      If (whichShape="d8")
      {
         ; torus
         EllipseSelectMode := 1
         VPselRotation := 0
         innerSelectionCavityX := innerSelectionCavityY := 0.2
         prevNameSavedVectorShape := ""
         saveVectorShapeInRegistry()
         dummyTimerDelayiedImageDisplay(100)
         BTNopenPrevPanel(mustOpenWin, "yes")
         Return
      }

      EllipseSelectMode := 2
      bezierSplineCustomShape := 0
      closedLineCustomShape := 1
      vpFreeformShapeOffset := []
      prevVectorShapeSymmetryMode := []
      customShapePoints := []
      VPselRotation := innerSelectionCavityX := innerSelectionCavityY := 0
      initialDrawingStartCoords := []
      prevNameSavedVectorShape := ""
      predefinedVectorShapes(SubStr(whichShape, 2))
      Loop, % customShapePoints.Count()
           initialDrawingStartCoords[A_Index] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]

      saveVectorShapeInRegistry()
      dummyTimerDelayiedImageDisplay(100)
      BTNopenPrevPanel(mustOpenWin, "yes")
      Return
   }

   OutDir := PathCompact(mainCompiledPath "\resources\vector-shapes", "a", 1, OSDfontSize)
   If (StrLen(givenName)<2 || !FileExist(mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"))
   {
      showTOOLtip("ERROR: The file no longer seems to exist: " givenName ".vqpv`n" OutDir)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   FileRead, contentu, % mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"
   If StrLen(contentu)<5
   {
      showTOOLtip("Failed to read file contents: " givenName ".vqpv`n" OutDir)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      BTNopenPrevPanel(mustOpenWin, "yes")
      Return
   }

   obju := StrSplit(contentu, "`n", "`r `t")
   newArrayu := convertShapePointsStrToArray(obju[1])
   If (newArrayu.Count()<3)
   {
      showTOOLtip("ERROR: Incorrect file format. Found no points defining the vector shape.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      BTNopenPrevPanel(mustOpenWin, "yes")
      Return
   }

   customShapeHasSelectedPoints := 0
   If (editingSelectionNow!=1)
      ToggleEditImgSelection()

   initialDrawingStartCoords := []
   Loop, % newArrayu.Count()
        initialDrawingStartCoords[A_Index] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]

   EllipseSelectMode := 2
   vpFreeformShapeOffset := []
   prevVectorShapeSymmetryMode := []
   customShapePoints := []
   customShapePoints := newArrayu.Clone()
   VPselRotation := clampInRange(obju[2], 0, 360)
   FillAreaCurveTension := clampInRange(obju[3], 1, 5)
   innerSelectionCavityX := clampInRange(obju[4], 0, 0.49)
   innerSelectionCavityY := clampInRange(obju[5], 0, 0.49)
   closedLineCustomShape := obju[6]
   prevVectorShapeSymmetryMode[1] := [obju[7], obju[8]]
   prevNameSavedVectorShape := givenName
   decideCustomShapeStyle()
   saveVectorShapeInRegistry()
   dummyTimerDelayiedImageDisplay(100)
   BTNopenPrevPanel(mustOpenWin, "yes")
}

PopulateCustomVectorShapesList() {
    Static defaultShapes := {1:"right triangle", 2:"triangle", 3:"rhombus", 4:"box callout", 5:"star-5", 6:"star-4", 7:"christian cross", 8:"torus", 9:"Last temporarily saved"}

    thisIndex := 0
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    Loop, % mainCompiledPath "\resources\vector-shapes\*.vqpv"
    {
        thisIndex++
        Try FormatTime, datu, % A_LoopFileTimeModified, dd/MM/yyyy, HH:mm
        LV_Add(A_Index, A_Index, StrReplace(A_LoopFileName, ".vqpv"), datu)
    }

    thisIndex := 0
    For Key, Value in defaultShapes
    {
       thisIndex++
       StringUpper, value, value, T
       LV_Add(thisIndex, "D" thisIndex, value, "-")
    }

    Loop, 3
        LV_ModifyCol(A_Index, "AutoHdr Left")
}

PanelSaveVectorShape() {
   Static forbiddenChars := "<`~@>:""/\|?*.,;"
   If (EllipseSelectMode!=2)
      Return

   If (AnyWindowOpen=72)
   {
      Gui, SettingsGUIA: Default
      Gui, SettingsGUIA: ListView, LViewDynas
      RowNumber := LV_GetNext(0, "F")
      LV_GetText(prevNameSavedVectorShape, RowNumber, 2)
   }

   widthu := (PrefsLargeFonts=1) ? 950 : 460
   msgResult := msgBoxWrapper("Save vector shape: " appTitle, "Please type a name for the vector shape to be saved.", "&Save|&Cancel", 1, "save", 0, 0, 0, "limit350", prevNameSavedVectorShape, 0, widthu)
   If InStr(msgResult.btn, "save")
   {
      givenName := msgResult.edit
      Loop, Parse, forbiddenChars
          givenName := StrReplace(givenName, A_LoopField)

      givenName := filterFileName(givenName)
      If StrLen(givenName)>1
      {
         r := saveCurrentVectorShape(givenName)
         If (AnyWindowOpen=72 && !r)
         {
            BtnCloseWindow()
            SetTimer, PanelManageVectorShapes, -250
         }
      } Else
      {
         showTOOLtip("WARNING: Incorrect name provided for the vector shape")
         SoundBeep 300, 100
         SetTimer, PanelSaveVectorShape, -250
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

saveCurrentVectorShape(givenName) {
   If (EllipseSelectMode!=2)
      Return

   If !FolderExist(mainCompiledPath "\resources\vector-shapes")
   {
      FileCreateDir, %mainCompiledPath%\resources\vector-shapes
      If ErrorLevel
         errorOccured := 1

      Sleep, 1
   }

   thisFile := mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"
   If FileExist(thisFile)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "A vector shape was already defined with the provided name: " givenName ". Do you want to overwrite it? This action is irreversible.", "&Overwrite|&Cancel", 2, "exclamation")
      If (msgResult!="overwrite")
         Return
   }

   contentu := convertShapePointsArrayToStr(customShapePoints) "`n"
   contentu .= VPselRotation "`n" FillAreaCurveTension "`n" innerSelectionCavityX "`n" innerSelectionCavityY "`n" closedLineCustomShape "`n" Round(prevVectorShapeSymmetryMode[1, 1]) "`n" Round(prevVectorShapeSymmetryMode[1, 2]) "`n"
   FileDelete, % thisFile
   FileAppend, % contentu, % thisFile , UTF-8
   If ErrorLevel
      errorOccured := 1

   If (errorOccured=1)
   {
      showTOOLtip("Failed to save vector shape into:`n" mainCompiledPath "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else prevNameSavedVectorShape := givenName

   Return errorOccured
}

PanelFillSelectedArea(dummy:=0, which:=0) {
    openingPanelNow := 1
    If !(thisBtnHeight := createSettingsGUI(23, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsFillAreaPanel()
    ReadSettingsBrushPanel()
    ReadSettingsAlphaMaskPanel()
    If (EllipseSelectMode=1)
       FillAreaShape := 3
    Else If (EllipseSelectMode=0)
       FillAreaShape := 1
    Else If (EllipseSelectMode=2)
       FillAreaShape := 7

    If (dummy="tlbr" && isInRange(which, 1, 7))
       FillAreaShape := which

    customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60, EllipseSelectMode := 0
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    minislideWid := slideWid//2
    If isWinXP
    {
       FillAreaBlendMode := 1
       FillAreaGlassy := 1
    }

    FillAreaClosedPath := 1
    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    this2ndOpacity := Round((FillArea2ndOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoFillArea2ndOpacity, infoFillAreaContour, infoFillAreaGradientScale, infoFillAreaGradientAngle
         , infoFillAreaSigma, infoFillAreaBlend, PickuFillAreaColor, PickuFillArea2ndColor, txtLine4
         , uiPasteInPlaceAlphaDrawMode

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "None"
    Gui, Add, Tab3, gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Main|Fill|Border|Adjust colors|Alpha mask|Paint mask
    Gui, Tab, 1
    Gui, Add, DropDownList, x+10 y+10 Section w%slideWid% AltSubmit Choose%FillAreaShape% vFillAreaShape gupdateUIfillPanel, Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape
    Gui, Add, DropDownList, x+5 w%slideWid% AltSubmit Choose%FillAreaCurveTension% vFillAreaCurveTension gupdateUIfillPanel, Polygonal|Smooth corners|Curve|Round curve|Bézier
    Gui, Add, Checkbox, xs y+7 hp Checked%FillAreaRemBGR% vFillAreaRemBGR gupdateUIfillPanel, &Erase background behind the new object
    Gui, Add, Checkbox, xs y+7 hp Checked%FillAreaInverted% vFillAreaInverted gupdateUIfillPanel, &Invert selection area
    Gui, Add, Checkbox, xs y+7 hp gupdateUIfillPanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas if outside
    Gui, Add, Checkbox, xs y+7 hp Checked%userimgGammaCorrect% vuserimgGammaCorrect gupdateUIfillPanel, &Apply gamma corrections
    Gui, Add, Text, xs y+10 w%slideWid% +TabStop gBtnResetGlassFX vtxtLine1, Glass effect
    Gui, Add, DropDownList, x+5 w%slideWid% AltSubmit Choose%FillAreaGlassy% vFillAreaGlassy gupdateUIfillPanel, Not activated|Weak|Mild|Moderate|Strong|Extreme
    Gui, Add, Text, xs y+7 wp +TabStop gBtnResetBlendMode vtxtLine2, Blending mode
    Gui, Add, DropDownList, x+5 wp gupdateUIfillPanel AltSubmit Choose%FillAreaBlendMode% vFillAreaBlendMode, %infoBlend%|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference

    Gui, Tab, 2
    Gui, Add, DropDownList, x+10 y+10 Section w%slideWid% AltSubmit Choose%FillAreaColorMode% vFillAreaColorMode gupdateUIfillPanel, Solid color|Linear gradient|Radial gradient|Box gradient|Random patterns|Texture
    Gui, Add, Checkbox, x+5 hp Checked%FillAreaGradientWrapped% vFillAreaGradientWrapped gupdateUIfillPanel, &Tiling pattern
    Gui, Add, Slider, Center xs y+10 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vFillAreaOpacity Range1-255, % FillAreaOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor +hwndhBtnPickClrA, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 +TabStop vinfoFillAreaOpacity gBTNresetFillOpacity +hwndhBtnRopacity, %thisOpacity%`%
    ToolTip2ctrl(hBtnRopacity, "Reset color A opacity")
    Gui, Add, Slider, Center xs y+1 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vFillArea2ndOpacity Range1-255, % FillArea2ndOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillArea2ndColor +hwndhBtnPickClrB, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%FillArea2ndColor% vFillArea2ndColor hwndhLVfill2ndColor,
    Gui, Add, Text, x+5 hp wp +0x200 +TabStop gBTNresetFill2ndOpacity vinfoFillArea2ndOpacity +hwndhBtnRopacity, Opacity: %this2ndOpacity%00`%
    ToolTip2ctrl(hBtnRopacity, "Reset color B opacity")
    ToolTip2ctrl(hBtnPickClrA, "Pick color A from the viewport")
    ToolTip2ctrl(hBtnPickClrB, "Pick color B from the viewport")

    Gui, Add, Text, xs y+15 w%slideWid% gBtnResetPanelsSpecificControl vinfoFillAreaGradientAngle +TabStop, Angle: %FillAreaGradientAngle%° 
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaGradientScale +TabStop, Scale: %FillAreaGradientScale%`%
    Gui, Add, Slider, Center xs y+1 wp NoTicks gupdateUIfillPanel AltSubmit vFillAreaGradientAngle Range0-360, % FillAreaGradientAngle
    Gui, Add, Slider, Center x+5 wp NoTicks gupdateUIfillPanel AltSubmit vFillAreaGradientScale Range1-300, % FillAreaGradientScale

    Gui, Add, Text, xs y+10 wp gBtnResetPanelsSpecificControl vinfoFillAreaSigma +TabStop, Sigma: %FillAreaGradientPosA%`%
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaBlend +TabStop, Blend: %FillAreaGradientPosB%`%
    Gui, Add, Slider, Center xs y+1 wp NoTicks gupdateUIfillPanel AltSubmit vFillAreaGradientPosA Range0-100, % FillAreaGradientPosA
    Gui, Add, Slider, Center x+5 wp NoTicks gupdateUIfillPanel AltSubmit vFillAreaGradientPosB Range0-100, % FillAreaGradientPosB
    Gui, Add, Checkbox, xs y+5 w%slideWid% Checked%FillAreaColorReversed% vFillAreaColorReversed gupdateUIfillPanel, &Reverse colors
    Gui, Add, Button, x+5 vbtnFldr5 gBtnSetTextureSource, &Reset gradient center

    Gui, Tab, 3
    Gui, Add, Checkbox, x+10 y+10 Section Checked%FillAreaDoContour% vFillAreaDoContour gupdateUIfillPanel, &Draw shape outline
    Gui, Add, Slider, Center xs y+15 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vDrawLineAreaOpacity Range1-255, % DrawLineAreaOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuDrawLineAreaColor +hwndhBtnPickClrA, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%DrawLineAreaColor% vDrawLineAreaColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 +TabStop gBtnResetDrawLineOpacity vinfoDrawLineAreaOpacity +hwndhBtnRopacity, %thisOpacity%`%
    ToolTip2ctrl(hBtnRopacity, "Reset border color opacity")
    ToolTip2ctrl(hBtnPickClrA, "Pick border color from the viewport")
    Gui, Add, Text, xs y+15 w%btnWid% vtxtLine3, Alignment
    Gui, Add, Text, x+5 wp vtxtLine4, Styling
    Gui, Add, DropDownList, xs y+7 wp AltSubmit Choose%DrawLineAreaContourAlign% vDrawLineAreaContourAlign gupdateUIfillPanel, Inside|Centered|Outside
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%DrawLineAreaDashStyle% vDrawLineAreaDashStyle gupdateUIfillPanel, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, Checkbox, x+2 hp gupdateUIfillPanel Checked%FillAreaClosedPath% vFillAreaClosedPath, &Closed path
    Gui, Add, Checkbox, xs y+6 w%btnWid% hp Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles gupdateUIfillPanel, &Double line
    Gui, Add, Checkbox, x+2 w%btnWid% hp gupdateUIfillPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, &Round caps
    Gui, Add, Text, xs y+15 w%txtWid% vinfoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
    Gui, Add, Slider, Center xs y+1 gupdateUIfillPanel AltSubmit w%txtWid% vDrawLineAreaContourThickness Range1-450, % DrawLineAreaContourThickness

    Gui, Tab, 4
    Gui, Add, Checkbox, x+10 y+10 Section Checked%FillAreaApplyColorFX% vFillAreaApplyColorFX gupdateUIfillPanel, &Apply color adjustments
    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetPanelsSpecificControl vinfoPasteHue +TabStop, Hue: %PasteInPlaceHue%°
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIfillPanel vPasteInPlaceHue Range-180-180, % PasteInPlaceHue
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteSat +TabStop, Saturation: %PasteInPlaceSaturation%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIfillPanel vPasteInPlaceSaturation Range-100-100, % PasteInPlaceSaturation
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteLight +TabStop, Brightness: %PasteInPlaceLight%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIfillPanel vPasteInPlaceLight Range-255-255, % PasteInPlaceLight
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoPasteGamma +TabStop, Contrast: %PasteInPlaceGamma%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIfillPanel vPasteInPlaceGamma Range-100-100, % PasteInPlaceGamma
    Gui, Add, Text, xs y+10 Section, These apply only for blending modes and textures.

    uiADDalphaMaskTabs(5, 6, "updateUIfillPanel")
    Gui, Tab
    thisW := (PrefsLargeFonts=1) ? 80 : 60
    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    Gui, Add, Button, x+5 w%thisW% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%doImgEditLivePreview% vdoImgEditLivePreview gupdateUIfillPanel, &Live preview
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Fill shapes in selected area: " appTitle, winPos)
    SetTimer, updateUIfillPanel, -50
    SetTimer, resetOpeningPanel, -300
}

PanelSoloAlphaMasker() {
    If (imgEditPanelOpened=1 && AnyWindowOpen && AnyWindowOpen!=70 && thumbsDisplaying=0)
       postVectorWinOpen := AnyWindowOpen

    zz := postVectorWinOpen
    If !(thisBtnHeight := createSettingsGUI(70, A_ThisFunc, 1, 1))
       Return

    postVectorWinOpen := zz
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsBrushPanel()
    ReadSettingsAlphaMaskPanel()
    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60, EllipseSelectMode := 0
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    minislideWid := slideWid//2
    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    this2ndOpacity := Round((FillArea2ndOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoFillArea2ndOpacity, infoFillAreaContour, infoFillAreaGradientScale, infoFillAreaGradientAngle
         , infoFillAreaSigma, infoFillAreaBlend, PickuFillAreaColor, PickuFillArea2ndColor, txtLine4
         , uiPasteInPlaceAlphaDrawMode

    Gui, Add, Tab3, gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Alpha mask|Painting mode
    Gui, Tab, 1
    ; Gui, Add, Text, x+10 y+10 Section w%slideWid%, Hello vorld

    uiADDalphaMaskTabs(1, 2, "updateUIalphaMaskerPanel")
    Gui, Tab
    thisW := (PrefsLargeFonts=1) ? 85 : 65
    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    defu := postVectorWinOpen ? "" : "Default"
    If postVectorWinOpen
       Gui, Add, Button, x+5 hp w%thisW% gBTNopenPrevPanel Default, &Back

    Gui, Add, Button, x+5 hp w%thisW% %defu% gBtnCloseWindow, &Close
    Gui, Add, Slider, Center x+2 hp NoTicks gupdateUIalphaMaskerPanel ToolTip AltSubmit valphaMaskPreviewOpacity Range1-255, % alphaMaskPreviewOpacity
    Gui, Add, Text, x+5  hp +0x200 +TabStop gBTNresetAlphaPrevOpacity vinfoOpacity, Opacity

    Gui, Add, Checkbox, xm+5 y+5  Checked%doImgEditLivePreview% vdoImgEditLivePreview gupdateUIalphaMaskerPanel, &Live preview
    ; Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Define alpha mask: " appTitle, winPos)
    SetTimer, ForceRemoveTooltip, -100
    SetTimer, updateUIalphaMaskerPanel, -50
}

BTNopenPrevPanel(givenZZ:=0, isGiven:=0, morrigan:=0) {
   If isNowAlphaPainting()
   {
      toggleAlphaPaintingMode()
      Return
   }

   zz := postVectorWinOpen
   If (isNumber(givenZZ) && givenZZ>0 && isGiven="yes")
      zz := givenZZ
   Else If (isGiven="yes")
      Return

   If (morrigan!="n")
      CloseWindow()

   If (zz=66)
      f := "PanelFloodFillTool"
   Else If (zz=10)
      f := "PanelColorsAdjusterWindow"
   Else If (zz=23)
      f := "PanelFillSelectedArea"
   Else If (zz=25)
      f := "PanelEraseSelectedArea"
   Else If (zz=55)
      f := "PanelDesatureSelectedArea"
   Else If (zz=64)
      f := "PanelBrushTool"
   Else If (zz=65)
      f := "PanelDrawShapesInArea"
   Else If (zz=66)
      f := "PanelFloodFillTool"
   Else If (zz=68)
      f := "PanelFillBehindBgrImage"
   Else If (zz=70)
      f := "PanelSoloAlphaMasker"
   Else If (zz=74)
      f := "PanelColorsAdjusterImage"

   If f 
      SetTimer, % f, -100
   Else If (morrigan="n")
      SetTimer, openPreviousPanel, -100
}

PanelDrawShapesInArea(dummy:=0, which:=0) {
    If !(thisBtnHeight := createSettingsGUI(65, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsDrawShapeAreaPanel()
    If (EllipseSelectMode=1)
       FillAreaShape := 3
    Else If (EllipseSelectMode=0)
       FillAreaShape := 1
    Else If (EllipseSelectMode=2)
       FillAreaShape := 7

    If (dummy="tlbr" && isInRange(which, 1, 7))
       FillAreaShape := which

    customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60, EllipseSelectMode := 0
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    minislideWid := slideWid//2
    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoFillArea2ndOpacity, infoFillAreaContour, infoFillAreaGradientScale, infoFillAreaGradientAngle
         , infoFillAreaSigma, PickuFillAreaColor, PickuFillArea2ndColor

    Gui, Add, DropDownList, x+5 y+15 Section w%slideWid% AltSubmit Choose%FillAreaShape% vFillAreaShape gupdateUIdrawShapesPanel, Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape
    Gui, Add, DropDownList, x+5 wp-25 AltSubmit Choose%FillAreaCurveTension% vFillAreaCurveTension gupdateUIdrawShapesPanel, Polygonal|Smooth corners|Curve|Round curve|Bézier
    Gui, Add, Slider, Center xs y+10 NoTicks w%slideWid% gupdateUIdrawShapesPanel AltSubmit vDrawLineAreaOpacity Range1-255, % DrawLineAreaOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuDrawLineAreaColor +hwndhBtnPickClrA, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%DrawLineAreaColor% vDrawLineAreaColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 +TabStop gBtnResetDrawLineOpacity vinfoDrawLineAreaOpacity +hwndhBtnRopacity, %thisOpacity%`%
    ToolTip2ctrl(hBtnRopacity, "Reset color opacity")
    ToolTip2ctrl(hBtnPickClrA, "Pick color from the viewport")

    Gui, Add, Text, xs y+15 w%btnWid%, Alignment
    Gui, Add, Text, x+5 wp, Styling
    Gui, Add, DropDownList, xs y+7 wp AltSubmit Choose%DrawLineAreaContourAlign% vDrawLineAreaContourAlign gupdateUIdrawShapesPanel, Inside|Centered|Outside
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%DrawLineAreaDashStyle% vDrawLineAreaDashStyle gupdateUIdrawShapesPanel, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, Checkbox, x+2 hp gupdateUIdrawShapesPanel Checked%FillAreaClosedPath% vFillAreaClosedPath, &Closed path
    Gui, Add, Checkbox, xs y+6 w%btnWid% hp +0x1000 Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles gupdateUIdrawShapesPanel, &Double line
    Gui, Add, Checkbox, x+5 w%btnWid% hp +0x1000 gupdateUIdrawShapesPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, &Round caps
    Gui, Add, Text, xs y+20 w%txtWid% vinfoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
    Gui, Add, Slider, Center xs y+1 NoTicks gupdateUIdrawShapesPanel AltSubmit w%txtWid% vDrawLineAreaContourThickness Range1-450, % DrawLineAreaContourThickness
    Gui, Add, Checkbox, xs y+5 gupdateUIdrawShapesPanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas to fit selection area

    btnWid := (PrefsLargeFonts=1) ? 105 : 65
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 wp hp gBtnOpenPanelLines, &Lines
    Gui, Add, Button, x+5 wp hp gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xs y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Draw shapes in selected area: " appTitle, winPos)
    SetTimer, updateUIdrawShapesPanel, -50
}

toggleViewPortGridu() {
   showViewPortGrid := !showViewPortGrid
   If (showViewPortGrid=1)
      ReadSettingsVPgrid()

   friendly := (showViewPortGrid=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Viewport grid: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If isImgEditingNow()
      dummyTimerDelayiedImageDisplay(100)
}

toggleGridFixedSize() {
   vpGridFixedSize := !vpGridFixedSize
   RegAction(1, "vpGridFixedSize",, 1)
   friendly := (vpGridFixedSize=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Fixed size viewport grid: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(50)
}

PanelConfigVPgrid() {
    If (thumbsDisplaying=1)
       Return

    If (imgEditPanelOpened=1 && AnyWindowOpen && thumbsDisplaying=0)
       postVectorWinOpen := AnyWindowOpen

    zz := postVectorWinOpen
    thisBtnHeight := createSettingsGUI(63, A_ThisFunc)
    postVectorWinOpen := zz
    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsVPgrid()
    slideWid2 := slideWid
    slideWid := slideWid*2
    thisOpacity := Round((vpGridAlpha / 255) * 100)
    Global infoOpacity, PickuvpGridColor, infoStepu, infoGridu, infoThick

    Gui, Add, Checkbox, x15 y15 w%slideWid2% Section gupdateUIgridPanel Checked%showViewPortGrid% vshowViewPortGrid, &Show viewport grid
    Gui, Add, Checkbox, x+0 gupdateUIgridPanel Checked%LimitSelectBoundsImg% vLimitSelectBoundsImg, &Limit to image bounds
    Gui, Add, Slider, Center xs y+10 gupdateUIgridPanel NoTicks w%slideWid2% ToolTip vvpGridAlpha Range1-255, % vpGridAlpha
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuvpGridColor, &P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%vpGridColor% vvpGridColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +TabStop +0x200 gBtnResetVPgridOpacity vinfoOpacity, %thisOpacity%`%
    Gui, Add, Text, xs y+15 w%slideWid2% vinfoGridu, Grid size: ----
    Gui, Add, Checkbox, x+0 gupdateUIgridPanel Checked%vpGridFixedSize% vvpGridFixedSize, &Fixed grid
    Gui, Add, Slider, Center xs y+1 w%slideWid% gupdateUIgridPanel NoTicks ToolTip vvpGridSize Range10-350, % vpGridSize
    Gui, Add, Text, xs y+10 w%slideWid2% vinfoThick, Thickness: %vpGridThickness%
    Gui, Add, Text, x+5 wp vinfoStepu, Stepping: %vpGridStepu%
    Gui, Add, Slider, Center xs y+1 wp gupdateUIgridPanel NoTicks ToolTip vvpGridThickness Range1-15, % vpGridThickness
    Gui, Add, Slider, Center x+5 wp gupdateUIgridPanel NoTicks ToolTip vvpGridStepu Range2-20, % vpGridStepu
    Gui, Add, Text, xs y+10 w%slideWid%, You can use Alt + [-] / [+] in the main window to change the dimensions of the grid.

    thisW := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, xs y+15 w%thisW% h%thisBtnHeight% Default gBtnCloseWindow, &Close
    If postVectorWinOpen
       Gui, Add, Button, x+5 hp wp gBTNopenPrevPanel, &Back

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Viewport grid: " appTitle, winPos)
    SetTimer, updateUIgridPanel, -50
}

changeGridSize(dir) {
   If (thumbsDisplaying=1)
      Return

   If (showViewPortGrid!=1)
   {
      If (dir=1)
         toggleViewPortGridu()
      Return
   }

   thisGridThickness := vpGridThickness + imgHUDbaseUnit//30
   If (dir=1)
      vpGridSize += 5
   Else
      vpGridSize -= 5

   If (vpGridSize<thisGridThickness + 6)
   {
      vpGridSize := clampInRange(vpGridSize, 10, 350)
      toggleViewPortGridu()
      Return
   }

   vpGridSize := clampInRange(vpGridSize, 10, 350)
   showTOOLtip("Viewport grid size: " vpGridSize, A_ThisFunc, 2, vpGridSize/350)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   RegAction(1, "vpGridSize")
   dummyResizeImageGDIwin()
   ; dummyTimerDelayiedImageDisplay(90)
}

updateUIgridPanel() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide

   thisOpacity := Round((vpGridAlpha / 255) * 100)
   GuiControl, SettingsGUIA:, infoOpacity, %thisOpacity%`%
   GuiControl, SettingsGUIA:, infoGridu, Grid size: %vpGridSize% 
   GuiControl, SettingsGUIA:, infoThick, Thickness: %vpGridThickness%
   GuiControl, SettingsGUIA:, infoStepu, Stepping: %vpGridStepu%

   actu := (showViewPortGrid=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, vpGridStepu
   GuiControl, % actu, PickuvpGridColor
   GuiControl, % actu, vpGridColor
   GuiControl, % actu, vpGridThickness
   GuiControl, % actu, vpGridSize
   GuiControl, % actu, vpGridAlpha
   GuiControl, % actu, vpGridFixedSize
   GuiControl, % actu, LimitSelectBoundsImg
   GuiControl, % actu, infoOpacity
   GuiControl, % actu, infoGridu
   GuiControl, % actu, infoThick
   GuiControl, % actu, infoStepu

   dummyTimerDelayiedImageDisplay(100)
   SetTimer, WriteSettingsVPgrid, -150
}

WriteSettingsVPgrid() {
   ReadSettingsVPgrid(1)
}

WriteSettingsBrushPanel() {
   ReadSettingsBrushPanel(1)
}

ToggleClosePanelApply() {
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   INIaction(1, "closeEditPanelOnApply", "General")
}

ReadSettingsDrawLinesArea(act:=0) {
    RegAction(act, "DrawLineAreaColor",, 3)
    RegAction(act, "DrawLineAreaOpacity",, 2, 1, 255)
    RegAction(act, "DrawLineAreaKeepBounds",, 1)
    RegAction(act, "DrawLineAreaCapsStyle",, 1)
    RegAction(act, "DrawLineAreaDoubles",, 1)
    RegAction(act, "DrawLineAreaContourAlign",, 2, 1, 3)
    RegAction(act, "DrawLineAreaDashStyle",, 2, 1, 4)
    RegAction(act, "DrawLineAreaContourThickness",, 2, 1, 450)
    RegAction(act, "DrawLineAreaBorderTop",, 1)
    RegAction(act, "DrawLineAreaBorderBottom",, 1)
    RegAction(act, "DrawLineAreaBorderLeft",, 1)
    RegAction(act, "DrawLineAreaBorderRight",, 1)
    RegAction(act, "DrawLineAreaBorderArcA",, 1)
    RegAction(act, "DrawLineAreaBorderArcB",, 1)
    RegAction(act, "DrawLineAreaBorderArcC",, 1)
    RegAction(act, "DrawLineAreaBorderArcD",, 1)
    RegAction(act, "DrawLineAreaBorderCenter",, 2, 1, 7)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
}

BtnResetDrawLineOpacity() {
   DrawLineAreaOpacity := 254
   GuiControl, SettingsGUIA:, DrawLineAreaOpacity,% DrawLineAreaOpacity
   If (AnyWindowOpen=23)
      updateUIfillPanel()
   Else If (AnyWindowOpen=30)
      updateUIDrawLinesPanel()
   Else
      updateUIdrawShapesPanel()
}

PanelDrawLines() {
    If !(thisBtnHeight := createSettingsGUI(30, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsDrawLinesArea()
    txtWid := 245
    EditWid := 60
    EllipseSelectMode := 0
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid := (PrefsLargeFonts=1) ? 166 : 105
    sml := (PrefsLargeFonts=1) ? 55 : 34
    BtnHeight := thisBtnHeight - 5
    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    Global infoDrawLineAreaOpacity, infoDrawLineAreaContour, PickuDrawLineAreaColor
    Gui, Add, Text, x15 y15 Section, Please configure what lines to draw and how.
    Gui, Add, Text, y+10 Section, Line style. Alignment.
    Gui, Add, DropDownList, xs y+7 w%btnWid% gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaDashStyle% vDrawLineAreaDashStyle, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, DropDownList, x+10 wp gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaContourAlign% vDrawLineAreaContourAlign, Inside|Centered|Outside

    Gui, Add, Checkbox, xs y+10 w%sml% h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcA% vDrawLineAreaBorderArcA,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderTop% vDrawLineAreaBorderTop,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcB% vDrawLineAreaBorderArcB,○
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, Rounded caps
    Gui, Add, Checkbox, xs y+1 w%sml% h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderLeft% vDrawLineAreaBorderLeft,▏
    Gui, Add, Text, x+1 wp hp Center,.
    ; Gui, Add, Checkbox, x+1 wp hp +0x1000 Checked%DrawLineAreaBorderCenter% vDrawLineAreaBorderCenter,▏
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderRight% vDrawLineAreaBorderRight,▏
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles, Double line
    Gui, Add, Checkbox, xs y+1 w%sml% h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcC% vDrawLineAreaBorderArcC,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderBottom% vDrawLineAreaBorderBottom,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcD% vDrawLineAreaBorderArcD,○
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaKeepBounds% vDrawLineAreaKeepBounds, &Within bounds

    Gui, Add, DropDownList, xs y+0 w%btnWid% gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaBorderCenter% vDrawLineAreaBorderCenter,No center line|Vertical|Horizontal|Slash|Backslash|Both diagonals|Both H/V lines
    sml := (PrefsLargeFonts=1) ? 30 : 20
    Gui, Add, Text, xs y+%sml% +0x200 hp, Color:
    Gui, Add, ListView, x+5 wp+15 hp %CCLVO% Background%DrawLineAreaColor% vDrawLineAreaColor,
    Gui, Add, Button, x+1 hp w25 gStartPickingColor vPickuDrawLineAreaColor +hwndhBtnPickClrA, P
    Gui, Add, Text, x+15 +0x200 hp +TabStop gBtnResetDrawLineOpacity vinfoDrawLineAreaOpacity +hwndhBtnRopacity, Opacity: 1011`%
    Gui, Add, Slider, Center xs y+1 NoTicks gupdateUIDrawLinesPanel AltSubmit w%txtWid% vDrawLineAreaOpacity Range3-255, % DrawLineAreaOpacity
    Gui, Add, Text, xs y+5 +0x200 wp hp vinfoDrawLineAreaContour, Contour thickness: %DrawLineAreaContourThickness% pixels
    Gui, Add, Slider, Center xs y+1 NoTicks gupdateUIDrawLinesPanel AltSubmit w%txtWid% vDrawLineAreaContourThickness Range1-450, % DrawLineAreaContourThickness
    Gui, Add, Checkbox, xs y+5 gupdateUIDrawLinesPanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas to fit selection area
    ToolTip2ctrl(hBtnRopacity, "Reset color opacity")
    ToolTip2ctrl(hBtnPickClrA, "Pick color from the viewport")

    btnWid := (PrefsLargeFonts=1) ? 105 : 65
    sml := (PrefsLargeFonts=1) ? 35 : 20
    Gui, Add, Button, xm+0 y+%sml% h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 wp hp gBtnOpenPanelShapes, &Shapes
    Gui, Add, Button, x+5 wp hp gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Draw lines or arcs in selected area: " appTitle, winPos)
    SetTimer, updateUIDrawLinesPanel, -50
}

BtnOpenPanelShapes() {
   BtnCloseWindow()
   Sleep, 2
   SetTimer, PanelDrawShapesInArea, -50
}

BtnOpenPanelLines() {
   BtnCloseWindow()
   Sleep, 2
   SetTimer, PanelDrawLines, -50
}

WriteSettingsDesaturateSelPanel() {
   ReadSettingsDesaturateSelPanel(1)
}

ReadSettingsDesaturateSelPanel(actu) {
   RegAction(actu, "DesatureAreaAmount",, 2, 1, 100)
   RegAction(actu, "DesatureAreaHue",, 2, -180, 180)
   RegAction(actu, "DesatureAreaAlternate",, 1)
   RegAction(actu, "DesaturateAreaDither",, 1)
   RegAction(actu, "DesaturateAreaChannel",, 2, 1, 4)
   RegAction(actu, "DesaturateAreaLevels",, 2, 1, 8)
   RegAction(actu, "EraseAreaInvert",, 1)
}

PanelDesatureSelectedArea(dummy:=0) {
    If !(thisBtnHeight := createSettingsGUI(55, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsDesaturateSelPanel(0)
    btnWid := 70
    txtWid := 340
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 20
       txtWid := txtWid + 110
       Gui, Font, s%LargeUIfontValue%
    }
    If isWinXP
       DesatureAreaAlternate := 0

    thisOpacity := DesatureAreaAmount
    Global infoAmount, infohueAdjust
    btnWid2 := btnWid + 20
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please experiment with the provided options to control how the image is desatured.
    Gui, Add, DropDownList, xs w%btnWid2% AltSubmit Choose%DesaturateAreaLevels% gupdateUIdesaturatePanel vDesaturateAreaLevels, Levels|4|8|16|32|64|128|256
    Gui, Add, DropDownList, x+10 w%btnWid2% AltSubmit Choose%DesaturateAreaChannel% gupdateUIdesaturatePanel vDesaturateAreaChannel, All channels|Red|Green|Blue
    Gui, Add, Checkbox, x+10 yp hp Checked%DesaturateAreaDither% vDesaturateAreaDither gupdateUIdesaturatePanel, &Dithering
    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetAmountDesature vinfoAmount +TabStop, intensity: %thisOpacity%`%
    Gui, Add, Slider, Center xp y+1 wp NoTicks AltSubmit gupdateUIdesaturatePanel vDesatureAreaAmount Range1-100, % DesatureAreaAmount
    Gui, Add, Text, xs y+10 wp gBtnResetDesatureHue vinfohueAdjust +TabStop, Relight: %DesatureAreaHue%°
    Gui, Add, Slider, Center xp y+1 wp NoTicks AltSubmit gupdateUIdesaturatePanel vDesatureAreaHue Range-180-180, % DesatureAreaHue
    Gui, Add, Checkbox, xs y+5 hp Checked%EraseAreaInvert% vEraseAreaInvert gupdateUIdesaturatePanel, &Invert selection area
    Gui, Add, Checkbox, x+15 Checked%EraseAreaUseAlpha% vEraseAreaUseAlpha gupdateUIdesaturatePanel, Apply alpha mas&k

    Gui, Add, Button, xm+0 y+20 h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%DesatureAreaAlternate% vDesatureAreaAlternate gupdateUIdesaturatePanel, &Simple mode
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Desaturate selected area: " appTitle, winPos)
    SetTimer, updateUIdesaturatePanel, -150
}

PanelFloodFillTool() {
    Static userWasWarned := 0
    initQPVmainDLL()
    If (dupesDCTcoeffsInit!=1 && userWasWarned=0)
    {
       userWasWarned := 1
       msgBoxWrapper(appTitle ": WARNING", appTitle " has failed to initialize the main DLL file: qpvmain.dll. Options within this panel and others will likely not function properly.", 0, 0, "error")
    }

    If !(thisBtnHeight := createSettingsGUI(66, A_ThisFunc, 1, 1))
       Return

    ReadSettingsFloodFillPanel()
    btnWid := 100
    txtWid := 250
    EditWid := 60
    FloodFillSelectionAdj := 0
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 205
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid2 := (PrefsLargeFonts=1) ? txtWid//2 + 5 : txtWid//2 + 15
    xCol := (PrefsLargeFonts=1) ? 285 : 195
    thisOpacity := Round((FloodFillOpacity / 255) * 100)
    thisOpacity2 := Round((FloodFillClrOpacity / 255) * 100)
    txtWid3 := (PrefsLargeFonts=1) ? txtWid//2 + 25 : txtWid//2 + 35
    txtWid := (PrefsLargeFonts=1) ? txtWid + 25 : txtWid + 40
    FloodFillUseAlpha := decideAlphaMaskingFeaseable(FloodFillUseAlpha)
    Global PickuFloodFillColor, infoFloodFillTolerance, infoClrOpacity

    Gui, Add, Text, x15 y15 Section, Flood fill (bucket) color:
    Gui, Add, Checkbox, x%xCol% yp+0 gupdateUIfloodFillPanel Checked%FloodFillCartoonMode% vFloodFillCartoonMode, Cartoon mode
    Gui, Add, Slider, Center xs+15 y+10 w%txtWid3% NoTicks ToolTip AltSubmit gupdateUIfloodFillPanel vFloodFillClrOpacity Range3-255, % FloodFillClrOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFloodFillColor +hwndhBtnPickClrA, P
    Gui, Add, ListView, x+1 hp w60 %CCLVO% Background%FloodFillColor% vFloodFillColor,
    Gui, Add, Text, x+5 hp +0x200 vinfoClrOpacity gBTNresetFloodClrOpacity +TabStop +hwndhBtnRopacity, 1011`%
    ToolTip2ctrl(hBtnRopacity, "Reset fill color opacity")
    ToolTip2ctrl(hBtnPickClrA, "Pick fill color from the viewport")
    ; Gui, Add, Checkbox, xs y+10 hp, &Overlay flood fill
    Gui, Add, Text, xs+15 y+15 hp vinfoOpacity gBTNresetFlooduOpacity +TabStop, Flooding opacity: %thisOpacity%00`%
    Gui, Add, DropDownList, x%xCol% yp+0 wp gupdateUIfloodFillPanel AltSubmit Choose%FloodFillBlendMode% vFloodFillBlendMode, No blending mode|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Slider, Center xs+15 y+5 NoTicks AltSubmit w%txtWid% gupdateUIfloodFillPanel vFloodFillOpacity Range3-255, % FloodFillOpacity
    Gui, Add, Checkbox, xs+14 y+5 hp gupdateUIfloodFillPanel Checked%FloodFillDynamicOpacity% vFloodFillDynamicOpacity, Reduce flooding opacity based on color similarity
    Gui, Add, Text, xs y+15 hp +0x200 vinfoFloodFillTolerance gBTNresetFloodColorTolerance +TabStop, Color similarity tolerance level: %FloodFillTolerance%00l
    Gui, Add, Slider, Center xs+15 y+5 NoTicks AltSubmit w%txtWid% gupdateUIfloodFillPanel vFloodFillTolerance Range0-256, % FloodFillTolerance
    Gui, Add, DropDownList, xs+15 w%txtWid2% y+5 gupdateUIfloodFillPanel AltSubmit Choose%FloodFillAltToler% vFloodFillAltToler, Grayscale [fast]|L*a'b' based grayscale|CIE 2000 Delta E [accurate]
    Gui, Add, Checkbox, x%xCol% yp+0 hp gupdateUIfloodFillPanel Checked%FloodFillEightWays% vFloodFillEightWays , Follow thin lines
    Gui, Add, Checkbox, xs+15 y+10 gupdateUIfloodFillPanel Checked%FloodFillModus% vFloodFillModus, Replace the similar colors anywhere

    Gui, Add, Button, xm+0 y+25 h%thisBtnHeight% w40 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    ; Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp wp+35 gBtnCloseWindow Default, &Close

    txtWid2 := (PrefsLargeFonts=1) ? 200 : 110
    Gui, Add, DropDownList, x+5 w%txtWid2% gupdateUIfloodFillPanel AltSubmit Choose%BrushToolOutsideSelection% vBrushToolOutsideSelection, Ignore selection|Flood inside|Flood outside
    Gui, Add, Checkbox, x+5 yp gupdateUIfloodFillPanel Checked%FloodFillUseAlpha% vFloodFillUseAlpha, Apply alpha mas&k

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Color bucket tool: " appTitle, winPos)
    SetTimer, updateUIfloodFillPanel, -190
}

PanelEraseSelectedArea() {
    If !(thisBtnHeight := createSettingsGUI(25, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    RegAction(0, "EraseAreaFader",, 1)
    RegAction(0, "EraseAreaOpacity",, 2, 4, 252)
    RegAction(0, "EraseAreaInvert",, 1)
    EraseAreaUseAlpha := decideAlphaMaskingFeaseable(EraseAreaUseAlpha)
    btnWid := 80
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((EraseAreaOpacity / 255) * 100)
    Global infoEraseOpacity
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please decide how to erase or fade selected area:
    Gui, Add, Checkbox, xs y+10 hp Checked%EraseAreaFader% vEraseAreaFader gupdateUIerasePanel, &Fade selected area
    Gui, Add, Checkbox, x+10 hp Checked%EraseAreaInvert% vEraseAreaInvert gupdateUIerasePanel, &Invert selection area
    Gui, Add, Text, xs+15 y+10 w%txtWid% hp +0x200 vinfoEraseOpacity gBTNresetEraseOpacity  +TabStop, Opacity: %thisOpacity%`%
    Gui, Add, Slider, Center xp y+5 wp AltSubmit gupdateUIerasePanel vEraseAreaOpacity Range5-255, % EraseAreaOpacity

    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    ; Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 yp hp Checked%EraseAreaUseAlpha% vEraseAreaUseAlpha gupdateUIerasePanel, Apply alpha mas&k
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Erase selected area: " appTitle, winPos)
    SetTimer, updateUIerasePanel, -150
}

PanelFillBehindBgrImage() {
    If !(thisBtnHeight := createSettingsGUI(68, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    RegAction(0, "FillBehindOpacity",, 2, 1, 512)
    RegAction(0, "FillBehindClrOpacity",, 2, 2, 255)
    RegAction(0, "FillBehindInvert",, 1)
    RegAction(0, "FillBehindColor",, 3)
    btnWid := 80
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Global infoOpacity, PickuFillBehindColor
    thisOpacityA := Round((FillBehindClrOpacity / 255) * 100)
    thisOpacityB := Floor((FillBehindOpacity / 26) * 100)
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please set the color and opacity to fill behind the image. This will have no visible effect on images without semi-transparent pixels.
    Gui, Add, Checkbox, xs y+10 Checked%FillBehindInvert% gupdateUIfillBehindPanel vFillBehindInvert, &Invert selection area
    Gui, Add, Text, xs y+15 hp+10 +0x200, Color:
    Gui, Add, ListView, x+5 hp wp+15 %CCLVO% Background%FillBehindColor% vFillBehindColor,
    Gui, Add, Button, x+1 hp w25 gStartPickingColor vPickuFillBehindColor +hwndhBtnPickClrA, P
    Gui, Add, Text, x+10 hp +TabStop +0x200 vinfoOpacity gBTNresetFillBehColorOpacity +TabStop +hwndhBtnRopacity, Opacity: 1011`%
    Gui, Add, Slider, Center xs y+10 w%txtWid% AltSubmit NoTicks gupdateUIfillBehindPanel vFillBehindClrOpacity Range2-255, % FillBehindClrOpacity
    Gui, Add, Text, xs+10 wp +TabStop +0x200 vtxtLine1 gBTNresetBehindOpacity +TabStop, Image opacity: %thisOpacityB%`%
    Gui, Add, Slider, Center xs y+10 w%txtWid% AltSubmit NoTicks gupdateUIfillBehindPanel vFillBehindOpacity Range1-512, % FillBehindOpacity
    ToolTip2ctrl(hBtnRopacity, "Reset fill color opacity")
    ToolTip2ctrl(hBtnPickClrA, "Pick fill color from the viewport")

    Gui, Add, Button, xm+0 y+25 h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    ; Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Fill behind image: " appTitle, winPos)
    SetTimer, updateUIfillBehindPanel, -150
}

updateUIfillBehindPanel(actionu:="", b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=68)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    RegAction(1, "FillBehindOpacity")
    RegAction(1, "FillBehindClrOpacity")
    RegAction(1, "FillBehindInvert")
    thisOpacity := Round((FillBehindClrOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoOpacity, Opacity: %thisOpacity%`%

    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := FillBehindClrOpacity

    thisOpacity := Round((FillBehindOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, txtLine1, Image opacity: %thisOpacity%`%
    If (actionu!="noPreview") && (A_TickCount - lastInvoked>50)
    {
       lastInvoked := A_TickCount
       livePreviewsImageEditing(0, 0, A_ThisFunc, actionu, b)
    }
}

createHatchBrush(thisOpacity) {
   thisBase := (coreDesiredPixFmt="0x21808") ? "0xFF000000" : "0xFF999999"
   Gdip_FromARGB(thisBase, A, R, G, B)
   thisColorA := Gdip_ToARGB(255 - thisOpacity, R, G, B)
   Gdip_FromARGB("0xFF111111", A, R, G, B)
   thisColorB := Gdip_ToARGB(255 - thisOpacity, R, G, B)
   thisBrush := Gdip_BrushCreateHatch(thisColorA, thisColorB, 50)
   Return thisBrush
}

getClampedVPimgBounds(ByRef dpX, ByRef dpY, ByRef kX, ByRef kY, ByRef kW, ByRef kH) {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   dpX := clampInRange(prevDestPosX, 0, mainWidth)
   dpY := clampInRange(prevDestPosY, 0, mainHeight)
   kX := clampInRange(prevDestPosX + prevResizedVPimgW, 2, mainWidth)
   kY := clampInRange(prevDestPosY + prevResizedVPimgH, 2, mainHeight)
   kW := max(dpX, kX) - min(dpX, kX)
   kH := max(dpY, kY) - min(dpY, kY)
}

livePreviewEraseArea() {
   Critical, on
   ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
   imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
   imgSelW := max(X1, X2) - min(X1, X2)
   imgSelH := max(Y1, Y2) - min(Y1, Y2)
   pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
   allowAlphaMasking := decideAlphaMaskingFeaseable(EraseAreaUseAlpha)
   fnOutputDebug("redraw: " A_ThisFunc)
   thisOpacity := (EraseAreaFader=1 && allowAlphaMasking=0) ? EraseAreaOpacity : 0
   thisBrush := createHatchBrush(thisOpacity)

   thisOpacity := (EraseAreaFader=1) ? EraseAreaOpacity : 0
   thisBrush2 := createHatchBrush(thisOpacity)
   If (allowAlphaMasking=1)
   {
      If (EraseAreaInvert=1)
      {
         imgSelPx := prevDestPosX    , imgSelPy := prevDestPosY
         imgSelW := prevResizedVPimgW, imgSelH := prevResizedVPimgH
      }
      zBitmap := trGdip_CreateBitmap(A_ThisFunc, imgSelW//2 + 2, imgSelH//2 + 2)
      G3 := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
      Gdip_FillRectangle(G3, thisBrush, 0, 0, imgSelW//2 + 2, imgSelH//2 + 2)
      Gdip_DeleteGraphics(G3)
   } Else If (EraseAreaInvert=1)
   {
      getClampedVPimgBounds(dpX, dpY, kX, kY, kW, kH)
      Gdip_SetClipPath(2NDglPG, pPath, 4)
      Gdip_FillRectangle(2NDglPG, thisBrush, dpX, dpY, kW, kH)
      Gdip_ResetClip(2NDglPG)
   } Else Gdip_FillPath(2NDglPG, thisBrush, pPath)

   If (allowAlphaMasking=1 && StrLen(zBitmap)>2)
   {
      modus := (EraseAreaInvert=1) ? 4 : 0
      Gdip_SetClipPath(2NDglPG, pPath, modus)
      og := alphaMaskColorReversed
      alphaMaskColorReversed := !og
      thisIDu := "a" alphaMaskColorReversed alphaMaskingMode userAlphaMaskBmpPainted VPselRotation imgSelPx imgSelPy imgSelW imgSelH EraseAreaInvert EraseAreaOpacity EraseAreaFader
      realtimePasteInPlaceAlphaMasker(1, zBitmap, thisIDu, newBitmap, 0, 0, 0, 0)
      If StrLen(newBitmap)>2
      {
         trGdip_DisposeImage(zBitmap, 1)
         zBitmap := newBitmap
      }

      thisOpacity := 1
      alphaMaskColorReversed := og
      r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
      If (EraseAreaFader=1 && EraseAreaInvert=0)
      {
         Gdip_FillPath(2NDglPG, thisBrush2, pPath)
      } Else If (EraseAreaFader=1)
      {
         getClampedVPimgBounds(dpX, dpY, kX, kY, kW, kH)
         Gdip_FillRectangle(2NDglPG, thisBrush2, dpX, dpY, kW, kH)
      }
      Gdip_ResetClip(2NDglPG)
      trGdip_DisposeImage(zBitmap, 1)
   }

   Gdip_DeletePath(pPath)
   Gdip_DeleteBrush(thisBrush)
   Gdip_DeleteBrush(thisBrush2)
   ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
}

livePreviewAlphaMasking(dummy:=0, dummyOpacity:=0) {
   Critical, on
   If (alphaMaskingMode<2 || (alphaMaskPreviewOpacity<2 && dummy="live") || (doImgEditLivePreview!=1 && dummy="live"))
      Return

   friendly := defineCurrentAlphaMask()
   If InStr(friendly, "inexistent")
   {
      showTOOLtip("WARNING: The referenced alpha mask bitmap does not exist")
      If (dummy!="live")
         SoundBeep 300, 100
      SetTimer, RemoveTooltip, -1050
      ToolTip
      Return
   }

   dotsSize := SelDotsSize
   ; fnOutputDebug("redraw: " A_ThisFunc)
   vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
   vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
   vPimgSelX := min(selDotX, selDotAx) + dotsSize//2
   vPimgSelY := min(selDotY, selDotAy) + dotsSize//2
   doInvertPreview := (AnyWindowOpen=66 && FloodFillUseAlpha=1 && (BrushToolOutsideSelection=1 || BrushToolOutsideSelection=3)) || (AnyWindowOpen=23 && FillAreaInverted=1) || ((AnyWindowOpen=25 || AnyWindowOpen=55) && EraseAreaInvert=1) ? 1 : 0
   If (doInvertPreview=1 && dummy!="live")
   {
      If (AnyWindowOpen=66 && FloodFillUseAlpha=1 && BrushToolOutsideSelection=3)|| (AnyWindowOpen=23 && FillAreaInverted=1) || ((AnyWindowOpen=25 || AnyWindowOpen=55) && EraseAreaInvert=1)
         pPath := createImgSelPath(vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
      getClampedVPimgBounds(vPimgSelX, vPimgSelY, x2, y2, vPimgSelW, vPimgSelH)
   }

   If (dummy!="live")
   {
      hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
      tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
      tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
   } Else If StrLen(userAlphaMaskBmpPainted)>2
   {
      Gdip_GetImageDimensions(userAlphaMaskBmpPainted, w, h)
      viewportDynamicOBJcoords.x := vPimgSelX, viewportDynamicOBJcoords.y := vPimgSelY
      viewportDynamicOBJcoords.w := vPimgSelW,  viewportDynamicOBJcoords.h := vPimgSelH
      viewportDynamicOBJcoords.zl := (vPimgSelW/w + vPimgSelH/h)/2 + 0.0001
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)

   ; pEffectGray := Gdip_CreateEffect(6, 0, -100, 0)
   thisOpacity := (alphaMaskPreviewOpacity<254) ? alphaMaskPreviewOpacity/255 : 1
   If dummyOpacity
      thisOpacity := dummyOpacity
   clrMatrix := (alphaMaskColorReversed=1) ? GenerateColorMatrix(6, a, b, c, thisOpacity) : thisOpacity
   If isNowAlphaPainting()
   {
      pBitmap := trGdip_ResizeBitmap(A_ThisFunc, userAlphaMaskBmpPainted, vPimgSelW, vPimgSelH, 0, 5)
      ; If (alphaMaskingMode=5 && alphaMaskBMPchannel!=5)
      ;    Gdip_BitmapApplyEffect(pBitmap, pEffectGray)
      trGdip_DrawImage(A_ThisFunc, 2NDglPG, pBitmap, vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH,,,,, clrMatrix)
      trGdip_DisposeImage(pBitmap)
      Gdip_GetImageDimensions(userAlphaMaskBmpPainted, w, h)
      msg := "Alpha mask type: user painted bitmap (raw)`nDimensions: " groupDigits(w) " x " groupDigits(h) " (" Round(w/h, 2) ")`nSelection area: " groupDigits(imgSelW) " x " groupDigits(imgSelH) " (" Round(imgSelW/imgSelH, 2) ")"
   } Else
   {
      w := vPimgSelW , h := vPimgSelH
      If InStr(friendly, "user painted")
         Gdip_GetImageDimensions(userAlphaMaskBmpPainted, w, h)
      Else If InStr(friendly, "main image")
         Gdip_GetImageDimensions(useGdiBitmap(), w, h)
      Else If InStr(friendly, "transformed")
         Gdip_GetImageDimensions(userClipBMPpaste, w, h)

      kImgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
      kImgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
      thisIDu := "a" alphaMaskingMode alphaMaskColorReversed userAlphaMaskBmpPainted kImgSelW kImgSelH VPselRotation zoomLevel
      alphaMaskGray := generateAlphaMaskBitmap(0, 1, vPimgSelW//2 + 1, vPimgSelH//2 + 1, 0, 0, thisIDu, 1)
      msg := "Alpha mask type: " friendly "`nDimensions: " groupDigits(w) " x " groupDigits(h) " (" Round(w/h, 2) ")`nSelection dimensions: " groupDigits(imgSelW) " x " groupDigits(imgSelH) " (" Round(imgSelW/imgSelH, 2) ")"
      If StrLen(alphaMaskGray)>2
      {
         ; ToolTip, % msg , , , 2
         ; If (alphaMaskingMode=5 && alphaMaskBMPchannel!=5)
         ;    QPV_ConvertToGrayscale(alphaMaskGray, alphaMaskBMPchannel)
            ; Gdip_BitmapApplyEffect(alphaMaskGray, pEffectGray)
         trGdip_DrawImage(A_ThisFunc, 2NDglPG, alphaMaskGray, vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH,,,,, clrMatrix)
         ; trGdip_DisposeImage(alphaMaskGray)
         If (dummy!="live")
            generateAlphaMaskBitmap("kill", 0)
      }
   }

   If (dummy!="live")
   {
      If pPath
      {
         thisBrush := createHatchBrush(1)
         Gdip_FillPath(2NDglPG, thisBrush, pPath)
         Gdip_DeleteBrush(thisBrush)
         Gdip_DeletePath(pPath)
      }
      Gdip_ResetWorldTransform(2NDglPG)
      BoxBMP := drawTextInBox(msg, OSDFontName, OSDfontSize, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0, 0)
      trGdip_DrawImage(A_ThisFunc, 2NDglPG, BoxBMP, tlbrBonusX, tlbrBonusY)
      trGdip_DisposeImage(BoxBMP, 1)
   }

   ; Gdip_DisposeEffect(pEffectGray)
}

livePreviewFillBehindArea(modus:=0) {
      Static prevState, prevBMP

      If (modus="kill")
      {
         trGdip_DisposeImage(prevBMP, 1)
         prevBMP := prevState := ""
         Return
      }

      imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
      imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
      imgSelW := max(X1, X2) - min(X1, X2)
      imgSelH := max(Y1, Y2) - min(Y1, Y2)
      pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)

      Gdip_FromARGB("0xFF" FillBehindColor, A, R, G, B)
      thisColorA := Gdip_ToARGB(FillBehindClrOpacity, R, G, B)
      thisBrush := Gdip_BrushCreateSolid(thisColorA)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      If (FillBehindOpacity<254 || FillBehindClrOpacity<254 || FillBehindInvert=1)
      {
         If (FillBehindInvert=1)
         {
            getClampedVPimgBounds(dpX, dpY, kX, kY, kW, kH)
            modus := (FillBehindInvert=1) ? 4 : 0
            Gdip_SetClipPath(2NDglPG, pPath, modus)
            Gdip_FillRectangle(2NDglPG, pBrushHatchLow, dpX, dpY, kW, kH)
            Gdip_ResetClip(2NDglPG)
         } Else
         {
            hRgn := Gdip_CreateRegionPath(pPath)
            hRgnB := Gdip_GetRegionHRgn(2NDglPG, hRgn)
            Gdi_FillRegion(2NDglHDC, hRgnB, useGdiHatchedBrush("vp"))
            Gdi_DeleteObject(hRgnB)
            Gdip_DeleteRegion(hRgn)
            Gdip_ResetClip(2NDglPG)
         }
      }

      gimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
      gimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
      thisu := (FillBehindInvert=1) ? "a" prevDestPosX prevDestPosY : "a" prevResizedVPimgW prevResizedVPimgH
      thisState := "a" imgSelPx imgSelPy imgSelW imgSelH mainWidth mainHeight zoomLevel thisu FillBehindInvert IMGresizingMode imageAligned getIDvpFX() useGdiBitmap() gimgSelW gimgSelH
      If (prevState!=thisState)
      {
         fnOutputDebug("redraw: " A_ThisFunc)
         trGdip_DisposeImage(prevBMP, 1)
         If (FillBehindInvert=1)
         {
            pBitmap := useGdiBitmap()
            Gdip_GetImageDimensions(pBitmap, w, h)
            If (w!=prevResizedVPimgW || h!=prevResizedVPimgH)
            {
               zBitmap := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, prevResizedVPimgW, prevResizedVPimgH, 0, 5)
               pBitmap := StrLen(zBitmap)>2 ? zBitmap : ""
            } Else pBitmap := trGdip_CloneBitmap(A_ThisFunc, pBitmap)
            pBitmap := applyVPeffectsOnBMP(pBitmap)
         } Else
         {
            pBitmap := getImgSelectedAreaEditMode(0, imgSelX1, imgSelY1, gimgSelW, gimgSelH, gimgSelW, gimgSelH, 0)
            Gdip_GetImageDimensions(pBitmap, w, h)
            If (w!=imgSelW || h!=imgSelH)
            {
               zBitmap := Gdip_ResizeBitmap(pBitmap, imgSelW, imgSelH, 0, 5)
               trGdip_DisposeImage(pBitmap, 1)
               pBitmap := zBitmap
            }
         }
         prevBMP := pBitmap
         prevState := thisState
         ; ToolTip, % imgSelW "=" imgSelH "`n" w "=" h , , , 2
      } Else pBitmap := prevBMP

      If pBitmap
      {
         modus := (FillBehindInvert=1) ? 4 : 0
         Gdip_SetClipPath(2NDglPG, pPath, modus)
         thisOpacity := (FillBehindOpacity>255) ? (FillBehindOpacity - 245)/10 : FillBehindOpacity/255
         If (FillBehindInvert=1)
         {
            Gdip_FillRectangle(2NDglPG, thisBrush, dpX, dpY, kX - dpX, kY - dpY)
            trGdip_DrawImage(A_ThisFunc, 2NDglPG, pBitmap, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, , , , , thisOpacity)
         } Else
         {
            Gdip_FillPath(2NDglPG, thisBrush, pPath)
            trGdip_DrawImage(A_ThisFunc, 2NDglPG, pBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, , , , , thisOpacity)
         }
         Gdip_ResetClip(2NDglPG)
      }

      Gdip_DeletePath(pPath)
      Gdip_DeleteBrush(thisBrush)
      ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
}

PasteInPlaceEraseArea(G2, mode) {
      If (mode=1)
      {
         imgSelPx := x1 := prevSelDotX + SelDotsSize//2, x2 := prevSelDotAx + SelDotsSize//2
         imgSelPy := y1 := prevSelDotY + SelDotsSize//2, y2 := prevSelDotAy + SelDotsSize//2
         imgSelW := max(X1, X2) - min(X1, X2)
         imgSelH := max(Y1, Y2) - min(Y1, Y2)
      } Else
      {
         Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
         calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 1)
      }

      pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, prevEllipseSelectMode, prevVPselRotation, prevrotateSelBoundsKeepRatio, 0, 1, 1, previnnerSelectionCavityX, previnnerSelectionCavityY)
      If (mode=1)
      {
         If pPath
            Gdip_FillPath(G2, useHatchedBrush(), pPath)
      } Else
      {
         If pPath
            Gdip_SetClipPath(G2, pPath)
         trGdip_GraphicsClear(A_ThisFunc, G2)
         Gdip_ResetClip(G2)
      }

      Gdip_DeletePath(pPath)
}

WriteSettingsBlurPanel() {
    ReadSettingsBlurPanel(1)
}

WriteSettingsZoomBlurPanel() {
    ReadSettingsZoomBlurPanel(1)
}

ReadSettingsZoomBlurPanel(act:=0) {
    RegAction(act, "blurAreaMode",, 2, 1, 3)
    RegAction(act, "BlurAreaAlphaMask",, 1)
    RegAction(act, "blurAreaOpacity",, 2, 3, 255)
    RegAction(act, "blurAreaInverted",, 1)
    RegAction(act, "BlurAreaBlendMode",, 2, 1, 21)
    RegAction(act, "BlurAreaGamma",, 2, -100, 100)
    RegAction(act, "BlurAreaHue",, 2, -180, 180)
    RegAction(act, "BlurAreaLight",, 2, -255, 255)
    RegAction(act, "BlurAreaSaturation",, 2, -100, 100)
    RegAction(act, "zoomBlurAreaXamount",, 2, 1, 25)
}

ReadSettingsBlurPanel(act:=0) {
    RegAction(act, "BlurAreaGamma",, 2, -100, 100)
    RegAction(act, "BlurAreaHue",, 2, -180, 180)
    RegAction(act, "BlurAreaLight",, 2, -255, 255)
    RegAction(act, "BlurAreaSaturation",, 2, -100, 100)
    RegAction(act, "blurAreaAmount",, 2, 0, 255)
    RegAction(act, "blurAreaMode",, 2, 1, 3)
    RegAction(act, "blurAreaPixelizeAmount",, 2, 0, 1024)
    RegAction(act, "blurAreaPixelizeMethod",, 2, 1, 3)
    RegAction(act, "blurAreaOpacity",, 2, 3, 255)
    RegAction(act, "blurAreaInverted",, 1)
    RegAction(act, "blurAreaSoftEdges",, 1)
    RegAction(act, "blurAreaSoftLevel",, 2, 1, 7)
    RegAction(act, "BlurAreaBlendMode",, 2, 1, 21)
    RegAction(act, "blurAreaTwice",, 1)
    RegAction(act, "BlurAreaAlphaMask",, 1)
}

PanelZoomBlurSelectedArea() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(69, A_ThisFunc)
    ReadSettingsZoomBlurPanel()
    btnWid := 75
    txtWid := 280
    EditWid := 60
    thisW := 135
    If (PrefsLargeFonts=1)
    {
       EditWid += 50
       btnWid += 40
       txtWid += 105
       thisW += 40
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    Global infoBlurOpacity, infoBlurAmount, infoZoomX, infoZoomY, uizoomBlurAreaXamount, uizoomBlurAreaYamount
    If (wasSelect!=1)
       blurAreaInverted := 0

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    tinyPrevAreaCoordX := !isNumber(tinyPrevAreaCoordX) ? imgW/2 : clampInRange(tinyPrevAreaCoordX, 0, imgW)
    tinyPrevAreaCoordY := !isNumber(tinyPrevAreaCoordY) ? imgH/2 : clampInRange(tinyPrevAreaCoordY, 0, imgH)
    friendly := (isWinXP=1) ? " (unsupported)" : ""
    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click in the viewport to set the origin for the zoom.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "None"
    If (coreDesiredPixFmt="0x21808")
       BlurAreaBlendMode := 1

    infoMask := defineCurrentAlphaMask()
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       BlurAreaAlphaMask := 0

    Gui, +DPIScale
    Gui, Add, Tab3, x+20 ys gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Color options
    Gui, Tab, 1
    Gui, Add, Text, x+10 y+10 w%thisW% Section , Blur mode: 
    Gui, Add, DropDownList, x+5 wp gupdateUIzoomBlurPanel AltSubmit Choose%zoomBlurMode% vzoomBlurMode, Zoom H/V|Horizontal|Vertical|Alt-Horizontal|Alt-Vertical
    ; Gui, Add, Text, xs y+10 w%thisW% gBTNresetBlurAmount vinfoBlurAmount +TabStop, Blur amount: %blurAreaAmount%
    ; Gui, Add, Slider, Center xs y+5 gupdateUIzoomBlurPanel AltSubmit w%txtWid% vblurAreaAmount Range0-255, % blurAreaAmount
    Gui, Add, Text, xs y+10 w%thisW% vinfoZoomX +TabStop, Zoom X: %zoomBlurAreaXamount%
    Gui, Add, Slider, Center xs y+5 gupdateUIzoomBlurPanel AltSubmit w%txtWid% vuizoomBlurAreaXAmount Range1-250, % zoomBlurAreaXamount*10
    ; Gui, Add, Text, xs y+10 w%thisW% vinfoZoomY +TabStop, Zoom Y: %zoomBlurAreaYamount%
    ; Gui, Add, Slider, Center xs y+5 gupdateUIzoomBlurPanel AltSubmit w%txtWid% vuizoomBlurAreaYamount Range1-250, % zoomBlurAreaYamount*10
    Gui, Add, Text, xs y+10 w%txtWid% gBTNresetBlurOpacity vinfoBlurOpacity +TabStop, Opacity: %thisOpacity%`%
    Gui, Add, Slider, Center xs y+5 gupdateUIzoomBlurPanel AltSubmit w%txtWid% vblurAreaOpacity Range5-255, % blurAreaOpacity
    Gui, Add, Checkbox, xs y+10 Checked%BlurAreaAlphaMask% vBlurAreaAlphaMask gupdateUIzoomBlurPanel, Apply alpha mas&k
    Gui, Add, Checkbox, xs y+10 Checked%blurAreaInverted% vblurAreaInverted gupdateUIzoomBlurPanel, &Invert selection area
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       GuiControl, Disable, BlurAreaAlphaMask

    If (wasSelect!=1 && EllipseSelectMode=0)
       GuiControl, Disable, blurAreaInverted

    Global infoBlurHue, infoBlurSat, infoBlurLight, infoBlurGamma

    Gui, Tab, 2
    Gui, Add, Text, x+10 y+10 Section w%thisW% gBtnResetBlendMode +TabStop, Blending mode: 
    Gui, Add, DropDownList, x+5 wp gupdateUIzoomBlurPanel AltSubmit Choose%BlurAreaBlendMode% vBlurAreaBlendMode, %infoBlend%|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetPanelsSpecificControl vinfoBlurHue +TabStop, Hue: %BlurAreaHue%°
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIzoomBlurPanel vBlurAreaHue Range-180-180, % BlurAreaHue
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoBlurSat +TabStop, Saturation: %BlurAreaSaturation%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIzoomBlurPanel vBlurAreaSaturation Range-100-100, % BlurAreaSaturation
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoBlurLight +TabStop, Brightness: %BlurAreaLight%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIzoomBlurPanel vBlurAreaLight Range-255-255, % BlurAreaLight
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoBlurGamma +TabStop, Contrast: %BlurAreaGamma%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIzoomBlurPanel vBlurAreaGamma Range-100-100, % BlurAreaGamma

    Gui, Tab
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnZoomBlurSelectedArea, &Proceed
    Gui, Add, Button, x+6 hp wp gOpenPanelBlur, &Gaussian
    Gui, Add, Button, x+6 hp wp gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Zoom blur in selected area: " appTitle, winPos)
    SetTimer, updateUIzoomBlurPanel, -100
}

OpenPanelBlur() {
   BtnCloseWindow()
   PanelBlurSelectedArea()
}

PanelBlurSelectedArea() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(26, A_ThisFunc)
    ReadSettingsBlurPanel()
    btnWid := 75
    txtWid := 280
    EditWid := 60
    thisW := 135
    If (PrefsLargeFonts=1)
    {
       EditWid += 50
       btnWid += 40
       txtWid += 105
       thisW += 40
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    Global infoBlurOpacity, infoBlurAmount, infoPixelize
    If (wasSelect!=1)
    {
       blurAreaSoftEdges := 0
       blurAreaInverted := 0
    }

    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125
    If (isWinXP=1 && blurAreaMode=1)
    {
       blurAreaMode := 2
       blurAreaSoftEdges := 0
    }
    
    If (coreDesiredPixFmt="0x21808")
       blurAreaSoftEdges := 0

    friendly := (isWinXP=1) ? " (unsupported)" : ""
    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag to change the preview area, or in the viewport.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "None"
    If (coreDesiredPixFmt="0x21808")
       BlurAreaBlendMode := 1

    infoMask := defineCurrentAlphaMask()
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       BlurAreaAlphaMask := 0

    Gui, +DPIScale
    Gui, Add, Tab3, x+20 ys gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Color options
    Gui, Tab, 1
    Gui, Add, Checkbox, x+10 y+10 w%thisW% Section Checked%blurAreaSoftEdges% vblurAreaSoftEdges gupdateUIblurPanel, &Soft edges%friendly%
    Gui, Add, DropDownList, x+5 w60 AltSubmit Choose%blurAreaSoftLevel% gupdateUIblurPanel vblurAreaSoftLevel, 0.3x|0.6x|1x|2x|3x|4x|5x
    Gui, Add, Checkbox, xs y+10 hp Checked%blurAreaTwice% vblurAreaTwice gupdateUIblurPanel, &Blur twice in one go (for large images)
    Gui, Add, Text, xs y+10 w%thisW% gBTNresetBlurAmount vinfoBlurAmount +TabStop, Blur amount: %blurAreaAmount%
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%blurAreaMode% gupdateUIblurPanel vblurAreaMode, High quality%friendly%|Alternate blur|Box blur (slow)
    Gui, Add, Slider, Center xs y+5 gupdateUIblurPanel AltSubmit w%txtWid% vblurAreaAmount Range0-255, % blurAreaAmount
    Gui, Add, Text, xs y+10 w%thisW% gBTNresetBlurPixelizationAmount vinfoPixelize +TabStop, Pixelize level: %blurAreaPixelizeAmount%
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%blurAreaPixelizeMethod% gupdateUIblurPanel vblurAreaPixelizeMethod, Method 1|Method 2|Method 3
    Gui, Add, Slider, Center xs y+5 gupdateUIblurPanel AltSubmit w%txtWid% vblurAreaPixelizeAmount Range0-1024, %blurAreaPixelizeAmount%
    Gui, Add, Checkbox, xs y+10 w%thisW% Checked%blurAreaInverted% vblurAreaInverted gupdateUIblurPanel, &Invert selection
    Gui, Add, Checkbox, x+5 Checked%BlurAreaAlphaMask% vBlurAreaAlphaMask gupdateUIblurPanel, Apply alpha mas&k

    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       GuiControl, Disable, BlurAreaAlphaMask

    If (wasSelect!=1 && EllipseSelectMode=0)
       GuiControl, Disable, blurAreaInverted

    Gui, Tab, 2
    Gui, Add, Text, x+10 y+10 Section w%thisW% gBtnResetBlendMode +TabStop, Blending mode: 
    Gui, Add, DropDownList, x+5 wp gupdateUIblurPanel AltSubmit Choose%BlurAreaBlendMode% vBlurAreaBlendMode, %infoBlend%|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetPanelsSpecificControl vinfoBlurHue +TabStop, Hue: %BlurAreaHue%°
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIblurPanel vBlurAreaHue Range-180-180, % BlurAreaHue
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoBlurSat +TabStop, Saturation: %BlurAreaSaturation%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIblurPanel vBlurAreaSaturation Range-100-100, % BlurAreaSaturation
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoBlurLight +TabStop, Brightness: %BlurAreaLight%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIblurPanel vBlurAreaLight Range-255-255, % BlurAreaLight
    Gui, Add, Text, y+6 wp gBtnResetPanelsSpecificControl vinfoBlurGamma +TabStop, Contrast: %BlurAreaGamma%`%
    Gui, Add, Slider, Center y+1 wp AltSubmit NoTicks gupdateUIblurPanel vBlurAreaGamma Range-100-100, % BlurAreaGamma
    Gui, Add, Text, y+6 wp gBTNresetBlurOpacity vinfoBlurOpacity +TabStop, Opacity: %thisOpacity%`%
    Gui, Add, Slider, Center xs y+1 gupdateUIblurPanel AltSubmit wp NoTicks vblurAreaOpacity Range5-255, % blurAreaOpacity

    Gui, Tab
    Gui, Add, Button, xs+0 y+10 h%thisBtnHeight% Default w%btnWid% gBtnBlurSelectedArea, &Blur area
    Gui, Add, Button, x+6 hp wp gOpenPanelZoomBlur, &Motion blur
    Gui, Add, Button, x+6 hp wp gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Blur/pixelize selected area: " appTitle, winPos)
    SetTimer, updateUIblurPanel, -100
}

OpenPanelZoomBlur() {
   BtnCloseWindow()
   PanelZoomBlurSelectedArea()
}

BTNresetBlurOpacity() {
   blurAreaOpacity := 255
   GuiControl, SettingsGUIA:, blurAreaOpacity, 255
   If (AnyWindowOpen=44)
      updateUIaddNoisePanel()
   Else If (AnyWindowOpen=69)
      updateUIzoomBlurPanel()
   Else
      updateUIblurPanel()
}

BTNresetBlurPixelizationAmount() {
   blurAreaPixelizeAmount := 0
   GuiControl, SettingsGUIA:, blurAreaPixelizeAmount, 0
   updateUIblurPanel()
}

BTNresetPixelizAmountNoiser() {
   UserAddNoIsePixelizeAmount := 0
   GuiControl, SettingsGUIA:, UserAddNoIsePixelizeAmount, 0
   updateUIaddNoisePanel()
}

BTNresetBlurAmount() {
   blurAreaAmount := 25
   GuiControl, SettingsGUIA:, blurAreaAmount, 25
   updateUIblurPanel()
}

BTNresetBlurNoiserAmount() {
   UserAddNoiseBlurAmount := 0
   GuiControl, SettingsGUIA:, UserAddNoiseBlurAmount, 0
   updateUIaddNoisePanel()
}

WriteSettingsEdgesPanel() {
    ReadSettingsEdgesPanel(1)
}

WriteSettingsAddNoisePanel() {
    ReadSettingsAddNoisePanel(1)
}

ReadSettingsEdgesPanel(act:=0) {
    RegAction(act, "IDedgesOpacity",, 2, 3, 255)
    RegAction(act, "IDedgesEmphasis",, 2, -255, 255)
    RegAction(act, "IDedgesContrast",, 2, -100, 100)
    RegAction(act, "IDedgesBlendMode",, 2, 1, 21)
    RegAction(act, "IDedgesCenterAmount",, 2, 1, 6)
    RegAction(act, "IDedgesXuAmount",, 2, -3, 3)
    RegAction(act, "IDedgesYuAmount",, 2, -3, 3)
    RegAction(act, "IDedgesAfterBlur",, 2, 1, 5)
    RegAction(act, "IDedgesEmbossLvl",, 2, 1, 6)
    RegAction(act, "IDedgesInvert",, 1)
}

ReadSettingsAddNoisePanel(act:=0) {
    RegAction(act, "IDedgesOpacity",, 2, 3, 255)
    RegAction(act, "IDedgesEmphasis",, 2, -255, 255)
    RegAction(act, "IDedgesContrast",, 2, -100, 100)
    RegAction(act, "IDedgesInvert",, 1)
    RegAction(act, "IDedgesBlendMode",, 2, 1, 21)
    RegAction(act, "UserAddNoiseMode",, 1)
    RegAction(act, "UserAddNoiseIntensity",, 2, 1, 100)
    RegAction(act, "UserAddNoiseBlurAmount",, 2, 0, 255)
    RegAction(act, "UserAddNoIsePixelizeAmount",, 2, 0, 1024)
    RegAction(act, "BlurAreaAlphaMask",, 1)
}

PanelDetectEdgesImage() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(43, A_ThisFunc)
    ReadSettingsEdgesPanel()
    btnWid := 100
    txtWid := 270
    thisW := 100
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    2ndcol := (PrefsLargeFonts=1) ? 155 : 130
    thisOpacity := Round((IDedgesOpacity / 255) * 100)
    Global infoEdgesOpacity, infoBright, infoContrst
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125

    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag to change the preview area, or click in the viewport.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    thisW := (PrefsLargeFonts=1) ? 85 : 55
    Gui, +DPIScale
    Gui, Add, Text, x+20 ys Section, Direction and iterations:
    Gui, Add, DropDownList, x+6 w45 gupdateUIedgesPanel AltSubmit Choose%IDedgesEmbossLvl% vIDedgesEmbossLvl, 1|2|3|4|5|6
    Gui, Add, Text, xs y+10 w%thisW%, X
    Gui, Add, Text, x+3 wp, Y
    Gui, Add, Text, x+3 wp, C
    Gui, Add, DropDownList, xs y+7 wp gupdateUIedgesPanel vIDedgesXuAmount, -3|-2|-1|0|1|2|3|%IDedgesXuAmount%||
    Gui, Add, DropDownList, x+3 wp gupdateUIedgesPanel vIDedgesYuAmount, -3|-2|-1|0|1|2|3|%IDedgesYuAmount%||
    Gui, Add, DropDownList, x+3 wp gupdateUIedgesPanel AltSubmit Choose%IDedgesCenterAmount% vIDedgesCenterAmount, 0|1|2|3|4|5

    Gui, Add, Text, xs y+10 w%2ndcol% gBTNresetEdgesBright vinfoBright +TabStop, Brightness: %IDedgesEmphasis%
    Gui, Add, Checkbox, x+7 gupdateUIedgesPanel Checked%IDedgesInvert% vIDedgesInvert, &Invert image
    Gui, Add, Slider, Center xs y+2 AltSubmit w%txtWid% gupdateUIedgesPanel vIDedgesEmphasis Range-255-255, % IDedgesEmphasis
    Gui, Add, Text, xs y+7 w%2ndcol% gBTNresetEdgesContrast vinfoContrst +TabStop, Contrast: %IDedgesContrast%
    Gui, Add, DropDownList, x+7 wp AltSubmit gupdateUIedgesPanel Choose%IDedgesAfterBlur% vIDedgesAfterBlur, After blur|4|6|8|10
    Gui, Add, Slider, Center xs y+2 AltSubmit w%txtWid% gupdateUIedgesPanel vIDedgesContrast Range-100-100, % IDedgesContrast
    Gui, Add, Text, xs y+7 w%2ndcol% gBTNresetEdgesOpacity vinfoEdgesOpacity +TabStop, Opacity: %thisOpacity%`%
    Gui, Add, DropDownList, x+7 wp gupdateUIedgesPanel AltSubmit Choose%IDedgesBlendMode% vIDedgesBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Slider, Center xs y+2 AltSubmit w%txtWid% gupdateUIedgesPanel vIDedgesOpacity Range5-255, % IDedgesOpacity

    thisW := (PrefsLargeFonts=1) ? 90 : 65
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default gBtnIDedgesNow w%btnWid%, &Process image
    Gui, Add, Button, x+5 hp w%thisW% gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Detect edges in selected area: " appTitle, winPos)
    SetTimer, updateUIedgesPanel, -200
}

PanelAddNoiserImage() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(44, A_ThisFunc)
    ReadSettingsAddNoisePanel()
    btnWid := 70
    txtWid := 270
    thisW := 100
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 110
       Gui, Font, s%LargeUIfontValue%
    }

    2ndcol := (PrefsLargeFonts=1) ? 185 : 127
    thisOpacity := Round((IDedgesOpacity / 255) * 100)
    Global infoEdgesOpacity, infoBright, infoContrst, infoNoiseLvl, infoBlurAmount, infoPixelize
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125

    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag to change the preview area, or click in the viewport.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    Gui, +DPIScale
    infoMask := defineCurrentAlphaMask()
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       BlurAreaAlphaMask := 0

    Gui, Add, Checkbox, x+20 ys w%2ndcol% Section gupdateUIaddNoisePanel Checked%UserAddNoiseMode% vUserAddNoiseMode, &Grayscale noise
    Gui, Add, Text, x+7 +0x200 hp gBTNresetNoiseLevel vinfoNoiseLvl -wrap +TabStop, Noise cut-off: 10001
    Gui, Add, Slider, Center xs y+5 AltSubmit NoTicks w%txtWid% gupdateUIaddNoisePanel vUserAddNoiseIntensity Range1-100, % UserAddNoiseIntensity
    
    Gui, Add, Text, xs y+10 w%2ndcol% gBTNresetEdgesBright vinfoBright +TabStop, Brightness: %IDedgesEmphasis%
    Gui, Add, Checkbox, x+7 gupdateUIaddNoisePanel Checked%IDedgesInvert% vIDedgesInvert, &Invert noise
    Gui, Add, Slider, Center xs y+2 AltSubmit NoTicks w%txtWid% gupdateUIaddNoisePanel vIDedgesEmphasis Range-255-255, % IDedgesEmphasis
    Gui, Add, Text, xs y+7 w%txtWid% gBTNresetEdgesContrast vinfoContrst +TabStop, Contrast: %IDedgesContrast%
    Gui, Add, Slider, Center xs y+2 AltSubmit NoTicks w%txtWid% gupdateUIaddNoisePanel vIDedgesContrast Range-100-100, % IDedgesContrast

    Gui, Add, Text, xs y+7 wp gBTNresetPixelizAmountNoiser vinfoPixelize +TabStop, Pixelize: %UserAddNoIsePixelizeAmount%
    Gui, Add, Slider, Center xs y+2 AltSubmit gupdateUIaddNoisePanel NoTicks w%txtWid% vUserAddNoIsePixelizeAmount Range0-100, % UserAddNoIsePixelizeAmount
    Gui, Add, Text, xs y+7 w%txtWid% gBTNresetBlurNoiserAmount vinfoBlurAmount +TabStop, Blur: %UserAddNoiseBlurAmount%
    Gui, Add, Slider, Center xs y+2 AltSubmit gupdateUIaddNoisePanel NoTicks w%txtWid% vUserAddNoiseBlurAmount Range0-254, % UserAddNoiseBlurAmount

    Gui, Add, Text, xs y+7 w%2ndcol% gBTNresetEdgesOpacity vinfoEdgesOpacity +TabStop, Opacity: %thisOpacity%`%
    Gui, Add, DropDownList, x+7 wp gupdateUIaddNoisePanel AltSubmit Choose%IDedgesBlendMode% vIDedgesBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Slider, Center xs y+2 AltSubmit NoTicks w%txtWid% gupdateUIaddNoisePanel vIDedgesOpacity Range5-255, % IDedgesOpacity

    thisW := (PrefsLargeFonts=1) ? 85 : 65
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default gBtnAddNoiseNow w%btnWid%, &Add noise
    Gui, Add, Button, x+5 hp w%thisW% gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 Checked%BlurAreaAlphaMask% vBlurAreaAlphaMask gupdateUIaddNoisePanel, Use alpha mas&k
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       GuiControl, Disable, BlurAreaAlphaMask

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Add noise in selected area: " appTitle, winPos)
    SetTimer, updateUIaddNoisePanel, -200
}

BTNresetEdgesOpacity() {
    IDedgesOpacity := 255
    GuiControl, SettingsGUIA:, IDedgesOpacity, 255
    If (AnyWindowOpen=43)
       updateUIedgesPanel()
    Else If (AnyWindowOpen=44)
       updateUIaddNoisePanel()
}

BTNresetNoiseLevel() {
    UserAddNoiseIntensity := 30
    GuiControl, SettingsGUIA:, UserAddNoiseIntensity, 30
    updateUIaddNoisePanel()
}

BTNresetFloodClrOpacity() {
    FloodFillClrOpacity := 255
    GuiControl, SettingsGUIA:, FloodFillClrOpacity, 255
    updateUIfloodFillPanel()
}

BTNresetFlooduOpacity() {
    FloodFillOpacity := 255
    GuiControl, SettingsGUIA:, FloodFillOpacity, 255
    updateUIfloodFillPanel()
}

BTNresetFillOpacity() {
    FillAreaOpacity := 255
    GuiControl, SettingsGUIA:, FillAreaOpacity, 255
    If (AnyWindowOpen=66)
       updateUIfloodFillPanel()
    Else If (AnyWindowOpen=27)
       updateUInewImagePanel()
    Else If (AnyWindowOpen=23)
       updateUIfillPanel()
    Else If (AnyWindowOpen=73)
       updateUIresizeImgEditPanel()
}

BTNresetFill2ndOpacity() {
    FillArea2ndOpacity := 255
    GuiControl, SettingsGUIA:, FillArea2ndOpacity, 255
    If (AnyWindowOpen=23)
       updateUIfillPanel()
}

BtnResetVPgridOpacity() {
    vpGridAlpha := 255
    GuiControl, SettingsGUIA:, vpGridAlpha, % vpGridAlpha
    If (AnyWindowOpen=63)
       updateUIgridPanel()
}

BTNresetEraseOpacity() {
    EraseAreaOpacity := isVarEqualTo(AnyWindowOpen, 74, 68, 66) ? 255 : 127
    GuiControl, SettingsGUIA:, EraseAreaOpacity, % EraseAreaOpacity
    If (AnyWindowOpen=66)
       updateUIfloodFillPanel()
    Else If (AnyWindowOpen=25)
       updateUIerasePanel()
    Else If (AnyWindowOpen=68)
       updateUIfillBehindPanel()
    Else If (AnyWindowOpen=74)
       UpdateUIadjustVPcolors()
}

BTNresetFillBehColorOpacity() {
    FillBehindClrOpacity := 255
    GuiControl, SettingsGUIA:, FillBehindClrOpacity, % FillBehindClrOpacity
    updateUIfillBehindPanel()
}

BTNresetBehindOpacity() {
    FillBehindOpacity := 255
    GuiControl, SettingsGUIA:, FillBehindOpacity, 255
    updateUIfillBehindPanel()
}

BTNresetFloodColorTolerance() {
    FloodFillTolerance := 0
    GuiControl, SettingsGUIA:, FloodFillTolerance, % FloodFillTolerance
    updateUIfloodFillPanel()
}

BTNresetEdgesBright() {
    GuiControl, SettingsGUIA:, IDedgesEmphasis, 0
    If (AnyWindowOpen=43)
       updateUIedgesPanel()
    Else If (AnyWindowOpen=44)
       updateUIaddNoisePanel()
}

BTNresetEdgesContrast() {
    GuiControl, SettingsGUIA:, IDedgesContrast, 0
    If (AnyWindowOpen=43)
       updateUIedgesPanel()
    Else If (AnyWindowOpen=44)
       updateUIaddNoisePanel()
}

BtnIDedgesNow() {
    updateUIedgesPanel("no")
    CloseWindow()
    detectEdgesSelectedArea()
}

BtnAddNoiseNow() {
    updateUIaddNoisePanel("no")
    CloseWindow()
    addNoiseSelectedArea()
}

updateUIedgesPanel(dummy:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=43)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    GuiControl, SettingsGUIA:, infoBright, Brightness: %IDedgesEmphasis%
    GuiControl, SettingsGUIA:, infoContrst, Contrast: %IDedgesContrast%`%
    GuiControl, SettingsGUIA:, infoEdgesOpacity, % "Opacity: " Round((IDedgesOpacity / 255) * 100) "%"
    If (dummy!="no")
    {
       SetTimer, WriteSettingsEdgesPanel, -150
       updateLiveTinyPreviewsWindow(dummy, b)
    }
    lastInvoked := A_TickCount
}

updateUIaddNoisePanel(dummy:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=44)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide

    GuiControl, SettingsGUIA:, infoBright, Brightness: %IDedgesEmphasis%
    GuiControl, SettingsGUIA:, infoContrst, Contrast: %IDedgesContrast%`%
    GuiControl, SettingsGUIA:, infoEdgesOpacity, % "Opacity: " Round((IDedgesOpacity / 255) * 100) "%"
    GuiControl, SettingsGUIA:, infoNoiseLvl, % "Noise cut-off: " UserAddNoiseIntensity "%"
    GuiControl, SettingsGUIA:, infoBlurAmount, % "Blur: " UserAddNoiseBlurAmount
    GuiControl, SettingsGUIA:, infoPixelize, % "Pixelize: " UserAddNoIsePixelizeAmount
    If (dummy!="no")
    {
       SetTimer, WriteSettingsAddNoisePanel, -150
       updateLiveTinyPreviewsWindow(dummy, b)
    }
}

PanelNewImage() {
    If (thumbsDisplaying=1)
       Return

    thisBtnHeight := createSettingsGUI(27, A_ThisFunc)
    RegAction(0, "NewDocUseColor",, 1)
    RegAction(0, "PredefinedDocsSizes",, 2, 1, 13)
    RegAction(0, "NewImageReverseDimensions",, 1)
    RegAction(0, "FillAreaColor",, 3)
    RegAction(0, "FillAreaOpacity",, 2, 1, 255)
    If (!UserNewWidth || !UserNewHeight || !UserNewDPI)
       PredefinedDocsSizes := 1
    Else If (UserNewWidth && UserNewHeight &&UserNewDPI)
       PredefinedDocsSizes := 13

    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoResultRes, PickuFillAreaColor
    Gui, Add, Text, x15 y15 Section, Create new RGBA image. Please set image dimensions.
    Gui, Add, DropDownList, y+10 wp gupdateUInewImagePanel AltSubmit Choose%PredefinedDocsSizes% vPredefinedDocsSizes, Viewport size|Screen size|Current image size|640x480|800x600|1024x768|HD 480p|HD 720p|HD 1080p|HD 2160p [4K]|A4 @ 300 dpi|A4 @ 150 dpi|Previously used dimensions
    Gui, Add, Text, xs y+10 w%EditWid%, Width (px)
    Gui, Add, Text, x+1 wp, Height (px)
    Gui, Add, Text, x+1 wp, DPI
    Gui, Add, Edit, xs y+7 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewWidth, % UserNewWidth
    Gui, Add, Edit, x+5 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewHeight, % UserNewHeight
    Gui, Add, Edit, x+5 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewDPI, % UserNewDPI
    Gui, Add, Checkbox, xs y+10 Checked%NewImageReverseDimensions% vNewImageReverseDimensions, Rotate canvas 90° degrees
    Gui, Add, Checkbox, xs y+10 gupdateUInewImagePanel Checked%NewDocUseColor% vNewDocUseColor, Fill background with color
    Gui, Add, ListView, xs y+10 h30 w%editWid% %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P
    Gui, Add, Text, x+5 hp +0x200 vinfoFillAreaOpacity gBTNresetFillOpacity  +TabStop, Opacity: %thisOpacity%00`%
    Gui, Add, Slider, Center xs y+1 hp w%txtWid% gupdateUInewImagePanel ToolTip AltSubmit vFillAreaOpacity Range3-255, % FillAreaOpacity
    ; Gui, Add, Text, xs y+10, Resulted dimensions:
    ; Gui, Add, Text, xs y+10 w%txtWid% vinfoResultRes, --`n--

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnCreateNewImage, &Create new image
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Button, x+25 hp w%btnWid% gOpenNewQPVinstance, &New instance
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "New image: " appTitle)
    SetTimer, updateUInewImagePanel, -150
}

ReadSettingsPrintPanel(act:=0) {
    RegAction(act, "TextInAreaAlign",, 2, 1, 3)
    RegAction(act, "TextInAreaValign",, 2, 1, 3)
    RegAction(act, "TextInAreaFontColor",, 3)
    RegAction(act, "TextInAreaFontName",, 5)
    RegAction(act, "TextInAreaFontBold",, 1)
    RegAction(act, "TextInAreaFontItalic",, 1)
    RegAction(act, "TextInAreaFontUline",, 1)
    RegAction(act, "PrintTxtSize",, 2, 24, 999)
    RegAction(act, "PrintDimensionsXYWH",, 5)
    RegAction(act, "PrintOrientation",, 2, 0, 359)
    RegAction(act, "PrintDoFlipuH",, 1)
    RegAction(act, "PrintDoFlipuV",, 1)
    RegAction(act, "PrintColorMode",, 1)
    RegAction(act, "PrintAdaptToFit",, 1)
    RegAction(act, "PrintUseViewportColors",, 1)
    RegAction(act, "PrintStrechedSize",, 1)
    RegAction(act, "PrintPaperOrient",, 1)
}

PanelPrintImage() {
    Global EditFx, EditFy, EditFw, EditFh, PrintPosTxtX, PrintPosTxtY, PrintPosTxtW, PrintPosTxtH
         , PrintCopies, SelectedPrinteru, PrintDoFlipuH, PrintDoFlipuV, PrinterPageInfos, UserTextArea, editF1, PickuTextInAreaFontColor

    If (thumbsDisplaying=1 || AnyWindowOpen)
       Return

    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

    If StrLen(useGdiBitmap())>2
       viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, useGdiBitmap(), 450, 450, 1, 3, -1)

    thisBtnHeight := createSettingsGUI(57, A_ThisFunc)
    ReadSettingsPrintPanel()
    printDims := StrSplit(PrintDimensionsXYWH, "|")
    PrintPosX := printDims[1]
    PrintPosY := printDims[2]
    PrintPosW := printDims[3]
    PrintPosH := printDims[4]
    
    btnWid := 70
    txtWid := 350
    EditWid := 70
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 25
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    printerlist := SGDIPrint_GetDefaultPrinter() "||" SGDIPrint_EnumPrinters("|") 
    Gui, -DPIScale
    Gui, Add, Text, x20 y20 w248 h351 Section +0x1000 +0xE +hwndhCropCornersPic, Print preview
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, -`n-`n-`n-
    Gui, +DPIScale

    Gui, Add, Tab3, x+20 ys Section, General|Text line

    Gui, Tab, 1
    Gui, Add, Text, x+15 y+15 Section, Please choose printer:
    Gui, Add, DropDownList, y+7 wp+90 gupdatePrintPreview vSelectedPrinteru, %printerlist%
    Gui, Add, Button, x+5 hp gBtnSetPrinterDefault, Set as &default
    Gui, Add, DropDownList, xs y+10 w%EditWid% gupdatePrintPreview AltSubmit Choose%PrintPaperOrient% vPrintPaperOrient, Portrait|Landscape
    Gui, Add, Edit, x+5 w%EditWid% gupdatePrintPreview r1 limit2 +number -multi -wantTab -wrap veditFc, % PrintCopies
    Gui, Add, UpDown, vPrintCopies gupdatePrintPreview Range1-99, % PrintCopies
    Gui, Add, Text, x+5 hp +0x200, copies to print
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintAdaptToFit% vPrintAdaptToFit, Automatically adapt image to cover page
    Gui, Add, Text, xs y+10 vPrintPosTxtY w%EditWid%, Top
    Gui, Add, Text, x+1 vPrintPosTxtX wp, Left
    Gui, Add, Text, x+1 vPrintPosTxtW wp, Width
    Gui, Add, Text, x+1 vPrintPosTxtH wp, Height
    Gui, Add, Text, x+1 wp, Angle
    Gui, Add, Edit, xs y+7 wp gupdatePrintPreview vEditFy number -multi limit3, % PrintPosY
    Gui, Add, UpDown, vPrintPosY Range0-98, % PrintPosY
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vEditFx number -multi limit3, % PrintPosX
    Gui, Add, UpDown, vPrintPosX Range0-98, % PrintPosX
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vEditFw number -multi limit3, % PrintPosW
    Gui, Add, UpDown, vPrintPosW Range2-100, % PrintPosW
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vEditFh number -multi limit3, % PrintPosH
    Gui, Add, UpDown, vPrintPosH Range2-100, % PrintPosH
    Gui, Add, Edit, x+2 wp gupdatePrintPreview number -multi limit3 veditF3, % PrintOrientation
    Gui, Add, UpDown, vPrintOrientation Range0-360, % PrintOrientation
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintStrechedSize% vPrintStrechedSize, &Stretch to given dimensions
    Gui, Add, Checkbox, xs y+10 hp gupdatePrintPreview Checked%PrintDoFlipuH% vPrintDoFlipuH, &Vertical
    Gui, Add, Checkbox, x+10 hp gupdatePrintPreview Checked%PrintDoFlipuV% vPrintDoFlipuV, &Horizontal
    Gui, Add, Text, x+10 hp +0x200, flipped image
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintColorMode% vPrintColorMode, Print &with colors
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintUseViewportColors% vPrintUseViewportColors, Apply &viewport color adjustments

    Gui, Tab, 2
    EditWid2 := (PrefsLargeFonts!=1) ? 290 : 450
    Gui, Add, Text, x+15 y+15 Section, Text to insert on the page:
    Gui, Add, Edit, xs y+5 w%EditWid2% r3 gupdatePrintPreview vUserTextArea limit2048 hwndhEditField, % UserTextArea
    Gui, Add, Text, xs y+15 wp, Font name:
    Gui, Add, DropDownList, xs y+5 wp Sort gupdatePrintPreview Choose1 vTextInAreaFontName, % TextInAreaFontName
    Gui, Add, Text, xs y+15, Text size and color:
    Gui, Add, Edit, xs+0 y+5 w%editWid% gupdatePrintPreview r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF1 , % PrintTxtSize
    Gui, Add, UpDown, vPrintTxtSize gupdatePrintPreview Range25-999, % PrintTxtSize
    Gui, Add, ListView, x+2 w%editWid% hp gupdatePrintPreview %CCLVO% Background%TextInAreaFontColor% vTextInAreaFontColor hwndhLV3,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaFontColor, P
    Gui, Add, Text, xs y+15, Text alignment and style:
    Gui, Add, DropDownList, xs y+5 w%editWid% gupdatePrintPreview Choose%TextInAreaAlign% AltSubmit vTextInAreaAlign, Left|Center|Right
    Gui, Add, DropDownList, x+2 wp gupdatePrintPreview Choose%TextInAreaValign% AltSubmit vTextInAreaValign, Top|Center|Bottom
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontBold% vTextInAreaFontBold, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontItalic% vTextInAreaFontItalic, I
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontUline% vTextInAreaFontUline, U

    Gui, Tab
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnStartPrintingNow, &Print now
    Gui, Add, Button, x+5 hp gBtnOpenPrinterOptions, &More options
    Gui, Add, Button, x+5 hp w80 gBtnCloseWindow, &Cancel

    PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Print image: " appTitle)
    ; SetTimer, updatePrintPreview, -500
}

BtnOpenPrinterOptions() {
   GuiControlGet, SelectedPrinteru
   if (lastSelPrinterName!=SelectedPrinteru)
      printerDevModeOptions := ""

   SGDIPrint_OpenPrintingOptions(SelectedPrinteru, printerDevModeOptions, hSetWinGui)
   lastSelPrinterName := SelectedPrinteru
   updatePrintPreview("extern")
}

BtnSetPrinterDefault() {
   Gui, SettingsGUIA: Default
   GuiControlGet, SelectedPrinteru
   If (lastSelPrinterName!=SelectedPrinteru)
      printerDevModeOptions := ""

   lastSelPrinterName := SelectedPrinteru
   If !SGDIPrint_SetDefaultPrinter(SelectedPrinteru)
      msgBoxWrapper(appTitle ": ERROR", "Failed to set " SelectedPrinteru " as default.", 0, 0, "error")
}

printSettingsObj() {
   Static dmSize := A_IsUnicode ? 68 : 36
        , dmFields := dmSize + 4
        , DM_COPIES := "0x100" , DM_COLOR := "0x800" , DM_ORIENTATION := "0x1"
        , ansiUnicodeOffSet := (A_IsUnicode=1) ? 32 : 0

   If (AnyWindowOpen!=57)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, PrintAdaptToFit
   GuiControlGet, PrintPosX
   GuiControlGet, PrintPosY
   GuiControlGet, PrintPosW
   GuiControlGet, PrintPosH
   GuiControlGet, PrintColorMode
   GuiControlGet, PrintCopies
   GuiControlGet, SelectedPrinteru
   GuiControlGet, PrintOrientation
   GuiControlGet, PrintPaperOrient
   GuiControlGet, PrintDoFlipuH
   GuiControlGet, PrintDoFlipuV
   GuiControlGet, PrintUseViewportColors
   GuiControlGet, TextInAreaAlign
   GuiControlGet, TextInAreaValign
   GuiControlGet, TextInAreaFontName
   GuiControlGet, TextInAreaFontBold
   GuiControlGet, TextInAreaFontItalic
   GuiControlGet, TextInAreaFontUline
   GuiControlGet, PrintTxtSize
   GuiControlGet, PrintStrechedSize
   GuiControlGet, UserTextArea

   PrintOptions := []
   If (lastSelPrinterName!=SelectedPrinteru)
      printerDevModeOptions := ""

   UserTextArea := Trimmer(UserTextArea)
   UserTextArea := allowCtrlBkspEdit(hEditField, UserTextArea)
   If (!printerDevModeOptions)
   {
      pPrinterName := Trim(SelectedPrinteru)
      VarSetCapacity(pPrinter , A_PtrSize, 0)
      out := DllCall("Winspool.drv\OpenPrinter", "UPtr", &pPrinterName, "UPtr*", pPrinter, "Ptr", 0, "Ptr")

      sizeDevMode := DllCall("Winspool.drv\DocumentProperties", "Ptr", PVhwnd, "Ptr", pPrinter, "Ptr", &pPrinterName, "Ptr", 0, "Ptr", 0, "UInt", 0, "Int")
      VarSetCapacity(printerDevModeOptions, sizeDevMode, 0)
      out2 := DllCall("Winspool.drv\DocumentProperties", "Ptr", PVhwnd, "Ptr", pPrinter, "Ptr", &pPrinterName, "UPtr", &printerDevModeOptions, "Ptr", 0, "UInt", 2, "Int")

      updateFields := 0 | DM_COLOR | DM_ORIENTATION | DM_COPIES
      NumPut(PrintPaperOrient, printerDevModeOptions, 44 + ansiUnicodeOffSet, "Short")
      NumPut(Trim(PrintCopies), printerDevModeOptions, 54 + ansiUnicodeOffSet, "Short")
      NumPut(PrintColorMode + 1, printerDevModeOptions, 60 + ansiUnicodeOffSet, "Short")
      NumPut(updateFields, printerDevModeOptions, dmFields, "UInt")
      out3 := DllCall("Winspool.drv\DocumentProperties", "UPtr", PVhwnd, "Ptr", pPrinter, "Ptr", &pPrinterName, "UPtr", &printerDevModeOptions, "UPtr", &printerDevModeOptions, "UInt", 10, "Int") 
      DllCall("ClosePrinter", "Ptr", pPrinter)
   } Else
   {
      NumPut(PrintPaperOrient, printerDevModeOptions, 44 + ansiUnicodeOffSet, "Short")
      NumPut(Trim(PrintCopies), printerDevModeOptions, 54 + ansiUnicodeOffSet, "Short")
      NumPut(PrintColorMode + 1, printerDevModeOptions, 60 + ansiUnicodeOffSet, "Short")
   }

   lastSelPrinterName := SelectedPrinteru
   PrintOptions.pPrinterName := SelectedPrinteru
   PrintOptions.adaptFit := PrintAdaptToFit
   PrintOptions.userImgX := PrintPosX
   PrintOptions.userImgY := PrintPosY
   PrintOptions.userImgW := PrintPosW
   PrintOptions.userImgH := PrintPosH
   PrintOptions.colorsMode := PrintColorMode
   PrintOptions.imgOrient := PrintOrientation
   PrintOptions.paperOrient := PrintPaperOrient
   PrintOptions.copiez := PrintCopies
   PrintOptions.flipuV := PrintDoFlipuH
   PrintOptions.flipuH := PrintDoFlipuV
   PrintOptions.applyFX := PrintUseViewportColors
   PrintOptions.text := Trimmer(UserTextArea)
   PrintDimensionsXYWH := PrintPosX "|" PrintPosY "|" PrintPosW "|" PrintPosH
   SetTimer, WriteSettingsPrintPanel, -200

   act := (PrintAdaptToFit=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % act, PrintPosX
   GuiControl, % act, PrintPosY
   GuiControl, % act, PrintPosW
   GuiControl, % act, PrintPosH
   GuiControl, % act, EditFx
   GuiControl, % act, EditFy
   GuiControl, % act, EditFw
   GuiControl, % act, EditFh
   GuiControl, % act, PrintPosTxtX
   GuiControl, % act, PrintPosTxtY
   GuiControl, % act, PrintPosTxtW
   GuiControl, % act, PrintPosTxtH
   GuiControl, % act, PrintStrechedSize
   Return PrintOptions
}

WriteSettingsPrintPanel() {
    ReadSettingsPrintPanel(1)
}

updatePrintPreview(dummy:=0) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<350)
   {
      SetTimer, updatePrintPreview, -500
      Return
   }

   If (dummy="extern")
   {
      ansiUnicodeOffSet := (A_IsUnicode=1) ? 32 : 0
      DC_Orientation := NumGet(printerDevModeOptions, 44 + ansiUnicodeOffSet, "Short")
      DC_Copies := NumGet(printerDevModeOptions, 54 + ansiUnicodeOffSet, "Short")
      DC_Color := NumGet(printerDevModeOptions, 60 + ansiUnicodeOffSet , "Short")
      PrintCopies := DC_Copies
      PrintPaperOrient := DC_Orientation
      PrintColorMode := DC_Color - 1
      GuiControl, SettingsGUIA: Choose, PrintPaperOrient, % DC_Orientation
      GuiControl, SettingsGUIA:, PrintCopies, % DC_Copies
      GuiControl, SettingsGUIA:, PrintColorMode, % DC_Color - 1
   }

   PrintOptions := printSettingsObj()
   printImageNow(viewportStampBMP, PrintOptions, 1)
   lastInvoked := A_TickCount
}

BtnStartPrintingNow() {
   PrintOptions := printSettingsObj()
   WriteSettingsPrintPanel()
   BtnCloseWindow()
   Sleep, 2
   showTOOLtip("Please wait, preparing to print image")
   Sleep, 2
   printImageNow(useGdiBitmap(), PrintOptions, 0)
   Sleep, 2
   RemoveTooltip()
}

PanelIMGselProperties() {
    If (thumbsDisplaying=1)
       Return

    If (imgEditPanelOpened=1 && AnyWindowOpen && thumbsDisplaying=0)
       postVectorWinOpen := AnyWindowOpen

    zz := postVectorWinOpen
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(34, A_ThisFunc)
    postVectorWinOpen := zz
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := EditWid//2 - 2
    Global NewPosX1, NewPosY1, NewPosX2, NewPosY2, NewVProt
         , BtnPosX1m, BtnPosX1p, BtnPosY1m, BtnPosY1p, BtnPosX2m, BtnPosX2p, BtnPosY2m, BtnPosY2p
         , BtnPosXm, BtnPosXp, BtnPosYm, BtnPosYp, BtnPosZm, BtnPosZp

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    Gui, Add, Text, x15 y15 Section, Current image size: %imgW% x %imgH% px.
    Gui, Add, Checkbox, y+7 gupdateUIselPropPanel Checked%userDefinedSelCoords% vuserDefinedSelCoords, Define image selection coordinates in:
    sml := (PrefsLargeFonts=1) ? 150 : 90
    Gui, Add, DropDownList, x+1 w%sml% AltSubmit gupdateUIchangeSelectionType vSelectionCoordsType, Pixels||Percentages
    Gui, Add, Text, xs+15 y+10 w%EditWid% vtxtLine1, X1
    Gui, Add, Text, x+3 wp vtxtLine2, Y1
    Gui, Add, Text, x+3 wp vtxtLine3, X2
    Gui, Add, Text, x+3 wp vtxtLine4, Y2
    Gui, Add, Text, x+3 wp, Rotation
    Gui, Add, Edit, xs+15 y+7 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosX1, % imgSelX1
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosY1, % imgSelY1
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosX2, % imgSelX2
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosY2, % imgSelY2
    Gui, Add, ComboBox, x+3 wp limit9 -multi -wrap gupdateUIselPropPanel vNewVProt, 0|45|90|105|135|150|180|200|225|250|270|300|315|%VPselRotation%||
    Gui, Add, Text, xs y+10, Adjust current selection coordinates:
    Gui, Add, Button, xs+15 y+7 w%btnWid2% gOffsetSelProperPanel vbtnFldr6, &Align
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosX1m, X1
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosY1m, Y1
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosX2m, X2
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosY2m, Y2
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosXm, V
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosYm, H
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp+10 gOffsetSelProperPanel vBtnPosZm, Size
    Gui, Add, Checkbox, xs y+15 gupdateUIselPropPanel Checked%LimitSelectBoundsImg% vLimitSelectBoundsImg, &Limit selection to image boundaries
    Gui, Add, Checkbox, xs y+10 gupdateUIselPropPanel Checked%rotateSelBoundsKeepRatio% vrotateSelBoundsKeepRatio, &Keep aspect ratio on rotation
    Gui, Add, Text, xs y+10 hp +0x200, Lock aspect ratio
    thisW := (PrefsLargeFonts=1) ? 190 : 120
    Gui, Add, DropDownList, x+10 w%thisW% gupdateUIselPropPanel AltSubmit Choose%lockSelectionAspectRatio% vlockSelectionAspectRatio, Unlocked|Current selection ratio|Current window|Current image|Square [1:1]|SDTV [4:3]|35mm film [3:2]|HDTV [16:9]|Wide screens [16:10]|Phone
    ; ToggleEditImgSelection("show-edit")
    ; dummyTimerDelayiedImageDisplay(50)

    thisW := (PrefsLargeFonts=1) ? 125 : 80
    Gui, Add, Button, xs y+25 w%thisW% h%thisBtnHeight% gBTNselectEntireImg, &Select all
    Gui, Add, Button, x+10 wp hp gBTNselectNoneImg, &Select none
    thisW := (PrefsLargeFonts=1) ? 80 : 60
    If postVectorWinOpen
       Gui, Add, Button, x+10 w%thisW% hp gBTNopenPrevPanel Default, &Back
    Else
       Gui, Add, Button, x+10 w%thisW% hp gBtnCloseWindow Default, &Close
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Selection properties: " appTitle, winPos)
    ; SetTimer, updateUIselPropPanel, -350
    updateUIselPropPanel()
}

BTNselectNoneImg() {
   BtnCloseWindow()
   editingSelectionNow := 0
   updateUIctrl()
   MouseMoveResponder()
   dummyTimerDelayiedImageDisplay(50)
}

dummyOffsetSelProperPanel() {
    If (determineLClickstate()=1)
    {
       SetTimer, dummyOffsetSelProperPanel, -25
       OffsetSelProperPanel("usePrev")
    }
}

updateUIselEditsPropPanel() {
   If (SelectionCoordsType=1)
   {
      GuiControl, SettingsGUIA:, NewPosX1, % imgSelX1
      GuiControl, SettingsGUIA:, NewPosY1, % imgSelY1
      GuiControl, SettingsGUIA:, NewPosX2, % imgSelX2
      GuiControl, SettingsGUIA:, NewPosY2, % imgSelY2
   } Else
   {
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      X1 := Round(imgSelX1 / imgW*100, 2)
      Y1 := Round(imgSelY1 / imgH*100, 2)
      X2 := Round(imgSelX2 / imgW*100, 2)
      Y2 := Round(imgSelY2 / imgH*100, 2)
 
      GuiControl, SettingsGUIA:, NewPosX1, % X1
      GuiControl, SettingsGUIA:, NewPosY1, % Y1
      GuiControl, SettingsGUIA:, NewPosX2, % X2
      GuiControl, SettingsGUIA:, NewPosY2, % Y2
   }
}

OffsetSelProperPanel(dummy:=0) {
   Static prevVaru, lastInvoked := 1
   If (AnyWindowOpen!=34)
      Return

   GuiControlGet, SelectionCoordsType
   stepu := (A_TickCount - lastInvoked<350) ? 4 : 2
   If (dummy!="usePrev")
      ; GuiControlGet, varu, SettingsGUIA: FocusV
      ControlGetText, varu,, ahk_id %dummy%
   Else
      varu := prevVaru

   If (varu="&align")
   {
      deleteMenus()
      createMenuSelectionAlign()
      showThisMenu("PVselAlign")
      SetTimer, updateUIselEditsPropPanel, -250
      Return
   }

   cX := 0, cY := 0
   GetPhysicalCursorPos(oX, oY)
   setwhileLoopExec(1)
   ToolTip, Move up/down relative to this point on screen to adjust %varu%
   While, (determineLClickstate()=1 || A_Index=1)
   {
      GetPhysicalCursorPos(mX, mY)
      dir := (oY<mY) ? -1 : 1
      If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
         Continue

      cX := mX, cY := mY
      stepu := (A_Index>50) ? 4 : 2
      If (varu="H")
      {
         arrowKeysAdjustSelectionArea(dir * -1, 1, stepu, 1)
         arrowKeysAdjustSelectionArea(dir * -1, 2, stepu, 1)
      } Else If (varu="V")
      {
         arrowKeysAdjustSelectionArea(dir * -2, 1, stepu, 1)
         arrowKeysAdjustSelectionArea(dir * -2, 2, stepu, 1)
      } Else If (varu="size")
         changeSelectZoom(dir, 1)
      Else If (varu="X1")
         arrowKeysAdjustSelectionArea(dir * -1, 1, stepu, 1)
      Else If (varu="Y1")
         arrowKeysAdjustSelectionArea(dir * -2, 1, stepu, 1)
      Else If (varu="X2")
         arrowKeysAdjustSelectionArea(dir * -1, 2, stepu, 1)
      Else If (varu="Y2")
         arrowKeysAdjustSelectionArea(dir * -2, 2, stepu, 1)

      updateUIselEditsPropPanel()
   }
   setwhileLoopExec(0)
   Tooltip
   lastInvoked := A_TickCount
   prevVaru := varu
   SetTimer, updateUIselEditsPropPanel, -150
   SetTimer, dummyOffsetSelProperPanel, -250
}

updateUIchangeSelectionType() {
   If (AnyWindowOpen!=34)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, SelectionCoordsType
   GuiControlGet, userDefinedSelCoords
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   GuiControl, SettingsGUIA:, NewPosX1, 0
   GuiControl, SettingsGUIA:, NewPosY1, 0
   If (SelectionCoordsType=1)
   {
      GuiControl, SettingsGUIA:, NewPosX2, % imgW//2
      GuiControl, SettingsGUIA:, NewPosY2, % imgH//2
   } Else
   {
      GuiControl, SettingsGUIA:, NewPosX2, 50
      GuiControl, SettingsGUIA:, NewPosY2, 50
   }
   updateUIselPropPanel()
}

BTNselectEntireImg() {
   BtnCloseWindow()
   selectEntireImage()
}

updateUIselPropPanel() {
   If (AnyWindowOpen!=34)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, NewPosX1, SettingsGUIA:, NewPosX1
   GuiControlGet, NewPosY1, SettingsGUIA:, NewPosY1
   GuiControlGet, NewPosX2, SettingsGUIA:, NewPosX2
   GuiControlGet, NewPosY2, SettingsGUIA:, NewPosY2
   GuiControlGet, NewVProt, SettingsGUIA:, NewVProt
   GuiControlGet, lockSelectionAspectRatio, SettingsGUIA:, lockSelectionAspectRatio
   GuiControlGet, userDefinedSelCoords, SettingsGUIA:, userDefinedSelCoords
   GuiControlGet, SelectionCoordsType, SettingsGUIA:, SelectionCoordsType
   GuiControlGet, LimitSelectBoundsImg, SettingsGUIA:, LimitSelectBoundsImg
   GuiControlGet, rotateSelBoundsKeepRatio, SettingsGUIA:, rotateSelBoundsKeepRatio
   
   If (lockSelectionAspectRatio>1)
   {
      userDefinedSelCoords := 0
      LimitSelectBoundsImg := 0
      GuiControl, SettingsGUIA:, userDefinedSelCoords, 0
      GuiControl, SettingsGUIA:, LimitSelectBoundsImg, 0
      GuiControl, SettingsGUIA: Disable, userDefinedSelCoords
      GuiControl, SettingsGUIA: Disable, LimitSelectBoundsImg
   } Else
   {
      GuiControl, SettingsGUIA: Enable, userDefinedSelCoords
      GuiControl, SettingsGUIA: Enable, LimitSelectBoundsImg
   }

   defineSelectionAspectRatios()
   ; ToggleEditImgSelection("show-edit")
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   actuA := (userDefinedSelCoords=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   INIaction(1, "LimitSelectBoundsImg", "General")
   ; If (userDefinedSelCoords=1)
   ;    lockSelectionAspectRatio := 0

   If (lockSelectionAspectRatio>1)
   {
      GuiControl, SettingsGUIA: Disable, BtnPosX1m
      GuiControl, SettingsGUIA: Disable, BtnPosX2m
   } Else
   {
      GuiControl, % actuA, BtnPosX1m
      GuiControl, % actuA, BtnPosX2m
   }

   GuiControl, % actuA, btnFldr6
   GuiControl, % actuA, BtnPosY1m
   GuiControl, % actuA, BtnPosY2m
   GuiControl, % actuA, BtnPosXm
   GuiControl, % actuA, BtnPosYm
   GuiControl, % actuA, BtnPosZm

   actuB := (userDefinedSelCoords=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actuB, txtLine1
   GuiControl, % actuB, txtLine2
   GuiControl, % actuB, txtLine3
   GuiControl, % actuB, txtLine4
   GuiControl, % actuB, NewPosX1
   GuiControl, % actuB, NewPosY1
   GuiControl, % actuB, NewPosX2
   GuiControl, % actuB, NewPosY2
   GuiControl, % actuB, SelectionCoordsType
   If (userDefinedSelCoords=1)
   {
      If (SelectionCoordsType=1)
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := imgW//2
         If !IsNumber(NewPosY2)
            NewPosY2 := imgH//2
         imgSelX1 := Round(NewPosX1), imgSelY1 := Round(NewPosY1)
         imgSelX2 := Round(NewPosX2), imgSelY2 := Round(NewPosY2)
      } Else
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := 50
         If !IsNumber(NewPosY2)
            NewPosY2 := 50
         wNewPosX1 := min(NewPosX1, NewPosX2)
         wNewPosX2 := max(NewPosX1, NewPosX2)

         wNewPosY1 := min(NewPosY1, NewPosY2)
         wNewPosY2 := max(NewPosY1, NewPosY2)
         imgSelX1 := Round(imgW*(Abs(wNewPosX1)/100), 3), imgSelY1 := Round(imgH*(Abs(wNewPosY1)/100), 3)
         imgSelX2 := Round(imgW*(Abs(wNewPosX2)/100), 3), imgSelY2 := Round(imgH*(Abs(wNewPosY2)/100), 3)
      }
   }

   If !IsNumber(NewVProt)
      NewVProt := 0

   VPselRotation := clampInRange(Round(NewVProt), 0, 360, 1)
   dummyTimerDelayiedImageDisplay(50)
   Return
}

updateUInewImagePanel() {
    If (AnyWindowOpen!=27)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, PredefinedDocsSizes
    GuiControlGet, NewDocUseColor
    GuiControlGet, FillAreaOpacity
    GuiControlGet, NewImageReverseDimensions

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoFillAreaOpacity, Opacity: %thisOpacity%`%
    actu := (NewDocUseColor=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, infoFillAreaOpacity
    GuiControl, % actu, FillAreaOpacity
    GuiControl, % actu, FillAreaColor
    GuiControl, % actu, PickuFillAreaColor

    GetPresetDocSizes(PredefinedDocsSizes, UserNewWidth, UserNewHeight, UserNewDPI)
    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := FillAreaOpacity
    If (PredefinedDocsSizes<13)
    {
       GuiControl, SettingsGUIA:, UserNewWidth, % UserNewWidth
       GuiControl, SettingsGUIA:, UserNewHeight, % UserNewHeight
       GuiControl, SettingsGUIA:, UserNewDPI, % UserNewDPI
    }
}

GetPresetDocSizes(docSize, ByRef UserNewWidth, ByRef UserNewHeight, ByRef UserNewDPI) {
    If (docSize=1)
    {
       GetWinClientSize(UserNewWidth, UserNewHeight, PVhwnd, 0)
       UserNewDPI := A_ScreenDPI
    } Else If (docSize=2)
    {
       calcScreenLimits()
       UserNewWidth := ResolutionWidth
       UserNewHeight := ResolutionHeight
       UserNewDPI := A_ScreenDPI
    } Else If (docSize=3)
    {
       If useGdiBitmap()
       {
          Gdip_BitmapGetDPIResolution(useGdiBitmap(), dpix, dpiy)
          Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
          UserNewDPI := (dpix + dpiy)//2
       } Else
       {
          GetWinClientSize(imgW, imgH, PVhwnd, 0)
          UserNewDPI := A_ScreenDPI
       }
       UserNewWidth := imgW
       UserNewHeight := imgH
    } Else If (docSize=4)
    {
       UserNewWidth := 640
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (docSize=5)
    {
       UserNewWidth := 800
       UserNewHeight := 600
       UserNewDPI := 72
    } Else If (docSize=6)
    {
       UserNewWidth := 1024
       UserNewHeight := 768
       UserNewDPI := 72
    } Else If (docSize=7)
    {
       UserNewWidth := 858
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (docSize=8)
    {
       UserNewWidth := 1280
       UserNewHeight := 720
       UserNewDPI := 72
    } Else If (docSize=9)
    {
       UserNewWidth := 1920
       UserNewHeight := 1080
       UserNewDPI := 72
    } Else If (docSize=10)
    {
       UserNewWidth := 3860
       UserNewHeight := 2160
       UserNewDPI := 72
    } Else If (docSize=11)
    {
       UserNewWidth := 2480
       UserNewHeight := 3508
       UserNewDPI := 300
    } Else If (docSize=12)
    {
       UserNewWidth := 1240
       UserNewHeight := 1754
       UserNewDPI := 150
    } Else If (docSize=14)
    {
       UserNewWidth := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
       UserNewHeight := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
       UserNewDPI := 72
    }
}

NewImageEditResponder() {
   If (AnyWindowOpen!=27)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, UserNewWidth
   GuiControlGet, UserNewHeight
   GuiControlGet, UserNewDPI
   GuiControlGet, whichFocused, FocusV

   If (whichFocused="UserNewWidth" || whichFocused="UserNewHeight" || whichFocused="UserNewDPI")
   {
      PredefinedDocsSizes := 13
      GuiControl, SettingsGUIA: Choose, PredefinedDocsSizes, 13
   }
}

BtnCreateNewImage() {
    Static clippyCount
    If (AnyWindowOpen!=27)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, UserNewWidth
    GuiControlGet, UserNewHeight
    GuiControlGet, UserNewDPI
    GuiControlGet, NewDocUseColor
    GuiControlGet, FillAreaOpacity
    GuiControlGet, NewImageReverseDimensions

    If (UserNewWidth<5 || UserNewHeight<5 || UserNewDPI<5)
    {
       SoundBeep, 300, 100
       showTOOLtip("WARNING: Incorrect dimensions provided for the new image")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If isImgSizeTooLarge(UserNewWidth, UserNewHeight)
    {
       SoundBeep, 300, 100
       showTOOLtip("ERROR: The document dimensions exceed the maximum limits")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    RegAction(1, "NewDocUseColor")
    RegAction(1, "PredefinedDocsSizes")
    RegAction(1, "NewImageReverseDimensions")
    RegAction(1, "FillAreaColor")
    RegAction(1, "FillAreaOpacity")

    DestroyGIFuWin()
    BtnCloseWindow()
    If askAboutFileSave(" and new image will be created")
       Return

    PredefinedDocsSizes := 13
    showTOOLtip("Creating the new image, please wait")
    setImageLoading()
    calcScreenLimits()
    mustOpenStartFolder := ""
    terminateIMGediting()
    discardViewPortCaches()
    clippyCount++
    If (NewImageReverseDimensions=1)
    {
       tUserNewWidth := UserNewHeight
       tUserNewHeight := UserNewWidth
    } Else
    {
       tUserNewWidth := UserNewWidth
       tUserNewHeight := UserNewHeight
    }

    UserMemBMP := trGdip_CreateBitmap(A_ThisFunc, tUserNewWidth, tUserNewHeight, coreDesiredPixFmt)
    If warnUserFatalBitmapError(UserMemBMP, A_ThisFunc)
    {
       showTOOLtip("Failed to create new image")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       clippyCount--
       Return
    }

    Gdip_BitmapSetResolution(UserMemBMP, UserNewDPI, UserNewDPI)
    If (NewDocUseColor=1)
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, UserMemBMP)
       Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
       thisColor := Gdip_ToARGB(FillAreaOpacity, R, G, B)
       trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       Gdip_DeleteGraphics(G2)
    }

    If (!currentFileIndex || !CurrentSLD || !maxFilesIndex)
    {
       maxFilesIndex := currentFileIndex := 0
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\New-" clippyCount ".img"
    }

    currIMGdetails.HasAlpha := 1
    If (NewDocUseColor=1 && FillAreaOpacity>253)
       currIMGdetails.HasAlpha := 0

    imgIndexEditing := currentFileIndex
    currentImgModified := usrColorDepth := imgFxMode := 1
    vpIMGrotation := FlipImgH := FlipImgV := 0
    dropFilesSelection(1)
    RemoveTooltip()
    RefreshImageFile()
    SetTimer, createGUItoolbar, -100
    SetTimer, TriggerMenuBarUpdate, -90
    SetTimer, ResetImgLoadStatus, -50
}

BtnDrawLinesSelectedArea() {
  If throwErrorSelectionOutsideBounds()
     Return

  updateUIDrawLinesPanel("noPreview")
  GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply

  If (DrawLineAreaBorderTop=0 && DrawLineAreaBorderBottom=0 && DrawLineAreaBorderLeft=0 && DrawLineAreaBorderRight=0
  && DrawLineAreaBorderCenter=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=0)
  {
     SoundBeep , 300, 100
     showTOOLtip("WARNING: No lines to draw selected")
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
  If (closeEditPanelOnApply=1)
     BtnCloseWindow()

  Sleep, 1
  prevImgEditZeit := A_TickCount
  ToggleEditImgSelection("show-edit")
  DrawLinesInSelectedArea(1)
  prevImgEditZeit := A_TickCount
  SetTimer, RemoveTooltip, -250
}

updateUIDrawLinesPanel(actionu:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=30)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide

    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoDrawLineAreaOpacity, Opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
    ; ToggleEditImgSelection("show-edit")
    If (DrawLineAreaBorderTop=0 && DrawLineAreaBorderBottom=0 && DrawLineAreaBorderLeft=0 && DrawLineAreaBorderRight=0
    && DrawLineAreaBorderCenter=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=0)
    {
       dummyRefreshImgSelectionWindow()
    } Else If (actionu!="noPreview") && (A_TickCount - lastInvoked>50)
    {
       lastInvoked := A_TickCount
       livePreviewsImageEditing(0, 0, A_ThisFunc, actionu, b)
    }

    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := DrawLineAreaOpacity
    SetTimer, WriteSettingsDrawLinesPanel, -250
}

WriteSettingsDrawLinesPanel() {
    ReadSettingsDrawLinesArea(1)
}

updateUIdrawShapesPanel(actionu:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=65)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide

    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoDrawLineAreaOpacity, %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
    decideCustomShapeStyle()
    actu := (FillAreaShape=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, FillAreaClosedPath
    GuiControl, % actu, FillAreaCurveTension
    If (FillAreaShape=3)
       EllipseSelectMode := 1
    Else If (FillAreaShape=7)
       EllipseSelectMode := 2
    Else
       EllipseSelectMode := 0

    closedLineCustomShape := FillAreaClosedPath
    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := DrawLineAreaOpacity
    ; ToggleEditImgSelection("show-edit")
    If (actionu!="noPreview") && (A_TickCount - lastInvoked>50)
    {
       lastInvoked := A_TickCount
       livePreviewsImageEditing(0, 0, A_ThisFunc, actionu, b)
    }
    SetTimer, dummyRefreshImgSelectionWindow, -50
    SetTimer, WriteSettingsDrawShapeAreaPanel, -250
}

updateUIzoomBlurPanel(a:=0,b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=69)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    GuiControlGet, uizoomBlurAreaXamount
    If (coreDesiredPixFmt="0x21808")
    {
       BlurAreaBlendMode := 0
       GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Disable, BlurAreaBlendMode
       GuiControl, SettingsGUIA: Choose, BlurAreaBlendMode, 1
    }

    actu2 := (BlurAreaBlendMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, BlurAreaLight
    GuiControl, % actu2, BlurAreaGamma
    GuiControl, % actu2, BlurAreaHue
    GuiControl, % actu2, BlurAreaSaturation
    GuiControl, % actu2, infoBlurLight
    GuiControl, % actu2, infoBlurGamma
    GuiControl, % actu2, infoBlurHue
    GuiControl, % actu2, infoBlurSat
    GuiControl, SettingsGUIA:, infoBlurHue, Hue: %BlurAreaHue%°
    GuiControl, SettingsGUIA:, infoBlurSat, Saturation: %BlurAreaSaturation%`%
    GuiControl, SettingsGUIA:, infoBlurLight, Brightness: %BlurAreaLight%
    GuiControl, SettingsGUIA:, infoBlurGamma, Contrast: %BlurAreaGamma%`%

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    thisuX := Round(uizoomBlurAreaXamount/10, 1)
    zoomBlurAreaXamount := uizoomBlurAreaXamount/10
    GuiControl, SettingsGUIA:, infoBlurOpacity, Opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoZoomX, Intensity: %thisuX%
    lastInvoked := A_TickCount
    SetTimer, WriteSettingsZoomBlurPanel, -300
    updateLiveTinyPreviewsWindow(a, b)
}

updateUIblurPanel(a:=0,b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=26)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (coreDesiredPixFmt="0x21808")
    {
       blurAreaSoftEdges := 0
       BlurAreaBlendMode := 0
       GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Disable, BlurAreaBlendMode
       GuiControl, SettingsGUIA: Choose, BlurAreaBlendMode, 1
       GuiControl, SettingsGUIA:, blurAreaSoftEdges, 0
    }

    actu := (blurAreaPixelizeAmount>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, blurAreaPixelizeMethod
    If (blurAreaAmount>1)
    {
       GuiControl, SettingsGUIA: Enable, blurAreaMode
       GuiControl, SettingsGUIA: Enable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Enable, blurAreaSoftLevel
       If (blurAreaSoftEdges=1)
          GuiControl, SettingsGUIA: Enable, blurAreaTwice
    } Else
    {
       GuiControl, SettingsGUIA: Disable, blurAreaMode
       GuiControl, SettingsGUIA: Disable, blurAreaTwice
       GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Disable, blurAreaSoftLevel
    }

    actu := (blurAreaSoftEdges=1 && blurAreaAmount>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, blurAreaSoftLevel

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoBlurOpacity, Opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoBlurAmount, Blur amount: %blurAreaAmount%
    GuiControl, SettingsGUIA:, infoPixelize, Pixelize level: %blurAreaPixelizeAmount%

    actu2 := (BlurAreaBlendMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, BlurAreaLight
    GuiControl, % actu2, BlurAreaGamma
    GuiControl, % actu2, BlurAreaHue
    GuiControl, % actu2, BlurAreaSaturation
    GuiControl, % actu2, infoBlurLight
    GuiControl, % actu2, infoBlurGamma
    GuiControl, % actu2, infoBlurHue
    GuiControl, % actu2, infoBlurSat
    GuiControl, SettingsGUIA:, infoBlurHue, Hue: %BlurAreaHue%°
    GuiControl, SettingsGUIA:, infoBlurSat, Saturation: %BlurAreaSaturation%`%
    GuiControl, SettingsGUIA:, infoBlurLight, Brightness: %BlurAreaLight%
    GuiControl, SettingsGUIA:, infoBlurGamma, Contrast: %BlurAreaGamma%`%

    lastInvoked := A_TickCount
    updateLiveTinyPreviewsWindow(a, b)
    SetTimer, WriteSettingsBlurPanel, -300
}

PanelsLivePreviewResponder(a, b, c) {
   ; ToolTip, % a "=" b "=" c , , , 2
   SetTimer, PanelsPanIMGpreviewClick, -15
}

PanelsPanIMGpreviewClick() {
   Static noPreview := 0
   keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0
   If (AnyWindowOpen=64 && (BrushToolType=2 || BrushToolType=4))
   {
      GetPhysicalCursorPos(zX, zY)
      setwhileLoopExec(1)
      While, (determineLClickstate()=1)
      {
         Sleep, 1
         If !keysState
            keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

         GetPhysicalCursorPos(mX, mY)
         If (isInRange(mX, zX - 2, zX + 2) && isInRange(mY, zY - 2, zY + 2))
            Continue

         If (mX>zX)
            alphaMaskOffsetX += 0.05
         Else If (mX<zX)
            alphaMaskOffsetX -= 0.05
         If (mY>zY)
            alphaMaskOffsetY += 0.05
         Else If (mY<zY)
            alphaMaskOffsetY -= 0.05

         alphaMaskOffsetX := clampInRange(alphaMaskOffsetX, -0.9, 0.9)
         alphaMaskOffsetY := clampInRange(alphaMaskOffsetY, -0.9, 0.9)
         zX := mX, zY := mY
         Sleep, 2
         createLivePreviewBrush()
      }

      setwhileLoopExec(0)
      ; ToolTip, % vPosX "==" vPosY "`n" alphaMaskOffsetX "==" alphaMaskOffsetY , , , 2
      If (keysState=1)
         alphaMaskOffsetX := alphaMaskOffsetY := 0

      If (AnyWindowOpen=64)
         SetTimer, updateUIbrushTool, -150
      Return
   }

   If (AnyWindowOpen=64 && !(BrushToolType=3 || BrushToolType=5))
      Return

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Sleep, 0
   GetPhysicalCursorPos(oX, oY)
   newPosZeit := A_TickCount
   oDx := tinyPrevAreaCoordX, oDy := tinyPrevAreaCoordY
   zX := oX, zY := oY
   thisZeit := A_TickCount
   hasRun := 0
   setwhileLoopExec(1)
   While, (determineLClickstate()=1)
   {
      Sleep, 1
      If !keysState
         keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

      GetPhysicalCursorPos(mX, mY)
      skipLoop := (isInRange(mX, zX - 2, zX + 2) && isInRange(mY, zY - 2, zY + 2)) ? 1 : 0
      Dx := mX - oX + 1
      Dy := mY - oY + 1
      tinyPrevAreaCoordX := oDx - Dx
      tinyPrevAreaCoordY := oDy - Dy
      tinyPrevAreaCoordX := clampInRange(tinyPrevAreaCoordX, 120, imgW)
      tinyPrevAreaCoordY := clampInRange(tinyPrevAreaCoordY, 120, imgH)

      ; ToolTip, % diffIMGdecX "--" diffIMGdecY " || " IMGdecalageX "--" IMGdecalageY " || " odX "--" odY , , , 2
      If (A_TickCount - newPosZeit>750) || (mX=oX && mY=oY)
      {
         newPosZeit := A_TickCount
         zX := mX, zY := mY
         If (skipLoop=1)
            Continue
      } Else If (skipLoop=1)
         Continue

      If (A_TickCount - thisZeit>15)
      {
         hasRun := 1
         noPreview := 0
         ; If (A_TickCount - thisZeit>95)
         ; zeitSillyPrevent := A_TickCount
         coreUpdateLiveTinyPreviewsWindow()
         dummyRefreshImgSelectionWindow()
         thisZeit := A_TickCount
      }
   }
   setwhileLoopExec(0)
   If !keysState
      keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

   If (keysState=1 && hasRun=0 && noPreview=0)
   {
      noPreview := 1
      livePreviewsPanelNoEffects()
   } Else If !hasRun
   {
      If (noPreview=0)
         doubleBlurPreviewArea := !doubleBlurPreviewArea

      noPreview := 0
      If (AnyWindowOpen=26)
         updateUIblurPanel()
      Else If (AnyWindowOpen=43)
         updateUIedgesPanel()
      Else If (AnyWindowOpen=44)
         updateUIaddNoisePanel()
      Else If (AnyWindowOpen=69)
         updateUIzoomBlurPanel()
   }
}

livePreviewBlurPanel() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    WriteSettingsBlurPanel()
    whichBmp := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    fnOutputDebug("redraw: " A_ThisFunc)
    Gdip_GetImageDimensions(whichBmp, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    thisBlurMode := blurAreaMode
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    thisOpacity := blurAreaOpacity/255
    thisBlurAmount := (doubleBlurPreviewArea=1) ? blurAreaAmount//2 : blurAreaAmount
    If (thisBlurMode=1)
       bEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
    Else If (thisBlurMode=2)
       bEffect := Gdip_CreateEffect(1, Round(thisBlurAmount*0.85), 0, 0)

    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    If (BlurAreaBlendMode>1)
       bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, cornersBMP)

    If pEffect
       Gdip_BitmapApplyEffect(cornersBMP, pEffect)

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    r1 := trGdip_DrawImage(A_ThisFunc, G, zBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize, uiboxSize, 1, 2, imageAttribs)
    yBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    If (blurAreaPixelizeAmount>1)
    {
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
       QPV_PixelateBitmap(yBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, uiboxSize))
       prevBMPu := yBitmap
       yBitmap:= pixiBMP
    }

    Gdip_DisposeImageAttributes(imageAttribs)
    If (blurAreaTwice=1)
    {
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, uiboxSize//2, uiboxSize//2, 1, 3, -1)
       If xBitmap
       {
          prevBMPa := yBitmap
          yBitmap := xBitmap
       }

       If (bEffect && (thisBlurMode=1 || thisBlurMode=2))
          ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
       Else If (thisBlurMode=3)
          QPV_BoxBlurBitmap(yBitmap, Round(thisBlurAmount/2))

       cBitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, uiboxSize, uiboxSize, 1, 3, -1)
       If cBitmap
       {
          prevBMPc := yBitmap
          yBitmap := cBitmap
          sF := 1
       } Else sF := 1
    } Else sF := 1

    If (bEffect && (thisBlurMode=1 || thisBlurMode=2))
       ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
    Else If (thisBlurMode=3)
       QPV_BoxBlurBitmap(yBitmap, Round(thisBlurAmount/2))

    If (BlurAreaBlendMode>1)
    {
       applyBlurColorsFX(yBitmap)
       rz := QPV_BlendBitmaps(bgrBMPu, yBitmap, BlurAreaBlendMode - 1, 0)
       ; ToolTip, % "l=" rz , , , 2
       ou := yBitmap
       yBitmap := bgrBMPu
       bgrBMPu := ou
    }

    ; thisBMP := (BlurAreaBlendMode>1) ? bgrBMPu : cornersBMP
    r1 := trGdip_DrawImage(A_ThisFunc, G, yBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize // sF, uiboxSize // sF, thisOpacity)
    flipBitmapAccordingToViewPort(cornersBMP, 1)
    If (r1!="fail")
       hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)

    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    Gdip_DeleteGraphics(G)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(yBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    trGdip_DisposeImage(prevBMPu, 1)
    trGdip_DisposeImage(prevBMPa, 1)
    trGdip_DisposeImage(prevBMPc, 1)
    trGdip_DisposeImage(cornersBMP, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(bEffect)
}

livePreviewZoomBlurPanel() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBmp := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    fnOutputDebug("redraw: " A_ThisFunc)
    Gdip_GetImageDimensions(whichBmp, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    thisOpacity := blurAreaOpacity/255
    thisBlurAmount := (doubleBlurPreviewArea=1) ? zoomBlurAreaXamount*2 : zoomBlurAreaXamount*4

    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    If (BlurAreaBlendMode>1)
       bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, cornersBMP)

    If pEffect
       Gdip_BitmapApplyEffect(cornersBMP, pEffect)

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    r1 := trGdip_DrawImage(A_ThisFunc, G, zBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize, uiboxSize, 1, 2, imageAttribs)
    yBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)

    Gdip_DisposeImageAttributes(imageAttribs)
    thisBlurAmount := clampInRange(5 + Round(zoomBlurAreaXamount/2) - 2, 5, 20) ; A_Index * thisBlur
    If (doubleBlurPreviewArea=1)
       thisBlurAmount := thisBlurAmount//2 + 1

    opEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
    gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, yBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    G3 := trGdip_GraphicsFromImage(A_ThisFunc, gBitmap, 5)
    thisO := 0.85
    imgSelPx := imgSelPy := 0
    dimgSelPx := dimgSelPy := 0
    imgSelW := imgSelH := uiboxSize
    dimgSelW := dimgSelH := uiboxSize

    b := (doubleBlurPreviewArea=1) ? zoomBlurAreaXamount/3 : zoomBlurAreaXamount/2
    If isInRange(zoomBlurMode, 1, 3)
    {
       Loop
       {
          thisO -= 0.1 ; thisOpacity - (A_Index - 1) * startOpacity
          If (thisO<0)
             Break

          ; showTOOLtip("Zoom blur: step " A_Index,, , (1 - thisO)/1)
          ; fnOutputDebug(thisBlurAmount "=" thisO)
          ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, opEffect)
          If (zoomBlurMode=1 || zoomBlurMode=2)
             dimgSelW += A_Index * b*2
          If (zoomBlurMode=1 || zoomBlurMode=3)
             dimgSelH += A_Index * b*2

          If (zoomBlurMode=1 || zoomBlurMode=2)
             dimgSelPx -= A_Index * b
          If (zoomBlurMode=1 || zoomBlurMode=3)
             dimgSelPy -= A_Index * b

          r1 := trGdip_DrawImage(A_ThisFunc, G3, yBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH,,,,, thisO)
          trGdip_DisposeImage(yBitmap, 1)
          yBitmap := trGdip_CloneBitmap(A_ThisFunc, gBitmap)
       }
    } Else
    {
       f := (doubleBlurPreviewArea=1) ? (zoomBlurAreaXamount*8)/2 : zoomBlurAreaXamount*8
       ff := (doubleBlurPreviewArea=1) ? ((zoomBlurAreaXamount*8)/2)/2 : (zoomBlurAreaXamount*8)/2
       If (zoomBlurMode=4)
       {
          wbitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, imgSelW//ff, imgSelH, 0, 5)
          rbitmap := trGdip_ResizeBitmap(A_ThisFunc, wBitmap, imgSelW//f, imgSelH, 0, 7)
       } Else
       {
          wbitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, imgSelW, imgSelH//ff, 0, 5)
          rbitmap := trGdip_ResizeBitmap(A_ThisFunc, wBitmap, imgSelW, imgSelH//f, 0, 7)
       }
       fbitmap := trGdip_ResizeBitmap(A_ThisFunc, rBitmap, imgSelW, imgSelH, 0, 7)
       r1 := trGdip_DrawImage(A_ThisFunc, G3, fBitmap, 0, 0, imgSelW, imgSelH)
       trGdip_DisposeImage(wBitmap)
       trGdip_DisposeImage(rBitmap)
       trGdip_DisposeImage(fBitmap)
    }

    Gdip_DeleteGraphics(G3)
    If (BlurAreaBlendMode>1)
    {
       applyBlurColorsFX(gBitmap)
       rz := QPV_BlendBitmaps(bgrBMPu, gBitmap, BlurAreaBlendMode - 1, 0)
       ; ToolTip, % "l=" rz , , , 2
       ou := gBitmap
       gBitmap := bgrBMPu
       bgrBMPu := ou
    }

    ; thisBMP := (BlurAreaBlendMode>1) ? bgrBMPu : cornersBMP
    r1 := trGdip_DrawImage(A_ThisFunc, G, gBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize, uiboxSize, thisOpacity)
    flipBitmapAccordingToViewPort(cornersBMP, 1)
    If (r1!="fail")
       hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)

    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    Gdip_DeleteGraphics(G)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(yBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    trGdip_DisposeImage(cornersBMP, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(opEffect)
}

updateUIerasePanel(actionu:=0, b:=0, c:=0) {
    If (AnyWindowOpen!=25)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide

    RegAction(1, "EraseAreaOpacity")
    RegAction(1, "EraseAreaFader")
    RegAction(1, "EraseAreaInvert")
    thisOpacity := Round((EraseAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoEraseOpacity, Opacity: %thisOpacity%`%
    actu := (EraseAreaFader=1) ?  "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, infoEraseOpacity
    GuiControl, % actu, EraseAreaOpacity

    If (actionu!="noPreview")
       livePreviewsImageEditing(0, 0, A_ThisFunc, actionu, b)
}

BtnResetAmountDesature() {
   GuiControl, SettingsGUIA:, DesatureAreaAmount, 100
   updateUIdesaturatePanel()
}

BtnResetDesatureHue() {
   GuiControl, SettingsGUIA:, DesatureAreaHue, 0
   updateUIdesaturatePanel()
}

updateUIdesaturatePanel(actionu:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=55)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (DesaturateAreaChannel>1)
    {
       DesatureAreaAmount := 100
       GuiControl, SettingsGUIA:, DesatureAreaAmount, 100
    }

    GuiControl, SettingsGUIA:, infoAmount, Intensity: %DesatureAreaAmount%`%
    GuiControl, SettingsGUIA:, infohueAdjust, Relight: %DesatureAreaHue%°
    actu := (DesaturateAreaLevels>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, DesaturateAreaDither
    actu := (DesaturateAreaChannel=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, infoAmount
    GuiControl, % actu, DesatureAreaAmount

    actu := (DesatureAreaAmount>98 && isWinXP=0) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, DesatureAreaAlternate

    actu := (DesatureAreaAlternate!=1 && !isWinXP && DesatureAreaAmount>98) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, infohueAdjust
    GuiControl, % actu, DesatureAreaHue
    SetTimer, WriteSettingsDesaturateSelPanel, -200
    If (actionu!="noPreview")
       livePreviewsImageEditing(0, 0, A_ThisFunc, actionu, b)
    lastInvoked := A_TickCount
}

BtnEraseSelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   updateUIerasePanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()

   prevImgEditZeit := A_TickCount
   ToggleEditImgSelection("show-edit")
   EraseSelectedArea()
   prevImgEditZeit := A_TickCount
}

BtnFillBehindSelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   updateUIfillBehindPanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()

   prevImgEditZeit := A_TickCount
   ToggleEditImgSelection("show-edit")
   FillBehindSelectedArea()
   prevImgEditZeit := A_TickCount
}

coreDesatureAreaFX(ByRef matrix, ByRef pEffect) {
    thisChannel := (DesaturateAreaChannel>1) ? DesaturateAreaChannel + 1 : 1
    thisu := (DesaturateAreaChannel=1) ? 1 - (DesatureAreaAmount/100) : 1
    matrix := GenerateColorMatrix(thisChannel, , , thisu)
    thisAmount2 := (DesatureAreaAlternate=1) ? DesatureAreaAmount : 0
    If (DesatureAreaAlternate=1)
    {
       thisHAmount := 0
    } Else If (DesatureAreaHue>0)
    {
       thisHAmount := DesatureAreaHue - (100 - DesatureAreaAmount)*16
       thisHAmount := clampInRange(thisHAmount, 0, 180)
    } Else
    {
       thisHAmount := (100 - DesatureAreaAmount)*16 + DesatureAreaHue
       thisHAmount := clampInRange(thisHAmount, -180, 0)
    }

    If (!isWinXP && (thisHAmount!=0 || thisAmount2!=0) && DesatureAreaAmount>98 && DesatureAreaAlternate=0)
       pEffect := Gdip_CreateEffect(6, thisHAmount, thisAmount2, 0)
}

livePreviewAdjustColorsArea(modus:=0) {
   Critical, on
   Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:16}
        , prevState, prevBMP

   thisBitsDepth := bitsOptions[DesaturateAreaLevels]
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
   imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
   imgSelW := max(X1, X2) - min(X1, X2)
   imgSelH := max(Y1, Y2) - min(Y1, Y2)

   pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
   If (EraseAreaInvert=1)
   {
      getClampedVPimgBounds(imgSelPx, imgSelPy, x2, y2, imgSelW, imgSelH)
      imgSelPx := prevDestPosX, imgSelPy := prevDestPosY
   }

   ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   Gdip_ResetClip(2NDglPG)
   modus := (EraseAreaInvert=1) ? 4 : 0
   Gdip_SetClipPath(2NDglPG, pPath, modus)

   gimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   gimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   thisu := (EraseAreaInvert=1) ? "a" prevDestPosX prevDestPosY : "a" prevResizedVPimgW prevResizedVPimgH
   thisState := "a" imgSelPx imgSelPy imgSelW imgSelH mainWidth mainHeight zoomLevel thisu EraseAreaInvert IMGresizingMode imageAligned useGdiBitmap() gimgSelW gimgSelH currentUndoLevel undoLevelsRecorded
   If (prevState!=thisState)
   {
      fnOutputDebug("redraw: " A_ThisFunc)
      trGdip_DisposeImage(prevBMP, 1)
      If (EraseAreaInvert=1)
      {
         pBitmap := useGdiBitmap()
         Gdip_GetImageDimensions(pBitmap, w, h)
         If (w!=prevResizedVPimgW || h!=prevResizedVPimgH)
         {
            zBitmap := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, prevResizedVPimgW, prevResizedVPimgH, 0, 5)
            pBitmap := StrLen(zBitmap)>2 ? zBitmap : ""
         } Else pBitmap := trGdip_CloneBitmap(A_ThisFunc, pBitmap)
      } Else
      {
         ; pBitmap := getImgSelectedAreaEditMode(0, imgSelX1, imgSelY1, gimgSelW, gimgSelH, gimgSelW, gimgSelH, 0)
         pBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, useGdiBitmap(), imgSelX1, imgSelY1, gimgSelW, gimgSelH, 0, 0, 1)
         Gdip_GetImageDimensions(pBitmap, w, h)
         If (w!=imgSelW || h!=imgSelH)
         {
            zBitmap := Gdip_ResizeBitmap(pBitmap, imgSelW, imgSelH, 0, 5)
            trGdip_DisposeImage(pBitmap, 1)
            pBitmap := zBitmap
         }
      }
      prevBMP := pBitmap
      prevState := thisState
      ; ToolTip, % imgSelW "=" imgSelH "`n" w "=" h , , , 2
   } Else pBitmap := prevBMP

   If (userimgGammaCorrect=1)
   {
      Gdip_SetCompositingQuality(2NDglPG, 2)
      r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, pBitmap, imgSelPx, imgSelPy)
   }

   zBitmap := applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, pBitmap))
   If (thisBitsDepth>1 && DesaturateAreaLevels>1 && imgFxMode>1)
   {
      E := Gdip_BitmapSetColorDepth(zBitmap, thisBitsDepth, DesaturateAreaDither)
      Gdip_BitmapSetColorDepth(zBitmap, 32)
   }

   allowAlphaMasking := decideAlphaMaskingFeaseable(EraseAreaUseAlpha)
   If (allowAlphaMasking=1 && StrLen(zBitmap)>2)
   {
      thisIDu := "a" alphaMaskColorReversed alphaMaskingMode userAlphaMaskBmpPainted VPselRotation EllipseSelectMode imgSelPx imgSelPy imgSelW imgSelH EraseAreaInvert getIDvpFX() DesaturateAreaLevels DesaturateAreaDither currentUndoLevel undoLevelsRecorded userimgGammaCorrect useGdiBitmap()
      realtimePasteInPlaceAlphaMasker(1, zBitmap, thisIDu, newBitmap, 0, 0, 0, 0)
      If StrLen(newBitmap)>2
      {
         trGdip_DisposeImage(zBitmap, 1)
         zBitmap := newBitmap
      }
   }

   thisOpacity := EraseAreaOpacity/255
   r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, zBitmap, imgSelPx, imgSelPy,,,,,,, thisOpacity)
   If (userimgGammaCorrect=1)
      Gdip_SetCompositingQuality(2NDglPG, 1)

   ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
   Gdip_ResetClip(2NDglPG)
   trGdip_DisposeImage(zBitmap, 1)
}

livePreviewDesaturateArea(modus:=0) {
   Critical, on
   Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8}

   thisBitsDepth := bitsOptions[DesaturateAreaLevels]
   ; Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
   imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
   imgSelW := max(X1, X2) - min(X1, X2)
   imgSelH := max(Y1, Y2) - min(Y1, Y2)

   pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
   If (EraseAreaInvert=1)
      getClampedVPimgBounds(imgSelPx, imgSelPy, x2, y2, imgSelW, imgSelH)

   ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   coreDesatureAreaFX(clrMatrix, pEffect)
   Gdip_ResetClip(2NDglPG)
   modus := (EraseAreaInvert=1) ? 4 : 0
   Gdip_SetClipPath(2NDglPG, pPath, modus)
   zBitmap := getImgSelectedAreaEditMode(1, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0, imgSelW, imgSelH)
   If (thisBitsDepth>1)
   {
      E := Gdip_BitmapSetColorDepth(zBitmap, thisBitsDepth, DesaturateAreaDither)
      Gdip_BitmapSetColorDepth(zBitmap, 32)
   }

   allowAlphaMasking := decideAlphaMaskingFeaseable(EraseAreaUseAlpha)
   If (allowAlphaMasking=1 && StrLen(zBitmap)>2)
   {
      thisIDu := "a" alphaMaskColorReversed alphaMaskingMode userAlphaMaskBmpPainted VPselRotation EllipseSelectMode imgSelPx imgSelPy imgSelW imgSelH EraseAreaInvert DesatureAreaHue DesatureAreaAmount DesaturateAreaChannel DesatureAreaAlternate DesaturateAreaLevels DesaturateAreaDither currentUndoLevel undoLevelsRecorded useGdiBitmap()
      realtimePasteInPlaceAlphaMasker(1, zBitmap, thisIDu, newBitmap, 0, 0, 0, 0)
      If StrLen(newBitmap)>2
      {
         trGdip_DisposeImage(zBitmap, 1)
         zBitmap := newBitmap
      }
   }

   If pEffect
      r1 := trGdip_DrawImageFX(A_ThisFunc, 2NDglPG, zBitmap, imgSelPx, imgSelPy,,,,, clrMatrix, pEffect)
   Else
      r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, zBitmap, imgSelPx, imgSelPy,,,,,,, clrMatrix)

   ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
   Gdip_ResetClip(2NDglPG)
   Gdip_DisposeEffect(pEffect)
   trGdip_DisposeImage(zBitmap, 1)
}

BtnGraySelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   updateUIdesaturatePanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   prevImgEditZeit := A_TickCount
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()
   ToggleEditImgSelection("show-edit")
   GraySelectedArea()
   prevImgEditZeit := A_TickCount
}

BtnAdjustColorsImgSelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   RegAction(1, "EraseAreaOpacity")
   RegAction(1, "EraseAreaInvert")
   o_imgFxMode := imgFxMode
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   prevImgEditZeit := A_TickCount
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()
   ToggleEditImgSelection("show-edit")
   AdjustColorsSelectedArea(o_imgFxMode)
   prevImgEditZeit := A_TickCount
}

BtnBlurSelectedArea() {
  updateUIblurPanel()
  BtnCloseWindow()
  ToggleEditImgSelection("show-edit")
  BlurSelectedArea()
}

BtnZoomBlurSelectedArea() {
  updateUIzoomBlurPanel()
  BtnCloseWindow()
  ToggleEditImgSelection("show-edit")
  zoomBlurSelectedArea()
}

updateUIfillPanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=23)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIfillPanel, -150
       Return
    }

    decideCustomShapeStyle()
    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1
    If (FillAreaInverted=1 && FillAreaBlendMode>1)
       FillAreaGradientWrapped := 1

    closedLineCustomShape := FillAreaClosedPath
    If (CurrentPanelTab=1)
    {
       actu := (FillAreaShape=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, FillAreaCurveTension
       GuiControl, % actu, FillAreaClosedPath

       actu := (FillAreaInverted!=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, PasteInPlaceAutoExpandIMG

       actu := (FillAreaRemBGR=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, txtLine1
       GuiControl, % actu, txtLine2
       GuiControl, % actu, FillAreaGlassy
       GuiControl, % actu, FillAreaBlendMode

       actu := (FillAreaGlassy>1 && FillAreaRemBGR!=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, doImgEditLivePreview
       If (coreDesiredPixFmt="0x21808")
          GuiControl, SettingsGUIA: Disable, FillAreaBlendMode
    } Else If (CurrentPanelTab=2)
    {
       thisOpacity := Round((FillAreaOpacity / 255) * 100)
       this2ndOpacity := Round((FillArea2ndOpacity / 255) * 100)
       GuiControl, SettingsGUIA:, infoFillAreaOpacity, %thisOpacity%`%
       GuiControl, SettingsGUIA:, infoFillArea2ndOpacity, %this2ndOpacity%`%
       If (FillAreaColorMode=5)
       {
          iterations := Round(100*(FillAreaGradientScale/300)) + 1
          modelu := Round(7*(FillAreaGradientPosB/100))
          moduz := Round(9*(FillAreaGradientPosA/100))
          sweepRand := Round(9*(FillAreaGradientAngle/360))
          GuiControl, SettingsGUIA:, infoFillAreaSigma, Style deviation: %moduz%
          GuiControl, SettingsGUIA:, infoFillAreaBlend, Pattern style: %modelu%
          GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Petals sweep: %sweepRand%
          GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Iterations: %iterations%
          GuiControl, SettingsGUIA:, FillAreaColorReversed, &Reverse colors
          GuiControl, SettingsGUIA: , FillAreaGradientWrapped, -
          GuiControl, SettingsGUIA: Disable, FillAreaGradientWrapped
       } Else If (FillAreaColorMode=6)
       {
          texSize := 3 * FillAreaGradientScale
          thisAR := texSize + Round(texSize * (FillAreaGradientPosB/100))
          GuiControl, SettingsGUIA:, FillAreaGradientWrapped, Mirror X
          GuiControl, SettingsGUIA:, FillAreaColorReversed, Mirror Y
          GuiControl, SettingsGUIA:, infoFillAreaSigma, Scale: %FillAreaGradientPosA%`%
          GuiControl, SettingsGUIA:, infoFillAreaBlend, Size Y: %thisAR% px
          GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%°
          GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Size X: %texSize% px
          GuiControl, SettingsGUIA: Enable, FillAreaGradientWrapped
       } Else
       {
          GuiControl, SettingsGUIA:, FillAreaGradientWrapped, &Tiling pattern
          GuiControl, SettingsGUIA:, FillAreaColorReversed, &Reverse colors
          GuiControl, SettingsGUIA:, infoFillAreaSigma, Pos. A: %FillAreaGradientPosA%`%
          GuiControl, SettingsGUIA:, infoFillAreaBlend, Pos. B: %FillAreaGradientPosB%`%
          GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%°
          GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
          actu := (FillAreaColorMode=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
          GuiControl, % actu, FillAreaGradientWrapped
       }

       actu := (FillAreaColorMode=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, infoFillAreaSigma
       GuiControl, % actu, infoFillAreaBlend
       GuiControl, % actu, infoFillAreaGradientAngle
       GuiControl, % actu, infoFillAreaGradientScale
       GuiControl, % actu, FillAreaGradientAngle
       GuiControl, % actu, FillAreaGradientPosA
       GuiControl, % actu, FillAreaGradientPosB
       GuiControl, % actu, FillAreaGradientScale
       GuiControl, % actu, FillArea2ndOpacity

       If (isInRange(FillAreaColorMode, 2, 4) || FillAreaColorMode=6)
          GuiControl, SettingsGUIA: Enable, FillAreaColorReversed
       Else
          GuiControl, SettingsGUIA: Disable, FillAreaColorReversed

       actu := (FillAreaColorMode>4) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, PickuFillAreaColor
       GuiControl, % actu, FillAreaColor

       actu := (FillAreaColorMode=1 || FillAreaColorMode=6) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, PickuFillArea2ndColor
       GuiControl, % actu, FillArea2ndColor
       GuiControl, % actu, FillArea2ndOpacity
       GuiControl, % actu, infoFillArea2ndOpacity

       actu := (isInRange(FillAreaColorMode, 2, 4) || FillAreaColorMode=6) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, btnFldr5

       actu := (FillAreaColorMode=6) ? "&Set texture source" : "&Reset gradient center"
       GuiControl, SettingsGUIA: , btnFldr5, % actu
    } Else If (CurrentPanelTab=3)
    {
       thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
       GuiControl, SettingsGUIA:, infoDrawLineAreaOpacity, %thisOpacity%`%
       GuiControl, SettingsGUIA:, infoDrawLineAreaContour, Line thickness: %DrawLineAreaContourThickness% pixels
       actu2 := (FillAreaDoContour=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, PickuDrawLineAreaColor
       GuiControl, % actu2, infoDrawLineAreaOpacity
       GuiControl, % actu2, infoDrawLineAreaContour
       GuiControl, % actu2, DrawLineAreaColor
       GuiControl, % actu2, DrawLineAreaOpacity
       GuiControl, % actu2, DrawLineAreaKeepBounds
       GuiControl, % actu2, DrawLineAreaCapsStyle
       GuiControl, % actu2, DrawLineAreaDoubles
       GuiControl, % actu2, DrawLineAreaContourAlign
       GuiControl, % actu2, DrawLineAreaDashStyle
       GuiControl, % actu2, DrawLineAreaContourThickness
       GuiControl, % actu2, txtLine3
       GuiControl, % actu2, txtLine4
    } Else If (CurrentPanelTab=4)
    {
       actu := (FillAreaGlassy>1 || FillAreaColorMode>=5 || FillAreaBlendMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, FillAreaApplyColorFX

       actu2 := (FillAreaApplyColorFX=1 && InStr(actu, "enable")) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, PasteInPlaceLight
       GuiControl, % actu2, PasteInPlaceGamma
       GuiControl, % actu2, PasteInPlaceHue
       GuiControl, % actu2, PasteInPlaceSaturation
       GuiControl, % actu2, infoPasteLight
       GuiControl, % actu2, infoPasteGamma
       GuiControl, % actu2, infoPasteHue
       GuiControl, % actu2, infoPasteSat
       GuiControl, SettingsGUIA:, infoPasteHue, Hue: %PasteInPlaceHue%°
       GuiControl, SettingsGUIA:, infoPasteSat, Saturation: %PasteInPlaceSaturation%`%
       GuiControl, SettingsGUIA:, infoPasteLight, Brightness: %PasteInPlaceLight%
       GuiControl, SettingsGUIA:, infoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    } Else If (CurrentPanelTab=5)
    {
       updateUIalphaMaskStuff(1)
    } Else If (CurrentPanelTab=6)
       updateUIalphaMaskStuff(2)

    EllipseSelectMode := (FillAreaShape=7) ? 2 : 0
    If (FillAreaShape=3)
       EllipseSelectMode := 1
    ; ToggleEditImgSelection("show-edit")
    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing()

    If (ShowAdvToolbar=1 && FillAreaColorMode=1)
    {
       thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
       %thisOpa% := FillAreaOpacity
    } Else If (ShowAdvToolbar=1)
    {
       BrushToolAopacity := FillAreaOpacity
       BrushToolBopacity := FillArea2ndOpacity
    }

    lastInvoked := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -50
    SetTimer, WriteSettingsFillAreaPanel, -350
    SetTimer, WriteSettingsBrushPanel, -350
    SetTimer, WriteSettingsAlphaMaskPanel, -250
}

updateUIalphaMaskerPanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=70)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (CurrentPanelTab=1)
       updateUIalphaMaskStuff(1)
    Else If (CurrentPanelTab=2)
       updateUIalphaMaskStuff(2)
    
    EllipseSelectMode := 0
    thisOpacity := Round(alphaMaskPreviewOpacity/255*100)
    GuiControl, SettingsGUIA:, infoOpacity, %thisOpacity%`%
    ; ToggleEditImgSelection("show-edit")
    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing()

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsBrushPanel, -350
    SetTimer, WriteSettingsAlphaMaskPanel, -250
}

WriteSettingsFillAreaPanel() {
    ReadSettingsFillAreaPanel(1)
}

WriteSettingsAlphaMaskPanel() {
    ReadSettingsAlphaMaskPanel(1)
}

WriteSettingsDrawShapeAreaPanel() {
    ReadSettingsDrawShapeAreaPanel(1)
}

BtnFillSelectedArea() {
    Gui, SettingsGUIA: Default
    updateUIfillPanel("noPreview")
    If (FillAreaInverted=1)
       PasteInPlaceAutoExpandIMG := 0
    If (PasteInPlaceAutoExpandIMG!=1)
    {
       If throwErrorSelectionOutsideBounds()
          Return
    }

    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    Sleep, 1
    prevImgEditZeit := A_TickCount
    If (closeEditPanelOnApply=1)
       CloseWindow("yes", 0)
    ; Sleep, 1
    ToggleEditImgSelection("show-edit")
    FillSelectedArea()
    prevImgEditZeit := A_TickCount
    SetTimer, RemoveTooltip, -250
}

BtnDrawShapeSelectedArea() {
    If throwErrorSelectionOutsideBounds()
       Return

    Gui, SettingsGUIA: Default
    updateUIfillPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    Sleep, 1
    prevImgEditZeit := A_TickCount
    If (closeEditPanelOnApply=1)
       CloseWindow("yes", 0)
    ; Sleep, 1
    ToggleEditImgSelection("show-edit")
    DrawLinesInSelectedArea(2)
    prevImgEditZeit := A_TickCount
    SetTimer, RemoveTooltip, -250
}

BtnInsertTextSelectedArea() {
    If (PasteInPlaceAutoExpandIMG!=1 || TextInAreaBlendMode>1)
    {
       If throwErrorSelectionOutsideBounds()
          Return
    }

    Gui, SettingsGUIA: Default
    updateUIInsertTextPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    Sleep, 1
    If (closeEditPanelOnApply=1)
       BtnCloseWindow()
    ; Sleep, 1
    prevImgEditZeit := A_TickCount
    ToggleEditImgSelection("show-edit")
    InsertTextSelectedArea()
    prevImgEditZeit := A_TickCount
    SetTimer, RemoveTooltip, -250
}

BtnViewedImages2List() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (userSeenSlideImages<3)
      Return

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

  If askAboutSlidesListSave()
     Return

   BtnCloseWindow()
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := "\QPV\viewed-images-history-current-session.SLD"
   For Key, Value in userSeenSessionImagesArray
       resultedFilesList[Value] := [Key]

   SLDtypeLoaded := 2
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   RandomPicture()
}

BtnALLviewedImages2List(dummy:=0) {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   BtnCloseWindow()
   startOperation := A_TickCount
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   showTOOLtip("Gathering seen images list, please wait")
   setImageLoading()
   friendly := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : "ALL"
   dummy := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : ""
   seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 1, dummy)
   If (totalSeenIMGs<3)
   {
      seenEntries := ""
      SetTimer, ResetImgLoadStatus, -50
      CurrentSLD := backCurrentSLD
      If (SLDtypeLoaded=3)
         activeSQLdb.Exec("COMMIT TRANSACTION;")
      showTOOLtip("Found no already seen images in the database")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   PopulateIndexFilesStatsInfos("kill")
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := "\QPV\viewed-images-history-" friendly ".SLD"
   For Key, Value in seenEntries
       resultedFilesList[A_Index] := [Key,,1]

   seenEntries := ""
   SLDtypeLoaded := 2
   currentFilesListModified := 0
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   etaTime := "Elapsed time to retrieve seen images list from the database:`n" SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   RandomPicture()
}

PanelJournalWindow(tabu:=1) {
    If (AnyWindowOpen=1)
       CloseWindow()

    thisBtnHeight := createSettingsGUI(33, A_ThisFunc)
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 40
       Gui, Font, s%LargeUIfontValue%
    }

    textList := ""
    txtWid := Round(editWid*6.25)
    totalIndex := QPVjournal.Count()
    For Key, Value in QPVjournal
    {
        currentEntry := totalIndex - A_Index
        line := Trimmer(Value)
        If line
           textList .= "(" currentEntry ") " Trimmer(line) "`n`n"
    }

    errList := ""
    totalIndex := QPVerrJournal.Count()
    For Key, Value in QPVerrJournal
    {
        currentEntry := totalIndex - A_Index
        line := Trimmer(Value)
        If line
           errList .= "(" currentEntry ") " Trimmer(line) "`n`n"
    }

    userSeenSlideImages := userSeenSessionImagesArray.Count()
    WinGetTitle, thisTitle, ahk_id %PVhwnd%
    If (tabu=2)
       thisPanelTab := 3

    Gui, Add, Tab3, AltSubmit gBtnTabsInfoUpdate hwndhCurrTab vCurrentPanelTab Choose%thisPanelTab%, Journal|Errors|Seen images
    Gui, Tab, 1
    Gui, Add, Button, x+15 y+15 w1 h1 gBtnCloseWindow Default, Clo&se
    Gui, Add, Edit, x+0 y+0 Section ReadOnly w%txtWid% r15, % "WinTitle: " thisTitle "`n`n" textList
    Gui, Tab, 2
    Gui, Add, Edit, x+15 y+15 Section ReadOnly w%txtWid% r15, % errList
    ; Gui, Add, Button, xs y+2 h%thisBtnHeight% gPanelSeenIMGsOptions, &Seen images database options

    Gui, Tab, 3
    If (mustRecordSeenImgs=1)
    {
       Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.

       Gui, Add, Button, xs y+15 h%thisBtnHeight% gBtnALLviewedImages2List, &Retrieve list of all recorded seen images
       Gui, Add, Button, y+5 hp wp gCleanDeadFilesSeenImagesDB, &Purge records of inexistent files
       Gui, Add, Button, y+5 hp wp geraseSeenIMGsDB, &Erase the entire list
       Gui, Add, Button, y+5 hp wp gPanelSeenStats, &Seen images statistics
       Gui, Add, Text, y+5 wp, TIP: To retrieve the images seen on a given day or month`, open the statistics panel.
    } Else
    {
       Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.
       Gui, Add, Text, xs y+10 hp +0x200, Seen images are not recorded in the database.
       Gui, Add, Button, xs+15 y+5 hp gBtnActivateRecordSeen, &Activate this
    }
/*
    Gui, Tab, 4
    olistedVars := ListGlobalVars()
    listedVars := "Global variables:`n"
    Loop, Parse, olistedVars, `n,`r
       listedVars .= A_LoopField " = " %A_loopField% "`n"

    deleteMenus()
    buildQuickSearchMenus()
    objs := kMenu(0, "give", 0)
    mainList := objs[1]
    listedVars .= "`n`nFunctions: (min/max params)`n"
    Loop, % mainList.Count()
    {
       fn := Func(mainList[A_Index, 2])
       listedVars .= mainList[A_Index, 2] "(" fn.MinParams "/" fn.MaxParams ")`n"
    }

    Gui, Add, Edit, x+1 y+1 Section ReadOnly w%txtWid% r15, % listedVars
*/

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Application journal: " appTitle)
    SetTimer, ResetImgLoadStatus, -100
}

BtnActivateRecordSeen() {
   BtnCloseWindow()
   Sleep, 10
   ToggleRecordSeenImages()
}

PanelSeenIMGsOptions() {
    PanelJournalWindow(2)
}

ReadSettingsTextInArea(act:=0) {
    RegAction(act, "TextInAreaFlipV",, 1)
    RegAction(act, "TextInAreaFlipV",, 1)
    RegAction(act, "TextInAreaAlign",, 2, 1, 3)
    RegAction(act, "TextInAreaLineAngle",, 2, -900, 900)
    RegAction(act, "TextInAreaCharSpacing",, 2, -100, 255)
    RegAction(act, "TextInAreaBlendMode",, 2, 1, 21)
    RegAction(act, "TextInAreaValign",, 2, 1, 3)
    RegAction(act, "TextInAreaBlurAmount",, 2, 1, 255)
    RegAction(act, "TextInAreaBlurBorderAmount",, 2, 1, 255)
    RegAction(act, "TextInAreaUsrMarginz",, 2, 0, 500)
    RegAction(act, "TextInAreaBgrColor",, 3)
    RegAction(act, "TextInAreaBgrEntire",, 1)
    RegAction(act, "TextInAreaBgrUnified",, 1)
    RegAction(act, "TextInAreaFillSelArea",, 1)
    RegAction(act, "TextInAreaCutOutMode",, 1)
    RegAction(act, "TextInAreaBgrOpacity",, 2, 3, 255)
    RegAction(act, "TextInAreaBorderSize",, 2, 1, 650)
    RegAction(act, "TextInAreaBorderOut",, 2, 1, 3)
    RegAction(act, "TextInAreaBorderColor",, 3)
    RegAction(act, "TextInAreaBorderOpacity",, 2, 3, 255)
    RegAction(act, "TextInAreaFontBold",, 1)
    RegAction(act, "TextInAreaFontColor",, 3)
    RegAction(act, "TextInAreaFontItalic",, 1)
    RegAction(act, "TextInAreaFontName",, 5)
    RegAction(act, "TextInAreaFontLineSpacing",, 2, -950, 950)
    RegAction(act, "TextInAreaFontOpacity",, 2, 3, 255)
    RegAction(act, "TextInAreaFontSize",, 2, 5, 950)
    RegAction(act, "TextInAreaFontStrike",, 1)
    RegAction(act, "TextInAreaFontUline",, 1)
    RegAction(act, "TextInAreaOnlyBorder",, 1)
    RegAction(act, "TextInAreaPaintBgr",, 1)
    RegAction(act, "TextInAreaRoundBoxBgr",, 1)
    RegAction(act, "TextInAreaAutoWrap",, 1)
    RegAction(act, "TextInAreaCaseTransform",, 2, 1, 5)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
    IniAction(act, "userimgGammaCorrect", "General", 1)
}

BtnResetTextSpacing() {
   TextInAreaCharSpacing := 0
   TextInAreaLineAngle := 0
   GuiControl, SettingsGUIA:, TextInAreaCharSpacing, % TextInAreaCharSpacing
   GuiControl, SettingsGUIA:, TextInAreaLineAngle, % TextInAreaLineAngle
   updateUIInsertTextPanel()
}

BtnResetTextAligns() {
   TextInAreaAlign := 1
   TextInAreaValign := 1
   GuiControl, SettingsGUIA: Choose, TextInAreaAlign, % TextInAreaAlign
   GuiControl, SettingsGUIA: Choose, TextInAreaValign, % TextInAreaValign
   updateUIInsertTextPanel()
}

BtnResetTextLead() {
   TextInAreaUsrMarginz := 0
   TextInAreaFontLineSpacing := 0
   GuiControl, SettingsGUIA: , TextInAreaUsrMarginz, % TextInAreaUsrMarginz
   GuiControl, SettingsGUIA: , TextInAreaFontLineSpacing, % TextInAreaFontLineSpacing
   updateUIInsertTextPanel()
}

BtnResetTextOpacity() {
   TextInAreaFontOpacity := 254
   GuiControl, SettingsGUIA: , TextInAreaFontOpacity, % TextInAreaFontOpacity
   updateUIInsertTextPanel()
}

BtnResetBrushColorBopacity() {
   BrushToolBopacity := 255
   this2ndOpacity := Round((BrushToolBopacity / 255) * 100)
   GuiControl, SettingsGUIA:, BrushToolBopacity, % BrushToolBopacity
   GuiControl, SettingsGUIA:, infoBrushBopacity, %this2ndOpacity%`%
}

BtnResetBrushColorAopacity() {
   BrushToolAopacity := 255
   thisOpacity := Round((BrushToolAopacity / 255) * 100)
   GuiControl, SettingsGUIA:, BrushToolAopacity, % BrushToolAopacity
   GuiControl, SettingsGUIA:, infoBrushAopacity, %thisOpacity%`%
}

BtnResetTextBgrOpacity() {
   TextInAreaBgrOpacity := 255
   GuiControl, SettingsGUIA: , TextInAreaBgrOpacity, % TextInAreaBgrOpacity
   updateUIInsertTextPanel()
}

BTNresetAlphaPrevOpacity() {
   alphaMaskPreviewOpacity := 255
   GuiControl, SettingsGUIA: , alphaMaskPreviewOpacity, % alphaMaskPreviewOpacity
   updateUIalphaMaskerPanel()
}

BtnResetTextBordOpacity() {
   TextInAreaBorderOpacity := 255
   GuiControl, SettingsGUIA: , TextInAreaBorderOpacity, % TextInAreaBorderOpacity
   updateUIInsertTextPanel()
}

PanelInsertTextArea() {
    openingPanelNow := 1
    If !(thisBtnHeight := createSettingsGUI(32, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsTextInArea()
    ReadSettingsBrushPanel()
    ReadSettingsAlphaMaskPanel()
    btnWid := 70,       txtWid := 350
    columnBpos := 165,  slideWid := 150
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos := columnBpos + 95
       slideWid := slideWid + 55
       EditWid := EditWid + 40
       btnWid := btnWid + 20
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    ddWid := Round(editWid*3.25)
    txtWid := (PrefsLargeFonts=1) ? Round(editWid*4.5) : Round(editWid*5)
    EllipseSelectMode := 0

    Global editF1, editF2, editF3, editF4, editF5, editF6,  editF7, editF8, editF9, editF10, editF11
         , editF12, PickuTextInAreaFontColor, PickuTextInAreaBgrColor, PickuTextInAreaBorderColor, uiPasteInPlaceAlphaDrawMode

    widu := (PrefsLargeFonts=1) ? 55 : 40
    ml := (PrefsLargeFonts=1) ? 35 : 24
    Gui, Add, Tab3, gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Text|Styling|Colors|Alpha mask|Paint mask
    Gui, Tab, 1
    Gui, Add, Edit, x+15 y+15 Section w%txtWid% r10 gupdateUIInsertTextPanel vUserTextArea hwndhEditField, % UserTextArea
    Gui, Add, Button, gBtnFntDlgInsertText, Font options
    Gui, Add, Edit, x+2 hp w%widu% gupdateUIInsertTextPanel limit3 -multi number -wantCtrlA -wantTab -wrap veditF1 , % TextInAreaFontSize
    Gui, Add, UpDown, vTextInAreaFontSize Range5-950, % TextInAreaFontSize
    widu := (PrefsLargeFonts=1) ? 30 : 25
    Gui, Add, Checkbox, x+2 yp hp w%widu% +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontBold% vTextInAreaFontBold, B
    Gui, Add, Checkbox, x+2 yp hp wp +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontItalic% vTextInAreaFontItalic, I
    Gui, Add, Checkbox, x+2 yp hp wp +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontUline% vTextInAreaFontUline, U
    Gui, Add, Checkbox, x+2 yp hp wp +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontStrike% vTextInAreaFontStrike, S
    ; Gui, Add, DropDownList, x+5 w%ddWid% Sort Choose1 gupdateUIInsertTextPanel vTextInAreaFontName, % TextInAreaFontName
    Gui, Add, Checkbox, x+5 hp +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaAutoWrap% vTextInAreaAutoWrap, Word-&wrap
    Gui, Add, DropDownList, xs y+5 wp gupdateUIInsertTextPanel Choose%TextInAreaCaseTransform% AltSubmit vTextInAreaCaseTransform, Transform case|CAPITALIZED|lowercase|Title Case|Leet speak
    Gui, Add, Checkbox, x+5 hp +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFlipV% vTextInAreaFlipV, Flip &V
    Gui, Add, Checkbox, x+5 hp +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFlipH% vTextInAreaFlipH, Flip &H

    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 Section +TabStop gBtnResetTextSpacing, Line angle / letter spacing
    Gui, Add, Text, xs yp+%ml% +TabStop gBtnResetTextLead, Leading / margins
    Gui, Add, Text, xs yp+%ml% +TabStop gBtnResetTextAligns, Text alignment
    Gui, Add, Text, xs yp+%ml%, Border style / thickness
    Gui, Add, Checkbox, xs yp+%ml% gupdateUIInsertTextPanel Checked%TextInAreaDoBlurs% vTextInAreaDoBlurs, Blur for text / border
    Gui, Add, Checkbox, xs yp+%ml% gupdateUIInsertTextPanel Checked%TextInAreaPaintBgr% vTextInAreaPaintBgr, Draw background

    Gui, Add, Edit, xs+%columnBpos% ys+0 Section w%editWid% r1 gupdateUIInsertTextPanel limit4 -multi -wantCtrlA -wantTab -wrap veditF11, % TextInAreaLineAngle
    Gui, Add, UpDown, vTextInAreaLineAngle Range-900-900, % TextInAreaLineAngle
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIInsertTextPanel limit4 -multi -wantCtrlA -wantTab -wrap veditF12, % TextInAreaCharSpacing
    Gui, Add, UpDown, vTextInAreaCharSpacing Range-100-255, % TextInAreaCharSpacing

    Gui, Add, Edit, xs+0 yp+%ml% w%editWid% gupdateUIInsertTextPanel r1 limit4 -multi -wantCtrlA -wantTab -wrap veditF9, % TextInAreaFontLineSpacing
    Gui, Add, UpDown, vTextInAreaFontLineSpacing Range-950-950, % TextInAreaFontLineSpacing
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF10, % TextInAreaUsrMarginz
    Gui, Add, UpDown, vTextInAreaUsrMarginz Range0-500, % TextInAreaUsrMarginz

    Gui, Add, DropDownList, xs yp+%ml% w%editWid% gupdateUIInsertTextPanel Choose%TextInAreaAlign% AltSubmit vTextInAreaAlign, Left|Center|Right
    Gui, Add, DropDownList, x+2 wp gupdateUIInsertTextPanel Choose%TextInAreaValign% AltSubmit vTextInAreaValign, Top|Center|Bottom

    Gui, Add, DropDownList, xs yp+%ml% w%editWid% gupdateUIInsertTextPanel Altsubmit Choose%TextInAreaBorderOut% vTextInAreaBorderOut, None|Center|Outset
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIInsertTextPanel limit3 -multi number -wantCtrlA -wantTab -wrap veditF2, % TextInAreaBorderSize
    Gui, Add, UpDown, vTextInAreaBorderSize Range1-650, % TextInAreaBorderSize

    Gui, Add, Edit, xs yp+%ml% w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF6, % TextInAreaBlurAmount
    Gui, Add, UpDown, vTextInAreaBlurAmount Range1-255, % TextInAreaBlurAmount
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF8, % TextInAreaBlurBorderAmount
    Gui, Add, UpDown, vTextInAreaBlurBorderAmount Range1-255, % TextInAreaBlurBorderAmount

    Gui, Add, Checkbox, xs yp+%ml% gupdateUIInsertTextPanel Checked%TextInAreaFillSelArea% vTextInAreaFillSelArea, Fill selection area
    Gui, Add, Checkbox, xm+15 yp+%ml% Section gupdateUIInsertTextPanel Checked%TextInAreaBgrUnified% vTextInAreaBgrUnified, Unified block
    Gui, Add, Checkbox, xs+%columnBpos% yp hp gupdateUIInsertTextPanel Checked%TextInAreaRoundBoxBgr% vTextInAreaRoundBoxBgr, Rounded corners
    Gui, Add, Checkbox, xs yp+%ml% gupdateUIInsertTextPanel Checked%TextInAreaCutOutMode% vTextInAreaCutOutMode, Cut-out mode
    Gui, Add, Checkbox, xs+%columnBpos% yp hp gupdateUIInsertTextPanel Checked%TextInAreaBgrEntire% vTextInAreaBgrEntire, Fill entire line(s)
    Gui, Add, Checkbox, xs yp+%ml% gupdateUIInsertTextPanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas to fit selection area

    Gui, Tab, 3
    Gui, Add, Text, x+15 y+15 Section +TabStop vtxtLine6 gBtnResetTextOpacity, Text opacity / color
    Gui, Add, Slider, Center xs y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaFontOpacity Range1-255, % TextInAreaFontOpacity
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaFontColor +hwndhBtnPickClrA, P
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaFontColor% vTextInAreaFontColor hwndhLV3,
    Gui, Add, Text, x+5 hp +0x200 +TabStop vinfoPasteOpacity gBtnResetTextOpacity +hwndhBtnRopacity, Opacity
    ToolTip2ctrl(hBtnRopacity, "Reset text color opacity")
    ToolTip2ctrl(hBtnPickClrA, "Pick text color from the viewport")

    ml := (PrefsLargeFonts=1) ? 15 : 10
    Gui, Add, Text, xs y+%ml% +TabStop vtxtLine1 gBtnResetTextBordOpacity, Border opacity / color
    Gui, Add, Slider, Center xs y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaBorderOpacity Range1-255, % TextInAreaBorderOpacity
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaBorderColor +hwndhBtnPickClrA, P
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaBorderColor% vTextInAreaBorderColor hwndhLV45,
    Gui, Add, Text, x+5 hp +0x200 +TabStop vinfoFillAreaOpacity gBtnResetTextBordOpacity +hwndhBtnRopacity, Opacity
    Gui, Add, Checkbox, xs+15 y+2 hp gupdateUIInsertTextPanel Checked%TextInAreaOnlyBorder% vTextInAreaOnlyBorder, &Draw only the border
    ToolTip2ctrl(hBtnRopacity, "Reset border color opacity")
    ToolTip2ctrl(hBtnPickClrA, "Pick border color from the viewport")

    Gui, Add, Text, xs y+%ml% vtxtLine2, Background opacity / color
    Gui, Add, Slider, Center xs y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaBgrOpacity Range1-255, % TextInAreaBgrOpacity
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaBgrColor +hwndhBtnPickClrA, P
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaBgrColor% vTextInAreaBgrColor hwndhLV2,
    Gui, Add, Text, x+5 hp +0x200 +TabStop vinfoFillArea2ndOpacity gBtnResetTextBgrOpacity +hwndhBtnRopacity, Opacity
    Gui, Add, Checkbox, xs y+%ml% Checked%userimgGammaCorrect% vuserimgGammaCorrect gupdateUIInsertTextPanel, &Apply gamma corrections
    Gui, Add, Text, xs y+10 +TabStop gBtnResetTextBlendMode, Blending mode:
    Gui, Add, DropDownList, x+5 wp+25 gupdateUIInsertTextPanel AltSubmit Choose%TextInAreaBlendMode% vTextInAreaBlendMode, None|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    ToolTip2ctrl(hBtnRopacity, "Reset background color opacity")
    ToolTip2ctrl(hBtnPickClrA, "Pick background color from the viewport")

    uiADDalphaMaskTabs(4, 5, "updateUIInsertTextPanel")

    Gui, Tab
    ml := (PrefsLargeFonts=1) ? 90 : 70
    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w%ml% gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%doImgEditLivePreview% vdoImgEditLivePreview gupdateUIInsertTextPanel, Live preview (low quality)
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    ; PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Insert text in image: " appTitle, winPos)
    SetTimer, updateUIInsertTextPanel, -250
    SetTimer, resetOpeningPanel, -300
}

uiADDalphaMaskTabs(t1, t2, labelu) {
    Global uiPasteInPlaceAlphaDrawMode
    btnWid := 90,  txtWid := 310
    EditWid := 60, slideWid := 150
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 55
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid2 := txtWid//2
    sml := (PrefsLargeFonts=1) ? 70 : 55

    Gui, Tab, %t1% ; alpha mask
    friendlyMaskInfo := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "No alpha mask"
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid2% AltSubmit Choose%alphaMaskingMode% valphaMaskingMode g%labelu%, %friendlyMaskInfo%|Linear gradient|Radial gradient|Box gradient|Image file|Custom shape
    Gui, Add, Checkbox, x+8 Checked%alphaMaskGradientWrapped% valphaMaskGradientWrapped g%labelu%, &Tiled gradient
    Gui, Add, Text, xs y+10 w%slideWid% +0x200 gBtnResetPanelsSpecificControl vinfoAlphaClrAint +TabStop, Intensity A: 0
    Gui, Add, Text, x+5 hp wp +0x200 gBtnResetPanelsSpecificControl vinfoAlphaClrBint +TabStop, Intensity B: 0
    Gui, Add, Slider, Center xs y+1 NoTicks wp g%labelu% AltSubmit valphaMaskClrAintensity Range0-255, % alphaMaskClrAintensity
    Gui, Add, Slider, Center x+5 NoTicks wp g%labelu% AltSubmit valphaMaskClrBintensity Range0-255, % alphaMaskClrBintensity

    Gui, Add, Text, xs y+15 w%slideWid% gBtnResetPanelsSpecificControl vinfoAlphaMaskGradientAngle +TabStop, Angle: %alphaMaskGradientAngle%° 
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoAlphaMaskGradientScale +TabStop, Scale: %alphaMaskGradientScale%`%
    Gui, Add, Slider, Center xs y+1 wp NoTicks g%labelu% AltSubmit valphaMaskGradientAngle Range0-360, % alphaMaskGradientAngle
    Gui, Add, Slider, Center x+5 wp NoTicks g%labelu% AltSubmit valphaMaskGradientScale Range1-300, % alphaMaskGradientScale

    Gui, Add, Text, xs y+10 wp gBtnResetPanelsSpecificControl vinfoAlphaMaskSigma +TabStop, Sigma: %alphaMaskGradientPosA%`%
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoAlphaMaskBlend +TabStop, Blend: %alphaMaskGradientPosB%`%
    Gui, Add, Slider, Center xs y+1 wp NoTicks g%labelu% AltSubmit valphaMaskGradientPosA Range0-100, % alphaMaskGradientPosA
    Gui, Add, Slider, Center x+5 wp NoTicks g%labelu% AltSubmit valphaMaskGradientPosB Range0-100, % alphaMaskGradientPosB
    Gui, Add, Text, xs y+10 vinfoAlphaFile, Image to use as alpha mask:
    Gui, Add, DropDownList, xs y+10 w%txtWid2% g%labelu% AltSubmit valphaMaskRefBMP Choose%alphaMaskRefBMP%, User painted bitmap|Main image|Transformed object
    Gui, Add, DropDownList, x+5 wp-95 AltSubmit Choose%alphaMaskBMPchannel% valphaMaskBMPchannel g%labelu%, Red|Green|Blue|Alpha|All gray
    Gui, Add, Checkbox, xs y+10 Checked%alphaMaskColorReversed% valphaMaskColorReversed g%labelu%, &Invert
    Gui, Add, Checkbox, x+8 Checked%alphaMaskReplaceMode% valphaMaskReplaceMode g%labelu%, &Replace alpha channel

    Gui, Tab, %t2% ; paint alpha
    sml := (PrefsLargeFonts=1) ? 30 : 20
    BrushToolType := clampInRange(BrushToolType, 1, 2)
    Gui, Add, Checkbox, x+15 y+15 Section gBTNtoggleAlphaPainting Choose%uiPasteInPlaceAlphaDrawMode% vuiPasteInPlaceAlphaDrawMode, Enable alpha mask painting mode
    Gui, Add, DropDownList, xs y+10 Section AltSubmit w%txtWid2% g%labelu% Choose%BrushToolType% vBrushToolType, Simple solid color|Soft edges brush
    Gui, Add, Checkbox, x+10 hp gupdateUIbrushTool Checked%BrushToolOverDraw% vBrushToolOverDraw , &Airbrush mode
    Gui, Add, Text, xs y+10 hp w%sml% +0x200 Center gBtnToggleBrushColors vUIbtnBrushColorA +TabStop +hwndhBtnTglClrA, [X]
    Gui, Add, Slider, Center x+5 w%slideWid% g%labelu% NoTicks ToolTip AltSubmit vBrushToolAopacity Range1-255, % BrushToolAopacity
    Gui, Add, Button, x+5 hp w%sml% gStartPickingColor vPickuBrushToolAcolor +hwndhBtnPickClrA, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%BrushToolAcolor% vBrushToolAcolor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp +0x200 +TabStop gBtnResetBrushColorAopacity vinfoBrushAopacity +hwndhBtnRopacity, 1011`%
    ToolTip2ctrl(hBtnRopacity, "Reset color A opacity")
    Gui, Add, Text, xs y+10 hp w%sml% +0x200 Center gBtnToggleBrushColors vUIbtnBrushColorB +TabStop +hwndhBtnTglClrB, [X]
    Gui, Add, Slider, Center x+5 w%slideWid% g%labelu% NoTicks ToolTip AltSubmit vBrushToolBopacity Range1-255, % BrushToolBopacity
    Gui, Add, Button, x+5 hp w%sml% gStartPickingColor vPickuBrushToolBcolor +hwndhBtnPickClrB, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%BrushToolBcolor% vBrushToolBcolor hwndhLVfill2ndColor,
    Gui, Add, Text, x+5 hp +0x200 +TabStop gBtnResetBrushColorBopacity vinfoBrushBopacity +hwndhBtnRopacity, 1011`%
    ToolTip2ctrl(hBtnRopacity, "Reset color B opacity")
    ToolTip2ctrl(hBtnTglClrA, "Toggle active color")
    ToolTip2ctrl(hBtnPickClrA, "Pick color A from the viewport")
    ToolTip2ctrl(hBtnTglClrB, "Toggle active color")
    ToolTip2ctrl(hBtnPickClrB, "Pick color B from the viewport")

    ; Gui, Add, Text, xs y+15 w%slideWid2% vinfoBrushSize, Size: %BrushToolSize%
    Gui, Add, Checkbox, xs y+15 w%slideWid% g%labelu% Checked%brushToolDoubleSize% vbrushToolDoubleSize, Diameter: 2000 px
    Gui, Add, Text, x+5 wp vinfoBrushStepping gBTNresetBrushStepu +TabStop, Stepping: %BrushToolStepping%
    Gui, Add, Slider, Center xs y+1 wp g%labelu% NoTicks AltSubmit vBrushToolSize Range2-950, % BrushToolSize
    Gui, Add, Slider, Center x+5 wp g%labelu% NoTicks AltSubmit vBrushToolStepping Range0-251, % brushToolStepping

    Gui, Add, Text, xs y+10 wp vinfoBrushAspectRatio gBTNresetBrushAspectRatio  +TabStop, Aspect ratio: %BrushToolAspectRatio%
    Gui, Add, Text, x+5 wp vinfoBrushAngle gBTNresetBrushAngle +TabStop, Angle: %BrushToolAngle%° 
    Gui, Add, Slider, Center xs y+1 wp g%labelu% NoTicks AltSubmit vBrushToolAspectRatio Range-100-100, % BrushToolAspectRatio
    Gui, Add, Slider, Center x+5 wp g%labelu% NoTicks AltSubmit vBrushToolAngle Range0-180, % BrushToolAngle

    Gui, Add, Text, xs y+10 wp vinfoBrushSoftness, Softness: %BrushToolSoftness%
    Gui, Add, Text, x+5 wp vinfoBrushDrying gBTNresetBrushDryer +TabStop, Dry-out rate: %BrushToolDryingRate%
    Gui, Add, Slider, Center xs y+1 wp g%labelu% NoTicks AltSubmit vBrushToolSoftness Range1-100, % BrushToolSoftness
    Gui, Add, Slider, Center x+5 wp g%labelu% NoTicks AltSubmit vBrushToolDryingRate Range0-20, % BrushToolDryingRate
}

PopulateFontsList(thisCtrl, guiu) {
    If !FontList._NewEnum()[k, v]
    {
       Fnt_GetListOfFonts()
       FontList := trimArray(FontList)
    }

    Loop, % FontList.Count()
    {
        fontNameInstalled := FontList[A_Index]
        If (fontNameInstalled ~= "i)(@|biz ud|ud digi kyo|oem|extb|symbol|marlett|wst_|glyph|reference specialty|system|terminal|mt extra|small fonts|cambria math|this font is not|fixedsys|emoji|hksc| mdl|wingdings|webdings)") || (fontNameInstalled=OSDFontName)
           Continue

        GuiControl, %guiu%:, %thisCtrl%, %fontNameInstalled%
    }
}

BtnFntDlgInsertText() {
   fntObj := []
   fntObj.name := TextInAreaFontName
   fntObj.size := TextInAreaFontSize//2
   fntObj.strike := TextInAreaFontStrike
   fntObj.underline := TextInAreaFontUline
   fntObj.bold := TextInAreaFontBold
   fntObj.italic := TextInAreaFontItalic
   ; fntObj.color := TextInAreaFontColor
   WinSet, Disable,, ahk_id %PVhwnd%
   oc := A_IsCritical
   Critical, Off
   nFntObj := Dlg_FontSelect(fntObj, hSetWinGui, 1)
   Critical, %oc%
   WinSet, Enable,, ahk_id %PVhwnd%
   If IsObject(nFntObj)
   {
      Gui, SettingsGUIA: Default
      TextInAreaFontName := nfntObj.name
      TextInAreaFontSize := nfntObj.size * 2
      TextInAreaFontStrike := nfntObj.strike
      TextInAreaFontUline := nfntObj.underline
      TextInAreaFontBold := nfntObj.bold
      TextInAreaFontItalic := nfntObj.italic
      GuiControl, SettingsGUIA:, TextInAreaFontSize, % TextInAreaFontSize
      GuiControl, SettingsGUIA:, TextInAreaFontStrike, % TextInAreaFontStrike
      GuiControl, SettingsGUIA:, TextInAreaFontUline, % TextInAreaFontUline
      GuiControl, SettingsGUIA:, TextInAreaFontBold, % TextInAreaFontBold
      GuiControl, SettingsGUIA:, TextInAreaFontItalic, % TextInAreaFontItalic
      ; TextInAreaFontColor := nfntObj.color
      If (doImgEditLivePreview=1)
         livePreviewsImageEditing()

      SetTimer, WriteSettingsTextAreaPanel, -100
   }
}

updateUIInsertTextPanel(actionu:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=32)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If !isNumber(TextInAreaFontLineSpacing)
       TextInAreaFontLineSpacing := 0

    If (TextInAreaBorderSize>=TextInAreaFontSize*2)
       TextInAreaBorderSize := TextInAreaFontSize*2

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIInsertTextPanel, -200
       Return
    }

    If (CurrentPanelTab=1)
    {
       UserTextArea := Trimmer(UserTextArea)
       UserTextArea := allowCtrlBkspEdit(hEditField, UserTextArea)
    } Else If (CurrentPanelTab=2)
    {
       actu := (TextInAreaPaintBgr=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, TextInAreaBgrUnified
       GuiControl, % actu, TextInAreaBgrEntire
       GuiControl, % actu, TextInAreaCutOutMode

       actu := (TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, TextInAreaBgrEntire
       GuiControl, % actu, TextInAreaCutOutMode

       actu2 := (TextInAreaDoBlurs=1 && TextInAreaBorderOut>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, TextInAreaBlurBorderAmount
       GuiControl, % actu2, editF8

       actu2 := (TextInAreaDoBlurs=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, TextInAreaBlurAmount
       GuiControl, % actu2, editF6

       actu2 := (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1 || TextInAreaFillSelArea=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, TextInAreaRoundBoxBgr

       actu2 := (TextInAreaBorderOut>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, editF2
       GuiControl, % actu2, editF7
       GuiControl, % actu2, TextInAreaBorderSize
    } Else If (CurrentPanelTab=3)
    {
       thisOpacity := Round((TextInAreaBorderOpacity / 255) * 100)
       this2ndOpacity := Round((TextInAreaBgrOpacity / 255) * 100)
       this3rdOpacity := Round((TextInAreaFontOpacity / 255) * 100)
       GuiControl, SettingsGUIA:, infoFillAreaOpacity, %thisOpacity%`%
       GuiControl, SettingsGUIA:, infoFillArea2ndOpacity, %this2ndOpacity%`%
       GuiControl, SettingsGUIA:, infoPasteOpacity, %this3rdOpacity%`%

       actu := (TextInAreaBorderOut>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, txtLine1
       GuiControl, % actu, TextInAreaBorderColor
       GuiControl, % actu, TextInAreaBorderOpacity
       GuiControl, % actu, PickuTextInAreaBorderColor
       GuiControl, % actu, infoFillAreaOpacity

       actu := (TextInAreaCutOutMode=1 && TextInAreaPaintBgr=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, txtLine6
       GuiControl, % actu, TextInAreaFontColor
       GuiControl, % actu, TextInAreaFontOpacity
       GuiControl, % actu, PickuTextInAreaFontColor
       GuiControl, % actu, infoPasteOpacity

       actu := (TextInAreaPaintBgr=1 || TextInAreaFillSelArea=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, txtLine2
       GuiControl, % actu, TextInAreaBgrOpacity
       GuiControl, % actu, TextInAreaBgrColor
       GuiControl, % actu, PickuTextInAreaBgrColor
       GuiControl, % actu, infoFillArea2ndOpacity

       actu2 := (TextInAreaBorderOut>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, TextInAreaOnlyBorder
    } Else If (CurrentPanelTab=4)
    {
       updateUIalphaMaskStuff(1)
    } Else If (CurrentPanelTab=5)
       updateUIalphaMaskStuff(2)

    If (actionu!="noPreview")
       livePreviewsImageEditing(0, 0, A_ThisFunc, actionu, b)

    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    If (ShowAdvToolbar=1 && (TextInAreaPaintBgr=1 && TextInAreaCutOutMode=1 && TextInAreaBgrUnified=0 || TextInAreaFillSelArea=1))
    {
       %thisOpa% := TextInAreaBgrOpacity
    } Else If (ShowAdvToolbar=1 && TextInAreaPaintBgr=0)
    {
       %thisOpa% := TextInAreaFontOpacity
    } Else If (ShowAdvToolbar=1)
    {
       BrushToolAopacity := TextInAreaFontOpacity
       BrushToolBopacity := TextInAreaBgrOpacity
    }

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsTextAreaPanel, -300
    SetTimer, WriteSettingsBrushPanel, -350
    SetTimer, WriteSettingsAlphaMaskPanel, -250
}

WriteSettingsTextAreaPanel() {
     ReadSettingsTextInArea(1)
}

PanelPrefsWindow() {
    If AnyWindowOpen
       Return

    thisBtnHeight := createSettingsGUI(14, A_ThisFunc)
    btnWid := 100
    txtWid := 350
    columnBpos2 := 255
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos2 := columnBpos2 + 50
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Global editF4, editF5, editF6, PickuWindowBGRcolor, PickuOSDbgrColor, PickuOSDtextColor

    Gui, Add, Text, x15 y15 w%txtWid%, The text style options apply to the On-Screen Display in the viewport. The same text style is used to render as images texts pasted from the clipboard.
    Gui, Add, Text, y+15 Section, Font name
    Gui, Add, Text, xs yp+30, Font size (OSD / clipboard)
    Gui, Add, Text, xs yp+30, Text color and style
    Gui, Add, Text, xs yp+30, Alignment (captions / paste)
    Gui, Add, Text, xs yp+30, OSD background color
    Gui, Add, Text, xs yp+30, Display time (in sec.)
    Gui, Add, Text, xs yp+30, Window background color
    Gui, Add, Text, xs yp+30, Add rows in list views
    Gui, Add, Checkbox, xs yp+30 gupdateUIsettings Checked%usrTextureBGR% vusrTextureBGR, &Ambiental textured background

    Gui, Add, DropDownList, xs+%columnBpos2% ys+0 Section w190 gupdateUIsettings Sort Choose1 vOSDFontName, %OSDFontName%
    Gui, Add, Edit, xs+0 yp+30 w%editWid% r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF5, %OSDfontSize%
    Gui, Add, UpDown, vOSDfontSize Range10-350, %OSDfontSize%
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF4, %PasteFntSize%
    Gui, Add, UpDown, vPasteFntSize Range12-350, %PasteFntSize%

    Gui, Add, ListView, xs yp+30 w%editWid% h28 %CCLVO% Background%OSDtextColor% vOSDtextColor hwndhLV1,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuOSDtextColor, P
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIsettings Checked%OSDfontBolded% vOSDfontBolded, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIsettings Checked%OSDfontItalica% vOSDfontItalica, I
    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIsettings vusrTextAlign, %usrTextAlign%||Left|Right|Center
    Gui, Add, ListView,  xs+0 yp+30 gupdateUIsettings w%editWid% hp %CCLVO% Background%OSDbgrColor% vOSDbgrColor hwndhLV2,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuOSDbgrColor, P
    Gui, Add, Edit, xs+0 yp+30 gupdateUIsettings w%editWid% hp r1 limit2 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF6, %DisplayTimeUser%
    Gui, Add, UpDown, vDisplayTimeUser Range1-99, %DisplayTimeUser%
    Gui, Add, ListView, xs+0 yp+30 w%editWid% hp %CCLVO% Background%WindowBGRcolor% vWindowBGRcolor hwndhLV3,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuWindowBGRcolor, P
    Gui, Add, Edit, xs+0 yp+30 gupdateUIsettings w%editWid% hp r1 limit2 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF8, % additionalLVrows
    Gui, Add, UpDown, vadditionalLVrows Range0-15, % additionalLVrows
    Gui, Add, Edit, xs+0 yp+30 gupdateUIsettings w%editWid% hp r1 limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF7, %ambiTexBrushSize%
    Gui, Add, UpDown, vambiTexBrushSize Range25-950, %ambiTexBrushSize%
    Gui, Add, Checkbox, x15 y+10 gupdateUIsettings Checked%borderAroundImage% vborderAroundImage, &Highlight image borders in the viewport

    PopulateFontsList("OSDFontName", "SettingsGUIA")
    Gui, Add, Button, xm+0 y+20 h%thisBtnHeight% w%btnWid% gOpenUImenu, &More options
    Gui, Add, Button, x+5 hp w90 gPrefsCloseBTN Default, Clo&se
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Interface settings: " appTitle)
}

PanelAdjustToneMapping() {
    If AnyWindowOpen
       Return

    IniAction(0, "cmrRAWtoneMapAlgo", "General", 2, 1, 3)
    IniAction(0, "cmrRAWtoneMapParamA", "General", 2, -8, 10)
    IniAction(0, "cmrRAWtoneMapParamB", "General", 2, -8, 10)
    thisBtnHeight := createSettingsGUI(42, A_ThisFunc)
    btnWid := 100
    txtWid := 500
    columnBpos2 := 205
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos2 := columnBpos2 + 50
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 20
       Gui, Font, s%LargeUIfontValue%
    }

    If (cmrRAWtoneMapAlgo=1)
    {
       prcA := cmrRAWtoneMapParamA/9.9
       paramA := Round(200*prcA)
       prcB := (cmrRAWtoneMapParamB + 8)/16
       paramB := Round(200*prcB)
    } Else If (cmrRAWtoneMapAlgo=2)
    {
       prcA := (cmrRAWtoneMapParamA + 8)/16
       paramA := Round(200*prcA)
       paramB := 200*cmrRAWtoneMapParamB
    } Else If (cmrRAWtoneMapAlgo=3)
    {
       paramA := 200*cmrRAWtoneMapParamA
       paramB := 200*cmrRAWtoneMapParamB
    }

    showTOOLtip("Initializing tone-mapping panel, please wait")
    Global SliderA, SliderB, infoSliderA, infoSliderB
    Gui, -DPIScale
    Gui, Add, Text, x15 y15 w460 h320 +0x1000 +0xE +hwndhLVmainu, Image before 
    Gui, Add, Text, x480 y15 w460 h320 +0x1000 +0xE +hwndhCropCornersPic, Image after
    ; Gui, Add, Text, xp-480 y+1 w2 h2 +0x1000 +0xE, -
    Gui, +DPIScale
    Gui, Add, Text, x15 y+10 Section w%txtWid%, High-dynamic range images (HDRIs) must be converted to 32 bits to be displayed on screen. You can choose the algorithm to use for this and also configure it.
    Gui, Add, DropDownList, xs y+10 w%txtWid% AltSubmit gupdateUItoneMappingPanel Choose%cmrRAWtoneMapAlgo% vcmrRAWtoneMapAlgo, Adaptive logarithmic mapping (F. Drago, 2003)|HDR reduction inspired by photoreceptors physiology (E. Reinhard, 2005)|Gradient domain HDR compression (R. Fattal, 2002)
    Gui, Add, Text, xs y+10 wp vinfoSliderA, ParamA
    Gui, Add, Slider, Center xs y+5 wp gupdateUItoneMappingPanel AltSubmit ToolTip NoTicks vsliderA Range1-200, % ParamA
    Gui, Add, Text, xs y+10 wp vinfoSliderB, ParamB
    Gui, Add, Slider, Center xs y+5 wp gupdateUItoneMappingPanel AltSubmit ToolTip NoTicks vsliderB Range1-200, % ParamB
    friendly := (PrefsLargeFonts=1) ? "`n" : ""
    Gui, Add, Checkbox, xs y+10 gupdateUItoneMappingPanel Checked%userHQraw% vuserHQraw, Load camera RAW images at high quality`nEnable this to have tone-mapping apply%friendly%on RAW images as well

    initializeFimPreviewIMG(getIDimage(currentFileIndex))
    Gui, Add, Button, xs+0 y+25 h%thisBtnHeight% w35 gBtnPrevToneMapPic +hwndhBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gBtnNextToneMapPic +hwndhBtnNextImg, >>
    ToolTip2ctrl(hBtnNextImg, "Next image")
    ToolTip2ctrl(hBtnPrevImg, "Previous image")
    Gui, Add, Button, x+5 h%thisBtnHeight% w%btnWid% gBTNtoneMapRefresh Default, &Update viewport
    Gui, Add, Button, x+5 hp w90 gBTNresetToneMap, &Reset
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, Clo&se
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "HDR tone-mapping options: " appTitle, winPos)
    RemoveTooltip()
    SetTimer, updateUItoneMappingPanel, -350
}

BtnNextToneMapPic() {
    If globalhFIFimg
    {
       ; related to PanelAdjustToneMapping()
       FreeImage_UnLoad(globalhFIFimg)
       globalhFIFimg := ""
    }
    BtnNextImg()
    updateUIfimBeforeIMG("r")
    initializeFimPreviewIMG(getIDimage(currentFileIndex))
}

BtnPrevToneMapPic() {
    If globalhFIFimg
    {
       ; related to PanelAdjustToneMapping()
       FreeImage_UnLoad(globalhFIFimg)
       globalhFIFimg := ""
    }

    BtnPrevImg()
    updateUIfimBeforeIMG("r")
    initializeFimPreviewIMG(getIDimage(currentFileIndex))
}

initializeFimPreviewIMG(imgPath) {
  Static uiBoxW := 460, uiBoxH := 320
  initFIMGmodule()
  If !wasInitFIMlib
     Return 0

  If globalhFIFimg
  {
     FreeImage_UnLoad(globalhFIFimg)
     globalhFIFimg := ""
  }

  loadArgs := 0
  GFT := FreeImage_GetFileType(imgPath)
  If (GFT=34 && loadArgs=0)
     loadArgs := 0
  Else If (GFT=2 && loadArgs=0)
     loadArgs := 8

  hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
  If hFIFimgA
  {
     FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
     calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
     imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
     ColorsType := FreeImage_GetColorType(hFIFimgA)
     mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba")) || (imgBPP>64) ? 1 : 0
     If (mustApplyToneMapping=1)
        hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, 0)
  }

  If !hFIFimgB
  {
     FreeImage_UnLoad(globalhFIFimg)
     globalhFIFimg := ""
     Return 0
  }

  globalhFIFimg := hFIFimgB ? hFIFimgB : 0
  If !globalhFIFimg
     Return 0
  Else
     Return 1
}

updateUIfimBeforeIMG(modus:=0) {
   Static prevImg := 0
   Static uiBoxW := 460, uiBoxH := 320
   If (modus="r")
   {
      prevImg := 0
      Return
   }

   thisImg := getIDimage(currentFileIndex) "|" currentFileIndex "|" maxFilesIndex "|" globalhFIFimg
   If (prevImg!=thisImg)
   {
      tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, coreDesiredPixFmt)
      If !tempBMP
      {
         prevImg := 0
         Return 0
      }
 
      Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
      If !Gu
      {
         prevImg := 0
         trGdip_DisposeImage(tempBMP, 1)
         Return 0
      }
 
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
      thisX := uiBoxW//2 - thisW//2
      thisY := uiBoxH//2 - thisH//2
      Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
      r1 := trGdip_DrawImage(A_ThisFunc, Gu, useGdiBitmap(), thisX, thisY, thisW, thisH)
      hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
      SetImage(hLVmainu, hBitmap)
      Gdi_DeleteObject(hBitmap)
      trGdip_DisposeImage(tempBMP, 1)
      Gdip_DeleteGraphics(Gu)
      prevImg := thisImg
   }
}

updateUIfimToneMappedIMG() {
   Static uiBoxW := 460, uiBoxH := 320
   If !globalhFIFimg
   {
      showTOOLtip("ERROR: The image loaded does not have high color depth required for tone mapping.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   updateUIfimBeforeIMG()
   hFIFimgE := FreeImage_ToneMapping(globalhFIFimg, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
   imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgE), "-"))
   If (imgBPPc!=32)
      hFIFimgD := FreeImage_ConvertTo(hFIFimgE, "32Bits")

   hFIFimgZ := hFIFimgD ? hFIFimgD : hFIFimgE
   pBitmap := ConvertFIMtoPBITMAP(hFIFimgZ)

   tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, coreDesiredPixFmt)
   If !tempBMP
   {
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      trGdip_DisposeImage(tempBMP, 1)
      Return
   }

   Gdip_GetImageDimensions(pBitmap, imgW, imgH)
   calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
   thisX := uiBoxW//2 - thisW//2
   thisY := uiBoxH//2 - thisH//2
   Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
   r1 := trGdip_DrawImage(A_ThisFunc, Gu, pBitmap, thisX, thisY, thisW, thisH)
   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
   SetImage(hCropCornersPic, hBitmap)
   Gdi_DeleteObject(hBitmap)
   trGdip_DisposeImage(tempBMP, 1)
   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(pBitmap, 1)

   FreeImage_UnLoad(hFIFimgE)
   If hFIFimgD
      FreeImage_UnLoad(hFIFimgD)
}

BTNtoneMapRefresh() {
   updateUItoneMappingPanel()
   discardViewPortCaches()
   disposeCacheIMGs()
   RefreshImageFileAction()
}

BTNresetToneMap() {
   If (AnyWindowOpen!=42)
      Return

   Gui, SettingsGUIA: Default
   GuiControl, SettingsGUIA: Choose, cmrRAWtoneMapAlgo, 1
   GuiControl, SettingsGUIA:, SliderA, 38
   GuiControl, SettingsGUIA:, SliderB, 100
   Sleep, 1
   updateUItoneMappingPanel()
}

updateUItoneMappingPanel() {
   Static lastInvoked := 1
   If (AnyWindowOpen!=42)
      Return

   If (A_TickCount - lastInvoked<100)
   {
      SetTimer, updateUItoneMappingPanel, -250
      Return
   }

   Gui, SettingsGUIA: Default
   GuiControlGet, cmrRAWtoneMapAlgo
   GuiControlGet, SliderA
   GuiControlGet, SliderB
   GuiControlGet, userHQraw
   prcA := SliderA/200
   prcB := SliderB/200
   If (cmrRAWtoneMapAlgo=1)
   {
      cmrRAWtoneMapParamA := 9.9*prcA
      GuiControl, SettingsGUIA:, infoSliderA, Gamma: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := 16*prcB - 8
      GuiControl, SettingsGUIA:, infoSliderB, Exposure: %cmrRAWtoneMapParamB%
   } Else If (cmrRAWtoneMapAlgo=2)
   {
      cmrRAWtoneMapParamA := 16*prcA - 8
      GuiControl, SettingsGUIA:, infoSliderA, Intensity: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := prcB
      GuiControl, SettingsGUIA:, infoSliderB, Contrast: %cmrRAWtoneMapParamB%
   } Else If (cmrRAWtoneMapAlgo=3)
   {
      cmrRAWtoneMapParamA := prcA
      GuiControl, SettingsGUIA:, infoSliderA, Saturation: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := prcB
      GuiControl, SettingsGUIA:, infoSliderB, Attenuation: %cmrRAWtoneMapParamB%
   }

   updateUIfimToneMappedIMG()
   IniAction(1, "cmrRAWtoneMapAlgo", "General")
   IniAction(1, "cmrRAWtoneMapParamA", "General")
   IniAction(1, "cmrRAWtoneMapParamB", "General")
   lastInvoked := A_TickCount
}

updateUIsettings() {
     If (AnyWindowOpen!=14)
        Return

     Gui, SettingsGUIA: Default
     Gui, SettingsGUIA: Submit, NoHide

     calcHUDsize()
     setLVrowsCount()
     msgDisplayTime := DisplayTimeUser*1000
     SetTimer, WriteSettingsUI, -90
     If !throwErrorNoImageLoaded(1)
        SetTimer, RefreshImageFile, -250
}

WriteSettingsUI() {
  INIaction(1, "ambiTexBrushSize", "General")
  INIaction(1, "borderAroundImage", "General")
  INIaction(1, "DisplayTimeUser", "General")
  INIaction(1, "OSDfontBolded", "General")
  INIaction(1, "OSDfontItalica", "General")
  INIaction(1, "OSDbgrColor", "General")
  INIaction(1, "OSDfontSize", "General")
  INIaction(1, "OSDFontName", "General")
  INIaction(1, "OSDtextColor", "General")
  INIaction(1, "PasteFntSize", "General")
  INIaction(1, "usrTextAlign", "General")
  INIaction(1, "usrTextureBGR", "General")
  INIaction(1, "WindowBgrColor", "General")
  INIaction(1, "additionalLVrows", "General")
}

PrefsCloseBTN() {
   updateUIsettings()
   interfaceThread.ahkFunction("updateWindowColor")
   BtnCloseWindow()
}

InvokeStandardDialogColorPicker(hC, event, c, err:=0) {
; Function by Drugwash
; Critical MUST be disabled below! If that's not done, script will enter a deadlock !
  Static
  If (event="RightClick")
  {
     g := A_Gui, c := A_GuiControl
     Sleep, 1
     mouseTurnOFFtooltip()
     fn := Func("StartPickingColor").Bind("isGiven", g, c)
     SetTimer, % fn, -100
     ; SetTimer, mouseTurnOFFtooltip, -50
     Return
  } Else If (event!="Normal")
     Return

  oc := A_IsCritical
  Critical, Off

  ; ToolTip, % event , , , 2
  g := A_Gui, ctrl := A_GuiControl
  theColor := createStandardColorzDialog(%ctrl%, hC, ctrl)
  Critical, %oc%
  If (theColor="-")
     Return

  r := %ctrl% := theColor
  GuiControl, %g%:+Background%r%, %ctrl%
  If (ctrl="WindowBGRcolor")
     INIaction(1, ctrl, "General")
  Else
     RegAction(1, ctrl)

  If (AnyWindowOpen=63)
  {
     updateUIgridPanel()
  } Else If (AnyWindowOpen=14)
  {
     interfaceThread.ahkassign("WindowBGRcolor", WindowBGRcolor)
     interfaceThread.ahkFunction("updateWindowColor")
     updateUIsettings()
     refreshWinBGRbrush()
     dummyTimerDelayiedImageDisplay(50)
  } Else If (imgEditPanelOpened=1)
  {
     SetTimer, fromCurrentPanelToColorsSwatch, -200
     livePreviewsImageEditing()
  }
}

getCustomColorsFromImage(whichBitmap) {
  Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
  calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
  c := []
  c[1] := Gdip_GetPixelColor(whichBitmap, X1, Y1, 3)
  c[2] := Gdip_GetPixelColor(whichBitmap, X2, Y2, 3)
  c[3] := Gdip_GetPixelColor(whichBitmap, X1, Y2, 3)
  c[4] := Gdip_GetPixelColor(whichBitmap, X2, Y1, 3)
  c[5] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1 + imgSelH//2, 3)
  c[6] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1, 3)
  c[7] := Gdip_GetPixelColor(whichBitmap, X1, Y1 + imgSelH//2, 3)
  c[8] := Gdip_GetPixelColor(whichBitmap, X2, Y2 - imgSelH//2, 3)
  c[9] := Gdip_GetPixelColor(whichBitmap, X2 - imgSelW//2, Y2, 3)
  c[10] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//4, Y1 + imgSelH//4, 3)
  c[11] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2 + imgSelW//4, Y1 + imgSelH//2 + imgSelH//4, 3)
  c[12] := Gdip_GetPixelColor(whichBitmap, 1, 1, 3)
  c[13] := Gdip_GetPixelColor(whichBitmap, 1, imgH - 1, 3)
  c[14] := Gdip_GetPixelColor(whichBitmap, imgW - 1, imgH - 1, 3)
  c[15] := Gdip_GetPixelColor(whichBitmap, imgW - 1, 1, 3)
  c[16] := Gdip_GetPixelColor(whichBitmap, imgW//2, imgH//2, 3)
  Return c
}

createStandardColorzDialog(coloru, hwnd, ctrlName) {
  WinSet, Disable,, ahk_id %PVhwnd%
  customColors := getCustomColorsFromImage(useGdiBitmap())
  nc := Dlg_Color(coloru, hwnd, customColors)
  WinSet, Enable,, ahk_id %PVhwnd%
  If (nc="-")
     Return "-"

  theColor := Gdi_ColorRef2RGB(nc)
  If (isNowAlphaPainting()=1 && InStr(ctrlName, "brushtool"))
     theColor := convertColorToGrayscale(theColor)

  Return theColor
  ; GuiControl, %g%:+Background%r%, %ctrl%
}

OpenUImenu(givenCoords:=0) {
   deleteMenus()
   createMenuInterfaceOptions()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PvUIprefs") : givenCoords
   showThisMenu("PvUIprefs")
}

invokeTlbrContextMenu(givenCoords:=0) {
   deleteMenus()
   kMenu("PvUItoolbarMenu", "Add", "S&earch menu options`t;", "PanelQuickSearchMenuOptions", "actions")
   kMenu("PvUItoolbarMenu", "Add/Uncheck", "Show &menu bar`tF10", "ToggleQuickBaru", "toolbar")
   If (showMainMenuBar=1)
      kMenu("PvUItoolbarMenu", "Check", "Show &menu bar`tF10")

   kMenu("PvUItoolbarMenu", "Add/Uncheck", "&Show tooltips on icons", "ToggleToolBarToolTips")
   If (ShowToolTipsToolbar=1)
      kMenu("PvUItoolbarMenu", "Check", "&Show tooltips on icons")

   kMenu("PvUItoolbarMenu", "Add", "Toggle toolbar`tShift+F10", "toggleAppToolbar")
   Menu, PvUItoolbarMenu, Add

   kMenu("PvUItoolbarMenu", "Add/Uncheck", "&Vertical toolbar", "TglToolBarValign")
   If (TLBRverticalAlign=1 || TLBRtwoColumns=1)
      kMenu("PvUItoolbarMenu", "Check", "&Vertical toolbar")

   kMenu("PvUItoolbarMenu", "Add/Uncheck", "&Two columns vertical", "TLBRapplyTwoColumns")
   If (TLBRtwoColumns=1)
      kMenu("PvUItoolbarMenu", "Check", "&Two columns vertical")

   kMenu("PvUItoolbarMenu", "Add/Uncheck", "Attach to main &window", "tlbrLockPositionWin")
   If (lockToolbar2Win=1)
      kMenu("PvUItoolbarMenu", "Check", "Attach to main &window")

   Menu, PvUItoolbarMenu, Add
   kMenu("PvUItoolbarMenu", "Add", "Scale: " Round(ToolbarScaleFactor, 2) "x", "dummy")
   kMenu("PvUItoolbarMenu", "Disable", "Scale: " Round(ToolbarScaleFactor, 2) "x", "dummy")
   kMenu("PvUItoolbarMenu", "Add", "0.50x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "0.75x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "1.00x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "1.25x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "1.50x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "2.00x", "SetToolbarScaling")
   kMenu("PvUItoolbarMenu", "Add", "3.00x", "SetToolbarScaling")
   Menu, PvUItoolbarMenu, Add
   kMenu("PvUItoolbarMenu", "Add", "Help", "btnHelpToolbar")
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PvUItoolbarMenu") : givenCoords
   showThisMenu("PvUItoolbarMenu")
}

SetToolbarScaling(a, b, c) {
   ToolbarScaleFactor := StrReplace(a, "x")
   IniAction(1, "ToolbarScaleFactor", "General")
   createGUItoolbar()
}

InvokeOpenRecentMenu(givenCoords:=0) {
   deleteMenus()
   createMenuOpenRecents()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVopenF") : givenCoords
   showThisMenu("PVopenF")
}

PanelDefineEntireSlideshowLength() {
    Global userHourDur, userMinDur, userSecDur, infoLine, userDefinedSpeedSlideshow
    If StrLen(mustOpenStartFolder)>3
    {
       currentFileIndex := doOpenStartFolder()
       Return
    }

    If (maxFilesIndex<3)
       Return

    thisBtnHeight := createSettingsGUI(19, A_ThisFunc)
    btnWid := 130
    txtWid := 350
    EditWid := 35
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 2
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    infoSliSpeed := DefineSlidesRate()
    etaTime := EstimateSlideShowLength()
    infou := groupDigits(maxFilesIndex)
    Gui, Add, Text, x15 y15 Section w%txtWid%, Define the total time of the slideshow`nfor %infou% images.
    Gui, Add, Text, y+15 w85, Hours
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserHourDur, % Round(Hrs)
    Gui, Add, Checkbox, x+5 hp Checked%doSlidesTransitions% vdoSlidesTransitions gUpdateSlideshowPanel, &Smooth slide transitions
    Gui, Add, Text, xs y+5 w85, Minutes
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserMinDur, % Round(Min)
    Gui, Add, Text, xs y+5 wp, Seconds
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserSecDur, % Round(Sec)
    Gui, Add, Text, xs y+5 wp, Speed
    Gui, Add, DropDownList, x+5 wp gChooseSlideSpeed AltSubmit vuserDefinedSpeedSlideshow, ---||30 FPS|15 FPS|7 FPS|2 FPS|1 sec.|2 sec.|4 sec.|8 sec.|16 sec.
    Gui, Add, Button, x+5 hp w75 gTimeLapseInfoBox, Infos
    thisW := (PrefsLargeFonts=1) ? 105 : 80
    Gui, Add, Button, x+5 hp w%thisW% gSetTimeLapseMode, Timelapse
    Gui, Add, Text, xs y+5 w85, Mode
    Gui, Add, DropDownList, x+5 wp gUpdateSlideshowPanel AltSubmit Choose%SlideHowMode% vSlideHowMode, Random|Backwards|Forwards
    Gui, Add, Checkbox, x+5 hp Checked%allowGIFsPlayEntirely% vallowGIFsPlayEntirely gUpdateSlideshowPanel, &Allow GIFs play entirely

    Gui, Add, Text, xs y+15 w%txtWid% vinfoLine, One image every: %infoSliSpeed%`nEstimated slideshow duration: %etaTime%
    Gui, Add, Text, xp+15 y+7 wp-20, - based on current file index position, direction and previous image load time;

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gStartSlideINtotalTimeBTNaction, &Start slideshow
    Gui, Add, Button, x+5 hp w90 gResetSlideSpeed, De&fault
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Define total slideshow time: " appTitle)
}

TimeLapseInfoBox() {
    msgBoxWrapper(appTitle ": HELP", "The estimated slideshow duration displayed in the panel includes the time estimated to load each image. Based on previously loaded images, it takes about " groupDigits(drawModeCzeit) " miliseconds to load an image.`n `nIf the option to allow GIFs play entirely during slideshows is selected, the duration of the slideshow will be influenced by how many GIFs are indexed and how long they are.`n `nFor optimal timelapses [or very fast slideshows] set zoom at 100`%, disable image rotation and color adjustments and «skip already seen images».", -1, 0, 0)
}

SetTimeLapseMode() {
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to set slideshow mode to timelapse? This will set zoom level to 100% and disable any image effect or adjustment.`n`nThe slideshow speed will be set at ~30 FPS [33 images/sec.].", 4, 0, "question")
    If (msgResult="Yes")
    {
       IMGresizingMode := 4
       customZoomAdaptMode := 0
       interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
       mustRecordSeenImgs := 0
       imgFxMode := usrColorDepth := zoomLevel := 1
       vpIMGrotation := FlipImgH := FlipImgV := 0
       coreResetSlideSpeed(33, 1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 2
       dummyTimerDelayiedImageDisplay(50)
    }
}

ResetSlideSpeed() {
    coreResetSlideSpeed(4000, 1)
    GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 8
}

ChooseSlideSpeed() {
    GuiControlGet, userDefinedSpeedSlideshow
    If (userDefinedSpeedSlideshow=2)
       coreResetSlideSpeed(33, 1)
    Else If (userDefinedSpeedSlideshow=3)
       coreResetSlideSpeed(67, 1)
    Else If (userDefinedSpeedSlideshow=4)
       coreResetSlideSpeed(143, 1)
    Else If (userDefinedSpeedSlideshow=5)
       coreResetSlideSpeed(500, 1)
    Else If (userDefinedSpeedSlideshow=6)
       coreResetSlideSpeed(1000, 1)
    Else If (userDefinedSpeedSlideshow=7)
       coreResetSlideSpeed(2000, 1)
    Else If (userDefinedSpeedSlideshow=8)
       coreResetSlideSpeed(4000, 1)
    Else If (userDefinedSpeedSlideshow=9)
       coreResetSlideSpeed(8000, 1)
    Else If (userDefinedSpeedSlideshow=10)
       coreResetSlideSpeed(16000, 1)
}

coreResetSlideSpeed(varu, noDDLjump:=0) {
    slideShowDelay := varu
    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    GuiControl, SettingsGUIA:, userHourDur, % Round(Hrs)
    GuiControl, SettingsGUIA:, userMinDur, % Round(Min)
    GuiControl, SettingsGUIA:, userSecDur, % Round(Sec)
    If (noDDLjump!=1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    DefineSlidesTotalTimeBTNaction(0)
}

DefineSlidesRate() {
   slidesDuration := slideShowDelay
   ; slidesDuration := (slideShowDelay<drawModeCzeit) ? Round((drawModeCzeit*0.7+slideShowDelay)//2) : slideShowDelay
  ; If (slidesDuration<1995 && slidesDuration!=1000)
  ;    miliSec := slidesDuration " milisec."
   ; Else
      duration := SecToHHMMSS(Round(slidesDuration/1000, 3))
   Return miliSec ? miliSec : duration
}

StartSlideINtotalTimeBTNaction() {
   DefineSlidesTotalTimeBTNaction(0)
   BtnCloseWindow()
   Sleep, 300
   delayu := (thumbsDisplaying=1) ? 400 : 25
   lastOtherWinClose := 1
   If (thumbsDisplaying=1)
      ToggleThumbsMode()
   Settimer, dummyInfoToggleSlideShowu, % -delayu
}

UpdateSlideshowPanel() {
    Static lastInvoked := 1
    If (AnyWindowOpen!=19)
       Return

    Gui, SettingsGUIA: Default
    DefineSlidesTotalTimeBTNaction()
    GuiControlGet, doSlidesTransitions
    GuiControlGet, allowGIFsPlayEntirely
    GuiControlGet, WhatsFocused, SettingsGUIA: FocusV
    GuiControlGet, WhatsFocused, SettingsGUIA: FocusV
    actu := (slideShowDelay<900) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
    GuiControl, % actu, doSlidesTransitions

    INIaction(1, "doSlidesTransitions", "General")
    INIaction(1, "allowGIFsPlayEntirely", "General")
    If (WhatsFocused="userHourDur" || WhatsFocused="userMinDur" || WhatsFocused="userSecDur")
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    lastInvoked := A_TickCount
}

DefineSlidesTotalTimeBTNaction(doDDLjump:=1) {
    If (AnyWindowOpen!=19)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, SlideHowMode
    GuiControlGet, userHourDur
    GuiControlGet, userMinDur
    GuiControlGet, userSecDur
    slideShowDelay := 0    
    slideShowDelay += userSecDur*1000
    slideShowDelay += (userMinDur*60)*1000
    slideShowDelay += ((userHourDur*60)*60)*1000
    slideShowDelay := Round(slideShowDelay/maxFilesIndex)
    If (slideShowDelay<16)
       slideShowDelay := 16

    etaTime := EstimateSlideShowLength()
    infoSliSpeed := DefineSlidesRate()
    IniAction(1, "SlideHowMode", "General")
    GuiControl, SettingsGUIA:, InfoLine, One image every: %approxMarker%%infoSliSpeed%`nEstimated slideshow duration: %approxMarker%%etaTime%
}

EstimateSlideShowLength(noPrecision:=0) {
    slidesDuration := (slideShowDelay<drawModeCzeit) ? (drawModeCzeit + slideShowDelay)/2 : drawModeCzeit*0.9 + slideShowDelay
    ; slidesDuration := (slideShowDelay<drawModeCzeit) ? drawModeCzeit : slideShowDelay
    approxMarker := (slideShowDelay<drawModeCzeit) ? "~" : ""
    If (SlideHowMode=1)
       infoFilesSel := maxFilesIndex - RandyIMGnow
    Else If (SlideHowMode=2)
       infoFilesSel := currentFileIndex
    Else If (SlideHowMode=3)
       infoFilesSel := maxFilesIndex - currentFileIndex
    Else
       infoFilesSel := (maxFilesIndex>0) ? maxFilesIndex : 1
    slidesDuration := Round(slidesDuration/1000, 3) * infoFilesSel
    ; MsgBox, % etaTime "--" slidesDuration "--" slideShowDelay "--" drawModeCzeit "--" maxFilesIndex
    etaTime := approxMarker SecToHHMMSS(slidesDuration)
    If (noPrecision=1)
       etaTime := RegExReplace(etaTime, "\...s", "s")
    Return etaTime
}

jumpPreviousImage() {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If askAboutFileSave(" and another image will be loaded")
       Return

    currentFileIndex := clampInRange(prevLastImg[2, 1], 1, maxFilesIndex)
    dummyTimerDelayiedImageDisplay(50)
}

PanelJump2index() {
   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to open panel")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (RandyIMGnow=-1 || !RandyIMGids.Count())
      coreGenerateRandomList()

   imgPath := getIDimage(currentFileIndex)
   isAnim := (RegExMatch(imgPath, "i)(.\.(gif))$") && totalFramesIndex>1) ? "`fSkip to given frame index" : ""
   fakeWinCreator(13, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Skip to given index: " appTitle, "Please type a number to skip at in the files list`nand choose the action.`n`nTotal entries: " groupDigits(maxFilesIndex) "`nCurrent random index: " groupDigits(RandyIMGnow), "&Skip to...|C&ancel", 1, "fast-forward", 0, 0, "Skip to the given file index`f`fSkip to the given index in the random list`fSelect from the current file index to the given index" isAnim, "limit9050 +number", currentFileIndex, 2)
   If InStr(msgResult.btn, "skip")
   {
      usrJumpIndex := Trimmer(msgResult.edit)
      If !usrJumpIndex
         Return

      newJumpIndex := clampInRange(usrJumpIndex, 1, maxFilesIndex)
      If (newJumpIndex=currentFileIndex && newJumpIndex>0 && msgResult.list!=4)
         Return

      If askAboutFileSave(" and another image will be loaded")
         Return

      If (IsNumber(newJumpIndex) && newJumpIndex>=1)
      {
         If (msgResult.list=4)
         {
            desiredFrameIndex := clampInRange(usrJumpIndex, 1, totalFramesIndex)
            RefreshImageFile()
            Return
         } Else If (msgResult.list=2)
         {
            RandyIMGnow := newJumpIndex
            currentFileIndex := clampInRange(RandyIMGids[newJumpIndex], 1, maxFilesIndex)
            ; ToolTip, % RandyIMGids "==" newJumpIndex "==" currentFileIndex , , , 2
            RefreshImageFile()
            Return
         } Else If (msgResult.list=3)
            jumpSelectRangeGiven(currentFileIndex, newJumpIndex)

         currentFileIndex := newJumpIndex
         dummyTimerDelayiedImageDisplay(50)
      }
   }
}

SaveClipboardImage(dummy:=0, allowCropping:=0, noDialog:=0) {
   Static lastInvoked := 1, dephtus := {1:32, 2:24, 3:16, 4:8}

   If throwErrorNoImageLoaded()
      Return

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   initFIMGmodule()
   RegAction(0, "userDesireWriteFMT",, 2, 1, 16)
   INIaction(0, "prevFileSavePath", "General", 6)
   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
   defaultu := (dummy="current") ? OutDir "\" OutNameNoExt : prevFileSavePath "\" OutNameNoExt
   If !defaultu
      defaultu := prevFileSavePath "\" OutNameNoExt
   If FolderExist(dummy)
      defaultu := dummy "\" OutNameNoExt

   Loop, Parse, dialogSaveFptrn, |
   {
        If InStr(A_LoopField, "." oEXT)
           defFMTindex := A_Index
   }

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If isImgSizeTooLarge(imgW, imgH)
   {
      SoundBeep, 300, 100
      showTOOLtip("ERROR: The image size is too large. Image file saving disabled.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If alertReduceSaveColorDepth()
      Return

   If (noDialog=1)
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "PathMustExist", defaultu, "Save image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)

   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      If (FileExist(file2save) && imgPath!=file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      If FileExist(imgPath)
      {
         FileGetTime, originalMtime, % imgPath, M
         FileGetTime, originalCtime, % imgPath, C
         Sleep, 1
         FileSetAttrib, -R, % file2save
      }

      ForceRefreshNowThumbsList()
      If (AnyWindowOpen=35)
         BtnCloseWindow()

      prevFileSavePath := OutDir
      showTOOLtip("Saving image, please wait`n" OutFileName "`nIntended color format: " dephtus[userSaveBitsDepth] "-bits")
      newBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap())))
      INIaction(1, "prevFileSavePath", "General")
      lastInvoked := A_TickCount
      If StrLen(newBitmap)>2
      {
         destroyGDIfileCache(1, 1)
         changeMcursor()
         r := QPV_SaveImageFile(A_ThisFunc, newBitmap, file2save, userJpegQuality, userSaveBitsDepth)
         trGdip_DisposeImage(newBitmap, 1)
      } Else r := "err-no-main-bmp"

      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         resultedFilesList[currentFileIndex, 4] := 1
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
      }

      If r
      {
         sOutDir := PathCompact(OutDir, "a", 1, OSDfontSize)
         showTOOLtip("Failed to save image file`n" OutFileName "`n" sOutDir "\")
         msgBoxWrapper(appTitle ": ERROR", appTitle " was unable to save the image file due to an undetermined cause.`n`n" OutFileName "`n" OutDir "\`nError code: " r, 0, 0, "error")
      } Else
      {
         FileGetSize, OutputVar, % OutDir "\" OutFileName
         If (OutputVar>2)
            friendly := "`nFile size: " fileSizeFrienly(OutputVar)

         sOutDir := PathCompact(OutDir, "a", 1, OSDfontSize)
         showTOOLtip("Image file succesfully saved`n" OutFileName "`n" sOutDir "\" friendly)
         testMem := getIDimage(currentFileIndex)
         lastZeitIMGsaved := [A_Now, currentUndoLevel, undoLevelsRecorded, OutFileName, OutDir, currentFileIndex]
         If (currentFileIndex=0 && maxFilesIndex<1) || (InStr(testMem, "\temporary memory object\") && maxFilesIndex<1)
         {
            currentFileIndex := maxFilesIndex := 1
            resultedFilesList[1, 1] := file2save
            DynamicFoldersList := OutDir "`n"
            prevOpenFolderPath := OutDir
            CurrentSLD := "|" OutDir
            SLDtypeLoaded := 1
         ; } Else If (imgPath!=file2save && StrLen(filesFilter)<2)
         ; {
         ;    obju := [file2save]
         ;    resultedFilesList.InsertAt(currentFileIndex, obju)
         ;    currentFileIndex++
         ;    maxFilesIndex++
         } Else If (imgPath=file2save)
            resultedFilesList[currentFileIndex, 1] := file2save

         If (SLDtypeLoaded=3)
            selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

         imgIndexEditing := currentFileIndex
         currentImgModified := 2
      }

      SoundBeep, % r ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -50
   }
}

BtnCpyMvChooseFilesDest() {
   If (currentFileIndex=0)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   SelectedDir := openFoldersDialogWrapper("S2", prevFileMovePath)
   SelectedDir := Trimmer(SelectedDir)
   If FolderExist(SelectedDir)
   {
      GuiControl, SettingsGUIA:, UsrEditFileDestination, % SelectedDir
   } Else
   {
      WinActivate, ahk_id %hSetWinGui%
   }
}

zPlitPath(inputu, fastMode, ByRef fileNamu, ByRef folderu, ByRef fileNamuNoEXT:=0, ByRef fileEXT:=0) {
    If (fastMode=0)
    {
       inputu := Trimmer(StrReplace(inputu, "|"))
       FileGetAttrib, OutputAttribs, %inputu%
    } Else StringRight, OutputVar, inputu, 1

    If InStr(OutputAttribs, "D") || (OutputVar="\")
    {
       ; ToolTip, % OutputVar , , , 2
       ; SoundBeep , 300, 100
       folderu := inputu
       fileEXT := fileNamuNoEXT := fileNamu := ""
    } Else
    {
       lineArr := StrSplit(inputu, "\")
       maxuIndex := lineArr.Count()
       fileNamu := lineArr[maxuIndex]
       fileParentFolder := lineArr[maxuIndex - 1]
       ; folderu := SubStr(inputu, 1, StrLen(inputu) - StrLen(fileNamu) - 1)
       ; fileEXTpos := RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
       fileEXTpos := InStr(fileNamu, ".", 0, -1) ; RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
       If fileEXTpos
          fileEXT := Trimmer(SubStr(fileNamu, fileEXTpos + 1))

       If (fileExt="" || StrLen(fileExt)>4)
       {
          fileNamu := fileEXTpos := ""
          folderu := Trim(Trimmer(inputu), "\")
       } Else
       {
          folderu := ""
          Loop, % maxuIndex - 1
          {
             If (lineArr[A_Index]!="")
                folderu .= lineArr[A_Index] "\"
          }
          folderu := Trim(folderu, "\")
       }

       ; fileNamuNoEXT := fileEXTpos ? RegExReplace(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$") : fileNamu
       fileNamuNoEXT := fileEXTpos!="" ? SubStr(fileNamu, 1, fileEXTpos - 1) : fileNamu
    }
    Return fileParentFolder
}

StringToASC(string) {
   Static lastInvoked, lastAsc
   If (String="")
      Return

   If (string=lastInvoked)
      Return lastAsc

   ; AscString := StrLen(string)
   Loop, Parse, string 
      AscString .= RegExMatch(A_LoopField, "[[:alnum:]]") ? A_LoopField : Ord(A_LoopField)

   ; ToolTip, % AscString , , , 2 
   lastInvoked := string
   lastAsc := AscString
   Return AscString
}

readRecentFileDesties(modus:=0) {
   listu := ""
   If (modus!=1)
   {
      If FolderExist(prevFileMovePath)
         listu .= prevFileMovePath "`n"
      If FolderExist(prevFileSavePath)
         listu .= prevFileSavePath "`n"
      If FolderExist(prevOpenFolderPath)
         listu .= prevOpenFolderPath "`n"
   }

   Loop, 15
   {
       IniRead, newEntry, % mainRecentsFile, RecentFDestinations, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (FolderExist(newEntry) && !InStr(listu, newEntry "`n"))
          listu .= newEntry "`n"
   }
   Return listu
}

PanelMoveCopyFiles() {
   UsrCopyMoveOperation := 2
   CopyMovePanelWindow()
}

InvokeCopyFiles() {
   UsrCopyMoveOperation := 3
   If (maxFilesIndex>0)
      CopyMovePanelWindow()
}

CopyMovePanelWindow() {
    Global BtnCpyMv, LViewDynas, lastInvoked := 1
    ; Static prevmainDynaFoldersListu, prevCurrentSLD

    openingPanelNow := 1
    thisBtnHeight := createSettingsGUI(9, A_ThisFunc)
    sml := (PrefsLargeFonts=1) ? 90 : 72
    btnWid := 125
    btnWid2 := 60
    txtWid := 360
    EditWid := 385
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       btnWid2 += 60
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    EditWid -= sml
    lstWid := sml + editWid

    ToolTip, Please wait...,,, 2
    listu := readRecentFileDesties()
    listu .= "--={ other destinations }=--`n"
    setImageLoading()
    historyList := readRecentEntries()
    Loop, Parse, historyList, `n
    {
       If (A_Index>10)
          Break 

       If StrLen(A_LoopField<4)
          Continue 

       changeMcursor()
       OutDir := StrReplace(A_LoopField, "|")
       If InStr(listu, OutDir "`n") || !FolderExist(OutDir)
          Continue

       listu .= OutDir "`n"
    } 

    thisDynaList := getDynamicFoldersList()
    ; DynamicFoldersList := mainDynaFoldersListu
    prevCurrentSLD := CurrentSLD
    lastInvoked := A_TickCount

    Loop, Parse, thisDynaList, `n
    {
        If (A_Index>15)
           Break

        If StrLen(A_LoopField)<4
           Continue

        changeMcursor()
        folderu := StrReplace(A_LoopField, "|")
        If InStr(listu, folderu "`n") || !FolderExist(folderu)
           Continue

        listu .= folderu "`n"
    }

    List_MakeUnique(listu, "`n", 0, 0)
    Loop, Parse, listu, `n
    {
        If !A_LoopField
           Continue

        changeMcursor()
        ; indexu := InStr(A_LoopField, "{ other dest") ? "" : A_Index - 1 "; "
        finalListu .= A_LoopField "`n"
        If (A_Index=1)
           finalListu .= "`n"
    }

    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       finalListu .= "[group-by-month-year]`n[group-by-years]`n[group-by-file-types]"
       copyMoveDoLastOption := 0
       infoSelection := "Selected files: " markedSelectFile ". "
    }

    Gui, +Delimiter`n
    sml := (PrefsLargeFonts=1) ? 90 : 72
    Gui, Add, Text, x15 y15 Section, %infoSelection%Please browse, select or type a destination folder:
    Gui, Add, Edit, xs y+10 w%EditWid% gUIeditsGenericAllowCtrlBksp vUsrEditFileDestination, % prevFileMovePath
    Gui, Add, Button, x+1 w%sml% hp gBtnCpyMvChooseFilesDest, &Browse
    Gui, Add, ListView, xs y+5 w%lstWid% gBTNlvRecentFileDesties -multi r10 Grid AltSubmit vLViewDynas +hwndhLVmainu, #`nRecent destination folders
    Gui, Add, Checkbox, y+10 Checked%copyMoveDoLastOption% vcopyMoveDoLastOption, When file name(s) collide, use previously given answer
    If (markedSelectFile>1)
       GuiControl, Disable, copyMoveDoLastOption

    Loop, Parse, finalListu, `n
    {
       If StrLen(A_LoopField)>2
          LV_Add(A_Index, A_Index, A_LoopField)
    }

    Loop, 3
        LV_ModifyCol(A_Index, "AutoHdr Left")

    ToolTip,,,,2
    SetTimer, ResetImgLoadStatus, -50
    btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
    Gui, Add, DropDownList, xs y+20 w%btnWid% gchangeCopyMoveAction AltSubmit Choose%UsrCopyMoveOperation% vUsrCopyMoveOperation, Action to perform...`nMove file(s)`nCopy file(s)
    Gui, Add, Button, x+5 hp wp-25 gEraseCopyMoveHisto, Erase &history

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBtnCopyMoveAction vBtnCpyMv, &Proceed
    Gui, Add, Button, x+5 hp wp+85 gBtnMarkFilesExplorer, &Mark file(s) (Explorer)
    Gui, Add, Button, x+5 hp w70 gBtnHelpCopyMovePanel, Hel&p
    Gui, Add, Button, x+5 hp wp+10 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, btnName " file(s) to...: " appTitle)
    SetTimer, resetOpeningPanel, -300
}

BTNlvRecentFileDesties(a, b, c) {
   If !(b="RightClick" || b="k" ||  b="normal" || b="DoubleClick")
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(givenName, RowNumber, 2)
   GuiControl, SettingsGUIA: , UsrEditFileDestination, % givenName
   If (b="DoubleClick")
      BtnCopyMoveAction()
}

BtnHelpCopyMovePanel() {
  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  If (AnyWindowOpen=9)
     moreInfo := "`n`nIf you click on «Mark files (Explorer)» button, the selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle "."

  msgBoxWrapper(appTitle ": HELP", "Recognized patterns:`n`na) " btnName " files to parent folder: .\`n`nb) " btnName " files to a new or existing sub-folder: \given-folder`n`nc) " btnName " files into a new or exiting folder within the parent folder: .\given-folder`n`nThe destination folder for all selected files [if any] will be calculated relative to the currently focused file index entry: " groupDigits(currentFileIndex) ".`n" OutDir "`n`nUse [group-by-month-year], [group-by-years] or [group-by-file-types] as folder name to automatically group files in newly created folders named based on files' modification date or file types." moreInfo, -1, 0, 0)
}

changeCopyMoveAction() {
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrCopyMoveOperation
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  ; GuiControl, SettingsGUIA:, BtnCpyMv, &%btnName% file(s)
  Gui, SettingsGUIA: Show,, %btnName% file(s) to...: %appTitle%
  actu := (UsrCopyMoveOperation=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
  GuiControl, % actu, BtnCpyMv
}

allowCtrlBkspEdit(hwnd, oldValue) {
   Static bksp := "", delims := "|:;?!@\_/, (.-)"
   If InStr(oldValue, bksp)
   {
      ; handle ctrl+backspace
      posu := 0
      newValue := ""
      value := StrReplace(oldValue, "`t", "  ")
      value := StrReplace(value, bksp bksp, bksp)
      remPlus := 0
      delim := StrSplit(delims)
      k := ""
      For w, g in delim
      {
          If InStr(value, g bksp)
             k := g
      }

      If (k!="")
      {
         remPlus := 1
         value := StrReplace(value, k bksp, bksp k)
      }
      posuX := InStr(value, bksp)
      posuS := 0
      Loop, Parse, value
      {
         If (A_Index>=posuX)
            Break

         z := A_LoopField
         thisIndex := A_Index
         Loop, Parse, delims
         {
            If (z=A_LoopField)
            {
               posuS := thisIndex
               Break
            }
         }
      }

      a := SubStr(value, 1, posuS)
      b := SubStr(value, posuX + 1 + remPlus)
      ; TulTip(0, "==", posuX, posuS, a, b, "`n" oldValue)
      newValue := a . b
      If (newValue!=oldValue)
      {
         posuS += ST_Count(a, "`n")
         newValue := StrReplace(newValue, bksp)
         ControlSetText, , % newValue , ahk_id %hwnd%
         EM_SETSEL(hwnd, posuS, posuS)
      } Else newValue := oldValue
   } Else newValue := oldValue

   Return newValue
}

EraseCopyMoveHisto() {
  IniDelete, % mainRecentsFile, RecentFDestinations
  BtnCloseWindow()
  CopyMovePanelWindow()
}

BtnMarkFilesExplorer() {
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
  GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
  GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
  If (UsrCopyMoveOperation=1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "Please choose an action to perform: copy or move.`n`nThe selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle ".", 0, 0, "exclamation")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  BtnCloseWindow()
  If (UsrCopyMoveOperation=3)
     MenuExplorerCopyFiles()
  Else
     MenuExplorerCutFiles()
}

BtnCopyMoveAction(dummy:=0) {
  If (dummy!="quick-actu")
  {
     Gui, SettingsGUIA: Default
     GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
     GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
     GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
     If (UsrCopyMoveOperation=1)
     {
        showTOOLtip("WARNING: Please choose an action to perform: copy or move")
        SoundBeep, 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     }
  }

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  folderu := Trimmer(UsrEditFileDestination)
  folderu := StrReplace(folderu, "/", "\")
  folderu := RegExReplace(folderu, "\\{2,}", "\")
  groupingMode := 0
  If (folderu="[group-by-month-year]" || folderu="[group-by-years]" || folderu="[group-by-file-types]")
  {
     ; group files by given criteria
     groupingMode := 1
     folderu := OutDir "\" folderu
  } Else If (folderu=".\")
  {
     ; move files one level up
     folderu := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
  } Else If RegExMatch(folderu, "^(\\.)")
  {
     ; move files to a given sub-folder
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)
     If folderu
        folderu := OutDir "\" folderu
  } Else If RegExMatch(folderu, "^(\.\\.)")
  {
     ; move files to a given sibling folder
     OutDir := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)
     If folderu
        folderu := OutDir "\" folderu
  }

  folderu := StrReplace(folderu, "\\", "\")
  folderu := Trimmer(folderu, "\")
  folderu := Trimmer(folderu, ".")
  If (b := InStr(folderu, "; "))
     folderu := SubStr(folderu, b+2)

  wrongNames := 0
  testFolderu := SubStr(folderu, 4)
  Loop, Parse, testFolderu, \
  {
      IF (!filterFileName(A_LoopField) && A_LoopField)
         wrongNames := 1
  }

  If (InStr(folderu, "[group-by-month-year]") || InStr(folderu, "[group-by-file-types]") || InStr(folderu, "[group-by-years]"))
     groupingMode := 1

  If (!RegExMatch(folderu, "^(.\:\\.)") || wrongNames=1)
  {
     showTOOLtip("WARNING: Incorrect file path given:`n" folderu)
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return 0
  }

  If (FolderExist(folderu) || groupingMode=1)
  {
     Sleep, 2
     r := QuickMoveFile2Dest(folderu, copyMoveDoLastOption, groupingMode, dummy)
  } Else If (StrLen(folderu)>4)
  {
     If (dummy!="quick-actu")
        msgResult := msgBoxWrapper(appTitle, "Destination folder does not seem to exist:`n" folderu "\`n`nDo you want to create the folder?", 4, 0, "question")

     If (msgResult="yes" || dummy="quick-actu")
     {
        FileCreateDir, % folderu
        If ErrorLevel
        {
           OutDir := PathCompact(folderu, "a", 1, OSDfontSize)
           SoundBeep , 300, 100
           If (dummy="quick-actu")
              showTOOLtip("Failed to create the destination folder:`n" OutDir "\")
           Else
              msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n" folderu "\", 0, 0, "error")
           Return 0
        } Else
        {
           Sleep, 2
           r := QuickMoveFile2Dest(folderu, copyMoveDoLastOption, groupingMode, dummy)
        }
     }
  }
  ; MsgBox, %folderu% -- %newentry%
  Return r
}

RecentCopyMoveManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentFileDesties(1)

  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu,`n
  {
      If (A_LoopField=entry2add)
      {
         isAddedAlready := 1
         Break
      }
  }

  If (isAddedAlready=1)
     Return

  mainListu := entry2add "`n" mainListu
  Loop, Parse, mainListu, `n
  {
      If (A_Index>15)
         Break

      folderu := Trimmer(A_LoopField)
      folderu := Trimmer(folderu, "\")
      If (!FolderExist(folderu) || !InStr(folderu, ":\"))
         Continue

      countItemz++
      IniWrite, % folderu, % mainRecentsFile, RecentFDestinations, E%countItemz%
  }
}

QuickMoveFile2Dest(finalDest, goLastOption, groupingMode:=0, dummy:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()
 
    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       batchCopyMoveFile(finalDest, groupingMode, dummy)
       Return 0
    } 

    file2rem := getIDimage(currentFileIndex)
    zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
    If !FileExist(file2rem)
    {
       sOldOutDir := PathCompact(OldOutDir, "a", 1, OSDfontSize)
       ResetImgLoadStatus()
       SoundBeep, 300, 100 
       If (dummy="quick-actu")
          showTOOLtip("Failed to perform action. File not found or access denied.`n" OldOutFileName "`n" sOldOutDir "\")
       Else
          msgBoxWrapper(appTitle ": ERROR", "Failed to perform action. File not found or access denied.`n`n" OldOutFileName "`n" OldOutDir "\", 0, 0, "error")
       Return 0
    }

    If (groupingMode=1)
    {
       FileGetTime, originalMtime, % file2rem, M
       finalDest := determineCreateFileGroupFolder(finalDest, originalMtime, OutFileExt)
    }

    If (OldOutDir=finalDest)
    {
       sOldOutDir := PathCompact(OldOutDir, "a", 1, OSDfontSize)
       SetTimer, ResetImgLoadStatus, -200
       SoundBeep, 300, 100 
       If (dummy="quick-actu")
          showTOOLtip("WARNING: Illegal operation. The destination folder is the same with the initial location:`n" sOldOutDir "\")
       Else
          msgBoxWrapper(appTitle ": WARNING", "Illegal operation. The destination folder is the same with the initial location:`n" finalDest "\", 0, 0, "exclamation")
       Return 0
    }

    BtnCloseWindow()
    Sleep, 2
    destroyGDIfileCache()
    FileGetTime, originalCtime, % file2rem, C
    file2save := finalDest "\" OldOutFileName

    thisFileExists := 0
    forceConflictOption := (dummy="quick-actu") ? QuickFileActConflict : 0
    If (FileExist(file2save) && !FolderExist(file2save))
    {
       thisFileExists := 1
       file2save := askAboutFileCollision(file2rem, file2save, 0, goLastOption + 1, forceConflictOption, performOverwrite)
       If !file2save
       {
          OutDir := PathCompact(finalDest, "a", 1, OSDfontSize)
          showTOOLtip("WARNING: Another file with the same file name already exists in the destination folder:`n" OldOutFileName "`n" OutDir "\`nOperation aborted.")
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SetTimer, ResetImgLoadStatus, -200
          Return 0
       }
    }

    If (file2save="abort" || !file2save) && (dummy!="quick-actu")
    {
       If (UsrCopyMoveOperation!=2)
          SetTimer, InvokeCopyFiles, -150
       Else
          SetTimer, PanelMoveCopyFiles, -150
       Return 0
    }

    If (thisFileExists=1)
    {
       If (performOverwrite=1)
       {
          FileSetAttrib, -R, %file2save%
          Sleep, 5
          FileRecycle, %file2save%
          Sleep, 5
          mustPerformOperation := 1
       } Else If (performOverwrite!=2)
       {
          OutDir := PathCompact(finalDest, "a", 1, OSDfontSize)
          showTOOLtip("Operation aborted. A file with the same name already exists in the destination folder.`n" OldOutFileName "`n" OutDir "\")
          SoundBeep, 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SetTimer, ResetImgLoadStatus, -25
          Return
       } Else mustPerformOperation := 1
    } Else mustPerformOperation := 1

    If (mustPerformOperation=1)
    {
       operationExecuted := 1
       If (UsrCopyMoveOperation=2)
          FileMove, %file2rem%, %file2save%
       Else
          FileCopy, %file2rem%, %file2save%
       If ErrorLevel
          wasError := 1
    }

    If (wasError!=1 && operationExecuted=1)
    {
       updateDates := 1
       If (originalMtime)
       {
          FileSetTime, % originalMtime, % file2save, M
          FileSetTime, % originalCtime, % file2save, C
          updateDates := 0
       }

       If (dummy!="quick-actu")
       {
          prevFileMovePath := finalDest
          INIaction(1, "prevFileMovePath", "General")
          RecentCopyMoveManager(finalDest)
       }

       actName := (UsrCopyMoveOperation=2) ? "MOVED" : "COPIED"
       zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
       OutDir := PathCompact(finalDest, "a", 1, OSDfontSize)
       showTOOLtip("File " actName " to`n" OldOutFileName "`n" OutDir "\")
       If (UsrCopyMoveOperation=2)
       {
          resultedFilesList[currentFileIndex, 1] := file2save
          updateMainUnfilteredList(currentFileIndex, 1, file2save)
          If (SLDtypeLoaded=3)
             updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[currentFileIndex, 12])
       }
       Sleep, 1
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -25
       Return 1
    } Else If (operationExecuted=1)
    {
       actName := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
       OutDir := PathCompact(finalDest, "a", 1, OSDfontSize)
       showTOOLtip("ERROR: Failed to " actName " file:`n" OldOutFileName "To destination:`n" OutDir "\")
       SoundBeep, 300, 100
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -25
    Return 0
}

determineCreateFileGroupFolder(oFinalDest, originalMtime, OutFileExt) {
   If ((InStr(oFinalDest, "[group-by-month-year]") && originalMtime)
   || (InStr(oFinalDest, "[group-by-file-types]") && OutFileExt)
   || (InStr(oFinalDest, "[group-by-years]") && originalMtime))
   {
      FormatTime, grouper, % originalMtime, yyyy-MM-MMMM
      FormatTime, groupery, % originalMtime, yyyy
      finalDest := StrReplace(oFinalDest, "[group-by-month-year]", grouper)
      finalDest := StrReplace(finalDest, "[group-by-file-types]", OutFileExt)
      finalDest := StrReplace(finalDest, "[group-by-years]", groupery)
      If !FolderExist(finalDest)
      {
         FileCreateDir, % finalDest
         Sleep, 2
      }
   } Else finalDest := oFinalDest 
   Return FinalDest
}

batchCopyMoveFile(finalDest, groupingMode:=0, dummy:=0) {
   Static lastInvoked := 1
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>150) ; ((A_TickCount - lastInvoked > 29500) && dummy!="quick-actu")
   {
      wording := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to " wording " the selected files.`n`nSelected " groupDigits(filesElected) " files`nDestination: " finalDest "\", 4, 0, "question")
      If (msgResult!="Yes")
         Return 0
   }

   BtnCloseWindow()
   lastInvoked := A_TickCount
   friendly := (UsrCopyMoveOperation=2) ? "Moving " : "Copying "
   showTOOLtip(friendly groupDigits(filesElected) " files to`n" finalDest "\`nPlease wait")
   If (dummy!="quick-actu")
   {
      prevFileMovePath := finalDest
      RecentCopyMoveManager(finalDest)
   }

   destroyGDIfileCache()
   Sleep, 25
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   countTFilez := filezMoved := failedFiles := skippedFiles := 0
   oFinalDest := finalDest
   forceConflictOption := (dummy="quick-actu") ? QuickFileActConflict : 0
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      changeMcursor()
      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
      countTFilez++
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If (OldOutDir=finalDest)
      {
         skippedFiles++
         Continue
      }

      FileGetTime, originalMtime, % file2rem, M
      FileGetTime, originalCtime, % file2rem, C
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"
         If (failedFiles>0)
            etaTime .= "`nFailed to perform action on " groupDigits(failedFiles) " files"

         showTOOLtip(friendly " files to`n" finalDest "\" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      ; grouper := ""
      If (groupingMode=1)
         finalDest := determineCreateFileGroupFolder(oFinalDest, originalMtime, OutFileExt)

      file2save := finalDest "\" OldOutFileName
      thisFileExists := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
      {
         thisFileExists := 1
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, forceConflictOption, performOverwrite)
      }
  
      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }
  
      If (thisFileExists=1)
      {
         If (performOverwrite=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 2
            FileRecycle, %file2save%
            Sleep, 2
            mustPerformOperation := 1
         } Else If (performOverwrite!=2)
         {
            skippedFiles++
            Continue
         } Else mustPerformOperation := 1
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (UsrCopyMoveOperation=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         updateDates := 1
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
            updateDates := 0
         }

         filezMoved++
         ; zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
         If (UsrCopyMoveOperation=2)
         {
            resultedFilesList[thisFileIndex, 1] := file2save
            ; resultedFilesList[thisFileIndex, 2] := 1
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[thisFileIndex, 12])

            updateMainUnfilteredList(thisFileIndex, 1, file2save)
         }
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         someErrors .= "`nFailed to commit changes to the SQL database"
   }

   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped"
   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " failedFiles " files"

   watchFolderDetails := ""
   If (UsrCopyMoveOperation=2)
      currentFilesListModified := 1

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (UsrCopyMoveOperation=2)
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   Return 0
}

batchConvert2format() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to convert " groupDigits(filesElected) " files to the ." rDesireWriteFMT " format ? "
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      If (userActionConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."
      If (OnConvertKeepOriginals!=1)
         msgInfos .= "`n`nThe original files will be ERASED."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
   BtnCloseWindow()
   setImageLoading()
   showTOOLtip("Converting to ." rDesireWriteFMT " format " groupDigits(filesElected) " files, please wait")

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>2) ? 1 : 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresConvertFormat(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("JPEG lossless processing: failed to initialize multi-threaded processing")

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   initFIMGmodule()
   skipDeadFiles := theseFailures := failedFiles := countTFilez := filesConverted := 0
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If (RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") || InStr(imgPath, "||") || !imgPath)
      {
         skippedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to convert " groupDigits(failedFiles) " files"
         If (theseFailures>0)
            etaTime .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip("Converting to ." rDesireWriteFMT " format, please wait" etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      countTFilez++
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If !file2save
      {
         skippedFiles++
         Continue
      }

      changeMcursor()
      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         filesConverted++

      If (OnConvertKeepOriginals!=1 && !r)
      {
         FileSetAttrib, -R, % imgPath
         Sleep, 2
         FileRecycle, % imgPath
         If ErrorLevel
            theseFailures++

         resultedFilesList[thisFileIndex, 1] := file2save
         ; resultedFilesList[thisFileIndex, 2] := 1
         updateMainUnfilteredList(thisFileIndex, 1, file2save)
         If (SLDtypeLoaded=3)
            updateSQLdbEntry(imgPath, file2save, 1, resultedFilesList[thisFileIndex, 12])
      }
   }

   currentFilesListModified := 1
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   }

   If (failedFiles>0)
      someErrors := "`nFailed to convert " groupDigits(failedFiles) " files"
   If (theseFailures>0)
      someErrors .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files were converted to ." rDesireWriteFMT " until now" someErrors)
   Else
      showTOOLtip("Finished converting to ." rDesireWriteFMT " format`n" groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

coreConvertImgFormat(imgPath, file2save) {
   If (PreserveDateTimeOnSave=1)
   {
      ; fnOutputDebug("got original date")
      FileGetTime, originalMtime, % imgPath, M
      FileGetTime, originalCtime, % imgPath, C
   }

   maxLimitReached := 0 ; (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
   If (FIMfailed2init=1 || maxLimitReached=1)
   {
      If FileExist(file2save)
         FileSetAttrib, -R, %file2save%

      pBitmap := LoadBitmapFromFileu(imgPath)
      If StrLen(pBitmap)<3
         Return -1

      rawFmt := Gdip_GetImageRawFormat(pBitmap)
      If (rawFmt="JPEG")
         RotateBMP2exifOrientation(pBitmap)

      changeMcursor()
      r := Gdip_SaveBitmapToFile(pBitmap, file2save, 90)
      trGdip_DisposeImage(pBitmap, 1)
      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
         ; fnOutputDebug("original date ... set")
      } ; Else fnOutputDebug("set original date skipped...  " PreserveDateTimeOnSave "  ---  " r "  ---  " originalMtime "  -- fim-fail  " FIMfailed2init " ")
   } Else
   {
      loadArgs := 0
      GFT := FreeImage_GetFileType(imgPath)
      If (GFT=34)
         loadArgs := (userHQraw=1) ? 0 : 5
      Else If (GFT=2)
         loadArgs := 8

      hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
      If !hFIFimgA
         Return -1

      imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
      ColorsType := FreeImage_GetColorType(hFIFimgA)
      mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba")) || (imgBPP>64) ? 1 : 0
      If (mustApplyToneMapping=1)
      {
         ; setWindowTitle("Applying adaptive logarithmic tone mapping to display high color depth image")
         changeMcursor()
         hFIFimgB := FreeImage_ToneMapping(hFIFimgA, 0, 1.85, 0)
      }

      hFIFimgC := hFIFimgB ? hFIFimgB : hFIFimgA
      If (FileExist(file2save) && hFIFimgC)
      {
         Try FileSetAttrib, -R, % file2save
         Sleep, 1
         FileMove, % file2save, % file2save "-tmp"
         If !ErrorLevel
            tempFileExists := 1

         Sleep, 1
      }

      saveArg := 0
      If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
         saveArg := clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
      Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
         saveArg := clampInRange(Round(userJpegQuality), 1, 100)

      imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgC), "-"))
      If (RegExMatch(file2save, "i)(.\.(gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|wbm|xpm))$") && hFIFimgC)
      {
         changeMcursor()
         hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "24Bits")
         changeMcursor()
         r := FreeImage_Save(hFIFimgD, file2save, saveArg)
         FreeImage_UnLoad(hFIFimgD)
      } Else If hFIFimgC
      {
         changeMcursor()
         r := FreeImage_Save(hFIFimgC, file2save, saveArg)
         If (!r && imgBPP!=32)
         {
            FileDelete, % file2save
            Sleep, 1
            changeMcursor()
            hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "32Bits")
            changeMcursor()
            r := FreeImage_Save(hFIFimgD, file2save, saveArg)
            FreeImage_UnLoad(hFIFimgD)
          }
      }

      FreeImage_UnLoad(hFIFimgA)
      FreeImage_UnLoad(hFIFimgB)
      If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
      {
         r := 0
         FileDelete, % file2save
         Sleep, 1
         FileMove, % file2save "-tmp", % file2save
      } Else If (tempFileExists=1)
         FileDelete, % file2save "-tmp"

      r := !r
      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
         ; fnOutputDebug("original date ... set")
      } ; Else fnOutputDebug("set original date skipped...  " PreserveDateTimeOnSave "  ---  " r "  ---  " originalMtime " ")
   }
   Return r
}

convert2format(givenIndex) {
  Critical, on
  If (givenIndex=0)
     Return "err"

  If (slideShowRunning=1)
     ToggleSlideShowu()

  file2rem := getIDimage(givenIndex)
  If RegExMatch(file2rem, "i)(.\.(" rDesireWriteFMT "))$")
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "The image file seems to be already in the given file format: ." rDesireWriteFMT ". Please choose another format.", 0, 0, "exclamation")
     Return "err"
  }

  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If FileExist(file2save)
  {
     ToolTip
     zPlitPath(file2save, 0, OutFileName, OutDir)
     msgResult := msgBoxWrapper(appTitle ": Confirmation", "A file with the same name already exists in the destination folder... Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
     forceOverwrite := (msgResult="Yes") ? 1 : 0
     If !forceOverwrite
     {
        SetTimer, ResetImgLoadStatus, -150
        Return
     }
  }

  BtnCloseWindow()
  destroyGDIfileCache()
  Sleep, 1
  changeMcursor()
  setImageLoading()
  showTOOLtip("Converting image file, please wait")
  If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
     FileCreateDir, % ResizeDestFolder

  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If FileExist(file2save)
     FileSetAttrib, -R, %file2save%

  changeMcursor()
  r := coreConvertImgFormat(file2rem, file2save)
  SetTimer, ResetImgLoadStatus, -50
  FileGetSize, OutputVar, % file2save
  If (OutputVar>2 && !r)
     friendly := "`nFile size: " fileSizeFrienly(OutputVar)
 
  If r
     showTOOLtip("Failed to convert file`n" OutFileName "`n" OutDir "\")
  Else
     showTOOLtip("File converted succesfully to ." rDesireWriteFMT "`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\" friendly)

  SoundBeep, % r ? 300 : 900, 100
  If (OnConvertKeepOriginals!=1 && !r)
  {
     currentFilesListModified := 1
     Try FileSetAttrib, -R, %file2rem%
     Sleep, 1
     FileRecycle, %file2rem%
     If ErrorLevel
        showTOOLtip("Failed to remove original file, however the file was converted succesfully to ." rDesireWriteFMT "`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\")

     resultedFilesList[givenIndex, 1] := file2save
     resultedFilesList[givenIndex, 4] := 1
     If (SLDtypeLoaded=3)
        updateSQLdbEntry(file2rem, file2save, 1, resultedFilesList[givenIndex, 12])

     updateMainUnfilteredList(givenIndex, 1, file2save)
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
  SetTimer, ResetImgLoadStatus, -150
}

OpenFolders(dummy:=0) {
   If (AnyWindowOpen || imageLoading=1)
      Return

   initQPVmainDLL()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If FolderExist(StrReplace(dummy, "|"))
      SelectedDir := dummy
   Else
      SelectedDir := openFoldersDialogWrapper(2, prevOpenFolderPath, "Select the folder to open recursively")

   If (SelectedDir)
   {
      SelectedDir := Trimmer(StrReplace(SelectedDir, "\\", "\"), "\")
      If askAboutFileSave(" and another image will be loaded")
         Return

      If askAboutSlidesListSave()
         Return

      newStaticFoldersListCache := []
      prevOpenFolderPath := StrReplace(SelectedDir, "|")
      INIaction(1, "prevOpenFolderPath", "General")
      coreOpenFolder(SelectedDir, 1, 1, 1)
      If (maxFilesIndex>0)
         SLDtypeLoaded := 1
      ; Else resetMainWin2Welcome()
   }
}

openFoldersDialogWrapper(optionz, startPath, msg:="") {
   Static defaultu := "<Use current folder>"
   setWinCloseZeit()
   thisHwnd := (AnyWindowOpen>0) ? hSetWinGui : PVhwnd
   entriesList := defaultu "`n" recentOpenedFolders()
   r := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, entriesList, 1, "History", entriesList)
   If (!InStr(r.SelectedCombo, defaultu) && StrLen(r.SelectedCombo)>3)
      z := r.SelectedCombo
   Else If StrLen(r.SelectedDir)>4
      z := r.SelectedDir

   SetTimer, setWinCloseZeit, -150, 900
   lastLongOperationAbort := A_TickCount
   Return z
}

renewCurrentFilesList() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
   }

   RandyIMGnow := -1
   RandyIMGids := []
   resultedFilesList := []
   lastRenameUndo := []
   prevLastImg := []
   reviewSelectedIndexes := []
   markedSelectFile := EntryMarkedMoveIndex := maxFilesIndex := 0
   lastZeitFileSelect := editingSelectionNow := hasHamDistCached := 0
   ForceRefreshNowThumbsList()
   updateUIctrl()
   currentFileIndex := 1
   prevLoadedImageIndex := ""
   currentImgModified := allImagesWereSeen := 0
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   discardSRCfileCaches()
   destroyGDIfileCache()
   discardViewPortCaches()
   disposeCacheIMGs()
   hudBTNfuncu := thisSearchString := userSearchString := ""
   terminateIMGediting()
   If hSNDmedia
      StopMediaPlaying()
}

FileExploreUpDownLevel(direction, returnObj:=0, ByRef iLevel:=0, forceLevel:=0) {
   Static thisLevel := 0, prevPathArray := []
   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   oldFolder := baseFolder
   initialLevel := thisLevel
   thisFolder := StrReplace(Trimmer(baseFolder), "|")
   prevMaxLevels := prevPathArray.Length()
   If (prevMaxLevels=thisLevel)
   {
      doStartLongOpDance()
      Loop, Files, % thisFolder "\*", DF
      {
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
         {
            thisFolder .= "\" A_LoopFileName
            Break
         }
      }
      If (abandonAll=1)
      {
         ResetImgLoadStatus()
         Return
      }

      If (direction=1)
      {
         Loop, Files, % thisFolder "\*", DF
         {
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }

            If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
            {
               thisFolder .= "\" A_LoopFileName
               Break
            }
         }
      }
      ResetImgLoadStatus()
      If (abandonAll=1)
         Return
   }

   thisFolder := StrReplace(thisFolder, "\\", "\")
   thisFolder := Trimmer(thisFolder, "\")
   folderPathArray := StrSplit(thisFolder, "\")
   maxLevels := folderPathArray.Length()
   Loop, % maxLevels
   {
        If (folderPathArray[A_Index]!=prevPathArray[A_Index])
        {
           thisLevel := 0
           prevPathArray := folderPathArray.Clone()
           Break
        }
   }

   thisParent := SubStr(oldFolder, InStr(oldFolder, "\", 0, -1) + 1)
   If !thisLevel
   {
      Loop, % maxLevels + 1
      {
           If (folderPathArray[A_Index]=thisParent)
           {
              thisLevel := A_Index
              Break
           }
      }
   }

   oldIndex := currentFileIndex
   prevMaxLevels := prevPathArray.Length()
   If (returnObj=1)
   {
      iLevel := thisLevel
      Return prevPathArray
   }

   If (direction=-1)
      thisLevel := clampInRange(thisLevel - 1, 1, prevMaxLevels)
   Else
      thisLevel := clampInRange(thisLevel + 1, 1, prevMaxLevels)

   If forceLevel
      thisLevel := forceLevel

   Loop, % prevMaxLevels
   {
      newFolder .= prevPathArray[A_Index] "\"
      If (A_Index=thisLevel)
         Break
   }

   newFolder := Trimmer(newFolder, "\")
   If (initialLevel!=thisLevel)
      tryOpenGivenFolder(newFolder, oldFolder)
}

FileExploreSiblingsNav(direction, isInLoop:=0, returnObj:=0, ByRef iLevel:=0, forceLevel:=0) {
   Static thisLevel, prevFolder, subFoldersArray := []
   If (direction="reset")
   {
      prevFolder := thisLevel := ""
      subFoldersArray := []
      Return
   }

   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   initialLevel := thisLevel
   oldFolder := baseFolder
   thisFolder := StrReplace(Trimmer(baseFolder), "|")
   initialSibling := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
   thisFolder := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1) - 1)
   If (thisFolder!=prevFolder)
   {
      subFoldersArray := []
      thisIndex := 0
      prevFolder := thisFolder
      doStartLongOpDance()
      Loop, Files, % thisFolder "\*", DF
      {
         If (determineTerminateOperation()=1)
            Break

         If !InStr(A_LoopFileAttrib, "D")
            Continue

         thisIndex++
         If (A_LoopFileName=initialSibling)
            thisLevel := thisIndex

         If (A_LoopFileName!="")
            subFoldersArray[thisIndex] := A_LoopFileName
      }
      ResetImgLoadStatus()
   }

   oldIndex := currentFileIndex
   maxLevels := subFoldersArray.Count()
   If (maxLevels<2)
   {
      showTOOLtip("No sibling folders found")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (returnObj=1)
   {
      iLevel := thisLevel
      Return subFoldersArray
   }

   If (direction=-1)
      thisLevel := clampInRange(thisLevel - 1, 1, maxLevels, 1)
   Else
      thisLevel := clampInRange(thisLevel + 1, 1, maxLevels, 1)

   If forceLevel
      thisLevel := forceLevel

   If (subFoldersArray[thisLevel]!="")
   {
      newFolder := thisFolder "\" subFoldersArray[thisLevel]
   } Else If (isInLoop<maxLevels)
   {
      isInLoop++
      FileExploreSiblingsNav(direction, isInLoop)
      Return
   } Else
   {
      showTOOLtip("No sibling folders found")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (initialLevel!=thisLevel && FolderExist(newFolder))
   {
      r := tryOpenGivenFolder(newFolder, oldFolder)
      If (r=1)
      {
         subFoldersArray[thisLevel] := ""
         thisLevel := initialLevel
      } Else showDelayedTooltip("Sibling folders navigation: " thisLevel " / " maxLevels "`n.\" subFoldersArray[thisLevel] "\")
   } Else If !FolderExist(newFolder)
   {
      ; subFoldersArray[thisLevel] := ""
      FileExploreSiblingsNav(direction, 1)
   }
}

coreOpenFolder(thisFolder, doOptionals:=1, openFirst:=0, doReset:=0, safeMode:=0) {
   testThis := StrReplace(thisFolder, "|")
   mustOpenStartFolder := ""
   If FolderExist(testThis)
   {
      If (A_TickCount - scriptStartTime>350)
         BtnCloseWindow()

      filesFilter := CurrentSLD := ""
      setWindowTitle("Indexing files, please wait...", 1)
      renewCurrentFilesList()
      ; activeSQLdb.Exec("DELETE FROM images;")
      r := GetFilesList(thisFolder "\*")
      If (maxFilesIndex<1 || !maxFilesIndex) && (safeMode=0)
      {
         If (!CurrentSLD || doReset=1)
            resetMainWin2Welcome()
         Else
            FadeMainWindow()

         showTOOLtip("ERROR: Found no recognized image files in the folder`n" thisFolder "\")
         SoundBeep, 300, 100
         setWindowTitle(appTitle " v" appVersion, 1)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      GenerateRandyList()
      mustGenerateStaticFolders := 1
      DynamicFoldersList := thisFolder "`n"
      CurrentSLD := thisFolder
      watchFolderDetails := ""
      If (safeMode=0)
         RecentFilesManager(CurrentSLD)

      If (r=1)
      {
         clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
         RemoveTooltip()
      } Else SetTimer, RemoveTooltip, % -msgDisplayTime

      If (doOptionals=1)
      {
         If (maxFilesIndex>0 && r!=1)
            RandomPicture()
         Else
            dummyTimerDelayiedImageDisplay(25)
      }
   } Else
   {
      setWindowTitle(appTitle " v" appVersion, 1)
      If (!CurrentSLD || maxFilesIndex<2 || !maxFilesIndex)
         resetMainWin2Welcome()
      Else
         FadeMainWindow()

      showTOOLtip("ERROR: The folder seems to be inexistent`n" testThis "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

addDynamicFolderSQLdb(whichFolder, renewList, whichTable) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM dynamicfolders;")

    folderu := StrReplace(whichFolder, "|")
    If !FolderExist(folderu)
       Return

    FileGetTime, fileMdate, % folderu, M
    SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES ('" SQLescapeStr(whichFolder) "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Return 0
    }
    Return 1
}

addStaticFolderSQLdb(whichFolder, fileMdate, renewList) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM staticfolders;")

    SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES ('" whichFolder "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Sleep, 0
    }
}

RefreshImageFileAction() {
   isThumbMode := (thumbsDisplaying=1 && maxFilesIndex>1) ? 1 : 0
   ; imgPath := getIDimage(currentFileIndex)
   ; If (!useGdiBitmap() && !imgPath && isThumbMode!=1) || !imgPath

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (thumbsDisplaying!=1)
   {
      If throwErrorNoImageLoaded(0, 0)
         Return

      If InStr(imgPath, "\temporary memory object\")
      {
         showTOOLtip("WARNING: This image is currently unsaved. Unable to refresh object.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If askAboutFileSave(" and the original file will be reloaded")
         Return

      currentImgModified := 0
      discardViewPortCaches()
      terminateIMGediting()
      FlipImgV := FlipImgH := vpIMGrotation := 0
      imgFxMode := 1
      If (AutoDownScaleIMGs=1)
         AutoDownScaleIMGs := 2

      INIaction(1, "IMGresizingMode", "General")
      INIaction(1, "imgFxMode", "General")
      INIaction(1, "FlipImgH", "General")
      INIaction(1, "FlipImgV", "General")
      INIaction(1, "vpIMGrotation", "General")

      r := IDshowImage(currentFileIndex, 3)
      If !r
         informUserFileMissing(1)
      Else If (toolTipGuiCreated!=1)
         showTOOLtip("Image file reloaded")

      thisIMGisDownScaled := 0
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   } Else If (thumbsDisplaying=1)
      RefreshFilesList()
}

RefreshImageFile() {
   ; disposeCacheIMGs()
   r := IDshowImage(currentFileIndex, 3)
   If !r
      informUserFileMissing(1)
}

RefreshFilesList() {
  If !CurrentSLD
  {
     showTOOLtip("WARNING: No folder or files list index currently opened")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
  {
     retrieveFavesAsList()
     Return
  } Else If InStr(CurrentSLD, "\viewed-images-history-")
  {
     showTOOLtip("The current files list index is: `n" CurrentSLD)
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If RegExMatch(CurrentSLD, sldsPattern)
  {
     If askAboutFileSave(" and the files list will be reloaded")
        Return

     If askAboutSlidesListSave()
        Return

     thisIndex := currentFileIndex
     OpenSLD(CurrentSLD, 1)
     currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
     dummyTimerDelayiedImageDisplay(50)
  } Else If StrLen(CurrentSLD)>3
     RegenerateEntireList()
     ; coreOpenFolder(CurrentSLD)
}

OpenDialogFiles(dummy:=0) {
    Static lastInvoked := A_TickCount
    If (AnyWindowOpen || imageLoading=1) || (A_TickCount - lastInvoked<150)
       Return

    initQPVmainDLL()
    If (slideShowRunning=1)
       ToggleSlideShowu()

    pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.sld*)"
    ; pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
    ; pattern .= "|QPV slideshows (*.sld;*.sldb)"

    patternObj := fileImgFormatsOpenDialog(1)
    If isWinXP
       FileSelectFile, imgPath, 3, % prevOpenFolderPath, Open Image file, % pattern
    Else
       imgPath := openFileDialogWrapper("O1", "-", prevOpenFolderPath, "Open image or slideshow...", patternObj, chosenOption, 3, "open-folder")

    lastInvoked := A_TickCount
    If !imgPath
       Return

    If (askAboutFileSave(" and another image will be loaded") && !InStr(chosenOption, "instance"))
       Return

   zPlitPath(imgPath, 0, OutFileName, SelectedDir)
   If !FolderExist(SelectedDir)
      SelectedDir := SubStr(SelectedDir, 1, InStr(SelectedDir, "\", 0, -1) - 1)

   ; ToolTip, % SelectedDir , , , 2
   If FolderExist(SelectedDir)
   {
      If InStr(chosenOption, "instance")
      {
         If RegExMatch(imgPath, RegExFilesPattern)
            OpenWithNewQPVinstance(0, imgPath, 2)
         Else
            OpenNewQPVinstance(SelectedDir)
         Return
      }

      newStaticFoldersListCache := []
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      lastInvoked := A_TickCount
      If RegExMatch(imgPath, sldsPattern)
      {
         OpenSLD(imgPath)
         Return
      }

      PopulateIndexFilesStatsInfos("kill")
      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }
 
      doNotRecursive := InStr(chosenOption, "perform") ? "" : "|"
      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath) && InStr(chosenOption, "selected"))
      {
         SLDtypeLoaded := 1
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg
         MenuOpenLastImg(imgPath)
         currentFilesListModified := 0
      } Else 
      {
         coreOpenFolder(doNotRecursive SelectedDir, 0, 0, 1)
         currentFilesListModified := 0
         SlidesMusicSong := ""
         If (doNotRecursive && maxFilesIndex<1)
         {
            msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " SelectedDir "\ to open without recursive scanning. QPV found no supported image files.`n`nWould you like to recursively scan the given folder?", 4, 0, "question")
            If (msgResult="Yes")
               coreOpenFolder(SelectedDir, 0, 0, 1)
         }
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         SlidesMusicSong := ""
         If FileRexists(imgPath)
         {
            currentFileIndex := detectFileID(imgPath)
            If (allowRecordHistory=1)
               IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

            IDshowImage(currentFileIndex)
         } Else If OutFileName!=""
         {
            FriendlyName := FileExist(imgPath) ? "malformed" : "inexistent"
            msgBoxWrapper(appTitle ": ERROR", "Error opening file: " OutFileName ". It seems to be " FriendlyName " .`n`nAnother file from the folder will be displayed now. Files indexed: " groupDigits(maxFilesIndex) ".", 0, 0, "error")
            RandomPicture()
         }
      } Else If (maxFilesIndex>0)
      {
         SlidesMusicSong := ""
         SLDtypeLoaded := 1
         RandomPicture()
      } ; Else resetMainWin2Welcome()
   }

   SetTimer, createGUItoolbar, -100
   SetTimer, TriggerMenuBarUpdate, -90
   lastInvoked := A_TickCount
}

askAboutSlidesListSave() {
   Static lastInvoked := 1, prevAnswer
   If (A_TickCount - lastInvoked<300)
      Return prevAnswer

   r := 0
   If (currentFilesListModified=1 && RegExMatch(CurrentSLD, "i)(.\.sld)$") && FileExist(CurrentSLD) && maxFilesIndex>1 && SLDtypeLoaded=2)
   || (currentFilesListModified=1 && maxFilesIndex>1 && InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      zPlitPath(CurrentSLD, 0, OutFileName, OutDir)
      msgResult := msgBoxWrapper(appTitle ": Save files list", "The currently opened files list has been modified and the changes have not been saved. To continue with the action you chose, select the Discard button.`n`nWould like to save the currently opened files list?`n`n" OutFileName, "&Save|&Discard|&Cancel", 0, "question")
      If (msgResult="Save")
      {
         SetTimer, PanelSaveSlideShowu, -150
         r := 1
      } Else If (msgResult="Discard")
      {
         r := 0
      } Else ; If (msgResult="Ok")
         r := 1

      lastInvoked := A_TickCount
   }

   prevAnswer := r
   Return r
}

askAboutFileSave(msg:="", lvls:=1, dummy:=0, dontOpen:=0) {
   Static lastInvoked := 1, prevAnswer
   lvls := (minimizeMemUsage=1 || A_PtrSize=4) ? 1 : 2
   If (preventUndoLevels=1)
      lvls := -1

   If (StrLen(UserMemBMP)>3 && undoLevelsRecorded>lvls && currentImgModified=1) && (A_TickCount - lastInvoked<300)
      Return prevAnswer

   r := 0
   imgPath := getIDimage(imgIndexEditing)
   If (StrLen(UserMemBMP)>3 && imgPath && undoLevelsRecorded>lvls && currentImgModified=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      zPlitPath(imgPath, 0, OutFileName, OutDir)
      msgResult := msgBoxWrapper(appTitle ": Save image", "The currently modified image is about to be discarded" msg ".`n`nWould you like to save the current image?`n`n" OutFileName, "&Save|&Discard|&Cancel", 0, "question")
      If (msgResult="Save")
      {
         If (dontOpen!="yes")
            SetTimer, PanelSaveImg, -150
         r := 1
      } Else If (msgResult="Discard")
         r := 0
      Else ; If (msgResult="Ok")
         r := (dontOpen="yes") ? 2 : 1

      lastInvoked := A_TickCount
   }

   prevAnswer := r
   Return r
}

MenuOpenLastImg(forceOpenGiven:=0) {
   If (thumbsDisplaying=1)
   {
      MenuDummyToggleThumbsMode()
      Sleep, 25
   }

   If !FileRexists(forceOpenGiven)
   {
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      LastOpenedImg := Trimmer(LastOpenedImg)
   } Else LastOpenedImg := Trimmer(forceOpenGiven)

   If RegExMatch(LastOpenedImg, RegExFilesPattern) && FileRexists(LastOpenedImg)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return

      If askAboutSlidesListSave()
         Return

      If (thumbsDisplaying=1)
         ToggleThumbsMode()

      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      PopulateIndexFilesStatsInfos("kill")
      renewCurrentFilesList()
      setImageLoading()
      currentFileIndex := maxFilesIndex := 1
      resultedFilesList[1, 1] := LastOpenedImg
      IDshowImage(currentFileIndex)
      zPlitPath(LastOpenedImg, 0, OutFileName, OutDir)
      DynamicFoldersList := OutDir "`n"
      prevOpenFolderPath := OutDir
      CurrentSLD := "|" OutDir
      SLDtypeLoaded := 1
      SlidesMusicSong := ""
      currentFilesListModified := 0
      interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
      interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
      updateUIctrl()
      INIaction(1, "prevOpenFolderPath", "General")
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
      winPrefix := defineWinTitlePrefix()
  
      SetTimer, GuiGDIupdaterResize, Off
      mustOpenStartFolder := OutDir
      ; currentFileIndex := detectFileID(LastOpenedImg)
      pVwinTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
      setWindowTitle(pVwinTitle, 1)
      SetTimer, RemoveTooltip, -250
      SetTimer, TriggerMenuBarUpdate, -100
      SetTimer, ResetImgLoadStatus, -50
      SetTimer, createGUItoolbar, -200
      If (RegExMatch(OutFileName, "i)(\.gif)$") && totalFramesIndex>1 && animGIFsSupport=1)
      {
         animGIFplaying := 0
         allowNextSlide := 1
         prevAnimGIFwas := ""
         dummyTimerDelayiedImageDisplay(250)
      }
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   }
}

OpenArgFile(inputu) {
    setImageLoading()
    Global scriptStartTime := A_TickCount
    currentFileIndex := maxFilesIndex := 1
    interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
    interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)

    ; usrColorDepth := imgFxMode := 1
    ; vpIMGrotation := FlipImgH := FlipImgV := 0
    resultedFilesList[1, 1] := inputu
    IDshowImage(currentFileIndex)
    Global scriptStartTime := A_TickCount
    zPlitPath(inputu, 0, OutFileName, OutDir)
    DynamicFoldersList := OutDir "`n"
    zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
    winPrefix := defineWinTitlePrefix()

    SetTimer, GuiGDIupdaterResize, Off
    mustOpenStartFolder := OutDir
    ; coreOpenFolder("|" OutDir, 0)
    Global scriptStartTime := A_TickCount
    ; currentFileIndex := detectFileID(inputu)
    winTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
    setWindowTitle(winTitle, 1)
    SetTimer, RemoveTooltip, -250
    SetTimer, ResetImgLoadStatus, -50
    CurrentSLD := "|" OutDir
    prevOpenFolderPath := OutDir
    INIaction(1, "prevOpenFolderPath", "General")
    If (allowRecordHistory=1 && FileRexists(inputu))
       IniWrite, % inputu, % mainSettingsFile, General, LastOpenedImg

    updateUIctrl()
    SLDtypeLoaded := 1
    SetTimer, createGUItoolbar, -100
    If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
       CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)

    SetTimer, TriggerMenuBarUpdate, -90
    ; Else resetMainWin2Welcome()
    ; IDshowImage(currentFileIndex)
}

addNewFile2list() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ")"
   pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
   pattern .= "|QPV files lists / slideshows (*.sld;*.sldb)"

   imgsListu := openFileDialogWrapper("M", "AllowMultiSelect FileMustExist", prevOpenFolderPath, "Add image file(s) to the list...", pattern, null, 1)
   If !imgsListu
      Return "cancel"

   If AnyWindowOpen
      BtnCloseWindow()

   Sleep, 25
   If askAboutFileSave(" and the selected file(s) will be added to the list")
      Return

   showTOOLtip("Processing files list, please wait")
   setImageLoading()
   If InStr(imgsListu, "`n")
      firstFile := Trimmer(SubStr(imgsListu, 1, InStr(imgsListu, "`n")))
   Else
      firstFile := Trimmer(imgsListu)

   zPlitPath(firstFile, 0, OutFileName, SelectedDir)
   countFiles := ST_Count(imgsListu, "`n") + 1
   ; msgbox, % firstFile "a`n" countFiles "`n" imgsListu
   If StrLen(SelectedDir)>3
   {
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
   }

   If (RegExMatch(firstFile, "i)(.\.sldb)$") && SLDtypeLoaded!=3)
   {
      importSLDBintoPlainText(firstFile)
   } Else If (RegExMatch(firstFile, "i)(.\.sldb)$") && SLDtypeLoaded=3)
   {
      importSLDBintoSLDB(firstFile)
   } Else If RegExMatch(firstFile, "i)(.\.sld)$")
   {
      importSLDplainText(firstFile)
   } Else If StrLen(imgsListu)>3
   {
      showTOOLtip("Processing files list, please wait")
      setImageLoading()
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir)
      GenerateRandyList()
      currentFileIndex := maxFilesIndex
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(50)
   }

   SetTimer, TriggerMenuBarUpdate, -90
   SetTimer, createGUItoolbar, -100
   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

importSLDplainText(whichFile) {
   If (!RegExMatch(whichFile, "i)(.\.sld)$") || !RegExMatch(CurrentSLD, "i)(.\.sld)$"))
      Return

   If (whichFile=CurrentSLD)
   {
      showTOOLtip("WARNING: Illegal operation. You cannot import the already opened files list`nNo one likes duplicates :-)")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If StrLen(filesFilter)>1
   {
      showTOOLtip("Deactivating the files list filter, please wait")
      remFilesListFilter("simple")
      Sleep, 10
      RemoveTooltip()
   }

   mustOpenStartFolder := ""
   zPlitPath(whichFile, 0, OutFileName, SelectedDir)
   showTOOLtip("Importing plain-text files list, please wait`n" OutFileName "`n" SelectedDir "\")
   If (SLDtypeLoaded=2)
      DynamicFoldersList := getDynamicFoldersList()

   FileReadLine, firstLine, % whichFile, 1
   FileRead, tehFileVar, % whichFile
   mustRemQuotes := InStr(firstLine, "[General]") ? 0 : 1
   If !mustRemQuotes
   {
      IniRead, testDynaFolderz, % whichFile, DynamicFolderz, DF1, @
      If StrLen(testDynaFolderz)>4
         DynamicFoldersList .= "`n" coreLoadDynaFolders(whichFile)
   } Else
   {
      tehFileVar := StrReplace(tehFileVar, """-")
      tehFileVar := StrReplace(tehFileVar, """")
   }

   Sort, DynamicFoldersList, UD`n
   DynamicFoldersList := cleanDynamicFoldersList(DynamicFoldersList)
   If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
      recreateDynaFoldersSQLdbList(DynamicFoldersList)

   countFiles := ST_Count(tehFileVar, "`n") + 1
   coreAddNewFiles(tehFileVar, countFiles, SelectedDir)

   ; res := sldGenerateFilesList(whichFile, 0, mustRemQuotes, 0)
   SoundBeep , 900, 100
   currentFilesListModified := 1
   GenerateRandyList()
   RandomPicture()
   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

importSLDBintoSLDB(whichFile) {
   If (!RegExMatch(whichFile, "i)(.\.sldb)$") || SLDtypeLoaded!=3)
      Return

   If StrLen(filesFilter)>1
   {
      showTOOLtip("Deactivating the files list filter, please wait")
      remFilesListFilter("simple")
      Sleep, 10
      RemoveTooltip()
   }

   If (whichFile=CurrentSLD)
   {
      showTOOLtip("WARNING: Illegal operation. You cannot import the already opened database")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (dbVersion!=dbExpectedVersion)
   {
      showTOOLtip("WARNING: Illegal operation. You cannot import into the currently opened database, because it was saved with a different version of QPV. Please rebuild this database.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   startZeit := A_TickCount
   mustOpenStartFolder := ""
   zPlitPath(CurrentSLD, 0, OutFileName, SelectedDir)
   showTOOLtip("Preparing main database content, please wait`n" OutFileName "`n" SelectedDir "\")
   setImageLoading()
   Static  SQLa := "SELECT imgfile, imgfolder, fsize, fmodified, fcreated, imgwidth, imgheight, imgframes, imgdpi, imgpixfmt, imgavg, imghpeak, imghlow, imghmode, imghrms, imghminu, imghrange, dHash, pHash, pixelzFsmall, pixelzFbig, lHash, imgmedian FROM images"
   If !activeSQLdb.GetTable(SQLa, mainRecordSet)
   {
      ResetImgLoadStatus()
      throwSQLqueryDBerror(A_ThisFunc)
      Return
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   countFiles := mainRecordSet.RowCount
   totalArrayu := []
   mainArrayu := []
   uniqueArrayu := new hashtable()
   doStartLongOpDance()
   allIndex := 0
   Loop, % mainRecordSet.RowCount
   {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, countFiles, startOperation)
           showTOOLtip("Preparing main database content, please wait" etaTime, 0, 0, A_Index/countFiles)
           prevMSGdisplay := A_TickCount
        }

        Rowu := mainRecordSet.Rows[A_Index]
        If Rowu[2]
        {
           allIndex++
           mainArrayu[allIndex] := A_Index
           totalArrayu[allIndex] := "m"
           uniqueArrayu[Rowu[2] "\" Rowu[1]] := 1
        }
   }

   If (abandonAll=1)
   {
      showTOOLtip("Database import operation aborted by user")
      mainArrayu := ""
      totalArrayu := ""
      uniqueArrayu := ""
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      ResetImgLoadStatus()
      Return
   }

   zPlitPath(whichFile, 0, OutFileName, SelectedDir)
   otherSQLdb := new SQLiteDB
   If !otherSQLdb.OpenDB(whichFile)
   {
      mainArrayu := ""
      totalArrayu := ""
      uniqueArrayu := ""
      throwSQLqueryDBerror(A_ThisFunc)
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   showTOOLtip("Retrieving imported database content, please wait`n" OutFileName "`n" SelectedDir "\")
   If !otherSQLdb.GetTable(SQLa, otherRecordSet)
   {
      mainArrayu := ""
      totalArrayu := ""
      uniqueArrayu := ""
      mainRecordSet.Free()
      throwSQLqueryDBerror(A_ThisFunc)
      otherSQLdb.CloseDB()
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   countFiles := otherRecordSet.RowCount
   otherArrayu := []
   Loop, % otherRecordSet.RowCount
   {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, countFiles, startOperation)
           showTOOLtip("Retrieving imported database content, please wait" etaTime, 0, 0, A_Index/countFiles)
           prevMSGdisplay := A_TickCount
        }

        Rowu := otherRecordSet.Rows[A_Index]
        If Rowu[2]
        {
           allIndex++
           otherArrayu[allIndex] := A_Index
           totalArrayu[allIndex] := uniqueArrayu.hasKey(Rowu[2] "\" Rowu[1]) ? "b" : "o"
        }
   }

   If (abandonAll=1)
   {
      showTOOLtip("Database import operation aborted by user")
      SoundBeep 300, 100
      totalArrayu := ""
      mainArrayu := ""
      uniqueArrayu := ""
      otherArrayu := ""
      otherRecordSet.Free()
      mainRecordSet.Free()
      otherSQLdb.CloseDB()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return
   }

   showTOOLtip("Merging databases contents, please wait")
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM images;")

   sqlDBrowID := 1
   baseSQLstr := "INSERT INTO images (imgidu, imgfile, imgfolder, fsize, fmodified, fcreated, imgwidth, imgheight, imgframes, imgdpi, imgpixfmt, imgavg, imghpeak, imghlow, imghmode, imghrms, imghminu, imghrange, dHash, pHash, pixelzFsmall, pixelzFbig, lHash, imgmedian) VALUES ("
   k1 := k2 := k3 := k4 := k5 := k6 := k7 := k8 := k9 := k10 := k11 := k12 := k13 := k14 := k15 := k16 := k17 := k18 := k19 := k20 := k21 := k22 := k23 := k24 := ""

   newIndex := 0
   newArrayu := []
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   countFiles := allIndex ; totalArrayu.Count()
   ; For Key, Value in totalArrayu
   Loop, % allIndex
   {
      key := A_Index
      value := totalArrayu[key]
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>1500)
      {
         etaTime := ETAinfos(A_Index, countFiles, startOperation)
         If errorsOccured
            moreSpam := "`n" groupDigits(errorsOccured) " errors occured until now"

         showTOOLtip("Merging databases contents, please wait" moreSpam etaTime, 0, 0, A_Index/countFiles)
         prevMSGdisplay := A_TickCount
      }

      If (value="m")
      {
         thisIndex := mainArrayu[key]
         Rowu := mainRecordSet.Rows[thisIndex]
      } Else If (value="o")
      {
         thisIndex := otherArrayu[key]
         Rowu := otherRecordSet.Rows[thisIndex]
      } Else If (value="b")
      {
         thisIndex := otherArrayu[key]
         oRowu := otherRecordSet.Rows[thisIndex]
         thisIndex := mainArrayu[key]
         mRowu := mainRecordSet.Rows[thisIndex]
         Loop, 23
            k%A_Index% := oRowu[A_Index] ? oRowu[A_Index] : mRowu[A_Index]
      }

      If (value="m" || value="o")
      {
         Loop, 23
            k%A_Index% := Rowu[A_Index]
      }

      activeSQLdb.EscapeStr(k1)
      activeSQLdb.EscapeStr(k2)
      moreSQL := baseSQLstr "'" sqlDBrowID "', " k1 ", " k2 ", '" k3 "', '" k4 "', '" k5 "', '" k6 "', '" k7 "', '" k8 "', '" k9 "', '" k10 "', '" k11 "', '" k12 "', '" k13 "', '" k14 "', '" k15 "', '" k16 "', '" k17 "', '" k18 "', '" k19 "', '" k20 "', '" k21 "', '" k22 "', '" k23 "');"
      If !activeSQLdb.Exec(moreSQL)
      {
         errorsOccured++
      } Else
      {
         newIndex++
         sqlDBrowID++
      }
   }

   If (abandonAll=1)
   {
      showTOOLtip("Database import operation aborted by user")
      SoundBeep 300, 100
      activeSQLdb.Exec("ROLLBACK TRANSACTION;")
      totalArrayu := ""
      mainArrayu := ""
      otherArrayu := ""
      newArrayu := ""
      uniqueArrayu := ""
      otherRecordSet.Free()
      mainRecordSet.Free()
      otherSQLdb.CloseDB()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return
   }

   showTOOLtip("Finalising database import operations, please wait")
   Static cols := "fsize,fmodified,fcreated,imgwidth,imgheight,imgframes,imgdpi,imgpixfmt,imgavg,imghpeak,imghlow,imghmode,imghrms,imghminu,imghrange,dHash,pHash,pixelzFsmall,pixelzFbig,lHash,imgmedian"
   Loop, Parse, cols, CSV
   {
      If !activeSQLdb.Exec("UPDATE images SET " A_LoopField " = NULL WHERE " A_LoopField "='';")
         errorsOccured++
   }

   If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      throwSQLqueryDBerror(A_ThisFunc)

   SQL := "SELECT imgfolder FROM dynamicfolders;"
   otherSQLdb.GetTable(SQL, gRecordSet)
   Loop, % gRecordSet.RowCount
   {
       Rowu := gRecordSet.Rows[A_Index]
       If Rowu[1]
          DynamicFoldersList .= Rowu[1] "`n"
   }

   maxFilesIndex := newIndex
   resultedFilesList := []
   ; resultedFilesList := newArrayu.Clone()
   newArrayu := []
   totalArrayu := []
   mainArrayu := []
   otherArrayu := []
   uniqueArrayu := []
   gRecordSet.Free()
   otherRecordSet.Free()
   mainRecordSet.Free()
   otherSQLdb.CloseDB()
   Sort, DynamicFoldersList, UD`n
   newListu := cleanDynamicFoldersList(DynamicFoldersList)
   recreateDynaFoldersSQLdbList(newListu)
   If errorsOccured
      someErrors := "`n" groupDigits(errorsOccured) " errors occured during merger."

   zeitOperation := A_TickCount - startZeit
   etaTime := SecToHHMMSS(Round(zeitOperation/1000, 3))
   OpenSLD(CurrentSLD, 1)
   showDelayedTooltip("Databases merger has finished in " etaTime someErrors "`nTotal files: " groupDigits(maxFilesIndex))
   ; res := sldGenerateFilesList(whichFile, 0, mustRemQuotes, 0)
   SoundBeep , % errorsOccured ? 300 : 900, 100
   ; GenerateRandyList()
   ; RandomPicture()
   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

importSLDBintoPlainText(whichFile) {
   If !RegExMatch(whichFile, "i)(.\.sldb)$")
      Return

    If CurrentSLD
       dropFilesSelection(1)

    mustOpenStartFolder := ""
    zPlitPath(whichFile, 0, OutFileName, SelectedDir)
    showTOOLtip("Importing files list from database`n" OutFileName "`n" SelectedDir "\")
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    OpenSLDBdataBase(whichFile, 1)
    currentFilesListModified := 1
    Sort, DynamicFoldersList, UD`n
    DynamicFoldersList := cleanDynamicFoldersList(DynamicFoldersList)
    If (!CurrentSLD && maxFilesIndex>0)
       CurrentSLD := SelectedDir "\newFile.SLD"

    GenerateRandyList()
    RandomPicture()
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -150
}

coreAddNewFiles(imgsListu, countFiles, SelectedDir, selectNewOnes:=0) {
    If CurrentSLD
       dropFilesSelection(1)

    showTOOLtip("Adding " groupDigits(countFiles) " files into the current files list")
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    doStartLongOpDance()
    If (SLDtypeLoaded=3)
    {
       getMaxRowIDsqlDB()
       activeSQLdb.Exec("BEGIN TRANSACTION;")
    }

    isFaves := InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") ? 1 : 0
    prevMSGdisplay := A_TickCount
    startOperation := A_TickCount
    Loop, Parse, imgsListu, `n`r
    {
       line := Trimmer(A_LoopField)
       If StrLen(line)<3
          Continue

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, countFiles, startOperation)
          showTOOLtip("Adding image files to the current list" etaTime, 0, 0, A_Index/countFiles)
          prevMSGdisplay := A_TickCount
       }

       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          If (SLDtypeLoaded=3 && maxFilesIndex>0)
          {
             zPlitPath(line, 1, OutFileName, OutDir)
             erru := addSQLdbEntry(OutFileName, OutDir, 0, 0, 0, 1)
          }

          If !erru
          {
             added++
             maxFilesIndex++
             If (selectNewOnes=1)
                markedSelectFile++

             resultedFilesList[maxFilesIndex] := [line, selectNewOnes]
             If (isFaves=1)
                resultedFilesList[maxFilesIndex, 5] := 1

             If (SLDtypeLoaded=3 && maxFilesIndex>0)
                resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
          }
       }
    }

    If (SLDtypeLoaded=3)
    {
       If !activeSQLdb.Exec("COMMIT TRANSACTION;")
          throwSQLqueryDBerror(A_ThisFunc)
       getMaxRowIDsqlDB()
    }

    If added
       currentFilesListModified := 1

    If (!CurrentSLD && maxFilesIndex>0)
    {
       SLDtypeLoaded := 2
       CurrentSLD := SelectedDir "\newFile.SLD"
    }

    mustOpenStartFolder := ""
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -150
}

wrapperAddNewFolderToList(folderu, forceRemAll, isInLoop:=0) {
    showTOOLtip("Preparing files list, please wait`n" folderu "\")
    z := coreAddNewFolder(folderu, forceRemAll, 0, 0, 0)
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=2 && isInLoop!=1)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1 || InStr(folderu, "|"))
          good2go := "null"
    } Else good2go := "null"

    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
    {
       good2go := 0
       SQLdeleteEntriesMarked()
       isPipe := InStr(folderu, "|") ? 1 : 0
       folderuz := StrReplace(folderu, "|")
       SQLdbRetrieveGivenFolder(folderuz, !isPipe)
       getMaxRowIDsqlDB()
    }

    If (isInLoop=1)
       Return z
    Else
       GenerateRandyList()

    Return good2go
}

addNewFolder2list(givenPath:=0, externMode:=0, actu:=0) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (FolderExist(givenPath) && externMode="yes")
   {
      SelectImg := givenPath
   } Else If (externMode!="yes")
   {
      SelectImg := openFoldersDialogWrapper("S2", prevOpenFolderPath, "Add new folder(s) to the list")
      If !Trim(SelectImg)
         Return "cancel"
   }

   SelectedDir := Trimmer(SelectImg)
   If SelectedDir
   {
      If askAboutFileSave(" and new files will be added from the selected folder")
         Return

      If InStr(DynamicFoldersList, SelectedDir "`n")
      {
         hasAskedAboutDupes := 1
         msgResult := msgBoxWrapper(appTitle, "The folder you want to add, seems to be already indexed. Are you sure you want to add it again? This action will likely lead to duplicate entries in the list.`n`n" SelectedDir "\", 4, 0, "question")
         If (msgResult!="yes")
            Return "cancel"
      }

      If (actu="not" || actu="recursive")
      {
         If (actu="not")
            isNotRecursive := "|"
      } Else
      {
         msgResult := msgBoxWrapper(appTitle, "Do you want to scan for image files recursively, through all its subfolders?`n`n" SelectedDir "\", 3, 0, "question")
         If (msgResult="no")
            isNotRecursive := "|"
         Else If (msgResult="cancel" || InStr(msgResult, "win_close"))
            Return "cancel"
      }

      BtnCloseWindow()
      Sleep, 1
      prevOpenFolderPath := SelectedDir
      setImageLoading()
      INIaction(1, "prevOpenFolderPath", "General")
      mainListu := retrieveListFoldersIndexed()
      If (mainListu[Format("{:L}", SelectedDir)] && hasAskedAboutDupes!=1)
      {
         msgu := "The folder seems to be already indexed:`n`n" SelectedDir "\"
         msgResult := msgBoxWrapper(appTitle ": Confirmation", msgu "`n`nDo you want to add it to the list? This may lead to duplicate entries.", 4, 0, "question")
         If (msgResult!="Yes")
         {
            mainListu := ""
            SetTimer, RemoveTooltip, % -msgDisplayTime
            ResetImgLoadStatus()
            Return "cancel"
         }
      }

      mustOpenStartFolder := ""
      modus := isNotRecursive ? 1 : 0
      z := wrapperAddNewFolderToList(isNotRecursive SelectedDir, !modus)
      If (z!="null" && RegExMatch(CurrentSLD, sldsPattern))
         updateCachedStaticFolders(SelectedDir, modus)
      Else
         mustGenerateStaticFolders := 1

      listu := DynamicFoldersList "`n" isNotRecursive SelectedDir "`n"
      Sort, listu, UD`n
      DynamicFoldersList := cleanDynamicFoldersList(listu)
      If (SLDtypeLoaded=3 && RegExMatch(CurrentSLD, sldsPattern))
         recreateDynaFoldersSQLdbList(DynamicFoldersList)

      ResetImgLoadStatus()
      SoundBeep 900, 100
      If !CurrentSLD
      {
         SLDtypeLoaded := 2
         CurrentSLD := SelectedDir "\newFile.SLD"
         RandomPicture()
      }
   }
}

coreAddNewFolder(SelectedDir, forceRemAll, noRandom:=0, forReal:=1, fastu:=1) {
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    ; markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    thisFolder := (forceRemAll=1) ? StrReplace(SelectedDir, "|") : SelectedDir
    If (forReal=0 && SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    remFilesFromList(thisFolder, 1, forReal)
    z := GetFilesList(SelectedDir "\*", 0, 1, fastu)
    If (fastu=1)
    {
       GenerateRandyList()
       SoundBeep, 900, 100
    }

    CurrentSLD := backCurrentSLD
    If (noRandom=1)
    {
       currentFileIndex := maxFilesIndex - 1
       dummyTimerDelayiedImageDisplay(150)
    } Else RandomPicture()
    Return z
}

detectFileID(imgPath) {
    Loop, % maxFilesIndex + 1
    {
       If (resultedFilesList[A_Index, 1]=imgPath)
       {
          good := A_Index
          Break
       }
    }
    If !good
       good := 1

    Return good
}

GuiDroppedFiles(imgsListu, foldersListu, sldFile, countFiles, isCtrlDown) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<900)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   lastInvoked := A_TickCount
   If (imgsListu && isCtrlDown=1)
   {
      OpenWithNewQPVinstance(0, imgsListu, countFiles)
      Return
   }
   ; ToolTip, % "l=" sldFile , , , 2
   initQPVmainDLL()
   If sldFile
   {
      zPlitPath(sldFile, 0, FileName, OutDir)
      If (CurrentSLD && maxFilesIndex>1)
         msgResult := msgBoxWrapper(appTitle ": Import file", "Would you like to import the dropped files list into the current one?`n`nFile to open or import:`n" FileName "`n" OutDir "\", "&Import|&Open files list|&Cancel", 1, "question")
      Else msgResult := "open"

      If (msgResult="import")
      {
         If (RegExMatch(sldFile, "i)(.\.sldb)$") && SLDtypeLoaded!=3)
            importSLDBintoPlainText(sldFile)
         Else If (RegExMatch(sldFile, "i)(.\.sldb)$") && SLDtypeLoaded=3)
            importSLDBintoSLDB(sldFile)
         Else If RegExMatch(sldFile, "i)(.\.sld)$")
            importSLDplainText(sldFile)

         SetTimer, createGUItoolbar, -100
         TriggerMenuBarUpdate()
      } Else If InStr(msgResult, "open")
         OpenSLD(sldFile)
      lastInvoked := A_TickCount
      Return
   }

   If (CurrentSLD && maxFilesIndex>1 && StrLen(foldersListu)>3)
      msgResult := msgBoxWrapper(appTitle ": Import files", "Would you like to import the dropped folder(s) to the current files list?", "&Import|&New list|&Cancel", 1, "question")

   If (msgResult="cancel" || InStr(msgResult, "win_close"))
   {
      lastInvoked := A_TickCount
      Return
   } Else If InStr(msgResult, "new")
   {
      SlidesMusicSong := ""
      mainFoldersListu := CurrentSLD := DynamicFoldersList := ""
      renewCurrentFilesList()
      AnyWindowOpen := 1000
      resetMainWin2Welcome()
      AnyWindowOpen := ""
   }

   watchFolderDetails := ""
   updateUIctrl()
   If StrLen(foldersListu)>3
   {
      mustOpenStartFolder := ""
      mainFoldersListu := getDynamicFoldersList()
      doStartLongOpDance()
      dropFilesSelection(1)
      setwhileLoopExec(1)
      showTOOLtip("Preparing to import dropped folders, please wait")
      If StrLen(filesFilter)>1
         remFilesListFilter("simple")

      mainListu := retrieveListFoldersIndexed()
      newListu := DynamicFoldersList "`n"
      Loop, Parse, foldersListu,`n,`r
      {
          linea := Trimmer(A_LoopField)
          If StrLen(linea)<4
             Continue

          If mainListu[Format("{:L}", linea)]
          {
             msgu := "The following folder seems to be already indexed:`n`n" linea "\"
             msgResult := msgBoxWrapper(appTitle ": Confirmation", msgu "`n`nDo you want to add it to the list? This may lead to duplicate entries.", 4, 0, "question")
             If (msgResult!="Yes")
                Continue
          }

          changeMcursor()
          r := wrapperAddNewFolderToList(linea, 1, 1)
          ; r := GetFilesList(linea "\*")
          If (r="abandoned")
             Break

          stuffAdded := 1
          lastOne := linea
          newListu .= "`n" linea "`n"
      }

      mainListu := ""
      DynamicFoldersList := cleanDynamicFoldersList(newListu)
      If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
         recreateDynaFoldersSQLdbList(DynamicFoldersList)

      If (stuffAdded=1)
      {
         newStaticFoldersListCache := []
         mustGenerateStaticFolders := 1
         GenerateRandyList()
      }

      setwhileLoopExec(0)
      If !CurrentSLD
      {
         If FolderExist(StrReplace(Trimmer(DynamicFoldersList), "|"))
         {
            SLDtypeLoaded := 1
            CurrentSLD := Trimmer(DynamicFoldersList)
         } Else
         {
            SLDtypeLoaded := 2
            CurrentSLD := lastOne "\newFile.SLD"
         }
      }

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, createGUItoolbar, -100
      TriggerMenuBarUpdate()
      currentFileIndex := maxFilesIndex - 1
      dummyTimerDelayiedImageDisplay(10)
   } Else If (imgsListu && countFiles=1 && !CurrentSLD)
   {
      imgPath := Trimmer(imgsListu)
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      If (OutDir="")
      {
         lastInvoked := A_TickCount
         Return
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath))
      {
         SLDtypeLoaded := 1
         lastInvoked := A_TickCount
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

         MenuOpenLastImg(imgPath)
         lastInvoked := A_TickCount
         Return
      }

      showTOOLtip("Opening file`n" imgPath)
      newStaticFoldersListCache := []
      dropFilesSelection(1)
      If StrLen(filesFilter)>1
         remFilesListFilter("simple")

      If !InStr(msgResult, "new")
      {
         prevMaxFilesIndex := maxFilesIndex
         prevFoldersDyna := DynamicFoldersList
         bckpResultedFilesList := resultedFilesList.Clone()
      }

      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      coreOpenFolder("|" OutDir, 0)
      If prevMaxFilesIndex
      {
         DynamicFoldersList .= prevFoldersDyna
         Loop, % prevMaxFilesIndex
         {
             r := bckpResultedFilesList[A_Index, 1]
             If (r && !InStr(r, "||"))
             {
                maxFilesIndex++
                resultedFilesList[maxFilesIndex, 1] := r
             }
         }
         bckpResultedFilesList := []
      }

      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         currentFileIndex := detectFileID(imgPath)
         SetTimer, createGUItoolbar, -100
         TriggerMenuBarUpdate()
         IDshowImage(currentFileIndex)
      } Else resetMainWin2Welcome()
   } Else If StrLen(imgsListu)>3
   {
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, prevOpenFolderPath)
      mustGenerateStaticFolders := 1
      ForceRefreshNowThumbsList()
      GenerateRandyList()
      SetTimer, ResetImgLoadStatus, -50
      If (A_TickCount - lastInvoked>2000)
         SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      currentFileIndex := maxFilesIndex
      SetTimer, createGUItoolbar, -100
      TriggerMenuBarUpdate()
      dummyTimerDelayiedImageDisplay(50)
   }

   lastInvoked := A_TickCount
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyPrevShowToolTip() {
   showTOOLtip("nully")
}

dummyDelayShowToolTip() {
   showTOOLtip(delayiedHUDmsg, 0, 0, delayiedHUDperc)
}

showDelayedTooltip(msg, perc:=0, delayu:=450, expire:=0) {
    if InStr(msg, "error")
       addJournalEntry(msg)

    delayiedHUDmsg := msg
    delayiedHUDperc := perc
    SetTimer, dummyDelayShowToolTip, % -delayu
    expire := (expire<100) ? msgDisplayTime + delayu*2 : expire + delayu
    SetTimer, RemoveTooltip, % -expire
}

showTOOLtip(msg, funcu:=0, typeFuncu:=0, perc:=0) {
   Critical, on
   Static prevMsg
   If (msg="nully" && prevMsg)
      msg := prevMsg

   prevMsg := msg
   CreateOSDinfoLine(msg, 0, 0, perc, funcu, typeFuncu)
   If (AnyWindowOpen>0 && WinActive("A")=hSetWinGui && panelWinCollapsed=0)
   {
      GetPhysicalCursorPos(mX, mY)
      If ((InStr(msg, "error") || InStr(msg, "failed") || InStr(msg, "warning")) && !perc)
      {
         If (z := InStr(msg, "`n"))
         {
            a := SubStr(msg, 1, z - 1)
            b := SubStr(msg, z + 1)
            BalloonTip(b, a, "I=2 T=10", uiUseDarkMode)
         } Else BalloonTip(appTitle, msg, "I=2 T=5", uiUseDarkMode)
      } Else ToolTip
      ; Else If !perc
      ; ToolTip, % msg, % mX + 25, % mY + 25
   } Else If (AnyWindowOpen>0)
      ToolTip
}

RemoveTooltip() {
   Tooltip
   lastOSDtooltipInvoked := 1
   CreateOSDinfoLine(1, 1)
}

ForceRemoveTooltip() {
   Tooltip
   lastOSDtooltipInvoked := 1
   BalloonTip_Kill()
   CreateOSDinfoLine(2, 1)
}

PanelAssociateQPV() {
   fakeWinCreator(52, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Associate " appTitle, "Please choose what to associate " appTitle " with.", "&Proceed|C&ancel", 1, "settings", "Add file explorer context menu entry for folders: Open in QPV", 0, "Associate with common image formats`f`fAssociate with all supported image formats`fAssociate with QPV slideshow / files list formats`fRemove QPV files associations`fDo not change files associations", 0, 0)
   If InStr(msgResult.btn, "Proceed")
   {
      If !A_IsCompiled
      {
         msgBoxWrapper(appTitle ": ERROR", "This feature is only available when this application is compiled.", 0, 0, "error")
         Return
      }

      associateWithImages(msgResult.list)
      If (msgResult.check=1)
         associateWithExplorer(1)
      Else
         associateWithExplorer(3)
   }
}

associateWithExplorer(modus) {
   Static q := Chr(34)
   zPlitPath(fullPath2exe, 0, OutFileName, OutDir)
   Cmd := q fullPath2exe q A_Space q "%1" q
   Cmd := StrReplace(Cmd, "\", "\\")
   Cmd := StrReplace(Cmd, """", "\""")

   regFile := "Windows Registry Editor Version 5.00`n`n"
   If (modus=1)
   {
      regFile .= "[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer]`n""Icon""=" q StrReplace(fullPath2exe, "\", "\\") q "`n"
      regFile .= "@=""Open in QPV""`n"
      regFile .= "[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer\Command]`n"
      regFile .= "@=""\" q StrReplace(fullPath2exe, "\", "\\") "\"" fd=|\""%1\" q q "`n"
   } Else If (modus=3) ; remove explorer context menu
   {
      regFile .= "[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer]`n"
   } Else If (modus=4) ; remove file associations
   {
      regFile .= "[-HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "]`n"
      regFile .= "[-HKEY_CLASSES_ROOT\QPVslideshow]`n"
      regFile .= "[-HKEY_LOCAL_MACHINE\Software\Classes\QPVslideshow]`n"
      allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")
      Loop, Parse, allFormats, |
      {
         If !A_LoopField
            Continue

         regFile .= "[-HKEY_CLASSES_ROOT\QPVimage." A_LoopField "]`n"
         regFile .= "[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\QPVimage." A_LoopField "]`n"
      }
   } Else
   {
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "]`n" q "FriendlyAppName""=" q appTitle q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell]`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell\open]`n" q "FriendlyAppName""=" q appTitle q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell\open\command]`n@=" q Cmd q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\SupportedTypes]`n"
      allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")
      Loop, Parse, allFormats, |
      {
         If !A_LoopField
            Continue

         regFile .= q "." A_LoopField q "=" q q "`n"
      }
   }

   If !FolderExist(mainCompiledPath "\regFiles")
   {
      FileCreateDir, %mainCompiledPath%\regFiles
      If ErrorLevel
         errorOccured := 1

      Sleep, 1
   }

   FileDelete, %mainCompiledPath%\regFiles\RegExplGeneral.reg
   FileDelete, %mainCompiledPath%\regFiles\runThis.bat
   Sleep, 1
   FileAppend, % regFile, %mainCompiledPath%\regFiles\RegExplGeneral.reg, UTF-16
   If ErrorLevel
      errorOccured := 1

   runTarget := "Reg Import " q mainCompiledPath "\regFiles\RegExplGeneral.reg" q "`n"
   FileAppend, % runTarget, %mainCompiledPath%\regFiles\runThis.bat
   If ErrorLevel
      errorOccured := 1

   ;  msgbox, % "loool=" A_ThisFunc "==" modus
   If !errorOccured
      Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
   Sleep, 1
   FileDelete, %mainCompiledPath%\regFiles\RegExplGeneral.reg
   FileDelete, %mainCompiledPath%\regFiles\runThis.bat
   If (errorOccured && modus!=2)
      msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while associating " appTitle " with Explorer context menu options.", 0, 0, "error")
}

associateSLDsNow() {
    z := ShellFileAssociate("QPVslideshow",".sld", fullPath2exe, 0, 0, mainCompiledPath)
    If z
       ShellFileAssociate("QPVslideshow",".sldb", fullPath2exe, 0, 0, mainCompiledPath)
    Else
       msgBoxWrapper(appTitle ": ERROR", "An unknown error occured when associating " appTitle " with slideshow / files list formats.", 0, 0, "error")
}

associateWithImages(modus) {
  Static FileFormatsCommon := "|png|bmp|gif|jpg|tif|tga|webp|jpeg|tiff|exr|hdr|psd|"
       , allFormats := 0 ; "dib|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif"

  If !allFormats
     allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")

  If (modus=3)
  {
     associateSLDsNow()
     Return
  } Else If (modus=4)
  {
     associateWithExplorer(4)
     Return
  } Else Return

  Loop, Parse, FileFormatsCommon, |
  {
      If !A_LoopField
         Continue

      z := ShellFileAssociate("QPVimage." A_LoopField,"." A_LoopField, fullPath2exe, 0, 1, mainCompiledPath)
      If !z
      {
         errorOccured := 1
         Break
      }

  }

  Sleep, 25
  If !errorOccured
     Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
  Sleep, 5
  FileDelete, %mainCompiledPath%\regFiles\*.reg
  FileDelete, %mainCompiledPath%\regFiles\*.bat

  ; msgResult := msgBoxWrapper(appTitle, appTitle " was now associated with common image file formats. Would you like to associate it with all the 85 supported file formats?", 4, 0, "question")
  ; If (msgResult="yes")
  If (modus=2 && !errorOccured)
  {
     Loop, Parse, allFormats, |
     {
         If (!A_LoopField || InStr(FileFormatsCommon, "|" A_LoopField "|"))
            Continue
 
         z := ShellFileAssociate("QPVimage." A_LoopField,"." A_LoopField, fullPath2exe, 0, 1, mainCompiledPath)
         If !z
         {
            errorOccured := 1
            Break
         }
     }
 
     Sleep, 25
     If !errorOccured
        Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
     Sleep, 5
     FileDelete, %mainCompiledPath%\regFiles\*.reg
     FileDelete, %mainCompiledPath%\regFiles\*.bat
  }

  If errorOccured
  {
     msgBoxWrapper(appTitle ": ERROR", "An unknown error occured during associating " appTitle " with image file formats.", 0, 0, "error")
     Return
  } Else associateWithExplorer(2)

  addJournalEntry(appTitle " has been associated with image file formats")
}

closeDocuments() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (animGIFplaying=1)
   {
      DestroyGIFuWin()
      Return
   }

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("discard it")
      Return

   If AnyWindowOpen
   {
      BtnCloseWindow()
      SetTimer, closeDocuments, -700
      Return
   }

   terminateIMGediting()
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   PopulateIndexFilesStatsInfos("kill")
   SLDtypeLoaded := 1
   resetMainWin2Welcome()
   addJournalEntry("All images/documents closed.")
   ResetImgLoadStatus()
}

restartAppu() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will restart")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("restart")
      Return

   ; writeMainSettings()
   If A_IsCompiled
      Try Run, "%fullPath2exe%"
   Else
      Try Run, %unCompiledExePath%

   TrueCleanup(0)
   Sleep, 5
   ExitApp
}

exitAppu(dummy:=0) {
   If (MsgBox2hwnd && InStr(dummy, "external"))
   {
      interfaceThread.ahkPostFunction("dummyTimerExit")
      terminateIMGediting()
      TrueCleanup()
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will exit")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("exit")
      Return

   terminateIMGediting()
   TrueCleanup()
}

askAboutFilesSelect(act) {
   Static doNotAskAgain := 0
   If (markedSelectFile>50 && maxFilesIndex>250 && doNotAskAgain=0)
   {
      msgResult := msgBoxWrapper(appTitle ": Discard selection", "The current opened files list has " groupDigits(markedSelectFile) " files selected. Are you sure you want to " act " ?", "&Yes|&No", 2, "question", "Do not ask again in the current session")
      If !InStr(msgResult.btn, "Yes")
         Return 1
      Else
         doNotaskAgain := msgResult.check
   }
}

InitGuiContextForcedMenu() {
   InitGuiContextMenu("forced")
}

InitGuiContextMenu(keyu:=0, mX:="-", mY:=0, givenCoords:=0) {
   Static lastInvoked := 1
   Critical, off

   If (A_TickCount - lastPointerUseZeit<600)
      Return

   If !isNumber(mX)
      GetMouseCoord2wind(PVhwnd, mX, mY)

   globalMenuOptions := givenCoords
   If (keyu!="forced")
   {
      If (A_TickCount - lastInvoked<250) && (keyu="extern") || (A_TickCount - zeitSillyPrevent<250)
         Return

      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      Au := WinActive("A")
      If !InStr(keyu, "appsk")
         MouseGetPos, , , Bu
      Else
         Bu := Au

      okay := (isVarEqualTo(Au, PVhwnd, hGDIwin, hGDIthumbsWin) && isVarEqualTo(Bu, PVhwnd, hGDIwin, hGDIthumbsWin)) ? 1 : 0
      If (okay!=1)
         Return 1

      setwhileLoopExec(0)
      If (slideShowRunning=1)
         ToggleSlideShowu()

      DestroyGIFuWin()
      If (thumbsDisplaying=0 && editingSelectionNow=1 && adjustNowSel=0 && drawingShapeNow=0)
         dotActiveObj := determineSelAreaClickRect(mX, mY, SelDotsSize, mainWidth, mainHeight, 1)

      If (showHUDnavIMG=1 && hasDrawnImageMap=1 && !dotActiveObj.n && (IMGlargerViewPort=1 && thumbsDisplaying=0 || thumbsDisplaying=1)
      && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
      {
         invokeImgSizeVP()
         lastInvoked := A_TickCount
         Return
      } Else If (dotActiveObj.n>0 && dotActiveObj.n!=9 && editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1)
      {
         If (imgEditPanelOpened=1)
            BuildImgLiveEditMenu()
         Else
            invokeSelectionAreaMenu("DoubleClick")
         lastInvoked := A_TickCount
         Return
      } Else If (showHistogram>1 && hasDrawnHistoMap=1 && !dotActiveObj.n && thumbsDisplaying=0 && drawingShapeNow=0
      && isDotInRect(mX, mY, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3], HUDobjHistoBoxu[4], HUDobjHistoBoxu[2] + HUDobjHistoBoxu[4]))
      {
         invokeHistoMenu()
         lastInvoked := A_TickCount
         Return
      }

      delayu := 1
      If (thumbsDisplaying=1 && maxFilesIndex>1 && !InStr(keyu, "appskey"))
      {
         delayu := 10
         r := WinClickAction("rclick", "nona", mX, mY)
         dummyTimerDelayiedImageDisplay(50)
      }
   } Else If (drawingShapeNow=0)
      Sleep, 350

   If (drawingShapeNow=1)
   {
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      ; GetMouseCoord2wind(PVhwnd, mX, mY)
      addNewVectorShapePoints(mX, mY, mainWidth, mainHeight, "rClick", 0, 0)
      Return
   }

   If (r="scrollbar")
      SetTimer, invokeNavigationMenu, -10
   Else If (r="StatusBar")
      SetTimer, MenuPanelFoldersTree, -10
   Else If (r="FsoloMenu")
      SetTimer, invokeFileOptionsMenu, -10
   Else If (InStr(keyu, "+") || InStr(keyu, "^"))
      SetTimer, BuildSecondMenu, % -10 - Round(delayu)
   Else If (r!="none")
      SetTimer, BuildMainMenu, % -10 - Round(delayu)

   lastInvoked := A_TickCount
   ; WinActivate, ahk_id %PVhwnd%
}

MeasureStringGdipLight(stringu, fontName, isBold, Size, xpos, ypos, Width, Height, Unit:=0, NoWrap:=1) {
   hFontFamily := Gdip_FontFamilyCreate(fontName)
   If !hFontFamily
      hFontFamily := Gdip_FontFamilyCreateGeneric(1)
   If !hFontFamily
      Return 0

   hFont := Gdip_FontCreate(hFontFamily, Size, isBold, Unit)
   If !hFont
      Return 0

   FormatStyle := NoWrap ? 0x4000 | 0x1000 : 0x4000
   hStringFormat := Gdip_StringFormatCreate(FormatStyle)
   If !hStringFormat
      hStringFormat := Gdip_StringFormatGetGeneric(1)

   CreateRectF(RC, xpos, ypos, Width, Height)
   ReturnRC := Gdip_MeasureString(2NDglPG, stringu, hFont, hStringFormat, RC)
   ReturnRCtest := StrSplit(ReturnRC, "|")
   testW := Floor(ReturnRCtest[3])

   Gdip_DeleteFont(hFont)
   Gdip_DeleteFontFamily(hFontFamily)
   Gdip_DeleteStringFormat(hStringFormat)
   RC := ""
   Return testW
}

PathCompact(givenPath, CharMax, allowOverflow:=0, fontSizeu:=0, givenWidth:=0, minChars:=0) {
    If (CharMax="a")
    {
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       mainWidth := givenWidth ? givenWidth : mainWidth//1.6 + 1
       borderSize := imgHUDbaseUnit//5
       txtResW := MeasureStringGdipLight(givenPath, OSDFontName, OSDfontBolded, fontSizeu, borderSize, 0, mainWidth*3, mainHeight)
       If (txtResW>=mainWidth - borderSize)
       {
          CharMax := Round((mainWidth/(txtResW / StrLen(givenPath))) + mainWidth/fontSizeu)//2 + 1
          If (CharMax<minChars)
             CharMax := minChars
       } Else CharMax := StrLen(givenPath)
       ; ToolTip, % txtResW "=" mainWidth "==" CharMax , , , 2
    }

    If (StrLen(givenPath)>CharMax+3)
    {
       partB := SubStr(givenPath, InStr(givenPath, "\", 0, 0))
       If (StrLen(partB)>CharMax && allowOverflow=0)
          partB := SubStr(givenPath, 1, 3) "[...]" SubStr(givenPath, -CharMax + 3)
       Else
          partA := SubStr(givenPath, 1, max(CharMax - StrLen(partB), 3)) "..."
       Return partA partB
    } Else Return givenPath
}

createMenuSelectionRotationAspectRatio() {
   ; defiSelAR := defineSelectionAspectRatios()
   kMenu("PVselRatio", "Add", "&Increase rotation by 1°`tShift+0", "MenuSelIncRotation")
   kMenu("PVselRatio", "Add", "&Decrease rotation by 1°`tShift+9", "MenuSelDecRotation")
   kMenu("PVselRatio", "Add", "R&otate by 45°`tShift+R", "MenuSelRotation")
   If (VPselRotation>0)
      kMenu("PVselRatio", "Add", "R&eset rotation`tShift+\", "resetSelectionRotation")
   kMenu("PVselRatio", "Add/Uncheck", "&Keep aspect ratio on rotation", "ToggleSelKeepRatioRotation")
   kMenu("PVselRatio", "Add", "Set to s&quare ratio (1:1)`tR", "makeSquareSelection")
   If (lockSelectionAspectRatio>1)
      kMenu("PVselRatio", "Disable", "Set to s&quare ratio (1:1)`tR")

   Menu, PVselRatio, Add
   kMenu("PVselRatio", "Add", "Cycle loc&k aspect ratios`tShift+A", "toggleImgSelectionAspectRatio")
   kMenu("PVselRatio", "Add/Uncheck", "&Unlocked", "MenuSetLockSelRatioUnlocked")
   kMenu("PVselRatio", "Add/Uncheck", "&Active selection`tCtrl+Shift+A", "MenuSetLockSelRatioSelu")
   kMenu("PVselRatio", "Add/Uncheck", "&Current window", "MenuSetLockSelRatioWindow")
   kMenu("PVselRatio", "Add/Uncheck", "&Current image", "MenuSetLockSelRatioImage")
   kMenu("PVselRatio", "Add/Uncheck", "&Square [1:1]", "MenuSetLockSelRatioSquare")
   kMenu("PVselRatio", "Add/Uncheck", "&SDTV [4:3]", "MenuSetLockSelRatioSDTV")
   kMenu("PVselRatio", "Add/Uncheck", "&35mm film [3:2]", "MenuSetLockSelRatio35mmFilm")
   kMenu("PVselRatio", "Add/Uncheck", "&HDTV [16:9]", "MenuSetLockSelRatioHDTV")
   kMenu("PVselRatio", "Add/Uncheck", "&Wide screens [16:10]", "MenuSetLockSelRatioWide")
   kMenu("PVselRatio", "Add/Uncheck", "&Phone", "MenuSetLockSelRatioPhone")
   If (lockSelectionAspectRatio<=1)
      kMenu("PVselRatio", "Check", "&Unlocked")
   Else If (lockSelectionAspectRatio=2)
      kMenu("PVselRatio", "Check", "&Active selection`tCtrl+Shift+A")
   Else If (lockSelectionAspectRatio=3)
      kMenu("PVselRatio", "Check", "&Current window")
   Else If (lockSelectionAspectRatio=4)
      kMenu("PVselRatio", "Check", "&Current image")
   Else If (lockSelectionAspectRatio=5)
      kMenu("PVselRatio", "Check", "&Square [1:1]")
   Else If (lockSelectionAspectRatio=6)
      kMenu("PVselRatio", "Check", "&SDTV [4:3]")
   Else If (lockSelectionAspectRatio=7)
      kMenu("PVselRatio", "Check", "&35mm film [3:2]")
   Else If (lockSelectionAspectRatio=8)
      kMenu("PVselRatio", "Check", "&HDTV [16:9]")
   Else If (lockSelectionAspectRatio=9)
      kMenu("PVselRatio", "Check", "&Wide screens [16:10]")
   Else If (lockSelectionAspectRatio=10)
      kMenu("PVselRatio", "Check", "&Phone")

   If (rotateSelBoundsKeepRatio=1)
      kMenu("PVselRatio", "Check", "&Keep aspect ratio on rotation")
}

createMenuSelectionAlign() {
   kMenu("PVselAlign", "Add", "Inside", "dummy")
   kMenu("PVselAlign", "Disable", "Inside")
   kMenu("PVselAlign", "Add", "&Top`tCtrl+NumPad8", "alignImgSelectTop")
   kMenu("PVselAlign", "Add", "&Bottom`tCtrl+NumPad2", "alignImgSelectBottom")
   kMenu("PVselAlign", "Add", "&Left`tCtrl+NumPad4", "alignImgSelectLeft")
   kMenu("PVselAlign", "Add", "&Right`tCtrl+NumPad6", "alignImgSelectRight")
   Menu, PVselAlign, Add
   kMenu("PVselAlign", "Add", "&Center horizontally`tCtrl+NumPad5", "alignImgSelectCenterH")
   kMenu("PVselAlign", "Add", "Center &vertically`tCtrl+NumPad0", "alignImgSelectCenterV")
   If (AnyWindowOpen=32 || AnyWindowOpen=31 || AnyWindowOpen=24 || AnyWindowOpen=23)
   {
      Menu, PVselAlign, Add
      kMenu("PVselAlign", "Add", "Outside", "dummy")
      kMenu("PVselAlign", "Disable", "Outside")
      kMenu("PVselAlign", "Add", "&Top", "alignImgSelectOutTop")
      kMenu("PVselAlign", "Add", "&Bottom", "alignImgSelectOutBottom")
      kMenu("PVselAlign", "Add", "&Left", "alignImgSelectOutLeft")
      kMenu("PVselAlign", "Add", "&Right", "alignImgSelectOutRight")
   }
}

createMenuSelectShapeTension() {
   keyuA := (drawingShapeNow=1) ? "`tB" : ""
   kMenu("PVshapeTension", "Add/Uncheck", "Bézier spline" keyuA, "MenuToggleBezierMode", "shape tension anchors")

   Menu, PVshapeTension, Add
   keyuB := (drawingShapeNow=1) ? "`tT" : ""
   kMenu("PVshapeTension", "Add", "&Cycle smoothness levels" keyuB, "togglePathCurveTension", "shape tension")
   Menu, PVshapeTension, Add
   kMenu("PVshapeTension", "Add/Uncheck", "&Polygonal", "MenuSetShapeTensionP", "shape tension")
   kMenu("PVshapeTension", "Add/Uncheck", "&Smooth corners", "MenuSetShapeTensionS", "shape tension")
   kMenu("PVshapeTension", "Add/Uncheck", "&Curve", "MenuSetShapeTensionC", "shape tension")
   kMenu("PVshapeTension", "Add/Uncheck", "&Rounded curve", "MenuSetShapeTensionR", "shape tension")
   If (FillAreaCurveTension=1)
      kMenu("PVshapeTension", "Check", "&Polygonal")
   Else If (FillAreaCurveTension=2)
      kMenu("PVshapeTension", "Check", "&Smooth corners")
   Else If (FillAreaCurveTension=3)
      kMenu("PVshapeTension", "Check", "&Curve")
   Else If (FillAreaCurveTension=4)
      kMenu("PVshapeTension", "Check", "&Rounded curve")

   kMenu("PVshapeTension", "Disable", "&Cycle smoothness levels" keyuB, "togglePathCurveTension", "shape tension")
   If (bezierSplineCustomShape=1)
      kMenu("PVshapeTension", "Check", "Bézier spline" keyuA)
}

createMenuSelectSizeShapes(dummy:=0, b:=0) {
   If (dummy!="simple")
   {
      kMenu("PVselSize", "Add", "C&ycle selection types`tShift+E", "toggleEllipseSelection")
      kMenu("PVselSize", "Add/Uncheck", "&Rectangular", "MenuSetSelectionShapeRect", "shape type")
      kMenu("PVselSize", "Add/Uncheck", "&Ellipse / oval", "MenuSetSelectionShapeEllipse", "shape type")
      kMenu("PVselSize", "Add/Uncheck", "&Custom shape", "MenuSetSelectionShapeFreeform", "freeform type spline polygonal")

      If (EllipseSelectMode=1)
         kMenu("PVselSize", "Check", "&Ellipse / oval")
      Else If (EllipseSelectMode=2)
         kMenu("PVselSize", "Check", "&Custom shape")
      Else
         kMenu("PVselSize", "Check", "&Rectangular")
   }

   friendly := AnyWindowOpen ? "" : "Manage / "
   If (dummy!="mnb" && b!="mnb")
   {
      Menu, PVselSize, Add
      kMenu("PVselSize", "Add", friendly "Load custom shapes", "PanelManageVectorShapes")
   }

   infoKbd := (EllipseSelectMode!=2) ? "`tShift+L" : ""
   If (dummy!="simple" && dummy!="mnb")
      kMenu("PVselSize", "Add", "&Define new freeform shape" infoKbd, "MenuStartDrawingSelectionArea", "edit freeform draw selection")

   If (EllipseSelectMode=2)
   {
      Menu, PVselSize, Add
      createMenuSelectShapeTension()
      If !AnyWindowOpen
         kMenu("PVselSize", "Add", "Save vector shape", "PanelSaveVectorShape")
      kMenu("PVselSize", "Add", "&Modify custom shape`tShift+L", "MenuResumeDrawingShapes", "edit draw freeform selection")
      kMenu("PVselSize", "Add", "Flip shape &horizontally`tH", "MenuSelectionFlipH")
      kMenu("PVselSize", "Add", "&Flip shape vertically`tV", "MenuSelectionFlipV")
      kMenu("PVselSize", "Add/Uncheck", "&Open ended path", "toggleOpenClosedAnyCustomShape", "opened closed vector")
      kMenu("PVselSize", "Add", "Set &points tension", ":PVshapeTension")
      If (closedLineCustomShape=0)
         kMenu("PVselSize", "Check", "&Open ended path")
   }
}

createMenuSelectionArea(modus:=0) {
   If (modus="DoubleClick")
   {
      kMenu("PVselv", "Add", "Main menu`tAppsKey", "InitGuiContextForcedMenu")
      Menu, PVselv, Add, 
   }

   If (undoLevelsRecorded>1 && undoLevelsRecorded!="" && infoImgEditingNow=1 && editingSelectionNow=1)
   {
      friendly := (modus="DoubleClick") ? " selection" : ""
      kMenu("PVselv", "Add", "&Undo" friendly "`tCtrl+Shift+Z", "ImgSelUndoAct")
      kMenu("PVselv", "Add", "&Redo" friendly "`tCtrl+Shift+Y", "ImgSelRedoAct")
      Menu, PVselv, Add,
   }

   infoImgEditingNow := isImgEditingNow()
   If (infoImgEditingNow=1)
   {
      keyword := (editingSelectionNow=1) ? "hide" : " display"
      kMenu("PVselv", "Add/Uncheck", "&Show selection area`tE", "ToggleEditImgSelection", keyword)
      If (editingSelectionNow=1)
         kMenu("PVselv", "Check", "&Show selection area`tE")
   }

   If (modus!="DoubleClick")
      kMenu("PVselv", "Add", "&Drop and reset`tCtrl+D", "resetImgSelection", "hide")

   If (innerSelectionCavityX>0.01 && innerSelectionCavityY>0.01)
      kMenu("PVselv", "Add", "R&eset exclude area`tShift+\", "resetSelectionAreaCavity")

   If (infoImgEditingNow=1)
      kMenu("PVselv", "Add", "Se&lect all`tCtrl+A", "selectEntireImage")

   If (editingSelectionNow=1 && infoImgEditingNow=1)
   {
      createMenuSelectSizeShapes()
      createMenuSelectionAlign()
      kMenu("PVselv", "Add/Uncheck", "Limit to image bo&undaries`tL", "toggleLimitSelection")
      kMenu("PVselv", "Add", "Flip width / &height`tW", "flipSelectionWH")
      If (LimitSelectBoundsImg=1)
         kMenu("PVselv", "Check", "Limit to image bo&undaries`tL")

      createMenuSelectionRotationAspectRatio()
      kMenu("PVselv", "Add", "&Selection shapes", ":PVselSize")
      kMenu("PVselv", "Add", "Ali&gnment", ":PVselAlign")
      kMenu("PVselv", "Add", "Rotation and &aspect ratio", ":PVselRatio")
      Menu, PVselv, Add, 
      keyword := (editingSelectionNow=1) ? "hide" : " display"
      kMenu("PVselv", "Add/Uncheck", "Sho&w grid", "ToggleSelectGrid", keyword)
      kMenu("PVselv", "Add", "Selection properties`tAlt+E", "PanelIMGselProperties")
      If (showSelectionGrid=1)
         kMenu("PVselv", "Check", "Sho&w grid")
   }

   If (infoImgEditingNow=1 && modus="DoubleClick")
   {
      createMenuImageEditSubMenus()
      createMenuAlphaMask()
      Menu, PVselv, Add
      If (editingSelectionNow=1)
         kMenu("PVselv", "Add", "C&ut selected area`tCtrl+X", "CutSelectedArea", "image")

      kMenu("PVselv", "Add", "&Copy to clipboard`tCtrl+C", "CopyImage2clip", "image")
      If (editingSelectionNow=1)
         kMenu("PVselv", "Add", "&Paste in place`tCtrl+Shift+V", "PanelPasteInPlace", "image editing")

      Menu, PVselv, Add
      Try kMenu("PVselv", "Add", "Alpha mas&k", ":PValpha")
      kMenu("PVselv", "Add", "&Filters", ":PVimgFilters")
      kMenu("PVselv", "Add", "&Draw", ":PVimgDraw")
      kMenu("PVselv", "Add", "&Transform", ":PVimgTransform")
   }
}

createMenuImageEditSubMenus() {
   infoImgEditingNow := isImgEditingNow()
   If (thumbsDisplaying!=1 && infoImgEditingNow=1)
   {
      kMenu("PVimgFilters", "Add", "&Blur/pixelize`tShift+B", "PanelBlurSelectedArea", "effects")
      kMenu("PVimgFilters", "Add", "&Zoom blur", "PanelZoomBlurSelectedArea", "effects")
      kMenu("PVimgFilters", "Add", "&Invert colors`tShift+I", "InvertSelectedArea", "effects")
      kMenu("PVimgFilters", "Add", "Desaturate color&s`tCtrl+G", "PanelDesatureSelectedArea", "grayscale effects")
      kMenu("PVimgFilters", "Add", "Ad&just image colors`tU", "PanelColorsAdjusterImage", "grayscale effects lightness contrast saturation levels brightness")
      kMenu("PVimgFilters", "Add", "&Detect edges filter", "PanelDetectEdgesImage", "emboss effects")
      kMenu("PVimgFilters", "Add", "&Add noise filter", "PanelAddNoiserImage", "effects")

      kMenu("PVimgDraw", "Add", "Define f&reeform filled shape`tShift+P", "MenuStartDrawingShapes", "curve polygonal")
      kMenu("PVimgDraw", "Add", "Define freeform &outline`tAlt+P", "MenuStartDrawingLines", "curve polygonal lines")
      kMenu("PVimgDraw", "Add", "&Paint brushes`tP", "PanelBrushTool", "pinch bulge effects draw deformer smudge cloner effects")
      kMenu("PVimgDraw", "Add", "&Erase or fade area`tDelete", "PanelEraseSelectedArea")
      kMenu("PVimgDraw", "Add", "&Flood fill / color bucket`tK", "PanelFloodFillTool")
      kMenu("PVimgDraw", "Add", "&Fill shapes`tAlt+Bksp", "PanelFillSelectedArea", "curve polygonal glass effects blur")
      kMenu("PVimgDraw", "Add", "Fill be&hind image", "PanelFillBehindBgrImage")
      kMenu("PVimgDraw", "Add", "Draw s&hape contours`tCtrl+L", "PanelDrawShapesInArea", "lines")
      kMenu("PVimgDraw", "Add", "&Draw simple lines or arcs", "PanelDrawLines")
      kMenu("PVimgDraw", "Add", "Insert te&xt`tShift+T", "PanelInsertTextArea", "write add draw type")

      kMenu("PVimgTransform", "Add", "&Adjust canvas size`tAlt+A", "PanelAdjustImageCanvasSize")
      kMenu("PVimgTransform", "Add", "&Resize image`tCtrl+R", "PanelEditorImgResize")
      kMenu("PVimgTransform", "Add", "A&uto-crop image`tAlt+Y", "PanelImgAutoCrop")
      kMenu("PVimgTransform", "Add", "A&dvanced live transform`tCtrl+T", "PanelTransformSelectedArea", "crop rotate resize clone blend alpha-masking flip blur glass effects adjust colors")
      Menu, PVimgTransform, Add, 
      kMenu("PVimgTransform", "Add", "Flip selected &horizontally`tShift+H", "FlipSelectedAreaH")
      kMenu("PVimgTransform", "Add", "Flip selected &vertically`tShift+V", "FlipSelectedAreaV")
      kMenu("PVimgTransform", "Add", "&Crop image to selection`tShift+Enter", "CropImageInViewPortToSelection")
      kMenu("PVimgTransform", "Add", "&Resize image to selection`tAlt+R", "ResizeIMGviewportSelection")

      If (editingSelectionNow!=1)
      {
         kMenu("PVimgDraw", "Disable", "&Erase or fade area`tDelete")
         kMenu("PVimgTransform", "Disable", "A&dvanced live transform`tCtrl+T")
         kMenu("PVimgTransform", "Disable", "Flip selected &horizontally`tShift+H")
         kMenu("PVimgTransform", "Disable", "Flip selected &vertically`tShift+V")
         kMenu("PVimgTransform", "Disable", "&Crop image to selection`tShift+Enter")
         kMenu("PVimgTransform", "Disable", "&Resize image to selection`tAlt+R")
      }
   }
}

InvokeMenuBarVectorFile(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarFile, Delete

   kMenu("pvMenuBarFile", "Add", "Vector drawing mode", "dummy")
   kMenu("pvMenuBarFile", "Disable", "Vector drawing mode")
   kMenu("pvMenuBarFile", "Add", "&Apply / done`tEnter", "stopDrawingShape")
   kMenu("pvMenuBarFile", "Add", "&Exit pen tool mode`tEscape", "cancelDrawingShape")

   showThisMenu("pvMenuBarFile", 0, 1, manuID)
}

InvokeMenuBarVectorInterface(manuID) {
   deleteMenus()
   createMenuInterfaceOptions()
   showThisMenu("PvUIprefs", 0, 1, manuID)
}

InvokeMenuBarVectorView(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarView, Delete

   createMenuImgSizeAdapt()
   kMenu("pvMenuBarView", "Add", "Zoom adapt modes", ":PvImgAdapt")
   Menu, pvMenuBarView, Add
   createMenuImgColorsFX()
   kMenu("pvMenuBarView", "Add", "Colors F&X and display modes", ":PVimgColorsFX")
   kMenu("pvMenuBarView", "Add", "Reset vie&wport adjustments`t\", "ResetImageView", "image")
   Menu, pvMenuBarView, Add
   kMenu("pvMenuBarView", "Add/Uncheck", "Show viewport &grid", "toggleViewPortGridu", keyword)
   kMenu("pvMenuBarView", "Add/Uncheck", "Fi&xed grid size", "toggleGridFixedSize")
   If (vpGridFixedSize=1)
      kMenu("pvMenuBarView", "Check", "Fi&xed grid size")
   If (showViewPortGrid=1)
      kMenu("pvMenuBarView", "Check", "Show viewport &grid")

   kMenu("pvMenuBarView", "Add", "Increase grid size`tAlt+[+]", "MenuIncVPgridSize")
   kMenu("pvMenuBarView", "Add", "Decrease grid size`tAlt+[-]", "MenuDecVPgridSize")
   Menu, pvMenuBarView, Add
   kMenu("pvMenuBarView", "Add/Uncheck", "Centered &alignment`tA", "ToggleIMGalign", "viewport image position")
   If (imageAligned=5)
      kMenu("pvMenuBarView", "Check", "Centered &alignment`tA")

   kMenu("pvMenuBarView", "Add/Uncheck", "Allo&w outside viewport image panning", "toggleFreePanning")
   If (allowFreeIMGpanning=1)
      kMenu("pvMenuBarView", "Check", "Allo&w outside viewport image panning")

   showThisMenu("pvMenuBarView", 0, 1, manuID)
}

InvokeMenuBarVectorSelection(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarSelection, Delete

   kMenu("pvMenuBarSelection", "Add", "Select all points`tCtrl+A", "MenuSelAllVectorPoints")
   kMenu("pvMenuBarSelection", "Add", "Total points: " groupDigits(customShapePoints.count()), "dummy")
   kMenu("pvMenuBarSelection", "Disable", "Total points: " groupDigits(customShapePoints.count()))
   If (customShapeHasSelectedPoints=1)
   {
      Menu, pvMenuBarSelection, Add
      If (bezierSplineCustomShape!=1)
         kMenu("pvMenuBarSelection", "Add", "Cop&y points", "MenuCopyVectorPoints")

      kMenu("pvMenuBarSelection", "Add", "Deselect points`tCtrl+D", "MenuSelNoVectorPoints")
      kMenu("pvMenuBarSelection", "Add", "In&vert points selection`tShift+I", "MenuSelInvertVectorPoints")
      kMenu("pvMenuBarSelection", "Add", "&Delete selected points`tDelete", "MenuRemSelVectorPoints")
      If (bezierSplineCustomShape=1)
      {
         kMenu("pvMenuBarSelection", "Add", "&Collapse anchors for selected points", "MenuCollapseSelectedAnchorPoints")
         kMenu("pvMenuBarSelection", "Add", "&Expand anchors for selected points", "MenuExpandSelectedAnchorPoints")
      }
   }

   showThisMenu("pvMenuBarSelection", 0, 1, manuID)
}

InvokeMenuBarVectorEdit(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarEdit, Delete

   undos := undoVectorShapesLevelsArray.Count()
   If (currentVectorUndoLevel>1 || undos>1)
   {
      kMenu("pvMenuBarEdit", "Add", "&Undo`tCtrl+Z", "ImgVectorUndoAct")
      kMenu("pvMenuBarEdit", "Add", "&Redo`tCtrl+Y", "ImgVectorRedoAct")
      kMenu("pvMenuBarEdit", "Add", "Levels: " groupDigits(undos), "dummy")
      kMenu("pvMenuBarEdit", "Disable", "Levels: " groupDigits(undos))
      Menu, pvMenuBarEdit, Add
   }

   kMenu("pvMenuBarEdit", "Add", "&Remove last point`tBackspace", "reduceCustomShapelength")
   If (customShapePoints.Count()<2)
   {
      kMenu("pvMenuBarEdit", "Add", "C&ycle symmetry modes`tY", "toggleBrushSymmetryModes")
   } Else If (CustomShapeLockedSymmetry)
   {
      kMenu("pvMenuBarEdit", "Add/Uncheck", "Toggle symmetry mode`tY", "toggleBrushSymmetryModes")
      If CustomShapeSymmetry
         kMenu("pvMenuBarEdit", "Check", "Toggle symmetry mode`tY")
   } 

   createMenuSelectShapeTension()
   kMenu("pvMenuBarEdit", "Add", "&Path smoothness", ":PVshapeTension")
   If (bezierSplineCustomShape!=1)
   {
      kMenu("pvMenuBarEdit", "Add/Uncheck", "&Preview new point`tP", "togglePreviewVectorNewPoint")
      If (showNewVectorPointPreview=1)
         kMenu("pvMenuBarEdit", "Check", "&Preview new point`tP")
   } Else
   {
      kMenu("pvMenuBarEdit", "Add/Uncheck", "Auto-reflect anchors`tR", "toggleAutoReflectAnchors")
      If (autoReflectVectorAnchors=1)
         kMenu("pvMenuBarEdit", "Check", "Auto-reflect anchors`tR")
   }

   kMenu("pvMenuBarEdit", "Add/Uncheck", "&Open ended path`tO", "toggleOpenClosedLineCustomShape", "opened closed vector")
   If (closedLineCustomShape=0)
      kMenu("pvMenuBarEdit", "Check", "&Open ended path`tO")

   showThisMenu("pvMenuBarEdit", 0, 1, manuID)
}

InvokeMenuBarEditorFile(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarFile, Delete

   kMenu("pvMenuBarFile", "Add", "Live tool mode", "dummy")
   kMenu("pvMenuBarFile", "Disable", "Live tool mode")
   kMenu("pvMenuBarFile", "Add/Uncheck", "&Collapse tool panel`tF8", "toggleImgEditPanelWindow")
   If (panelWinCollapsed=1)
      kMenu("pvMenuBarFile", "Check", "&Collapse tool panel`tF8")

   drawing := isNowAlphaPainting()
   If (drawing!=1)
      kMenu("pvMenuBarFile", "Add", "&Cancel / close panel`tEscape", "BtnCloseWindow")

   If (!isVarEqualTo(AnyWindowOpen, 10  64, 66) && imgEditPanelOpened=1)
      kMenu("pvMenuBarFile", "Add", "Appl&y tool`tEnter", "applyIMGeditFunction")

   Try Menu, PVtActFile, Delete
   zPlitPath(resultedFilesList[currentFileIndex, 1], 0, OutFileName, OutDir)
   If FileExist(resultedFilesList[currentFileIndex, 1])
   {
      kMenu("PVtActFile", "Add", "Open with default application", "OpenWithDefaultApp")
      kMenu("PVtActFile", "Add", "&Open with external app", "OpenThisFileMenu")
      kMenu("PVtActFile", "Add", "Open file in a new &QPV instance", "SoloNewQPVinstance")
      kMenu("PVtActFile", "Add", "System «Open with» dialog", "MenuInvokeSHopenWith", "external")

      Menu, pvMenuBarFile, Add
      kMenu("pvMenuBarFile", "Add", "Open this&...", ":PVtActFile")
      kMenu("pvMenuBarFile", "Add", "File prope&rties (Explorer)", "OpenFileProperties")
      kMenu("pvMenuBarFile", "Add", "&Explore containing folder", "OpenThisFileFolder")
      If !FolderExist(OutDir)
         kMenu("pvMenuBarFile", "Disable", "&Explore containing folder")
   }

   showThisMenu("pvMenuBarFile", 0, 1, manuID)
}

InvokeMenuBarFile(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarFile, Delete
   createMenuOpenRecents("simple")
   createMenuFavourites()

   If (thumbsDisplaying!=1)
   {
      kMenu("pvMenuBarFile", "Add", "New image`tCtrl+N", "PanelNewImage", "image editing")
      If isImgEditingNow()
      {
         If (StrLen(UserMemBMP)>2)
         {
            kMenu("pvMenuBarFile", "Add", "&Save image`tCtrl+S", "PanelSaveImg", "image edit")
            If FileExist(resultedFilesList[currentFileIndex, 1])
               kMenu("pvMenuBarFile", "Add", "&Revert changes...`tF5", "RefreshImageFileAction", "reload refresh")
         } Else
            kMenu("pvMenuBarFile", "Add", "&Save image as...`tCtrl+S", "PanelSaveImg", "image editing")
         kMenu("pvMenuBarFile", "Add", "Print image`tCtrl+P", "PanelPrintImage")
      }

      kMenu("pvMenuBarFile", "Add", "Ac&quire image (WIA)", "AcquireWIAimage", "capture devices")
      Menu, pvMenuBarFile, Add
   }

   kMenu("pvMenuBarFile", "Add", "&Open image or slideshow`tCtrl+O", "OpenDialogFiles", "open image files")
   kMenu("pvMenuBarFile", "Add", "&Open folder recursively`tShift+O", "OpenFolders", "open image folder files")
   kMenu("pvMenuBarFile", "Add", "&New QPV instance`tCtrl+Shift+N", "OpenNewQPVinstance")
   If (maxFilesIndex<1 || !CurrentSLD)
      kMenu("pvMenuBarFile", "Add", "Insert file(s)`tInsert", "addNewFile2list", "images list")

   Menu, pvMenuBarFile, Add
   kMenu("pvMenuBarFile", "Add", "&Recents", ":PVopenF", "files recent")
   kMenu("pvMenuBarFile", "Add", "Fa&vourites", ":PVfaves", "files favourites")
   If (thumbsDisplaying=1 && maxFilesIndex>0)
   {
      Menu, pvMenuBarFile, Add,
      If (markedSelectFile>0)
      {
         createMenuSoloFile("simple")
         kMenu("pvMenuBarFile", "Add", "Active / focused file", ":PVtActFile")
         Menu, pvMenuBarFile, Add
      }

      If !markedSelectFile
      {
         createMenuOpenFileOptions("simple")
         kMenu("pvMenuBarFile", "Add", "Open this&...", ":PVtFileOpen")
         ; kMenu("pvMenuBarFile", "Add", "Set as &wallpaper", "setImageWallpaper", "desktop image")
         If FileExist(resultedFilesList[currentFileIndex, 1])
            kMenu("pvMenuBarFile", "Add", "&Import into currently loaded image", "importEditGivenImageFile")
         kMenu("pvMenuBarFile", "Add", "File prope&rties (Explorer)", "OpenFileProperties")
         kMenu("pvMenuBarFile", "Add", "&Containing folder properties (Explorer)", "OpenThisFilePropFolder", "external")
      } Else
         kMenu("pvMenuBarFile", "Add", "Open files in new &QPV instances`tCtrl+Enter", "OpenWithNewQPVinstance")

      Menu, pvMenuBarFile, Add,
      kMenu("pvMenuBarFile", "Add", "&Delete file(s)`tDelete", "DeletePicture", "erase")
      kMenu("pvMenuBarFile", "Add", "&Rename file(s)`tF2", "PanelRenameThisFile")
      kMenu("pvMenuBarFile", "Add", "&Move file(s) to...`tM", "PanelMoveCopyFiles")
      kMenu("pvMenuBarFile", "Add", "&Copy file(s) to...`tC", "InvokeCopyFiles")
   } Else If FileExist(resultedFilesList[currentFileIndex, 1])
   {
      Menu, pvMenuBarFile, Add
      Try Menu, PVtActFile, Delete

      zPlitPath(resultedFilesList[currentFileIndex, 1], 0, OutFileName, OutDir)
      kMenu("PVtActFile", "Add", "Open with default application", "OpenWithDefaultApp")
      kMenu("PVtActFile", "Add", "&Open with external app`tO", "OpenThisFileMenu")
      kMenu("PVtActFile", "Add", "Open file in a new &QPV instance`tCtrl+Enter", "SoloNewQPVinstance")
      kMenu("PVtActFile", "Add", "Open in QPV the containin&g folder`tAlt+E", "OpenQPVfileFolder")
      kMenu("PVtActFile", "Add", "&Explore containing folder`tCtrl+E", "OpenThisFileFolder")
      If ((!FolderExist(OutDir) || StrReplace(CurrentSLD, "|")=OutDir) && !mustOpenStartFolder)
         kMenu("PVtActFile", "Disable", "Open in QPV the containin&g folder`tAlt+E")

      kMenu("PVtActFile", "Add", "System «Open with» dialog", "MenuInvokeSHopenWith", "external")
      kMenu("pvMenuBarFile", "Add", "Open this&...", ":PVtActFile")
      Menu, pvMenuBarFile, Add
      kMenu("pvMenuBarFile", "Add", "&File information`tAlt+Enter", "PanelImageInfos", "properties image details")
      kMenu("pvMenuBarFile", "Add", "File prope&rties (Explorer)", "OpenFileProperties")
      If !FolderExist(OutDir)
         kMenu("pvMenuBarFile", "Disable", "&Explore containing folder`tCtrl+E")
      Menu, pvMenuBarFile, Add
      kMenu("pvMenuBarFile", "Add", "&Delete file`tDelete", "DeleteActivePicture")
      kMenu("pvMenuBarFile", "Add", "&Rename file`tShift+F2", "SingularRenameFile")
      kMenu("pvMenuBarFile", "Add", "&Move file(s) to...`tM", "PanelMoveCopyFiles")
      kMenu("pvMenuBarFile", "Add", "&Copy file(s) to...`tC", "InvokeCopyFiles")
   }

   Menu, pvMenuBarFile, Add
   modus := (StrLen(UserMemBMP)>2 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : "welcome"
   If (modus!="welcome")
      kMenu("pvMenuBarFile", "Add", "Close ima&ge and files list`tCtrl+F4", "closeDocuments", "reset")
   kMenu("pvMenuBarFile", "Add", "Restart`tShift+Esc", "restartAppu", "close renew")
   kMenu("pvMenuBarFile", "Add", "Exit`tEscape", "exitAppu", "close")
   showThisMenu("pvMenuBarFile", 0, 1, manuID)
}

InvokeMenuBarEdit(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarEdit, Delete

   infoImgEditingNow := isImgEditingNow()
   If (thumbsDisplaying!=1)
   {
      kMenu("pvMenuBarEdit", "Add", "&Undo`tCtrl+Z", "ImgUndoAction", "image edit")
      kMenu("pvMenuBarEdit", "Add", "&Redo`tCtrl+Y", "ImgRedoAction", "image edit")
      If !(undoLevelsRecorded>1 && undoLevelsRecorded!="" && infoImgEditingNow=1)
      {
         kMenu("pvMenuBarEdit", "Disable", "&Undo`tCtrl+Z")
         kMenu("pvMenuBarEdit", "Disable", "&Redo`tCtrl+Y")
      } Else
      {
         kMenu("pvMenuBarEdit", "Add", "Levels: " groupDigits(undoLevelsRecorded), "dummy")
         kMenu("pvMenuBarEdit", "Disable", "Levels: " groupDigits(undoLevelsRecorded))
      }

      Menu, pvMenuBarEdit, Add
      kMenu("pvMenuBarEdit", "Add", "C&ut selected area`tCtrl+X", "CutSelectedArea", "image editing")
      kMenu("pvMenuBarEdit", "Add", "&Copy to clipboard`tCtrl+C", "CopyImage2clip", "image")

      If (infoImgEditingNow!=1)
         kMenu("pvMenuBarEdit", "Disable", "&Copy to clipboard`tCtrl+C")

      kMenu("pvMenuBarEdit", "Add", "P&aste clipboard`tCtrl+V", "PasteClipboardIMG")
      kMenu("pvMenuBarEdit", "Add", "&Paste in place`tCtrl+Shift+V", "PanelPasteInPlace")
      If !AnyWindowOpen
      {
         hasAdded := 1
         Menu, pvMenuBarEdit, Add
         kMenu("pvMenuBarEdit", "Add", "&Crop image to selection`tShift+Enter", "CropImageInViewPortToSelection")
         kMenu("pvMenuBarEdit", "Add", "&Resize image to selection`tAlt+R", "ResizeIMGviewportSelection")
      }

      If AnyWindowOpen
         kMenu("pvMenuBarEdit", "Disable", "P&aste clipboard`tCtrl+V")

      If (editingSelectionNow!=1 || infoImgEditingNow!=1 || AnyWindowOpen)
      {
         kMenu("pvMenuBarEdit", "Disable", "C&ut selected area`tCtrl+X")
         kMenu("pvMenuBarEdit", "Disable", "&Paste in place`tCtrl+Shift+V")
         If hasAdded
         {
            kMenu("pvMenuBarEdit", "Disable", "&Crop image to selection`tShift+Enter", "CropImageInViewPortToSelection")
            kMenu("pvMenuBarEdit", "Disable", "&Resize image to selection`tAlt+R", "ResizeIMGviewportSelection")
         }
      }

      If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      {
         Menu, pvMenuBarEdit, Add
         createMenuCopyFile("PVcopy")
         kMenu("pvMenuBarEdit", "Add", "&Modify index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
         kMenu("pvMenuBarEdit", "Add", "&Copy...", ":PVcopy")
      }

      If (imgEditPanelOpened=1)
      {
         If isVarEqualTo(AnyWindowOpen, 64, 31, 24, 23)
         {
            added := 1
            Menu, pvMenuBarEdit, Add
         }

         If (editingSelectionNow=1 && AnyWindowOpen=23 && liveDrawingBrushTool!=1)
         {
            If isInRange(FillAreaColorMode, 2, 4)
            {
               kMenu("pvMenuBarEdit", "Add", "&Reset gradient center", "BtnSetTextureSource")
               kMenu("pvMenuBarEdit", "Add/Uncheck", "&Allow gradient center repositioning", "toggleClrGradientCenterRepose")
               If (userAllowClrGradientRecenter=1)
                  kMenu("pvMenuBarEdit", "Check", "&Allow gradient center repositioning")
            } Else If (FillAreaColorMode=6)
               kMenu("pvMenuBarEdit", "Add", "&Set texture fill source`tS", "BtnSetTextureSource")
         } Else If (AnyWindowOpen=64 && BrushToolType<4)
         {
            kMenu("pvMenuBarEdit", "Add", "&Cycle symmetry modes`tY", "toggleBrushSymmetryModes")
            kMenu("pvMenuBarEdit", "Add", "&Define symmetry point`tShift+Y", "BtnSetBrushSymmetryCoords")
            If (BrushToolType=3)
               kMenu("pvMenuBarEdit", "Add", "Define cloner &source`tS", "BtnSetClonerBrushSource")
         } Else If isVarEqualTo(AnyWindowOpen, 31, 24)
         {
            kMenu("pvMenuBarEdit", "Add", "Reset to &initial position", "ResetTransformToolPos")
            If (shearImgX!=0 || shearImgY!=0)
               kMenu("pvMenuBarEdit", "Add", "&Reset image skew offsets", "resetImgSkewOffsets")
         }

         If isVarEqualTo(AnyWindowOpen, 64, 66)
         {
            additions := FloodFillSelectionAdj
            labelu := (AnyWindowOpen=64) ? "Painting" : "Bucket"
            kMenu("pvMenuBarEdit", "Add/Uncheck", "&" labelu " mode`tCtrl+K", "toggleAlphaPaintingMode")
            kMenu("pvMenuBarEdit", "Add", "&Cycle " labelu " modes`tShift+K", "toggleBrushDrawInOutModes")
            If (liveDrawingBrushTool=1 && AnyWindowOpen=64) || (FloodFillSelectionAdj!=1 && AnyWindowOpen=66)
               kMenu("pvMenuBarEdit", "Check", "&" labelu " mode`tCtrl+K")
         }

         If (!isVarEqualTo(AnyWindowOpen, 10, 64, 66, 12) && liveDrawingBrushTool!=1)
         {
            If !added
               Menu, pvMenuBarEdit, Add
            kMenu("pvMenuBarEdit", "Add", "&Hide dynamic object`tD", "toggleLiveEditObject")
         }
      }
   } Else
   {
      createMenuCopyFile("pvMenuBarEdit")
      Menu, pvMenuBarEdit, Add
      kMenu("pvMenuBarEdit", "Add", "&Paste file(s) to list`tCtrl+V", "PasteClipboardIMG", "index list")
      If markedSelectFile
      {
         Menu, pvMenuBarEdit, Add
         kMenu("pvMenuBarEdit", "Add", "Re&group dispersed files", "regroupSelectedFiles")
      }

      Menu, pvMenuBarEdit, Add
      If !EntryMarkedMoveIndex
         kMenu("pvMenuBarEdit", "Add", "Mar&k entry to reorder`tX", "moveMarkedEntryNow")
      Else
         kMenu("pvMenuBarEdit", "Add", "Move mar&ked entry to focused index`tX", "moveMarkedEntryNow")

      kMenu("pvMenuBarEdit", "Add", "Remove inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
      If markedSelectFile
        kMenu("pvMenuBarEdit", "Add", "Remove selected inde&x entries`tDelete", "InListMultiEntriesRemover", "erase")

      kMenu("pvMenuBarEdit", "Add", "&Modify index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
      If (StrLen(UserMemBMP)>2)
      {
         Menu, pvMenuBarEdit, Add
         kMenu("pvMenuBarEdit", "Add", "&Return to image editing", "MenuReturnIMGedit", "back")
      }
   }

   showThisMenu("pvMenuBarEdit", 0, 1, manuID)
}

InvokeMenuBarEditorSelection(manuID) {
   deleteMenus()
   infoImgEditingNow := isImgEditingNow()
   kMenu("PVselv", "Add", "&Undo`tCtrl+Shift+Z", "ImgSelUndoAct")
   kMenu("PVselv", "Add", "&Redo`tCtrl+Shift+Y", "ImgSelRedoAct")
   If !(undoLevelsRecorded>1 && undoLevelsRecorded!="" && infoImgEditingNow=1 && editingSelectionNow=1)
   {
      kMenu("PVselv", "Disable", "&Undo`tCtrl+Shift+Z")
      kMenu("PVselv", "Disable", "&Redo`tCtrl+Shift+Y")
   } Else
   {
      totalSelUndos := Round(undoSelLevelsArray.Count())
      kMenu("PVselv", "Add", "Levels: " groupDigits(totalSelUndos), "dummy")
      kMenu("PVselv", "Disable", "Levels: " groupDigits(totalSelUndos))
   }

   Menu, PVselv, Add
   If (isVarEqualTo(AnyWindowOpen, 10, 12, 64, 66) && imgEditPanelOpened=1)
   {
      kMenu("PVselv", "Add/Uncheck", "&Show selection`tE", "ToggleEditImgSelection")
      If (editingSelectionNow=1)
         kMenu("PVselv", "Check", "&Show selection`tE")
      Else
         kMenu("PVselv", "Add", "&Select all`tCtrl+A", "MenuSelectAllAction")
   }

   isWinCustomShapeFriendly := isVarEqualTo(AnyWindowOpen, 74, 68, 66, 65, 64, 55, 25, 23, 10)
   drawing := isNowAlphaPainting()
   decideLiveSelectionBasedOnWindow(angleu, isToolGood)
   If isVarEqualTo(AnyWindowOpen, 65, 23)
      isToolGood := 1

   If (editingSelectionNow=1)
   {
      additions := 1
      If (AnyWindowOpen=23)
         additions := !liveDrawingBrushTool
      Else If isVarEqualTo(AnyWindowOpen, 64, 66)
         additions := FloodFillSelectionAdj
   }

   If (additions=1)
   {
      If (isToolGood=1 && isWinCustomShapeFriendly=1 && editingSelectionNow=1)
      {
         kMenu("PVselv", "Add", "&Load custom shapes", "PanelManageVectorShapes")
         If (EllipseSelectMode=2 && editingSelectionNow=1)
         {
            createMenuSelectSizeShapes("simple", "mnb")
            kMenu("PVselv", "Add", "&Custom shape options", ":PVselSize")
         }
         Menu, PVselv, Add
      }

      If (isToolGood=1)
      {
         infoSelShape := DefineVPselAreaMode()
         kMenu("PVselv", "Add", "C&ycle selection types`tShift+E", "MenuCycleSelectionShapes")
         kMenu("PVselv", "Add", infoSelShape, "dummy")
         kMenu("PVselv", "Disable", infoSelShape)
         Menu, PVselv, Add
      }

      kMenu("PVselv", "Add", "&Select all`tCtrl+A", "MenuSelectAllAction")
      If (innerSelectionCavityX>0.01 && innerSelectionCavityY>0.01)
         kMenu("PVselv", "Add", "R&eset exclude area`tShift+\", "resetSelectionAreaCavity")

      kMenu("PVselv", "Add", "&Flip selection W/H`tW", "flipSelectionWH")
      kMenu("PVselv", "Add/Uncheck", "&Limit selection to image area`tL", "toggleLimitSelection")
      If (LimitSelectBoundsImg=1)
         kMenu("PVselv", "Check", "&Limit selection to image area`tL")

      kMenu("PVselv", "Add", "&Reset selection", "newImgSelection")
      kMenu("PVselv", "Add/Uncheck", "Sho&w grid", "ToggleSelectGrid")
      If (showSelectionGrid=1)
         kMenu("PVselv", "Check", "Sho&w grid")

      createMenuSelectionAlign()
      createMenuSelectionRotationAspectRatio()
      kMenu("PVselv", "Add", "Ali&gnment", ":PVselAlign")
      kMenu("PVselv", "Add", "&Rotation and aspect ratio", ":PVselRatio")
      If (imgEditPanelOpened=1 && isWinCustomShapeFriendly=1)
      {
         Menu, PVselv, Add
         kMenu("PVselv", "Add", "Selection &properties`tAlt+E", "PanelIMGselProperties")
      }
   } Else If (isVarEqualTo(AnyWindowOpen, 64, 66) && editingSelectionNow=1)
   {
      kMenu("PVselv", "Add", "&Activate selection mode`tK", "toggleAlphaPaintingMode")
   }

   showThisMenu("PVselv", 0, 1, manuID)
}

InvokeMenuBarSelection(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarSelection, Delete

   If (thumbsDisplaying=1)
   {
      createMenuFilesSelections("pvMenuBarSelection")
      If StrLen(filesFilter)>1
      {
         If testIsDupesList()
         {
            Menu, pvMenuBarSelection, Add
            kMenu("pvMenuBarSelection", "Add", "Auto-select &duplicates", "PanelAutoSelectDupes")
         }
      }
   } Else
   {
      infoImgEditingNow := isImgEditingNow()
      kMenu("pvMenuBarSelection", "Add", "&Undo`tCtrl+Shift+Z", "ImgSelUndoAct")
      kMenu("pvMenuBarSelection", "Add", "&Redo`tCtrl+Shift+Y", "ImgSelRedoAct")
      If !(undoLevelsRecorded>1 && undoLevelsRecorded!="" && infoImgEditingNow=1 && editingSelectionNow=1)
      {
         kMenu("pvMenuBarSelection", "Disable", "&Undo`tCtrl+Shift+Z")
         kMenu("pvMenuBarSelection", "Disable", "&Redo`tCtrl+Shift+Y")
      } Else
      {
         totalSelUndos := Round(undoSelLevelsArray.Count())
         kMenu("pvMenuBarSelection", "Add", "Levels: " groupDigits(totalSelUndos), "dummy")
         kMenu("pvMenuBarSelection", "Disable", "Levels: " groupDigits(totalSelUndos))
      }

      Menu, pvMenuBarSelection, Add
      keyword := (editingSelectionNow=1) ? "hide" : " display"
      If (editingSelectionNow!=1 && imgSelX2=-1 && imgSelY2=-1)
      {
         kMenu("pvMenuBarSelection", "Add", "Create &selection area`tE", "newImgSelection", "image editing")
         If (infoImgEditingNow!=1)
            kMenu("pvMenuBarSelection", "Disable", "Create &selection area`tE")
      } Else
      {
         kMenu("pvMenuBarSelection", "Add/UnCheck", "Sho&w selection area`tE", "ToggleEditImgSelection", "image editing")
         If (editingSelectionNow=1)
            kMenu("pvMenuBarSelection", "Check", "Sho&w selection area`tE")
         If (infoImgEditingNow!=1)
            kMenu("pvMenuBarSelection", "Disable", "Sho&w selection area`tE")
      }

      friendly := AnyWindowOpen ? "" : "Manage / "
      kMenu("pvMenuBarSelection", "Add", friendly "Load custom shapes", "PanelManageVectorShapes")
      infoKbd := (EllipseSelectMode!=2) ? "`tShift+L" : ""
      kMenu("pvMenuBarSelection", "Add", "&Define new freeform shape" infoKbd, "MenuStartDrawingSelectionArea", "edit freeform draw selection")
      kMenu("pvMenuBarSelection", "Add", "Se&lect all`tCtrl+A", "selectEntireImage")
      If (infoImgEditingNow!=1)
      {
         kMenu("pvMenuBarSelection", "Disable", "Se&lect all`tCtrl+A")
         kMenu("pvMenuBarSelection", "Disable", "&Define new freeform shape" infoKbd)
         kMenu("pvMenuBarSelection", "Disable", friendly "Load custom shapes")
      }

      If (editingSelectionNow=1 && infoImgEditingNow=1)
      {
         createMenuSelectSizeShapes("mnb")
         createMenuSelectionAlign()
         If (innerSelectionCavityX>0.01 && innerSelectionCavityY>0.01)
            kMenu("pvMenuBarSelection", "Add", "R&eset exclude area`tShift+\", "resetSelectionAreaCavity")
         kMenu("pvMenuBarSelection", "Add", "&Drop and reset`tCtrl+D", "resetImgSelection", "hide")
         kMenu("pvMenuBarSelection", "Add/Uncheck", "Limit to image bo&undaries`tL", "toggleLimitSelection")
         kMenu("pvMenuBarSelection", "Add", "Flip width / &height`tW", "flipSelectionWH")
         If (LimitSelectBoundsImg=1)
            kMenu("pvMenuBarSelection", "Check", "Limit to image bo&undaries`tL")

         createMenuSelectionRotationAspectRatio()
         kMenu("pvMenuBarSelection", "Add", "&Shape options", ":PVselSize")
         kMenu("pvMenuBarSelection", "Add", "Ali&gnment", ":PVselAlign")
         kMenu("pvMenuBarSelection", "Add", "Rotation and &aspect ratio", ":PVselRatio")
         Menu, pvMenuBarSelection, Add, 
         keyword := (editingSelectionNow=1) ? "hide" : " display"
         kMenu("pvMenuBarSelection", "Add/Uncheck", "Sho&w grid", "ToggleSelectGrid", keyword)
         kMenu("pvMenuBarSelection", "Add", "Selection properties`tAlt+E", "PanelIMGselProperties")
         If (showSelectionGrid=1)
            kMenu("pvMenuBarSelection", "Check", "Sho&w grid")
      }
      Menu, pvMenuBarSelection, Add, 
      friendly := resultedFilesList[currentFileIndex, 2] ? "De&select" : "&Select"
      kMenu("pvMenuBarSelection", "Add", friendly " file`tTab", "MenuMarkThisFileNow")
      If (maxFilesIndex<2)
         kMenu("pvMenuBarSelection", "Disable", friendly " file`tTab")
   }

   showThisMenu("pvMenuBarSelection", 0, 1, manuID)
}

InvokeMenuBarImage(manuID) {
  deleteMenus()
  Try Menu, pvMenuBarImage, Delete
  infoImgEditingNow := isImgEditingNow()
  If (infoImgEditingNow=1)
  {
     If ((isAlphaMaskPartialWin()=1 || isAlphaMaskWindow()=1) && imgEditPanelOpened=1 || !AnyWindowOpen)
     {
        createMenuAlphaMask()
        Try kMenu("pvMenuBarImage", "Add", "Alpha mas&k", ":PValpha")
     }

     If !AnyWindowOpen
     {
        createMenuImageEditSubMenus()
        Try kMenu("pvMenuBarImage", "Add", "&Filters", ":PVimgFilters")
        Try kMenu("pvMenuBarImage", "Add", "&Draw", ":PVimgDraw")
        Try kMenu("pvMenuBarImage", "Add", "&Transform", ":PVimgTransform")
     } Else If (editingSelectionNow=1 && dummy!="mbr")
     {
        createMenuImageEditSubMenus()
        Try kMenu("pvMenuBarImage", "Add", "&Filters", ":PVimgFilters")
        kMenu("pvMenuBarImage", "Add", "Flip selected &horizontally`tShift+H", "FlipSelectedAreaH")
        kMenu("pvMenuBarImage", "Add", "Flip selected &vertically`tShift+V", "FlipSelectedAreaV")
        ; kMenu("pvMenuBarImage", "Add", "&Invert colors`tShift+I", "InvertSelectedArea")
     }

     Menu, pvMenuBarImage, Add
     kMenu("pvMenuBarImage", "Add/Uncheck", "&Use gamma correction", "toggleImgEditGammaCorrect")
     If (userimgGammaCorrect=1)
        kMenu("pvMenuBarImage", "Check", "&Use gamma correction")

     If (imgEditPanelOpened=1)
        kMenu("pvMenuBarImage", "Add", "Pic&k color from image`tC", "changeBrushColorPicker")

     If !AnyWindowOpen
     {
        Menu, pvMenuBarImage, Add
        kMenu("pvMenuBarImage", "Add", "Set as &wallpaper", "setImageWallpaper", "desktop image") 
        kMenu("pvMenuBarImage", "Add", "Con&vert file format(s) to...`tCtrl+K", "PanelFileFormatConverter", "image conversion")
        imgPath := getIDimage(currentFileIndex)
        kMenu("pvMenuBarImage", "Add", "&JPEG lossless operations`tShift+J", "PanelJpegPerformOperation")
        If !RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$")
           kMenu("pvMenuBarImage", "Disable", "&JPEG lossless operations`tShift+J")

        kMenu("pvMenuBarImage", "Add", "&Auto-crop image(s)`tAlt+Y", "PanelImgAutoCrop")
     }
  } Else If (thumbsDisplaying=1 && maxFilesIndex>0)
  {
     createMenuImageFileActions("pvMenuBarImage")
     kMenu("pvMenuBarImage", "Add", "Con&vert file format(s) to...`tCtrl+K", "PanelFileFormatConverter", "image conversion")
  }
  showThisMenu("pvMenuBarImage", 0, 1, manuID)
}

InvokeMenuBarFind(manuID) {
  deleteMenus()
  Try Menu, pvMenuBarFind, Delete
  showThese := (StrLen(mustOpenStartFolder)>3 || maxFilesIndex>1) ? 1 : 0
  If (showThese=1)
  {
     kMenu("pvMenuBarFind", "Add", "Searc&h index`tCtrl+F3", "PanelSearchIndex", "files list")
     If userSearchString
     {
        kMenu("pvMenuBarFind", "Add", "Erase search criteria", "EraseSearchEdit")
        Menu, pvMenuBarFind, Add
     }

     kMenu("pvMenuBarFind", "Add", "Search and re&place`tCtrl+H", "PanelSearchAndReplaceIndex", "files index list")
     kMenu("pvMenuBarFind", "Add", "&Find duplicate images", "PanelFindDupes")
     kMenu("pvMenuBarFind", "Add", "&Keywords indexer", "PanelKeywordsDetector")
     Menu, pvMenuBarFind, Add
     kMenu("pvMenuBarFind", "Add", "&Define index filter(s)`tCtrl+F", "PanelEnableFilesFilter", "files list")
     If (StrLen(filesFilter)>1)
     {
        kMenu("pvMenuBarFind", "Add", "Remove files list filter`tCtrl+Space", "MenuRemFilesListFilter")
        If testIsDupesList()
        {
           If InStr(resultedFilesList[currentFileIndex, 23], "_")
           {
              kMenu("pvMenuBarFind", "Disable", "&Define index filter(s)`tCtrl+F")
              kMenu("pvMenuBarFind", "Add", "Change dupes filter threshold`tCtrl+F", "PanelChangeHamDistThreshold")
           }
        }
     }
  } Else
  {
     kMenu("pvMenuBarFind", "Add", "Insufficient files indexed", "dummy")
     kMenu("pvMenuBarFind", "Disable", "Insufficient files indexed")
  }

  showThisMenu("pvMenuBarFind", 0, 1, manuID)
}

InvokeMenuBarList(manuID) {
  deleteMenus()
  Try Menu, pvMenuBarList, Delete
  showThese := (StrLen(mustOpenStartFolder)>3 || maxFilesIndex>1) ? 1 : 0
  If (showThese!=1)
  {
     kMenu("pvMenuBarList", "Add", "Insufficient files indexed", "dummy")
     kMenu("pvMenuBarList", "Disable", "Insufficient files indexed")
     showThisMenu("pvMenuBarList", 0, 1, manuID)
     Return
  }

  kMenu("pvMenuBarList", "Add", "I&mport list / insert file(s)`tInsert", "addNewFile2list")
  kMenu("pvMenuBarList", "Add", "&Add folder(s)`tShift+Insert", "addNewFolder2list")
  kMenu("pvMenuBarList", "Add", "Mana&ge folder(s) list`tAlt+U", "PanelDynamicFolderzWindow")
  labelu := (FileExist(CurrentSLD) && RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? "&Update files list selectively`tCtrl+U" : "Folders containin&g indexed files`tCtrl+U"
  kMenu("pvMenuBarList", "Add", labelu, "PanelStaticFolderzManager", "folders manage")
  If StrLen(DynamicFoldersList)>6
     kMenu("pvMenuBarList", "Add", "&Regenerate the entire list", "RegenerateEntireList")
  Menu, pvMenuBarList, Add
  If (SLDtypeLoaded=2 && currentFilesListModified=1 && CurrentSLD && maxFilesIndex>1)
     kMenu("pvMenuBarList", "Add", "&Save files list no&w`tCtrl+S", "BTNsaveCurrentSlideshow")
  If (maxFilesIndex>1)
     kMenu("pvMenuBarList", "Add", "Save files list as .S&LD`tCtrl+Shift+S", "PanelSaveSlideShowu")

  StringRight, infoPrevMovePath, prevFileMovePath, 25
  infoMenuRefresh := RegExMatch(CurrentSLD, sldsPattern) ? "Reload .SLD file" : "Refresh opened folder(s)"
  pathu := PathCompact(CurrentSLD, 40)
  If pathu
      kMenu("pvMenuBarList", "Add", infoMenuRefresh "`tShift+F5", "RefreshFilesList", "reload refresh list files")

  createMenuStatistics()
  Menu, pvMenuBarList, Add
  kMenu("pvMenuBarList", "Add", "&Statistics", ":PVstats")
  Menu, pvMenuBarList, Add
  kMenu("pvMenuBarList", "Add/Uncheck", "Auto-remove entries of dead files", "ToggleAutoRemEntries")
  If (autoRemDeadEntry=1)
     kMenu("pvMenuBarList", "Check", "Auto-remove entries of dead files")

  ; If RegExMatch(CurrentSLD, sldsPattern)
  labelu := (SLDtypeLoaded=3) ? "Clean inexistent files entries" : "Clean &duplicate and inexistent entries"
  kMenu("pvMenuBarList", "Add", labelu, "cleanDeadFilesList", "remove dead files erase")
  If (mustRecordSeenImgs=1)
     kMenu("pvMenuBarList", "Add", "Remove alread&y seen images", "removeFilesListSeenImages", "eliminate")
  If !InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
     kMenu("pvMenuBarList", "Add", "Remove fa&vourited images from list", "removeFilesListFavouritedImages", "eliminate")

  Menu, pvMenuBarList, Add
  If (mustRecordSeenImgs=1)
  {
     kMenu("pvMenuBarList", "Add", "Identify &already seen images", "quickFindSeenImages", "saw")
     kMenu("pvMenuBarList", "Add", "Identify &never seen images", "quickFindUnseenImages", "unseen")
  }

  If !InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
     kMenu("pvMenuBarList", "Add", "&Identify favourited images", "findFavesInList", "faved faves stared")
  showThisMenu("pvMenuBarList", 0, 1, manuID)
}

InvokeMenuBarView(manuID) {
  deleteMenus()
  If (isImgEditingNow() || thumbsDisplaying=1 && maxFilesIndex>0)
  {
     createMenuMainView()
  } Else
  {
     kMenu("PVview", "Add", "No image loaded", "dummy")
     kMenu("PVview", "Disable", "No image loaded")
  }
  showThisMenu("PVview", 0, 1, manuID)
}

InvokeMenuBarEditorTools(manuID) {
  deleteMenus()
  If isImgEditingNow()
  {
     createMenuLiveTools("mbr")
     showThisMenu("PVlTools", 0, 1, manuID)
  }
}

InvokeMenuBarAlphaMask(manuID) {
   deleteMenus()
   kMenu("PValpha", "Add", "Painting mode", "dummy")
   kMenu("PValpha", "Disable", "Painting mode")
   kMenu("PValpha", "Add", "E&xit tool`tEnter", "applyIMGeditFunction")
   Menu, PValpha, Add
   createMenuAlphaMask("PValpha")
   showThisMenu("PValpha", 0, 1, manuID)
}

InvokeMenuBarInterface(manuID) {
   deleteMenus()
   createMenuInterfaceOptions()
   showThisMenu("PvUIprefs", 0, 1, manuID)
}

InvokeMenuBarNavigate(manuID) {
   deleteMenus()
   createMenuNavigation()
   showThisMenu("PVnav", 0, 1, manuID)
}

InvokeMenuBarCaptions(manuID) {
   deleteMenus()
   createMenuAnnotations()
   showThisMenu("PVsounds", 0, 1, manuID)
}

InvokeMenuBarSlides(manuID) {
   deleteMenus()
   createMenuSlideshows()
   showThisMenu("PVslide", 0, 1, manuID)
}

InvokeMenuBarSort(manuID) {
   deleteMenus()
   createMenuFilesSort()
   showThisMenu("PVsort", 0, 1, manuID)
}

InvokeMenuBarSettings(manuID) {
   deleteMenus()
   createMenuMainPreferences()
   showThisMenu("PVprefs", 0, 1, manuID)
}

InvokeMenuBarHelp(manuID) {
   deleteMenus()
   createMenuHelpQPV()
   showThisMenu("PVhelp", 0, 1, manuID)
}

createMenuNavigation() {
   If (thumbsDisplaying!=1)
   {
      kMenu("PVnav", "Add/Uncheck", "&Skip missing files", "ToggleSkipDeadFiles")
      If (skipDeadFiles=1)
         kMenu("PVnav", "Check", "&Skip missing files")
      If (maxFilesIndex<2)
         kMenu("PVnav", "Disable", "&Skip missing files")
      Menu, PVnav, Add
   } Else 
   {
      kMenu("PVnav", "Add", "&Display the files list map now`tW", "MenuDrawFilesListMap")
      kMenu("PVnav", "Add/Uncheck", "&Show files list map on scrollbar click", "ToggleFilesMap")
      If (showFilesListMap=1)
         kMenu("PVnav", "Check", "&Show files list map on scrollbar click")
      If !(maxFilesIndex>10 && markedSelectFile>1)
         kMenu("PVnav", "Disable", "&Show files list map on scrollbar click")
      Menu, PVnav, Add,
   }

   showThese := (StrLen(mustOpenStartFolder)>3 || maxFilesIndex>1) ? 1 : 0
   kMenu("PVnav", "Add", "&First`tHome", "FirstPicture")
   kMenu("PVnav", "Add", "&Previous`tPage down", "PreviousPicture")
   kMenu("PVnav", "Add", "&Next`tPage up", "NextPicture")
   kMenu("PVnav", "Add", "&Last`tEnd", "LastPicture")
   If (thumbsDisplaying!=1)
   {
      Menu, PVnav, Add,
      kMenu("PVnav", "Add", "Previous &frame`tShift+Page Down", "prevDesiredFrame", "gifs")
      kMenu("PVnav", "Add", "Ne&xt frame`tShift+Page Up", "nextDesiredFrame", "gifs")
      If (totalFramesIndex<1)
      {
         kMenu("PVnav", "Disable", "Previous &frame`tShift+Page Down")
         kMenu("PVnav", "Disable", "Ne&xt frame`tShift+Page Up")
      }
   }

   If (markedSelectFile>1 && thumbsDisplaying!=1)
   {
      Menu, PVnav, Add,
      kMenu("PVnav", "Add", "F&irst selected`tCtrl+Home", "jumpToFilesSelBorderFirst")
      kMenu("PVnav", "Add", "Pr&evious selected`tCtrl+Left", "navSelectedFilesPrev")
      kMenu("PVnav", "Add", "Nex&t selected`tCtrl+Right", "navSelectedFilesNext")
      kMenu("PVnav", "Add", "L&ast selected`tCtrl+End", "jumpToFilesSelBorderLast")
   }

   thisFolder := StrReplace(Trimmer(CurrentSLD), "|")
   imgPath := getIDimage(currentFileIndex)
   OutDir := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1))

   Menu, PVnav, Add,
   kMenu("PVnav", "Add", "&Skip to index`tJ", "PanelJump2index", "frames")
   kMenu("PVnav", "Add", "Next &random image`tShift+Bksp", "RandomPicture")
   kMenu("PVnav", "Add", "Pre&vious random image`tBksp", "PrevRandyPicture", "previous")
   If (FolderExist(thisFolder) || FolderExist(OutDir) || FileRexists(imgPath))
   {
      Menu, PVnav, Add,
      kMenu("PVnav", "Add", "Open &omnibox to file location`tShift+;", "invokeOmniBoxCurrentFile")
      kMenu("PVnav", "Add", "Folders e&xplorer menu for active file`tShift+F4", "chainInvokerFoldersListMenu")
      kMenu("PVnav", "Add/UnCheck", "Show folders tree panel`tF4", "PanelFoldersTree")
      If (folderTreeWinOpen=1)
         kMenu("PVnav", "Check", "Show folders tree panel`tF4")
   }

   If !showThese
   {
      kMenu("PVnav", "Add", "&First`tHome", "FirstPicture")
      kMenu("PVnav", "Add", "&Previous`tPage down", "PreviousPicture")
      kMenu("PVnav", "Add", "&Next`tPage up", "NextPicture")
      kMenu("PVnav", "Add", "&Last`tEnd", "LastPicture")
      kMenu("PVnav", "Add", "&Skip to index`tJ", "PanelJump2index", "frames")
      kMenu("PVnav", "Add", "Next &random image`tShift+Bksp", "RandomPicture")
      kMenu("PVnav", "Add", "Pre&vious random image`tBksp", "PrevRandyPicture", "previous")
   }
}

createMenuAlphaMask(givenMenu:="PValpha") {
   isThisWin := (isAlphaMaskWindow()=1 && imgEditPanelOpened=1) ? 1 : 0
   If (alphaMaskingMode>1 && alphaMaskingMode!=5 && isThisWin=1)
   {
      kMenu(givenMenu, "Add", "&Reset gradient center", "BtnResetGradientCenter")
      kMenu(givenMenu, "Add/Uncheck", "&Allow gradient center repositioning", "toggleAlphaGradientCenterReposition")
      If (userAllowsGradientRecentering=1)
         kMenu(givenMenu, "Check", "&Allow gradient center repositioning")
   } 

   If (editingSelectionNow=1 && alphaMaskingMode>1 && AnyWindowOpen!=70)
   {
      kMenu(givenMenu, "Add/Uncheck", "Previe&w the alpha mask`tM", "ViewAlphaMaskNow")
      If (forceLiveAlphaPreviewMode=1 && liveDrawingBrushTool=1)
         kMenu(givenMenu, "Check", "Previe&w the alpha mask`tM")
   } Else
   {
      kMenu(givenMenu, "Add", "Previe&w the alpha mask`tM", "dummy")
      kMenu(givenMenu, "Disable", "Previe&w the alpha mask`tM", "dummy")
   }

   If StrLen(userAlphaMaskBmpPainted)>2
   {
      keyu := isNowAlphaPainting() ? "`tCtrl+Z" : ""
      If (editingSelectionNow=1 && alphaMaskingMode=5 && alphaMaskRefBMP=1 && StrLen(userPrevAlphaMaskBmpPainted)>2)
         kMenu(givenMenu, "Add", "Undo alpha mask" keyu, "performUndoAlphaPainting")

      If isThisWin
      {
         kMenu(givenMenu, "Add/Uncheck", "&Keep painted mask between tools", "toggleKeepAlphMask")
         If (keepUserPaintAlphaMask=1)
            kMenu(givenMenu, "Check", "&Keep painted mask between tools")
      }

      kMenu(givenMenu, "Add", "&Discard the painted alpha mask", "discardUserPaintedAlpha")
      If (liveDrawingBrushTool=1)
      {
         kMenu(givenMenu, "Disable", "&Discard the painted alpha mask")
         kMenu(givenMenu, "Add", "Flip painted mask &horizontally`tShift+H", "FlipHalphaMask")
         kMenu(givenMenu, "Add", "Flip painted mask &vertically`tShift+V", "FlipValphaMask")
      } Else
      {
         If (editingSelectionNow=1 && alphaMaskingMode=5 && alphaMaskRefBMP=1)
            kMenu(givenMenu, "Add", "Resize &bitmap to selection dimensions", "ResizeAlphaMask2sel")
      }
   } Else
   {
      kMenu(givenMenu, "Add", "&Discard the painted alpha mask", "dummy")
      kMenu(givenMenu, "Disable", "&Discard the painted alpha mask")
      kMenu(givenMenu, "Add", "Flip painted mask &horizontally`tShift+H", "dummy")
      kMenu(givenMenu, "Add", "Flip painted mask &vertically`tShift+V", "dummy")
      kMenu(givenMenu, "Add", "Resize &bitmap to selection dimensions", "dummy")
      kMenu(givenMenu, "Disable", "Flip painted mask &horizontally`tShift+H")
      kMenu(givenMenu, "Disable", "Flip painted mask &vertically`tShift+V")
      kMenu(givenMenu, "Disable", "Resize &bitmap to selection dimensions")
   }

   If isThisWin
      kMenu(givenMenu, "Add/Uncheck", "&Paint alpha mask`tCtrl+K", "toggleAlphaPaintingMode")
   Else
      kMenu(givenMenu, "Add", "&Define alpha mask`tM", "PanelSoloAlphaMasker")

   infoMask := defineCurrentAlphaMask()
   kMenu(givenMenu, "Add", "Copy to clipboard", "CopyAlphaMask2clippy")
   If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
      kMenu(givenMenu, "Disable", "Copy to clipboard")

   If (alphaMaskingMode>1)
   {
      keyu := (isThisWin=1 || isAlphaMaskPartialWin()=1) ? "`tN" : ""
      If (liveDrawingBrushTool!=1 && editingSelectionNow=1)
         kMenu(givenMenu, "Add", "Rasteri&ze alpha mask", "RasterizeAlphaMaskNow")
      kMenu(givenMenu, "Add/Uncheck", "&Invert alpha mask" keyu, "toggleInvertAlphaMask")
      If (alphaMaskColorReversed=1)
         kMenu(givenMenu, "Check", "&Invert alpha mask" keyu)
   } Else
   {
      kMenu(givenMenu, "Add", "Rasteri&ze alpha mask", "dummy")
      kMenu(givenMenu, "Disable", "Rasteri&ze alpha mask")
      kMenu(givenMenu, "Add", "&Invert alpha mask", "dummy")
      kMenu(givenMenu, "Disable", "&Invert alpha mask")
   }

   If (liveDrawingBrushTool=1)
   {
      kMenu(givenMenu, "Add", "&Reset brush colors to B/W`tD", "ResetColorsToBW")
      kMenu(givenMenu, "Check", "&Paint alpha mask`tCtrl+K")
      kMenu(givenMenu, "Check", "&Paint alpha mask`tCtrl+K")
   } Else If (editingSelectionNow=1)
      kMenu(givenMenu, "Add", "&Capture selected area as alpha mask", "SetImageAsAlphaMask")
}

createMenuHelpQPV() {
   If (thumbsDisplaying=1 && maxFilesIndex>1)
   {
      kMenu("PVhelp", "Add", "Capture screen shot of QPV", "ScreenCaptureListView", "screenshot")
      Menu, PVhelp, Add,
   }

   kMenu("PVhelp", "Add", "&Search menu options`t;", "PanelQuickSearchMenuOptions", "keyboard")
   kMenu("PVhelp", "Add", "&Keyboard shortcuts`tF1", "HelpWindow", "keyboard shortcuts")
   kMenu("PVhelp", "Add", "Session &events journal`tShift+``", "PanelJournalWindow", "journal history")
   kMenu("PVhelp", "Add", "&Command line options", "MenuCmdLineHelp")
   If (TouchScreenMode=1)
      kMenu("PVhelp", "Add", "&Viewport help map", "MenuDrawViewportHelpMap")

   Menu, PVhelp, Add,
   kMenu("PVhelp", "Add", "C&heck for updates", "checkForUpdatesNow")
   kMenu("PVhelp", "Add", "&About", "AboutWindow", "author")
}

MenuSetShapeTensionP() {
   MenuSetShapeTension(1,1,1)
}

MenuSetShapeTensionS() {
   MenuSetShapeTension(1,2,1)
}

MenuSetShapeTensionC() {
   MenuSetShapeTension(1,3,1)
}

MenuSetShapeTensionR() {
   MenuSetShapeTension(1,4,1)
}

MenuSetShapeTension(a,b,c) {
   FillAreaCurveTension := b
   If (AnyWindowOpen=23)
      GuiControl, SettingsGUIA: Choose, FillAreaCurveTension, % FillAreaCurveTension

   decideCustomShapeStyle()
   RegAction(1, "FillAreaCurveTension")
   SetTimer, dummyRefreshImgSelectionWindow, -150
   ; If (imgEditPanelOpened=1)
   ;    livePreviewsImageEditing()
}

checkForUpdatesNow() {
  Static iniURL := "http://marius.sucan.ro/media/files/blog/ahk-scripts/qpv-version.ini"
  iniTMP := mainCompiledPath "\resources\update-infos.ini"
  BtnCloseWindow()
  showTOOLtip("Checking for updates, please wait")
  newVersion := newDate := 0
  FileDelete, %iniTmp%
  Sleep, 150
  UrlDownloadToFile, %iniURL%, %iniTmp%
  Sleep, 950
  If FileExist(iniTMP)
  {
     FileRead, OutputVar, %iniTmp%
     Loop, Parse, OutputVar, `n,`r
     {
        If InStr(A_LoopField, "version=")
        {
           klop := StrSplit(A_LoopField, "=")
           newVersion := Trimmer(klop[2])
        } Else If InStr(A_LoopField, "ReleaseDate=")
        {
           klop := StrSplit(A_LoopField, "=")
           newDate := Trimmer(klop[2])
        }
        If (A_Index>10)
           Break
     }
  }

  failed := (InStr(newVersion, ".") && InStr(newDate, "/")) ? 0 : 1
  new := (newVersion=appVersion && newDate=vReleaseDate) ? 0 : 1
  If (failed=1)
  {
     msg := "Failed to check for updates... Please click on «Manual check» to open the " appTitle " web site."
     friendly := "Manual check"
  } Else
  {
     msg := "Running version:`n" appVersion " [ " vReleaseDate " ]"
     msg .= "`n`nOnline version:`n" newVersion " [ " newDate " ]"
     msg .= (new=1) ? "`n`nA" : "`n`nNo"
     msg .= " new version seems to be available."
     friendly := (new!=1) ? "Open QPV web page" : "Download latest version"
  }
  RemoveTooltip()
  msgResult := msgBoxWrapper(appTitle ": Check for updates", msg, "&" friendly "|&Cancel", 0, "settings")

  If (InStr(msgResult, "open") || InStr(msgResult, "manual") || InStr(msgResult, "download"))
     OpenGitHub()

  RemoveTooltip()
}

MenuCmdLineHelp() {
   HelpWindow("cmdu")
}

createMenuSoloFile(modus:=0) {
   Try Menu, PVtActFile, Delete
   kMenu("PVtActFile", "Add", "&Open with external app`tO", "OpenThisFileMenu")
   kMenu("PVtActFile", "Add", "Open file in a new &QPV instance", "SoloNewQPVinstance")
   zPlitPath(resultedFilesList[currentFileIndex, 1], 0, OutFileName, OutDir)
   kMenu("PVtActFile", "Add", "Open in QPV the containin&g folder`tAlt+E", "OpenQPVfileFolder")
   kMenu("PVtActFile", "Add", "&Explore containing folder`tCtrl+E", "OpenThisFileFolder")
   If !FolderExist(OutDir)
   {
      kMenu("PVtActFile", "Disable", "Open in QPV the containin&g folder`tAlt+E")
      kMenu("PVtActFile", "Disable", "&Explore containing folder`tCtrl+E")
   }
   If (StrReplace(CurrentSLD, "|")=OutDir)
      kMenu("PVtActFile", "Disable", "Open in QPV the containin&g folder`tAlt+E")

   kMenu("PVtActFile", "Add", "Set containing folder as the &protected folder", "setContaintFolderAsProtected")
   If (mustPreventMenus=1)
   {
      kMenu("PVtActFile", "Add", "Open with default application", "OpenWithDefaultApp")
      kMenu("PVtActFile", "Add", "System «Open with» dialog", "MenuInvokeSHopenWith", "external")
   }

   Menu, PVtActFile, Add
   If (modus!="simple")
   {
      If (thumbsDisplaying=1)
      {
         ; kMenu("PVtActFile", "Add", "&Import into currently loaded image", "importEditGivenImageFile")
         If !EntryMarkedMoveIndex
            kMenu("PVtActFile", "Add", "Mar&k entry to reorder`tX", "moveMarkedEntryNow")
         Else
            kMenu("PVtActFile", "Add", "Move mar&ked entry to focused index`tX", "moveMarkedEntryNow")
      }

      friendly := resultedFilesList[currentFileIndex, 2] ? "De&select" : "&Select"
      If !markedSelectFile
         kMenu("PVfilesActs", "Add", friendly " file`tTab", "MenuMarkThisFileNow")

      kMenu("PVtActFile", "Add", "Remove inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
      kMenu("PVtActFile", "Add", "&Modify index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
      Menu, PVtActFile, Add
   }

   kMenu("PVtActFile", "Add", "&Delete file`tDelete", "DeleteActivePicture")
   kMenu("PVtActFile", "Add", "&Rename file`tShift+F2", "SingularRenameFile")
   If (thumbsDisplaying!=1 && modus!="simple")
      kMenu("PVtActFile", "Add", "&File information`tAlt+Enter", "PanelImageInfos", "show details properties image")
}

chainInvokerFoldersListMenu() {
   Global lastOtherWinClose := 1
   SetTimer, invokeFoldersListerMenu, -60
}

MenuIncVProtation() {
   changeImgRotationInVP(1)
}

MenuDecVProtation() {
   changeImgRotationInVP(-1)
}

MenuResetVProtation() {
   vpIMGrotation := 0
   dummyTimerDelayiedImageDisplay(50)
}

createMenuImgVProtation() {
   kMenu("PVimgVProt", "Add", "&Increase rotation by 15°`t0", "MenuIncVProtation")
   kMenu("PVimgVProt", "Add", "&Decrease rotation by 15°`t9", "MenuDecVProtation")
   If (vpIMGrotation>0)
   {
      kMenu("PVimgVProt", "Add", "&Reset rotation`t\", "MenuResetVProtation")
      Return
   }

   Menu, PVimgVProt, Add
   kMenu("PVimgVProt", "Add", "0°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "23°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "45°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "90°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "135°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "180°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "225°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "270°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", "315°", "MenuSetVProt")
   kMenu("PVimgVProt", "Add", vpIMGrotation "°", "dummy")
   kMenu("PVimgVProt", "Check/Disable", vpIMGrotation "°")
}

createMenuNavBox() {
   infoThumbsList := defineListViewModes()
   infoThumbsMode := (thumbsDisplaying=1) ? "Switch to image view" : "Switch to " infoThumbsList " list view"
   If (thumbsDisplaying=1)
      kMenu("PvImgAdapt", "Add", "C&ycle view modes`tL", "toggleListViewModeThumbs")

   If (maxFilesIndex>0 && !AnyWindowOpen)
      kMenu("PvImgAdapt", "Add", infoThumbsMode "`tEnter/MClick", "MenuDummyToggleThumbsMode")

   If (mustRecordSeenImgs=1 && thumbsDisplaying=1)
   {
      Menu, PvImgAdapt, Add
      kMenu("PvImgAdapt", "Add/Uncheck", "&Highlight already seen images", "ToggleMarkSeenIMGs", "thumbnails")
      If (highlightAlreadySeenImages=1)
         kMenu("PvImgAdapt", "Check", "&Highlight already seen images")
      Menu, PvImgAdapt, Add
   }

   keyword := (folderTreeWinOpen=1) ? " hide" : " display"
   kMenu("PvImgAdapt", "Add/Uncheck", "Show &folders tree panel`tF4", "MenuPanelFoldersTree", "window treeview explore" keyword)
   If (folderTreeWinOpen=1)
      kMenu("PvImgAdapt", "Check", "Show &folders tree panel`tF4")

   keyword := (ShowAdvToolbar=1) ? "hide" : "display"
   kMenu("PvImgAdapt", "Add/Uncheck", "Show &toolbar`tShift+F10", "toggleAppToolbar", keyword)
   If (ShowAdvToolbar=1)
      kMenu("PvImgAdapt", "Check", "Show &toolbar`tShift+F10")

   If (maxFilesIndex>0 && CurrentSLD)
   {
      keyword := (showInfoBoxHUD=1) ? "hide" : "show display"
      kMenu("PvImgAdapt", "Add/Uncheck", "&Show viewport Info-box`tI", "ToggleInfoBoxu", "files information properties " keyword)
      If (showInfoBoxHUD>=1)
         kMenu("PvImgAdapt", "Check", "&Show viewport Info-box`tI")
   }

   kMenu("PvImgAdapt", "Add/Uncheck", "&Show image preview`tZ", "ToggleImgNavBox")
   If (showHUDnavIMG=1)
   {
      kMenu("PvImgAdapt", "Check", "&Show image preview`tZ")
      kMenu("PvImgAdapt", "Add/Uncheck", "&Large preview size", "ToggleImgNavSizeBox")
      If (HUDnavBoxSize>=125)
         kMenu("PvImgAdapt", "Check", "&Large preview size")
   }
}

createMenuImgSizeAdapt(dummy:=0) {
   keyu := (drawingShapeNow=1) ? "" : "`tT"
   kMenu("PvImgAdapt", "Add", "C&ycle adapt to window modes" keyu, "ToggleImageSizingMode")
   Menu, PvImgAdapt, Add
   kMenu("PvImgAdapt", "Add/Uncheck", "&Adapt all to fit window`t/", "MenuSetImageAdaptAll")
   kMenu("PvImgAdapt", "Add/Uncheck", "Adapt only &large images", "MenuSetImageAdaptLarge")
   kMenu("PvImgAdapt", "Add/Uncheck", "Custom &zoom level (" Round(zoomLevel*100) "%)", "MenuSetImageCustomZoom")
   kMenu("PvImgAdapt", "Add/Uncheck", "Stretched to &window", "MenuSetImageStretchedWin")
   If (IMGresizingMode=5)
      kMenu("PvImgAdapt", "Check", "Stretched to &window")

   If (drawingShapeNow=1 || imgEditPanelOpened=1)
      kMenu("PvImgAdapt", "Disable", "Stretched to &window")

   kMenu("PvImgAdapt", "Add/Uncheck", "&Adapt to window width`tNUM *", "toggleCustomZLadaptW")
   kMenu("PvImgAdapt", "Add/Uncheck", "&Adapt to window height`tNUM *", "toggleCustomZLadaptH")
   If (customZoomAdaptMode=1 && IMGresizingMode=4)
      kMenu("PvImgAdapt", "Check", "&Adapt to window width`tNUM *")
   Else If (customZoomAdaptMode=2 && IMGresizingMode=4)
      kMenu("PvImgAdapt", "Check", "&Adapt to window height`tNUM *")

   If (IMGresizingMode=1)
      kMenu("PvImgAdapt", "Check", "&Adapt all to fit window`t/")
   Else If (IMGresizingMode=2)
      kMenu("PvImgAdapt", "Check", "Adapt only &large images")
   Else If (IMGresizingMode=4 && customZoomAdaptMode=0)
      kMenu("PvImgAdapt", "Check", "Custom &zoom level (" Round(zoomLevel*100) "%)")

   If (mustPreventMenus!=1)
   {
      Menu, PvImgAdapt, Add
      If (dummy!="bonus")
      {
         kMenu("PvImgAdapt", "Add", "6%", "MenuSetImgZoom")
         kMenu("PvImgAdapt", "Add", "12%", "MenuSetImgZoom")
         kMenu("PvImgAdapt", "Add", "25%", "MenuSetImgZoom")
      }
      kMenu("PvImgAdapt", "Add", "50%", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "100% (original size)`tNUM *", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "200%", "MenuSetImgZoom")
      If (dummy!="bonus")
      {
         kMenu("PvImgAdapt", "Add", "400%", "MenuSetImgZoom")
         kMenu("PvImgAdapt", "Add", "800%", "MenuSetImgZoom")
      }
      Menu, PvImgAdapt, Add
   }

   kMenu("PvImgAdapt", "Add/Uncheck", "&High quality image resampling", "ToggleImgQuality", "settings performance")
   If (userimgQuality=1)
      kMenu("PvImgAdapt", "Check", "&High quality image resampling")

   If (IMGresizingMode=4 && drawingShapeNow=0)
   {
      kMenu("PvImgAdapt", "Add/Uncheck", "&Keep zoom level between images", "toggleLockZoom")
      If (lockZoomLevel=1 && customZoomAdaptMode=0)
         kMenu("PvImgAdapt", "Check", "&Keep zoom level between images")
   }

   If (dummy="bonus")
   {
      Menu, PvImgAdapt, Add
      kMenu("PvImgAdapt", "Add/Uncheck", "&Show image navigator`tZ", "ToggleImgNavBox")
      If (showHUDnavIMG=1)
      {
         kMenu("PvImgAdapt", "Check", "&Show image navigator`tZ")
         kMenu("PvImgAdapt", "Add/Uncheck", "&Large navigator size", "ToggleImgNavSizeBox")
         If (HUDnavBoxSize>=125)
            kMenu("PvImgAdapt", "Check", "&Large navigator size")
      }

      If (drawingShapeNow=0 && mustCaptureCloneBrush=0)
      {
         If (InStr(currIMGdetails.PixelFormat, "TONE-MAPPED") && !AnyWindowOpen)
            kMenu("PVview", "Add", "Adjust &HDR tone-mapping", "PanelAdjustToneMapping", "colors dynamic")

         If !AnyWindowOpen
            kMenu("PVview", "Add", "Viewport and color adjustments panel`tU", "PanelColorsAdjusterWindow")

         kMenu("PVview", "Add", "Reset vie&wport adjustments`t\", "ResetImageView", "image")
         kMenu("PVview", "Add/Uncheck", "Centered &alignment`tA", "ToggleIMGalign", "viewport image position")
         If (imageAligned=5)
            kMenu("PVview", "Check", "Centered &alignment`tA")

         If (thumbsDisplaying!=1)
         {
            kMenu("PVview", "Add/Uncheck", "Allo&w outside viewport image panning", "toggleFreePanning")
            If (allowFreeIMGpanning=1)
               kMenu("PVview", "Check", "Allo&w outside viewport image panning")
         }

         If (thumbsDisplaying!=1 && (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen!=24 && AnyWindowOpen!=31))
            kMenu("PVview", "Add", "Configure viewport &grid", "PanelConfigVPgrid")

         kMenu("PVview", "Add/Uncheck", "Show viewport &grid", "toggleViewPortGridu", keyword)
         If (showViewPortGrid=1)
            kMenu("PVview", "Check", "Show viewport &grid")

         kMenu("PVview", "Add", "C&ycle histogram modes`tShift+G", "ToggleImgHistogram")
         kMenu("PVview", "Add", "C&ycle simulate color depths`tQ", "ToggleImgColorDepth")
         kMenu("PVview", "Add", "C&ycle colors display modes`tF", "ToggleImgFX")

         infoThumbsList := defineListViewModes()
         infoThumbsMode := (thumbsDisplaying=1) ? "Switch to image view" : "Switch to " infoThumbsList " list view"
         If (maxFilesIndex>0 && !AnyWindowOpen)
            kMenu("PVview", "Add", infoThumbsMode "`tEnter/MClick", "MenuDummyToggleThumbsMode")

         If (maxFilesIndex>1 && !AnyWindowOpen && prevOpenedWindow[2])
            kMenu("PVview", "Add", "Open pre&vious panel`tF8", "openPreviousPanel", "show")

         keyword := (ShowAdvToolbar=1) ? "hide" : "display"
         kMenu("PVview", "Add/Uncheck", "Show &toolbar`tShift+F10", "toggleAppToolbar", keyword)
         If (ShowAdvToolbar=1)
            kMenu("PVview", "Check", "Show &toolbar`tShift+F10")

         If (maxFilesIndex>0 && CurrentSLD)
         {
            keyword := (showInfoBoxHUD=1) ? "hide" : "show display"
            kMenu("PVview", "Add/Uncheck", "&Show viewport Info-box`tI", "ToggleInfoBoxu", "files information properties " keyword)
            If (showInfoBoxHUD>=1)
               kMenu("PVview", "Check", "&Show viewport Info-box`tI")
         }
         kMenu("PvImgAdapt", "Add", "&More options", ":PVview")
      } Else
      {
         kMenu("PvImgAdapt", "Add/Uncheck", "Centered &alignment`tA", "ToggleIMGalign", "viewport image position")
         If (imageAligned=5)
            kMenu("PvImgAdapt", "Check", "Centered &alignment`tA")

         If (thumbsDisplaying!=1)
         {
            kMenu("PvImgAdapt", "Add/Uncheck", "Allo&w outside viewport image panning", "toggleFreePanning")
            If (allowFreeIMGpanning=1)
               kMenu("PvImgAdapt", "Check", "Allo&w outside viewport image panning")
         }
      }
   }
}

createMenuMainPreferences() {
   kMenu("PVperfs", "Add/Uncheck", "&Limit memory usage", "ToggleLimitMemUsage")
   kMenu("PVperfs", "Add/Uncheck", "&Do not record undo levels", "TogglePreventUndos", "history")
   If (preventUndoLevels=1)
      kMenu("PVperfs", "Check", "&Do not record undo levels")
   kMenu("PVperfs", "Add/Uncheck", "&Multi-threaded processing", "PanelSetSystemCores")
   If (minimizeMemUsage=1)
      kMenu("PVperfs", "Disable", "&Multi-threaded processing")

   If (A_PtrSize=4)
   {
      kMenu("PVperfs", "Disable", "&Multi-threaded processing")
      kMenu("PVperfs", "Disable", "&Limit memory usage")
      kMenu("PVperfs", "Check", "&Limit memory usage")
   }

   kMenu("PVperfs", "Add/Uncheck", "&High quality image resampling", "ToggleImgQuality")
   If (thumbsDisplaying!=1)
   {
      kMenu("PVperfs", "Add/Uncheck", "&Downscale images to viewport dimensions", "ToggleImgDownScaling")
      If (AutoDownScaleIMGs=1)
         kMenu("PVperfs", "Check", "&Downscale images to viewport dimensions")
   }
   kMenu("PVperfs", "Add/Uncheck", "&Perform dithering on color depth changes", "ToggleImgColorDepthDithering")
   kMenu("PVperfs", "Add/Uncheck", "&Apply gamma correction", "toggleImgEditGammaCorrect")
   kMenu("PVperfs", "Add/Uncheck", "&Load Camera RAW files at high quality", "ToggleRAWquality")
   If (userimgGammaCorrect=1)
      kMenu("PVperfs", "Check", "&Apply gamma correction")
   If (minimizeMemUsage=1)
      kMenu("PVperfs", "Check", "&Limit memory usage")
   If (allowMultiCoreMode=1)
      kMenu("PVperfs", "Check", "&Multi-threaded processing")
   If (ColorDepthDithering=1)
      kMenu("PVperfs", "Check", "&Perform dithering on color depth changes")
   If (userimgQuality=1)
      kMenu("PVperfs", "Check", "&High quality image resampling")
   If (userHQraw=1)
      kMenu("PVperfs", "Check", "&Load Camera RAW files at high quality")

   kMenu("PVprefs", "Add", "Save settings into a .SLD file", "WritePrefsIntoSLD")
   kMenu("PVprefs", "Add/Uncheck", "&Never load settings from a .SLD", "ToggleIgnoreSLDprefs")
   kMenu("PVprefs", "Add", "Associate QPV with image formats", "PanelAssociateQPV", "system")
   If !A_IsAdmin
      kMenu("PVprefs", "Add", "Run in admin mode", "RunAdminMode")

   Menu, PVprefs, Add, 
   kMenu("PVprefs", "Add/Uncheck", "Load an&y image format using FreeImage", "ToggleAlwaysFIMus")
   kMenu("PVprefs", "Add", "Performance options", ":PVperfs")
   Menu, PVprefs, Add, 
   If (thumbsDisplaying!=1)
   {
      kMenu("PVprefs", "Add/Uncheck", "Auto-play an&imated GIFs", "ToggleAnimGIFsupport")
      If (animGIFsSupport=1)
         kMenu("PVprefs", "Check", "Auto-play an&imated GIFs")
      If (alwaysOpenwithFIM=1)
         kMenu("PVprefs", "Disable", "Auto-play an&imated GIFs")
   }

   kMenu("PVprefs", "Add", "&Quick file actions", "PanelQuickMoveConfigure", "index list")
   kMenu("PVprefs", "Add/Uncheck", "&Record seen images", "ToggleRecordSeenImages", "history")
   If (mustRecordSeenImgs=1)
      kMenu("PVprefs", "Check", "&Record seen images")

   kMenu("PVprefs", "Add/Uncheck", "&Prompt before file delete", "TogglePromptDelete")
   If (askDeleteFiles=1)
      kMenu("PVprefs", "Check", "&Prompt before file delete")
   If (MustLoadSLDprefs=0)
      kMenu("PVprefs", "Check", "&Never load settings from a .SLD")

   Menu, PVprefs, Add, 
   If (mustRecordSeenImgs=1)
   {
      kMenu("PVprefs", "Add", "Seen images database options", "PanelSeenIMGsOptions")
   }

   If FolderExist(thumbsCacheFolder)
      kMenu("PVprefs", "Add", "Erase cached thumbnails", "PanelfolderThanEraseThumbsCache")

   kMenu("PVprefs", "Add/Uncheck", "Cache generated thumbnails", "ToggleThumbsCaching")
   If (alwaysOpenwithFIM=1)
      kMenu("PVprefs", "Check", "Load an&y image format using FreeImage")

   If (enableThumbsCaching=1)
   {
      If (thumbsDisplaying=1)
         kMenu("PVprefs", "Add", "Generate all thumbnails no&w", "generateAllThumbsNow")

      kMenu("PVprefs", "Check", "Cache generated thumbnails")
   }
}

createMenuMainView() {
   If (thumbsDisplaying=1)
   {
      kMenu("PVview", "Add", "C&ycle view modes`tL", "toggleListViewModeThumbs")
      kMenu("PVview", "Add", defineListViewModes(), "dummy")
      kMenu("PVview", "Disable", defineListViewModes())

      Menu, PVview, Add
      kMenu("PVview", "Add/Uncheck", "&Two lines status bar", "ToggleMultiLineStatus", "statusbar info")
      If (multilineStatusBar=1)
         kMenu("PVview", "Check", "&Two lines status bar")

      kMenu("PVview", "Add/Uncheck", "Private mode UI", "TogglePrivateMode")
      If (userPrivateMode=1)
         kMenu("PVview", "Check", "Private mode UI")

      If (testIsDupesList()=1)
      {
         kMenu("PVview", "Add/Uncheck", "&Fade the other dupe groups", "ToggleTDupesGroupsFading")
         If (fadeOtherDupeGroups=1)
            kMenu("PVview", "Check", "&Fade the other dupe groups")
      }

      If (mustRecordSeenImgs=1)
      {
         kMenu("PVview", "Add/Uncheck", "&Highlight seen images", "ToggleMarkSeenIMGs", "thumbnails")
         If (highlightAlreadySeenImages=1)
            kMenu("PVview", "Check", "&Highlight seen images")
      }

      If (thumbsListViewMode=1)
      {
         infoThumbZoom := thumbsColumns " | " thumbsW "x" thumbsH " px" ; " (" Round(thumbsZoomLevel*100) "%)"
         kMenu("PVview", "Add", "&Cycle aspect ratios`tT", "ToggleThumbsAratio")
         Try kMenu("PVview", "Add", defineThumbsAratio(), "ToggleThumbsAratio")
         Try kMenu("PVview", "Disable", defineThumbsAratio())
         Menu, PVview, Add
         kMenu("PVview", "Add", "&Set columns and other options`tU", "PanelSetThumbColumnOptions")
         ; kMenu("PVview", "Disable", "Thumbnails columns and size:")
         kMenu("PVview", "Add", infoThumbZoom, "ToggleThumbsAratio")
         kMenu("PVview", "Disable", infoThumbZoom)
      }
   } Else
   {
      createMenuImgSizeAdapt()
      If !AnyWindowOpen
         createMenuImgVProtation()

      If (InStr(currIMGdetails.PixelFormat, "TONE-MAPPED") && !AnyWindowOpen)
         kMenu("PVview", "Add", "Adjust &HDR tone-mapping", "PanelAdjustToneMapping", "colors dynamic")

      If !AnyWindowOpen
         kMenu("PVview", "Add", "Viewport and color adjustments panel`tU", "PanelColorsAdjusterWindow")

      ; createMenuVPhudHisto()
      ; kMenu("PVview", "Add", "Show histogram", ":PVimgHistos")
      friendlyPix := (coreDesiredPixFmt="0x21808") ? "24-RGB" : "32-RGBA"
      Menu, PVview, Add
      If (A_PtrSize=4)
         kMenu("PVview", "Add", "Pi&xel format mode: " friendlyPix, "ToggleCorePixFmt")

      If !AnyWindowOpen
         kMenu("PVview", "Add", "&Rotation ("vpIMGrotation "°)", ":PVimgVProt")
      kMenu("PVview", "Add", "&Zoom and adapt modes", ":PvImgAdapt")
   }

   If (thumbsListViewMode=1 || thumbsDisplaying!=1)
   {
      createMenuColorDepth()
      dontShow := (thumbsDisplaying=1 && minimizeMemUsage=1) ? 1 : 0
      Menu, PVview, Add
      kMenu("PVview", "Add", "Simulated color &depth", ":PVimgSdepth")
      If (dontShow!=1)
      {
         createMenuImgColorsFX()
         kMenu("PVview", "Add", "Colors F&X and display modes", ":PVimgColorsFX")
      }

      Menu, PVview, Add
      kMenu("PVview", "Add/Uncheck", "Centered &alignment`tA", "ToggleIMGalign", "viewport image position")
      If (imageAligned=5)
         kMenu("PVview", "Check", "Centered &alignment`tA")

      kMenu("PVview", "Add/Uncheck", "Mirror &vertically`tV", "VPflipImgV", "viewport flip image")
      If (FlipImgV=1)
         kMenu("PVview", "Check", "Mirror &vertically`tV")
   }

   kMenu("PVview", "Add/Uncheck", "Mirror &horizontally`tH", "VPflipImgH", "viewport flip image")
   If (FlipImgH=1)
      kMenu("PVview", "Check", "Mirror &horizontally`tH")

   Menu, PVview, Add
   If (thumbsDisplaying!=1)
   {
      kMenu("PVview", "Add/Uncheck", "Allo&w outside viewport image panning", "toggleFreePanning")
      If (allowFreeIMGpanning=1)
         kMenu("PVview", "Check", "Allo&w outside viewport image panning")
   }

   If (thumbsDisplaying!=1 || thumbsListViewMode=1)
      kMenu("PVview", "Add", "Reset vie&wport adjustments`t\", "ResetImageView", "image")

   If (mustPreventMenus=1 && thumbsDisplaying!=1)
   {
      keyword := (showViewPortGrid=1) ? "hide" : "display"
      kMenu("PVview", "Add", "Increase viewport grid size`tAlt+[+]", "MenuIncVPgridSize")
      kMenu("PVview", "Add", "Decrease viewport grid size`tAlt+[-]", "MenuDecVPgridSize")
   }
 
   If (thumbsDisplaying!=1)
   {
      kMenu("PVview", "Add/Uncheck", "Show viewport &grid", "toggleViewPortGridu", keyword)
      If (showViewPortGrid=1)
         kMenu("PVview", "Check", "Show viewport &grid")
   
      If ((imgEditPanelOpened=1 || mustPreventMenus=1) && showViewPortGrid=1)
      {
         kMenu("PVview", "Add/Uncheck", "Fi&xed grid size", "toggleGridFixedSize")
         If (vpGridFixedSize=1)
            kMenu("PVview", "Check", "Fi&xed grid size")
      }

      If (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen!=24 && AnyWindowOpen!=31)
         kMenu("PVview", "Add", "Configure viewport &grid", "PanelConfigVPgrid")

      If !AnyWindowOpen
      {
         Menu, PVview, Add
         kMenu("PVview", "Add/Uncheck", "Reset adjustments on image change", "ToggleAutoResetImageView")
         If (resetImageViewOnChange=1)
            kMenu("PVview", "Check", "Reset adjustments on image change")
      }
   } Else
   {
      Menu, PVview, Add
      friendly := (markedSelectFile>1) ? "Refresh selected thumbnails on scroll" : "Refresh all thumbnails on scroll"
      If (thumbsDisplaying=1 && thumbsListViewMode=1)
      {
         kMenu("PVview", "Add", friendly "`tAlt+F5", "DeepRefreshThumbsNow")
         If (enableThumbsCaching=1)
            kMenu("PVview", "Add", "Generate all thumbnails no&w", "generateAllThumbsNow")
      }
   }
}

createMenuCopyFile(mena) {
   kMenu(mena, "Add", "Copy folder path(s) as text", "CopyImageFolderPaths", "text clipboard")
   kMenu(mena, "Add", "Cop&y file name(s) as text", "CopyImageFileNames", "clipboard")
   kMenu(mena, "Add", "&Copy complete path(s) as text`tShift+C", "CopyImagePath", "clipboard")

   Menu, % mena, Add
   infoKbd := (thumbsDisplaying=1) ? "`tCtrl+C" : ""
   kMenu(mena, "Add", "Copy file(s) (for E&xplorer)" infoKbd, "MenuExplorerCopyFiles", "clipboard")
   infoKbd := (thumbsDisplaying=1) ? "`tCtrl+X" : ""
   kMenu(mena, "Add", "C&ut file(s) (for Explorer)" infoKbd, "MenuExplorerCutFiles", "clipboard")
   kMenu(mena, "Add", "Copy con&taining folder(s) (for Explorer)", "MenuExplorerCopyContainFolder", "clipboard")
   kMenu(mena, "Add", "Cut containin&g folder(s) (for Explorer)", "MenuExplorerCutContainFolder", "clipboard")
}

createMenuOpenFileOptions(modus:=0) {
   If !markedSelectFile
      kMenu("PVtFileOpen", "Add", "&Open with external app`tO", "OpenThisFileMenu")

   If markedSelectFile
      kMenu("PVtFileOpen", "Add", "Open files in new &QPV instances`tCtrl+Enter", "OpenWithNewQPVinstance")
   Else
      kMenu("PVtFileOpen", "Add", "Open file in a new &QPV instance`tCtrl+Enter", "SoloNewQPVinstance")

   zPlitPath(resultedFilesList[currentFileIndex, 1], 0, OutFileName, OutDir)
   kMenu("PVtFileOpen", "Add", "&Open in QPV the containing folder`tAlt+E", "OpenQPVfileFolder")
   If (StrReplace(CurrentSLD, "|")=OutDir)
      kMenu("PVtFileOpen", "Disable", "&Open in QPV the containing folder`tAlt+E")

   If !markedSelectFile
   {
      kMenu("PVtFileOpen", "Add", "&Open containing folder in Explorer`tCtrl+E", "OpenThisFileFolder", "external")
      If (modus!="simple")
         kMenu("PVtFileOpen", "Add", "&Containing folder properties (Explorer)", "OpenThisFilePropFolder", "external")
   }

   If (thumbsDisplaying=1 && !markedSelectFile && modus!="simple")
      kMenu("PVtFileOpen", "Add", "&Import into currently loaded image", "importEditGivenImageFile")
}

createMenuImageFileActions(whichMenu) {
   imgPath := getIDimage(currentFileIndex)
   kMenu(whichMenu, "Add", "&JPEG lossless operations`tShift+J", "PanelJpegPerformOperation")
   If !RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$")
      kMenu(whichMenu, "Disable", "&JPEG lossless operations`tShift+J")

   keyu := (thumbsDisplaying=1) ? "`tCtrl+R" : ""
   kMenu(whichMenu, "Add", "Resi&ze/rotate/crop image(s)" keyu, "PanelSimpleResizeRotate", "process advanced")
   If markedSelectFile
      kMenu(whichMenu, "Add", "&Auto-crop image(s)`tAlt+Y", "PanelImgAutoCrop")

   If (thumbsDisplaying=1 || markedSelectFile)
   {
      infoKbd := (thumbsDisplaying=1) ? "`tShift+U" : ""
      kMenu(whichMenu, "Add", "Apply vie&wport color adjustments" infoKbd, "filesListApplyColors", "image")
      infoKbd := (thumbsDisplaying=1) ? "`tShift+H" : ""
      kMenu(whichMenu, "Add", "Flip image horizontally" infoKbd, "filesListFlipHimage")
      infoKbd := (thumbsDisplaying=1) ? "`tShift+V" : ""
      kMenu(whichMenu, "Add", "Flip image vertically" infoKbd, "filesListFlipVimage")
      infoKbd := (thumbsDisplaying=1) ? "`tShift+0" : ""
      kMenu(whichMenu, "Add", "Rotate image by 90°" infoKbd, "filesListFlipRotatePlus")
      infoKbd := (thumbsDisplaying=1) ? "`tShift+9" : ""
      kMenu(whichMenu, "Add", "Rotate image by -90°" infoKbd, "filesListFlipRotateMinus")
   }
}

createMenuCurrentFilesActs(dummy:=0) {
   If (dummy="rclick" && markedSelectFile>0)
   {
      createMenuSoloFile()
      kMenu("PVfilesActs", "Add", "Active / focused file", ":PVtActFile")
      Menu, PVfilesActs, Add
   }

   Try Menu, PVcopy, Delete
   createMenuCopyFile("PVcopy")
   kMenu("PVfilesActs", "Add", "&Copy", ":PVcopy")

   Menu, PVfilesActs, Add, 
   If !markedSelectFile
   {
      createMenuOpenFileOptions()
      kMenu("PVfilesActs", "Add", "&Open...", ":PVtFileOpen")
      If (dummy!="rclick")
         kMenu("PVfilesActs", "Add", "Set as &wallpaper", "setImageWallpaper", "desktop image")
   } Else
      kMenu("PVtFileOpen", "Add", "Open files in new &QPV instances`tCtrl+Enter", "OpenWithNewQPVinstance")

   Menu, PVfilesActs, Add, 
   kMenu("PVfilesActs", "Add", "Con&vert file format(s) to...`tCtrl+K", "PanelFileFormatConverter", "image conversion")

   createMenuImageFileActions("PVtFileImgAct")
   kMenu("PVfilesActs", "Add", "Modify image(s)", ":PVtFileImgAct")
   Menu, PVfilesActs, Add, 
   If markedSelectFile
      kMenu("PVfilesActs", "Add", "Remove file inde&x entries`tDelete", "InListMultiEntriesRemover", "erase")

   kMenu("PVfilesActs", "Add", "&Delete file(s)`tDelete", "DeletePicture", "erase")
   kMenu("PVfilesActs", "Add", "&Rename file(s)`tF2", "PanelRenameThisFile")
   kMenu("PVfilesActs", "Add", "&Move file(s) to...`tM", "PanelMoveCopyFiles")
   kMenu("PVfilesActs", "Add", "&Copy file(s) to...`tC", "InvokeCopyFiles")
   Menu, PVfilesActs, Add,
   If markedSelectFile
   {
      kMenu("PVfilesActs", "Add", "Re&group dispersed files", "regroupSelectedFiles")
      kMenu("PVfilesActs", "Add", "&Calculate total files size`tAlt+L", "CalculateSelectedFilesSizes", "file details")
      kMenu("PVfilesActs", "Add", "Revie&w selected files`tR", "PanelReviewSelectedFiles")
   } Else kMenu("PVfilesActs", "Add", "&File information`tAlt+Enter", "PanelImageInfos", "properties image details")

   If !markedSelectFile
   {
      friendly := resultedFilesList[currentFileIndex, 2] ? "De&select" : "&Select"
      kMenu("PVfilesActs", "Add", friendly " file`tTab", "MenuMarkThisFileNow")
      If (dummy="rclick")
      {
         friendly := resultedFilesList[currentFileIndex, 5] ? "Remove from" : "Add to"
         kMenu("PVfilesActs", "Add", friendly " f&avourites list`tB", "ToggleImgFavourites")
         kMenu("PVfilesActs", "Add", "Remove inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
         kMenu("PVfilesActs", "Add", "&Modify index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
         ; kMenu("PVfilesActs", "Add", "&Import into currently loaded image", "importEditGivenImageFile")
      }
   }

   If (mustRecordSeenImgs=1 && thumbsDisplaying=1)
      kMenu("PVfilesActs", "Add", "&Toggle Image(s) Seen status`tShift+S", "ToggleSeenIMGstatus")
}

createMenuFilesSort() {
   kMenu("PVsort", "Add", "File details", "dummy")
   kMenu("PVsort", "Disable", "File details")
   kMenu("PVsort", "Add", "&Path and name`tCtrl+1", "ActSortName")
   kMenu("PVsort", "Add", "&Folder path`tCtrl+2", "ActSortPath")
   kMenu("PVsort", "Add", "&File name`tCtrl+3", "ActSortFileName")
   kMenu("PVsort", "Add", "File si&ze`tCtrl+4", "ActSortSize")
   kMenu("PVsort", "Add", "&Modified date`tCtrl+5", "ActSortModified")
   kMenu("PVsort", "Add", "&Created date`tCtrl+6", "ActSortCreated")
   If testIsDupesList()
   {
      Menu, PVsort, Add
      kMenu("PVsort", "Add", "&Duplicates ID group", "ActSortDupeGroups")
   }

   Menu, PVsort, Add
   kMenu("PVsort", "Add/Uncheck", "&Reversed order on sort", "TglRvrSort")
   If (reverseOrderOnSort=1)
      kMenu("PVsort", "Check", "&Reversed order on sort")

   kMenu("PVsort", "Add/Uncheck", "&Remove inexistent files on sort", "TglCheckDeadFilesSort")
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      kMenu("PVsort", "Disable", "&Remove inexistent files on sort")
   Else If (OnSortdoFilesCheck=1)
      kMenu("PVsort", "Check", "&Remove inexistent files on sort")

   If (SLDtypeLoaded=3)
   {
      kMenu("PVsort", "Add", "&Purge cached data", "PanelPurgeCachedSQLdata")
      kMenu("PVsort", "Add/Uncheck", "&Use cached data", "TglUseCacheSLDinfo")
      If (useCachedSLDdata=1)
         kMenu("PVsort", "Check", "&Use cached data")

      defaultSort := defineSQLdbSort()
      StringUpper, defaultSort, defaultSort
      Menu, PVsort, Add
      kMenu("PVsort", "Add", "Default sorting:", "ToggleDBdefaultSQLsort")
      kMenu("PVsort", "Add", "[" defaultSort "]", "ToggleDBdefaultSQLsort")
      kMenu("PVsort", "Disable", "[" defaultSort "]")
   }

   Menu, PVsort, Add
   kMenu("PVsort", "Add", "Image information", "dummy")
   kMenu("PVsort", "Disable", "Image information")
   kMenu("PVsort", "Add", "&Resolution`tCtrl+7", "PanelResolutionSorting")
   kMenu("PVsort", "Add", "&Histogram data points`tCtrl+8", "PanelHistogramSorting")
   If (mustPreventMenus=1)
   {
      kMenu("PVsort", "Add", "Resolution (MPx)", "MenuSortImageResolutionMGPX")
      kMenu("PVsort", "Add", "Image width", "MenuSortImageWdithRes")
      kMenu("PVsort", "Add", "Image height", "MenuSortImageHeightRes")
      kMenu("PVsort", "Add", "Aspect ratio (W/H)", "MenuSortImageAspectRatioRes")
      kMenu("PVsort", "Add", "Image DPI", "MenuSortImageDPIres")
      kMenu("PVsort", "Add", "Pages / frames", "MenuSortImageFrameRes")
      kMenu("PVsort", "Add", "Histogram average", "MenuActSortHisto1")
      kMenu("PVsort", "Add", "Histogram median", "MenuActSortHisto2")
      kMenu("PVsort", "Add", "Histogram peak range", "MenuActSortHisto3")
      kMenu("PVsort", "Add", "Histogram minimum range", "MenuActSortHisto4")
      kMenu("PVsort", "Add", "Histogram range", "MenuActSortHisto5")
      kMenu("PVsort", "Add", "Histogram mode", "MenuActSortHisto6")
      kMenu("PVsort", "Add", "Histogram minimum", "MenuActSortHisto7")
      kMenu("PVsort", "Add", "Histogram root-mean square", "MenuActSortHisto8")
   }

   Menu, PVsort, Add, 
   kMenu("PVsort", "Add", "R&everse list`tCtrl+0", "ReverseListNow", "files")
   kMenu("PVsort", "Add", "R&andomize list", "RandomizeListNow", "files")
}

MenuSortImageResolutionMGPX() {
   ActSortImageProperties(1)
}

MenuSortImageWdithRes() {
   ActSortImageProperties(2)
}

MenuSortImageHeightRes() {
   ActSortImageProperties(3)
}

MenuSortImageAspectRatioRes() {
   ActSortImageProperties(4)
}

MenuSortImageDPIres() {
   ActSortImageProperties(5)
}

MenuSortImageFrameRes() {
   ActSortImageProperties(6)
}

MenuActSortHisto1() {
   ActSortHistogram(1)
}

MenuActSortHisto2() {
   ActSortHistogram(2)
}

MenuActSortHisto3() {
   ActSortHistogram(3)
}

MenuActSortHisto4() {
   ActSortHistogram(4)
}

MenuActSortHisto5() {
   ActSortHistogram(5)
}

MenuActSortHisto6() {
   ActSortHistogram(6)
}

MenuActSortHisto7() {
   ActSortHistogram(7)
}

MenuActSortHisto8() {
   ActSortHistogram(8)
}

createMenuSlideshows() {
   sliSpeed := Round(slideShowDelay/1000, 2) " sec."
   kMenu("PVslide", "Add", "&Start slideshow`tSpace", "dummyInfoToggleSlideShowu", "play")
   kMenu("PVslide", "Add/Uncheck", "Smoot&h transitions", "ToggleSlidesTransitions", "fade")
   kMenu("PVslide", "Add/Uncheck", "&Easy to stop slideshows", "ToggleEasySlideStop")
   kMenu("PVslide", "Add/Uncheck", "&Randomize colour effects", "ToggleSlidesFXmode", "slideshow")
   kMenu("PVslide", "Add/Uncheck", "&Wait for GIFs to play once", "ToggleGIFsPlayEntirely", "animations")
   If (animGIFsSupport!=1 || alwaysOpenwithFIM=1)
      kMenu("PVslide", "Disable", "&Wait for GIFs to play once")
   If (slidesFXrandomize=1)
      kMenu("PVslide", "Check", "&Randomize colour effects")

   kMenu("PVslide", "Add/Uncheck", "S&kip already seen images", "ToggleSkipSeenIMGs")
   If (mustRecordSeenImgs!=1)
      kMenu("PVslide", "Disable", "S&kip already seen images")
   Else If (skipSeenImageSlides=1)
      kMenu("PVslide", "Check", "S&kip already seen images")
   Menu, PVslide, Add, 
   kMenu("PVslide", "Add", "De&fine slideshow duration`tShift+/", "PanelDefineEntireSlideshowLength")
   kMenu("PVslide", "Add", EstimateSlideShowLength(1), "dummy")
   kMenu("PVslide", "Disable", EstimateSlideShowLength(1))
   Menu, PVslide, Add,
   kMenu("PVslide", "Add", "C&ycle slideshow directions`tS", "ToggleSlideshowModes")
   kMenu("PVslide", "Add", DefineSlideShowType(), "dummy")
   kMenu("PVslide", "Disable", DefineSlideShowType())
   Menu, PVslide, Add,
   thisMusic := StrLen(SlidesMusicSong)>3 ? PathCompact(SlidesMusicSong, 30) : "NONE"
   kMenu("PVslide", "Add/Uncheck", "Auto&matically play music", "ToggleAutoPlaySlidesMusic")
   kMenu("PVslide", "Add", "Set back&ground music", "PanelSetSlidesMusic")
   kMenu("PVslide", "Add", thisMusic, "dummy")
   kMenu("PVslide", "Disable", thisMusic)
   If (autoPlaySlidesAudio=1)
      kMenu("PVslide", "Check", "Auto&matically play music")
   Menu, PVslide, Add,
   kMenu("PVslide", "Add", "&Increase speed`tDot [ . ]", "IncreaseSlideSpeed")
   kMenu("PVslide", "Add", "&Decrease speed`tComma [ , ]", "DecreaseSlideSpeed")
   kMenu("PVslide", "Add", "Current speed: " sliSpeed, "dummy")
   kMenu("PVslide", "Disable", "Current speed: " sliSpeed)
   If (allowGIFsPlayEntirely=1)
      kMenu("PVslide", "Check", "&Wait for GIFs to play once")
   If (doSlidesTransitions=1)
      kMenu("PVslide", "Check", "Smoot&h transitions")
   If (minimizeMemUsage=1)
      kMenu("PVslide", "Disable", "Smoot&h transitions")
   If (easySlideStoppage=1)
      kMenu("PVslide", "Check", "&Easy to stop slideshows")
}

createMenuAnnotations() {
   kMenu("PVsounds", "Add", "&Edit image captions`tShift+N", "PanelEditImgCaption", "modify")
   keywords := (showImgAnnotations=1) ? "hide viewport" : "display viewport"
   kMenu("PVsounds", "Add/Uncheck", "&Show image captions`tN", "ToggleImgCaptions", keywords)
   If (showImgAnnotations=1)
      kMenu("PVsounds", "Check", "&Show image captions`tN")
   Menu, PVsounds, Add, 
   If (SLDtypeLoaded=3)
      kMenu("PVsounds", "Add", "&Choose audio file", "PanelBrowseAudioAnnotation")
   kMenu("PVsounds", "Add", "&Play associated sound file`tX", "PlayAudioFileAssociatedNow")
   kMenu("PVsounds", "Add", "&Stop playing`tShift+X", "StopMediaPlaying")
   If !hSNDmedia
      kMenu("PVsounds", "Disable", "&Stop playing`tShift+X")
   Menu, PVsounds, Add, 
   kMenu("PVsounds", "Add/Uncheck", "&Auto-play sound files", "ToggleAutoPlaySND")
   If (autoPlaySNDs=1)
      kMenu("PVsounds", "Check", "&Auto-play sound files")
   kMenu("PVsounds", "Add/Uncheck", "Slidesho&w speed based on audio length", "ToggleSyncSlide2sndDuration")
   If (syncSlideShow2Audios=1)
      kMenu("PVsounds", "Check", "Slidesho&w speed based on audio length")
   If (autoPlaySNDs!=1)
      kMenu("PVsounds", "Disable", "Slidesho&w speed based on audio length")
   Menu, PVsounds, Add, 
   kMenu("PVsounds", "Add", "&Increase audio volume`tShift + [ . ]", "MenuSetVolumeUp")
   kMenu("PVsounds", "Add", "&Decrease audio volume`tShift + [ , ]", "MenuSetVolumeDown")
   kMenu("PVsounds", "Add", "Audio volume: " mediaSNDvolume "%", "dummy")
   kMenu("PVsounds", "Disable", "Audio volume: " mediaSNDvolume "%")
}

createMenuVPhudHisto() {
   kMenu("PVimgHistos", "Add", "C&ycle histogram modes`tShift+G", "ToggleImgHistogram")
   Menu, PVimgHistos, Add, 
   kMenu("PVimgHistos", "Add/Uncheck", "&None", "MenuSetVPhistoNone", "histogram")
   kMenu("PVimgHistos", "Add/Uncheck", "&Luminance", "MenuSetVPhistoLuminance", "histogram")
   kMenu("PVimgHistos", "Add/Uncheck", "&Red", "MenuSetVPhistoRed", "histogram")
   kMenu("PVimgHistos", "Add/Uncheck", "&Green", "MenuSetVPhistoGreen", "histogram")
   kMenu("PVimgHistos", "Add/Uncheck", "&Blue", "MenuSetVPhistoBlue", "histogram")
   kMenu("PVimgHistos", "Add/Uncheck", "&All mixed", "MenuSetVPhistoAll", "histogram")
   Menu, PVimgHistos, Add, 
   kMenu("PVimgHistos", "Add", "Graph emphasis", "dummy")
   kMenu("PVimgHistos", "Disable", "Graph emphasis")
   kMenu("PVimgHistos", "Add/Uncheck", "&Lows", "MenuSetVPgraphHistoLows", "graph histogram")
   kMenu("PVimgHistos", "Add/Uncheck", "&Balanced", "MenuSetVPgraphHistoMids", "graph histogram")
   kMenu("PVimgHistos", "Add/Uncheck", "&Peaks", "MenuSetVPgraphHistoPeaks", "graph histogram")

   If (showHistogram=1)
      kMenu("PVimgHistos", "Check", "&None")
   Else If (showHistogram=2)
      kMenu("PVimgHistos", "Check", "&Luminance")
   Else If (showHistogram=3)
      kMenu("PVimgHistos", "Check", "&Red")
   Else If (showHistogram=4)
      kMenu("PVimgHistos", "Check", "&Green")
   Else If (showHistogram=5)
      kMenu("PVimgHistos", "Check", "&Blue")
   Else If (showHistogram=6)
      kMenu("PVimgHistos", "Check", "&All mixed")

   If (showHistogram=1)
   {
      kMenu("PVimgHistos", "Disable", "&Lows")
      kMenu("PVimgHistos", "Disable", "&Balanced")
      kMenu("PVimgHistos", "Disable", "&Peaks")
   }

   If (histogramMode=1)
      kMenu("PVimgHistos", "Check", "&Lows")
   Else If (histogramMode=2)
      kMenu("PVimgHistos", "Check", "&Balanced")
   Else If (histogramMode=3)
      kMenu("PVimgHistos", "Check", "&Peaks")
}

createMenuColorDepth() {
   infoColorDepth := (usrColorDepth>1) ? "Original / reset" : defineColorDepth()
   kMenu("PVimgSdepth", "Add", "C&ycle simulate color depths`tQ", "ToggleImgColorDepth")
   Menu, PVimgSdepth, Add
   kMenu("PVimgSdepth", "Add/Uncheck", infoColorDepth, "MenuResetImageColorDepth")
   kMenu("PVimgSdepth", "Add/Uncheck", "2 bits (4 colors)", "MenuSetImageDepth2bits")
   kMenu("PVimgSdepth", "Add/Uncheck", "3 bits (8 colors)", "MenuSetImageDepth3bits")
   kMenu("PVimgSdepth", "Add/Uncheck", "4 bits (16 colors)", "MenuSetImageDepth4bits")
   kMenu("PVimgSdepth", "Add/Uncheck", "5 bits (32 colors)", "MenuSetImageDepth5bits")
   kMenu("PVimgSdepth", "Add/Uncheck", "6 bits (64 colors)", "MenuSetImageDepth6bits")
   kMenu("PVimgSdepth", "Add/Uncheck", "7 bits (128 colors)", "MenuSetImageDepth7bits")
   kMenu("PVimgSdepth", "Add/Uncheck", "8 bits (256 colors)", "MenuSetImageDepth8bits")
   kMenu("PVimgSdepth", "Add/Uncheck", "16 bits (65536 colors)", "MenuSetImageDepth16bits")
   If (usrColorDepth<2)
   {
      kMenu("PVimgSdepth", "Check", infoColorDepth)
      kMenu("PVimgSdepth", "Disable", infoColorDepth)
   } Else If (usrColorDepth=2)
      kMenu("PVimgSdepth", "Check", "2 bits (4 colors)")
   Else If (usrColorDepth=3)
      kMenu("PVimgSdepth", "Check", "3 bits (8 colors)")
   Else If (usrColorDepth=4)
      kMenu("PVimgSdepth", "Check", "4 bits (16 colors)")
   Else If (usrColorDepth=5)
      kMenu("PVimgSdepth", "Check", "5 bits (32 colors)")
   Else If (usrColorDepth=6)
      kMenu("PVimgSdepth", "Check", "6 bits (64 colors)")
   Else If (usrColorDepth=7)
      kMenu("PVimgSdepth", "Check", "7 bits (128 colors)")
   Else If (usrColorDepth=8)
      kMenu("PVimgSdepth", "Check", "8 bits (256 colors)")
   Else If (usrColorDepth=9)
      kMenu("PVimgSdepth", "Check", "16 bits (65536 colors)")

   Menu, PVimgSdepth, Add
   kMenu("PVimgSdepth", "Add/Uncheck", "&Perform dithering", "ToggleImgColorDepthDithering", "settings performance quality")
   If (ColorDepthDithering=1)
      kMenu("PVimgSdepth", "Check", "&Perform dithering")
}

createMenuImgColorsFX() {
   infolumosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(lumosAdjust, 2) : Round(lumosGrayAdjust, 2)
   infoGammosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(GammosAdjust, 2) : Round(GammosGrayAdjust, 2)
   infoSatAdjust := (imgFxMode=4) ? zatAdjust : Round(satAdjust*100)
   kMenu("PVimgColorsFX", "Add", "C&ycle colors display modes`tF", "ToggleImgFX")
   kMenu("PVimgColorsFX", "Add", DefineFXmodes(), "ToggleImgFX")
   kMenu("PVimgColorsFX", "Disable", DefineFXmodes())
   If (imgFxMode=2 || imgFxMode=3 || imgFxMode=4)
   {
      kMenu("PVimgColorsFX", "Add", "Br: " infolumosAdjust " / Ctr: "infoGammosAdjust " / dS: " infoSatAdjust, "ToggleImgFX")
      kMenu("PVimgColorsFX", "Disable", "Br: " infolumosAdjust " / Ctr: "infoGammosAdjust " / dS: " infoSatAdjust)
   }

   Menu, PVimgColorsFX, Add
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Original colors", "MenuSetColorModeOriginal")
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Personalized colors", "MenuSetColorModePersonalized")
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Auto-adjusted colors", "MenuSetColorModeAuto")
   kMenu("PVimgColorsFX", "Add/Uncheck", "Grays&cale", "MenuSetColorModeGrayscale")
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Red channel", "MenuSetColorModeRedC")
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Green channel", "MenuSetColorModeGreenC")
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Blue channel", "MenuSetColorModeBlueC")
   kMenu("PVimgColorsFX", "Add/Uncheck", "Alp&ha channel", "MenuSetColorModeAlphaC")
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Inverted colors", "MenuSetColorModeInverted")
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Sepia", "MenuSetColorModeSepia")
   If (thumbsDisplaying=1)
   {
      kMenu("PVimgColorsFX", "Disable", "&Auto-adjusted colors")
      kMenu("PVimgColorsFX", "Disable", "Alp&ha channel")
   }

   If (imgFxMode=1)
      kMenu("PVimgColorsFX", "Check", "&Original colors")
   Else If (imgFxMode=2)
      kMenu("PVimgColorsFX", "Check", "&Personalized colors")
   Else If (imgFxMode=3)
      kMenu("PVimgColorsFX", "Check", "&Auto-adjusted colors")
   Else If (imgFxMode=4)
      kMenu("PVimgColorsFX", "Check", "Grays&cale")
   Else If (imgFxMode=5)
      kMenu("PVimgColorsFX", "Check", "&Red channel")
   If (imgFxMode=6)
      kMenu("PVimgColorsFX", "Check", "&Green channel")
   Else If (imgFxMode=7)
      kMenu("PVimgColorsFX", "Check", "&Blue channel")
   Else If (imgFxMode=8)
      kMenu("PVimgColorsFX", "Check", "Alp&ha channel")
   Else If (imgFxMode=9)
      kMenu("PVimgColorsFX", "Check", "&Inverted colors")
   Else If (imgFxMode=10)
      kMenu("PVimgColorsFX", "Check", "&Sepia")
}

MenuSelectAllAction() {
   selectEntireImage("rm")
}

MenuDoOpenStartFolder() {
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()
   dummyTimerDelayiedImageDisplay(50)
   RemoveTooltip()
}

MenuToggleColorAdjustments() {
   If (imgFxMode=1)
   {
      UpdateUIadjustVPcolors("ignore-zoom")
   } Else
   {
      o_usrColorDepth := usrColorDepth
      imgFxMode := usrColorDepth := 1
      If (o_usrColorDepth=1)
         dummyTimerDelayiedImageDisplay(50)
      Else
         dummyTimerReloadThisPicture(50)
   }
}

MenuStartDrawingSelectionArea() {
   startDrawingShape("selection")
}

MenuStartDrawingShapes() {
   startDrawingShape("shape", 0, "draw")
}

MenuResumeDrawingShapes() {
   startDrawingShape("selection", "resume")
}

MenuStartDrawingLines() {
   startDrawingShape("line", 0, "draw")
}

createMenuLiveTools(dummy:=0) {
   If (dummy!="mbr")
   {
      kMenu("PVlTools", "Add", "Live tools", "dummy")
      kMenu("PVlTools", "Disable", "Live tools")
   }
   kMenu("PVlTools", "Add", "&Paint brushes`tP", "PanelBrushTool", "pinch bulge effects draw deformer smudge cloner effects")
   kMenu("PVlTools", "Add", "&Erase or fade area`tDelete", "PanelEraseSelectedArea")
   kMenu("PVlTools", "Add", "F&lood fill / color bucket`tK", "PanelFloodFillTool")
   kMenu("PVlTools", "Add", "&Fill shapes`tAlt+Bksp", "PanelFillSelectedArea")
   kMenu("PVlTools", "Add", "Fill be&hind image", "PanelFillBehindBgrImage")
   kMenu("PVlTools", "Add", "Draw s&hape contours`tCtrl+L", "PanelDrawShapesInArea", "lines")
   kMenu("PVlTools", "Add", "&Draw predetermined lines or arcs", "PanelDrawLines", "lines")
   kMenu("PVlTools", "Add", "Define f&reeform filled shape`tShift+P", "MenuStartDrawingShapes")
   kMenu("PVlTools", "Add", "Define freeform &outline`tAlt+P", "MenuStartDrawingLines")
   kMenu("PVlTools", "Add", "Define alpha mas&k", "PanelSoloAlphaMasker")
   kMenu("PVlTools", "Add", "&Insert te&xt`tShift+T", "PanelInsertTextArea")
   kMenu("PVlTools", "Add", "&Adjust image colors`tU", "PanelColorsAdjusterImage")
   kMenu("PVlTools", "Add", "Adjust vie&wport colors and effects`tShift+U", "PanelColorsAdjusterWindow")
   kMenu("PVlTools", "Add", "Desaturate color&s`tCtrl+G", "PanelDesatureSelectedArea")
   If (AnyWindowOpen=10)
      kMenu("PVlTools", "Check/Disable", "Adjust vie&wport colors and effects`tShift+U")
   Else If (AnyWindowOpen=23)
      kMenu("PVlTools", "Check/Disable", "&Fill shapes`tAlt+Bksp")
   Else If (AnyWindowOpen=25)
      kMenu("PVlTools", "Check/Disable", "&Erase or fade area`tDelete")
   Else If (AnyWindowOpen=30)
      kMenu("PVlTools", "Check/Disable", "&Draw predetermined lines or arcs")
   Else If (AnyWindowOpen=32)
      kMenu("PVlTools", "Check/Disable", "&Insert te&xt`tShift+T")
   Else If (AnyWindowOpen=55)
      kMenu("PVlTools", "Check/Disable", "Desaturate color&s`tCtrl+G")
   Else If (AnyWindowOpen=64)
      kMenu("PVlTools", "Check/Disable", "&Paint brushes`tP")
   Else If (AnyWindowOpen=65)
      kMenu("PVlTools", "Check/Disable", "Draw s&hape contours`tCtrl+L")
   Else If (AnyWindowOpen=66)
      kMenu("PVlTools", "Check/Disable", "F&lood fill / color bucket`tK")
   Else If (AnyWindowOpen=68)
      kMenu("PVlTools", "Check/Disable", "Fill be&hind image")
   Else If (AnyWindowOpen=70)
      kMenu("PVlTools", "Check/Disable", "Define alpha mas&k")
   Else If (AnyWindowOpen=74)
      kMenu("PVlTools", "Check/Disable", "&Adjust image colors`tU")

   If (editingSelectionNow=1 && dummy!="mbr")
   {
      Menu, PVlTools, Add
      kMenu("PVlTools", "Add", "Other operations", "dummy")
      kMenu("PVlTools", "Disable", "Other operations")
      kMenu("PVlTools", "Add", "Flip selected &horizontally`tShift+H", "FlipSelectedAreaH")
      kMenu("PVlTools", "Add", "Flip selected &vertically`tShift+V", "FlipSelectedAreaV")
      kMenu("PVlTools", "Add", "&Invert colors`tShift+I", "InvertSelectedArea")
   }
}

toggleAlphaGradientCenterReposition() {
   userAllowClrGradientRecenter := 0
   userAllowsGradientRecentering := !userAllowsGradientRecentering
   friendly := (userAllowsGradientRecentering=1) ? "ACTIVATED" : "DEACTIVATED"
   friendly2 := (userAllowsGradientRecentering=1) ? "`nClick and drag inside the selection area to adjust the center" : ""
   showTOOLtip("Alpha mask gradient center repositioning: " friendly friendly2, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleClrGradientCenterRepose() {
   userAllowsGradientRecentering := 0
   userAllowClrGradientRecenter := !userAllowClrGradientRecenter
   friendly := (userAllowClrGradientRecenter=1) ? "ACTIVATED" : "DEACTIVATED"
   friendly2 := (userAllowClrGradientRecenter=1) ? "`nClick and drag inside the selection area to adjust the center" : ""
   showTOOLtip("Color gradient center repositioning: " friendly friendly2, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

isVarEqualTo(value, vals*) {
   yay := 0
   for index, param in vals
   {
       If (value=param)
       {
          yay := 1
          Break
       }
   }
   Return yay
}

BuildImgLiveEditMenu() {
   If (editingSelectionNow!=1 && !AnyWindowOpen) || (thumbsDisplaying=1)
      Return

   deleteMenus()
   isWinCustomShapeFriendly := isVarEqualTo(AnyWindowOpen, 74, 68, 66, 65, 64, 55, 25, 23, 10)
   kMenu("PVmenu", "Add/Uncheck", "&Collapse tool panel`tF8", "toggleImgEditPanelWindow")
   If (panelWinCollapsed=1)
      kMenu("PVmenu", "Check", "&Collapse tool panel`tF8")

   drawing := isNowAlphaPainting()
   If (drawing!=1)
      kMenu("PVmenu", "Add", "&Cancel / close panel`tEscape", "BtnCloseWindow")
   If (!isVarEqualTo(AnyWindowOpen, 10  64, 66) && imgEditPanelOpened=1)
      kMenu("PVmenu", "Add", "Appl&y tool`tEnter", "applyIMGeditFunction")

   Menu, PVmenu, Add
   If (AnyWindowOpen!=24 && AnyWindowOpen!=31 && drawing!=1 && showMainMenuBar!=1)
   {
      createMenuLiveTools()
      kMenu("PVmenu", "Add", "S&witch live tool", ":PVlTools")
   }

   If (AnyWindowOpen=10)
   {
      Menu, PVmenu, Add
      If (editingSelectionNow=1)
      {
         kMenu("PVmenu", "Add", "Appl&y color effects inside selection`tCtrl+Shift+U", "ApplyColorAdjustsSelectedArea")
         kMenu("PVmenu", "Add", "&... outside the selection", "ApplyColorAdjustsSelectedArea")
      }

      kMenu("PVmenu", "Add/Uncheck", "&Activate viewport color adjustments`t\", "BtnToggleNoColorsFX")
      If (ForceNoColorMatrix!=1)
         kMenu("PVmenu", "Check", "&Activate viewport color adjustments`t\")
      kMenu("PVmenu", "Add", "&Reset all adjustments to defaults`tCtrl+\", "BtnResetImageView")
   }

   If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
   {
      Menu, PVmenu, Add
      kMenu("PVmenu", "Add", "&Undo`tCtrl+Z", "ImgUndoAction")
      kMenu("PVmenu", "Add", "&Redo`tCtrl+Y", "ImgRedoAction")
   }

   If (isVarEqualTo(AnyWindowOpen, 10, 12, 64, 66) && imgEditPanelOpened=1)
   {
      kMenu("PVmenu", "Add/Uncheck", "&Show selection`tE", "ToggleEditImgSelection")
      If (editingSelectionNow=1)
         kMenu("PVmenu", "Check", "&Show selection`tE")

      If (editingSelectionNow=1)
         kMenu("PVselv", "Add", "&Reset selection", "newImgSelection")
      Else
         kMenu("PVmenu", "Add", "&Select all`tCtrl+A", "MenuSelectAllAction")
   }

   If (undoLevelsRecorded>1 && undoLevelsRecorded!="" && editingSelectionNow=1)
   {
      Menu, PVselv, Add
      kMenu("PVselv", "Add", "&Undo selection`tCtrl+Shift+Z", "ImgSelUndoAct")
      kMenu("PVselv", "Add", "&Redo selection`tCtrl+Shift+Y", "ImgSelRedoAct")
   }

   decideLiveSelectionBasedOnWindow(angleu, isToolGood)
   If isVarEqualTo(AnyWindowOpen, 65, 23)
      isToolGood := 1

   If (isToolGood=1 && isWinCustomShapeFriendly=1 && editingSelectionNow=1)
      kMenu("PVselv", "Add", "&Load custom shapes", "PanelManageVectorShapes")

   Menu, PVselv, Add
   kMenu("PVselv", "Add", "&Select all`tCtrl+A", "MenuSelectAllAction")
   If (innerSelectionCavityX>0.01 && innerSelectionCavityY>0.01)
      kMenu("PVselv", "Add", "R&eset exclude area`tShift+\", "resetSelectionAreaCavity")

   kMenu("PVselv", "Add", "&Flip selection W/H`tW", "flipSelectionWH")
   kMenu("PVselv", "Add/Uncheck", "&Limit selection to image area`tL", "toggleLimitSelection")
   If (LimitSelectBoundsImg=1)
      kMenu("PVselv", "Check", "&Limit selection to image area`tL")

   kMenu("PVselv", "Add/Uncheck", "Sho&w grid", "ToggleSelectGrid")
   If (showSelectionGrid=1)
      kMenu("PVselv", "Check", "Sho&w grid")

   If (isToolGood=1)
   {
      infoSelShape := DefineVPselAreaMode()
      kMenu("PVselv", "Add", "C&ycle selection types`tShift+E", "MenuCycleSelectionShapes")
      kMenu("PVselv", "Add", infoSelShape, "dummy")
      kMenu("PVselv", "Disable", infoSelShape)
   }

   Menu, PVmenu, Add, 
   If (editingSelectionNow=1)
   {
      additions := 1
      If (isAlphaMaskWindow()=1)
      {
         If (AnyWindowOpen=23)
         {
            ; fill area panel ; PanelFillSelectedArea()
            If (isInRange(FillAreaColorMode, 2, 4) && liveDrawingBrushTool!=1)
            {
               kMenu("PVmenu", "Add", "&Reset gradient center", "BtnSetTextureSource")
               kMenu("PVmenu", "Add/Uncheck", "&Allow gradient center repositioning", "toggleClrGradientCenterRepose")
               If (userAllowClrGradientRecenter=1)
                  kMenu("PVmenu", "Check", "&Allow gradient center repositioning")
            } Else If (FillAreaColorMode=6 && liveDrawingBrushTool!=1)
               kMenu("PVmenu", "Add", "&Set texture fill source`tS", "BtnSetTextureSource")
         }

         ; paste in place / transform tools ; PanelPasteInPlace()
         additions := !liveDrawingBrushTool
         givenMenu := (liveDrawingBrushTool=1) ? "PVmenu" : "PValpha"
         createMenuAlphaMask(givenMenu)
         If !liveDrawingBrushTool
            kMenu("PVmenu", "Add", "Alpha mas&k", ":PValpha")
      } Else If isVarEqualTo(AnyWindowOpen, 64, 66)
      {
         additions := FloodFillSelectionAdj
         labelu := (AnyWindowOpen=64) ? "Painting" : "Bucket"
         kMenu("PVmenu", "Add/Uncheck", "&" labelu " mode`tCtrl+K", "toggleAlphaPaintingMode")
         kMenu("PVmenu", "Add", "&Cycle " labelu " modes`tShift+K", "toggleBrushDrawInOutModes")
         If (liveDrawingBrushTool=1 && AnyWindowOpen=64) || (FloodFillSelectionAdj!=1 && AnyWindowOpen=66)
            kMenu("PVmenu", "Check", "&" labelu " mode`tCtrl+K")
      }

      If (additions=1)
      {
         createMenuSelectionAlign()
         createMenuSelectionRotationAspectRatio()
         kMenu("PVmenu", "Add", "Ali&gnment", ":PVselAlign")
         kMenu("PVmenu", "Add", "&Selection area", ":PVselv")
         kMenu("PVmenu", "Add", "&Rotation and aspect ratio", ":PVselRatio")
      }
   }

   If (AnyWindowOpen=64 && BrushToolType=3)
      kMenu("PVmenu", "Add", "Define cloner &source`tS", "BtnSetClonerBrushSource")

   If (AnyWindowOpen=64 && BrushToolType<4)
   {
      kMenu("PVmenu", "Add", "&Cycle symmetry modes`tY", "toggleBrushSymmetryModes")
      kMenu("PVmenu", "Add", "&Define symmetry point`tShift+Y", "BtnSetBrushSymmetryCoords")
   }

   If isVarEqualTo(AnyWindowOpen, 31, 24)
   {
      kMenu("PVmenu", "Add", "Reset to &initial position", "ResetTransformToolPos")
      If (shearImgX!=0 || shearImgY!=0)
         kMenu("PVmenu", "Add", "&Reset image skew offsets", "resetImgSkewOffsets")
   }

   If isAlphaMaskPartialWin()
   {
      kMenu("PValpha", "Add", "Previe&w the alpha mask`tM", "ViewAlphaMaskNow")
      kMenu("PValpha", "Add", "&Define alpha mask`tM", "PanelSoloAlphaMasker")
      kMenu("PValpha", "Add/Uncheck", "&Invert alpha mask`tN", "toggleInvertAlphaMask")
      If (editingSelectionNow=1)
         kMenu("PValpha", "Add", "&Capture selected area as alpha mask", "SetImageAsAlphaMask")
      If (alphaMaskColorReversed=1)
         kMenu("PValpha", "Check", "&Invert alpha mask`tN")
      kMenu("PVmenu", "Add", "Alpha mas&k", ":PValpha")
   }

   If (isWinCustomShapeFriendly=1 && EllipseSelectMode=2 && editingSelectionNow=1 && additions=1)
   {
      createMenuSelectSizeShapes("simple")
      kMenu("PVmenu", "Add", "&Custom shape options", ":PVselSize")
   }

   If !AnyWindowOpen
      kMenu("PVmenu", "Add", "Selection &properties`tAlt+E", "PanelIMGselProperties")

   Menu, PVmenu, Add
   If (showMainMenuBar!=1)
   {
      createMenuMainView()
      kMenu("PVmenu", "Add", "Image vie&w", ":PVview")
   }

   If (imgEditPanelOpened=1 && !isVarEqualTo(AnyWindowOpen, 10, 64, 66, 12) && drawing!=1)
      kMenu("PVmenu", "Add", "&Hide dynamic object`tD", "toggleLiveEditObject")

   showThisMenu("PVmenu")
}

MenuCopyAction() {
   If (thumbsDisplaying=1)
      InvokeCopyFiles()
   Else If isImgEditingNow()
      CopyImage2clip()
}

MenuSelectAction() {
   If (thumbsDisplaying=1)
      MenuMarkThisFileNow()
   Else
      ToggleEditImgSelection()
}

MenuChangeZoomMinus() {
   changeZoom(-1)
}

MenuChangeZoomPlus() {
   changeZoom(1)
}

BuildSecondMenu(givenCoords:=0) {
   ; main menu
   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   DestroyGIFuWin()
   If (thumbsDisplaying=1)
   {
      invokeFileOptionsMenu(givenCoords)
      Return
   } Else If (editingSelectionNow=1 && useGdiBitmap() && StrLen(getIDimage(currentFileIndex))>4 && imgEditPanelOpened!=1)
   {
      invokeSelectionAreaMenu("DoubleClick")
      Return
   }

   deleteMenus()
   If (imgEditPanelOpened=1)
   {
      kMenu("PVmenu", "Add", "Collapse panel`tF11", "toggleImgEditPanelWindow")
      Menu, PVmenu, Add, 
      If (AnyWindowOpen=10)
      {
         kMenu("PVmenu", "Add", "Apply vie&wport effects inside selection`tCtrl+Shift+U", "ApplyColorAdjustsSelectedArea")
         kMenu("PVmenu", "Add", "&... outside the selection", "ApplyColorAdjustsSelectedArea")
      } Else kMenu("PVmenu", "Add", "&Apply tool`tEnter", "applyIMGeditFunction")

      labelu := (AnyWindowOpen=10) ? "Close panel" : "Cancel tool"
      kMenu("PVmenu", "Add", labelu "`tEscape", "CloseWindow")
      Menu, PVmenu, Add, 
      kMenu("PVmenu", "Add", "Undo`tCtrl+Z", "ImgUndoAction", "image editing")
      kMenu("PVmenu", "Add", "Redo`tCtrl+Y", "ImgRedoAction", "image editing")
      Menu, PVmenu, Add, 
      If (AnyWindowOpen=10)
         kMenu("PVmenu", "Add", "Select area`tE", "ToggleEditImgSelection", "image editing")
      Else
         kMenu("PVmenu", "Add", "Select all`tCtrl+A", "MenuSelectAllAction")

      kMenu("PVmenu", "Add", "Square`tR", "makeSquareSelection", "image editing selection")
      kMenu("PVmenu", "Add", "Flip selection W/H`tW", "flipSelectionWH", "image editing selection")
      kMenu("PVmenu", "Add", "Limit selection to image boundaries`tL", "toggleLimitSelection")
      Menu, PVmenu, Add, 
      If (AnyWindowOpen!=10)
         kMenu("PVmenu", "Add", "&Rotate selection by 45°`tShift+R", "MenuSelRotation")

      If (AnyWindowOpen=10)
         kMenu("PVmenu", "Add", "Reset image vie&w", "BtnResetImageView", "viewport")
      Else If (VPselRotation>0)
         kMenu("PVmenu", "Add", "&Reset selection rotation`tShift+\", "resetSelectionRotation")

      If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
         kMenu("PVmenu", "Add", "R&eset exclude area`tShift+\", "resetSelectionAreaCavity")

      Menu, PVmenu, Add, 
      kMenu("PVmenu", "Add", "Adapt image to viewport`t/", "ToggleImageSizingMode")
      If (AnyWindowOpen=10 || AnyWindowOpen=74)
         kMenu("PVmenu", "Add", "Toggle colour &effects", "BtnToggleNoColorsFX")
      Else
         kMenu("PVmenu", "Add", "Hide tool preview object`tD", "toggleLiveEditObject")

      showThisMenu("PVmenu")
      Return
   }

   isWelcomeScreenu := (StrLen(UserMemBMP)>2 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
   ; zt := (thumbsDisplaying=1) ? "file(s) to" : ""
   zt2 := (thumbsDisplaying=1) ? "list" : "image"
   kMenu("PVmenu", "Add", "Main menu`tAppsKey", "InitGuiContextForcedMenu")
   Menu, PVmenu, Add,
   kMenu("PVmenu", "Add", "&Open image`tCtrl+O", "OpenDialogFiles")
   If isWelcomeScreenu
      kMenu("PVmenu", "Add", "Open &folder`tShift+O", "OpenFolders")

   If (thumbsDisplaying!=1)
   {
      kMenu("PVmenu", "Add", "&New image`tCtrl+N", "PanelNewImage", "editing")
      kMenu("PVmenu", "Add", "&Acquire image", "AcquireWIAimage", "editing")
   }

   If !isWelcomeScreenu
   {
      kMenu("PVmenu", "Add", "&Save " zt2 "`tCtrl+S", "PanelSaveImg")
      kMenu("PVmenu", "Add", "&Refresh " zt2 "`tF5", "RefreshImageFileAction", "reload revert image")
      Menu, PVmenu, Add, 

      If (thumbsDisplaying=1)
         kMenu("PVmenu", "Add", "S&elect file`tSpace", "MenuSelectAction")
      Else
         kMenu("PVmenu", "Add", "S&election area`tE", "MenuSelectAction", "create")

      kMenu("PVmenu", "Add", "&All / none`tCtrl+A", "MenuSelectAllAction")
      Menu, PVmenu, Add, 
      If (thumbsDisplaying!=1)
      {
         kMenu("PVmenu", "Add", "&Copy image`tCtrl+C", "CopyImage2clip")
         If (editingSelectionNow=1)
            kMenu("PVmenu", "Add", "Cut area`tCtrl+X", "CutSelectedArea", "create image editing selection")

         kMenu("PVmenu", "Add", "&Paste image`tCtrl+V", "tlbrPasteClipboardIMG")
      } Else
      {
         kMenu("PVmenu", "Add", "Cut file(s) (for E&xplorer)`tCtrl+X", "MenuExplorerCutFiles")
         kMenu("PVmenu", "Add", "&Copy file(s) to`tC", "InvokeCopyFiles")
         kMenu("PVmenu", "Add", "&Move file(s) to`tM", "PanelMoveCopyFiles")
         kMenu("PVmenu", "Add", "Pas&te file(s)`tCtrl+V", "MenuPasteHDropFiles")
      }

      kl := (editingSelectionNow=1 && thumbsDisplaying!=1) ? "area" : "file(s)"
      kMenu("PVmenu", "Add", "Er&ase " kl "`tDelete", "deleteKeyAction")
      Menu, PVmenu, Add, 
      If (maxFilesIndex>1)
      {
         kMenu("PVmenu", "Add", "Searc&h index`tF3", "PanelSearchIndex")
         kMenu("PVmenu", "Add", "&Jump to`tJ", "PanelJump2index")
      }

      kMenu("PVmenu", "Add", "Reset " zt2 " vie&w`t\", "ResetImageView")
      If (thumbsDisplaying=1)
      {
         Menu, PVmenu, Add, 
         kMenu("PVmenu", "Add", "&Toggle list modes`tL", "toggleListViewModeThumbs")
         If (thumbsListViewMode>1)
         {
            kMenu("PVmenu", "Add", "Increase text size`t+", "MenuChangeZoomPlus")
            kMenu("PVmenu", "Add", "Decrease text size`t-", "MenuChangeZoomMinus")
         } Else
         {
            kMenu("PVmenu", "Add", "More columns`t+", "MenuChangeZoomPlus")
            kMenu("PVmenu", "Add", "Fewer columns`t-", "MenuChangeZoomMinus")
         }
      } Else
      {
         Menu, PVmenu, Add, 
         If (maxFilesIndex>1)
         {
            infoThumbsMode := (thumbsDisplaying=1) ? "Image view" : "List view"
            kMenu("PVmenu", "Add", infoThumbsMode "`tEnter", "MenuDummyToggleThumbsMode", "full view list")
            kMenu("PVmenu", "Add", "Start slideshow`tSpace", "dummyInfoToggleSlideShowu", "play")
         }
         kMenu("PVmenu", "Add", "Image information`tI", "ToggleHistoInfoBoxu", "histogram")
         kMenu("PVmenu", "Add", "Open previous panel`tF8", "openPreviousPanel", "last opened")
      }
   } Else
   {
      createMenuFavourites()
      createMenuHelpQPV()
      kMenu("PVmenu", "Add", "Fa&vourites", ":PVfaves")
      kMenu("PVmenu", "Add", "&Help", ":PVhelp")
   }

   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVmenu") : givenCoords
   showThisMenu("PVmenu")
}

StopCaptureClickStuff(dummy:=0) {
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   endCaptureCloneBrush()
   showTOOLtip("Operation abandoned: define source point")
   SoundBeep , 300, 100
   If (dummy!="escape" && panelWinCollapsed=1 && imgEditPanelOpened=1 && AnyWindowOpen)
      toggleImgEditPanelWindow()
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BuildMainMenu(dummy:=0, givenCoords:=0) {
   Static lastInvoked := 1
   If (toolTipGuiCreated=2)
      RemoveTooltip()

   If givenCoords
      globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVmenu") : givenCoords

   If (drawingShapeNow=1)
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      createContextMenuCustomShapeDrawing(mX, mY, 0, 0, 0)
      ; stopDrawingShape()
      Return
   } Else If (mustCaptureCloneBrush=1)
   {
      StopCaptureClickStuff(dummy)
      Return
   } Else If (imgEditPanelOpened=1)
   {
      deleteMenus()
      BuildImgLiveEditMenu()
      Return
   }

   If (AnyWindowOpen>0 && dummy!="forced")
   {
      If ((A_TickCount - lastInvoked < 650) && !MsgBox2hwnd)
         CloseWindow()
      Else If (panelWinCollapsed!=1)
         WinActivate, ahk_id %hSetWinGui%
      lastInvoked := A_TickCount
      Return
   }

   SetTimer, drawWelcomeImg, Off
   deleteMenus()
   ResetImgLoadStatus()
   Global lastWinDrag := A_TickCount
   infoImgEditingNow := isImgEditingNow()
   If (thumbsDisplaying!=1)
   {
      kMenu("PVedit", "Add", "New image`tCtrl+N", "PanelNewImage", "image editing")
      If (infoImgEditingNow=1)
      {
         kMenu("PVedit", "Add", "&Save image as...`tCtrl+S", "PanelSaveImg", "image editing")
         kMenu("PVedit", "Add", "C&ut selected area`tCtrl+X", "CutSelectedArea", "image editing")
         If (editingSelectionNow!=1)
            kMenu("PVedit", "Disable", "C&ut selected area`tCtrl+X", "image editing")
         kMenu("PVedit", "Add", "&Copy to clipboard`tCtrl+C", "CopyImage2clip", "image")
         kMenu("PVedit", "Add", "Close ima&ge and files list`tCtrl+F4", "closeDocuments", "reset")
      }

      kMenu("PVedit", "Add", "P&aste clipboard`tCtrl+V", "PasteClipboardIMG")
      If (infoImgEditingNow=1)
      {
         createMenuAlphaMask()
         kMenu("PVedit", "Add", "&Paste in place`tCtrl+Shift+V", "PanelPasteInPlace")
         If (editingSelectionNow!=1)
            kMenu("PVedit", "Disable", "&Paste in place`tCtrl+Shift+V")

         Menu, PVedit, Add,
         kMenu("PVedit", "Add", "Print image`tCtrl+P", "PanelPrintImage")
      }

      kMenu("PVedit", "Add", "Ac&quire image (WIA)", "AcquireWIAimage", "capture devices")
      Menu, PVedit, Add, 
      If (editingSelectionNow!=1 && imgSelX2=-1 && imgSelY2=-1 && (CurrentSLD || StrLen(UserMemBMP)>2))
         kMenu("PVedit", "Add", "Create &selection area`tE", "newImgSelection", "image editing")
      Else If (editingSelectionNow!=1 && infoImgEditingNow=1)
         kMenu("PVedit", "Add", "Sho&w selection area`tE", "ToggleEditImgSelection", "image editing")

      createMenuImageEditSubMenus()
      ; Try kMenu("PVedit", ""Add", &Create", ":PVimgCreate"
      Try kMenu("PVedit", "Add", "Alpha mas&k", ":PValpha")
      Try kMenu("PVedit", "Add", "&Filters", ":PVimgFilters")
      Try kMenu("PVedit", "Add", "&Draw", ":PVimgDraw")
      Try kMenu("PVedit", "Add", "&Transform", ":PVimgTransform")
   }

   createMenuFavourites()
   createMenuOpenRecents()

; main menu
   kMenu("PVmenu", "Add", "&Open...", ":PVopenF")
   kMenu("PVmenu", "Add", "Fa&vourites", ":PVfaves")
   If StrLen(mustOpenStartFolder)>3
      kMenu("PVmenu", "Add", "&Scan files in folder`tSpace/Wheel", "MenuDoOpenStartFolder", "open index")
   If (thumbsDisplaying=1)
      kMenu("PVmenu", "Add", "&Paste files`tCtrl+V", "PasteClipboardIMG", "index list")

   If (StrLen(UserMemBMP)>2 && thumbsDisplaying!=1 && showMainMenuBar!=1)
   {
      Menu, PVmenu, Add,
      If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
      {
         kMenu("PVmenu", "Add", "&Undo`tCtrl+Z", "ImgUndoAction", "image edit")
         kMenu("PVmenu", "Add", "&Redo`tCtrl+Y", "ImgRedoAction", "image edit")
      }
      kMenu("PVmenu", "Add", "&Save image`tCtrl+S", "PanelSaveImg", "image edit")
      If FileExist(resultedFilesList[currentFileIndex, 1])
         kMenu("PVmenu", "Add", "&Revert changes...`tF5", "RefreshImageFileAction", "reload refresh")
   } Else If (StrLen(UserMemBMP)>2 && thumbsDisplaying=1)
      kMenu("PVmenu", "Add", "&Return to image editing", "MenuReturnIMGedit", "back")

   Menu, PVmenu, Add,
   If (thumbsDisplaying!=1)
      kMenu("PVmenu", "Add", "&Edit image", ":PVedit")

   friendlyImgView := (thumbsDisplaying=1) ? "&Thumbnails view" : "Image vie&w"
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      friendlyImgView := "List vie&w"

   If (maxFilesIndex>0 && CurrentSLD)
   {
      infoThisFile := markedSelectFile ? "S&elected files" : "C&urrent file"
      If (thumbsDisplaying!=1 && editingSelectionNow=1)
      {
         createMenuSelectionArea()
         kMenu("PVmenu", "Add", "Selec&tion area", ":PVselv")
      }

      createMenuCurrentFilesActs()
      kMenu("PVmenu", "Add", infoThisFile, ":PVfilesActs")
      If markedSelectFile
      {
         createMenuSoloFile()
         kMenu("PVmenu", "Add", "&Active / focused file", ":PVtActFile")
      }

      If (thumbsDisplaying=1) || (thumbsDisplaying!=1 && editingSelectionNow!=1)
      {
         createMenuFilesIndexOptions()
         kMenu("PVmenu", "Add", "Files inde&x/list", ":PVfList")
      }

      If (thumbsDisplaying=1 && maxFilesIndex>1)
      {
         okay := (testIsDupesList() && InStr(resultedFilesList[currentFileIndex, 23], "_")) ? 0 : 1
         If okay
         {
            createMenuFilesSort()
            kMenu("PVmenu", "Add", "Sort images list b&y", ":PVsort", "images files")
         }
      }

      createMenuMainView()
      kMenu("PVmenu", "Add", friendlyImgView, ":PVview")

      If (thumbsDisplaying!=1 && StrLen(UserMemBMP)<3 && currentFileIndex!=0)
      {
         createMenuAnnotations()
         kMenu("PVmenu", "Add", "&Annotation", ":PVsounds")
      }

      If (maxFilesIndex>2 || mustOpenStartFolder)
      {
         createMenuNavigation()
         kMenu("PVmenu", "Add", "Navi&gation", ":PVnav")
         If (thumbsDisplaying!=1 && editingSelectionNow!=1)
         {
            createMenuSlideshows()
            kMenu("PVmenu", "Add", "Slides&how", ":PVslide")
         }
      }
      Menu, PVmenu, Add,
   } Else If StrLen(UserMemBMP)>2
   {
      If (editingSelectionNow=1 && thumbsDisplaying!=1)
      {
         createMenuSelectionArea()
         kMenu("PVmenu", "Add", "Selec&tion", ":PVselv")
         kMenu("PVmenu", "Add", "&Edit image", ":PVedit")
      }

      createMenuMainView()
      kMenu("PVmenu", "Add", friendlyImgView, ":PVview")
   }

   If (markedSelectFile && thumbsDisplaying!=1)
      kMenu("PVmenu", "Add", "Dro&p files selection`tShift+Tab", "dropFilesSelection")

   If (thumbsDisplaying=1 || mustPreventMenus=1 && maxFilesIndex>2 && CurrentSLD)
   {
      createMenuFilesSelections("PVfileSel")
      kMenu("PVmenu", "Add", "F&iles selection", ":PVfileSel")
   }

   If StrLen(filesFilter)>1
   {
      Menu, PVmenu, Add
      kMenu("PVmenu", "Add", "Remove files list filter`tCtrl+Space", "MenuRemFilesListFilter")
      If testIsDupesList()
      {
         kMenu("PVmenu", "Add", "Auto-select &duplicates", "PanelAutoSelectDupes")
         If InStr(resultedFilesList[currentFileIndex, 23], "_")
            kMenu("PVmenu", "Add", "Change filter threshold`tCtrl+F", "PanelChangeHamDistThreshold")
      }
      Menu, PVmenu, Add
   } Else If (SLDtypeLoaded=2 && currentFilesListModified=1 && CurrentSLD && maxFilesIndex>1)
   {
      Menu, PVmenu, Add
      thisKey := (thumbsDisplaying=1) ? "Ctrl+S" : "Ctrl+Shift+S"
      kMenu("PVmenu", "Add", "Save files list now`t" thisKey, "BTNsaveCurrentSlideshow")
      Menu, PVmenu, Add
   }

   createMenuInterfaceOptions()
   createMenuMainPreferences()
   If (mustRecordSeenImgs=1 && mustPreventMenus=1 && !AnyWindowOpen)
      createMenuSeenImages()

   createMenuHelpQPV()
   kMenu("PVmenu", "Add", "Inter&face", ":PvUIprefs")
   kMenu("PVmenu", "Add", "Prefe&rences", ":PVprefs")
   ; If StrLen(UserMemBMP)<3
   kMenu("PVmenu", "Add", "Help", ":PVhelp")
   Menu, PVmenu, Add,
   kMenu("PVmenu", "Add", "Restart`tShift+Esc", "restartAppu", "close renew")
   kMenu("PVmenu", "Add", "Exit`tEscape", "exitAppu", "close")
   If thisCoords
      globalMenuOptions := thisCoords

   showThisMenu("PVmenu")
}

createMenuSeenImages() {
   If (maxFilesIndex>2 && CurrentSLD)
   {
      kMenu("PVmenu", "Add", "&Identify already seen images in the list", "quickFindSeenImages", "saw")
      kMenu("PVmenu", "Add", "&Identify never seen images in the list", "quickFindUnseenImages", "unseen")
   }

   If (userSeenSessionImagesArray.Count()>1)
      kMenu("PVmenu", "Add", "&Images seen in this session", "BtnViewedImages2List", "retrieve saw")

   kMenu("PVmenu", "Add", "&Retrieve list of all recorded seen images", "BtnALLviewedImages2List")
   ; kMenu("PVseenImgs", "Add", "&Purge records of inexistent files (seen images)", "CleanDeadFilesSeenImagesDB", "erase")
   kMenu("PVmenu", "Add", "&Erase the entire list of recorded seen images", "eraseSeenIMGsDB", "purge saw")
   kMenu("PVmenu", "Add", "&Already seen images statistics", "PanelSeenStats", "stats")
}

kMenu(mena, actu, labelu, funcu:=0, keywords:="") {
   Static objuA := [], indexu := 0
        , objuB := new hashtable()
        , objuC := []

   If (actu="Reset" && !mena)
   {
      indexu := 0
      objuA := []
      objuC := []
      objuB := ""
      objuB := new hashtable()
      Return
   } Else If (actu="Give" && !mena)
      Return [objuA, objuB, objuC]

   zLabelu := StrReplace(labelu, "%", "`%")
   zLabelu := StrReplace(zlabelu, ",", "`,")
   If (InStr(actu, "Add") && funcu && labelu)
   {
      If !InStr(funcu, ":")
      {
         accel :=  InStr(labelu, "&") ? Format("{:U}", SubStr(labelu, InStr(labelu, "&") + 1, 1)) : ""
         kLabelu := StrReplace(labelu, "&")
         gup := StrSplit(kLabelu, "`t")
         flabel := Trimmer(fuzzifyString(gup[1]))
         testu := gup[1] A_Space funcu
         If (RegExMatch(testu, "i)(image|bitmap)") && !InStr(keywords, "img"))
            keywords .= " img"
         If (InStr(testu, "duplicate") && !InStr(keywords, "dupes"))
            keywords .= " dupes"
         If (InStr(testu, "image") && !InStr(keywords, "bitmap"))
            keywords .= " bitmap"
         If (InStr(testu, "img") && !InStr(keywords, "image"))
            keywords .= " image"
         If (InStr(testu, "create") && !InStr(keywords, "new"))
            keywords .= " new"
         If (InStr(testu, "insert") && !InStr(keywords, "add"))
            keywords .= " add"
         If (InStr(testu, "favo") && !InStr(keywords, "faves"))
            keywords .= " faves"
         If (InStr(testu, "save") && !InStr(keywords, "write"))
            keywords .= " write"
         If (InStr(testu, "statistic") && !InStr(keywords, "stats"))
            keywords .= " stats"
         If (InStr(testu, "folder") && !InStr(keywords, "directory"))
            keywords .= " directory"
         If (InStr(testu, "delete") && !InStr(keywords, "remove"))
            keywords .= " remove"
         If (InStr(testu, "remove") && !InStr(keywords, "delete"))
            keywords .= " delete"
         If (InStr(testu, "erase") && !InStr(keywords, "delete"))
            keywords .= " delete"
         If (InStr(testu, "purge") && !InStr(keywords, "delete"))
            keywords .= " delete"
         If ((InStr(testu, "preference") || InStr(testu, "settings")) && !InStr(keywords, "prefs"))
            keywords .= " prefs config"
         fkwds := keywords ? fuzzifyString(keywords) : ""
         ffuncu := fuzzifyString(StrReplace(funcu, "menu"))
         indexu++
         objuA[indexu] := [gup[1], funcu, keywords, 1, 0, mena, gup[2], accel, flabel, fkwds, ffuncu]
         objuB[mena "-" klabelu] := indexu
      } Else
      {
         kLabelu := StrReplace(labelu, "&")
         gLabelu := kLabelu ? kLabelu : "Q" mena
         kfuncu := StrReplace(funcu, ":")
         objuC[kfuncu, 1] := gLabelu
         objuC[kfuncu, 2] := mena
         objuC[kfuncu, 3] := Trimmer(fuzzifyString(gLabelu))
         objuC[kfuncu, 4] := InStr(labelu, "&") ? SubStr(labelu, InStr(labelu, "&") + 1, 1) : ""
      }

      Menu, % mena, Add, % zLabelu, % funcu
      If (!InStr(funcu, ":") && InStr(actu, "Uncheck") && mustPreventMenus!=1)
      {
         objuA[indexu, 5] := -1
         Try Menu, % mena, Icon, % zLabelu, %mainCompiledPath%\resources\menu-checkable.ico
      }
   } Else If (RegExMatch(actu, "i)(disable|check)") && labelu)
   {
      kLabelu := StrReplace(labelu, "&")
      thisindexu := objuB[mena "-" klabelu]
      If (actu="Disable" || actu="Check/Disable")
         objuA[thisindexu, 4] := 0
      Else If (actu="Check" || actu="Check/Disable")
         objuA[thisindexu, 5] := 1
      Else If (mustPreventMenus!=1)
      {
         If InStr(actu, "Check")
            Menu, % mena, Icon, % zLabelu
      }

      If (actu="Check/Disable")
      {
         Menu, % mena, Check, % zLabelu
         Menu, % mena, Disable, % zLabelu
      } Else
         Menu, % mena, % actu, % zLabelu
   }
}

showThisMenu(menarg, forceIT:=0, manubarMode:=0, manuID:=0) {
   Static prevMenu, prevItems
   If (VisibleQuickMenuSearchWin=1 && mustPreventMenus!=1 && forceIT!=1 && omniBoxMode=0)
      closeQuickSearch()

   SetTimer, drawWelcomeImg, Off
   items := DllCall("GetMenuItemCount", "uptr", MenuGetHandle(menarg))
   If (manubarMode!=1)
   {
      If ((A_TickCount - lastOtherWinClose<100) && prevMenu=menarg && prevItems=items) || (mustPreventMenus=1)
         Return

      GetPhysicalCursorPos(mX, mY)
      If InStr(globalMenuOptions, "|")
      {
         klop := StrSplit(globalMenuOptions, "|")
         If (klop[1]=menarg)
         {
            mX := klop[2]
            mY := klop[3]
         }
      }
     ; ToolTip, % items "==" prevItems "|" menarg "==" prevMenu, , , 2
   } Else
   {
      SetTimer, setWinCloseZeit, Off
      hMenuBar := "0x" Format("{:x}", DllCall("GetMenu", "ptr", PVhwnd, "uptr"))
      rect := GetMenuItemRect(PVhwnd, hMenuBar, manuID - 1)
      mX := Trim(rect.left)
      mY := Trim(rect.bottom)
      mYz := Trim(rect.top)
      mH := max(rect.bottom, rect.top) - min(rect.bottom, rect.top)
      mW := max(rect.left, rect.right) - min(rect.left, rect.right)
      interfaceThread.ahkFunction("ShowClickHalo", mX, mYz, mW, mH, 1)
   }

   mouseTurnOFFtooltip()
   addJournalEntry("Invoked UI menu: " menarg)
   Global lastOtherWinClose := A_TickCount
   prevItems := items
   prevMenu := menarg
   globalMenuOptions := 0
   okay := (!AnyWindowOpen || imgEditPanelOpened=1) && (drawingShapeNow!=1) ? 1 : 0
   idu := (manubarMode=1) ? klop[2] : "reset"

   interfaceThread.ahkFunction("menuFlyoutDisplay", "yes", mX, mY, okay, uiUseDarkMode, A_ScriptHwnd, idu)
   Sleep, 0
   ; SetMenuInfo(MenuGetHandle(menarg), 0, 1)
   Menu, % menarg, Show, % mX, % mY
   ; showDelayedTooltip("Menu item selected:`n" A_ThisMenuItem " [" A_ThisMenu "]")

   isFakeWin := (isNowFakeWinOpen=1 && AnyWindowOpen>0) ? 1 : 0
   ; If (isFakeWin=0)
      ; SetTimer, setWinCloseZeit, -185, 900
   setWinCloseZeit()
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
   Global lastWinDrag := A_TickCount
   Global lastOtherWinClose := A_TickCount + 100
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
}

setWinCloseZeit() {
   interfaceThread.ahkPostFunction("menuFlyoutDisplay", "no", 1, 1, 0, uiUseDarkMode, A_ScriptHwnd, "reset")
   ; doSuspendu(0)
}

deleteMenus() {
    If (mustPreventMenus=1)
       Return

    Static menusList := "PVmenu|PValpha|PVtFileOpen|PVtFileImgAct|PVselSize|PVselRatio|PVimgTransform|PVimgCreate|PVimgFilters|PVimgDraw|PVperfs|PVfileSel|PVslide|PVnav|PVview|PVfList|PVtActFile|PVfilesActs|PVprefs|PvUIprefs|PVfaves|PVopenF|PVsort|PVedit|PVselv|PVsounds|PvImgAdapt|PVimgColorsFX|PVimgSdepth|PVimgVProt|PVimgHistos|PVlTools|PVstats|PVhelp|PvUItoolbarMenu|PVshapeTension|PVselAlign"
    kMenu(0, "Reset", 0)
    Loop, Parse, menusList, |
        Try Menu, % A_LoopField, Delete
}

MenuSetImageAdaptAll() {
   IMGresizingMode := 0
   ToggleImageSizingMode()
}

MenuSetImageAdaptLarge() {
   IMGresizingMode := 1
   ToggleImageSizingMode()
}

MenuSetImageOriginalFixed() {
   IMGresizingMode := 2
   ToggleImageSizingMode()
}

MenuSetImageCustomZoom() {
   IMGresizingMode := 3
   ToggleImageSizingMode()
}

MenuSetImageStretchedWin() {
   IMGresizingMode := 4
   ToggleImageSizingMode()
}

MenuSetLockSelRatioUnlocked() {
   lockSelectionAspectRatio := 0
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioSelu() {
   lockSelectionAspectRatio := 1
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioWindow() {
   lockSelectionAspectRatio := 2
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioImage() {
   lockSelectionAspectRatio := 3
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioSquare() {
   lockSelectionAspectRatio := 4
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioSDTV() {
   lockSelectionAspectRatio := 5
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatio35mmFilm() {
   lockSelectionAspectRatio := 6
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioHDTV() {
   lockSelectionAspectRatio := 7
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioWide() {
   lockSelectionAspectRatio := 8
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioPhone() {
   lockSelectionAspectRatio := 9
   toggleImgSelectionAspectRatio()
}

MenuSetColorModeOriginal() {
   imgFxMode := 0
   ToggleImgFX(1)
}

MenuSetColorModePersonalized() {
   imgFxMode := 1
   ToggleImgFX(1)
}

MenuSetColorModeAuto() {
   imgFxMode := 2
   ToggleImgFX(1)
}

MenuSetColorModeGrayscale() {
   imgFxMode := 3
   ToggleImgFX(1)
}

MenuSetColorModeRedC() {
   imgFxMode := 4
   ToggleImgFX(1)
}

MenuSetColorModeGreenC() {
   imgFxMode := 5
   ToggleImgFX(1)
}

MenuSetColorModeBlueC() {
   imgFxMode := 6
   ToggleImgFX(1)
}

MenuSetColorModeAlphaC() {
   imgFxMode := 7
   ToggleImgFX(1)
}

MenuSetColorModeInverted() {
   imgFxMode := 8
   ToggleImgFX(1)
}

MenuSetColorModeSepia() {
   imgFxMode := 9
   ToggleImgFX(1)
}

MenuSetVPhistoNone() {
   showHistogram := 0
   ToggleImgHistogram(1)
}

MenuSetVPhistoLuminance() {
   showHistogram := 1
   ToggleImgHistogram(1)
}

MenuSetVPhistoRed() {
   showHistogram := 2
   ToggleImgHistogram(1)
}

MenuSetVPhistoGreen() {
   showHistogram := 3
   ToggleImgHistogram(1)
}

MenuSetVPhistoBlue() {
   showHistogram := 4
   ToggleImgHistogram(1)
}

MenuSetVPhistoAll() {
   showHistogram := 5
   ToggleImgHistogram(1)
}

MenuSetVPgraphHistoPeaks() {
   histogramMode := 2
   ToggleHistogramMode()
}

MenuSetVPgraphHistoMids() {
   histogramMode := 1
   ToggleHistogramMode()
}

MenuSetVPgraphHistoLows() {
   histogramMode := 0
   ToggleHistogramMode()
}

MenuSetSelectionShapeRect() {
   toggleEllipseSelection(0)
}

MenuSetSelectionShapeEllipse() {
   toggleEllipseSelection(1)
}

MenuSetSelectionShapeFreeform() {
   toggleEllipseSelection(2)
}

MenuIncVPgridSize() {
   changeGridSize(1)
}

MenuDecVPgridSize() {
   changeGridSize(-1)
}

MenuResetImageColorDepth() {
   usrColorDepth := 0
   ToggleImgColorDepth(1)
}

MenuSetImageDepth2bits() {
   usrColorDepth := 1
   ToggleImgColorDepth(1)
}

MenuSetImageDepth3bits() {
   usrColorDepth := 2
   ToggleImgColorDepth(1)
}

MenuSetImageDepth4bits() {
   usrColorDepth := 3
   ToggleImgColorDepth(1)
}

MenuSetImageDepth5bits() {
   usrColorDepth := 4
   ToggleImgColorDepth(1)
}

MenuSetImageDepth6bits() {
   usrColorDepth := 5
   ToggleImgColorDepth(1)
}

MenuSetImageDepth7bits() {
   usrColorDepth := 6
   ToggleImgColorDepth(1)
}

MenuSetImageDepth8bits() {
   usrColorDepth := 7
   ToggleImgColorDepth(1)
}

MenuSetImageDepth16bits() {
   usrColorDepth := 8
   ToggleImgColorDepth(1)
}

MenuSelectionFlipH() {
   flipWHcustomShape("h")
}

MenuSelectionFlipV() {
   flipWHcustomShape("v")
}

MenuSelIncRotation() {
   changeSelRotation(1)
}

MenuSelDecRotation() {
   changeSelRotation(-1)
}

MenuSetVolumeDown() {
   ChangeVolume(-1)
}

MenuSetVolumeUp() {
   ChangeVolume(1)
}

MenuSetImgZoom(a, b) {
   zoomLevel := StrReplace(StrReplace(a, "`tNUM *"), "%")/100
   IMGresizingMode := 4
   customZoomAdaptMode := 0
   interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
   zoomLevel := clampInRange(zoomLevel, 0.01, 20)
   INIaction(1, "IMGresizingMode", "General")
   INIaction(1, "zoomLevel", "General")
   updateUIctrl()
   dummyTimerDelayiedImageDisplay(150)
}

MenuSetVProt(a, b) {
   vpIMGrotation := StrReplace(a, "°")
   interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
   INIaction(1, "vpIMGrotation", "General")
   updateUIctrl()
   dummyTimerDelayiedImageDisplay(150)
}

ToggleDBdefaultSQLsort() {
   prevFilesSortMode := 0
   IniSLDBWrite("prevFilesSortMode", prevFilesSortMode)
   INIaction(1, "prevOpenFolderPath", "General")
   showTOOLtip("Default sorting of the files is now set to none.`nTo set it otherwise,please choose a sorting mode in the Sort menu.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createMenuFilesSelections(whichMenu) {
   If (markedSelectFile>1)
   {
      kMenu(whichMenu, "Add", "&First`tCtrl+Home", "jumpToFilesSelBorderFirst")
      kMenu(whichMenu, "Add", "&Previous`tCtrl+Left", "navSelectedFilesPrev")
      kMenu(whichMenu, "Add", "&Next`tCtrl+Right", "navSelectedFilesNext")
      kMenu(whichMenu, "Add", "&Last`tCtrl+End", "jumpToFilesSelBorderLast")
      Menu, % whichMenu, Add
      kMenu(whichMenu, "Add", "Invert selection`tShift+I", "invertFilesSelection", "files list")
   }

   If (markedSelectFile>1 || EntryMarkedMoveIndex)
      kMenu(whichMenu, "Add", "Select none`tCtrl+D", "dropFilesSelection", "files list")
   kMenu(whichMenu, "Add", "Select all`tCtrl+A", "selectAllFiles", "files list")
   kMenu(whichMenu, "Add", "Select / deselect file`tTab / Space", "MenuMarkThisFileNow")
   kMenu(whichMenu, "Add", "Select &random", "PanelSelectRandomFiles")
   kMenu(whichMenu, "Add", "Select all in same folder`tE", "QuickSelectFilesSameFolder")
   kMenu(whichMenu, "Add", "Select ine&xistent files", "SelectFilesDead", "missing dead")
   kMenu(whichMenu, "Add", "Select by &given string", "SelectFilesSearchIndex", "text matching")
   kMenu(whichMenu, "Add", "Select fa&vourited", "SelectFilesFavourited")
   kMenu(whichMenu, "Add", "Select &already seen images", "SelectFilesAlreadySeen")
   If (testIsDupesList()=1)
      kMenu(whichMenu, "Add", "Select the other images in &dupes group`tS", "keepSelectedDupeInGroup")

   If (markedSelectFile>1)
   {
      Menu, % whichMenu, Add
      kMenu(whichMenu, "Add", "Revie&w selected files`tR", "PanelReviewSelectedFiles")
      kMenu(whichMenu, "Add", "&Calculate total files size`tAlt+L", "CalculateSelectedFilesSizes", "file details")
      kMenu(whichMenu, "Add", "Filter files list to selection`tCtrl+Tab", "filterToFilesSelection")
   }

}

InvokeRecentMenu(givenCoords:=0) {
   deleteMenus()
   createMenuOpenRecents("simple")
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVopenF") : givenCoords
   showThisMenu("PVopenF")
}

InvokeFavesMenu(givenCoords:=0) {
   deleteMenus()
   createMenuFavourites()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVfaves") : givenCoords
   showThisMenu("PVfaves")
}

createMenuOpenRecents(modus:=0) {
   countItemz := 0
   If (modus!="simple")
   {
      kMenu("PVopenF", "Add", "&Image or slideshow`tCtrl+O", "OpenDialogFiles", "open image files")
      kMenu("PVopenF", "Add", "&Folder recursively`tShift+O", "OpenFolders", "open image folder files")
      kMenu("PVopenF", "Add", "&New QPV instance`tCtrl+Shift+N", "OpenNewQPVinstance")
      If (maxFilesIndex<1 || !CurrentSLD)
         kMenu("PVopenF", "Add", "Insert file(s)`tInsert", "addNewFile2list", "images list")
   }

   If (allowRecordHistory=1 && mustPreventMenus!=1)
   {
      Menu, PVopenF, Add,
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      friendlyLabel := (userPrivateMode=1) ? "*:\*******\******.***" : PathCompact(Trimmer(LastOpenedImg), 30)
      If (RegExMatch(Trimmer(LastOpenedImg), RegExFilesPattern) && FileRexists(Trimmer(LastOpenedImg)))
         kMenu("PVopenF", "Add", "&0. " friendlyLabel, "MenuOpenLastImg")

      historyList := readRecentEntries(0, 0)
      Loop, Parse, historyList, `n
      {
         If (A_Index>10)
            Break

         countItemz++
         testThis := StrReplace(A_LoopField, "|")
         If (StrLen(A_LoopField)<4 || !FileExist(testThis))
            Continue

         entryu := (userPrivateMode=1) ? "*:\*******\******.***" : PathCompact(testThis, 30)
         If InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= "\" ; entryu
         If !InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= " (*)"
         If RegExMatch(A_LoopField, sldsPattern)
            entryu := "# " entryu

         kMenu("PVopenF", "Add", "&" countItemz ". " entryu, "OpenRecentEntry")
      }

      Menu, PVopenF, Add, 
      If FolderExist(prevFileSavePath)
         aListu := prevFileSavePath "`n"
      If (FolderExist(prevFileMovePath) && !InStr(aListu, prevFileMovePath "`n"))
         aListu .= prevFileMovePath "`n"
      If (FolderExist(prevOpenFolderPath) && !InStr(aListu, prevOpenFolderPath "`n"))
         aListu .= prevOpenFolderPath "`n"

      Loop, Parse, aListu, `n
      {
         If !A_LoopField
            Continue

         friendlyLabel := (userPrivateMode=1) ? "*:\*******\******.***" : PathCompact(A_LoopField, 30)
         kMenu("PVopenF", "Add", "O" A_Index ". " friendlyLabel, "OpenRecentEntry")
         ; kMenu("PVopenF", "Add", "% "O" A_Index ". " SubStr(A_LoopField, -30)", "OpenRecentEntry")
      }
   }

   Menu, PVopenF, Add, 
   If (countItemz>0 || mustPreventMenus=1)
      kMenu("PVopenF", "Add", "&Erase history list", "EraseOpenedHistory", "files")

   kMenu("PVopenF", "Add/Uncheck", "&Record recently opened", "ToggleRecordOpenHistory", "files")
   If (allowRecordHistory=1)
      kMenu("PVopenF", "Check", "&Record recently opened")
}

createMenuFavourites() {
   If (mustPreventMenus!=1)
      favesList := readMiniFavesEntries()

   Loop, Parse, favesList, `n
   {
      If (A_Index>15)
         Break

      countItemz++
      If !Trimmer(A_LoopField)
         Continue

      entryu := (userPrivateMode=1) ? "*:\*******\******.***" : PathCompact(A_LoopField, 30)
      If StrLen(entryu)>3
      {
         countFaved++
         kMenu("PVfaves", "Add", "&" countItemz ". " entryu, "OpenFavesEntry")
      }
   }

   If !countFaved
   {
      kMenu("PVfaves", "Add", "No image added to favourites", "dummy")
      kMenu("PVfaves", "Disable", "No image added to favourites")
   } Else If (userAddedFavesCount>15)
   {
      moru := userAddedFavesCount - 15
      kMenu("PVfaves", "Add", "... and another " moru " images", "dummy")
      kMenu("PVfaves", "Disable", "... and another " moru " images")
   }

   Menu, PVfaves, Add
   kMenu("PVfaves", "Add/Uncheck", "&Cycle favourites list on open", "ToggleCycleFavesOpen")
   If (cycleFavesOpenIMG=1)
      kMenu("PVfaves", "Check", "&Cycle favourites list on open")

   kMenu("PVfaves", "Add", "&Add/remove current image to favourites`tB", "ToggleImgFavourites")
   If !(maxFilesIndex>0 && CurrentSLD)
      kMenu("PVfaves", "Disable", "&Add/remove current image to favourites`tB")

   If !countFaved
      IniAction(0, "userAddedFavesCount", "General", 4)

   If (countFaved>1 || userAddedFavesCount>1)
   {
      kMenu("PVfaves", "Add", "&Manage the favourites list", "retrieveFavesAsList", "open faves favorites")
      kMenu("PVfaves", "Add", "&Remove all from favourites", "eraseAllFavedIMGs")
   }
}

createMenuStatistics() {
   If (mustPreventMenus!=1)
      kMenu("PVstats", "Add", "Open main panel", "PanelWrapperFilesStats")
   kMenu("PVstats", "Add", "&Files stats panel", "PanelIndexedFilesStats")
   kMenu("PVstats", "Add", "&Image properties stats panel", "PanelIndexedImagesStats")
   If (mustRecordSeenImgs=1)
      kMenu("PVstats", "Add", "&Seen images stats panel", "PanelSeenStats", "stats")

   If (mustPreventMenus=1)
      kMenu("PVstats", "Add", "&Remove all from favourites", "eraseAllFavedIMGs")

   Menu, PVstats, Add
   kMenu("PVstats", "Add", "&Collect file details", "BtnCollectFileInfos")
   kMenu("PVstats", "Add", "Collect image &properties", "BtnCollectImageInfos")
   kMenu("PVstats", "Add", "Collect image &histogram data", "BtnCollectHistoInfos")
   If (mustPreventMenus=1)
      kMenu("PVstats", "Add", "C&reate custom files list filter`tCtrl+F", "PanelEnableFilesFilter")
}

createMenuFilesIndexOptions() {
   StringRight, infoPrevMovePath, prevFileMovePath, 25
   infoMenuRefresh := RegExMatch(CurrentSLD, sldsPattern) ? "Reload .SLD file" : "Refresh opened folder(s)"
   pathu := PathCompact(CurrentSLD, 40)
   If pathu
   {
      kMenu("PVfList", "Add", infoMenuRefresh "`tShift+F5", "RefreshFilesList", "reload refresh list files")
      If RegExMatch(CurrentSLD, sldsPattern)
      {
         kMenu("PVfList", "Add", pathu, "RefreshFilesList")
         kMenu("PVfList", "Disable", pathu)
      }
   }

   Menu, PVfList, Add,
   kMenu("PVfList", "Add", "Import list / insert file(s)`tInsert", "addNewFile2list")
   kMenu("PVfList", "Add", "&Add folder(s)`tShift+Insert", "addNewFolder2list")
   kMenu("PVfList", "Add", "Mana&ge folder(s) list`tAlt+U", "PanelDynamicFolderzWindow")
   If (maxFilesIndex>1)
   {
      kMenu("PVfList", "Add", "Save files list as &.SLD`tCtrl+Shift+S", "PanelSaveSlideShowu")
      Menu, PVfList, Add,
      If (thumbsDisplaying=1 && !markedSelectFile)
      {
         If !EntryMarkedMoveIndex
            kMenu("PVfList", "Add", "Mar&k entry to reorder`tX", "moveMarkedEntryNow")
         Else
            kMenu("PVfList", "Add", "Move mar&ked entry to focused index`tX", "moveMarkedEntryNow")
      } Else If (thumbsDisplaying=1 && markedSelectFile>1)
            kMenu("PVfList", "Add", "Move/regroup entries to focused index`tShift+X", "MenuMoveMarkedEntries")

      If !markedSelectFile
      {
         kMenu("PVfList", "Add", "&Modify focused index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
         kMenu("PVfList", "Add", "Remove focused inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
      }

      kMenu("PVfList", "Add/Uncheck", "Auto-remove entries of dead files", "ToggleAutoRemEntries")
      If (autoRemDeadEntry=1)
         kMenu("PVfList", "Check", "Auto-remove entries of dead files")

      Menu, PVfList, Add,
      ; If RegExMatch(CurrentSLD, sldsPattern)
      labelu := (SLDtypeLoaded=3) ? "Clean inexistent files entries" : "Clean &duplicate and inexistent entries"
      kMenu("PVfList", "Add", labelu, "cleanDeadFilesList", "remove dead files erase")
      If StrLen(DynamicFoldersList)>6
         kMenu("PVfList", "Add", "&Regenerate the entire list", "RegenerateEntireList")

      labelu := (FileExist(CurrentSLD) && RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? "&Update files list selectively`tCtrl+U" : "Folders containin&g indexed files`tCtrl+U"
      kMenu("PVfList", "Add", labelu, "PanelStaticFolderzManager", "folders manage")
      If (mustRecordSeenImgs=1)
         kMenu("PVfList", "Add", "Remove alread&y seen images", "removeFilesListSeenImages", "eliminate")
      If !InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
         kMenu("PVfList", "Add", "Remove fa&vourited images from list", "removeFilesListFavouritedImages", "eliminate")

      Menu, PVfList, Add, 
      kMenu("PVfList", "Add", "&Find duplicate images", "PanelFindDupes")
      If (mustPreventMenus=1)
      {
         createMenuStatistics()
         kMenu("PVfList", "Add", "&Statistics main panel", "PanelWrapperFilesStats")
         kMenu("PVfList", "Add", "&Statistics", ":PVstats")
      } Else
         kMenu("PVfList", "Add", "&Statistics", "PanelWrapperFilesStats", "files index list")

      kMenu("PVfList", "Add", "&Keywords indexer", "PanelKeywordsDetector")
      kMenu("PVfList", "Add", "Searc&h index`tCtrl+F3", "PanelSearchIndex", "files list")
      kMenu("PVfList", "Add", "Search and re&place`tCtrl+H", "PanelSearchAndReplaceIndex", "files index list")
      kMenu("PVfList", "Add", "&Index filters`tCtrl+F", "PanelEnableFilesFilter", "files list")
      If (StrLen(filesFilter)>1 && !testIsDupesList())
         kMenu("PVfList", "Check", "&Index filters`tCtrl+F")
   }
}

createMenuInterfaceOptions() {
   If (AnyWindowOpen && imgEditPanelOpened=1)
   {
      kMenu("PvUIprefs", "Add/Uncheck", "&Collapse tool panel`tF8", "toggleImgEditPanelWindow")
      If (panelWinCollapsed=1)
         kMenu("PvUIprefs", "Check", "&Collapse tool panel`tF8")
      Menu, PvUIprefs, Add
      If (showMainMenuBar=1)
      {
         kMenu("PvUIprefs", "Add", "&Search menu options`t;", "PanelQuickSearchMenuOptions", "keyboard")
         Menu, PvUIprefs, Add
      }
   }

   If (drawingShapeNow!=1)
   {
      infoThumbsList := defineListViewModes()
      infoThumbsMode := (thumbsDisplaying=1) ? "Switch to image view" : "Switch to " infoThumbsList " list view"
      If (thumbsDisplaying=1 && showMainMenuBar!=1)
         kMenu("PvUIprefs", "Add", "C&ycle view modes`tL", "toggleListViewModeThumbs")

      If (maxFilesIndex>0 && !AnyWindowOpen)
         kMenu("PvUIprefs", "Add", infoThumbsMode "`tEnter/MClick", "MenuDummyToggleThumbsMode")
      If (maxFilesIndex>1 && !AnyWindowOpen && prevOpenedWindow[2])
         kMenu("PvUIprefs", "Add", "Open pre&vious panel`tF8", "openPreviousPanel", "show")

      If (thumbsDisplaying!=1 && !AnyWindowOpen)
         kMenu("PvUIprefs", "Add", "&Toggle full-screen mode`tF11", "ToggleFullScreenMode")

      If (thumbsDisplaying!=1)
      {
         kMenu("PvUIprefs", "Add/Uncheck", "&Touch screen mode", "ToggleTouchMode")
         If (TouchScreenMode=1)
            kMenu("PvUIprefs", "Check", "&Touch screen mode")
      }

      Menu, PvUIprefs, Add
   }

   If (!isWinXP && A_OSVersion!="WIN_7")
   {
      kMenu("PvUIprefs", "Add/Uncheck", "Dar&k mode", "ToggleDarkModus", "disability handicap eyes eyesight black display")
      If (uiUseDarkMode=1)
         kMenu("PvUIprefs", "Check", "Dar&k mode")
   }

   kMenu("PvUIprefs", "Add/Uncheck", "&Large UI fonts", "ToggleLargeUIfonts", "disability handicap eyes eyesight large display")
   If (PrefsLargeFonts=1)
      kMenu("PvUIprefs", "Check", "&Large UI fonts")

   If (AnyWindowOpen!=14)
   {
      kMenu("PvUIprefs", "Add", "Increase viewport text size`tCtrl+Plus", "MenuChangeZoomPlus", "disability handicap eyes eyesight large")
      kMenu("PvUIprefs", "Add", "Decrease viewport text size`tCtrl+Minus", "MenuChangeZoomMinus", "disability  handicap eyes eyesight large")
   }

   Menu, PvUIprefs, Add
   kMenu("PvUIprefs", "Add/Uncheck", "&Always on top", "ToggleAllonTop", "window")
   If (getTopMopStyle(PVhwnd)=1)
      kMenu("PvUIprefs", "Check", "&Always on top")

   If (thumbsDisplaying!=1 && drawingShapeNow!=1 && !AnyWindowOpen)
   {
      kMenu("PvUIprefs", "Add/Uncheck", "&Hide title bar", "ToggleTitleBaru", "window")
      If (getCaptionStyle(PVhwnd)=1)
         kMenu("PvUIprefs", "Check", "&Hide title bar")
   }

   Menu, PvUIprefs, Add
   If (AnyWindowOpen!=14 && imgEditPanelOpened!=1 && drawingShapeNow!=1)
   {
      keyword := (folderTreeWinOpen=1) ? " hide" : " display"
      kMenu("PvUIprefs", "Add/Uncheck", "Show &folders tree panel`tF4", "MenuPanelFoldersTree", "window treeview explore" keyword)
      If (folderTreeWinOpen=1)
         kMenu("PvUIprefs", "Check", "Show &folders tree panel`tF4")
   }

   If (!throwErrorNoImageLoaded(1) && thumbsDisplaying!=1 && drawingShapeNow!=1)
   {
      createMenuVPhudHisto()
      kMenu("PvUIprefs", "Add", "Show histogram", ":PVimgHistos")
   }

   If (drawingShapeNow!=1)
   {
      keyword := (showMainMenuBar=1) ? " hide" : " display"
      kMenu("PvUIprefs", "Add/Uncheck", "Show &menu bar`tF10", "ToggleQuickBaru", "toolbar" keyword)
      If (showMainMenuBar=1)
         kMenu("PvUIprefs", "Check", "Show &menu bar`tF10")
   }

   keyword := (ShowAdvToolbar=1) ? "hide" : "display"
   kMenu("PvUIprefs", "Add/Uncheck", "Show &toolbar`tShift+F10", "toggleAppToolbar", keyword)
   If (ShowAdvToolbar=1)
      kMenu("PvUIprefs", "Check", "Show &toolbar`tShift+F10")

   If (maxFilesIndex>0 && CurrentSLD && drawingShapeNow!=1)
   {
      keyword := (showInfoBoxHUD=1) ? "hide" : "show display"
      If (AnyWindowOpen!=14)
      {
         kMenu("PvUIprefs", "Add/Uncheck", "&Show viewport Info-box`tI", "ToggleInfoBoxu", "files information properties " keyword)
         If (showInfoBoxHUD>=1)
            kMenu("PvUIprefs", "Check", "&Show viewport Info-box`tI")
      }
   }

   If (maxFilesIndex>0 && CurrentSLD)
   {
      keyword := (showHUDnavIMG=1) ? " hide" : " show display"
      friendly := (thumbsDisplaying=1) ? "Image previe&w box`tZ" : "Auto-display image navi&gator`tZ"
      kMenu("PvUIprefs", "Add/Uncheck", friendly, "ToggleImgNavBox", "map" keyword)
      If (showHUDnavIMG=1)
         kMenu("PvUIprefs", "Check", friendly)
   }

   If (maxFilesIndex>0 && CurrentSLD && thumbsDisplaying!=1)
   {
      Menu, PvUIprefs, Add
      kMenu("PvUIprefs", "Add/Uncheck", "&Ambiental textured background", "ToggleTexyBGR", "viewport image performance")
      If (usrTextureBGR=1)
         kMenu("PvUIprefs", "Check", "&Ambiental textured background")
   }

   If (!AnyWindowOpen && drawingShapeNow!=1)
   {
      Menu, PvUIprefs, Add
      kMenu("PvUIprefs", "Add", "Additional settings`tF12", "PanelPrefsWindow")
   }
}

EraseOpenedHistory() {
   Loop, 15
       IniWrite, 0, % mainRecentsFile, RecentOpen, E%A_Index%
   IniWrite, 0, % mainSettingsFile, General, LastOpenedImg
}

OpenRecentEntry(menuItem) {
  testOs := menuItem
  initQPVmainDLL()
  If askAboutFileSave(" and another image will be loaded")
     Return

  If askAboutSlidesListSave()
     Return

  If askAboutFilesSelect("discard it")
     Return

  startZeit := A_TickCount
  If RegExMatch(testOs, "i)^(o1\. )")
     openThisu := prevFileSavePath
  Else If RegExMatch(testOs, "i)^(o2\. )")
     openThisu := prevFileMovePath
  Else If RegExMatch(testOs, "i)^(o3\. )")
     openThisu := prevOpenFolderPath

  If openThisu
  {
     If (SLDtypeLoaded=3)
     {
        SLDtypeLoaded := 0
        activeSQLdb.CloseDB()
     }

     PopulateIndexFilesStatsInfos("kill")
     SlidesMusicSong := ""
     coreOpenFolder("|" openThisu, 1, 0, 1)
     currentFilesListModified := 0
     interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
     SetTimer, createGUItoolbar, -100
     SetTimer, TriggerMenuBarUpdate, -90
     If (maxFilesIndex>0)
        SLDtypeLoaded := 1
     ; Else resetMainWin2Welcome()
     Return
  }

  openThisu := SubStr(testOs, 2, InStr(testOs, ". ")-2)
  IniRead, newEntry, % mainRecentsFile, RecentOpen, E%openThisu%, @
  ; MsgBox, %openthisu% -- %newentry%
  newEntry := Trimmer(newEntry)
  If StrLen(newEntry)>4
  {
     If (SLDtypeLoaded=3)
     {
        SLDtypeLoaded := 0
        activeSQLdb.CloseDB()
     }

     If RegExMatch(newEntry, sldsPattern)
     {
        OpenSLD(newEntry)
     } Else
     {
        PopulateIndexFilesStatsInfos("kill")
        prevOpenFolderPath := StrReplace(newEntry, "|")
        If FolderExist(prevOpenFolderPath)
           INIaction(1, "prevOpenFolderPath", "General")
        coreOpenFolder(newEntry, 1, 0, 1)
        currentFilesListModified := 0
        SlidesMusicSong := ""
        interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
        If (maxFilesIndex>0)
           SLDtypeLoaded := 1

        SetTimer, createGUItoolbar, -100
        SetTimer, TriggerMenuBarUpdate, -90
        ; Else resetMainWin2Welcome()
     }
  }
  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

OpenFavesEntry(menuItem) {
  testOs := menuItem
  openThisu := SubStr(testOs, 2, InStr(testOs, ". ")-2)
  If (InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") && maxFilesIndex>500)
  {
     currentFileIndex := openThisu
     dummyTimerDelayiedImageDisplay(50)
     Return
  }

  If askAboutFileSave(" and the selected image from favourites will be loaded")
     Return

  If askAboutSlidesListSave()
     Return

  If askAboutFilesSelect("discard it")
     Return

  startZeit := A_TickCount
  contentu := readMiniFavesEntries()
  Loop, Parse, contentu, `n, `r
  {
      If (openThisu=A_Index)
      {
         newEntry := Trimmer(A_LoopField)
         Break
      }
  }

  ; IniRead, newEntry, % mainRecentsFile, favourites, E%openThisu%, @
  If !FileRexists(newEntry)
  {
     msgResult := msgBoxWrapper(appTitle ": ERROR", "The file you are trying to open seems to no longer exist. Would you like to remove it from the favourites list?", 4, 0, "question")
     If InStr(msgResult, "yes")
        ToggleImgFavourites(newEntry, "rem")
  } Else If (cycleFavesOpenIMG=1 && newEntry!="@" && StrLen(newEntry)>2)
  {
     retrieveFavesAsList(openThisu)
     Return
  } Else If (newEntry!="@" && StrLen(newEntry)>2)
  {
     MenuOpenLastImg(newEntry)
     resultedFilesList[currentFileIndex, 5] := 1
     currentImgModified := 0
     SlidesMusicSong := ""
     interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
  }

  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

RegAction(act, var, section:="PanelOptions", type:=0, mini:=0, maxy:=0, forcedDef:="") {
    INIaction(act, var, section, type, mini, maxy, forcedDef,, 1)
}

INIaction(act, var, section, type:=0, mini:=0, maxy:=0, forcedDef:="", iniFile:="", storeReg:=0) {
   thisIniFile := iniFile ? iniFile : mainSettingsFile
   varValue := %var%
   If (act=1)
   {
      If (var="FillAreaCustomShape")
         varValue := SubStr(varValue, 1, 64321)

      If (storeReg=1)
         RegWrite, REG_SZ, % QPVregEntry "\" section, %var%, %varValue%
      Else
         IniWrite, %varValue%, % thisIniFile, %section%, %var%
      If ErrorLevel
         addJournalEntry("Error saving INI settings (" var ") in " thisIniFile " | " section)
   } Else
   {
      defaultu := (forcedDef!="") ? forcedDef : %var%
      If (storeReg=1)
         RegRead, %var%, % QPVregEntry "\" section, %var%
      Else
         IniRead, %var%, % thisIniFile, %section%, %var%, %varValue%

      loadedValue := %var%
      If (ErrorLevel && loadedValue="") || (ErrorLevel && storeReg=1)
         loadedValue := defaultu

      If ErrorLevel
         addJournalEntry("Error loading INI settings (" var ") in " thisIniFile " | " section)

      If (type=1) ; binary
      {
         loadedValue := (Round(loadedValue)=0 || Round(loadedValue)=1) ? Round(loadedValue) : defaultu
         %var% := loadedValue
      } Else If (type=2)  ; range min/max
      {
         If !isNumber(loadedValue)
         {
            %var% := defaultu
         } Else
         {
            loadedValue := clampInRange(loadedValue, mini, maxy)
            %var% := loadedValue
         }
      } Else If (type=3)  ; HEX colour
      {
         loadedValue := Trimmer(loadedValue)
         If (loadedValue ~= "[^[:xdigit:]]") || (StrLen(loadedValue)!=6)
            loadedValue := defaultu
         %var% := loadedValue
      } Else If (type=4)  ; isNumber
      {
         If !isNumber(loadedValue)
            %var% := defaultu
         Else
            %var% := loadedValue
      } Else If (!(loadedValue ~= "i)^(.\:\\.)") && type=6)
      {
         %var% := defaultu
      } Else If (loadedValue="error" && type=5)
         %var% := defaultu
   }
}

ToggleFullScreenMode() {
   Static prevState := 1, o_TouchScreenMode := "a"
   If (drawingShapeNow=1 && isImgEditingNow())
      Return

   If (thumbsDisplaying=1)
   {
      ; o_TouchScreenMode := TouchScreenMode
      ToggleThumbsMode()
      Return
   }

  ; If (tempBtnVisible!="null")
     ; DestroyTempBtnGui("now")

  prevState := !prevState
  If (prevState=0)
  {
     If (showMainMenuBar=1)
     {
        showMainMenuBar := 0
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        Win_SetMenu(PVhwnd, 0)
        TriggerMenuBarUpdate()
     }
     ; o_TouchScreenMode := TouchScreenMode
     If (userAllowWindowDrag=1)
        TouchScreenMode := 0
     isTitleBarVisible := 0
     If (editingSelectionNow=1)
       ToggleEditImgSelection()
     WinSet, Style, -0xC00000, ahk_id %PVhwnd%
     WinMaximize, ahk_id %PVhwnd%
  } Else
  {
     ; If (o_TouchScreenMode!="a")
     ;    TouchScreenMode := o_TouchScreenMode
     isTitleBarVisible := 1
     WinSet, Style, +0xC00000, ahk_id %PVhwnd%
     WinRestore, ahk_id %PVhwnd%
     INIaction(0, "showMainMenuBar", "General", 1)
     INIaction(0, "TouchScreenMode", "General", 1)
     If (showMainMenuBar=1)
     {
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        TriggerMenuBarUpdate()
     }
  }

  interfaceThread.ahkassign("isTitleBarVisible", isTitleBarVisible)
  interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
  interfaceThread.ahkassign("userAllowWindowDrag", userAllowWindowDrag)
  ; ToolTip, % "l=" isTitleBarVisible " kl=" kl , , , 2
  SetTimer, dummySetTlbrVisibility, -300
  SetTimer, dummyFullScreenButtons, -350
}

dummySetTlbrVisibility() {
  kl := getCaptionStyle(PVhwnd)
  If (ShowAdvToolbar=1 && kl=1)
     Gui, OSDguiToolbar: Hide
  Else If (ShowAdvToolbar=1 && kl=0)
     Gui, OSDguiToolbar: Show, NoActivate
}

dummyFullScreenButtons() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  friendly .= (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1) ? "`nAllow window dragging: ENABLED" : "`nAllow window dragging: DISABLED"
  friendly := Trimmer(friendly)
  If (editingSelectionNow=1 || showHistogram>1 || showInfoBoxHUD>=1)
  {
     2ndLabel := "Hide viewport elements"
     2ndact := "turnOffViewportStuff"
  }

  If (userAllowWindowDrag=1 && isTitleBarVisible=0)
  {
     1stLabel := "Deactivate window dragging"
     1stact := "toggleWindowDraggableMode"
  } Else If (userAllowWindowDrag=0 && isTitleBarVisible=0)
  {
     1stLabel := "Allow window dragging"
     1stact := "toggleWindowDraggableMode"
  } Else ; If (isTitleBarVisible=1)
  {
     1stLabel := "Interface options"
     1stact := "OpenUImenu"
  }

  showTOOLtip(friendly)
  CreateGuiButton(1stLabel ",," 1stact "||" 2ndLabel ",," 2ndact, "force", msgDisplayTime + 500)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleWindowDraggableMode() {
   userAllowWindowDrag := !userAllowWindowDrag
   If (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1)
      TouchScreenMode := 0
   Else If (userAllowWindowDrag=0)
      INIaction(0, "TouchScreenMode", "General", 1)

   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   interfaceThread.ahkassign("isTitleBarVisible", isTitleBarVisible)
   interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
   interfaceThread.ahkassign("userAllowWindowDrag", userAllowWindowDrag)
   INIaction(1, "userAllowWindowDrag", "General")
}

turnOffViewportStuff() {
   If (showHistogram>1 || showInfoBoxHUD>=1)
      ToggleHistoInfoBoxu()
   If (editingSelectionNow=1)
      ToggleEditImgSelection()
   DestroyTempBtnGui("now")
}

ToggleAllonTop() {
   isAlwaysOnTop := !isAlwaysOnTop
   WinSet, AlwaysOnTop, % isAlwaysOnTop, ahk_id %PVhwnd%
   INIaction(1, "isAlwaysOnTop", "General")
   interfaceThread.ahkassign("isAlwaysOnTop", isAlwaysOnTop)
   friendly := (isAlwaysOnTop=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Window always on top: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleEasySlideStop() {
   easySlideStoppage := !easySlideStoppage
   INIaction(1, "easySlideStoppage", "General")
}

ToggleSlidesFXmode() {
   slidesFXrandomize := !slidesFXrandomize
   INIaction(1, "slidesFXrandomize", "General")
   interfaceThread.ahkassign("slidesFXrandomize", slidesFXrandomize)
   friendly := (slidesFXrandomize=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Randomize colour FX during slideshows:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSelKeepRatioRotation() {
   rotateSelBoundsKeepRatio := !rotateSelBoundsKeepRatio
   INIaction(1, "rotateSelBoundsKeepRatio", "General")
   friendly := (rotateSelBoundsKeepRatio!=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Distort selection on rotation:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (editingSelectionNow=1 && thumbsDisplaying!=1)
      SetTimer, dummyRefreshImgSelectionWindow, -10
}

ToggleGIFsPlayEntirely() {
   allowGIFsPlayEntirely := !allowGIFsPlayEntirely
   INIaction(1, "allowGIFsPlayEntirely", "General")
   friendly := (allowGIFsPlayEntirely=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Allow GIFs play entirely during slideshows:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleRecordSeenImages() {
   mustRecordSeenImgs := !mustRecordSeenImgs
   If (sqlFailedInit=1 && mustRecordSeenImgs=1)
   {
      mustRecordSeenImgs := 0
      msgBoxWrapper(appTitle ": ERROR", "An unknown error occured when attempting to initialize SqlLite Database.`n`nFeature not available.", 0, 0, "error")
   }

   INIaction(1, "mustRecordSeenImgs", "General")
   friendly := (mustRecordSeenImgs=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Record images seen through QPV: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSkipSeenIMGs() {
   skipSeenImageSlides := !skipSeenImageSlides
   INIaction(1, "skipSeenImageSlides", "General")
   friendly := (skipSeenImageSlides=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Skip already seen images: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAutoResetImageView() {
   If (AnyWindowOpen=10)
      GuiControlGet, resetImageViewOnChange, SettingsGUIA:, resetImageViewOnChange
   Else
      resetImageViewOnChange := !resetImageViewOnChange

   INIaction(1, "resetImageViewOnChange", "General")
   If !AnyWindowOpen
   {
      friendly := (resetImageViewOnChange=1) ? "ACTIVATED" : "DEACTIVATED"
      showTOOLtip("Reset viewing options on image change: " friendly)
      SetTimer, RemoveTooltip, % -msgDisplayTime 
   }
}

toggleListViewModeThumbs() {
   If (thumbsDisplaying!=1)
      Return

   thumbsListViewMode++
   If (thumbsListViewMode>4)
      thumbsListViewMode := 1

   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   If (thumbsListViewMode=1)
      initAHKhThumbThreads()

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   friendly := defineListViewModes()
   If StrLen(userSearchString)>1
      friendly .= "`nFiles matching search criteria are highlighted:`n" userSearchString

   If (ShowAdvToolbar=1)
      decideIconBTNthumbsList()
   showTOOLtip("List view: " friendly, A_ThisFunc, 1, thumbsListViewMode/4)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

defineListViewModes() {
   ; infoThumbsSize := (thumbsDisplaying=1) ? " (" thumbsW " x " thumbsH " px )" : ""
   If (thumbsListViewMode=1)
      friendly := "THUMBNAILS"
   Else If (thumbsListViewMode=2)
      friendly := "COMPACT"
   Else If (thumbsListViewMode=3)
      friendly := "FILE DETAILS"
   Else If (thumbsListViewMode=4)
      friendly := "IMAGE DETAILS"

   Return friendly
}

ToggleAutoPlaySND() {
   autoPlaySNDs := !autoPlaySNDs
   INIaction(1, "autoPlaySNDs", "General")
   friendly := (autoPlaySNDs=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Auto-play associated sound file: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSyncSlide2sndDuration() {
   syncSlideShow2Audios := !syncSlideShow2Audios
   INIaction(1, "syncSlideShow2Audios", "General")
   friendly := (syncSlideShow2Audios=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Wait for complete playback of audio files during slideshows:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSlidesTransitions() {
   doSlidesTransitions := !doSlidesTransitions
   INIaction(1, "doSlidesTransitions", "General")
   friendly := (doSlidesTransitions=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Smooth slideshow transitions: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMarkSeenIMGs() {
   highlightAlreadySeenImages := !highlightAlreadySeenImages
   INIaction(1, "highlightAlreadySeenImages", "General")
   friendly := (highlightAlreadySeenImages=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Highlight already seen images: " friendly, A_ThisFunc, 1)
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TglUseCacheSLDinfo() {
   useCachedSLDdata := !useCachedSLDdata
   INIaction(1, "useCachedSLDdata", "General")
   If (useCachedSLDdata=1)
      showTOOLtip("SQL database cached data will be used to sort the files list", A_ThisFunc, 1)
   Else
      showTOOLtip("SQL database cached data will NOT be used to sort the files list", A_ThisFunc, 1)

   SetTimer, RemoveTooltip, % -msgDisplayTime + 1500
}

TglRvrSort() {
   reverseOrderOnSort := !reverseOrderOnSort
   INIaction(1, "reverseOrderOnSort", "General")
   friendly := (reverseOrderOnSort=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Reverse order on files list sort: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TglCheckDeadFilesSort() {
   OnSortdoFilesCheck := !OnSortdoFilesCheck
   INIaction(1, "OnSortdoFilesCheck", "General")
   friendly := (OnSortdoFilesCheck=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Auto-remove inexistent files on files list sort: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleHistoInfoBoxu() {
   prevState := (showHistogram>1 || showInfoBoxHUD>=1) ? 1 : 0
   imgPath := getIDimage(currentFileIndex)
   If (prevState!=1)
   {
      If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
         Return
   }

   showHistogram := (prevState=0) ? 1 : 0
   showInfoBoxHUD := (prevState=0) ? 1 : 2
   ToggleImgHistogram(1)
   ToggleInfoBoxu()
   RemoveTooltip()
}

ToggleInfoBoxu() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 85) ; || (thumbsDisplaying=1)
       Return

    showInfoBoxHUD++
    lastInvoked := A_TickCount
    lastInfoBoxZeitToggle := A_TickCount
    showInfoBoxHUD := clampInRange(showInfoBoxHUD, 0, 2, 1)
    INIaction(1, "showInfoBoxHUD", "General")
    If (thumbsDisplaying=1)
       SetTimer, mainGdipWinThumbsGrid, -50
    Else
       SetTimer, dummyRefreshImgSelectionWindow, -50
    ; dummyTimerDelayiedImageDisplay(50)
}

ToggleImgCaptions() {
    Static lastInvoked := 1
    If (thumbsDisplaying=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    showImgAnnotations := !showImgAnnotations
    INIaction(1, "showImgAnnotations", "General")
    SetTimer, dummyRefreshImgSelectionWindow, -50
    If (showImgAnnotations=1)
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       textFile := OutDir "\" OutNameNoExt ".txt"
       If (SLDtypeLoaded=3)
          textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

       If (!FileExist(textFile) && SLDtypeLoaded!=3) || (!textFileContent && SLDtypeLoaded=3)
          showTOOLtip("Display image captions: ACTIVATED`n" OutNameNoExt ".txt (NOT FOUND)`nNo image caption / annotation file associated`nPress Shift+N to create/edit one.", A_ThisFunc, 1)
       Else
          showTOOLtip("Display image captions: ACTIVATED", A_ThisFunc, 1)
    } Else showTOOLtip("Display image captions: DEACTIVATED", A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMultiLineStatus() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 55)
       Return

    lastInvoked := A_TickCount
    multilineStatusBar := !multilineStatusBar
    INIaction(1, "multilineStatusBar", "General")
    dummyTimerDelayiedImageDisplay(50)
    CreateGuiButton("File options,,invokeFileOptionsMenu", 0, msgDisplayTime//1.5 + 500)
}

invokeFileOptionsMenu(givenCoords:=0) {
   deleteMenus()
   createMenuCurrentFilesActs("rclick")
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVfilesActs") : givenCoords
   showThisMenu("PVfilesActs")
}

invokeSelectionAreaMenu(modus:=0, givenCoords:=0) {
   deleteMenus()
   createMenuSelectionArea(modus)
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVselv") : givenCoords
   showThisMenu("PVselv")
}

invokeNavigationMenu(givenCoords:=0) {
   deleteMenus()
   createMenuNavigation()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVnav") : givenCoords
   showThisMenu("PVnav")
}

folderzNavLoadAllSiblings() {
   initialFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)
   baseFolder := StrReplace(baseFolder, "|")
   If FolderExist(baseFolder)
      OpenFolders(baseFolder)
}

invokeFoldersListerMenu() {
    Static menusList := "PVmFsibs|PVmFsubs|PVmFparents|PVmFexplorer"
    Loop, Parse, menusList, |
        Try Menu, % A_LoopField, Delete

    If (userPrivateMode=1)
    {
       showTOOLtip("WARNING: Private mode is activated. Access to this feature is denied,`nbecause it would be a breach of privacy.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
    If (SLDtypeLoaded!=1)
       baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

    If !InStr(baseFolder, ":\")
       Return "err"

    showTOOLtip("Identifing sibling and parent folders for`n" baseFolder)
    sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
    parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
    If (sibsObj.Count()>1)
    {
       Try Menu, PVmFsibs, Add, &See all, folderzNavLoadAllSiblings
       Try Menu, PVmFsibs, Add,
    }

    Loop, % sibsObj.Count()
    {
       If (A_Index>200)
       {
          Try Menu, PVmFsibs, Add, % "and " sibsObj.Count()  - A_Index " more folders", PanelFoldersTree
          Break
       }

       Try Menu, PVmFsibs, Add, % A_Index ". " sibsObj[A_Index], folderzNavInvokeSib
       If (A_Index=currentSib)
          Try Menu, PVmFsibs, Check, % A_Index ". " sibsObj[A_Index]
    }

    Loop, % parentsObj.Count()
    {
       If (A_Index>200)
       {
          Try Menu, PVmFsibs, Add, % "and " parentsObj.Count()  - A_Index " more folders", PanelFoldersTree
          Break
       }

       Try Menu, PVmFparents, Add, % A_Index ". " parentsObj[A_Index], folderzNavInvokeParents
       If (A_Index=1)
          Try Menu, PVmFparents, Disable, % A_Index ". " parentsObj[A_Index]

       If (A_Index=currentParent)
          Try Menu, PVmFparents, Check, % A_Index ". " parentsObj[A_Index]
    }

    thisFolder := StrReplace(Trimmer(baseFolder), "|")
    If (SLDtypeLoaded=1)
    {
       Menu, PVmFsubs, Add, &See all`tCtrl+F5, invertCurrentFolderRecursiveness
       If !InStr(CurrentSLD, "|")
          Menu, PVmFsubs, Check, &See all`tCtrl+F5
       Menu, PVmFsubs, Add,
    }

    hasAddedSubs := 0
    doStartLongOpDance()
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", DF
       {
          If (determineTerminateOperation()=1)
             Break

          If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
          {
             Try Menu, PVmFsubs, Add, % A_Index ". " A_LoopFileName, folderzNavInvokeSubs
             hasAddedSubs++
             If (hasAddedSubs>200)
             {
                Try Menu, PVmFsibs, Add, ... more folders can be listed, PanelFoldersTree
                Break
             }
          }
       }
    }

    ResetImgLoadStatus()
    friendly := (SLDtypeLoaded=1) ? "Currently opened" : "Selected file"
    kMenu("PVmFexplorer", "Add", friendly " folder:", "dummy")
    kMenu("PVmFexplorer", "Disable", friendly " folder:")
    Try kMenu("PVmFexplorer", "Add", PathCompact(baseFolder, 40), "OpenQPVfileFolder")
    If (SLDtypeLoaded=1)
       Try kMenu("PVmFexplorer", "Disable", PathCompact(baseFolder, 40))

    Menu, PVmFexplorer, Add
    If (FolderExist(thisFolder) && hasAddedSubs>0)
    {
       Try kMenu("PVmFexplorer", "Add", "Sub-folders", ":PVmFsubs")
    } Else
    {
       kMenu("PVmFexplorer", "Add", "No sub-folders", "dummy")
       kMenu("PVmFexplorer", "Disable", "No sub-folders")
    }

    If (parentsObj.Count()>0)
    {
       Menu, PVmFexplorer, Add
       Try kMenu("PVmFexplorer", "Add", "Breadcrumb folders &hierarchy", ":PVmFparents")
       If (parentsObj.Count()>1 && SLDtypeLoaded=1)
       {
          kMenu("PVmFexplorer", "Add", "Next breadcrumb`tCtrl+Page Down", "MenuFolderExplorerUpDown")
          kMenu("PVmFexplorer", "Add", "Previous breadcrumb`tCtrl+Page Up", "MenuFolderExplorerUpDown")
       }
    }

    If (sibsObj.Count()>0)
    {
       Menu, PVmFexplorer, Add
       Try kMenu("PVmFexplorer", "Add", "Sibling folders", ":PVmFsibs")
       If (SLDtypeLoaded=1)
       {
          kMenu("PVmFexplorer", "Add", "Next sibling`tAlt+Page Down", "MenuFolderExplorerSiblings")
          kMenu("PVmFexplorer", "Add", "Previous sibling`tAlt+Page Up", "MenuFolderExplorerSiblings")
       }
    } Else
    {
       kMenu("PVmFexplorer", "Add", "No sibling folders", "dummy")
       kMenu("PVmFexplorer", "Disable", "No sibling folders")
    }

    Menu, PVmFexplorer, Add
    If (folderTreeWinOpen!=1)
    {
       kMenu("PVmFexplorer", "Add/UnCheck", "Folders tree view`tF4", "MenuPanelFoldersTree")
       kMenu("PVmFexplorer", "Add", "Open omnibox at file location`tShift+;", "invokeOmniBoxCurrentFile")
    } Else
    {
       kMenu("PVmFexplorer", "Add/UnCheck", "&Large UI fonts", "folderTreeToggleLargeUIfonts")
       If (PrefsLargeFonts=1)
          kMenu("PVmFexplorer", "Check", "&Large UI fonts")
       kMenu("PVmFexplorer", "Add", "Open omnibox from folder tree item`t;", "fromFolderTreeToOmniBox")
       kMenu("PVmFexplorer", "Add/UnCheck", "Sho&w folder details", "toggleFDtreeInfos")
       If (showFolderTreeDetails=1)
          kMenu("PVmFexplorer", "Check", "Sho&w folder details")
       kMenu("PVmFexplorer", "Add", "Copy folder tree path", "folderTreeCopyPath")
       kMenu("PVmFexplorer", "Add", "Collapse/expand entire folder tree", "folderTreeExpandCollapseAll")
    }

    RemoveTooltip()
    showThisMenu("PVmFexplorer")
    Return "m"
}

MenuFolderExplorerUpDown(menuItem) {
   If InStr(menuItem, "next")
      FileExploreUpDownLevel(1)
   Else
      FileExploreUpDownLevel(-1)
}

MenuFolderExplorerSiblings(menuItem) {
   If InStr(menuItem, "next")
      FileExploreSiblingsNav(1)
   Else
      FileExploreSiblingsNav(-1)
}

folderzNavInvokeSubs(menuItem) {
    baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
    If (SLDtypeLoaded!=1)
       baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

    oldFolder := baseFolder
    openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
    thisFolder := StrReplace(Trimmer(baseFolder), "|")
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", DF
       {
          If (A_Index=openThisu && InStr(A_LoopFileAttrib, "D"))
          {
             hasFound := 1
             thisFolder .= "\" A_LoopFileName
             Break
          }
       }
    }
    If (hasFound!=1)
       Return

    tryOpenGivenFolder(thisFolder, oldFolder)
}

tryOpenGivenFolder(thisFolder, oldFolder) {
   oldFolderu := StrReplace(oldFolder, "|")
   thisFolder := StrReplace(thisFolder, "|")
   thisFolder := StrReplace(Trimmer(thisFolder, "\"), "\\", "\")
   If !FolderExist(thisFolder)
   {
      showTOOLtip("ERROR: Folder not found or access denied:`n" thisFolder)
      SoundBeep , 300, 100
      Return
   }

   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   initially := thisFolder
   newStaticFoldersListCache := []
   maxFilesIndex := 0
   SLDtypeLoaded := 1
   coreOpenFolder("|" thisFolder, 0, 0, 0, 1)
   If (maxFilesIndex<1)
   {
      addJournalEntry("Failed to find image files in: |" thisFolder)
      If !FolderExist(oldFolderu)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have attempted to open: " thisFolder "\. QPV found no supported image files in the folder.`n`nWould you like to recursively scan the given folder for supported image files?", 4, 0, "question")
      Else msgResult := "Yes"

      If (msgResult="Yes" || !FolderExist(oldFolderu))
      {
         coreOpenFolder(thisFolder, 0, 0, 0, 1)
         CurrentSLD := thisFolder
      }
   } Else CurrentSLD := "|" thisFolder

   hasFailed := 0
   If (maxFilesIndex<1 && FolderExist(oldFolderu))
   {
      addJournalEntry("Failed to recursively find image files in: " thisFolder "\`nReopening initial folder: " oldFolder)
      coreOpenFolder(oldFolder, 0, 0, 0, 1)
      CurrentSLD := oldFolder
      hasFailed := 1
   } Else If (maxFilesIndex<1)
      resetMainWin2Welcome()

   If (maxFilesIndex>1)
      prevOpenFolderPath := StrReplace(CurrentSLD, "|")

   currentFilesListModified := 0
   currentFileIndex := clampInRange(oldIndex, 1, maxFilesIndex)
   If maxFilesIndex
      dummyTimerDelayiedImageDisplay(50)

   If (hasFailed=1 || maxFilesIndex<1)
   {
      showDelayedTooltip("WARNING: No image files found in the folder:`n" initially)
      SoundBeep , 300, 100
   } Else RemoveTooltip()
   Return hasFailed
}

folderzNavInvokeSib(menuItem) {
   sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
   openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
   FileExploreSiblingsNav(1, 0, 0, iLevel, openThisu)
   ; ToolTip, % menuItem "-" openThisu "-" c , , , 2

}

folderzNavInvokeParents(menuItem) {
   parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
   openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
   FileExploreUpDownLevel(1, 0, prevMaxLevels, openThisu)
   ; ToolTip, % menuItem "==" openThisu "==" c , , , 2
}

toggleImgSelCoords() {
   relativeImgSelCoords := !relativeImgSelCoords
   calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)
   INIaction(1, "relativeImgSelCoords", "General")
}

ToggleSelectGrid() {
   showSelectionGrid := !showSelectionGrid
   INIaction(1, "showSelectionGrid", "General")
   If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
}

toggleEllipseSelection(modus:=-1) {
   If (editingSelectionNow!=1 && thumbsDisplaying!=1)
   {
      ToggleEditImgSelection()
      Return
   }
   
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   liveDrawingBrushTool := 0
   FloodFillSelectionAdj := 1
   EllipseSelectMode := clampInRange(EllipseSelectMode + 1, 0, 2, 1)
   If isInRange(modus, 0, 2)
      EllipseSelectMode := modus

   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   If (customShapePoints.Count()<3 && EllipseSelectMode=2)
   {
      RegAction(0, "FillAreaCustomShape",, 5)
      RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
      RegAction(0, "closedLineCustomShape",, 1)
      customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
      decideCustomShapeStyle()
      If (customShapePoints.Count()<3)
      {
         MenuStartDrawingSelectionArea()
         Return
      }
   }

   If (imgEditPanelOpened=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)

   ; INIaction(1, "EllipseSelectMode", "General")
   showTOOLtip("Selection area: " DefineVPselAreaMode(), 0, 0, (EllipseSelectMode+1)/3)
   If (EllipseSelectMode=2)
   {
     If (FillAreaCurveTension=1)
        ll := "Polygonal path"
     Else If (FillAreaCurveTension=5)
        ll := "Bézier path"
     Else
        ll := "Points tension: " tensionCurveCustomShape

      dummy := "||" ll ",,togglePathCurveTension"
   }

   If (ShowAdvToolbar=1)
      decideIconBTNselectShape()
   CreateGuiButton("Draw new form,,MenuStartDrawingSelectionArea" dummy, 0, msgDisplayTime//1.5 + 500)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleImgSelectionAspectRatio(dummy:=0) {
   If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
      Return

   If (dummy="simple")
      lockSelectionAspectRatio := (lockSelectionAspectRatio>=2) ? 1 : 2
   Else
      lockSelectionAspectRatio := clampInRange(lockSelectionAspectRatio + 1, 1, 10, 1)

   friendly := defineSelectionAspectRatios()
   If (LimitSelectBoundsImg=1)
      infou := "WARNING: The selection area is now no longer limited to the image boundaries"

   LimitSelectBoundsImg := 0
   INIaction(1, "LimitSelectBoundsImg", "General")
   showTOOLtip(infou "Selection area aspect ratio locked to:`n" friendly, 0, 0, lockSelectionAspectRatio/10)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyRefreshImgSelectionWindow()
}

toggleImgSelectLockedRatio() {
   toggleImgSelectionAspectRatio("simple")
}

defineSelectionAspectRatios(doFlipper:=0, modus:=0) {
   Static types := {0:"NONE", 1:"NONE", 2:"CURRENT RATIO", 3:"CURRENT WINDOW", 4:"CURRENT IMAGE", 5:"SQUARE [1:1]", 6:"SDTV [4:3]", 7:"35MM FILM [3:2]", 8:"HDTV [16:9]", 9:"WIDE SCREENS [16:10]", 10:"PHONE"}
        , flipper := 0

   If (doFlipper="yes" && isNumber(modus))
      flipper := modus

   If (!lockSelectionAspectRatio || !isNumber(lockSelectionAspectRatio))
      lockSelectionAspectRatio := 1

   imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If isImgEditingNow()
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)

   If (lockSelectionAspectRatio=2 && imgSelW>1 && imgSelH>1)
      desiredSelAspectRatio := imgSelW/imgSelH
   Else If (lockSelectionAspectRatio=3)
      desiredSelAspectRatio := (flipper=1) ? mainHeight/mainWidth : mainWidth/mainHeight
   Else If (lockSelectionAspectRatio=4 && imgW && imgH)
      desiredSelAspectRatio := (flipper=1) ? imgH/imgW : imgW/imgH
   Else If (lockSelectionAspectRatio=5)
      desiredSelAspectRatio := 1
   Else If (lockSelectionAspectRatio=6)
      desiredSelAspectRatio := (flipper=1) ? 3/4 : 4/3
   Else If (lockSelectionAspectRatio=7)
      desiredSelAspectRatio := (flipper=1) ? 2/3 : 3/2
   Else If (lockSelectionAspectRatio=8)
      desiredSelAspectRatio := (flipper=1) ? 9/16 : 16/9
   Else If (lockSelectionAspectRatio=9)
      desiredSelAspectRatio := (flipper=1) ? 10/16 : 16/10
   Else If (lockSelectionAspectRatio=10)
      desiredSelAspectRatio := (flipper=1) ? 2.14567 : 0.46543
   Else
      desiredSelAspectRatio := 0

   If (lockSelectionAspectRatio=10 || isInRange(lockSelectionAspectRatio, 2, 4))
      friendly := " [" Round(desiredSelAspectRatio, 2) "]"

   If (lockSelectionAspectRatio=3 || lockSelectionAspectRatio=4 || isInRange(lockSelectionAspectRatio, 6, 10))
      friendly .= " - flipped"

   Return types[lockSelectionAspectRatio] friendly
}

ToggleRecordOpenHistory() {
   allowRecordHistory := !allowRecordHistory
   INIaction(1, "allowRecordHistory", "General")
   friendly := (allowRecordHistory=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Keep history of opened files and folders: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ; If !allowRecordHistory
   ;    EraseOpenedHistory()
}

toggleLimitSelection() {
   If (showViewPortGrid!=1 && editingSelectionNow!=1) || (thumbsDisplaying=1) || (liveDrawingBrushTool=1 && editingSelectionNow=1)
      Return

   LimitSelectBoundsImg := !LimitSelectBoundsImg
   If (lockSelectionAspectRatio>1)
      infou := "WARNING: The selection area aspect ratio is now no longer locked.`n"

   lockSelectionAspectRatio := 1
   INIaction(1, "LimitSelectBoundsImg", "General")
   friendly1 := (LimitSelectBoundsImg=1) ? "ACTIVATED" : "DEACTIVATED"
   friendly2 := (editingSelectionNow=1) ? "selection area" : "viewport grid"
   showTOOLtip(infou "Limit " friendly2 " to image boundaries: " friendly1, A_ThisFunc, 1)
   If (imgEditPanelOpened=1 && showViewPortGrid!=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAlwaysFIMus() {
   alwaysOpenwithFIM := !alwaysOpenwithFIM
   r := initFIMGmodule()
   If InStr(r, "err - 126")
      friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2015."
   Else If InStr(r, "err - 404")
      friendly := "`n`nThe FreeImage.dll file seems to be missing..."

   INIaction(1, "alwaysOpenwithFIM", "General")
   If (FIMfailed2init=1)
      msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Various image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
   Else If (thumbsDisplaying!=1 && CurrentSLD && maxFilesIndex>0 && StrLen(UserMemBMP)<4)
      RefreshImageFileAction()
}

ToggleAnimGIFsupport() {
   animGIFsSupport := !animGIFsSupport
   INIaction(1, "animGIFsSupport", "General")
   friendly := (animGIFsSupport=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Automatically play animated GIFs: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleWICloader() {
   initQPVmainDLL()
   allowWICloader := (WICmoduleHasInit=1) ? !allowWICloader : 0
   friendly := (allowWICloader=1) ? "ACTIVATED" : "DEACTIVATED"
   If (WICmoduleHasInit!=1)
      friendly := "`nFAILED TO INITIALIZE"
   showTOOLtip("Load images through WIC: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TogglePrivateMode() {
   userPrivateMode := !userPrivateMode
   friendly := (userPrivateMode=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Private mode: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()
   dummyTimerReloadThisPicture(100)
   ; dummyTimerDelayiedImageDisplay(100)
}

ToggleFIMloader() {
   initFIMGmodule()
   allowFIMloader := (wasInitFIMlib=1) ? !allowFIMloader : 0
   friendly := (allowFIMloader=1) ? "ACTIVATED" : "DEACTIVATED"
   If (wasInitFIMlib!=1)
      friendly := "`nFAILED TO INITIALIZE"
   showTOOLtip("Allow images to load through FreeImage: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAutoRemEntries() {
   autoRemDeadEntry := !autoRemDeadEntry
   INIaction(1, "autoRemDeadEntry", "General")
   friendly := (autoRemDeadEntry=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Automatically remove entries to inexistent files: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TogglePromptDelete() {
   askDeleteFiles := !askDeleteFiles
   INIaction(1, "askDeleteFiles", "General")
   friendly := (askDeleteFiles=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Prompt before deleting files: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleTitleBaruNow(dummy:=0) {
   If (getCaptionStyle(PVhwnd)=0)
   {
      isTitleBarVisible := 0
      If (userAllowWindowDrag=1)
         TouchScreenMode := 0
      ; If (editingSelectionNow=1)
      ;    ToggleEditImgSelection()
      WinSet, Style, -0xC00000, ahk_id %PVhwnd%
   } Else
   {
      isTitleBarVisible := 1
      WinSet, Style, +0xC00000, ahk_id %PVhwnd%
   }
   interfaceThread.ahkassign("isTitleBarVisible", isTitleBarVisible)
   interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
   INIaction(1, "isTitleBarVisible", "General")
   ; INIaction(1, "TouchScreenMode", "General")
   ; If (isTitleBarVisible=0)
   If (drawingShapeNow!=1)
      SetTimer, dummyToggleTitleBarActionBtns, -350
}

dummyToggleTitleBarActionBtns() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  friendly .= (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1) ? "`nAllow window dragging: ENABLED" : "`nAllow window dragging: DISABLED"
  friendly := Trimmer(friendly)
  1stLabel := (userAllowWindowDrag=1 && isTitleBarVisible=0) ? "Deactivate window dragging" : "Allow window dragging"
  1stact := "toggleWindowDraggableMode"
  If (TouchScreenMode!=1)
  {
     2ndLabel := "Activate touch screen mode"
     2ndact := "ToggleTouchMode"
  }
  If (getCaptionStyle(PVhwnd)!=1)
  {
     1stLabel := "Interface options"
     1stact := "OpenUImenu"
  }

  ; If (isTitleBarVisible=0)
  CreateGuiButton(1stLabel ",," 1stact "||" 2ndLabel ",," 2ndact, "force", msgDisplayTime + 500)
  showTOOLtip(friendly)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleQuickBaru() {
   Critical, on
   Static lastInvoked := 1
   hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
   showMainMenuBar := !showMainMenuBar
   INIaction(1, "showMainMenuBar", "General")
   interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
   If !showMainMenuBar
      Win_SetMenu(PVhwnd, 0)

   TriggerMenuBarUpdate("forced")
   If (A_TickCount - lastInvoked > 900)
      CreateGuiButton("Interface options,,OpenUImenu", 0, msgDisplayTime//1.5 + 500)

   If (isImgEditingNow()=1 || (thumbsDisplaying=1 && maxFilesIndex>1))
   {
      ; If (thumbsDisplaying=1)
      ForceRefreshNowThumbsList()
      SetTimer, dummyUpdateWin, -300, 100
   }
   If hasTrans
      SetTimer, tlbrResetPosition, -300, 100
   lastInvoked := A_TickCount
}

dummyUpdateWin() {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   ; ToolTip, % mainWidth "=" mainHeight , , , 2
   createGDIPcanvas(mainWidth, mainHeight, 1)
   dummyTimerDelayiedImageDisplay(50)
}

ToggleTitleBaru() {
    SetTimer, ToggleTitleBaruNow, -150
}

ToggleLargeUIfonts() {
    PrefsLargeFonts := !PrefsLargeFonts
    ; If (AnyWindowOpen=14)
    ;    PanelPrefsWindow()

    calcHUDsize()
    INIaction(1, "PrefsLargeFonts", "General")
    interfaceThread.ahkassign("PrefsLargeFonts", PrefsLargeFonts)
    thisFunc := prevOpenedWindow[2]
    AddTooltip2Ctrl("reset")
    If (VisibleQuickMenuSearchWin=1)
    {
       closeQuickSearch()
       SetTimer, PanelQuickSearchMenuOptions, -150
    }

    If (AnyWindowOpen=16)
    {
       BtnCloseWindow()
       Sleep, 5
       PanelMultiFileDelete()
    } Else If (AnyWindowOpen && thisfunc)
    {
       BtnCloseWindow()
       Sleep, 5
       openPreviousPanel("forced")
    } Else
    {
       friendly := (PrefsLargeFonts=1) ? "ACTIVATED" : "DEACTIVATED"
       showTOOLtip("Large user interface fonts: " friendly, A_ThisFunc, 1)
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
}

ToggleTexyBGR() {
    usrTextureBGR := !usrTextureBGR
    INIaction(1, "usrTextureBGR", "General")
    friendly := (usrTextureBGR=1) ? ambiTexBrushSize " px" : "DEACTIVATED"
    RefreshImageFile()
    showDelayedTooltip("Viewport ambiental texture: " friendly, A_ThisFunc, 1)
}

ToggleDarkModus() {
    If (isWinXP || A_OSVersion="WIN_7")
    {
       msgBoxWrapper(appTitle ": WARNING", "This option is available only for Windows 10 and Windows 11.", 0, 0, "error")
       Return
    }

    uiUseDarkMode := !uiUseDarkMode
    INIaction(1, "uiUseDarkMode", "General")
    friendly := (uiUseDarkMode=1) ? "ACTIVATED" : "DEACTIVATED"
    AddTooltip2Ctrl("reset")
    setMenusTheme(uiUseDarkMode)
    showDelayedTooltip("Dark mode: " friendly)
    thisFunc := prevOpenedWindow[2]
    If (VisibleQuickMenuSearchWin=1)
       closeQuickSearch()

    If (AnyWindowOpen && thisfunc)
    {
       BtnCloseWindow()
       Sleep, 5
       openPreviousPanel("forced")
    }
}

tlbrLockPositionWin() {
    lockToolbar2Win := !lockToolbar2Win
    INIaction(1, "lockToolbar2Win", "General")
    friendly := (lockToolbar2Win=1) ? "ATTACHED to the main window" : "DETACHED from the main window"
    If (lockToolbar2Win=1)
       tlbrResetPosition()

    interfaceThread.ahkassign("lockToolbar2Win", lockToolbar2Win)
    showDelayedTooltip("Toolbar position: `n" friendly, A_ThisFunc, 1)
}

ToggleImgNavBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50)
       Return

    showHUDnavIMG := !showHUDnavIMG
    INIaction(1, "showHUDnavIMG", "General")
    dummyTimerDelayiedImageDisplay(25)
    SetTimer, dummyNavBoxInfo, -150
    lastInvoked := A_TickCount
}

ToggleImgNavSizeBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (showHUDnavIMG!=1)
       Return

    HUDnavBoxSize := (HUDnavBoxSize=75) ? 125 : 75
    RegAction(1, "HUDnavBoxSize")
    If (thumbsDisplaying=1)
       mainGdipWinThumbsGrid()
    Else
       dummyTimerDelayiedImageDisplay(25)
    lastInvoked := A_TickCount
}

dummyNavBoxInfo() {
    friendly := (IMGlargerViewPort=1) ? "" : "`nThe navigator will be displayed`nwhen the image is larger than the viewport."
    If (thumbsDisplaying=1)
       friendly := ""

    labelu := (thumbsDisplaying=1) ? "preview" : "navigator"
    If (showHUDnavIMG=1)
       showTOOLtip("Image " labelu " display: AUTO" friendly, "ToggleImgNavBox", 1)
    Else
       showTOOLtip("Image " labelu ": OFF", "ToggleImgNavBox", 1)

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

invokeHistoMenu(givenCoords:=0) {
   deleteMenus()
   createMenuVPhudHisto()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVimgHistos") : givenCoords
   showThisMenu("PVimgHistos")
}

invokeImgSizeVP(givenCoords:=0) {
   deleteMenus()
   If (thumbsDisplaying=1)
      createMenuNavBox()
   Else
      createMenuImgSizeAdapt("bonus")

   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PvImgAdapt") : givenCoords
   showThisMenu("PvImgAdapt")
}

ToggleImgHistogram(direction, dummy:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1) || (dummy="rClick")
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    showHistogram := (direction=1) ? showHistogram + 1 : showHistogram - 1
    showHistogram := clampInRange(showHistogram, 1, 6, 1)
    If (dummy="normal" && showHistogram=1)
       showHistogram := 2

    msgu := (showHistogram>1) ? "Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode() : "Histogram: NONE"
    INIaction(1, "showHistogram", "General")
    If (showHistogram>1)
       showTOOLtip(msgu, A_ThisFunc, 2, (showHistogram - 0.999)/5)
    Else
       showTOOLtip("Histogram: NONE", A_ThisFunc, 2, 0.001/6)

    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, showHistogram, % showHistogram
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
    lastInvoked := A_TickCount
}

ToggleHistogramMode() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 || showHistogram<=1)
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    lastInvoked := A_TickCount
    histogramMode := clampInRange(histogramMode + 1, 1, 3, 1)
    INIaction(1, "histogramMode", "General")
    showTOOLtip("Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode(), 0, 0, histogramMode/3)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, histogramMode, % histogramMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

defineHistogramType() {
    If (showHistogram=1)
       friendly := "NONE"
    Else If (showHistogram=2)
       friendly := "LUMINANCE"
    Else If (showHistogram=3)
       friendly := "RED"
    Else If (showHistogram=4)
       friendly := "GREEN"
    Else If (showHistogram=5)
       friendly := "BLUE"
    Else If (showHistogram=6)
       friendly := "ALL MIXED"

    Return friendly
}

defineHistogramMode() {
    If (histogramMode=1)
       friendly := "LOWS"
    Else If (histogramMode=2)
       friendly := "BALANCED"
    Else If (histogramMode=3)
       friendly := "PEAKS"

    Return friendly
}

ToggleThumbsCaching() {
    enableThumbsCaching := !enableThumbsCaching
    INIaction(1, "enableThumbsCaching", "General")
    friendly := (enableThumbsCaching=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Image thumbnails caching on disk: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleKeepAlphMask() {
    keepUserPaintAlphaMask := !keepUserPaintAlphaMask
    friendly := (keepUserPaintAlphaMask=1) ? "ACTIVATED`nIt will be available between different tool sessions" : "DEACTIVATED`nIt will be discarded once the current tool session ends"
    showTOOLtip("Keep user painted alpha mask: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSkipDeadFiles() {
    skipDeadFiles := !skipDeadFiles
    INIaction(1, "skipDeadFiles", "General")
    friendly := (skipDeadFiles=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Skip inexistent files in image view: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleFilesMap() {
    showFilesListMap := !showFilesListMap
    INIaction(1, "showFilesListMap", "General")
    friendly := (showFilesListMap=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Display selected files list map on scrollbar click: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleIgnoreSLDprefs() {
    MustLoadSLDprefs := !MustLoadSLDprefs
    INIaction(1, "MustLoadSLDprefs", "General")
}

toggleFDtreeInfos() {
    showFolderTreeDetails := !showFolderTreeDetails
    INIaction(1, "showFolderTreeDetails", "General")
    If (folderTreeWinOpen=1)
       folderTreeInfoStatusLineUpdater()
}

ToggleCycleFavesOpen() {
    cycleFavesOpenIMG := !cycleFavesOpenIMG
    INIaction(1, "cycleFavesOpenIMG", "General")
    friendly := (cycleFavesOpenIMG=1) ? "The favourites list will be opened when one of the 15 entries is opened." : "The containing folder of the favourite image will be opened."
    showTOOLtip(friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgQuality(modus:=0) {
    userimgQuality := !userimgQuality
    If (modus="lowu")
       userimgQuality := 0
    Else If (modus="highu")
       userimgQuality := 1
    Else
       INIaction(1, "userimgQuality", "General")

    fnOutputDebug("Set viewport quality: " modus "--" forceIT "==" userimgQuality)
    imgQuality := (userimgQuality=1) ? 6 : 5
    PixelMode := (userimgQuality=1) ? 2 : 0
    smoothMode := (userimgQuality=1) ? 4 : 1
    compositingQuality := 1 ; (userimgGammaCorrect=1) ? 2 : 1

    Gdip_SetInterpolationMode(glPG, imgQuality)
    Gdip_SetPixelOffsetMode(glPG, 2)
    Gdip_SetSmoothingMode(glPG, smoothMode)
    Gdip_SetCompositingQuality(glPG, compositingQuality)

    Gdip_SetInterpolationMode(2NDglPG, imgQuality)
    Gdip_SetPixelOffsetMode(2NDglPG, 2)
    Gdip_SetSmoothingMode(2NDglPG, smoothMode)
    Gdip_SetCompositingQuality(2NDglPG, compositingQuality)
}

toggleImgEditGammaCorrect() {
    userimgGammaCorrect := !userimgGammaCorrect
    INIaction(1, "userimgGammaCorrect", "General")
    friendly := (userimgGammaCorrect=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Gamma correction for image editing: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    If (AnyWindowOpen=23 || AnyWindowOpen=32)
       GuiControl, SettingsGUIA:, userimgGammaCorrect, % userimgGammaCorrect
}

toggleScreenSaverMode() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked<600)
       Return

    screenSaverMode := !screenSaverMode
    SoundBeep , % (screenSaverMode=1) ? 900 : 300, 100
    If (screenSaverMode=1)
       SetTimer, drawWelcomeImg, -50
    Else
       SetTimer, drawWelcomeImg, Off

    lastInvoked := A_TickCount
}

ToggleRAWquality() {
    userHQraw := !userHQraw
    INIaction(1, "userHQraw", "General")
    friendly := (userHQraw=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Load Camera RAW images at high quality: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleFreePanning() {
    allowFreeIMGpanning := !allowFreeIMGpanning
    INIaction(1, "allowFreeIMGpanning", "General")
    friendly := (allowFreeIMGpanning=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Allow image panning exceed the viewport area: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    IMGdecalageX := IMGdecalageY := 1
    PrintPosX := "C"
    dummyTimerDelayiedImageDisplay(90)
}

ToggleAutoPlaySlidesMusic() {
    autoPlaySlidesAudio := !autoPlaySlidesAudio
    INIaction(1, "autoPlaySlidesAudio", "General")
    friendly := (autoPlaySlidesAudio=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Automatically play music during slideshows: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleLockZoom() {
    lockZoomLevel := !lockZoomLevel
    customZoomAdaptMode := 0
    ; INIaction(1, "lockZoomLevel", "General")
    friendly := (lockZoomLevel=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Lock to current zoom level: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleCustomZLadaptH() {
    ToggleImageSizingMode("cus-h")
}

toggleCustomZLadaptW() {
    ToggleImageSizingMode("cus-w")
}

toggleCustomZLmodes() {
   If (thumbsDisplaying=1)
      Return

   If (customZoomAdaptMode=2 || zoomLevel!=1 && customZoomAdaptMode=0)
      ToggleImageSizingMode("cus-tom")
   Else If (customZoomAdaptMode=1)
      ToggleImageSizingMode("cus-h")
   Else If (customZoomAdaptMode=0)
      ToggleImageSizingMode("cus-w")
}

ToggleMultiCoreSupport() {
    allowMultiCoreMode := !allowMultiCoreMode
    INIaction(1, "allowMultiCoreMode", "General")
    If (thumbsDisplaying=1 && thumbsListViewMode=1 && multiCoreThumbsInitGood="n")
       initAHKhThumbThreads()
}

ToggleLimitMemUsage() {
    minimizeMemUsage := !minimizeMemUsage
    INIaction(1, "minimizeMemUsage", "General")
    If (minimizeMemUsage=1)
    {
       msgBoxWrapper(appTitle ": WARNING", "By limiting memory usage, the performance of Quick Picto Viewer will likely be drastically reduced. Additionally, some features or functions might be disabled.", 0, 0, "exclamation")
       discardViewPortCaches()
    }
}

TogglePreventUndos() {
    preventUndoLevels := !preventUndoLevels
    maxMemUndoLevels := (preventUndoLevels=1) ? 100 : 979394
    friendly := (preventUndoLevels=1) ? "NO" : "YES"
    showTOOLtip("Record undo levels: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgColorDepthDithering() {
    ColorDepthDithering := !ColorDepthDithering
    INIaction(1, "ColorDepthDithering", "General")
    If (thumbsDisplaying!=1)
       RefreshImageFile()
    friendly := (ColorDepthDithering=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Color depth dithering: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgDownScaling() {
    If (thumbsDisplaying=1 || StrLen(UserMemBMP)>3)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    AutoDownScaleIMGs := !AutoDownScaleIMGs
    INIaction(1, "AutoDownScaleIMGs", "General")
    If (AutoDownScaleIMGs=1)
       showTOOLtip("Images larger than the screen resolution will be`ndownscaled prior to any potential effect.")
    Else
       showTOOLtip("Downscaling: DISABLED")
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, RefreshImageFileAction, -300
}

toggleAppToolbar() {
    ShowAdvToolbar := !ShowAdvToolbar
    INIaction(1, "ShowAdvToolbar", "General")
    interfaceThread.ahkassign("ShowAdvToolbar", ShowAdvToolbar)
    createGUItoolbar()
    If (lockToolbar2Win=1 && ShowAdvToolbar=1)
       tlbrResetPosition()
    SetTimer, fromCurrentPanelToColorsSwatch, -150
}

ToggleToolBarToolTips() {
    ShowToolTipsToolbar := !ShowToolTipsToolbar
    INIaction(1, "ShowToolTipsToolbar", "General")
}

ToggleTouchMode() {
    DestroyTempBtnGui("now")
    TouchScreenMode := !TouchScreenMode
    updateUIctrl()
    interfaceThread.ahkassign("isTitleBarVisible", isTitleBarVisible)
    interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
    INIaction(1, "TouchScreenMode", "General")
    INIaction(1, "isTitleBarVisible", "General")
    If (getCaptionStyle(PVhwnd)=1 && TouchScreenMode=1 && userAllowWindowDrag=1)
       toggleWindowDraggableMode()

    friendly := (TouchScreenMode=1) ? "ACTIVATED" : "DEACTIVATED"
    If (TouchScreenMode=1)
       friendly .= "`nThe viewport is now split into different responsive areas.`nSee the Help menu for more details."

    showTOOLtip("Touch screen mode: " friendly)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

defineWinTitlePrefix() {
   Static FXmodesLabels := {2:"cP", 3:"cAUTO", 4:"cGR", 5:"cR", 6:"cG", 7:"cB", 8:"cA", 9:"cI"}

   If (StrLen(UserMemBMP)>1 && thumbsDisplaying!=1)
      winPrefix .= "IMAGE EDITING | "

   If StrLen(filesFilter)>1
      winPrefix .= "F "

   If hSNDmedia
      winPrefix .= "(A) "

   If (editingSelectionNow=1 && thumbsDisplaying!=1)
      winPrefix .= "SEL "

   If (slideShowRunning=1)
   {
      winPrefix .= "s"
      If (SlideHowMode=1)
         winPrefix .= "R "
      Else If (SlideHowMode=2)
         winPrefix .= "B "
      Else If (SlideHowMode=3)
         winPrefix .= "F "
   }

   If (usrColorDepth>1)
      winPrefix .= internalColorDepth  " bits "

   If (FlipImgV=1)
      winPrefix .= "V "
   If (FlipImgH=1)
      winPrefix .= "H "

   If (thisIMGisDownScaled=1 && thumbsDisplaying!=1)
      winPrefix .= "DWS "

   If FXmodesLabels.HasKey(imgFxMode)
      winPrefix .= FXmodesLabels[imgFxMode] A_Space

   If (IMGresizingMode=3 && thumbsDisplaying!=1)
      winPrefix .= "O "
   Else If (IMGresizingMode=4 && thumbsDisplaying!=1)
      winPrefix .= "Z "

   Return winPrefix
}

calculateTouchMargins(ByRef thisX, ByRef thisY, ByRef thisW, ByRef thisH) {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   thisX := (editingSelectionNow=1) ? mainWidth//8 : mainWidth//7
   thisY := (editingSelectionNow=1) ? mainHeight//6 : mainHeight//5
   thisW := mainWidth - thisX*2
   thisH := mainHeight - thisY*2
}

drawWelcomeImg() {
    Critical, on
    If StrLen(UserMemBMP)>2
       thisClippyIMG := 1

    If (maxFilesIndex>0 || thisClippyIMG=1 || StrLen(CurrentSLD)>1 || AnyWindowOpen>0)
    {
       screenSaverMode := 0
       Return
    }

    If (A_TickCount - scriptStartTime>550)
    {
       If (identifyThisWin()!=1)
       {
          screenSaverMode := 0
          Return
       }
    }

    thisZeit := A_TickCount
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    Random, modelu, 1, 8
    If (modelu=8)
       Random, modelu, 1, 8

    Random, moduz, 1, 9
    Random, iterations, 10, 30
    Random, sweepRand, 1, 9

    ; pBr4 := Gdip_BrushCreateSolid("0x55030201")
    BMPcache := coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, mainWidth, mainHeight, 5, 5, 1)
    If !BMPcache
    {
       Gdip_DeleteBrush(pBr4)
       addJournalEntry("Welcome screen failed to render... mainBMP=" BMPcache " -- pG=" G)
       setWindowTitle(appTitle " v" appVersion, 1)
       SetTimer, drawWelcomeImg, Off
       Return
    }

    createGDIPcanvas()
    getColors := (imgFxMode=3 || imgFxMode=8) ? 0 : 1
    If (getColors=1)
       decideGDIPimageFX(matrix, imageAttribs, zEffect)

    If !isWinXP
       pEffect := Gdip_CreateEffect(1, 3, 0, 0)

    If pEffect
       Gdip_BitmapApplyEffect(BMPcache, pEffect)

    r1 := trGdip_DrawImage(A_ThisFunc, glPG, BMPcache, 0, 0, mainWidth, mainHeight, 0, 0, mainWidth, mainHeight,,, imageAttribs)
    Gdip_AddPathGradient(glPG, 0, 0, mainWidth, mainHeight, mainWidth//2, mainHeight//2, "0x00000000", "0x65010101", 1, 0, 0, 1)
    Gdip_DisposeImageAttributes(imageAttribs)
    If (TouchScreenMode=1 && screenSaverMode!=1)
    {
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//11
       Penuha := Gdip_CreatePen("0x34334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x05EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x10778877)
       Gdip_FillRectangle(glPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(glPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(glPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)

       Gdip_SetClipRect(glPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(glPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(glPG)
       Gdip_DrawRectangle(glPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(glPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)
    }

    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
    trGdip_DisposeImage(BMPcache, 1)
    Gdip_DeleteBrush(pBr4)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    ; updateUIctrl()
    runningLongOperation := 0
    mustAbandonCurrentOperations := imageLoading := 0
    changeMcursor("normal-extra")
    addJournalEntry("Welcome screen rendered in " A_TickCount - thisZeit " ms." r2 " - " r1)
    setWindowTitle(appTitle " v" appVersion, 1)
    If (A_TickCount - thisZeit<250) || (screenSaverMode=1)
       SetTimer, drawWelcomeImg, -3500
    Else
       SetTimer, drawWelcomeImg, Off
}

coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, mainWidth, mainHeight, minX, minY, startMode, previewMode:=0, usePrevious:=0) {
    Static prevObj := [], prevBMPu, prevState

    If (modelu="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    thisState := "a" kimgSelW kimgSelH AnyWindowOpen VPselRotation FillAreaInverted modelu iterations moduz sweepRand minX minY startMode previewMode usePrevious
    If (thisState=prevState && previewMode=1 && StrLen(prevBMPu)>2)
       Return trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
 
    prevState := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    BMPcache := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, coreDesiredPixFmt)
    If BMPcache
    {
       compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
       If (userimgQuality!=1 && previewMode=1) || (previewMode=1) || (startMode=1 && userimgQuality!=1)
          G := trGdip_GraphicsFromImage(A_ThisFunc, BMPcache, 1, 3,, compositingQuality)
       Else
          G := trGdip_GraphicsFromImage(A_ThisFunc, BMPcache, 7, 4,, compositingQuality)
    }

    If (!BMPcache || !G)
    {
       prevState := 0
       trGdip_DisposeImage(BMPcache, 1)
       Return
    }

    If (usePrevious=1 && prevObj.type!=modelu)
       usePrevious := 0

    If (usePrevious!=1)
    {
       scaleuX := scaleuY := 1
       prevObj.type := modelu
       prevObj.mW := mainWidth
       prevObj.mH := mainHeight
       Random, a, 22, 66
       Random, b, 22, 66
       Random, c, 22, 66
       Random, d, 66, 99
       Random, anglu, 0.0, 24.5
       If (startMode!=1)
          anglu := VPselRotation ; + anglu/12
       prevObj.a := a
       prevObj.b := b
       prevObj.c := c
       prevObj.d := d
       prevObj.anglu := anglu
    } Else
    {
       scaleuX := prevObj.mW/mainWidth
       scaleuY := prevObj.mH/mainHeight
    }

    pBr1 := Gdip_BrushCreateSolid("0x" prevObj.a "882211")
    pBr2 := Gdip_BrushCreateSolid("0x" prevObj.b "112288")
    pBr3 := Gdip_BrushCreateSolid("0x" prevObj.c "118822")
    pBr5 := Gdip_BrushCreateSolid("0x" prevObj.d "939291")
    ; MsgBox, % minX "--" minY "`n" mainWidth "--" mainHeight "`n" bgrBrush
    If (GetKeyState("CapsLock", "T") && startMode=1)
       Gdip_FillRectangle(G, pBr5, 0, 0, mainWidth, mainHeight)
    ; Else If (startMode!=1)
    ;    Gdip_FillRectangle(G, bgrBrush, 0, 0, mainWidth, mainHeight)

    If (startMode=1)
       trGdip_GraphicsClear(A_ThisFunc, G, "0xFF" WindowBgrColor)

    Gdip_SetClipRect(G, 0, 0, mainWidth, mainHeight)
    cX := 0 + (mainWidth / 2)
    cY := 0 + (mainHeight / 2)
    pMatrix := Gdip_CreateMatrix()
    Gdip_TranslateMatrix(pMatrix, -cX , -cY)
    Gdip_RotateMatrix(pMatrix, prevObj.anglu, 1)
    Gdip_TranslateMatrix(pMatrix, cX, cY, 1)
    Gdip_SetWorldTransform(G, pMatrix)
    Gdip_DeleteMatrix(pMatrix)

    If (modelu=1)
    {
       ; rects
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % minY, % mainHeight
             Random, w, % minX, % mainWidth
             Random, h, % minY, % mainHeight
             w += 10
             h += 10
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          ; MsgBox, % xPos "--" yPos "`n" w "--" h "`n" tBrsh
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=2)
    {
       ; ellipses
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % minY, % mainHeight
             Random, w, % minX, % mainWidth//2 + mainHeight//2
             w += 5
             h := w
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=3 || modelu=5)
    {
       ; ellipses snapped to corners
       ; Random, moduz, 1, 9
       Loop, % iterations
       {  
          If (usePrevious!=1)
          {
             Random, w, 5, % mainWidth//1.5 + mainHeight//1.5
             w += 5
             h := w
             Random, deviation, -25, 25
             If (modelu=5)
                Random, moduz, 1, 9

             If (moduz=1)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else If (moduz=2)
             {
                xPos := 1 - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else If (moduz=3)
             {
                xPos := 1 - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=4)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=5)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=6)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             } Else If (moduz=7)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             } Else If (moduz=8)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else
             {
                xPos := 1 - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             }
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }

          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=6)
    {
       ; Maurer Rose; based on the implemention by Hellbent - found on AHK Forums
       If (startMode!=1)
          iterations := Ceil(iterations/10)
       Else
          Random, iterations, 2, 5

       o_sweepRand := sweepRand
       PetalPenA := Gdip_CreatePenFromBrush(pBr5, thickness)
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, thickness, 2.0, 3.5
             Random, tBrsh, 1, 3
             Random, ttBrsh, 1, 3
             If (startMode!=1)
                Random, sweepRand, 1, 9
             Else If (A_Index=1)
                sweepRand := o_sweepRand - 1
             Else If (A_Index=2)
                sweepRand := o_sweepRand + 1
             Else
                sweepRand := o_sweepRand

             Random, Petals, 2, 7
             If (startMode!=1)
                Petals := clampInRange(moduz + 1, 2, 9)

             prevObj[A_Index] := [thickness, Petals, sweepRand, ttBrsh, tBrsh]
          } Else
          {
             thickness := prevObj[A_Index, 1] / ((scaleuX + scaleuY)/2)
             Petals := prevObj[A_Index, 2]
             sweepRand := prevObj[A_Index, 3]
             ttBrsh := prevObj[A_Index, 4]
             tBrsh := prevObj[A_Index, 5]
          }

          PetalPen := Gdip_CreatePenFromBrush(pBr%ttBrsh%, thickness)
          SweepPen := Gdip_CreatePenFromBrush(pBr%tBrsh%, thickness)
          PetalList := SweepList := mainWidth//2 "," mainHeight//2 "|", Sweep := sweepRand
          Loop, 360
          {
              SweepList .= CalculateSweep(A_Index*Sweep, Petals, mainWidth//2, mainHeight//2)
              PetalList .= CalculateSweep(A_Index*3.14159/180, Petals, mainWidth//2, mainHeight//2)
          }
          PetalList .= mainWidth//2 "," mainHeight//2
          SweepList .= mainWidth//2 "," mainHeight//2
          Gdip_DrawLines(G, PetalPenA, PetalList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          ; Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, PetalPen, PetalList)
          Gdip_DeletePen(PetalPen)
          Gdip_DeletePen(SweepPen)
       }
       Gdip_DeletePen(PetalPenA)
    } Else If (modelu=4)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % -mainHeight, % minY
             Random, w, % minX, % mainWidth//2
             w += 5
             h := mainHeight*3
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }

          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=8)
    {
       ; noise
       Random, z, 0.02, 0.09 ; scale
       Random, l, 0.1, 0.45 ; opacity
       Random, kl, 0, 10
       doGray := (kl<3) ? 1 : 0
       Gdip_SetInterpolationMode(G, 5)
       Gdip_SetPixelOffsetMode(G, 2)
       Gdip_ResetWorldTransform(G)
       noiseBMP := QPV_CreateBitmapNoise(Ceil(mainWidth*z), Ceil(mainHeight*z), 1, doGray, 1)
       trGdip_DrawImage(A_ThisFunc, G, noiseBMP, 0, 0, mainWidth, mainHeight,,,,, l)
       trGdip_DisposeImage(noiseBMP, 1)
    } Else ; If (modelu=6)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % -mainWidth, % minY
             Random, yPos, % minY, % mainHeight
             w := mainWidth*3
             Random, h, % minY, % mainHeight//2
             h += 5
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    }
    
    Gdip_ResetWorldTransform(G)
    ; If (startMode!=1)
       ; Gdip_FillRectangle(G, overBrush, 0, 0, mainWidth, mainHeight)

    If (startMode!=1 && previewMode=1)
    {
       prevBMPu := (minimizeMemUsage=0) ? trGdip_CloneBitmap(A_ThisFunc, BMPcache) : 0
       prevState := (minimizeMemUsage=0) ? thisState : 0
    } Else prevState := 0

    Gdip_DeleteBrush(pBr1)
    Gdip_DeleteBrush(pBr2)
    Gdip_DeleteBrush(pBr3)
    Gdip_DeleteBrush(pBr5)
    Gdip_DeleteGraphics(G)
    Return BMPcache
}

CalculateSweep(InputValue, Petals, w, h) {
   r:=((w+h)//2)*Sin(Petals*InputValue)
   x:=r*cos(InputValue)+w
   y:=r*sin(InputValue)+h
   return x "," y "|"
}

addJournalEntry(msg) {
    Static currentEntry := 0, currentErrEntry := 0, maxEntries := 256, lastError, prevEntry
    If (slideShowRunning=1 && slideShowDelay<300)
       Return

    If (msg="get_last_err")
       Return lastError

    If (msg="WinTitle: " pVwinTitle) || InStr(msg, "WinTitle: " appTitle " v" appVersion) || (msg="Loading") || (slideShowRunning=1 && slideShowDelay<600) || (animGIFplaying=1)
       Return

    ; mamUsage := GetProcessMemoryUsage(QPVpid)
    ; If (A_PtrSize=8)
    ;    systemMemInfo := GlobalMemoryStatusEx()
    ; thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
    ; memUsage := "Mem: " Round(max(mamUsage[1], mamUsage[8]) / 1024**2, 1) " MB " 
    ; ToolTip, % memUsage , , , 2

    If (hasInitSpecialMode=1 || prevEntry=msg)
       Return

    prevEntry := msg
    fnOutputDebug("User journal: " StrReplace(msg, "`n", " | "))
    If ((InStr(msg, "error") || InStr(msg, "fail")) && !InStr(msg, "dialog box:"))
    {
       lastError := msg
       currentErrEntry++
       QPVerrJournal.InsertAt(1, getCurrentDate() ":`n" msg "`n")
       If (currentErrEntry>maxEntries)
       {
          currentErrEntry := maxEntries
          QPVerrJournal.Pop()
       }
       Return
    }

    currentEntry++
    QPVjournal.InsertAt(1, getCurrentDate() ":`n" msg "`n")
    If (currentEntry>maxEntries)
    {
       currentEntry := maxEntries
       QPVjournal.Pop()
    }
}

getCurrentDate() {
   FormatTime, CurrentTimeB,, H:mm:ss
   FormatTime, CurrentDateB,, ShortDate
   Return CurrentDateB ", " CurrentTimeB
}

destroyGDIPcanvas() {
    qpvCanvasHasInit := 0
    Gdi_SelectObject(glHDC, glOBM)
    If glHbitmap
       Gdi_DeleteObject(glHbitmap)
    If glHDC
       Gdi_DeleteDC(glHDC)
    If glPG
       Gdip_DeleteGraphics(glPG)

    Gdi_SelectObject(2NDglHDC, 2NDglOBM)
    If 2NDglHbitmap
       Gdi_DeleteObject(2NDglHbitmap)
    If 2NDglHDC
       Gdi_DeleteDC(2NDglHDC)
    If 2NDglPG
       Gdip_DeleteGraphics(2NDglPG)

    glHbitmap := 2NDglHbitmap := ""
    glHDC := 2NDglHDC := ""
    glPG := 2NDglPG := ""
}

createGDIPcanvas(W:=0, H:=0, forceIT:=0) {
   Critical, on
   Static prevDimensions, hasInit
   If (A_TickCount - lastMenuBarUpdated<700) && (forceIT=0)
      Return

   If (!W || !H)
      GetWinClientSize(W, H, PVhwnd, 0)

   newDimensions := "w" W "-h" H "-mbar" showMainMenuBar
   doAgain := (prevDimensions!=newDimensions) ? 1 : 0
   If (!qpvCanvasHasInit || doAgain=1 || forceIT=1)
   {
      If (hasInit=1)
         destroyGDIPcanvas()

      ; gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
      imgQuality := (userimgQuality=1) ? 6 : 5
      If (minimizeMemUsage=1)
         imgQuality := ""    ; default interpolation mode

      PixelMode := (userimgQuality=1) ? 2 : 0
      smoothMode := (userimgQuality=1) ? 4 : 1
      compositingQuality := 1 ; (userimgGammaCorrect=1) ? 2 : 1
      glHDC := Gdi_CreateCompatibleDC()
      ; Gdi_SetPolyFillMode(glHDC, 2)
      glHbitmap := Gdi_CreateDIBSection(W, H)
      glOBM := Gdi_SelectObject(glHDC, glHbitmap)
      glPG := Gdip_GraphicsFromHDC(glHDC, 0, imgQuality, smoothMode, 2, compositingQuality)
      Gdip_SetPixelOffsetMode(glPG, 2)
      ; ToolTip, % W "==" H "==" glHDC "==" glHbitmap "==" glOBM "==" glPG , , , 2

      2NDglHDC := Gdi_CreateCompatibleDC()
      2NDglHbitmap := Gdi_CreateDIBSection(W, H)
      2NDglOBM := Gdi_SelectObject(2NDglHDC, 2NDglHbitmap)
      2NDglPG := Gdip_GraphicsFromHDC(2NDglHDC, 0, imgQuality, smoothMode, 2, compositingQuality)
      Gdip_SetPixelOffsetMode(2NDglPG, 2)

      hasInit := 1
      prevDimensions := newDimensions
      addJournalEntry("Canvas infos: " prevDimensions " - glPG:" glPG " - glHDC:" glHDC " - glOBM:" glOBM " - glHbmp:" glHbitmap " - 2NDglPG:" 2NDglPG " - 2NDglHDC:" 2NDglHDC " - 2NDglOBM:" 2NDglOBM " - 2NDglHbmp:" 2NDglHbitmap)
      If (!glPG || !glHDC || !glHbitmap || !glOBM || !2NDglPG || !2NDglHDC || !2NDglOBM || !2NDglHbitmap)
      {
         qpvCanvasHasInit := 0
         prevDimensions := "r"
         ; MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+ window...`n`nThe program will probably malfunction or crash.
         handleFatalWinInitErrors()
      } Else
      {
         qpvCanvasHasInit := 1
         addJournalEntry("Main canvas created: " W " x " H " px.")
      }
   }
}

handleFatalWinInitErrors() {
   msgResult := msgBoxWrapper(appTitle ": FATAL ERROR", appTitle " was unable to initialize the GDI+ windows required to display images.`n`nWould you like to try initialize it again? By choosing to continue, the application may malfunction.", "&Try again|&Continue|&Exit", 1, "error")
   If InStr(msgResult, "again")
   {
      restartEntireGui()
   } Else If InStr(msgResult, "exit")
   {
      hasInitSpecialMode := 1
      ForceExitNow()
   }
}

restartEntireGui() {
   destroyGDIPcanvas()
   interfaceThread.ahkFunction("destroyAllGUIs")
   Sleep, 25
   externObj := WindowBgrColor "$" isAlwaysOnTop "$" mainCompiledPath "$" isTitleBarVisible "$" TouchScreenMode "$" userAllowWindowDrag "$" mainWinPos "$" mainWinSize "$" mainWinMaximized
   initGUI := interfaceThread.ahkFunction("BuildGUI", externObj)
   fnOutputDebug("RESTARTED extern UI HWNDs: " initGUI)
   If InStr(initGui, "|")
      handleUIhwnd(InitGui)

   createGDIPcanvas()
}

handleUIhwnd(initGui) {
   externObj := StrSplit(initGUI, "|")
   PVhwnd := externObj[1]
   hGDIinfosWin := externObj[2]
   hGDIwin := externObj[3]
   hGDIthumbsWin := externObj[4]
   hGDIselectWin := externObj[5]
   hPicOnGui1 := externObj[6]
   winGDIcreated := externObj[7]
   ThumbsWinGDIcreated := externObj[8]
   If (!PVhwnd || !hGDIinfosWin || !hGDIwin || !hGDIthumbsWin || !hGDIselectWin || !hPicOnGui1)
   {
      handleFatalWinInitErrors()
   } Else
   {
      GroupAdd, QPVwindows, ahk_id %PVhwnd%
      GroupAdd, QPVwindows, ahk_id %hGDIthumbsWin%
      GroupAdd, QPVwindows, ahk_id %hGDIwin%
      GroupAdd, QPVwindows, ahk_id %hGDIselectWin%
      GroupAdd, QPVwindows, ahk_id %hGDIinfosWin%
      updateUIctrl()
   }
}

InitGDIpStuff() {
   thisBMPdummy := Gdip_CreateBitmap(10, 10)
   dummyGu := Gdip_GraphicsFromImage(thisBMPdummy)

; create pens and brushes
   pPen1 := Gdip_CreatePen("0xCCbbccbb", 3)
   pPen1d := Gdip_CreatePen("0xCCbbccbb", 3)
   ; Gdip_SetPenAlignment(pPen1d, 1)
   Gdip_SetPenDashArray(pPen1d, "1.1|1.1")
   pPen2 := Gdip_CreatePen("0xBBffccbb", imgHUDbaseUnit//9)
   pPen3 := Gdip_CreatePen("0x66334433", imgHUDbaseUnit//8)
   pPen4 := Gdip_CreatePen("0x88998899", imgHUDbaseUnit//11)
   pPen5 := Gdip_CreatePen("0x880088FF", imgHUDbaseUnit//11.5)
   pPen6 := Gdip_CreatePen("0xDD998822", imgHUDbaseUnit//6)
   pPen7 := Gdip_CreatePen("0xDDFFeeFF", imgHUDbaseUnit//6)
   Gdip_SetPenDashArray(pPen4, "0.5|0.5")
   pBrushA := Gdip_BrushCreateSolid("0x90898898")
   pBrushB := Gdip_BrushCreateSolid("0xBB898898")
   pBrushC := Gdip_BrushCreateSolid("0x77898898")
   pBrushD := Gdip_BrushCreateSolid("0xDDbbccFF")
   pBrushE := Gdip_BrushCreateSolid("0x77333333")
   pBrushF := Gdip_BrushCreateSolid("0x33667766")
   pBrushZ := Gdip_BrushCreateSolid("0xFF000000")
   ; Loop, 6
      ; r := Gdip_SetPenAlignment(pPen%A_Index%, 1)
   ; ToolTip, % "0x" rgb2bgr(WindowBgrColor) "`n" WindowBgrColor , , , 2
   GDIcreateCheckersBrush(20)
   Gdi_SetBgrColor(glHDC, "0x" rgb2bgr(WindowBgrColor))
   pBrushHatchLow := Gdip_BrushCreateHatch("0xff999999", "0xff111111", 50)
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
   GDIbrushWinBGR := Gdi_CreateSolidBrush("0x" rgb2bgr(WindowBgrColor))
   OSDwinFadedBrushBGR := Gdip_BrushCreateSolid("0xEE" OSDbgrColor)
}

GDIcreateCheckersBrush(size) {
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, size, size, coreDesiredPixFmt)
   If !pBitmap
      Return

   pBr1 := Gdip_BrushCreateSolid("0x99ffFFff")
   pBr2 := Gdip_BrushCreateSolid("0x99515151")
   pBr3 := Gdip_BrushCreateHatch("0xff999999", "0xff111111", 50)

   G := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   Gdip_FillRectangle(G, pBr3, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr2, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr1, 0, 0, size//2, size//2)
   Gdip_FillRectangle(G, pBr1, size//2, size//2, size//2, size//2)
   Gdip_DeleteGraphics(G)
   GDIbrushHatch := createGDIbrushPbitmap(pBitmap)
   trGdip_DisposeImage(pBitmap, 1)
   Gdip_DeleteBrush(pBr1)
   Gdip_DeleteBrush(pBr2)
   Gdip_DeleteBrush(pBr3)
}

refreshWinBGRbrush() {
   If pBrushWinBGR
      Gdip_DeleteBrush(pBrushWinBGR)
   If OSDwinFadedBrushBGR
      Gdip_DeleteBrush(OSDwinFadedBrushBGR)
   If GDIbrushWinBGR
      Gdi_DeleteObject(GDIbrushWinBGR)
   Sleep, 0
   ; ToolTip, % "0x" rgb2bgr(WindowBgrColor) , , , 2
   Gdi_SetBgrColor(glHDC, "0x" rgb2bgr(WindowBgrColor))
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
   GDIbrushWinBGR := Gdi_CreateSolidBrush("0x" rgb2bgr(WindowBgrColor))
   OSDwinFadedBrushBGR := Gdip_BrushCreateSolid("0xEE" OSDbgrColor)
}

useHatchedBrush(dummy:=0) {
   If (dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha!=1)
      Return
   Else If (coreDesiredPixFmt="0x21808" || dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha=1)
      Return pBrushZ
   Else 
      Return pBrushHatchLow
}

useGdiHatchedBrush(dummy:=0) {
   If (dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha!=1)
      Return Gdi_GetStockObject(0)
   Else If (coreDesiredPixFmt="0x21808" || dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha=1)
      Return Gdi_GetStockObject(4)
   Else 
      Return GDIbrushHatch
}

ToggleSeenIMGstatus() {
   initSeenImagesListDB()
   If (thumbsDisplaying!=1 || sqlFailedInit=1)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   mustRem := 0 
   imgPath := getIDimage(currentFileIndex)
   cachedAllSessionsSeen[Format("{:L}", imgPath)] := "-"
   resultedFilesList[currentFileIndex, 3] := ""
   seenImagesDB.Exec("COMMIT TRANSACTION;")
   If retrieveSeenImageDBentry(imgPath, currentFileIndex)
      mustRem := 1 

   If markedSelectFile
   {
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      countFilez := 0
      getSelectedFiles(0, 1)
      friendly := (mustRem=1) ? "NOT SEEN" : "SEEN"
      showTOOLtip("Marking as " friendly A_Space groupDigits(markedSelectFile) " images, please wait")
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      doStartLongOpDance()
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue
      
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(countFilez, markedSelectFile, startOperation)
            showTOOLtip("Marking as " friendly " images, please wait" etaTime, 0, 0, countFilez / markedSelectFile)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countFilez++
         resultedFilesList[A_Index, 3] := ""
         imgPath := resultedFilesList[A_Index, 1]
         cachedAllSessionsSeen[Format("{:L}", imgPath)] := "-"
         If (mustRem=1)
            deleteSQLseenEntry(imgPath, A_Index)
         Else
            recordSeenIMGdbEntry(imgPath, A_Index, 0)
      }

      If !seenImagesDB.Exec("COMMIT TRANSACTION;")
         someERR := "Failed to commit changes to the SQL database`n"

      If (abandonAll=1)
         showTOOLtip(someERR "Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected images were marked as " friendly ".")
      Else
         showTOOLtip(someERR "Finished marking " groupDigits(countFilez) " images as " friendly ".")

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % (abandonAll=1) ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      If (mustRem=1)
         deleteSQLseenEntry(imgPath, currentFileIndex)
      Else
         recordSeenIMGdbEntry(imgPath, currentFileIndex, 0)

      If !seenImagesDB.Exec("COMMIT TRANSACTION;")
      {
         throwSQLqueryDBerror(A_ThisFunc)
      } Else
      {
         friendly := (mustRem=1) ? "NOT SEEN" : "SEEN"
         showTOOLtip("Marked image as " friendly)
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
}

CleanDeadFilesSeenImagesDB(doPartial:=0, partu:=0) {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If AnyWindowOpen
     BtnCloseWindow()

   If (doPartial!="yesu")
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to purge no longer existent files from the list of seen images?`n`nThis action is irreversible and may take awhile...", "&Continue|C&ancel", 2, "question")
      If !InStr(msgResult, "continue")
         Return
   }

  startOperation := A_TickCount
  showTOOLtip("Removing entries of inexistent files`nfrom the already seen images database, please wait")
  doStartLongOpDance()
  prevMSGdisplay := A_TickCount
  startOperation := A_TickCount
  entriesCount := entriesScanned := entriesDoneCount := 0
  RecordSet := ""
  npartu := StrReplace(partu, "\viewed-images-history-")
  npartu := StrReplace(npartu, ".sld")
  If (doPartial="yesu" && !InStr(partu, "-viewed-images-history-current-session"))
     SQL := "SELECT imgfile FROM images WHERE imgViewDate LIKE '" npartu "%';"
  Else
     SQL := "SELECT imgfile FROM images;"

  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entries := []
  seenImagesDB.Exec("BEGIN TRANSACTION;")
  entriesCount := RecordSet.RowCount
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      item := Trimmer(Rowu[1])
      If !FileExist(item)
      {
         deleteSQLseenEntry(item, 0)
         entriesDoneCount++
      }

      entriesScanned++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(entriesScanned, entriesCount, startOperation)
         showTOOLtip("Removing entries of inexistent files`nfrom the seen images database, please wait" etaTime "`n" groupDigits(entriesDoneCount) " entries removed", 0, 0, entriesScanned / entriesCount)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
  }

  RecordSet.Free()
  If !seenImagesDB.Exec("COMMIT TRANSACTION;")
     throwSQLqueryDBerror(A_ThisFunc)

  If (doPartial!="yesu")
     seenImagesDB.Exec("VACUUM main;")

  zeitOperation := A_TickCount - startOperation
  etaTime := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
  If (abandonAll=1)
     etaTime .= "`nOperation aborted. " groupDigits(entriesScanned) " / " groupDigits(entriesCount) " entries were scanned until now"

  showTOOLtip(groupDigits(entriesDoneCount) " entries of inexistent files were removed from the database" etaTime)
  SetTimer, ResetImgLoadStatus, -50
  SoundBeep, 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return entries
}

retrieveEntireSeenImagesDB(ByRef entriesCount, doSorting, applyFilter:=0) {
  entriesCount := 0
  RecordSet := ""
  filteru := Strlen(applyFilter)>1 ? " WHERE imgViewDate LIKE '" applyFilter "%'" : ""
  orderu := (doSorting=1) ? " ORDER BY imgViewDate;" : ";"
  SQL := "SELECT imgfile FROM images" filteru orderu
  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entries := new hashtable(RecordSet.RowCount)
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      ; entries[CalcStringHash(Row[1], 0x8003)] := Row[1]
      If RegExMatch(Rowu[1], RegExFilesPattern)
      {
         entriesCount++
         entries[Format("{:L}", Rowu[1])] := 1
      }
  }

  RecordSet.Free()
  addJournalEntry("Recorded seen images: " entriesCount "`nRetrieved entries: " entries.Count())
  Return entries
}

deleteSQLseenEntry(imgPath, thisIndex) {
  seenImagesDB.EscapeStr(imgPath)
  SQLstr := "DELETE FROM images WHERE imgfile=" imgPath " COLLATE NOCASE;"
  seenImagesDB.Exec(SQLStr)
  resultedFilesList[thisIndex, 3] := 0
}

retrieveSeenImageDBentry(imgPath, thisIndex) {
  Static lastInvoked := 1

  If (!imgPath || (A_TickCount - lastInvoked<350) && (slideShowRunning!=1))
     Return 0

  If (resultedFilesList[thisIndex, 3]=1)
     Return 1
  Else If (resultedFilesList[thisIndex, 3]=0 && thumbsDisplaying=1)
     Return 0

  zu := cachedAllSessionsSeen[Format("{:L}", imgPath)]
  If (zu=1 && imgPath)
  {
     resultedFilesList[thisIndex, 3] := 1
     Return 1
  } Else If (thumbsDisplaying=1 && zu=0)
     Return 0
 
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  RecordSet := ""
  stringA := imgPath
  seenImagesDB.EscapeStr(stringA)
  SQL := "SELECT imgfile FROM images WHERE imgfile=" stringA " COLLATE NOCASE;"
  If !seenImagesDB.GetTable(SQL, RecordSet)
     Return 0

  entries := 0
  Loop, % RecordSet.RowCount
  {
     Rowu := RecordSet.Rows[A_Index]
     If (Trimmer(Rowu[1])=imgPath)
        entries := "yay"
  }

  RecordSet.Free()
  If entries
  {
     cachedAllSessionsSeen[Format("{:L}", imgPath)] := 1
     resultedFilesList[thisIndex, 3] := 1
     Return 1
  } Else
  {
     cachedAllSessionsSeen[Format("{:L}", imgPath)] := 0
     resultedFilesList[thisIndex, 3] := 0
     Return 0
  }

  lastInvoked := A_TickCount
}

recordSeenIMGdbEntry(imgPath, thisIndex, doCommits:=1) {
   Static invoked := 0
   If (resultedFilesList[thisIndex, 3]=1 || userPrivateMode=1)
      Return

   If (doCommits=1)
      initSeenImagesListDB()

   If (sqlFailedInit=1)
      Return

   FormatTime, currDate, , yyyy-MM-dd@HH
   ; MD5name := currDate
   resultedFilesList[thisIndex, 3] := 1
   cachedAllSessionsSeen[Format("{:L}", imgPath)] := 1

   SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES ('" imgPath "', '" currDate "');"
   If !seenImagesDB.Exec(SQLStr)
   {
      stringA := imgPath
      seenImagesDB.EscapeStr(stringA)
      stringB := currDate
      seenImagesDB.EscapeStr(stringB)
      ; MsgBox, % stringA "--" stringB 
      SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES (" stringA ", " stringB ");"
      err := seenImagesDB.Exec(SQLStr)
      ; If !err
      ; addJournalEntry(seenImagesDB.ErrorMsg " == " seenImagesDB.ErrorCode)
   }

   If (invoked>14 && doCommits=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      invoked := 0
   }

   invoked++
}

eraseSeenIMGsDB() {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If !seenImagesDB
      Return

   msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete the list of seen images?`n`nThis action is irreversible. The actual files will be untouched, only the list of seen images is going to be erased.", "&Erase list|&Cancel", 2, "exclamation")
   If !InStr(msgResult, "erase list")
      Return

   If AnyWindowOpen
      BtnCloseWindow()

   seenImagesDB.CloseDB()
   FileDelete, % mainCompiledPath "\seenImagesList.db"
   Sleep, 5
   seenImagesDB := ""
   showTOOLtip("Already seen images list is now empty.`nEntries will be added only if the option`nto skip seen images is activated.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (mustRecordSeenImgs=1)
      initSeenImagesListDB()
}

initSeenImagesListDB() {
   If (sqlFailedInit=-1 || sqlFailedInit=1)
      Return

   If FileExist(mainCompiledPath "\seenImagesList.db")
      alreadyExisting := 1

   seenImagesDB := new SQLiteDB
   sqlFailedInit := seenImagesDB.hasFailedInit
   If !seenImagesDB.OpenDB(mainCompiledPath "\seenImagesList.db")
   {
      mustRecordSeenImgs := 0
      sqlFailedInit := 1
   } Else If (alreadyExisting!=1)
   {
      SQL := "CREATE TABLE images (imgfile TEXT COLLATE NOCASE UNIQUE ON CONFLICT IGNORE, imgViewDate TEXT, PRIMARY KEY(imgfile ASC)); CREATE INDEX imgsIndex ON images (imgfile COLLATE NOCASE);"
      If !seenImagesDB.Exec(SQL)
      {
         mustRecordSeenImgs := 0
         sqlFailedInit := 1
      } Else
      {
         sqlFailedInit := -1
         seenImagesDB.Exec("BEGIN TRANSACTION;")
      }
   } Else
   {
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      sqlFailedInit := -1
   }
}

SLDBinitSQLdb(fileNamu) {
   activeSQLdb.CloseDB()
   Sleep, 5
   activeSQLdb := new SQLiteDB
   activeSQLdb.OpenDB(fileNamu)
      ; Return -1

   SQL := "CREATE TABLE images (imgidu NUMERIC PRIMARY KEY NOT NULL, imgfile TEXT COLLATE NOCASE NOT NULL, imgfolder TEXT COLLATE NOCASE NOT NULL, fullPath TEXT AS (imgfolder||'\'||imgfile), fsize INT, kbfsize FLOAT AS (round(cast(fsize AS float)/1024,1)), fmodified INT, fcreated INT, imgwidth INT, imgheight INT, imgframes INT, imgdpi INT, imgpixfmt TEXT COLLATE NOCASE, imgwhratio FLOAT AS (round(cast(imgwidth AS float)/imgheight, 5)), imgmegapix FLOAT AS (round((cast(imgwidth AS float)*imgheight)/1000000, 5)), imgmedian FLOAT, imgavg FLOAT, imghpeak FLOAT, imghlow FLOAT, imghmode FLOAT, imghrms FLOAT, imghminu FLOAT, imghrange FLOAT, pixelzFsmall TEXT, HpixelzFsmall TEXT, pixelzFbig TEXT, HpixelzFbig TEXT, dHash TEXT, pHash TEXT, lHash TEXT, HdHash TEXT, HpHash TEXT, HlHash TEXT, isDeleted INT DEFAULT 0, UNIQUE (fullPath));"
   SQL .= "CREATE TABLE imagesData (imgfile TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, imgCaption TEXT, imgAudio TEXT COLLATE NOCASE, PRIMARY KEY(imgfile ASC));"
   SQL .= "CREATE TABLE dynamicfolders (imgfolder TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, fmodified INT, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE staticfolders (imgfolder TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, fmodified INT, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE settings (paramz TEXT COLLATE NOCASE NOT NULL ON CONFLICT REPLACE, valuez TEXT COLLATE NOCASE, PRIMARY KEY(paramz ASC));"
   SQL .= "CREATE INDEX imgsIndex ON images(imgidu, imgfolder, imgfile);"
   If !activeSQLdb.Exec(SQL)
      Return activeSQLdb.ErrorMsg
}

dummy() {
  Sleep, 0
}

setImageLoading() {
  If (slideShowRunning=1 || animGIFplaying=1 || drawingShapeNow=1 || hasInitSpecialMode=1 || liveDrawingBrushTool=1)
     Return

  imageLoading := 1
  changeMcursor("busy-img")
}

ResetImgLoadStatus() {
  If (slideShowRunning=1 || animGIFplaying=1) && (imageLoading!=1 && runningLongOperation!=1)
  {
     If (imageLoading=1)
        SetTimer, ResetImgLoadStatus, -70
     Return
  }

  If !GetKeyState("LButton")
  {
     changeMcursor("normal-extra")
     runningLongOperation := 0
     mustAbandonCurrentOperations := imageLoading := 0
  } Else If (imageLoading=1)
     SetTimer, ResetImgLoadStatus, -70
}

ShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
  Static prevImgPath, lastInvoked := 1
  If (usePrevious=2)
     preventHUDelements := 0

  imgPath := StrReplace(imgPath, "||")
  If (slideShowRunning=1)
  {
     slideShowRunning := interfaceThread.ahkgetvar.slideShowRunning
     If (slideShowRunning!=1)
     {
        StopMediaPlaying(1)
        prevSlideShowStop := A_TickCount
     }
  }

  doIT := ((A_TickCount - lastInvoked<125) && (drawModeAzeit>180 && LastWasFastDisplay!=1 && prevDrawingMode=1)) || ((A_TickCount - lastInvoked<65) && (prevImgPath!=imgPath && drawModeAzeit>50)) || ((A_TickCount - lastInvoked<10) && prevDrawingMode=1) ? 1 : 0
  If (A_TickCount - prevColorAdjustZeit<90) || (animGIFplaying=1 || slideShowRunning=1)
     doIT := 0

  thisModus := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? 1 : 0
  If (usePrevious=0 && ForceIMGload=0 && AnyWindowOpen!=10 && vpImgPanningNow=0
  && doIT=1 && !diffIMGdecX && !diffIMGdecY && thumbsDisplaying!=1 && thisModus!=1)
  {
     ; ToolTip, % Exception("", -1).Line "`n" Exception("", -1).What, , , 2
     zPlitPath(imgPath, 1, OutFileName, OutDir)
     If (vpIMGrotation>0)
        zoomu := " @ " vpIMGrotation "°"
     If (IMGresizingMode=4)
        zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"

     If (userPrivateMode=1)
        winTitle := currentFileIndex "/" maxFilesIndex zoomu
     Else
        winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
     winPrefix := defineWinTitlePrefix()
     pVwinTitle := winPrefix winTitle
     setWindowTitle(pVwinTitle, 1)
     lastInvoked := A_TickCount
     dummyFastImageChangePlaceHolder(OutFileName, OutDir)
     ; SetTimer, dummyFastImageChangePlaceHolder, -15
     dummyTimerReloadThisPicture(550)
     prevImgPath := imgPath
  } Else
  {
     If (animGIFplaying=1)
        usePrevious := 0

     prevImgPath := imgPath
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount

     coreShowTheImage(imgPath, usePrevious, ForceIMGload)
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount
  }

  lastInvoked := A_TickCount
}

coreShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
   Critical, on
   Static prevImgPath, lastInvoked2 := 1, counteru
        , lastInvoked := 1, prevPicCtrl := 1

   WinGet, winStateu, MinMax, ahk_id %PVhwnd%
   If (winStateu=-1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()
      DestroyGIFuWin()
      Return
   }

   startZeitIMGload := A_TickCount
   SetTimer, ResetImgLoadStatus, Off
   ThisPrev := (ForceIMGload=1 || usePrevious=2) ? 1 : 0
   If (imgPath=prevImgPath && StrLen(prevImgPath)>3 && ThisPrev!=1)
      usePrevious := 1

   If (usePrevious=2 || ForceIMGload=1)  ; force no caching
   {
      If (ForceIMGload=1)
         prevImgPath := 1
      usePrevious := 0
   }

   If (vpIMGrotation>0)
      zoomu := " @ " vpIMGrotation "°"
   If (IMGresizingMode=4)
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"

   If (userPrivateMode!=1)
   {
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
   } Else
      winTitle := currentFileIndex "/" maxFilesIndex zoomu
 
   If (thumbsDisplaying=1)
   {
      filesSelInfo := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
      SetTimer, UpdateThumbsScreen, -10
      winPrefix := defineWinTitlePrefix()
      pVwinTitle := winPrefix filesSelInfo currentFileIndex "/" maxFilesIndex " | List mode: " defineListViewModes() " | " CurrentSLD
      setWindowTitle(pVwinTitle, 1)
      If (imageLoading=1)
         SetTimer, ResetImgLoadStatus, -15
      Return
   }

   If !gdiBitmap
   {
      usePrevious := 0
      ForceIMGload := 1
   }
   ; ToolTip, % AprevImgCall "`n" BprevImgCall "`n" imgPath,,,2
   If (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath)) && (ForceIMGload=0) || StrLen(UserMemBMP)>1
      ignoreFileCheck := 1

   If (vpImgPanningNow=0 && usePrevious=0 && ignoreFileCheck!=1)
   {
      If !FileRexists(imgPath)
      {
         destroyGDIfileCache()
         DestroyGIFuWin()
         If (hSNDmedia && autoPlaySNDs!=1)
            StopMediaPlaying()
         If (slideShowRunning=1)
            invokeExternalSlideshowHandler()

         If (WinActive("A")=PVhwnd)
         {
            winTitle := "[*] " winTitle
            pVwinTitle := winTitle
            setWindowTitle(pVwinTitle, 1)
            clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIwin)
            showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir "\")
            SetTimer, RemoveTooltip, % -msgDisplayTime
         }

         If (imgPath!=prevImgPath)
         {
            If (minimizeMemUsage=1)
               terminateIMGediting()

            If (A_TickCount - lastInvoked2>125) && (A_TickCount - lastInvoked>95)
            {
               SoundBeep, 300, 50
               lastInvoked2 := A_TickCount
            }
    
            If (autoRemDeadEntry=1)
               remCurrentEntry(1)
            lastInvoked := A_TickCount
            SetTimer, ResetImgLoadStatus, -15
            Return "fail"
         }
      }
   }

   thisModus := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? 1 : 0
   If (A_TickCount - lastInvoked>85) && (A_TickCount - lastInvoked2>85)
   || (slideShowRunning=1 || animGIFplaying=1 || usePrevious=1 || oldZoomLevel || ForceIMGload=1 || diffIMGdecX || diffIMGdecY || LastWasFastDisplay=1)
   {
       lastInvoked := A_TickCount
       r2 := ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload)
       ; msgbox, % r2
       If InStr(r2, "error")
       {
          DestroyGIFuWin()
          destroyGDIfileCache()
          If (hSNDmedia && autoPlaySNDs!=1)
             StopMediaPlaying()
          If (slideShowRunning=1)
             invokeExternalSlideshowHandler()

          friendly := (A_PtrSize=4) ? "`nOr, insufficient memory." : ""
          errMsg := "ERROR: Unable to display the image: " groupDigits(currentFileIndex) "`nPossibly malformed image file format or access denied." friendly "`n" r2 "`n" OutFileName "`n" OutDir "\"
          If (WinActive("A")=PVhwnd)
          {
             clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIwin)
             showTOOLtip(errMsg)
             SetTimer, RemoveTooltip, % -msgDisplayTime
          } Else addJournalEntry(errMsg)
      
          winTitle := "[*] " winTitle
          pVwinTitle := winTitle
          setWindowTitle(pVwinTitle, 1)
          SetTimer, ResetImgLoadStatus, -15
          If (slideShowRunning!=1)
             SoundBeep, 300, 100
          Return "fail"
       } Else prevImgPath := imgPath
       lastInvoked := A_TickCount
   } Else If (vpImgPanningNow=0 && thisModus!=1)
   {
      winPrefix := defineWinTitlePrefix()
      pVwinTitle := winPrefix winTitle
      setWindowTitle(pVwinTitle, 1)
      delayu := (A_TickCount - prevFastDisplay < 500) ? 110 : 325
      dummyFastImageChangePlaceHolder(OutFileName, OutDir)
      dummyTimerReloadThisPicture(delayu)
   }
   ; SetTimer, ResetImgLoadStatus, -15
   lastInvoked2 := A_TickCount
}

dummyFastImageChangePlaceHolder(OutFileName, OutDir) {
   Static lastInvoked := 1, prevImgPath
   If (A_TickCount - lastInvoked<50)
      Return

   lastInvoked := A_TickCount
   entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
   If (entireString=prevImgPath)
      Return

   prevImgPath := entireString
   CreateOSDinfoLine(entireString, 0, 0, currentFileIndex/maxFilesIndex)
   SetTimer, RemoveTooltip, -500
}

calcImgSizeForVP(modus, imgW, imgH, GuiW, GuiH, ByRef ResizedW, ByRef ResizedH) {
   If (imgW<=GuiW && imgH<=GuiH && modus=2)
   {
      ResizedW := imgW
      ResizedH := imgH
   } Else If (modus=5)
   {
      ResizedW := GuiW
      ResizedH := GuiH
   } Else calcIMGdimensions(imgW, imgH, GuiW, GuiH, ResizedW, ResizedH)

    ; ToolTip, % modus "=modusa" , , , 2
}

ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload) {
    Critical, on
    Static oImgW, oImgH, prevImgPath, lastTitleChange := 1
         , IDprevImgPath, tinyW, tinyH, wscale, prevSize

    setImageLoading()
    If (editingSelectionNow=1 && IMGresizingMode=5)
    {
       IMGresizingMode := 1
       interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
    }

    imgPath := StrReplace(imgPath, "||")
    setWindowTitle("Loading file | " imgPath)
    changeMcursor()
    calcScreenLimits()
    ; If (winGDIcreated!=1)
    ;   createGDIwin()
    ; o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    o_AutoDownScaleIMGs := (AutoDownScaleIMGs>0) ? 1 : 0
    extraID := ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation usrTextureBGR usrColorDepth bwDithering
    IDthisImgPath := imgPath "-" userHQraw extraID
    If (imgPath!=prevImgPath || IDthisImgPath!=IDprevImgPath || !gdiBitmap || ForceIMGload=1)
    {
       ; ToolTip, % imgPath "`n" prevImgPath , , , 2
       gdiBMPchanged := 1
       If (imgPath!=prevImgPath) && (currentFileIndex!=0)
       {
          terminateIMGediting()
          desiredFrameIndex := 0
          If (AutoDownScaleIMGs=2)
             AutoDownScaleIMGs := 1
       }

       mustReloadIMG := (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath) || (ForceIMGload=1) ? 1 : 0
       If (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath)
       {
          usePrevious := 0
          mustReloadIMG := ForceIMGload := 1
          If (currentFileIndex!=0)
             GdipCleanMain(6)
       }

       disposeCacheIMGs()
       changeMcursor()
       r1 := CloneMainBMP(imgPath, oImgW, oImgH, mustReloadIMG, hasFullReloaded)
       abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
       If (imgFxMode=3 && r1!="error" && abortImgLoad<3)
       {
          setWindowTitle("Calculating auto-color adjustments")
          AdaptiveImgLight(gdiBitmap, imgPath, oImgW, oImgH)
       }

       If (abortImgLoad>2)
       {
          o_ImgQuality := userimgQuality
          If (userimgQuality=1)
             ToggleImgQuality("lowu")
          If (desiredFrameIndex<1 && (usrColorDepth>1 || vpIMGrotation>0))
          {
             setWindowTitle("Image processing aborted")
             showTOOLtip("Image processing aborted")
             SetTimer, RemoveTooltip, % -msgDisplayTime//2
          }
       }
       If (lockSelectionAspectRatio=4)
          defineSelectionAspectRatios()
    }

    If (!gdiBitmap || r1="error")
    {
       If (o_ImgQuality=1)
          ToggleImgQuality("highu")
       If (AutoDownScaleIMGs=2)
          AutoDownScaleIMGs := 1

       prevImgPath := ""
       interfaceThread.ahkassign("canCancelImageLoad", 0)
       FadeMainWindow()
       SetTimer, ResetImgLoadStatus, -15
       r := (r1="error") ? r1 : 0
       Return r
    }

   prevImgPath := imgPath
   IDprevImgPath := imgPath "-" userHQraw extraID
   GetWinClientSize(GuiW, GuiH, PVhwnd, 0)
   imgW := oImgW
   imgH := oImgH
   decideUndoLevelsAccepted(imgW, imgH)
   If (IMGresizingMode=3) ; original [100%]
   {
      lGuiW := (GuiW>imgW) ? imgW : GuiW
      lGuiH := (GuiH>imgH) ? imgH : GuiH
      ws := Round(ResizedW / imgW * 100)
      If (ws<100)
      {
         ws := Round(((lGuiW*lGuiH) / (imgW*imgH)) * 100)
         ws .= "% visible"
      } Else If (ws>100)
      {
         ws := "100%"
      } Else ws .= "%"
      zoomLevel := 1
      ResizedW := imgW
      ResizedH := imgH
   } Else If (IMGresizingMode=4) ; custom zoom level
   {
      prevVPsize := max(prevResizedVPimgW, prevResizedVPimgH)
      If (customZoomAdaptMode>0)
      {
         zoomLevel := (customZoomAdaptMode=1) ? GuiW/oImgW : GuiH/oImgH
         zoomLevel := clampInRange(Round(zoomLevel, 3), 0.01, 20)
         ResizedW := Round(oimgW * zoomLevel, 3)
         ResizedH := Round(oimgH * zoomLevel, 3)
         ws := Round(zoomLevel * 100) "%"
      } Else If (prevVPsize>2 && gdiBMPchanged=1 && lockZoomLevel=0 && animGIFplaying!=1 && allowFreeIMGpanning=0)
      {
         calcImgSizeForVP(1, oimgW, oimgH, prevVPsize, prevVPsize, ResizedW, ResizedH)
         zoomLevel := clampInRange(Round(ResizedW / imgW, 3), 0.01, 20)
         ResizedW := Round(oimgW * zoomLevel, 3)
         ResizedH := Round(oimgH * zoomLevel, 3)
         ws := Round(zoomLevel * 100) "%"
      } Else
      {
         ResizedW := Round(imgW * zoomLevel, 3)
         ResizedH := Round(imgH * zoomLevel, 3)
         ws := Round(zoomLevel * 100) "%"
      }
   } Else
   {
      calcImgSizeForVP(IMGresizingMode, oimgW, oimgH, GuiW, GuiH, ResizedW, ResizedH)
      zoomLevel := Round(ResizedW / imgW, 3)
      ws := Round(ResizedW / imgW * 100) "%"
   }

   ; ToolTip, % imgW ", " oImgW ", " roImgW ", " ResizedW ,,, 2
   IMGlargerViewPort := ((ResizedH-5>GuiH+1) || (ResizedW-5>GuiW+1)) ? 1 : 0
   IMGentirelylargerThanVP := ((ResizedH-5>GuiH+1) && (ResizedW-5>GuiW+1)) ? 1 : 0
   If (vpIMGrotation>0)
      zoomu := " @ " vpIMGrotation "°"

   winPrefix := defineWinTitlePrefix()
   If (userPrivateMode!=1)
   {
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      winTitle := winPrefix currentFileIndex "/" maxFilesIndex " [" ws zoomu "] | " OutFileName " | " OutDir "\"
   } Else
      winTitle := winPrefix currentFileIndex "/" maxFilesIndex " [" ws zoomu "]"

   If (A_TickCount - lastTitleChange>300)
      setWindowTitle("Adapting image to viewport")

   If (allowFreeIMGpanning=1 && imageAligned=5 && (gdiBMPchanged=1 || isVarEqualTo(PrintPosX, "X", "W", "C")) && IMGresizingMode=4)
   {
      thisSize := "a" Round(GuiW/2 - ResizedW/2) . Round(GuiH/2 - ResizedH/2) imgPath currentFileIndex maxFilesIndex prevResizedVPimgW prevResizedVPimgH
      If (PrintPosX="W")
      {
         IMGdecalageX += Round((prevResizedVPimgW - ResizedW)/2)
         IMGdecalageY += Round((prevResizedVPimgH - ResizedH)/2)
         prevSize := thisSize
      } Else If (prevSize!=thisSize || PrintPosX="X")
      {
         PrintPosX := "C"
         prevSize := thisSize
         IMGdecalageX := Round(GuiW/2 - ResizedW/2)
         IMGdecalageY := Round(GuiH/2 - ResizedH/2)
      }
   }

   prevResizedVPimgW := ResizedW := Round(ResizedW)
   prevResizedVPimgH := ResizedH := Round(ResizedH)
   prevMaxSelX := roImgW ? roImgW : oImgW
   prevMaxSelY := roImgH ? roImgH : oImgH
   If (hSNDsong && StrLen(SlidesMusicSong)>3 && autoPlaySlidesAudio=1 && gdiBMPchanged=1)
   {
      If RegExMatch(MCI_Status(hSNDsong), "i)^(stop|pause)")
      {
         MCI_SendString("seek " hSNDsong " to 1 wait")
         If MCI_Play(hSNDsong)
            StopMediaPlaying(1)
      }
   }

   If (editingSelectionNow=1 && relativeImgSelCoords=1 && gdiBMPchanged=1)
      calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

   GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
   If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && (animGIFplaying!=1 || desiredFrameIndex=0) && slideShowDelay>950)
      GDIfadeVPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)

   changeMcursor()
   pVwinTitle := infoFilesSel infoFrames winTitle
   r := QPV_ShowImgonGui(ResizedW, ResizedH, GuiW, GuiH, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged, wasPrevious)
   delayu := (A_TickCount - prevFastDisplay < 300) ? 90 : 550
   thisModus := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? 1 : 0
   If (wasPrevious=1 && animGIFplaying!=1 && vpImgPanningNow=0 && thisModus!=1)
      dummyTimerReloadThisPicture(delayu)

   infoFilesSel := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
   If (totalFramesIndex>0)
      infoFrames := "["  desiredFrameIndex "/" totalFramesIndex "] "

   setWindowTitle(pVwinTitle, 1)
   lastTitleChange := A_TickCount
   If (o_ImgQuality=1)
      ToggleImgQuality("highu")

   SetTimer, ResetImgLoadStatus, -15
   Return r
}

drawinfoBox(mainWidth, mainHeight, directRefresh, Gu) {
    Static prevMsg, prevOSDfnt
    modus := (StrLen(UserMemBMP)>2 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : "welcome"
    If (modus="welcome")
       Return

    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    infoFilesSel := (markedSelectFile>0) ? "`nFiles selected: " groupDigits(markedSelectFile) " ( " Round(markedSelectFile/maxFilesIndex*100, 2) "% )" : ""
    If (totalFramesIndex>0 || currIMGdetails.Frames>1) && (thumbsDisplaying!=1)
    {
       thisFramesInfo := (totalFramesIndex>0) ? totalFramesIndex : currIMGdetails.Frames
       infoFrames := "`nMultiple pages: " desiredFrameIndex " / " thisFramesInfo
    }

    zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
    If FileExist(imgPath)
    {
       QPV_FileGetSizeTime(imgPath, "R", currentFileIndex)
       fileSizu := fileSizeFrienly(resultedFilesList[currentFileIndex, 6])
       FileDateM := resultedFilesList[currentFileIndex, 7]
       Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
       fileMsg := "`n" fileSizu " | " FileDateM
    } Else If (currentFileIndex!=0)
       fileMsg := "`nFile not found or access denied..."

    fileIndexu := (maxFilesIndex>1) ? " | " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) " (" Round((currentFileIndex/maxFilesIndex)*100, 2) "%)" : ""
    If (userPrivateMode=1 && StrLen(folderu)>3)
    {
       fileRelatedInfos := "*****.***`n*:\******\*****\" fileMsg fileIndexu
    } Else
    {
       OutDir := PathCompact(folderu, "a", 1, OSDfontSize//1.1, 0, 45)
       fileRelatedInfos := (StrLen(folderu)>3) ? fileNamu "`n" OutDir "\" fileMsg fileIndexu : ""
    }

    If (thumbsDisplaying!=1)
    {
       If (vpIMGrotation>0)
          infoRotate := " @ " vpIMGrotation "°"

       infoSizing := "`nRescaling mode: " DefineImgSizing()
       If (IMGresizingMode!=5)
       {
          infoSizing .= (IMGresizingMode!=4) ? " | " Round(zoomLevel*100) "%" infoRotate : infoRotate
          If (showInfoBoxHUD=2)
             infoSizing .= "`nViewport alignment: " defineImgAlign()
       }

       infoRes := "`nResolution: " groupDigits(maxSelX) " x " groupDigits(maxSelY) " px (" Round(maxSelX/maxSelY, 2) ") | " Round((maxSelX*maxSelY)/1000000,2) " MPx"
       If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1)
          infoRes .= " | DOWNSCALED"
       If (currIMGdetails.TooLargeGDI=1)
          infoRes .= "`nOriginal resolution: " groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
       ; infoRes := "`nResolution (W x H): " thisW " x " thisH " px [ " Round(zoomLevel*100) "%" infoRotate " ]"
    } Else
    {
       thisFileIndex := currentFileIndex
       If (showInfoBoxHUD=2)
       {
          infoSizing := "`nThumbnails alignment: " defineImgAlign() "`nThumbnails size: " thumbsW " x " thumbsH " px (" Round(thumbsW/thumbsH, 2) ") | Intended: " defineThumbsAratio()
          thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
          infoSizing .= "`nThumbnails grid: " maxItemsW " x " maxItemsH " = " maxItemsPage
       }

       If (!resultedFilesList[thisFileIndex, 9] && notFound!=1)
       {
          If !retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12], 1)
             GetCachableImgFileDetails(imgPath, thisFileIndex)
          If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
             updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
       }

       If (notFound!=1)
       {
          asr := " px (" Round(resultedFilesList[thisFileIndex, 13] / resultedFilesList[thisFileIndex, 14], 2) ") | "
          infoRes := "`nResolution: " groupDigits(resultedFilesList[thisFileIndex, 13]) " x " groupDigits(resultedFilesList[thisFileIndex, 14]) asr resultedFilesList[thisFileIndex, 17] " MPx"
          infoRes .= " | " resultedFilesList[thisFileIndex, 22] " DPI"
          infoRes .= (resultedFilesList[thisFileIndex, 9]>1) ? "`nImage frames: " resultedFilesList[thisFileIndex, 9] : ""
          infoRes .= "`nPixel format: " resultedFilesList[thisFileIndex, 15]
       }
    }

    If (userPrivateMode=1)
       infoEditing := "PRIVATE MODE UI`n"

    If StrLen(UserMemBMP)>2
    {
       infoEditing .= "IMAGE EDITING MODE`n"
       If (showInfoBoxHUD=2 && thumbsDisplaying!=1)
          infoEditing .= "Undo levels recorded: " currentUndoLevel " / " undoLevelsRecorded "`n"
    }

    knobSize := imgHUDbaseUnit//3
    If (showInfoBoxHUD=1)
    {
       hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
       If (thumbsDisplaying=1)
       {
          tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
          tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
       } Else
       {
          tlbrBonusX := (hasTrans=1 && FlipImgH=0) ? ToolbarWinW : 0
          If (FlipImgH=1 && scrollBarVx>1)
             tlbrBonusX += knobSize

          tlbrBonusY := (hasTrans=2 && FlipImgV=0) ? ToolbarWinH : 0
          If (FlipImgV=1 && scrollBarHy>1)
             tlbrBonusY += knobSize
       }

       entireString := infoEditing fileRelatedInfos infoRes infoSizing infoFrames
       thisOSDfnt := OSDFontName FlipImgH FlipImgV OSDfontSize OSDbgrColor OSDtextColor
       If (prevMsg!=entireString || prevOSDfnt!=thisOSDfnt)
       {
          prevOSDfnt := thisOSDfnt
          infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
          infoBoxGdiCached := drawTextInBox(entireString, OSDFontName, OSDfontSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 1, !thumbsDisplaying)
          prevMsg := entireString
       }
       Gdip_GetImageDimensions(infoBoxGdiCached, imgW, imgH)
       trGdip_DrawImage(A_ThisFunc, Gu, infoBoxGdiCached, tlbrBonusX, tlbrBonusY)
       lastInfoBoxBMP[1] := [imgW, imgH]
       interfaceThread.ahkPostFunction("uiAccessUpdateInfoBox", entireString, imgW, imgH, FlipImgV, FlipImgH)
       Return
    }

    mamUsage := GetProcessMemoryUsage(QPVpid)
    If (A_PtrSize=8)
       systemMemInfo := GlobalMemoryStatusEx()

    thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/1500063598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
    totalMemoryLoad := (A_PtrSize=8) ? "/ " Round(systemMemInfo.TotalPhys/1024**3, 1) " GB" : "/ 1.5 GB"
    memUsage := "`nMemory usage: " Round(max(mamUsage[1], mamUsage[8]) / 1024**2, 1) " MB " totalMemoryLoad " | " thisMemoryLoad "%"
    If (userPrivateMode!=1)
    {
       If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
          memUsage.= "`nFile matched search criteria: " thisSearchString
    }

    sliSpeed := Round(slideShowDelay/1000, 2) " sec."
    If (slideShowRunning=1)
       infoSlider := "`nSlideshow running: " DefineSlideShowType() " @ " sliSpeed

    infoMirroring := defineIMGmirroring()
    If (editingSelectionNow=1 && thumbsDisplaying!=1)
    {
       imgSelW := Round(max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2))
       imgSelH := Round(max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2))
       If (relativeImgSelCoords=1)
       {
          x1 := " [ " Round(prcSelX1 * 100) "%, "
          y1 := Round(prcSelY1 * 100) "% ]"
          wP := " [ " Round((prcSelX2 - prcSelX1) * 100) "%, "
          hP := Round((prcSelY2 - prcSelY1) * 100) "% ]"
          ; moreSelInfo := "`nCoordinates relative to image size"
       }

       infoLocked := (lockSelectionAspectRatio>1) ? "`n  Locked aspect ratio: " defineSelectionAspectRatios() : "`n  Aspect ratio: " Round(imgSelW/imgSelH, 2)
       infoLocked .= (LimitSelectBoundsImg=1) ? "`n  Selection area limited to image boundaries" : ""
       imgSelW := groupDigits(imgSelW)
       imgSelH := groupDigits(imgSelH)
       infoSelection := "`n `n" DefineVPselAreaMode() " selection coordinates:`n  X / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) x1 y1 "`n  W / H: " imgSelW ", " imgSelH wP hP moreSelInfo "`n  Rotation: " Round(VPselRotation, 2) "°" infoLocked
       If (innerSelectionCavityX>0.01 && innerSelectionCavityY>0.01)
          infoSelection .= "`n  Exclusion area defined"
    } Else If (editingSelectionNow=1)
       infoSelection := "`nSelection area activated in image view"

    typeu :=  defineFilesListType()
    If (typeu && userPrivateMode!=1)
    {
       infoThisSLD := "`nFiles list opened: "
       If (SLDtypeLoaded>1)
          sldu := PathCompact(CurrentSLD, 40)
       If sldu
          infoThisSLD .= sldu
       Else
          infoThisSLD .= typeu
    }

    If (usrColorDepth>1)
       infoColorDepth := "`nSimulated color depth: " defineColorDepth()

    If (StrLen(filesFilter)>1)
    {
       modus := (userFilterInvertThis=1) ? ": (inverted)`n" : ":`n"
       infoFilteru := "`nFiles list filtered from " groupDigits(bckpMaxFilesIndex) " down to " groupDigits(maxFilesIndex) " ( " Round(maxFilesIndex/bckpMaxFilesIndex*100, 2) "% )."
       oldIndex := filteredMap2mainList[currentFileIndex]
       If oldIndex
          infoFilteru .= "`nIndex in main list: " groupDigits(oldIndex)
       If (userPrivateMode!=1)
          infoFilteru .= "`nFilter pattern used" modus SubStr(filesFilter, 1, 45)

       ; If (userFilterDoString=1 && UsrEditFilter!="")
       ;    infoFilteru .= UsrEditFilter
    }

    totalZeit := A_TickCount - startZeitIMGload + 2
    InfoLoadTime := "`nViewport size: " groupDigits(mainWidth) " x " groupDigits(mainHeight) " px (" Round(mainWidth/mainHeight, 2) ")"
    If (thumbsDisplaying!=1 && directRefresh=1)
    {
       InfoLoadTime .= "`nViewport refresh speed: ~" groupDigits(totalZeit) " milisec."
       If (currIMGdetails.HasAlpha=1)
          InfoLoadTime .= " (*)"
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If (userPrivateMode=1)
          OutFileName := "*******.***"

       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " | " sndMediaPos hSNDmediaDuration
       }
       infoAudio := "`nAudio file associated: " OutFileName mediaDuration statusMedia
    }

    If (animGIFplaying=1)
       infoAnim := "`nGIF animation playing at " GIFspeedDelay " ms / frame."

    If (imgFxMode>1 || usrColorDepth>1)
       infoColors := "`nColors display mode: " DefineFXmodes()

    If (thumbsDisplaying!=1)
       infoPixFmt := "`nPixel format: " currIMGdetails.PixelFormat " | " currIMGdetails.RawFormat

    If (resultedFilesList[currentFileIndex, 5]=1)
       infoFaved := "`nImage: FAVOURITED"

    If (resultedFilesList[currentFileIndex, 3]=1)
       infoFaved := infoFaved ? infoFaved " and ALREADY SEEN" : "`nImage: ALREADY SEEN"

    If (thumbsDisplaying=1)
    {
       maxLimitReached := (minimizeMemUsage=1) && (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
       mustDoMultiCore := (allowMultiCoreMode=1 && maxLimitReached!=1 && multiCoreThumbsInitGood=1) ? 1 : 0
       friendlyCoreInfo := (mustDoMultiCore=1) ? "ACTIVATED" : "DEACTIVATED"
       memUsage .= "`nMulti-threaded mode: " friendlyCoreInfo
   }

    hasTrans := adjustCanvas2Toolbar(Gu, 0)
    entireString := infoEditing fileRelatedInfos infoFaved infoRes infoPixFmt memUsage infoSizing infoMirroring infoColors infoColorDepth infoFrames infoAnim InfoLoadTime infoThisSLD infoFilesSel infoAudio infoSlider infoFilteru infoSelection 
    tlbrBonusX := (hasTrans=1 && (FlipImgH=0 || thumbsDisplaying=1)) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2 && (FlipImgV=0 || thumbsDisplaying=1)) ? ToolbarWinH : 0
    If (FlipImgH=1 && thumbsDisplaying=0 && scrollBarVx>1)
    {
       tlbrBonusX += knobSize
       scX := knobSize
    }

    If (FlipImgV=1 && thumbsDisplaying=0 && scrollBarHy>1)
    {
       tlbrBonusY += knobSize
       scY := knobSize
    }

    borderSize := imgHUDbaseUnit//6
    thisTxtAlignu := (thumbsDisplaying=1) ? "Left" : 0
    txtOptions := initInPlaceTextOptions(thisGu, OSDfontBolded, 0, 1, thisTxtAlignu, OSDFontName, OSDfontSize//1.1, "0xEE" OSDtextColor, "0xEE" OSDbgrColor, borderSize)
    otherTxtObj := TextuToGraphics(thisGu, "initing", txtOptions, OSDFontName, "begin", 0, 0, 1)
    dims := TextuToGraphics(Gu, entireString, nul, OSDFontName, "measure", 0, otherTxtObj)
    dimsFw := clampInRange(dims.w + borderSize*2, 0, mainWidth)
    dimsFh := clampInRange(dims.h + borderSize*2, 0, mainHeight)
    txtOptions.x := (FlipImgH=1 && thumbsDisplaying!=1) ? - tlbrBonusX : borderSize + tlbrBonusX
    txtOptions.y := (FlipImgV=1 && thumbsDisplaying!=1) ? mainHeight - dimsFh + borderSize - tlbrBonusY : borderSize + tlbrBonusY
    txtOptions.w := mainWidth - borderSize
    txtOptions.h := mainHeight - borderSize
    lastInfoBoxBMP[1] := [dimsFw, dimsFh]
    interfaceThread.ahkPostFunction("uiAccessUpdateInfoBox", entireString, dimsFw, dimsFh, FlipImgV, FlipImgH, tlbrBonusX, tlbrBonusY, scX, scY)
    Gdip_FillRectangle(Gu, OSDwinFadedBrushBGR, tlbrBonusX, tlbrBonusY, dimsFw, dimsFh)
    If (thumbsDisplaying!=1)
       Gdip_ResetWorldTransform(Gu)

    drawInPlaceTextInBox(Gu, entireString, txtOptions)
    If (thumbsDisplaying!=1)
       setMainCanvasTransform(mainWidth, mainHeight, Gu)
}

drawAnnotationBox(mainWidth, mainHeight, Gu) {
    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    imgPath := getIDimage(currentFileIndex)

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " (" sndMediaPos hSNDmediaDuration  ")"
       }
       If mediaDuration
          infoAudio := "Audio file associated" mediaDuration statusMedia "`n"
    } ; Else If (autoPlaySNDs=1)
      ;  infoAudio := "No audio file associated.`n"


    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"
    If (SLDtypeLoaded=3)
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

    If !textFileContent
    {
       Try FileRead, textFileContent, % textFile
       If StrLen(textFileContent)<1
          textFileContent := ""
    }

    entireString := infoAudio textFileContent
    If !entireString
       Return

    infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfontSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0, 1, usrTextAlign)
    Gdip_GetImageDimensions(infoBoxBMP, imgW, imgH)
    thisPosY := mainHeight - imgH
    thisPosX := mainWidth - imgW
    If (FlipImgV=0)
       thisPosY -= scrollBarHy

    If (usrTextAlign="Left")
       thisPosX := 0
    Else If (usrTextAlign="Center")
       thisPosX := mainWidth//2 - imgW//2

    If (FlipImgH=1)
       thisPosX += scrollBarVx
    Else If (thisPosX + imgW>mainWidth - scrollBarVx)
       thisPosX -= scrollBarVx

    If infoBoxBMP
    {
       trGdip_DrawImage(A_ThisFunc, Gu, infoBoxBMP, thisPosX, thisPosY)
       If (FlipImgH=1 && usrTextAlign="Left")
          thisPosX := mainWidth - imgW - scrollBarVx
       Else If (FlipImgH=1 && usrTextAlign="Right")
          thisPosX := 0
       If (FlipImgV=1)
          thisPosY := 0
       interfaceThread.ahkPostFunction("uiAccessUpdateAnnoBox", entireString, imgW, imgH, thisPosX, thisPosY)
    }
    infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
}

clampInRange(value, min, max, reverse:=0) {
   If (reverse=1)
   {
      If (value>max)
         value := min
      Else If (value<min)
         value := max
   } Else
   {
      If (value>max)
         value := max
      Else If (value<min)
         value := min
   }

   Return value
}

changeOSDfontSize(direction) {
  stepu := (OSDfontSize>30) ? 5 : 2
  If (direction=1)
     OSDfontSize += stepu
  Else
     OSDfontSize -= stepu

  OSDfontSize := clampInRange(OSDfontSize, 15, 350)
  INIaction(1, "OSDfontSize", "General")
  showTOOLtip("OSD font size: " OSDfontSize, A_ThisFunc, 2, OSDfontSize/350)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  calcHUDsize()
  recalculateThumbsSizes()
  interfaceThread.ahkassign("OSDfontSize", OSDfontSize)
  updateUIctrl()
  If (thumbsListViewMode>1 && thumbsDisplaying=1)
  {
     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(25)
  } Else If (thumbsDisplaying=1)
     SetTimer, mainGdipWinThumbsGrid, -25
  Else If (CurrentSLD && maxFilesIndex>0)
     SetTimer, dummyRefreshImgSelectionWindow, -25

  If (ShowAdvToolbar=1)
     SetTimer, createGUItoolbar, -500
}

determineGDIsmallCacheSize(mainWidth, mainHeight) {
  Resized := []
  Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
  if (imgW*imgH>640000)
     size := 300
  Else
     size := 800

  calcIMGdimensions(imgW, imgH, size, size, ResizedW, ResizedH)

  Resized.Wsmall := ResizedW
  Resized.Hsmall := ResizedH
  Resized.Small := Round((ResizedW * ResizedH)/1000000, 2)
  Resized.Main := Round((imgW * imgH)/1000000, 2)
  Resized.Screen := Round((Floor(mainWidth*1.15) * Floor(mainHeight*1.15))/1000000, 2)
  Return Resized
}

RescaleBMPtiny(imgPath, mainWidth, mainHeight) {
  Critical, on
  Static prevImgPath
  Gdip_GetImageDimensions(useGdiBitmap(), fimgW, fimgH)
  thisID := "|==|" ColorDepthDithering vpIMGrotation desiredFrameIndex totalFramesIndex currentUndoLevel undoLevelsRecorded fimgW fimgH
  If (Strlen(gdiBitmapSmall)>3 && prevImgPath=gdiBitmapIDentire && InStr(gdiBitmapIDentire, imgPath) && InStr(gdiBitmapIDentire, thisID))
     Return gdiBitmapSmall

  gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
  Resized := determineGDIsmallCacheSize(mainWidth, mainHeight)
  If StrLen(gdiBMPvPsize)>3 
  {
     Gdip_GetImageDimensions(gdiBMPvPsize, otherW, otherH)
     vpIMGres := Round((otherW * otherH)/1000000)
  }

  thisImgQuality := (userimgQuality=1) ? 3 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  changeMcursor()
  whichBitmap := (StrLen(gdiBMPvPsize)>3 && vpIMGres>Resized.Small*1.01) ? gdiBMPvPsize : gdiBitmap
  gdiBitmapSmall := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, Resized.Wsmall, Resized.Hsmall, 0, thisImgQuality, -1)
  ; gdiBitmapSmall := Gdi_ResizeBitmap(whichBitmap, Resized.W, Resized.H, 0, 4)
  gdiBitmapIDentire := SubStr(gdiBitmapIDentire, 1, InStr(gdiBitmapIDentire, "|==|") - 1) . thisID
  prevImgPath := gdiBitmapIDentire
  If StrLen(gdiBitmapSmall)>3
     Return gdiBitmapSmall
}

RescaleBMPtinyVPsize(imgPath, GuiW, GuiH) {
  Critical, on

  Static prevImgPath
  Gdip_GetImageDimensions(useGdiBitmap(), fimgW, fimgH)
  thisID := "|==|" ColorDepthDithering vpIMGrotation desiredFrameIndex totalFramesIndex currentUndoLevel undoLevelsRecorded fimgW fimgH
  If (StrLen(gdiBMPvPsize)>3 && prevImgPath=gdiBitmapIDentire && InStr(gdiBitmapIDentire, imgPath) && InStr(gdiBitmapIDentire, thisID))
     Return gdiBMPvPsize

  gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
  thisImgQuality := (userimgQuality=1) ? 6 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  changeMcursor()
  gdiBMPvPsize := trGdip_ResizeBitmap(A_ThisFunc, gdiBitmap, Floor(GuiW*1.15), Floor(GuiH*1.15), 0, thisImgQuality, -1)
  gdiBitmapIDentire := SubStr(gdiBitmapIDentire, 1, InStr(gdiBitmapIDentire, "|==|") - 1) . thisID
  ; ToolTip, % gdiBitmapIDentire "`n" prevImgPath , , , 2
  prevImgPath := gdiBitmapIDentire
  If StrLen(gdiBMPvPsize)>3
     Return gdiBMPvPsize
}

setGIFframesDelay() {
   GIFspeedDelay := (totalFramesIndex>75) ? 35 : 45
   If (totalFramesIndex>195)
      GIFspeedDelay := 20
   Else If (totalFramesIndex<15)
      GIFspeedDelay := 60

   If (totalFramesIndex<8)
      GIFspeedDelay := 85

   GIFspeedDelay := GIFspeedDelay + UserGIFsDelayu
}

multiPageFileManaging(oBitmap, frameu) {
   rawFmt := Gdip_GetImageRawFormat(oBitmap)
   If RegExMatch(rawFmt, "i)(gif|tiff)$")
   {
      tFrames := Gdip_GetBitmapFramesCount(oBitmap) - 1
      If (tFrames<0 || !tFrames)
         tFrames := 0

      If (frameu>=tFrames)
         frameu := tFrames

      setGIFframesDelay()
      If (tFrames>0 && slideShowRunning=1 && SlideHowMode=1 && animGIFsSupport!=1)
         Random, frameu, 0, % tFrames

      Gdip_BitmapSelectActiveFrame(oBitmap, frameu)
      Return tFrames
   }
   Return 0
}

LoadFileWithWIA(imgPath, fastMode, noBMP:=0, sizesDesired:=0, ByRef newBitmap:=0) {
   oBitmap := 0
   thisZeit := A_TickCount
   Try wiaImg := WIA_LoadImage(imgPath)
   If IsObject(wiaImg)
   {
      mainLoadedIMGdetails.File := imgPath
      mainLoadedIMGdetails.dpi := Round((wiaImg.HorizontalResolution + wiaImg.VerticalResolution)/2)
      mainLoadedIMGdetails.Width := wiaImg.Width
      mainLoadedIMGdetails.Height := wiaImg.Height
      mainLoadedIMGdetails.Frames := wiaImg.FrameCount
      mainLoadedIMGdetails.HasAlpha := wiaImg.IsAlphaPixelFormat
      If (wiaImg.IsAlphaPixelFormat=1)
         extraPixelFormat := "A"
      If (wiaImg.IsIndexedPixelFormat)
         extraPixelFormat .= " [INDEXED-" wiaImg.IsIndexedPixelFormat "]"
      If (wiaImg.IsExtendedPixelFormat)
         extraPixelFormat .= " [EXTENDED-" wiaImg.IsExtendedPixelFormat "]"
      mainLoadedIMGdetails.PixelFormat := wiaImg.PixelDepth "-bit RGB" extraPixelFormat
      mainLoadedIMGdetails.RawFormat := WIA_GetImageFormatID(wiaImg)
      mainLoadedIMGdetails.OpenedWith := "Windows Image Acquisition (WIA)"
      mainLoadedIMGdetails.TooLargeGDI := isImgSizeTooLarge(wiaImg.Width, wiaImg.Height)
      If (noBMP=1)
         oBitmap := 1
   } Else
   {
      addJournalEntry("Failed to load image file using WIA`n" imgPath)
      Return
   }

   If (fastMode!=1 && IsObject(wiaImg) && noBMP=0)
   {
      forceW := sizesDesired[1, 1]
      forceH := sizesDesired[1, 2]
      keepAratio := sizesDesired[1, 3]
      ScaleAnySize := sizesDesired[1, 4]
      If (forceW && forceH)
      {
         If (wiaImg.Width>forceW || wiaImg.Height>forceH || ScaleAnySize=1)
            Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, forceW, forceH, keepAratio)
      } Else If isImgSizeTooLarge(wiaImg.width, wiaImg.height)
      {
         mainLoadedIMGdetails.TooLargeGDI := 1
         setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits")
         changeMcursor()
         Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, 32500, 32500, 1)
      }
   }

   If (IsObject(wiaImg) && noBMP=0)
   {
      Try PicObj := ScaledWiaIMG.Height ? WIA_GetImageBitmap(ScaledWiaIMG) : WIA_GetImageBitmap(wiaImg)
      If (PicObj.Handle)
      {
         setWindowTitle("Converting WIA image format to GDI+ bitmap")
         changeMcursor()
         If wiaImg.IsAlphaPixelFormat
            oBitmap := trGdip_CreateARGBBitmapFromHBITMAP(PicObj.Handle)
         Else
            oBitmap := trGdip_CreateBitmapFromHBITMAP(PicObj.Handle)
         Gdi_DeleteObject(PicObj.Handle)
      }
   }

   If (IsObject(sizesDesired[2]) && IsObject(wiaImg))
   {
      forceW := sizesDesired[2, 1]
      forceH := sizesDesired[2, 2]
      keepAratio := sizesDesired[2, 3]
      ScaleAnySize := sizesDesired[2, 4]
      If (wiaImg.Width>forceW || wiaImg.Height>forceH || ScaleAnySize=1)
         Try ScaledWiaIMGb := WIA_ScaleImage(wiaImg, forceW, forceH, keepAratio)

      If (ScaledWiaIMGb.Height)
      {
         Try PicObju := WIA_GetImageBitmap(ScaledWiaIMGb)
         If wiaImg.IsAlphaPixelFormat
            newBitmap := trGdip_CreateARGBBitmapFromHBITMAP(PicObju.Handle)
         Else
            newBitmap := trGdip_CreateBitmapFromHBITMAP(PicObju.Handle)
         Gdi_DeleteObject(PicObju.Handle)
      }
      ScaledWiaIMGb := ""
   }

   wiaImg := ""
   ScaledWiaIMG := ""
   PicObj := ""
   Return oBitmap
}

LoadBitmapForScreen(imgPath, allowCaching, frameu) {
  Static prevMD5nameA, prevMD5nameB

  initQPVmainDLL()
  coreIMGzeitLoad := A_TickCount
  If StrLen(UserMemBMP)>2
  {
     totalFramesIndex := 0
     currIMGdetails.PixelFormat := Gdip_GetImagePixelFormat(UserMemBMP, 2)
     If (currIMGdetails.HasAlpha!=1)
        currIMGdetails.PixelFormat := StrReplace(currIMGdetails.PixelFormat, "A")

     currIMGdetails.RawFormat := Gdip_GetImageRawFormat(UserMemBMP)
     ; currIMGdetails.HasAlpha := InStr(currIMGdetails.PixelFormat, "argb") ? 1 : 0
     currIMGdetails.Frames := 0
     prevMD5nameA := prevMD5nameB := ""
     ; If (minimizeMemUsage=1)
     discardSRCfileCaches()
     destroyGDIfileCache()
     Return trGdip_CloneBitmap(A_ThisFunc, UserMemBMP)
  }

  GDIbmpFileConnected := 1
  If (allowCaching=1)
  {
     MD5name := generateThumbName(imgPath, 1)
     ; fimStuff := (alwaysOpenwithFIM=1) ? 1 desiredFrameIndex totalFramesIndex : 0
     thisMD5name := MD5name imgPath userHQraw cmrRAWtoneMapAlgo cmrRAWtoneMapParamA cmrRAWtoneMapParamB
     tFramesA := Gdip_GetBitmapFramesCount(GDIcacheSRCfileA) - 1
     tFramesB := Gdip_GetBitmapFramesCount(GDIcacheSRCfileB) - 1
     isFramesA := (tFramesA=AbackupIMGdetails.Frames) ? 1 : 0
     isFramesB := (tFramesB=BbackupIMGdetails.Frames) ? 1 : 0
     ; ToolTip, % thisMD5name "`n" prevMD5nameA "`n" prevMD5nameB "`n" isFramesA "=" isFramesB "`n" tFramesA "=" tFramesB "`n" AbackupIMGdetails.Frames "=" BbackupIMGdetails.Frames "`n" AbackupIMGdetails.FIle "=" BbackupIMGdetails.File , , , 2
     If (thisMD5name=prevMD5nameA && StrLen(GDIcacheSRCfileA)>2 && StrLen(prevMD5nameA)>2 && isFramesA=1)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileA "`n" imgPath)
        totalFramesIndex := multiPageFileManaging(GDIcacheSRCfileA, desiredFrameIndex)
        currIMGdetails := AbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileA)
     } Else If (thisMD5name=prevMD5nameB && StrLen(GDIcacheSRCfileB)>2 && StrLen(prevMD5nameB)>2 && isFramesB=1)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileB "`n" imgPath)
        totalFramesIndex := multiPageFileManaging(GDIcacheSRCfileB, desiredFrameIndex)
        currIMGdetails := BbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileB)
     } Else
     {
        prevMD5nameB := idGDIcacheSRCfileB := ""
        GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
        ; SoundBeep 
     }
  }

  If ((RegExMatch(imgPath, RegExFIMformPtrn) || (alwaysOpenwithFIM=1 && wasInitFIMlib=1)) && allowFIMloader=1)
  {
     If (thumbsDisplaying!=1 && runningLongOperation!=1 && slideShowRunning!=1)
        setWindowTitle("Loading file using the FreeImage library")
     totalFramesIndex := 0
     oBitmap := LoadFimFile(imgPath, 0, 0, frameu)
     totalFramesIndex := mainLoadedIMGdetails.Frames
     desiredFrameIndex := clampInRange(frameu, 0, totalFramesIndex)
     GDIbmpFileConnected := 0
  } Else If (RegExMatch(imgPath, RegExWICfmtPtrn) && WICmoduleHasInit=1 && allowWICloader=1)
  {
     totalFramesIndex := 0
     thisImgQuality := (userimgQuality=1) ? 6 : 5
     sizesDesired := []
     sizesDesired[1] := [32500, 32500, 1, 0, thisImgQuality]
     oBitmap := LoadWICimage(imgPath, 0, frameu, sizesDesired)
     totalFramesIndex := mainLoadedIMGdetails.Frames
     desiredFrameIndex := clampInRange(frameu, 0, totalFramesIndex)
     GDIbmpFileConnected := 0
  } Else
  {
     totalFramesIndex := 0
     oBitmap := LoadFileWithGDIp(imgPath, 0, frameu)
     If (StrLen(oBitmap)<3 && wasInitFIMlib=1 && allowFIMloader=1)
        oBitmap := LoadFimFile(imgPath, 0, 0, frameu)

     If (mainLoadedIMGdetails.TooLargeGDI=1 || InStr(Gdip_GetImageRawFormat(oBitmap), "MEMORYBMP"))
        GDIbmpFileConnected := 0
     totalFramesIndex := mainLoadedIMGdetails.Frames
     desiredFrameIndex := clampInRange(frameu, 0, totalFramesIndex)
  }

  If (allowCaching=1 && StrLen(oBitmap)>2)
  {
     If (slideShowRunning!=1) || (slideShowRunning=1 && slideShowDelay>600)
     {
        zu := Format("{:L}", imgPath)
        If !userSeenSessionImagesArray[zu]
        {
           userSeenSessionImagesIndex++
           userSeenSessionImagesArray[zu] := userSeenSessionImagesIndex
        }
     }

     prevMD5nameB := prevMD5nameA
     prevMD5nameA := thisMD5name
     idGDIcacheSRCfileB := idGDIcacheSRCfileA
     idGDIcacheSRCfileA := GDIbmpFileConnected MD5name imgPath
     GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
     GDIcacheSRCfileB := GDIcacheSRCfileA
     GDIcacheSRCfileA := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
     BbackupIMGdetails := AbackupIMGdetails.Clone()
     AbackupIMGdetails := mainLoadedIMGdetails.Clone()
  }

  currIMGdetails := mainLoadedIMGdetails.Clone()
  Return oBitmap
}

LoadFileWithGDIp(imgPath, noBPPconv:=0, frameu:=0, sizesDesired:=0, ByRef newBitmap:=0) {
  changeMcursor()
  oBitmap := trGdip_CreateBitmapFromFile(imgPath)
  If StrLen(oBitmap)>2
  {
     pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
     Gdip_GetImageDimensions(oBitmap, imgW, imgH)
     Gdip_BitmapGetDPIResolution(oBitmap, dpix, dpiy)
     mainLoadedIMGdetails.File := imgPath
     mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
     mainLoadedIMGdetails.Width := imgW
     mainLoadedIMGdetails.Height := imgH
     mainLoadedIMGdetails.Frames := Gdip_GetBitmapFramesCount(oBitmap) - 1
     mainLoadedIMGdetails.HasAlpha := InStr(pixFmt, "argb") ? 1 : 0
     mainLoadedIMGdetails.PixelFormat := pixFmt
     mainLoadedIMGdetails.RawFormat := Gdip_GetImageRawFormat(oBitmap)
     mainLoadedIMGdetails.OpenedWith := "GDI+"
     mainLoadedIMGdetails.TooLargeGDI := 0

     If (RegExMatch(mainLoadedIMGdetails.RawFormat, "i)(gif|tiff)$") && mainLoadedIMGdetails.Frames>0)
     {
        frameu := clampInRange(frameu, 0, mainLoadedIMGdetails.Frames)
        Gdip_BitmapSelectActiveFrame(oBitmap, frameu)
     }

     ; ToolTip, % imgW "-" imgH "-" pixFmt , , , 2
     If (InStr(pixFmt, "CMYK") || InStr(pixFmt, "48-") || InStr(pixFmt, "64-"))
        ER := Gdip_BitmapSetColorDepth(oBitmap, 32, 1)

     forceW := sizesDesired[1, 1]
     forceH := sizesDesired[1, 2]
     mustRsize := (forceW>1 && forceH>1 && noBPPconv=0) ? 1 : 0
     If (!imgW || !imgH || ER || InStr(pixFmt, "0x"))
     {
        mustOpenWithWia := 1
     } Else If (isImgSizeTooLarge(imgW, imgH) && mustRsize=0)
     {
        addJournalEntry("Rescaling image to GDI+ maximum image dimensions limits")
        nBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 32500, 32500, 1, 3, -1)
        If StrLen(nBitmap)>3
        {
           mainLoadedIMGdetails.TooLargeGDI := 1
           oBitmap := trGdip_DisposeImage(oBitmap, 1)
           oBitmap := nBitmap
        } Else mustOpenWithWia := 1
     }
  } Else mustOpenWithWia := 1

   If (mustOpenWithWia=1 && noBPPconv=0) ; || (allowCaching=1)
   {
      loadedWith := 2
      oBitmap := trGdip_DisposeImage(oBitmap, 1)
      oBitmap := LoadFileWithWIA(imgPath, noBPPconv, 0, sizesDesired, newSizedImage)
      newBitmap := newSizedImage
      Return oBitmap
   }

   If (sizesDesired.Count()>1 && StrLen(oBitmap)>2 && noBPPconv=0 && mustOpenWithWia!=1)
   {
      hasFlipped := 0
      newBitmap := []
      Loop, % sizesDesired.Count()
      {
         ; ToolTip, % mainLoadedIMGdetails.width "==" mainLoadedIMGdetails.height "|" z "==" W "=f" frameu "==s" ScaleAnySize "==k" keepAratio , , , 2
         forceW := sizesDesired[A_Index + 1, 1]
         forceH := sizesDesired[A_Index + 1, 2]
         If (forceW>1 && forceH>1)
         {
            keepAratio := sizesDesired[A_Index + 1, 3]
            ScaleAnySize := sizesDesired[A_Index + 1, 4]
            thisImgQuality := sizesDesired[A_Index + 1, 5]
            doFlipu := sizesDesired[A_Index + 1, 6]
            If (imgW>forceW || imgH>forceH || ScaleAnySize=1)
            {
               If (doFlipu>0 && hasFlipped=0)
               {
                  hasFlipped := 1
                  Gdip_ImageRotateFlip(oBitmap, doFlipu)
               }

               newBitmap[A_Index] := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, forceW, forceH, keepAratio, thisImgQuality, -1)
               NextDoFlipu := sizesDesired[A_Index + 2, 6]
               If (doFlipu>0 && !NextDoFlipu)
               {
                  hasFlipped := 0
                  Gdip_ImageRotateFlip(oBitmap, doFlipu)
               }
            }
         }
      }
   }

   If (mustOpenWithWia!=1)
   {
      forceW := sizesDesired[1, 1]
      forceH := sizesDesired[1, 2]
   }

   If (forceW>1 && forceH>1 && noBPPconv=0)
   {
      keepAratio := sizesDesired[1, 3]
      ScaleAnySize := sizesDesired[1, 4]
      thisImgQuality := sizesDesired[1, 5]
      If (imgW>forceW || imgH>forceH || ScaleAnySize=1)
         zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, forceW, forceH, keepAratio, thisImgQuality, -1)

      If StrLen(zBitmap)>2
      {
         trGdip_DisposeImage(oBitmap)
         oBitmap := zBitmap
      }
   }

   Return oBitmap
}

LoadBitmapFromFileu(imgPath, noBPPconv:=0, forceGDIp:=0, frameu:=0, sizesDesired:=0, ByRef newSizedImage:=0) {

  If (RegExMatch(imgPath, RegExFIMformPtrn) || (alwaysOpenwithFIM=1 && forceGDIp=0) && allowFIMloader=1)
  {
     oBitmap := LoadFimFile(imgPath, noBPPconv, noBPPconv, frameu, sizesDesired, newBitmap)
     newSizedImage := newBitmap
  } Else If (RegExMatch(imgPath, RegExWICfmtPtrn) && WICmoduleHasInit=1 && allowWICloader=1)
  {
     oBitmap := LoadWICimage(imgPath, noBPPconv, frameu, sizesDesired, newBitmap)
     newSizedImage := newBitmap
  } Else ; If StrLen(oBitmap)<3
  {
     oBitmap := LoadFileWithGDIp(imgPath, noBPPconv, frameu, sizesDesired, newBitmap)
     If (StrLen(oBitmap)<4 && allowFIMloader=1 && wasInitFIMlib=1)
        oBitmap := LoadFimFile(imgPath, noBPPconv, noBPPconv, frameu, sizesDesired, newBitmap)

     newSizedImage := newBitmap
  }

  Return oBitmap
}

RotateBMP2exifOrientation(oBitmap) {
   Static orient := {6:1, 8:3, 3:2, 2:4, 5:5, 4:6, 7:7}
   exifOrientation := Gdip_GetPropertyItem(oBitmap, 0x112)
   orientation := orient[exifOrientation.Value]
   ; MsgBox, % orientation
   If (orientation>0)
      Gdip_ImageRotateFlip(oBitmap, orientation)
}

capMaxGDIbmpSize32bits() {
  If (A_PtrSize=4)
  {
     mamUsage := GetProcessMemoryUsage(QPVpid)
     If !mamUsage[1]
        Return

     maxGDIbmpSize := ((2115473648 - mamUsage[1] - mamUsage[8]//2)//4)//1.9
     If (maxGDIbmpSize<10101)
        maxGDIbmpSize := 10101
  }
}

Gdip_CloneBmpPargbArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:=0, KeepPixelFormat:=0, ignoreBounds:=0, addBgr:=0) {
   thisPixFmt := !PixelFormat ? coreDesiredPixFmt : PixelFormat
   ; If (thisPixFmt="0xE200B" && userimgQuality=0)
   ;    thisPixFmt := "0x26200A"

   If (ignoreBounds=1 && w>0 && h>0)
   {
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       If (isDotInRect(x, y, 0, imgW, 0, imgH) && isDotInRect(x + w, y + h, 0, imgW, 0, imgH))
       {
          simpleMode := 1
          newBitmap := trGdip_CloneBitmapArea(A_ThisFunc "<-" funcu, pBitmap, x, y, w, h, thisPixFmt, KeepPixelFormat)
       } Else newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, w, h, thisPixFmt)

       If (StrLen(newBitmap)>2 && simpleMode!=1)
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc "() initially invoked by " funcu, newBitmap, 3)
          If G2
          {
             r1 := trGdip_DrawImage(A_ThisFunc "() initially invoked by " funcu, G2, pBitmap, 0, 0, w, h, x, y, w, h)
             If (addBgr=1)
             {
                x1 := (x<0) ? Abs(x) : 0
                y1 := (y<0) ? Abs(y) : 0
                x2 := (x+w>imgW) ? x1 + w - ((x + w) - imgW) : x1 + w
                y2 := (y+h>imgH) ? y1 + h - ((y + h) - imgH) : y1 + h
                Gdip_SetClipRect(G2, x1, y1, w, h, 4)
                ; r1 := trGdip_DrawImage(A_ThisFunc "() initially invoked by " funcu, G2, pBitmap, 0, 0, w, h, x3, y3, w2, h2)
                ; ToolTip, % x1 "=" y1 "=" x2 "=" y2 "`n" w "=" h , , , 2
                trGdip_GraphicsClear(A_ThisFunc "() initially invoked by " funcu, G2, "0x01828282")
             }
          }

          Gdip_DeleteGraphics(G2)
          If (r1="fail" || !G2)
          {
             trGdip_DisposeImage(newBitmap, 1)
             newBitmap := ""
          }
       }
   } Else
     newBitmap := trGdip_CloneBitmapArea(A_ThisFunc "<-" funcu, pBitmap, x, y, w, h, thisPixFmt, KeepPixelFormat)

   If StrLen(newBitmap)<3
   {
      baseMsg := "Unable to create internal PARGB bitmap clone to apply operations on image... Error occured in " A_ThisFunc "() invoked by " funcu  "() for pBMP=" pBitmap ". "
      generalInternalErrorMsgBox(gdipLastError, baseMsg)
      newBitmap := ""
   }

   Return newBitmap
}

generalInternalErrorMsgBox(err, baseMsg, silentMode:=0) {
   Static forceSilent := 0

   If err
      message := "`n`n" Gdip_ErrorHandler(err, 0)

   friendly := (A_PtrSize=4) ? "`n`nPossible cause: memory limit reached." : ""
   friendly .= (A_PtrSize=4 && A_is64BitOS) ? " Please use the 64-bits edition of this application." : ""
   If (InStr(message, "out_of_memory") && maxMemUndoLevels>12012)
      maxMemUndoLevels -= 100000

   addJournalEntry(baseMsg message friendly)
   If (runningLongOperation!=1 && hasInitSpecialMode!=1 && silentMode=0 && forceSilent=0)
   {
      If (imgEditPanelOpened=1)
         doImgEditLivePreview := 0
      ; SoundBeep, 300, 100
      simpleMsgBoxWrapper(appTitle ": ERROR", baseMsg message friendly, 0, 0, "error")
      If (InStr(baseMsg, glPG) || InStr(baseMsg, 2NDglPG)) && (forceSilent=0)
      {
         info := (debugModa=1) ? "" : "You can start QPV with /qpv-debug to view all error messages in a debug viewer."
         msgResult := msgBoxWrapper(appTitle, "It seems you are receving errors related to core viewport components. Choose Yes to no longer receive GDI+ error messages.`n`nAnyhow, the application will likely continue to malfunction, but at least in silence.", 4, 0, "question")
         If (msgResult="yes")
            forceSilent := 1
      }
   }
}

highlightActiveArrowsCtrl() {
    highlightActiveCtrl("arrows")
}

highlightActiveCtrl(modus:=0, givenHwnd:=0) {
   Static prevCtrl

   If (modus="RButton")
   {
      ActiveHwnd := WinActive("A")
      If (isVarEqualTo(ActiveHwnd, hfdTreeWinGui, hQuickMenuSearchWin, MsgBox2hwnd, hSetWinGui) && isNowFakeWinOpen=1)
         Return

      MouseGetPos, , , id, hwnd, 2
      ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
      ControlGet, ctrlActiveState, Enabled,,, ahk_id %hwnd%
      ControlGetText, info, , ahk_id %hwnd%
      If (posuk := InStr(info, "&"))
         hotkeyu := "`nAlt+" SubStr(info, posuk + 1, 1)

      info := StrReplace(info, "&")
      WinGetClass, OutputVar, ahk_id %hwnd%
      If InStr(OutputVar, "_trackbar")
      {
         SendMessage, 0x0400,,,, ahk_id %hwnd%   ; TBM_GETPOS
         curr := ErrorLevel
         SendMessage, 0x0401,,,, ahk_id %hwnd%   ; TBM_GETRANGEMIN
         minu := ErrorLevel
         SendMessage, 0x0402,,,, ahk_id %hwnd%   ; TBM_GETRANGEMAX
         maxu := ErrorLevel
         OutputVar := "Slider: " curr " | " minu "; " maxu
      } Else If InStr(OutputVar, "combol") 
      {
         ; VarSetCapacity(varu, 34521, 0)
         SendMessage, 0x018B,,,, ahk_id %hwnd%   ; LB_GETCOUNT
         maxu := ErrorLevel
         SendMessage, 0x0188,,,, ahk_id %hwnd%   ; LB_GETCURSEL
         curr := ErrorLevel
         ; SendMessage, 0x0140, % curr, &varu,, ahk_id %hwnd%   ; CB_GETEDITSEL
         ; curr .= ErrorLevel
         OutputVar := "List box: " curr " / " maxu
         ; varu := ""
      } Else If InStr(OutputVar, "ComboBox") 
      {
         ; ControlGet, userChoice, Choice,,, ahk_id %hwnd%
         SendMessage, 0x0147,,,, ahk_id %hwnd%   ; CB_GETCURSEL
         curr := ErrorLevel + 1
         info := curr " = " info
      } Else If (OutputVar="button") 
      {
         ControlGet, userChoice, Checked,,, ahk_id %hwnd%
         ControlGet, stylu, Style,,, ahk_id %hwnd%
         r := (stylu & 0x00000002) ? 1 : 0
         If r
            OutputVar := "Checkbox: " userChoice
      } Else If InStr(OutputVar, "_updown")
      {
         SendMessage, 0x0400+102,,,, ahk_id %hwnd%   ; UDM_GETRANGE
         UDM_GETRANGE := ErrorLevel
         minu := UDM_GETRANGE >> 16
         maxu := UDM_GETRANGE & 0xFFFF
         OutputVar := "Up/Down number range: " minu "; " maxu
      } Else If InStr(OutputVar, "edit")
      {
         OutputVar := "Edit field"
      } Else If (InStr(OutputVar, "static") && value && ctrlu)
      {
         OutputVar := "Maybe clickable" ; value  " - " ctrlu
      }

      msg2show := Trimmer(info "`n[" OutputVar "] " hotkeyu)
      If StrLen(listBoxOptions)>3
      {
         countListBoxOptions := ST_Count(listBoxOptions, "`n") + 1
         If (countListBoxOptions>10)
            listBoxOptions := "[too many to list]"
         msg2show .= "`n`nLIST OPTIONS: " countListBoxOptions "`n" listBoxOptions
      }

      thisSize := (PrefsLargeFonts=1) ? Round(LargeUIfontValue*1.55) : LargeUIfontValue
      interfaceThread.ahkFunction("mouseCreateOSDinfoLine", msg2show, thisSize)
      Sleep, 500
      Return
   } Else If (modus="click")
   {
      GuiControlGet, whichHwnd, hwnd, %A_GuiControl%
      WinGetClass, ctrlClassNN, ahk_id %whichHwnd%
      ; MouseGetPos, , , WhichWindow, whichHwnd
      If InStr(ctrlClassNN, "static")
      {
         prevCtrl := 0
         ControlFocus, , ahk_id %whichHwnd%
         highlightActiveCtrl()
      }
      Return
   }

   thisHwnd := (modus="given" && givenHwnd) ? givenHwnd : WinActive("A")
   ControlGetFocus, ctrlClassNN, ahk_id %thisHwnd%
   ControlGet, ctrlHwnd, Hwnd,, % ctrlClassNN, ahk_id %thisHwnd%
   ControlGetPos, x, y, w, h, % ctrlClassNN, ahk_id %thisHwnd%
   thisCtrl := ctrlClassNN ctrlHwnd x y w h modus
   If (thisCtrl=prevCtrl) || (InStr(ctrlClassNN, "edit") && InStr(modus, "space"))
      Return

   prevCtrl := thisCtrl
   JEE_ClientToScreen(thisHwnd, 1, 1, aX, aY)
   WinGetPos, zX, zY, ,, ahk_id %thisHwnd%
   kX := aX - zX
   kY := aY - zY

   JEE_ClientToScreen(thisHwnd, x, y, X2, Y2)
   x2 -= kX,   y2 -= kY
   x2 += 3,    y2 += 3

   interfaceThread.ahkPostFunction("ShowClickHalo", x2, y2, w, h, 1)
   If (InStr(modus, "space") && (ctrlClassNN ~= "i)(static|combobox|syslistview32)"))
   {
      If (thisHwnd=hSetWinGui)
      {
         GuiControlGet, vLabel, SettingsGUIA: FocusV
         If (!InStr(vLabel, "color") && InStr(ctrlClassNN, "syslistview32"))
            Return
      }

      prevCtrl := 0
      MouseMove, x2, y2, 1
      Click
   }
   ; ToolTip, % vLabel "=" x "--" y "--" w "--" h "`n" ctrlClassNN "||" ctrlHwnd , , , 2
}

CloneMainBMP(imgPath, ByRef imgW, ByRef imgH, mustReloadIMG, ByRef hasFullReloaded) {
  Critical, on
  Static prevFrame := -1, AprevImgDownScaled := 0, BprevImgDownScaled := 0, lastInvoked := 1

  GDIbmpFileConnected := 1
  hasFullReloaded := CountGIFframes := totalFramesIndex := 0
  MD5name := generateThumbName(imgPath, 1)
  o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
  o_AutoDownScaleIMGs := (AutoDownScaleIMGs>0) ? 1 : 0
  thisImgCall := MD5name imgPath o_bwDithering ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation
  If !FileRexists(imgPath) && (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath))
     thisImgCall := InStr(AprevImgCall, imgPath) ? SubStr(AprevImgCall, 2) : SubStr(BprevImgCall, 2)

  prevLastImg[2] := prevLastImg[1]
  prevLastImg[1] := [currentFileIndex, resultedFilesList[currentFileIndex, 1]]
  gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
  file2load := thumbsCacheFolder "\big-" alwaysOpenwithFIM userHQraw MD5name ".png"
  ignoreCache := (prevFrame!=desiredFrameIndex || minimizeMemUsage=1 || StrLen(UserMemBMP)>2) ? 1 : mustReloadIMG
  ; MsgBox, % imgPath "`n" AbackupIMGdetails.File "`n" BbackupIMGdetails.File "`n" CbackupIMGdetails.File
  If (SubStr(AprevImgCall, 2)=thisImgCall && StrLen(AprevGdiBitmap)>2 && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     thisIMGisDownScaled := AprevImgDownScaled
     Gdip_GetImageDimensions(AprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, AprevGdiBitmap)
     addJournalEntry("Used cached GDI bitmap ID: " AprevGdiBitmap "`n" imgPath)
     gdiBitmapIDcall := AprevImgCall
     gdiBitmapIDentire := AprevImgCall gdiBitmap
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     extractAmbientalTexture()
     totalFramesIndex := currIMGdetails.Frames
     Return
  } Else If (SubStr(BprevImgCall, 2)=thisImgCall && StrLen(BprevGdiBitmap)>2 && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     thisIMGisDownScaled := BprevImgDownScaled
     Gdip_GetImageDimensions(BprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, BprevGdiBitmap)
     gdiBitmapIDcall := BprevImgCall
     gdiBitmapIDentire := BprevImgCall gdiBitmap
     addJournalEntry("Used cached GDI bitmap ID: " BprevGdiBitmap "`n" imgPath)
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     totalFramesIndex := currIMGdetails.Frames
     extractAmbientalTexture()
     Return
  }

  pargbPixFmt := (coreDesiredPixFmt="0xE200B") ? -1 : 0
  If (slideShowRunning!=1 && desiredFrameIndex<1) && (A_TickCount - lastInvoked>250)
     GdipCleanMain(6)

  interfaceThread.ahkassign("canCancelImageLoad", 1)
  changeMcursor()
  preventDownScaling := (IMGresizingMode=3) || (StrLen(UserMemBMP)>2) || (currentFileIndex=0) || (IMGresizingMode=4 && zoomLevel>1.5) ? 1 : 0
  thisImgPath := (preventDownScaling!=1 && FileExist(file2load) && AutoDownScaleIMGs=1) ? file2load : imgPath
  thisIMGisDownScaled := (thisImgPath!=imgPath && AutoDownScaleIMGs=1) ? 1 : 0
  allowCaching := !minimizeMemUsage
  If StrLen(UserMemBMP)>2
     thisIMGisDownScaled := allowCaching := 0

  If (slideShowRunning!=1 && (A_TickCount - lastInvoked>2000))
     interfaceThread.ahkPostFunction("uiAccessImgViewSetUIlabels")

  oBitmap := LoadBitmapForScreen(thisImgPath, allowCaching, desiredFrameIndex)
  ; ToolTip, % currIMGdetails.OpenedWith , , , 2
  If !oBitmap
     Return "error"

  lastInvoked := A_TickCount
  slowFileLoad := (A_TickCount - coreIMGzeitLoad > 450) ? 1 : 0
  hasFullReloaded := 1
  rawFmt := Gdip_GetImageRawFormat(oBitmap)
  rawFmt := (rawFmt="MEMORYBMP" && fimMultiPage) ? fimMultiPage : rawFmt
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad

  ; If (RegExMatch(rawFmt, "i)(gif|tiff)$") && totalFramesIndex>0)
  If (currIMGdetails.frames>0)
  {
     totalFramesIndex := currIMGdetails.Frames
     multiFrameImg := 1
  } Else If (rawFmt="JPEG")
     RotateBMP2exifOrientation(oBitmap)
  Else If (rawFmt="MEMORYBMP")
     GDIbmpFileConnected := 0

  If ((InStr(currIMGdetails.RawFormat, "webp") || InStr(currIMGdetails.RawFormat, "gif")) && totalFramesIndex>0)
  {
     gifLoaded := 1
     CountGIFframes := (animGIFsSupport=1) ? totalFramesIndex : 0
  }

  If (AnyWindowOpen=17 && performAutoCropNow=1 && usrAutoCropGenerateSelection=0)
  {
     GDIbmpFileConnected := 0
     hasAutoCropped := 1
     setWindowTitle("Auto-cropping image")
     ; xBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, oBitmap)
     kBitmap := AutoCropAction(oBitmap, usrAutoCropColorTolerance, usrAutoCropImgThreshold)
     FlipImgV := FlipImgH := vpIMGrotation := performAutoCropNow := 0
     ; trGdip_DisposeImage(xBitmap, 1)
     If StrLen(kBitmap)>3
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
        oBitmap := kBitmap
     }
  }

  Gdip_GetImageDimensions(oBitmap, imgW, imgH)
  totalIMGres := imgW + imgH
  totalScreenRes := ResolutionWidth + ResolutionHeight
  thisImgQuality := (userimgQuality=1) ? 6 : 5
  preventDownScaling := (multiFrameImg=1) || (IMGresizingMode=3) || StrLen(UserMemBMP)>2 || (currentFileIndex=0) || (IMGresizingMode=4 && zoomLevel>1.5) ? 1 : 0
  If (hasAutoCropped!=1 && preventDownScaling!=1 && !FileExist(file2load) && AutoDownScaleIMGs=1 && totalIMGres/totalScreenRes>1.3)
  {
     setWindowTitle("Downscaling large image to viewport")
     thisImgQuality := (userimgQuality=1) ? "" : 5
     roImgW := imgW, roImgH := imgH
     calcIMGdimensions(imgW, imgH, ResolutionWidth, ResolutionHeight, newW, newH)
     imgW := newW, imgH := newH
     totalIMGres := newW + newH
     slowFileLoad := 0
     thisIMGisDownScaled := 1
     mustSaveFile := (userPrivateMode!=1 && multiFrameImg!=1 && enableThumbsCaching=1) ? 1 : 0
  } ; Else thisIMGisDownScaled := 0
  If (minimizeMemUsage=1 && rawFmt!="MEMORYBMP")
     thisImgQuality := ""

  If !newW
     newW := imgW
  If !newH
     newH := imgH

  BprevImgDownScaled := AprevImgDownScaled
  AprevImgDownScaled := thisIMGisDownScaled
  If (currIMGdetails.HasAlpha!=1 || gifLoaded=1)
     brushRequired := 1

  changeMcursor()
  isGIFgdip := ((animGIFplaying=1 || gifLoaded=1) && currIMGdetails.OpenedWith="GDI+") ? 1 : 0
  If (thisIMGisDownScaled=1 || userPrivateMode=1 || isGIFgdip=1 || minimizeMemUsage!=1 && rawFmt!="MEMORYBMP")
  {
     If (userPrivateMode=1)
     {
        rBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 800, 800, 1, 5, pargbPixFmt)
        blurEffect := Gdip_CreateEffect(1, 150, 0, 0)
        Gdip_BitmapApplyEffect(rBitmap, blurEffect)
        Gdip_DisposeEffect(blurEffect)
    } Else rBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, newW, newH, 0, thisImgQuality, pargbPixFmt)

    If rBitmap
    {
       GDIbmpFileConnected := 0
       trGdip_DisposeImage(oBitmap, 1)
       If (mustSaveFile=1 && thisIMGisDownScaled=1)
          z := Gdip_SaveBitmapToFile(rBitmap, file2load, 90)
    } Else rBitmap := oBitmap
  } Else
  {
     If (currIMGdetails.HasAlpha=1 && rawFmt!="MEMORYBMP")
        rBitmap := cloneGDItoMem(A_ThisFunc, oBitmap)

     If rBitmap
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
     } Else rBitmap := oBitmap
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && vpIMGrotation>0)
  {
     setWindowTitle("Rotating image at " vpIMGrotation "°")
     brushu := (brushRequired=1) ? pBrushWinBGR : ""
     ; nBitmap := simpleFreeImgRotate(rBitmap, vpIMGrotation)
     changeMcursor()
     nBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, rBitmap, vpIMGrotation, "", imgQuality, pargbPixFmt)
     If StrLen(nBitmap)>3
     {
        Gdip_GetImageDimensions(nBitmap, imgW, imgH)
        newW := imgW, newH := imgH
        currIMGdetails.HasAlpha := 1
        trGdip_DisposeImage(rBitmap, 1)
        rBitmap := nBitmap
     } Else vpIMGrotation := 0
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && bwDithering=1 && imgFxMode=4)
  {
     GDIbmpFileConnected := 0
     setWindowTitle("Converting image to black and white with dithering")
     If (currIMGdetails.HasAlpha=1)
        E := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)

     zBitmap := trGdip_BitmapConvertGray(rBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
     If zBitmap
     {
        trGdip_DisposeImage(rBitmap, 1)
        rBitmap := zBitmap
        E := Gdip_BitmapSetColorDepth(rBitmap, "BW", 1)
     }
  } Else If (usrColorDepth>1)
  {
     infoColorDepth := defineColorDepth()
     setWindowTitle("Converting image to " infoColorDepth)
     If (currIMGdetails.HasAlpha=1)
        E := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)
     E := Gdip_BitmapSetColorDepth(rBitmap, internalColorDepth, ColorDepthDithering)
  }

  Gdip_GetImageDimensions(rBitmap, fimgW, fimgH)
  BprevImgCall := AprevImgCall
  AprevImgCall := "a" GDIbmpFileConnected MD5name imgPath o_bwDithering o_AutoDownScaleIMGs "|==|" ColorDepthDithering vpIMGrotation desiredFrameIndex totalFramesIndex currentUndoLevel undoLevelsRecorded fimgW fimgH
  gdiBitmapIDcall := AprevImgCall
  gdiBitmapIDentire := AprevImgCall rBitmap
  gdiBitmap := rBitmap
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  extractAmbientalTexture(abortImgLoad)
  BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
  prevFrame := desiredFrameIndex
  If (allowCaching=1)
  {
     BprevGdiBitmap := AprevGdiBitmap
     AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
  }
  imgW := newW, imgH := newH
  ; msgbox, % a_thisfunc "=" totalFramesIndex
}

createGDIbrushPbitmap(pBitmap) {
    hbitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, pBitmap)
    If StrLen(hBitmap)>1
    {
       gdiBrushu := Gdi_CreatePatternBrush(hBitmap)
       Gdi_DeleteObject(hBitmap)
       Return gdiBrushu
    }
}

extractAmbientalTexture(abortImgLoad:=0) {
    confirmTexBGR := isVarEqualTo(vpIMGrotation, 0, 90, 180, 270)
    If (abortImgLoad<3 && usrTextureBGR=1 && IMGresizingMode!=5 && confirmTexBGR=1)
    {
       setWindowTitle("Extracting image texture for the window background")
       If gdiAmbientalTexBrush
          Gdi_DeleteObject(gdiAmbientalTexBrush)

       decideGDIPimageFX(matrix, imageAttribs, pEffect)
       TexBrush := Gdip_CreateTextureBrush(useGdiBitmap(), 3, 3, 3, ambiTexBrushSize, ambiTexBrushSize, matrix, 0, 0, 0, imageAttribs)
       If TexBrush
       {
          klBMP := trGdip_CreateBitmap(A_ThisFunc, ambiTexBrushSize*2, ambiTexBrushSize*2)
          If klBMP
          {
             Gup := Gdip_GraphicsFromImage(klBMP)
             Gdip_FillRectangle(Gup, TexBrush, 0, 0, ambiTexBrushSize*2, ambiTexBrushSize*2)
             gdiAmbientalTexBrush := createGDIbrushPbitmap(klBMP)
             Gdip_DeleteGraphics(Gup)
             trGdip_DisposeImage(klBMP)
          }
          Gdip_DeleteBrush(TexBrush)
       }
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
    }

    preventScreenOff()
    OnImgFileChangeActions(0)
    If (autoPlaySNDs=1)
    {
       AutoPlayAudioFileAssociated()
       identifyAudioMediaLength()
    }
}

OnImgFileChangeActions(forceThis) {
  Static prevImgPath := ""
  imgPath := currentFileIndex "=" getIDimage(currentFileIndex)
  If (imgPath=prevImgPath && forceThis=0)
  {
     Return
  } Else
  {
     SetTimer, RemoveTooltip, -200
     If (LimitSelectBoundsImg!=1 && editingSelectionNow=1)
        correctActiveSelectionAreaViewPort()
     GIFframesPlayied := 0
     allowNextSlide := 1
     If (A_TickCount - lastGIFdestroy > 950)
        prevAnimGIFwas := ""
     If (AutoDownScaleIMGs=2)
        AutoDownScaleIMGs := 1
     If (hSNDmedia && autoPlaySNDs!=1)
        StopMediaPlaying()
     If (slideShowRunning=1) ;  && (animGIFplaying!=1 || totalFramesIndex<2))
        invokeExternalSlideshowHandler()
  }

  prevImgPath := imgPath
}

invokeExternalSlideshowHandler() {
   allowNextSlide := 1
   interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
   interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
   interfaceThread.ahkPostFunction("dummySlideshow")
}

identifyAudioMediaLength() {
   If hSNDmedia
   {
      milisec := MCI_Length(hSNDmedia)
      hSNDmediaDuration := MCI_ToHHMMSS(milisec)
      If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(0, 1)
   } Else If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(0, 1)
}

IdentifyAudioFileAssociated() {
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3)
    {
       AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
       If StrLen(AudioFileu)>3 && FileExist(AudioFileu)
          Return AudioFileu
    }

    audioFile1 := OutDir "\" OutNameNoExt ".WAv"
    audioFile2 := OutDir "\" OutNameNoExt ".WMA"
    audioFile3 := OutDir "\" OutNameNoExt ".MP3"

    If FileRexists(audioFile1)
       thisSNDfile := audioFile1
    Else If FileRexists(audioFile2)
       thisSNDfile := audioFile2
    Else If FileRexists(audioFile3)
       thisSNDfile := audioFile3
    Else
       thisSNDfile := 0
    Return thisSNDfile
}

PlayAudioFileAssociatedNow() {
    If (thumbsDisplaying=1)
       Return

    restartGIFplayback()
    ohSNDmediaFile := hSNDmediaFile
    ohSNDmedia := hSNDmedia
    StopMediaPlaying()
    If (ohSNDmediaFile && ohSNDmedia)
    {
       zPlitPath(ohSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("Media file stopped: `n" OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       dummyTimerDelayiedImageDisplay(50)
       Return
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       identifyAudioMediaLength()
       zPlitPath(hSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       thisMsg := (E || !hSNDmedia) ? "ERROR: " E " - " hSNDmedia ". Unable to play media file: `n" : "Media file now playing: `n(" hSNDmediaDuration ") " 
       showTOOLtip(thisMsg OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime

       If (E || !hSNDmedia)
          StopMediaPlaying()
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("WARNING: No media file found to play`n" OutNameNoExt " (.WAV / .WMA / .MP3)`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
}

AutoPlayAudioFileAssociated() {
    Static prevAudioFile
    thisSNDfile := IdentifyAudioFileAssociated()
    If (thisSNDfile=prevAudioFile && StrLen(thisSNDfile)>3)
       Return

    StopMediaPlaying()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       milisec := MCI_Length(hSNDmedia)
       If (E || !hSNDmedia || milisec<350)
          StopMediaPlaying()
       Else
          prevAudioFile := hSNDmediaFile
    } Else prevAudioFile := ""
}

startSlidesMusicNow() {
    StopMediaPlaying(1)
    If StrLen(SlidesMusicSong)>3
    {
       hSNDsong := MCI_Open(SlidesMusicSong,,,0)
       E := MCI_Play(hSNDsong)
       milisec := MCI_Length(hSNDsong)
       ; lenghtu := MCI_ToHHMMSS(milisec)
       If (E || !hSNDsong || milisec<900)
          StopMediaPlaying(1)
    }
}

StopMediaPlaying(modus:=0) {
    If (modus=1)
    {
       If (StrLen(SlidesMusicSong)>3 && hSNDsong)
       {
          MCI_Stop(hSNDsong)
          hSNDsong := ""
       }
    } Else
    {
       If hSNDmedia
       {
          MCI_Stop(hSNDmedia)
          hSNDmediaDuration := hSNDmedia := hSNDmediaFile := ""
       }
    }
}

createHistogramBMP(whichBitmap) {
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   mpxu := Round((imgW*imgH)/1000000,2)
   If (mpxu>7.5 && StrLen(whichBitmap)>2)
      whichBMP := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, 520, 520, 1, 3, -1)
   Else
      whichBMP := whichBitmap

   If StrLen(whichBMP)<3
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram - no bitmap given")
      Return
   }

   If (showHistogram=2)
   {
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
   } Else If (showHistogram=3)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlArray, 0, 0)
   } Else If (showHistogram=4)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlArray, 0)
   } Else If (showHistogram=5)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlArray)
   } Else If (showHistogram=6)
   {
      setWindowTitle("Calculating histogram")
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlR, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlG, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlB)
      brLvlFakeArray := []
      Loop, 257
      {
          thisIndex := A_Index - 1
          thisMax := max(brLvlR[thisIndex], brLvlG[thisIndex], brLvlB[thisIndex])
          brLvlFakeArray[thisIndex] := Round(thisMax/1.25)
          ; MsgBox, % thisMax
      }
   }

   If ERR
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram... " Gdip_ErrorHandler(err, 0))
      Return
   }

   Gdip_GetImageDimensions(whichBMP, imgW, imgH)
   zr2ndMaxV := r2ndMaxV := 0
   minBrLvlV := TotalPixelz := imgW * imgH
   Loop, 256
   {
       thisIndex := A_Index - 1
       nrPixelz := brLvlArray[thisIndex]
       If (nrPixelz="")
          Continue

       stringArray .= nrPixelz "." (thisIndex+1) "`n"
       If (nrPixelz>0)
       {
          thisSum += nrPixelz
          If (thisSum>TotalPixelz//2 && medianValue="")
             medianValue := thisIndex
       }

       If (nrPixelz>1)
          stringArray3 .= (thisIndex+1) "." nrPixelz "`n"
       sumTotalBr += nrPixelz * (thisIndex+1)
       SimpleSumTotalBr += nrPixelz
       If (nrPixelz>modePointV)
       {
          modePointV := nrPixelz
          modePointK := thisIndex
       }

       If (nrPixelz<modePointV && nrPixelz>r2ndMaxV)
          r2ndMaxV := nrPixelz
       If (nrPixelz>zr2ndMaxV)
          zr2ndMaxV := nrPixelz

       If (nrPixelz<minBrLvlV && nrPixelz>1)
       {
          minBrLvlV := nrPixelz
          minBrLvlK := thisIndex
       }
   }

   Sort, stringArray, ND`n
   RstringArray := stringArray
   Sort, RstringArray, RND`n
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   avgBrLvlK := Round(sumTotalBr/TotalPixelz - 1, 1)
   thisVal := minu := maxu := 0
   Loop, 256
   {
      thisVal := brLvlArray[Round(avgBrLvlK) - A_Index]
      If (thisVal>0 && !minu)
      {
         minu := thisVal
         Break
      }
   }

   Loop, 256
   {
      thisVal := brLvlArray[A_Index + Round(avgBrLvlK)]
      If (thisVal>0 && !maxu)
      {
         maxu := thisVal
         Break
      }
   }

   avgBrLvlV := (minu + maxu)//2 ;  brLvlArray[Round(avgBrLvlK)]
   modePointK3 := ST_ReadLine(RstringArray, 2)
   modePointK3 := StrSplit(modePointK3, ".")
   rangeA := ST_ReadLine(stringArray3, 1)
   rangeA := StrSplit(rangeA, ".")
   rangeB := ST_ReadLine(stringArray3, "L")
   rangeB := StrSplit(rangeB, ".")
   Loop, 256
   {
       minBrLvlK2 := ST_ReadLine(stringArray, A_Index)
       minBrLvlK2 := StrSplit(minBrLvlK2, ".")
       If (minBrLvlK2[1]=0)
          Continue
       If (minBrLvlK2[2]>0)
          Break
   }

   rangeC := rangeB[1] - rangeA[1] + 1
   meanValue := SimpleSumTotalBr/rangeC
   meanValuePrc := Round(meanValue/TotalPixelz * 100)
   meanValuePrc := (meanValuePrc>0) ? " (" meanValuePrc "%) " : ""
   2ndMaxVa := (modePointK3[1] + avgBrLvlV)//2 + minBrLvlV
   2ndMaxVb := (r2ndMaxV + meanValue)//2 + minBrLvlV
   Loop, 256
   {
       lookMean := ST_ReadLine(stringArray, A_Index)
       lookMean := StrSplit(lookMean, ".")
       thisMean := lookMean[1]
       If (thisMean>meanValue)
       {
          meanValueK := Round((prevMean + lookMean[2] - 1)/2, 1)
          Break
       } prevMean := lookMean[2]
   }

   ; ToolTip, % avgBrLvlV "--" minBrLvlK2[1] "--" r2ndMaxV , , , 2
   meanValueK := !meanValueK ? "" : " | Mean: " meanValueK meanValuePrc
   peakPrc := Round(modePointV/TotalPixelz * 100)
   peakPrc := (peakPrc>0) ? " (" peakPrc "%)" : ""
   minPrc := Round(minBrLvlK2[1]/TotalPixelz * 100)
   minPrc := (minPrc>0) ? " (" minPrc "%)" : ""
   medianPrc := Round(lookValue[2]/TotalPixelz * 100)
   medianPrc := (medianPrc>0) ? " (" medianPrc "%)" : ""
   avgPrc := Round(avgBrLvlV/TotalPixelz * 100)
   avgPrc := (avgPrc>0) ? " (" avgPrc "%)" : ""
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   TotalPixelzSpaced := groupDigits(imgW*imgH)

   infoPeak := "`nMode: " modePointK peakPrc
   infoAvg := " | Avg: " avgBrLvlK avgPrc " | Min: " minBrLvlK2[2] - 1 minPrc
   infoMin := "`nMedian: " medianValue medianPrc meanValueK

   avgsMax := (2ndMaxVa + r2ndMaxV + 2ndMaxVb + avgBrLvlV + meanValue)/5
   If (histogramMode=2)
      graphFocus := clampInRange(Round(avgsMax/modePointV, 2), 0.20, 0.60)
   Else If (histogramMode=1)
      graphFocus := clampInRange(Round((avgsMax*0.3)/modePointV, 2), 0.03, 0.10)
   Else
      graphFocus := clampInRange(Round(modePointK3[1] / modePointV, 2), 0.85, 0.99) ; 0.98

   infoRange := defineHistogramMode() ": " graphFocus " | " defineHistogramType() " | Range: " rangeA[1] - 1 " - " rangeB[1] - 1 " (" rangeC ")"
   entireString := infoRange infoPeak infoAvg infoMin "`nTotal pixels: " TotalPixelzSpaced
   If (slideShowRunning=1)
      infoBoxBMP := trGdip_CreateBitmap(A_ThisFunc, 5, 5)
   Else
      infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfontSize//1.5, mainWidth//1.3, mainHeight//1.3, OSDtextColor, OSDbgrColor, 1, 0)
   ; tooltip, % "|" TotalPixelz "|" modePointV ", " 2ndMaxV ", " avgBrLvlV " || "  maxW "," maxH  ;  `n" PointsList
   Scale := (slideShowRunning=1) ? imgHUDbaseUnit/100 : imgHUDbaseUnit/80
   thisData := (showHistogram=6) ? brLvlFakeArray : brLvlArray
   thisOpacity := (showHistogram=6) ? "CC" : "FF"
   If (showHistogram=3)
      thisGraphColor := "FEFF3300"
   Else If (showHistogram=4)
      thisGraphColor := "FE33FF33"
   Else If (showHistogram=5)
      thisGraphColor := "FE3366FF"
   Else If (showHistogram=6)
      thisGraphColor := "FFaaAAaa"
   Else
      thisGraphColor := thisOpacity OSDtextColor

   ; TulTip(0, "|  ", modePointK3[1], modePointV, r2ndMaxV, graphFocus, lookValue[2], avgBrLvlV, meanValue)
   HistogramBMP := drawHistogram(thisData, graphFocus, 256, Scale, thisGraphColor, OSDbgrColor, imgHUDbaseUnit//2.5, infoBoxBMP)
   prevHistoBoxString := entireString
   trGdip_DisposeImage(infoBoxBMP, 1)
   If (whichBMP!=whichBitmap && StrLen(whichBMP)>2)
      trGdip_DisposeImage(whichBMP, 1)
}

groupDigits(nrIn, delim:=" ") {
   If StrLen(nrin)>3
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 2)
   If StrLen(nrin)>7
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 6)
   If StrLen(nrin)>11
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 10)
   If StrLen(nrin)>15
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 14)
   Return nrIn
}

defineRelativeSelCoords(maxSelX, maxSelY) {
   prcSelX1 := imgSelX1/maxSelX
   prcSelY1 := imgSelY1/maxSelY
   prcSelX2 := imgSelX2/maxSelX
   prcSelY2 := imgSelY2/maxSelY
}

capSelectionRelativeCoords() {
   If (prcSelX1<0)
      prcSelX1 := 0
   Else If (prcSelX1>=1)
      prcSelX1 := 0.99

   If (prcSelY1<0)
      prcSelY1 := 0
   Else If (prcSelY1>=1)
      prcSelY1 := 0.99

   If (prcSelX2<0.001)
      prcSelX2 := 0.001
   Else If (prcSelX2>1)
      prcSelX2 := 1

   If (prcSelY2<0.001)
      prcSelY2 := 0.001
   Else If (prcSelY2>1)
      prcSelY2 := 1
}

calcRelativeSelCoords(whichBitmap, imgW:=0, imgH:=0) {
   If (imgSelX1=0 && imgSelY1=0 && imgSelX2=-1 && imgSelY2=-1)
      Return

   If (!imgW || !imgH)
      Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

   imgSelX1 := Round(prcSelX1*imgW)
   imgSelY1 := Round(prcSelY1*imgH)
   imgSelX2 := Round(prcSelX2*imgW)
   imgSelY2 := Round(prcSelY2*imgH)
   nImgSelX1 := imgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := imgSelY1 := min(imgSelY1, imgSelY2)
   nimgSelX2 := max(imgSelX1, imgSelX2)
   nimgSelY2 := max(imgSelY1, imgSelY2)

   kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
   kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
   If (kimgSelW>32500)
      nImgSelX2 := nImgSelX1 + 32500
   If (kimgSelH>32500)
      nImgSelY2 := nImgSelY1 + 32500

   If (kimgSelH*kimgSelW>23125**2)
   {
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      scaleu := (kimgSelH*kimgSelW)/(23125**2)
      nImgSelX2 := nImgSelX1 + Floor(kimgSelW/scaleu)
      nImgSelY2 := nImgSelY1 + Floor(kimgSelH/scaleu)
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      If (kimgSelW>32500)
         nImgSelX2 := nImgSelX1 + 32500
      If (kimgSelH>32500)
         nImgSelY2 := nImgSelY1 + 32500
   }

   ImgSelX2 := nImgSelX2
   ImgSelY2 := nImgSelY2
}

AdaptiveImgLight(whichImg, imgPath, Width, Height) {
   If isWinXP
   {
      addJournalEntry("Automatic colors adjustments is deactivated on " A_OSVersion)
      Return
   }

   startZeit := A_TickCount
   If (Width=1 && Height=1)
      Gdip_GetImageDimensions(whichImg, Width, Height)

   mustRem := 0
   If ((Width//10*Height//10)>18500)
   {
      ; calcIMGdimensions(Width, Height, 900, 900, newWidth, newHeight)
      rBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichImg, 900, 900, 1, 3, -1)
      If !rBitmap
         Return -1
      Else
         mustRem := 1

      whichImg := rBitmap
   }

   Gdip_GetImageDimensions(whichImg, Width, Height)
   xCrop := Width//11
   yCrop := Height//11
   wCrop := Width - xCrop*2 + 1
   hCrop := Height - yCrop*2 + 1

   cropBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichImg, xCrop, yCrop, wCrop, hCrop)
   If !cropBMP
      Return -1

   brLvlArray := [], ArrChR := [], ArrChG := [], ArrChB := []
   rMinBrLvl := minBrLvl := 256
   modePointV := lumosAdjust := 1
   maxBrLvl := sumTotalBr := countTotalPixelz := thisBrLvl := 0
   GammosAdjust := countBrightPixelz := countMidPixelz := countDarkPixelz := 0

   ERR := Gdip_GetHistogram(cropBMP, 2, ArrChR, ArrChG, ArrChB)
   pEffect := Gdip_CreateEffect(6, 0, -100, 0)
   If !ERR
   {
      If pEffect
         rT := Gdip_BitmapApplyEffect(cropBMP, pEffect)
   
      Gdip_DisposeEffect(pEffect)
      ERR := Gdip_GetHistogram(cropBMP, 3, brLvlArray, 0, 0)
   }

   trGdip_DisposeImage(cropBMP, 1)
   If (mustRem=1)
      trGdip_DisposeImage(rBitmap, 1)

   If ERR
      Return -1

   rTotalPixelz := Width*Height
   TotalPixelz := wCrop*hCrop
   otherThreshold := (usrAdaptiveThreshold>0) ? usrAdaptiveThreshold : 2
   minMaxThreshold := Floor(rTotalPixelz*0.000015) + usrAdaptiveThreshold
   If (minMaxThreshold<1)
      minMaxThreshold := 1

   ; gather image histogram statistics
   Loop, 256
   {
       thisIndex := A_Index - 1
       nrPixelz := brLvlArray[thisIndex]
       If !nrPixelz
          Continue

       sumTotalBr += nrPixelz * thisIndex
       If (nrPixelz>modePointV)
       {
          modePointV := nrPixelz
          modePointK := thisIndex
       }

       If (thisIndex>maxBrLvl && nrPixelz>minMaxThreshold)
          maxBrLvl := thisIndex

       If (thisIndex<minBrLvl && nrPixelz>minMaxThreshold)
          minBrLvl := thisIndex

       If (thisIndex<rMinBrLvl && nrPixelz>otherThreshold)
          rMinBrLvl := thisIndex

       If (isInRange(thisIndex, 4, 40))
          countDarkPixelz += nrPixelz
       Else If (isInRange(thisIndex, 170, 253))
          countBrightPixelz += nrPixelz
       Else If (isInRange(thisIndex, 50, 165))
          countMidPixelz += nrPixelz
   }

   avgBrLvl := Round(sumTotalBr/TotalPixelz)
   Loop, 23
   {
       nrPixelz := brLvlArray[avgBrLvl - 11 + A_Index]
       If nrPixelz
          countFlatties += nrPixelz
   }

   Loop, 11
   {
       nrPixelz := brLvlArray[modePointK - 6 + A_Index]
       If nrPixelz
          countModies += nrPixelz
   }

   aMinBrLvl := (rMinBrLvl + minBrLvl)//2
   Loop, 10
   {
       nrPixelz := brLvlArray[aMinBrLvl + A_Index]
       If nrPixelz
          countLowestPx += nrPixelz
   }
   percmodePx := Round((countModies/TotalPixelz)*100, 4)
   percBrgPx := Round((countBrightPixelz/TotalPixelz) * 100, 4)
   percLowPx := Round((countLowestPx/TotalPixelz) * 100, 4)
   percDrkPx := Round((countDarkPixelz/TotalPixelz) * 100, 4)
   percMidPixu := Round((countMidPixelz/TotalPixelz) * 100, 4)
   oPercAvgPx := Round((countFlatties/TotalPixelz) * 100, 4)
   If (percmodePx<=0.00015)
      percmodePx += 0.000156
   If (percMidPixu<=0.00015)
      percMidPixu += 0.000156
   If (percBrgPx<=0.00025)
      percBrgPx += 0.000256
   If (percDrkPx<=0.001)
      percDrkPx += 0.01512
   percAvgPx := Round((oPercAvgPx + percmodePx + percMidPixu)/3, 4)
   percMidPx := 100 - percBrgPx - percDrkPx
   If (percMidPx<=0.00025)
      percMidPx += 0.000256

   ; make the image brighter if max. luminance [maxBrLvl] is less than 255
   multiplieruA := 255.1/maxBrLvl + (percDrkPx + (255.1 - avgBrLvl)/3 + (255.1 - (modePointK+avgBrLvl)/2)/3)/(500 + maxBrLvl*2 + avgBrLvl*10)
   If (percBrgPx>1.25)
      multiplieruA := multiplieruA - Round(percMidPx/450, 4)

   multiplieruB := 255.1/maxBrLvl + (percDrkPx/8 + (255.1 - avgBrLvl)/15 + (255.1 - modePointK)/10)/50 - percBrgPx/25 - ((percMidPixu + percMidPx)/2)/40
   multiplieru := (multiplieruA + multiplieruB)/2

   If (multiplieru<=1)
      multiplieru := 1.0002
   If (multiplieru<=1.15)
   {
      multiplieruC := 255.1/maxBrLvl + (percDrkPx + (255.1 - avgBrLvl)/3 + (255.1 - (modePointK+avgBrLvl)/2)/3)/(500 + maxBrLvl*2 + avgBrLvl*10)
      If (percBrgPx>1.25)
         multiplieruC := multiplieruC - Round(percMidPx/450, 4)
      multiplieru := multiplieruC/1.25
      If (multiplieru<=1)
         multiplieru := 1.0002
   }

   lumosAdjust := multiplieru
   GammosAdjust := - lumosAdjust/40 + 0.025 + ((percDrkPx + percAvgPx)/(900 + percBrgPx*100 + avgBrLvl*2))/3.25
   realGammos := Round(1 - ((percDrkPx + percAvgPx)/(900 + percBrgPx*100 + avgBrLvl*2))/1.25, 3)

   ; make the image darker when lacking contrast or min. luminance level [minBrLvl] is higher than 1
   darkerOffsetA := rMinBrLvl*multiplieru
   darkerOffsetA := (darkerOffsetA - 3)/105
   darkerOffsetB := (aMinBrLvl/multiplieru/(200 - percBrgPx/4) + percBrgPx/percDrkPx/avgBrLvl/300)/1.5
   darkerOffsetC := (minBrLvl/multiplieru)/250 + avgBrLvl/(600 - avgBrLvl/10)
   darkerOffset := (darkerOffsetA + darkerOffsetB)/2 - percLowPx/700
   testGammosAdjust := GammosAdjust - darkerOffset/1.1
   If (testGammosAdjust>-0.02 && aMinBrLvl>3)
      darkerOffset := darkerOffsetC/1.5
   If (darkerOffset<=0)
      darkerOffset := 0.00001

   lumosAdjust := lumosAdjust + darkerOffset
   GammosAdjust := GammosAdjust - darkerOffset/1.1

   If (autoAdjustMode=2)
   {
      lumosAdjust := multiplieru := 255.1/maxBrLvl
      GammosAdjust := - lumosAdjust/40 + 0.025
   } Else If (autoAdjustMode=3)
   {
      darkerOffset := rMinBrLvl/255
      lumosAdjust := 1 + darkerOffset*1.1
      GammosAdjust := 0 - darkerOffset*1.3
   }

   ; adjust saturation
   If (doSatAdjusts=1)
   {
      Loop, 256
      {
          thisIndex := A_Index
          nrPixR := ArrChR[thisIndex]
          nrPixG := ArrChG[thisIndex]
          nrPixB := ArrChB[thisIndex]
          If (nrPixR="" || nrPixG="" || nrPixB="")
             Continue
 
          sumTotalR += nrPixR * thisIndex
          sumTotalG += nrPixG * thisIndex
          sumTotalB += nrPixB * thisIndex
          BrLvlDifs := max(NrPixR, NrPixG, NrPixB) - min(NrPixR, NrPixG, NrPixB)
          If (BrLvlDifs<minMaxThreshold*2) || (nrPixR+nrPixB+nrPixB<minMaxThreshold*3)
             Continue
          tNrPixR += nrPixR
          tNrPixG += nrPixG
          tNrPixB += nrPixB
          tNrPixAll += max(NrPixR, NrPixG, NrPixB)
          AllBrLvlDifs += BrLvlDifs
      }
   }
   BrLvlDiffX := max(tNrPixR, tNrPixG, tNrPixB) - min(tNrPixR, tNrPixG, tNrPixB)
   PrcLvlDiffX := Round((BrLvlDiffX/tNrPixAll)*100, 4)
   PrcLvlDiffXa := Round((AllBrLvlDifs/tNrPixAll)*100, 4)

   v1a := ArrChR[maxBrLvl]
   v2a := ArrChG[maxBrLvl]
   v3a := ArrChB[maxBrLvl]
   v1b := ArrChR[maxBrLvl - 1]
   v2b := ArrChG[maxBrLvl - 1]
   v3b := ArrChB[maxBrLvl - 1]
   v1e := ArrChR[modePointK]
   v2e := ArrChG[modePointK]
   v3e := ArrChB[modePointK]
   ; hmmu := max(v1a, v2a, v3a) " -- " min(v1a, v2a, v3a) " -- " v1a "," v2a "," v3a

   BrLvlDiffA := max(v1a, v2a, v3a) - min(v1a, v2a, v3a)
   BrLvlDiffB := max(v1b, v2b, v3b) - min(v1b, v2b, v3b)
   BrLvlDiffE := max(v1e, v2e, v3e) - min(v1e, v2e, v3e)
   PrcLvlDiffA := Round((BrLvlDiffA/max(v1a, v2a, v3a))*100, 4)
   PrcLvlDiffB := Round((BrLvlDiffB/max(v1b, v2b, v3b))*100, 4)
   PrcLvlDiffE := Round((BrLvlDiffE/max(v1e, v2e, v3e))*100, 4)
   avgLvlsDiff := (PrcLvlDiffA + PrcLvlDiffB + PrcLvlDiffE)/3

   satAdjust := 1
   satLevel := (lumosAdjust - GammosAdjust - 1)/15 - percDrkPx/50
   If (satLevel<0)
      satLevel := 0
   satAdjust := 1 - satLevel
   If (satAdjust<0.5)
      satAdjust := 0.5
   Else If (PrcLvlDiffX>0.5)
      satAdjust := satAdjust - PrcLvlDiffX/50 + 0.02

   If (PrcLvlDiffX<0.2)
   {
      PrcLvlDiffX := Round((3*BrLvlDiffX/TotalPixelz)*100, 4)
      satAdjust := satAdjust + PrcLvlDiffX/40 + 0.02
   }

   If (avgLvlsDiff>95)
      satAdjust := satAdjust - (avgLvlsDiff - 95)/100 + 0.02
   Else If (avgLvlsDiff<20)
      satAdjust := satAdjust + (20 - avgLvlsDiff)/100

   If (PrcLvlDiffXa>50)
      satAdjust -= PrcLvlDiffXa/1000
   Else
      satAdjust += PrcLvlDiffXa/700

   avgBrLvlR := Round(sumTotalR/TotalPixelz)
   avgBrLvlG := Round(sumTotalG/TotalPixelz)
   avgBrLvlB := Round(sumTotalB/TotalPixelz)
   chnlDiffs := max(avgBrLvlR, avgBrLvlG, avgBrLvlB) - min(avgBrLvlR, avgBrLvlG, avgBrLvlB)
   chnlDiffs := Round((chnlDiffs/maxBrLvl)*100, 4)
   If (avgBrLvlR>240 || avgBrLvlG>240 || avgBrLvlB>240) && (avgBrLvlR!=avgBrLvlB || avgBrLvlR!=avgBrLvlG ||  avgBrLvlB!=avgBrLvlG)
      satAdjust -= 0.05

   If (satAdjust<0.86)
      satAdjust += percDrkPx/800
   If (satAdjust<0.70)
      satAdjust := 0.70

   If (satAdjust>0.8 && chnlDiffs>=20)
      satAdjust -= chnlDiffs>50 ? chnlDiffs/825 : chnlDiffs/950
   Else If (chnlDiffs<11)
      satAdjust += (100 - chnlDiffs)/950

   otherz := (avgBrLvlG + avgBrLvlB)//1.5
   rLevelu := (avgBrLvlR>otherz+5 && avgBrLvlR<100 && otherz/avgBrLvlR<0.5) ? 1 - otherz/avgBrLvlR : 0
   satAdjust -= rLevelu/11
   otherz := (avgBrLvlR + avgBrLvlB)//1.5
   gLevelu := (avgBrLvlG>otherz+5 && avgBrLvlG<100 && otherz/avgBrLvlG<0.5) ? 1 - otherz/avgBrLvlG : 0
   satAdjust -= gLevelu/11
   otherz := (avgBrLvlG + avgBrLvlR)//1.5
   bLevelu := (avgBrLvlB>otherz+5 && avgBrLvlB<100 && otherz/avgBrLvlB<0.5) ? 1 - otherz/avgBrLvlB : 0
   satAdjust -= bLevelu/11
   If (doSatAdjusts!=1)
      satAdjust := 1

   ; execTime := A_TickCount - startZeit
   ; ToolTip, % redLevelu ",avgRGB=" avgBrLvlR ", " avgBrLvlG ", " avgBrLvlB ", ChnlDiff=" chnlDiffs  ", AvgLvlDif=" avgLvlsDiff " %, diffA=" PrcLvlDiffA " %, diffE=" PrcLvlDiffE " %, diffX=" PrcLvlDiffX "/" PrcLvlDiffXa "% `nTh=" minMaxThreshold ", min=" minBrLvl "/" rMinBrLvl ", max=" maxBrLvl ", A=" avgBrLvl ", mP=" modePointK " [" modePointV " / " percmodePx "% ]"  ",`nL=" percBrgPx "%, D=" percDrkPx "%, Dl=" percLowPx "%, Mr=" percMidPx "% / Mo=" percMidPixu "%, oAvg=" oPercAvgPx "%, fAvg=" percAvgPx "%`ncL=" lumosAdjust ", cG=" GammosAdjust ", cS=" satAdjust ", T=" execTime "ms",,, 2
}

VPnavBoxWrapper(mainWidth, mainHeight, Gu) {
    Critical, on

    createVPnavBox(navBoxu, imgW, imgH, diffX, diffY, zImgW, zImgH, entireString)
    hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
    scrbH := (thumbsDisplaying=1 && FlipImgV=0) ? 0 : scrollBarHy
    scrbV := (thumbsDisplaying=1 && FlipImgH=1) ? 0 : scrollBarVx
    tlbrBonusX := (hasTrans=1 && (FlipImgH=0 || thumbsDisplaying=1 && FlipImgH=1) && ((ToolbarWinH - 3 > mainHeight - imgH - scrbH) || FlipImgV=1 && thumbsDisplaying=0)) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2 && FlipImgV=1 && ((ToolbarWinW - 3 > mainWidth  - imgW - scrbV) || FlipImgH=0)) ? ToolbarWinH : 0
    thisPosX := (FlipImgH=1 && scrbV>0) ? tlbrBonusX + scrbV : tlbrBonusX
    thisPosY := (FlipImgV=0 && scrbH>0 && thumbsDisplaying!=1) ? mainHeight - scrbH - imgH - tlbrBonusY : mainHeight - imgH - tlbrBonusY
    If navBoxu
       ERR := trGdip_DrawImage(A_ThisFunc, Gu, navBoxu, thisPosX, thisPosY)

    hasDrawnImageMap := (navBoxu && !ERR) ? 1 : 0
    If (thumbsDisplaying=0)
    {
       thisPosX := tlbrBonusX
       thisPosY := (scrbH>0) ? mainHeight - scrbH - imgH : mainHeight - imgH
       If (FlipImgH=1)
          thisPosX := mainWidth - imgW - scrbV
       If (FlipImgV=1)
          thisPosY := tlbrBonusY
    }

    ; ToolTip, % scrollBarVx "==" scrollBarHy , , , 2
    If navBoxu
       HUDobjNavBoxu := [zImgW, zImgH, thisPosX + diffX, thisPosY + diffY, imgW, imgH, thisPosX, thisPosY]

    thisString := hasDrawnImageMap ? entireString : "hide"
    interfaceThread.ahkPostFunction("uiAccessUpdateNavBox", thisString, imgW, imgH, thisPosX, thisPosY)
    trGdip_DisposeImage(navBoxu, 1)
}

createVPnavBox(ByRef pBitmap, ByRef imgW, ByRef imgH, ByRef posX, ByRef posY, ByRef fImgW, ByRef fImgH, ByRef entireString) {
   Static lastState := 1
   pBitmap := ""
   navBoxu := coreCreateVPnavBox()
   If StrLen(navBoxu)<3
      Return

   Gdip_GetImageDimensions(navBoxu, fImgW, fImgH)
   Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   imgW := imgH := Ceil(HUDnavBoxSize * imgHUDbaseUnit/20)
   posX := imgW//2 - fImgW//2
   posY := imgH//2 - fImgH//2

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
   If StrLen(pBitmap)<3
   {
      pBitmap := ""
      trGdip_DisposeImage(navBoxu, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      pBitmap := ""
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   entireString := (thumbsDisplaying=1) ? "Image preview area: " : "Image navigator box: "
   entireString .= (HUDnavBoxSize<76) ? "small size." : "large size."
   If (usrColorDepth>1 || imgFxMode>1) 
      entireString .= "`nViewport color effects are applied."

   If (thumbsDisplaying=1)
   {
      If (resultedFilesList[currentFileIndex, 3]=1)
         entireString .= "`nImage already seen. "

      If (resultedFilesList[currentFileIndex, 5]=1)
         entireString .= "`nAdded to favourites. "

      If (resultedFilesList[currentFileIndex, 2]=1)
         entireString .= "`nFile selected."
   } Else
   {
      entireString .= "`nZoom level: " Round(zoomLevel*100) "%."
      If (allowFreeIMGpanning=1)
         entireString .= "`nThe image can be panned outside the viewport. "

      If (vpIMGrotation>0)
         entireString .= "`nImage rotation: " vpIMGrotation "°. "

      If (editingSelectionNow=1)
         entireString .= "`nImage " DefineVPselAreaMode() " selection area. " 

      If (imgSelLargerViewPort=1)
         entireString .= "`nIt covers the entire viewport area. "
      Else If (imgSelOutViewPort=1)
         entireString .= "`nIt is situated outside the viewport area, but a handle to retrieve it is available in the viewport. "

      entireString .= "`nResolution: " groupDigits(prevMaxSelX) " x " groupDigits(prevMaxSelY) " pixels. " Round((prevMaxSelX*prevMaxSelY)/1000000,2) " megapixels. "
      If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1)
         entireString .= ". The image is downscaled. "
      If (currIMGdetails.TooLargeGDI=1)
         entireString .= "`nOriginal resolution: " groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " pixels. " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " megapixels."

      entireString .= "`nAlt+Left click to toggle size. Ctrl+Left-click and drag to adjust zoom level."
   }

   entireString .= "`nRight-click for more options."
   Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)
   If (resultedFilesList[currentFileIndex, 2]=1 && thumbsDisplaying=0)
   {
      pBrush3 := Gdip_BrushCreateSolid("0x400188FF")
      Gdip_FillRectangle(Gu, pBrush3, 0, 0, imgW, imgH)
      Gdip_DeleteBrush(pBrush3)
   } Else
      Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)

   E := trGdip_DrawImage(A_ThisFunc, Gu, navBoxu, posX, posY, fImgW, fImgH)
   If (E="fail")
   {
      pBitmap := ""
      Gdip_DeleteGraphics(Gu)
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   ; Gdip_SetClipRect(Gu, posX, posY, fImgW, fImgH, 4)
   borderu := Round(imgW*0.0099)
   ; Gdip_FillRectangle(Gu, pBrushE, posX - borderu, posY - borderu, fImgW + borderu*2, fImgH + borderu*2)
   ; Gdip_ResetClip(Gu)
   If (resultedFilesList[currentFileIndex, 3]=1 && highlightAlreadySeenImages=1 && thumbsDisplaying=1)
      Gdip_DrawRectangle(Gu, pPen5, 2, 2, imgW - 5, imgH - 5)

   If (resultedFilesList[currentFileIndex, 5]=1) ; is bookmarked
      Gdip_DrawRectangle(Gu, pPen1d, 2, 2, imgW - 5, imgH - 5)

   If (editingSelectionNow=1 && thumbsDisplaying!=1)
   {
      calcImgSelection2bmp(1, oimgW, oimgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      If (zImgSelW<borderu*2 || zImgSelH<borderu*2)
         Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

      If (zImgSelW<borderu*2)
         zImgSelW := borderu*2
      If (zImgSelH<borderu*2)
         zImgSelH := borderu*2

      pPath := createImgSelPath(posX + zimgSelPx, posY + zimgSelPy, zimgSelW, zimgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
      Gdip_SetClipPath(Gu, pPath, 0)
      If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
         thisBrush := lastState ? pBrushA : pBrushD
      Else
         thisBrush := pBrushA

      Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      Gdip_DeletePath(pPath)
      Gdip_ResetClip(Gu)
   }

   If (thumbsDisplaying!=1)
   {
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      obju := createImgSelection2Win(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, prevMaxSelX, prevMaxSelY, mainWidth, mainHeight, 1, 0)
      coords := obju.x1 "|" obju.y1 "|" obju.x2 "|" obju.y2
      calcImgSelection2bmp(1, oimgW, oimgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, coords)
      If (zImgSelW<borderu*2)
         zImgSelW := borderu*2
      If (zImgSelH<borderu*2)
         zImgSelH := borderu*2

      If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
         thisBrush := lastState ? pBrushC : pBrushD
      Else
         thisBrush := pBrushC

      Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      ; Gdip_SetClipRect(Gu, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH, 4)
      ; borderu := Round(imgW*0.006)
      ; Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

      Gdip_ResetClip(Gu)
      ; Gdip_SetClipRect(Gu, borderu, borderu, imgW - borderu*2, imgH - borderu*2, 4)
      ; Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)
   }

   lastState := !lastState
   Gdip_DeleteGraphics(Gu)
   Return pBitmap
}

coreCreateVPnavBox(modus:=0) {
   Static lastCall, prevBMP
   If (modus="kill")
   {
      prevBMP := trGdip_DisposeImage(prevBMP, 1)
      prevBMP := lastCall := ""
      Return
   }

   whichBitmap := useGdiBitmap()
   If (thumbsDisplaying=1)
   {
      whichBitmap := ""
      imgPath := StrReplace(getIDimage(currentFileIndex), "||")
      If !FileRexists(imgPath)
         Return

      MD5name := generateThumbName(imgPath, 1, 1)
      file2save := thumbsCacheFolder "\500-" MD5name ".jpg"
      If FileExist(file2save)
      {
         whichBitmap := LoadCachableBitmapFromFile(file2save)
      } Else
      {
         sizesDesired := []
         sizesDesired[1] := [500, 500, 1, 0, 6]
         changeMcursor()
         whichBitmap := LoadBitmapFromFileu(imgPath, 0, 0, 0, sizesDesired)
         If StrLen(whichBitmap)>1
         {
            ; whichBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 500, 500, 1, 7)
            ; trGdip_DisposeImage(oBitmap, 1)
            Gdip_SaveBitmapToFile(whichBitmap, file2save, 94)
         }
         ResetImgLoadStatus()
      }
      If StrLen(whichBitmap)>1
         whichBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(whichBitmap))
   }

   thisCall := "a" whichBitmap MD5name imgPath thumbsDisplaying gdiBitmapIDcall currentFileIndex getIDimage(currentFileIndex) currentUndoLevel undoLevelsRecorded UserMemBMP imgHUDbaseUnit OSDfontSize HUDnavBoxSize FlipImgH FlipImgV imgFxMode
   If (thisCall=lastCall)
      Return prevBMP

   If !whichBitmap
   {
      prevBMP := trGdip_DisposeImage(prevBMP, 1)
      prevBMP := lastCall := ""
      Return
   }

   prevBMP := trGdip_DisposeImage(prevBMP, 1)
   imgW := imgH := Ceil(HUDnavBoxSize * imgHUDbaseUnit/20)
   Gdip_GetImageDimensions(whichBitmap, rImgW, rImgH)
   calcIMGdimensions(rImgW, rImgH, imgW, imgH, ResizedW, ResizedH)

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, coreDesiredPixFmt)
   If !pBitmap
   {
      If (thumbsDisplaying=1)
         trGdip_DisposeImage(whichBitmap, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      If (thumbsDisplaying=1)
         trGdip_DisposeImage(whichBitmap, 1)
      Return
   }
   ; Gdip_FillRectangle(Gu, pBrushE, 0, 0, ResizedW, ResizedH)
   posX := posY := 0
   E := trGdip_DrawImage(A_ThisFunc, Gu, whichBitmap, posX, posY, ResizedW, ResizedH)
   Gdip_DeleteGraphics(Gu)
   prevBMP := (E!="fail") ? pBitmap : ""
   lastCall := (E!="fail") ? thisCall : ""
   If (E="fail")
   {
      pBitmap := trGdip_DisposeImage(pBitmap, 1)
   } Else If (userPrivateMode=1)
   {
      pBlurEffect := Gdip_CreateEffect(1, 190, 0)
      Gdip_BitmapApplyEffect(pBitmap, pblurEffect)
      Gdip_DisposeEffect(pBlurEffect)
   }

   If (thumbsDisplaying=1)
      trGdip_DisposeImage(whichBitmap, 1)

   Return pBitmap
}

ImageNavBoxClickResponder() {
   Static prevState := "a"
   If GetKeyState("Alt", "P")
   {
      ToggleImgNavSizeBox()
      Return
   }

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If ((!imgW || !imgH) && (thumbsDisplaying!=1))
      Return

   If (thumbsDisplaying!=1 && IMGresizingMode!=4)
   {
      IMGresizingMode := 3
      ToggleImageSizingMode()
   }

   If (GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P")) && (thumbsDisplaying!=1)
   {
      tlbrZoomIN("navBox")
      Return
   }

   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := clampInRange(mX - HUDobjNavBoxu[3], 0, HUDobjNavBoxu[1])
   mY := clampInRange(mY - HUDobjNavBoxu[4], 0, HUDobjNavBoxu[2])
   navWidth := HUDobjNavBoxu[1]
   navHeight := HUDobjNavBoxu[2]
   diffIMGdecX := diffIMGdecY := 0
   prevImgDecaX := prevImgDecaY := 0
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   minTopCornerX := (allowFreeIMGpanning=1) ? mainWidth : 0
   minTopCornerY := (allowFreeIMGpanning=1) ? mainHeight : 0
   vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
   imgPath := getIDimage(currentFileIndex)
   thisZeit := A_TickCount - 100
   thisIndex := 0
   Random, randomFactor, -950, 950
   minX := (allowFreeIMGpanning=1) ? - HUDobjNavBoxu[1] : 0
   minY := (allowFreeIMGpanning=1) ? - HUDobjNavBoxu[2] : 0
   setwhileLoopExec(1)
   While, (determineLClickstate()=1 || A_Index<2)
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := clampInRange(mX - HUDobjNavBoxu[3], minX, HUDobjNavBoxu[1])
      mY := clampInRange(mY - HUDobjNavBoxu[4], minY, HUDobjNavBoxu[2])
      f := (imageAligned=1 || allowFreeIMGpanning=1) ? 0 : 0.5

      If (FlipImgV=1)
         mY := navHeight - mY
      If (FlipImgH=1)
         mX := navWidth - mX

      prcW := mX/navWidth
      prcH := mY/navHeight
      ; ToolTip, % mX "==" mY "==" navWidth "==" navHeight "==" prcW "==" prcH , , , 2
      If (allowFreeIMGpanning=0)
      {
         prcW := (prcW>f) ? prcW - f : f - prcW
         prcH := (prcH>f) ? prcH - f : f - prcH
      }

      decX := Round(((imgW)*prcW) * zoomLevel)
      decY := Round(((imgH)*prcH) * zoomLevel)
      prcW := mX/navWidth
      prcH := mY/navHeight
      If (prcW>f || imageAligned=1 || allowFreeIMGpanning=1)
         decX := -decX
      If (prcH>f || imageAligned=1 || allowFreeIMGpanning=1)
         decY := -decY

      If (decX>0 && imageAligned=1 && FlipImgH=0 && allowFreeIMGpanning=0)
         decX := 0

      If (decY>0 && imageAligned=1 && FlipImgV=0 && allowFreeIMGpanning=0)
         decY := 0

      limitPanningDist(decX, decY, minTopCornerX, minTopCornerY)
      diffIMGdecX := -1*(prevImgDecaX - decX) + 2
      diffIMGdecY := -1*(prevImgDecaY - decY) + 2
      thisState := "a" randomFactor decX decY diffIMGdecX diffIMGdecY currentFileIndex getIDimage(currentFileIndex) currentUndoLevel zoomLevel gdiBitmap
      If (prevState!=thisState) && (A_TickCount - thisZeit>25)
      {
         ; ToolTip, % diffIMGdecX "==" diffIMGdecY , , , 2
         thisIndex++
         zeitSillyPrevent := A_TickCount
         IMGdecalageX := decX
         IMGdecalageY := decY
         prevImgDecaX := decX
         prevImgDecaY := decY
         thisZeit := A_TickCount
         prevState := thisState
         dummyResizeImageGDIwin()
      }
   }

   setwhileLoopExec(0)
   vpImgPanningNow := diffIMGdecX := diffIMGdecY := 0
   If (thisIndex>10 || lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
}

wrapResizeImageGDIwin() {
    startZeitIMGload := A_TickCount
    imgPath := StrReplace(getIDimage(currentFileIndex), "||")
    ResizeImageGDIwin(imgPath, 2, 0)
}

getPixelColorAvg(pBitmap, kX, kY, startToolColor, oldColor) {
   coloruA := Gdip_GetPixelColor(pBitmap, kX, kY, 1)
   coloruB := Gdip_GetPixelColor(pBitmap, kX + 2, kY + 2, 1)
   coloruD := Gdip_GetPixelColor(pBitmap, kX - 2, kY - 2, 1)
   coloruC := Gdip_GetPixelColor(pBitmap, kX + 2, kY - 2, 1)
   If (coloruA && coloruB)
      coloruZ := MixARGB(coloruA, coloruB, 0.5)
   If (coloruC && coloruD)
      coloruX := MixARGB(coloruC, coloruD, 0.5)
   If (coloruZ && coloruX)
      coloruY := MixARGB(coloruZ, coloruX, 0.5)
   Else If coloruZ
      coloruY := coloruZ
   Else If coloruX
      coloruY := coloruX
   Else
      coloruY := startToolColor

   Return coloruY
}

toggleBrushDoubleSize() {
   brushToolDoubleSize := !brushToolDoubleSize
   friendly := (brushToolDoubleSize=1) ? "RADIUS" : "DIAMETER"
   showTOOLtip("Brush " friendly " size: " brushToolSize " px", A_ThisFunc, 1, brushToolSize/950)
   If isVarEqualTo(AnyWindowOpen, 64, 24, 31)
      GuiControl, SettingsGUIA:, brushToolDoubleSize, % brushToolDoubleSize

   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushAirMode() {
   If (BrushToolType=2 || BrushToolType=3)
      Return

   BrushToolOverDraw := !BrushToolOverDraw
   friendly := (BrushToolOverDraw=1) ? "ACTIVATED" : "DEACTIVATED"
   labelu := (BrushToolType>=6) ? "Auto-scale brush deformer: " : "Airbrush mode: "
   If isVarEqualTo(AnyWindowOpen, 64, 24, 31)
      GuiControl, SettingsGUIA:, BrushToolOverDraw, % BrushToolOverDraw

   showTOOLtip(labelu friendly moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushSymmetryModes() {
   Static hasRan := 0
   If (drawingShapeNow=1)
   {
      If (customShapePoints.Count()>1)
      {
         CustomShapeSymmetry := CustomShapeSymmetry ? 0 : CustomShapeLockedSymmetry
         If (CustomShapeSymmetry || CustomShapeLockedSymmetry=0)
            moreInfo := "`nSymmetry mode is locked"
      } Else CustomShapeSymmetry := clampInRange(CustomShapeSymmetry + 1, 0, 2, 1)

      If (CustomShapeSymmetry=1)
         friendly := "X"
      Else If (CustomShapeSymmetry=2)
         friendly := "Y"
      Else
         friendly := "NONE"
      ; ToolTip, % CustomShapeSymmetry "==" CustomShapeLockedSymmetry , , , 2
      showTOOLtip("Shape symmetry: " friendly moreInfo, A_ThisFunc, 1, CustomShapeSymmetry/3)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, dummyRefreshImgSelectionWindow, -150
      Sleep, 500
      showQuickActionButtonsDrawingShape()
      Return
   }

   If (BrushToolType>3)
   {
      showTOOLtip("WARNING: Symmetry painting not available for the current brush type")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (BrushToolSymmetryX=0 && BrushToolSymmetryY=0)
   {
      levelu := 3
      BrushToolSymmetryX := BrushToolSymmetryY := 1
   } Else If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
   {
      levelu := 2
      BrushToolSymmetryX := 0
      BrushToolSymmetryY := 1
   } Else If (BrushToolSymmetryX=0 && BrushToolSymmetryY=1)
   {
      levelu := 1
      BrushToolSymmetryX := 1
      BrushToolSymmetryY := 0
   } Else If (BrushToolSymmetryX=1 && BrushToolSymmetryY=0)
   {
      levelu := 0.0001
      BrushToolSymmetryX := BrushToolSymmetryY := 0
   }

   friendly := (BrushToolSymmetryX=1) ? "X" : ""
   friendly2 := friendly ? friendly ", " : ""
   friendly3 := (BrushToolSymmetryY=1) ?  friendly2 "Y" : friendly
   If !friendly3
      friendly3 := "NONE"

   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA:, BrushToolSymmetryX, % BrushToolSymmetryX
      GuiControl, SettingsGUIA:, BrushToolSymmetryY, % BrushToolSymmetryY
   }

   If (hasRan<4)
      moreInfos := "`nPress Shift + Y to define the symmetry coordinates"

   hasRan++
   showTOOLtip("Painting symmetry: " friendly3 moreInfos, A_ThisFunc, 1, levelu/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, dummyRefreshImgSelectionWindow, -200
}

discardUserPaintedAlpha() {
   If isNowAlphaPainting()
      Return

   okay := (StrLen(userAlphaMaskBmpPainted)>2 || StrLen(userPrevAlphaMaskBmpPainted)>2) ? 1 : 0
   If (okay=1)
   {
      userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted, 1)
      userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
      If (alphaMaskingMode=5 && isAlphaMaskWindow()=1)
      {
         GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 1
         GuiControl, SettingsGUIA:, alphaMaskGradientScale, 100
         UItriggerBrushUpdate(1)
         showDelayedTooltip("User painted alpha mask discarded")
      } Else showTOOLtip("User painted alpha mask discarded")
   } Else If (alphaMaskingMode>1)
   {
      alphaMaskingMode := 1
      If (isAlphaMaskWindow()=1)
      {
         GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 1
         GuiControl, SettingsGUIA:, alphaMaskGradientScale, 100
         UItriggerBrushUpdate(1)
         showDelayedTooltip("The alpha mask is now undefined")
      } Else 
      {
         corelivePreviewsImageEditing()
         showTOOLtip("The alpha mask is now undefined")
      }
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastPaintEventID := ""
}

toggleInvertAlphaMask() {
   alphaMaskColorReversed := !alphaMaskColorReversed
   GuiControl, SettingsGUIA:, alphaMaskColorReversed, % alphaMaskColorReversed
   livePreviewsImageEditing()
   friendly := (alphaMaskColorReversed=1) ? "ACTIVATED" : "DEACTIVATED" 
   showTOOLtip("Inverted alpha mask: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleAlphaPaintingMode() {
   Critical, on
   ; alpha mask painting, transform tool
   If !isImgEditingNow()
      Return

   forceLiveAlphaPreviewMode := userAllowsGradientRecentering := userAllowClrGradientRecenter := 0
   If (AnyWindowOpen=66 || AnyWindowOpen=64)
   {
      ; flood fill / paint brushes tool
      If !editingSelectionNow
      {
         showTOOLtip("WARNING: No selection area is activated.")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
      labelu := (AnyWindowOpen=66) ? "Flood fill" : "Paint brush"
      friendly := (BrushToolOutsideSelection=1) ? "ANYWHERE" : "INSIDE SELECTION"
      If (BrushToolOutsideSelection=3)
         friendly := "OUTSIDE SELECTION"

      FloodFillSelectionAdj := !FloodFillSelectionAdj
      If (AnyWindowOpen=64)
         liveDrawingBrushTool := !FloodFillSelectionAdj
      interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
      If (FloodFillSelectionAdj=1)
         showTOOLtip(labelu " tool: DEACTIVATED`nSelection area can be adjusted.", A_ThisFunc, 1)
      Else
         showTOOLtip(labelu " tool: ACTIVATED`nFill mode: " Friendly, A_ThisFunc, 1)

      SetTimer, dummyRefreshImgSelectionWindow, -100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (mustCaptureCloneBrush=1)
   {
      StopCaptureClickStuff(dummy)
      Return
   }

   FloodFillSelectionAdj := 0
   liveDrawingBrushTool := !liveDrawingBrushTool
   Random, OutputVar, 1, 950
   Random, OutputaVar, 1, 950
   randomu := OutputVar / OutputaVar
   If (isAlphaMaskWindow()=1 && liveDrawingBrushTool=1)
   {
      allGood := 1
      infoMask := defineCurrentAlphaMask()
      If StrLen(userAlphaMaskBmpPainted)>2 && !InStr(infoMask, "user painted")
      {
         liveDrawingBrushTool := 0
         allGood := 0
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "There is an already user painted bitmap created, but the alpha mask is currently set to a parametric / generated one. Would you like to rasterize this or return to the already created bitmap?`n`nPlease note, you can blend the current alpha mask with the user painted bitmap by using the «Rasterize» option from the main menu.", "&Rasterize this|Return to &bitmap|&Cancel", 1, "question")
         If InStr(msgResult, "rasterize")
         {
            allGood := 1
            RasterizeAlphaMaskNow("no-ask")
         } Else If InStr(msgResult, "return")
            allGood := 1
      }

      If !allGood
      {
         liveDrawingBrushTool := 0
         Return
      }

      liveDrawingBrushTool := 1
      imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
      imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
      showTOOLtip("Please wait, activating painting mode")
      If StrLen(userAlphaMaskBmpPainted)<3
      {
         freshMode := 1
         If (isVarEqualTo(AnyWindowOpen, 70, 32, 23) && alphaMaskingMode>1)
            alphaMaskGray := generateAlphaMaskBitmap(0, 0, imgSelW//2, imgSelH//2, 0, 0, 0, 1)
         Else If (alphaMaskingMode>1)
            alphaMaskGray := generateAlphaMaskBitmap(userClipBMPpaste, 0, 0, 0, 0, 0, 0, 1)

         If StrLen(alphaMaskGray)>2
            generated := 1
      }

      RegAction(0, "brushAclrAlpha",, 3)
      RegAction(0, "brushBclrAlpha",, 3)
      BrushToolAcolor := (brushAclrAlpha!="") ? brushAclrAlpha : convertColorToGrayscale(BrushToolAcolor)
      BrushToolBcolor := (brushBclrAlpha!="") ? brushBclrAlpha : convertColorToGrayscale(BrushToolBcolor)
      GuiControl, SettingsGUIA: +Background%BrushToolAcolor%, BrushToolAcolor
      GuiControl, SettingsGUIA: +Background%BrushToolBcolor%, BrushToolBcolor
      BrushToolType := 2
      alphaMaskingMode := 5
      alphaMaskBMPchannel := maybeColors ? 5 : 1
      GuiControl, SettingsGUIA: Choose, alphaMaskBMPchannel, % alphaMaskBMPchannel
      GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 5
      GuiControl, SettingsGUIA: Choose, alphaMaskRefBMP, 1
      GuiControl, SettingsGUIA: Choose, BrushToolType, 2
      GuiControl, SettingsGUIA: Enable, BrushToolType
      doImgEditLivePreview := 1
      GuiControl, SettingsGUIA:, doImgEditLivePreview, 1
      GuiControl, SettingsGUIA: Disable, doImgEditLivePreview
      If (AnyWindowOpen=24 || AnyWindowOpen=31)
         GuiControl, SettingsGUIA: Disable, btnReset

      GuiControl, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode, 1
      mustReset := (alphaMaskClrAintensity<4 && alphaMaskClrBintensity>252) || (alphaMaskClrAintensity<3) ? 1 : 0
      If (StrLen(userAlphaMaskBmpPainted)<3 || freshMode=1 || mustReset=1)
      {
         alphaMaskClrAintensity := 128
         alphaMaskClrBintensity := alphaMaskGradientAngle := alphaMaskReplaceMode := 0
         alphaMaskGradientScale := 1
         GuiControl, SettingsGUIA:, alphaMaskClrAintensity, 128
         GuiControl, SettingsGUIA:, alphaMaskClrBintensity, 0
         GuiControl, SettingsGUIA:, alphaMaskGradientScale, 1
         GuiControl, SettingsGUIA:, alphaMaskGradientAngle, 0
         GuiControl, SettingsGUIA:, alphaMaskReplaceMode, 0
      }

      If (StrLen(userAlphaMaskBmpPainted)<3 || freshMode=1)
      {
         If (PasteInPlaceOpacity<20)
         {
            PasteInPlaceOpacity := 20
            GuiControl, SettingsGUIA:, PasteInPlaceOpacity, 20
         }

         If !generated
         {
            alphaMaskColorReversed := 0
            GuiControl, SettingsGUIA:, alphaMaskColorReversed, 0
         }

         If StrLen(alphaMaskGray)>2
         {
            userAlphaMaskBmpPainted := alphaMaskGray
            keepUserPaintAlphaMask := 1
         } Else
         {
            keepUserPaintAlphaMask := 1
            Gdip_GetImageDimensions(userClipBMPpaste, rImgW, rImgH)
            If (AnyWindowOpen=70 || AnyWindowOpen=32 || AnyWindowOpen=23)
               userAlphaMaskBmpPainted := trGdip_CreateBitmap(A_ThisFunc, ImgSelW//2, imgSelH//2, "0xE200B")
            Else
               userAlphaMaskBmpPainted := trGdip_CreateBitmap(A_ThisFunc, rImgW, rimgH, "0xE200B")
            G := Gdip_GraphicsFromImage(userAlphaMaskBmpPainted)
            Gdip_GraphicsClear(G, "0xFFffFFff")
            Gdip_DeleteGraphics(G)
         }
      }
      lastPaintEventID := "a" A_TickCount userAlphaMaskBmpPainted randomu
      SetTimer, showLEDprimaryColor, -200
      If (ShowAdvToolbar=1)
         updateTlbrColorsSwatch()
   } Else If (isAlphaMaskWindow()=1)
   {
      showTOOLtip("Please wait, deactivating painting mode")
      RegAction(1, "brushAclrAlpha",, 3)
      RegAction(1, "brushBclrAlpha",, 3)
      brushAclrAlpha := convertColorToGrayscale(BrushToolAcolor)
      brushBclrAlpha := convertColorToGrayscale(BrushToolBcolor)
      lastPaintEventID := "a" A_TickCount userAlphaMaskBmpPainted randomu
      GuiControl, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode, 0
      GuiControl, SettingsGUIA: Enable, doImgEditLivePreview
      If (AnyWindowOpen=24 || AnyWindowOpen=31)
         GuiControl, SettingsGUIA: Enable, btnReset

      If (ShowAdvToolbar=1 && (AnyWindowOpen=23 || AnyWindowOpen=32))
         fromCurrentPanelToColorsSwatch()

      realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
   }

   createGUItoolbar()
   interfaceThread.ahkPostFunction("uiAlphaMaskTrigger", AnyWindowOpen, liveDrawingBrushTool, editingSelectionNow, UserMemBMP, showMainMenuBar)
   BrushToolTexture := 1
   dummyRefreshImgSelectionWindow()
   BtnTabsInfoUpdate("ignore-panel")
   SetTimer, MouseMoveResponder, -50
   SetTimer, corelivePreviewsImageEditing, -150
   SetTimer, RemoveTooltip, -200
}

toggleBrushTypes() {
   If (liveDrawingBrushTool=1)
      BrushToolType := (BrushToolType=1) ? 2 : 1

   endCaptureCloneBrush()
   liveDrawingBrushTool := 1
   friendly := (BrushToolType=1) ? "Simple color brush" : "Soft edges color brush"
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   If (BrushToolType=2)
      moreInfos .= "`nSoftness: " BrushToolSoftness "%"

   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType

   showTOOLtip(friendly ":" moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushDeformers() {
   If (isNowAlphaPainting()=1) || (A_TickCount - lastZeitOpenWin<650)
      Return

   endCaptureCloneBrush()
   If (liveDrawingBrushTool=1)
      BrushToolType := (BrushToolType=7) ? 8 : 7

   liveDrawingBrushTool := 1
   friendly := (BrushToolType=7) ? "Pinch brush" : "Bulge brush"
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (AnyWindowOpen=64)
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType

   showTOOLtip(friendly ":" moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushTypeEraser() {
   If (isNowAlphaPainting()=1)
      Return

   BrushToolType := 4
   liveDrawingBrushTool := 1
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "Eraser brush:`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   BrushToolEraserRestore := 0
   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA:, BrushToolEraserRestore, % BrushToolEraserRestore
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
   }

   showTOOLtip(moreinfos)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushTypeFX() {
   If (isNowAlphaPainting()=1)
      Return

   BrushToolType := 5
   liveDrawingBrushTool := 1
   endCaptureCloneBrush()
   BrushToolUseSecondaryColor := 0
   friendly := "Effects brush"
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (AnyWindowOpen=64)
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType

   showTOOLtip(friendly ":" moreinfos)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

togglePresetsBrushes(modus, dir:=1) {
   If (isNowAlphaPainting()=1)
      Return

   BrushToolType := 5
   liveDrawingBrushTool := 1
   endCaptureCloneBrush()
   BrushToolUseSecondaryColor := 0
   level := 0, maxu := 0
   If (modus=1)
   {
      BrushToolApplyColorFX := 0
      BrushToolBlurStrength := clampInRange(BrushToolBlurStrength + 5*dir, 3, 99, 1)
      friendly := "Effects brush`nBlur strength: " BrushToolBlurStrength "%"
      level := BrushToolBlurStrength
      maxu := 99
   } Else If (modus=2)
   {
      BrushToolApplyColorFX := 1
      BrushToolBlurStrength := 0
      friendly := "Effects brush: color adjustments"
   } Else If (modus=3)
   {
      BrushToolType := 2
      BrushToolWetness := clampInRange(BrushToolWetness + 1*dir, 2, 22, 1)
      friendly := "Soft edges brush`nWetness: " Round(BrushToolWetness/22 * 100) "%"
      level := BrushToolWetness
      maxu := 22
   } Else If (modus=4)
   {
      BrushToolWetness := 0
      BrushToolType := 2
      friendly := "Soft edges brush:"
   } Else If (modus=5)
   {
      BrushToolType := 1
      friendly := "Hard brush:"
   }

   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      GuiControl, SettingsGUIA:, BrushToolBlurStrength, % BrushToolBlurStrength
      GuiControl, SettingsGUIA:, BrushToolWetness, % BrushToolWetness
      GuiControl, SettingsGUIA:, BrushToolApplyColorFX, % BrushToolApplyColorFX
      SetTimer, updateUIbrushTool, -150
   }

   showTOOLtip(friendly moreinfos, 0, 0, level/maxu)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushDrawInOutModes() {
   If (isNowAlphaPainting()=1)
      Return

   endCaptureCloneBrush()
   FloodFillSelectionAdj := 0
   If (AnyWindowOpen!=66)
      liveDrawingBrushTool := 1

   BrushToolOutsideSelection := clampInRange(BrushToolOutsideSelection + 1, 1, 3, 1)
   friendly := (BrushToolOutsideSelection=1) ? "ANYWHERE" : "INSIDE"
   If (BrushToolOutsideSelection=3)
      friendly := "OUTSIDE"

   If (BrushToolOutsideSelection>1 && AnyWindowOpen=66)
      friendly .= " SELECTION"
   If (AnyWindowOpen=64 || AnyWindowOpen=66)
      GuiControl, SettingsGUIA: Choose, BrushToolOutsideSelection, % BrushToolOutsideSelection

   If (editingSelectionNow!=1)
      msgu := "WARNING: The image selection area is currently not created.`nPress E to create or display it.`n"

   If (ShowAdvToolbar=1)
      decideIconBTNpaintBrushSelect()

   labelu := (AnyWindowOpen=66) ? "Flood fill selection mode:`n" friendly : "Paint " Friendly " image selection area"
   showTOOLtip(msgu labelu, A_ThisFunc, 1, BrushToolOutsideSelection/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, dummyRefreshImgSelectionWindow, -100
}

toggleBrushTypeCloner() {
   If (isNowAlphaPainting()=1)
      Return

   If (BrushToolType=3 && liveDrawingBrushTool=1)
      BrushToolDynamicCloner := !BrushToolDynamicCloner

   BrushToolType := 3
   liveDrawingBrushTool := 1
   friendly := "Cloner brush"
   If (BrushToolDynamicCloner=1)
      friendly .= " (dynamic coords mode)"

   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (BrushToolApplyColorFX=1 || BrushToolBlurStrength>2)
      moreInfos .= "`nBrush effects are enabled"

   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA:, BrushToolDynamicCloner, % BrushToolDynamicCloner
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      GuiControl, SettingsGUIA: Show, uiBtnSetCloner
      GuiControl, SettingsGUIA: Enable, BrushToolDynamicCloner
   }

   showTOOLtip(friendly ":" moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyChangeBrushOpacity(dir) {
    If (dir=1)
       changeBrushOpacity(-1)
    Else
       changeBrushOpacity(1)
}

changeBrushOpacity(keyu, isKeyu:=0) {
    If (isKeyu=1)
    {
       thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       keyu := StrReplace(keyu, "+")
       factoru := (keyu>0.2) ? "0." keyu : 1
       If (keyu=1 && isInRange(thisOpacity, 22, 27))
          factoru := 0.05

       newOpacity := clampInRange(Round(255 * factoru), 1, 255)
       If (BrushToolUseSecondaryColor=1)
          BrushToolBopacity := newOpacity 
       Else
          BrushToolAopacity := newOpacity

       showTOOLtip("Brush opacity: " Round(factoru*100) "%", "dummyChangeBrushOpacity", 2, newOpacity/255)
    } Else
    {
       newOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       If (keyu=-1)
          newOpacity += 10
       Else
          newOpacity -= 10

       newOpacity := clampInRange(newOpacity, 1, 255)
       If (BrushToolUseSecondaryColor=1)
          BrushToolBopacity := newOpacity 
       Else
          BrushToolAopacity := newOpacity

       showTOOLtip("Brush opacity: " Round((newOpacity / 255) * 100) "%", "dummyChangeBrushOpacity", 2, newOpacity/255)
    }

    If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
    {
       thisOpacity := Round((BrushToolAopacity / 255) * 100)
       this2ndOpacity := Round((BrushToolBopacity / 255) * 100)
       showLEDprimaryColor()
       GuiControl, SettingsGUIA:, infoBrushAopacity, %thisOpacity%`%
       GuiControl, SettingsGUIA:, infoBrushBopacity, %this2ndOpacity%`%
       GuiControl, SettingsGUIA:, BrushToolAopacity, % BrushToolAopacity
       GuiControl, SettingsGUIA:, BrushToolBopacity, % BrushToolBopacity
    }

    liveDrawingBrushTool := 1
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, MouseMoveResponder, -25
}

preventColorChange() {
    If (AnyWindowOpen=64 && BrushToolType>2)
    {
       If (mustCaptureCloneBrush=1)
          Return

       If (BrushToolType=3)
          showTOOLtip("WARNING: You are currently using the cloner brush tool`nTo define the source pattern, press D.")
       Else
          showTOOLtip("WARNING: You are currently using a brush that does not rely on a given color")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return 1
    }
}

changeBrushColorPicker() {
    If preventColorChange() 
       Return

    endCaptureCloneBrush()
    thisColor := (BrushToolUseSecondaryColor=1) ? "PickuBrushToolBcolor" : "PickuBrushToolAcolor"
    oldClrName := (BrushToolUseSecondaryColor=1) ? "BrushToolBcolor" : "BrushToolAcolor"
    ; showTOOLtip("Pick brush color")
    ; SetTimer, RemoveTooltip, % -msgDisplayTime
    obju := StartPickingColor("isGiven", "SettingsGUIA", thisColor, "leave-it")
    If (ShowAdvToolbar=1)
    {
       newColor := obju[1] , oldColor := obju[2]
       updateToolColorsBasedToolbar(newColor, oldColor, oldClrName)
       updateTlbrColorsSwatch()
    }

    SetTimer, MouseMoveResponder, -25
    If (imgEditPanelOpened=1 && AnyWindowOpen)
       livePreviewsImageEditing()
}

changeBrushSize(dir) {
   liveDrawingBrushTool := 1
   factoru := (brushToolSize>50) ? 10 : 5
   If (dir=1)
      brushToolSize += factoru
   Else
      brushToolSize -= factoru

   endCaptureCloneBrush()
   BrushToolSize := clampInRange(brushToolSize, 1, 950)
   friendly := (brushToolDoubleSize=1) ? "RADIUS" : "DIAMETER"
   showTOOLtip("Brush " friendly " size: " groupDigits(brushToolSize) " px", A_ThisFunc, 2, brushToolSize/950)
   If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
   {
      theSize := (brushToolDoubleSize!=1) ? "Diameter" : "Radius"
      GuiControl, SettingsGUIA:, BrushToolSize, % BrushToolSize
      GuiControl, SettingsGUIA:, brushToolDoubleSize, %theSize%: %BrushToolSize% px
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

changeBrushShapeRatio(dir) {
   changeBrushRatioAngle(dir, 1)
}

changeBrushAnglu(dir) {
   changeBrushRatioAngle(dir, 2)
}

changeBrushRatioAngle(dir, what) {
   liveDrawingBrushTool := 1
   endCaptureCloneBrush()
   If (what=1)
   {
      factoru := 5
      BrushToolAspectRatio := clampInRange(BrushToolAspectRatio + factoru*dir, -100, 100, 0)
      If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
      {
         GuiControl, SettingsGUIA:, BrushToolAspectRatio, % BrushToolAspectRatio
         GuiControl, SettingsGUIA:, infoBrushAspectRatio, Aspect ratio: %BrushToolAspectRatio%
      }

      showTOOLtip("Brush aspect ratio: " BrushToolAspectRatio, 0, 0, (BrushToolAspectRatio + 100)/201)
   } Else
   {
      factoru := 10
      BrushToolAutoAngle := 0
      BrushToolAngle := clampInRange(BrushToolAngle + factoru*dir, 0, 359, 0)
      If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
      {
         GuiControl, SettingsGUIA:, BrushToolAngle, % BrushToolAngle
         GuiControl, SettingsGUIA:, infoBrushAngle, Angle: %BrushToolAngle%° 
      }
      showTOOLtip("Brush angle: " BrushToolAngle "° ", 0, 0, BrushToolAngle/360)
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

resetBrushAsRatio() {
   liveDrawingBrushTool := 1
   endCaptureCloneBrush()
   BrushToolAspectRatio := BrushToolAngle := 0
   If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
   {
      GuiControl, SettingsGUIA:, BrushToolAspectRatio, % BrushToolAspectRatio
      GuiControl, SettingsGUIA:, BrushToolAngle, % BrushToolAngle
      GuiControl, SettingsGUIA:, infoBrushAspectRatio, Aspect ratio: %BrushToolAspectRatio%
      GuiControl, SettingsGUIA:, infoBrushAngle, Angle: %BrushToolAngle%° 
   }

   showTOOLtip("Brush aspect ratio: RESET")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

toggleBrushMouseAngle() {
   endCaptureCloneBrush()
   liveDrawingBrushTool := 1
   BrushToolAutoAngle  := !BrushToolAutoAngle
   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
   {
      GuiControl, SettingsGUIA:, BrushToolAutoAngle, % BrushToolAutoAngle
      friendly := (BrushToolAutoAngle=1) ? "Disable" : "Enable"
      GuiControl, SettingsGUIA: %friendly%, BrushToolAngle
   }

   friendly := (BrushToolAutoAngle=1) ? "Alter brush angle based on mouse movements" : "Fixed brush angle: " BrushToolAngle "° "
   showTOOLtip(friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

changeBrushSoftness(dir) {
   If (BrushToolType=1)
      Return

   If (dir=1)
      BrushToolSoftness += 2
   Else
      BrushToolSoftness -= 2

   endCaptureCloneBrush()
   liveDrawingBrushTool := 1
   BrushToolSoftness := clampInRange(BrushToolSoftness, 1, 99)
   showTOOLtip("Brush softness: " BrushToolSoftness "%", A_ThisFunc, 2, BrushToolSoftness/100)
   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControl, SettingsGUIA:, BrushToolSoftness, % BrushToolSoftness
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

changeBrushWetness(dir) {
   isOkay := (BrushToolType=2 || BrushToolType=7 || BrushToolType=8) ? 1 :0
   If (isOkay!=1)
      Return

   If (dir=1)
      BrushToolWetness++
   Else
      BrushToolWetness--

   liveDrawingBrushTool := 1
   BrushToolWetness := clampInRange(BrushToolWetness, 0, 22)
   friendly := (BrushToolType>6) ? "deform intensity" : "wetness"
   showTOOLtip("Brush " friendly ": " BrushToolWetness, A_ThisFunc, 2, BrushToolWetness/22)
   If (AnyWindowOpen=64)
      GuiControl, SettingsGUIA:, BrushToolWetness, % BrushToolWetness
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

createGradientBrushBitmap(brushColor, grPosA, brushSize, grAngle, bAR, opacity:=0, bgr:=0) {
    Critical, on
    Static offsetX := 0, offsetY := 0, grPosB := 99, prevState, prevBrushu
    If (brushColor="kill")
    {
       prevState := ""
       prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
       Return
    }

    isAlphaPainting := isNowAlphaPainting()
    offsetX := (isAlphaPainting=1) ? 0 : alphaMaskOffsetX
    offsetY := (isAlphaPainting=1) ? 0 : alphaMaskOffsetY
    thisColorA := opacity ? opacity brushColor : "0xFF" brushColor
    thisColorB := "0x00" brushColor
    rImgW := rImgH :=  brushSize
    ; ToolTip, % thisColorA "`n" thisColorB, , , 2
    thisAR := 1 - Abs(bAR)/105
    brImgSelW := (bAR>0) ? brushSize * thisAR : brushSize
    brImgSelH := (bAR<0) ? brushSize * thisAR : brushSize
    brimgSelPx := 0 - (brImgSelW - rImgW)//2
    brimgSelPy := 0 - (brImgSelH - rImgH)//2
    thisState := "a" bgr brImgSelW brImgSelH brimgSelPx brimgSelPy thisAR bAR brushSize thisColorA thisColorB grPosA grAngle offsetX offsetY BrushToolTexture
    If (thisState!=prevState || StrLen(prevBrushu)<3)
    {
       brushBitmap := trGdip_CreateBitmap(A_ThisFunc, brushSize, brushSize, "0xE200B")
       If !brushBitmap
          Return

       prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
       Ga := trGdip_GraphicsFromImage(A_ThisFunc, brushBitmap, 3)
       Gdip_SetPixelOffsetMode(Ga, 2)
       If (BrushToolTexture=1)
       {
          grpPath := Gdip_CreatePath()
          If grpPath
          {
             Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
             gradBrush := Gdip_PathGradientCreateFromPath(grpPath)
             If gradBrush
             {
                Gdip_PathGradientSetCenterPoint(gradBrush, 0 + rImgW//2 + Round(rImgW*offsetX), 0 + rImgH//2 + Round(rImgH*offsetY))
                Gdip_SetLinearGrBrushPresetBlend(gradBrush, [grPosA/100, grPosB/100], [thisColorA, thisColorB])
                Gdip_RotatePathGradientAtCenter(gradBrush, grAngle, 1)
                ; Gdip_PathGradientSetWrapMode(gradBrush, gradientWrapMode)
             }

             Gdip_DeletePath(grpPath)
          }

          If bgr
             Gdip_GraphicsClear(Ga, bgr)
          Gdip_FillEllipse(Ga, gradBrush, 0, 0, rImgW, rImgH)
          Gdip_DeleteBrush(gradBrush)
       } Else
       {
          pBitmap := LoadCachableBitmapFromFile(mainCompiledPath "\resources\brush-texture-" BrushToolTexture - 1 ".png")
          If pBitmap
          {
             If (grAngle>0)
             {
                pBitmap3 := trGdip_RotateBitmapAtCenter(A_ThisFunc, pBitmap, grAngle, 0, 3)
                If StrLen(pBitmap3)>2
                {
                   trGdip_DisposeImage(pBitmap, 1)
                   pBitmap := pBitmap3
                }
             }

             If !bgr
             {
                Gdip_GraphicsClear(Ga, thisColorA)
                pBitmap2 := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, rImgW, rImgH, 0, 3)
                trGdip_DisposeImage(pBitmap, 1)
                ; QPV_BlendBitmaps(brushBitmap, pBitmap2, 2, 0)
                QPV_SetAlphaChannel(brushBitmap, pBitmap2, 0, 1, 1, 0)
                trGdip_DisposeImage(pBitmap2, 1)
             } Else
             {
                Gdip_DrawImage(Ga, pBitmap, 0, 0, rImgW, rImgH)
                trGdip_DisposeImage(pBitmap, 1)
             }
          }
          ; Gdip_DrawImage(Ga, pBitmap, 0, 0, rImgW, rImgH)
       }
       If Ga
          Gdip_DeleteGraphics(Ga)
       prevState := thisState
       prevBrushu := trGdip_CloneBitmap(A_ThisFunc, brushBitmap)
    } Else If StrLen(prevBrushu)>2
       brushBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBrushu)

    Return brushBitmap
}

createClonedBrushBitmap(brushSize, brushSofty, brushAngle, thisAR, whichBitmap, offsetX:=0, offsetY:=0, doBlur:=0, noAlphaMask:=0, previewMode:=0) {
   Static noPrompting :=0, brushAlpha, prevState, prevBrushu, hasEverDefineSource := 0
   endCaptureCloneBrush()
   If (brushSize="kill")
   {
      prevState := ""
      prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
      Return
   }

   If (!isNumber(tinyPrevAreaCoordX) || !isNumber(tinyPrevAreaCoordY))
   {
      prevState := ""
      hasEverDefineSource := 1
      If (brushAngle="mouse")
      {
         mX := brushSize
         mY := brushSofty
      } Else GetMouseCoord2wind(PVhwnd, mX, mY)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
      tinyPrevAreaCoordX := kX, tinyPrevAreaCoordY := kY
      showTOOLtip("Cloner brush source set to`n" kX " / " kY)
      SoundBeep , 900, 100
      If (BrushToolApplyColorFX=1 || BrushToolBlurStrength>1) && (noPrompting=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Cloner effects", "The cloner tool has color effects activated. Do you want to deactivate the brush cloner effects?", 4, 0, "question", "&Do not prompt me again in this session")
         noPrompting := msgResult.check
         If (msgResult.btn="Yes")
         {
            BrushToolApplyColorFX := 0
            BrushToolBlurStrength := 0
            If (AnyWindowOpen=64)
            {
               GuiControl, SettingsGUIA:, BrushToolApplyColorFX, 0
               GuiControl, SettingsGUIA:, BrushToolBlurStrength, 0
            }
         }
      }

      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      SetTimer, dummyRefreshImgSelectionWindow, -150
      Return
   }

   If (!hasEverDefineSource && previewMode=0)
   {
      msgBoxWrapper(appTitle ": WARNING", "Please define the source for the clone tool.", 0, 0, "exclamation")
      BtnSetClonerBrushSource()
      Return
   }

   tkX := tinyPrevAreaCoordX
   tkY := tinyPrevAreaCoordY
   If (BrushToolDynamicCloner=1)
   {
      tkX := tkX - offsetX
      tkY := tkY - offsetY
   }

   thisState := "a" brushSofty brushSize brushAngle BrushToolDynamicCloner thisAR offsetX offsetY tkX tkY BrushToolBlurStrength doBlur BrushToolApplyColorFX PasteInPlaceLight PasteInPlaceGamma PasteInPlaceHue PasteInPlaceSaturation noAlphaMask BrushToolTexture
   If (thisState!=prevState || !prevBrushu)
   {
      prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
      brushu := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, 1)
      If (noAlphaMask=0)
      {
         applyPersonalizedColorsBMP(brushu, 1, BrushToolBlurStrength, BrushToolApplyColorFX)
         brushuAlpha := createGradientBrushBitmap("ffFFff", brushSofty, brushSize, brushAngle, thisAR, 0, "0xFF000000")
         QPV_SetAlphaChannel(brushu, brushuAlpha)
         trGdip_DisposeImage(brushuAlpha, 1)
      }
      prevState := thisState
      prevBrushu := trGdip_CloneBitmap(A_ThisFunc, brushu)
   } Else brushu := trGdip_CloneBitmap(A_ThisFunc, prevBrushu)
   Return brushu
}

somewhatAccurateBrightnessShift(hex, lum=0.5, mode=1) {
   ; from tidbit ; thanks 
   for k, val in [substr(hex, 3, 2), substr(hex, 5, 2), substr(hex, 7, 2)] ; split the hex into an array of [##,##,##]
      val:=format("{1:d}", "0x" val) ; convert from hex, to decimal values
      , val:=round((mode=1) ? val*lum : val+lum) ; do the math
      , val:=(val<0) ? 0 : (val>255) ? 255 : val ; clamp the values between 0 and 255
      , out.=format("{1:02}", format("{1:x}", val)) ; build it again, make sure each hex thing is 2 chars long
   return out ; we're done!
}

RandomizeBrushColor(startToolColor) {
   o_startToolColor := startToolColor
   If (BrushToolRandomLight>0 && BrushToolRandomDark<1)
      zR := 1
   Else If (BrushToolRandomLight<1 && BrushToolRandomDark>0)
      zR := 6
   Else
      zR := Randomizer(1, 10, 1, 14)

   If (BrushToolRandomLight>0 && isInRange(zR, 1, 5))
   {
      gR := BrushToolRandomLight
      gR := Randomizer(0, gR, 8, 8)
      gRz := (100 - gR)/101
      startToolColor := SubStr(MixARGB("0xFFfffFff", "0xFF" startToolColor, gRz), 5)
      ; ToolTip, % gR "===" gRz "`n" startToolColor "`n" o_startToolColor , , , 2
   }

   If (BrushToolRandomDark>0 && isInRange(zR, 5, 10))
   {
      gR := BrushToolRandomDark
      gR := Randomizer(0, gR, 8, 9)
      gRz := (100 - gR)/101
      startToolColor := SubStr(MixARGB("0xFF000000", "0xFF" startToolColor, gRz), 5)
   }

   If (BrushToolRandomHue<1 && BrushToolRandomSat<1)
      Return startToolColor

   ; Gdip_FromARGB("0xFF" startToolColor, A, R, G, B)
   ; HSLobj := ConvertRGBtoHSL(R, G, B)
   H := HSL_Hue("0x" startToolColor)
   S := HSL_Sat("0x" startToolColor)
   L := HSL_Lum("0x" startToolColor)
   If (BrushToolRandomHue>0)
   {
      gR := BrushToolRandomHue
      gR := Randomizer(-gR, gR, 2, 10)
      H := clampInRange(H + gR, 0, 360)
   }

   If (BrushToolRandomSat>0)
   {
      gR := BrushToolRandomSat
      gR := Randomizer(-gR, gR, 2, 11)
      S := clampInRange(S*100 + gR, 0, 100)/100
   }

   startToolColor := HSL_ToRGB(H, S, L)
   startToolColor := SubStr(startToolColor, 3)
   ; ToolTip, % H "=" S "=" L "`n" R "=" G "=" B , , , 2
   Return startToolColor
}


HSL_ToRGB(hue, sat:=1, lum:=0.5 ) {
; Function by [VxE]. See > http://www.wikipedia.org/wiki/HSV_color_space
; HSL to/from RGB conversion functions by [VxE]. Freely avalable @ http://www.autohotkey.com/community/viewtopic.php?f=2&t=88707
; Converts a hue/sat/lum into a 24-bit RGB color code. Input: 0 <= hue <= 360, 0 <= sat <= 1, 0 <= lum <= 1. 

   Static i24 := 0xFFFFFF, i40 := 0xFFFFFF0000, hx := "0123456789ABCDEF"

; Transform the decimal inputs into 24-bit integers. Integer arithmetic is nice..
   sat := ( sat * i24 ) & i24
   lum := ( lum * i24 ) & i24
   hue := ( hue * 0xB60B60 >> 8 ) & i24 ; conveniently, 360 * 0xB60B60 = 0xFFFFFF00

; Determine the chroma value and put it in the 'sat' var since the saturation value is not used after this.
   sat := lum + Round( sat * ( i24 - Abs( i24 - lum - lum ) ) / 0x1FFFFFE )

; Calculate the base values for red and blue (green's base value is the hue)
   red := hue < 0xAAAAAA ? hue + 0x555555 : hue - 0xAAAAAA
   blu := hue < 0x555555 ? hue + 0xAAAAAA : hue - 0x555555

; Run the blue value through the cases
   If ( blu < 0x2AAAAB )
      blu := sat + 2 * ( i24 - 6 * blu ) * ( lum - sat ) / i24 >> 16
   Else If ( blu < 0x800000 )
      blu := sat >> 16
   Else If ( blu < 0xAAAAAA )
      blu := sat + 2 * ( i24 - 6 * ( 0xAAAAAA - blu ) ) * ( lum - sat ) / i24 >> 16
   Else
      blu := 2 * lum - sat >> 16

; Run the red value through the cases
   If ( red < 0x2AAAAB )
      red := sat + 2 * ( i24 - 6 * red ) * ( lum - sat ) / i24 >> 16
   Else If ( red < 0x800000 )
      red := sat >> 16
   Else If ( red < 0xAAAAAA )
      red := sat + 2 * ( i24 - 6 * ( 0xAAAAAA - red ) ) * ( lum - sat ) / i24 >> 16
   Else
      red := 2 * lum - sat >> 16

; Run the green value through the cases
   If ( hue < 0x2AAAAB )
      hue := sat + 2 * ( i24 - 6 * hue ) * ( lum - sat ) / i24 >> 16
   Else If ( hue < 0x800000 )
      hue := sat >> 16
   Else If ( hue < 0xAAAAAA )
      hue := sat + 2 * ( i24 - 6 * ( 0xAAAAAA - hue ) ) * ( lum - sat ) / i24 >> 16
    Else
      hue := 2 * lum - sat >> 16

; Return the values in RGB as a hex integer
   Return "0x" SubStr( hx, ( red >> 4 ) + 1, 1 ) SubStr( hx, ( red & 15 ) + 1, 1 )
         . SubStr( hx, ( hue >> 4 ) + 1, 1 ) SubStr( hx, ( hue & 15 ) + 1, 1 )
         . SubStr( hx, ( blu >> 4 ) + 1, 1 ) SubStr( hx, ( blu & 15 ) + 1, 1 )
} ; END - HSL_ToRGB( hue, sat, lum )

HSL_Hue( RGB ) {
; Function by [VxE]. Returns the HSL hue of the input 24-bit RGB code.
; Returns a floating point value less than 360 but not less than 0.

   blu := 255 & ( RGB )
   grn := 255 & ( RGB >> 8 )
   red := 255 & ( RGB >> 16 )

   If ( blu = grn ) && ( blu = red )
   {
      Return 0 + 0.0
   } Else If ( blu < grn )
   {
      If ( red < blu )
         Return 60 * ( blu - red ) / ( grn - red ) + 120
      Else If ( grn < red )
         Return 60 * ( grn - blu ) / ( red - blu )
      Else
         Return 60 * ( blu - red ) / ( grn - blu ) + 120
   } Else
   {
      If ( red < grn )
         Return 60 * ( red - grn ) / ( blu - red ) + 240
      Else If ( blu < red )
         Return 60 * ( grn - blu ) / ( red - grn ) + ( blu = grn ? 0 : 360 )
      Else
         Return 60 * ( red - grn ) / ( blu - grn ) + 240
   }
} ; END - HSL_Hue( RGB )

HSL_Sat( RGB ) {
; Function by [VxE]. Returns the HSL saturation of the input 24-bit RGB code.
; Returns a floating point value between 0 and 1, inclusive.

   blu := 255 & ( RGB )
   grn := 255 & ( RGB >> 8 )
   red := 255 & ( RGB >> 16 )

   If ( blu = grn ) && ( blu = red )
   {
      Return 0 + 0.0
   } Else If ( blu < grn )
   {
      If ( red < blu )
         return ( grn - red ) / ( 255 - Abs( 255 - grn - red ) )
      Else If ( grn < red )
         return ( red - blu ) / ( 255 - Abs( 255 - red - blu ) )
      Else
         return ( grn - blu ) / ( 255 - Abs( 255 - grn - blu ) )
   } Else
   {
      If ( red < grn )
         return ( blu - red ) / ( 255 - Abs( 255 - blu - red ) )
      Else If ( blu < red )
         return ( red - grn ) / ( 255 - Abs( 255 - red - grn ) )
      Else
         return ( blu - grn ) / ( 255 - Abs( 255 - blu - grn ) )
   }
} ; END - HSL_Sat( RGB )

HSL_Lum( RGB ) {
; Function by [VxE]. Returns the HSL lightness of the input 24 bit color.
; Returns a floating point value between 0 and 1, inclusive.

   blu := 255 & ( RGB )
   grn := 255 & ( RGB >> 8 )
   red := 255 & ( RGB >> 16 )

   If ( blu < grn )
   {
      If ( red < blu )
         Return ( red + grn ) / 510
      Else If ( grn < red )
         Return ( blu + red ) / 510
      Else
         Return ( blu + grn ) / 510
   } Else
   {
      If ( red < grn )
         Return ( red + blu ) / 510
      Else If ( blu < red )
         Return ( grn + red ) / 510
      Else
         Return ( grn + blu ) / 510
   }
} ; END - HSL_Lum( RGB )


Randomizer(minu, maxu, errMargin, idu) {
   Static prevIDs := []
   Random, OutputVar, % minu, % maxu
   ; If isInRange(OutputVar, prevIDs[idu] + errMargin, prevIDs[idu] - errMargin)
   ; {
   ;    Random, OutputVar, % minu, % maxu
   ;    If (prevIDs[idu]=OutputVar)
   ;       Random, OutputVar, % minu, % maxu
   ; }

   prevIDs[idu] := OutputVar
   Return OutputVar
}

decideAlphaMaskingFeaseable(userBias, doLimits:=0) {
   allowAlphaMasking := userBias
   If (userBias=1)
      infoMask := defineCurrentAlphaMask()
   If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
      allowAlphaMasking := 0

   If (allowAlphaMasking=1 && doLimits=1)
      innerSelectionCavityX := innerSelectionCavityX := VPselRotation := EllipseSelectMode := 0
   Return allowAlphaMasking
}

ActFloodFillNow() {
   Critical, on
   Static lastInvoked := 1, prevMX, prevMY, countClicks, HasTested

   If (A_TickCount - lastOtherWinClose<450) || (A_TickCount - lastInvoked<250)
      Return

   If (usrColorDepth>1 || imgFxMode>1 || vpIMGrotation>0)
   {
      mergeViewPortEffectsImgEditing(A_ThisFunc)
      dummyTimerDelayiedImageDisplay(25)
      ; SoundBeep , 900, 100
      Return
   }

   whichBitmap := useGdiBitmap("yes")
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   If (!imgW || !imgH || !whichBitmap)
   {
      addJournalEntry(A_ThisFunc "(): Main bitmap malformed or missing.")
      Return
   }

   If (toolTipGuiCreated=2)
   {
      RemoveTooltip()
      Return
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := (FlipImgH=1) ? mainWidth - mX : mX
   mY := (FlipImgV=1) ? mainHeight - mY : mY
   MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
   If (kX>=imgW || kY>=imgH || kX<1 || kY<1)
      Return

   hasCloned := 0
   allowAlphaMasking := decideAlphaMaskingFeaseable(FloodFillUseAlpha)
   allowSelectionCrop := (BrushToolOutsideSelection>1 && editingSelectionNow=1 && allowAlphaMasking=0) ? 1 : 0
   If (allowSelectionCrop=1 || allowAlphaMasking=1)
   {
      hasCloned := 1
      thisBMP := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
      If StrLen(thisBMP)>2
         G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)

      calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      If (editingSelectionNow=1 && BrushToolOutsideSelection>1)
         pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)

      If ((StrLen(thisBMP)<3) || (G2="") || (pPath="" && editingSelectionNow=1 && BrushToolOutsideSelection>1))
      {
         showTOOLtip("Failed to apply flood fill in the image selected area")
         SoundBeep , 300, 100
         If (G2!="")
            Gdip_DeleteGraphics(G2)
         If (pPath!="")
            Gdip_DeletePath(pPath)
         trGdip_DisposeImage(thisBMP, 1)
         SetTimer, ResetImgLoadStatus, -250
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   } Else thisBMP := whichBitmap

   If (undoLevelsRecorded<2)
      recordUndoLevelNow("init", 0)

   If (FloodFillAltToler=3)
      showTOOLtip("Applying flood fill at the coordinates:`n" groupDigits(kX) ", " groupDigits(kY))

   ; newColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor 
   r := QPV_FloodFill(thisBMP, kX, kY, "0x" Format("{:X}", FloodFillClrOpacity) FloodFillColor, FloodFillOpacity)

   If (pPath!="" && G2!="" && allowSelectionCrop=1 && hasCloned=1) || (thisBMP!="" && allowAlphaMasking=1)
   {
      If (allowAlphaMasking=1)
      {
         If (editingSelectionNow=1 && BrushToolOutsideSelection=2)
            gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

         fBitmap := StrLen(gBitmap)>2 ? gBitmap : thisBMP
         thisIDu := "a" imgSelPx imgSelPy imgSelW imgSelH
         realtimePasteInPlaceAlphaMasker(0, fBitmap, thisIDu, newBitmap, 0, 0, 0, 0)
         If StrLen(newBitmap)>2
         {
            If StrLen(gBitmap)>2
            {
               G3 := trGdip_GraphicsFromImage(A_ThisFunc, thisBMP)
               Gdip_SetClipRect(G3, imgSelPx, imgSelPy, imgSelW, imgSelH)
               r0 := trGdip_GraphicsClear(A_ThisFunc, G3)
               r1 := trGdip_DrawImage(A_ThisFunc, G3, newBitmap, imgSelPx, imgSelPy)
               Gdip_DeleteGraphics(G3)
               trGdip_DisposeImage(newBitmap, 1)
            } Else
            {
               trGdip_DisposeImage(thisBMP, 1)
               thisBMP := newBitmap
            }
         }
         trGdip_DisposeImage(gBitmap, 1)
         ; realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
      }

      thisMode := (BrushToolOutsideSelection=3) ? 4 : 0
      If (pPath!="" && (allowSelectionCrop=1 || allowAlphaMasking=1))
      {
         Gdip_SetClipPath(G2, pPath, thisMode)
         If (userimgGammaCorrect=1 && allowAlphaMasking=1)
            Gdip_SetCompositingQuality(G2, 2)
         If (allowAlphaMasking!=1)
            r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
      }
      r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, 0, 0)
      trGdip_DisposeImage(thisBMP, 1)
      Gdip_DeleteGraphics(G2)
   }

   If (pPath!="")
      Gdip_DeletePath(pPath)
   If (FloodFillClrOpacity<254 && r>1)
      currIMGdetails.HasAlpha := 1

   lastInvoked := A_TickCount
   If (r>1)
   {
      If !UserMemBMP
         UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap())
      recordUndoLevelNow(0, useGdiBitmap())
   }

   SetTimer, MouseMoveResponder, -25
   SetTimer, wrapResizeImageGDIwin, -30
   SetTimer, RemoveTooltip, -10
}

ActPaintBrushNow() {
   Critical, on
   Static lastInvoked := 1, prevMX, prevMY, countClicks, HasTested

   If (usrColorDepth>1 || vpIMGrotation>0)
   {
      mergeViewPortEffectsImgEditing(A_ThisFunc)
      dummyTimerDelayiedImageDisplay(25)
      ; SoundBeep , 900, 100
      Return
   }

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (!imgW || !imgH)
   {
      addJournalEntry("ERROR: main bitmap seems inexistent. Failure occured in " A_ThisFunc "()")
      Return
   }

   If (A_TickCount - lastOtherWinClose<450)
      Return

   canApplyFXa := (PasteInPlaceHue!=0 || PasteInPlaceSaturation!=0) && (BrushToolApplyColorFX=1) ? 1 : 0
   canApplyFXb := (PasteInPlaceLight!=0 || PasteInPlaceGamma!=0) && (BrushToolApplyColorFX=1) ? 1 : 0
   If (BrushToolBlurStrength<3 && canApplyFXa=0 && canApplyFXb=0 && BrushToolType=5)
      Return

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := (FlipImgH=1) ? mainWidth - mX : mX
   mY := (FlipImgV=1) ? mainHeight - mY : mY
   imgPath := getIDimage(currentFileIndex)
   thisZeit := A_TickCount - 100
   thisIndex := 0
   Random, randomFactor, -950, 950
   randomFactor := Randomizer(-950, 950, 2, 1)
   prevState := "a"
   liveDrawingBrushTool := 1
   whichBitmap := useGdiBitmap("yes")
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   thisUseSecondaryColor := BrushToolUseSecondaryColor
   If GetKeyState("Ctrl", "P")
      thisUseSecondaryColor := !BrushToolUseSecondaryColor

   o_startToolColor := startToolColor := (thisUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   o_startToolColor := startToolColor := RandomizeBrushColor(startToolColor)
   thisMainOpacity := (thisUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisHexOpacity := Format("{1:#x}", thisMainOpacity)
   MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
   If (BrushToolWetness=21)
   {
      coloruA := Gdip_GetPixelColor(whichBitmap, kX, kY, 1)
      startToolColor := SubStr(MixARGB(coloruA, "0xFF" startToolColor, 0.5), 5)
      thisWetness := 20
   } Else If (BrushToolWetness=22)
   {
      coloruA := Gdip_GetPixelColor(whichBitmap, kX, kY, 1)
      startToolColor := SubStr(MixARGB(coloruA, "0xFF" startToolColor, 0.2), 5)
      thisWetness := 20
   } Else thisWetness := BrushToolWetness

   oMx := kX, oMy := kY
   thisSelectionConstrain := (editingSelectionNow=1) ? BrushToolOutsideSelection - 1 : 0
   o_brushSize := brushSize := (brushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
   If (BrushToolType>=6 && brushSize<5)
      brushSize := 5

   If (BrushToolRandomSize>0)
   {
      gR := Ceil(brushSize * (BrushToolRandomSize/100)) + 1
      gR := Randomizer(-gR, gR, 2, 2)
      brushSize := clampInRange(brushSize + gR, brushSize//3 + 2, brushSize + Abs(gR))
   }

   thisBulgePinchFactor := (BrushToolType=6) ? BrushToolWetness*2 + 1 :  BrushToolWetness + 1
   If (BrushToolType=7)
      thisBulgePinchFactor := -BrushToolWetness - 1

   thisToolSoftness := BrushToolSoftness
   If (BrushToolRandomSoftness>0)
   {
      gR := BrushToolRandomSoftness
      gR := Randomizer(-gR, gR, 2, 3)
      thisToolSoftness := clampInRange(BrushToolSoftness + gR, 1, 100)
   }

   thisToolAngle := BrushToolAngle
   If (BrushToolRandomAngle>0)
   {
      gR := BrushToolRandomAngle
      gR := Randomizer(-gR, gR, 2, 4)
      thisToolAngle := clampInRange(BrushToolAngle + gR, 0, 180)
   }

   thisToolAspectRatio := BrushToolAspectRatio
   If (BrushToolRandomAspectRatio>0)
   {
      gR := BrushToolRandomAspectRatio
      gR := Randomizer(-gR, gR, 2, 5)
      thisToolAspectRatio := clampInRange(BrushToolAspectRatio + gR, -100, 100)
   }

   ; create base brush element / bitmap
   If (BrushToolType=3) ; cloner
      brushu := createClonedBrushBitmap(brushSize, 101 - thisToolSoftness, thisToolAngle, thisToolAspectRatio, whichBitmap, 0, 0, 1)
   Else If (BrushToolType=4 || BrushToolType=5 || BrushToolType=7 || BrushToolType=8) ; eraser, effects, pinch and bulge brushes
      brushu := createGradientBrushBitmap("ffFFff", 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio, 0, "0xff000000")
   Else If (BrushToolType=6) ; smudge/pinch/bulge
      brushu := createGradientBrushBitmap("ffFFff", 101 - thisToolSoftness, brushSize + thisBulgePinchFactor, thisToolAngle, thisToolAspectRatio, 0, "0xff000000")
   Else If (BrushToolType>1) ; soft edges
      brushu := createGradientBrushBitmap(startToolColor, 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio)
   Else ; simple solid
      gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)

   If (!brushu && BrushToolType>1)
   {
      addJournalEntry("ERROR: no brush image. Failure occured in " A_ThisFunc "()")
      Return
   }

   If (BrushToolType=4 && !thisSelectionConstrain) || (BrushToolType=5 && BrushToolOverDraw=0) || (BrushToolType=3 && BrushToolDynamicCloner=1)
      clonescu := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)

   imgIndexEditing := currentFileIndex
   thisQuality := (BrushToolType>5) ? 7 : 5
   compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
   Gu := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, thisQuality,,, compositingQuality)
   If !Gu
   {
      trGdip_DisposeImage(brushu, 1)
      trGdip_DisposeImage(brushImg, 1)
      trGdip_DisposeImage(clonescu, 1)
      If gdipbrushu
         Gdip_DeleteBrush(gdipbrushu)
      addJournalEntry("ERROR: failed to create graphics object on " whichBitmap ". Failure occured in " A_ThisFunc "()")
      Return
   }

   Gdip_SetPixelOffsetMode(Gu, 2)
   If thisSelectionConstrain
   {
      calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
      modus := (thisSelectionConstrain=1) ? 0 : 4
      Gdip_SetClipPath(Gu, ImgSelPath, modus)
   } 

   thisOpacity := (thisUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisEraseOpacity := thisOpacity
   thisEraserMode := (BrushToolOverDraw=1) ? 2 : 1
   If (BrushToolEraserRestore=1)
      thisEraserMode := 3

   thisEraseOpacity := (thisEraserMode=1) ? 255 - thisEraseOpacity : thisEraseOpacity
   thisWet := 0.79 + (21 - thisWetness)/100
   If ((A_TickCount - lastInvoked>350) && undoLevelsRecorded<2)
      recordUndoLevelNow("init", 0)

   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   dryZeit := A_TickCount
   dryRateZeit := 300 - BrushToolDryingRate**2
   thisDryRate := clampInRange(BrushToolDryingRate/4, 1, 20)
   isUserStepu := (brushToolStepping=1 || brushToolStepping=2 || brushToolStepping=251) ? 0 : 1
   stepu := (isUserStepu=0) ? Ceil(brushSize * 0.2)**1.09 : brushToolStepping
   If (BrushToolType>6 || BrushToolType=5) && (isUserStepu=1 && stepu<brushSize/4 && isInRange(BrushToolAspectRatio, -5, 5) && isInRange(thisToolAngle, 0, 5))
      stepu := brushSize//4 + 1

   If (!stepu || BrushToolType>=7 || brushToolStepping=0)
      stepu := 1

   If !GetKeyState("Shift", "P")
      prevMX := prevMY := 0

   offX := offY := 0
   setwhileLoopExec(1)
   While, (determineLClickstate()=1 || A_Index<2)
   {
      If (thisOpacity<0.005 || brushSize<2)
         Break
      
      GetMouseCoord2wind(PVhwnd, mX, mY)
      If (BrushToolRandomPosX>0)
      {
         gR := Ceil(brushSize*(BrushToolRandomPosX/100))
         gR := Randomizer(-gR, gR, 3, 6)
         mX += gR
      }

      If (BrushToolRandomPosY>0)
      {
         gR := Ceil(brushSize*(BrushToolRandomPosY/100))
         gR := Randomizer(-gR, gR, 3, 7)
         mY += gR
      }

      If (BrushToolType<3 && BrushToolWetness>0) || (BrushToolType=3 && BrushToolDynamicCloner=1)
      {
         If (BrushToolRandomSize>0)
         {
            gR := Ceil(o_brushSize * (BrushToolRandomSize/100)) + 1
            gR := Randomizer(-gR, gR, 2, 2)
            brushSize := clampInRange(o_brushSize + gR, o_brushSize//3 + 2, o_brushSize + Abs(gR))
         }

         If (BrushToolRandomSoftness>0)
         {
            gR := BrushToolRandomSoftness
            gR := Randomizer(-gR, gR, 2, 3)
            thisToolSoftness := clampInRange(BrushToolSoftness + gR, 1, 100)
         }

         If (BrushToolRandomAngle>0)
         {
            gR := BrushToolRandomAngle
            gR := Randomizer(-gR, gR, 2, 4)
            thisToolAngle := clampInRange(BrushToolAngle + gR, 0, 180)
         }

         If (BrushToolRandomAspectRatio>0)
         {
            gR := BrushToolRandomAspectRatio
            gR := Randomizer(-gR, gR, 2, 5)
            thisToolAspectRatio := clampInRange(BrushToolAspectRatio + gR, -100, 100)
         }
      }

      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
      ; ToolTip, % offX "-" offY "`n" kX "-" kY "`n" oMx "-" oMy , , , 2
      If isDotInRect(kX, kY, prevMX - stepu, prevMX + stepu, prevMY - stepu, prevMY + stepu)
      || !isDotInRect(kX, kY, 0 - brushSize//2, imgW + brushSize//2, 0 - brushSize//2, imgH + brushSize//2)
         Continue

      thisState := "a" mX mY kX kY randomFactor
      ; ToolTip, % thisState , , , 2
      If (prevState!=thisState && (A_TickCount - thisZeit>5))
      {
         ; calculate coords for the brush
         If !prevMX
            prevMX := kX 
         If !prevMY
            prevMY := kY
         distX := Abs(kX - prevMX) ; max(kX, prevMX) - min(kX, prevMX)
         distY := Abs(kY - prevMY) ; max(kY, prevMY) - min(kX, prevMY)
         maxDistuK := (distX>=distY) ? 1 : 2
         maxDistuV := (distX>=distY) ? distX : distY
         steps2cover := maxDistuV/stepu
         otherStepu := min(distX, distY)/steps2cover
         dirX := (kX>=prevMX) ? 1 : -1
         dirY := (kY>=prevMY) ? 1 : -1
         distStepX := (maxDistuK=1) ? stepu : otherStepu
         distStepY := (maxDistuK=2) ? stepu : otherStepu
         tkX := prevMX
         tkY := prevMY
         thisIndex++
         avgDistX := (distX + distStepX)//2
         avgDistY := (distY + distStepY)//2
         ; ToolTip, % "l=" distX "=" distY "||" dirX "=" dirY "||" distStepX "=" distStepY "||" steps2cover , , , 2
         Loop ; , % loops2do
         {
            ; loop interim brush steps
            Xgood := Ygood := 0
            zeitSillyPrevent := A_TickCount
            If (dirX=1)
            {
               smudgeX := clampInRange(avgDistX//2, 0, thisBulgePinchFactor)
               ; smudgeX := Ceil(thisBulgePinchFactor/2)
               tkX := clampInRange(tkX + distStepX, prevMX, kX)
               If (tkX>=kX)
                  Xgood := 1
            } Else
            {
               smudgeX := - clampInRange(avgDistX//2, 0, thisBulgePinchFactor)
               ; smudgeX := - Ceil(thisBulgePinchFactor/2)
               tkX := clampInRange(tkX - distStepX, kX, prevMX)
               If (tkX<=kX)
                  Xgood := 1
            }

            If (dirY=1)
            {
               smudgeY := clampInRange(avgDistY//2, 0, thisBulgePinchFactor)
               ; smudgeY := Ceil(thisBulgePinchFactor/2)
               tkY := clampInRange(tkY + distStepY, prevMY, kY)
               If (tkY>=kY)
                  Ygood := 1
            } Else
            {
               smudgeY := - clampInRange(avgDistY//2, 0, thisBulgePinchFactor)
               ; smudgeY := - Ceil(thisBulgePinchFactor/2)
               tkY := clampInRange(tkY - distStepY, kY, prevMY)
               If (tkY<=kY)
                  Ygood := 1
            }

            offX := oMx - tkX, offY := oMy - tkY
            ; [re]create dynamic brushes
            If (BrushToolType=6)
            {
               ; smudge brush
               brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, Round(tkX - brushSize/2 - smudgeX/2), Round(tkY - brushSize/2 - smudgeY/2), brushSize + thisBulgePinchFactor, brushSize + thisBulgePinchFactor, 0, 0, 1)
               QPV_SetAlphaChannel(brushImg, brushu, 0)
            } Else If (BrushToolType>=7)
            {
               ; pinch/bulge brush
               brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, 1)
               QPV_SetAlphaChannel(brushImg, brushu, 0)
            } Else If (BrushToolType=5)
            {
               ; effects brush
               thisBMP := (BrushToolOverDraw=0 && clonescu) ? clonescu : whichBitmap
               brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, 1)
               applyPersonalizedColorsBMP(brushImg, 1, BrushToolBlurStrength, BrushToolApplyColorFX)
               QPV_SetAlphaChannel(brushImg, brushu, 0)
            } Else If (BrushToolType=4)
            {
               ; eraser brush
               If thisSelectionConstrain
               {
                  ; ToolTip, % testuz "=" otestPos , , , 2
                  brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, 1)
                  QPV_EraserBrush(brushImg, brushu, 0, thisEraserMode, thisEraseOpacity, 0, 0, 0)
               } Else
                  QPV_EraserBrush(whichBitmap, brushu, 0, thisEraserMode, thisEraseOpacity, tkX - brushSize/2, tkY - brushSize/2, clonescu)
               currIMGdetails.HasAlpha := 1
               ; countClicks++
            } Else If (BrushToolDynamicCloner=1 && BrushToolType=3) ; dynamic cloner mode
            {
               brushu := trGdip_DisposeImage(brushu, 1)
               brushu := createClonedBrushBitmap(brushSize, 101 - thisToolSoftness, thisToolAngle, thisToolAspectRatio, clonescu, offX, offY, 1)
            } Else If (BrushToolWetness>0 && BrushToolType=2)
            {
               ; wet soft edges brush
               brushu := trGdip_DisposeImage(brushu, 1)
               coloruY := getPixelColorAvg(whichBitmap, kX, kY, "0xFF" o_startToolColor, startToolColor)
               startToolColor := SubStr(MixARGB(coloruY, "0xFF" startToolColor, thisWet), 5)
               g_startToolColor := RandomizeBrushColor(startToolColor)
               brushu := createGradientBrushBitmap(g_startToolColor, 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio)
            } Else If (BrushToolWetness>0 && BrushToolType=1)
            {
               ; wet simple brush
               Gdip_DeleteBrush(gdipbrushu)
               coloruY := getPixelColorAvg(whichBitmap, kX, kY, "0xFF" o_startToolColor, startToolColor)
               startToolColor := SubStr(MixARGB(coloruY, "0xFF" startToolColor, thisWet), 5)
               thisHexOpacity := Format("{1:#x}", thisOpacity)
               g_startToolColor := RandomizeBrushColor(startToolColor)
               gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity g_startToolColor)
            }

            ; ToolTip, % diffIMGdecX "==" diffIMGdecY , , , 2
            ; draw the brushes into main image [ whichBitmap - Gu ]
            If (BrushToolType=1)
            {
               ; draw simple brush
               allowBrushOverDraw := (BrushToolSymmetryX=1 && BrushToolSymmetryY=1) ? 1 : BrushToolOverDraw
               tmpPath := createBrushShapePath(brushSize, tkX, tkY, thisToolAspectRatio, thisToolAngle)
               Gdip_FillPath(Gu, gdipbrushu, tmpPath)
               If (allowBrushOverDraw=0)
                  Gdip_SetClipPath(Gu, tmpPath, 4)

               Gdip_DeletePath(tmpPath)
               If (BrushToolSymmetryX=1 || BrushToolSymmetryY=1)
               {
                  ccX := Round(imgW * BrushToolSymmetryPointX)
                  ccY := Round(imgH * BrushToolSymmetryPointY)
                  skX := (tkX<ccX) ? ccX - tkX + ccX : ccX - (tkX - ccX)
                  skY := (tkY<ccY) ? ccY - tkY + ccY : ccY - (tkY - ccY)
                  If (BrushToolSymmetryX!=1)
                     skX := tkX
                  If (BrushToolSymmetryY!=1)
                     skY := tkY

                  tmpPath := createBrushShapePath(brushSize, skX, skY, thisToolAspectRatio, thisToolAngle)
                  Gdip_FillPath(Gu, gdipbrushu, tmpPath)
                  If (allowBrushOverDraw=0)
                      Gdip_SetClipPath(Gu, tmpPath, 4)

                  Gdip_DeletePath(tmpPath)
                  If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
                  {
                     tmpPath := createBrushShapePath(brushSize, tkX, skY, thisToolAspectRatio, thisToolAngle)
                     Gdip_FillPath(Gu, gdipbrushu, tmpPath)
                     Gdip_DeletePath(tmpPath)
                     tmpPath := createBrushShapePath(brushSize, skX, tkY, thisToolAspectRatio, thisToolAngle)
                     Gdip_FillPath(Gu, gdipbrushu, tmpPath)
                     Gdip_DeletePath(tmpPath)
                  }
               }
            } Else If (BrushToolType=4)
            {
               If thisSelectionConstrain
               {
                  ; redraw eraser area
                  Gdip_SetClipRect(Gu, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 1)
                  Gdip_GraphicsClear(Gu)
                  Gdip_DrawImage(Gu, brushImg, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, brushSize, brushSize)
                  brushImg := trGdip_DisposeImage(brushImg, 1)
                  Gdip_ResetClip(Gu)
                  modus := (thisSelectionConstrain=1) ? 0 : 4
                  If ImgSelPath
                     Gdip_SetClipPath(Gu, ImgSelPath, modus)
               }
            } Else
            {
               ; draw any «generic» brush
               thisBrushu := (BrushToolType>=5) ? brushImg : brushu
               thisFloatOpacity := thisOpacity/255
               If (BrushToolType>=7)
               {
                  ; pinch/bulge brushes
                  Gdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2 - thisBulgePinchFactor, tkY - brushSize//2 - thisBulgePinchFactor, brushSize + thisBulgePinchFactor*2, brushSize + thisBulgePinchFactor*2, 0, 0, brushSize, brushSize, thisFloatOpacity)
                  If (thisBulgePinchFactor>3 && BrushToolType=8 && BrushToolDynamicCloner=1)
                     Gdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2 - thisBulgePinchFactor//2, tkY - brushSize/2 - thisBulgePinchFactor/2, brushSize + thisBulgePinchFactor, brushSize + thisBulgePinchFactor, 0, 0, brushSize, brushSize, thisFloatOpacity)
               } Else
                  Gdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)

               If (BrushToolSymmetryX=1 || BrushToolSymmetryY=1) && (BrushToolType=2 || BrushToolType=3)
               {
                  ccX := Round(imgW * BrushToolSymmetryPointX)
                  ccY := Round(imgH * BrushToolSymmetryPointY)
                  skX := (tkX<ccX) ? ccX - tkX + ccX : ccX - (tkX - ccX)
                  skY := (tkY<ccY) ? ccY - tkY + ccY : ccY - (tkY - ccY)
                  If (BrushToolSymmetryX!=1)
                     skX := tkX
                  If (BrushToolSymmetryY!=1)
                     skY := tkY

                  Gdip_DrawImage(Gu, thisBrushu, skX - brushSize//2, skY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
                  If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
                  {
                     Gdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2, skY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
                     Gdip_DrawImage(Gu, thisBrushu, skX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
                  }
               }

               If (BrushToolType>=5)
                  brushImg := trGdip_DisposeImage(brushImg, 1)

               If (BrushToolType>=6 && BrushToolOverDraw=1)
               {
                  ; smudge/pinch/bulge brushes
                  f := (BrushToolType=7) ? BrushToolWetness*2 + 2 : BrushToolWetness + 2
                  If (BrushToolType=6)
                     f := BrushToolWetness//2 + 2
                  brushSize -= f
                  If (brushSize>2)
                  {
                     If (BrushToolType=6)
                        brusha := Gdip_ResizeBitmap(brushu, brushSize + thisBulgePinchFactor, brushSize + thisBulgePinchFactor, 0, 3)
                     Else
                        brusha := Gdip_ResizeBitmap(brushu, brushSize, brushSize, 0, 3)
                     brushu := trGdip_DisposeImage(brushu, 1)
                     brushu := brusha
                  }
               }
            }

            ; Gdip_DrawImageFast(Gu, brushu[1], tkX - brushToolSize//2, tkY - brushToolSize//2)
            If (BrushToolDryingRate>0) && (A_TickCount - dryZeit>dryRateZeit)
            {
               dryZeit := A_TickCount
               thisOpacity -= thisDryRate
               If (BrushToolType=1)
               {
                  Gdip_DeleteBrush(gdipbrushu)
                  thisHexOpacity := Format("{1:#x}", thisOpacity)
                  gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)
               } Else If (BrushToolType=4 || BrushToolType=5)
               {
                  brushu := trGdip_DisposeImage(brushu, 1)
                  thisHexOpacity := Format("{1:#x}", thisOpacity)
                  brushu := createGradientBrushBitmap("ffFFff", 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio, thisHexOpacity, "0xff000000")
               }
            }
            thisZeit := A_TickCount
            ; ToolTip, % A_TickCount - thisZeit , , , 2
            If (Xgood=1 && Ygood=1 && A_index>1 || stepu<=1 && BrushToolType>5 || brushToolStepping=0 || BrushToolType>=7 || brushSize<2 || thisOpacity<0.005)
               Break
         }
         prevState := thisState
         prevMX := kX, prevMY := kY
         zeitSillyPrevent := A_TickCount
         If (thisIndex=1)
            oMx := tkX, oMy := tkY
         dummyResizeImageGDIwin()
      }
   }

   setwhileLoopExec(0)
   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(brushu, 1)
   trGdip_DisposeImage(brushImg, 1)
   trGdip_DisposeImage(clonescu, 1)

   ; gdipObjectsStats(1, "createGradientBrushBitmap")

   If gdipbrushu
      Gdip_DeleteBrush(gdipbrushu)

   MouseMoveResponder()
   If (A_TickCount - lastInvoked>350)
   {
      If !UserMemBMP
         UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap())
      recordUndoLevelNow(0, useGdiBitmap())
   }

   ; liveDrawingBrushTool := 0
   If (thisIndex>10 || lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
   lastInvoked := A_TickCount
}

ActDrawAlphaMaskBrushNow() {
   Critical, on
   Static lastInvoked := 1, prevMX, prevMY, countClicks

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (!imgW || !imgH)
   {
      addJournalEntry("ERROR: main bitmap seems inexistent. Failure occured in " A_ThisFunc "()")
      Return
   }

   If (A_TickCount - lastOtherWinClose<450)
      Return

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := (FlipImgH=1) ? mainWidth - mX : mX
   mY := (FlipImgV=1) ? mainHeight - mY : mY
   imgPath := getIDimage(currentFileIndex)
   thisZeit := A_TickCount - 100
   thisIndex := 0
   Random, randomFactor, -950, 950
   prevState := "a"
   liveDrawingBrushTool := 1
   whichBitmap := userAlphaMaskBmpPainted
   If StrLen(whichBitmap)<3
   {
      addJournalEntry("ERROR: no alpha mask bitmap. Failure occured in " A_ThisFunc "()")
      Return
   }

   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   o_startToolColor := startToolColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   thisMainOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisHexOpacity := Format("{1:#x}", thisMainOpacity)
   pDPX := viewportDynamicOBJcoords.x,     pDPY := viewportDynamicOBJcoords.y
   pVPimgW := viewportDynamicOBJcoords.w,  pVPimgH := viewportDynamicOBJcoords.h
   MouseCoords2Image(mX, mY, 0, pDPX, pDPY, pVPimgW, pVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)

   oMx := kX, oMy := kY
   brushSize := (brushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize

   ; create base brush element / bitmap
   If (BrushToolType>1) ; soft edges
      brushu := createGradientBrushBitmap(startToolColor, 101 - BrushToolSoftness, brushSize, BrushToolAngle, BrushToolAspectRatio)
   Else ; simple solid
      gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)

   If (!brushu && BrushToolType>1)
   {
      addJournalEntry("ERROR: no brush image. Failure occured in " A_ThisFunc "()")
      Return
   }

   imgIndexEditing := currentFileIndex
   thisQuality := (BrushToolType>5) ? 7 : 5
   Gu := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, thisQuality)
   If !Gu
   {
      trGdip_DisposeImage(brushu, 1)
      If gdipbrushu
         Gdip_DeleteBrush(gdipbrushu)
      addJournalEntry("ERROR: failed to create graphics object on " whichBitmap ". Failure occured in " A_ThisFunc "()")
      Return
   }

   Gdip_SetPixelOffsetMode(Gu, 2)
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisEraseOpacity := thisOpacity
   thisEraserMode := (BrushToolOverDraw=1) ? 2 : 1
   If (BrushToolEraserRestore=1)
      thisEraserMode := 3

   thisEraseOpacity := (thisEraserMode=1) ? 255 - thisEraseOpacity : thisEraseOpacity
   thisWet := 0.79 + (21 - thisWetness)/100

   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   If (A_TickCount - lastInvoked>250)
   {
      trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
      userPrevAlphaMaskBmpPainted := trGdip_CloneBitmap(A_ThisFunc, userAlphaMaskBmpPainted)
   }

   dryZeit := A_TickCount
   dryRateZeit := 300 - BrushToolDryingRate**2
   thisDryRate := clampInRange(BrushToolDryingRate/4, 1, 20)
   isUserStepu := (brushToolStepping=1 || brushToolStepping=2 || brushToolStepping=251) ? 0 : 1
   stepu := (isUserStepu=0) ? Ceil(brushSize * 0.2)**1.09 : brushToolStepping
   If (BrushToolType>6 || BrushToolType=5) && (isUserStepu=1 && stepu<brushSize/4 && isInRange(BrushToolAspectRatio, -5, 5) && isInRange(BrushToolAngle, 0, 5))
      stepu := brushSize//4 + 1

   If (!stepu || BrushToolType>=7 || brushToolStepping=0)
      stepu := 1

   If !GetKeyState("Shift", "P")
      prevMX := prevMY := 0

   offX := offY := 0
   setwhileLoopExec(1)
   While, (determineLClickstate()=1 || A_Index<2)
   {
      If (thisOpacity<0.005 || brushSize<2)
         Break
      
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 0, pDPX, pDPY, pVPimgW, pVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
      ; ToolTip, % offX "-" offY "`n" kX "-" kY "`n" oMx "-" oMy , , , 2
      If isDotInRect(kX, kY, prevMX - stepu, prevMX + stepu, prevMY - stepu, prevMY + stepu)
      || !isDotInRect(kX, kY, 0 - brushSize//2, imgW + brushSize//2, 0 - brushSize//2, imgH + brushSize//2)
         Continue

      thisState := "a" mX mY kX kY randomFactor
      ; ToolTip, % thisState , , , 2
      Sleep, 2
      If (prevState!=thisState && (A_TickCount - thisZeit>5))
      {
         ; calculate coords for the brush
         If !prevMX
            prevMX := kX 
         If !prevMY
            prevMY := kY
         distX := Abs(kX - prevMX) ; max(kX, prevMX) - min(kX, prevMX)
         distY := Abs(kY - prevMY) ; max(kY, prevMY) - min(kX, prevMY)
         maxDistuK := (distX>=distY) ? 1 : 2
         maxDistuV := (distX>=distY) ? distX : distY
         steps2cover := maxDistuV/stepu
         otherStepu := min(distX, distY)/steps2cover
         dirX := (kX>=prevMX) ? 1 : -1
         dirY := (kY>=prevMY) ? 1 : -1
         distStepX := (maxDistuK=1) ? stepu : otherStepu
         distStepY := (maxDistuK=2) ? stepu : otherStepu
         tkX := prevMX
         tkY := prevMY
         thisIndex++
         avgDistX := (distX + distStepX)//2
         avgDistY := (distY + distStepY)//2
         ; ToolTip, % "l=" distX "=" distY "||" dirX "=" dirY "||" distStepX "=" distStepY "||" steps2cover , , , 2
         Loop ; , % loops2do
         {
            ; loop interim brush steps
            Xgood := Ygood := 0
            zeitSillyPrevent := A_TickCount
            If (dirX=1)
            {
               tkX := clampInRange(tkX + distStepX, prevMX, kX)
               If (tkX>=kX)
                  Xgood := 1
            } Else
            {
               tkX := clampInRange(tkX - distStepX, kX, prevMX)
               If (tkX<=kX)
                  Xgood := 1
            }

            If (dirY=1)
            {
               tkY := clampInRange(tkY + distStepY, prevMY, kY)
               If (tkY>=kY)
                  Ygood := 1
            } Else
            {
               tkY := clampInRange(tkY - distStepY, kY, prevMY)
               If (tkY<=kY)
                  Ygood := 1
            }

            offX := oMx - tkX, offY := oMy - tkY
            ; draw the brushes into main image [ whichBitmap - Gu ]
            If (BrushToolType=1)
            {
               ; draw simple brush
               tmpPath := createBrushShapePath(brushSize, tkX, tkY, BrushToolAspectRatio, BrushToolAngle)
               Gdip_FillPath(Gu, gdipbrushu, tmpPath)
               If (BrushToolOverDraw=0)
                  Gdip_SetClipPath(Gu, tmpPath, 4)
               Gdip_DeletePath(tmpPath)
            } Else
            {
               ; draw any «generic» brush
               thisBrushu := (BrushToolType>=5) ? brushImg : brushu
               thisFloatOpacity := thisOpacity/255
               Gdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
            }

            ; Gdip_DrawImageFast(Gu, brushu[1], tkX - brushToolSize//2, tkY - brushToolSize//2)
            If (BrushToolDryingRate>0) && (A_TickCount - dryZeit>dryRateZeit)
            {
               dryZeit := A_TickCount
               thisOpacity -= thisDryRate
               If (BrushToolType=1)
               {
                  Gdip_DeleteBrush(gdipbrushu)
                  thisHexOpacity := Format("{1:#x}", thisOpacity)
                  gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)
               }
            }
            thisZeit := A_TickCount
            ; ToolTip, % A_TickCount - thisZeit , , , 2
            If (Xgood=1 && Ygood=1 && A_index>1 || brushToolStepping=0 || brushSize<2 || thisOpacity<0.005)
               Break
         }
         prevState := thisState
         prevMX := kX, prevMY := kY
         zeitSillyPrevent := A_TickCount
         If (thisIndex=1)
            oMx := tkX, oMy := tkY

         corelivePreviewsImageEditing()
      }
   }

   setwhileLoopExec(0)
   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(brushu, 1)
   If gdipbrushu
      Gdip_DeleteBrush(gdipbrushu)

   MouseMoveResponder()
   ; liveDrawingBrushTool := 0
   SetTimer, ResetImgLoadStatus, -100
   lastInvoked := A_TickCount
}

drawVPgridsNow(mW, mH, newW, newH, DestPosX, DestPosY, Gu) {
   Static penGrid, penGridL, lastPenState, miniPath, maxiPath, prevPathsState
   thisGridThickness := vpGridThickness + imgHUDbaseUnit//30
   thisPen := thisGridThickness vpGridColor vpGridAlpha
   If (thisPen!=lastPenState)
   {
      If penGrid
         Gdip_DeletePen(penGrid)
      If penGridL
         Gdip_DeletePen(penGridL)

      Gdip_FromARGB("0xFF" vpGridColor, A, R, G, B)
      this1stOpacity := vpGridAlpha
      thisColor := Gdip_ToARGB(this1stOpacity, R, G, B)
      penGrid := Gdip_CreatePen(thisColor , thisGridThickness)

      thisColor := SubStr(MixARGB("0xFF998899", "0xFF" vpGridColor, 0.85), 5)
      Gdip_FromARGB("0xFF" thisColor, A, R, G, B)
      this1stOpacity := clampInRange(vpGridAlpha + 25, 1, 255)
      thisColor := Gdip_ToARGB(this1stOpacity, R, G, B)
      penGridL := Gdip_CreatePen(thisColor , Round(thisGridThickness*1.65))
   }

   dS := (vpGridFixedSize=1) ? vpGridSize : Ceil(vpGridSize/1.5 + (vpGridSize/5)*zoomLevel + (imgHUDbaseUnit/25)*zoomLevel)
   If (zoomLevel<0.5 && vpGridSize<15 && vpGridFixedSize=0)
      dS := dS*2
   Else If (zoomLevel>10 && vpGridFixedSize=0)
      dS := dS//2
   Else If (zoomLevel>5 && vpGridFixedSize=0)
      dS := dS//1.5

   loops := 0
   prevDPx := clampInRange(prevDestPosX, 0, mW)
   prevDPy := clampInRange(prevDestPosY, 0, mH)
   MaxLimX := (LimitSelectBoundsImg=1) ? prevDestPosX + prevResizedVPimgW : mW
   MaxLimY := (LimitSelectBoundsImg=1) ? prevDestPosY + prevResizedVPimgH : mH
   MinLimX := (LimitSelectBoundsImg=1) ? prevDPx : 0
   MinLimY := (LimitSelectBoundsImg=1) ? prevDPy : 0
   dX := (LimitSelectBoundsImg=1) ? prevDPx : 0
   dY := (LimitSelectBoundsImg=1) ? prevDPy : 0
   mW := clampInRange(dX + mW, MinLimX, MaxLimX)
   mH := clampInRange(dY + mH, MinLimY, MaxLimY)
   thisPathsState := "a" dS vpGridStepu imageAligned vpGridFixedSize mW mH prevDPx prevDPy LimitSelectBoundsImg
   If (prevPathsState!=thisPathsState)
   {
      If miniPath
         Gdip_DeletePath(miniPath)
      If maxiPath
         Gdip_DeletePath(maxiPath)

      prevPathsState := thisPathsState
      miniPath := Gdip_CreatePath()
      maxiPath := Gdip_CreatePath()
      Loop
      {
         dX += dS
         If (dX>mW)
            Break
     
         loops++
         If (loops=vpGridStepu)
         {
            Gdip_StartPathFigure(maxiPath)
            Gdip_AddPathLine(maxiPath, dX, dY, dX, mH)
            loops := 0
         } Else
         {
            Gdip_StartPathFigure(miniPath)
            Gdip_AddPathLine(miniPath, dX, dY, dX, mH)
         }
      }

      ; ToolTip, % mW "==" dS "==" thisThick "==" loops    , , , 2
      dX := (LimitSelectBoundsImg=1) ? prevDPx : 0
      loops := prevu := 0
      Loop
      {
         dY += dS
         If (dY>mH)
            Break
     
         loops++
         If (loops=vpGridStepu)
         {
            Gdip_StartPathFigure(maxiPath)
            Gdip_AddPathLine(maxiPath, dX, dY, mW, dY)
            loops := 0
         } Else
         {
            Gdip_StartPathFigure(miniPath)
            Gdip_AddPathLine(miniPath, dX, dY, mW, dY)
         }
      }
      Gdip_ClosePathFigures(miniPath)
      Gdip_ClosePathFigures(maxiPath)
   }

   Gdip_DrawPath(Gu, penGrid, miniPath)
   Gdip_DrawPath(Gu, penGridL, maxiPath)
}

drawHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath) {
    Static prevImgPath, lastInvoked := 1
    If (preventHUDelements=1)
    {
       preventHUDelements := 0
       Return
    }

    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    pBrush := (mode=2) ? pBrushB : pBrushA
    indicWidth := 150
    lineThickns := imgHUDbaseUnit
    lineThickns2 := lineThickns//4
    If (showHistogram>1 && drawingShapeNow!=1 && mode!=2)
    {
       thisImgCall := imgPath currentFileIndex zoomLevel IMGresizingMode imgFxMode showHistogram gdiBitmap undoLevelsRecorded currentUndoLevel UserMemBMP OSDfontSize histogramMode
       thisSizingModes := isVarEqualTo(IMGresizingMode, 1, 2, 5) || (IMGresizingMode=4 && IMGlargerViewPort!=1) ? 1 : 0
       If (imgFxMode!=1 || thisSizingModes!=1 || animGIFplaying=1 || desiredFrameIndex>0)
       {
          prevImgPath := 0
          thisPosX := (DestPosX<0) ? 0 : DestPosX
          thisPosY := (DestPosY<0) ? 0 : DestPosY
          thisW := (newW>mainWidth) ? mainWidth : newW
          thisH := (newH>mainHeight) ? mainHeight : newH
          If (thisPosX+thisW>mainWidth)
             thisW := mainWidth - thisPosX
          If (thisPosY+thisH>mainHeight)
             thisH := mainHeight - thisPosY
          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          If (thisW>4 && thisH>4)
             tempBMP := trGdip_CreateBitmapFromHBITMAP(glHbitmap)

          ; ToolTip, % thisPosX "==" thisPosY "`n" thisW "==" thisH , , , 2
          If StrLen(tempBMP)>2
          {
             thisVPimg := Gdip_CloneBmpPargbArea(A_ThisFunc, tempBMP, thisPosX + 1, thisPosY + 1, thisW - 2, thisH - 2)
             createHistogramBMP(thisVPimg)
             trGdip_DisposeImage(thisVPimg, 1)
             trGdip_DisposeImage(tempBMP, 1)
          }
       } Else If (prevImgPath!=thisImgCall) && (A_TickCount - lastInvoked>50)
       {
          lastInvoked := A_TickCount
          prevImgPath := thisImgCall
          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          If StrLen(gdiBitmap)>3
             createHistogramBMP(gdiBitmap)
       }
    } Else 
    {
       prevImgCall := 0
       interfaceThread.ahkPostFunction("uiAccessUpdateHistoBox", "hide", 1, 1, 0, 0)
    }

    Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
    If (showViewPortGrid=1 && slideShowRunning!=1 && imgEditPanelOpened!=1)
       drawVPgridsNow(mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, glPG)

    If (mode=2 && IMGresizingMode=4 && IMGlargerViewPort=1 && slideShowRunning!=1)
    {
       ; highlight action areas
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//10
       Gdip_SetPenWidth(pPen1d, thisThick)
       Gdip_DrawRectangle(glPG, pPen1d, thisX, thisY, thisW, thisH)
    } Else If (mode=1 && slideShowRunning!=1)
    {
       ; highlight action areas
       thisThick := imgHUDbaseUnit//11
       If (showSelectionGrid=1 || imgSelLargerViewPort=1) && (editingSelectionNow=1)
       {
          Gdip_SetPenWidth(pPen4, thisThick)
          Gdip_DrawLine(glPG, pPen4, DestPosX + newW//2 - thisThick//4, DestPosY, DestPosX + newW//2 - thisThick//4, DestPosY + newH)
          Gdip_DrawLine(glPG, pPen4, DestPosX, DestPosY + newH//2 - thisThick//4, DestPosX + newW, DestPosY + newH//2 - thisThick//4)
       }

       If (IMGentirelylargerThanVP=0)
       {
          If (borderAroundImage=1) || (editingSelectionNow=1 && LimitSelectBoundsImg=1)
             Gdip_DrawRectangle(glPG, pPen4, DestPosX - thisThick//2, DestPosY - thisThick//2, newW + thisThick, newH + thisThick)
       }
    }

; visual markers for image viewing conditions

    If (markedSelectFile || FlipImgV=1 || FlipImgH=1 || IMGlargerViewPort=1 || imgFxMode>1) && (slideShowRunning!=1)
    {
       If (FlipImgH=1 && mode=2)
          Gdip_FillRoundedRectanglePath(glPG, pBrush, mainWidth//2 - indicWidth//2, mainHeight//2 - lineThickns2//2, indicWidth, lineThickns2, lineThickns2//2)
       If (FlipImgV=1 && mode=2)
          Gdip_FillRoundedRectanglePath(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//2, lineThickns2, indicWidth, lineThickns2//2)

       If (imgFxMode>1 && mode=2)
       {
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//4, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2, 0, 180)
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//8, mainHeight//2 - indicWidth//8, indicWidth//4, indicWidth//4, 180, 360)
       }

       If (IMGlargerViewPort=1 && imgEditPanelOpened!=1)
       {
          marginErr := (mode=2) ? 12 : 25
          lineThickns2 := (imgHUDbaseUnit/3)//1.5
          If (newH>mainHeight)
          {
             If (DestPosY<-marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, 0, mainWidth, lineThickns2//2)
             If (DestPosY>-newH+mainHeight+marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, mainHeight - lineThickns2//2, mainWidth, lineThickns2//2)
          }

          If (newW>mainWidth)
          {
             If (DestPosX<-marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, 0, lineThickns2//2, mainHeight)
             If (DestPosX>-newW+mainWidth+marginErr)
                Gdip_FillRectangle(glPG, pBrush, mainWidth - lineThickns2//2, 0, lineThickns2//2, mainHeight)
          }
       }

       If (markedSelectFile && imgEditPanelOpened!=1)
       {
          sqSize := lineThickns ; (mode=2) ? lineThickns + lineThickns2 : lineThickns
          sqPosX := mainWidth - sqSize
          Gdip_FillRectangle(glPG, pBrush, sqPosX, 0, sqSize, sqSize)
          thisThick := lineThickns//9
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen1d, sqPosX, 0, sqSize, sqSize)
       }

       If resultedFilesList[currentFileIndex, 2] ; file is selected
       {
          thisThick := lineThickns//4.2 ; (mode=2) ? lineThickns//2.5 : lineThickns//4.2
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen3, 0, 0, mainWidth, mainHeight)
          Gdip_DrawRectangle(glPG, pPen1d, 0, 0, mainWidth, mainHeight)
       }
    }

; highlight usePrevious=1 mode

    lineThickns := (mode=2) ? imgHUDbaseUnit//10 : imgHUDbaseUnit//9
    If (mode=2 && imgFxMode=1)
    {
       indicWidth := (zoomLevel<1) ? Round(120 * zoomLevel) : 110
       If (indicWidth<50)
          indicWidth := 50
       Gdip_SetPenWidth(pPen2, lineThickns)
       Gdip_FillRectangle(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
       Gdip_DrawRectangle(glPG, pPen2, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
    }

; draw the scrollbar indicators
    calculateScrollBars(newW, newH, DestPosX, DestPosY, mainWidth, mainHeight, knobW, knobH, knobX, knobY)
    knobSize := imgHUDbaseUnit//3
    If (knobW<mainWidth - 5) && (IMGresizingMode=4 && slideShowRunning!=1)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, knobX, 0, knobW, knobSize)
       scrollBarHy := (FlipImgV=1) ? 0 : mainHeight - knobSize
       Gdip_FillRectangle(glPG, pBrushE, 0, scrollBarHy, mainWidth, knobSize)
       Gdip_FillRectangle(glPG, pBrushD, knobX, scrollBarHy + 1, knobW, knobSize)
       If (vpImgPanningNow>0)
          Gdip_FillRectangle(glPG, pBrushE, knobX, scrollBarHy + 1, knobW, knobSize)
       scrollBarHy := knobSize
    } Else scrollBarHy := 0

    If (knobH<mainHeight - 5) && (IMGresizingMode=4 && slideShowRunning!=1)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, 0, knobY, knobSize, knobH)
       scrollBarVx := (FlipImgH=1) ? 0 : mainWidth - knobSize
       Gdip_FillRectangle(glPG, pBrushE, scrollBarVx, 0, knobSize, mainHeight)
       Gdip_FillRectangle(glPG, pBrushD, scrollBarVx + 1, knobY, knobSize, knobH)
       If (vpImgPanningNow>0)
          Gdip_FillRectangle(glPG, pBrushE, scrollBarVx + 1, knobY, knobSize, knobH)
       scrollBarVx := knobSize
    } Else scrollBarVx := 0

; highlight number of frames and the current frame in multi-frame images [tiff and gif]

    If (totalFramesIndex>0)
    {
       bulletSize := imgHUDbaseUnit//3
       totalBulletsWidth := bulletSize * totalFramesIndex
       If (totalBulletsWidth>mainWidth)
          bulletsPerc := Round(desiredFrameIndex/totalFramesIndex, 3)
       maxBullets := Round(mainWidth/bulletSize)
       centerPos := bulletsPerc ? 0 : mainWidth//2 - totalBulletsWidth//2
       If (centerPos<0)
          centerPos := 0
       Loop, % totalFramesIndex + 1
       {
           If bulletsPerc
              whichBrush := (A_Index/maxBullets<bulletsPerc) || (desiredFrameIndex=totalFramesIndex) ? pBrushA : pBrushE
           Else
              whichBrush := (A_Index - 1 <= desiredFrameIndex) ? pBrushA : pBrushE
           Gdip_FillEllipse(glPG, whichBrush, centerPos + bulletSize * (A_Index - 1), mainHeight - bulletSize, bulletSize, bulletSize)
           If (A_index>maxBullets)
              Break
       }
    }

    If (adjustNowSel=1)
       Return

    If (showHistogram>1 && StrLen(HistogramBMP)>3 && mode!=2)
    { 
       Gdip_GetImageDimensions(HistogramBMP, imgW, imgH)
       hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
       tlbrBonusX := (hasTrans=1 && FlipImgH=1 && ((ToolbarWinH - 3 > mainHeight - imgH - scrollBarHy) || FlipImgV=1)) ? ToolbarWinW : 0
       tlbrBonusY := (hasTrans=2 && FlipImgV=1 && ((ToolbarWinW - 3 > mainWidth  - imgW - scrollBarVx) || FlipImgH=1)) ? ToolbarWinH : 0
       thisPosX := (FlipImgH=0 && scrollBarVx>0) ? mainWidth - scrollBarVx - imgW - tlbrBonusX : mainWidth - imgW - tlbrBonusX
       thisPosY := (FlipImgV=0 && scrollBarHy>0) ? mainHeight - scrollBarHy - imgH - tlbrBonusY : mainHeight - imgH - tlbrBonusY
       If (FlipImgH=1 || FlipImgV=1)
       {
          tempBMP := trGdip_CloneBitmap(A_ThisFunc, HistogramBMP)
          flipBitmapAccordingToViewPort(tempBMP, 1)
          E := trGdip_DrawImage(A_ThisFunc, glPG, tempBMP, thisPosX, thisPosY)
          trGdip_DisposeImage(tempBMP, 1)
       } Else E := trGdip_DrawImage(A_ThisFunc, glPG, HistogramBMP, thisPosX, thisPosY,,,,,,, 0.9)

       If (FlipImgH=1)
          thisPosX := tlbrBonusX
       If (FlipImgV=1)
          thisPosY := tlbrBonusY

       HUDobjHistoBoxu[1] := imgW, HUDobjHistoBoxu[2] := imgH
       HUDobjHistoBoxu[3] := thisPosX, HUDobjHistoBoxu[4] := thisPosY
       hasDrawnHistoMap := (E="fail") ? 0 : 1
       thisString := (prevHistoBoxString && hasDrawnHistoMap=1) ? prevHistoBoxString : "hide"
       interfaceThread.ahkPostFunction("uiAccessUpdateHistoBox", thisString, imgW, imgH, thisPosX, thisPosY)
    } Else 
    {
       hasDrawnHistoMap := 0
       interfaceThread.ahkPostFunction("uiAccessUpdateHistoBox", "hide", 0, 0, 0, 0)
    }

    additionalHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, 1)
}

calculateScrollBars(newW, newH, DestPosX, DestPosY, mainWidth, mainHeight, ByRef knobW, ByRef knobH, ByRef knobX, ByRef knobY) {
   If (allowFreeIMGpanning=1 && IMGresizingMode=4)
   {
       totalW := (IMGlargerViewPort=1) ? newW*3 : newW + mainWidth
       totalH := (IMGlargerViewPort=1) ? newH*3 : newH + mainHeight
       prcVisX := mainWidth/totalW
       prcVisY := mainHeight/totalH
       knobW := Round(mainWidth*prcVisX)
       knobH := Round(mainHeight*prcVisY)
       Ax := 1 - (DestPosX + newW) / (newW + mainWidth)
       Ay := 1 - (DestPosY + newH) / (newH + mainHeight)
       knobX := Round(Ax*(mainWidth - knobW))
       knobY := Round(Ay*(mainHeight - knobH)) 
       ; ToolTip, % Ay "`n" knobY "`n" totalH "`n" DestPosY "`n" newH  , , , 2
   } Else
   {
       prcVisX := mainWidth/newW
       prcVisY := mainHeight/newH
       knobW := Round(mainWidth*prcVisX)
       knobH := Round(mainHeight*prcVisY)
       Ax := (DestPosX<0) ? Abs(DestPosX)/newW : 0
       Ax := Round(Ax*prevMaxSelX)
       Ay := (DestPosY<0) ? Abs(DestPosY)/newH : 0
       Ay := Round(Ay*prevMaxSelY)
       knobX := Round((Ax/prevMaxSelX)*mainWidth)
       knobY := Round((Ay/prevMaxSelY)*mainHeight) 
   }

   If (knobH<15)
      knobH := 15
   If (knobW<15)
      knobW := 15
}

snapPointsAtAngles(gmX, gmY, dulaX, dulaY, ByRef guX, ByRef guY) {
; dulaX, dulaY     = coords of the fixed point [P1]
; gmX, gmY         = coords of the 2nd point [P2], the point to be placed at 90/45/0°

    mustSnapLiveDrawPoints := 1
    guY := gmY, guX := gmX
    zY := Abs(gmY),   zX := Abs(gmX)
    wY := Abs(dulaY), wX := Abs(dulaX)
    maxX := max(zX, wX), maxY := max(zY, wY)
    minX := min(zX, wX), minY := min(zY, wY)
    lenX := maxX - minX
    lenY := maxY - minY
    lenAvg := (lenX + lenY)//2
    thisAngle := getAngleBetweenTwoPoints(gmX, gmY, dulaX, dulaY, 2)
    ; ToolTip, % thisAngle , , , 2
    If isInRange(thisAngle, 30, 60)
    {
       guX := dulaX + lenAvg
       guY := dulaY - lenAvg
    } Else If isInRange(thisAngle, 120, 150)
    {
       guX := dulaX - lenAvg
       guY := dulaY - lenAvg
    } Else If isInRange(thisAngle, 210, 240)
    {
       guX := dulaX - lenAvg
       guY := dulaY + lenAvg
    } Else If isInRange(thisAngle, 300, 330)
    {
       guX := dulaX + lenAvg
       guY := dulaY + lenAvg
    } Else If (lenX>lenY)
       guY := dulaY
    Else
       guX := dulaX
}


fAddPathLines(pPath, inPoints) {
   PointsCount := inPoints.Length()
   If !PointsCount
      Return 1

   VarSetCapacity(PointsF, 4 * PointsCount, 0)
   Loop, % PointsCount
       NumPut(inPoints[A_Index], &PointsF, 4 * (A_Index-1), "float")

   iCount := PointsCount//2
   return DllCall("gdiplus\GdipAddPathLine2", "UPtr", pPath, "UPtr", &PointsF, "int", iCount)
}

fAddPathLine(pPath, x1, y1, x2, y2) {
   If (x1=x2 && y1=y2)
      Return 1
   Return DllCall("gdiplus\GdipAddPathLine", "UPtr", pPath, "float", x1, "float", y1, "float", x2, "float", y2)
}

drawLiveCreateCustomShape(mainWidth, mainHeight, Gu) {
    Static pWhite
    If !pWhite
       pWhite := Gdip_BrushCreateSolid("0xDDeeFFaa")

    ; Related addNewVectorShapePoints()
    If StrLen(HistogramBMP)>2
       HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)

    GetMouseCoord2wind(PVhwnd, mX, mY)
    gmX := (FlipImgH=1) ? mainWidth - mX : mX
    gmY := (FlipImgV=1) ? mainHeight - mY : mY

    dontAddPoint := (mX<0 || mY<0) ? -1 : 0
    If (dontAddPoint!=-1 && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1))
    {
       ; handle H/V scrollbars for images larger than the viewport
       knobSize := imgHUDbaseUnit//3
       If (scrollBarHy>1 && mY>(mainHeight - knobSize))
       || (scrollBarVx>1 && mX>(mainWidth - knobSize))
          dontAddPoint := -1
    }

    If (dontAddPoint!=-1)
    {
       MouseGetPos, , , OutputVarWin
       If GetKeyState("Space", "P") || (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1 && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
       || (OutputVarWin!=PVhwnd) || (A_TickCount - zeitSillyPrevent<100)
          dontAddPoint := -1
    }

    PointsListArray := [] ; flatten
    customShapeHasSelectedPoints := 0
    k := firstPx := firstPy := 0
    totalz := customShapePoints.Count()
    Loop, % totalz
    {
       ; convert and normalize points coordinates to current viewport conditions
       getVPcoordsVectorPoint(A_Index, xu, yu)
       If (initialDrawingStartCoords[A_Index, 3])
       {
          firstPx := xu  ,  firstPy := yu
          customShapeHasSelectedPoints := 1
       }

       If (A_Index=1 && !vpSymmetryPointX && !vpSymmetryPointY && totalz=1 && bezierSplineCustomShape=0)
       || (A_Index=2 && !vpSymmetryPointX && !vpSymmetryPointY && totalz=2 && bezierSplineCustomShape=1)
       {
          fX := prevResizedVPimgW/initialDrawingStartCoords[A_Index, 4]
          fY := prevResizedVPimgH/initialDrawingStartCoords[A_Index, 5]
          vpSymmetryPointX := customShapePoints[A_Index, 1]*fX
          vpSymmetryPointY := customShapePoints[A_Index, 2]*fY
          vpSymmetryPointXdp := initialDrawingStartCoords[A_Index, 1]
          vpSymmetryPointYdp := initialDrawingStartCoords[A_Index, 2]
          prevVectorShapeSymmetryMode[1] := [1, 0]
       }

       ; k := (bezierSplineCustomShape=1) ? clampInRange(k + 1, 1, 3, 1) : 1
       ; newArrayu[A_Index] := [xu, yu, k]
       PointsListArray[A_Index*2 - 1] := xu
       PointsListArray[A_Index*2] := yu
       ; test if mouse location is hovering one of the points in the vector path
       If (dontAddPoint!=-1)
       {
          If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, PointsListArray[A_Index*2 - 1], PointsListArray[A_Index*2], 1)
             dontAddPoint := A_Index
       }
    }

    lastPx := xu,    lastPy := yu
    If (totalz<=2 && bezierSplineCustomShape=0 || totalz=3 && bezierSplineCustomShape=1)
    {
       vpFreeformShapeOffset[1] := 0, vpFreeformShapeOffset[2] := 0, vpFreeformShapeOffset[3] := 0
       CustomShapeLockedSymmetry := CustomShapeSymmetry
    }

    SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
    thisThick := SelDotsSize//5 + 1
    sz := SelDotsSize * 5
    If (mustSnapLiveDrawPoints=2)
    {
       Gdip_SetPenWidth(pPen1d, thisThick)
       Gdip_DrawLine(Gu, pPen1d, VPstampBMPx - sz, VPstampBMPy, VPstampBMPx + sz, VPstampBMPy)
       Gdip_DrawLine(Gu, pPen1d, VPstampBMPx, VPstampBMPy - sz, VPstampBMPx, VPstampBMPy + sz)
    }

    mustSnapLiveDrawPoints := 0
    If (GetKeyState("Shift", "P") && dontAddPoint=0 && totalz>0)
    {
       If (customShapeHasSelectedPoints=1)
          snapPointsAtAngles(gmX, gmY, firstPx, firstPy, gmX, gmY)
       Else
          snapPointsAtAngles(gmX, gmY, lastPx, lastPy, gmX, gmY)
       VPstampBMPx := gmX, VPstampBMPy := gmY
    }

    ; ToolTip, % CustomShapeLockedSymmetry "=" CustomShapeSymmetry "=" vpSymmetryPointX  , , , 2
    If (dontAddPoint=0 && bezierSplineCustomShape=0 && showNewVectorPointPreview=1 && vpImgPanningNow=0 && customShapeHasSelectedPoints=0)
    {
       If (CustomShapeSymmetry=1 && vpSymmetryPointX)
       {
          vpSymX := Round(vpSymmetryPointX) - (vpSymmetryPointXdp - prevDestPosX)
          gmXa := vpSymX - (gmX - vpSymX)
          If (gmX<vpSymX)
          {
             gmc := gmX,  gmd := gmXa
             gmXa := gmX, gmX := gmd
          }

          PointsListArray.InsertAt(1, gmXa)
          PointsListArray.InsertAt(2, gmY)
          ; ToolTip, % mirrorBonus  "`n" gmX "==" gmXa "==" vpSymmetryPointX, , , 2
       } Else If (CustomShapeSymmetry=2 && vpSymmetryPointY)
       {
          vpSymY := Round(vpSymmetryPointY) - (vpSymmetryPointYdp - prevDestPosY)
          gmYa := vpSymY - (gmY - vpSymY)
          If (gmY<vpSymY)
          {
             gmc := gmY,  gmd := gmYa
             gmYa := gmY, gmY := gmd
          }
          PointsListArray.InsertAt(1, gmX)
          PointsListArray.InsertAt(2, gmYa)
       }

       PointsListArray.Push(gmX)
       PointsListArray.Push(gmY)
    }
    ; ToolTip, % gmX "--" gmY , , , 2
    ; ToolTip, % tensionCurveCustomShape "=t" , , , 2
    If (PenuDrawLive && isInRange(PointsListArray.Count(), 3, 4))
    {
       Gdip_SetPenWidth(pPen4, imgHUDbaseUnit//11)
       Gdip_DrawLines(Gu, pPen4, PointsListArray)
    } Else If (PenuDrawLive && PointsListArray.Count()>4)
    {
       thisPath := Gdip_CreatePath()
       createPathVectorCustomShape(thisPath, PointsListArray, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, 0, 0, 0)
       If (drawingVectorLiveMode=1 || drawingVectorLiveMode=3)
          Gdip_DrawPath(Gu, PenuDrawLive, thisPath)
       Else
          Gdip_FillPath(Gu, PenuDrawLive, thisPath)
       Gdip_DeletePath(thisPath)
    }

    If (dontAddPoint!=-1 && vpImgPanningNow=0)
    {
       If (customShapeHasSelectedPoints=1)
          Gdip_SetPenWidth(pPen7, SelDotsSize//2.5 + 1)

       If (mustSnapLiveDrawPoints=1)
       {
          ; draw snap indicator
          Gdip_SetPenWidth(pPen1d, thisThick)
          thisPx :=  (customShapeHasSelectedPoints=1) ? firstPx : lastPx
          thisPy :=  (customShapeHasSelectedPoints=1) ? firstPy : lastPy
          Gdip_DrawLine(Gu, pPen1d, thisPx - sz, thisPy, thisPx + sz, thisPy)
          Gdip_DrawLine(Gu, pPen1d, thisPx, thisPy - sz, thisPx, thisPy + sz)
       }

       If (bezierSplineCustomShape=1)
          thisPath := Gdip_CreatePath()

       k := 0
       Loop, % totalz
       {
           ; draw the vector points
           xu := PointsListArray[A_Index*2 - 1], yu := PointsListArray[A_Index*2]
           k := (bezierSplineCustomShape=1) ? clampInRange(k + 1, 1, 3, 1) : 1
           sl := (k=1) ? SelDotsSize : SelDotsSize//2 + 1
           slz := sl//2 + 1
           If (k=1 && A_Index>1 && A_Index<totalz)
           {
              ; prepare the list of lines to draw formed by anchors connected to the main/key points
              xA := PointsListArray[(A_Index + 1)*2 - 1], yA := PointsListArray[(A_Index + 1)*2]
              xB := PointsListArray[(A_Index + 3)*2 - 1], yB := PointsListArray[(A_Index + 3)*2]
              xC := PointsListArray[(A_Index - 1)*2 - 1], yC := PointsListArray[(A_Index - 1)*2]
              If isDotInRect(xA, yA, slz, slz, xB, yB, 1)
                 j := fAddPathLine(thisPath, xC, yC, xu, yu)
              Else If isDotInRect(xC, yC, slz, slz, xu, yu, 1)
                 j := fAddPathLine(thisPath, xu, yu, xA, yA)
              Else
                 j := fAddPathLines(thisPath, [xC, yC, xu, yu, xA, yA])

              If !j
                 Gdip_StartPathFigure(thisPath)
           }

           selu := initialDrawingStartCoords[A_Index, 3]
           thisState := "a" xu yu
           highl := 0
           If (prevState=thisState)
           {
              highl := pselu
              counter++
           } else counter := 0

           If (prevState!=thisState || counter<3 && k=1)
           {
              pselu := (A_Index=dontAddPoint) ? 1 : 0
              prevState := thisState
              If (A_Index=dontAddPoint || highl=1)
                 Gdip_FillRectangle(Gu, pBrushE, xu - sl, yu - sl, sl*2, sl*2)

              whichBrush := (selu=1) ? pBrushA : pBrushD
              If (A_Index=dontAddPoint || highl=1)
                 Gdip_FillRectangle(Gu, pWhite, xu - sl//2, yu - sl//2, sl, sl)
              Else
                 Gdip_FillRectangle(Gu, whichBrush, xu - sl//2, yu - sl//2, sl, sl)

              If (A_Index=1)
                 Gdip_FillEllipse(Gu, pBrushZ, xu - SelDotsSize//4, yu - SelDotsSize//4, SelDotsSize//2, SelDotsSize//2)

              If (selu=1) ; || highl=1)
                 Gdip_DrawRectangle(Gu, pPen7, xu - sl//2, yu - sl//2, sl, sl)
           } ; else skipped++
           ; ToolTip, % skipped "=" skopped , , , 2
       }

       If (thisPath!="" && bezierSplineCustomShape=1)
       {
          ; draw the lines formed by anchors and the main/key points
          Gdip_SetPenWidth(pPen1d, SelDotsSize//5 + 1)
          Gdip_AddPathLine(thisPath, PointsListArray[1*2 - 1], PointsListArray[1*2], PointsListArray[2*2 - 1], PointsListArray[2*2]) ; first anchor
          Gdip_StartPathFigure(thisPath)
          Gdip_AddPathLine(thisPath, PointsListArray[totalz * 2 - 3], PointsListArray[totalz * 2 - 2], PointsListArray[totalz * 2 - 1], PointsListArray[totalz * 2]) ; last anchor
          Gdip_DrawPath(Gu, pPen1d, thisPath)
          Gdip_DeletePath(thisPath)
       }
    } 

    doNormalCursor := (dontAddPoint!=0 || vpImgPanningNow=1) ? 1 : 0
    interfaceThread.ahkassign("doNormalCursor", doNormalCursor)
}

getVPcustomShapePath(PointsListArray) {
    thisIndex := 0
    newArrayu := []
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       fX := prevResizedVPimgW/initialDrawingStartCoords[A_Index, 4]
       fY := prevResizedVPimgH/initialDrawingStartCoords[A_Index, 5]
       xu := c[1]*fX - (initialDrawingStartCoords[A_Index, 1]*fX - prevDestPosX)
       newArrayu[thisIndex] := xu

       thisIndex++
       yu := c[2]*fY - (initialDrawingStartCoords[A_Index, 2]*fY - prevDestPosY)
       newArrayu[thisIndex] := yu
    }

    pPath := Gdip_CreatePath()
    createPathVectorCustomShape(pPath, newArrayu, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, 0, 0, 0)
    Return [pPath, newArrayu]
}

convertCustomShape2relativeCoords(PointsListArray) {
    ; this function is executed when user exits vector path editing mode
    ; called from stopDrawingShape()
    If (PointsListArray.Count()<3)
       Return

    obju := getVPcustomShapePath(PointsListArray)
    pPath := obju[1]
    newArrayu := obju[2]
    Rect := getAccuratePathBounds(pPath)
    minXu := Rect.X,  minYu := Rect.Y
    maxXu := Rect.X + Rect.W, maxYu := Rect.Y + Rect.H

    MouseCoords2Image(minXu, minYu, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX1, imgSelY1)
    MouseCoords2Image(maxXu, maxYu, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX2, imgSelY2)

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    defineRelativeSelCoords(imgW, imgH)
    initialCustomShapeCoords := imgSelX1 "|" imgSelY1 ; i forgot what this is for ^_^ 
    RegAction(1, "initialCustomShapeCoords")
    mW := Rect.W
    mH := maxYu - minYu

    newShape := []
    thisIndex := 0
    maxindexu := newArrayu.Count()
    Loop
    {
       thisIndex++
       xu := (newArrayu[thisIndex] - minXu) / Rect.W

       thisIndex++
       yu := (newArrayu[thisIndex] - minYu) / Rect.H
       newShape[A_Index] := [xu, yu]
       If (thisIndex>=maxIndexu)
          Break
    }

    Return newShape
}

adjustCustomShapePositionLive(dir:=0) {
    Static lastInvoked := 1
    If (customShapePoints.Count()<3)
       Return

    stepuX := stepuY := 0
    If (Abs(dir)=1)
       stepuX := (dir=1) ? 2 : -2

    If (Abs(dir)=2)
       stepuY := (dir=2) ? 2 : -2

    If (A_TickCount - lastInvoked<400)
    {
       stepuX *= 2
       stepuY *= 2
    }

    newArrayu := []
    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       selu := initialDrawingStartCoords[A_Index, 3]
       tstepuX := (customShapeHasSelectedPoints=1 && selu=1 || customShapeHasSelectedPoints!=1) ? stepuX : 0
       tstepuY := (customShapeHasSelectedPoints=1 && selu=1 || customShapeHasSelectedPoints!=1) ? stepuY : 0
       xu := c[1] - tstepuX
       yu := c[2] - tstepuY
       newArrayu[thisIndex] := [xu, yu]
    }

    lastZeitFileSelect := A_TickCount
    If (thisIndex>2)
       customShapePoints := newArrayu.Clone()
    lastInvoked := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

convertCustomShape2givenArea(PointsListArray, refX, refY, refW, refH, returnArray:=1, filterPointDupes:=0) {
    ; this assumes drawingShapeNow=0
    ; values must be in the range of 0 to 1 for the coord entries in PointsListArray
    If (PointsListArray.Count()<3)
       Return

    If (returnArray=1)
       newArrayu := []
    Else
       newShape := ""

    If (filterPointDupes=1)
       deduper := new hashtable()

    thisIndex := 0
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       xu := refW * c[1] + refX
       yu := refH * c[2] + refY
       puf := "a" Round(xu) Round(yu)
       If (xu="" || yu="" || deduper[puf]=1)
          Continue

       thisIndex++
       If (filterPointDupes=1)
          deduper[puf] := 1
   
       If (returnArray=1)
       {
          newArrayu[thisIndex*2 - 1] := xu
          newArrayu[thisIndex*2 + 1 - 1] := yu
       } Else newShape .= xu "," yu "|"
       ; newShape .= Round(xu) "," Round(yu) "|"
    }

    deduper := ""
    ; ToolTip, % newShape , , , 2
    If (returnArray=1)
       Return newArrayu
    Else
       Return Trimmer(newShape, "|")
}

convertShapePointsArrayToStr(PointsListArray) {
    If (PointsListArray.Count()<3)
       Return

    newShape := ""
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       newShape .= c[1] "," c[2] "|"
    }

    Return Trimmer(newShape, "|")
}

convertShapePointsStrToArray(PointsList, offX:=0, offY:=0) {
    If !InStr(PointsList, "|")
       Return

    newShape := []
    ; newArrayu := new hashtable()
    ogmX := ogmY := 0
    Loop, Parse, PointsList, "|"
    {
       c := StrSplit(A_LoopField, ",")
       ogmX := c[1]
       ogmY := c[2]
       If (ogmX="" || ogmY="") ; || newArrayu[ogmX ogmY]=1)
          Continue

       thisIndex++
       ; newArrayu[ogmX ogmY] := 1
       newShape[thisIndex] := [ogmX + offX, ogmY + offY]
    }

    ; newArrayu := ""
    If (newShape.Count()<3)
       Return
    ; ToolTip, % A_ThisFunc "=" thisIndex "=" ogmX "=" ogmY "n" FillAreaCurveTension "=" tensionCurveCustomShape , , , 2
    Return newShape
}

additionalHUDelements(mode, mainWidth, mainHeight, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0, directRefresh:=0) {
    Critical, on

    If (imgEditPanelOpened=1 && AnyWindowOpen!=10 && drawingShapeNow!=1 && imgSelOutViewPort!=1)
    {
       If (vpImgPanningNow>0)
       {
          Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
          r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, 2NDglHDC)
          r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
       } Else livePreviewsImageEditing("coords")
    }

    Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
    If (dynamicLiveObjVisible=0)
       toggleLiveEditObject()

    setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
    ; If (showViewPortGrid=1)
    ;    drawVPgridsNow(mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, 2NDglPG)

    If (drawingShapeNow=1)
       drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG)
    Else If (editingSelectionNow=1 && mode=2)
       drawImgSelectionOnWindow("prev", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=1)
       drawImgSelectionOnWindow("active", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=3)
       drawImgSelectionOnWindow("return", "-", "-", "-", mainWidth, mainHeight)

    If (AnyWindowOpen=64 && BrushToolType=3) || (AnyWindowOpen=23 && FillAreaColorMode=6) 
    || isVarEqualTo(AnyWindowOpen, 69, 44, 43, 26)
    {
       ImageCoords2Window(tinyPrevAreaCoordX, tinyPrevAreaCoordY, prevDestPosX, prevDestPosY, SelDotsSize, outX, outY)
       Gdip_FillRectangle(2NDglPG, pBrushE, outX, outY, SelDotsSize, SelDotsSize)
       Gdip_DrawRectangle(2NDglPG, pPen1d, outX, outY, SelDotsSize, SelDotsSize)
    }

    If (showImgAnnotations=1 && !AnyWindowOpen && drawingShapeNow!=1 && currentUndoLevel<3)
       drawAnnotationBox(mainWidth, mainHeight, 2NDglPG)
    Else
       interfaceThread.ahkPostFunction("uiAccessUpdateAnnoBox", "hide", 1, 1, 0, 0)

    If (showInfoBoxHUD>=1 && drawingShapeNow!=1)
       drawinfoBox(mainWidth, mainHeight, directRefresh, 2NDglPG)
    Else
       interfaceThread.ahkPostFunction("uiAccessUpdateInfoBox", "hide", 1, 1, 0, 0)

    If (showHUDnavIMG=1 && IMGlargerViewPort=1 && slideShowRunning!=1)
       VPnavBoxWrapper(mainWidth, mainHeight, 2NDglPG)
    Else
       interfaceThread.ahkPostFunction("uiAccessUpdateNavBox", "hide", 1, 1, 0, 0)

    thisThick := imgHUDbaseUnit//11
    Gdip_SetPenWidth(pPen4, thisThick)
    isSymmetryAllowed := (AnyWindowOpen=64 && BrushToolType<4 && liveDrawingBrushTool=1) || (drawingShapeNow=1 && !AnyWindowOpen) ? 1 : 0
    ccX := (drawingShapeNow=1) ? Round(vpSymmetryPointX) - (vpSymmetryPointXdp - prevDestPosX) : prevDestPosX + Round(prevResizedVPimgW * BrushToolSymmetryPointX)
    ccY := (drawingShapeNow=1) ? Round(vpSymmetryPointY) - (vpSymmetryPointYdp - prevDestPosY) : prevDestPosY + Round(prevResizedVPimgH * BrushToolSymmetryPointY)
    If ((BrushToolSymmetryX=1 || CustomShapeSymmetry=1) && isSymmetryAllowed=1)
       Gdip_DrawLine(2NDglPG, pPen4, ccX - thisThick//4, 0, ccX - thisThick//4, mainHeight)
    If ((BrushToolSymmetryY=1 || CustomShapeSymmetry=2) && isSymmetryAllowed=1)
       Gdip_DrawLine(2NDglPG, pPen4, 0, ccY - thisThick//4, mainWidth, ccY - thisThick//4)

    Gdip_ResetWorldTransform(2NDglPG)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectwin, 2NDglHDC)
}

toggleLiveEditObject(dummy:=0) {
   dynamicLiveObjVisible := !dynamicLiveObjVisible
   If (dummy="hide")
      dynamicLiveObjVisible := 1

   ;  TOOLTIP, % "l= " dynamicLiveObjVisible , , , 2
   actu := (dynamicLiveObjVisible!=1) ? "hide" : "show"
   ToggleVisibilityWindow(actu, hGDIselectwin)
   ToggleVisibilityWindow(actu, hGDIwin)
   If (actu="hide")
   {
      trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
      r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectwin, 2NDglHDC)
   }
}

getColorMatrix() {
    Static prevMatrix, prevState

    thisState := "a" ForceNoColorMatrix AnyWindowOpen imgFxMode bwDithering lumosGrayAdjust GammosGrayAdjust lumosAdjust GammosAdjust satAdjust IntensityAlphaChannel chnRdecalage chnGdecalage chnBdecalage
    If (thisState=prevState)
       Return prevMatrix

    matrix := ""
    fraction := (isWinXP=1) ? 0.0001 : 0
    If (ForceNoColorMatrix=1 && AnyWindowOpen=10) || (imgFxMode=1)
       Return matrix

    If (imgFxMode=4 && !bwDithering)       ; grayscale
       matrix := GenerateColorMatrix(2, lumosGrayAdjust, GammosGrayAdjust + fraction, , IntensityAlphaChannel)
    Else If (imgFxMode=5)  ; grayscale R
       matrix := GenerateColorMatrix(3, , , , IntensityAlphaChannel)
    Else If (imgFxMode=6)  ; grayscale G
       matrix := GenerateColorMatrix(4, , , , IntensityAlphaChannel)
    Else If (imgFxMode=7)  ; grayscale B
       matrix := GenerateColorMatrix(5, , , , IntensityAlphaChannel)
    Else If (imgFxMode=8)  ; alpha channel
       matrix := GenerateColorMatrix(7)
    Else If (imgFxMode=9)  ; negative / invert
       matrix := GenerateColorMatrix(6, , , , IntensityAlphaChannel)
    Else If (imgFxMode=10)  ; sepia
       matrix := GenerateColorMatrix(8, , , , IntensityAlphaChannel)
    Else If (imgFxMode=2 || imgFxMode=3) ; personalized
       matrix := GenerateColorMatrix(1, lumosAdjust, GammosAdjust + fraction, satAdjust, IntensityAlphaChannel, chnRdecalage, chnGdecalage, chnBdecalage)

    prevMatrix := matrix
    prevState := thisState
    Return matrix
}

decideGDIPimageFX(ByRef matrix, ByRef imageAttribs, ByRef pEffect) {
    Static colorzFX := {1:0, 2:5, 3:6, 4:7, 5:8, 6:9, 7:11}
    infos := matrix := imageAttribs := pEffect := ""
    matrix := getColorMatrix()
    If (thumbsDisplaying=1 && (imgFxMode=3 || imgFxMode=8))
       matrix := ""
    ; ToolTip, % matrix , , , 2
    thisFXapplies := isVarEqualTo(imgFxMode, 2, 3, 4, 9, 10)
    mustCreateAttribs := (realGammos!=1 && imgThreshold=0 && !matrix) ? 0 : 1
    If (mustCreateAttribs=1 && ForceNoColorMatrix!=1 && imgFxMode>1)
    {
       imageAttribs := Gdip_CreateImageAttributes()
       Gdip_SetImageAttributesColorMatrix(matrix, imageAttribs)
       ; Gdip_SetImageAttributesWrapMode(imageAttribs, 3)
       If (imgThreshold>0 && thisFXapplies=1)
       {
          infos := "moreThanClrMatrix"
          Gdip_SetImageAttributesThreshold(imageAttribs, imgThreshold)
       }

       If (realGammos!=1 && thisFXapplies=1)
       {
          infos := "moreThanClrMatrix"
          Gdip_SetImageAttributesGamma(imageAttribs, realGammos)
       }
    }

    If (isWinXP=1)
       Return "a" thisFXapplies lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold thisZatAdjust mustCreateAttribs imgFxMode ForceNoColorMatrix matrix zatAdjust infos

    o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    thisZatAdjust := (imgFxMode=4 && !bwDithering && zatAdjust=0) ? -40 : zatAdjust
    If ((thisZatAdjust=0 && hueAdjust=0 && lummyAdjust=0) || !colorzFX[specialColorFXmode] || ForceNoColorMatrix=1)
       applyAdjusts := 0

    If (thisFXapplies=1 && applyAdjusts!=0 && o_bwDithering=0 && specialColorFXmode>1)
    {
       paramA := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXmode : hueAdjust
       paramB := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXchannel : thisZatAdjust
       If (colorzFX[specialColorFXmode]=1)
          paramB := 0

       pEffect := Gdip_CreateEffect(colorzFX[specialColorFXmode], paramA, paramB, lummyAdjust)
    }

    Return "a" paramA paramB infos thisFXapplies thisZatAdjust applyAdjusts o_bwDithering mustCreateAttribs getIDvpFX()
}

getIDvpFX() {
    Return "a" specialColorFXmode uiColorCurveFXchannel uiColorCurveFXmode lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold imgFxMode ForceNoColorMatrix zatAdjust satAdjust hueAdjust chnRdecalage chnGdecalage chnBdecalage IntensityAlphaChannel
}

testSelectOutsideImgEntirely(pBitmap) {
     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nimgSelX2 := max(imgSelX1, imgSelX2)
     nimgSelY2 := max(imgSelY1, imgSelY2)

     Gdip_GetImageDimensions(pBitmap, imgW, imgH)
     If (nimgSelX1<0)
        nimgSelX1 := 0
     If (nimgSelY1<0)
        nimgSelY1 := 0

     If (nimgSelX2<5)
        nimgSelX2 := 1
     If (nimgSelY2<5)
        nimgSelY2 := 1

     If (nimgSelX1>imgW-5)
        nimgSelX1 := ImgW-1
     If (nimgSelY1>ImgH-5)
        nimgSelY1 := imgH-1

     If (nimgSelX2>imgW)
        nimgSelX2 := imgW
     If (nimgSelY2>imgH)
        nimgSelY2 := imgH

     isOutside := 0
     imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     If (imgSelW<3 || imgSelH<3)
        isOutside := 1

     ; If (nimgSelX1<2 && nimgSelY1<2 && nimgSelX2<5 && nimgSelY2<5)
     ;    isOutside := 1

     ; If (nimgSelX1>ImgW-5 && nimgSelY1>imgH-5 && nimgSelX2>imgW && nimgSelY2>imgH)
     ;    isOutside := 1
     Return isOutside
}

ViewPortSelectionManageCoords(mainWidth, mainHeight, dpX, dpY, maxSelX, maxSelY, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, ByRef zImgSelX1, ByRef zImgSelY1, ByRef zImgSelX2, ByRef zImgSelY2, ByRef vPimgSelW, ByRef vPimgSelH, ByRef vPimgSelPx, ByRef vPimgSelPy) {
     If (LimitSelectBoundsImg=1)
     {
        If (imgSelX1<0)
           imgSelX1 := 0
        If (imgSelY1<0)
           imgSelY1 := 0
 
        If (imgSelX2<2)
           imgSelX2 := 2
        If (imgSelY2<2)
           imgSelY2 := 2
     }

     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nimgSelX2 := max(imgSelX1, imgSelX2)
     nimgSelY2 := max(imgSelY1, imgSelY2)

     If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     kimgSelRatio := Round(kimgSelW/kimgSelH, 2)

     If (LimitSelectBoundsImg!=1 && lockSelectionAspectRatio>1 && kimgSelRatio!=Round(desiredSelAspectRatio, 2) && desiredSelAspectRatio && !adjustingSelDotNow)
     {
        avgWH := min(kimgSelW, kimgSelH)
        nimgSelX2 := nimgSelX1 + Round(avgWH*desiredSelAspectRatio)
        nimgSelY2 := nimgSelY1 + avgWH
     }

     If (kimgSelW>32500)
        nImgSelX2 := nImgSelX1 + 32500
     If (kimgSelH>32500)
        nImgSelY2 := nImgSelY1 + 32500
     If (kimgSelH*kimgSelW>23125**2)
     {
        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        scaleu := (kimgSelH*kimgSelW)/(23125**2)
        nImgSelX2 := nImgSelX1 + Floor(kimgSelW/scaleu)
        nImgSelY2 := nImgSelY1 + Floor(kimgSelH/scaleu)
        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        If (kimgSelW>32500)
           nImgSelX2 := nImgSelX1 + 32500
        If (kimgSelH>32500)
           nImgSelY2 := nImgSelY1 + 32500
     }

     If (editingSelectionNow=1)
        defineRelativeSelCoords(maxSelX, maxSelY)

     If (LimitSelectBoundsImg=1)
        capSelectionRelativeCoords()

     zImgSelX1 := Round(nImgSelX1*zoomLevel)
     zImgSelX2 := Round(nImgSelX2*zoomLevel)
     zImgSelY1 := Round(nImgSelY1*zoomLevel)
     zImgSelY2 := Round(nImgSelY2*zoomLevel)

     minSizu := SelDotsSize*2
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<minSizu)
        vPimgSelW := minSizu
     If (vPimgSelH<minSizu)
        vPimgSelH := minSizu

     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)

     minMargin := 2 ; (mainWidth*0.025 + mainHeight*0.205)//2
     imgSelLargerViewPort := (vPimgSelPx<minMargin && vPimgSelPy<minMargin) && (vPimgSelPx + vPimgSelW>mainWidth - minMargin) && (vPimgSelPy + vPimgSelH>mainHeight - minMargin) ? 1 : 0
     imgSelOutViewPort := 0
     If (vPimgSelPx>mainWidth - minSizu)
     {
        vPimgSelPx := mainWidth - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy>mainHeight - minSizu)
     {
        vPimgSelPy := mainHeight - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPx + vPimgSelW<minSizu)
     {
        vPimgSelW := minSizu*2
        vPimgSelPx := -minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy + vPimgSelH<minSizu)
     {
        vPimgSelH := minSizu*2
        vPimgSelPy := -minSizu
        imgSelOutViewPort := 1
     }

     dotsSize := SelDotsSize//2
     selDotX := vPimgSelPx - dotsSize
     selDotY := vPimgSelPy - dotsSize
     selDotAx := vPimgSelPx + vPimgSelW - dotsSize
     selDotAy := vPimgSelPy + vPimgSelH - dotsSize
     selDotBx := vPimgSelPx + vPimgSelW - dotsSize
     selDotBy := vPimgSelPy - dotsSize
     selDotCx := vPimgSelPx - dotsSize
     selDotCy := vPimgSelPy + vPimgSelH - dotsSize
     selDotDx := vPimgSelPx + vPimgSelW//2 - dotsSize
     selDotDy := vPimgSelPy + vPimgSelH//2 - dotsSize
     selDotMaX := vPimgSelPx + vPimgSelW//2 - dotsSize
     selDotMaY := vPimgSelPy - dotsSize
     selDotMbX := vPimgSelPx + vPimgSelW - dotsSize
     selDotMbY := vPimgSelPy + vPimgSelH//2 - dotsSize
     selDotMcX := vPimgSelPx + vPimgSelW//2 - dotsSize
     selDotMcY := vPimgSelPy + vPimgSelH - dotsSize
     selDotMdX := vPimgSelPx - dotsSize
     selDotMdY := vPimgSelPy + vPimgSelH//2 - dotsSize
     If ((AnyWindowOpen=31 || AnyWindowOpen=24) && imgEditPanelOpened=1)
        prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY)
}

prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY) {
     If (LimitSelectBoundsImg=1)
     {
        If (previmgSelX1<0)
           previmgSelX1 := 0
        If (previmgSelY1<0)
           previmgSelY1 := 0
 
        If (previmgSelX2<2)
           previmgSelX2 := 2
        If (previmgSelY2<2)
           previmgSelY2 := 2
     }

     nImgSelX1 := min(previmgSelX1, previmgSelX2)
     nImgSelY1 := min(previmgSelY1, previmgSelY2)
     nimgSelX2 := max(previmgSelX1, previmgSelX2)
     nimgSelY2 := max(previmgSelY1, previmgSelY2)

     If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     zImgSelX1 := Round(nImgSelX1*zoomLevel)
     zImgSelX2 := Round(nImgSelX2*zoomLevel)
     zImgSelY1 := Round(nImgSelY1*zoomLevel)
     zImgSelY2 := Round(nImgSelY2*zoomLevel)
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<2)
        vPimgSelW := 2
     If (vPimgSelH<2)
        vPimgSelH := 2

     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)
     dotsSize := SelDotsSize
     prevSelDotX := vPimgSelPx - dotsSize//2
     prevSelDotY := vPimgSelPy - dotsSize//2
     prevSelDotAx := vPimgSelPx + vPimgSelW - dotsSize//2
     prevSelDotAy := vPimgSelPy + vPimgSelH - dotsSize//2
}

createPathVectorCustomShape(ImgSelPath, ByRef PointsList, tension, isClosed, isBezier, zeroTension:=0, allowAutoFix:=1, allowCloseOpenAuto:=1) {
   If (allowAutoFix=1 && isBezier=1)
   {
      ; auto-fix uneven paths
      PointsCount := PointsList.Count()
      r := mod(PointsCount//2, 3)
      ; ToolTip, % "r=" r, , , 2
      xu := PointsList[PointsCount - 1], yu := PointsList[PointsCount]
      loops := (r=2) ? 2 : 1
      If (r=1)
         loops := 0

      Loop, % loops
         PointsList.Push(xu, yu)
   }

   If (allowCloseOpenAuto=1)
   {
      r := testIsBezierAltPathClosed(PointsList)
      If (isClosed=1 && r=0 && isBezier=1)
      {
         thisIndex := PointsList.Count()//2 - 1
         xA := PointsList[1],            yA := PointsList[2]
         PointsList.Push(xA, yA)
         loops := (PointsList.Count()//2 > 4) ? 2 : 1
         Loop, % loops
            PointsList.Push(xA, yA)

         ; ToolTip, %  thisIndex "=l=" PointsList.Count()//2 "`n" xA "==" yA , , , 2
         reflectGivenAnchorInAltPath(PointsList, 2, PointsList.Count()//2 - 1, 1)
         reflectGivenAnchorInAltPath(PointsList, thisIndex, thisIndex + 2, thisIndex + 1)
      } Else If (isClosed=0 && r=1)
      {
         loops := ((PointsList.Count()//2 - 2) >= 4) ? 3 : 2
         If (isBezier!=1)
            loops := 1

         Loop, % loops * 2
            PointsList.Pop()

         While, (testIsBezierAltPathClosed(PointsList)=1)
         {
            loops := ((PointsList.Count()//2 - 2) >= 4) ? 3 : 2
            If (isBezier!=1)
               loops := 1

            Loop, % loops * 2
               PointsList.Pop()

            If (A_Index>10)
               Break
         }
      }
   }

   If (isBezier=1)
      Gdip_AddPathBeziers(ImgSelPath, PointsList)
   Else If ((tension=1 || zeroTension=1) && isClosed=1)
      Gdip_AddPathPolygon(ImgSelPath, PointsList)
   Else If ((tension=1 || zeroTension=1) && isClosed=0)
      Gdip_AddPathLines(ImgSelPath, PointsList)
   Else If isClosed
      Gdip_AddPathClosedCurve(ImgSelPath, PointsList, tensionCurveCustomShape)
   Else
      Gdip_AddPathCurve(ImgSelPath, PointsList, tensionCurveCustomShape)
}

createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, ellipse, angleu:=0, keepBounds:=0, zeroTension:=0, allowSelectionCenter:=1, allowCavity:=1, selCavityX:=0, selCavityY:=0) {
   ImgSelPath := Gdip_CreatePath()
   If (ImgSelPath="")
      Return

   If (ellipse=2)
   {
      PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, !bezierSplineCustomShape)
      createPathVectorCustomShape(ImgSelPath, PointsList, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, zeroTension)
   } Else If (ellipse=1)
      Gdip_AddPathEllipse(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
   Else
      Gdip_AddPathRectangle(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)

   If (selCavityX>0.01 && selCavityY>0.01 && allowCavity=1)
   {
      zX := imgSelW * selCavityX
      zY := imgSelH * selCavityY
      nimgSelPx := imgSelPx + zX , nimgSelPy := imgSelPy + zY
      nimgSelW := imgSelW - zX*2 , nimgSelH := imgSelH - zY*2

      If (ellipse=2)
      {
         PointsList := convertCustomShape2givenArea(customShapePoints, nimgSelPx, nimgSelPy, nimgSelW, nimgSelH, 1, !bezierSplineCustomShape)
         createPathVectorCustomShape(ImgSelPath, PointsList, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, zeroTension)
      } Else If (ellipse=1)
         Gdip_AddPathEllipse(ImgSelPath, nimgSelPx, nimgSelPy, nimgSelW, nimgSelH)
      Else
         Gdip_AddPathRectangle(ImgSelPath, nimgSelPx, nimgSelPy, nimgSelW, nimgSelH)
   }

   If angleu
      trGdip_RotatePathAtCenter(ImgSelPath, angleu, 1, 1, keepBounds, 1)

   If (ellipse=2 && allowSelectionCenter=1)
      vpFreeformShapeOffset := centerPath2bounds(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)

   ; Sleep, -1
   Return ImgSelPath
}

centerPath2bounds(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH, destinationPath:=0, scaleUniform:=1) {
   ; resize to bounding box
   Rect := getAccuratePathBounds(ImgSelPath)
   pMatrix := Gdip_CreateMatrix()
   If (scaleUniform=1)
   {
      scaleu := min(imgSelW/Rect.w, imgSelH/Rect.h)
      Gdip_ScaleMatrix(pMatrix, scaleu, scaleu)
   } Else Gdip_ScaleMatrix(pMatrix, imgSelW/Rect.w, imgSelH/Rect.h)

   E := Gdip_TransformPath(ImgSelPath, pMatrix)
   If destinationPath
      E := Gdip_TransformPath(destinationPath, pMatrix)
   Gdip_DeleteMatrix(pMatrix)

   ; center to bounding box
   Rect := getAccuratePathBounds(ImgSelPath)
   cX := imgSelPx + imgSelW/2
   cY := imgSelPy + imgSelH/2
   rX := Rect.x + Rect.w/2
   rY := Rect.y + Rect.h/2
   nX := max(cX, rX) - min(cX, rX)
   nY := max(cY, rY) - min(cY, rY)
   nX := (rX>cX) ? -nX : nX
   nY := (rY>cY) ? -nY : nY
   ; ToolTip, % nX "=" nY , , , 2
   obju := []
   pMatrix := Gdip_CreateMatrix()
   obju := [nX, nY, scaleu, VPselRotation, innerSelectionCavityX, innerSelectionCavityY, EllipseSelectMode, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape]
   Gdip_TranslateMatrix(pMatrix, nX, nY)
   E := Gdip_TransformPath(ImgSelPath, pMatrix)
   If destinationPath
      E := Gdip_TransformPath(destinationPath, pMatrix)

   Gdip_DeleteMatrix(pMatrix)
   ; RectE := getAccuratePathBounds(ImgSelPath)
   ; Gdip_GetPathLastPoint(ImgSelPath, zX, zY)
   ; obju := [nX, nY, scaleu, VPselRotation, RectE.x, RectE.y, RectE.w, RectE.h, zX, zY]
   Return obju
}

getAccuratePathBounds(pPath, doRound:=0) {
   Gdip_ResetClip(dummyGu)
   Gdip_SetClipPath(dummyGu, pPath)
   Rect := Gdip_GetClipBounds(dummyGu)
   If (!Rect.w || !Rect.h)
      Rect := Gdip_GetPathWorldBounds(pPath)

   If (doRound=1)
   {
      Rect.x := Round(Rect.x)
      Rect.y := Round(Rect.y)
      Rect.w := Round(Rect.w)
      Rect.h := Round(Rect.h)
   }
   Return Rect
}

decideLiveSelectionBasedOnWindow(ByRef angleu, ByRef okay) {
   okay := (imgEditPanelOpened!=1 || isVarEqualTo(AnyWindowOpen, 10, 25, 55, 64, 66, 68, 74) || AnyWindowOpen=65 && EllipseSelectMode || AnyWindowOpen=23 && EllipseSelectMode) ? 1 : 0
   angleu := (okay=1) ? VPselRotation : 0
}

drawImgSelectionOnWindow(operation, theMsg:="", colorBox:="", dotActive:="", mainWidth:=0, mainHeight:=0, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0, snappyX:=0, snappyY:=0) {
     Static prevMsg, infoBoxBMP, lineThickns, infoW, infoH, pBr0, zPen
          , infoPosX, infoPosY, prevuDPx, prevuDPy, prevNewW, prevNewH

     SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
     If !identifyThisWin()
        SelDotsSize := dotsSize := dotsSize//2 + 1

     maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
     allowControls := isNowAlphaPainting() || (liveDrawingBrushTool=1 && AnyWindowOpen=64) || (FloodFillSelectionAdj!=1 && AnyWindowOpen=66) ? 0 : 1
     decideLiveSelectionBasedOnWindow(angleu, isAngleu)
     ; ForceRefreshNowThumbsList()
     If (operation="return" || operation="faker")
     {
        o_operation := operation
        operation := "active"
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        newW := prevNewW, newH := prevNewH
        ; DestPosX := prevuDPx, DestPosY := prevuDPy
        DestPosX := prevDestPosX, DestPosY := prevDestPosY
        ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
     }

     If !zPen
     {
        zPen := Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10)
        ; Gdip_SetPenDashArray(zPen, "0.2|0.2")
     }

     If (operation="init")
     {
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
        If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
           clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIselectWin)

        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        ; Gdip_ResetWorldTransform(2NDglPG)
        setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
        InfoW := InfoH := ""
        lineThickns := imgHUDbaseUnit//9
        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//13)
     } Else If (operation="prev")
     {
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        lineThickns :=  imgHUDbaseUnit//10
        Gdip_SetPenWidth(pPen1, lineThickns)
        ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio, 0, 1, isAngleu, innerSelectionCavityX, innerSelectionCavityY)
        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//7)
        Gdip_DrawPath(2NDglPG, zPen, ImgSelPath)
        Gdip_DrawPath(2NDglPG, pPen1, ImgSelPath)

        Gdip_ResetClip(2NDglPG)
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)
     } Else If (operation="active")
     {
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        lineThickns := (editingSelectionNow!=1) ? imgHUDbaseUnit//13 : imgHUDbaseUnit//9

        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//12)
        pPen := (editingSelectionNow=1) ? pPen1d : pPen1
        Gdip_SetPenWidth(pPen, lineThickns)
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)

        ViewPortSelectionManageCoords(mainWidth, mainHeight, DestPosX, DestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 

        If (o_operation!="faker")
        {
           ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio, 0, 1, isAngleu, innerSelectionCavityX, innerSelectionCavityY)
           If (showSelectionGrid=1)
           {
              Sleep, 1
              Gdip_SetClipPath(2NDglPG, ImgSelPath, 0)
              pathBounds := Gdip_GetClipBounds(2NDglPG)
              Gdip_ResetClip(2NDglPG)
           }
           ; Gdip_FillRectangle(2NDglPG, pBrushC, imgSelPx, imgSelPy, imgSelW, imgSelH)
           whichPen := (EllipseSelectMode>0) ? zPen : pPen
           Gdip_DrawPath(2NDglPG, whichPen, ImgSelPath)
           ; If (EllipseSelectMode=1) || ((showSelectionGrid=1 || imgSelLargerViewPort=1) && (EllipseSelectMode!=1))
              ; Gdip_DrawEllipse(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
           If (EllipseSelectMode>0 && AnyWindowOpen!=23)
              Gdip_DrawPath(2NDglPG, pPen, ImgSelPath)

           thisExterior := (editingSelectionNow=1) ? pBrushE : pBrushF
           Gdip_SetClipPath(2NDglPG, ImgSelPath, 4)
           If (imgEditPanelOpened!=1)
              Gdip_FillRectangle(2NDglPG, pBrushF, 0, 0, mainWidth, mainHeight)

           If (allowControls=1)
              Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
           If (imgEditPanelOpened!=1 && showSelectionGrid=1 && allowControls=1)
              Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)
        }

        Gdip_ResetClip(2NDglPG)
        If ((showSelectionGrid=1) || (imgSelLargerViewPort=1 && allowControls=1)) && (o_operation!="faker")
        {
           If (imgSelLargerViewPort=1)
           {
              Gdip_DrawRectangle(2NDglPG, whichPen, 1, 1, mainWidth - 1, mainHeight - 1)
              Gdip_DrawRectangle(2NDglPG, pPen, mainWidth*0.15, mainHeight*0.15, mainWidth - mainWidth*0.3, mainHeight - mainHeight*0.3)
           }
           Gdip_SetClipRect(2NDglPG, imgSelPx, imgSelPy, imgSelW, imgSelH, 0)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2)
           Gdip_ResetClip(2NDglPG)
        }

        If (FlipImgV=1)
           imgSelPy := mainHeight - imgSelPy - imgSelH
        If (FlipImgH=1)
           imgSelPx := mainWidth - imgSelPx - imgSelW

        If (imgSelLargerViewPort!=1 && allowControls=1 && o_operation!="faker")
        {
           whichFunc := (VPselRotation!=0) ? "Ellipse" : "Rectangle"
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
           If (AnyWindowOpen=31 || AnyWindowOpen=24)
           {
              Gdip_FillEllipse(2NDglPG, pBrushD, selDotMdX, selDotMdY, dotsSize, dotsSize)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotMaX, SelDotMaY, dotsSize, dotsSize)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotMbX, SelDotMbY, dotsSize, dotsSize)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotMcX, SelDotMcY, dotsSize, dotsSize)
           }
        }

        If (allowControls=1 && o_operation!="faker")
        {
           If (VPselRotation!=0)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)
           Gdip_FillEllipse(2NDglPG, pBrushE, SelDotDx, SelDotDy, dotsSize, dotsSize)
        }

        If ImgSelPath
           Gdip_DeletePath(ImgSelPath)
     } Else If (operation="live")
     {
        Sleep, 1
        lineThickns := imgHUDbaseUnit/9
        trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
        ViewPortSelectionManageCoords(mainWidth, mainHeight, prevuDPx, prevuDPy, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 

        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio, 0, 1, isAngleu, innerSelectionCavityX, innerSelectionCavityY)
        Gdip_SetPenWidth(pPen1d, lineThickns//2 + 1)
        Gdip_SetClipPath(2NDglPG, ImgSelPath, 0)
        pathBounds := Gdip_GetClipBounds(2NDglPG)
        Gdip_ResetClip(2NDglPG)
        Gdip_SetClipPath(2NDglPG, ImgSelPath, 4)
        If (imgEditPanelOpened!=1 && imgSelLargerViewPort!=1)
           Gdip_FillRectangle(2NDglPG, pBrushE, 0, 0, mainWidth, mainHeight)

        If (imgSelLargerViewPort!=1)
        {
           ; ToolTip, lol , , , 2
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
           Gdip_DrawLine(2NDglPG, zPen, zImgSelX1 + prevDestPosX, 0, zImgSelX1 + prevDestPosX, mainHeight)
           Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY1 + prevDestPosY, mainWidth, zImgSelY1 + prevDestPosY)
           Gdip_DrawLine(2NDglPG, zPen, zImgSelX2 + prevDestPosX, 0, zImgSelX2 + prevDestPosX, mainHeight)
           Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY2 + prevDestPosY, mainWidth, zImgSelY2 + prevDestPosY)
           Gdip_DrawRectangle(2NDglPG, pPen1d, imgSelPx, imgSelPy, imgSelW, imgSelH)
        }
        ; pathBounds := Gdip_GetPathWorldBounds(ImgSelPath)
        ; ToolTip, % pathBounds.x "=" pathBounds.y "`n" pathBounds.w "=" pathBounds.h , , , 2
        Gdip_ResetClip(2NDglPG)
        Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)
        If (IMGentirelylargerThanVP!=1) ; image boundaries
           Gdip_DrawRectangle(2NDglPG, pPen4, prevuDPx, prevuDPy, prevResizedVPimgW, prevResizedVPimgH)

        If (imgSelW>125 && imgSelH>125 && minimizeMemUsage!=1 && dotActive<10 && !InStr(theMsg, "offset"))
        {
           cornersPreview := coreCaptureImgCorners(useGdiBitmap(), 6, 100)
           Gdip_GetImageDimensions(cornersPreview, cImgW, cImgH)
           cX := imgSelPx + imgSelW//2 - cImgW//2
           cY := imgSelPy + imgSelH//2 - cImgH//2
           cX := clampInRange(cX, 0, mainWidth - cImgW)
           cY := clampInRange(cY, 0, mainHeight - cImgH)
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, cornersPreview, cX, cY)
           trGdip_DisposeImage(cornersPreview, 1)
        }

        If (minimizeMemUsage!=1)
        {
            If (dotActive=10)
            {
               theMsg := SubStr(theMsg, InStr(theMsg, "rotation"))
               fScale := 0.9
            } Else fScale := 1.3

           infoBoxBMP := drawTextInBox(theMsg, OSDFontName, OSDfontSize//fScale, mainWidth//2, mainHeight//2, OSDtextColor, OSDbgrColor, 1, 1)
           colorBoxH := colorBox ? imgHUDbaseUnit//7 : 1
           Gdip_GetImageDimensions(infoBoxBMP, infoW, infoH)
           If (imgSelPy + imgSelH + 5 < mainHeight - infoH)
           {
              infoPosY := (imgSelPy + imgSelH<5) ? 5 : imgSelPy + imgSelH + 20
              If (infoPosY + infoH + colorBoxH>mainHeight)
                 infoPosY := mainHeight - infoH - colorBoxH
           } Else
           {
              otherPos := 1
              infoPosY := (imgSelPy - infoH - colorBoxH <20) ? 5 : imgSelPy - infoH - colorBoxH - 20
              If (infoPosY + infoH + colorBoxH>mainHeight)
                 infoPosY := mainHeight - infoH - colorBoxH
           }
 
           If (dotActive=4 || otherPos=1) && (dotActive!=3)
           {
              infoPosX := imgSelPx  + imgSelW - infoW - 25
              If (infoPosX + infoW>mainWidth)
                 infoPosX := mainWidth - infoW
           } Else
           { 
              infoPosX := (imgSelPx<5) ? 5 : imgSelPx + 25
              If (infoPosX + infoW>mainWidth)
                 infoPosX := mainWidth - infoW
           }
 
           If colorBox
           {
              pBr0 := Gdip_BrushCreateSolid(colorBox)
              Gdip_FillRectangle(2NDglPG, pBr0, infoPosX, infoPosY + infoH, infoW, colorBoxH)
              Gdip_DeleteBrush(pBr0)
           }
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, infoPosX, infoPosY,,,,,,, 0.97)
           infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        }

        ; Gdip_FillRectangle(2NDglPG, pBrushC, imgSelPx, imgSelPy, imgSelW, imgSelH)
        If (showSelectionGrid=1 || imgSelLargerViewPort=1 || EllipseSelectMode>0)
        {
           whichPen := (EllipseSelectMode>0) ? pPen : zPen
           ; Gdip_DrawEllipse(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        }

        pPen := (editingSelectionNow=1) ? pPen1d : pPen1
        Gdip_SetPenWidth(pPen, lineThickns)
        If ((EllipseSelectMode>0 || VPselRotation>0) && AnyWindowOpen!=23)
           Gdip_DrawPath(2NDglPG, pPen, ImgSelPath)

        If (showSelectionGrid=1 || imgSelLargerViewPort=1)
        {
           Gdip_SetClipRect(2NDglPG, imgSelPx, imgSelPy, imgSelW, imgSelH, 0)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2)
           Gdip_ResetClip(2NDglPG)
        }

        If (imgSelLargerViewPort!=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
           Gdip_FillRectangle(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
           Gdip_FillRectangle(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
           Gdip_FillRectangle(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
        }

        If (dotActive=9 && snappyX && snappyY)
        {
           thisThick := SelDotsSize//5 + 1
           sz := SelDotsSize * 5
           Gdip_SetPenWidth(pPen1d, thisThick)
           Gdip_DrawLine(2NDglPG, pPen1d, snappyX - sz, snappyY, snappyX + sz, snappyY)
           Gdip_DrawLine(2NDglPG, pPen1d, snappyX, snappyY - sz, snappyX, snappyY + sz)
       }

        If (dotActive=10)
        {
            ; Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize*2, dotsSize*2)
            Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)
        }
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)

        If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
        {
           r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
           livePreviewsImageEditing("live-selection")
        } Else r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
     } Else If (operation="end")
     {
        InfoW := InfoH := ""
        ; Gdip_ResetWorldTransform(2NDglPG)
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        If pBr0
        {
           Gdip_DeleteBrush(pBr0)
           pBr0 := ""
        }

        Gdip_ResetWorldTransform(2NDglPG)
        SetTimer, dummyRefreshImgSelectionWindow, -25
     }
}

dummyRefreshImgSelectionWindow() {
     Static prevStatus, loopsOccured := 0
     If (editingSelectionNow=1 && IMGresizingMode=5)
     {
        thisu := 1
        IMGresizingMode := 1
        interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
     }

     ; ToolTip, % "l=" drawingShapeNow "==" editingSelectionNow "==" drawingVectorLiveMode , , , 2
     If (drawingShapeNow!=1 && imgSelX2=-1 && imgSelY2=-1 && editingSelectionNow=1) || (thisu=1)
     {
        dummyTimerDelayiedImageDisplay(25)
        Return
     }

     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     If (drawingShapeNow=1)
        GetMouseCoord2wind(PVhwnd, mX, mY)

     thisState := "a" mX mY mainWidth mainHeight closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 BrushToolSymmetryX BrushToolSymmetryY BrushToolSymmetryPointX BrushToolSymmetryPointY customShapeHasSelectedPoints showNewVectorPointPreview vpGridSize showViewPortGrid bezierSplineCustomShape
     If (thisState!=prevStatus) || (drawingShapeNow!=1)
     {
        loopsOccured++
        ; ToolTip, % loopsOccured "==" thisState " -- " A_TickCount , , , 2
        additionalHUDelements(3, mainWidth, mainHeight)
        prevStatus := thisState
     }
}

drawVPpartialIMGsection(brickVPx, brickVPy, brickVPw, brickVPh, DestPosX, DestPosY, newW, newH, whichBitmap, Gu, dpX, dpY, kW, kH, imageAttribs, clrMatrix, pEffect, rImgW, rImgH, thisUSRimgQuality, simpleMode:=0) {
    MouseCoords2Image(brickVPx, brickVPy, 1, DestPosX, DestPosY, newW, newH, brickIMGx, brickIMGy, whichBitmap, 0, rimgW, rimgH)
    MouseCoords2Image(brickVPx + brickVPw, brickVPy + brickVPh, 1, DestPosX, DestPosY, newW, newH, brickIMGxz, brickIMGyz, whichBitmap, 0, rimgW, rimgH)
    brickIMGw := brickIMGxz - brickIMGx
    brickIMGh := brickIMGyz - brickIMGy
    If (simpleMode=1)
       Return trGdip_DrawImage(A_ThisFunc, Gu, whichBitmap, brickVPx, brickVPy, brickVPw, brickVPh, brickIMGx, brickIMGy, brickIMGw, brickIMGh, clrMatrix, 2, imageAttribs)

    ; kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, brickIMGx, brickIMGy, brickIMGw, brickIMGh, 0, 0, 1, 0)
    If (brickVPx<dpX)
    {
       brickVPw -= dpX - brickVPx
       brickVPx := dpX
    }

    If (brickVPy<dpY)
    {
       brickVPh -= dpY - brickVPy
       brickVPy := dpY
    }

    If (brickVPw + brickVPx>kW + dpX)
       brickVPw -= brickVPw + brickVPx - (kW + dpX)
    If (brickVPh + brickVPy>kH + dpY)
       brickVPh -= brickVPh + brickVPy - (kH + dpY)

    totalVPsize := Round((brickVPw * brickVPh)/1000000)
    totalIMGsize := Round((brickIMGw * brickIMGh)/1000000)

    If (brickVPw>0 && brickVPh>0) && (brickIMGw>0 && brickIMGh>0)
    {
       thisQuality := (thisUSRimgQuality=1) ? 7 : 5
       kBitmap := trGdip_CloneBitmapArea(A_ThisFunc, whichBitmap, brickIMGx, brickIMGy, brickIMGw, brickIMGh, "0xE200B")
       If (kBitmap && (totalIMGsize + 2>totalVPsize) && imageAttribs)
       {
          zBitmap := trGdip_ResizeBitmap(A_ThisFunc, kBitmap, brickVPw, brickVPh, 0, thisQuality, -1)
          If zBitmap
             kBitmap := trGdip_DisposeImage(kBitmap)
       }
       aBmp := zBitmap ? zBitmap : kBitmap
       If (pEffect && aBmp)
          Gdip_BitmapApplyEffect(aBmp, pEffect)
    }

    If (zBitmap || kBitmap)
    {
       If zBitmap
       {
          r1 := trGdip_DrawImage(A_ThisFunc, Gu, zBitmap, brickVPx, brickVPy, brickVPw, brickVPh, 0, 0, brickVPw, brickVPh, clrMatrix, 2, imageAttribs)
          trGdip_DisposeImage(zBitmap)
       } Else
       {
          r1 := trGdip_DrawImage(A_ThisFunc, Gu, kBitmap, brickVPx, brickVPy, brickVPw, brickVPh, 0, 0, brickIMGw, brickIMGh, clrMatrix, 2, imageAttribs)
          trGdip_DisposeImage(kBitmap)
       }
    }
    ; ToolTip, % brickVPx "=" brickVPy "`n" brickVPw "==" brickVPh , , , 2
}

QPV_ShowImgonGui(newW, newH, mainWidth, mainHeight, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged, ByRef wasPrevious) {
    Critical, on
    Static IDviewPortCache, PREVtestIDvPcache, prevImgAlphaChn, prevVPcacheIMGid, lastZeitLowQuality, prevDelayu
         , prevVPcachePos, prevVPcacheZoom :=[], prevVPcacheHadpartialFX, prevVPcacheIDfx, prevNewW, prevNewH

    prevLoadedImageIndex := currentFileIndex
    createGDIPcanvas(mainWidth, mainHeight)
    If (CountGIFframes>1 && !AnyWindowOpen && animGIFsSupport=1 && prevAnimGIFwas!=imgPath)
       mustPlayAnim := 1

    If (mustPlayAnim=1) || (IMGresizingMode=4 && allowFreeIMGpanning=1)
    {
       prevVPcacheZoom[1] := 0
       allowVPcacheOptimizations := 0
    } Else
    {
       DestroyGIFuWin()
       gdiSmallSize := determineGDIsmallCacheSize(mainWidth, mainHeight)
       totalNewSize := Round((newW * newH)/1000000, 2)
       If (IMGresizingMode=3 || zoomLevel=1)
          mustGenerate := 0
       Else If isInRange(totalNewSize, 0, gdiSmallSize.Small + 0.09)
          mustGenerate := 2
       Else If isInRange(totalNewSize, gdiSmallSize.Small + 0.08, gdiSmallSize.Screen + 2.1)
          mustGenerate := 1
       Else
          mustGenerate := 0

       If (mustGenerate=1) ; do not resize to screen size if it is already at screen size
          mustGenerate := (gdiSmallSize.Screen + 2.1<gdiSmallSize.Main + 1) || (gdiSmallSize.Screen//3>gdiSmallSize.Main) ? 1 : 0

       If (mustGenerate=1 && minimizeMemUsage=1 && usePrevious=1)
          mustGenerate := 2

       allowVPcacheOptimizations := (userimgQuality=1) ? 1 : 0
    }

    If (minimizeMemUsage=1 && usePrevious!=1 || mustPlayAnim=1 || allowVPcacheOptimizations=0)
       mustGenerate := 0

    mustGoIntoLowQuality := 0
    thisDelayu := (vpImgPanningNow=2 || sizeChanged=1) ? 950 : 400
    If (((A_TickCount - lastZeitLowQuality<thisDelayu + prevDelayu) || (drawModeAzeit>70 && mustPlayAnim=1 && desiredFrameIndex>1) || (usePrevious=1)) && (userimgQuality=1 && usePrevious!=2 && zoomLevel!=1))
       mustGoIntoLowQuality := 1

    If (imgEditPanelOpened=1 || drawingShapeNow=1 || paintBrushToolActive=1) && (userimgQuality=1)
       mustGoIntoLowQuality := 2

    If (mustGoIntoLowQuality=1 && minimizeMemUsage!=1 && mustGenerate=0 && usePrevious!=2 && mustPlayAnim!=1 && imgFxMode>1 && vpImgPanningNow!=2)
       forcedSmallSize := mustGenerate := 1

    If (liveDrawingBrushTool=1)
       whichBitmap := gdiBitmap
    Else If (mustGenerate=1) ; window size
       whichBitmap := RescaleBMPtinyVPsize(imgPath, mainWidth, mainHeight)
    Else If (mustGenerate=2) ; for QPV_ShowImgOther() ; very small
       whichBitmap := RescaleBMPtiny(imgPath, mainWidth, mainHeight)
    Else ; original image
       whichBitmap := gdiBitmap

    sizeChanged := (prevNewW!=newW || prevNewH!=newH) ? 1 : 0
    prevNewW := newW, prevNewH := newH
    ; ToolTip, % "resized cache = " mustGenerate , , , 2
    interfaceThread.ahkassign("canCancelImageLoad", 0)
    startZeit := A_TickCount
    ; ToolTip, % oldZoomLevel "==" zoomLevel , , , 2
    oldZoomLevel := matrix := ""
    prevDrawingMode := 1
    thisVPpanningNow := (vpImgPanningNow=2) ? 1 : 0
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcIMGcoordsInVP(usePrevious, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    If (StrLen(ViewPortBMPcache)<3 || mustPlayAnim=1)
    {
       thisVPpanningNow := diffuDestPosX := diffuDestPosY := 0
    } Else If (allowVPcacheOptimizations=1)
    {
       diffuDestPosX := diffIMGdecX ? DestPosX - prevDestPosX : 0   ; has panned on X
       diffuDestPosY := diffIMGdecY ? DestPosY - prevDestPosY : 0   ; has panned on Y
       If (Abs(diffuDestPosY)>mainHeight - 1) || (Abs(diffuDestPosX)>mainWidth - 1)
       {
          thisVPpanningNow := 0
          diffuDestPosX := diffuDestPosY := 0
          ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
       }
    }

    prevDestPosX := DestPosX
    prevDestPosY := DestPosY
    diffIMGdecX := diffIMGdecY := 0

    ; calculate in viewport coords
    errMargin := (mustPlayAnim=1) ? 0 : 5
    dpX := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? DestPosX`: clampInRange(DestPosX, 0 - errMargin, mainWidth + errMargin*2)
    dpY := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? DestPosY`: clampInRange(DestPosY, 0 - errMargin, mainHeight + errMargin*2)
    kW := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? newW`: clampInRange(newW, 0 - errMargin, mainWidth + errMargin*2)
    kH := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? newH`: clampInRange(newH, 0 - errMargin, mainHeight + errMargin*4)
    ; If (kH<mainHeight)
       ; ToolTip, % "kWH = mWH = newWH`nW=" kW "=" mainWidth "=" newW "`nH=" kH "=" mainHeight "=" newH , , , 2
    errMargin := Ceil(zoomLevel + 1)
    If diffuDestPosX
    {
       ; calculate the new visible rect
       AdpX := (diffuDestPosX<0) ? diffuDestPosX + mainWidth - errMargin : -errMargin*1.5
       AdpX := clampInRange(AdpX, -errMargin*1.5, mainWidth)
       AkW := Abs(diffuDestPosX) + errMargin*2
       AkW := clampInRange(AkW, 0, mainWidth + errMargin*2)
    }

    If diffuDestPosY
    {
       ; calculate the new visible rect
       AdpY := (diffuDestPosY<0) ? diffuDestPosY + mainHeight - errMargin : -errMargin
       AdpY := clampInRange(AdpY, -errMargin, mainHeight)
       AkH := Abs(diffuDestPosY) + errMargin*2
       AkH := clampInRange(AkH, 0, mainHeight + errMargin*2)
    }

    thisUSRimgQuality := userimgQuality
    allowForceIMGload := (thisVPpanningNow=1) ? ForceIMGload : 0
    thisVPcacheIMGid := "a" gdiBitmap currentFileIndex imgPath allowForceIMGload whichBitmap desiredFrameIndex currentUndoLevel UserMemBMP undoLevelsRecorded
    thisVPcachePos := "a" newW newH zoomLevel allowForceIMGload DestPosX DestPosY thisVPcacheIMGid
    prevVPcacheIDfx := (AnyWindowOpen=74) ? "-" : decideGDIPimageFX(matrix, imageAttribs, pEffect)
    forceNoFXcaching := (thisVPcachePos=prevVPcachePos && prevVPcacheHadpartialFX=2 && thisVPpanningNow=0) ? 1 : 0
    thisThingMatrix := (IntensityAlphaChannel>1 && imgFxMode>=2 && imgFxMode!=8 && currIMGdetails.HasAlpha=1) ? 1 : 0
    isAlphaMaskMode := (currIMGdetails.HasAlpha=1 && imgFxMode=8 && ForceNoColorMatrix=0) ? 1 :0 
    thisImgAlphaChn := "a" IntensityAlphaChannel thisThingMatrix isAlphaMaskMode
    Gdip_GetImageDimensions(whichBitmap, rImgW, rImgH)
    ; ToolTip, % forceNoFXcaching "==" vpImgPanningNow , , , 2
    If (thisVPcachePos!=prevVPcachePos || forceNoFXcaching=1 || StrLen(ViewPortBMPcache)<2 || thisImgAlphaChn!=prevImgAlphaChn || liveDrawingBrushTool=1)
    {
       If (mustGoIntoLowQuality>0)
       {
          lastZeitLowQuality := A_TickCount
          lastWasLowQuality := 1
          thisUSRimgQuality := 0
          Gdip_SetInterpolationMode(glPG, 5)
       }
 
       If (thisVPcacheIMGid!=prevVPcacheIMGid && thisVPpanningNow=0 || thisImgAlphaChn!=prevImgAlphaChn)
       {
          ; if the image has changed, no cached section must be used
          forceNoFXcaching := prevVPcacheHadpartialFX := AdpX := AdpY := diffuDestPosX := diffuDestPosY := 0
          ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
          prevVPcacheZoom[1] := 0
       }

       windowScreenMGPX := Ceil((mainWidth * mainHeight)/1000000)
       azW := prevVPcacheZoom[8] , azH := prevVPcacheZoom[9]
       prevIMGrectMGPX := Round((azW * azH)/1000000) - 1
       If (prevIMGrectMGPX<windowScreenMGPX//4.5 || liveDrawingBrushTool=1)        ; no need to slice and dice images when the rect we need is much smaller than the viewport
          hasPanned := thisVPpanningNow := AdpX := AdpY := diffuDestPosX := diffuDestPosY := 0

       Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
       If (mustPlayAnim!=1)
       {
          Gdip_SetClipRect(glPG, dpX + errMargin, dpY + errMargin, kW - errMargin*2, kH - errMargin*2, 4)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
          If (isAlphaMaskMode=1)
          {
             Gdip_SetClipRect(glPG, dpX + errMargin, dpY + errMargin, kW - errMargin*2, kH - errMargin*2)
             Gdip_GraphicsClear(glPG, "0xFF000000")
          }
       } Else If (desiredFrameIndex=0)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
       Gdip_ResetClip(glPG)

       ; errMargin := Ceil(zoomLevel*70) + 2
       If (currIMGdetails.HasAlpha=1 && imgFxMode!=8 && mustPlayAnim!=1)
       {
          ; draw image background - if it has an alpha channel
          hRgnB := Gdi_CreateRectRegion(dpX, dpY, dpX + kW, dpY + kH)
          Gdi_FillRegion(glHDC, hRgnB, useGdiHatchedBrush("vp"))
          Gdi_DeleteObject(hRgnB)
       }
       ; Gdip_GraphicsClear(glPG, "0xFf" WindowBgrColor)
       ; gp := Gdip_GetImagePixelFormat(ViewPortBMPcache, 2) 
       ; ToolTip, % gp , , , 2
       thisAllowed := (allowVPcacheOptimizations=1 || diffuDestPosX || diffuDestPosY) ? 1 : 0
       thisImageAttribs := (imageAttribs && ((forceNoFXcaching=0 && thisAllowed=1 && currIMGdetails.HasAlpha!=1) || (isAlphaMaskMode=1))) ? imageAttribs : 0
       clrMatrix := (thisImageAttribs=0 && IntensityAlphaChannel>1 && imgFxMode>1 && imgFxMode!=8 && currIMGdetails.HasAlpha=1) ? IntensityAlphaChannel : 1
       thisPeffect := (pEffect && forceNoFXcaching=0 && thisAllowed=1 && isAlphaMaskMode!=1) ? pEffect : 0
       If diffuDestPosX
       {
          ; resize and draw the new visible rect if panned on the X axis
          errMargin := (diffuDestPosX<0) ? Ceil(zoomLevel) : zoomLevel//2
          errMargin := errMargin//4
          drawVPpartialIMGsection(AdpX - errMargin, dpY, AkW + errMargin, kH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin*2, kH, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)
          prevVPcacheZoom[1] := 0
       }

       If diffuDestPosY
       {
          ; resize and draw the new visible rect if panned on the Y axis
          If !AdpX
             AdpX := 0

          tdpX := (diffuDestPosX<0) ? 0 : Round(AkW) + 1
          tdpW := (diffuDestPosX<0) ? tdpX - 2 : Round(AkW) + 2
          drawVPpartialIMGsection(dpX + tdpX, AdpY, kW - tdpW, AkH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW, kH, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)
          ; ToolTip, % tdpX "=" tdpW "`n" AkW "=" AkH "`n" AdpX "=" AdpY "`n" diffuDestPosX "=" diffuDestPosY, , , 2
          prevVPcacheZoom[1] := 0
       }
       ; ToolTip, % diffuDestPosX "==" diffuDestPosY , , , 2
       If ((diffuDestPosX || diffuDestPosY || thisVPpanningNow=1 && allowVPcacheOptimizations=1) && ViewPortBMPcache)
       {
          ; draw the cached section on image panning

          ; Gdip_SetClipRect(glPG, diffuDestPosX - errX, diffuDestPosY - errY, mainWidth, mainHeight)
          hasPanned := 1
          thisuAttribs := (!diffuDestPosX && !diffuDestPosY) || (isAlphaMaskMode=1) ? 0 : thisImageAttribs
          thisuAttribs := (prevVPcacheHadpartialFX!=2 && (thisuAttribs || clrMatrix>1) && forceNoFXcaching=0) ? thisuAttribs : 0
          thisuClrMatrix := (prevVPcacheHadpartialFX!=2 && (thisuAttribs || clrMatrix>1) && forceNoFXcaching=0) ? clrMatrix : 1
          thisuEffectu := (!diffuDestPosX && !diffuDestPosY) || (isAlphaMaskMode=1) ? 0 : thisPeffect
          thisuEffectu := (prevVPcacheHadpartialFX!=2 && thisuEffectu && forceNoFXcaching=0) ? thisuEffectu : 0
          ; If (prevVPcacheHadpartialFX!=2 && (thisuAttribs || clrMatrix>1) && forceNoFXcaching=0)
          ; {
             brickIMGx := (diffuDestPosX<0) ? Abs(diffuDestPosX) : 0
             brickIMGy := (diffuDestPosY<0) ? Abs(diffuDestPosY) : 0
             brickVPx := (diffuDestPosX<0) ? 0 : Abs(diffuDestPosX)
             brickVPy := (diffuDestPosY<0) ? 0 : Abs(diffuDestPosY)
             brickIMGw := mainWidth - Abs(diffuDestPosX)
             brickIMGh := mainHeight - Abs(diffuDestPosY)
             If (brickIMGw && brickIMGh)
                kBitmap := trGdip_CloneBitmapArea(A_ThisFunc, ViewPortBMPcache, brickIMGx, brickIMGy, brickIMGw, brickIMGh, "0xE200B")

             If kBitmap
             {
                If thisuEffectu
                   Gdip_BitmapApplyEffect(kBitmap, thisuEffectu)

                r2 := trGdip_DrawImage(A_ThisFunc, glPG, kBitmap, brickVPx, brickVPy, brickIMGw, brickIMGh, 0, 0, brickIMGw, brickIMGh, thisuClrMatrix, 2, thisuAttribs)
                kBitmap := trGdip_DisposeImage(kBitmap, 1)
             }

             ; r2 := trGdip_DrawImage(A_ThisFunc, glPG, ViewPortBMPcache, diffuDestPosX, diffuDestPosY, mainWidth, mainHeight,,,,, thisuClrMatrix, 2, thisuAttribs)

          If (!diffuDestPosX && !diffuDestPosY)
          {
             Gdip_DisposeEffect(thisPeffect)
             Gdip_DisposeImageAttributes(thisImageAttribs)
             thisImageAttribs := thisPeffect := pEffect := imageAttribs := ""
          }
          ; ToolTip, % r2 "==" diffuDestPosX "==" diffuDestPosY "`n"  brickIMGx "=" brickIMGy "`n" brickIMGw "==" brickIMGh , , , 2
       }

       If (!diffuDestPosX && !diffuDestPosY && hasPanned!=1)
       {
          ; draw and calculate the image visible rect if image was not panned
          zX := prevVPcacheZoom[2] , zY := prevVPcacheZoom[3]
          zW := prevVPcacheZoom[4] , zH := prevVPcacheZoom[5]
          sameNess := (dpX=zX && dpY=zY && zW=kW && zH=kH && prevVPcacheZoom[11]=DestPosX && prevVPcacheZoom[12]=DestPosY) ? 1 : 0
          ; ToolTip, % "l=" sameNess "`n" DestPosX "==" DestPosY "`n" prevVPcacheZoom[11] "==" prevVPcacheZoom[12] , , , 2
          If ((sameNess=1 || prevVPcacheZoom[1]>zoomLevel) && (prevIMGrectMGPX>windowScreenMGPX//2) && IMGresizingMode=4 && StrLen(ViewPortBMPcache)>2 && whichBitmap=gdiBitmap && allowVPcacheOptimizations=1)
          {
             ; on zoom out, reuse viewport cached image
             azX := prevVPcacheZoom[6] , azY := prevVPcacheZoom[7]
             ImageCoords2Window(azX, azY, DestPosX, DestPosY, 0, outXa, outYa, 0, 1)
             ImageCoords2Window(azX + azW, azY + azH, DestPosX, DestPosY, 0, outXb, outYb, 0, 1)
             errMargin := 0 ; Ceil(zoomLevel)
             If (thisUSRimgQuality=1)
                Gdip_SetInterpolationMode(glPG, 3)

             thisuAttribs := (prevVPcacheHadpartialFX!=2 && thisImageAttribs && forceNoFXcaching=0 && isAlphaMaskMode=0) ? thisImageAttribs : 0
             thisuEffectu := (prevVPcacheHadpartialFX!=2 && thisPeffect && forceNoFXcaching=0 && isAlphaMaskMode=0) ? thisPeffect : 0
             If thisuEffectu
             {
                thisBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
                If thisBMP
                   Gdip_BitmapApplyEffect(thisBMP, thisuEffectu)
             }
             aBmp := StrLen(thisBMP)>2 ? thisBMP : ViewPortBMPcache
             r2 := trGdip_DrawImage(A_ThisFunc, glPG, aBmp, outXa - errMargin, outYa - errMargin, outXb - outXa + errMargin*2, outYb - outYa + errMargin*2, zX, zY, zW, zH, clrMatrix, 2, thisuAttribs)
             thisBMP := trGdip_DisposeImage(thisBMP)
             If (thisUSRimgQuality=1)
                Gdip_SetInterpolationMode(glPG, 7)

             If (prevVPcacheZoom[10]=1)
             {
                ; if the image is larger than the viewport, and user zooms out
                ; resize and draw only the newly visible image sections
                mX := 0, mY := 0
                mW := mainWidth, mH := mainHeight

                ; left side
                errMargin := (outXa>0) ? Ceil(zoomLevel) + 4 : 0
                drawVPpartialIMGsection(mX, mY, outXa + errMargin, mH + errMargin*2, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin*2, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)

                ; right side
                errMargin := Ceil(zoomLevel) + 4
                tW := mW - outXb, tH := mH
                tX := mW - tW, tY := mY
                tW := (tW>0) ? tW + errMargin*2 : 0
                tH := (tH>0) ? tH + errMargin*2 : 0
                If (tW>0)
                   tX -= errMargin
                drawVPpartialIMGsection(tX, tY, tW, tH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin*2, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)

                ; top side
                tW := mW - outXa - (mW - outXb), tH := outYa
                tX := outXa, tY := mY
                tH := (tH>0) ? tH + errMargin*2 : 0
                If (tH>0)
                   tY -= errMargin
                drawVPpartialIMGsection(tX, tY, tW, tH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)

                ; bottom side
                tW := mW - outXa - (mW - outXb)
                tH := mH - outYb
                tX := outXa, tY := outYb
                tH := (tH>0) ? tH + errMargin*2 : 0
                If (tH>0)
                   tY -= errMargin
                drawVPpartialIMGsection(tX, tY, tW, tH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)
             } 

             ; ToolTip,  % zX "==" zY "`n" zW "==" zH "`n" azX "=" azY "`n" azW "=" azH "`n" outXa "==" outYa "`n" outXb "=" outYb , , , 2
          } Else If (thisVPpanningNow=0 || allowVPcacheOptimizations=0)
          {
             ; no cached sections reused
             If (thisUSRimgQuality=1 && whichBitmap!=gdiBitmap)
                Gdip_SetInterpolationMode(glPG, 3)

             thisModus := (thisPeffect || thisImageAttribs || thisUSRimgQuality=1 || allowFreeIMGpanning=1 && IMGresizingMode=4) ? 0 : 1
             ; ToolTip, % " not cached  = " thisModus "`n" dpX "=" dpY "`n" kW "=" kH , , , 2
             drawVPpartialIMGsection(dpX, dpY, kW, kH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW, kH, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality, thisModus)
             If (thisUSRimgQuality=1 && whichBitmap!=gdiBitmap)
                Gdip_SetInterpolationMode(glPG, 7)
          }
       }

       dpX := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? DestPosX`: clampInRange(DestPosX, 0, mainWidth)
       dpY := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? DestPosY`: clampInRange(DestPosY, 0, mainHeight)
       kW := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? newW`: clampInRange(newW, 0, mainWidth)
       kH := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? newH`: clampInRange(newH, 0, mainHeight)
       MouseCoords2Image(dpX, dpY, 0, DestPosX, DestPosY, newW, newH, sfPosX1, sfPosY1, whichBitmap, 0, rImgW, rImgH)
       MouseCoords2Image(dpX + kW, dpY + kH, 0, DestPosX, DestPosY, newW, newH, sfPosX2, sfPosY2, whichBitmap, 0, rImgW, rImgH)
       sfW := sfPosX2 - sfPosX1
       sfH := sfPosY2 - sfPosY1

       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
       ViewPortBMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       prevVPcachePos := thisVPcachePos
       prevVPcacheIMGid := thisVPcacheIMGid
       zl := (IMGresizingMode=4 && !AdpX && !AdpY && whichBitmap=gdiBitmap) ? zoomLevel : 0
       prevVPcacheIDfx := thisVPcacheIDfx
       prevVPcacheHadpartialFX := thisImageAttribs ? 2 : 0
       prevImgAlphaChn := thisImgAlphaChn
       prevVPcacheZoom := [zl, dpX, dpY, kW, kH, sfPosX1, sfPosY1, sfW, sfH, IMGlargerViewPort, DestPosX, DestPosY]
       If (thisPeffect && pEffect)
       {
          Gdip_DisposeEffect(pEffect)
          pEffect := ""
       }

       If (thisImageAttribs && imageAttribs)
       {
          Gdip_DisposeImageAttributes(imageAttribs)
          imageAttribs := ""
       }

       wasVPcached := 0
    } Else
    {
       ; the entire image visible area is cached, recalculate colour effects if needed
       wasVPcached := 1
    }

    ; ToolTip, % "l=" r2 "=" kBitmap "=" ViewPortBMPcache "=" gdipLastError "=" glHbitmap , , , 2
    confirmTexBGR := isVarEqualTo(vpIMGrotation, 0, 90, 180, 270) && (usrTextureBGR=1 && gdiAmbientalTexBrush && (IMGentirelylargerThanVP!=1 || allowFreeIMGpanning=1 && IMGresizingMode=4)) ? 1 : 0
    If (FlipImgV=1 || FlipImgH=1 || pEffect || imageAttribs || wasVPcached=1)
    {
       ; redraw viewport with the activated FX
       If (prevVPcacheHadpartialFX=2 || isAlphaMaskMode=1)
       {
          ; ToolTip, llllllol , , , 2
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeImageAttributes(imageAttribs)
          imageAttribs := ""
          pEffect := ""
       }

       if (imageAttribs || pEffect)
       {
          ; ToolTip, nooooooooo , , , 2
          prevVPcacheHadpartialFX := 0
       }

       If ((imageAligned=1 || allowFreeIMGpanning=1 && imageAligned=5) && wasVPcached=0 && (FlipImgV=1 || FlipImgH=1))
       {
          If (allowFreeIMGpanning=0)
             Gdip_SetClipRect(glPG, dpX, dpY, kW, kH)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
          Gdip_ResetClip(glPG)
       }

       ; flipBitmapAccordingToViewPort(kBitmap, 1)
       setMainCanvasTransform(mainWidth, mainHeight)
       If (wasVPcached=1 && confirmTexBGR=0)
       {
          Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
          Gdip_SetClipRect(glPG, dpX, dpY, kW, kH, 4)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
          Gdip_ResetClip(glPG)
       }

       If pEffect
       {
          thisBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          If thisBMP
             Gdip_BitmapApplyEffect(thisBMP, pEffect, dpX, dpY, kW, kH)

          Gdip_DisposeEffect(pEffect)
       }
       aBmp := StrLen(thisBMP)>2 ? thisBMP : ViewPortBMPcache
          ; r4 := trGdip_DrawImageFX(A_ThisFunc, glPG, ViewPortBMPcache, , , dpX, dpY, kW, kH,, pEffect, imageAttribs)
       r2 := trGdip_DrawImage(A_ThisFunc, glPG, aBmp, dpX, dpY, kW, kH, dpX, dpY, kW, kH,,, imageAttribs)
       Gdip_DisposeImageAttributes(imageAttribs)
       thisBMP := trGdip_DisposeImage(thisBMP, 1)
    } Else Gdip_ResetClip(glPG)

    If (confirmTexBGR=1)
    {
       Gdip_ResetClip(glPG)
       hRgnA := Gdi_CreateRectRegion(0, 0, mainWidth, mainHeight)
       dpX := (FlipImgH=1 && imageAligned=1) ? mainWidth - kW : dpX
       dpY := (FlipImgV=1 && imageAligned=1) ? mainHeight - kH : dpY
       hRgnB := Gdi_CreateRectRegion(dpX, dpY, dpX + kW, dpY + kH)
       Gdi_CombineRegion(hRgnA, hRgnA, hRgnB, 3)
       Gdi_FillRegion(glHDC, hRgnA, gdiAmbientalTexBrush)
       Gdi_DeleteObject(hRgnA)
       Gdi_DeleteObject(hRgnB)
    }

    ; ToolTip, % confirmTexBGR "=" z "=" hRgnA "==" gdiAmbientalTexBrush , , , 2
    thisModus := (mustPlayAnim=0 && thisUSRimgQuality=0 && userimgQuality=1 && mustGoIntoLowQuality!=2) ? 2 : 1
    drawHUDelements(thisModus, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath)
    Gdip_ResetWorldTransform(glPG)
    If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && slideShowDelay>950 && StrLen(GDIfadeVPcache)>2)
       imageHasFaded := performFadeTransition(imgPath, mustPlayAnim)

    whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
    r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC)
    If (imageHasFaded=1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, 2NDglHDC)

    If (mustPlayAnim=1 && !AnyWindowOpen)
    {
       setGIFframesDelay()
       autoChangeDesiredFrame("start", imgPath)
       SetTimer, autoChangeDesiredFrame, % GIFspeedDelay
       If (mustRecordSeenImgs=1 && desiredFrameIndex=2 && gdiBMPchanged=1 && !InStr(r, "error"))
          recordSeenIMGdbEntry(imgPath, currentFileIndex)
    } Else
    {
       autoChangeDesiredFrame("stop")
       If (mustRecordSeenImgs=1 && gdiBMPchanged=1 && !InStr(r, "error"))
          recordSeenIMGdbEntry(imgPath, currentFileIndex)
    }

    totalZeit := A_TickCount - startZeitIMGload
    If (thisUSRimgQuality=0 && userimgQuality=1 && mustGoIntoLowQuality!=2)
    {
       lastWasLowQuality := 1
       If (usePrevious=0)
          lastZeitLowQuality := A_TickCount
       Gdip_SetInterpolationMode(glPG, 7)
       prevDelayu := (vpImgPanningNow=2 || hasPanned=1 || totalZeit>100 && hasPanned=1 || sizeChanged=1 || forcedSmallSize=1) ? 850 : 65
       SetTimer, wrapResizeImageGDIwin, % -prevDelayu
    } Else
    {
       prevDelayu := 50
       lastWasLowQuality := (mustGoIntoLowQuality=2) ? 1 : 0
    }

    ; Gdip_ResetClip(glPG)
    thisZeit := A_TickCount - startZeit
    If (totalZeit<155)
       prevFastDisplay := A_TickCount
    Else If (usePrevious!=2)
       lastZeitLowQuality := A_TickCount

    ; prevFullIMGload := A_TickCount
    LastWasFastDisplay := (totalZeit<150 && usePrevious<2) ? 1 : 0
    drawModeAzeit := A_TickCount - startZeit
    If (hasFullReloaded=1 && imageHasFaded!=1)
    {
       fullLoadZeit := A_TickCount - startZeitIMGload
       fullLoadZeit2 := (fullLoadZeit + drawModeCzeit)//2
       drawModeCzeit := max(fullLoadZeit, fullLoadZeit2)
    }

    ; ToolTip, % fullLoadZeit ", "  thisZeit ", " totalZeit ", " drawModeCzeit ,,,2
    Return r
}

performFadeTransition(imgPath, gifAnim) {
    Static prevImgPath
    If (gifAnim=1 && prevImgPath=imgPath)
       Return 0

    setWindowTitle(pVwinTitle, 1)
    ForceRefreshNowThumbsList()
    tempBMP := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
    trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
    ToggleVisibilityWindow("show", hGDIthumbsWin)
    trGdip_DrawImage(A_ThisFunc, glPG, GDIfadeVPcache)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
    Loop, 255
    {
        opacity := 255 - A_Index*12
        If (opacity<2)
           Break

        dummyPos := (A_OSVersion!="WIN_7") ? 0 : ""
        r2 := UpdateLayeredWindow(hGDIwin, glHDC, dummyPos, dummyPos, mainWidth, mainHeight, opacity)
        Sleep, 1
    }
    trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
    trGdip_DisposeImage(tempBMP, 1)
    trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xFF" WindowBGRcolor)
    prevImgPath := imgPath
    Return 1
}

getTabStopStyle(hwnd) {
  WinGet, Stylu, Style, ahk_id %hwnd%
  r := (Stylu & 0x10000) ? 0 : 1
  Return r
}

getCaptionStyle(hwnd) {
  WinGet, Stylu, Style, ahk_id %hwnd%
  r := (Stylu & 0xC00000) ? 0 : 1
  Return r
}

getTopMopStyle(hwnd) {
  WinGet, Stylu, ExStyle, ahk_id %hwnd%
  r := (Stylu & 0x8) ? 1 : 0
  Return r
}

updateUIctrl() {
   modus := (StrLen(UserMemBMP)>2 || (maxFilesIndex>0 && CurrentSLD)) ? modus : "welcome"
   If (modus="welcome")
      interfaceThread.ahkPostFunction("uiAccessWelcomeView")
   Else
      interfaceThread.ahkPostFunction("updateUIctrlFromOutside", editingSelectionNow, isAlwaysOnTop, drawingShapeNow, IMGresizingMode)
}

coreselectRandomFiles(howMany, a, b) {
   newArrayu := []
   a := clampInRange(a, 1, maxFilesIndex)
   b := clampInRange(b, 1, maxFilesIndex)
   maxu := max(a, b) - min(a, b)
   If (maxu<3)
      Return

   thisHowMany := clampInRange(howMany, 1, maxu)
   Loop
   {
      Random, Randy, %a%, %b%
      newArrayu[Randy] := 1
      If (newArrayu.Count()=thisHowMany)
         Break
   }

   For Key, Value in newArrayu
      resultedFilesList[Key, 2] := 1
}

selectRandomFiles(howMany, replaceAll, modus) {
   If (replaceAll=1)
      dropFilesSelection(1)

   If (modus=1)
   {
      coreselectRandomFiles(howMany, 1, maxFilesIndex)
   } Else
   {
      thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
      Loop, % Ceil(maxFilesIndex / maxItemsPage)
         coreselectRandomFiles(howMany, (A_Index - 1) * maxItemsPage, A_Index * maxItemsPage)
   }

   updateFilesSelectionInfos()
   dummyTimerReloadThisPicture(50)
}

updateFilesSelectionInfos(this:=-1) {
   lastZeitFileSelect := A_TickCount
   If (this=-1 || !isNumber(this))
      getSelectedFiles(0, 1)
   Else
      markedSelectFile := this

   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
}

PanelSelectRandomFiles() {
   Static a := 1, b := 5, dropListu := "Entire files list`f`fOn every page of thumbnails"

   fakeWinCreator(54, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Select random files: " appTitle, "Please specify how many files to select.", "&Apply|&Cancel", 1, "modify-entry", "Replace pre-existing selection", a, dropListu, "limit6 number", b)

   If InStr(msgResult.btn, "apply")
   {
      a := msgResult.check
      c := msgResult.list
      b := Trimmer(msgResult.edit)
      b := clampInRange(b, 2, maxFilesIndex - 2)
      selectRandomFiles(b, a, c)
      ; dummyTimerDelayiedImageDisplay(50)
   }
}

regroupSelectedFiles() {
   MenuMoveMarkedEntries() 
}

selectAllFiles(dummy:=0) {
    ; Static selMode := 0
    If (maxFilesIndex<3)
       Return

    selMode := (markedSelectFile < maxFilesIndex || !markedSelectFile) ? 1 : 0
    Loop, % maxFilesIndex
        resultedFilesList[A_Index, 2] := selMode

    thid := (selMode=1) ? maxFilesIndex : 0
    updateFilesSelectionInfos(this)
    SetTimer, mainGdipWinThumbsGrid, -10
}

ToggleEditImgSelection(dummy:=0) {
  Critical, on
  imgPath := getIDimage(currentFileIndex)
  If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  DestroyGIFuWin()
  If (editingSelectionNow!=1)
     correctActiveSelectionAreaViewPort()

  ; If (relativeImgSelCoords=1)
     calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

  If (getCaptionStyle(PVhwnd)=1)
     ToggleTitleBaruNow()

  If (editingSelectionNow=1)
     recordSelUndoLevelNow()

  editingSelectionNow := (dummy="show-edit") ? 1 : !editingSelectionNow
  liveDrawingBrushTool := (AnyWindowOpen=64 && editingSelectionNow=0) ? 1 : 0
  FloodFillSelectionAdj := (AnyWindowOpen=66 && editingSelectionNow=0) ? 0 : 1
  interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
  If (AnyWindowOpen=12)
     EllipseSelectMode := 0
  if (imgSelX2=-1 || ImgSelX2="c") && (editingSelectionNow=1)
  {
     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     createDefaultSizedSelectionArea(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, prevMaxSelX, prevMaxSelY, mainWidth, mainHeight)
     ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, prevMaxSelX, prevMaxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
  }

  updateUIctrl()
  If (ShowAdvToolbar=1)
     decideIconBTNselectShape()
  clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(25)
}

selectEntireImage(act:=0) {
   imgPath := getIDimage(currentFileIndex)
   If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
      Return

   If (getCaptionStyle(PVhwnd)=1)
      ToggleTitleBaruNow()

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (editingSelectionNow=1)
      recordSelUndoLevelNow()

   vpts := (act="r") ? 0 : EllipseSelectMode
   vpr := (act="r") ? 0 : VPselRotation
   vpx := (act="r") ? 0 : innerSelectionCavityX
   vpy := (act="r") ? 0 : innerSelectionCavityY
   If (act="r")
      EllipseSelectMode := 0

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (ImgSelX2=imgW && imgSelY2=imgH
   && imgSelX1=0 && imgSelY1=0 && editingSelectionNow=1)
   {
      resetImgSelection()
      If (act="rm" && imgEditPanelOpened!=1)
         Return
   } Else
   {
      ImgSelX2 := imgW, imgSelY2 := imgH
      imgSelX1 := imgSelY1 := 0
   }

   VPselRotation := vpr
   EllipseSelectMode := vpts
   innerSelectionCavityX := vpx
   innerSelectionCavityY := vpy
   editingSelectionNow := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   updateUIctrl()
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   If (ShowAdvToolbar=1)
      decideIconBTNselectShape()
   ; SetTimer, MouseMoveResponder, -50
   SetTimer, dummyRefreshImgSelectionWindow, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

changeSelectZoom(direction, klop:=0) {
    If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
       Return

    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    If (direction=-1)
    {
       imgSelW -= Round(imgSelW*0.02)
       imgSelH -= Round(imgSelH*0.02)
       imgSelX1 += Round(imgSelW*0.01)
       imgSelY1 += Round(imgSelH*0.01)
    } Else
    {
       imgSelW += Round(imgSelW*0.02)
       imgSelH += Round(imgSelH*0.02)
       imgSelX1 -= Round(imgSelW*0.01)
       imgSelY1 -= Round(imgSelH*0.01)
    }

    imgSelX2 := Round(imgSelX1 + imgSelW)
    imgSelY2 := Round(imgSelY1 + imgSelH)
    If (klop=1)
    {
       dummyRefreshImgSelectionWindow()
    } Else
    {
       userFriendlyPrevImgSelAction:= (direction=-1) ? "SHRINK SELECTION AREA" : "ENLARGE SELECTION AREA"
       SetTimer, dummyRefreshImgSelectionWindow, -10
       SetTimer, dummyShowSelCoordsInfos, -25
    }
}

alignImgSelectCenterV() {
   alignImgSelection(0)
}

alignImgSelectCenterH() {
   alignImgSelection(5)
}

alignImgSelectTop() {
   alignImgSelection(8)
}

alignImgSelectBottom() {
   alignImgSelection(2)
}

alignImgSelectLeft() {
   alignImgSelection(4)
}


alignImgSelectRight() {
   alignImgSelection(6)
}

alignImgSelectOutTop() {
   alignImgSelection(8, 1)
}

alignImgSelectOutBottom() {
   alignImgSelection(2, 1)
}

alignImgSelectOutLeft() {
   alignImgSelection(4, 1)
}


alignImgSelectOutRight() {
   alignImgSelection(6, 1)
}

alignImgSelection(keyu, outu:=0) {
    static K := 0, listu := {0:"Center V.", 1:"Bottom-left", 2:"Bottom", 3:"Bottom-right", 4:"Left", 5:"Center H.", 6:"Right", 7:"Top-left", 8:"Top", 9:"Top-right"}
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
       Return

    IF (keyu="^NumpadAdd")
    {
       changeSelectZoom(1)
       Return
    } Else IF (keyu="^NumpadSub")
    {
       changeSelectZoom(-1)
       Return
    } Else IF (keyu="^NumpadDiv")
    {
       changeSelectionAreaCavity(-1)
       Return
    } Else IF (keyu="^NumpadMult")
    {
       changeSelectionAreaCavity(1)
       Return
    } Else IF (keyu="^NumpadDot")
    {
       If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
          resetSelectionAreaCavity()
       Else
          resetSelectionRotation()
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    k := StrReplace(keyu, "^Numpad")
    If isInRange(k, 0, 9)
       userFriendlyPrevImgSelAction := "ALIGNMENT: " Format("{:U}", listu[k])
    Else
       userFriendlyPrevImgSelAction := Format("{:U}", listu[k])

    If (k=5)
    {
       k := 4
       cX := 1
    } Else If (k=0)
    {
       k := 8
       cY := 1
    }

    If (outu=1)
    {
       PasteInPlaceAutoExpandIMG := 1
       PasteInPlaceBlendMode := 1
       GuiControl, SettingsGUIA:, PasteInPlaceAutoExpandIMG, 1
       GuiControl, SettingsGUIA: Choose, PasteInPlaceBlendMode, 1
       LimitSelectBoundsImg := 0
    }

    timgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    timgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    wX := (k=3 || k=6 || k=9 || k="right") ? imgW - imgSelX2 : imgSelX1
    wY := (k=3 || k=2 || k=1 || k="down") ? ImgH - imgSelY2 : imgSelY1
    If (k=8 || k="up")
    {
       imgSelY1 -= wY
       imgSelY2 -= wY
       if (outu=1)
       {
          imgSelY1 -= timgSelH
          imgSelY2 -= timgSelH
       }
    } Else If (k=9)
    {
       imgSelX1 += wX
       imgSelX2 += wX
       imgSelY1 -= wY
       imgSelY2 -= wY
    } Else If (k=1)
    {
       imgSelX1 -= wX
       imgSelX2 -= wX
       imgSelY1 += wY
       imgSelY2 += wY
    } Else If (k=2 || K="down")
    {
       imgSelY1 += wY
       imgSelY2 += wY
       if (outu=1)
       {
          imgSelY1 += timgSelH
          imgSelY2 += timgSelH
       }
    } Else If (k=3)
    {
       imgSelX1 += wX
       imgSelX2 += wX
       imgSelY1 += wY
       imgSelY2 += wY
    } Else If (k=4 || k="left")
    {
       imgSelX1 -= wX
       imgSelX2 -= wX
       if (outu=1)
       {
          imgSelX1 -= timgSelW
          imgSelX2 -= timgSelW
       }
    } Else If (k=6 || k="right")
    {
       imgSelX1 += wX
       imgSelX2 += wX
       if (outu=1)
       {
          imgSelX1 += timgSelW
          imgSelX2 += timgSelW
       }
    } Else If (k=7)
    {
       imgSelY1 -= wY
       imgSelY2 -= wY
       imgSelX1 -= wX
       imgSelX2 -= wX
    }
    If (cX=1)
    {
       imgSelX1 += imgW//2 - timgSelW//2
       imgSelX2 += imgW//2 - timgSelW//2
    }

    If (cY=1)
    {
       imgSelY1 += imgH//2 - timgSelH//2
       imgSelY2 += imgH//2 - timgSelH//2
    }

    SetTimer, dummyRefreshImgSelectionWindow, -10
    SetTimer, dummyShowSelCoordsInfos, -25
}

arrowKeysAdjustSelectionArea(direction, modus, extraUmphf:=1, klop:=0) {
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
       Return

    factoru := (zoomLevel>2) ? 1 : 2 - zoomLevel
    stepu := Round(2 * (factoru + 0.1))
    If (stepu<2)
       stepu := 2

    stepu := stepu * extraUmphf
    If (FlipImgH=1 && InStr(direction, "1"))
       direction := (direction=1) ? -1 : 1

    If (FlipImgV=1 && InStr(direction, "2"))
       direction := (direction=2) ? -2 : 2

    If (modus=1) ; reposition selection
    {
       If (direction=1)
          imgSelX1 += stepu
       Else If (direction=-1)
          imgSelX1 -= stepu
       Else If (direction=2)
          imgSelY1 += stepu
       Else If (direction=-2)
          imgSelY1 -= stepu
    } Else If (modus=2)
    {
       If (direction=1)
          imgSelX2 += stepu
       Else If (direction=-1)
          imgSelX2 -= stepu
       Else If (direction=2)
          imgSelY2 += stepu
       Else If (direction=-2)
          imgSelY2 -= stepu
    }

    If (klop=1)
    {
       dummyRefreshImgSelectionWindow()
    } Else
    {
       userFriendlyPrevImgSelAction := (modus=1) ? "ADJUST SELECTION POSITION" : "ADJUST SELECTION SIZE"
       SetTimer, dummyRefreshImgSelectionWindow, -10
       SetTimer, dummyShowSelCoordsInfos, -25
    }
}

arrowKeysAdjustPrevPointPath(direction, modus, extraUmphf:=1) {
    Static lastInvoked := 1
    If (drawingShapeNow!=1)
       Return

    maxu := (modus=1) ? 1 : customShapePoints.Count()
    cX1 := customShapePoints[maxu, 1]
    cY1 := customShapePoints[maxu, 2]

    stepu := (A_TickCount - lastInvoked<400) ? 1 : 2
    If (direction=1)
       cX1 += stepu
    Else If (direction=-1)
       cX1 -= stepu
    Else If (direction=2)
       cY1 += stepu
    Else If (direction=-2)
       cY1 -= stepu

    customShapePoints[maxu, 1] := cX1
    customShapePoints[maxu, 2] := cY1
    lastZeitFileSelect := A_TickCount
    dummyRefreshImgSelectionWindow()
    lastInvoked := A_TickCount
}

dummyShowSelCoordsInfos() {
    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    theRatio := "`nRatio: " Round(imgSelW/imgSelH, 2)
    theRatio .= "`nRotation: " Round(VPselRotation, 2) "° "
    theMsg := userFriendlyPrevImgSelAction "`nX / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) "`nW / H: " Round(imgSelW) ", " Round(imgSelH) theRatio "`nCavity: " Round(innerSelectionCavityX, 2)
    showTOOLtip(theMsg, 0, 0, VPselRotation/360)
    SetTimer, RemoveTooltip, -500
}

resetImgSelection() {
  If (thumbsDisplaying=1) || (slideShowRunning=1 && editingSelectionNow!=1)
     Return

  imgSelX1 := imgSelY1 := VPselRotation := innerSelectionCavityX := innerSelectionCavityY := 0
  imgSelX2 := imgSelY2 := -1
  lockSelectionAspectRatio := 1
  defineSelectionAspectRatios()
  EllipseSelectMode := editingSelectionNow := 0
  liveDrawingBrushTool := (AnyWindowOpen=64 && editingSelectionNow=0) ? 1 : 0
  FloodFillSelectionAdj := (AnyWindowOpen=66 && editingSelectionNow=0) ? 0 : 1
  interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
  updateUIctrl()
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(50)
}

resetSelectionAreaCavity() {
  If (thumbsDisplaying=1) || (slideShowRunning=1 && editingSelectionNow!=1)
     Return

  innerSelectionCavityX := innerSelectionCavityY := 0
  SetTimer, dummyRefreshImgSelectionWindow, -25
  userFriendlyPrevImgSelAction := "RESET SELECTION CAVITY"
  SetTimer, dummyShowSelCoordsInfos, -50

  ; dummyTimerDelayiedImageDisplay(50)
}

changeSelectionAreaCavity(dir:=1) {
  If (thumbsDisplaying=1) || (slideShowRunning=1 && editingSelectionNow!=1)
     Return

  thisValue := (dir=1) ? innerSelectionCavityX + 0.01 : innerSelectionCavityX - 0.01
  innerSelectionCavityX := innerSelectionCavityY := clampInRange(thisValue, 0, 0.48)
  SetTimer, dummyRefreshImgSelectionWindow, -15
  userFriendlyPrevImgSelAction := (dir=1) ? "INCREASE SELECTION CAVITY" : "DECREASE SELECTION CAVITY"
  SetTimer, dummyShowSelCoordsInfos, -25
  ; dummyTimerDelayiedImageDisplay(50)
}

newImgSelection() {
  IMGdecalageX := IMGdecalageY := VPselRotation := innerSelectionCavityX := innerSelectionCavityY := 0
  resetImgSelection()
  Sleep, -1
  ToggleEditImgSelection()
}

createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight) {
    If (imgSelX2="C" && imgSelY2="C" && useGdiBitmap())
    {
       GetMouseCoord2wind(PVhwnd, mX, mY)
       MouseCoords2Image(mX - 200, mY - 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
       MouseCoords2Image(mX + 200, mY + 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
       Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
       defineRelativeSelCoords(rImgW, rImgH)
    } Else If (imgSelX2=-1 && imgSelY2=-1)
    {
       obju := createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, 2, 1)

       imgSelX1 := obju.x1, imgSelY1 := obju.y1
       imgSelX2 := obju.x2, imgSelY2 := obju.y2
       If (imgSelX2>maxSelX/2 && newW<mainWidth)
          imgSelX2 := maxSelX//2
       If (imgSelY2>maxSelY/factor && newH<mainHeight)
          imgSelY2 := maxSelY//2
    }
}

createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, factor, applyLimits) {
    obju := []

    x1 := (DestPosX<0) ? Abs(DestPosX)/newW : 0
    SelX1 := Round(x1*maxSelX)

    y1 := (DestPosY<0) ? Abs(DestPosY)/newH : 0
    SelY1 := Round(y1*maxSelY)
    If (applyLimits!=1)
    {
       x1 := Abs(DestPosX)/newW
       If (DestPosX>0)
          SelX1 -= Round(x1*maxSelX)

       y1 := Abs(DestPosY)/newH
       If (DestPosY>0)
          SelY1 -= Round(y1*maxSelY)
    }
    ;  ToolTip, % selx1 "=" sely1 , , , 2
    SelX2 := Round(SelX1 + (mainWidth/factor)/zoomLevel) + 5
    SelY2 := Round(SelY1 + (mainHeight/factor)/zoomLevel) + 5
    If (applyLimits=1)
    {
       If (SelX2>maxSelX/factor && newW<mainWidth && allowFreeIMGpanning=0)
          SelX2 := maxSelX//factor
       If (SelY2>maxSelY/factor && newH<mainHeight && allowFreeIMGpanning=0)
          SelY2 := maxSelY//factor
    }

    obju.x1 := SelX1, obju.y1 := SelY1
    obju.x2 := SelX2, obju.y2 := SelY2
    Return obju  
}

correctActiveSelectionAreaViewPort() {
    Static prevDimensions
    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    theseDimensions := imgW "," imgH

    If (imgSelX2=-1 && imgSelY2=-1)
    {
       prevDimensions := theseDimensions
       Return
    }

    If (theseDimensions=prevDimensions)
       Return

    capSelectionRelativeCoords()
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    ; msgbox, % x1 "--" x2 "--" y1 "--" y2
    imgSelX1 := X1, imgSelY1 := Y1
    imgSelX2 := X2, imgSelY2 := Y2
    prevDimensions := theseDimensions
}

coremakeSquareSelection(imgW, imgH) {
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    avg := (imgSelW+imgSelH)//2
    avg := clampInRange(avg, 5, min(imgW, imgH))
    imgSelX2 := X1 + avg
    imgSelY2 := Y1 + avg
    prcSelX2 := imgSelX2/prevMaxSelX
    If (prcSelX2>1)
       prcSelX2 := 1

    prcSelY2 := imgSelY2/prevMaxSelY
    If (prcSelY2>1)
       prcSelY2 := 1

    Sleep, 1
    If (LimitSelectBoundsImg=1)
       dummyRefreshImgSelectionWindow()
}

makeSquareSelection() {
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
       Return

    If (lockSelectionAspectRatio>1)
    {
       lockSelectionAspectRatio := 1
       toggleImgSelectionAspectRatio()
       Return
    }

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    doLoops := (LimitSelectBoundsImg=1) ? 20 : 1
    Loop, % doLoops
       coremakeSquareSelection(imgW, imgH)

    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

resetSelectionRotation() {
   If (thumbsDisplaying=1)
      Return

   VPselRotation := 0
   SetTimer, dummyRefreshImgSelectionWindow, -10
   userFriendlyPrevImgSelAction := "RESET SELECTION ROTATION"
   SetTimer, dummyShowSelCoordsInfos, -20
}

resetImgSkewOffsets() {
   If (thumbsDisplaying=1)
      Return

   shearImgX := shearImgY := 0
   dummyTimerDelayiedImageDisplay(50)
}

MenuSelRotation() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
      Return

   VPselRotation := Round(VPselRotation) + 45
   If (VPselRotation>350)
      VPselRotation := 0

   SetTimer, dummyRefreshImgSelectionWindow, -10
   userFriendlyPrevImgSelAction := "SELECTION ROTATION +45°"
   SetTimer, dummyShowSelCoordsInfos, -20
}

flipSelectionWH() {
    Static lastState := 0
    If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
       Return

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    If (!imgW || !imgH)
       Return

    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    Gdip_GetRotatedDimensions(imgSelW, imgSelH, 90, rimgSelW, rimgSelH)
    imgSelX2 := X1 + Floor(rimgSelW)
    imgSelY2 := Y1 + Floor(rimgSelH)
    If (lockSelectionAspectRatio>1)
    {
       lastState := !lastState
       defineSelectionAspectRatios("yes", lastState)
    } 
    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

ImageCoords2Window(inputX, inputY, DestPosX, DestPosY, dotSize, ByRef outX, ByRef outY, rounding:=1, limitBounds:=0, givenZL:=99) {
   thisZL := (givenZL!=99) ? givenZL : zoomLevel
   If (rounding=1)
   {
      outX := Round(inputX*thisZL) + DestPosX - dotSize//2
      outY := Round(inputY*thisZL) + DestPosY - dotSize//2
   } Else
   {
      outX := inputX*thisZL + DestPosX - dotSize/2
      outY := inputY*thisZL + DestPosY - dotSize/2
   }

   If (limitBounds=1)
   {
      GetWinClientSize(mW, mH, PVhwnd, 0)
      outX := clampInRange(outX, 0, mW)
      outY := clampInRange(outY, 0, mH)
   }
}

MouseCoords2Image(mX, mY, limitBounds, dPosX, dPosY, newW, newH, ByRef x, ByRef y, whichBitmap:=0, rounding:=1, imgW:=0, imgH:=0) {
    x1 := (dPosX<0) ? mX + Abs(dPosX) : mX - Abs(dPosX)
    y1 := (dPosY<0) ? mY + Abs(dPosY) : mY - Abs(dPosY)
    If (limitBounds=1)
    {
       x1 := clampInRange(x1, 0, newW)
       y1 := clampInRange(y1, 0, newH)
    }

    whichBitmap := whichBitmap ? whichBitmap : useGdiBitmap()
    If (!imgW || !imgH)
       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

    prcx1 := x1/newW
    prcy1 := y1/newH
    x := (rounding=1) ? Round(imgW * prcx1) : imgW * prcx1
    y := (rounding=1) ? Round(imgH * prcy1) : imgH * prcy1
    If (limitBounds=1)
    {
       x := clampInRange(x, 0, imgW)
       y := clampInRange(y, 0, imgH)
    }
    ; ToolTip, % mX " -- " mY "`n" x " -- " y "`n" DestPosX " -- " DestPosY "`n" newW " -- " newH "`n" prcx1 " -- " prcy1, , , 2
}

coreUpdateLiveTinyPreviewsWindow() {
    If (AnyWindowOpen=26)
       livePreviewBlurPanel()
    Else If (AnyWindowOpen=43)
       livePreviewIDedges()
    Else If (AnyWindowOpen=44)
       livePreviewAddNoiser()
    Else If (AnyWindowOpen=64)
       createLivePreviewBrush()
    Else If (AnyWindowOpen=69)
       livePreviewZoomBlurPanel()
}

updateLiveTinyPreviewsWindow(hwnd:=0, eventu:=0) {
   ; function meant to filter out repeated calls
   WinGetClass, WinClass, ahk_id %hwnd%
   If (InStr(WinClass, "_trackbar"))
   {
      ; fnOutputDebug("slider:" hwnd)
      If (eventu!="normal")
         SetTimer, coreUpdateLiveTinyPreviewsWindow, -25
   } Else
      coreUpdateLiveTinyPreviewsWindow()
}

updateTinyPreviewArea(DestPosX, DestPosY, newW, newH, urgent:=0) {
    Static lastInvoked := 1
    If (tinyPrevAreaCoordX="C" || tinyPrevAreaCoordY="C" || urgent=1)
    {
       GetMouseCoord2wind(hGDIwin, mX, mY)
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       mX := (FlipImgH=1) ? mainWidth - mX : mX
       mY := (FlipImgV=1) ? mainHeight - mY : mY
       MouseCoords2Image(mX, mY, 1, DestPosX, DestPosY, newW, newH, x, y)
       tinyPrevAreaCoordX := x, tinyPrevAreaCoordY := y
       If (panelWinCollapsed!=1)
          WinActivate, ahk_id %hSetWinGui%

       If (urgent=1)
       {
          If (A_TickCount - lastInvoked<90)
             Return

          coreUpdateLiveTinyPreviewsWindow()
          lastInvoked := A_TickCount
       } Else
       {
          SetTimer, coreUpdateLiveTinyPreviewsWindow, -100
       }
    } 
}

destroyBlacked() {
  If (imageLoading=1)
  {
     SetTimer, destroyBlacked, -50
     Return
  }
  BlackedCreator(1, 1)
}

ToggleVisibilityWindow(actu, winIDu) {
   Static prevState
   thisState := actu "-" winIDu
   If (thisState=prevState)
      Return

   globalWinStates["a" winIDu] := (actu="show") ? 1 : 0
   If (actu="show")
      WinSet, Region,, ahk_id %winIDu%
   Else
      WinSet, Region, 0-0 w1 h1, ahk_id %winIDu%

   prevState := thisState
}

FadeMainWindow() {
   If (A_TickCount - scriptStartTime<5000)
      Return

   whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
   r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC, 125)
}

GdipCleanMain(modus:=0) {
    If (modus=2)
    {
       ; BlackedCreator(128)
       ; SetTimer, destroyBlacked, -100
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       Gdi_FillShape(glHDC, 0, 0, mainWidth, mainHeight, WindowBgrColor, 1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC, 200)
       Return
    }

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    opacity := (modus=1) ? "0xFF" : "0x50"
    If (modus=4 || modus=5 || modus=6)
    {
       ; BMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       If (modus=4)
       {
          graphPath := Gdip_CreatePath()
          x1 := mainWidth//2 - 45 , x2 := mainWidth//2 + 45
          x3 := mainWidth//2,       y1 := mainHeight//2
          y2 := mainHeight//2,      y3 := mainHeight//2 - 200
          Gdip_AddPathPolygon(graphPath, [x1, y1, x2, y2, x3, y3])
          trGdip_RotatePathAtCenter(graphPath, vpIMGrotation)
       }

       ; trGdip_DrawImage(A_ThisFunc, glPG, BMPcache)
       If (modus=5 || modus=6)
       {
          If (vpIMGrotation>0)
             zoomu := " @ " vpIMGrotation "°"
          zoomu := Round(zoomLevel * 100) "%" zoomu
          thisInfo := max(oldZoomLevel, zoomLevel) - min(oldZoomLevel, zoomLevel)
          If (modus=6)
             thisInfo := zoomu := "( - )"

          If thisInfo
          {
             thisFntSize := (modus!=6) ? OSDfontSize*1.25 : OSDfontSize*0.75
             infoBoxBMP := drawTextInBox(zoomu, OSDFontName, thisFntSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             Gdip_GetImageDimensions(infoBoxBMP, Wi, He)
             If (modus=5)
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2)
             Else
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2,,,,,,, 0.45)
             trGdip_DisposeImage(infoBoxBMP, 1)
          } Else
          {
             imgPath := getIDimage(currentFileIndex)
             zPlitPath(imgPath, 0, OutFileName, OutDir)
             entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
             infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfontSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP)
             trGdip_DisposeImage(infoBoxBMP, 1)
             oldZoomLevel := zoomLevel
          }
       }

       If (modus=4)
       {
          thisW := thisH := 250
          Gdip_FillEllipse(glPG, pBrushE, mainWidth//2 - thisW//2, mainHeight//2 - thisH + 30, thisW, thisH)
          Gdip_FillPath(glPG, pBrushD, graphPath)
          Gdip_DeletePath(graphPath)
       }
       thisOpacity := (modus!=6) ? "0x22" : "0x33"
       Random, hu, 6, 8
       Random, ha, 6, 8
       clr := thisOpacity . ha . hu . ha . hu . ha . hu
       widthu := imgHUDbaseUnit//3
       yPen := Gdip_CreatePen(clr, widthu)
       Gdip_DrawRectangle(glPG, yPen, 0, 0, mainWidth, mainHeight)
       Gdip_DeletePen(yPen)
       whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
       r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC, 225)
       ; trGdip_DisposeImage(BMPcache)
    } Else 
    {
       trGdip_GraphicsClear(A_ThisFunc, glPG, opacity WindowBgrColor)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
    }
}

clearGivenGDIwin(funcu, Gu, DCu, hwnd) {
    trGdip_GraphicsClear(funcu "<-" A_ThisFunc, Gu, "0x00" WindowBgrColor, 1)
    Return doLayeredWinUpdate(funcu "<-" A_ThisFunc, hwnd, DCu)
}

GetCachableImgFileDetails(imgPath, imgIndex, thumbBMP:=0, returnObj:=0, isFilter:=0) {
     If (!imgPath || !imgIndex)
     {
        addJournalEntry(A_ThisFunc "() - incorrect params error: " imgIndex " = " imgPath)
        Return
     }

     r := 0
     ; fnOutputDebug(A_ThisFunc "() - no cache: " imgIndex " = " imgPath)
     If StrLen(thumbBMP)<3
     {
        r := LoadBitmapFromFileu(imgPath, 1)
        If (mainLoadedIMGdetails.OpenedWith="GDI+")
           trGdip_DisposeImage(r, 1)
     } else r := 1

     r := (mainLoadedIMGdetails.Width>1 && mainLoadedIMGdetails.Height>1) ? 1 : 0
     If r
     {
        If (returnObj=1)
        {
           obju := []
           obju.w := mainLoadedIMGdetails.Width
           obju.h := mainLoadedIMGdetails.Height
           obju.pixFmt := mainLoadedIMGdetails.PixelFormat
           obju.frames := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames +1 : 1
           obju.ratio := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
           obju.mgpx := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
           obju.dpi := mainLoadedIMGdetails.dpi
        } Else
        {
           updateFilesListByID(imgIndex, 9, (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1, isFilter)
           updateFilesListByID(imgIndex, 13, mainLoadedIMGdetails.Width, isFilter)
           updateFilesListByID(imgIndex, 14, mainLoadedIMGdetails.Height, isFilter)
           updateFilesListByID(imgIndex, 15, mainLoadedIMGdetails.PixelFormat, isFilter)
           updateFilesListByID(imgIndex, 16, Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2), isFilter)
           updateFilesListByID(imgIndex, 17, Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2), isFilter)
           updateFilesListByID(imgIndex, 22, mainLoadedIMGdetails.dpi, isFilter)

           fileInfos := GetFileAttributesEx(imgPath)
           updateFilesListByID(imgIndex, 6, fileInfos.size, isFilter)
           updateFilesListByID(imgIndex, 7, fileInfos.wTime, isFilter)
           updateFilesListByID(imgIndex, 8, fileInfos.cTime, isFilter)
        }
     } Else obju := r := 0

     If (returnObj=1)
        Return obju
     Else
        Return r
}

MixARGB(color1, color2, t := 0.5, gamma := 1) {
   rgamma := 1/gamma
   a1 := (color1 >> 24) & 0xff,  r1 := (color1 >> 16) & 0xff,  g1 := (color1 >>  8) & 0xff,  b1 := (color1 >>  0) & 0xff
   a2 := (color2 >> 24) & 0xff,  r2 := (color2 >> 16) & 0xff,  g2 := (color2 >>  8) & 0xff,  b2 := (color2 >>  0) & 0xff
   
   ga1 := (a1 / 255) ** gamma,   gr1 := (r1 / 255) ** gamma,   gg1 := (g1 / 255) ** gamma,   gb1 := (b1 / 255) ** gamma
   ga2 := (a2 / 255) ** gamma,   gr2 := (r2 / 255) ** gamma,   gg2 := (g2 / 255) ** gamma,   gb2 := (b2 / 255) ** gamma
   
   ma := ga1 * (1-t) + ga2 * t,  mr := gr1 * (1-t) + gr2 * t,  mg := gg1 * (1-t) + gg2 * t,  mb := gb1 * (1-t) + gb2 * t
   mga := 255 * (ma ** rgamma),  mgr := 255 * (mr ** rgamma),  mgg := 255 * (mg ** rgamma),  mgb := 255 * (mb ** rgamma)

   thisColor := Gdip_ToARGB(mga, mgr, mgg, mgb)
   Return thisColor := Format("{1:#x}", thisColor)
}

initInPlaceTextOptions(Gu, boldu, italicu, NoWrap, thisTextAlign, face, theFntSize, txtColor, bgrColor, borderu) {
    If (OSDfontBolded=1)
       txtStyle .= " Bold"

    If (OSDfontItalica=1 && NoWrap=0)
       txtStyle .= " Italic"

    If !thisTextAlign
       thisTextAlign := (FlipImgH=1) ? "Right" : "Left"
    Else
       thisTextAlign := Trimmer(thisTextAlign)

    txtOptions := []
    txtOptions.Styles := txtStyle
    txtOptions.Align := thisTextAlign
    txtOptions.Color := txtColor
    txtOptions.Size := theFntSize
    txtOptions.Fontu := face
    txtOptions.borderSize := borderu
    txtOptions.wrapu := NoWrap
    fontQuality := (theFntSize>90) ? 2 : 3
    If (theFntSize<20)
       fontQuality := 4

    Gdip_SetTextRenderingHint(Gu, fontQuality)
    Return txtOptions
}

QPV_listThumbnailsGridMode(forceMode, thisGu, thisHDC, thisHwnd) {
    Static zBru := 0
    If !zBru
       zBru := Gdip_BrushCreateSolid("0x66994433")

    If (forceMode!=1)
       setImageLoading()

    startZeit := A_TickCount
    trGdip_GraphicsClear(A_ThisFunc, thisGu, "0xFF" WindowBgrColor)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    rowIndex := 0
    columnIndex := -1
    prevMSGdisplay := A_TickCount
    If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1 && forceMode!=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    If (SLDtypeLoaded=3 && thumbsListViewMode=4 && forceMode!=1)
       activeSQLdb.Exec("BEGIN TRANSACTION;")

    borderSize := imgHUDbaseUnit//5
    txtOptions := initInPlaceTextOptions(thisGu, OSDFontBolded, 0, 1, 0, OSDFontName, OSDfontSize//1.25, "0xEE" OSDtextColor, "0xFF" WindowBGRcolor, borderSize)
    otherTxtObj := TextuToGraphics(thisGu, "initing", txtOptions, OSDFontName, "begin", 0, 0, 1)
    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := StrReplace(resultedFilesList[thisFileIndex, 1], "||")
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        zPlitPath(imgPath, 1, fileNamu, folderu)
        If (userPrivateMode!=1)
           sfolderu := PathCompact(folderu, "a", 1, OSDfontSize//1.25, thumbsW - borderSize)

        ; Gdip_FillRectangle(thisGu, pBrushWinBGR, DestPosX, DestPosY, thumbsW, thumbsH)
        If (StrLen(imgPath)>2 && (thumbsListViewMode=2 || forceMode=1))
        {
           ; no details mode
           entireString := (userPrivateMode=1) ? "******.***`n*:\***\******\`n" : fileNamu "`n" sfolderu "\"
           If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(thisGu, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=3)
        {
           ; file details mode
           ofileSizu := QPV_FileGetSizeTime(imgPath, "S", thisFileIndex)
           fileSizu := fileSizeFrienly(ofileSizu)
           FileDateM := QPV_FileGetSizeTime(imgPath, "M", thisFileIndex)
           FileDateC := QPV_FileGetSizeTime(imgPath, "C", thisFileIndex)
           Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
           Try FormatTime, FileDateC, % FileDateC, dd/MM/yyyy, HH:mm
           fileMsg := FileExist(imgPath) ? FileDateC " | " FileDateM " | " fileSizu : "Error gathering data..."
           entireString := (userPrivateMode=1) ?  mgpx "******.***`n*:\***\******\`n" fileMsg : mgpx fileNamu "`n" sfolderu "\`n" fileMsg
           If (ofileSizu<50 && !InStr(fileMsg, "error"))
           {
              Gdip_FillRectangle(thisGu, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           } Else If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(thisGu, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=4)
        {
           ; image details mode
           If FileExist(imgPath)
           {
              If !resultedFilesList[thisFileIndex, 9]
              {
                 If !retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12], 1)
                    GetCachableImgFileDetails(imgPath, thisFileIndex)

                 If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
                    updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
              }

              Width := resultedFilesList[thisFileIndex, 13]
              Height := resultedFilesList[thisFileIndex, 14]
              CountFrames := (resultedFilesList[thisFileIndex, 9]>1) ? " | " resultedFilesList[thisFileIndex, 9] " f" : ""
              mgpx := " | " resultedFilesList[thisFileIndex, 17] " MPx | " Round(Width/Height, 2)
              ofileSizu := QPV_FileGetSizeTime(imgPath, "S", thisFileIndex)
              fileSizu := " | " fileSizeFrienly(ofileSizu)
              fileMsg := groupDigits(Width) " x " groupDigits(Height) CountFrames mgpx fileSizu
           } Else fileMsg := "Error gathering data"

           entireString := (userPrivateMode=1) ? "******.***`n*:\***\******\`n" fileMsg : fileNamu "`n" sfolderu "\`n" fileMsg
           If ((Width<2 || Height<2 || ofileSizu<50) && !InStr(fileMsg, "error"))
           {
              Gdip_FillRectangle(thisGu, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           } Else If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(thisGu, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        }

        If StrLen(entireString)>2
        {
           txtOptions.x := (FlipImgH=1) ? DestPosX : DestPosX + borderSize
           txtOptions.y := DestPosY + borderSize
           txtOptions.w := thumbsW - borderSize
           txtOptions.h := thumbsH - borderSize
           drawInPlaceTextInBox(thisGu, entireString, txtOptions)
           ; Gdip_ResetClip(thisGu)
           ; trGdip_DrawImage(A_ThisFunc, thisGu, infoBoxBMP2, DestPosX, DestPosY)
           ; infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
           entireString := ""
        } 

        If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1)
        {
           If retrieveSeenImageDBentry(imgPath, thisFileIndex)
              Gdip_DrawRectangle(thisGu, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (A_TickCount - prevMSGdisplay > 450)
        {
           prevMSGdisplay := A_TickCount
           r2 := doLayeredWinUpdate(A_ThisFunc, thisHwnd, thisHDC)
        } Else If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }
    }

    If (SLDtypeLoaded=3 && thumbsListViewMode=4 && forceMode!=1)
       activeSQLdb.Exec("COMMIT TRANSACTION;")

    ; Gdip_DeleteBrush(zBru)
    r2 := doLayeredWinUpdate(A_ThisFunc, thisHwnd, thisHDC)
    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    ; ToolTip, % mainEndZeit - startZeit , , , 2
    If (forceMode!=1)
    {
       prevFullIndexThumbsUpdate := startIndex
       SetTimer, ResetImgLoadStatus, -15
       prevFullThumbsUpdate := A_TickCount
    } Else prevTryThumbsUpdate := A_TickCount
}

mainGdipWinThumbsGrid(mustDestroyBrushes:=0, simpleMode:=0, listMap:=0, actu:="", mapOffset:=0) {
    Critical, on
    Static pBrush1, pBrush2, pBrush3, pBrush4, pBrush5
         , brushesCreated, prevIndexu

    If (mustDestroyBrushes=1 && brushesCreated=1)
    {
       Gdip_DeleteBrush(pBrush1)
       Gdip_DeleteBrush(pBrush2)
       Gdip_DeleteBrush(pBrush3)
       Gdip_DeleteBrush(pBrush4)
       Gdip_DeleteBrush(pBrush5)
       brushesCreated := 0
       Return
    } Else If (mustDestroyBrushes=1)
       Return

    If (thumbsDisplaying!=1)
       Return

    If (brushesCreated!=1)
    {
       pBrush1 := Gdip_BrushCreateSolid("0x88999999")
       pBrush2 := Gdip_BrushCreateSolid("0x55999999")
       pBrush3 := Gdip_BrushCreateSolid("0x400188FF")
       pBrush4 := Gdip_BrushCreateSolid("0x55404040")
       pBrush5 := Gdip_BrushCreateSolid("0x66334433")
       brushesCreated := 1
    }

    selectorWidth := imgHUDbaseUnit//6
    If (selectorWidth>min(thumbsW, thumbsH)*0.3)
       selectorWidth := Round(min(thumbsW, thumbsH)*0.3)

    If (simpleMode=0)
    {
       Gdip_SetPenWidth(pPen6, selectorWidth)
       Gdip_SetPenWidth(pPen1d, selectorWidth//2)
       Gdip_SetPenWidth(pPen5, selectorWidth//2)
    }

    Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    thisThumb := rowIndex := 0, cbox := []
    currentDupeID := columnIndex := -1
    If (simpleMode=0)
    {
       If testIsDupesList()
       {
          isDupesList := 1
          Gdip_SetPenWidth(pPen2, imgHUDbaseUnit//9 + 1)
          currentDupeID := resultedFilesList[currentFileIndex, 23]
          currentDupeDetails := "." resultedFilesList[currentFileIndex, 33] "." resultedFilesList[currentFileIndex, 34]
       }
    }

    If (startIndex=prevIndexu)
       prevIndexu := ""

    If (showInfoBoxHUD>0)
    {
       drawinfoBox(mainWidth, mainHeight, 0, 2NDglPG)
       If (A_TickCount - lastInfoBoxZeitToggle<800)
          Gdip_SetClipRect(2NDglPG, 0, 0, lastInfoBoxBMP[1, 1], lastInfoBoxBMP[1, 2], 4)
    } Else
       interfaceThread.ahkPostFunction("uiAccessUpdateInfoBox", "hide", 1, 1, 0, 0)

    listedItems := ""
    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := resultedFilesList[thisFileIndex, 1]
        imgPathSelected := resultedFilesList[thisFileIndex, 2]
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        If (simpleMode=0)
        {
           tPath := (thumbsListViewMode>1) ? imgPath : SubStr(imgPath, InStr(imgPath, "\", 0, -1) + 1)
           listedItems .= (imgPathSelected=1) ? tPath " (selected).`n" : tPath ".`n"
        }

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        isStringLen := StrLen(imgPath)>5 ? 1 : 0
        If (simpleMode=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           ; Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
           If (isStringLen=0)
              Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (isStringLen=1 && (simpleMode=0 || thisFileIndex=currentFileIndex))
           isFile := FileRexists(imgPath)

        If (simpleMode=1 && isStringLen=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX + 1, DestPosY + 1, thumbsW - 2, thumbsH - 2)
        } Else If (thumbsListViewMode=1 && isFile=0)
        {
           infoBoxBMP2 := drawTextInBox("! " thisFileIndex, OSDFontName, OSDfontSize//1.5, thumbsW, thumbsH, OSDtextColor, OSDbgrColor, 0, 0)
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP2, DestPosX, DestPosY)
           infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
        }

        If (isFile=0)
           Gdip_FillRectangle(2NDglPG, pBrush4, DestPosX, DestPosY, thumbsW, thumbsH)

        If (thisFileIndex=currentFileIndex)
        {
           ; Gdip_FillRectangle(2NDglPG, pBrush1, DestPosX, DestPosY, thumbsW, thumbsH)
           If (thumbsListViewMode=1 && userPrivateMode=0 && simpleMode=0 && showInfoBoxHUD>0)
           {
              MD5name := generateThumbName(imgPath, 1, 1)
              If StrLen(imgThumbsCacheIDsArray[MD5name])>0
                 thisThumb := imgThumbsCacheArray[imgThumbsCacheIDsArray[MD5name], 1]

              If thisThumb
              {
                 Gdip_GetImageDimensions(thisThumb, imgW, imgH)
                 thisThumb := Gdip_CloneBitmap(thisThumb)
                 calcIMGdimensions(imgW, imgH, thumbsW, thumbsH, fW, fH)
                 dpX := DestPosX + thumbsW/2
                 dpX -= (imageAligned!=5) ? thumbsW/2 : fW/2
                 dpY := DestPosY + thumbsH/2
                 dpY -= (imageAligned!=5) ? thumbsH/2 : fH/2
                 flipBitmapAccordingToViewPort(thisThumb)
                 If (usrColorDepth>1)
                    Gdip_BitmapSetColorDepth(thisThumb, internalColorDepth, ColorDepthDithering)

                 thisThumb := applyVPeffectsOnBMP(thisThumb)
                 Gdip_DrawImage(2NDglPG, thisThumb, dpX, dpY, fW, fH,,,,, 0.3)
                 Gdip_DisposeImage(thisThumb)
              }
           }

           If (isStringLen=1)
           {
              zPlitPath(imgPath, 1, fileNamu, folderu)
              If isFile
              {
                 QPV_FileGetSizeTime(imgPath, "R", thisFileIndex)
                 fileSizu := fileSizeFrienly(resultedFilesList[thisFileIndex, 6])
                 FileDateM := resultedFilesList[thisFileIndex, 7]
                 Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
                 fileMsg := fileSizu " | " FileDateM
                 fileMsg2 := "File size: " fileSizu " | Modified date: " FileDateM
              } Else 
              {
                 fileMsg := (isStringLen=1) ? "File access error" : "-"
                 fileMsg2 := (isStringLen=1) ? "File access error" : ""
              }

              delim := (multilineStatusBar=1 || simpleMode>=1) ? "`n" : " | "
              If (multilineStatusBar=1 && userPrivateMode!=1)
                 folderuz := PathCompact(folderu, "a", 1, Ceil(OSDfontSize*0.9), mainWidth - OSDfontSize//2)
              Else
                 folderuz := folderu

              namu := (userPrivateMode=1) ? "******.***" delim "*:\***\******\" : fileNamu delim folderuz "\"
              namu2 := (userPrivateMode=1) ? "" : "File: " fileNamu delim "Location: " folderu "\"
              fileIndexu := (multilineStatusBar=1) ? groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) : groupDigits(currentFileIndex) 
              fileIndexu2 := "Current index: " groupDigits(currentFileIndex) ". " groupDigits(maxFilesIndex)
              theMsg := fileIndexu " | " fileMsg " | " namu
              theMsg2 := fileIndexu2 " files listed | " fileMsg2 " | " namu2
           }
        }

        If (imgPathSelected=1)
        {
           countSel++
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_FillRectangle(2NDglPG, pBrush3, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (resultedFilesList[thisFileIndex, 3]=1 && highlightAlreadySeenImages=1)
           Gdip_DrawRectangle(2NDglPG, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)

        If (currentDupeID=resultedFilesList[thisFileIndex, 23] && simpleMode=0 && isDupesList=1 && fadeOtherDupeGroups!=1)
        {
           thisu := imgHUDbaseUnit//3.5
           Gdip_DrawLine(2NDglPG, pPen2, DestPosX, DestPosY, DestPosX + thumbsW, DestPosY)
           Gdip_DrawLine(2NDglPG, pPen2, DestPosX, DestPosY + thumbsH, DestPosX + thumbsW, DestPosY + thumbsH)
           Gdip_FillEllipse(2NDglPG, pBrushA, DestPosX + thumbsW//2 - thisu//2, DestPosY + thumbsH//2 - thisu//2, thisu, thisu)
           Gdip_FillEllipse(2NDglPG, pBrushA, DestPosX + thumbsW//2 - thisu//2 + 2, DestPosY + thumbsH//2 - thisu//2 + 2, thisu, thisu)
        } Else If (isDupesList=1 && fadeOtherDupeGroups=1 && currentDupeID!=resultedFilesList[thisFileIndex, 23])
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)

        If (thisFileIndex=EntryMarkedMoveIndex)
           Gdip_FillRectangle(2NDglPG, pBrushC, DestPosX, DestPosY, thumbsW, thumbsH)

        If (thisFileIndex=currentFileIndex)
           Gdip_DrawRectangle(2NDglPG, pPen6, DestPosX, DestPosY, thumbsW, thumbsH)

        If (resultedFilesList[thisFileIndex, 5]=1) ; is bookmarked
           Gdip_DrawRectangle(2NDglPG, pPen1d, DestPosX, DestPosY, thumbsW, thumbsH)
    }

    If (countSel>markedSelectFile && countSel>1 && markedSelectFile>1)
       SetTimer, dummyRecountSelectedFiles, -100

    If (mustDrawBoxNow=1 || simpleMode>=1)
    {
       ; draw top line progress bar
       knobSize := imgHUDbaseUnit//3.5
       Gdip_FillRectangle(2NDglPG, pBrushE, 0, 0, mainWidth, knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, Round(mainWidth*(currentFileIndex/maxFilesIndex)), knobSize//2)
    }

    If StrLen(filesFilter)>1
       theMsg := "[F] " theMsg

    prevIndexu := startIndex
    If markedSelectFile
    {
       Gdip_FillRectangle(2NDglPG, pBrush1, 0, 0, mainWidth, imgHUDbaseUnit//5)
       theMsg := groupDigits(markedSelectFile) " selected | " theMsg
       theMsg2 := groupDigits(markedSelectFile) " files selected | " theMsg2
    }

    scrollYpos := startIndex/maxFilesIndex
    scrollYpos := Round(mainHeight*scrollYpos)
    thisFileIndex := currentFileIndex
    If (thisFileIndex>maxFilesIndex - maxItemsPage)
       thisFileIndex := maxFilesIndex - maxItemsPage

    scrollHeight := (maxItemsPage/maxFilesIndex)*100
    scrollHeight := Ceil((mainHeight/100)*scrollHeight)
    If (scrollHeight<imgHUDbaseUnit//4.5)
       scrollHeight := imgHUDbaseUnit//4.5

    scrollYpos := clampInRange(scrollYpos, 1, mainHeight - imgHUDbaseUnit//4.5)
    If (StrLen(theMsg)>1)
    {
       bgrTXT := (resultedFilesList[currentFileIndex, 2]=1) ? SubStr(MixARGB("0xFF0188FF", "0xFF" WindowBgrColor, 0.65), 5) : OSDbgrColor
       If isDupesList
       {
          theMSG := "DUPE ID: " currentDupeID StrReplace(currentDupeDetails, ".2500") " | " theMSG
          theMSG2 := "DUPE ID: " currentDupeID StrReplace(currentDupeDetails, ".2500") " | " theMSG2
          mpxu := " | " Round(resultedFilesList[currentFileIndex, 17], 2) " MPx"
          mpxu2 := " | " Round(resultedFilesList[currentFileIndex, 17], 2) " Megapixels"
          theMSG := StrReplace(theMSG, " MB |", " MB" mpxu " |")
          theMSG := StrReplace(theMSG, " KB |", " KB" mpxu " |")
          theMSG2 := StrReplace(theMSG2, " MB |", " MB" mpxu2 " |")
          theMSG2 := StrReplace(theMSG2, " KB |", " KB" mpxu2 " |")
       } Else If (SLDtypeLoaded=3 && resultedFilesList[currentFileIndex, 33]!="")
       {
          thisu := resultedFilesList[currentFileIndex, 33]
          labelu2 := defineSQLdbSort()
          labelu := StrReplace(labelu2, "histogram", "Histo")
          If (InStr(labelu, "histo") && !InStr(labelu, "rms"))
             thisu := thisu * 256
          If InStr(thisu, ".")
             thisu := Round(thisu, 2)
          theMSG := labelu ": " thisu " | " theMSG
          theMSG2 := labelu2 ": " thisu " | " theMSG2
       }

       hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
       tlbrBonusX := (hasTrans=1 && (ToolbarWinH - 3 > mainHeight - ThumbsStatusBarH)) ? ToolbarWinW + 5 : 0
       tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
       infoBoxBMP := drawTextInBox(theMsg, OSDFontName, Round(OSDfontSize*0.9), mainWidth, mainHeight//3, OSDtextColor, bgrTXT, 1)
       Gdip_GetImageDimensions(infoBoxBMP, ThumbsStatusBarW, ThumbsStatusBarH)
       statusPosX := -1 + tlbrBonusX
       ThumbsStatusBarW := clampInRange(ThumbsStatusBarW, 1, mainWidth - imgHUDbaseUnit//3.3)
       If tlbrBonusX
          Gdip_FillRectangle(2NDglPG, OSDwinFadedBrushBGR, 0, mainHeight - ThumbsStatusBarH, tlbrBonusX, ThumbsStatusBarH)

       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, statusPosX, mainHeight - ThumbsStatusBarH)
       If (simpleMode=0)
       {
          ; theMSG2 := theMSG
          If (markSearchMatches=1 && userSearchString && modus!="all")
          {
             If coreSearchIndex(getIDimage(currentFileIndex), thisSearchString, userSearchWhat)
             {
                Gdip_FillRectangle(2NDglPG, pBrushD, statusPosX, mainHeight - ThumbsStatusBarH, OSDfontSize//2.5+1, ThumbsStatusBarH)
                theMSG2 .= " | File matches search criteria" 
             }
          }

          If (resultedFilesList[currentFileIndex, 3]=1)
          {
             Gdip_DrawRectangle(2NDglPG, pPen5, statusPosX, mainHeight - ThumbsStatusBarH, ThumbsStatusBarW, ThumbsStatusBarH)
             theMSG2 .= " | Image already seen"
          }

          If (resultedFilesList[currentFileIndex, 5]=1)
          {
             Gdip_DrawRectangle(2NDglPG, pPen1d, statusPosX, mainHeight - ThumbsStatusBarH, ThumbsStatusBarW, ThumbsStatusBarH)
             theMSG2 .= " | Added to favourites"
          }

          If (bgrTXT!=OSDbgrColor)
             theMSG2 .= " | File selected"

          If StrLen(filesFilter)>1
             theMSG2 .= " | Files list filtered"

          listInfos := "Files list container: " maxItemsPage " elements in view. Listing mode: " defineListViewModes() ". Tap and hold, or Control+Left-Click, on any listed item to select it. Items listed:`n" listedItems
          interfaceThread.ahkPostFunction("uiAccessUpdateUiStatusBar", theMSG2, ThumbsStatusBarH, 0, listInfos, OSDfontSize, maxFilesIndex)
          trGdip_DisposeImage(infoBoxBMP, 1)
          If (showHUDnavIMG=1) ;  && (thumbsListViewMode>1 || isDupesList=1))
             VPnavBoxWrapper(mainWidth, mainHeight - ThumbsStatusBarH, 2NDglPG)
          Else
             interfaceThread.ahkPostFunction("uiAccessUpdateNavBox", "hide", 1, 1, 0, 0)
       }
    }

    lineThickns := imgHUDbaseUnit//3
    If mapOffset
       mapOffset := scrollYpos - scrollYpos*2

    If StrLen(listMap)>2
       Gdip_DrawImage(2NDglPG, listMap, mainWidth - lineThickns - imgHUDbaseUnit//2, mapOffset)

    Gdip_ResetClip(2NDglPG)
    If (scrollHeight<mainHeight)
    {
       whichBrush := (actu="scroll") ? pBrushWinBGR : pBrushC
       Gdip_FillRectangle(2NDglPG, whichBrush, mainWidth - lineThickns, 0, lineThickns, mainHeight)
       Gdip_FillRectangle(2NDglPG, pBrushE, mainWidth - lineThickns, 0, lineThickns, mainHeight)
       Gdip_FillRectangle(2NDglPG, pBrushD, mainWidth - lineThickns + 5, scrollYpos, lineThickns, scrollHeight)
    }

    SetTimer, ResetImgLoadStatus, -25
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
    If (toolTipGuiCreated=2)
    {
       clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       toolTipGuiCreated := 0
    }
}

generateFilesListMap(dummy:=0) {
   Static lastVal := 0
   thisVal := 0
   If (!markedSelectFile && dummy="auto")
      thisVal := lastVal ? 5 : 3
   Else
      thisVal := 2

   lastVal := !lastVal
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   mainBMP := trGdip_CreateBitmap(A_ThisFunc, 2, maxFilesIndex)
   G1 := trGdip_GraphicsFromImage(A_ThisFunc, mainBMP)
   Gdip_GraphicsClear(G1, "0xFF" WindowBgrColor)
   thisColor := (thisVal=2) ? "33EEFF" : "FF9922"
   thisThick := (maxFilesIndex - 10<mainHeight) ? 1 : 2
   If (thisVal=2 && markedSelectFile/maxFilesIndex<3 && maxFilesIndex>mainHeight*2)
      thisThick := 3

   countThese := 0
   selPen := Gdip_CreatePen("0xFF" thisColor, thisThick)
   Loop, % maxFilesIndex
   {
        If resultedFilesList[A_Index, thisVal]
        {
           Gdip_DrawLine(G1, selPen, -1, A_Index, 3, A_Index)
           countThese++
        }
   }

   Gdip_DeleteGraphics(G1)
   Gdip_DeletePen(selPen)
   If !countThese
   {
      trGdip_DisposeImage(mainBMP)
      Return
   }

   If (thisVal=2)
      markedSelectFile := countThese

   doubled := 0
   If (maxFilesIndex//3>mainHeight && dummy!="auto")
   {
      doubled := 1
      mainHeight *= 2
   }

   knobSize := imgHUDbaseUnit//2
   finalBMP := trGdip_ResizeBitmap(A_ThisFunc, mainBMP, knobSize, mainHeight, 0, 7)
   trGdip_DisposeImage(mainBMP)
   
   sFinal := trGdip_CreateBitmap(A_ThisFunc, knobSize, mainHeight, "0x21808")
   G1 := trGdip_GraphicsFromImage(A_ThisFunc, sFinal)
   Gdip_DrawImageFast(G1, finalBMP)
   Gdip_DrawImageFast(G1, finalBMP)
   Gdip_DeleteGraphics(G1)
   trGdip_DisposeImage(finalBMP)

   Return [sFinal, thisVal, doubled]
}

dummyRecountSelectedFiles() {
   getSelectedFiles(0, 1)
}

EraseThumbsCache(dummy:=0, remCacheOldDays:=0) {
   startZeit := A_TickCount
   showTOOLtip("Emptying thumbnails cache, please wait")
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   countTFilez := countFilez := 0
   Loop, Files, %thumbsCacheFolder%\*.*
   {
      If !(A_LoopFileExt="tiff" || A_LoopFileExt="png" || A_LoopFileExt="jpg")
         Continue

      changeMcursor()
      timeNow := %A_Now%
      EnvSub, timeNow, %A_LoopFileTimeCreated%, Days
      mustRem := (timeNow>remCacheOldDays && dummy="daysITis") ? 1 : 0
      countTFilez++
      If (mustRem=1 || dummy!="daysITis")
      {
         FileDelete, % A_LoopFileFullPath
         If !ErrorLevel
            countFilez++
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         showTOOLtip("Emptying thumbnails cache, please wait`n" countFilez " removed until now.")
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   If (dummy="daysITis")
   {
      moreInfo := " out of " countTFilez
      friendly := " older than " remCacheOldDays " days"
   }


   If (abandonAll=1)
      showTOOLtip("Operation aborted. Removed " countFilez " cached thumbnails until now")
   Else If (A_TickCount - startZeit>1500) || (dummy="daysITis")
      showTOOLtip("Finished removing " countFilez moreInfo " cached thumbnails" friendly)
   
   remCacheOldDays := 0
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createThumbsFolder() {
    If !FolderExist(thumbsCacheFolder)
    {
       FileCreateDir, %thumbsCacheFolder%
       If ErrorLevel
          Return "error"
    }
}

ObjToString(obj) {
  if (!IsObject(obj))
    return obj
  str := "`n{"
  for key, value in obj
    str .= "`n" key ": " ObjToString(value) ","
  return str "`n}"
}

CustomObjToString(obj) {
  if (!IsObject(obj))
    return obj
;  str := "|&|"
  for key, value in obj
    str .= "?" key "|" CustomaObjToString(value)
  return str ; "|&|"
}

CustomaObjToString(obj) {
  if (!IsObject(obj))
    return obj
 ; str := "/&/"
  for key, value in obj
    str .= "<" ObjToString(value) "@"
  return str ; "/&/"
}

StrToObject(stringu) {
  newArrayu := []
  Loop, Parse, stringu, ?
  {
      If !A_LoopField
         Continue
      lineArrayu := StrSplit(A_LoopField, "|<")
      thisIndex := lineArrayu[1]
      preparedOther := StrReplace(lineArrayu[2], "@")
      otherLineArrayu := StrSplit(preparedOther, "<")
      ; MsgBox, % A_LoopField "`n" thisIndex "`n" preparedOther "`n" otherLineArrayu[1] "`n" lineArrayu[2] "`n" A_Index
      Loop, % otherLineArrayu.Count()
          newArrayu[thisIndex, A_Index] := otherLineArrayu[A_Index]
  }
  ; MsgBox, % CustomObjToString(newArrayu)
  Sleep, 50
  Return newArrayu
}

generateAllThumbsNow() {
   Static chunkSize := 1500
   If (thumbsDisplaying!=1 || maxFilesIndex<3 || !CurrentSLD)
      Return

   currentFileIndex := 1
   thumbsListViewMode := 1
   ; If (thumbnailsListMode!=1)
   ;    initAHKhThumbThreads()

   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   loopTimes := Ceil(maxFilesIndex/chunkSize)
   startZeit := A_TickCount
   Loop, % loopTimes
   {
      currentFileIndex := (A_Index - 1) * chunkSize
      If !currentFileIndex
         currentFileIndex := 1

      r := QPV_ShowThumbnails("all", A_Index * chunkSize, startZeit)
      If r
         Break
   }
 
   currentFileIndex := 1
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(90)
   SoundBeep , 900, 100
   SetTimer, ResetImgLoadStatus, -25
   RemoveTooltip()
}

ScreenCaptureListView() {
   ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIselectwin)
   ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   pBitmap := Gdip_BitmapFromHWND(PVhwnd, 1)
   If StrLen(pBitmap)>1
   {
      r := Gdip_SetBitmapToClipboard(pBitmap)
      trGdip_DisposeImage(pBitmap, 1)
      If !r
      {
         showDelayedTooltip("List view captured as image. It is now in the Clipboard.`nYou can paste the image in the image view.")
      } Else
      {
         SoundBeep 300, 100
         showDelayedTooltip("ERROR: Failed to set image to clipoard")
      }
   } Else
   {
      SoundBeep 300, 100
      showDelayedTooltip("ERROR: Failed to capture image of the list view")
   }
   dummyTimerDelayiedImageDisplay(50)
}

QPV_ShowThumbnails(modus:=0, allStarter:=0, allStartZeit:=0) {
    Critical, on

    prevFullThumbsUpdate := A_TickCount
    mainStartZeit := A_TickCount
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    If (modus="all")
    {
       maxItemsW := maxItemsH := allStarter//2 + 1
       maxItemsPage := allStarter + 1
       ; MsgBox, % maxItemsPage
    }

    If (thumbsListViewMode>1)
    {
       QPV_listThumbnailsGridMode(0, glPG, glHDC, hGDIthumbsWin)
       Return
    }

    setImageLoading()
    If (minimizeMemUsage!=1)
    {
       thumbsBitmap := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, coreDesiredPixFmt)
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbsBitmap, 5, 1)
       If !G2
       {
          trGdip_DisposeImage(thumbsBitmap, 1)
          thumbsBitmap := ""
          G2 := glPG
       }
    } Else G2 := glPG

    hasUpdated := rowIndex := imgsListed := 0
    maxImgSize := maxZeit := columnIndex := -1
    fnOutputDebug("Begin show " maxItemsPage " thumbs from index " startIndex)
    setPriorityThread(-2)
    DestroyGIFuWin()
    createThumbsFolder()
    Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
    If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, mainWidth + 5, mainHeight + 5)
    prevGUIupdate := A_TickCount
    imgsListArrayThumbs := []
    lastMsg := imgsMustPaint := imgsNotCached := 0
    doStartLongOpDance()
    Loop, % maxItemsW*maxItemsH*2
    {
        ; identify what needs to be done; are thumbs cached in memory? load files or...?

        If (modus="all" && maxFilesIndex>100)
        {
           If (determineTerminateOperation()=1)
           {
              fnOutputDebug("ThumbsMode. User abandoned the operation during preparations phase of generate all thumbs.")
              abandonAll := 1
              hasUpdated := 0
              Break
           }
        }

        thisFileIndex := startIndex + A_Index - 1
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH || thisFileIndex>maxFilesIndex) || (modus="all" && thisFileIndex>allStarter)
        {
           ; If (thisFileIndex>maxFilesIndex)
           ;    SoundBeep , 300, 100
           Break
        }

        If (modus="all") && (A_TickCount - lastMsg > 450)
        {
           lastMsg := A_TickCount
           showTOOLtip("Preparing to generate all thumbnails: " thisFileIndex "/" maxFilesIndex, 0, 0, thisFileIndex / maxFilesIndex)
        }

        imgPath := StrReplace(getIDimage(thisFileIndex), "||")
        thisFileDead := (StrLen(imgPath)<5 || !FileRexists(imgPath)) ? 1 : 0
        DestPosX := thumbsW//2 + thumbsW*columnIndex
        DestPosY := thumbsH//2 + thumbsH*rowIndex
        memCached := wasThumbCached := 0
        MD5name := generateThumbName(imgPath, 1, 1)
        isForceRefresh := resultedFilesList[thisFileIndex, 4]
        If (thisFileDead=1)
        {
           imgsListArrayThumbs[thisFileIndex] := ["x", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else If StrLen(imgThumbsCacheIDsArray[MD5name])>0
        {
           memCached := 1
           imgsListArrayThumbs[thisFileIndex] := ["m", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else
        {
           wasThumbCached := (isForceRefresh=1) ? 0 : checkThumbExists(MD5name, imgPath, file2load)
           fnOutputDebug("Thumb = " thisFileIndex  " cached=" wasThumbCached " original file: " imgPath " thumb file: " file2load)
           If (wasThumbCached=1)
              imgsListArrayThumbs[thisFileIndex] := ["f", 0, imgPath, file2load, DestPosX, DestPosY, MD5name]
        }

        If (currentFileIndex=thisFileIndex)
        {
           sizeSquare := thumbsSizeQuality//10
           Gdip_FillRectangle(glPG, pBrushA, DestPosX - sizeSquare//2, DestPosY - sizeSquare//2, sizeSquare, sizeSquare)
        }

        imgsMustPaint++
        If (memCached=1 || wasThumbCached=1 || thisFileDead=1) && (isForceRefresh!=1)
           Continue

        imgsNotCached++
        ; Gdip_FillRectangle(glPG, pBrushE, DestPosX - 10, DestPosY - 10, 20, 20)
        file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
        If (isForceRefresh=1)
        {
           FileDelete, % file2save
           resultedFilesList[thisFileIndex, 4] := 0
        }

        thisType := imgPath ? "w" : "x"
        imgsListArrayThumbs[thisFileIndex] := [thisType, 0, imgPath, file2save, DestPosX, DestPosY, MD5name]
        ; fnoutputdebug("thumbs prepare " imgPath "|" thisFileIndex "|" MD5name)
    }

   limitCores := realSystemCores + 1
   filesPerCore := imgsNotCached//limitCores
   If (filesPerCore<2 && limitCores>1)
   {
      systemCores := imgsNotCached//2
      filesPerCore := imgsNotCached//systemCores
   } Else systemCores := limitCores

   maxLimitReached := (minimizeMemUsage=1) && (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
   mustDoMultiCore := (allowMultiCoreMode=1 && maxLimitReached!=1 && systemCores>1 && filesPerCore>1 && multiCoreThumbsInitGood=1) ? 1 : 0
   fnOutputDebug("ThumbsMode. Init. doMultiCore:" mustDoMultiCore ", cores:" systemCores ", filesPerCore:" filesPerCore ", imgsNotCached:" imgsNotCached ", imgsMustPaint:" imgsMustPaint)
   mamUsage := GetProcessMemoryUsage(QPVpid)
   systemMemInfo := GlobalMemoryStatusEx()
   thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/Round(systemMemInfo.TotalPhys*0.9))*100, 1)
   fnOutputDebug("ThumbsMode. Memory usage: " thisMemoryLoad "%")
   If (thisMemoryLoad>70 || isWinXP=1)
   {
      fnOutputDebug("ThumbsMode. Memory usage above 70%. Multi-threaded thumbnails generation deactivated.")
      mustDoMultiCore := 0
   }

   ; how much time in miliseconds can an image take to load and not be cached
   timePerImg := 1550//imgsNotCached
   If (timePerImg<25 || modus="all")
      timePerImg := 25
   Else If (timePerImg>300)
      timePerImg := 300

   timePerImgMultiCore := (modus="all") ? 25 : timePerImg*2 + limitCores*2
   If (timePerImgMultiCore>350)
      timePerImgMultiCore := 350

   If (mustDoMultiCore=1)
   {
      fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. Cores: " limitCores)
      Loop, % limitCores
          thumbThread%A_Index%.ahkPostFunction("cleanMess", "c" A_Index)
      ; fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. DONE")
   } Else limitCores := 1

   thisImgQuality := (userimgQuality=1) ? 6 : 5
   sizesDesired := []
   sizesDesired[1] := [thumbsSizeQuality, thumbsSizeQuality, 1, 0, thisImgQuality]
   thisFileIndex := MD5name := Bindex := hasUpdated := rowIndex := imgsListed := lastMsg := 0
   imgsHavePainted := thisNonCachedImg := coreIndex := threadIndex := memCached := lapsOccured := totalLoops := 0
   lowestGiven := maxIndexu := maxImgSize := maxZeit := columnIndex := -1
   prevCoreEventZeit := A_TickCount - 2
    ; MsgBox, % filesPerCore "--" imgsMustPaint "--" imgsNotCached "--" imgsListArrayThumbs.Length()
   interfaceThread.ahkassign("alterFilesIndex", 0)
   If (userPrivateMode=1)
      blurEffect := Gdip_CreateEffect(1, clampInRange(thumbsSizeQuality//2, 30, thumbsSizeQuality*2), 0, 0)

   If (abandonAll!=1)
   {
      Loop
      {
          alterFilesIndex := interfaceThread.ahkgetvar.alterFilesIndex
          If (alterFilesIndex>1 && lapsOccured>3)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation by scrolling.")
             userScrolled := 1
             Break
          }

          totalLoops++
          If (determineTerminateOperation()=1)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation.")
             abandonAll := 1
             hasUpdated := 0
             Break
          }

          ; Sleep, 0
          Bindex++
          If (Bindex>imgsMustPaint)
          {
             lapsOccured++
             Bindex := 1
          }

          thisFileIndex := startIndex + Bindex - 1
          If (mustEndLoop=1)
          {
             fnOutputDebug("ThumbsMode. Must end loop = 1. laps " lapsOccured "  -- loops " totalLoops "  -- inner " innerLoops " ")
             hasUpdated := 0
             Break
          }

          If (imgsHavePainted>=imgsMustPaint)
             mustEndLoop := 1

          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          If (cacheType="d")
             Continue

          If (cacheType="x")
          {
             addJournalEntry("ThumbsMode. Failed to generate. " thisFileIndex " = " imgsListArrayThumbs[thisFileIndex, 3])
             imgsListArrayThumbs[thisFileIndex, 1] := "d"
             thumbsFailures++
             imgsHavePainted++
             Continue
          }

          If (modus="all") && (A_TickCount - lastMsg > 750)
          {
             allStuffPerc := (startIndex + imgsHavePainted) / maxFilesIndex
             etaTime := ETAinfos(startIndex + imgsHavePainted, maxFilesIndex, allStartZeit)
             If (mustDoMultiCore=1)
                etaTime .= "`nUsing multi-threaded processing"

             showTOOLtip("Generating all thumbnails at " thumbsSizeQuality "px: " etaTime, 0, 0, allStuffPerc)
             lastMsg := A_TickCount
          }

          innerLoops++
          If (cacheType="w" && mustDoMultiCore=1)
          {
             ; Sleep, -1
             thisCoreDoneLine := ""
             thisCoreDoneArr := ""
             whichCoreBusy := imgsListArrayThumbs[thisFileIndex, 2]
             mamUsage := GetProcessMemoryUsage(QPVpid)
             systemMemInfo := GlobalMemoryStatusEx()
             thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/Round(systemMemInfo.TotalPhys*0.9))*100, 1)
             If (A_TickCount - prevCoreEventZeit>69500 && innerLoops>2 && lapsOccured>2 && totalLoops>2)
             {
                fnOutputDebug("ThumbsMode. Wait time since last new core started ... exceeded.  " thisFileIndex " . Loop. Break. Now. :-) ")
                Break
             }

             If (whichCoreBusy>0)
             {
                hasThumbFailed := thumbThread%whichCoreBusy%.AHKgetvar.operationFailed
                thisCoreDoneLine := thumbThread%whichCoreBusy%.AHKgetvar.resultsList
                thisCoreDoneArr := StrSplit(thisCoreDoneLine, "|")
                waitDataCollect := thumbThread%whichCoreBusy%.AHKgetvar.waitDataCollect
                If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && thisCoreDoneArr[5]=Bindex && waitDataCollect=1)
                {
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "fim"
                   imgsListArrayThumbs[thisCoreDoneArr[3], 2] := thisPBitmap
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      addJournalEntry("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "x"
                   }
                } Else If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && waitDataCollect=1)
                {
                   ; SoundBeep 
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisFileIndex := thisCoreDoneArr[3]
                   Bindex := thisCoreDoneArr[5]
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   imgsListArrayThumbs[thisFileIndex, 1] := "fim"
                   imgsListArrayThumbs[thisFileIndex, 2] := thisPBitmap
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      addJournalEntry("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisFileIndex, 1] := "x"
                   }
                } Else Continue
             } Else
             {
                coreIndex++
                If (coreIndex>limitCores)
                   coreIndex := 1

                thisCoreDone := thumbThread%coreIndex%.AHKgetvar.operationDone
                waitDataCollect := thumbThread%coreIndex%.AHKgetvar.waitDataCollect
                hasThumbFailed := thumbThread%coreIndex%.AHKgetvar.operationFailed
                If (thisMemoryLoad<90 && thisCoreDone=1 && waitDataCollect<1 && hasThumbFailed=0)
                {
                   prevCoreEventZeit := A_TickCount
                   thumbThread%coreIndex%.ahkassign("operationDone", 0)
                   thumbThread%coreIndex%.ahkassign("waitDataCollect", 0)
                   thisPath := imgsListArrayThumbs[thisFileIndex, 3]
                   thisSavePath := imgsListArrayThumbs[thisFileIndex, 4]
                   thumbThread%coreIndex%.ahkPostFunction("MonoGenerateThumb", thisPath, thisSavePath, enableThumbsCaching, thumbsSizeQuality, timePerImgMultiCore, coreIndex, thisFileIndex, Bindex)
                   imgsListArrayThumbs[thisFileIndex, 2] := coreIndex
                   fnOutputDebug("ThumbsMode. Work assigned to thread. IMG #" thisFileIndex ". Core " coreindex " ")
                   Sleep, 1
                }
                Continue
             }
          }

          ; Sleep, 1
          changeMcursor()
          startZeit := A_TickCount
          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          fnOutputDebug("thumbs inner " thisCoreDoneLine " -- cT" cacheType " --cB" whichCoreBusy  " -- " reallyThreadsDone " -- loops infos " A_Index " -- " innerLoops " -- " lapsOccured " -- " totalLoops " -- " imgsHavePainted " -- " imgsMustPaint)
          fimCached := mustDisposeImgNow := 0
          wasCacheFile := thumbCachable := WasMemCached := hasNowMemCached := 0
          If (cacheType="w")
          {
             ; when the original file must be loaded
             If (mustDoMultiCore=1)
                Continue

             ; mustDisposeImgNow := 1
             thumbCachable := 1
             imgsListArrayThumbs[thisFileIndex, 1] := "f"
             oBitmap := 0
             file2load := imgsListArrayThumbs[thisFileIndex, 3]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 0, 0, sizesDesired)
             GetCachableImgFileDetails(file2load, thisFileIndex, oBitmap, 0, 0)
          } Else If (cacheType="m")
          {
             WasMemCached := 1
             MD5name := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := imgThumbsCacheArray[imgThumbsCacheIDsArray[MD5name], 1]
          } Else If (cacheType="f")
          {
             wasCacheFile := 1
             file2load := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 1)
          } Else If (cacheType="fim")
          {
             fimCached := 1
             oBitmap := imgsListArrayThumbs[thisFileIndex, 2]
             If !oBitmap
             {
                ; mustDisposeImgNow := 1
                cacheType := "f"
                wasCacheFile := 1
                fimCached := 0
                file2load := imgsListArrayThumbs[thisFileIndex, 4]
                fnOutputDebug("missing thumb cached with a FIM thread " thisFileIndex ". Trying to load file... " file2load)

                If !FileRexists(file2load)
                {
                   wasCacheFile := fimCached := 0
                   thumbCachable := 1
                   file2load := imgsListArrayThumbs[thisFileIndex, 3]
                   oBitmap := LoadBitmapFromFileu(file2load, 0, 0, 0, sizesDesired)
                } Else
                   oBitmap := LoadBitmapFromFileu(file2load, 0, 1)
             }
          }

          extendedLoops++
          imgsListArrayThumbs[thisFileIndex, 1] := "d"
          imgPath := imgsListArrayThumbs[thisFileIndex, 3]
          MD5name := imgsListArrayThumbs[thisFileIndex, 7]
          file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
          Gdip_GetImageDimensions(oBitmap, imgW, imgH)

          If (!oBitmap || !FileExist(imgPath) || !imgW || !imgH)
          {
             If (WasMemCached=1)
             {
                wasThumbCached := checkThumbExists(MD5name, imgPath, file2load)
                imgsListArrayThumbs[thisFileIndex, 1] := FileExist(file2load) ? "fim" : "w"
                imgsListArrayThumbs[thisFileIndex, 2] := 0
                imgsListArrayThumbs[thisFileIndex, 4] := file2load
             } Else imgsHavePainted++

             fnOutputDebug("broken thumb: mem" WasMemCached " -- w" imgW "-- h" imgH "-- obj bmp id" oBitmap)
             Continue
          } Else imgsHavePainted++

          If (thumbCachable=1)
          {
             fnOutputDebug("must resize GDI object thumbCachable=1. " oBitmap)
             zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, thumbsW, thumbsH, 1, thisImgQuality, -1)
             If zBitmap
             {
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. " oBitmap)
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. DONE")
                oBitmap := zBitmap
             }
          } Else If (WasMemCached!=1 && modus!="all")
          {
             fnOutputDebug("must clone GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
             zBitmap := cloneGDItoMem(A_ThisFunc, oBitmap, imgW, imgH)
             If (fimCached!=1)
             {
                fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. DONE")
             }
             If zBitmap
                oBitmap := zBitmap
          }

          thisZeit := A_TickCount - startZeit
          fnOutputDebug("MEM cached thumbs infos: " memCached " -- " hasMemThumbsCached " -- " imgThumbsCacheIDsArray[MD5name] " = " file2save)
          Gdip_GetImageDimensions(oBitmap, newW, newH)
          If (!newW || !newH)
          {
             addJournalEntry("Faulty GDI thumbnail. File Index: " thisFileIndex ". GDI bmp: " oBitmap "." imgsListArrayThumbs[thisFileIndex, 3])
             oBitmap := trGdip_DisposeImage(oBitmap, 1)
             ; fnOutputDebug("ThumbsMode. Faulty GDI thumbnail object disposed.")
             Continue
          }

          If (WasMemCached!=1 && minimizeMemUsage!=1 && modus!="all")
          {
             hasNowMemCached := 1
             hasMemThumbsCached++ 
             fnOutputDebug("ThumbsMode. Memory cached GDI thumb to be disposed: " imgThumbsCacheArray[hasMemThumbsCached, 1] )
             trGdip_DisposeImage(imgThumbsCacheArray[hasMemThumbsCached, 1], 1)
             ; fnOutputDebug("ThumbsMode. A memory cached GDI thumb to be disposed... DONE")
             imgThumbsCacheIDsArray[imgThumbsCacheArray[hasMemThumbsCached, 2]] := ""
             imgThumbsCacheArray[hasMemThumbsCached] := [oBitmap, MD5name]
             imgThumbsCacheIDsArray[MD5name] := hasMemThumbsCached
             If (hasMemThumbsCached>maxMemThumbsCache)
                hasMemThumbsCached := 0
          }

          calcIMGdimensions(newW, newH, thumbsW, thumbsH, fW, fH)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
          DestPosX -= (imageAligned!=5) ? thumbsW//2 : fW//2
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
          DestPosY -= (imageAligned!=5) ? thumbsH//2 : fH//2
          If (fimCached!=1 && thumbCachable=1 && thisZeit>timePerImg && file2save!=file2load && enableThumbsCaching=1 && WasMemCached!=1)
          && ((newW<imgW//2) || (newH<imgH//2))
          {
             fnOutputDebug("Saving thumb for: " file2load " -- " file2save) 
             zr := Gdip_SaveBitmapToFile(oBitmap, file2save, 94)
             If zr
                addJournalEntry("ThumbsMode. Failed to save thumbnail to file: " file2save)
          }

          If (WasMemCached=1 || hasNowMemCached=1)
          {
             zBitmap := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
             oBitmap := zBitmap
          }

          If (bwDithering=1 && imgFxMode=4) || (modus="all")
          {
             nullu := ""
          } Else If (usrColorDepth>1)
          {
             fnOutputDebug("ThumbsMode. Changing thumb color depth... " oBitmap)
             E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
          }

          If (modus!="all")
          {
             ; fnOutputDebug("ThumbsMode. (maybe) flipping thumb... " oBitmap)
             flipBitmapAccordingToViewPort(oBitmap)
             ; changeMcursor()
             hasUpdated := 0
             fnOutputDebug("ThumbsMode. Drawing image thumb: " oBitmap)
             If (userPrivateMode=1 && blurEffect)
                Gdip_BitmapApplyEffect(oBitmap, blurEffect)
             r1 := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, DestPosX, DestPosY, fW - 1, fH - 1)
          }

          fnOutputDebug("ThumbsMode. Disposing GDI thumb after drawing: " oBitmap)
          oBitmap := trGdip_DisposeImage(oBitmap, 1)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
          If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1 && modus!="all")
          {
             If retrieveSeenImageDBentry(imgPath, thisFileIndex)
             {
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
             }
          }

          If (markSearchMatches=1 && userSearchString && modus!="all")
          {
             If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                Gdip_FillRectangle(G2, pBrushD, DestPosX - thumbsW//2, DestPosY - thumbsH//2, Ceil(thumbsW*0.05), thumbsH - 8)
          }

          If ((A_TickCount - prevGUIupdate>350) && modus!="all")
          {
             fnOutputDebug("ThumbsMode. Redraw the whole window.")
             If (minimizeMemUsage!=1 && thumbsBitmap)
                r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)
             r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
             prevGUIupdate := A_TickCount
             If (minimizeMemUsage!=1)
                hasUpdated := 1
          }
      }
   }

    Gdip_DisposeEffect(blurEffect)
    If (alterFilesIndex>1 && mustEndLoop!=1 && lapsOccured>3 && modus!="all")
    {
       mustReloadThumbsList := 1
       ; mainGdipWinThumbsGrid()
       SetTimer, ForceRefreshNowThumbsList, -350
       ; Return
    } Else If (mustDoMultiCore=1 && mustEndLoop=1 && abandonAll!=1 && modus!="all")
    {
       fnOutputDebug("ThumbsMode after. Clean GDIs mess. Cores: " limitCores)
       Loop, % limitCores
           thumbThread%A_Index%.ahkPostFunction("cleanMess", "c" A_Index)
       ; fnOutputDebug("Thumbnails generator after. Clean GDIs mess. DONE.")
    }

    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    setPriorityThread(0)
    If (modus!="all" && (minimizeMemUsage=1 || !thumbsBitmap))
    {
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
    } Else If (modus!="all")
    {
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(thumbsBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If StrLen(zBitmap)>2
          {
             trGdip_DisposeImage(thumbsBitmap, 1)
             thumbsBitmap := zBitmap
          }
          E := Gdip_BitmapSetColorDepth(thumbsBitmap, "BW", 1)
       }
       If !isWinXP
          decideGDIPimageFX(matrix, imageAttribs, pEffect)

       fnOutputDebug("ThumbsMode end. Redraw the whole window.")
       If (pEffect || imageAttribs)
          r1 := trGdip_DrawImageFX(A_ThisFunc, glPG, thumbsBitmap, 0, 0, 0, 0, mainWidth, mainHeight, matrix, pEffect, imageAttribs)
       Else If (hasUpdated=0)
          r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)

       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
    }

    If (minimizeMemUsage!=1 && thumbsBitmap)
       Gdip_DeleteGraphics(G2)

    trGdip_DisposeImage(thumbsBitmap, 1)
    Gdip_DisposeImageAttributes(imageAttribs)
    Gdip_DisposeEffect(pEffect)
    ; ToolTip, %imgW% -- %imgH% == %newW% -- %newH%
    prevFullThumbsUpdate := A_TickCount
    If (!userScrolled && !abandonAll && alterFilesIndex!=1)
    {
       mustReloadThumbsList := 0
       prevFullIndexThumbsUpdate := startPageIndex
    }

    If (abandonAll=1)
       lastLongOperationAbort := A_TickCount

    executingCanceableOperation := 0
    If (modus!="all")
       SetTimer, ResetImgLoadStatus, -25

    prevFullThumbsUpdate := A_TickCount
    addJournalEntry(maxItemsPage " thumbnails listed in " SecToHHMMSS((A_TickCount - mainStartZeit)/1000) ".")
    ; ToolTip, % lapsOccured "|"  totalLoops " | " innerLoops " | " extendedLoops " | " imgsNotCached "`nZeit: " A_TickCount - mainStartZeit , , , 2
    r := (r1!=0 || !r2 || abandonAll=1) ? 0 : 1
    If (modus="all")
       Return abandonAll
    Return r
}

cloneGDItoMem(funcu, pBitmap, W:=0, H:=0) {
    If !pBitmap
    {
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: no bitmap given")
       Return
    }

    If (!W || !H)
       Gdip_GetImageDimensions(pBitmap, W, H)

    newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, W, H, coreDesiredPixFmt)
    If newBitmap
    {
       ; thisImgQuality := 5 ; (userimgQuality=1) ? 3 : 5
       G := trGdip_GraphicsFromImage(A_ThisFunc "() invoked by " funcu, newBitmap, 5)
       If G
          E := trGdip_DrawImage(A_ThisFunc "() invoked by " funcu, G, pBitmap, 0, 0, W, H)

       If (E="fail" || !G)
       {
          newBitmap := trGdip_DisposeImage(newBitmap, 1)
          addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create GDI+ graphics object")
       }

       Gdip_DeleteGraphics(G)
    } Else addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create bitmap")
    Return newBitmap
}

calcIMGcoordsInVP(usePrevious, mainWidth, mainHeight, newW, newH, ByRef DestPosX, ByRef DestPosY) {
    Static orderu := {1:7, 2:8, 3:9, 4:4, 5:5, 6:6, 7:1, 8:2, 9:3}
         , prevW := 1, prevH := 1, prevZoom := 0

    If (allowFreeIMGpanning=1 && IMGresizingMode=4)
    {
       o_mW := mainWidth
       o_mH := mainHeight
       mainWidth := 1
       mainHeight := 1
    }

    imgDecLX := LX := mainWidth - newW
    imgDecLY := LY := mainHeight - newH
    ; vpCenterX := 1, vpCenterY := 1
    CX := Round(mainWidth/2 - newW/2)
    CY := Round(mainHeight/2 - newH/2)

    ; hasTrans := adjustCanvas2Toolbar(2NDglPG, 0) ; to-do ; make image not appear under the toolbar
    tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
    If ((imageAligned=1) || (allowFreeIMGpanning=1 && IMGresizingMode=4) && thumbsDisplaying=0)
    {
       DestPosX := tlbrBonusX
       DestPosY := tlbrBonusY
    } Else If (imageAligned=5)
    {
       DestPosX := CX + tlbrBonusX
       DestPosY := CY + tlbrBonusY
    } 

    If (IMGlargerViewPort!=1 && allowFreeIMGpanning=0) || (IMGresizingMode!=4 && allowFreeIMGpanning=1)
    {
       IMGdecalageY := IMGdecalageY := 1
    } Else If (IMGresizingMode=4 && thumbsDisplaying!=1)
    {
       If (prevZoom!=zoomLevel && prevZoom!=0 && PrintPosX!="C" && PrintPosX!="W")
       {
          scaleu := newH/prevH
          IMGdecalageX := Round(IMGdecalageX*scaleu, 1)
          IMGdecalageY := Round(IMGdecalageY*scaleu, 1)
       }

       factoru := (imageAligned=5) ? 2 : 1
       If (allowFreeIMGpanning=1 && IMGresizingMode=4)
          factoru := 1

       If (IMGdecalageX<LX//factoru) && (newW>mainWidth)
          IMGdecalageX := LX//factoru
       If (IMGdecalageY<LY//factoru) && (newH>mainHeight)
          IMGdecalageY := LY//factoru

       minTopCornerX := (allowFreeIMGpanning=1) ? o_mW : 0
       minTopCornerY := (allowFreeIMGpanning=1) ? o_mH : 0
       If (newW - 2 > mainWidth)
          DestPosX := DestPosX + Round(IMGdecalageX)
       Else
          IMGdecalageX := minTopCornerX

       If (newH - 2 > mainHeight)
          DestPosY := DestPosY + Round(IMGdecalageY)
       Else
          IMGdecalageY := minTopCornerX

       If (DestPosX>minTopCornerX && newW>mainWidth)
       {
          DestPosX := minTopCornerX
          IMGdecalageX := (imageAligned=1) || (allowFreeIMGpanning=1 && IMGresizingMode=4) ? minTopCornerX : - LX//2
       }

       If (DestPosY>minTopCornerY && newH>mainHeight)
       {
          DestPosY := minTopCornerY
          IMGdecalageY := (imageAligned=1) || (allowFreeIMGpanning=1 && IMGresizingMode=4) ? minTopCornerY : - LY//2
       }
    }

; ToolTip, % DestPosX "=" DestPosY "`n" IMGdecalageX "=" IMGdecalageY , , , 2
    If (allowFreeIMGpanning=1)
       PrintPosX := ""
    prevW := newW
    prevH := newH
    prevZoom := zoomLevel
}

saveMainWinPos() {
   WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
   mainWinPos := winX "|" winY
   RegAction(1, "mainWinPos")
}

writeMainWindowPos() {
   Static prevInfos
   If determineLClickstate()
   {
      SetTimer, writeMainWindowPos, -300
      Return
   }

   thisWinHwnd := (thumbsDisplaying=1) ? hGDIthumbsWin : hGDIwin
   WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
   WinGetPos,,, winWidth, winHeight, ahk_id %thisWinHwnd%
   WinGetPos,,, win2Width, win2Height, ahk_id %PVhwnd%
   If (winX && winY && winWidth && winHeight)
   {
      mainWinPos := winX "|" winY
      mainWinSize := winWidth "|" winHeight
      WinGet, Stylu, Style, ahk_id %PVhwnd%
      mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
      ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
      thisInfos := win2Width "z" win2Height "z" mainWinSize "z" mainWinPos "z" mainWinMaximized
      If (prevInfos!=thisInfos)
      {
         prevInfos := thisInfos
         RegAction(1, "mainWinPos")
         RegAction(1, "mainWinSize")
         RegAction(1, "mainWinMaximized")
         SetTimer, writeMainWindowPos, -300
      }
   }
}

GuiGDIupdaterResize(eventu:=0) {
   If (A_TickCount - scriptStartTime<950)
      Return

   If (drawingShapeNow=1)
      stopDrawingShape()
   If (toolTipGuiCreated=1)
      RemoveTooltip()
   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   If (eventu=2)
   {
      WinGet, Stylu, Style, ahk_id %PVhwnd%
      mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
      RegAction(1, "mainWinMaximized")
      ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
   } Else If (eventu!=1)
      SetTimer, writeMainWindowPos, -350

   SetTimer, dummyTimerReloadThisPicture, Off
   SetTimer, dummyTimerDelayiedImageDisplay, Off
   DestroyGIFuWin()
   resetSlideshowTimer(0)
   imgPath := getIDimage(currentFileIndex)
   If StrLen(UserMemBMP)>2
      thisClippyIMG := 1

   If (!imgPath || !maxFilesIndex || PrevGuiSizeEvent=1 || !CurrentSLD) && (thisClippyIMG!=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      If (A_OSVersion="WIN_7" || isWinXP=1)
         GDIwindowsPosCorrections()

      ForceRefreshNowThumbsList()
      If (A_TickCount - lastWinDrag<350)
         Return

      If (thumbsDisplaying=1) && (!maxFilesIndex || !CurrentSLD)
         ToggleVisibilityWindow("hide", hGDIthumbsWin)
      Else
         FadeMainWindow()

      Return
   }

   If (lockSelectionAspectRatio=3)
      defineSelectionAspectRatios()

   If (maxFilesIndex>0 && PrevGuiSizeEvent!=1 && thumbsDisplaying!=1) && (A_TickCount - scriptStartTime>500) || (thisClippyIMG=1)
   {
      preventHUDelements := 1
      fnOutputDebug("Resize window event - image view mode. ")
      delayu := (A_TickCount - lastWinDrag<450) ? 450 : 15
      filterDelayiedImageDisplay()
      ; dummyTimerDelayiedImageDisplay(delayu)
      dummyTimerReloadThisPicture(150)
      ForceRefreshNowThumbsList()
   } Else If (thumbsDisplaying=1 && maxFilesIndex>1)
   {
      fnOutputDebug("Resize window event - thumbs mode.")
      recalculateThumbsSizes()
      ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      ; WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight% , ahk_id %hGDIthumbsWin%
      delayu := (A_TickCount - lastWinDrag<450) ? 550 : 325
      SetTimer, RefreshThumbsList, % -delayu
   }

   If (A_OSVersion="WIN_7" || isWinXP=1)
      GDIwindowsPosCorrections()
}

ToggleViewModeTouch() {
   zoomLevel := IMGdecalageY := IMGdecalageX := 1

   If (IMGresizingMode=1)
   {
      IMGresizingMode := 3
      ToggleImageSizingMode()
   } Else
   {
      IMGresizingMode := 0
      ToggleImageSizingMode()
   }
}

JEE_ClientToScreen(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472

  VarSetCapacity(POINT, 8)
  NumPut(vPosX, &POINT, 0, "Int")
  NumPut(vPosY, &POINT, 4, "Int")
  DllCall("user32\ClientToScreen", "Ptr", hWnd, "Ptr", &POINT)
  vPosX2 := NumGet(&POINT, 0, "Int")
  vPosY2 := NumGet(&POINT, 4, "Int")
}


ReloadDynamicFolderz(fileNamu) {
    showTOOLtip("Refreshing files list, please wait")
    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    listu := coreLoadDynaFolders(fileNamu)
    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue
       Else
          r := GetFilesList(line "\*")
       If (r="abandoned")
          Break
    }
}

coreLoadDynaFolders(fileNamu) {
    If (SLDtypeLoaded=3 && fileNamu=CurrentSLD)
    {
       listu := DynamicFoldersList "`n"
       SQL := "SELECT imgfolder FROM dynamicfolders;"
       activeSQLdb.GetTable(SQL, RecordSet)
       Loop, % RecordSet.RowCount
       {
           Rowu := RecordSet.Rows[A_Index]
           If Rowu[1]
              listu .= Rowu[1] "`n"
       }

       Sort, listu, UD`n
       listu := cleanDynamicFoldersList(listu)
       DynamicFoldersList := listu
       RecordSet.Free()
       Return listu
    }

    FileRead, tehFileVar, %fileNamu%
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(DF[0-9].*\=[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
          listu .= SubStr(line, InStr(line, "=")+1) "`n"
    }
 
    DynamicFoldersList := StrReplace(DynamicFoldersList, "|hexists|")
    listu .= "`n" Trimmer(DynamicFoldersList) "`n"
    changeMcursor()
    Sort, listu, UD`n
    listu := cleanDynamicFoldersList(listu)
    DynamicFoldersList := listu
    Return listu
}

cleanDynamicFoldersList(listu) {
    newArrayu := new hashtable()
    listuArray := StrSplit(listu, "`n", "`r")
    Loop, % listuArray.Count()
    {
       lineu := Format("{:L}", listuArray[A_Index])
       If lineu
          newArrayu[lineu] := 1
    }

    Loop, % listuArray.Count()
    {
       lineu := Format("{:L}", listuArray[A_Index])
       isPipe := InStr(lineu, "|")
       linea := StrReplace(lineu, "|")
       If (newArrayu[linea]=1 && newArrayu[lineu]=1 && isPipe)
          newArrayu[lineu] := 0
    }

    For Key, Value in newArrayu
    {
       If (Value=1 && !InStr(Key, "|"))
       {
          Loop, % listuArray.Count()
          {
              lineu := Format("{:L}", listuArray[A_Index])
              ; MsgBox, % lineu "`n" Key
              If (InStr(lineu "\", Key "\") && lineu!=Key)
                 newArrayu[lineu] := 0
          }
       }
    }

    newListu := ""
    For Key, Value in newArrayu
    {
        If Value
           newListu .= key "`n"
    }
    newArrayu := ""
    Return newListu
}

compareFoldersList(mainFoldersListu, foldersListu) {
   obju := []
   stuffAdded := 0
   Loop, Parse, foldersListu,`n
   {
       linea := Trimmer(A_LoopField)
       If StrLen(linea)<4
          Continue

       skipThis := 0
       Loop, Parse, mainFoldersListu, `n
       {
           line := Trimmer(A_LoopField)
           If StrLen(line)<4
              Continue

           If (line=linea)
              skipThis := 1
       }

       If (skipThis=1)
          Continue

       obju.newEntries .= linea "`n"
   }

   mainFoldersListu .= "`n" obju.newEntries
   Sort, mainFoldersListu, UD`n
   obju.newListu := mainFoldersListu

   Return obju
}

RegenerateEntireList() {
    If (AnyWindowOpen>0)
       BtnCloseWindow()

    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
    {
       retrieveFavesAsList()
       Return
    } Else If InStr(CurrentSLD, "\viewed-images-history-")
       Return

    If askAboutFileSave(" and the files list will be reloaded")
       Return

    thisIndex := currentFileIndex
    newStaticFoldersListCache := []
    startOperation := A_TickCount
    showTOOLtip("Preparing to refresh the files list, please wait")
    listu := getDynamicFoldersList()
    If StrLen(listu)<4
    {
       showTOOLtip("WARNING: No list of dynamic folders found")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    mustOpenStartFolder := ""
    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    renewCurrentFilesList()
    mustGenerateStaticFolders := (SLDtypeLoaded=3) ? 0 : 1
    If (SLDtypeLoaded=3)
    {
       getMaxRowIDsqlDB()
       activeSQLdb.Exec("BEGIN TRANSACTION;")
    }

    countFolders := ST_Count(listu, "`n") + 1
    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       isPipe := InStr(line, "|") ? 1 : 0
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue

       If (SLDtypeLoaded=3)
       {
          getMaxRowIDsqlDB()
          thisR := SQLescapeStr(fileTest, 1)
          thisR := (isPipe=1) ? thisR : thisR "%"
          SQLstr := "UPDATE images SET isDeleted=1 WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          activeSQLdb.Exec(SQLstr)
       }

       r := GetFilesList(line "\*", A_Index / countFolders, 0, 0)
       If (SLDtypeLoaded=3)
          maxFilesIndex := getTotalIMGsSQLdb("WHERE isDeleted=0")

       If (r="abandoned")
          Break
    }

    If (SLDtypeLoaded=3 && RegExMatch(CurrentSLD, "i)(.\.sldb)$"))
    {
       If (r="abandoned")
       {
          showTOOLtip("Operation aborted: regenerate files list. The files list is unchanged.`nReopening now the database, please wait")
          activeSQLdb.Exec("ROLLBACK TRANSACTION;")
          Sleep, 250
       } Else
       {
          showTOOLtip("Finalising database operations, please wait", 0, 0, 1/5)
          SQLdeleteEntriesMarked()
          showTOOLtip("Finalising database operations, please wait", 0, 0, 2/5)
          If !activeSQLdb.Exec("COMMIT TRANSACTION;")
             throwSQLqueryDBerror(A_ThisFunc)

          showTOOLtip("Regenerating main folders list, please wait", 0, 0, 3/5)
          recreateDynaFoldersSQLdbList(listu)
          showTOOLtip("Regenerating secondary folders list, please wait", 0, 0, 4/5)
          SQLdbGenerateStaticFolders()
          saveSlideSettingsInDB()
          etaTime := "Elapsed time to regenerate files list, database mode: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
          addJournalEntry(etaTime)
       }

       OpenSLD(CurrentSLD, 1)
       Return
    }

    thisFolder := StrReplace(CurrentSLD, "|")
    If (SLDtypeLoaded=1 && FolderExist(thisFolder))
       watchFolderDetails := getFolderDetails(thisFolder)

    GenerateRandyList()
    SoundBeep, % (r="abandoned" && SLDtypeLoaded!=3) ? 300 : 900, 100
    currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
    If (maxFilesIndex<1)
    {
       friendly := (SLDtypeLoaded=1 && FolderExist(thisFolder)) ? "No image files found in the folder:`n" thisFolder "\`n`n" : "Error refreshing files list... found nothing.`n`n"
       FadeMainWindow()
       msgBoxWrapper(appTitle ": WARNING", friendly "No indexed files found, please open a file or folder.", 0, 0, "info")
       resetMainWin2Welcome()
    } Else dummyTimerDelayiedImageDisplay(50)

    etaTime := "Elapsed time to regenerate files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " groupDigits(maxFilesIndex)
    addJournalEntry(etaTime)
}

throwSQLqueryDBerror(funcu) {
   SetTimer, ResetImgLoadStatus, -150
   showDelayedTooltip("ERROR: " funcu "() failed to query or commit changes the SQL database`n" activeSQLdb.ErrorMsg)
   SoundBeep, 300, 100
   ; SetTimer, RemoveTooltip, % -msgDisplayTime
}

getMaxRowIDsqlDB() {
  SQL := "SELECT max(imgidu) FROM images;"
  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "() " activeSQLdb.ErrorMsg)
     Return
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If IsNumber(Rowu[1])
         sqlDBrowID := Rowu[1] + 1 ; Rowu[2] Rowu[3]
  }

  RecordSet.Free()
  Return sqlDBrowID
}

getTotalIMGsSQLdb(morus:="") {
  SQL := "SELECT COUNT(*) FROM images " morus ";"
  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "() " activeSQLdb.ErrorMsg)
     Return
  }

  value := 0
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If IsNumber(Rowu[1])
         value := Rowu[1]
  }

  RecordSet.Free()
  Return value
}

OpenSLDBdataBase(fileNamu, importMode:=0) {
  activeSQLdb.CloseDB()
  activeSQLdb := new SQLiteDB
  If !activeSQLdb.OpenDB(fileNamu)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return -1
  }

  startOperation := A_TickCount
  If (MustLoadSLDprefs=1 && importMode!=1)
  {
     SlidesMusicSong := ""
     IniSLDBreadAll() ; read slideshow settings
  } Else If (importMode!=1)
  {
     SlidesMusicSong := ""
     IniSLDBreadAll("prevFilesSortMode")
     IniSLDBreadAll("reverseOrderOnSort")
     IniSLDBreadAll("autoPlaySlidesAudio")
     IniSLDBreadAll("SlidesMusicSong")
     IniSLDBreadAll("hamDistInterpolation")
     IniSLDBreadAll("userpHashMode")
     IniSLDBreadAll("dbVersion")
  }

  RecordSet := ""
  sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
  reorder := StrLen(prevFilesSortMode)>3 ? " ORDER BY " prevFilesSortMode sortMode ";" : " ORDER BY imgidu;"
  If !RegExMatch(prevFilesSortMode, "i)(fsize|fmodified|fcreated|imgfile|imgfolder)")
     moreCol := StrLen(prevFilesSortMode)>3 ? ", " prevFilesSortMode : ""
  ; ToolTip, % prevFilesSortMode "=" reverseOrderOnSort , , , 2
  startOperation := A_TickCount
  SQL := "SELECT imgidu, imgfolder||'\'||imgfile " moreCol " FROM images" reorder
  If !InitSQLgetTable(SQL, activeSQLdb._Handle, errMsg, Rows, Cols, hTable)
  {
      showTOOLtip("ERROR: Failed to open the SQL database:`n" errMsg)
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return -1
  } Else
  {
      ; ToolTip, % "prev=" prevFilesSortMode " cols = " cols " rows=" rows , , , 2
      If Rows
      {
         If (importMode!=1)
         {
            newStaticFoldersListCache := []
            SLDcacheFilesList := 1
            resultedFilesList := []
            maxFilesIndex := 0
         }
         performSQLgetTable(Rows, Cols, hTable)
         disposeSQLgetTableHandle(hTable)
      } Else
      {
         disposeSQLgetTableHandle(hTable)
         showTOOLtip("ERROR: No images indexed in the SQL database")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return -1
      }
  }

  getMaxRowIDsqlDB()
  If (importMode!=1)
     DynamicFoldersList := ""

  SQL := "SELECT imgfolder FROM dynamicfolders;"
  activeSQLdb.GetTable(SQL, RecordSet)
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[1]
         DynamicFoldersList .= Rowu[1] "`n"
  }

  RecordSet.Free()
  etaTime := "Elapsed time to open SQL database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
  addJournalEntry(etaTime)
  If (A_TickCount - startOperation>7000) && (maxFilesIndex>2)
     SoundBeep , 900, 100

  If (dbVersion!=dbExpectedVersion && importMode!=1)
     msgResult := msgBoxWrapper(appTitle ": WARNING", "This database was saved by an older version of " appTitle ". Some features in the application will likely malfunction, because this version of the application expects a database with a different structure.`n`nPlease use the «Rebuild» option in the save panel to recreate this database with the new structure. Resaving this database will not restructure the database.", "&OK", 1, "exclamation")

  If (importMode=1)
     activeSQLdb.CloseDB()

  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}

performSQLgetTable(Rows, Cols, hTable) {
   Offset := A_PtrSize * Cols
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   thisIndex := 0
   Loop, %Rows%
   {
      thisIndex++
      maxFilesIndex++
      Loop, %Cols%
      {
         If (A_Index=1) ; database index
            resultedFilesList[maxFilesIndex, 12] := StrGet(NumGet(hTable+0, Offset, "UPtr"), "UTF-8")
         Else If (A_Index=3) ; sort key value
            resultedFilesList[maxFilesIndex, 33] := StrGet(NumGet(hTable+0, Offset, "UPtr"), "UTF-8")
         Else ; full path
            resultedFilesList[maxFilesIndex, 1] := StrGet(NumGet(hTable+0, Offset, "UPtr"), "UTF-8")
         Offset += A_PtrSize
      }

      If (A_TickCount - prevMSGdisplay>2100)
      {
         etaTime := ETAinfos(thisIndex, Rows, startOperation)
         showTOOLtip("Generating files list index" etaTime, 0, 0, thisIndex/Rows)
         prevMSGdisplay := A_TickCount
      }
   }
}

InitSQLgetTable(SQL, dbHandle, ByRef errMsg, ByRef Rows, ByRef Cols, ByRef hTable) {
   Err := 0, RC := 0
   Rows := Cols := 0
   errMsg := hTable := 0 ; the sql output
   activeSQLdb._StrToUTF8(SQL, UTF8)
   RC := DllCall("SQlite3.dll\sqlite3_get_table", "Ptr", dbHandle, "Ptr", &UTF8, "PtrP", hTable
               , "IntP", Rows, "IntP", Cols, "PtrP", Err, "Cdecl Int")
   If ErrorLevel
   {
      errMsg := "DLLCall sqlite3_get_table failed! Code: " ErrorLevel
      Return False
   }

   If (RC)
   {
      errMsg := StrGet(Err, "UTF-8") "`n" SQL " | Code: " RC
      DllCall("SQLite3.dll\sqlite3_free", "Ptr", Err, "Cdecl")
      Return False
   }
   Return True
}

disposeSQLgetTableHandle(hTable) {
   DllCall("SQLite3.dll\sqlite3_free_table", "Ptr", hTable, "Cdecl")
   Return ErrorLevel
}

SQLdbRetrieveGivenFolder(pathu, isRecursive) {
   rec := (isRecursive=1) ? "%" : ""
   pathu := SQLescapeStr(pathu, 1)
   SQL := "SELECT imgidu, fullPath FROM images WHERE imgfolder LIKE '%" pathu rec "' ESCAPE '>'" ; reorder
   If !InitSQLgetTable(SQL, activeSQLdb._Handle, errMsg, Rows, Cols, hTable)
   {
      showTOOLtip("ERROR: Failed to open the SQL database:`n" errMsg)
      SoundBeep, 300, 100
      Return -1
   }

   If Rows
      performSQLgetTable(Rows, Cols, hTable)
   disposeSQLgetTableHandle(hTable)
}

filterDupeResultsByHdist(threshold, mustConvertHash) {
   doStartLongOpDance()
   showTOOLtip("Preparing list for Hamming distance calculations, please wait")
   groupies := []
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
          showTOOLtip("Preparing list for Hamming distance calculations, please wait" etaTime, 0, 0, A_index/maxFilesIndex)
          prevMSGdisplay := A_TickCount
       }

       grpIDu := resultedFilesList[A_Index, 23]
       If grpIDu
       {
          grpIDv%grpIDu%++
          resultedFilesList[A_Index, 33] := 100
          resultedFilesList[A_Index, 34] := 2500
          groupies[grpIDu, grpIDv%grpIDu%] := A_Index
       }
   }

   If (abandonAll=1)
   {
      groupies := ""
      Return 2
   }

   ; prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalLoops := groupies.Count()
   rtotalLoops := 0
   For Key, Value in groupies
       rtotalLoops += Value.Count()

   ; MsgBox, % "groups=" totalLoops "= l=" rtotalLoops
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   resultsDupesArray := []
   thisLoop := 0
   For Key, arrayGroup in groupies
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       ; If (A_TickCount - prevMSGdisplay>1000)
       ; {
       ;    etaTime := ETAinfos(thisLoop, rtotalLoops, startOperation)
       ;    showTOOLtip("Calculating Hamming distance between image pairs`nImage groups: " groupDigits(A_Index) " / " groupDigits(totalLoops) etaTime, 0, 0, thisLoop/rtotalLoops)
       ;    prevMSGdisplay := A_TickCount
       ; }

       thisLoop += arrayGroup.Count()
       thisCounter := resultsDupesArray.Count()
       ; fnOutputDebug("tL=" arrayGroup.Count() )
       If corefilterDupeResultsByHdist(arrayGroup, threshold, thisLoop, rtotalLoops, thisCounter)
       {
          abandonAll := 1
          Break
       }
   }

   thisFunc := (A_PtrSize=8) ? "clearHammingDistanceResults" : "_clearHammingDistanceResults@0"
   err := DllCall(whichMainDLL "\" thisFunc)
   groupies := ""
   If (abandonAll=1)
      Return 2

   changeHdistLevelCached("kill")
   hamUppLim := mseLowLim := 0
   mseUppLim := userFindDupesMSElvl
   hamUppLim := threshold
   UserHamDistStringFilter := ""
   UserHamDistCacheFilterMonoGroups := 0
   showTOOLtip("Finishing the duplicate images filtered list, please wait")
   r := changeHdistLevelCached(0, 0, threshold, 0, userFindDupesMSElvl)
   ResetImgLoadStatus()
   If (r<1)
      Return 1

   ; finalArray := sortDupeGroups(resultedFilesList.Clone())
   ; maxFilesIndex := finalArray.Count()
   ; resultedFilesList := []
   ; resultedFilesList := finalArray.Clone()
}

sortDupeGroups(givenArray, oldMap:=0, remSingles:=1) {
   groupies := []
   looseGroupies := []
   listuGroupies := "|"
   Loop, % givenArray.Count()
   {
       grpIDu := givenArray[A_Index, 23]
       If (grpIDu && InStr(grpIDu, "_"))
       {
          tgrpIDu := SubStr(grpIDu, 1, InStr(grpIDu,"_") - 1)
          grpIDv%tgrpIDu%++
          If (grpIDv%tgrpIDu%>remSingles)
             groupies[grpIDu] := 1
 
          ; lgrpIDv%grpIDu%++
          ; If (InStr(givenArray[A_Index, 28], "_"))
          ;    looseGroupies[grpIDu] := (lgrpIDv%grpIDu%=1) ? A_Index : 0
          listuGroupies .= grpIDu "z" A_Index "|"
       }
   }

   ; For key, value in looseGroupies
   ; {
   ;    If value
   ;    {
   ;       givenArray[value, 23] := givenArray[value, 28]
   ;       listuGroupies .= value "z" A_Index "|"
   ;    }
   ; }

   listuGroupies := Trimmer(listuGroupies, "|")
   Sort, listuGroupies, D|
   newIndex := 0
   newArrayu := []
   newMappingList := []
   ; ToolTip, % listuGroupies , , , 2
   Loop, Parse, listuGroupies, |
   {
       If A_LoopField
       {
          zu := StrSplit(A_LoopField, "z")
          If groupies[zu[1]]
          {
             newIndex++
             newArrayu[newIndex] := givenArray[zu[2]]
             newArrayu[newIndex, 28] := ""
             If (PerformMSDonDupes=1)
             {
                newArrayu[newIndex, 29] := ""
                newArrayu[newIndex, 31] := ""
             }

             If (hasHamDistCached=1 && IsObject(oldMap))
                newMappingList[newIndex] := oldMap[zu[2]]
          }
       }
   }

   If (hasHamDistCached=1 && IsObject(oldMap) && newIndex>1)
   {
      filteredMap2mainList := []
      filteredMap2mainList := newMappingList.Clone()
   }
 
   Return newArrayu
}

testWasMSEdupes() {
   MSEna := resultsDupesArray[1, 4]
   MSEnb := resultsDupesArray[2, 4]
   MSEa := isNumber(Trim(MSEna))
   MSEb := isNumber(Trim(MSEnb))
   allowMSE := (MSEa=1 && MSEb=1 && MSEna<2500 && MSEnb<2500) ? 1 : 0
   Return allowMSE
}

changeHdistLevelCached(modus, newLvlA:=0, newLvlB:=0, newLvlMSEa:=0, newLvlMSEb:=0) {
   ; Static cachedListu := []
   If (modus="kill")
   {
      hasHamDistCached := 0
      bckpResultedFilesList := []
      filteredMap2mainList := []
      Return -1
   }

   ; mustRenew := (newLvl=userFindDupesHamDistLvl && resultedFilesList.Count() != cachedListu.Count()) ? 1 : 0
   If (bckpResultedFilesList.Count()<3) ; || mustRenew=1)
   {
      hasHamDistCached := 1
      If markedSelectFile
         dropFilesSelection()

      bckpResultedFilesList := []
      bckpResultedFilesList := resultedFilesList.Clone()
      bckpMaxFilesIndex := maxFilesIndex
   }
   ; ToolTip, % MSEa "=" MSEb "=" allowMSE , , , 2
   thisString := StrReplace(Trimmer(UserHamDistStringFilter), "||", "|")
   thisString := Trimmer(thisString, "|")
   If thisString
   {
      If InStr(thisString, "/")
         n := 2
      Else If InStr(thisString, ">")
         n := 3

      If (userHamDistStringStringPos=2 && !n)
         thisString .= "/"
      Else If (userHamDistStringStringPos=3 && !n)
         thisString .= ">"
      Else If (userHamDistStringStringPos=4)
         thisString := "\>" thisString
      givenRegEx := processSearchIndexString(thisString)
      If n
         userHamDistStringStringPos := n
   }

   allowMSE := testWasMSEdupes()
   isStrFilter := StrLen(thisString)>1 ? 1 : 0
   newArrayu := []
   dupesIDs := []
   Loop, % resultsDupesArray.Count()
   {
        idRa := resultsDupesArray[A_Index, 1]
        idRb := resultsDupesArray[A_Index, 2]
        hamDist := resultsDupesArray[A_Index, 3]
        MSE := resultsDupesArray[A_Index, 4]
        If isInRange(hamDist, newLvlA, newLvlB)
        {
           If (allowMSE=1)
           {
              If !isInRange(MSE, newLvlMSEa, newLvlMSEb)
                 Continue
           }

           If (isStrFilter=1)
           {
              If !coreSearchIndex(imgPath, givenRegEx, userHamDistStringFilterWhat, UserHamDistStringInvert)
                 Continue
           }
       } Else Continue

       If (dupesIDs[idRa]!="" && dupesIDs[idRb]!="")
       {
          If (BreakDupesGroups=1)
          {
             thisDupeID := newArrayu[idRa, 23]
             thisDupeID := SubStr(thisDupeID, 1, InStr(thisDupeID, "_") - 1)  "_" hamDist
             newArrayu[idRa, 23] := thisDupeID
             newArrayu[idRa, 33] := hamDist
             newArrayu[idRa, 34] := MSE

             thisDupeID := newArrayu[idRb, 23]
             thisDupeID := SubStr(thisDupeID, 1, InStr(thisDupeID, "_") - 1)  "_" hamDist
             newArrayu[idRb, 23] := thisDupeID
             newArrayu[idRb, 33] := hamDist
             newArrayu[idRb, 34] := MSE
          }

          ; y := i := ""
          ; i .= newArrayu[idRa, 23]
          ; i .= "h" newArrayu[idRa, 33]
          ; i .= "m" newArrayu[idRa, 34]
          ; y .= newArrayu[idRb, 23]
          ; y .= "h" newArrayu[idRb, 33]
          ; y .= "m" newArrayu[idRb, 34]
          ; fnOutputDebug(hamDist "|" idRa "=" i "|" idRb "=" y "wow")
          ; Sleep, -1
          ; SoundBeep 300, 900
          ; SoundBeep 950, 900
          Continue
       } Else If (dupesIDs[idRa]="" && dupesIDs[idRb]="")
       {
          ; thisDupeID := idRc "_" min(idRa, idRb)
          thisDupeID := min(idRa, idRb) "_" hamDist
          dupesIDs[idRa] := thisDupeID
          dupesIDs[idRb] := thisDupeID
          newArrayu[idRa] := bckpResultedFilesList[idRa]
          newArrayu[idRa, 2] := 0
          newArrayu[idRa, 23] := thisDupeID
          newArrayu[idRa, 33] := hamDist
          newArrayu[idRa, 34] := MSE

          newArrayu[idRb] := bckpResultedFilesList[idRb]
          newArrayu[idRb, 2] := 0
          newArrayu[idRb, 23] := thisDupeID
          newArrayu[idRb, 33] := hamDist
          newArrayu[idRb, 34] := MSE
       } Else
       {
          thisDupeID := (dupesIDs[idRa]="") ? dupesIDs[idRb] : dupesIDs[idRa]
          If (BreakDupesGroups=1)
             thisDupeID := SubStr(thisDupeID, 1, InStr(thisDupeID, "_") - 1)  "_" hamDist
          dupesIDs[idRa] := thisDupeID
          dupesIDs[idRb] := thisDupeID
          If (newArrayu[idRa, 1]="")
          {
             newArrayu[idRa] := bckpResultedFilesList[idRa]
             newArrayu[idRa, 2] := 0
          } Else If (newArrayu[idRb, 1]="")
          {
             newArrayu[idRb] := bckpResultedFilesList[idRb]
             newArrayu[idRb, 2] := 0
          }

          newArrayu[idRa, 23] := thisDupeID
          newArrayu[idRa, 33] := min(hamDist, newArrayu[idRa, 33], newArrayu[idRb, 33])
          newArrayu[idRa, 34] := min(MSE, newArrayu[idRa, 34], newArrayu[idRb, 34])

          newArrayu[idRb, 23] := thisDupeID
          newArrayu[idRb, 33] := (BreakDupesGroups=1) ? hamDist : min(hamDist, newArrayu[idRa, 33], newArrayu[idRb, 33])
          newArrayu[idRb, 34] := (BreakDupesGroups=1) ? MSE : min(MSE, newArrayu[idRa, 34], newArrayu[idRb, 34])
       }
   }

   newIndex := 0
   fnewArrayu := []
   newMappingList := []
   For Key, Value in newArrayu
   {
       grpIDu := Value[23]
       imgPath := Value[1]
       If (grpIDu && imgPath && !InStr(imgPath, "||"))
       {
          newIndex++
          fnewArrayu[newIndex] := Value
          newMappingList[newIndex] := Key
       }
   }

   If (newIndex>1)
   {
      hasThis := 1
      finalArray := sortDupeGroups(fnewArrayu, newMappingList, UserHamDistCacheFilterMonoGroups)
      newIndex := finalArray.Count()
   }

   ; ToolTip, % lvl "=" newLvlA "=" newLvlB "=" newIndex , , , 2
   If (newIndex>1)
   {
      If !hasThis
      {
         maxFilesIndex := newIndex
         filteredMap2mainList := []
         filteredMap2mainList := newMappingList.Clone()
         resultedFilesList := []
         resultedFilesList := fnewArrayu.Clone()
      } Else
      {
         maxFilesIndex := finalArray.Count()
         resultedFilesList := []
         resultedFilesList := finalArray.Clone()
      }

      hasHamDistCached := 1
      ForceRefreshNowThumbsList()
      lastZeitFileSelect := A_TickCount
      ; dropFilesSelection(1)
      ; SetTimer, RandomPicture, -350
      Return 1
   } Else Return 0
}

calcMSDvalues(arrayA, arrayB, size, asStr:=0) {
    Static squaredCache := []
    ; [avg/ ] mean square difference [/ error] also known as standard deviation
    ; https://stackoverflow.com/questions/20271479/what-does-it-mean-to-get-the-mse-mean-error-squared-for-2-images
    ; https://stackoverflow.com/questions/25493010/c-difference-between-the-sum-of-the-squares-of-the-first-ten-natural-numbers-a
    ; https://www.introspective-mode.org/means-squared-variance-standard-deviation-error/
    ; https://stats.stackexchange.com/questions/239379/what-is-the-difference-between-mean-squared-deviation-and-variance
    ; https://www.mygreatlearning.com/blog/mean-square-error-explained/

    If (asStr=1)
    {
       arrayA := StrSplit(arrayA, "|")
       arrayB := StrSplit(arrayB, "|")
    }

    sumB := 0
    Loop, % size
    {
       f := (A_Index<33 || A_Index>991) ? 1 : 1
       sumB += (arrayA[A_Index] - arrayB[A_Index])**2 // f
       ; sumB += Abs(arrayA[A_Index] - arrayB[A_Index]) // f
    }

    If (squaredCache[sumB]!="")
       Return squaredCache[sumB]

    ; squaredCache[sumB] := Round(sqrt(sumB)/2)
    squaredCache[sumB] := Round(sqrt(sumB/(size/2)))
    ; fnOutputDebug("sum=" sumB "|" squaredCache[sumB])
    Return squaredCache[sumB]
}

corefilterDupeResultsByHdist(dupeIDsArray, threshold, grupu, totalgroups, thisCounter) {
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   totalLoops := dupeIDsArray.Count()
   VarSetCapacity(IDsbigArray, 8 * totalLoops + 1, 0)
   VarSetCapacity(HbigArray, 8 * totalLoops + 1, 0)
   If (findFlippedDupes=1)
      VarSetCapacity(flipHbigArray, 8 * totalLoops + 1, 0)
   Else
      VarSetCapacity(flipHbigArray, 8)

   generalDetails := "`nGroups: " groupDigits(grupu) " / " groupDigits(totalgroups) "`nImages in current group: " groupDigits(totalLoops)
   etaTime := ""
   Loop, % totalLoops
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalLoops, startOperation)
          showTOOLtip("Hamming distance image duplicates preparations" etaTime generalDetails, 0, 0, A_Index/totalLoops)
          prevMSGdisplay := A_TickCount
       }

       idu := dupeIDsArray[A_Index]
       hIDu :=  resultedFilesList[idu, 12]
       If (InStr(dupesHashesData[hIDu], "|") && findFlippedDupes=1)
       {
          ash := StrSplit(dupesHashesData[hIDu], "|")
          hashA := "0x" ash[1],   hashB := "0x" ash[2]
          NumPut(hashA, HbigArray, (A_Index - 1) * 8, "uint64")
          NumPut(hashB, flipHbigArray, (A_Index - 1) * 8, "uint64")
       } Else
       {
          hashA := "0x" dupesHashesData[hIDu]
          NumPut(hashA, HbigArray, (A_Index - 1) * 8, "uint64")

       }

       NumPut(idu, IDsbigArray, (A_Index - 1) * 4, "uint")
       ; fnOutputDebug("tL=" totalLoops " g=" grupu " imgID[" A_Index "]=" idu)
       ; stringu .= A_Index "|" idu "=" hash "`n"
       ; msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have. " stringu, 4, 0, "question")
       ; If (msgResult="Yes")
       ;    Break
   }

   If (abandonAll=1)
   {
      flipHbigArray := ""
      IDsbigArray := ""
      HbigArray := ""
      Return 1
   }

   ; If (A_TickCount - prevMSGdisplay>1000)
   ; {
      showTOOLtip("Calculating Hamming distance between the images in the current group" generalDetails "`nPlease wait", 0, 0, grupu/totalgroups)
      prevMSGdisplay := A_TickCount
   ; }

   ; initQPVmainDLL()
   thisFunc := (A_PtrSize=8) ? "hammingDistanceOverArray" : "_hammingDistanceOverArray@36"
   totalResults := DllCall(whichMainDLL "\" thisFunc, "UPtr", &HbigArray, "UPtr", &flipHbigArray, "UPtr", &IDsbigArray, "uint", totalLoops, "Int", threshold + 1, "uint", hamDistLBorderCrop, "uint", hamDistRBorderCrop, "int", findInvertedDupes, "int", findFlippedDupes)
   ; fnOutputDebug(A_ThisFunc ": hamDist g=" grupu " results=" totalResults)   
   IDsbigArray := ""
   flipHbigArray := ""
   HbigArray := ""

   If (A_TickCount - prevMSGdisplay>1500)
   {
      showTOOLtip("Preparing to retrieve the similarity results for the images compared" generalDetails "`nPlease wait", 0, 0, grupu/totalgroups)
      prevMSGdisplay := A_TickCount
   }

   thisFunc := (A_PtrSize=8) ? "retrieveHammingDistanceResults" : "_retrieveHammingDistanceResults@12"
   VarSetCapacity(resultsArrayA, 4 * totalResults + 1, 0) ; Lpair
   err := DllCall(whichMainDLL "\" thisFunc, "UPtr", &resultsArrayA, "Int", 1, "uInt", totalResults)
   VarSetCapacity(resultsArrayB, 4 * totalResults + 1, 0) ; Rpair
   err := DllCall(whichMainDLL "\" thisFunc, "UPtr", &resultsArrayB, "Int", 2, "uInt", totalResults)
   VarSetCapacity(resultsArrayC, 4 * totalResults + 1, 0) ; hamming distance
   err := DllCall(whichMainDLL "\" thisFunc, "UPtr", &resultsArrayC, "Int", 3, "uInt", totalResults)
   ; msgbox, % "r=" totalResults

   startOperation := A_TickCount
   MSE := 2500
   thisindex := 0
   Loop, % totalResults + 2
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalResults, startOperation)
          If (PerformMSDonDupes=1)
             showTOOLtip("Calculating Mean-Squared Difference for image duplicates pairs" etaTime generalDetails, 0, 0, A_Index/totalResults)
          Else
             showTOOLtip("Integrating Hamming distance results" etaTime generalDetails, 0, 0, A_Index/totalResults)
          prevMSGdisplay := A_TickCount
       }

       idRa := NumGet(resultsArrayA, 4 * (A_Index - 1), "uInt")
       If (idRa<0)
          idRa := Abs(idRa)

       idRb := NumGet(resultsArrayB, 4 * (A_Index - 1), "uInt")
       If (idRb<0)
          idRb := Abs(idRb)

       If (idRa && idRb)
       {
          thisIndex++
          If (PerformMSDonDupes=1)
          {
             pixIDa := resultedFilesList[idRa, 12]
             pixIDb := resultedFilesList[idRb, 12]
             MSE := calcMSDvalues(dupesPixelData[pixIDa], dupesPixelData[pixIDb], 1024, 1)
          }

          idRc := NumGet(resultsArrayC, 4 * (A_Index - 1), "uInt")
          If !idRc
             idRc := 1

          resultsDupesArray[thisCounter + thisIndex] := [idRa, idRb, idRc, MSE]
          ; fnOutputDebug("res=" totalResults " tL=" totalLoops " g=" grupu " tC=" thisCounter " (" resultsDupesArray.Count() ") aI=" thisIndex " MSE=" MSE " hD=" idRc " A=" idRa " B=" idRb)
       }
   }

   IDsbigArray := ""
   HbigArray := ""
   resultsArrayA := ""
   resultsArrayB := ""
   resultsArrayC := ""
}

retrieveDupesByProperties(theseCols, fsCmp, SortCriterion:=0, mustForceHashes:=0) {
   Static prevMode, notFloatsRegEX := "i)(fcreated|fmodified|fsize|imgfile|dHash|lHash|pHash|imgwidth|imgheight|imgframes|imgdpi|imgpixfmt)"

   If SortCriterion
      mode := prevMode

   wasDupesList := (testIsDupesList() && dupesHashesData.Count()>2) ? 1 : 0
   If (RegExMatch(theseCols, "i)(dHash)") || userFindDupesFilterHamDist=2)
      thisNOTnullCol := "dHash"
   Else If (RegExMatch(theseCols, "i)(pHash)") || userFindDupesFilterHamDist=3)
      thisNOTnullCol := "pHash"
   Else If (RegExMatch(theseCols, "i)(lHash)") || userFindDupesFilterHamDist=4)
      thisNOTnullCol := "lHash"
   Else If RegExMatch(theseCols, "i)(imgmedian|imgavg|imghpeak|imghlow|imghmode|imghminu|imghrange|imghrms)")
      thisNOTnullCol := "imgmedian"
   Else If RegExMatch(theseCols, "i)(imgmegapix|imgdpi|imgwidth|imgframes|imgpixfmt|imgheight|imgwhratio)")
      thisNOTnullCol := "imgwidth"
   Else If RegExMatch(theseCols, "i)(fcreated|fmodified|fsize)")
      thisNOTnullCol := "fsize"
   Else
      thisNOTnullCol := "imgfile"

   ; ToolTip, % theseCols "==" thisNOTnullCol "==" mustForceHashes , , , 2
   showTOOLtip("Identifying image duplicates, please wait")
   If (InStr(thisNOTnullCol, "hash") || mustForceHashes=1 || userFindDupesFilterHamDist>1)
   {
      scu :=  (findFlippedDupes=1) ? "HpixelzFsmall" : "pixelzFsmall"
      collectSQLFileInfosNow(scu, 0, 1, 2, 0, dupesStringFilter, userFilterStringIsNot)
   }

   If (InStr(thisNOTnullCol, "hash") || userFindDupesFilterHamDist>1 || mustForceHashes>1)
   {
      generateSQLimageFingerPrintHash(userFindDupesFilterHamDist, 0, dupesStringFilter, userFilterStringIsNot, userFilterStringPos, userFilterWhat)
      If (findFlippedDupes=1)
         generateSQLimageFingerPrintHash(userFindDupesFilterHamDist, 1, dupesStringFilter, userFilterStringIsNot, userFilterStringPos, userFilterWhat)
   }

   If (InStr(theseCols, "hash") && userFindDupesFilterHamDist>1)
   {
      theseCols := StrReplace(theseCols, "hdHash")
      theseCols := StrReplace(theseCols, "hpHash")
      theseCols := StrReplace(theseCols, "hlHash")
      theseCols := StrReplace(theseCols, "dHash")
      theseCols := StrReplace(theseCols, "pHash")
      theseCols := StrReplace(theseCols, "lHash")
      theseCols := StrReplace(theseCols, ",,", ",")
      theseCols := StrReplace(theseCols, ", ,", ",")
   }

   prevMode := theseCols
   innerTrimL := hamDistLBorderCrop + 1
   innerTrimR := 64 - hamDistLBorderCrop - hamDistRBorderCrop
   mustDoSubStr := 0

   orderCol := "a.imgmegapix,a.fsize"
   ONlist := "ON ("
   Loop, Parse, % theseCols, CSV
   {
      If !A_LoopField
         Continue

       ONlist .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " AND Round(a." A_LoopField "," findDupesPrecision ") = b." A_LoopField : " AND a." A_LoopField " = b." A_LoopField
   }

   Loop, Parse, % theseCols, CSV
   {
      If !A_LoopField
         Continue

      newCols .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " Round(" A_LoopField "," findDupesPrecision ")," : A_LoopField ","
      selectuCols .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " Round(" A_LoopField "," findDupesPrecision ") AS " A_LoopField "," : A_LoopField ","
   }

   mustConvertHash := 0
   theseCols := Trimmer(newCols, ",")
   selectuCols := Trimmer(selectuCols, ",")
   includeHash := (userFindDupesFilterHamDist=2) ? ", dHash" : ""
   If (userFindDupesFilterHamDist=3)
      includeHash := ", pHash"
   Else If (userFindDupesFilterHamDist=4)
      includeHash := ", lHash"

   If (findFlippedDupes=1)
   {
      hashA := thisNOTnullCol
      hashB := thisNOTnullCol := StrReplace(includeHash, ", ", "h")
      includeHash .= StrReplace(includeHash, ", ", ", h")
   } Else if includeHash
      hashA := thisNOTnullCol

   If (PerformMSDonDupes=1 && includeHash)
   {
      pixelzA := (hashA) ? 7 : 6
      If (findFlippedDupes=1)
         pixelzA++

      ; If (findFlippedDupes=1)
      ;    pixelzB := pixelzA + 1
      ; includePixels := (findFlippedDupes=1) ? ", pixelzFbig, HpixelzFbig" : ", pixelzFbig"
      includePixels := ", pixelzFbig"
   }

   doStartLongOpDance()
   startOperation := A_TickCount
   SQLstr := "SELECT imgidu, fullPath, a.imgmegapix, a.fsize, b.groupID" includeHash includePixels " FROM images AS a`n"
   SQLstr .= " JOIN (SELECT " selectuCols ", ROWID AS groupID`n"
   ; SQLstr .= " FROM images WHERE " thisNOTnullCol " IS NOT NULL`n"
   SQLstr .= " FROM images WHERE ifnull(" thisNOTnullCol ", '')!=''`n"
   SQLstr .= " GROUP BY " theseCols " HAVING count(*)>1) AS b`n"
   SQLstr .= StrReplace(ONlist, "ON ( AND ", "ON (") ") "
   SQLstr .= StrLen(SortCriterion)>1 ? "ORDER BY a." SortCriterion ";" : "ORDER BY b.groupID," orderCol ";"
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      userFindDupesFilterHamDist := 1
      throwSQLqueryDBerror(A_ThisFunc)
      Return -1
   }

   addJournalEntry("SQL query used to identify the dupes:`n" SQLstr)
   If (determineTerminateOperation()=1)
      abandonAll := 1

   If (RecordSet.RowCount<2 || abandonAll=1)
   {
      RecordSet.Free()
      If (abandonAll=1)
         showTOOLtip("Operation aborted by user")
      Else
         showTOOLtip("Found no image duplicates")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -150
      If !SortCriterion
         SetTimer, PanelFindDupes, -250
      Return
   }

   showTOOLtip("Found " groupDigits(RecordSet.RowCount) " duplicate images`nGenerating the files list, please wait")
   If !filesFilter
      bckpMaxFilesIndex := maxFilesIndex   

   backupArray := resultedFilesList.Clone()
   backupFilter := filesFilter
   backupIndexu := currentFileIndex
   renewCurrentFilesList()
   thisString := StrReplace(dupesStringFilter, "||", "|")
   thisString := Trimmer(Trimmer(thisString), "|")
   If thisString
   {
      thisString := StrReplace(thisString, "/")
      thisString := StrReplace(thisString, ">")
      If (userFilterStringPos=2)
         thisString .= "/"
      Else If (userFilterStringPos=3)
         thisString .= ">"
      givenRegEx := processSearchIndexString(thisString)
   }

   abandonAll := 0
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   groupies := []
   totalFiles := RecordSet.RowCount
   arrHashesData := new hashtable(totalFiles)
   arrPixelData := new hashtable(totalFiles)
   Loop, % RecordSet.RowCount
   {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[2]
      {
         If (toBeExcludedIndexes[Rowu["imgidu"]]=1)
            Continue

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         If givenRegEx
         {
            okay := 0
            If coreSearchIndex(Rowu[2], givenRegEx, userFilterWhat, userFilterStringIsNot)
               okay := 1
         } Else okay := 1

         If (okay!=1)
            Continue

         groupies[Rowu[5]] := 1
         maxFilesIndex++
         resultedFilesList[maxFilesIndex, 1]  := Rowu[2]
         resultedFilesList[maxFilesIndex, 12] := Rowu[1]  ; sqlDBrowID
         resultedFilesList[maxFilesIndex, 17] := Rowu[3]
         resultedFilesList[maxFilesIndex, 6]  := Rowu[4]
         resultedFilesList[maxFilesIndex, 23] := Rowu[5]  ; initial dupe group ID
         If includeHash
         {
            If (hashA && hashB)
               arrHashesData[ Rowu[1] ] := Rowu[6] "|" Rowu[7]
            Else
               arrHashesData[ Rowu[1] ] := Rowu[6]
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(maxFilesIndex, totalFiles, startOperation)
            showTOOLtip("Retrieving image duplicates files list, please wait" etaTime, 0, 0, A_Index/totalFiles)
            prevMSGdisplay := A_TickCount
         }

         If includePixels
         {
            arrPixelData[ Rowu[1] ] := processPixArrayCharsAsSTR(Rowu[pixelzA])
            ; resultedFilesList[maxFilesIndex, 29] := processPixArrayChars(Rowu[pixelzA])
            ; If pixelzB
            ;    resultedFilesList[maxFilesIndex, 31] := processPixArrayChars(Rowu[pixelzB])
         }
      }
   }

   If (maxFilesIndex<2 || abandonAll=1)
   {
      arrHashesData := ""
      arrPixelData := ""
   } Else
   {
      dupesHashesData := arrHashesData
      dupesPixelData := arrPixelData
   }

   RecordSet.Free()
   ; MsgBox, % "g=" groupies.Count() " | i = " resultedFilesList.Count()
   If (userFindDupesFilterHamDist>1 && maxFilesIndex>2 && includeHash && abandonAll!=1)
      r := filterDupeResultsByHdist(userFindDupesHamDistLvl, mustConvertHash)

   userFilterInvertThis := userFilterDoString := 0
   currentFileIndex := userFilterProperty := 1
   filesFilter := "SQL:query:" StrReplace(SubStr(SQLstr, Round(InStr(SQLstr, "JOIN (")), InStr(SQLstr, " ORDER BY") - InStr(SQLstr, "JOIN (")), "`n", A_Space)
   ; ToolTip, % filesFilter , , , 2
   CurrentSLD := backCurrentSLD
   etaTime := "Elapsed time to identify possible image duplicates: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   SetTimer, ResetImgLoadStatus, -100
   If (maxFilesIndex<2 || abandonAll=1 || r>0)
   {
      If (r>0)
      {
         arrHashesData := ""
         arrPixelData := ""
         dupesHashesData := arrHashesData
         dupesPixelData := arrPixelData
      }

      maxFilesIndex := backupArray.Count()
      filesFilter := backupFilter
      currentFileIndex := backupIndexu
      resultedFilesList := []
      resultedFilesList := backupArray.Clone()
      backupArray := ""
      If (abandonAll=1 || r=2)
         showTOOLtip("User abandoned image duplicates identification")
      Else
         showTOOLtip("Found no image duplicates after filtering the duplicates list")

      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If !SortCriterion
         SetTimer, PanelFindDupes, -350
      Return
   } Else
      SoundBeep , 900, 100

   ; SetTimer, RemoveTooltip, % -msgDisplayTime
   backupArray := ""
   showDelayedTooltip("Found " groupDigits(groupies.Count()) " groups of duplicate images`nTotal images: " groupDigits(maxFilesIndex))
   ; ToolTip, % "x=" x , , , 2
   dummyTimerDelayiedImageDisplay(90)

   ; RandomPicture()
}

keepSelectedDupeInGroup() {
   thisGrpID := resultedFilesList[currentFileIndex, 23]
   If !thisGrpID
      Return

   desiredImgID := currentFileIndex
   Loop, % maxFilesIndex
   {
      grpID := resultedFilesList[A_Index, 23]
      If (grpID=thisGrpID)
      {
         osel := resultedFilesList[A_Index, 2] ? 1 : 0
         nsel := (desiredImgID!=A_Index) ? 1 : 0
         resultedFilesList[A_Index, 2] := nsel
         If (nsel!=osel && nsel=1)
            markedSelectFile++
         Else If (nsel!=osel && nsel=0)
            markedSelectFile--
      }
   }

   lastZeitFileSelect := A_TickCount
   dummyTimerDelayiedImageDisplay(90)
}

autoSelectDupesInGroups(mode, givenRegEx:=0) {
   ; dropFilesSelection(1)
   theArray := []
   ; ToolTip, % mode "==" givenRegEx , , , 2
   Loop, % maxFilesIndex
   {
      If (grpID := resultedFilesList[A_Index, 23])
      {
         countPerGroup%grpID%++
         fs := resultedFilesList[A_Index, 6]
         mgpx := Round(resultedFilesList[A_Index, 17], 4)
         If (fs>theArray[grpID, 1, 1])
            theArray[grpID, 1] := [fs, A_Index]
         If (fs<theArray[grpID, 3, 1] || !theArray[grpID, 3, 1])
            theArray[grpID, 3] := [fs, A_Index]

         If (mgpx>theArray[grpID, 2, 1])
            theArray[grpID, 2] := [mgpx, A_Index]
         If (mgpx<theArray[grpID, 4, 1] || !theArray[grpID, 4, 1])
            theArray[grpID, 4] := [mgpx, A_Index]
      }
   }

   indexu := 0
   rescanIDs := []
   Loop, % maxFilesIndex
   {
      grpID := resultedFilesList[A_Index, 23]
      If (mode=1) ; Automatic
      {
         If (grpID && countPerGroup%grpID%>1)
         {
            mgpxMax := theArray[grpID, 2, 1]
            mgpxMin := theArray[grpID, 4, 1]
            mgpxMin := snapToValues(mgpxMin, mgpxMax, mgpxMax, 0.01, 0)

            ; Sleep, 100
            ; ToolTip, % mgpxMin "==" mgpxMax , , , 2
            If (mgpxMin=mgpxMax)
            {
               fsMax := Round(theArray[grpID, 1, 1]/1024, 2)
               fsMin := Round(theArray[grpID, 3, 1]/1024, 2)
               If (fsMin=fsMax && givenRegEx)
               {
                  imgPath := resultedFilesList[A_Index, 1]
                  r := coreSearchIndex(imgPath, givenRegEx, 2)
                  resultedFilesList[A_Index, 2] := r ? 0 : 1
                  If !rescanIDs[grpID, 1]
                  {
                     indexu++
                     rescanIDs[grpID, 1] := r ? 0 : 1
                  }

                  If (rescanIDs[grpID, 2]!=0)
                     rescanIDs[grpID, 2] := r ? 0 : 1

                  If !r
                     countSel%grpID%++
               } Else If (fsMax=fsMin && countSel%grpID%<countPerGroup%grpID%)
               {
                  ; SoundBeep , 300, 100
                  countSel%grpID%++
                  If (countSel%grpID%<countPerGroup%grpID%)
                     resultedFilesList[A_Index, 2] := 1
               } Else If (fsMax!=fsMin)
               {
                  thisIndex := theArray[grpID, 1, 2] ; max file size
                  resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
                  If (thisIndex!=A_Index)
                     countSel%grpID%++
               }
            } Else
            {
               thisIndex := theArray[grpID, 2, 2] ; max res
               resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
               If (thisIndex!=A_Index)
                  countSel%grpID%++
            }
         } Else resultedFilesList[A_Index, 2] := 0
      } Else
      {
         ; mode=3 - megapixels
         ; mode=2 - fsize
         If (grpID && countPerGroup%grpID%>1)
         {
            fsMax := (mode=2) ? Round(theArray[grpID, 1, 1]/1024, 2) : theArray[grpID, 2, 1]
            fsMin := (mode=2) ? Round(theArray[grpID, 3, 1]/1024, 2) : theArray[grpID, 4, 1]
            If (fsMin=fsMax && givenRegEx)
            {
               imgPath := resultedFilesList[A_Index, 1]
               r := coreSearchIndex(imgPath, givenRegEx, 2)
               resultedFilesList[A_Index, 2] := r ? 0 : 1
               If !rescanIDs[grpID, 1]
               {
                  indexu++
                  rescanIDs[grpID, 1] := r ? 0 : 1
               }

               If (rescanIDs[grpID, 2]!=0)
                  rescanIDs[grpID, 2] := r ? 0 : 1

               If !r
                  countSel%grpID%++
            } Else If (fsMax=fsMin && countSel%grpID%!=1)
            {
               countSel%grpID% := 1
               resultedFilesList[A_Index, 2] := 1
            } Else If (fsMax!=fsMin)
            {
               thisIndex := (mode=2) ? theArray[grpID, 1, 2] : theArray[grpID, 2, 2]
               resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
               If (thisIndex!=A_Index)
                  countSel%grpID%++
            }
         } Else resultedFilesList[A_Index, 2] := 0
      }
   }

   If (indexu>0 && givenRegEx)
   {
      ; ensure that all or none are selected within a group after regex
      Loop, % maxFilesIndex
      {
         grpID := resultedFilesList[A_Index, 23]
         If (grpID && countPerGroup%grpID%>1)
         {
            If (rescanIDs[grpID, 1]=0)
            {
               rescanIDs[grpID, 1] := 1
               resultedFilesList[A_Index, 2] := 1
            }

            If (rescanIDs[grpID, 2]=1)
            {
               rescanIDs[grpID, 2] := 0
               resultedFilesList[A_Index, 2] := 0
            }
         }
      }
   }

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)
}

sldGenerateFilesList(readThisFile, doFilesCheck, mustRemQuotes, doOptionals:=1) {
    startZeit := A_TickCount
    FileRead, tehFileVar, %readThisFile%
    If (mustRemQuotes=1)
    {
       tehFileVar := StrReplace(tehFileVar, """-")
       tehFileVar := StrReplace(tehFileVar, """")
    }

    doStartLongOpDance()
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If InStr(line, "|")
       {
          RecursiveFlag := "|"
          line := StrReplace(line, "|")
       } Else RecursiveFlag := ""

       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       ; changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          If (doFilesCheck=1)
          {
             If !FileRexists(line)
                Continue
          }

          maxFilesIndex++
          resultedFilesList[maxFilesIndex] := [line]
          ; tempu .= Chr(34) line Chr(34) "`n"
       } Else If RegExMatch(line, "i)^(.\:\\.)") ; RegExMatch(line, "i)^(.\:\\.).*(\\)$")
       {
          line := Trimmer(line, "\")
          If FolderExist(line)
          {
             DynamicFoldersList .= "`n" RecursiveFlag line "`n"
             GetFilesList(RecursiveFlag line "\*")
          }
       }
    }

    ; Clipboard := tempu
    etaTime := "Elapsed time to open TXT files list: " SecToHHMMSS(Round((A_TickCount - startZeit)/1000, 3)) ". Files: " maxFilesIndex
    addJournalEntry(etaTime)
    If (A_TickCount - startZeit>7000) && (maxFilesIndex>2 && abandonAll!=1)
       SoundBeep, 900, 100

    executingCanceableOperation := 0
    SetTimer, ResetImgLoadStatus, -50
    If (doOptionals=1)
    {
       If (abandonAll=1)
          showDelayedTooltip("Operation aborted. The files list is now empty.")
       Else If (maxFilesIndex<1)
          showDelayedTooltip("Found no files or folders in the SLD`nThe files list is now empty.")

       If (abandonAll=1 || maxFilesIndex<1)
       {
          lastLongOperationAbort := A_TickCount
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SoundBeep, 300, 100
          Return "abandoned"
       }
    }
}

filterCoreString(stringu, behave, thisFilter, doExactFolderMatch:=0) {
  If (doExactFolderMatch=1)
  {
     zPlitPath(stringu, 1, OutFileName, OutDir)
     r := RegExMatch(OutDir "\", "i)^(" thisFilter "\\)$")
  } Else r := RegExMatch(stringu, "i)(" thisFilter ")")
  z := r ? 1 : 0
  Return (behave=2) ? !z : z
}

GetFilesList(strDir, progressInfo:=0, doCommits:=1, factCheck:=1) {
/*
  QPV internally relies on resultedFilesList[] array. 
  Each file entry is defined by various properties:

  resultedFilesList[index_number] :=
  [ 1_filePath, 2_isSelected, 3_isSeen, 4_forceThumbRefresh
  , 5_isFavourite, 6_fileSize, 7_fileDateModified
  , 8_fileDateCreated, 9_imgFrames, 10_mustDoSort, 11_IsImgHisto
  , 12_dbRowIndex, 13_imgW, 14_imgH, 15_imgPixFmt, 16_imgWHratio
  , 17_imgMGPX, 18_imgHAvg, 19_imgHmedian, 20_imgHpeak, 21_imgHlow
  , 22_imgDPI, 23_dupeID, 24_imghRMS, 25_imghRange, 26_imghMode
  , 27_imghMin, 28_imgHASH, 29_pixelzFsmall, 30_pixelzFbig
  , 31_HpixelzFsmall, 32_HpixelzFbig]

  All these properties are optional and are filled based on the
  application context. 1_filePath is the only property that is not
  optional, because it specifies the file path and image file at
  the given index entry.

  resultedFilesList[] array is populated by, GetFilesList(),
  OpenSLD(), sldGenerateFilesList(),  OpenSLDBdataBase(),
  performSQLgetTable(), dbSortingCached(), SortFilesList() and others.
*/

  OutDir := PathCompact(Trim(StrReplace(strDir, "*"), "\"), "a", 1, OSDfontSize)
  friendly := (userPrivateMode=1) ? "*:\********\****" : OutDir
  showTOOLtip("Loading files from`n" friendly "`n", 0, 0, progressInfo)
  If InStr(strDir, "|")
  {
     doRecursive := ""
     strDir := StrReplace(strDir, "|")
  } Else doRecursive := "R"

  abandonAll := thisCounter := addedNow := 0
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  prevDisplay := A_TickCount
  doStartLongOpDance()
  If (SLDtypeLoaded=3)
  {
     newArrayu := []
     If (doCommits=1)
        activeSQLdb.Exec("BEGIN TRANSACTION;")

     Loop, Files, %strDir%, %doRecursive%
     {
         fullPath := Trimmer(A_LoopFileFullPath)
         If (RegExMatch(fullPath, RegExFilesPattern) && A_LoopFileSize>120)
         {
            thisCounter++
            newArrayu[thisCounter] := [A_LoopFileName, A_LoopFileDir, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated]
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            showTOOLtip("Loading files from`n" friendly "`nFound " groupDigits(thisCounter) " files...`nTotal indexed files: " groupDigits(maxFilesIndex), 0, 0, progressInfo)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }

     Loop, % thisCounter
     {
         If (determineTerminateOperation()=1 || abandonAll=1)
         {
            abandonAll := 1
            Break
         }

         erru := addSQLdbEntry(newArrayu[A_Index, 1], newArrayu[A_Index, 2], newArrayu[A_Index, 3], newArrayu[A_Index, 4], newArrayu[A_Index, 5], 0, factCheck)
         If !erru
         {
            addedNow++
            If (factCheck!=0)
            {
               maxFilesIndex++
               fullPath := newArrayu[A_Index, 2] "\" newArrayu[A_Index, 1]
               If (A_PtrSize=8 && minimizeMemUsage!=1)
                  resultedFilesList[maxFilesIndex] := [fullPath,,,,, newArrayu[A_Index, 3], newArrayu[A_Index, 4], newArrayu[A_Index, 5]]
               Else
                  resultedFilesList[maxFilesIndex] := [fullPath]

               resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
            }
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(A_Index, thisCounter, startOperation)
            showTOOLtip("Inserting records into the database for`n" friendly etaTime, 0, 0, A_Index / thisCounter)
            prevMSGdisplay := A_TickCount
         }

     }

     If (doCommits=1)
     {
        If !activeSQLdb.Exec("COMMIT TRANSACTION;")
           throwSQLqueryDBerror(A_ThisFunc)
     }
  } Else
  {
     Loop, Files, %strDir%, %doRecursive%
     {
         fullPath := Trimmer(A_LoopFileFullPath)
         If (RegExMatch(fullPath, RegExFilesPattern) && A_LoopFileSize>120)
         {
            If (SLDtypeLoaded=3) ; SQLite database 
               erru := addSQLdbEntry(A_LoopFileName, A_LoopFileDir, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated)

            If !erru
            {
               addedNow++
               maxFilesIndex++
               If (A_PtrSize=8 && minimizeMemUsage!=1)
                  resultedFilesList[maxFilesIndex] := [fullPath,,,,, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated]
               Else
                  resultedFilesList[maxFilesIndex] := [fullPath]

               If (SLDtypeLoaded=3)
                  resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
            }
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            showTOOLtip("Loading files from`n" friendly "`nFound " groupDigits(addedNow) " files...`nTotal indexed files: " groupDigits(maxFilesIndex), 0, 0, progressInfo)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }
  }

  currentFilesListModified := 1
  executingCanceableOperation := 0
  SetTimer, ResetImgLoadStatus, -50
  If (abandonAll=1)
  {
     showTOOLtip("Files list loading aborted")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "abandoned"
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return loadedFirst
}

getIDimage(imgID) {
    Return resultedFilesList[imgID, 1]
}

IDshowImage(imgID, opentehFile:=0) {
    Static prevIMGid, prevImgPath, lastInvoked := 1
    imgPath := getIDimage(imgID)
    If StrLen(imgPath)<4
    {
       addJournalEntry("Index entry error: incorrect file path:`n" imgPath " [ " imgID " ]")
       If (A_TickCount - lastInvoked>1050)
          SoundBeep, 300, 90
       lastInvoked := A_TickCount
       Return 0
    }

    isPipe := InStr(imgPath, "||")
    imgPath := StrReplace(imgPath, "||")
    If (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath) || StrLen(UserMemBMP)>2 || thumbsDisplaying=1)
       ignoreFileCheck := 1

    If (ignoreFileCheck!=1 && skipDeadFiles=1)
    {
       If (!FileRexists(imgPath) && opentehFile!=250 && imgPath!=prevImgPath)
       {
          If (autoRemDeadEntry=1 && imgID=currentFileIndex)
             remCurrentEntry(1)
          Return 0
       }
    }

    If (AnyWindowOpen!=10 && resetImageViewOnChange=1 && thumbsDisplaying!=1)
    {
       newIMGid := generateThumbName(imgPath, 1)
       If (prevIMGid!=newIMGid)
       {
          prevIMGid := newIMGid
          usrColorDepth := imgFxMode := 1
          vpIMGrotation := FlipImgH := FlipImgV := 0
       }
    }

    prevImgPath := (opentehFile=0 || opentehFile=2) ? imgPath : 0
    If (opentehFile=2)
       ShowTheImage(imgPath, 2)  ; prevent down-scaled display
    Else If (opentehFile=3)
       ShowTheImage(imgPath, 2, 1)  ; force image reload
    Else
       ShowTheImage(imgPath)
    Return 1
}

PreventKeyPressBeep() {
   IfEqual,A_Gui,1,Return 0 ; prevent keystrokes for GUI 1 only
}

trimArray(arr) {
; Hash O(n) - function by errorseven from:
; https://stackoverflow.com/questions/46432447/how-do-i-remove-duplicates-from-an-autohotkey-array
    hash := {}
    newArr := []
    thisCounter := 0
    For k, v in arr
    {
        z := "z" StringToASC(v)
        If (hash[z]!=1)
        {
           thisCounter++
           hash[z] := 1
           newArr[thisCounter] := v
        }
    }
    Return newArr
}

ReverseListNow() {
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (askAboutFileSave(" and the files list will be reversed") || maxFilesIndex<3)
       Return

    showTOOLtip("Reversing files list order")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := reverseArray(resultedFilesList)
    If StrLen(filesFilter)>1
       filteredMap2mainList := reverseArray(filteredMap2mainList)

    currentFilesListModified := 1
    ForceRefreshNowThumbsList()
    CurrentSLD := backCurrentSLD
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

RandomizeListNow() {
    If StrLen(filesFilter)>1
    {
       msgResult := msgBoxWrapper(appTitle ": Randomize files list", "You currently have a files list filter applied. To randomize the list, it will be deactivated.", 4, 0, "question")
       If InStr(msgResult, "yes")
       {
          markedSelectFile := 0
          showTOOLtip("Deactivating the files list filter, please wait")
          remFilesListFilter("simple")
          Sleep, 10
          RemoveTooltip()
       } Else Return
    }

    If askAboutFileSave(" and the files list will be randomized")
       Return

    showTOOLtip("Randomizing files list order")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := Random_ShuffleArray(resultedFilesList)
    CurrentSLD := backCurrentSLD
    currentFilesListModified := 1
    ForceRefreshNowThumbsList()
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

Random_ShuffleArray(Array) {
; function from "Facade Functional Programming Suite"
; by Shambles, from https://github.com/Shambles-Dev/AutoHotkey-Facade
; modified by Marius Șucan
; This is the Fisher–Yates shuffle algorithm.

    Result := Array.Clone()
    maxArray := Array.Count()
    Loop, % maxArray - 1
    {
        Random, J, % A_Index, % maxArray
        Temp            := Result[A_Index]
        Result[A_Index] := Result[J]
        Result[J]       := Temp
    }

    Return Result
}

reverseArray(a) {
; function inspired by RHCP from https://autohotkey.com/board/topic/97722-some-array-functions/

    aStorage := []
    maxIndexu := a.Count()
    Loop, % maxIndexu
        aStorage[A_Index] := a[maxIndexu - A_Index + 1]

    Return aStorage
}

coreResizeIMG(imgPath, newW, newH, file2save, goFX, toClippy, rotateAngle, soloMode:=1, imgW:=0, imgH:=0, batchMode:=0) {
    Static rr := "error"
    If (soloMode=1)
    {
       oBitmap := LoadBitmapFromFileu(imgPath)
       If StrLen(oBitmap)>2
       {
          Gdip_GetImageDimensions(oBitmap, imgW, imgH)
          rawFmt := Gdip_GetImageRawFormat(oBitmap)
          If (rawFmt="JPEG")
             RotateBMP2exifOrientation(oBitmap)

          If (!newW || !newH)
             mustDoRotateCoord := 1

          If !newW
             newW := imgW
          If !newH
             newH := imgH
          If (rotateAngle>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1 && mustDoRotateCoord=1)
             Gdip_GetRotatedDimensions(newW, newH, rotateAngle, newW, newH)
       } Else Return rr
    } Else oBitmap := soloMode

    If !oBitmap
       Return rr

    If (ResizeApplyEffects=1 || goFX=1)
    {
       mustDoBw := (bwDithering=1 && imgFxMode=4) ? 1 : 0
       If (imgFxMode=3 && toClippy!=1)
          AdaptiveImgLight(oBitmap, imgPath, 1, 1)

       decideGDIPimageFX(matrix, imageAttribs, pEffect)
    }

    ; to-do - if pargb - always??
    oPixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    If (toClippy=1)
       oPixFmt := (currIMGdetails.HasAlpha=1) ? "32-PARGB" : "24-RGB"

    brushRequired := !InStr(oPixFmt, "argb") ? 1 : 0
    pixFmt := (must24bits=1) ? "0x21808" : "0x26200A"     ; 24-RGB  //  32-ARGB
    thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
    If (editingSelectionNow=1 && ResizeCropAfterRotation=1 && ResizeWithCrop=1 && rotateAngle>0)
    {
       oBitmap := coreRotateBMP(oBitmap, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired)
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
    }

    If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1 && soloMode=1)
       calcRelativeSelCoords(oBitmap, imgW, imgH)

    If (editingSelectionNow=1 && (goFX=1 || ResizeWithCrop=1))
    {
       calcImgSelection2bmp(0, imgW, imgH, newW, newH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       imgSelW := Round(imgW), imgSelH := Round(imgH)
       imgSelPx := 0, imgSelPy := 0

       zImgSelW := Round(newW), zImgSelH := Round(newH)
       zImgSelPx := 0, zImgSelPy := 0
    }

    thumbBMP := trGdip_CreateBitmap(A_ThisFunc, zImgSelW, zImgSelH, pixFmt)
    If warnUserFatalBitmapError(thumbBMP, A_ThisFunc)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return rr
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbBMP, thisImgQuality, 4, 2)
    If !G2
    {
       trGdip_DisposeImage(oBitmap, 1)
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return rr
    }

    If (brushRequired=1) || (!RegExMatch(file2save, saveAlphaTypesRegEX) && toClippy!=1)
       trGdip_GraphicsClear(A_ThisFunc, G2, "0xFf" WindowBgrColor)
       ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, imgW + 4, imgH + 4)

    If (goFX=1 || ResizeApplyEffects=1)
    {
       setMainCanvasTransform(zImgSelW, zImgSelH, G2)
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(oBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If zBitmap
          {
             trGdip_DisposeImage(oBitmap, 1)
             oBitmap := zBitmap
          }

          E := Gdip_BitmapSetColorDepth(oBitmap, "BW", 1)
       } Else If (usrColorDepth>1)
          E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
 
       If pEffect
          Gdip_BitmapApplyEffect(oBitmap, pEffect)
    }

    changeMcursor()
    E := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, 0, 0, zImgSelW, zImgSelH, imgSelPx, imgSelPy, imgSelW, imgSelH,, 2, imageAttribs)
    trGdip_DisposeImage(oBitmap, 1)
    If (E="fail")
    {
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DeleteGraphics(G2)
       Gdip_DisposeImageAttributes(imageAttribs)
       Gdip_DisposeEffect(pEffect)
       Return rr
    }

    Sleep, 0
    If (editingSelectionNow=1 && ResizeCropAfterRotation=0 && ResizeWithCrop=1 && rotateAngle>0) || (rotateAngle>0 && editingSelectionNow!=1) || (rotateAngle>0 && ResizeWithCrop!=1)
       thumbBMP := coreRotateBMP(thumbBMP, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired)

    If (toClippy!=1 && FileExist(file2save))
       Try FileSetAttrib, -R, %file2save%

    Sleep, 0
    changeMcursor()
    If StrLen(thumbBMP)>3
    {
       If (toClippy=1)
       {
          hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, thumbBMP)
          r := hBitmap ? Gdip_SetBitmapToClipboard(thumbBMP, hBitmap) : addJournalEntry("get_last_err")
       } Else
          r := Gdip_SaveBitmapToFile(thumbBMP, file2save, userJpegQuality)

       If (toClippy!=1) && (r=-2 || r=-1)
          r := SaveFIMfile(file2save, thumbBMP)
    } Else r := "err"

    Gdip_DeleteGraphics(G2)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeImageAttributes(imageAttribs)
    trGdip_DisposeImage(thumbBMP, 1)
    Return r
}

coreRotateBMP(whichBitmap, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired) {
    Static imgOrientOpt := {"i000":0, "i100":1, "i200":2, "i300":3, "i010":4, "i110":5, "i210":6, "i310":7, "i001":6, "i101":7, "i201":4, "i301":5, "i011":2, "i111":3, "i211":0, "i311":1}

    confirmSimpleRotation := isVarEqualTo(rotateAngle, 0, 90, 180, 270)
    If (confirmSimpleRotation=1)
    {
       imgFoperation := (rotateAngle=90) ? 1 : 0
       imgFoperation := (rotateAngle=180) ? 2 : imgFoperation
       imgFoperation := (rotateAngle=270) ? 3 : imgFoperation
       ; If (goFX=1 || ResizeApplyEffects=1)
       ;    imgFoperation := imgOrientOpt["i" imgFoperation FlipImgH FlipImgV]
       If (imgFoperation>0)
          Gdip_ImageRotateFlip(whichBitmap, imgFoperation)
       thumbBMP := whichBitmap
    } Else
    {
       whichBrush := (brushRequired=1) ? pBrushWinBGR : ""
       zBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, rotateAngle, whichBrush, thisImgQuality, pixFmt)
       If StrLen(zBitmap)>2
       {
          trGdip_DisposeImage(whichBitmap, 1)
          thumbBMP := zBitmap
       } Else thumbBMP := zBitmap
       ; If (goFX=1 || ResizeApplyEffects=1) && (ResizeCropAfterRotation=1)
       ;    flipBitmapAccordingToViewPort(thumbBMP, 1)
    }
    Return thumbBMP
}

flipBitmapAccordingToViewPort(whichBitmap, ignoreThis:=0) {
   imgOp := (FlipImgH=1) ? 4 : 0
   imgOp := (FlipImgV=1) ? 6 : imgOp
   imgOp := (FlipImgV=1 && FlipImgH=1) || (vpIMGrotation=180 && ignoreThis=0) ? 2 : imgOp
   If (imgOp>0 && whichBitmap)
      Gdip_ImageRotateFlip(whichBitmap, imgOp)
   Return whichBitmap
}

calcImgSelection2bmp(boundLess, imgW, imgH, newW, newH, ByRef imgSelPx, ByRef imgSelPy, ByRef imgSelW, ByRef imgSelH, ByRef zImgSelPx, ByRef zImgSelPy, ByRef zImgSelW, ByRef zImgSelH, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, usePrevious:=0, givenRotation:=0, givenCoords:=0) {
   If (usePrevious=1)
   {
      nImgSelX1 := min(prevImgSelX1, prevImgSelX2)
      nImgSelY1 := min(prevImgSelY1, prevImgSelY2)
      nImgSelX2 := max(prevImgSelX1, prevImgSelX2)
      nImgSelY2 := max(prevImgSelY1, prevImgSelY2)
   } Else
   {
      nImgSelX1 := min(imgSelX1, imgSelX2)
      nImgSelY1 := min(imgSelY1, imgSelY2)
      nImgSelX2 := max(imgSelX1, imgSelX2)
      nImgSelY2 := max(imgSelY1, imgSelY2)
   }

   If InStr(givenCoords, "|")
   {
      givenCoordsObj := StrSplit(givenCoords, "|")
      nImgSelX1 := min(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY1 := min(givenCoordsObj[2], givenCoordsObj[4])
      nImgSelX2 := max(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY2 := max(givenCoordsObj[2], givenCoordsObj[4])
   }

   If (boundLess=-1)
   {
      initialboundLess := boundLess
      boundLess := (A_PtrSize=4) ? 0 : 1
   }

   If (boundLess!=1)
   {
      If (nImgSelX1<0)
         nImgSelX1 := 0
      If (nImgSelY1<0)
         nImgSelY1 := 0

      If (nImgSelX2>imgW)
         nImgSelX2 := imgW
      If (nImgSelY2>imgH)
         nImgSelY2 := imgH
   }

   imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
   imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
   imgSelPx := min(nImgSelX1, nImgSelX2)
   imgSelPy := min(nImgSelY1, nImgSelY2)
   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(imgSelW, imgSelH, givenRotation, rimgSelW, rimgSelH)
      imgSelPx := imgSelPx - (rimgSelW - imgSelW)//2
      imgSelPy := imgSelPy - (rimgSelH - imgSelH)//2
      imgSelW := rimgSelW
      imgSelH := rimgSelH
      If (imgSelPx<1)
         imgSelPx := 0
      If (imgSelPy<1)
         imgSelPy := 0
      If (imgSelPx + imgSelW>imgW)
         imgSelW := imgW - imgSelPx
      If (imgSelPy + imgSelH>imgH)
         imgSelH := imgH - imgSelPy
   }

   If (imgSelW<2)
   {
      imgSelW := 2
      imgSelPx := (imgSelPx>=2) ? imgSelPx - 2 : 0
      nImgSelX2 := imgSelPx + imgSelW
   }

   If (imgSelH<2)
   {
      imgSelH := 2
      imgSelPy := (imgSelPy>=2) ? imgSelPy - 2 : 0
      nImgSelY2 := imgSelPy + imgSelH
   }

   nImgSelX1 := imgSelPx
   nImgSelY1 := imgSelPy

   zLv := newH/imgH
   zLh := newW/imgW
   zImgSelX1 := Floor(nImgSelX1*zLh)
   zImgSelY1 := Floor(nImgSelY1*zLv)
   zImgSelX2 := Floor(nImgSelX2*zLh)
   zImgSelY2 := Floor(nImgSelY2*zLv)
   If (boundLess!=1)
   {
      If (zImgSelX2>newW)
         zImgSelX2 := newW
      If (zImgSelY2>newH)
         zImgSelY2 := newH
   }

   zImgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   zImgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
   zImgSelPx := min(zImgSelX1, zImgSelX2)
   zImgSelPy := min(zImgSelY1, zImgSelY2)

   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(zimgSelW, zimgSelH, givenRotation, zrimgSelW, zrimgSelH)
      zimgSelPx := zimgSelPx - (zrimgSelW - zimgSelW)//2
      zimgSelPy := zimgSelPy - (zrimgSelH - zimgSelH)//2
      zimgSelW := zrimgSelW
      zimgSelH := zrimgSelH
      If (zimgSelPx<1)
         zimgSelPx := 0
      If (zimgSelPy<1)
         zimgSelPy := 0
      If (zimgSelPx + zimgSelW>newW)
         zimgSelW := newW - zimgSelPx
      If (zimgSelPy + zimgSelH>newH)
         zimgSelH := newH - zimgSelPy
   }

   If (zImgSelW<2)
   {
      zImgSelW := 2
      zImgSelPx := (zImgSelPx>=2) ? zImgSelPx - 2 : 0
   }

   If (zImgSelH<2)
   {
      zImgSelH := 2
      zImgSelPy := (zImgSelPy>=2) ? zImgSelPy - 2 : 0
   }

   If (initialboundLess=-1 && boundLess=0)
   {
      capSelectionRelativeCoords()
      imgSelX1 := X1, imgSelY1 := Y1
      imgSelX2 := X2, imgSelY2 := Y2
      SetTimer, dummyRefreshImgSelectionWindow, -100
   }
}

ResizePanelHelpBoxInfo() {
    msgBoxWrapper(appTitle ": HELP", "In «Advanced mode» there is limited support for color depths other than 24 and 32 bits. All images will be converted to 24 bits per pixel. If the alpha channel is present, the resulted file will be in 32 bits, if the format allows. When saving images in formats that do not support an alpha channel, the window background color is used.`n`nUse «Simple mode» to better preserve color depths or work with images larger than 530 MPx or than 32500 px [if the given file format allows it]. This mode supports 1-, 8-, 24-, 32-, 16- (UINT16), 48- (RGB16), 64- (RGBA16), 32- (FLOAT), 96- (RGBF) and 128- (RGBAF) bits images. High-dynamic range formats supported: .EXR, .HDR, .JXR, .HDP, .PFM and .TIFF.`n`nPlease also note, while there is full support for multi-frames/paged images [for GIFs and TIFFs only] in the viewport... on file (re)save or format conversion, only the first frame will be preserved.", -1, 0, 0)
}

OpenGitHub() {
  Static thisURL := "https://github.com/marius-sucan/Quick-Picto-Viewer"
  Try Run, % thisURL
  Catch wasError
        msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the URL:`n" %thisURL%, 0, 0, "error")
}

MenuDrawViewportHelpMap() {
   SetTimer, RemoveTooltip, Off
   lastOSDtooltipInvoked := A_TickCount
   SetTimer, drawViewportHelpMap, -100
}

drawViewportHelpMap() {
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    If (editingSelectionNow=1)
    {
       lastOSDtooltipInvoked := A_TickCount
       SetTimer, RemoveTooltip, Off
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xEE121212")
       thisThick := imgHUDbaseUnit//9
       Penuha := Gdip_CreatePen("0xEE445544", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x15EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x20778877)
       dotsSize := SelDotsSize
       thisW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
       thisH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
       thisX := min(selDotX, selDotAx) + dotsSize//2
       thisY := min(selDotY, selDotAy) + dotsSize//2

       Gdip_FillRectangle(2NDglPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisX, thisY, thisW, thisH)
       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfontSize*0.77)
       thisStylu := " x" thisX " y" thisY
       ERR := Gdip_TextToGraphics(2NDglPG, "Image selected area", thisFntSize thisStylu , "Arial", thisW, thisH)
       thisFntSize := "Bold cFFeeEEee s" Round(OSDfontSize*0.77)
       thisStylu := " x" OSDfontSize*2 " y" OSDfontSize*2
       ERR := Gdip_TextToGraphics(2NDglPG, "Current selection type: " DefineVPselAreaMode() ".`n `nDouble click on it to open a menu.`n `nDouble click outside to drop the selection.`n `nHold Space and click to pan image.`n `nCtrl + Wheel Up/Down to zoom in/out anywhere.", thisFntSize thisStylu , "Arial", mainWidth - OSDfontSize*2, mainHeight - OSDfontSize*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
       lastOSDtooltipInvoked := A_TickCount
       toolTipGuiCreated := 2
    } Else If (TouchScreenMode=1)
    {
       SetTimer, RemoveTooltip, Off
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xEE121212")
       thisThick := imgHUDbaseUnit//10
       Penuha := Gdip_CreatePen("0x99334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x15EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x20778877)

       calculateTouchMargins(thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(2NDglPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(2NDglPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(2NDglPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_SetClipRect(2NDglPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(2NDglPG)
       Gdip_DrawRectangle(2NDglPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfontSize*0.77)
       thisStylu := " x" thisX " y" thisY
       ERR := Gdip_TextToGraphics(2NDglPG, "Image panning area.`n`nDouble click in this area to change how the image is adapted to the viewport.`n`nShift + Left-click to create a new selection area.`n`nOne-finger swipe gestures allowed when nothing to pan - outside this rectangle they are always allowed.`n`nCtrl + Wheel Up/Down to zoom in/out anywhere", thisFntSize thisStylu , "Arial", thisW, thisH)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfontSize*0.9)
       thisStylu := " x" thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom in", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x" thisX " y" thisY + thisH
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom out", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x1 y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Previous`nimage", thisFntSize thisStylu, "Arial", thisX, mainHeight)
       thisStylu := " x" thisW + thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Next`nimage", thisFntSize thisStylu, "Arial", thisX, mainHeight)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
       lastOSDtooltipInvoked := A_TickCount
       toolTipGuiCreated := 2
    }
}

ShowContextualHelp() {
   Static blushTypes := {1:"Simple solid color", 2:"Soft edges brush", 3:"Cloner", 4:"Eraser", 5:"Effects", 6:"Smudge", 7:"Pinch", 8:"Bulge"}

   infoThumbsList := defineListViewModes()
   If (thumbsDisplaying=1)
   {
      If testIsDupesList()
         info := "`nDisplaying a list of identified image duplicates"
      msgu := "Current context: " infoThumbsList " list view" info "`nF4 - Open folders tree explorer`nEscape / Enter - Return to image view"
   } Else If (drawingShapeNow=1)
   {
      msgu := "Current context: drawing a freeform shape`nEscape - Abandon`nEnter - Finish drawing`nR-Click - Options"
   } Else If (AnyWindowOpen>0)
   {
      If (AnyWindowOpen=24 || AnyWindowOpen=31)
         SetTimer, BtnHelpTransform, -100
      Else If (AnyWindowOpen=64)
         SetTimer, BtnHelpBrushes, -100

      WinGetTitle, OutputVar , ahk_id %hSetWinGui%
      If (imgEditPanelOpened=1)
      {
         if isNowAlphaPainting()
            thisu := "`nContext: painting alpha mask"
         Else If (AnyWindowOpen=64)
            thisu := "`nCurrent brush: " blushTypes[BrushToolType]

         moreInfo := "`nLive image editing tool" thisu "`nF8 - Toggle panel visibility`nEscape - Abandon`nEnter - Apply"
      }

      OutputVar := StrReplace(OutputVar, ": " appTitle)
      If (imgEditPanelOpened=1 && IMGlargerViewPort=1)
         moreInfo .= "`nHold the Space key and left-click to pan the image"
      msgu := "Current tool: " OutputVar moreInfo
   }
   
   If msgu
      showTOOLtip(msgu)
   SetTimer, RemoveTooltip, % -msgDisplayTime*3
}

showQuickHelp() {
    Static lastInvoked := 1
    If ((A_TickCount - lastInvoked<650) && !AnyWindowOpen && drawingShapeNow!=1)
       HelpWindow()
    Else If (AnyWindowOpen || drawingShapeNow=1 || thumbsDisplaying=1)
       ShowContextualHelp()
    Else
       drawViewportHelpMap()

    lastInvoked := A_TickCount
    ; listu := ""
    ; Loop, 256
    ;    listu .= Chr(A_Index + 161)
    ; MsgBox, % listu
}

AboutWindow() {
    Global LViewOthers, listViewFilteru
    thisBtnHeight := createSettingsGUI(1, A_ThisFunc)
    Gui, Add, Button, x1 y1 h1 w1 Default gBtnCloseWindow, Close
    Gui, -DPIScale
    Gui, Font, s19 Bold, Arial, -wrap
    Gui, Add, Picture, x+10 y+10 w150 Section h-1 +0x3 gOpenGitHub, qpv-icon.ico
    Gui, Add, Text, x+20 y15, %appTitle% v%appVersion%
    Gui, Font, s10 Bold, Arial, -wrap
    Gui, Add, Link, y+5 wp, Developed by <a href="http://marius.sucan.ro/">Marius Șucan</a>.
    Gui, Font
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%
    Gui, Add, Link, y+10 wp, Based on the prototype image viewer by <a href="http://sites.google.com/site/littlescripting/">SBC</a> from October 2010 published on <a href="https://autohotkey.com/board/topic/58226-ahk-picture-viewer/">AHK forums</a>.
    lstWid := 450
    btnWid := 60
    txtWid := 440
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 250
       btnWid := btnWid + 30
       txtWid := txtWid + 190
       Gui, Font, s%LargeUIfontValue%
    }

    IniAction(1, "appVersion", "General")
    If wasInitFIMlib
       thisVersion := " v" FreeImage_GetVersion()

    compiled := (A_IsCompiled=1) ? "Compiled. " : "Uncompiled. "
    compiled .= (A_PtrSize=8) ? "x64. " : "x32. "
    Gui, +DPIScale
    Gui, Font, Bold

    Gui, Add, Text, xs+15 y+25 w%txtWid%, Current version: v%appVersion% from %vReleaseDate%. Internal AHK-H version: %A_AhkVersion%. %compiled%OS: %A_OSVersion%.
    Gui, Add, Link, y+10 wp, New and previous versions are available on <a href="https://github.com/marius-sucan/Quick-Picto-Viewer">GitHub</a>.
    Gui, Font, Normal
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, y+10 wp h2 +0x1007, lol
    Gui, Add, Text, y+10 wp, Dedicated to people with really large image collections and slideshow needs.
    Gui, Add, Text, y+10 wp, This application contains code from various entities. You can find more details in the source code.
    Gui, Add, Text, y+10 wp, QPV uses GDI+ [Windows APIs] to display images and FreeImage%thisVersion% to load exotic file formats. FreeImage is licensed under the GNU General Public License, v2.0 (GPLv2) or v3.0 (GPLv3)`, and the FreeImage Public License (FIPL)

    Gui, Add, Link, y+10 wp, To keep the development going, <a href="https://www.paypal.me/MariusSucan/10">please donate</a> or <a href="mailto:marius.sucan@gmail.com?subject=%appTitle% v%appVersion%">send me feedback</a>.

    Gui, Add, Button, xs+15 y+20 h%thisBtnHeight% w%btnWid% gBtnHelpWin, &Help
    Gui, Add, Button, x+5 hp wp gPanelJournalWindow, &Journal
    Gui, Add, Button, x+5 hp wp Default gBtnCloseWindow, &Close
    Gui, Add, Button, x+5 hp gcheckForUpdatesNow, &Check for updates
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "About " appTitle " v" appVersion)
    PopulateAboutKbdShortcutsList()
    checkDLLfiles()
}

BtnHelpWin() {
   BtnCloseWindow()
   HelpWindow()
}

HelpWindow(dummy:=0) {
    Global LViewOthers, listViewFilteru

    thisBtnHeight := createSettingsGUI(61, A_ThisFunc)
    Gui, Add, Button, x1 y1 h1 w1 Default gBtnCloseWindow, Close
    lstWid := 490
    btnWid := 60
    txtWid := 440
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 210
       btnWid := btnWid + 30
       txtWid := txtWid + 190
       Gui, Font, s%LargeUIfontValue%
    }

    drawViewportHelpMap()
    tabu := (dummy="cmdu") ? 3 : 2
    rz := (PrefsLargeFonts=1) ? 15 + additionalLVrows : 17 + additionalLVrows
    rx := rz - 4
    Gui, Add, Tab3, x15 y15 Choose%tabu%, General|Keyboard shortcuts|Command line|Change log|Features
    Gui, Tab, 1 ; general

    FileRead, cmdHelp, % mainCompiledPath "\resources\general-help.txt"
    Gui, Add, Edit, x+15 y+15 w%lstWid% r%rz% ReadOnly, %cmdHelp%

    Gui, Tab, 2 ; keyboard 
    Gui, Add, ListView, x+15 y+15 w%lstWid% r%rx% Grid +LV0x10000 vLViewOthers, Keys|Action|Context|Opens
    Gui, Add, Combobox, xp y+10 wp gUIgenericComboAction hwndhEditField vlistViewFilteru, \Files list|\Image view|\Image selection area|\Live editing|\Folder tree|\Painting mode|\Vector drawing|\Anywhere|\Panel|\Menu

    cmdHelp := "QPV can be invoked with command line arguments. Examples:`n`n1. Open a folder:`nqpv.exe ""fd=C:\example folder\tempus""`n`nAdd a pipe ""|"" after equal ""="" to NOT have images loaded recursively."
    cmdHelp .= "`n`n2. Call an internal function:`nqpv.exe call_ToggleThumbsMode() ""fd=C:\folder\tempus""`n`nThis will index all the images in the given folder and switch to thumbnails mode.`n`nOnly functions that need no parameters can be invoked. If multiple call_ are used, only the last valid one will be considered."
    cmdHelp .= "`n`nTo learn what functions you can call, check the Journal window in QPV. It names functions when opening panels or when errors occur. You can also enable debug mode, to gather more intel, or study the source code."
    cmdHelp .= "`n`n3. Specify user settings:`n`nqpv.exe set_IMGresizingMode=3 set_vpIMGrotation=45 ""C:\folder\this-image.png""`n"
    cmdHelp .= "`nYou can find available user settings in the quick-picto-viewer.ini file or by right-clicking on controls in the panels.`n`nYou can pass up to 950 arguments`n`nPass /qpv-debug argument to have QPV send debug information to a Win32 Debug Viewer.`n`nIf one .SLD file or one folder is passed as argument, any other image file passed as argument is ignored."

    Gui, Tab, 3 
    Gui, Add, Edit, x+15 y+15 w%lstWid% r%rz% ReadOnly, %cmdHelp%

    Gui, Tab, 4
    FileRead, cmdHelp, % mainCompiledPath "\resources\qpv-change-log.txt"
    ; cmdHelp := SubStr(cmdHelp, 1, 65200)
    Gui, Add, Edit, x+15 y+15 w%lstWid% r%rz% ReadOnly vtxtLine1, a ; %cmdHelp%
    GuiControl, SettingsGUIA:, txtLine1, % StrReplace(cmdHelp, "Â")

    Gui, Tab, 5
    FileRead, cmdHelp, % mainCompiledPath "\resources\features-list.txt"
    Gui, Add, Edit, x+15 y+15 w%lstWid% r%rz% ReadOnly, % StrReplace(cmdHelp, "Â")

    Gui, Tab
    Gui, Add, Button, xs+15 y+8 h%thisBtnHeight% w%btnWid% gBtnAboutWin, &About
    Gui, Add, Button, x+5 hp wp gPanelJournalWindow, &Journal
    Gui, Add, Button, x+5 hp wp gPanelQuickSearchMenuOptions, &Search
    Gui, Add, Button, x+5 hp wp Default gBtnCloseWindow, &Close
    Gui, Add, Text, x+5 hp +0x200, QPV v%appVersion%

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Help " appTitle " v" appVersion)
    PopulateAboutKbdShortcutsList()
    checkDLLfiles()
}

BtnAboutWin() {
   BtnCloseWindow()
   AboutWindow()
}

PopulateAboutKbdShortcutsList(useFilter:=0) {
    Static fileData := 0
    EM_SETCUEBANNER(hEditField, "Filter keyboard shortcuts list", 0)
    startOperation := A_TickCount
    setImageLoading()
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    GuiControlGet, listViewFilteru
    GuiControl, -Redraw, LViewOthers
    LV_Delete()
    startZeit := A_TickCount
 
    If !fileData
       FileRead, fileData, % mainCompiledPath "\resources\help-keyboard-shortcuts.txt"

    listFilter := (useFilter=1) ? listViewFilteru : ""
    If (SubStr(listFilter, 1, 1)="\" && StrLen(listFilter)>3) 
       listFilter := StrReplace(listFilter, "\", "|")

    startOperation := A_TickCount
    Loop, Parse, fileData, `n, `r
    {
        If (StrLen(A_LoopField)<5) || (listFilter && !InStr(A_LoopField, listFilter))
           Continue

        countThese++
        lineArru := StrSplit(A_LoopField, "|")
        LV_Add(A_Index, lineArru[1], lineArru[2], lineArru[3], lineArru[4])
    }

    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")
    GuiControl, +Redraw, LViewOthers
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

UIfilterListViewKbdsAbout() {
   GuiControlGet, listViewFilteru
   If (SubStr(listViewFilteru, 1, 1)="\" && StrLen(listViewFilteru)>3) 
      listViewFilteru := StrReplace(listViewFilteru, "\", "|")

   PopulateAboutKbdShortcutsList(listViewFilteru)
}

BtnChangeSatPlus() {
  ChangeSaturation(1)
}

BtnChangeSatMin() {
  ChangeSaturation(-1)
}

BtnChangeLumPlus() {
  ChangeLumos(1)
}

BtnChangeLumMin() {
  ChangeLumos(-1)
}

BtnChangeGammPlus() {
  ChangeGammos(1)
}

BtnChangeGammMin() {
  ChangeGammos(-1)
}

PanelsCheckFileExists() {
   If (currentFileIndex=0)
      Return 0

   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, fileNamu, OutDir)
   If !FileRexists(imgPath)
   {
      OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" OutDir "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 0
   } Else Return 1
}

PanelResolutionSorting() {
   If AnyWindowOpen
   {
      addJournalEntry(A_ThisFunc "(): ERROR: cannot open panel. Another panel is opened: " AnyWindowOpen "=" prevOpenedWindow[2])
      Return
   }

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(20, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Choose resolution sort mode: " appTitle, "Each file will be read to identify the image resolution, in pixels.`n`nThis operation can take a lot of time with many files.", "&Sort list|&Histogram|&Cancel", 1, "image-file", "&Reverse order", 0, "Resolution (MPx)`f`fImage width`fImage height`fAspect ratio (W/H)`fImage DPI`fPages / frames", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "sort")
   {
      reverseOrderOnSort := msgResult.check
      IniAction(1, "reverseOrderOnSort", "General")
      ActSortImageProperties(msgResult.list)
   } Else If InStr(msgResult.btn, "histogram")
      PanelHistogramSorting()
}

PanelHistogramSorting() {
   Static hasAskedSort := 0
   If AnyWindowOpen
      Return

   If warnXPhistoSort()
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(45, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Choose image histogram sort mode: " appTitle, "Each image file will be read to extract its histogram data.`n`nThis operation can take a lot of time with many files.", "&Sort list|&Resolution|&Cancel", 1, "image-file", "&Reverse order", 0, "Average`f`fMedian`fPeak range`fMinimum range`f`Range`fMode`fMinimum`fRoot-mean square", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "sort")
   {
      good2go := 0
      If !hasAskedSort
      {
         msgResultu := msgBoxWrapper(appTitle ": Sort list", "Each file will be read to determine its histogram main points.`n`nAre you sure you want to sort the list in this mode? It can take a lot of time...", 4, 0, "question")
         If InStr(msgResultu, "yes")
            hasAskedSort := 1
      } Else good2go := 1
      If (good2go!=1 && hasAskedSort=0)
         Return

      reverseOrderOnSort := msgResult.check
      IniAction(1, "reverseOrderOnSort", "General")
      ActSortHistogram(msgResult.list)
   } Else If InStr(msgResult.btn, "resolution")
      PanelResolutionSorting()
}

testIsDupesList() {
   If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
      Return 1
   Else
      Return 0
}

PanelFindDupes(dummy:=0) {
    Global userFindDupesSelectAllDummy := 0, hasOpened, txtLine1, editFc, editFd, txtline2, editFr
    Static userWasWarned := 0

    userFindDupesSelectAllDummy := 0
    If !hasOpened
    {
       Global UIcheckimgfile := 0, UIcheckfcreated := 0, UIcheckfmodified := 0, UIcheckfsize := 0, UIcheckkbfsize := 0, UIcheckimgpixfmt := 0, UIcheckimgwidth := 0, UIcheckimgheight := 0, UIcheckimgmegapix := 0, UIcheckimgwhratio := 0, UIcheckimgframes := 0, UIcheckimghpeak := 0, UIcheckimghlow := 0
            , UIcheckimghrange := 0, UIcheckimgavg := 0, UIcheckimgmedian := 0, UIcheckimghrms := 0, UIcheckimghmode := 0, UIcheckimghminu := 0, editFE
       hasOpened := 1
    }

    If (maxFilesIndex<3 && !filesFilter)
    {
       showTOOLtip("WARNING: Insufficient indexed files to activate the list view mode")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (SLDtypeLoaded!=3)
    {
       msgResult := msgBoxWrapper(appTitle ": Confirmation", "The files list is currently not saved as an SQLite database. This format is required to store the collected image details and hashes needed for identifying similar or identical images.`n`nWould you like to save it in the specified format?", "&Yes|&Remove duplicate entries|&Cancel", 2, "question")
       If (msgResult="Yes")
          PanelSaveSlideShowu()
       Else If InStr(msgResult, "remove")
          cleanDeadFilesList("noFilesCheck")
       Return
    }

    IniAction(0, "fadeOtherDupeGroups", "General", 1)
    initFIMGmodule()
    initQPVmainDLL()
    If (dupesDCTcoeffsInit!=1 && userWasWarned=0)
    {
       userWasWarned := 1
       msgBoxWrapper(appTitle ": WARNING", appTitle " has failed to properly initialize the main DLL file: qpvmain.dll. Options within this panel and others will likely malfunction.", 0, 0, "error")
    }

    thisBtnHeight := createSettingsGUI(49, A_ThisFunc, 1)
    btnWid := 100
    txtWid := 350
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 175
       Gui, Font, s%LargeUIfontValue%
    }

    If StrLen(filesFilter)<3
       excludePreviousDupesFromList := 0

    If (A_PtrSize!=8)
       userFindDupesFilterHamDist := 1

    If (dummy>0 && isNumber(dummy) && isInRange(dummy, 1, 3))
       CurrentPanelTab := dummy

    col := (PrefsLargeFonts=1) ? 285 : 190
    Gui, Add, Tab3, gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Image hashes|Collect data|Filtering
    Gui, Tab, 1 ; general
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gupdateUIdupesPanel AltSubmit Choose%userFindDupePresets% vuserFindDupePresets, Image content fingerprint (dHash 8x8)|Image histogram data|Image resolution and file size|Image histogram, resolution and file size|Identical file names|Identical file names and file sizes|Custom mode
    Gui, Add, Checkbox, xs y+7 w%col% -wrap gUIfindDupesChecksu Checked%UIcheckimgfile% vUIcheckimgfile, File name and its extension
    Gui, Add, Checkbox, x+7 gBTNselectAllFindDupesProperties Checked%userFindDupesSelectAllDummy% vuserFindDupesSelectAllDummy, &Select all
    Gui, Add, Text, x+3 vbtnFldr, Precision:
    Gui, Add, Edit, x+2 w50 number -multi limit1 veditF5, % findDupesPrecision
    Gui, Add, UpDown, vfindDupesPrecision Range1-5, % findDupesPrecision
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckfcreated% vUIcheckfcreated, Date created
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckfmodified% vUIcheckfmodified, Date modified
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckfsize% vUIcheckfsize, Size (bytes)
    Gui, Add, Checkbox, X+7 gUIfindDupesChecksu Checked%UIcheckkbfsize% vUIcheckkbfsize, Size (kilobytes)
    Gui, Add, Checkbox, xs y+17 w%col% gUIfindDupesChecksu Checked%UIcheckimgpixfmt% vUIcheckimgpixfmt, Image pixel format
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgframes% vUIcheckimgframes, Frames / pages
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgwidth% vUIcheckimgwidth, Width
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgheight% vUIcheckimgheight, Height
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgmegapix% vUIcheckimgmegapix, Megapixels
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgwhratio% vUIcheckimgwhratio, Aspect ratio (W/H)
    Gui, Add, Checkbox, xs y+17 w%col% gUIfindDupesChecksu Checked%UIcheckimghpeak% vUIcheckimghpeak, Histogram max. range
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghlow% vUIcheckimghlow, Histogram min. range
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimghrange% vUIcheckimghrange, Histogram total range
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgavg% vUIcheckimgavg, Histogram average
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgmedian% vUIcheckimgmedian, Histogram median
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghrms% vUIcheckimghrms, Histogram root-mean square
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimghmode% vUIcheckimghmode, Histogram mode
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghminu% vUIcheckimghminu, Histogram minimum

    fingWid := (PrefsLargeFonts=1) ? 170 : 100
    fingEdt := (PrefsLargeFonts=1) ? 70 : 50
    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 w%txtWid% Section vbtnFldr6, Below you can choose what image hashing algorithm to use to compare images and configure what sections of the hashes to compare. The blue dots in the preview area highlight the areas of the images that will be compared. Higher threshold may yield more false-positives listed. lHash is the worst performing.
    Gui, -DPIScale
    Gui, Add, Text, xp y+20 Section w122 h122 +0x1000 +0xE +hwndhCropCornersPic, Image hashing preview
    Gui, +DPIScale
    Gui, Add, DropDownList, x+10 yp w%fingWid% AltSubmit Section gupdateUIdupesPanel Choose%userFindDupesFilterHamDist% vuserFindDupesFilterHamDist, Ignore|dHash 8x8|pHash DCT 32x32|lHash 8x8
    Gui, Add, Edit, x+5 w%fingEdt% gupdateUIdupesPanel number -multi limit1 veditF11, % hamDistLBorderCrop
    Gui, Add, UpDown, vhamDistLBorderCrop gupdateUIdupesPanel Range0-9, % hamDistLBorderCrop
    Gui, Add, Edit, x+5 w%fingEdt% gupdateUIdupesPanel number -multi limit1 veditF6, % hamDistLBorderCrop
    Gui, Add, UpDown, vhamDistRBorderCrop gupdateUIdupesPanel Range0-9, % hamDistLBorderCrop
    Gui, Add, Text, xs y+7 w%fingWid% vtxtLine1, Threshold
    Gui, Add, Edit, x+5 w%fingEdt% gupdateUIdupesPanel number -multi limit2 veditF7, % userFindDupesHamDistLvl
    Gui, Add, UpDown, vuserFindDupesHamDistLvl gupdateUIdupesPanel Range1-15, % userFindDupesHamDistLvl
    Gui, Add, Checkbox, xm+15 y+15 Checked%findFlippedDupes% vfindFlippedDupes, Identify images horizontally flipped
    Gui, Add, Checkbox, xp y+15 Checked%findInvertedDupes% vfindInvertedDupes, Attempt to identify color inverted images
    Gui, Add, Checkbox, xm+15 y+15 Checked%BreakDupesGroups%  vBreakDupesGroups, Break the groups based on hamming distance [similarity]
    Gui, Add, Checkbox, xp y+15 Checked%PerformMSDonDupes% gupdateUIdupesPanel vPerformMSDonDupes, Filter results using Mean-Squared Difference [32x32]
    Gui, Add, Edit, x+5 w%fingEdt% gupdateUIdupesPanel number -multi limit3 veditFr, % userFindDupesMSElvl
    Gui, Add, UpDown, vuserFindDupesMSElvl gupdateUIdupesPanel Range1-950, % userFindDupesMSElvl

    Gui, Tab, 3
    Gui, Add, Text, x+15 y+15 w%txtWid% Section, These options allow altering how image data is collected. For best results, these settings should be altered only once, before any data is collected. All processes can be interrupted and resumed at any time.
    
    Gui, Add, Text, xs y+15, For these to take effect, refresh image histogram and fingerprints data:
    Gui, Add, Checkbox, xs+15 y+15 Checked%hamDistInterpolation% vhamDistInterpolation gUIeditHammingInterpolation, High-quality resampling (slower)
    Gui, Add, Checkbox, xp y+15 Checked%dupesApplyBlur% vdupesApplyBlur, Blur images by 4x4 to weed out artefacts

    Gui, Add, Text, xs y+15, For these to take effect, refresh only the image hashes:
    Gui, Add, Checkbox, xs+15 y+15 Checked%userpHashMode% vuserpHashMode, pHashes based on averages, instead of the median values
    Gui, Add, Text, xp y+20 hp, Compress gray levels by a factor of
    Gui, Add, Edit, x+5 w%fingEdt% gupdateUIdupesPanel number -multi limit2 veditFc, % graylevelCompressor
    Gui, Add, UpDown, vgraylevelCompressor gupdateUIdupesPanel Range1-9, % graylevelCompressor
    Gui, Add, Button, xs y+15 h%thisBtnHeight% gBtnPurgeCachedSQLdata, Pur&ge cached data
    Gui, Add, Button, x+5 hp gBtnCollectDupesData, Collect image pi&xels data

    Gui, Tab, 4
    Gui, Add, Text, x+15 y+15 Section, Filter the results and data collection with a given string:
    Gui, Add, Edit, xp+15 y+7 wp-30 -multi limit12345 gUIeditsGenericAllowCtrlBksp vdupesStringFilter, % dupesStringFilter
    Gui, Add, Button, x+1 hp w35 gUIstringEditFilterErase hwndhBtnFilterRem, &X
    ToolTip2ctrl(hBtnFilterRem, "Remove list filter")

    Gui, Add, DropDownList, xs+15 y+7 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterStringPos% vuserFilterStringPos, Anywhere|Begins with|Ends with
    Gui, Add, DropDownList, x+2 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterWhat% vuserFilterWhat, Full path|Folder path|File name
    Gui, Add, Checkbox, xs+15 y+7 Checked%userFilterStringIsNot% vuserFilterStringIsNot, &Must not contain the given string
    Gui, Add, Checkbox, xs y+20 Checked%excludePreviousDupesFromList% vexcludePreviousDupesFromList, E&xclude the current list of results
    Gui, Add, Text, xs+15 y+30, The data will be collected only for the matching image files.

    Gui, Tab
    Gui, Add, Button, xm+15 y+20 h%thisBtnHeight% w%btnWid% Default gBTNfindDupesNow, &Find duplicates
    If testIsDupesList()
       Gui, Add, Button, x+5 hp wp gBTNautoselectDupes, &Auto-select dupes
    ; Else
    ;    Gui, Add, Button, x+5 hp wp gBtnCollectDupesData, Collect files &data
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNhelpFindDupes, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Find image duplicates: " appTitle)
    SetTimer, updateUIdupesPanel, -300
}

BtnCollectDupesData() {
    If (AnyWindowOpen!=49)
       Return

   Gui, SettingsGUIA: Default
   GuiControlGet, findDupesPrecision
   GuiControlGet, dupesStringFilter
   GuiControlGet, userFilterStringIsNot
   GuiControlGet, userFilterStringPos
   GuiControlGet, userFilterWhat
   GuiControlGet, graylevelCompressor
   GuiControlGet, findInvertedDupes
   GuiControlGet, findFlippedDupes
   GuiControlGet, userpHashMode
   GuiControlGet, hamDistInterpolation
   GuiControlGet, dupesApplyBlur
   GuiControlGet, findDupesPrecision

   scu :=  (findFlippedDupes=1) ? "HpixelzFsmall" : "pixelzFsmall"
   BtnCloseWindow()
   collectSQLFileInfosNow(scu, 0, 0, 2, 0, dupesStringFilter, userFilterStringIsNot, userFilterStringPos, userFilterWhat)
   PopulateImagesIndexStatsInfos("kill")
   openPreviousPanel()
}

updateUIimageHashPreview() {
    Static uiboxSize := 122, dotu := 12
    If (AnyWindowOpen!=49)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, userFindDupePresets
    GuiControlGet, userFindDupesHamDistLvl
    GuiControlGet, userFindDupesFilterHamDist
    GuiControlGet, hamDistLBorderCrop
    GuiControlGet, hamDistRBorderCrop
    GuiControlGet, graylevelCompressor

    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(cornersBMP, imgW, imgH)
    Gdip_FillRectangle(G, pBrushA, 0, 0, imgW, imgH)
    Gdip_FillRectangle(G, pBrushA, 0, 0, imgW, imgH)

    Loop, 8
    {
       If (userFindDupePresets!=7)
          Continue

       pY := A_Index - 1
       Loop, 8
       {
          pX := A_Index - 1
          allLoops++
          If (isInRange(allLoops, hamDistLBorderCrop + 1, 64 - hamDistRBorderCrop) && userFindDupesFilterHamDist>1)
             Gdip_FillRectangle(G, pBrushD, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)
       }
    }

    Gdip_DeleteGraphics(G)
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    UIfindDupesChecksu()
    ; updateUIdupesPanel()
    Return er
}

BTNautoselectDupes() {
   BtnCloseWindow()
   PanelAutoSelectDupes()
}

UIfindDupesChecksu() {
   GuiControl, SettingsGUIA:, userFindDupesSelectAllDummy, 0
}

updateUIdupesPanel() {
   If (AnyWindowOpen!=49)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, userFindDupePresets
   actu := (userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   actu2 := (userFindDupePresets=5 || userFindDupePresets=6) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, SettingsGUIA:, userFindDupesSelectAllDummy, 0
   GuiControl, % actu, userFindDupesSelectAllDummy
   GuiControl, % actu, btnFldr6
   GuiControl, % actu2, findDupesPrecision
   GuiControl, % actu2, editF5
   GuiControl, % actu2, btnFldr
   UIfindDupesCheckboxes(actu)
}

BTNselectAllFindDupesProperties() {
   GuiControlGet, userFindDupesSelectAllDummy
   UIfindDupesCheckboxes("SettingsGUIA:", userFindDupesSelectAllDummy)
}

UIfindDupesCheckboxes(hactu, v:="") {
   If (AnyWindowOpen!=49)
      Return

   Gui, SettingsGUIA: Default
   GuiControl, % hactu, UIcheckimgfile, %v%
   GuiControl, % hactu, UIcheckfcreated, %v%
   GuiControl, % hactu, UIcheckfmodified, %v%
   GuiControl, % hactu, UIcheckfsize, %v%
   GuiControl, % hactu, UIcheckkbfsize, %v%
   GuiControl, % hactu, UIcheckimgpixfmt, %v%
   GuiControl, % hactu, UIcheckimgwidth, %v%
   GuiControl, % hactu, UIcheckimgheight, %v%
   GuiControl, % hactu, UIcheckimgmegapix, %v%
   GuiControl, % hactu, UIcheckimgwhratio, %v%
   GuiControl, % hactu, UIcheckimgframes, %v%
   GuiControl, % hactu, UIcheckimghpeak, %v%
   GuiControl, % hactu, UIcheckimghlow, %v%
   GuiControl, % hactu, UIcheckimghrange, %v%
   GuiControl, % hactu, UIcheckimgavg, %v%
   GuiControl, % hactu, UIcheckimgmedian, %v%
   GuiControl, % hactu, UIcheckimghrms, %v%
   GuiControl, % hactu, UIcheckimghmode, %v%
   GuiControl, % hactu, UIcheckimghminu, %v%
   GuiControl, % hactu, userFindDupesFilterHamDist, %v%

   GuiControlGet, userFindDupePresets
   GuiControlGet, PerformMSDonDupes
   GuiControlGet, userFindDupesFilterHamDist
   If InStr(hactu, "able")
      updateUIimageHashPreview()

   actu := (userFindDupesFilterHamDist>1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, userFindDupesHamDistLvl
   GuiControl, % actu, editF11
   GuiControl, % actu, editF6
   GuiControl, % actu, hamDistLBorderCrop
   GuiControl, % actu, hamDistRBorderCrop
   GuiControl, % actu, editF7
   GuiControl, % actu, txtLine1
   GuiControl, % actu, PerformMSDonDupes
   GuiControl, % actu, BreakDupesGroups
   actu := (userFindDupesFilterHamDist>1 && userFindDupesFilterHamDist!=2 && PerformMSDonDupes!=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, findInvertedDupes
   ; actu := (userFindDupesFilterHamDist>1 && PerformMSDonDupes!=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   ; GuiControl, % actu, findFlippedDupes
   actu := (userFindDupesFilterHamDist>1 && PerformMSDonDupes=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, editFr
   GuiControl, % actu, userFindDupesMSElvl
}

BTNfindDupesNow() {
   If (AnyWindowOpen!=49)
      Return

   columnus := ""
   Gui, SettingsGUIA: Default
   GuiControlGet, findDupesPrecision
   GuiControlGet, dupesStringFilter
   GuiControlGet, userFilterStringIsNot
   GuiControlGet, userFilterStringPos
   GuiControlGet, userFilterWhat
   GuiControlGet, excludePreviousDupesFromList
   GuiControlGet, userFindDupesHamDistLvl
   GuiControlGet, userFindDupesFilterHamDist
   GuiControlGet, hamDistLBorderCrop
   GuiControlGet, hamDistRBorderCrop
   GuiControlGet, graylevelCompressor
   GuiControlGet, findInvertedDupes
   GuiControlGet, findFlippedDupes
   GuiControlGet, userpHashMode
   GuiControlGet, PerformMSDonDupes
   GuiControlGet, userFindDupesMSElvl
   GuiControlGet, dupesApplyBlur
   GuiControlGet, BreakDupesGroups
   If (PerformMSDonDupes=1)
      findFlippedDupes := findInvertedDupes := 0

   If GuiCtrlGet("UIcheckimgfile")
      columnus .= "imgfile,"

   If GuiCtrlGet("UIcheckfcreated")
      columnus .= "fcreated,"

   If GuiCtrlGet("UIcheckfmodified")
      columnus .= "fmodified,"

   If GuiCtrlGet("UIcheckfsize")
   {
      columnus .= "fsize,"
   } Else 
   {
      If GuiCtrlGet("UIcheckkbfsize")
         columnus .= "kbfsize,"
   }

   If GuiCtrlGet("UIcheckimgpixfmt")
      columnus .= "imgpixfmt,"

   If GuiCtrlGet("UIcheckimgwidth")
      columnus .= "imgwidth,"

   If GuiCtrlGet("UIcheckimgheight")
      columnus .= "imgheight,"

   If GuiCtrlGet("UIcheckimgmegapix")
      columnus .= "imgmegapix,"

   If GuiCtrlGet("UIcheckimgwhratio")
      columnus .= "imgwhratio,"

   If GuiCtrlGet("UIcheckimgframes")
      columnus .= "imgframes,"

   If GuiCtrlGet("UIcheckimghpeak")
      columnus .= "imghpeak,"

   If GuiCtrlGet("UIcheckimghlow")
      columnus .= "imghlow,"

   If GuiCtrlGet("UIcheckimghrange")
      columnus .= "imghrange,"

   If GuiCtrlGet("UIcheckimgavg")
      columnus .= "imgavg,"

   If GuiCtrlGet("UIcheckimgmedian")
      columnus .= "imgmedian,"

   If GuiCtrlGet("UIcheckimghrms")
      columnus .= "imghrms,"

   If GuiCtrlGet("UIcheckimghmode")
      columnus .= "imghmode,"

   If GuiCtrlGet("UIcheckimghminu")
      columnus .= "imghminu,"

   GuiControlGet, userFindDupePresets
   If (userFindDupePresets=1)
   {
      userFindDupesFilterHamDist := 2
      hamDistLBorderCrop := hamDistRBorderCrop := 1
      columnus := "imgframes,imgwhratio"
   } Else If (userFindDupePresets=2)
      columnus := "imgavg,imghpeak,imgmedian,imghlow,imghrange,imghmode,imgframes,imgwhratio"
   Else If (userFindDupePresets=3)
      columnus := "fsize,imgmegapix,imgwhratio,imgframes"
   Else If (userFindDupePresets=4)
      columnus := "kbfsize,imgframes,imgmegapix,imgwhratio,imgavg,imghpeak,imgmedian,imghlow"
   Else If (userFindDupePresets=5)
      columnus := "imgfile,imgframes"
   Else If (userFindDupePresets=6)
      columnus := "fsize,imgfile,imgframes"

   ; Gui, SettingsGUIA: Submit, NoHide
   ; ToolTip, % userFindDupePresets "==" columnus , , , 2
   columnus := Trimmer(columnus, ",")
   If (StrLen(columnus)<3 && userFindDupesFilterHamDist>1)
   {
      findDupesPrecision := 1
      columnus := theseCols := "imgwhratio,imgframes"
   } Else If (userFindDupesFilterHamDist>1)
   {
      theseCols := StrReplace(columnus, "dHash")
      theseCols := StrReplace(theseCols, "pHash")
      theseCols := StrReplace(theseCols, "lHash")
      theseCols := StrReplace(theseCols, ",,", ",")
      theseCols := StrReplace(theseCols, ", ,", ",")
      If StrLen(theseCols)<3
         columnus := theseCols := "imgwhratio,imgframes"
   } Else theseCols := columnus

   If StrLen(theseCols)<3
   {
      showTOOLtip("WARNING: Insufficient properties selected by which to identify duplicates.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   MSEgroupiesScores := []
   toBeExcludedIndexes := []
   If (excludePreviousDupesFromList=1)
   {
      Loop, % maxFilesIndex
         toBeExcludedIndexes[resultedFilesList[A_Index, 12]] := 1
   }

   retrieveDupesByProperties(columnus, 0, 0, userFindDupesFilterHamDist)
}

BTNhelpFindDupes() {
   friendly := 
   msgBoxWrapper(appTitle ": HELP", "This panel offers you the possibility to identify duplicate images based on the collected file and image properties, fingerprints and histogram data points.`n`nThe precision factor does not apply for file names, size in bytes, file dates and image width, height, frames and pixel format properties.`n`nThe functionality provided in this panel relies on collected data, please ensure you allow " appTitle " to scan the image files.`n`nFor optimal results activate aspect ratio, precision 2 and dHash threshold 3 in the fingerprints tab.`n`nA low threshold for the hashes means stricter matching. Increase it for looser matches. The same applies for MSD.`n`nBefore hashing, images are normalized to 8x8 and 32x32 sizes, grayscale. Optionally, a 4x4 blurring filter can be applied as well, but it may lead to an increase in false positives.", -1, 0, 0)
}

GuiCtrlGet(varu) {
   GuiControlGet, %varu%
   x := %varu%
   Return x
}

PanelPurgeCachedSQLdata() {
   If (AnyWindowOpen=49)
   {
      reOpenIT := 1
      BtnCloseWindow()
   }

   If (AnyWindowOpen || SLDtypeLoaded!=3)
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(46, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Purge cached data: " appTitle, "Please choose what kind of cached data to erase from the files list database.", "&Purge|C&ancel", 1, "trash", 0, 0, "File details`f`fImage properties`fImage histograms and hashes`fImage hashes`fAll`fAll (selected files only)`fAll (modified files only)", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "purge")
   {
      extraFilter := extractSQLqueryFromFilter()
      If extraFilter
         msgInfos := "`n`nThe purge will occur only for the files matching the current files list filter. To purge all the cached data, deactivate current filter."
 
      msgResultu := msgBoxWrapper(appTitle ": Purge cached data", "Please confirm you want to purge selected cached data from the database.`n`nThis data is used for sorting the files list much faster, identify image duplicates or to generate files list statistics." msgInfos, 4, 0, "question")
      If !InStr(msgResultu, "yes")
         Return

      If (msgResult.list=1)
         corePurgeCachedSQLdata("attributes")
      Else If (msgResult.list=2)
         corePurgeCachedSQLdata("resolution")
      Else If (msgResult.list=3)
         corePurgeCachedSQLdata("histogram")
      Else If (msgResult.list=4)
         corePurgeCachedSQLdata("hashes")
      Else If (msgResult.list=5)
         corePurgeCachedSQLdata("all")
      Else If (msgResult.list=6)
         PurgeCachedDataSelectedFiles()
      Else If (msgResult.list=7)
         PurgeCachedDataModifiedFiles()

      If (SLDtypeLoaded=3)
         PopulateIndexSQLFilesStatsInfos("kill")
      Else
         PopulateIndexFilesStatsInfos("kill")

      PopulateImagesIndexStatsInfos("kill")
   }

   If (reOpenIT=1)
      PanelWrapperFilesStats()
}

corePurgeCachedSQLdata(mode) {
   Static fAtribs := {1:"fsize", 2:"fmodified", 3:"fcreated"}
        , imgResu := {1:"imgdpi", 2:"imgwidth", 3:"imgheight", 4:"imgframes", 5:"imgpixfmt"}
        , hashTypes := {1:"pHash", 2:"dHash", 3:"lHash", 4:"HpHash", 5:"HdHash", 6:"HlHash"}
        , histoStuff := {1:"imgavg", 2:"imgmedian", 3:"imghpeak", 4:"imghlow", 5:"imghminu", 6:"imghmode", 7:"imghrms", 8:"imghrange", 9:"pixelzFsmall", 10:"pixelzFbig", 11:"HpixelzFsmall", 12:"HpixelzFbig"}
        , mantra := "UPDATE images SET "

   setImageLoading()
   extraFilter := extractSQLqueryFromFilter()
   wherePart := extraFilter ? A_Space extraFilter " AND " : " WHERE"
   friendly := extraFilter ? "`nCurrent files list filter:`n" extraFilter : ""
   showTOOLtip("Purging cached data from the database, please wait" friendly)
   thisu := ""
   If (mode="attributes" || mode="all")
   {
      Loop, 3
            thisu .= fAtribs[A_Index] "=NULL,"
      SQLstr .= mantra Trim(thisu, ",") wherePart " fsize IS NOT NULL; "
   }

   thisu := ""
   If (mode="resolution" || mode="all")
   {
      Loop, 5
            thisu .= imgResu[A_Index] "=NULL,"
      SQLstr .= mantra Trim(thisu, ",") wherePart " imgwidth IS NOT NULL; "
   }

   thisu := ""
   If (mode="hashes" || mode="all" || mode="histogram")
   {
      Loop, 6
            thisu .= hashTypes[A_Index] "=NULL,"
      SQLstr .= mantra Trim(thisu, ",") extraFilter "; "
   }

   thisu := ""
   If (mode="histogram" || mode="all")
   {
      Loop, 12
            thisu .= histoStuff[A_Index] "=NULL,"
      SQLstr .= mantra Trim(thisu, ",") wherePart " imgavg IS NOT NULL; "
   }

   addJournalEntry("Query used to purge data:`n" SQLstr)
   If !activeSQLdb.Exec(SQLStr)
   {
      showTOOLtip("Failed to purge the cached data from the database:`n" activeSQLdb.ErrorMsg)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep 300, 100
   } Else
   {
      If (mode="all" || mode="histogram" || mode="resolution")
         activeSQLdb.Exec("UPDATE images SET isDeleted=0 WHERE isDeleted=1;")
      SoundBeep 900, 100
   }

   SetTimer, RemoveTooltip, -350
   SetTimer, ResetImgLoadStatus, -250
}

PurgeCachedDataModifiedFiles() {
   SQLstr := "SELECT imgidu, imgfolder||'\'||imgfile, fsize, fmodified, fcreated FROM images WHERE ifnull(fsize, '')!='' ORDER BY fullPath;"
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      Return -1
   }

   totalFiles := RecordSet.RowCount
   totalImages := getTotalIMGsSQLdb()
   If (totalFiles<1)
   {
      showTOOLtip("No modified files identified. The file details must be collected first.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   setImageLoading()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   doStartLongOpDance()
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   prevSaveData := A_TickCount
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   remFiles := countFiles := failedFiles := countTFiles := 0
   Loop, % totalFiles
   {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[2]
      {
         obj := GetFileAttributesEx(Rowu[2])
         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countTFiles++
         If (!obj.size || obj.size<3)
         {
            deleteSQLdbEntry(Rowu[2], Rowu[1])
            remFiles++
         } Else If (obj.size!=Rowu[3] || SubStr(obj.wTime, 1, 12)!=Rowu[4] || SubStr(obj.cTime, 1, 12)!=Rowu[5])
         {
            r := selectivePurgeCachedSQLdata(Rowu[1])
            If r
               failedFiles++

            countFiles++
         }

         If (A_TickCount - prevSaveData>300100)
         {
            prevSaveData := A_TickCount
            If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            {
               SoundBeep 300, 100
               ErrorMsgS := "ERROR: Failed to commit the changes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
            } Else
               activeSQLdb.Exec("BEGIN TRANSACTION;")
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(countTFiles, totalFiles, startOperation)
            If failedFiles
               etaTime .= "`nFailed to remove cached data for " groupDigits(failedFiles) " files"
            If countFiles
               etaTime .= "`nModified files identified: " groupDigits(countFiles)
            If remFiles
               etaTime .= "`nMissing files: " groupDigits(remFiles)

            etaTime .= "`nFiles data available for: " groupDigits(totalImages) " ( " Round(totalFiles/totalImages, 1) "% )"
            showTOOLtip(ErrorMsgS "Purging cached data for modified image files, please wait" etaTime, 0, 0, A_Index/totalFiles)
            prevMSGdisplay := A_TickCount
         }

         If (A_TickCount - prevSaveData>9000)
            ErrorMsgS := ""
      }
   }

   activeSQLdb.Exec("COMMIT TRANSACTION;")
   etaTime := "`nScanned files: " groupDigits(countTFiles)
   If countFiles
      etaTime .= "`nModified files identified: " groupDigits(countFiles)
   If remFiles
      etaTime .= "`nMissing files: " groupDigits(remFiles)
   If failedFiles
      etaTime .= "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

   If (abandonAll=1)
   {
      showTOOLtip("Operation abandoned: purge cached data for modified files. " etaTime)
      SoundBeep, 300, 100
   } Else
   {
      showTOOLtip("Finished purging cached data for modified image files" etaTime)
      SoundBeep, 900, 100
   }

   RecordSet.Free()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -150
}

PurgeCachedDataSelectedFiles() {
   getSelectedFiles(0, 1)
   If !markedSelectFile
   {
      showTOOLtip("WARNING: No files are currently selected to perform given operation")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   doStartLongOpDance()
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   If markedSelectFile
   {
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countTFiles++
         r := selectivePurgeCachedSQLdata(resultedFilesList[A_Index,12])
         If r
            failedFiles++
         Else
            countFiles++

         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(countTFiles, markedSelectFile, startOperation)
            If failedFiles
               etaTime .= "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

            showTOOLtip("Purging cached data for selected image files, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }
      }
   }

   activeSQLdb.Exec("COMMIT TRANSACTION;")
   CurrentSLD := backCurrentSLD
   If failedFiles
      someErrors := "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

   If (abandonAll=1)
   {
      showTOOLtip("Operation abandoned. Files processed: " groupDigits(countFiles) " out of " groupDigits(markedSelectFile) someErrors)
      SoundBeep, 300, 100
   } Else
   {
      showTOOLtip("Finished purging cached data for the selected files: " groupDigits(markedSelectFile) someErrors)
      SoundBeep, 900, 100
   }
  
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -150
}

markSQLdbEntryDeleted(dbIndex, batchMode:=0) {
   SQLstr := "UPDATE images SET isDeleted=1 WHERE imgidu=" dbIndex ";"
   If !activeSQLdb.Exec(SQLStr)
   {
      If (batchMode=0)
         addJournalEntry("ERROR: " A_ThisFunc "(" dbIndex "). Failed to query or commit changes to the SQL database`n" activeSQLdb.ErrorMsg)
      Return 0
   } Else Return 1
}

selectivePurgeCachedSQLdata(dbIndex, batchMode:=0) {
   SQLstr := "UPDATE images SET dHash=NULL, lHash=NULL, pHash=NULL, HdHash=NULL, HlHash=NULL, HpHash=NULL, pixelzFbig=NULL, pixelzFsmall=NULL, HpixelzFbig=NULL, HpixelzFsmall=NULL, imgavg=NULL, imgmedian=NULL, imghmode=NULL, imghrms=NULL, imghminu=NULL, imghrange=NULL, imghpeak=NULL, imghlow=NULL, imgwidth=NULL, imgheight=NULL, imgframes=NULL, imgpixfmt=NULL, imgdpi=NULL, fsize=NULL, fmodified=NULL, fcreated=NULL, isDeleted=0 WHERE imgidu=" dbIndex ";"
   If !activeSQLdb.Exec(SQLStr)
   {
      If (batchMode=1)
         Return "fail"
      Else
         addJournalEntry("Failed to purge the cached data in the database for given index: " dbIndex "`n" activeSQLdb.ErrorMsg)
   }
}

PanelJpegPerformOperation() {
    Global mainBtnACT

    If !PanelsCheckFileExists()
       Return

    filesElected := getSelectedFiles(0, 1)
    panelMode := (filesElected<2 && thumbsDisplaying!=1) ? 1 : 0
    If !(thisBtnHeight := createSettingsGUI(12, A_ThisFunc, 1, panelMode))
       Return

    If (vpIMGrotation>0)
    {
       FlipImgV := FlipImgH := vpIMGrotation := 0
       showTOOLtip("Image rotation set to 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    } Else If (FlipImgH=1 || FlipImgV=1)
    {
       FlipImgV := FlipImgH := 0
       dummyTimerDelayiedImageDisplay(50)
    } 

    btnWid := 110
    txtWid := slideWid := 280
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 100
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    If (editingSelectionNow!=1 && imgEditPanelOpened!=1)
       jpegDoCrop := 0
    Else
       EllipseSelectMode := 0

    Gui, Add, Text, x15 y15 Section, Please choose a JPEG lossless operation...
    Gui, Add, DropDownList, y+10 Section w%txtWid% AltSubmit Choose%jpegDesiredOperation% vjpegDesiredOperation, None|Flip Horizontally|Flip Vertically|Transpose|Transverse|Rotate 90°|Rotate 180°|Rotate -90° [270°]
    Gui, Add, Checkbox, y+10 Checked%jpegDoCrop% vjpegDoCrop, Crop image(s) to selected area (irreversible)
    If (filesElected>1)
       Gui, Add, Text, y+20, %filesElected% files are selected.
    If (editingSelectionNow!=1 && imgEditPanelOpened!=1)
       GuiControl, Disable, jpegDoCrop

    If (filesElected<2)
    {
       If (thumbsDisplaying!=1)
       {
          Gui, Add, Button, xs y+10 h%thisBtnHeight% w%btnWid% gBTNautoCropRealtime, &Auto-crop selection
          Gui, Add, Button, x+5 hp w%btnWid% gPanelImgAutoCrop, &Configure auto-crop
       }
       Gui, Add, Button, xs+0 y+25 h%thisBtnHeight% w35 gPreviousPicture +hwndhBtnPrevImg, <<
       Gui, Add, Button, x+5 hp wp gNextPicture +hwndhBtnNextImg, >>
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnPerformJpegOp vmainBtnACT, &Perform operation
       ToolTip2ctrl(hBtnNextImg, "Next image")
       ToolTip2ctrl(hBtnPrevImg, "Previous image")
    } Else Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gBtnPerformJpegOp, &Perform operation
 
    Gui, Add, Button, x+5 hp w80 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "JPEG lossless operations: " appTitle)
}

BtnPerformJpegOp(dummy:=0) {
    Static lastInvoked := 1
    If (dummy!="extern")
    {
       Gui, SettingsGUIA: Default
       GuiControlGet, jpegDesiredOperation
       GuiControlGet, jpegDoCrop
       GuiControlGet, mainBtnACT
    }

    If (A_TickCount - lastInvoked < 150) || (jpegDesiredOperation=1 && jpegDoCrop=0)
    {
       showTOOLtip("WARNING: No operations selected to perform")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    initFIMGmodule()
    If !wasInitFIMlib
    {
       msgBoxWrapper(appTitle ": ERROR", "Unable to initialize the FreeImage library module.`n`nThis functionality is currently unavailable.", 0, 0, "error")
       Return
    }

    lastInvoked := A_TickCount
    ForceRefreshNowThumbsList()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       batchJpegLLoperations()
       Return
    } Else If (currIMGdetails.HasAlpha!=1)
    {
       destroyGDIfileCache()
       r := coreJpegLossLessAction(imgPath, jpegDesiredOperation, jpegDoCrop)
    }

    If (dummy!="extern")
    {
       GuiControl, SettingsGUIA: Disable, mainBtnACT
       SetTimer, reactivateMainBtnACT, -800
    }

    If r
    {
       resultedFilesList[currentFileIndex, 4] := 1
       FlipImgV := FlipImgH := vpIMGrotation := 0
       If (SLDtypeLoaded=3)
          selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])
       showTOOLtip("JPEG operation completed succesfully")
       RefreshImageFile()
    } Else
    {
       SoundBeep, 300, 100
       If (dummy!="extern")
          msgBoxWrapper(appTitle ": ERROR", "The JPEG operation has failed. The file might not be a JPEG as the file extension suggests.", 0, 0, "error")
       Else
          showTOOLtip("ERROR: The JPEG operation has failed. The file might not be a JPEG as the file extension suggests.")
    }

    lastInvoked := A_TickCount
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

reactivatemainBtnACT() {
    If isVarEqualTo(AnyWindowOpen, 12, 18, 17)
    {
       If (imageLoading=1)
          SetTimer, reactivatemainBtnACT, -600
       Else
          GuiControl, SettingsGUIA: Enable, mainBtnACT
    }
}

batchJpegLLoperations() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && jpegDoCrop=1) || (filesElected>150)
   {
      msgInfos := (jpegDoCrop=1) ? "`n`nThe crop operation IS irreversible!" : ""
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to perform the JPEG transformations on the selected files? There are currently " filesElected " selected files. " msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
 
   BtnCloseWindow()
   Sleep, 25
   showTOOLtip("Performing JPEG lossless operations on " filesElected " files, please wait")
   prevMSGdisplay := A_TickCount
   failedFiles := countFilez := countTFilez := 0

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>3) ? 1 : 0
   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresJpegLL(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("File format conversion: failed to initialize multi-threaded processing")

   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   CurrentSLD := ""
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      If (InStr(file2rem, "||") || !file2rem)
         Continue
 
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFor " groupDigits(failedFiles) " files, the operations failed"
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip("Performing JPEG lossless operations, please wait" etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      If !RegExMatch(file2rem, "i)(.\.(jpeg|jpg|jpe))$")
      {
         skippedFiles++
         Continue
      }

      r := coreJpegLossLessAction(file2rem, jpegDesiredOperation, jpegDoCrop)
      If r
      {
         resultedFilesList[thisFileIndex, 4] := 1
         countFilez++
      } Else failedFiles++
   }

   CurrentSLD := backCurrentSLD
   If (failedFiles>0)
      someErrors := "`nFor " groupDigits(failedFiles) " files, the operations failed"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip(countFilez " out of " groupDigits(countTFilez) " selected JPEG files were processed" someErrors)

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return
}

coreJpegLossLessAction(imgPath, jpegOperation, mustCrop) {
    FileGetTime, originalMtime, % imgPath, M
    FileGetTime, originalCtime, % imgPath, C
    FileSetAttrib, -R, %imgPath%
    Sleep, 1
    changeMcursor()
    If (mustCrop=1 && editingSelectionNow=1) || (mustCrop=1 && hasInitSpecialMode=1)
    {
       r1 := GetImgFileDimension(imgPath, imgW, imgH)
       If (relativeImgSelCoords=1)
          calcRelativeSelCoords("--", imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       x1 := Round(X1), y1 := Round(Y1)
       x2 := Round(X2), y2 := Round(Y2)
       changeMcursor()
       r := FreeImage_JPEGTransformCombined(imgPath, imgPath, jpegOperation - 1, X1, Y1, X2, Y2)
    } Else
    {
       Sleep, -1
       r := FreeImage_JPEGTransform(imgPath, imgPath, jpegOperation - 1)
    }

    If originalMtime
    {
       Sleep, 0
       FileSetTime, % originalMtime, % imgPath, M
       FileSetTime, % originalCtime, % imgPath, C
    }
    Return r
}

toggleImgEditPanelWindow(dummy:="") {
   Static Width := 0, Height := 0, lastInvoked := A_TickCount
   ot := TabsPerWindow[AnyWindowOpen]
   If (AnyWindowOpen!=10 && imgEditPanelOpened!=1 && dummy!="forced") || (A_TickCount - lastInvoked<350)
      Return

   WinGet, winStateu, MinMax, ahk_id %hSetWinGui%
   ; WinGetPos, , , nWidth, nHeight, ahk_id %hSetWinGui%
   thisHeight := imgHUDbaseUnit//4 + 2
   thisWidth := imgHUDbaseUnit//2 + 2
   ; If (Width<nWidth-5) || (Height<nHeigh-5)
   ;    panelWinCollapsed := 1
   If (winStateu=-1)
   {
      WinRestore, ahk_id %hSetWinGui%
   } Else If (panelWinCollapsed=0)
   {
      Gui, SettingsGUIA: Show, NoActivate w%thisWidth% h%thisHeight%
      Gui, SettingsGUIA: -SysMenu
      WinActivate, ahk_id %PVhwnd%
      WinSet, Transparent, 190, ahk_id %hSetWinGui%
      WinSet, Style, -0xC00000, ahk_id %hSetWinGui% ; WS_CAPTION
      ; WinGetPos, , , Width, Height, ahk_id %hSetWinGui%
      ; WinSet, Disable,, ahk_id %hSetWinGui%
      panelWinCollapsed := 1
   } Else 
   {
      endCaptureCloneBrush()
      WinSet, Transparent, Off, ahk_id %hSetWinGui%
      WinSet, Style, +0xC00000, ahk_id %hSetWinGui% ; WS_CAPTION
      Gui, SettingsGUIA: Show, AutoSize
      Gui, SettingsGUIA: +SysMenu
      ; WinSet, Enable,, ahk_id %hSetWinGui%
      panelWinCollapsed := 0
      If (ot>1)
      {
         fn := Func("selectGivenPanelTab").Bind(ot)
         SetTimer, % fn, -100
      }

      UItriggerBrushUpdate("noPreview", 5)
   }

   lastInvoked := A_TickCount
   interfaceThread.ahkassign("panelWinCollapsed", panelWinCollapsed)
}

selectGivenPanelTab(ot) {
   CurrentPanelTab := ot
   GuiControl, SettingsGUIA: Choose, CurrentPanelTab, % CurrentPanelTab
   TabsPerWindow[AnyWindowOpen] := ot
   UItriggerBrushUpdate("noPreview", 5)
}

PanelColorsAdjusterImage() {
   coreColorsAdjusterWindow("img")
}

PanelColorsAdjusterWindow() {
   coreColorsAdjusterWindow("vp")
}

coreColorsAdjusterWindow(modus:=0) {
    Global sliderBright, sliderContrst, sliderSatu, realTimePreview, infolummyAdjust, uiIMGresizingMode
         , infoBright, infoContrst, infoSatu, BtnLumPlus, BtnLumMin, BtnFlipH, infoZatAdjust, UIvpImgAlignCenter
         , BtnGammPlus, BtnGammMin, BtnSatPlus, BtnSatMin, ResizeModeDL, BtnFlipV, infohueAdjust
         , infoRGBchnls, RGBcbList := "-3.0|-2.0|-1.5|-1.0|-0.9|-0.8|-0.7|-0.6|-0.5|-0.4|-0.3|-0.2|-0.1|0.0|0.1|0.2|0.3|0.4|0.5|0.6|0.7|0.8|0.9|1.0|1.5|2.0|3.0"
         , infoRealGammos, infoThreshold, UIimgThreshold, UIrealGammos, infoImgRotation, uiForceNoColorMatrix

    openingPanelNow := 1
    idu := (modus="img") ? 74 : 10
    thisFuncu := (idu=10) ? A_ThisFunc : "PanelColorsAdjusterImage"
    If !(thisBtnHeight := createSettingsGUI(idu, thisFuncu, 1, 1))
       Return

    wasVPfxBefore := (imgFxMode>1) ? 1 : 0
    If (idu=74 && editingSelectionNow!=1)
       ToggleEditImgSelection()

    setImageLoading()
    showTOOLtip("Opening colors adjustments panel, please wait")
    ForceNoColorMatrix := 0
    uiForceNoColorMatrix := 1
    If !usrColorDepth
       usrColorDepth := 1

    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 180
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       slide2Wid := slide2Wid + 65
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }
    ml := (PrefsLargeFonts=1) ? 85 : 60
    zml := ml//2

    UIimgThreshold := imgThreshold*100
    UIrealGammos := (realGammos<=1.001) ? realGammos*200 : ((realGammos+5)*100)/3
    UIvpImgAlignCenter := (imageAligned=5) ? 1 : 0
    moru := (idu=10) ? "|Other options" : ""
    Gui, Add, Tab3, gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Color matrix|More adjustments%moru%
    Gui, Tab, 1 ; general
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gUpdateUIadjustVPcolors AltSubmit Choose%imgFxMode% vimgFxMode, Original image colors|Personalized colors|Auto-adjusted colors|Grayscale|Red channel|Green channel|Blue channel|Alpha channel|Inverted colors|Sepia
    Gui, Add, DropDownList, xs y+5 w%txtWid% gUpdateUIadjustVPcolors AltSubmit Choose%autoAdjustMode% vAutoAdjustMode, Adaptive mixed mode|Increase brightness|Increase contrast
    Gui, Add, ComboBox, x+1 w%ml% gUpdateUIadjustVPcolors vusrAdaptiveThreshold, -2000|-100|-50|-2|1|2|50|1000|2000|%usrAdaptiveThreshold%||
    Gui, Add, Checkbox, xs y+2 w%txtWid% gUpdateUIadjustVPcolors Checked%doSatAdjusts% vdoSatAdjusts, Auto-adjust image saturation level
    If (idu=10)
       Gui, Add, Checkbox, x+5 w%ml% gUpdateUIadjustVPcolors Checked%bwDithering% vbwDithering, B/W
    Gui, Add, Text, xs y+8 w%txtWid% gBtnResetBrightness vinfoBright +TabStop, Brightness: ----
    Gui, Add, Slider, Center y+5 AltSubmit NoTicks w%slideWid% gUpdateUIadjustVPcolors vsliderBright Range-100-100, 1
    Gui, Add, Button, x+1 hp w%zml% gBtnChangeLumMin vBtnLumMin, -
    Gui, Add, Button, x+1 hp wp gBtnChangeLumPlus vBtnLumPlus, +
    Gui, Add, Text, xs y+2 w%txtWid% gBtnResetContrast vinfoContrst +TabStop, Contrast: ----
    Gui, Add, Slider, Center y+1 AltSubmit NoTicks w%slideWid% gUpdateUIadjustVPcolors vsliderContrst Range-100-100, 1
    Gui, Add, Button, x+1 hp w%zml% gBtnChangeGammPlus vBtnGammPlus, -
    Gui, Add, Button, x+1 hp wp gBtnChangeGammMin vBtnGammMin, +
    Gui, Add, Text, xs y+2 w%txtWid% gBtnResetSaturation vinfoSatu +TabStop, Saturation: ----
    Gui, Add, Slider, Center y+5 AltSubmit NoTicks w%slideWid% gUpdateUIadjustVPcolors vsliderSatu Range-100-100, 1
    Gui, Add, Button, x+1 hp w%zml% gBtnChangeSatMin vBtnSatMin, -
    Gui, Add, Button, x+1 hp wp gBtnChangeSatPlus vBtnSatPlus, +
    Gui, Add, Text, xs y+2 w%slide2Wid% gBtnResetRealGamma vinfoRealGammos +TabStop, Gamma: ----
    Gui, Add, Text, x+5 w%slide2Wid% gBtnResetThreshold vinfoThreshold +TabStop, Threshold: ----
    Gui, Add, Slider, Center xs y+2 AltSubmit NoTicks w%slide2Wid% gUpdateUIadjustVPcolors vUIrealGammos Range1-500, % UIrealGammos
    Gui, Add, Slider, Center x+5 AltSubmit NoTicks w%slide2Wid% gUpdateUIadjustVPcolors vUIimgThreshold Range0-100, % UIimgThreshold
    ; Gui, Add, Checkbox, xs y+15 gUpdateUIadjustVPcolors Checked%realTimePreview% vrealTimePreview, Update image in real time
    tml := zml + 15
    Gui, Add, Text, xs y+8 gBtnResetCHNdec vinfoRGBchnls +TabStop, RGBA channels balance:
    Gui, Add, ComboBox, x+5 w%tml% gUpdateUIadjustVPcolors vchnRdecalage, %RGBcbList%|%chnRdecalage%||
    Gui, Add, ComboBox, x+5 wp gUpdateUIadjustVPcolors vchnGdecalage, %RGBcbList%|%chnGdecalage%||
    Gui, Add, ComboBox, x+5 wp gUpdateUIadjustVPcolors vchnBdecalage, %RGBcbList%|%chnBdecalage%||
    Gui, Add, ComboBox, x+5 wp gUpdateUIadjustVPcolors vIntensityAlphaChannel, 1|2|3|4|5|6|7|8|9|10|15|20|25|30|%IntensityAlphaChannel%||

    slide3wid := slide2wid - 42
    Gui, Tab, 2 ; more
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gUpdateUIadjustVPcolors AltSubmit Choose%specialColorFXmode% vspecialColorFXmode, None|Brightness / Contrast|Hue / Saturation / Lightness|Levels adjust|Color tint|Colors balance|Color curve per channel
    Gui, Add, DropDownList, xs y+2 w%slide3Wid% gUpdateUIadjustVPcolors AltSubmit Choose%uiColorCurveFXmode% vuiColorCurveFXmode, Brightness (density)|Contrast|Highlights|Shadows|Mid-tones|White saturation|Black saturation
    Gui, Add, DropDownList, x+2 wp gUpdateUIadjustVPcolors AltSubmit Choose%uiColorCurveFXchannel% vuiColorCurveFXchannel, Red|Green|Blue|Apply on all channels

    Gui, Add, Text, xs y+10 w%slideWid% gBtnResetHue vinfohueAdjust +TabStop, Hue: ----
    Gui, Add, Slider, Center xs y+2 wp AltSubmit NoTicks gUpdateUIadjustVPcolors vhueAdjust Range-300-300, % hueAdjust
    Gui, Add, Text, xs y+10 wp gBtnResetVibrance vinfoZatAdjust +TabStop, Vibrance: ----
    Gui, Add, Slider, Center xs y+2 wp AltSubmit NoTicks gUpdateUIadjustVPcolors vzatAdjust Range-300-300, % zatAdjust
    Gui, Add, Text, xs y+10 wp gBtnResetLummy vinfolummyAdjust +TabStop, Lightness: ----
    Gui, Add, Slider, Center xs y+2 wp AltSubmit NoTicks  gUpdateUIadjustVPcolors vlummyAdjust Range-300-300, % lummyAdjust

    uiIMGresizingMode := (customZoomAdaptMode>0 && IMGresizingMode=4) ? 5 + customZoomAdaptMode : IMGresizingMode
    If (idu=10)
    {
       Gui, Tab, 3 ; others
       Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gUpdateUIadjustVPcolors AltSubmit Choose%uiIMGresizingMode% vuiIMGresizingMode, Adapt all images to fit window|Adapt only large images into view|Original resolution (100`%)|Custom zoom level|Stretched to window dimensions|Adapt to window width|Adapt to window height
       Gui, Add, Checkbox, x+5 gUpdateUIadjustVPcolors Checked%UIvpImgAlignCenter% vUIvpImgAlignCenter, Centered
       Gui, Add, DropDownList, xs y+5 w%txtWid% gUpdateUIadjustVPcolors AltSubmit Choose%usrColorDepth% vusrColorDepth, Simulate color depth|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]
       Gui, Add, Checkbox, x+5 hp gUpdateUIadjustVPcolors Checked%ColorDepthDithering% vColorDepthDithering, Dithering
       Gui, Add, Text, xs y+10 hp +0x200, Flip viewport:
       Gui, Add, Checkbox, x+10 +0x1000 hp gUpdateUIadjustVPcolors Checked%FlipImgV% vFlipImgV, vertically
       Gui, Add, Checkbox, x+5 +0x1000 hp gUpdateUIadjustVPcolors Checked%FlipImgH% vFlipImgH, horizontally
       Gui, Add, Slider, Center xs y+10 NoTicks ToolTip w%slide2Wid% gUpdateUIadjustVPcolors vvpIMGrotation Range0-360, % Round(vpIMGrotation)
       Gui, Add, Text, x+10 hp +0x200 w%slide2Wid% gBtnResetRotation vinfoImgRotation +TabStop, Rotation: ----
       Gui, Add, Text, xs y+10, Display histogram:
       Gui, Add, DropDownList, x+10 w%btnWid% gUpdateUIadjustVPcolors AltSubmit Choose%showHistogram% vshowHistogram, None|Luminance|Red|Green|Blue|All mixed
       Gui, Add, DropDownList, x+6 w%btnWid% gUpdateUIadjustVPcolors AltSubmit Choose%histogramMode% vhistogramMode, Lows|Balanced|Peaks
       Gui, Add, Checkbox, xs y+10 gUpdateUIadjustVPcolors Checked%userimgQuality% vuserimgQuality, High quality image resampling
       Gui, Add, Checkbox, xs y+10 gUpdateUIadjustVPcolors Checked%usrTextureBGR% vusrTextureBGR, Auto-generated ambiental textured viewport background
       Gui, Add, Checkbox, xs y+10 gToggleAutoResetImageView Checked%resetImageViewOnChange% vresetImageViewOnChange, Reset all image adjustments on image file change
       ; Gui, Add, Checkbox, xs y+10 gUpdateUIadjustVPcolors Checked%showHistogram% vshowHistogram, Display the image luminance histogram
       Gui, Add, Text, xs y+10, TIP: right click on the viewport for more options.
    } Else
    {
       thisOpacity := Round((EraseAreaOpacity / 255) * 100)
       Gui, Add, Text, xs y+1 w%slideWid% hp +0x200 vinfoEraseOpacity gBTNresetEraseOpacity +TabStop, Opacity: %thisOpacity%`%
       Gui, Add, Slider, Center xp y+5 wp NoTicks AltSubmit gUpdateUIadjustVPcolors vEraseAreaOpacity Range5-255, % EraseAreaOpacity

       sml := (PrefsLargeFonts=1) ? 20 : 5
       Gui, Add, DropDownList, xs y+5 w%slide3Wid% gUpdateUIadjustVPcolors AltSubmit Choose%DesaturateAreaLevels% vDesaturateAreaLevels, Simulate color depth|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]
       Gui, Add, Checkbox, x+%sml% hp gUpdateUIadjustVPcolors Checked%DesaturateAreaDither% vDesaturateAreaDither, Dithering
       Gui, Add, Checkbox, xs y+5 hp Checked%EraseAreaInvert% vEraseAreaInvert gUpdateUIadjustVPcolors, &Invert selection area
       Gui, Add, Checkbox, x+15 Checked%EraseAreaUseAlpha% vEraseAreaUseAlpha gUpdateUIadjustVPcolors, Apply alpha mas&k
    }

    Gui, Tab
    jk := (PrefsLargeFonts=1) ? 82 : 50
    If (idu=10)
    {
       Gui, Add, Button, xs-10 y+15 h%thisBtnHeight% w35 gBtnPrevImg +hwndhBtnPrevImg, <<
       Gui, Add, Button, x+5 hp wp gBtnNextImg +hwndhBtnNextImg, >>
       Gui, Add, Button, x+5 hp wp hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
       Gui, Add, Button, x+5 hp w%jk% Default gBtnCloseWindow, &Close
       ToolTip2ctrl(hBtnNextImg, "Next image")
       ToolTip2ctrl(hBtnPrevImg, "Previous image")
    } Else
    {
       Gui, Add, Button, xs-10 y+15 h%thisBtnHeight% w35 hwndhBtnCollapse gtoggleImgEditPanelWindow, ▲
       Gui, Add, Button, x+5 hp w%jk% gapplyIMGeditFunction Default, &Apply
       Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Close
       dummyTimerDelayiedImageDisplay(150)
    }

    ToolTip2ctrl(hBtnCollapse, "Collapse panel [F11]")
    ; Gui, Add, Button, x+5 hp w%btnWid% gCopyImage2clip, &Copy to clipboard
    ; Gui, Add, Button, x+5 hp wp gBtnSaveIMGadjustPanel, &Save or copy
    Gui, Add, Button, x+5 hp wp+15 gBtnResetImageView, &Reset all
    Gui, Add, Checkbox, x+5 hp gBtnToggleNoColorsFX Checked%uiForceNoColorMatrix% vuiForceNoColorMatrix, Live preview
    If (idu=74)
       Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»
    ; Gui, Add, Button, x+5 hp w80 Default gBtnCloseWindow, C&lose
    titlu := (idu=10) ? "Adjust viewport image view: " : "Adjust image colors: "
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, titlu appTitle, winPos)
    Sleep, 1
    updatePanelColorsInfo()
    updatePanelColorSliderz()
    SetTimer, resetOpeningPanel, -300
    SetTimer, RemoveTooltip, -100
    SetTimer, ResetImgLoadStatus, -50
}

ToolTip2ctrl(hwnd, msg) {
    Return AddTooltip2Ctrl(hwnd, msg,, uiUseDarkMode, PrefsLargeFonts)
}

BtnToggleNoColorsFX() {
   ; Gui, SettingsGUIA: Default
   ; SoundBeep 
   ForceNoColorMatrix := !ForceNoColorMatrix
   ; GuiControlGet, uiForceNoColorMatrix
   uiForceNoColorMatrix := !ForceNoColorMatrix
   GuiControl, SettingsGUIA:, uiForceNoColorMatrix, % uiForceNoColorMatrix
   dummyTimerDelayiedImageDisplay(50)
}

resetOpeningPanel() {
    openingPanelNow := 0
}

BtnResetBrightness() {
  lumosAdjust := lumosGrayAdjust := 1
  GuiControl, SettingsGUIA:, infoBright, Brightness: 1.000
  GuiControl, SettingsGUIA:, sliderBright, 1
  INIaction(1, "lumosAdjust", "General")
  INIaction(1, "lumosGrayAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetContrast() {
  GammosAdjust := GammosGrayAdjust := 0
  GuiControl, SettingsGUIA:, infoContrst, Contrast: 0.000
  GuiControl, SettingsGUIA:, sliderContrst, 0
  INIaction(1, "GammosAdjust", "General")
  INIaction(1, "GammosGrayAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetSaturation() {
  satAdjust := 1
  GuiControl, SettingsGUIA:, infoSatu, Saturation: 1.000
  GuiControl, SettingsGUIA:, sliderSatu, 0
  INIaction(1, "satAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetVibrance() {
  zatAdjust := 0
  GuiControl, SettingsGUIA:, infoZatAdjust, 0
  GuiControl, SettingsGUIA:, zatAdjust, 0
  INIaction(1, "zatAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetLummy() {
  lummyAdjust := 0
  GuiControl, SettingsGUIA:, infoLummyAdjust, 0
  GuiControl, SettingsGUIA:, lummyAdjust, 0
  INIaction(1, "lummyAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetHue() {
  thisValue := (specialColorFXmode=4) ? 100 : 0
  hueAdjust := thisValue
  GuiControl, SettingsGUIA:, infohueAdjust, % thisValue
  GuiControl, SettingsGUIA:, hueAdjust, % thisValue
  INIaction(1, "hueAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetRealGamma() {
  realGammos := 1
  GuiControl, SettingsGUIA:, infoRealGammos, Gamma: 1.000 
  GuiControl, SettingsGUIA:, UIrealGammos, 200
  INIaction(1, "realGammos", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetThreshold() {
  imgThreshold := 0
  GuiControl, SettingsGUIA:, infoThreshold, Threshold: 0
  GuiControl, SettingsGUIA:, UIimgThreshold, 0
  INIaction(1, "imgThreshold", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetCHNdec() {
  chnRdecalage := chnGdecalage := chnBdecalage := 0.0
  IntensityAlphaChannel := 1
  GuiControl, SettingsGUIA: Choose, chnRdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnGdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnBdecalage, 14
  GuiControl, SettingsGUIA: Choose, IntensityAlphaChannel, 1
  INIaction(1, "chnRdecalage", "General")
  INIaction(1, "chnGdecalage", "General")
  INIaction(1, "chnBdecalage", "General")
  INIaction(1, "IntensityAlphaChannel", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetRotation() {
  If (vpIMGrotation=0)
     Return

  vpIMGrotation := 0
  GuiControl, SettingsGUIA:, vpIMGrotation, 0
  GuiControl, SettingsGUIA:, infoImgRotation, Image rotation: 0°
  GuiControl, SettingsGUIA: Enable, usrTextureBGR
  INIaction(1, "vpIMGrotation", "General")
  RefreshImageFile()
}

BtnSaveIMGadjustPanel() {
   ForceNoColorMatrix := 0
   CloseWindow()
   dummyTimerDelayiedImageDisplay(50)
   PanelSaveImg()
}

BtnNextImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  NextPicture()
  If (imgFxMode=3 && AnyWindowOpen=10)
  {
     updatePanelColorsInfo()
     updatePanelColorSliderz()
  }
}

BtnPrevImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  PreviousPicture()
  If (imgFxMode=3 && AnyWindowOpen=10)
  {
     updatePanelColorsInfo()
     updatePanelColorSliderz()
  }
}

updatePanelColorSliderz() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 100)
   {
      SetTimer, % A_ThisFunc, -110
      Return
   }

   If (AnyWindowOpen!=10 && AnyWindowOpen!=74)
      Return

   ; GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   Gui, SettingsGUIA: Default
   If isInRange(imgFxMode, 1, 3)
   {
      infoSliderBright := (lumosAdjust>1) ? Floor((lumosAdjust - 1)/14*100) : - Floor((1 - lumosAdjust)*100)
      infoSliderContrst := (GammosAdjust<0) ? Floor(Abs(GammosAdjust)/15*100) : - Floor((Abs(GammosAdjust))*100)
      infoSliderSatu := (satAdjust>1) ? Floor((satAdjust - 1)/2*100) : - Floor((1 - satAdjust)*100)
      UIrealGammos := (realGammos<=1.001) ? realGammos*200 : ((realGammos+5)*100)/3
      GuiControl, SettingsGUIA:, sliderSatu, % infoSliderSatu 
      GuiControl, SettingsGUIA:, sliderBright, % infoSliderBright
      GuiControl, SettingsGUIA:, sliderContrst, % infoSliderContrst
      GuiControl, SettingsGUIA:, UIrealGammos, % UIrealGammos
   } Else If (imgFxMode=4)
   {
      infoSliderBright := (lumosGrayAdjust>1) ? Floor((lumosGrayAdjust - 1)/14*100) :  - Floor((1 - lumosGrayAdjust)*100)
      infoSliderContrst := (GammosGrayAdjust<0) ? Floor(Abs(GammosGrayAdjust)/15*100) : - Floor((Abs(GammosGrayAdjust))*100)
      GuiControl, SettingsGUIA:, sliderBright, % infoSliderBright
      GuiControl, SettingsGUIA:, sliderContrst, % infoSliderContrst
      GuiControl, SettingsGUIA:, sliderSatu, 0
   }

   If (AnyWindowOpen=10)
      GuiControl, SettingsGUIA:, UIvpImgAlignCenter, % (imageAligned=5) ? 1 : 0
   lastInvoked := A_TickCount
}

updatePanelColorsInfo() {
   Static colorzFXinfoz := 0, colorzFXminz := 0, colorzFXmaxz := 0, lastInvoked := 1
   If (AnyWindowOpen!=10 && AnyWindowOpen!=74)
      Return

   If (A_TickCount - lastInvoked < 100)
   {
      SetTimer, updatePanelColorsInfo, -110
      Return
   }

   Gui, SettingsGUIA: Default
   If !IsObject(colorzFXinfoz)
   {
      colorzFXinfoz := []
      colorzFXinfoz[1] := ["-", "-", "-"]
      colorzFXinfoz[2] := ["Brightness", "Contrast", "-"]
      colorzFXinfoz[3] := ["Hue", "Saturation", "Lightness"]
      colorzFXinfoz[4] := ["Highlights", "Midtones", "Shadows"]
      colorzFXinfoz[5] := ["Hue", "Amount", "-"]
      colorzFXinfoz[6] := ["Cyan / Red", "Magenta / Green", "Yellow / Blue"]
      colorzFXinfoz[7] := ["-", "-", "Amount"]
      colorzFXminz := []
      colorzFXminz[1] := [-300, -300, -300]
      colorzFXminz[2] := [-255, -100, -300]
      colorzFXminz[3] := [-180, -100, -100]
      colorzFXminz[4] := [0, -100, 0]
      colorzFXminz[5] := [-180, 0, -300]
      colorzFXminz[6] := [-100, -100, -100]
      colorzFXminz[7] := [-300, -300, -100]
      colorzFXmaxz := []
      colorzFXmaxz[1] := [300, 300, 300]
      colorzFXmaxz[2] := [255, 100, 300]
      colorzFXmaxz[3] := [180, 100, 100]
      colorzFXmaxz[4] := [100, 100, 100]
      colorzFXmaxz[5] := [180, 100, 300]
      colorzFXmaxz[6] := [100, 100, 100]
      colorzFXmaxz[7] := [300, 300, 100]
   }

   GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   GuiControlGet, imgFxMode, SettingsGUIA:, imgFxMode
   GuiControlGet, bwDithering, SettingsGUIA:, bwDithering
   If (AnyWindowOpen=10)
      GuiControlGet, uiIMGresizingMode, SettingsGUIA:, uiIMGresizingMode

   thisMinA := colorzFXminz[specialColorFXmode, 1]
   thisMinB := colorzFXminz[specialColorFXmode, 2]
   thisMinC := colorzFXminz[specialColorFXmode, 3]
   thisMaxA := colorzFXmaxz[specialColorFXmode, 1]
   thisMaxB := colorzFXmaxz[specialColorFXmode, 2]
   thisMaxC := colorzFXmaxz[specialColorFXmode, 3]
   If (specialColorFXmode=7 && uiColorCurveFXmode=1)
   {
      thisMaxC := 255
      thisMinC := -255
   } Else If (specialColorFXmode=7 && uiColorCurveFXmode>=6)
   {
      thisMaxC := 255
      thisMinC := 0
   }

   GuiControl, SettingsGUIA: +Range%thisMinA%-%thisMaxA%, hueAdjust
   GuiControl, SettingsGUIA: +Range%thisMinB%-%thisMaxB%, zatAdjust
   GuiControl, SettingsGUIA: +Range%thisMinC%-%thisMaxC%, lummyAdjust

   infolumosAdjust := (imgFxMode=4) ? Round(lumosGrayAdjust, 3) : Round(lumosAdjust, 3)
   infoGammosAdjust := (imgFxMode=4) ? Round(GammosGrayAdjust, 3) : Round(GammosAdjust, 3)
   infoSatAdjust := Round(satAdjust, 3)
   GuiControl, SettingsGUIA:, infoBright, % "Brightness: " infolumosAdjust
   GuiControl, SettingsGUIA:, infoContrst, % "Contrast: " infoGammosAdjust
   GuiControl, SettingsGUIA:, infoSatu, % "Saturation: " infoSatAdjust
   GuiControl, SettingsGUIA:, infoRealGammos, % "Gamma: " realGammos
   GuiControl, SettingsGUIA:, infoThreshold, % "Threshold: " imgThreshold

   GuiControl, SettingsGUIA:, infohueAdjust, % colorzFXinfoz[specialColorFXmode, 1] ": " hueAdjust
   GuiControl, SettingsGUIA:, infoZatAdjust, % colorzFXinfoz[specialColorFXmode, 2] ": " zatAdjust
   GuiControl, SettingsGUIA:, infoLummyAdjust, % colorzFXinfoz[specialColorFXmode, 3] ": " lummyAdjust

   If (AnyWindowOpen=10)
   {
      GuiControl, SettingsGUIA:, infoImgRotation, % "Image rotation: " vpIMGrotation "° "
      act := isVarEqualTo(vpIMGrotation, 0, 90, 180, 270) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % act, usrTextureBGR

      act :=  (IMGresizingMode=5) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % act, usrTextureBGR
      GuiControl, % act, UIvpImgAlignCenter
   }

   act := (usrColorDepth>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, ColorDepthDithering

   act := (IMGresizingMode=4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   act := isVarEqualTo(imgFxMode, 2, 9, 10) || (imgFxMode=4 && o_bwDithering=0) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, infoRealGammos
   GuiControl, % act, UIrealGammos

   act := (imgFxMode=2) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   If (imgFxMode=4 && o_bwDithering=0)
   {
      GuiControl, SettingsGUIA: Enable, infoBright
      GuiControl, SettingsGUIA: Enable, infoContrst
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Enable, sliderBright
      GuiControl, SettingsGUIA: Enable, sliderContrst
      GuiControl, SettingsGUIA: Disable, sliderSatu
      GuiControl, SettingsGUIA: Enable, BtnLumPlus
      GuiControl, SettingsGUIA: Enable, BtnLumMin
      GuiControl, SettingsGUIA: Enable, BtnGammPlus
      GuiControl, SettingsGUIA: Enable, BtnGammMin
      GuiControl, SettingsGUIA: Disable, BtnSatPlus
      GuiControl, SettingsGUIA: Disable, BtnSatMin
   } Else
   {
      GuiControl, % act, infoBright
      GuiControl, % act, infoContrst
      GuiControl, % act, infoSatu
      GuiControl, % act, infoSatu
      GuiControl, % act, BtnLumPlus
      GuiControl, % act, BtnLumMin
      GuiControl, % act, BtnGammPlus
      GuiControl, % act, BtnGammMin
      GuiControl, % act, BtnSatPlus
      GuiControl, % act, BtnSatMin
      GuiControl, % act, sliderSatu
      GuiControl, % act, sliderBright
      GuiControl, % act, sliderContrst
   }

   act := (imgFxMode=4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, bwDithering

   act := isVarEqualTo(imgFxMode, 2, 3, 4, 9, 10) && (o_bwDithering=0) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, zatAdjust
   GuiControl, % act, infoZatAdjust
   GuiControl, % act, hueAdjust
   GuiControl, % act, infohueAdjust
   GuiControl, % act, lummyAdjust
   GuiControl, % act, infoLummyAdjust
   GuiControl, % act, specialColorFXmode
   GuiControl, % act, UIimgThreshold
   GuiControl, % act, infoThreshold
   act := (InStr(act, "disable")) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % act, IntensityAlphaChannel
   canEnableThese := InStr(act, "enable") ? 1 : 0

   act := (specialColorFXmode=7 && canEnableThese=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, uiColorCurveFXmode
   GuiControl, % act, uiColorCurveFXchannel

   act := (imgFxMode=2 || imgFxMode=3) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, infoRGBchnls
   GuiControl, % act, chnRdecalage
   GuiControl, % act, chnGdecalage
   GuiControl, % act, chnBdecalage

   act := (imgFxMode=3) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, autoAdjustMode
   GuiControl, % act, usrAdaptiveThreshold
   GuiControl, % act, doSatAdjusts

   If (colorzFXinfoz[specialColorFXmode, 1]="-")
   {
      GuiControl, SettingsGUIA: Disable, infohueAdjust
      GuiControl, SettingsGUIA: Disable, hueAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infohueAdjust
      GuiControl, SettingsGUIA: Enable, hueAdjust
   }

   If (colorzFXinfoz[specialColorFXmode, 2]="-")
   {
      GuiControl, SettingsGUIA: Disable, infoZatAdjust
      GuiControl, SettingsGUIA: Disable, zatAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infoZatAdjust
      GuiControl, SettingsGUIA: Enable, zatAdjust
   }

   If (colorzFXinfoz[specialColorFXmode, 3]="-")
   {
      GuiControl, SettingsGUIA: Disable, infoLummyAdjust
      GuiControl, SettingsGUIA: Disable, lummyAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infoLummyAdjust
      GuiControl, SettingsGUIA: Enable, lummyAdjust
   }

   lastInvoked := A_TickCount
}

btnResetImageView() {
  ; GuiControlGet, realTimePreview
  If (AnyWindowOpen!=10 && AnyWindowOpen!=74)
     Return

  Gui, SettingsGUIA: Default
  ForceNoColorMatrix := 0
  GuiControl, SettingsGUIA: , uiForceNoColorMatrix, 1
  GuiControl, SettingsGUIA: Choose, imgFxMode, 1
  GuiControl, SettingsGUIA: Choose, usrAdaptiveThreshold, 5
  GuiControl, SettingsGUIA: Choose, chnRdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnGdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnBdecalage, 14
  GuiControl, SettingsGUIA: Choose, specialColorFXmode, 1
  If (AnyWindowOpen=10)
  {
     usrColorDepth := IMGresizingMode := ColorDepthDithering := 1
     FlipImgV := FlipImgH := usrTextureBGR := vpIMGrotation := bwDithering := 0
     GuiControl, SettingsGUIA: Choose, usrColorDepth, 1
     GuiControl, SettingsGUIA: Choose, uiIMGresizingMode, 1
     GuiControl, SettingsGUIA:, bwDithering, 0
     GuiControl, SettingsGUIA:, ColorDepthDithering, 1
     GuiControl, SettingsGUIA:, vpIMGrotation, 0
     GuiControl, SettingsGUIA:, usrTextureBGR, 0
     GuiControl, SettingsGUIA:, FlipImgV, 0
     GuiControl, SettingsGUIA:, FlipImgH, 0
  } Else If (AnyWindowOpen=74)
  {
     EraseAreaOpacity := 255
     DesaturateAreaLevels := 1
     GuiControl, SettingsGUIA: Choose, DesaturateAreaLevels, 1
     GuiControl, SettingsGUIA:, EraseAreaOpacity, 255
  }

  imgFxMode := satAdjust := lumosAdjust := lumosGrayAdjust := specialColorFXmode := IntensityAlphaChannel := 1
  lummyAdjust := zatAdjust := hueAdjust := GammosAdjust := GammosGrayAdjust := 0
  chnRdecalage := chnGdecalage := chnBdecalage := 0.0
  updatePanelColorsInfo()
  UIrealGammos := 200
  realGammos := usrAdaptiveThreshold := infoBright := infoSatu := 1
  infoContrst := sliderSatu := sliderBright := sliderContrst := 0
  UIimgThreshold := imgThreshold := 0

  GuiControl, SettingsGUIA: Choose, IntensityAlphaChannel, 1
  GuiControl, SettingsGUIA:, infoBright, Brightness: 1.009
  GuiControl, SettingsGUIA:, infoContrst, Contrast: 0.000
  GuiControl, SettingsGUIA:, infoSatu, Saturation: 1.000
  GuiControl, SettingsGUIA:, infoThreshold, Threshold: 0.00
  GuiControl, SettingsGUIA:, infoRealGammos, Gamma: 1.00
  GuiControl, SettingsGUIA:, hueAdjust, 0
  GuiControl, SettingsGUIA:, zatAdjust, 0
  GuiControl, SettingsGUIA:, lummyAdjust, 0
  GuiControl, SettingsGUIA:, UIrealGammos, 200
  GuiControl, SettingsGUIA:, UIimgThreshold, 0
  GuiControl, SettingsGUIA:, sliderSatu, 0
  GuiControl, SettingsGUIA:, sliderBright, 0
  GuiControl, SettingsGUIA:, sliderContrst, 0

  interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
  defineColorDepth()
  SetTimer, WriteSettingsColorAdjustments, -90
  dummyTimerDelayiedImageDisplay(50)
}

UpdateUIadjustVPcolors(dummy:=0) {
   Critical, On
   If (AnyWindowOpen!=10 && AnyWindowOpen!=74)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, imgFxMode
   GuiControlGet, usrAdaptiveThreshold
   GuiControlGet, doSatAdjusts
   GuiControlGet, autoAdjustMode
   GuiControlGet, sliderBright
   GuiControlGet, sliderContrst
   GuiControlGet, sliderSatu
   GuiControlGet, chnRdecalage
   GuiControlGet, chnGdecalage
   GuiControlGet, chnBdecalage
   GuiControlGet, IntensityAlphaChannel
   GuiControlGet, zatAdjust
   GuiControlGet, hueAdjust
   GuiControlGet, lummyAdjust
   GuiControlGet, uiColorCurveFXchannel
   GuiControlGet, uiColorCurveFXmode
   GuiControlGet, specialColorFXmode
   GuiControlGet, UIimgThreshold
   GuiControlGet, UIrealGammos
   GuiControlGet, uiForceNoColorMatrix

   ForceNoColorMatrix := !uiForceNoColorMatrix
   If (AnyWindowOpen=10)
   {
      GuiControlGet, bwDithering
      GuiControlGet, usrColorDepth
      GuiControlGet, ColorDepthDithering
      GuiControlGet, UIvpImgAlignCenter
      GuiControlGet, FlipImgV
      GuiControlGet, FlipImgH
      GuiControlGet, userimgQuality
      GuiControlGet, vpIMGrotation
      GuiControlGet, usrTextureBGR
      GuiControlGet, histogramMode
      GuiControlGet, showHistogram
   } Else
   {
      GuiControlGet, EraseAreaInvert
      GuiControlGet, EraseAreaUseAlpha
      GuiControlGet, EraseAreaOpacity
      GuiControlGet, DesaturateAreaLevels
      GuiControlGet, DesaturateAreaDither
      thisOpacity := Round((EraseAreaOpacity / 255) * 100)
      GuiControl, SettingsGUIA:, infoEraseOpacity, Opacity: %thisOpacity%`%
   }

   ; GuiControlGet, realTimePreview
   If (dummy!="ignore-zoom" && AnyWindowOpen=10)
   {
      GuiControlGet, uiIMGresizingMode, SettingsGUIA:, uiIMGresizingMode
      If (uiIMGresizingMode=3)
      {
         lockZoomLevel := 0
         customZoomAdaptMode := 0
         IMGresizingMode := 4
         zoomLevel := 1
      } Else If (uiIMGresizingMode=6)
      {
         lockZoomLevel := 0
         customZoomAdaptMode := 1
         IMGresizingMode := 4
      } Else If (uiIMGresizingMode=7)
      {
         lockZoomLevel := 0
         customZoomAdaptMode := 2
         IMGresizingMode := 4
      } Else IMGresizingMode := uiIMGresizingMode

      imageAligned := (UIvpImgAlignCenter=1) ? 5 : 1
   }

   defineColorDepth()
   ; ForceNoColorMatrix := 0
   If (vpIMGrotation=1 || vpIMGrotation>358)
      vpIMGrotation := 0

   imgThreshold := Round(UIimgThreshold/100, 3)
   If (imgFxMode!=3 && imgFxMode!=1)
      realGammos := (UIrealGammos>200) ? Round((UIrealGammos*3 - 500)/100, 3) : Round(UIrealGammos/200, 3)

   If (imgFxMode=2)
   {
      lumosAdjust := (sliderBright>0) ? 0.14*sliderBright + 1 : 0.01*Abs(sliderBright + 100)
      GammosAdjust := (sliderContrst>0) ? -0.14*sliderContrst : 0.01*Abs(sliderContrst)
      satAdjust := (sliderSatu>0) ? 0.02*sliderSatu + 1 : 0.01*Abs(sliderSatu + 100)
   } Else If (imgFxMode=4)
   {
      lumosGrayAdjust := (sliderBright>0) ? 0.14*sliderBright + 1 : 0.01*Abs(sliderBright + 100)
      GammosGrayAdjust := (sliderContrst>0) ? -0.14*sliderContrst : 0.01*Abs(sliderContrst)
   }

   If (imgFxMode=3)
   {
      imgPath := getIDimage(currentFileIndex)
      AdaptiveImgLight(useGdiBitmap(), imgPath, 1, 1)
      updatePanelColorSliderz()
   }

   If (imgFxMode!=4 && AnyWindowOpen=10)
   {
      bwDithering := 0
      GuiControl, SettingsGUIA:, bwDithering, 0
   }

   updatePanelColorsInfo()
   filterDelayiedImageDisplay()
   SetTimer, WriteSettingsColorAdjustments, -150
}

PanelFileFormatConverter() {
    Global btnFldr, IDbtnConvert, editF5
    filesElected := getSelectedFiles(0, 1)
    thisBtnHeight := createSettingsGUI(15, A_ThisFunc)
    btnWid := 110
    txtWid := 280
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    sml := (PrefsLargeFonts=1) ? 250 : 140
    thisW := (PrefsLargeFonts=1) ? 85 : 75
    initFIMGmodule()
    ReadSettingsFormatConvert()
    Gui, Add, Text, x15 y15 w%sml% Section, Destination format:
    Gui, Add, DropDownList, x+5 w%thisW% gTglDesiredSaveFormat AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, % userPossibleWriteFMTs
    Gui, Add, Text, xs y+10 w%sml%, On file name conflicts:
    Gui, Add, DropDownList, x+5 w150 AltSubmit gTglOverwriteFiles Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10 w%sml%, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w%thisW% number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    Gui, Add, Checkbox, xs y+10 gTglKeepOriginals Checked%OnConvertKeepOriginals% vOnConvertKeepOriginals, &Keep original file[s]
    Gui, Add, Checkbox, y+10 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder:
    Gui, Add, Edit, xp+10 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    If (filesElected>1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, Files selected to convert: %filesElected%.
       Gui, Font, Normal
    } 

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    thisW := (PrefsLargeFonts=1) ? 90 : 70
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%thisW% gBTNconvertNow Default vIDbtnConvert, &Convert
    Gui, Add, Button, x+5 hp wp gBTNconvertHelp, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file format conversion: " appTitle)
}

BTNconvertHelp() {
    msgBoxWrapper(appTitle ": HELP", "File format conversion relies primarly on the FreeImage library.`n`nOn conversion, images will be converted to 24 bits or 32 bits.`n`nFailures can occur if the images are very large (above 250 MPx) and the destination format does not allow such large images, if there is insufficient system memory or... if file access is denied when attempting to write files.`n`nQuality option applies for JPG, JP2, J2K, JXR and WEBP file formats.", -1, 0, 0)
}

TglKeepOriginals() {
    GuiControlGet, OnConvertKeepOriginals
    RegAction(1, "OnConvertKeepOriginals")
}

TglOverwriteFiles() {
    GuiControlGet, userActionConflictingFile
    RegAction(1, "userActionConflictingFile")
}

TglDesiredSaveFormat() {
    GuiControlGet, userDesireWriteFMT
    RegAction(1, "userDesireWriteFMT")
}

BTNconvertNow() {
   If (AnyWindowOpen!=15)
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide

   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   If (!RegExMatch(rDesireWriteFMT, "i)(bmp|png|tiff|tif|gif|jpg|jpeg)$") && wasInitFIMlib!=1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "The ." rDesireWriteFMT " format is currently unsupported. The FreeImage library failed to properly initialize.", 0, 0, "error")
      Return
   }

   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   RegAction(1, "OnConvertKeepOriginals")
   RegAction(1, "PreserveDateTimeOnSave")
   RegAction(1, "ResizeDestFolder")
   RegAction(1, "userActionConflictingFile")
   RegAction(1, "userDesireWriteFMT")
   RegAction(1, "userJpegQuality")
   If (markedSelectFile>1)
   {
      CloseWindow()
      batchConvert2format()
   } Else convert2format(currentFileIndex)
}

WriteSettingsAdjustCanvasPanel() {
    ReadSettingsAdjustCanvasPanel()
}

ReadSettingsAdjustCanvasPanel(act:=0) {
    RegAction(act, "ResizeKeepAratio",, 1)
    RegAction(act, "ResizeInPercentage",, 1)
    RegAction(act, "adjustCanvasCentered",, 1)
    RegAction(act, "adjustCanvasMode",, 1)
    RegAction(act, "adjustCanvasNoBgr",, 1)
    RegAction(act, "FillAreaColor",, 3)
    RegAction(act, "FillAreaOpacity",, 2, 1, 255)
}

PanelAdjustImageCanvasSize() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight
         , userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter

    If (thumbsDisplaying=1 || AnyWindowOpen)
       Return

    r1 := Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (!oImgH || !oImgH)
    {
       showTOOLtip("ERROR: No image seems to be loaded or it is malformed")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(28, A_ThisFunc)
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 Section, Original image size: %oImgW% x %oImgH% pixels.
    Gui, Add, Edit, x15 y15 w1 r1 limit7 -multi -wrap, -
    Gui, Add, Text, xs y+10 vtxtLine1, Set new canvas dimensions (W x H):
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit7 -multi number -wrap gEditResizeWidth vuserEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 limit7 -multi number -wrap gEditResizeHeight vuserEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, Use `% percentages
    Gui, Add, Checkbox, xs+15 y+5 hp gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp Checked%adjustCanvasCentered% vadjustCanvasCentered, Centered image

    Gui, Add, Text, xs y+15, Resulted dimensions and background color:
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled -wrap vResultEditWidth, % oImgW
    Gui, Add, Edit, x+5 wp r1 Disabled -wrap vResultEditHeight, % oImgH
    Gui, Add, ListView, x+5 wp hp %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, ComboBox, x+5 wp vFillAreaOpacity, 25|50|75|100|150|200|255|%FillAreaOpacity%||
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P

    Gui, Add, Checkbox, xs y+10 hp Checked%adjustCanvasNoBgr% vadjustCanvasNoBgr gupdateUIadjustCanvasPanel, Transparent background 
    Gui, Add, Checkbox, xs y+10 Section hp Checked%adjustCanvasMode% vadjustCanvasMode gupdateUIadjustCanvasPanel, Add margins to current image dimensions:
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled +0x0800, -
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddTop, 0
    Gui, Add, Edit, x+5 wp r1 Disabled +0x0800, -

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddLeft, 0
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddCenter, 0
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddRight, 0

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled +0x0800, -
    Gui, Add, Edit, x+5 w%editWid% r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddBottom, 0
    Gui, Add, Edit, x+5 wp r1 Disabled +0x0800, -

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% gBTNadjustCanvasAction Default, &Adjust canvas
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Adjust image canvas size: " appTitle)
    updateUIadjustCanvasPanel()
}

EditCanvasMargins() {
   If (AnyWindowOpen!=28)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, userAddTop
   GuiControlGet, userAddBottom
   GuiControlGet, userAddCenter
   GuiControlGet, userAddLeft
   GuiControlGet, userAddRight
   If (!userAddTop || userAddTop<0)
      userAddTop := 0
   If (!userAddBottom || userAddBottom<0)
      userAddBottom := 0
   If (!userAddCenter || userAddCenter<0)
      userAddCenter := 0
   If (!userAddLeft || userAddLeft<0)
      userAddLeft := 0
   If (!userAddRight || userAddRight<0)
      userAddRight := 0

   Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   thisWidth := oImgW + userAddLeft + userAddRight + userAddCenter
   thisHeight := oImgH + userAddTop + userAddBottom + userAddCenter
   GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
   GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
}

updateUIadjustCanvasPanel() {
    If (AnyWindowOpen!=28)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, adjustCanvasNoBgr
    GuiControlGet, adjustCanvasMode
    GuiControlGet, adjustCanvasCentered
    GuiControlGet, FillAreaOpacity

    actu1 := (adjustCanvasMode=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    actu2 := (adjustCanvasMode!=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, ResizeKeepAratio
    GuiControl, % actu2, ResizeInPercentage
    GuiControl, % actu2, adjustCanvasCentered
    GuiControl, % actu2, userEditHeight
    GuiControl, % actu2, userEditWidth
    GuiControl, % actu2, txtLine1
    GuiControl, % actu1, userAddCenter
    GuiControl, % actu1, userAddTop
    GuiControl, % actu1, userAddBottom
    GuiControl, % actu1, userAddLeft
    GuiControl, % actu1, userAddRight
    If (adjustCanvasMode=1)
       EditCanvasMargins()
    Else
       EditResizeWidth()

    actu := (adjustCanvasNoBgr=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
    GuiControl, % actu, FillAreaColor
    GuiControl, % actu, FillAreaOpacity
    GuiControl, % actu, PickuFillAreaColor

    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := FillAreaOpacity
    SetTimer, WriteSettingsAdjustCanvasPanel, -300
}

BTNadjustCanvasAction() {
    Gui, SettingsGUIA: Default
    GuiControlGet, adjustCanvasCentered
    GuiControlGet, adjustCanvasNoBgr
    GuiControlGet, adjustCanvasMode
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, FillAreaOpacity
    GuiControlGet, userAddTop
    GuiControlGet, userAddBottom
    GuiControlGet, userAddCenter
    GuiControlGet, userAddLeft
    GuiControlGet, userAddRight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResultEditWidth

    If (!userAddTop || userAddTop<0)
       userAddTop := 0
    If (!userAddBottom || userAddBottom<0)
       userAddBottom := 0
    If (!userAddCenter || userAddCenter<0)
       userAddCenter := 0
    If (!userAddLeft || userAddLeft<0)
       userAddLeft := 0
    If (!userAddRight || userAddRight<0)
       userAddRight := 0

    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (ResultEditWidth=oImgW && ResultEditHeight=oImgH)
    {
       showTOOLtip("WARNING: The new dimension is equal with the initial one")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    If isImgSizeTooLarge(ResultEditWidth, ResultEditHeight)
    {
       showTOOLtip("ERROR: The document dimensions exceed the maximum limits")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    FillAreaOpacity := Trimmer(FillAreaOpacity)
    FillAreaOpacity := StrReplace(FillAreaOpacity, "%")
    FillAreaOpacity := StrReplace(FillAreaOpacity, A_Space)
    If !isNumber(FillAreaOpacity)
       FillAreaOpacity := 255

    clampInRange(FillAreaOpacity, 2, 255)
    WriteSettingsAdjustCanvasPanel()
    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := FillAreaOpacity

    BtnCloseWindow()
    ToggleEditImgSelection("show-edit")
    ChangeImageCanvasSize(ResultEditWidth, ResultEditHeight, userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter, 0)
}

PanelResizeImageWindow() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight, btnFldr, editF5

    ToolTip, Please wait...
    filesElected := getSelectedFiles(0, 1)
    multipleFilesMode := (filesElected>1) ? 1 : 0
    If (multipleFilesMode=0 && !PanelsCheckFileExists())
    {
       ToolTip
       Return
    }

    thisBtnHeight := createSettingsGUI(4, A_ThisFunc)
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsImageProcessing()
    img2resizePath := getIDimage(currentFileIndex)
    If (multipleFilesMode=0)
    {
       zPlitPath(img2resizePath, 0, fileNamu, folderu)
       r1 := GetImgFileDimension(img2resizePath, oImgW, oImgH)
       FileGetSize, fileSizu, % img2resizePath, K
       If !r1
       {
          BtnCloseWindow()
          showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
          SoundBeep, 300, 100
          img2resizePath := ""
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    } Else
    {
       oImgW := ResolutionWidth
       oImgH := ResolutionHeight
    }

    initFIMGmodule()
    If (editingSelectionNow!=1)
       ResizeWithCrop := 0

    If (resetImageViewOnChange=1)
       ResizeApplyEffects := 0

    Gui, Add, Tab3, , General|File(s) destination
    Gui, Tab, 1
    If (multipleFilesMode=1)
    {
       Gui, Add, Text, x+15 y+15 Section, Resize image to (W x H)
    } Else
    {
       Gui, Add, Text, x+15 y+15 Section, Original image dimensions:
       Gui, Add, Text, xs+15 y+5, %oImgW% x %oImgH% pixels. %fileSizu% kilobytes.
       Gui, Add, Text, xs y+10, Resize image to (W x H)
    }

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeWidth vuserEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeHeight vuserEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 wp+30 hp +0x1000 gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `% perc.
    If (multipleFilesMode!=1)
       Gui, Add, Text, xs y+15, Result (W x H) in pixels
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled -wrap vResultEditWidth, % (multipleFilesMode=1) ? "--" : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 Disabled -wrap vResultEditHeight, % (multipleFilesMode=1) ? "--" : oImgH
    thisRotation := (vpIMGrotation=0) ? ResizeRotationUser : vpIMGrotation
    otherRotation := (vpIMGrotation=thisRotation) ? ResizeRotationUser : vpIMGrotation
    Gui, Add, ComboBox, x+5 wp+30 gTglRszRotation vResizeRotationUser, Rotate: 0°|45°|90°|135°|180°|225°|270°|315°|%thisRotation%°||%otherRotation%°
    Gui, Add, Checkbox, xs y+10 hp +0x1000 gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp +0x1000 gTglRszQualityHigh Checked%ResizeQualityHigh% vResizeQualityHigh, High quality resampling
    Gui, Add, Checkbox, xs y+10 gTglRszCropping Checked%ResizeWithCrop% vResizeWithCrop, Crop image(s) to the viewport selection
    Gui, Add, Checkbox, xp+10 y+10 gTglRszCropping Checked%ResizeCropAfterRotation% vResizeCropAfterRotation, Perform image crop after image rotation (as in the viewport)
    Gui, Add, Checkbox, xs y+10 gTglRszApplyEffects Checked%ResizeApplyEffects% vResizeApplyEffects, Apply color adjustments and image mirroring`nactivated in the main window

    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15, If no destination folder is chosen,`nthe original files may be overwritten.
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the following folder
    Gui, Add, Edit, xp+15 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs y+7 , On file name conflicts
    Gui, Add, DropDownList, x+5 w150 gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    If (multipleFilesMode=1)
    {
       Gui, Add, DropDownList, xs y+10 w%txtWid% gTglRszUnsprtFrmt AltSubmit Choose%userUnsprtWriteFMT% vuserUnsprtWriteFMT, Skip files in unsupported write formats|Try to preserve file formats, convert unsupported to...|Convert all the files to...
       Gui, Add, DropDownList, xs y+5 w85 AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, % userPossibleWriteFMTs
       Gui, Add, Button, x+5 hp w85 gResizePanelHelpBoxInfo, Help
    }

    If (resetImageViewOnChange=1)
       GuiControl, Disable, ResizeApplyEffects

    If (editingSelectionNow!=1)
    {
       GuiControl, Disable, ResizeWithCrop
       GuiControl, Disable, ResizeCropAfterRotation
    }

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Tab
    If (multipleFilesMode=1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs-15 y+10, %filesElected% files are selected for processing.`nMulti-threaded processing not yet implemented.
       Gui, Font, Normal
       Gui, Add, Button, xp y+10 h%thisBtnHeight% w%btnWid% Default gBTNsaveResizedIMG, &Process images
       Gui, Add, Button, x+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       If (userUnsprtWriteFMT=1)
          GuiControl, SettingsGUIA: Disable, userDesireWriteFMT
    } Else
    {
       Gui, Add, Button, xs-15 y+20 h%thisBtnHeight% w%btnWid% gBtnCopy2ClipResizedIMG, &Copy to clipboard
       Gui, Add, Button, x+5 hp wp Default gBTNsaveResizedIMG, &Save image as...
       Gui, Add, Button, xs-15 y+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       Gui, Add, Button, x+5 hp w85 gResizePanelHelpBoxInfo, Help
    }
    ToolTip
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / rotate / crop image(s): " appTitle)
}

BtnInvokePanelSimpleResizeRotate() {
   BtnCloseWindow()
   Sleep, 25
   PanelSimpleResizeRotate("forced")
}

BTNchangeResizeDestFolder() {
   If (AnyWindowOpen=4)
      EditResizeWidth()

   SelectImg := openFoldersDialogWrapper("S2", ResizeDestFolder)
   OutDir := Trimmer(SelectImg)
   If !FolderExist(OutDir)
   {
      WinActivate, ahk_id %hSetWinGui%
   } Else
   {
      GuiControl, SettingsGUIA:, ResizeDestFolder, % OutDir
      ResizeDestFolder := OutDir
      RegAction(1, "ResizeDestFolder")
   }
}

setForceRefreshThumbsFilesIndex(onlySelected) {
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1 && onlySelected=1)
         Continue

      resultedFilesList[A_Index, 4] := 1
   }
   ForceRefreshNowThumbsList()
}

batchIMGresizer(desiredW, desiredH, isPercntg, dontAsk:=0) {
   cleanResizeUserOptionsVars()
   If (!desiredH || !desiredW
   || desiredW<1 || desiredH<1)
   || ((desiredW<5 || desiredH<5) && (isPercntg!=1))
   {
      showTOOLtip("WARNING: Incorrect dimensions given")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   filesElected := getSelectedFiles(0, 1)
   If (dontAsk!="yes")
   {
      If (filesElected>100)
      {
         overwriteWarning := (ResizeUseDestDir!=1) ? "`n`nWARNING: All the original files will be overwritten!" : "`n`nThe files will be saved in " ResizeDestFolder "\"
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to process multiple images in one go. There are " filesElected " selected files for this operation. " overwriteWarning, 4, 0, "question")
         If (msgResult!="Yes")
            Return
      } Else Return
   }

   BtnCloseWindow()
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   startOperation := A_TickCount
   CurrentSLD := ""
   thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
   If (ResizeKeepAratio=1 && isPercntg=1)
      desiredW := desiredH

   showTOOLtip("Processing " filesElected " images, please wait")
   prevMSGdisplay := A_TickCount
   countTFilez := countFilez := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   failedFiles := countFilez := skippedFiles := 0
   destroyGDIfileCache()
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      countTFilez++
      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (!FileExist(imgPath) || !imgPath) || (!RegExMatch(imgPath, saveTypesRegEX) && userUnsprtWriteFMT=1)
      {
         skippedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to process " groupDigits(failedFiles) " files"
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) "files were skipped"

         showTOOLtip("Processing images, please wait" etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      fOutDir := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      If (userUnsprtWriteFMT=3)
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else If (userUnsprtWriteFMT=2 && !RegExMatch(imgPath, saveTypesRegEX))
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else
         destImgPath := fOutDir "\" OutFileName

      If (userUnsprtWriteFMT!=1 || ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionConflictingFile, performOverwrite)
      }

      If !destImgPath
      {
         skippedFiles++
         Continue
      }

      oBitmap := LoadBitmapFromFileu(imgPath)
      If StrLen(oBitmap)<3
      {
         failedFiles++
         Continue
      }

      Gdip_GetImageDimensions(oBitmap, imgW, imgH)
      If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
         Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

      If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      z := calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, ResizeKeepAratio, newW, newH)
      If (z=-1 || z=1)
      {
         failedFiles++
         trGdip_DisposeImage(oBitmap, 1)
         Continue
      }

      r := coreResizeIMG(imgPath, newW, newH, destImgPath, 0, 0, ResizeRotationUser, oBitmap, imgW, imgH, 0)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If (failedFiles>0)
      someErrors := "`nFailed to process " groupDigits(failedFiles) " files"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   If (editingSelectionNow=1 && relativeImgSelCoords=1)
      calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip("Finished processing " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

WriteSettingsResizePanel() {
   coreReadSettingsImageProcessing(1)
}

WriteSettingsResizeSimplePanel() {
   coreReadSettingsImageProcessing(1)
}

calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, isKeepRatio, ByRef newW, ByRef newH) {
   r := 0
   If (isPercntg=1)
   {
      newW := Round((imgW/100)*desiredW)
      newH := Round((imgH/100)*desiredH)
      If (newW<10 && newH<10)
         r := -1
   } Else If (isKeepRatio=1)
   {
      calcIMGdimensions(imgW, imgH, desiredW, desiredH, newW, newH)
      If (newW<10 && newH<10)
         r := -1
   } Else
   {
      newW := desiredW
      newH := desiredH
   }

   If isImgSizeTooLarge(newW, newH)
      r := 1
   Return r
}

filesListApplyColors() {
    Static prevFXmode := "n"

    o_imgFxMode := imgFxMode
    If (imgFxMode>1)
       prevFXmode := imgFxMode
    Else If (prevFXmode!="n")
       imgFxMode := prevFXmode

    If (imgFxMode=1)
    {
       showTOOLtip("No viewport color adjustments to be applied on image`n`nPress F to cycle through mode")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && imgFxMode>1)
   {
      If (filesElected>200)
      {
         msgResult := msgBoxWrapper(appTitle ": Apply colors", "All the images in supported writing formats will be processed accordingly to the color adjustments of the viewport. The original files will be overwritten. Do you want to continue?", 4, 0, "question")
         If !InStr(msgResult, "yes")
            Return
      }

      ResizeMustPerform := ResizeUseDestDir := 0
      ResizeInPercentage := ResizeApplyEffects := 1
      userActionConflictingFile := userUnsprtWriteFMT := 1
      ResizeWithCrop := ResizeRotationUser := simpleOpRotationAngle := 0
      ResultEditWidth := ResultEditHeight := 100
      WriteSettingsResizePanel()
      batchIMGresizer(100, 100, ResizeInPercentage, "yes")
   } Else
   {
      imgPath := resultedFilesList[currentFileIndex, 1]
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      If !RegExMatch(imgPath, saveTypesRegEX)
      {
         showTOOLtip("ERROR: Image file is in an unsupported write format")
         SoundBeep, 300, 100
      } Else
      {
         destroyGDIfileCache()
         ResizeMustPerform := ResizeUseDestDir := 0
         ResizeInPercentage := ResizeApplyEffects := 1
         userActionConflictingFile := userUnsprtWriteFMT := 1
         ResizeWithCrop := ResizeRotationUser := simpleOpRotationAngle := 0
         ResultEditWidth := ResultEditHeight := 100
         ; WriteSettingsResizePanel()
         GetImgFileDimension(imgPath, imgW, imgH, 0)
         r := coreResizeIMG(imgPath, imgW, imgH, imgPath, 1, 0, 0, 1, imgW, imgH)
         If r
         {
            SoundBeep, 300, 100
            showTOOLtip("ERROR: Unable to save imagel file - unknown error:`n" OutFileName "`n" OutDir "\")
         } Else
         {
            resultedFilesList[currentFileIndex, 4] := 1
            If (SLDtypeLoaded=3)
               selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

            showTOOLtip("Viewport colour effects applied on the image:`n" OutFileName "`n" OutDir "\")
         }
      }
   }

   imgFxMode := 1
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
}

filesListFlipHimage() {
   coreQuickImageFilesListActions(2)
}

filesListFlipVimage() {
   coreQuickImageFilesListActions(3)
}

filesListFlipRotatePlus() {
   coreQuickImageFilesListActions(6)
}

filesListFlipRotateMinus() {
   coreQuickImageFilesListActions(8)
}

coreQuickImageFilesListActions(actu) {
   initFIMGmodule()
   countNotJpegs := firstu := 0
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1)
   {
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         imgPath := resultedFilesList[A_Index, 1]
         If (!RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && imgPath)
         {
            countNotJpegs++
            If !firstu
               firstu := A_Index
         }
         If (countNotJpegs>3)
            Break
      }
   }

   imgPath := resultedFilesList[currentFileIndex, 1]
   If (RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && countNotJpegs<2)
   {
      hasExec := 1
      jpegDesiredOperation := actu
      jpegDoCrop := 0
      BtnPerformJpegOp("extern")
   }

   If (countNotJpegs=1 && firstu)
   {
      hasExec := 0
      currentFileIndex := firstu
   }

   If (hasExec!=1)
   {
      ResizeMustPerform := 0 
      SimpleOperationsFlipV := (actu=3) ? 1 : 0
      SimpleOperationsFlipH := (actu=2) ? 1 : 0
      SimpleOperationsDoCrop := 0
      SimpleOperationsRotateAngle := 1
      If (actu=6)  ; 90 degrees rotation
         SimpleOperationsRotateAngle := 2
      Else If (actu=8) ; -90 degrees rotation 
         SimpleOperationsRotateAngle := 4

      SimpleOperationsScaleXimgFactor := 100
      SimpleOperationsScaleYimgFactor := 100
      ResizeQualityHigh := ResizeInPercentage := 1
      ResizeUseDestDir := 0
      cleanResizeUserOptionsVars()
      BtnPerformSimpleProcessing("no-prompt", "extern")
   }
}

BTNsaveResizedIMG() {
    Gui, SettingsGUIA: Default
    GuiControlGet, ResultEditWidth
    GuiControlGet, ResultEditHeight
    GuiControlGet, userEditWidth
    GuiControlGet, userEditHeight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResizeApplyEffects
    GuiControlGet, ResizeCropAfterRotation
    GuiControlGet, ResizeDestFolder
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, ResizeQualityHigh
    GuiControlGet, ResizeRotationUser
    GuiControlGet, ResizeUseDestDir
    GuiControlGet, ResizeWithCrop
    GuiControlGet, userActionConflictingFile
    GuiControlGet, userJpegQuality

    EditResizeWidth()
    cleanResizeUserOptionsVars()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       GuiControlGet, userDesireWriteFMT
       GuiControlGet, userUnsprtWriteFMT
       rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
       If (!RegExMatch(rDesireWriteFMT, "i)(bmp|png|tiff|tif|gif|jpg|jpeg)$") && wasInitFIMlib!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The ." rDesireWriteFMT " format is currently unsupported. The FreeImage library failed to properly initialize.", 0, 0, "error")
          Return
       }

       WriteSettingsResizePanel()
       If (ResizeUseDestDir=1)
          RegAction(1, "ResizeDestFolder")

       batchIMGresizer(userEditWidth, userEditHeight, ResizeInPercentage)
       Return
    }

   If (!ResultEditHeight || !ResultEditWidth
   || ResultEditWidth<5 || ResultEditHeight<5)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
      Return
   }

   If isImgSizeTooLarge(ResultEditWidth, ResultEditHeight)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceeds the limits of GDI+.`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
      Return
   }

   zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutFileNameNoExt, fileEXT)
   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileName : OutDir "\" OutFileNameNoExt
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   Loop, Parse, dialogSaveFptrn, |
   {
        If InStr(A_LoopField, "." fileEXT)
           defFMTindex := A_Index
   }

   file2save := openFileDialogWrapper("S", "PathMustExist", startPath, "Save processed image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)
   If file2save
   {
      zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      zPlitPath(file2save, 0, OutFileName, OutDir)
      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      GetImgFileDimension(img2resizePath, imgW, imgH, 0)
      If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
         Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

      z := calcNewImgDimensions(imgW, imgH, userEditWidth, userEditHeight, ResizeInPercentage, ResizeKeepAratio, newW, newH)
      If (z=-1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
         Return
      } Else If (z=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceed the limits of GDI+.`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
         Return
      }

      If FileExist(file2save)
      {
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      destroyGDIfileCache()
      SetTimer, WriteSettingsResizePanel, -90
      r := coreResizeIMG(img2resizePath, newW, newH, file2save, 0, 0, ResizeRotationUser, 1, imgW, imgH)
      If r
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Unable to save file... Unknown error.`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         Return
      }

      resultedFilesList[currentFileIndex, 4] := 1
      If (SLDtypeLoaded=3)
         selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

      SoundBeep, 900, 100
      showTOOLtip("Processed image saved`n" OutFileName "`n`n" OutDir "\")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -300
   }
}

BtnCopy2ClipResizedIMG() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResultEditWidth
   GuiControlGet, ResultEditHeight
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeQualityHigh
   GuiControlGet, ResizeApplyEffects
   GuiControlGet, ResizeRotationUser
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation

   EditResizeWidth()
   cleanResizeUserOptionsVars()
   GetImgFileDimension(img2resizePath, imgW, imgH, 0)
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
      Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

   z := calcNewImgDimensions(imgW, imgH, userEditWidth, userEditHeight, ResizeInPercentage, ResizeKeepAratio, newW, newH)
   If (z=-1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
      Return
   } Else If (z=1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceeds the limits of GDI+.`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
      Return
   }

   showTOOLtip("Processing image, please wait")
   r := coreResizeIMG(img2resizePath, newW, newH, "--", 0, 1, ResizeRotationUser, 1, imgW, imgH)
   SoundBeep, % r ? 300 : 900, 100
   ToolTip
   If !r
      showTOOLtip("Processed image copied to clipboard")
   Else 
      msgBoxWrapper(appTitle ": ERROR", "Unable to copy the processed image to the clipboard.`nError code: " r, 0, 0, "error")

   SetTimer, RemoveTooltip, % -msgDisplayTime//3
   ResetImgLoadStatus()
   SetTimer, ResetImgLoadStatus, -250
}

EditResizeWidth() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   GuiControlGet, ResizeRotationUser
   If (AnyWindowOpen=4)
      GuiControlGet, ResizeRotationUser
   
   If (A_TickCount - lastEditRHChange < 200)
      Return

   If (AnyWindowOpen=4)
      cleanResizeUserOptionsVars()

   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRWChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditHeight, % Round(userEditWidth)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditWidth<1 || !userEditWidth)
      userEditWidth := 1

   If (AnyWindowOpen=73 || AnyWindowOpen=28)
      Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   Else
      GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

   Global lastEditRWChange := A_TickCount
   Sleep, 5
   If (ResizeKeepAratio=1)
   {
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      calcIMGdimensions(oImgW, oImgH, thisWidth, 90000*oImgH, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newH/oimgH)*100) : newH
      GuiControl, SettingsGUIA:, userEditHeight, % Round(newValue)

      Gdip_GetRotatedDimensions(newW, newH, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }
}

EditResizeHeight() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   If (AnyWindowOpen=4)
      GuiControlGet, ResizeRotationUser

   If (A_TickCount - lastEditRWChange < 200)
      Return

   If (AnyWindowOpen=4)
      cleanResizeUserOptionsVars()
   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRHChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditWidth, % Round(userEditHeight)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditHeight<1 || !userEditHeight)
      userEditHeight := 1

   If (AnyWindowOpen=28 || AnyWindowOpen=73)
      Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   Else
      GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

   Global lastEditRHChange := A_TickCount
   Sleep, 5
   If (ResizeKeepAratio=1)
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      calcIMGdimensions(oImgW, oImgH, 90000*oImgW, thisHeight, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newW/oimgW)*100) : newW
      GuiControl, SettingsGUIA:, userEditWidth, % Round(newValue)
      Gdip_GetRotatedDimensions(newW, newH, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }
}

TglRszInPercentage() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<50)
      Return
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
   If (AnyWindowOpen!=18)
   {
      filesElected := getSelectedFiles()
      If (filesElected>1)
      {
         oImgW := ResolutionWidth
         oImgH := ResolutionHeight
      } Else If (AnyWindowOpen=28 || AnyWindowOpen=73)
         Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
      Else
         GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

      GuiControl, SettingsGUIA:, userEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
      GuiControl, SettingsGUIA:, userEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
      If (AnyWindowOpen=73)
         updateUIresizeImgEditPanel()
      Else If (filesElected<2)
         EditResizeWidth()
   } Else
   {
      Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
      GuiControl, SettingsGUIA:, SimpleOperationsScaleXimgFactor, % (ResizeInPercentage=1) ? 100 : oImgW
      GuiControl, SettingsGUIA:, SimpleOperationsScaleYimgFactor, % (ResizeInPercentage=1) ? 100 : oImgH
   }

   RegAction(1, "ResizeInPercentage")
   lastInvoked := A_TickCount
}

TglRszKeepAratio() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, ResizeKeepAratio
   If (AnyWindowOpen=73)
      updateUIresizeImgEditPanel()
   Else If (!markedSelectFile || ResizeKeepAratio=1 && ResizeInPercentage=1)
      EditResizeWidth()

   RegAction(1, "ResizeKeepAratio")
}

TglRszUnsprtFrmt() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userUnsprtWriteFMT
   GuiControlGet, userDesireWriteFMT
   actu := (userUnsprtWriteFMT>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, userDesireWriteFMT
   RegAction(1, "userDesireWriteFMT")
}

cleanResizeUserOptionsVars() {
    ResizeRotationUser := StrReplace(ResizeRotationUser, ":")
    ResizeRotationUser := StrReplace(ResizeRotationUser, "°")
    ResizeRotationUser := StrReplace(ResizeRotationUser, "rotate")
    ResizeRotationUser := Trimmer(ResizeRotationUser)
    If (SimpleOperationsRotateAngle=2)
       simpleOpRotationAngle := 90
    Else If (SimpleOperationsRotateAngle=3)
       simpleOpRotationAngle := 180
    Else If (SimpleOperationsRotateAngle=4)
       simpleOpRotationAngle := 270
    Else
       simpleOpRotationAngle := 0
}

TglRszRotation() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeRotationUser
   GuiControlGet, ResizeWithCrop
   cleanResizeUserOptionsVars()
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation

   EditResizeWidth()
   RegAction(1, "ResizeWithCrop")
   RegAction(1, "ResizeRotationUser")
}

TglRszCropping() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation
   EditResizeWidth()
   RegAction(1, "ResizeWithCrop")
   RegAction(1, "ResizeCropAfterRotation")
}

TglRszDestFoldr() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeUseDestDir

   actu := ResizeUseDestDir ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, btnFldr
   GuiControl, % actu, ResizeDestFolder
   RegAction(1, "ResizeUseDestDir")
}

TglRszQualityHigh() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeQualityHigh
   RegAction(1, "ResizeQualityHigh")
}

TglRszApplyEffects() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeApplyEffects
   RegAction(1, "ResizeApplyEffects")
   If (ResizeApplyEffects=1)
   {
      infoMirroring := defineIMGmirroring()
      If (usrColorDepth>1)
         infoColorDepth := "`nSimulated color depth: " defineColorDepth()
      If (imgFxMode>1)
         infoColors := "`nColors display mode: " DefineFXmodes() " [" currIMGdetails.PixelFormat "]"
 
      entireString := infoMirroring infoColors infoColorDepth infoRenderOpaque
      entireString := (entireString) ?  "Effects currently activated: " entireString : "No effects currently activated."
      msgBoxWrapper(appTitle, entireString, 0, 0, "info")
   }
}

invokePanelStaticFoldersContextMenu() {
   isUpdateList := (RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? 1 : 0
   Try Menu, PanelStaticMenu, Delete
   Sleep, 2
   Try Menu, PVopenF, Delete

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetNext(0, "F")

   totalSelected := LV_GetCount("S")
   total := LV_GetCount()
   LV_GetText(indexu, RowNumber, 1)
   LV_GetText(changeState, RowNumber, 3)
   folderPath := newStaticFoldersListCache[indexu, 1]

   kMenu("PVopenF", "Add", "Open folder now", "BtnPanelManageFoldersActus")
   kMenu("PVopenF", "Add", "In Explorer`tF6", "BtnPanelManageFoldersExplorer")
   kMenu("PVopenF", "Add", "With a new QPV instance", "BtnPanelManageFoldersNewInstance")
   kMenu("PVopenF", "Add", "Folder properties (Explorer)", "BtnPanelManageFoldersProperties")
   If (folderPath && totalSelected)
   {
      kMenu("PanelStaticMenu", "Add", "&Jump to first indexed file in folder`tEnter", "BtnPanelStaticJumpFirst")
      kMenu("PanelStaticMenu", "Add", "&Rescan folder(s)`tF5", "BTNupdateSelectedStaticFolder")
      kMenu("PanelStaticMenu", "Add", "&Open folder", ":PVopenF")
      kMenu("PanelStaticMenu", "Add", "&Select files`tAlt+L-Click", "BTNselFilesStaticFolder")
      kMenu("PanelStaticMenu", "Add", "&Deselect files`tAlt+R-Click", "BTNunselFilesStaticFolder")
      kMenu("PanelStaticMenu", "Add", "&Erase files from the index`tDelete", "BTNremFilesStaticFolder")
      kMenu("PanelStaticMenu", "Add", "&Copy folder path(s) as text", "BTNcopyStaticFolderPath")
      kMenu("PanelStaticMenu", "Add/UnCheck", "&Set as the protected folder", "BtnPanelManageFoldersProtect")
      If (protectedFolderPath=folderPath && preventDeleteFromProtectedPath=1)
         kMenu("PanelStaticMenu", "Check", "&Set as the protected folder")

      If (isUpdateList=1 && InStr(changeState, "*"))
         kMenu("PanelStaticMenu", "Add", "&Ignore date change", "BTNignoreDateStaticFolder")
      If (SLDtypeLoaded!=3 && isUpdateList=1 && FileExist(CurrentSLD))
         kMenu("PanelStaticMenu", "Add", "Rename inde&x entry`tF2", "PanelRenameStaticFolder")

      kMenu("PanelStaticMenu", "Add", "&Filter files list to selected folder(s)`tF3", "MenuFilterListSelectedFolder")
   }

   Menu, PanelStaticMenu, Add,
   kMenu("PanelStaticMenu", "Add", "Re&generate this folders list", "regenerateStaticFoldersList")
   If (SLDtypeLoaded=3)
      kMenu("PanelStaticMenu", "Add", "&Count selected files", "SqlWrapPopulateStaticFolderzList")
   Else
      kMenu("PanelStaticMenu", "Add", "&Count files per folders", "countAllFilesPerStaticFolders")
   kMenu("PanelStaticMenu", "Add", "&Count files in folders found on disk", "countFilesDiskPerStaticFolders")
   kMenu("PanelStaticMenu", "Add", "&Copy entire list as text", "BTNcopyAllStaticFolderPaths")
   If markedSelectFile
      kMenu("PanelStaticMenu", "Add", "Deselect all (files &list)", "dropFilesSelection")

   If (total!=totalSelected)
      kMenu("PanelStaticMenu", "Add", "Select entire &table`tCtrl+A", "BTNreviewLVselAll")
   kMenu("PanelStaticMenu", "Add", "&View list as a folders tree", "BTNshowStaticFoldersInTreeView")
   Menu, PanelStaticMenu, Add
   kMenu("PanelStaticMenu", "Add", "Help`tF1", "BtnHelpStaticFoldersPanel")
   showThisMenu("PanelStaticMenu")
}

SqlWrapPopulateStaticFolderzList() {
   countAllFilesPerStaticFolders("start")
   PopulateStaticFolderzList()
}

invokePanelDynaFoldersContextMenu() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetNext()
   LV_GetText(folderPath, RowNumber, 3)
   LV_GetText(r, RowNumber, 2)
   totalSelected := LV_GetCount("S")
   Try Menu, PanelDynaMenu, Delete
   Sleep, 2
   Try Menu, PVopenF, Delete
   kMenu("PVopenF", "Add", "Open folder now", "BtnPanelManageFoldersActus")
   kMenu("PVopenF", "Add", "In Explorer`tF6", "BtnPanelManageFoldersExplorer")
   kMenu("PVopenF", "Add", "With a new QPV instance", "BtnPanelManageFoldersNewInstance")
   kMenu("PVopenF", "Add", "Folder properties (Explorer)", "BtnPanelManageFoldersProperties")

   If (folderPath && totalSelected)
   {
      kMenu("PanelDynaMenu", "Add", "&Jump to first indexed file in folder`tEnter", "BtnPanelStaticJumpFirst")
      kMenu("PanelDynaMenu", "Add", "&Rescan folder`tF5", "BTNrescanDynaFolder")
      kMenu("PanelDynaMenu", "Add/UnCheck", "&Recursive folder scan", "BtnToggleRecurseDynaFolder")
      If InStr(r, "R")
         kMenu("PanelDynaMenu", "Check", "&Recursive folder scan")

      Menu, PanelDynaMenu, Add
      kMenu("PanelDynaMenu", "Add", "&Open folder", ":PVopenF")
      kMenu("PanelDynaMenu", "Add", "&Select files`tAlt+L-Click", "BTNselFilesStaticFolder")
      kMenu("PanelDynaMenu", "Add", "&Deselect files`tAlt+R-Click", "BTNunselFilesStaticFolder")
      kMenu("PanelDynaMenu", "Add", "&Remove folder from this list`tDelete", "BTNremDynaSelFolder")
      kMenu("PanelDynaMenu", "Add", "Rename inde&x entry`tF2", "PanelRenameStaticFolder")
      kMenu("PanelDynaMenu", "Add/UnCheck", "Set as the &protected folder", "BtnPanelManageFoldersProtect")
      If (protectedFolderPath=folderPath && preventDeleteFromProtectedPath=1)
         kMenu("PanelDynaMenu", "Check", "Set as the &protected folder")

      kMenu("PanelDynaMenu", "Add", "&Copy this folder path as text", "BTNcopyStaticFolderPath")
      kMenu("PanelDynaMenu", "Add", "&Count indexed files in folder`tF11", "BTNcountFilesDynaFolders")
      kMenu("PanelDynaMenu", "Add", "&Count files in folder found on disk`tF10", "BTNcountFilesDiskDynaFolder")
      Menu, PanelDynaMenu, Add
      kMenu("PanelDynaMenu", "Add", "&Filter list to selected folder`tF3", "MenuFilterListSelectedFolder")
      If markedSelectFile
         kMenu("PanelDynaMenu", "Add/UnCheck", "Deselect all (files &list)", "dropFilesSelection")
   }

   kMenu("PanelDynaMenu", "Add", "&View list as a folders tree", "BTNshowDynamicFoldersInTreeView")
   showThisMenu("PanelDynaMenu")
}

invokePanelReviewSelContextMenu() {
   Try Menu, MenuRevSelFiles, Delete
   Sleep, 2
   Try Menu, PVopenF, Delete
   If (RegExMatch(CurrentSLD, sldsPattern) || InStr(CurrentSLD, "\qpv\favourite-images-list") || InStr(CurrentSLD, "\qpv\viewed-images-history"))
      kMenu("PVopenF", "Add", "Open folder now", "BtnReviewPaneOpenActs")

   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   GuiControlGet, editu, SettingsGUIA:, listViewReviewFilteru

   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderPath, RowNumber, 3)
   Gui, SettingsGUIA: ListView, % whichLV
   totalSelected := LV_GetCount("S")
   total := LV_GetCount()

   kMenu("PVopenF", "Add", "Open folder in &Explorer`tF6", "BtnReviewPaneOpenActs")
   kMenu("PVopenF", "Add", "Open image with a new &QPV instance", "BtnReviewPaneOpenActs")
   kMenu("PVopenF", "Add", "Open image with an e&xternal app", "BtnReviewPaneOpenActs")
   kMenu("PVopenF", "Add", "Folder &properties (Explorer)", "BtnReviewPaneOpenActs")

   Try Menu, PVcopy, Delete
   kMenu("PVcopy", "Add", "Copy f&older path(s) as text", "BTNreviewCopyDirs")
   kMenu("PVcopy", "Add", "Copy &file name(s) as text", "BTNreviewCopyNames")
   kMenu("PVcopy", "Add", "Copy &complete path(s) as text", "BTNreviewCopyPanel")
   Menu, PVcopy, Add, 
   kMenu("PVcopy", "Add", "Cop&y files (Explorer)", "BTNreviewCopyExplorer")
   kMenu("PVcopy", "Add", "Cu&t files (Explorer)", "BTNreviewCutExplorer")
   kMenu("PVcopy", "Add", "Co&py containing folders (Explorer)", "BTNreviewCopyFoldersExplorer")
   kMenu("PVcopy", "Add", "C&ut containing folders (Explorer)", "BTNreviewCutFoldersExplorer")


   If totalSelected
   {
      UIupdateReviewLVinView()
      kMenu("MenuRevSelFiles", "Add", "&Open", ":PVopenF")
      kMenu("MenuRevSelFiles", "Add", "&Copy", ":PVcopy")
      kMenu("MenuRevSelFiles", "Add", "&Select file(s) in index", "BTNreviewApplySelection")
      kMenu("MenuRevSelFiles", "Add", "&Deselect file(s) in index", "BTNreviewRemSelection")
      kMenu("MenuRevSelFiles", "Add", "Select files in &index in same folder", "BTNreviewSelFilesInPath")
      If markedSelectFile
         kMenu("MenuRevSelFiles", "Add", "Select &none in index", "BTNreviewDropFilesSelection")

      If (total!=totalSelected)
         kMenu("MenuRevSelFiles", "Add", "Select entire &table`tCtrl+A", "BTNreviewLVselAll")

      kMenu("MenuRevSelFiles", "Add/UnCheck", "&Filter table to selected path", "BTNreviewFilterLVSelPath")
      If (InStr(folderPath, editu) && OutputVar=1 && editu)
         kMenu("MenuRevSelFiles", "Check", "&Filter table to selected path")

      kMenu("MenuRevSelFiles", "Add", "Filter files &list to selected path`tF3", "BTNreviewFilterListSelPath")
      kMenu("MenuRevSelFiles", "Add", "Modify inde&x entry`tF2", "BtnReviewPaneOpenActs")
   } Else
   {
      kMenu("MenuRevSelFiles", "Add", "No files are selected in the list view", "dummy")
      kMenu("MenuRevSelFiles", "Disable", "No files are selected in the list view")
   }

   Menu, MenuRevSelFiles, Add
   kMenu("MenuRevSelFiles", "Add", "Help`tF1", "BtnHelpReviewPanel")
   showThisMenu("MenuRevSelFiles")
}

BtnHelpStaticFoldersPanel() {
   msgBoxWrapper(appTitle ": HELP", "This panel lists the folders where the indexed files are located; selected and total files are counted per folder. It is useful to:`n `n- update / rescan folders selectively, in order to avoid entire rescans`n `n- facilitate management of large amounts of files`n `n- identify folders with few or many files`n `n- identify per folder missing files, already seen images or favourited images [if these were selected using the appropiate tools before opening this panel]`n `nFolders marked with (*) are changed since the last scan, based on folder modified date. Right-click on listed entries for more options.`n `nWhen you choose to «Erase files from the index»», the files indexed pertaining to the selected folder will be removed ONLY from the index, NOT from the disk.`n`nThe folders can be filtered by selected files (:), percentage (*), files on disk (!), folder size ($), diff (#) or files indexed (?) by typing something like: *>200 or ?<300.", -1, 0, 0)
}

BtnHelpReviewPanel() {
   msgBoxWrapper(appTitle ": HELP", "This panel is meant to help in scenarios where automatically selected files must be filtered out, eg., select already seen images or favourited images. It offers options to help users manage and filter the selected files.", -1, 0, 0)
}

UIlvFilterEraseStaticPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, SettingsGUIA:, StaticListViewFilteru
   If (!OutputVar && !lastFilterEditSearch)
      Return

   lastFilterEditSearch := StaticListViewFilteru := ""
   GuiControl, SettingsGUIA:, StaticListViewFilteru, 
   SetTimer, UIfilterListViewStaticFolderzList, -50
}

PanelKeywordsDetector() {
    Global LViewOthers, listViewFilteru

    thisBtnHeight := createSettingsGUI(71, A_ThisFunc)
    btnWid := 115
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 95
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    totals := newStaticFoldersListCache.Count()
    btnWid2 := (PrefsLargeFonts=1) ? 160 : 95
    btnWid3 := (PrefsLargeFonts=1) ? btnWid + 40 : btnWid + 30
    btnWid4 := (PrefsLargeFonts=1) ? 70 : 60
    sml := (PrefsLargeFonts=1) ? 120 : 90
    CountFilesFolderzList := 0
    Gui, Add, Text, x15 y15, This panel can help identify most used keywords in the indexed files list.
    Gui, Add, ListView, +LV0x10000 +LV0x400 r%uLVr% Grid xp y+10 w%lstWid% AltSubmit +multi gLVkeywordResponder vLViewOthers +hwndhLVmainu, Keywords|Files|`%|#
    Gui, Add, Edit, xs y+10 wp -multi -wantTab +hwndhEditField vkeywrdLVfilter, % keywrdLVfilter

    sml := (PrefsLargeFonts=1) ? 70 : 55
    Gui, Add, Text, xs y+7 hp +0x200, Min. length:
    Gui, Add, Edit, x+5 w%sml% number -multi limit2 veditF5, % minKeywordLength
    Gui, Add, UpDown, vminKeywordLength Range3-25, % minKeywordLength

    Gui, Add, Text, x+10 hp +0x200, Min. files:
    Gui, Add, Edit, x+5 w%sml% number -multi limit3 veditF6, % thresholdKeywords
    Gui, Add, UpDown, vthresholdKeywords Range2-987, % thresholdKeywords
    Gui, Add, Checkbox, x+10 hp Checked%LangKeywordsFilter% vLangKeywordsFilter, Dictionary filter (English)
    Gui, Add, Button, x+1 hp w%sml% Default gUIfilterListKeywords, &Apply
    Gui, Add, Button, x+1 hp w35 gUIremKeywordsFilter hwndhBtnFilterRem, &X
    ToolTip2ctrl(hBtnFilterRem, "Remove the filters [Alt+X]")

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% gBtnUiKeywordsLister w%btnWid2% , &Generate list
    Gui, Add, Button, x+5 hp w80 gBtnCloseWindow, &Close
    Gui, Add, Text, x+7 hp +0x200 vtxtLine1, Keywords omitted: 987 129 millions gazillions

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Keywords list: " appTitle)
    PopulateKeywordsListPanel(keywrdLVfilter)
}

LVkeywordResponder(a,b,c) {
   If (b="RightClick")
   {
      Gui, SettingsGUIA: Default
      Gui, SettingsGUIA: ListView, LViewOthers
      If (LV_GetCount("S")>1 || c="enter")
         filterListByKeywords()
      Else
         invokePrefsPanelsContextMenu()
   } Else If (b="DoubleClick")
      filterListByKeywords()
}

filterListByKeywords() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(keyword, RowNumber, 1)
   ; ToolTip, % folderu "=" colNum "=" RowNumber "=" whichLV , , , 2
   If StrLen(keyword)<3
      Return

   setImageLoading()
   listu := ""
   RowNumber := 0
   total := LV_GetCount()
   Loop, % total
   {
       RowNumber := LV_GetNext(RowNumber)
       If !RowNumber
          Break

       LV_GetText(keyword, RowNumber, 1)
       If !keyword
          Continue

       listu .= StrReplace(Trim(keyword), A_Space, "|") "|"
   }

   listu := StrReplace(Trim(listu, "|"), "||", "|")
   If !listu
      Return

   BtnCloseWindow()
   userFilterStringPos := userFilterWhat := 1
   UsrEditFilter := listu
   userFilterProperty := userFilterDoString := 1
   userFilterInvertThis := userFilterStringIsNot := 0
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   dummyTimerDelayiedImageDisplay(50)
   ; ToolTip, % listu  , , , 2
}

UIremKeywordsFilter() {
   Gui, SettingsGUIA: Default
   keywrdLVfilter := ""
   minKeywordLength := 3
   thresholdKeywords := 2
   LangKeywordsFilter := 0
   GuiControl, SettingsGUIA:, keywrdLVfilter,  % keywrdLVfilter
   GuiControl, SettingsGUIA:, thresholdKeywords,  % thresholdKeywords
   GuiControl, SettingsGUIA:, minKeywordLength,  % minKeywordLength
   GuiControl, SettingsGUIA:, LangKeywordsFilter,  % LangKeywordsFilter
   PopulateKeywordsListPanel(0)
}

UIfilterListKeywords() {
   If (AnyWindowOpen!=71)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, keywrdLVfilter
   If (imageLoading=1)
      Return

   PopulateKeywordsListPanel(keywrdLVfilter)
}

BtnUiKeywordsLister() {
   EM_SETCUEBANNER(hEditField, "Generating keywords list - please wait", 0)
   GenerateKeywordsListNow()
   PopulateKeywordsListPanel()
}


PopulateKeywordsListPanel(listFilter:=0) {
  Static dictionary := [], prevLang := 0

  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewOthers
  GuiControlGet, thresholdKeywords
  GuiControlGet, minKeywordLength
  GuiControlGet, LangKeywordsFilter
  GuiControl, -Redraw, LViewOthers
  setImageLoading()
  showTOOLtip("Preparing the dictionary, please wait")
  If (LangKeywordsFilter=1 && prevLang!=LangKeywordsFilter)
  {
     ; i intended to add more languages/dictionaries
     dictionary := new hashtable()
     prevLang := LangKeywordsFilter
     FileRead, dictum, % mainCompiledPath "\resources\dict-eng.txt"
     Loop, Parse, dictum, `n,`r
     {
        If A_LoopField
           dictionary[A_LoopField] := 1
     }
  }

  showTOOLtip("Populating the list view, please wait")
  EM_SETCUEBANNER(hEditField, "Preparing keywords list - please wait", 0)
  LV_Delete()
  LV_ModifyCol(2, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  thisString := StrReplace(Trimmer(listFilter), "||", "|")
  thisString := Trimmer(thisString, "|")
  thisFilter := "i)(" JEE_StrRegExLiteral(thisString) ")"
  isStrFilter := StrLen(thisString)>1 ? 1 : 0
  FilterSimple := (InStr(thisString, "|") || InStr(thisString, "*") || InStr(thisString, "?")) ? 0 : 1
  rowsCounter := counter := skippedFiles := wordSkipped := 0
  maxu := StrLen(filesFilter)>1 ? bckpMaxFilesIndex : maxFilesIndex
  newArrayu := []
  doStartLongOpDance()
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  thisMaxCount := keywordsListArray.Count()
  For Key, Value in keywordsListArray
  {
     executingCanceableOperation := A_TickCount
     If (determineTerminateOperation()=1)
     {
        abandonAll := 1
        Break
     }
 
     If (A_TickCount - prevMSGdisplay>1000)
     {
        etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
        showTOOLtip("Filtering the keywords list, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
        prevMSGdisplay := A_TickCount
     }
 
     If (Value>=thresholdKeywords && !isInRange(Value, maxFilesIndex - 1, maxFilesIndex) && StrLen(Key)>=minKeywordLength)
     {
        If (isStrFilter=1 && FilterSimple=1)
        {
           If !inStr(Key, thisString)
           {
              wordSkipped++
              skippedFiles += Value
              Continue
           }
        } Else If (isStrFilter=1)
        {
           If !RegExMatch(Key, thisFilter)
           {
              wordSkipped++
              skippedFiles += Value
              Continue
           }
        }

        If (LangKeywordsFilter=1)
        {
           doXtra := StrLen(key)
           If !dictionary[Key]
           {
              If (doXtra>4)
              {
                 isOkay := 1
                 a := SubStr(key, 1, doXtra - 1)
                 b := SubStr(key, 2, doXtra - 1)
                 c := SubStr(key, 2)
                 If (!dictionary[a] && !dictionary[b] && !dictionary[c])
                    isOkay := 0

                 If (doXtra>7 && isOkay=1)
                 {
                    a := SubStr(key, doXtra//2)
                    b := SubStr(key, 1, doXtra//2)
                    If (!dictionary[a] && !dictionary[b])
                       isOkay := 0
                 } Else isOkay := 0
              } Else isOkay := 0

              If !isOkay
              {
                 wordSkipped++
                 skippedFiles += Value
                 Continue
              }
           }
        }

        counter++
        thisKey := (userPrivateMode=1) ? "*****" : Key
        perc := Value ? Round((Round(Value)/maxu)*100, 1) : 0
        If (!newArrayu[Value, 1] || newArrayu[Value, 3]>5 || mergeKeywordRows!=1)
        {
           rowsCounter++
           newArrayu[Value] := [rowsCounter, thisKey, 1]
           LV_Add(A_Index, thisKey, Value, perc, A_Index)
        } Else
        {
           newArrayu[Value, 2] := newArrayu[Value, 2] A_Space thisKey
           newArrayu[Value, 3] := newArrayu[Value, 3] + 1
           LV_Modify(newArrayu[Value, 1], "Col1", newArrayu[Value, 2])
        }
     } Else
     {
        wordSkipped++
        skippedFiles += Value
     }
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Left")

  fperc := Round((skippedFiles/maxu)*100, 1)
  wperc := Round((wordSkipped/keywordsListArray.Count())*100, 1)
  GuiControl, SettingsGUIA:, txtLine1, % "Keywords omitted: " groupDigits(wordSkipped) " ( " wperc "% )"
  LV_ModifyCol(2, "SortDesc")
  EM_SETCUEBANNER(hEditField, groupDigits(counter) " keywords are listed", 0)
  GuiControl, +Redraw, LViewOthers
  ResetImgLoadStatus()
  RemoveTooltip()
}

GenerateKeywordsListNow() {
   ; keywordsListArray := ""
   keywordsListArray := new hashtable()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   Loop, % maxFilesIndex + 1
   {
        thisIndexu := A_Index
        imgPath := resultedFilesList[A_Index, 1]
        If (InStr(imgPath, "||") || !imgPath)
           Continue

        changeMcursor()
        OutDir := Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, ".", 0, -1) - 1))
        OutDir := RegExReplace(OutDir, "[[:digit:]]", A_Space)
        OutDir := RegExReplace(OutDir, "[[:punct:]]", A_Space)
        OutDir := RegExReplace(OutDir, "[[:blank:]]", A_Space)
        OutDir := StrReplace(OutDir, "  ", A_Space)
        thisArray := StrSplit(OutDir, A_Space)
        Loop, % thisArray.Count()
        {
           thisu := thisArray[A_Index]
           If (StrLen(thisu)<3)
              Continue

           keywordsListArray[thisu] := Round(keywordsListArray[thisu]) + 1
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
           showTOOLtip("Generating folders list based on the indexed files" etaTime, 0, 0, A_Index/maxFilesIndex)
           prevMSGdisplay := A_TickCount
        }
   }

   ResetImgLoadStatus()
   RemoveTooltip()
}

PanelStaticFolderzManager() {
    Global LViewOthers, listViewFilteru
    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    isUpdateList := (FileExist(CurrentSLD) && RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? 1 : 0
    thisBtnHeight := createSettingsGUI(2, A_ThisFunc)
    btnWid := 115
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 95
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    totals := newStaticFoldersListCache.Count()
    btnWid2 := (PrefsLargeFonts=1) ? 160 : 95
    btnWid3 := (PrefsLargeFonts=1) ? btnWid + 40 : btnWid + 30
    btnWid4 := (PrefsLargeFonts=1) ? 70 : 60
    sml := (PrefsLargeFonts=1) ? 120 : 90
    CountFilesFolderzList := 0
    Gui, Add, Text, x15 y15, This folders list was generated based on the indexed files. Multiple items can be selected.
    Gui, Add, ListView, +LV0x10000 +LV0x400 r%uLVr% Grid xp y+10 w%lstWid% +multi AltSubmit Count%totals% guiLVfolderzFilterListBTN vLViewOthers +hwndhLVmainu, #|Date|-?-|Folder path|Files|Selected|`%|Files on disk|Difference|Size (MB)
    Gui, Add, Edit, xs y+10 wp-%sml% -multi -wantTab gUIeditsGenericAllowCtrlBksp +hwndhEditField vStaticListViewFilteru, % staticListViewFilteru

    sml := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+1 hp w%sml% gUIeditApplyStaticFolderFilter Default, &Apply
    Gui, Add, Button, x+1 hp w35 gUIlvFilterEraseStaticPanel hwndhBtnFilterRem, &X
    ToolTip2ctrl(hBtnFilterRem, "Remove list filter [Alt+X]")
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid2% gBTNupdateSelectedStaticFolder, &Rescan folder(s)

    If isUpdateList
       Gui, Add, Button, x+5 hp w%btnWid% gBTNignoreDateStaticFolder, I&gnore all changes
    Gui, Add, Button, x+5 hp w%btnWid3% gRegenerateEntireList, R&egenerate entire index
    Gui, Add, Button, x+5 hp w%btnWid4% ginvokePanelStaticFoldersContextMenu, &More
    labelu := isUpdateList ? "Cached folders list: " : "Static folders list: "
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, labelu appTitle)
    Sleep, 25
    thisList := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
    If (newStaticFoldersListCache.Count()>0 && markedSelectFile>1 && thisList!=iduStaticFoldersListCache)
       countAllFilesPerStaticFolders("start")
    PopulateStaticFolderzList(staticListViewFilteru, "init")
}

PanelReviewSelectedFiles() {
    Global LViewOthers

    getSelectedFiles(0, 1)
    If !markedSelectFile
    {
       showTOOLtip("WARNING: There are no selected files to review.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(60, A_ThisFunc)
    Global LViewFiltered
    btnWid := 65
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 30
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    listViewReviewFilteru := ""
    edithu := lstWid - btnWid - 35
    hum := (PrefsLargeFonts=1) ? 85 : 45
    addCol := testIsDupesList() ? "|Dupe ID" : ""
    Gui, Add, Text, x15 y15 w%lstWid%, This list allows multiple items to be selected. The actions available in the context menu or below will be applied on the selected items.
    Gui, Add, ListView, +LV0x10000 +LV0x400 +ReadOnly -WantF2 y+10 wp AltSubmit Count%markedSelectFile% gBTNreviewPaneLV r%uLVr% Grid vLViewOthers +hwndhLVmainu, S|File name|Folder path|#%addCol%
    Gui, Add, ListView, +LV0x10000 +LV0x400 +ReadOnly -WantF2 xp yp wp hp AltSubmit Count%markedSelectFile% gBTNreviewPaneLV r%uLVr% Grid vLViewFiltered, S|*File name|*Folder path|#%addCol%
    Gui, Add, Edit, xs y+10 w%edithu% -multi gUIeditsGenericAllowCtrlBksp +hwndhEditField vlistViewReviewFilteru, % listViewReviewFilteru
    Gui, Add, Button, x+1 hp w%btnWid% gUIeditApplyFilterReviewPanel Default, &Apply
    Gui, Add, Button, x+1 hp w35 gUIstringEditFilterErase hwndhBtnFilterRem, &X
    ToolTip2ctrl(hBtnFilterRem, "Remove list filter [Alt+X]")

    Gui, Add, Button, xs+0 y+15 h%thisBtnHeight% w%btnWid% gBTNreviewApplySelection, &Select
    Gui, Add, Button, x+5 hp wp gBTNreviewRemSelection , &Deselect
    Gui, Add, Button, x+5 hp wp gBTNreviewDropFilesSelection, &None
    Gui, Add, Button, x+5 hp wp gBTNrefreshReviewPanel , &Refresh
    Gui, Add, Button, x+5 hp wp ginvokePanelReviewSelContextMenu , &More
    Gui, Add, Button, x+5 hp wp gBtnReviewSelClose, C&lose
    Gui, Add, Text, xs y+10 vinfoLine w%lstWid% +0x200, Listing items`, please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Review selected files: " appTitle)
    Sleep, 5
    reviewSelectedIndexes := []
    Loop, % maxFilesIndex
    {
        If resultedFilesList[A_Index, 2]
        {
           thisCounter++
           reviewSelectedIndexes[thisCounter] := [A_Index, 0]
        }
    }

    PopulateReviewSelectedFiles("init")
}

BtnReviewSelClose() {
   reviewSelectedIndexes := []
   BtnCloseWindow()
}

BTNreviewDropFilesSelection() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   RowNumber := 0
   GuiControlGet, listViewReviewFilteru
   modus := markedSelectFile ? 0 : 1
   If listViewReviewFilteru
   {
      LV_GetText(thisFileIndex, RowNumber + 1, 3)
      modus := resultedFilesList[thisFileIndex, 2] ? 0 : 1
      ; ToolTip, % thisFileIndex "===" isSelected "===" modus , , , 2
   }

   modusa := !modus ? "_" : "S"
   Loop
   {
       RowNumber++
       LV_GetText(thisFileIndex, RowNumber, 4)
       If !thisFileIndex
          Break

       resultedFilesList[thisFileIndex, 2] := modus
       LV_Modify(RowNumber, , modusa)
   }

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   dummyTimerDelayiedImageDisplay(50)
}

BTNreviewApplySelection() {
   BTNreviewToggleSelection(1)
}

BTNreviewRemSelection() {
   BTNreviewToggleSelection(0)
}

BTNreviewCopyNames() {
   BTNreviewCopyPanel("files")
}

BTNreviewCopyDirs() {
   BTNreviewCopyPanel("dirs")
}

BTNreviewCopyExplorer() {
   BTNreviewCopyPanel(0, "copy")
}

BTNreviewCutExplorer() {
   BTNreviewCopyPanel(0, "cut")
}

BTNreviewCopyFoldersExplorer() {
   BTNreviewCopyPanel("dirs", "copy")
}

BTNreviewCutFoldersExplorer() {
   BTNreviewCopyPanel("dirs", "cut")
}

BTNreviewFilterListSelPath() {
   dropFilesSelection()
   BTNreviewSelFilesInPath()
   If (markedSelectFile>1)
   {
      BtnCloseWindow()
      filterToFilesSelection()
   }
}

BTNreviewSelFilesInPath() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   RowNumber := 0
   RowNumber := LV_GetNext(RowNumber, "F")
   LV_GetText(thisFileIndex, RowNumber, 4)
   QuickSelectFilesSameFolder(resultedFilesList[thisFileIndex, 1], "aye")
}

BtnReviewPaneOpenActs(a:=0, b:=0, c:=0) {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV

   RowNumber := 0
   RowNumber := LV_GetNext(RowNumber, "F")
   LV_GetText(thisFileIndex, RowNumber, 4)
   currentFileIndex := thisFileIndex
   imgPath := resultedFilesList[thisFileIndex, 1]
   zPlitPath(imgPath, 1, OutFileName, OutDir)
   ; TulTip(0, "=", a, b, c, thisFileIndex)
   dummyTimerDelayiedImageDisplay(25)
   a := StrReplace(a, "&")
   If InStr(a, "folder now")
   {
      BtnCloseWindow()
      OpenQPVfileFolder()
   } Else If InStr(a, "external app")
   {
      lastOtherWinClose := 1
      InvokeOpenWithMenu(imgPath, 1)
   } Else If InStr(a, "modify")
   {
      BtnCloseWindow()
      PanelUpdateThisFileIndex("reviewer")
   } Else If InStr(a, "new QPV instance")
      SoloNewQPVinstance()
   Else If InStr(a, "in explorer")
      OpenThisFileFolder()
   Else If InStr(a, "properties")
      invokeStandardFolderProperties(OutDir)
}

BTNreviewFilterLVSelPath() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   RowNumber := 0
   RowNumber := LV_GetNext(RowNumber, "F")
   LV_GetText(thisFileIndex, RowNumber, 4)
   imgPath := resultedFilesList[thisFileIndex, 1]
   zPlitPath(imgPath, 1, OutFileName, OutDir)
   GuiControl, SettingsGUIA:, listViewReviewFilteru, % OutDir
   UIeditApplyFilterReviewPanel()
}

BTNreviewCopyPanel(modus:=0, extras:=0) {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   counter := RowNumber := 0
   listu := ""
   newArrayu := []
   useArray := (extras="cut" || extras="copy") ? 1 : 0

   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalSelected := LV_GetCount("Selected") + 1
   itemsList := new hashtable()
   Loop, % totalSelected
   {
       RowNumber := LV_GetNext(RowNumber)
       If (determineTerminateOperation()=1 || !RowNumber)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalSelected, startOperation)
          showTOOLtip("Processing the list to copy selected items" etaTime, 0, 0, A_Index/totalSelected)
          prevMSGdisplay := A_TickCount
       }

       LV_GetText(thisFileIndex, RowNumber, 4)
       If !thisFileIndex
          Continue

       imgPath := StrReplace(resultedFilesList[thisFileIndex, 1], "||")
       If imgPath
       {
          If (modus="dirs")
             zPlitPath(imgPath, 1, OutFileName, imgPath)
          Else If (modus="files")
             zPlitPath(imgPath, 1, imgPath, OutDir)

          If (modus="dirs" || modus="files")
          {
             t := Format("{:L}", imgPath)
             If itemsList[t]
                Continue

             itemsList[t] := 1
          }

          counter++
          If (useArray=1)
             newArrayu[counter] := imgPath
          Else
             listu .= imgPath "`n"
       }
   }

   itemsList := ""
   If (useArray=1 && counter>0)
   {
      destroyGDIfileCache()
      folderMode := (modus="dirs") ? 1 : 0
      dataHandle := ClipboardSetFiles(newArrayu, extras, folderMode)
      Sleep, 5
      testClipType := IsClipboardFormatAvailable(15)
      If (testClipType!=1 || !dataHandle)
      {
         showTOOLtip("ERROR: Failed to set the clipboard")
         SoundBeep 300, 100
      } Else
      {
         showTOOLtip(Format("{:U}", extras) " action: " groupDigits(counter) " items can now be pasted in any file manager or in QPV")
         SoundBeep 900, 100
      }
      SetTimer, RemoveTooltip, % -msgDisplayTime
      ResetImgLoadStatus()
      Return
   }

    If !listu
       Return

    Try Clipboard := listu
    Catch wasError
          Sleep, 1

    thisu := (modus="dirs") ? "containing folders" : "complete paths"
    If (modus="files")
       thisu := "file names"

    If wasError
    {
       showTOOLtip("Failed to copy to clipboard as text the selected " thisu)
       SoundBeep , 300, 100
    } Else
       showTOOLtip(groupDigits(counter) " selected " thisu " copied to clipboard as text")

    ResetImgLoadStatus()
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

UIupdateReviewLVinView() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   If OutputVar
      Return

   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_EX_GetTopIndex(hLVmainu)
   If (RowNumber<1 || !RowNumber)
      RowNumber := 1

   Loop, 18
   {
       RowNumber++
       LV_GetText(thisFileIndex, RowNumber, 4)
       sel := resultedFilesList[thisFileIndex, 2] ? "S" : "_"
       LV_Modify(RowNumber, "Col1" , sel)
   }
}

BTNreviewToggleSelection(modus:=0) {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   RowNumber := 0
   totalSelected := LV_GetCount("Selected") + 1
   Loop, % totalSelected
   {
       RowNumber := LV_GetNext(RowNumber)
       If (determineTerminateOperation()=1 || !RowNumber)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalSelected, startOperation)
          showTOOLtip("Updating files selection, please wait" etaTime, 0, 0, A_Index/totalSelected)
          prevMSGdisplay := A_TickCount
       }

       LV_GetText(thisFileIndex, RowNumber, 4)
       oSel := resultedFilesList[thisFileIndex, 2]
       sel := (modus>1) ? !oSel : modus
       resultedFilesList[thisFileIndex, 2] := sel
       ; sel := (oSel && !sel) ? 0 : 1
       If (oSel=sel)
          Continue
 
       If sel
       {
          LV_Modify(RowNumber, , "S")
          markedSelectFile++
       } Else
       {
          LV_Modify(RowNumber, , "_")
          markedSelectFile--
       }
   }

   RemoveTooltip()
   lastZeitFileSelect := A_TickCount
   dummyTimerDelayiedImageDisplay(50)
   ResetImgLoadStatus()
}

BTNreviewLVselAll() {
   Gui, SettingsGUIA: Default
   If (AnyWindowOpen=2)
   {
      Gui, SettingsGUIA: ListView, LViewOthers
   } Else
   {
      GuiControlGet, OutputVar, Visible, LViewFiltered
      whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
      Gui, SettingsGUIA: ListView, % whichLV
   }
   ToolTip, Selecting all the items in list
   loopsOccured := RowNumber := 0
   LV_Modify(0, "+Select")
   ToolTip
}

UIstringEditFilterErase() {
   If (AnyWindowOpen=49)
   {
      dupesStringFilter := ""
      GuiControl, SettingsGUIA:, dupesStringFilter, 
   } Else If (AnyWindowOpen=62)
   {
      UserHamDistStringFilter := ""
      GuiControl, SettingsGUIA:, UserHamDistStringFilter, 
   } Else If (AnyWindowOpen=60)
   {
      listViewReviewFilteru := ""
      GuiControl, SettingsGUIA:, listViewReviewFilteru, 
      fn := Func("PopulateReviewSelectedFiles").Bind("back")
      SetTimer, % fn, -250
   }
}

BTNreviewPaneLV(a:=0, b:=0, c:=0) {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV

   totalListed := LV_GetCount()
   topIndex := LV_EX_GetTopIndex(hLVmainu)
   totalIndex := reviewSelectedIndexes.Count()
   isInputOkay := (b="s" || b="k" && (c=40 || c=35 || c=34)) ? 1 : 0
   If (whichLV="LViewOthers" && (topIndex>totalListed - 25) && totalIndex>LVitemsPerPage && isInputOkay=1 && reviewSelectedIndexes[1, 2]!=2)
   {
      SetTimer, dummyPopulateReviewSelectedFiles, -250
      ToolTip, List view will further be populated
      Return
   }
   ; If (b="k")
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(indexu, RowNumber, 4)
   ;    TulTip(0, "=", a, b, c, indexu, RowNumber)

   If (b="K" && c=112) ; F1
   {
      BtnHelpReviewPanel()
      Return
   } Else If (b="K" && c=113) ; F2
   {
      BtnCloseWindow()
      currentFileIndex := indexu
      PanelUpdateThisFileIndex("reviewer")
      Return
   } Else If (b="K" && c=114) ; F3
   {
      BTNreviewFilterListSelPath()
      Return
   } Else If (b="K" && c=116) ; F5
   {
      BTNrefreshReviewPanel()
      Return
   } Else If (b="K" && c=117) ; F6
   {
      BtnReviewPaneOpenActs()
      Return
   } Else If (b!="DoubleClick")
      Return

   BtnCloseWindow()
   currentFileIndex := indexu
   dummyTimerDelayiedImageDisplay(50)
}

BTNrefreshReviewPanel() {
   BtnCloseWindow()
   PanelReviewSelectedFiles()
}

UIeditApplyFilterReviewPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, listViewReviewFilteru
   Tooltip
   If StrLen(Trimmer(listViewReviewFilteru))<2
   {
      UIstringEditFilterErase()
   } Else
   {
      lastFilterEditSearch := Trimmer(listViewReviewFilteru)
      SetTimer, PopulateReviewSelectedFiles, -50
   }
}

dummyPopulateReviewSelectedFiles() {
    If determineLClickstate()
       SetTimer, % A_ThisFunc, -350
    Else
       SetTimer, PopulateReviewSelectedFiles, -350
}

PopulateReviewSelectedFiles(modus:="") {
    Static initTotals := 0, lastSearch := 0, listedEntries := 0
    If (AnyWindowOpen!=60)
       Return

    Tooltip
    Gui, SettingsGUIA: Default
    GuiControlGet, listViewReviewFilteru
    thisString := StrReplace(Trimmer(listViewReviewFilteru), "||", "|")
    thisString := Trimmer(thisString, "|")
    thisFilter := processSearchIndexString(thisString)
    isStrFilter := StrLen(thisString)>1 ? 1 : 0
    FilterSimple := (InStr(thisString, "|") || InStr(thisString, "/") || InStr(thisString, ">") || InStr(thisString, "?")) ? 0 : 1

    whichLV := (isStrFilter=1) ? "LViewFiltered" : "LViewOthers"
    Gui, SettingsGUIA: ListView, % whichLV
    If (whichLV="LViewFiltered")
    {
       listedEntries := LV_GetCount()
       GuiControl, SettingsGUIA: Hide, LViewOthers
       GuiControl, SettingsGUIA: Show, LViewFiltered
       thisSearch := thisFilter thisString initTotals maxFilesIndex CurrentSLD
       If (thisSearch=lastSearch && listedEntries)
       {
          GuiControl, SettingsGUIA:, infoLine, % "Filtered table: " groupDigits(listedEntries) " / " groupDigits(initTotals) " (" Round(listedEntries/initTotals*100, 2) "%)"
          Return
       }
    } Else
    {
       GuiControl, SettingsGUIA: Hide, LViewFiltered
       GuiControl, SettingsGUIA: Show, LViewOthers
       If (modus="back")
       {
          UIupdateReviewLVinView()
          totalSelected := reviewSelectedIndexes.Count()
          percu := Round(LV_GetCount()/totalSelected*100, 2)
          if (percu=100)
             GuiControl, SettingsGUIA:, infoLine, % "Entries listed: " groupDigits(LV_GetCount())
          Else
             GuiControl, SettingsGUIA:, infoLine, % "Entries listed: " groupDigits(LV_GetCount()) " / " groupDigits(totalSelected) " (" percu "%)"
          Return
       }
    }

    doStartLongOpDance()
    If (whichLV="LViewFiltered")
       LV_Delete()

    LV_ModifyCol(4, "Integer")
    LV_ModifyCol(5, "Integer")
    GuiControl, SettingsGUIA:, infoLine, Listing items`, please wait...
    GuiControl, -Redraw, % whichLV
    EM_SETCUEBANNER(hEditField, "Populating the list view - please wait", 0)
    thisCounter :=  hasAutoSized := 0
    prevMSGdisplay := A_TickCount
    startOperation := A_TickCount
    isDupesList := testIsDupesList()
    totalSelected := reviewSelectedIndexes.Count()
    preventAutoSize := 0
    Loop, % totalSelected
    {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (reviewSelectedIndexes[A_Index, 2] && whichLV="LViewOthers")
        {
           preventAutoSize := 1
           Continue
        }

        thisIndex := reviewSelectedIndexes[A_Index, 1]
        If (whichLV="LViewOthers")
           reviewSelectedIndexes[A_Index, 2] := 1

        If (isStrFilter=1 && FilterSimple=1)
        {
           If !inStr(resultedFilesList[thisIndex, 1], thisString)
              Continue
        } Else If (isStrFilter=1)
        {
           If !coreSearchIndex(resultedFilesList[thisIndex, 1], thisFilter, 1, 0)
              Continue
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, totalSelected, startOperation)
           showTOOLtip("Populating list view, please wait" etaTime, 0, 0, A_Index/totalSelected)
           prevMSGdisplay := A_TickCount
        }

        If (whichLV!="LViewOthers")
           listedEntries++
        thisCounter++
        isSelected := resultedFilesList[thisIndex, 2] ? "S" : "_"
        zPlitPath(resultedFilesList[thisIndex, 1], 1, OutFileName, OutDir)
        OutDir := (userPrivateMode=1) ? "*:\****\***\" : OutDir
        OutFileName := (userPrivateMode=1) ? "*****.***" : OutFileName
        If (A_Index=totalSelected && whichLV="LViewOthers")
           reviewSelectedIndexes[1, 2] := 2

        If isDupesList
           LV_Add(A_Index, isSelected, OutFileName, OutDir, thisIndex, resultedFilesList[thisIndex, 23])
        Else
           LV_Add(A_Index, isSelected, OutFileName, OutDir, thisIndex)

        If ((A_Index=5 || A_Index=10) && preventAutoSize!=1)
        {
           hasAutoSized := 1
           Loop, 5
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }

        If ((A_TickCount - startOperation)>3500 && thisCounter>=LVitemsPerPage && whichLV="LViewOthers")
        {
           LVitemsPerPage := thisCounter
           Break
        }
    }

    If (!hasAutoSized && !preventAutoSize)
    {
       Loop, 5
           LV_ModifyCol(A_Index, "AutoHdr Left")
    }

    GuiControl, +Redraw, % whichLV
    If (whichLV="LViewOthers")
    {
       initTotals := reviewSelectedIndexes.Count()
       If (modus="init")
          lastSearch := listedEntries := 0
       Else
          UIupdateReviewLVinView()

       percu := Round(LV_GetCount()/totalSelected*100, 2)
       if (percu=100)
          GuiControl, SettingsGUIA:, infoLine, % "Entries listed: " groupDigits(LV_GetCount())
       Else
          GuiControl, SettingsGUIA:, infoLine, % "Entries listed: " groupDigits(LV_GetCount()) " / " groupDigits(totalSelected) " (" percu "%)"
    } Else
    {
       listedEntries := LV_GetCount()
       lastSearch := thisFilter thisString initTotals maxFilesIndex CurrentSLD
       GuiControl, SettingsGUIA:, infoLine, % "Filtered table: " groupDigits(listedEntries) " / " groupDigits(initTotals) " (" Round(listedEntries/initTotals*100, 2) "%)"
    }

    RemoveTooltip()
    SetTimer, ResetImgLoadStatus, -100
    EM_SETCUEBANNER(hEditField, "Filter files list", 0)
}

PanelDynamicFolderzWindow(dummy:=0) {
    Static LViewDynas, hasWarned := 0
    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    If (userPrivateMode=1 && hasWarned!=1)
    {
       msgBoxWrapper(appTitle ": WARNING", "QPV is currently in private mode, hiding all file paths and images, for privacy.`n `nWARNING: This panel MALFUNCTIONS in private mode. Proceed with care.", 0, 0, "exclamation")
       hasWarned := 1
    }

    thisBtnHeight := createSettingsGUI(3, A_ThisFunc)
    btnWid := 120
    txtWid := 360
    lstWid := 535
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 175
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    Gui, Add, Text, x15 y15, This folders list is used to generate the files list index.
    Gui, Add, ListView, y+10 w%lstWid% +LV0x10000 r%uLVr% Grid +LV0x400 guiLVfolderzFilterListBTN -multi AltSubmit vLViewDynas +hwndhLVmainu, #|(?)|Folder path|Files|Selected|`%|Files on disk|Difference|Size (MB)

    btnWid2 := (PrefsLargeFonts=1) ? 95 : 60
    btnWid3 := (PrefsLargeFonts=1) ? 120 : 90
    If (dummy="reopen")
    {
       Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w60 gPanelSaveSlideShowu, &Back
       Gui, Add, Button, x+5 hp wp gBTNaddNewFolder2list, &Add
    } Else
       Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w60 gBTNaddNewFolder2list, &Add
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNremDynaSelFolder, &Remove
    Gui, Add, Button, x+5 hp wp+30 gRegenerateEntireList, R&escan all
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNcopyDynaFoldersList, &Copy list
    Gui, Add, Button, x+5 hp wp+5 gBTNpasteDynaFoldersList, &Paste list
    Gui, Add, Button, x+5 hp wp+5 ginvokePanelDynaFoldersContextMenu, &More
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Manage folders list: " appTitle)
    Sleep, 25
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")
    PopulateDynamicFolderzList()
}

ToggleCountFilesFoldersList() {
  GuiControlGet, CountFilesFolderzList
  If (AnyWindowOpen=3)
     PanelDynamicFolderzWindow()
  Else If (AnyWindowOpen=2)
     PanelStaticFolderzManager()
}

BTNaddNewFolder2list() {
    BtnCloseWindow()
    Sleep, 10
    r := addNewFolder2list()
    Sleep, 10
    SetTimer, PanelDynamicFolderzWindow, -50
}

BTNignoreDateStaticFolder(dummy:=0) {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, 1)
    folderu := newStaticFoldersListCache[indexu, 1]
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded!=3)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
          Return
       }
    }

    setImageLoading()
    total := LV_GetCount()
    totalSelected := LV_GetCount("S")
    doAll := (totalSelected>=total || dummy="update-all") ? 1 : 0
    iF (doAll!=1)
    {
       indexu := RowNumber := 0
       Loop, % total
       {
          RowNumber := LV_GetNext(RowNumber)
          If !RowNumber
             Break

          LV_GetText(indexu, RowNumber, 1)
          If !indexu
             Continue

          folderu := newStaticFoldersListCache[indexu, 1]
          If FolderExist(folderu)
          {
             FileGetTime, dirDateO, % folderu, M
             newStaticFoldersListCache[indexu, 2] := dirDateO
             FormatTime, dirDate, % dirDateO, yyyy/MM/dd
             LV_Modify(RowNumber, "Col3", "")
             LV_Modify(RowNumber, "Col2", dirDate)
          }
       }
    } Else 
    {
       BtnCloseWindow()
       Loop, % newStaticFoldersListCache.MaxIndex()
       {
          folderu := newStaticFoldersListCache[A_Index, 1]
          If FolderExist(folderu)
          {
             FileGetTime, dirDateO, % folderu, M
             newStaticFoldersListCache[A_Index, 2] := dirDateO
          }
       }
    }
    If (SLDtypeLoaded=3)
       SQLDBdumpStaticFoldersList()

    ResetImgLoadStatus()
    showTOOLtip("Folders list information updated")
    If !AnyWindowOpen
    {
       SoundBeep 900, 100
       SetTimer, PanelStaticFolderzManager, -350
    }
    SetTimer, RemoveTooltip, % -msgDisplayTime
    Sleep, 1
}

BTNcopyStaticFolderPath() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    colNum := (AnyWindowOpen=3) ? 3 : 1
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(folderu, RowNumber, colNum)
    If (AnyWindowOpen=2)
       folderu := newStaticFoldersListCache[folderu, 1]

    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (AnyWindowOpen=2)
    {
       counter := indexu := RowNumber := 0
       total := LV_GetCount()
       foldersListArray := ""
       Loop, % total
       {
          RowNumber := LV_GetNext(RowNumber)
          If !RowNumber
             Break

          LV_GetText(indexu, RowNumber, colNum)
          If !indexu
             Continue

          folderu := newStaticFoldersListCache[indexu, 1]
          If folderu
          {
             counter++
             foldersListArray .= folderu
          }
       }

       If (counter<1)
          Return
    } Else counter := 1

    Try Clipboard := (AnyWindowOpen=2) ? foldersListArray : folderu
    Catch wasError
          Sleep, 1

    If wasError
    {
       showTOOLtip("Failed to copy the folder path(s) to clipboard as text")
       SoundBeep , 300, 100
    } Else
       showTOOLtip(groupDigits(counter) " folder path(s) copied to clipboard as text")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNcopyAllStaticFolderPaths() {
    counter := 0
    Loop, % newStaticFoldersListCache.MaxIndex()
    {
       counter++
       finalListu .= newStaticFoldersListCache[A_Index, 1] "`n"
    }

    If !counter
       Return

    Try Clipboard := finalListu
    Catch wasError
          Sleep, 1

    If wasError
    {
       showTOOLtip("Failed to copy the folder paths to clipboard as text")
       SoundBeep , 300, 100
    } Else
       showTOOLtip(groupDigits(counter) " folder paths are copied to clipboard as text")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNshowStaticFoldersInTreeView() {
    Loop, % newStaticFoldersListCache.MaxIndex()
          finalListu .= newStaticFoldersListCache[A_Index, 1] "`n"

    BtnCloseWindow()
    ; PanelFoldersTree()
    FolderTreeRepopulate("given", finalListu)
}

BTNshowDynamicFoldersInTreeView() {
    foldersListu := getDynamicFoldersList()
    Loop, Parse, foldersListu, `n
    {
        fileTest := StrReplace(Trimmer(A_LoopField), "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= fileTest "`n"
    }
    If !newFoldersList
       Return

    BtnCloseWindow()
    ; PanelFoldersTree()
    FolderTreeRepopulate("given", newFoldersList)
}

BTNremFilesStaticFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, 1)
    folderu := newStaticFoldersListCache[indexu, 1]
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    msgResult := msgBoxWrapper(appTitle ": Remove files by folder", "Please confirm that you want to remove the files from the index pertaining to the selected folder(s).", 4, 0, "question")
    If (msgResult="yes")
    {
       Sleep, 10
       Gui, SettingsGUIA: Default
       Gui, SettingsGUIA: ListView, LViewOthers
       indexu := RowNumber := 0
       total := LV_GetCount()
       foldersListArray := new hashtable()
       ; ToolTip, % indexu "=" RowNumber "=" total , , , 2
       Loop, % total
       {
          RowNumber := LV_GetNext(RowNumber)
          If !RowNumber
             Break

          LV_GetText(indexu, RowNumber, 1)
          If !indexu
             Continue

          folderu := Format("{:L}", newStaticFoldersListCache[indexu, 1])
          If folderu
             foldersListArray[folderu] := indexu
       }

       r := 0
       If (foldersListArray.Count()>0)
       {
          r := 1
          BtnCloseWindow()
          For foldar, Value in foldersListArray
          {
             If (maxFilesIndex>1)
             {
                r := coreRemFilesStaticFolder(foldar, "|")
                newStaticFoldersListCache[Value, 4] := 0
                newStaticFoldersListCache[Value, 3] := 0
             }
          }
       }

       foldersListArray := ""
       Sleep, 10
       If r
          PanelStaticFolderzManager()
    } Else Return
}

BTNunselFilesStaticFolder() {
   BTNselFilesStaticFolder("desel")
}

BTNselFilesStaticFolder(modus:=0) {
   whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, % whichLV
   colNum := (AnyWindowOpen=3) ? 3 : 1
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderu, RowNumber, colNum)
   If (AnyWindowOpen=2)
      folderu := newStaticFoldersListCache[folderu, 1]

   ; ToolTip, % folderu "=" colNum "=" RowNumber "=" whichLV , , , 2
   If (StrLen(folderu)<3 || folderu="folder path")
      Return

   ToolTip, Selecting matching files
   setImageLoading()
   If (AnyWindowOpen=2)
   {
      ; static folders panel
      indexu := RowNumber := 0
      total := LV_GetCount()
      foldersListArray := new hashtable()
      foldersSelListArray := new hashtable()
      foldersLVs := new hashtable()
      ; ToolTip, % "l=" total , , , 2
      Loop, % total
      {
          RowNumber := LV_GetNext(RowNumber)
          If !RowNumber
             Break

          LV_GetText(indexu, RowNumber, colNum)
          If !indexu
             Continue

          folderu :=  Format("{:L}", newStaticFoldersListCache[indexu, 1])
          If folderu
          {
             foldersListArray[folderu] := indexu
             foldersSelListArray[indexu] := 0
             foldersLVs[indexu] := RowNumber
          }
       }
    }

   thisIndex := 0
   folderu := StrReplace(folderu, "|")
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
         showTOOLtip("Updating files selection, please wait" etaTime, 0, 0, A_Index/maxFilesIndex)
         prevMSGdisplay := A_TickCount
      }

      imgPath := StrReplace(resultedFilesList[A_Index, 1], "|")
      If !imgPath
         Continue

      OutDir := (AnyWindowOpen=2) ? Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)) : imgPath
      If (AnyWindowOpen=2 && foldersListArray[OutDir])
      || (AnyWindowOpen=3 && InStr(OutDir "\", folderu "\"))
      {
         thisIndex++
         osel := resultedFilesList[A_Index, 2]
         If (AnyWindowOpen=2)
            foldersSelListArray[foldersListArray[OutDir]] := 1 + foldersSelListArray[foldersListArray[OutDir]]
         resultedFilesList[A_Index, 2] := (modus="desel") ? 0 : 1
         If (modus="desel" && osel=1)
            markedSelectFile--
         Else If (modus!="desel" && !osel)
            markedSelectFile++
      }
   }

   ToolTip
   lastZeitFileSelect := A_TickCount
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
   If (AnyWindowOpen=2)
   {
      iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
      For Key, Value in foldersListArray
      {
         indexu := Value
         selected := foldersSelListArray[indexu]
         RowNumber := foldersLVs[indexu]
         thisIndex :=  (modus="desel") ? 0 : selected
         LV_GetText(countFiles, RowNumber, 5)
         perc := countFiles ? Round((Round(thisIndex)/countFiles)*100, 1) : 0
         LV_Modify(RowNumber, "Col6", thisIndex)
         LV_Modify(RowNumber, "Col7", perc)
         newStaticFoldersListCache[indexu, 4] := (modus="desel") ? 0 : thisIndex
      }
   }

   ResetImgLoadStatus()
   RemoveTooltip()
   foldersListArray := ""
   foldersSelListArray := ""
   foldersLVs := ""
   dummyTimerDelayiedImageDisplay(50)
}

BTNcountFilesDynaFolders() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderu, RowNumber, 3)
   LV_GetText(onDisk, RowNumber, 7)
   ; ToolTip, % folderu "=" colNum "=" RowNumber "=" whichLV , , , 2
   If (StrLen(folderu)<3 || folderu="folder path")
      Return

   ToolTip, Identifying matching files
   setImageLoading()
   thisSelIndex := thisIndex := 0
   folderu := StrReplace(folderu, "|")
   doStartLongOpDance()
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := StrReplace(resultedFilesList[A_Index, 1], "|")
      If !imgPath
         Continue

      If (InStr(imgPath "\", folderu "\"))
      {
         thisIndex++
         If resultedFilesList[A_Index, 2]
            thisSelIndex++
      }
   }

   ToolTip
   LV_Modify(RowNumber, "Col4", thisIndex)
   LV_Modify(RowNumber, "Col5", thisSelIndex)

   diffu := (onDisk!="" && thisIndex!="") ? onDisk - thisIndex : 0
   perc := countFiles ? Round((Round(thisSelIndex)/thisIndex)*100, 1) : 0
   LV_Modify(RowNumber, "Col6", perc)
   LV_Modify(RowNumber, "Col8", diffu)
   ResetImgLoadStatus()
   Return thisIndex
}

coreRemFilesStaticFolder(folderu, recursive) {
    remFilesFromList(recursive folderu)
    If (maxFilesIndex>0)
    {
       GenerateRandyList()
       SoundBeep, 900, 100
       RandomPicture()
       Return 1
    } Else
    {
       r := handleEmptyFilesList(CurrentSLD, "", 2)
       z := r ? 1 : 0
       Return z
    }
}

BTNcopyDynaFoldersList() {
    foldersListu := getDynamicFoldersList()
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    ResetImgLoadStatus()
    If !newFoldersList
       Return

    Try Clipboard := newFoldersList
    Catch wasError
          Sleep, 1

    If !wasError
    {
       showTOOLtip("Dynamic folders list copied to clipboard")
    } Else
    {
       showTOOLtip("Failed to copy to clipboard the dynamic folders list")
       SoundBeep , 300, 100
    }

    SetTimer, RemoveTooltip, % msgDisplayTime
}

BTNpasteDynaFoldersList() {
    BtnCloseWindow()
    Sleep, 50
    foldersListu := getDynamicFoldersList()
    foldersListu .= SubStr(Clipboard, 1, 50432)
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    mustOpenStartFolder := ""
    Sort, newFoldersList, UD`n
    DynamicFoldersList := cleanDynamicFoldersList(newFoldersList)
    If (SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(DynamicFoldersList)

    currentFilesListModified := 1
    Sleep, 50
    ResetImgLoadStatus()
    PanelDynamicFolderzWindow()
}

BTNremDynaSelFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_GetNext()
    LV_GetText(folderu, RowNumber, 3)
    LV_GetText(isR, RowNumber, 2)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If !InStr(isR, "R")
       folderu := "|" folderu

    BtnCloseWindow()
    Sleep, 50
    mustOpenStartFolder := ""
    foldersListu := getDynamicFoldersList()
    currentFilesListModified := 1
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!RegExMatch(fileTest, "i)^(.\:\\.)") || folderu=line)
           Continue

        newFoldersList .= line "`n"
    }

    DynamicFoldersList := newFoldersList
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    msgResult := msgBoxWrapper(appTitle ": Remove dynamic folder", "Would you like to remove the files from the index/list pertaining to the removed dynamic folder as well ?`n`n" folderu "\", 4, 0, "question")
    If (msgResult="yes")
    {
       remFilesFromList(StrReplace(folderu, "|"))
       If (maxFilesIndex>0)
       {
          GenerateRandyList()
          SoundBeep, 900, 100
          RandomPicture()
       } Else 
       {
          If !handleEmptyFilesList(CurrentSLD, "", 2)
             Return
       }
    }

    Sleep, 50
    ResetImgLoadStatus()
    SetTimer, PanelDynamicFolderzWindow, -150
}

BtnPanelManageFoldersExplorer() {
   BtnPanelManageFoldersActus("explorer", "yo")
}

BtnPanelManageFoldersNewInstance() {
   BtnPanelManageFoldersActus("anew", "yo")
}

BtnPanelManageFoldersProperties() {
   BtnPanelManageFoldersActus("properties", "yo")
}

BtnPanelManageFoldersProtect() {
   BtnPanelManageFoldersActus("protect", "yo")
}

BtnPanelStaticJumpFirst() {
   whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, % whichLV
   colNum := (AnyWindowOpen=3) ? 3 : 1
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderu, RowNumber, colNum)
   If (AnyWindowOpen=2)
      folderu := newStaticFoldersListCache[folderu, 1]

   ; ToolTip, % RowNumber "==" A_GuiEventInfo "`n" folderu , , , 2
   If (StrLen(folderu)<3 || folderu="folder path")
      Return

   winOpen := AnyWindowOpen
   folderPath := StrReplace(folderu, "|")
   BtnCloseWindow()
   thisIndex := 0
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
         showTOOLtip("Searching for the first file in index in`n:" folderPath "\" etaTime, 0, 0, A_Index/maxFilesIndex)
         prevMSGdisplay := A_TickCount
      }

      imgPath := StrReplace(resultedFilesList[A_Index, 1], "|")
      If !imgPath
         Continue

      OutDir := (winOpen=2) ? SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1) : imgPath
      If (winOpen=2 && OutDir=folderPath) || (winOpen=3 && InStr(OutDir "\", folderPath "\"))
      {
         thisIndex := A_Index
         Break
      }
   }

   ResetImgLoadStatus()
   RemoveTooltip()
   If thisIndex
   {
      currentFileIndex := thisIndex
      dummyTimerDelayiedImageDisplay(100)
   } Else
   {
      showTOOLtip("WARNING: No file found to be indexed from the selected folder:`n" folderPath "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BtnPanelManageFoldersActus(modus:=0, g:=0) {
   z := 0
   If (modus="protect" && g="yo")
      z := 4
   Else If (modus="properties" && g="yo")
      z := 3
   Else If GetKeyState("Shift", "P") || (modus="anew" && g="yo") 
      z := 2
   Else If GetKeyState("Ctrl", "P") || (modus="explorer" && g="yo")
      z := 1

   whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, % whichLV
   colNum := (AnyWindowOpen=3) ? 3 : 1
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderu, RowNumber, colNum)
   If (AnyWindowOpen=2)
      folderu := newStaticFoldersListCache[folderu, 1]

   ; ToolTip, % RowNumber "==" A_GuiEventInfo "`n" folderu , , , 2
   If (StrLen(folderu)<3 || folderu="folder path")
      Return

   folderPath := StrReplace(folderu, "|")
   If (z=1 && folderPath)
   {
      Try Run, "%folderPath%"
      Catch wasError
      {
         If !AnyWindowOpen
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu, 0, 0, "error")
      }
   } Else If (z=2 && folderPath)
   {
      OpenNewQPVinstance(folderPath)
   } Else If (z=3 && folderPath)
   {
      invokeStandardFolderProperties(folderPath)
   } Else If (z=4 && folderPath)
   {
      setContaintFolderAsProtected(folderPath)
   } Else If FolderExist(folderPath)
   {
      BtnCloseWindow()
      If askAboutFileSave(" and the selected folder will be opened")
         Return

      If askAboutSlidesListSave()
         Return

      If askAboutFilesSelect("discard it")
         Return

      tryOpenGivenFolder(folderPath, CurrentSLD)
      FileExploreSiblingsNav("reset")
   }
}

invokeStandardFolderProperties(thisFolder) {
   If FolderExist(thisFolder)
   {
      Try Run, Properties "%thisFolder%"
      Catch wasError
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the system file properties.", 0, 0, "error")
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

uiLVfolderzFilterListBTN(a:=0, b:=0, c:=0) {
    If (!AnyWindowOpen || b="s")
       Return

    whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, % whichLV
    colNum := (AnyWindowOpen=3) ? 3 : 1
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, colNum)
    folderu := (AnyWindowOpen=2) ? newStaticFoldersListCache[indexu, 1] : indexu
    LV_GetText(files, RowNumber, 5)
    totalSelected := LV_GetCount("S")

    ; TulTip(0,"|  ", indexu, folderu, files)
    If (StrLen(folderu)<3 || !totalSelected || folderu="folder path")
       Return

    If (b="k" && c=112) ; F1
    {
       If (AnyWindowOpen=2)
          BtnHelpStaticFoldersPanel()
       Return
    } Else If (b="k" && c=113) ; F2
    {
       isUpdateList := (FileExist(CurrentSLD) && RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? 1 : 0
       If (isUpdateList || whichLV="LViewDynas")
          PanelRenameStaticFolder()
       Return
    } Else If (b="k" && c=45 && whichLV="LViewDynas") ; Insert
    {
       BTNaddNewFolder2list()
       Return
    } Else If (b="k" && c=114) ; F3
    {
       MenuFilterListSelectedFolder()
       Return
    } Else If (b="k" && c=32 && whichLV="LViewDynas") ; Space
    {
       invokePanelDynaFoldersContextMenu()
       Return
    } Else If (b="k" && c=116) ; F5
    {
       If (whichLV="LViewDynas")
          BTNrescanDynaFolder()
       Else
          BTNupdateSelectedStaticFolder()
       Return
    } Else If (b="k" && c=117) ; F6
    {
       BtnPanelManageFoldersExplorer()
       Return
    } Else If (b="k" && c=121 && whichLV="LViewDynas") ; F10
    {
       BTNcountFilesDiskDynaFolder()
       Return
    } Else If (b="k" && c=122 && whichLV="LViewDynas") ; F11
    {
       BTNcountFilesDynaFolders()
       Return
    } Else If (b="K" && (c=119 || c=46)) ; F8
    {
       If (whichLV="LViewDynas")
          BTNremDynaSelFolder()
       Else
          BTNremFilesStaticFolder()
       Return
    }

    If (A_GuiEvent="Normal" && GetKeyState("Alt", "P"))
    {
       BTNselFilesStaticFolder()
       Return
    } Else If (A_GuiEvent="RightClick" && GetKeyState("Alt", "P"))
    {
       BTNunselFilesStaticFolder()
       Return
    } Else If ((A_GuiEvent="Normal" || A_GuiEvent="K") && files="" && whichLV="LViewOthers")
    {
       countedFiles := 0
       countedSelFiles := 0
       ; startZeit := A_TickCount
       Loop, % maxFilesIndex
       {
          imgPath := resultedFilesList[A_Index, 1]
          If InStr(imgPath, folderu)
             zPlitPath(imgPath, 1, OutFileName, OutDir)
          Else
             OutDir := ""

          If (OutDir=folderu)
          {
             countedFiles++
             If resultedFilesList[A_Index, 2]
                countedSelFiles++
          }
       }
       ; ToolTip, % A_TickCount - startZeit , , , 2
       newStaticFoldersListCache[indexu, 3] := countedFiles
       newStaticFoldersListCache[indexu, 4] := countedSelFiles
       LV_Modify(RowNumber, "Col5", countedFiles)
       LV_Modify(RowNumber, "Col6", countedSelFiles)
       perc := countedFiles ? Round((Round(countedSelFiles)/countedFiles)*100, 1) : 0
       LV_Modify(RowNumber, "Col7", perc)
       ; LV_ModifyCol(colNum, "AutoHdr Left")
       Return
    }

    If (b="DoubleClick")
    {
       BtnPanelStaticJumpFirst()
    } Else If (a="menu-mode")
    {
       selu := LV_GetCount("S")
       If (a="menu-mode" && AnyWindowOpen=2 && selu>1)
          UIfilterListToSelectStaticFolders()
       Else
          uiFilterListDynaFolder(folderu, AnyWindowOpen)
    }
}

UIfilterListToSelectStaticFolders() {
   showTOOLtip("Filtering list to selected folders, please wait")
   Gui, SettingsGUIA: Hide
   dropFilesSelection(1)
   BTNselFilesStaticFolder()
   BtnCloseWindow()
   filterToFilesSelection()
   dropFilesSelection(1)
}

countAllFilesPerStaticFolders(dummy:=0) {
    If (dummy!="start")
    {
       BtnCloseWindow()
    } Else
    {
       EM_SETCUEBANNER(hEditField, "Preparing folders list - please wait", 0)
       Tooltip, Preparing folders list - please wait
    }

    setImageLoading()
    getSelectedFiles(0, 1)
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    doStartLongOpDance()
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    totalLoops := newStaticFoldersListCache.MaxIndex()
    folderMapArray := new hashtable()
    thisIndex := 0
    Loop, % totalLoops
    {
        If (SLDtypeLoaded!=3)
           newStaticFoldersListCache[A_Index, 3] := 0
        newStaticFoldersListCache[A_Index, 4] := 0
        OutDir := Format("{:L}", newStaticFoldersListCache[A_Index, 1])
        folderMapArray[OutDir] := A_Index
    }

    foldersListArray := new hashtable()
    foldersSelListArray := new hashtable()
    Loop, % maxFilesIndex
    {
        imgPath := resultedFilesList[A_Index, 1]
        executingCanceableOperation := A_TickCount
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>2000)
        {
           etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
           showTOOLtip("Counting files per folders, please wait`nTotal folders: " groupDigits(totalLoops) etaTime, 0, 0, A_Index/maxFilesIndex)
           prevMSGdisplay := A_TickCount
        }

        OutDir := Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1))
        foldersListArray[OutDir] := (SLDtypeLoaded=3) ? 1 : Round(foldersListArray[OutDir]) + 1
        If markedSelectFile
        {
           If resultedFilesList[A_Index, 2]
              foldersSelListArray[OutDir] := Round(foldersSelListArray[OutDir]) + 1
        }
    }
 
    totalLoops := foldersListArray.Count()
    For folderu, Value in foldersListArray
    {
        If !folderu
           Continue

        If (A_TickCount - prevMSGdisplay>1000)
        {
           etaTime := ETAinfos(A_Index, totalLoops, startOperation)
           showTOOLtip("Consolidating data: count files per folders" etaTime, 0, 0, A_Index/totalLoops)
           prevMSGdisplay := A_TickCount
        }

        executingCanceableOperation := A_TickCount
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        thisIndex := folderMapArray[folderu]
        If (SLDtypeLoaded!=3)
           newStaticFoldersListCache[thisIndex, 3] := Value

        If markedSelectFile
           newStaticFoldersListCache[thisIndex, 4] := foldersSelListArray[folderu]
    }

    iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
    foldersListArray := ""
    foldersSelListArray := ""
    folderMapArray := ""
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    CurrentSLD := backCurrentSLD
    ResetImgLoadStatus()
    RemoveTooltip()
    If (AnyWindowOpen!=2)
       PanelStaticFolderzManager()
}

uiFilterListDynaFolder(folderu, modus) {
    ; doExactMatch := (AnyWindowOpen=3) ? 0 : 1
    BtnCloseWindow()
    folderu := Trimmer(StrReplace(folderu, "|"))
    If (modus=3) ; full path recursive
    {
       userFilterStringPos := 2
       userFilterWhat := 1
       UsrEditFilter := folderu "\"
    } Else
    {
       userFilterStringPos := 3
       userFilterWhat := 2
       UsrEditFilter := folderu
    }

    userFilterProperty := userFilterDoString := 1
    userFilterInvertThis := userFilterStringIsNot := 0
    thisFilter := updateUIFiltersPanel("external")
    coreEnableFiltru(thisFilter)
    dummyTimerDelayiedImageDisplay(50)
}

MenuFilterListSelectedFolder() {
   uiLVfolderzFilterListBTN("menu-mode")
}

BtnToggleRecurseDynaFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_GetNext()
    LV_GetText(folderu, RowNumber, 3)
    LV_GetText(isPipe, RowNumber, 2)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    ; BtnCloseWindow()
    Sleep, 25
    foldersListu := "`n" getDynamicFoldersList() "`n"

    isPipe := InStr(isPipe, "R") ? 0 : 1
    If isPipe
       folderu := "|" folderu

    folderuz := StrReplace(folderu, "|")
    newfolderu := (isPipe!=1) ? "`n|" folderuz "`n" : "`n" folderuz "`n"
    newFoldersList := StrReplace(foldersListu, "`n" folderu "`n", newFolderu)
    Sort, newFoldersList, UD`n
    ; ToolTip, % folderu "`n" folderuz "`n" newFolderu "Z`n" DynamicFoldersList "`n Z `n" newFoldersList , , , 2
    DynamicFoldersList := newFoldersList
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    ; ToolTip, % newFoldersList , , , 2
    showTOOLtip("You need to rescan the folder for the effect to take place")
    PopulateDynamicFolderzList()
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNrescanDynaFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_GetNext()
    LV_GetText(folderu, RowNumber, 3)
    LV_GetText(recu, RowNumber, 2)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    BtnCloseWindow()
    Sleep, 25
    ; msgbox, % folderu
    mustOpenStartFolder := ""
    recu := InStr(recu, "R") ? "" : "|"
    z := wrapperAddNewFolderToList(recu folderu, 1)
    modus := InStr(recu, "|") ? 1 : 0
    If (z!="null" && RegExMatch(CurrentSLD, sldsPattern))
       updateCachedStaticFolders(folderu, modus)

    Sleep, 15
    PanelDynamicFolderzWindow()
}

updateCachedStaticFolders(mainFolderu, onlyMainFolder, updateAllDates:=0, allowDump:=1) {
   thisIndex := 0
   showTOOLtip("Updating static folders list")
   LoadStaticFoldersCached(CurrentSLD, countStaticFolders, "f")

   If !IsObject(mainFolderu)
   {
      foldersListArray := new hashtable()
      FileGetTime, dirDate, % mainFolderu, M
      foldersListArray[Format("{:L}", mainFolderu)] := dirDate
      If (onlyMainFolder!=1)
      {
         Loop, Files, %mainFolderu%\*, RD
         {
             FileGetTime, dirDate, %A_LoopFileFullPath%, M
             foldersListArray[Format("{:L}", A_LoopFileFullPath)] := dirDate
             ; Tooltip, % MoreNewFileFolders
         }
      }
   }

   counter++
   newArray := []
   hash := new hashtable()
   Loop, % newStaticFoldersListCache.MaxIndex()
   {
       ; update pre-existing folder dates
       folderu := newStaticFoldersListCache[A_Index, 1]
       oldDateu := newStaticFoldersListCache[A_Index, 2]
       z := Format("{:L}", folderu)
       If (!FolderExist(folderu) || hash[z]=1 || StrLen(folderu)<5)
          Continue

       counter++
       newArray[counter] := newStaticFoldersListCache[A_Index]
       hash[z] := 1
       If foldersListArray[z]
       {
          newArray[counter, 2] := foldersListArray[z]
          foldersListArray[z] := "-"
       } Else If (updateAllDates=1)
       {
          FileGetTime, newDateu, % folderu, M
          newArray[counter, 2] := newDateu
       }
   }

   For folderu, newDateu in foldersListArray
   {
       ; add new folder to main array: newStaticFoldersListCache[]
       If (hash[folderu]=1 || StrLen(folderu)<5 || newDateu="-")
          Continue

       counter++
       newArray[counter] := [folderu, newDateu]
   }

   newStaticFoldersListCache := []
   newStaticFoldersListCache := newArray.Clone()
   hash := ""
   foldersListArray := ""
   If (SLDtypeLoaded=3 && allowDump=1)
      SQLDBdumpStaticFoldersList()
}

SQLDBdumpStaticFoldersList() {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM staticfolders;")
   Loop, % newStaticFoldersListCache.MaxIndex()
       addStaticFolderSQLdb(newStaticFoldersListCache[A_Index, 1], newStaticFoldersListCache[A_Index, 2], 0)

   If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      throwSQLqueryDBerror(A_ThisFunc)
}

remFilesFromList(SelectedDir, silentus:=0, forReal:=1) {
    If (silentus=0)
       showTOOLtip("Removing files from the list pertaining to`n" SelectedDir "\")

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    selectedFiles := markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    oldMaxy := maxFilesIndex
    isPipe := InStr(SelectedDir, "|") ? 1 : 0
    SelectedDir := StrReplace(SelectedDir, "|")
    newArrayu := []
    Loop, % maxFilesIndex + 1
    {
        r := getIDimage(A_Index)
        If (InStr(r, "||") || !r)
           Continue

        If !isPipe
        {
           If InStr(r, SelectedDir "\")
              Continue
        } Else If (isPipe=1)
        {
           rT := StrReplace(r, SelectedDir "\")
           If !InStr(rT, "\")
              Continue
        }

        countFiles++
        newArrayu[countFiles] := resultedFilesList[A_Index]
        If (resultedFilesList[A_Index, 2]=1)
           selectedFiles++
    }

    If (SLDtypeLoaded=3)
    {
       thisR := SQLescapeStr(SelectedDir, 1)
       thisR := (isPipe=1) ? thisR : thisR "%"
       If (forReal=1)
       {
          activeSQLdb.Exec("BEGIN TRANSACTION;")
          SQLstr := "DELETE FROM images WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          If !activeSQLdb.Exec(SQLStr)
          {
             stringA:= thisR
             activeSQLdb.EscapeStr(stringA)
             SQLstr := "DELETE FROM images WHERE imgfolder LIKE " stringA " ESCAPE '>';"
             activeSQLdb.Exec(SQLStr)
          }

          If !activeSQLdb.Exec("COMMIT TRANSACTION;")
             throwSQLqueryDBerror(A_ThisFunc)
       } Else
       {
          SQLstr := "UPDATE images SET isDeleted=1 WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          If !activeSQLdb.Exec(SQLstr)
             throwSQLqueryDBerror(A_ThisFunc)
       }
    }

    renewCurrentFilesList()
    maxFilesIndex := countFiles
    resultedFilesList := newArrayu.Clone()
    markedSelectFile := selectedFiles
    ForceRefreshNowThumbsList()
    filesRemoved := oldMaxy - maxFilesIndex
    If (SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    If (filesRemoved<1)
       filesRemoved := 0
    Else
       currentFilesListModified := 1

    CurrentSLD := backCurrentSLD
    If (silentus=0)
       showTOOLtip("Finished removing " filesRemoved " files from the list")

    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

PanelRenameStaticFolder() {
    ; Global newFileName, idFolder, remFilesFromFolder, doRemRecursively
    winOpen := AnyWindowOpen
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    colNum := (AnyWindowOpen=3) ? 3 : 1
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, colNum)
    folderu := (AnyWindowOpen=2) ? newStaticFoldersListCache[indexu, 1] : indexu
    If (StrLen(folderu)<3 || folderu="folder path")
        Return

    If (SLDtypeLoaded=2 && AnyWindowOpen=2)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
          Return
       }
   }

   Sleep, 15
   folderu := StrReplace(folderu, "|")
   msgResult := msgBoxWrapper("Rename static folder entry: " appTitle, "Please type the new folder path.", "&Rename folder entry|C&ancel", 1, "modify-entry", "Propagate the change to subfolders", 1, 0, "limit9050 w850", folderu)
   If InStr(msgResult.btn, "Rename")
   {
      doPropagate := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      newFileName := StrReplace(newFileName, "/", "\")
      newFileName := StrReplace(newFileName, "|")
      newFileName := Trimmer(newFileName, "\")
      newFileName := RegExReplace(newFileName, "\\{2,}", "\")
      If (newFileName=folderu)
      {
         SetTimer, PanelRenameStaticFolder, -300
         Return
      }

      If (!RegExMatch(newFileName, "i)^(.\:\\.)") || !newFileName)
      {
         showTOOLtip("WARNING: Incorrect folder path provided")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelRenameStaticFolder, -300
         Return
      }

      If !FolderExist(newFileName)
      {
         showTOOLtip("WARNING: Inexistent folder path provided")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelRenameStaticFolder, -300
         Return
      }

      BtnCloseWindow()
      newName := newFileName
      If (winOpen=2)
      {
         showTOOLtip("Updating static folders list")
         If (SLDtypeLoaded=3)
         {
            Sleep, 25
         } Else
         {
            Loop, % newStaticFoldersListCache.MaxIndex()
            {
               If (newStaticFoldersListCache[A_Index, 1]=folderu)
               {
                  newStaticFoldersListCache[A_Index, 1] := newName
               } Else If (doPropagate=1)
               {
                  If InStr(newStaticFoldersListCache[A_Index, 1], folderu "\")
                     newStaticFoldersListCache[A_Index, 1] := StrReplace(newStaticFoldersListCache[A_Index, 1], folderu "\", newName "\")
               }
            }
         }
      } Else
      {
         finalListu := ""
         foldersListu := getDynamicFoldersList()
         Loop, Parse, foldersListu,`n,`r
         {
            line := StrReplace(A_LoopField, "|")
            If (line=folderu)
               finalListu .= StrReplace(A_LoopField, folderu, newName) "`n"
            Else
               finalListu .= (doPropagate=1) ? StrReplace(A_LoopField, folderu "\", newName "\") "`n" : A_LoopField "`n"
         }

         DynamicFoldersList := cleanDynamicFoldersList(finalListu)
         If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
            recreateDynaFoldersSQLdbList(DynamicFoldersList)
      }

      currentFilesListModified := 1
      msgResult := msgBoxWrapper(appTitle ": Update files list", "You have renamed a folder entry. Would you like to perform a search and replace in the files list to update the corresponding records?", 4, 0, "question")
      If (msgResult="Yes")
         SearchAndReplaceThroughIndex(folderu "\", newName "\", 0, 1)

      SetTimer, RemoveTooltip, % -msgDisplayTime
      ; MsgBox, % firstPart "`n" newName "`n" indexSelected
      If (winOpen=2)
         PanelStaticFolderzManager()
      Else
         PanelDynamicFolderzWindow()
    }
}

SearchAndReplaceThroughIndex(what, replacer, silentus:=0, folderMode:=0) {
    If (silentus=0)
       showTOOLtip("Performing search and replace in the files list index:`n" what "`n" replacer)

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    changeMcursor()
    getSelectedFiles(0, 1)
    If (StrLen(filesFilter)>1 && SLDtypeLoaded=3)
       remFilesListFilter("simple")

    selectedFiles := totalAffected := 0
    If (SLDtypeLoaded=3)
    {
       whatESC := SQLescapeStr(what)
       replacerESC := SQLescapeStr(replacer)
       ; activeSQLdb.EscapeStr(what)
       ; activeSQLdb.EscapeStr(replacer)
       activeSQLdb.Exec("BEGIN TRANSACTION;")
       If (folderMode=1)
          SQLstr := "UPDATE images SET imgfolder='" Trimmer(replacerESC, "\") "' WHERE imgfolder='" Trimmer(whatESC, "\") "' COLLATE NOCASE;"

       startOperation := A_TickCount
       prevMSGdisplay := A_TickCount
       If (activeSQLdb.Exec(SQLStr) || folderMode!=1)
       {
          If (folderMode=1)
             SQLstr := "SELECT imgidu, imgfolder FROM images WHERE imgfolder LIKE '" Trimmer(SQLescapeStr(what, 1), "\") "\%' ESCAPE '>';"
          Else
             SQLstr := "SELECT imgidu, imgfolder FROM images WHERE imgfolder LIKE '%" SQLescapeStr(what, 1) "%' ESCAPE '>';"

          If !activeSQLdb.GetTable(SQLstr, RecordSet)
             errorOccured := activeSQLdb.ErrorMsg

          changeMcursor()
          totalFiles := RecordSet.RowCount
          Loop, % RecordSet.RowCount
          {
              changeMcursor()
              Row := RecordSet.Rows[A_Index]
              If (A_TickCount - prevMSGdisplay>1500)
              {
                 etaTime := ETAinfos(A_Index, totalFiles, startOperation)
                 showTOOLtip("Performing search and replace in the files list index" etaTime, 0, 0, A_Index/totalFiles)
                 prevMSGdisplay := A_TickCount
              }

              If Row[2]
              {
                 newFolderName := StrReplace(Row[2], what, replacer)
                 SQLstr := "UPDATE images SET imgfolder='" SQLescapeStr(newFolderName) "' WHERE imgidu='" Row[1] "';"
                 If !activeSQLdb.Exec(SQLstr)
                    failedFiles++
              }
          }
          RecordSet.Free()
       } Else errorOccured := activeSQLdb.ErrorMsg

       showTOOLtip("Finishing search and replace in the files list, please wait")
       activeSQLdb.Exec("COMMIT TRANSACTION;")
    }

    If !errorOccured
    {
       Loop, % maxFilesIndex + 1
       {
           imgPath := getIDimage(A_Index)
           If !imgPath
              Continue

           If (!resultedFilesList[A_Index, 2] && limitSearchReplaceSelected=1 && SLDtypeLoaded!=3)
              Continue

           value := StrReplace(imgPath, what, replacer, affected)
           value := StrReplace(value, "\\", "\")
           resultedFilesList[A_Index, 1] := value
           If StrLen(filesFilter)>1
              updateMainUnfilteredList(A_Index, 1, value)

           totalAffected += affected
           If (resultedFilesList[A_Index, 2]=1)
              selectedFiles++
       }
    }

    currentFilesListModified := 1
    markedSelectFile := selectedFiles
    ForceRefreshNowThumbsList()
    dummyTimerDelayiedImageDisplay(50)
    If (SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    If errorOccured
    {
       showTOOLtip("Failed to update the files list database`n" errorOccured)
       SoundBeep , 300, 100
    } Else
    {
       If failedFiles
          someErrors := "Failed to modify " groupDigits(failedFiles) " entries in the files list`n"
       showTOOLtip(someErrors "Finished updating the files list`n" groupDigits(totalAffected) " records were modified")
       SoundBeep , 900, 100
    }
    CurrentSLD := backCurrentSLD
    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -200
}

SearchAndReplaceSeenDB(what, replacer) {
    initSeenImagesListDB()
    If (sqlFailedInit=1)
    {
       showTOOLtip("Failed to initialize database of seen images")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    startOperation := A_TickCount
    showTOOLtip("Performing search and replace in the seen database list:`n" what "`n" replacer)
    changeMcursor()
    whatESC := what
    replacerESC := replacer
    seenImagesDB.EscapeStr(whatESC)
    seenImagesDB.EscapeStr(replacerESC)
    seenImagesDB.Exec("BEGIN TRANSACTION;")
    SQLstr := "SELECT ROWID, imgfile FROM images WHERE imgfile LIKE '%" Trimmer(SQLescapeStr(what, 1)) "%' ESCAPE '>';"
    If !seenImagesDB.GetTable(SQLstr, RecordSet)
       errorOccured := seenImagesDB.ErrorMsg

    totalAffected := failedFiles := 0
    totalFiles := RecordSet.RowCount
    If !errorOccured
    {
       Loop, % RecordSet.RowCount
       {
           changeMcursor()
           Row := RecordSet.Rows[A_Index]
           If (A_TickCount - prevMSGdisplay>1500)
           {
              etaTime := ETAinfos(A_Index, totalFiles, startOperation)
              showTOOLtip("Performing search and replace in the seen database list" etaTime, 0, 0, A_Index/totalFiles)
              prevMSGdisplay := A_TickCount
           }

           If Row[2]
           {
              newFolderName := StrReplace(Row[2], what, replacer)
              SQLstr := "UPDATE images SET imgfile='" SQLescapeStr(newFolderName) "' WHERE ROWID='" Row[1] "';"
              If !seenImagesDB.Exec(SQLstr)
                 failedFiles++
              Else
                 totalAffected++
           }
       }
       RecordSet.Free()
    }

    k := seenImagesDB.Exec("COMMIT TRANSACTION;")
    If (errorOccured || !k)
    {
       showTOOLtip("Failed to update the seen images database`n" errorOccured)
       SoundBeep , 300, 100
    } Else
    {
       If failedFiles
          someErrors := "Failed to modify " groupDigits(failedFiles) " entries in the seen images database`n"
       showTOOLtip(someErrors "Finished updating the seen images database`n" groupDigits(totalAffected) " records were modified")
       SoundBeep , 900, 100
    }

    CurrentSLD := backCurrentSLD
    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -200
}

BTNupdateSelectedStaticFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, 1)
    folderu := newStaticFoldersListCache[indexu, 1]
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded=2 && FileExist(CurrentSLD))
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
          Return
       } Else allGood := 1
    }

   indexu := RowNumber := 0
   total := LV_GetCount()
   foldersListArray := new hashtable()
   Loop, % total
   {
       RowNumber := LV_GetNext(RowNumber)
       If !RowNumber
          Break

       LV_GetText(indexu, RowNumber, 1)
       If !indexu
          Continue

       folderu := Format("{:L}", newStaticFoldersListCache[indexu, 1])
       If folderu
          foldersListArray[folderu] := indexu
    }

    If (foldersListArray.Count()<1)
    {
       foldersListArray := ""
       Return
    }

    BtnCloseWindow()
    Sleep, 5
    currentFilesListModified := 1
    For foldar, indexu in foldersListArray
    {
       newStaticFoldersListCache[indexu, 3] := ""
       newStaticFoldersListCache[indexu, 4] := ""
       wrapperAddNewFolderToList("|" foldar, 0, 1)
    }

    setImageLoading()
    If (SLDtypeLoaded=3 || SLDtypeLoaded=2 && allGood=1)
    {
       showTOOLtip("Updating static folders list")
       setwhileLoopExec(1)
       For foldar, indexu in foldersListArray
       {
           FileGetTime, dirDate, % foldar, M
           foldersListArray[foldar] := dirDate
       }
       updateCachedStaticFolders(foldersListArray, 1)
       setwhileLoopExec(0)
    }

    ResetImgLoadStatus()
    Sleep, 5
    SetTimer, RemoveTooltip, % -msgDisplayTime
    foldersListArray := ""
    PanelStaticFolderzManager()
}

UIeditApplyStaticFolderFilter() {
   If (imageLoading=1)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, StaticListViewFilteru
   If StrLen(Trimmer(StaticListViewFilteru))<2
   {
      UIlvFilterEraseStaticPanel()
      Return
   }

   If (lastFilterEditSearch=StaticListViewFilteru)
      Return

   lastFilterEditSearch := Trimmer(StaticListViewFilteru)
   SetTimer, UIfilterListViewStaticFolderzList, -50
}

UIfilterListViewStaticFolderzList() {
   If (AnyWindowOpen!=2)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, StaticListViewFilteru
   If (imageLoading=1)
      Return

   PopulateStaticFolderzList(staticListViewFilteru)
}

retrieveListFoldersIndexed() {
   foldersListArray := new hashtable()

   If (SLDtypeLoaded=3 && RegExMatch(CurrentSLD, sldsPattern))
   {
      SQL := "SELECT imgfolder, COUNT(*) FROM images GROUP BY imgfolder;"
      If !activeSQLdb.GetTable(SQL, RecordSet)
      {
         throwSQLqueryDBerror(A_ThisFunc)
         Return
      }

      Loop, % RecordSet.RowCount
      {
          Rowu := RecordSet.Rows[A_Index]
          If Rowu[1]
          {
             OutDir := Rowu[1]
             foldersListArray[OutDir] := 1
          }
      }

      RecordSet.Free()
   } Else
   {
      Loop, % maxFilesIndex + 1
      {
           imgPath := resultedFilesList[A_Index, 1]
           If (InStr(imgPath, "||") || !imgPath)
              Continue

           OutDir := Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1))
           foldersListArray[OutDir] := 1
      }
   }
   Return foldersListArray
}

PopulateStaticSQLfolderzList(modus:=0) {

    If (StrLen(newStaticFoldersListCache[1, 1])>4 && modus!="forced")
       Return newStaticFoldersListCache.MaxIndex()

    RecordSet := ""
    Tooltip, Gathering folders list - please wait
    SQL := "SELECT imgfolder, COUNT(*) FROM images GROUP BY imgfolder;"
    If !activeSQLdb.GetTable(SQL, RecordSet)
    {
       Tooltip
       throwSQLqueryDBerror(A_ThisFunc)
       SetTimer, ResetImgLoadStatus, -200
       Return 0
    }

    arrayList := []
    fCountThese := 0
    Loop, % RecordSet.RowCount
    {
        Rowu := RecordSet.Rows[A_Index]
        If Rowu[1]
        {
           fCountThese++
           arrayList[fCountThese] := [Rowu[1], Rowu[2]]
        }
    }

    RecordSet.Free()
    SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
    If !activeSQLdb.GetTable(SQL, RecordSet)
    {
       throwSQLqueryDBerror(A_ThisFunc)
       SetTimer, ResetImgLoadStatus, -200
       Return 0
    }

    foldersDatesArray := new hashtable()
    Loop, % RecordSet.RowCount
    {
        Rowu := RecordSet.Rows[A_Index]
        If Rowu[1]
           foldersDatesArray[Format("{:L}", Rowu[1])] := Rowu[2]
    }

    countThese := 0
    RecordSet.Free()
    newStaticFoldersListCache := []
    Loop, % fCountThese
    {
        folderu := Trimmer(arrayList[A_Index, 1])
        If (StrLen(folderu)<5)
           Continue

        countThese++
        oldDateu := foldersDatesArray[Format("{:L}", folderu)]
        countFiles := arrayList[A_Index, 2]
        newStaticFoldersListCache[countThese] := [folderu, oldDateu, countFiles]
    }

    foldersDatesArray := ""
    Return countThese
}

PopulateStaticFolderzList(listFilter:=0, modus:=0) {

    EM_SETCUEBANNER(hEditField, "Preparing folders list - please wait", 0)
    startOperation := A_TickCount
    setImageLoading()
    Tooltip, Preparing folders list - please wait
    If (SLDtypeLoaded=3)
       PopulateStaticSQLfolderzList()
    Else 
       LoadStaticFoldersCached(CurrentSLD, hmmm, 1)

    countStaticFolders := newStaticFoldersListCache.MaxIndex()
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    setImageLoading()
    LV_Delete()
    GuiControl, -Redraw, LViewOthers
    Tooltip, Listing folders now - please wait...
    startZeit := A_TickCount
    Loop, 10
    {
       If !isInRange(A_Index, 2, 4)
          LV_ModifyCol(A_Index, "Integer")
    }

    doStartLongOpDance()
    startOperation := A_TickCount
    hasAutoSized := thisIndex := foldersCount := 0
    isUpdateList := (RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? 1 : 0
    prevMSGdisplay := A_TickCount
    k := SubStr(listFilter, 1, 2)
    givenLimit := SubStr(listFilter, 3)
    If StrLen(listFilter)<2
       listFilter := ""

    If (k=":>" || k=":<" || k="?>" || k="?<" || k="*>" || k="*<")
    || (k="!>" || k="!<" || k="#>" || k="#<" || k="$>" || k="$<")
    {
       listFilter := ""
       If (isNumber(givenLimit) && givenLimit>0)
       {
          filterWhat := SubStr(k, 1, 1)
          limitMode := InStr(k, ">") ? 2 : 1
       }
       ; TulTip(0, "|  ", k, givenLimit, limitMode, filterWhat)
    } Else If listFilter
    {
       thisString := StrReplace(Trimmer(listFilter), "||", "|")
       thisString := Trimmer(thisString, "|")
       thisFilter := "i)(" JEE_StrRegExLiteral(thisString) ")"
       isStrFilter := StrLen(thisString)>1 ? 1 : 0
       FilterSimple := (InStr(thisString, "|") || InStr(thisString, "*") || InStr(thisString, "?")) ? 0 : 1
    }

    Loop, % countStaticFolders
    {
        folderu := newStaticFoldersListCache[A_Index, 1]
        If (StrLen(folderu)<2)
           Continue

        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           CountFilesFolderzList := 0
           Break
        }

        If (isStrFilter=1 && FilterSimple=1)
        {
           If !inStr(folderu, thisString)
              Continue
        } Else If (isStrFilter=1)
        {
           If !RegExMatch(folderu, thisFilter)
              Continue
        }

        If (A_TickCount - prevMSGdisplay>1000)
        {
           prevMSGdisplay := A_TickCount
           showTOOLtip("Populating the list, please wait`n" groupDigits(countStaticFolders) " folders", 0, 0, A_Index/countStaticFolders)
        }

        oldDateu := newStaticFoldersListCache[A_Index, 2]
        FileGetTime, dirDateO, % folderu, M
        If (userPrivateMode=1)
           folderu := "*:\********\******\"
        statusu := (dirDateO!=oldDateu && isUpdateList=1) ? "*" : ""
        dirDate := SubStr(dirDateO, 1, StrLen(dirDate) - 2)
        FormatTime, dirDate, % dirDate, yyyy/MM/dd ; -HH:mm
        countedSelFiles := markedSelectFile ? Round(newStaticFoldersListCache[A_Index, 4]) : 0
        countFiles := newStaticFoldersListCache[A_Index, 3]
        countTFiles := newStaticFoldersListCache[A_Index, 5]
        countSize := Round(Round(newStaticFoldersListCache[A_Index, 6]/1024, 1)/1024, 1)
        diffu := (ountTFiles!="" && countFiles!="") ? countTFiles - countFiles : 0
        perc := countFiles ? Round((Round(countedSelFiles)/countFiles)*100, 1) : 0
        If filterWhat
        {
           thisValue := (filterWhat="?") ? countFiles : countedSelFiles
           If (filterWhat="*")
              thisValue := perc
           Else If (filterWhat="!")
              thisValue := countTFiles
           Else If (filterWhat="#")
              thisValue := diffu
           Else If (filterWhat="$")
              thisValue := countSize
        }

        If ((thisValue>=givenLimit && limitMode=1) || (thisValue<=givenLimit && limitMode=2) && countFiles && thisValue)
           Continue

        ; ToolTip, % "v=" countFiles "=" countedSelFiles , , , 2
        LV_Add(A_Index, A_Index, dirDate, statusu, folderu, countFiles, countedSelFiles, perc, countTFiles, diffu, countSize)
        If ((A_Index=5 || A_Index=10) && (modus="init"))
        {
           hasAutoSized := 1
           Loop, 10
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }
    ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 
    EM_SETCUEBANNER(hEditField, "Filter folders list: " groupDigits(LV_GetCount()) " entries", 0)
    executingCanceableOperation := 0
    If (!hasAutoSized && modus="init")
    {
       Loop, 10
           LV_ModifyCol(A_Index, "AutoHdr Left")
    }

    If (modus="init")
       LV_ModifyCol(3, "SortDesc")
    GuiControl, +Redraw, LViewOthers
    RemoveTooltip()
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

StrPutVar(string, ByRef var, encoding) {
    ; Ensure capacity.
    ; StrPut returns char count, but VarSetCapacity needs bytes.
    VarSetCapacity(var, StrPut(string, encoding) * ((encoding="utf-16"||encoding="cp1200") ? 2 : 1))
    ; Copy or convert the string.
    return StrPut(string, &var, encoding)
}

PopulateDynamicFolderzList() {
    listu := getDynamicFoldersList()
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    LV_Delete()

    Loop, 9
    {
       If !isInRange(A_Index, 2, 3)
          LV_ModifyCol(A_Index, "Integer")
    }

    Loop, Parse, listu, `n
    {
        statusu := InStr(A_LoopField, "|") ? "" : "R"
        line := (userPrivateMode=1) ? "*:\*****\********\" :  Trimmer(A_LoopField)
        If (StrLen(line)<3)
           Continue

        counteru++
        LV_Add(A_Index, counteru, statusu, StrReplace(line, "|"))
    }

    Loop, 3
        LV_ModifyCol(A_Index, "AutoHdr Left")

    LV_ModifyCol(3, "Sort")
    ResetImgLoadStatus()
}

uiPanelOpenCloseEvent(modus:=0) {
    b := (modus=1) ? "|" 0 "|" 0 "|" 0 "|" : "|" imgEditPanelOpened "|" AnyWindowOpen "|" hSetWinGui "|"
    a := panelWinCollapsed "|" liveDrawingBrushTool b editingSelectionNow "|" maxFilesIndex "|" UserMemBMP "|" undoLevelsRecorded "|" currentFilesListModified "|" lastOtherWinClose "|" IMGresizingMode "|" thumbsDisplaying
    interfaceThread.ahkPostFunction("PanelOpenCloseEvent", a)
}

CloseWindow(forceIT:=0, cleanCaches:=1) {
    Critical, on
    If (toolTipGuiCreated=2)
       SetTimer, RemoveTooltip, -3500

    If (uiUseDarkMode=1)
       CtlColors.Free()

    BalloonTip_Kill()
    endCaptureCloneBrush()
    fnOutputDebug("Close window: " prevOpenedWindow[1] "---" prevOpenedWindow[2])
    If (isNowFakeWinOpen=1 && AnyWindowOpen)
    {
       isNowFakeWinOpen := AnyWindowOpen := 0
       uiPanelOpenCloseEvent()
       SetTimer, CloseMsgBox2Win, Delete
       SetTimer, WatchMsgBox2Win, Delete
       MsgBox2Result := "win_closed"
       MsgBox2InputHook.Stop()
       Gui, WinMsgBox: Destroy
       MsgBox2hwnd := ""
       Sleep, 25
       Return 1
    }

    If (forceIT!="yes")
    {
       If (A_TickCount - lastLongOperationAbort < 1000)
          Return 1
    }

    Sleep, 5
    If (imgEditPanelOpened!=1)
       ResetImgLoadStatus()

    If isNowAlphaPainting()
    {
       Global lastOtherWinClose := A_TickCount
       interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
       toggleAlphaPaintingMode()
       Global lastOtherWinClose := A_TickCount
       uiPanelOpenCloseEvent()
       Return 1
    }

    If (AnyWindowOpen>0 && repositionedWindow=1)
       Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%

    Global lastOtherWinClose := A_TickCount
    panelWinCollapsed := forceLiveAlphaPreviewMode := FloodFillSelectionAdj := liveDrawingBrushTool := isNowFakeWinOpen := ForceNoColorMatrix := 0
    uiPanelOpenCloseEvent(1)
    DestroyGIFuWin()
    Gui, SettingsGUIA: Destroy
    WinActivate, ahk_id %PVhwnd%
    If globalhFIFimg
    {
       ; related to PanelAdjustToneMapping()
       FreeImage_UnLoad(globalhFIFimg)
       globalhFIFimg := ""
    }

    postVectorWinOpen := 0
    If (imgEditPanelOpened=1)
    {
       ; coreDesiredPixFmt := StrLen(UserMemBMP)>2 ? "0x26200A" : "0xE200B" ; 32-ARGB // 32-PARGB
       If (AnyWindowOpen=74 && wasVPfxBefore=0)
       {
          imgFxMode := 1
       } Else If (AnyWindowOpen=64)
       {
          clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       } Else If (AnyWindowOpen=23 && editingSelectionNow=1)
       {
          If (FillAreaShape<=2)
             EllipseSelectMode := 0
          Else If (FillAreaShape=3)
             EllipseSelectMode := 1
          Else If (FillAreaShape=7)
             EllipseSelectMode := 2
       }

       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
       ToggleVisibilityWindow("hide", hGDIthumbsWin)
       Gdip_GraphicsClear(2NDglPG, "0xff" WindowBGRcolor)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, 2NDglHDC)
       editingSelectionNow := prevOpenedWindow[4]
       dummyTimerDelayiedImageDisplay(90)
       getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
       livePreviewInsertTextinArea("kill")
       realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
       livePreviewFillBehindArea("kill")
       If (cleanCaches!=0)
       {
          corePasteInPlaceActNow("kill")
          coreFillSelectedArea("kill")
       }
       ; If (AnyWindowOpen=64)
       ; SetTimer, dummyRefreshImgSelectionWindow, -200
    }

    updateUIctrl()
    TriggerMenuBarUpdate()
    If !testIsDupesList()
       toBeExcludedIndexes := []

    If (AnyWindowOpen=6)
       InitialFilterSettingsPanel(0)

    hSetWinGui := imgEditPanelOpened := AnyWindowOpen := 0
    createGUItoolbar()
    If (ShowAdvToolbar=1)
       decideIconBTNmainTooler()
}

adjustCanvas2Toolbar(Gu, applyTransform) {
    If (ShowAdvToolbar!=1 || slideShowRunning=1)
       Return 0

    hasTrans := 0
    JEE_ScreenToClient(PVhwnd, UserToolbarX, UserToolbarY, thisX, thisY)
    positionOk := (isInRange(thisX, -2, 10) && isInRange(thisY, -2, 10)) ? 1 : 0
    If (positionOk=1 && (TLBRverticalAlign=1 || TLBRtwoColumns=1) && isTitleBarVisible=1)
    {
       hasTrans := 1
       If (applyTransform=1)
          Gdip_TranslateWorldTransform(Gu, ToolbarWinW, 0)
    } Else If (positionOk=1 && TLBRverticalAlign=0 && isTitleBarVisible=1)
    {
       hasTrans := 2
       If (applyTransform=1)
          Gdip_TranslateWorldTransform(Gu, 0, ToolbarWinH)
    }
    Return hasTrans
}

CreateOSDinfoLine(msg:=0, killWin:=0, forceDarker:=0, perc:=0, funcu:=0, typeFuncu:=0) {
    ; Critical, On
    Static prevMsg, preventKill, lastInvoked := 1

    If (TouchScreenMode=1)
    {
       hudBTNfuncu := funcu
       hudBTNtypeFuncu := typeFuncu
    } Else hudBTNtypeFuncu := hudBTNfuncu := 0

    If (killWin=1 || killWin=2 || StrLen(msg)<3)
    {
       If (A_TickCount - lastInvoked<msgDisplayTime + 900) && (preventKill=1)
       || (A_TickCount - lastInvoked<350) && (killWin=1 && slideShowRunning!=1)
       {
          If (killWin!=2)
          {
             SetTimer, RemoveTooltip, -400
             Return
          }
       }

       toolTipGuiCreated := 0
       interfaceThread.ahkPostFunction("uiAccessUpdateOSDmsg", "-", 0, 0)
       interfaceThread.ahkassign("toolTipGuiCreated", 0)
       clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       preventKill := 0
       Return
    }

    If (A_TickCount - lastInvoked<95) && (forceDarker!=1)
    {
       SetTimer, dummyPrevShowToolTip, -200
       Return
    }

    If (A_TickCount - lastInvoked<msgDisplayTime - 300) && (preventKill=1 && prevMsg!=msg && runningLongOperation!=1)
       msgBoxWrapper(appTitle ": ERROR", prevMsg, 0, 0, "error")

    addJournalEntry("OSD: " msg)
    If (!CurrentSLD && currentFileIndex!=0) || (forceDarker=1)
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x66" WindowBgrColor, 1)
    Else
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)

    preventKill := 0
    If RegExMatch(msg, "i)^(error|failed)")
    {
       preventKill := 1
       uBrushA := Gdip_BrushCreateSolid("0xEEFF2200")
    } Else If RegExMatch(msg, "i)^(WARNING|operation aborted)")
       uBrushA := Gdip_BrushCreateSolid("0xEEFFDE21")

    knobSize := imgHUDbaseUnit//3.5
    posXu := uBrushA ? knobSize : 0
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    BoxBMP := drawTextInBox(msg, OSDFontName, OSDfontSize, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0)
    If !BoxBMP
    {
       Gdip_DeleteBrush(uBrushA)
       Return
    }

    hasTrans := adjustCanvas2Toolbar(2NDglPG, 1)
    tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
    posYu := perc ? knobSize//2 : 0
    Gdip_GetImageDimensions(BoxBMP, imgW, imgH)
    If (showInfoBoxHUD>0 && FlipImgH=0 && FlipImgV=0)
    {
       thisBrush := Gdip_BrushCreateSolid("0x20" OSDbgrColor)
       unitu := lastInfoBoxBMP[1, 2] // 5
       Loop, 4
          Gdip_FillRectangle(2NDglPG, thisBrush, 0, knobSize, lastInfoBoxBMP[1,1], unitu)
       Loop, 3
          Gdip_FillRectangle(2NDglPG, thisBrush, 0, knobSize + unitu, lastInfoBoxBMP[1,1], unitu)
       Loop, 2
          Gdip_FillRectangle(2NDglPG, thisBrush, 0, knobSize + unitu *2, lastInfoBoxBMP[1,1], unitu)

       Gdip_FillRectangle(2NDglPG, thisBrush, 0, knobSize + unitu *3, lastInfoBoxBMP[1,1], unitu)
       Gdip_DeleteBrush(thisBrush)
    }

    If (hudBTNfuncu && hudBTNtypeFuncu=2)
       Gdip_FillRectangle(2NDglPG, pBrushF, imgW, 0, mainWidth - imgW, imgHUDbaseUnit*1.12)

    Gdip_DrawImage(2NDglPG, BoxBMP, posXu, posYu, imgW, imgH)
    hudBTNheightFuncu := imgH + posYu + tlbrBonusY
    hudBTNwidthFuncu := imgW + posXu + tlbrBonusX
    If uBrushA
    {
       Gdip_FillRectangle(2NDglPG, uBrushA, 0, posYu, knobSize, imgH)
       Gdip_FillRectangle(2NDglPG, uBrushA, imgW + posXu, posYu, knobSize, imgH)
    }

    omsg := msg "."
    If perc
    {
       percW := Round(mainWidth*perc)
       Gdip_FillRectangle(2NDglPG, pBrushE, percW, 0, mainWidth - percW + 1, knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushB, 0, knobSize//2, mainWidth, 3)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, percW, knobSize//2)
       omsg .= "`nProgress bar at " Round(perc*100) "%."
    }

    If hudBTNfuncu
       omsg .= "`nTemporarily clickable area."

    interfaceThread.ahkPostFunction("uiAccessUpdateOSDmsg", omsg, mainWidth, imgH)
    If (hudBTNfuncu && hudBTNtypeFuncu=1)
    {
       Gdip_FillRectangle(2NDglPG, pBrushD, posXu, posYu, knobSize//2, imgH)
    } Else If (hudBTNfuncu && hudBTNtypeFuncu=2)
    {
       Gdip_FillRectangle(2NDglPG, pBrushA, mainWidth - knobSize//2, posYu, knobSize//2, imgHUDbaseUnit*1.12 - knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushA, posXu, posYu, knobSize//2, imgHUDbaseUnit*1.12 - knobSize//2)
    }

    If hasTrans
       Gdip_ResetWorldTransform(2NDglPG)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
    trGdip_DisposeImage(BoxBMP, 1)
    Gdip_DeleteBrush(uBrushA)
    toolTipGuiCreated := 1
    prevMsg := msg
    If (prevMsg!=msg)
       lastInvoked := A_TickCount

    If ((perc || hudBTNfuncu) && InStr(mainCompiledPath, "\sucan twins") && !InStr(msg, "zoom level"))
    && runningLongOperation!=1 && (A_TickCount - lastOSDtooltipInvoked > 325)
       interfaceThread.ahkPostFunction("sndBeep", 1654, 100)

    lastOSDtooltipInvoked := A_TickCount
    If (forceDarker!=1)
       interfaceThread.ahkassign("toolTipGuiCreated", 1)
}

BlackedCreator(thisOpacity, killWin:=0) {
    Critical, On
    Static lastInvoked := 1
    If (killWin=1)
    {
       Gui, BlackGuia: Destroy
       Return
    }

    If (A_TickCount - lastInvoked<250)
       Return

    lastInvoked := A_TickCount
    Gui, BlackGuia: Destroy
    Sleep, 5
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    Gui, BlackGuia: -DPIScale -Caption +Owner%PVhwnd% +ToolWindow +E0x80000 +E0x20 +hwndhGuiBlack
    Gui, BlackGuia: Color, c%OSDbgrColor%
    Gui, BlackGuia: Margin, 0, 0
    Gui, BlackGuia: Add, Text,+0x80 c%OSDtextColor% w%mainWidth% h%mainHeight% gRemoveTooltip, %msg%
    JEE_ClientToScreen(hPicOnGui1, 1, 1, GuiX, GuiY)
    WinSet, Transparent, %thisOpacity%, ahk_id %hGuiBlack%
    WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight%, ahk_id %hGuiBlack%
    ; GuiX := GuiY := 0
    Gui, BlackGuia: Show, NoActivate AutoSize x%GuiX% y%GuiY%, GuiBlackedWin
    ; SetParentID(PVhwnd, hGuiBlack)
}

Fnt_GetListOfFonts() {
; function stripped down from Font Library 3.0 by jballi
; from https://autohotkey.com/boards/viewtopic.php?t=4379

    Static Dummy65612414
          ,HWND_DESKTOP := 0   ;-- Device constants
          ,LF_FACESIZE  := 32  ;-- In TCHARS - LOGFONT constants

    ;-- Initialize and populate LOGFONT structure
    Fnt_EnumFontFamExProc_List := ""
    p_CharSet := 1
    p_Flags := 0x800
    VarSetCapacity(LOGFONT,A_IsUnicode ? 92:60,0)
    NumPut(p_CharSet,LOGFONT,23,"UChar")                ;-- lfCharSet

    ;-- Enumerate fonts
    EFFEP := RegisterCallback("Fnt_EnumFontFamExProc","F")
    hDC := Gdi_GetDC(HWND_DESKTOP)
    DllCall("gdi32\EnumFontFamiliesExW"
       ,"Ptr", hDC                                      ;-- hdc
       ,"Ptr", &LOGFONT                                 ;-- lpLogfont
       ,"Ptr", EFFEP                                    ;-- lpEnumFontFamExProc
       ,"Ptr", p_Flags                                  ;-- lParam
       ,"UInt", 0)                                      ;-- dwFlags (must be 0)

    DllCall("user32\ReleaseDC","Ptr",HWND_DESKTOP,"Ptr",hDC)
    DllCall("GlobalFree", "Ptr", EFFEP)
    Return Fnt_EnumFontFamExProc_List
}

Fnt_EnumFontFamExProc(lpelfe,lpntme,FontType,p_Flags) {
    Fnt_EnumFontFamExProc_List := 0
    Static Dummy62479817
          ,LF_FACESIZE := 32     ;-- In TCHARS - LOGFONT constants

    l_FaceName := StrGet(lpelfe+28,LF_FACESIZE)
    FontList.Push(l_FaceName)    ;-- Append the font name to the list
    Return 1                     ;-- Continue enumeration
}

ST_Insert(insert,input,pos=1) {
  Length := StrLen(input)
  ((pos > 0) ? (pos2 := pos - 1) : (((pos = 0) ? (pos2 := StrLen(input),Length := 0) : (pos2 := pos))))
  output := SubStr(input, 1, pos2) . insert . SubStr(input, pos, Length)
  If (StrLen(output) > StrLen(input) + StrLen(insert))
     ((Abs(pos) <= StrLen(input)/2) ? (output := SubStr(output, 1, pos2 - 1) . SubStr(output, pos + 1, StrLen(input)))
     : (output := SubStr(output, 1, pos2 - StrLen(insert) - 2) . SubStr(output, pos - StrLen(insert), StrLen(input))))
  Return output
}

initCompiled(mode) {
   fullPath2exe := GetModuleFileNameEx(QPVpid)
   If (mode=1)
   {
      zPlitPath(fullPath2exe, 0, OutFileName, OutDir)
      mainCompiledExe := OutFileName
      mainCompiledPath := OutDir
      thumbsCacheFolder := OutDir "\thumbs-cache"
      mainSettingsFile := OutDir "\" mainSettingsFile
      mainRecentsFile := OutDir "\" mainRecentsFile
      mainFavesFile := OutDir "\" mainFavesFile
      miniFavesFile := OutDir "\" miniFavesFile
   } Else
   {
      mainCompiledPath := A_ScriptDir
      unCompiledExePath := Chr(34) fullPath2exe Chr(34) A_Space Chr(34) A_ScriptFullPath Chr(34)
   }
}

MenuInvokeSHopenWith() {
   imgPath := StrReplace(getIDimage(currentFileIndex), "||")
   invokeSHopenWith(imgPath)
}

ReadSettingsAutoCropPanel(act:=0) {
    RegAction(act, "AutoCropAdaptiveMode",, 1)
    RegAction(act, "ResizeDestFolder",, 6)
    RegAction(act, "ResizeUseDestDir",, 1)
    RegAction(act, "UIcropThreshold",, 2, 0, 99)
    RegAction(act, "userActionConflictingFile",, 2, 1, 3)
    RegAction(act, "userJpegQuality",, 2, 1, 100)
    RegAction(act, "usrAutoCropColorTolerance",, 2, 0, 255)
    RegAction(act, "usrAutoCropDeviation",, 2, -50, 50)
    RegAction(act, "usrAutoCropDeviationPixels",, 1)
    RegAction(act, "usrAutoCropDeviationSnap",, 1)
    RegAction(act, "usrAutoCropGenerateSelection",, 1)
}

PanelImgAutoCrop() {
    Global UIcropThreshold, btnFldr, infoCropTolerance, infoCropThreshold, infoCropDeviation, mainBtnACT, editF5
    If (thumbsDisplaying=1)
       ToggleThumbsMode()

    If (vpIMGrotation>0)
    {
       vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    }

    thisBtnHeight := createSettingsGUI(17, A_ThisFunc)
    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 220

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       slide2Wid := slide2Wid + 75
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsAutoCropPanel()
    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    filesElected := getSelectedFiles(0, 1)
    UIcropThreshold := Round(usrAutoCropImgThreshold * 100)
    if (StrLen(UserMemBMP)>2 && !markedSelectFile)
       usrAutoCropGenerateSelection := 1

    Gui, Add, Text, x15 y15 Section, Please adjust the following parameters for best results.
    Gui, Add, Text, xs y+8 w%slide2Wid% vinfoCropTolerance, Color variation tolerance: %usrAutoCropColorTolerance%
    Gui, Add, Text, x+1 yp, Image corners preview
    Gui, -DPIScale
    Gui, Add, Text, xp+1 y+1 w220 h220 +0xE gTglAutoCropBorderzSize +hwndhCropCornersPic +TabStop, -
    Gui, +DPIScale
    Gui, Add, Slider, Center xs yp+1 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vusrAutoCropColorTolerance Range0-254, % usrAutoCropColorTolerance
    Gui, Add, Text, xs y+8 w%slide2Wid% vinfoCropThreshold, Image threshold: %UIcropThreshold%
    Gui, Add, Slider, Center xs y+5 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vUIcropThreshold Range0-99, % UIcropThreshold
    Gui, Add, Text, xs y+8 w%slide2Wid% gresetAutoCropDeviation vinfoCropDeviation +TabStop, Margins deviation factor: %usrAutoCropDeviation%%measureUnit%
    Gui, Add, Slider, Center xs y+5 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vusrAutoCropDeviation Range-50-50, %usrAutoCropDeviation%

    Gui, Add, Checkbox, y+10 w%slide2Wid% gUpdateAutoCropParams Checked%usrAutoCropDeviationSnap% vusrAutoCropDeviationSnap, Snap to original image edges
    Gui, Add, Checkbox, x+1 gUpdateAutoCropParams Checked%usrAutoCropDeviationPixels% vusrAutoCropDeviationPixels, Deviation factor in pixels
    Gui, Add, Checkbox, xs y+10 w%slide2Wid% gUpdateAutoCropParams Checked%usrAutoCropGenerateSelection% vusrAutoCropGenerateSelection, Generate an image selection
    Gui, Add, Checkbox, x+1 gUpdateAutoCropParams Checked%AutoCropAdaptiveMode% vAutoCropAdaptiveMode, Adaptive color variations
 
    thisW := (filesElected>1) ? "" : "w1"
    thisH := (filesElected>1) ? "" : "h1"
    thisY := (filesElected>1) ? "+20" : "p-20"
    Gui, Add, Checkbox, xs y+10 gTglRszDestFoldr %thisW% %thisH% Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder: 
    Gui, Add, Edit, xp+10 y+5 wp %thisH% r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 %thisW% %thisH% gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs y+7 %thisW% %thisH%, On file name conflicts
    Gui, Add, DropDownList, x+5 w150 %thisW% %thisH% gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10 %thisW% %thisH%, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 %thisH% number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality

    if (StrLen(UserMemBMP)>2 && !markedSelectFile)
       GuiControl, Disable, usrAutoCropGenerateSelection

    If (filesElected>1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, Files selected to process: %filesElected%.`nMulti-threaded processing not yet implemented.`nFiles in unsupported write formats will be skipped.
       Gui, Font, Normal
    } 

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Add, Button, xs y%thisY% h%thisBtnHeight% w35 gBtnPrevImg +hwndhBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gBtnNextImg +hwndhBtnNextImg, >>
    ToolTip2ctrl(hBtnNextImg, "Next image")
    ToolTip2ctrl(hBtnPrevImg, "Previous image")

    If (filesElected>1)
    {
       Gui, Add, Button, x+5 hp w%btnWid% Default gBTNautoCropRealtime vmainBtnACT, &Viewport preview
       Gui, Add, Button, x+5 hp w%btnWid% gBTNsaveAutoCroppedFile, &Process files...
       Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    } Else
    {
       Gui, Add, Button, x+5 hp w90 Default gBTNautoCropRealtime vmainBtnACT, &Apply
       Gui, Add, Button, x+5 hp w%btnWid% gBTNsaveAutoCroppedFile, &Save image
       Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&lose
    }

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Automatic image crop: " appTitle, winPos)
    Sleep, 1
    captureImgCorners(useGdiBitmap())
    ResetImgLoadStatus()
}

resetAutoCropDeviation() {
    GuiControl, SettingsGUIA:, usrAutoCropDeviation, 0
    UpdateAutoCropParams()
}

UpdateAutoCropParams() {
    If (AnyWindowOpen!=17)
       Return

    GuiControlGet, UIcropThreshold
    GuiControlGet, usrAutoCropColorTolerance
    GuiControlGet, usrAutoCropGenerateSelection
    GuiControlGet, usrAutoCropDeviation
    GuiControlGet, usrAutoCropDeviationSnap
    GuiControlGet, usrAutoCropDeviationPixels
    GuiControlGet, AutoCropAdaptiveMode
    GuiControlGet, ResizeUseDestDir
    GuiControlGet, ResizeDestFolder
    GuiControlGet, userActionConflictingFile
    GuiControlGet, userJpegQuality

    usrAutoCropImgThreshold := UIcropThreshold/100
    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    GuiControl, SettingsGUIA:, infoCropTolerance, Color variation tolerance: %usrAutoCropColorTolerance%
    GuiControl, SettingsGUIA:, infoCropThreshold, Image threshold: %UIcropThreshold%
    GuiControl, SettingsGUIA:, infoCropDeviation, Margins deviation factor: %usrAutoCropDeviation%%measureUnit%
    SetTimer, WriteSettingsAutoCropPanel, -200
}

WriteSettingsAutoCropPanel() {
   ReadSettingsAutoCropPanel(1)
}

TglAutoCropBorderzSize() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 900) && (AutoCropBordersSize!=5)
       AutoCropBordersSize := 5
    Else
       AutoCropBordersSize := (AutoCropBordersSize=15) ? 30 : 15
    captureImgCorners(useGdiBitmap())
    lastInvoked := A_TickCount
}

captureImgCorners(whichBmp) {
   If !whichBmp
      Return

   cornersBMP2 := coreCaptureImgCorners(whichBmp)
   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP2)
   SetImage(hCropCornersPic, hBitmap)
   trGdip_DisposeImage(cornersBMP2, 1)
   Gdi_DeleteObject(hBitmap)
}

coreCaptureImgCorners(whichBmp, thisSize:=0, thisBoxSize:=0) {
    boxSize := (thisBoxSize=0) ? 220 : thisBoxSize
    realSize := (thisSize=0) ? AutoCropBordersSize : thisSize
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, boxSize, boxSize, coreDesiredPixFmt)
    If !cornersBMP
       Return

    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBmp, imgW, imgH)
    If (editingSelectionNow=1)
    {
       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       X1 := Y1 := 0
       X2 := ImgSelW := imgW
       Y2 := ImgSelH := imgH
    }

    Loop, 3
    {
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, boxSize//2, boxSize//2, X1, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, 0, boxSize//2, boxSize//2, X2 - realSize, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, boxSize//2, boxSize//2, boxSize//2, X1, Y2 - realSize, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, boxSize//2, boxSize//2, boxSize//2, X2 - realSize, Y2 - realSize, realSize, realSize)
    }

    Static borderSize := 8
    Gdip_DeleteGraphics(G)
    cornersBMP2 := trGdip_CreateBitmap(A_ThisFunc, boxSize+borderSize, boxSize+borderSize, coreDesiredPixFmt)
    If cornersBMP2
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP2, 3)
       If G2
       {
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, cornersBMP, borderSize//2, borderSize//2)
       }
    }

    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(cornersBMP, 1)
    Return cornersBMP2
}

AutoCropAction(zBitmap, varTolerance, threshold, silentMode:=0, forceNoSel:=0) {
   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 0", 0, 0, 0.001)

   aBitmap := trGdip_BitmapConvertGray(zBitmap)
   If !aBitmap
   {
      If (silentMode=0)
      {
         showTOOLtip("Failed to process image for auto-cropping")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   Gdip_GetImageDimensions(aBitmap, Width, Height)
   pBitmap := trGdip_ResizeBitmap(A_ThisFunc, aBitmap, Width//2, Height//2, 0)
   trGdip_DisposeImage(aBitmap, 1)
   If !pBitmap
   {
      If (silentMode=0)
      {
         showTOOLtip("Failed to process image for auto-cropping")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   ; pBitmap := aBitmap
   alphaUniform := Gdip_TestBitmapUniformity(pBitmap, 3, maxLevelIndex, maxLevelPixels)
   If (alphaUniform=1)
   {
      If (silentMode=0)
      {
         showTOOLtip("The image seems to be uniformly colored")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   selCoords := CoreAutoCropAlgo(pBitmap, varTolerance, threshold)
   trGdip_DisposeImage(pBitmap, 1)
   If (selCoords="error")
   {
      SoundBeep, 300, 100
      showTOOLtip("Auto-crop processing aborted by user")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   selCoords := StrSplit(selCoords, ",")
   X1 := selCoords[1], Y1 := selCoords[2]
   X2 := selCoords[3], Y2 := selCoords[4]

   If (silentMode=0)
   {
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, -500
   }

   If (usrAutoCropGenerateSelection=0 || forceNoSel=1)
   {
      newW := X2 - X1
      newH := Y2 - Y1
      kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, zBitmap, X1, Y1, newW, newH)
      return kBitmap
   } Else
   {
      VPselRotation := innerSelectionCavityX := innerSelectionCavityY := EllipseSelectMode := 0
      ImgSelX1 := X1, ImgSelY1 := Y1
      ImgSelX2 := X2, ImgSelY2 := Y2
      defineRelativeSelCoords(Width, Height)
   }
}

CoreAutoCropAlgo(pBitmap, varTolerance, threshold, silentMode:=0) {
   If !pBitmap
   {
      addJournalEntry(A_ThisFunc "(): no bitmap given for auto-cropping")
      Return "error"
   }

   interfaceThread.ahkassign("canCancelImageLoad", 1)
   Gdip_GetImageDimensions(pBitmap, Width, Height)
   maxThresholdHitsW := Round(Width*threshold) + 1
   If (maxThresholdHitsW>Width//2)
      maxThresholdHitsW := Width//2

   maxThresholdHitsH := Round(Height*threshold) + 1
   If (maxThresholdHitsH>Height//2)
      maxThresholdHitsH := Height//2

   If (threshold=0)
      maxThresholdHitsW := maxThresholdHitsH := 1

   c := Gdip_GetPixelColor(pBitmap, 1, 1, 2)
   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   If E1
      Return "error"

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 1 - Y1", 0, 0, 0.1)

   prevR1 := firstR1 := c[1]
   x := y := ToleranceHits := abortImgLoad := 0
   Loop %Height%
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      y++
      vX := 0, vY := y - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vX := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Width%
      {
         pX := A_Index - 1, pY := y - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
     ;  sleep, 10
      ;    ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsW " [" varTolerance "]" "`n" firstR1 ", " primeR1a ", " primeR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.2, R1 + varTolerance//1.2) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsW)
         {
            ToleranceHits++
         } Else
         {
            Y1 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If Y1
      {
         Y1 := y - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 2 - X1", 0, 0, 0.3)

   prevR1 := firstR1
   x := y := ToleranceHits := 0
   Loop %Width% 
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      x++
      vY := 0, vX := x - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vY := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Height%
      {
         pY := A_Index - 1, pX := x - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsH "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsH)
         {
            ToleranceHits++
         } Else
         {
            X1 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If X1
      {
         X1 := x - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 3 - Y2", 0, 0, 0.5)

   Gdip_UnlockBits(pBitmap, BitmapData1)
   Gdip_ImageRotateFlip(pBitmap, 2)
   c := Gdip_GetPixelColor(pBitmap, 1, 1, 2)
   prevR1 := firstR1 := c[1]
   x := y := ToleranceHits := 0
   E2 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   If E2
      Return "error"

   Loop %Height%
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      y++
      vX := 0, vY := y - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vX := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Width%
      {
         pX := A_Index - 1, pY := y - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsW "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsW)
         {
            ToleranceHits++
         } Else
         {
            Y2 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If Y2
      {
         Y2 := Height - y - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 4 - X2", 0, 0, 0.8)
   prevR1 := firstR1
   x := y := ToleranceHits := 0
   Loop %Width% 
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      x++
      vY := 0, vX := x - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vY := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Height%
      {
         pY := A_Index - 1, pX := x - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsH "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsH)
         {
            ToleranceHits++
         } Else
         {
            X2 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If X2
      {
         X2 := Width - x - 1
         Break
      }
   }

   deviationW := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Width/100)*usrAutoCropDeviation)
   deviationH := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Height/100)*usrAutoCropDeviation)
   If (usrAutoCropDeviationSnap=1 && X1>2) || (usrAutoCropDeviationSnap=0)
      X1 -= deviationW
   If (usrAutoCropDeviationSnap=1 && Y1>2) || (usrAutoCropDeviationSnap=0)
      Y1 -= deviationH
   If (usrAutoCropDeviationSnap=1 && X2<Width-3) || (usrAutoCropDeviationSnap=0)
      X2 += deviationW
   If (usrAutoCropDeviationSnap=1 && Y2<Height-3) || (usrAutoCropDeviationSnap=0)
      Y2 += deviationH

   ; ToolTip, % X1 "," Y1 "--" X2 "," Y2 "`n" maxThresholdHitsW "--" maxThresholdHitsH "--" firstR1, , , 2
   If (X1="" || X1>Width - 2)
      X1 := Width - 3
   If (Y1="" || Y1>Height - 2)
      Y1 := Height - 3
   If (X2="" || X2<3)
      X2 := 3
   If (Y2="" || Y2<3)
      Y2 := 3

   X2 := X2*2, Y2 := Y2*2
   X1 := X1*2, Y1 := Y1*2
   If (X2 < X1 - 2)
      X2 := X1 + 2
   If (Y2 < Y1 - 2)
      Y2 := Y1 + 2

   selCoords := x1 "," y1 "," x2 "," y2
   Gdip_UnlockBits(pBitmap, BitmapData1)
   If (abortImgLoad>1)
      selCoords := "error"

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nDONE", 0, 0, 0.99)
   interfaceThread.ahkassign("canCancelImageLoad", 0)
   Return selCoords
}

BTNsaveAutoCroppedFile() {
    UpdateAutoCropParams()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       batchAutoCropFiles()
       Return
    }

   BTNautoCropRealtime()
   BtnCloseWindow()
   PanelSaveImg()
}

coreAutoCropFileProcessing(imgPath, file2save, silentMode) {
    oBitmap := LoadBitmapFromFileu(imgPath)
    If !oBitmap
       Return -3

    Gdip_GetImageDimensions(oBitmap, oImgW, oImgH)
    pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    kBitmap := AutoCropAction(oBitmap, usrAutoCropColorTolerance, usrAutoCropImgThreshold, silentMode, 1)
    trGdip_DisposeImage(oBitmap, 1)
    If !kBitmap
       Return -1

    Gdip_GetImageDimensions(kBitmap, imgW, imgH)
    If (imgW>oImgW-1) && (imgH>oImgH-1)
       Return -2

    If InStr(pixFmt, "argb")
    {
       isUniform := Gdip_TestBitmapUniformity(kBitmap, 7, maxLevelIndex)
       If (isUniform=1 && (isInRange(maxLevelIndex, 0, 5) || isInRange(maxLevelIndex, 250, 255)))
          Gdip_BitmapSetColorDepth(kBitmap, 24)
    } Else Gdip_BitmapSetColorDepth(kBitmap, 24)

    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 1
    }

    r := Gdip_SaveBitmapToFile(kBitmap, file2save, 90)
    If (r=-2 || r=-1)
       r := SaveFIMfile(file2save, kBitmap)

    trGdip_DisposeImage(kBitmap, 1)
    Return r
}

batchAutoCropFiles() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to crop " filesElected " files? The auto-crop algorithm may take some time to finish going through all of them. Hold ESC to abandon it."
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"

      If (userActionConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."

      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   Sleep, 25
   showTOOLtip("Performing image auto-crop on " filesElected " files, please wait")
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   countFilez := countTFilez := skippedFiles := failedFiles := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (A_TickCount - prevMSGdisplay>3000)
      {
         If failedFiles
            someErrors := "`nErrors occured for " failedFiles "files..."
         If skippedFiles
            someErrors .= "`n" skippedFiles "files were skipped"

         showTOOLtip("Performing image auto-crop on " countTFilez "/" filesElected " files, please wait..." someErrors, 0, 0, (countTFilez + skippedFiles)/filesElected)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      If (!RegExMatch(imgPath, saveTypesRegEX) || StrLen(imgPath)<2)
      {
         skippedFiles++
         Continue
      }

      If (ResizeUseDestDir=1)
      {
         zPlitPath(imgPath, 0, OutFileName, OutDir)
         destImgPath := ResizeDestFolder "\" OutFileName
      } Else destImgPath := imgPath

      If (ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionConflictingFile, performOverwrite)
      }

      countTFilez++
      If !destImgPath
      {
         skippedFiles++
         Continue
      }

      changeMcursor()
      r := coreAutoCropFileProcessing(imgPath, destImgPath, 0)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If failedFiles
      someErrors := "`nErrors occured for " failedFiles "files..."
   If skippedFiles
      someErrors .= "`n" skippedFiles "files were skipped"
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countFilez " out of " filesElected " selected files were processed until now..." someErrors)
   Else
      showTOOLtip(countFilez " out of " countTFilez " selected images were automatically cropped" someErrors)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNautoCropRealtime() {
  Static wasAutoCropped := 0

  lockSelectionAspectRatio := 1
  defineSelectionAspectRatios()
  GuiControl, SettingsGUIA: Disable, mainBtnACT
  SetTimer, reactivateMainBtnACT, -350
  If (AnyWindowOpen=17)
     UpdateAutoCropParams()
  Else If (AnyWindowOpen=12)
     usrAutoCropGenerateSelection := 1

  If (usrAutoCropGenerateSelection=0)
  {
     editingSelectionNow := 0
     wasAutoCropped := performAutoCropNow := 1
     updateUIctrl()
     RefreshImageFile()
     MouseMoveResponder()
  } Else
  {
     resultu := getIDimage(currentFileIndex)
     If FileExist(resultu)
     {
        thumbBMP := LoadBitmapFromFileu(resultu)
        FlipImgV := FlipImgH := vpIMGrotation := performAutoCropNow := 0
        If thumbBMP
        {
           AutoCropAction(thumbBMP, usrAutoCropColorTolerance, usrAutoCropImgThreshold)
           trGdip_DisposeImage(thumbBMP, 1)
        }

        editingSelectionNow := performAutoCropNow := 1
        If (wasAutoCropped=0)
           dummyTimerDelayiedImageDisplay(50)
        Else
           RefreshImageFile()
     }
  }

  If (AnyWindowOpen=17)
  {
     captureImgCorners(useGdiBitmap())
  } Else If (editingSelectionNow=1 && AnyWindowOpen=12)
  {
     GuiControl, SettingsGUIA: Enable, jpegDoCrop
     GuiControl, SettingsGUIA: , jpegDoCrop, 1
  }
}

coreWIAsimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   Try wiaImg := WIA_LoadImage(imgPath)
   If !IsObject(wiaImg)
   {
      addJournalEntry("Failed to load and process image file using WIA`n" imgPath)
      Return 0
   }

   imgW := wiaImg.Width, imgH := wiaImg.Height
   If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
   {
      If (relativeImgSelCoords=1 && editingSelectionNow=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      wiaImg := WIA_CropImage(wiaImg, X1, Y1, X2, Y2)
   }

   If (rotateAngle!=0 && isNumber(rotateAngle))
      wiaImg := WIA_RotateImage(wiaImg, rotateAngle)

   If (SimpleOperationsFlipH=1)
      wiaImg := Wia_FlipImage(wiaImg, "Horizontal")
   If (SimpleOperationsFlipV=1)
      wiaImg := Wia_FlipImage(wiaImg, "Vertical")

   imgW := wiaImg.Width, imgH := wiaImg.Height
   thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
   thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
   changeMcursor()
   If (IsObject(wiaImg) && ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
      Try wiaImg := WIA_ScaleImage(wiaImg, thisW, thisH, 0)

    If (FileExist(file2save) && IsObject(wiaImg))
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    If IsObject(wiaImg)
       r := WIA_SaveImage(wiaImg, file2save)
    Else r := 0

    If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
    {
       r := 0
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

   wiaImg := ""
   Return !r
}

coreGdipSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
    Static imgOrientOpt := {"i000":0, "i100":1, "i200":2, "i300":3, "i010":4, "i110":5, "i210":6, "i310":7, "i001":6, "i101":7, "i201":4, "i301":5, "i011":2, "i111":3, "i211":0, "i311":1}
    oBitmap := trGdip_CreateBitmapFromFile(imgPath)
    If StrLen(oBitmap)>2
    {
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
       pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
       If (InStr(pixFmt, "CMYK") || InStr(pixFmt, "48-") || InStr(pixFmt, "64-"))
          ER := Gdip_BitmapSetColorDepth(oBitmap, 32, 1)
    } Else mustOpenWithWia := 1

    capMaxGDIbmpSize32bits()
    If (imgW<1) || (imgH<1) || InStr(pixFmt, "0x") || ER || isImgSizeTooLarge(imgW, imgH)
       mustOpenWithWia := 1

    If (mustOpenWithWia=1)
    {
       addJournalEntry("Failed to load and process image file using GDI+`n" imgPath)
       trGdip_DisposeImage(oBitmap, 1)
       r := coreWIAsimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
       Return r
    }

    If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
    {
       newPixFmt := InStr(pixFmt, "argb") ? "0x26200A" : "0x21808"   ; 32-bits // 24-bits
       If (relativeImgSelCoords=1 && editingSelectionNow=1)
          calcRelativeSelCoords(oBitmap, imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, oBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, newPixFmt)
       If zBitmap
       {
          trGdip_DisposeImage(oBitmap, 1)
          oBitmap := zBitmap
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    imgFoperation := (rotateAngle=90) ? 1 : 0
    imgFoperation := (rotateAngle=180) ? 2 : imgFoperation
    imgFoperation := (rotateAngle=270) ? 3 : imgFoperation
    imgFoperation := imgOrientOpt["i" imgFoperation SimpleOperationsFlipH SimpleOperationsFlipV]
    If (imgFoperation>0)
       flipErr := Gdip_ImageRotateFlip(oBitmap, imgFoperation)

    If flipErr
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    If (ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
    {
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
       newPixFmt := InStr(pixFmt, "argb") ? "0x26200A" : "0x21808"   ; 32-bits // 24-bits
       resizeFilter := (ResizeQualityHigh=1) ? 7 : 5
       thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
       thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
       changeMcursor()
       zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, thisW, thisH, 0, resizeFilter, newPixFmt)
       If zBitmap
       {
          trGdip_DisposeImage(oBitmap, 1)
          oBitmap := zBitmap
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    If StrLen(oBitmap)>2
    {
       tempFileExists := "r"
       If FileExist(file2save)
       {
          Try FileSetAttrib, -R, % file2save
          Sleep, 0
          FileMove, % file2save, % file2save "-tmp"
          If !ErrorLevel
             tempFileExists := 1
          Sleep, 0
       }

       r := Gdip_SaveBitmapToFile(oBitmap, file2save, 90)
       If (r=-2 || r=-1)
          r := SaveFIMfile(file2save, oBitmap)

       If (r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
       {
          FileDelete, % file2save
          Sleep, 0
          FileMove, % file2save "-tmp", % file2save
       } Else If (tempFileExists=1)
          FileDelete, % file2save "-tmp"

       trGdip_DisposeImage(oBitmap, 1)
    } Else r := 1

    Return r
}

coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
  maxLimitReached := 0 ; (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
  If (RegExMatch(imgPath, RegExFIMformPtrn) || (RegExMatch(imgPath, "i)(.\.(png|tiff|tif))$") && (maxLimitReached!=1 && wasInitFIMlib=1)))
     r := coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
  Else
     r := coreGdipSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
  Return r
}

coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
    Sleep, 0
    loadArgs := 0
    GFT := FreeImage_GetFileType(imgPath)
    If (GFT=34)
       loadArgs := (userHQraw=1) ? 0 : 5
    Else If (GFT=2)
       loadArgs := 8

    hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
    If !hFIFimgA
    {
       addJournalEntry("Failed to load and process image file using FreeImage library`n" imgPath)
       Return "err"
    }

    If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
    {
       FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
       If (relativeImgSelCoords=1 && editingSelectionNow=1)
          calcRelativeSelCoords("--", imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       x1 := Round(X1), y1 := Round(Y1)
       x2 := Round(X2), y2 := Round(Y2)
       changeMcursor()
       hFIFimgB := FreeImage_Copy(hFIFimgA, X1, Y1, X2, Y2)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    If (rotateAngle>0)
    {
       changeMcursor()
       hFIFimgB := FreeImage_Rotate(hFIFimgA, rotateAngle)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    If (SimpleOperationsFlipH=1)
       FreeImage_FlipHorizontal(hFIFimgA)
    If (SimpleOperationsFlipV=1)
       FreeImage_FlipVertical(hFIFimgA)

    If (ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
    {
       FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
       resizeFilter := (ResizeQualityHigh=1) ? 4 : 0
       thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
       thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
       changeMcursor()
       hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, resizeFilter)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    tempFileExists := "r"
    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    saveArg := 0
    If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
       saveArg := clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
    Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
       saveArg := clampInRange(Round(userJpegQuality), 1, 100)

    changeMcursor()
    r := FreeImage_Save(hFIFimgA, file2save, saveArg)

    FreeImage_UnLoad(hFIFimgA)
    If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
    {
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

    Return !r
}

PanelSimpleResizeRotate(modus:="") {
    Global mainBtnACT, btnFldr, editF5
    If !PanelsCheckFileExists()
       Return

    If (vpIMGrotation>0)
    {
       FlipImgV := FlipImgH := vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    } Else If (FlipImgH=1 || FlipImgV=1)
    {
       FlipImgV := FlipImgH := 0
       dummyTimerDelayiedImageDisplay(50)
    } 

    imgPath := getIDimage(currentFileIndex)
    filesElected := getSelectedFiles(0, 1)
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    If (!filesElected && !RegExMatch(imgPath, thisRegEX) && modus!="forced")
    {
       CloseWindow()
       Sleep, 5
       PanelResizeImageWindow()
       Return
    }

    thisBtnHeight := createSettingsGUI(18, A_ThisFunc)
    ReadSettingsImageProcessing()
    btnWid := 100
    txtWid := slideWid := 280
    If (editingSelectionNow!=1)
       SimpleOperationsDoCrop := 0

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }
    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    Gui, Add, Text, x15 y15 Section, Rotate / flip:
    Gui, Add, DropDownList, x+5 w100 AltSubmit Choose%SimpleOperationsRotateAngle% vSimpleOperationsRotateAngle, 0°|90°|180°|-90° [270°]
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipV% vSimpleOperationsFlipV, Vertical
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipH% vSimpleOperationsFlipH, Horizontal
    ; Gui, Add, ComboBox, x+5 w100 vSimpleOperationsScaleXimgFactor, 5 `%|10 `%|20 `%|50 `%|75 `%|100 `%|200 `%|500 `%|950 `%|%SimpleOperationsScaleXimgFactor%||
    ; Gui, Add, ComboBox, x+5 w100 vSimpleOperationsScaleYimgFactor, 5 `%|10 `%|20 `%|50 `%|75 `%|100 `%|200 `%|500 `%|950 `%|%SimpleOperationsScaleYimgFactor%||
    Gui, Add, Checkbox, xs y+10 gTglRszMustPerformResize Checked%ResizeMustPerform% vResizeMustPerform, Perform image resizing (W x H):
    Gui, Add, Edit, xs+15 y+5 w100 r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleXimgFactor, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 wp r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleYimgFactor, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 wp+30 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `% perc.
    Gui, Add, Checkbox, xs y+10 Checked%SimpleOperationsDoCrop% vSimpleOperationsDoCrop, Crop image(s) to selected area in viewport
    Gui, Add, Checkbox, xs y+10 Checked%ResizeQualityHigh% vResizeQualityHigh, High quality image resampling
    Gui, Add, Checkbox, xs y+15 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the specified destination folder:
    Gui, Add, Edit, xp+15 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs+15 y+7 , In destination folder, on file name conflicts
    Gui, Add, DropDownList, x+5 w140 gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite

    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    If (editingSelectionNow!=1)
       GuiControl, Disable, SimpleOperationsDoCrop

    If (filesElected>1)
    {
       msgFriendly := filesElected " files are selected for processing."
       Gui, Font, Bold
       Gui, Add, Text, xs y+20 w%txtWid%, % msgFriendly
       Gui, Font, Normal
       Gui, Add, Text, xs y+10 w%txtWid%, Files in unsupported write formats will be skipped.
    }

    If (filesElected<2)
    {
       Gui, Add, Button, xs+0 y+25 h%thisBtnHeight% w35 gPreviousPicture +hwndhBtnPrevImg, <<
       Gui, Add, Button, x+5 hp wp gNextPicture +hwndhBtnNextImg, >>
       ToolTip2ctrl(hBtnNextImg, "Next image")
       ToolTip2ctrl(hBtnPrevImg, "Previous image")
       ; Gui, Add, Button, x+5 hp w%btnWid%  gBtnSaveNowSimpleProcessing , &Save image
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnSaveAsSimpleProcessing vmainBtnACT, &Save image as...
    } Else Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% wp Default gBtnPerformSimpleProcessing, &Perform operations on the files

    Gui, Add, Button, xs y+5 h%thisBtnHeight% w%btnWid% gBtnInvokePanelResizeImageWindow, &Advanced mode
    Gui, Add, Button, x+5 hp w80 gResizePanelHelpBoxInfo, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / crop / rotate image [simple mode]: " appTitle)
    ResetImgLoadStatus()
    SetTimer, TglRszMustPerformResize, -300
}

BtnInvokePanelResizeImageWindow() {
   BtnCloseWindow()
   Sleep, 10
   PanelResizeImageWindow()
}

BtnSaveAsSimpleProcessing() {
    BtnPerformSimpleProcessing()
}

BtnSaveNowSimpleProcessing() {
    BtnPerformSimpleProcessing("no-prompt")
}

TglRszMustPerformResize() {
    Gui, SettingsGUIA: Default
    GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform

    actu := (ResizeMustPerform=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, SimpleOperationsScaleXimgFactor
    GuiControl, % actu, SimpleOperationsScaleYimgFactor
    GuiControl, % actu, ResizeInPercentage
}

BtnPerformSimpleProcessing(dummy:=0, contextu:="") {
    If (contextu!="extern")
    {
       Gui, SettingsGUIA: Default
       GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform
       GuiControlGet, SimpleOperationsFlipV, SettingsGUIA:, SimpleOperationsFlipV
       GuiControlGet, SimpleOperationsFlipH, SettingsGUIA:, SimpleOperationsFlipH
       GuiControlGet, SimpleOperationsDoCrop, SettingsGUIA:, SimpleOperationsDoCrop
       GuiControlGet, SimpleOperationsRotateAngle, SettingsGUIA:, SimpleOperationsRotateAngle
       GuiControlGet, SimpleOperationsScaleXimgFactor, SettingsGUIA:, SimpleOperationsScaleXimgFactor
       GuiControlGet, SimpleOperationsScaleYimgFactor, SettingsGUIA:, SimpleOperationsScaleYimgFactor
       GuiControlGet, ResizeQualityHigh, SettingsGUIA:, ResizeQualityHigh
       GuiControlGet, ResizeDestFolder, SettingsGUIA:, ResizeDestFolder
       GuiControlGet, ResizeUseDestDir, SettingsGUIA:, ResizeUseDestDir
       GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
       GuiControlGet, userJpegQuality, SettingsGUIA:, userJpegQuality
       GuiControlGet, userActionConflictingFile, SettingsGUIA:, userActionConflictingFile

       userJpegQuality := clampInRange(userJpegQuality, 1, 100)
       RegAction(1, "userJpegQuality")
       cleanResizeUserOptionsVars()
       If (ResizeMustPerform=0 && SimpleOperationsRotateAngle=1 && SimpleOperationsFlipV=0 && SimpleOperationsFlipH=0 && SimpleOperationsDoCrop=0)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": WARNING", "No image transformations selected or activated to perform.", 0, 0, "exclamation")
          Return
       }

       If ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
       || SimpleOperationsScaleXimgFactor<5 || SimpleOperationsScaleYimgFactor<5) && (ResizeMustPerform=1 && ResizeInPercentage=0))
       || ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
       || SimpleOperationsScaleXimgFactor<1 || SimpleOperationsScaleYimgFactor<1) && (ResizeMustPerform=1 && ResizeInPercentage=1))
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
          Return
       }
    }
 
    initFIMGmodule()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       If (contextu!="extern")
          WriteSettingsResizeSimplePanel()
       batchSimpleProcessing(simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    If (contextu!="extern")
    {
       Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
       oImgW := (ResizeInPercentage=1) ? Round(oImgW*(SimpleOperationsScaleXimgFactor/100)) : SimpleOperationsScaleXimgFactor
       oImgH := (ResizeInPercentage=1) ? Round(oImgH*(SimpleOperationsScaleYimgFactor/100)) : SimpleOperationsScaleYimgFactor
       newImgSize := oImgH*oImgW
       If (isImgSizeTooLarge(oImgW, oImgH) && ResizeMustPerform=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": WARNING", "The resulting image dimensions are very large. Image resizing might fail, depending on the file format.`n`nW x H: " oImgW " x " oImgH " pixels.", 0, 0, "Exclamation")
       }

       If (!filesElected && !RegExMatch(imgPath, thisRegEX))
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "This file format (." oExt ") cannot be processed in «Simple mode». Please use the «Advanced mode» which allows file format conversions.", 0, 0, "exclamation")
          Return
       }
    }

   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileName : imgPath
   If (dummy="no-prompt")
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save processed image as...", oExt " images (*." oExt ")")

   If file2save
   {
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." oExt

      If !RegExMatch(file2save, thisRegEX)
      {
         SoundBeep, 300, 100
         If (dummy="no-prompt")
         {
            If (contextu="extern")
            {
               showTOOLtip("ERROR: unsupported image file write format")
               SoundBeep , 300, 100
               SetTimer, RemoveTooltip, % -msgDisplayTime
            } Else msgBoxWrapper(appTitle ": ERROR", "Unsupported file write format. Please use one of the allowed image file formats: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         } Else msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      If (nExt!=oExt && StrLen(nExt)>0)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "You cannot change the image file format from ." oExt " to ." nExt ". If you want to do this, please use the «Advanced mode».", 0, 0, "exclamation")
         Return
      }

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         msgu := "The image file format is currently unsupported, because the FreeImage library failed to properly initialize."
         SoundBeep, 300, 100
         If (contextu="extern")
         {
            showTOOLtip("ERROR: " msgu "`n" OutFileName)
            SetTimer, RemoveTooltip, % -msgDisplayTime
         } Else msgBoxWrapper(appTitle ": ERROR", msgu "`n`n" OutFileName, 0, 0, "error")
         Return
      }

      If (FileExist(file2save) && dummy!="no-prompt" && contextu!="extern")
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      destroyGDIfileCache()
      If (contextu!="extern")
      {
         GuiControl, SettingsGUIA: Disable, mainBtnACT
         SetTimer, reactivateMainBtnACT, -950
      }

      showTOOLtip("Processing image, please wait")
      r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
      If r
      {
         SoundBeep, 300, 100
         If (contextu="extern")
            showTOOLtip("ERROR: Unable to save file, error code: " r "`n" OutFileName "`n" OutDir "\")
         Else
            msgBoxWrapper(appTitle ": ERROR", "Unable to save file, error code: " r ".`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      ForceRefreshNowThumbsList()
      resultedFilesList[currentFileIndex, 4] := 1
      If (SLDtypeLoaded=3)
         selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

      If (contextu!="extern")
      {
         SetTimer, WriteSettingsResizeSimplePanel, -90
         SoundBeep, 900, 100
      }

      showTOOLtip("Processed image saved`n" OutFileName)
      If (dummy="no-prompt")
         SetTimer, RefreshImageFile, -150

      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

batchSimpleProcessing(rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to process " filesElected " files?"
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      Else
         msgInfos .= "`n`nThe files will be will be OVERWRITTEN."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   backCurrentSLD := CurrentSLD
   setImageLoading()
   showTOOLtip("Processing " filesElected " images, please wait")

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>2) ? 1 : 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresSimpleImgProcessing(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("Image processing in batch: failed to initialize multi-threaded processing")

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
   countTFilez := failedFiles := filesConverted := skippedFiles := 0
   doStartLongOpDance()
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If !RegExMatch(imgPath, thisRegEX)
      {
         skippedFiles++
         Continue
      }

      countTFilez++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If failedFiles
            etaTime := "`nFailed to process " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip("Processing image files, please wait" etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := StrReplace(imgPath, "||")
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutFileName

      If (ResizeUseDestDir=1)
      {
         If (FileExist(file2save) && !FolderExist(file2save))
            file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)
      }

      If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
      If r
         failedFiles++
      Else
         filesConverted++
   }

   If failedFiles
      someErrors := "`nFailed to process " groupDigits(failedFiles) " files"
   If skippedFiles
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   executingCanceableOperation := 0
   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip("Finished processing " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

printArrayStr(whichArray, delim:="|", forMode:=0) {
   listu := ""
   If (forMode=1)
   {
      For Key, Value in whichArray
          listu .= Key "," Value delim
   } Else
   {
      Loop, % whichArray.Count()
          listu .= whichArray[A_Index] delim
   }

   Return Trim(listu, delim)
}

printLargeStrArray(whichArray, maxList, delim) {
  Static trenchSize := 15000
  startZeit := A_TickCount
  filesListu := ""
  changeMcursor()
  If (maxList<trenchSize)
  {
     Loop, % maxList
     {
          rA := whichArray[A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu .= r delim
     }
     Return filesListu
  }

  doStartLongOpDance()
  splitParts := maxList//trenchSize
  Loop, % splitParts - 1
  {
      If (A_TickCount - startZeit>2500)
         executingCanceableOperation := A_TickCount

      changeMcursor()
      thisIndex := A_Index
      Loop, % trenchSize
      {
          rA := whichArray[trenchSize*(thisIndex-1) + A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu%thisIndex% .= r delim
      }

      If (determineTerminateOperation()=1) ; && (A_TickCount - startZeit>2500)
      {
         abandonAll := 1
         Break
      }
  }

  If (abandonAll=1)
  {
     SoundBeep, 300, 100
     lastLongOperationAbort := A_TickCount
     Return
  }

  Loop, % maxList - trenchSize*(splitParts - 1)
  {
      rA := whichArray[trenchSize*(splitParts - 1) + A_Index]
      r := rA[1]
      If (InStr(r, "||") || !r)
         Continue

      filesListu%splitParts% .= r delim
  }

  result := ""
  filesListu%splitParts% := Trimmer(filesListu%splitParts%)
  Loop, % splitParts
      result .= filesListu%A_Index%

  ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 
  Return result
}

dumpBMPpixels(miniBMP, w, h, zEffect:=0) {
    entireImgSmall := ""
    ; Gdip_BitmapApplyEffect(miniBMP, zEffect)
    E1 := Gdip_LockBits(miniBMP, 0, 0, w, h, Stride1, Scan01, BitmapData1, 1, "0x21808")
    If !E1
    {
       Loop, % h
       {
          pY := A_Index - 1 ; y++
          Loop, % w ; x++
             entireImgSmall .= Chr(Gdip_BFromARGB(NumGet(Scan01+0, (A_Index - 1)*4+(pY*Stride1), "UInt")) + 161)
       }

       Gdip_UnlockBits(miniBMP, BitmapData1)
    } 
    Return entireImgSmall
}

calcHistoAvgFile(xBitmap, returnObj, isFilter, imgIndex, zEffect:=0, originalBMP:=0, newBMPs:=0) {
    Static TotalPixelz := 122500, fmt := 3
    
    If StrLen(xBitmap)<2
       Return 0

    ; Gdip_BitmapSetColorDepth(xBitmap, 24, 1)
    If zEffect
       Gdip_BitmapApplyEffect(xBitmap, zEffect)

    z := DllCall("gdiplus\GdipBitmapGetHistogramSize", "UInt", fmt, "UInt*", numEntries)
    VarSetCapacity(ch0, numEntries * 4, 0)
    R := DllCall("gdiplus\GdipBitmapGetHistogram", "UPtr", xBitmap, "UInt", fmt, "UInt", numEntries, "Ptr", &ch0, "Ptr", 0, "Ptr", 0, "Ptr", 0)
    If R
    {
       addJournalEntry(A_ThisFunc "() failed to retrieve histogram for " imgIndex)
       Return 0
    }

    medianValue := -1
    pixMinu := TotalPixelz
    modePointV := peakPointV := sumTotalBr := nrPixelz := thisSum := minBrLvlV := 0
    Loop, % numEntries
    {
        thisIndex := A_Index - 1
        nrPixelz := NumGet(&ch0+0, thisIndex * 4, "UInt")
        ; nrPixelz := brLvlArray[thisIndex]
        If (nrPixelz="")
           Continue

        If (nrPixelz>modePointV)
        {
           modePointV := nrPixelz
           modePointK := thisIndex
        }

        If (nrPixelz>0 && medianValue=-1)
        {
           thisSum += nrPixelz
           If (thisSum>TotalPixelz//2)
              medianValue := thisIndex
        }

        sumTotalBr += nrPixelz * A_Index
        If (nrPixelz>0)
        {
           peakPointK := thisIndex ; max range in histogram
           If !minBrLvlK
              minBrLvlK := thisIndex   ; min range in histogram
        }

        If (nrPixelz<pixMinu)
        {
           pixMinu := nrPixelz
           minPointK := thisIndex
        }
        pixRms += nrPixelz ** 2    ; root-mean square
    }

    ch0 := ""
    avgu := (sumTotalBr/TotalPixelz - 1)/2
    rmsu := Sqrt(pixRms / (peakPointK - minBrLvlK))

    entireImgSmall := entireImgBig := ""
    HentireImgSmall := HentireImgBig := ""
    If (SLDtypeLoaded=3) ; database 
    {
       If (dupesApplyBlur=1)
          Gdip_GaussianBlur(xBitmap, 4, 0)
       thispolate := (hamDistInterpolation=1) ? 6 : 5
       x1 := Gdip_ResizeBitmap(xBitmap, 9, 8, 0, thispolate, -1)
       x2 := Gdip_ResizeBitmap(xBitmap, 32, 32, 0, thispolate, -1)
       entireImgSmall := dumpBMPpixels(x1, 9, 8)
       entireImgBig := dumpBMPpixels(x2, 32, 32)
       Gdip_DisposeImage(x1, 1)
       Gdip_DisposeImage(x2, 1)
       If (findFlippedDupes=1 && StrLen(newBMPs[1])>2)
       {
          Gdip_BitmapApplyEffect(newBMPs[1], zEffect)
          If (dupesApplyBlur=1)
             Gdip_GaussianBlur(xBitmap, newBMPs[1], 0)
          x1 := Gdip_ResizeBitmap(newBMPs[1], 9, 8, 0, thispolate, -1)
          x2 := Gdip_ResizeBitmap(newBMPs[1], 32, 32, 0, thispolate, -1)
          HentireImgSmall := dumpBMPpixels(x1, 9, 8)
          HentireImgBig := dumpBMPpixels(x2, 32, 32)
          Gdip_DisposeImage(x1, 1)
          Gdip_DisposeImage(x2, 1)
       }

       ; If (StrLen(newBMPs[1])>2)
       ;    entireImgSmall := dumpBMPpixels(newBMPs[1], 9, 8, zEffect)
       ; If (StrLen(newBMPs[3])>2)
       ;    HentireImgSmall := dumpBMPpixels(newBMPs[3], 9, 8, zEffect)
       ; If (StrLen(newBMPs[2])>2)
       ;    entireImgBig := dumpBMPpixels(newBMPs[2], 32, 32, zEffect)
       ; If (StrLen(newBMPs[4])>2)
       ;    HentireImgBig := dumpBMPpixels(newBMPs[4], 32, 32, zEffect)
    }
    ; fnOutputDebug("p = " entireImgSmall)
    If (returnObj=1)
    {
       r := []
       r.avg := Round((avgu + 1)/256, 5)
       r.median := Round((medianValue + 1)/256, 5)
       r.peak := Round((peakPointK + 1)/256, 5)
       r.low := Round((minBrLvlK + 1)/256, 5)
       r.rms := Round((rmsu + 1)/7000, 5)
       r.range := Round((peakPointK - minBrLvlK + 1)/256, 5)
       r.mode := Round((modePointK + 1)/256, 5)
       r.minu := Round((minPointK + 1)/256, 5)
       r.entireSmall := entireImgSmall
       r.entireBig := entireImgBig
       r.HentireSmall := HentireImgSmall
       r.HentireBig := HentireImgBig
       Return r
    } Else
    {
       updateFilesListByID(imgIndex, 11, 1, isFilter)
       updateFilesListByID(imgIndex, 18, Round((avgu + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 19, Round((medianValue + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 20, Round((peakPointK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 21, Round((minBrLvlK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 24, Round((rmsu + 1)/7000, 5), isFilter)
       updateFilesListByID(imgIndex, 25, Round((peakPointK - minBrLvlK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 26, Round((modePointK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 27, Round((minPointK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 29, entireImgSmall, isFilter)
       updateFilesListByID(imgIndex, 30, entireImgBig, isFilter)
       updateFilesListByID(imgIndex, 31, hentireImgSmall, isFilter)
       updateFilesListByID(imgIndex, 32, hentireImgBig, isFilter)
    }
    ; ToolTip, % medianValue "=" r.avg "=" peakPointK "=" minBrLvlK , , , 2
    Return 1
}

GetCachableHistogramFile(imgPath, imgIndex, dummy:=0, returnObj:=0, noFileInfos:=0, isFilter:=0, zEffect:=0) {
     If (!imgPath || !imgIndex)
     {
        addJournalEntry(A_ThisFunc "() - incorrect params error: " imgPath " | " imgIndex)
        Return
     }

     sizesDesired := []
     thispolate := (hamDistInterpolation=1) ? 6 : 5
     sizesDesired[1] := [350, 350, 0, 1, thispolate, 0, 0]
     If (SLDtypeLoaded=3)
     {
        If (findFlippedDupes=1)
           sizesDesired[2] := [350, 350, 0, 1, thispolate, 4, 0]
     }

     thumbBMP := LoadBitmapFromFileu(imgPath, 0, 0, 0, sizesDesired, newBMPs)
     r := (mainLoadedIMGdetails.Width>1 && mainLoadedIMGdetails.Height>1) ? 1 : 0
     If (StrLen(thumbBMP)>2 && r)
     {
        If (returnObj=1)
        {
           imgInfosObju := []
           imgInfosObju.dpi := mainLoadedIMGdetails.dpi
           imgInfosObju.w := mainLoadedIMGdetails.Width
           imgInfosObju.h := mainLoadedIMGdetails.Height
           imgInfosObju.pixFmt := mainLoadedIMGdetails.PixelFormat
           imgInfosObju.frames := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
        } Else
        {
           updateFilesListByID(imgIndex, 9, (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1, isFilter)
           updateFilesListByID(imgIndex, 13, mainLoadedIMGdetails.Width, isFilter)
           updateFilesListByID(imgIndex, 14, mainLoadedIMGdetails.Height, isFilter)
           updateFilesListByID(imgIndex, 15, mainLoadedIMGdetails.PixelFormat, isFilter)
           updateFilesListByID(imgIndex, 16, Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2), isFilter)
           updateFilesListByID(imgIndex, 17, Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2), isFilter)
           updateFilesListByID(imgIndex, 22, mainLoadedIMGdetails.dpi, isFilter)
        }
     } Else imgInfosObju := 0

     If r
        histoObj := calcHistoAvgFile(thumbBMP, returnObj, isFilter, imgIndex, zEffect, originalBMP, newBMPs)
     Else
        histoObj := 0

     trGdip_DisposeImage(newBMPs[1], 1)
     trGdip_DisposeImage(thumbBMP, 1)

     If (IsObject(histoObj) && returnObj=1)
        Return [histoObj, imgInfosObju]
     Else
        Return histoObj
        ; fnOutputDebug(A_ThisFunc "() - no cache: " imgPath)
     ; } Else fnOutputDebug(A_ThisFunc "() - failed to generate histogram: " imgIndex " = " imgPath)
}

SaveFIMfile(file2save, pBitmap, givenDepth:=32, fileEXT:=0) {
  Static gifbitDp := "-8-",          ppmbitDp := "-24-"
       , jngbitDp := "-24-",         xpmbitDp := "-24-"
       , jpgbitDp := "-8-24-",       jp2bitDp := "-8-24-32-"
       , jfifbitDp := "-8-24-32-",   pngbitDp := "-8-24-32-"
       , tifbitDp := "-8-24-32-",    hdpbitDp := "-8-16-24-32-"
       , jxrbitDp := "-8-16-24-32-", tgabitDp := "-8-16-24-32-"
       , wdpbitDp := "-8-16-24-32-", bmpbitDp := "-8-16-24-32-"
       , webpbitDp := "-24-32-"

  initFIMGmodule()
  If !wasInitFIMlib
     Return 1

  hFIFimgA := ConvertPBITMAPtoFIM(pBitmap)
  If !hFIFimgA
  {
     SoundBeep , 300, 100
     message := "Failed to convert GDI+ image object to FreeImage object..."
     addJournalEntry(message)
     Return message 
  }

  If FileExist(file2save)
  {
     Try FileSetAttrib, -R, % file2save
     Sleep, 0
     FileMove, % file2save, % file2save "-tmp"
     If !ErrorLevel
        tempFileExists := 1

     Sleep, 0
  }
  
  If !fileEXT
  {
     fileEXTpos := InStr(file2save, ".", 0, -1) ; RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
     If fileEXTpos
        fileEXT := SubStr(file2save, fileEXTpos + 1)
  }

  saveArg := 0
  If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
     saveArg :=  clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
  Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
     saveArg :=  clampInRange(Round(userJpegQuality), 1, 100)

  ;   MsgBox, lol = %fileEXT% = %givenDepth%
  If (givenDepth>4 && givenDepth!=32 && InStr(%fileExt%bitDp, "-" givenDepth "-"))
  {
     changeMcursor()
     hFIFimgZZ := FreeImage_ConvertTo(hFIFimgA, "24Bits")
     If (givenDepth=8 && !RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k|hdp|wdp|jxr))$"))
     {
        changeMcursor()
        hFIFimgB := FreeImage_ColorQuantize(hFIFimgZZ, 1)
        ; hFIFimgB := FreeImage_ConvertTo(hFIFimgCC, givenDepth "Bits")
     } Else If (givenDepth!=24)
     {
        hFIFimgB := FreeImage_ConvertTo(hFIFimgZZ, givenDepth "Bits")
     } Else ; If (givenDepth!=24)
     {
        hFIFimgB := hFIFimgZZ
        hFIFimgZZ := 0
     }

     FreeImage_UnLoad(hFIFimgZZ)
     ; ToolTip, % hFIFimgB "=l=" givenDepth "=" fileEXT , , , 2
     changeMcursor()
     r := FreeImage_Save(hFIFimgB, file2save, saveArg)
     FreeImage_UnLoad(hFIFimgB)
  } Else If RegExMatch(file2save, "i)(.\.(gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|wbm|xpm))$")
  {
     hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")
     changeMcursor()
     r := FreeImage_Save(hFIFimgB, file2save, saveArg)
     FreeImage_UnLoad(hFIFimgB)
  } Else r := FreeImage_Save(hFIFimgA, file2save, saveArg)

  FreeImage_UnLoad(hFIFimgA)
  If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
  {
     r := 0
     FileDelete, % file2save
     Sleep, 0
     FileMove, % file2save "-tmp", % file2save
  } Else If (tempFileExists=1)
     FileDelete, % file2save "-tmp"

  Return !r
}

initFIMGmodule() {
  Static firstTimer := 1
  If (wasInitFIMlib!=1)
  {
     r := FreeImage_FoxInit(1) ; Load the FreeImage Dll
     wasInitFIMlib := (r && !InStr(r, "err")) ? 1 : 0
     If wasInitFIMlib
        addJournalEntry("FreeImage library initialized: v" FreeImage_GetVersion())
  }

  If InStr(r, "err - ")
  {
     alwaysOpenwithFIM := 0
     FIMfailed2init := 1
     If InStr(r, "err - 126")
        friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2013."
     Else If InStr(r, "err - 404")
        friendly := "`n`nThe FreeImage.dll file seems to be missing..."

     If (firstTimer=1 && hasInitSpecialMode!=1)
     {
        SoundBeep, 300, 100
        msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Some image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
     }
  } Else FIMfailed2init := 0

  firstTimer := 0
  Return r
}

LoadFimFile(imgPath, noBPPconv, noBMP:=0, frameu:=0, sizesDesired:=0, ByRef newBitmap:=0) {
  Critical, on
  sTime := A_tickcount  
  initFIMGmodule()
  If !wasInitFIMlib
     Return

  loadArgs := (noBPPconv=1 || noBMP=1) ? -1 : 0   ; FIF_LOAD_NOPIXELS
  GFT := FreeImage_GetFileType(imgPath)
  If (GFT=34 && loadArgs=0)
     loadArgs := (userHQraw=1 && thumbsDisplaying=0) ? 0 : 5
  Else If (GFT=2 && loadArgs=0)
     loadArgs := 8

  changeMcursor()
  If ((GFT=18 || GFT=25) && noBPPconv=0 && noBMP=0)
  {
     multiFlags := (GFT=25) ? 2 : 0
     hMultiBMP := FreeImage_OpenMultiBitmap(ImgPath, GFT, 0, 1, 1, multiFlags)
  }

  fimMultiPage := ""
  If StrLen(hMultiBMP)>1
  {
     hasOpenedMulti := 1
     tFrames := FreeImage_GetPageCount(hMultiBMP)
     If (tFrames<0 || !tFrames)
        tFrames := 0

     If (tFrames>1)
        fimMultiPage := (GFT=18) ? "tiff" : "gif"

     frameu := clampInRange(frameu, 0, tFrames - 1)
     mainLoadedIMGdetails.Frames := tFrames - 1
     ; msgbox, % a_thisfunc "=" totalFramesIndex "==" desiredFrameIndex
     hPage := FreeImage_LockPage(hMultiBMP, frameu)
     hFIFimgA := FreeImage_Clone(hPage)
     hasMultiTrans := FreeImage_GetTransparencyCount(hFIFimgA)
     ; ToolTip, % hasMultiTrans "==" frameu "==" frameu , , , 2
     FreeImage_UnlockPage(hMultiBMP, hPage, 0)
     FreeImage_CloseMultiBitmap(hMultiBMP, 0)
  } Else hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs) ; load image

  If !hFIFimgA
  {
     addJournalEntry("Failed to load image file using FreeImage library")
     Return
  }

   FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
   FreeImage_GetDPIresolution(hFIFimgA, dpiX, dpiY)

   If IsObject(sizesDesired[2])
   {
      forceW := sizesDesired[2, 1]
      forceH := sizesDesired[2, 2]
      If (forceW>1 && forceH>1 && noBPPconv=0 && noBMP=0)
      {
         keepAratio := sizesDesired[2, 3]
         ScaleAnySize := sizesDesired[2, 4]
         thisImgQuality := sizesDesired[2, 5]=6 ? 1 : 0
         doFlipu := sizesDesired[2, 6]

         If (imgW>forceW || imgH>forceH || ScaleAnySize=1)
         {
            If (keepAratio=1)
            {
               calcIMGdimensions(imgW, imgH, forceW, forceH, xForceW, xForceH)
               hFIFimgX := FreeImage_Rescale(hFIFimgA, xForceW, xForceH, thisImgQuality)
            } Else
               hFIFimgX := FreeImage_Rescale(hFIFimgA, forceW, forceH, thisImgQuality)
         } 

         If hFIFimgX
         {
            imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgX), "-"))
            If (imgBPPc!=32)
            {
               hFIFimgDE := FreeImage_ConvertTo(hFIFimgX, "32Bits")
               newBitmap := ConvertFIMtoPBITMAP(hFIFimgDE)
               FreeImage_UnLoad(hFIFimgDE)
            } Else newBitmap := ConvertFIMtoPBITMAP(hFIFimgX)

            If (doFlipu=4)
               FreeImage_FlipHorizontal(newBitmap)

            FreeImage_UnLoad(hFIFimgX)
         }
      }
   }

  forceW := sizesDesired[1, 1]
  forceH := sizesDesired[1, 2]
  If (forceW>1 && forceH>1 && noBPPconv=0 && noBMP=0)
  {
     keepAratio := sizesDesired[1, 3]
     ScaleAnySize := sizesDesired[1, 4]
     thisImgQuality := sizesDesired[1, 5]=6 ? 1 : 0
     If (imgW>forceW || imgH>forceH || ScaleAnySize=1)
     {
        If (keepAratio=1)
        {
           calcIMGdimensions(imgW, imgH, forceW, forceH, xForceW, xForceH)
           hFIFimgX := FreeImage_Rescale(hFIFimgA, xForceW, xForceH, thisImgQuality)
        } Else
           hFIFimgX := FreeImage_Rescale(hFIFimgA, forceW, forceH, thisImgQuality)
     }

     If hFIFimgX
     {
        FreeImage_UnLoad(hFIFimgA)
        hFIFimgA := hFIFimgX
     }
  }

  imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
  ColorsType := FreeImage_GetColorType(hFIFimgA)
  If (noBPPconv=0 && noBMP=0)
     alphaBitmap := FreeImage_GetChannel(hFIFimgA, 4)

  mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba")) || (imgBPP>64) ? 1 : 0
  toneMapped := ""
  If (mustApplyToneMapping=1 && noBPPconv=0 && noBMP=0)
  {
     setWindowTitle("Applying adaptive logarithmic tone mapping to display high color depth image")
     changeMcursor()
     hFIFimgB := FreeImage_ToneMapping(hFIFimgA, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
     toneMapped := " (TONE-MAPPED)"
  }

  fileType := FreeImage_GetFileType(imgPath, 1)
  If (fileType="raw" && userHQraw!=1)
     fileType .= " [LOW QUALITY]"

  imgType := FreeImage_GetImageType(hFIFimgA, 1)
  mainLoadedIMGdetails.File := imgPath
  mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
  mainLoadedIMGdetails.Width := imgW
  mainLoadedIMGdetails.Height := imgH
  mainLoadedIMGdetails.Frames := (hasOpenedMulti!=1) ? FreeImage_SimpleGetPageCount(hFIFimgA) - 1 : tFrames - 1
  mainLoadedIMGdetails.HasAlpha := (InStr(ColorsType, "rgba") || hasMultiTrans) ? 1 : 0
  mainLoadedIMGdetails.RawFormat := fileType " | " imgType
  mainLoadedIMGdetails.PixelFormat := imgBPP "-" ColorsType toneMapped
  mainLoadedIMGdetails.OpenedWith := "FreeImage library"
  mainLoadedIMGdetails.TooLargeGDI := isImgSizeTooLarge(imgW, imgH)
  If (noBMP=1)
  {
     FreeImage_UnLoad(hFIFimgA)
     Return 1
  }

  hFIFimgZ := hFIFimgB ? hFIFimgB : hFIFimgA
  hFIFimgC := hFIFimgZ ? hFIFimgZ : hFIFimgA
  FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)

  If (noBPPconv=0)
  {
     capMaxGDIbmpSize32bits()
     If isImgSizeTooLarge(imgW, imgH)
     {
        setWindowTitle("Rescaling image to fit the GDI+ maximum image dimensions limits")
        calcIMGdimensions(imgW, imgH, 32500, 32500, nImgW, nImgH)
        changeMcursor()
        hFIFimgKO := FreeImage_Rescale(hFIFimgC, nimgW, nimgH, 0)
     }

     If StrLen(hFIFimgKO)>2
     {
        hFIFimgC := hFIFimgKO
        mainLoadedIMGdetails.TooLargeGDI := 1
        FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)
     }

     setWindowTitle("Converting FreeImage object to GDI+ image bitmap")
     imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgC), "-"))
     If (imgBPPc!=32)
        hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "32Bits")

     hFIFimgE := hFIFimgD ? hFIFimgD : hFIFimgC
     If alphaBitmap
     {
        hFIFimgXu := FreeImage_ConvertTo(alphaBitmap, "Greyscale")
        eRR := FreeImage_GetHistogram(hFIFimgXu, 5, histoArray)
        mustInvert := eRR
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && A_Index>2)
               mustInvert := 0
        }

        HasAlpha := 0
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && isInRange(A_Index, 3, 254))
               HasAlpha := 1
        }

        ; ToolTip, %  eRR " - " mustInvert  " / " HasAlpha , , , 2
        If (mustInvert=1)
        {
           FreeImage_Invert(hFIFimgXu)
           FreeImage_SetChannel(hFIFimgE, hFIFimgXu, 4)
        }

        mainLoadedIMGdetails.HasAlpha := HasAlpha
        FreeImage_UnLoad(hFIFimgXu)
        FreeImage_UnLoad(alphaBitmap)
     }
     ; FreeImage_PreMultiplyWithAlpha(hFIFimgE)
     pBitmap := ConvertFIMtoPBITMAP(hFIFimgE)
     createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 1, A_ThisFunc]
  } Else pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)

  ; Gdip_GetImageDimensions(pBitmap, imgW2, imgH2)
  imgIDs := hFIFimgA "|" hFIFimgB "|" hFIFimgC "|" hFIFimgKO "|" hFIFimgD "|" hFIFimgE "|" hFIFimgZ
  Sort, imgIDs, UD|
  Loop, Parse, imgIDs, |
  {
      If A_LoopField
         FreeImage_UnLoad(A_LoopField)
  }

  eTime := A_TickCount - sTime
  ; ToolTip, % imgW ", " imgW2,,,2
  ; Tooltip, % etime "; " noPixels "; " GFT
  ; Tooltip, %r1% -- %r2% -- %pBits% ms ---`n %pbitmap% -- %hbitmap% -- %hfifimg%
  ; ToolTip, % Gdip_GetImagePixelFormat(pBitmap, 2) , , , 2
  Return pBitmap
}

changeMcursor(whichCursor:=0) {
  Static lastInvoked := 1, prevCursor := "none"
  If ((drawingShapeNow=1 || slideShowRunning=1 || animGIFplaying=1 || (A_TickCount - zeitSillyPrevent<300) || hasInitSpecialMode=1) && imageLoading!=1)
     Return

  If (whichCursor)
  {
     prevCursor := whichCursor
     interfaceThread.ahkPostFunction("changeMcursor", whichCursor)
  } Else If (A_TickCount - lastInvoked > 400) ; && (imageLoading!=1)
  {
     interfaceThread.ahkPostFunction("changeMcursor", "busy")
     ; interfaceThread.ahkassign("imageLoading", 1)
     ; Try DllCall("user32\SetCursor", "Ptr", hCursBusy)
     lastInvoked := A_TickCount
  }
}

GetImgFileDimension(imgPath, ByRef W, ByRef H, fastWay:=1) {
   Static prevImgPath, prevW, prevH
   thisImgPath := generateThumbName(imgPath, 1) fastWay
   If (prevImgPath=thisImgPath && prevH>1 && prevW>1)
   {
      W := prevW
      H := prevH
      Return 1
   }
   If (allowWICloader=1 && WICmoduleHasInit=1)
      fastWay := 1

   changeMcursor()
   prevImgPath := thisImgPath
   pBitmap := LoadBitmapFromFileu(imgPath, fastWay)
   prevW := W := mainLoadedIMGdetails.Width
   prevH := H := mainLoadedIMGdetails.Height
   trGdip_DisposeImage(pBitmap, 1)

   changeMcursor("normal")
   r := (w>1 && h>1) ? 1 : 0
   Return r
}

isInRange(value, inputA, inputB) {
    If (value=inputA || value=inputB)
       Return 1

    Return (value>=min(inputA, inputB) && value<=max(inputA, inputB)) ? 1 : 0
}

ST_ReadLine(String, line, delim="`n", exclude="`r") {
   String := Trimmer(String, delim)
   StringReplace, String, String, %delim%, %delim%, UseErrorLevel
   TotalLcount := ErrorLevel + 1

   If (abs(line)>TotalLCount && (line!="L" || line!="R" || line!="M"))
      Return 0

   If (Line="R")
      Random, Rand, 1, %TotalLcount%
   Else If (line<=0)
      line := TotalLcount + line

   Loop, Parse, String, %delim%, %exclude%
   {
      out := (Line="R" && A_Index=Rand) ? A_LoopField
           : (Line="M" && A_Index=TotalLcount//2) ? A_LoopField
           : (Line="L" && A_Index=TotalLcount) ? A_LoopField
           : (A_Index=Line) ? A_LoopField : -1
      If (out!=-1) ; Something was found so stop searching.
         Break
   }
   Return out
}

triggerOwnDialogs() {
  If AnyWindowOpen
     Gui, SettingsGUIA: +OwnDialogs
  Else
     Gui, 1: +OwnDialogs
}

checkThumbExists(MD5name, imgPath, ByRef file2load) {
   file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
   If FileExist(file2save)
   {
      FileGetSize, fileSizu, % file2save
      If (fileSizu<3)
         Return 0

      file2load := file2save
      Return 1
   } Else If (thumbsSizeQuality>755)
   {
      file2load := imgPath
      Return 0
   } Else If (thumbsSizeQuality>=500)
   {
      file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : imgPath
   } Else If (thumbsSizeQuality>=245)
   {
      file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : imgPath
      }
   } Else If (thumbsSizeQuality>124)
   {
      file2test := thumbsCacheFolder "\245-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : 0
         If !file2load
         {
            file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
            file2load := FileExist(file2test) ? file2test : imgPath
         }
      }
   }
   FileGetSize, fileSizu, % file2load
   r := (imgPath=file2load || fileSizu<3) ? 0 : 1
   Return r
}

generateThumbName(imgPath, forceThis:=0, thumbsSizer:=0) {
   Static lastInvoked := 1, prevMD5name, prevImgPath := "null"

   If (A_TickCount - lastInvoked<150) && (imgPath=prevImgPath)
      Return prevMD5name

   If (enableThumbsCaching!=1 && forceThis=0)
      Return

   obju := GetFileAttributesEx(imgPath)
   MD5name := CalcStringHash(imgPath obj.size obju.wtime obju.ctime, 0x8003)
   ; If (thumbsSizer=1)
   ;    MD5name := thumbsSizeQuality "-" MD5name
   lastInvoked := A_TickCount
   prevMD5name := MD5name
   Return MD5name
}

reorderStoredHashes(a, b) {
    outsideLoop := insideLoop := 0
    Loop, 8
    {
       pY := A_Index - 1 ; y++
       Loop, 8
       {
          pX := A_Index - 1 ; , pY := y - 1
          If (pY=0 || pY=7 || pX=0 || pX=7)
          {
             outsideLoop++
             newHash .= SubStr(b, outsideLoop, 1)
          } Else
          {
             insideLoop++
             newHash .= SubStr(a, insideLoop, 1)
          }
          ; pixContent .= Round(Gdip_RFromARGB(NumGet(Scan01+0, ((A_Index - 1)*4)+((y - 1)*Stride1), "UInt"))*0.9)
       }
    }
    ; Clipboard := newHash
    ; ToolTip, % newHash , , , 2
    Return newHash
}

decideWinReactivation() {
    SetTimer, dummyDecideWinReactivation, -55
}

dummyDecideWinReactivation() {
    If (WinActive("A")!=hQPVtoolbar)
       Return

    btnID := tlbrIconzList[lastTlbrClicked, 10]
    If (btnID="BTNundoImg" || btnID="BTNredoImg" || btnID="BTNpaintSelection" || InStr(btnID, "BTNchangeBrush"))
    {
       WinActivate, ahk_id %PVhwnd%
    } Else ; If (WinActive("A")=hQPVtoolbar)
    {
       If (AnyWindowOpen && imgEditPanelOpened!=1) || (AnyWindowOpen && imgEditPanelOpened=1 && panelWinCollapsed!=1)
          WinActivate, ahk_id %hSetWinGui%
       Else
          WinActivate, ahk_id %PVhwnd%
    }
    Return 1
}

WM_LBUTTONup(wP, lP, msg, hwnd) {
    thisWin := WinActive("A")
    If (thisWin=hSetWinGui && AnyWindowOpen)
       highlightActiveCtrl("click")
    Else If (ShowAdvToolbar=1 && thisWin=hQPVtoolbar)
       decideWinReactivation()
}

WM_LBUTTONdown(wP, lP, msg, hwnd) {
    Static lastInvoked := 1
    thisWin := WinActive("A")
    If (imgEditPanelOpened=1 && thisWin=hSetWinGui && panelWinCollapsed=1)
    {
       SetTimer, toggleImgEditPanelWindow, -50
    } Else If (thisWin=hSetWinGui) ; && (A_TickCount - lastInvoked<650)
    {
       GuiControlGet, OutputVname, SettingsGUIA: FocusV
       GuiControlGet, OutputVar, SettingsGUIA: Focus
       GuiControlGet, OutputVal, SettingsGUIA:, % OutputVname
       GuiControlGet, OutputEnable, SettingsGUIA: Enabled, % OutputVname
       GuiControlGet, hVar, SettingsGUIA: hwnd, % OutputVname
       MouseGetPos, , , OutputVarWin, OutputVarControl, 2
       If (OutputVarWin=hSetWinGui && OutputEnable=1 && OutputVarControl=hVar && isNumber(OutputVal) && InStr(OutputVar, "edit"))
       {
          fn := Func("adjustNumbersEditFields").Bind(OutputVal, OutputVname)
          SetTimer, % fn , -50
       }
    }
}

adjustWheelNumbersEditFields(wParam, lParam) {
   ; author: tidbit
   ; Created: Thu October 10, 2013
   If !AnyWindowOpen
      Return

   Static amt := 1 ; How much to increase the value
   GuiControlGet, controlType, Focus
   GuiControlGet, OutputVname, SettingsGUIA: FocusV
   GuiControlGet, OutputEnable, SettingsGUIA: Enabled, % OutputVname
   isOkay := (SubStr(OutputVname, 1, 5)!="editF" || StrLen(OutputVname)>6) ? 1 : 0
   if (!instr(controlType, "Edit") || !isOkay || !OutputEnable)
      return
      
   GuiControlGet, value,, %A_GuiControl%
   if value is not number
      return

   result := (wParam >> 16)     ; return the HIWORD -  high-order word 
   stepping := Round(Abs(result) / 120)
   direction := (result<0) ? -1 : 1
   mult := ((wParam & 0xffff=4) ? 5 : (wParam & 0xffff=8) ? 10 : 1)
   value += direction*amt*mult
   GuiControl,, %A_GuiControl%, % RegExReplace(value, "(\.[1-9]+)0+$", "$1")
}

adjustNumbersEditFields(OutputVal, OutputVname) {
    Static delayu := -1
    GetPhysicalCursorPos(oX, oY)
    cX := cY := lastIndex := thisIndex := lastInvoked2 := 0
    While, (determineLClickstate()=1 || A_Index=1)
    {
       GetPhysicalCursorPos(mX, mY)
       dir := (oY<mY) ? -1 : 1
       If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
       {
          If !isInRange(thisIndex, lastIndex - 2, lastIndex + 2)
          || (A_TickCount - lastInvoked2>100 + delayu)
          {
             lastIndex := thisIndex
             MouseMove, % oX, % oY, 1
          }
          cX := mX, cY := mY
          Continue
       }

       lastInvoked2 := A_TickCount
       cX := mX, cY := mY
       OutputVal := (dir=1) ? OutputVal + 1 : OutputVal - 1
       GuiControl, SettingsGUIA:, % OutputVname, % OutputVal
       Sleep, % delayu
       thisIndex++
    }
}

WM_RBUTTONUP() {
    ; unused function - see GuiContextMenu() functions 
    ; Tooltip, %A_GuiControl%
    thisWin := WinActive("A")
    If (ShowAdvToolbar=1 && thisWin=hQPVtoolbar)
       decideWinReactivation()
    Else If (AnyWindowOpen && !InStr(A_GuiControl, "lview")) || (MsgBox2hwnd)
       SettingsToolTips()
}

OpenNewExternalCoreThread(thisIndex, args, thisList) {
   pidThread := 0
   Try FileDelete, %thumbsCacheFolder%\tempList%thisIndex%.txt
   Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
   Sleep, 0
   Try FileAppend, % thisList, %thumbsCacheFolder%\tempFilesList.txt, utf-16
   Catch wasErrorA
         Sleep, 1

   If wasErrorA
      Return 0

   Sleep, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, threadParams, %thisIndex%||%args%

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath%,,, pidThread
   Catch wasErrorB
       Sleep, 0

   If (wasErrorB || !pidThread)
   {
      Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
      Return 0
   } Else
   {
      WinWait, ahk_pid %pidThread%,,2
      WinGet, hwndThread, ID, ahk_pid %pidThread%
      Sleep, 10
      Loop, 500
      {
          RegRead, thisThreadStarted, %QPVregEntry%\multicore, ThreadRunning%thisIndex%
          If (thisThreadStarted=1 || thisThreadStarted=2 || thisThreadStarted=-1)
             Break
          Else
             Sleep, 15
      }

      allGood := (thisThreadStarted=1 || thisThreadStarted=2) ? 1 : 0
      If (allGood!=1)
      {
         Process, Close, % pidThread
         RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
         Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
         Return 0
      }
      Return pidThread
   }
}

initExternalCoreMode() {
  Critical, on
  hasInitSpecialMode := 1
  RegRead, mainThreadHwnd, %QPVregEntry%\multicore, mainThreadHwnd
  If !WinExist("ahk_id" mainThreadHwnd)
  {
     RegWrite, REG_SZ, %QPVregEntry%, Running, 0
     fatalError := 1
  }

  RegRead, threadParams, %QPVregEntry%\multicore, threadParams
  If !threadParams
     fatalError := 1

  args := StrSplit(threadParams, "||")
  coreThread := args[1]

  Try FileRead, filesList, %thumbsCacheFolder%\tempFilesList.txt
  If !filesList
     fatalError := 1

  If (fatalError=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, -1
     ForceExitNow()
     Return
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 1
  initFIMGmodule()
  RegRead, hGDIwin, %QPVregEntry%\multicore, mainWindowID
     ; MsgBox, % args[1] "--" args[3]
  If (args[2]="batch-jpegll")
     multiCoresJpegLL(args[1], args[3], filesList)
  Else If (args[2]="batch-simpleimgproc")
     multiCoresSimpleImgProcessing(args[1], args[3], filesList)
  Else If (args[2]="batch-fmtconv")
     multiCoresFormatConvert(args[1], filesList)

  ; msgbox, killaaaa
  ForceExitNow()
  Return
}

PrinterGetMatchingBitmap(width, height, color:="0xffFFFFFF") {
  ; set background-color (default is white)
  pBitmap := trGdip_CreateBitmap(A_ThisFunc, width, height)
  If StrLen(pBitmap)<3
     Return

  G := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4, 2)
  If G
     Gdip_GraphicsClear(G, color)

  Gdip_DeleteGraphics(G)
  return pBitmap
}

printImageNow(mainBMP, PrintOptions, previewMode) {
   If StrLen(mainBMP)<3
      Return

   pPrinterName := PrintOptions.pPrinterName
   adaptFit := PrintOptions.adaptFit
   userImgX := PrintOptions.userImgX
   userImgY := PrintOptions.userImgY
   userImgW := PrintOptions.userImgW
   userImgH := PrintOptions.userImgH
   colorsMode := PrintOptions.colorsMode
   imgOrient := PrintOptions.imgOrient
   paperOrient := PrintOptions.paperOrient
   copiez := PrintOptions.copiez
   flipuV := PrintOptions.flipuV
   flipuH := PrintOptions.flipuH
   applyFX := PrintOptions.applyFX

   ; pPrinterName := SGDIPrint_GetDefaultPrinter()
   ; hdcObj := SGDIPrint_GetHDCfromPrintDlg(PVhwnd)
   hdcObj := SGDIPrint_GetHDCfromPrinterName(pPrinterName, paperOrient, Round(colorsMode + 1), copiez, PVhwnd, printerDevModeOptions)
   If (previewMode=1)
   {
      calcIMGdimensions(hdcObj.HDC_Width, hdcObj.HDC_Height, 248, 351, ResizedW, ResizedH)
   } Else
   {
      ResizedW := hdcObj.HDC_Width
      ResizedH := hdcObj.HDC_Height
   }

   ; - "print" to bitmap -
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, coreDesiredPixFmt)
   If (previewMode!=1)
   {
      If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
         Return
   }

   gPrint := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4, 2)
   E := trGdip_GraphicsClear(A_ThisFunc, gPrint, "0xFFffFFff")
   If (!pBitmap || !gPrint || E="fail")
      Return

   If (applyFX=1)
      decideGDIPimageFX(matrix, imageAttribs, pEffect)

   Gdip_GetImageDimensions(pBitmap, pageW, pageH)
   oimgPosX := imgPosX := Round(pageW*(userImgX/100))
   oimgPosY := imgPosY := Round(pageH*(userImgY/100))
   oimgNewW := imgNewW := Round(pageW*(userImgW/100))
   oimgNewH := imgNewH := Round(pageH*(userImgH/100))
   If (adaptFit=1)
   {
      imgNewH := pageH
      imgNewW := pageW
      imgPosX := imgPosY := 0
   }

   ; mainBMP := useGdiBitmap()
   If isInRange(imgOrient, 1, 359)
   {
      If (previewMode=1)
         imgToPrint := trGdip_ResizeBitmap(A_ThisFunc, mainBMP, 600, 600, 1, 3, -1)

      whichBitmap := StrLen(imgToPrint)>3 ? imgToPrint : mainBMP
      newBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, imgOrient, 1)
      If StrLen(imgToPrint)>3
         imgToPrint := trGdip_DisposeImage(imgToPrint, 1)

      If StrLen(newBitmap)>3
      {
         hasRotated := 1
         imgToPrint := newBitmap
      }
   } 

   whichBitmap := (hasRotated=1) ? imgToPrint : mainBMP
   Gdip_GetImageDimensions(whichBitmap, realImgW, realImgH)
   If (PrintAdaptToFit=1 || PrintAdaptToFit=0 && PrintStrechedSize=0)
      calcIMGdimensions(realImgW, realImgH, imgNewW, imgNewH, imgNewW, imgNewH)
   ; Gdip_GetRotatedDimensions(imgNewW, imgNewH, imgOrient, rotImgW, rotImgH)
   newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgNewW, imgNewH, 0)
   trGdip_DisposeImage(imgToPrint, 1)

   failedResize := 0
   If StrLen(newBitmap)>3
      imgToPrint := newBitmap
   Else failedResize := 1

   If pEffect
   {
      Gdip_BitmapApplyEffect(imgToPrint, pEffect)
      Gdip_DisposeEffect(pEffect)
   }

   If (colorsMode=0 && previewMode=1)
   {
      newBitmap := trGdip_BitmapConvertGray(imgToPrint)
      If StrLen(newBitmap)>3
      {
         trGdip_DisposeImage(imgToPrint, 1)
         imgToPrint := newBitmap
      }
   }
   If (flipuV=1)
      Gdip_ImageRotateFlip(imgToPrint, 6)
   If (flipuH=1)
      Gdip_ImageRotateFlip(imgToPrint, 4)

   If (adaptFit=1)
   {
      Gdip_GetImageDimensions(imgToPrint, imgNewW, imgNewH)
      imgPosX := (pageW - imgNewW)//2
      imgPosY := (pageH - imgNewH)//2
   }

   r4 := trGdip_DrawImage(A_ThisFunc, gPrint, imgToPrint, imgPosX, imgPosY,,,,,,,,, imageAttribs)
   Gdip_DisposeImageAttributes(imageAttribs)
   previewScale := ResizedW / hdcObj.HDC_Width
   If StrLen(PrintOptions.text)>0
   {
      If (TextInAreaFontBold=1)
         thisStylu .= "Bold "
      If (TextInAreaFontItalic=1)
         thisStylu .= "Italic "
      If (TextInAreaFontUline=1)
         thisStylu .= "Underline "

      If (TextInAreaAlign=1)
         thisTxtAlignu := "Left "
      Else If (TextInAreaAlign=2)
         thisTxtAlignu := "Center "
      Else If (TextInAreaAlign=3)
         thisTxtAlignu := "Right "

      If (TextInAreaValign=1)
         thisTxtvAlignu := "Top "
      Else If (TextInAreaValign=2)
         thisTxtvAlignu := "vCenter "
      Else If (TextInAreaValign=3)
         thisTxtvAlignu := "Bottom "
      ; SoundBeep 
      ERR := Gdip_TextToGraphics(gPrint, PrintOptions.text, thisTxtAlignu thisTxtvAlignu thisStylu " s" Round(PrintTxtSize*previewScale) " cFF" TextInAreaFontColor, TextInAreaFontName, pageW, pageH)
      ; ToolTip, % ERR " == "  PrintOptions.text "`n" thisTxtAlignu thisTxtvAlignu " s" TextInAreaFontSize " c" TextInAreaFontColor " == " TextInAreaFontName " == " pageW " == " pageH , , , 2
   }

   If (previewMode=1 && PrintAdaptToFit=0)
   {
      Gdip_SetPenWidth(pPen1d, 2.5)
      Gdip_SetPenWidth(pPen1, 2.5)
      Gdip_DrawRectangle(gPrint, pPen1d, oimgPosX, oimgPosY, oimgNewW, oimgNewH)
      Gdip_DrawRectangle(gPrint, pPen1, oimgPosX + 2, oimgPosY + 2, oimgNewW, oimgNewH)
   }

   If (previewMode!=1 && r4!="fail" && failedResize!=1)
   {
      r := SGDIPrint_BeginDocument(hdcObj.HDC_ptr, appTitle " image file")
      If r
      {
         SGDIPrint_CopyBitmapToPrinterHDC(pBitmap, hdcObj.HDC_ptr, hdcObj.HDC_Width, hdcObj.HDC_Height)
         SGDIPrint_EndDocument(hdcObj.HDC_ptr) ; starts printing
      }
   } Else If (previewMode=1)
   {
      marginuX := hdcObj.HDC_PHYSICALOFFSETX/hdcObj.HDC_PHYSICALWIDTH
      marginuY := hdcObj.HDC_PHYSICALOFFSETY/hdcObj.HDC_PHYSICALHEIGHT
      marginuX := Ceil(ResizedW * marginuX)
      marginuY := Ceil(ResizedH * marginuY)
      newBitmap := SGDIPrint_GetMatchingBitmap(ResizedW + marginuX*2, ResizedH + marginuY*2)
      If newBitmap
      {
         gU := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
         If gU
         {
            r4 := trGdip_DrawImage(A_ThisFunc, gU, pBitmap, marginuX, marginuY)
            If (r4!="fail")
            {
               hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, newBitmap)
               SetImage(hCropCornersPic, hBitmap)
               Gdi_DeleteObject(hBitmap)
            }
            Gdip_DeleteGraphics(gU)
         }
         trGdip_DisposeImage(newBitmap, 1)
      }
      pageDPI := Round((hdcObj.hdc_xdpi + hdcObj.hdc_ydpi)/2)
      pageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi, 1)
      pageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi, 1)
      MMpageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi * 25.4)
      MMpageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi * 25.4)
      GuiControl, SettingsGUIA:, PrinterPageInfos, % "Page details:`n" pageWr " x " pageHr " in`n" MMpageWr " x " MMpageHr " mm`n" pageDPI " DPI"
   }

   Gdip_DeleteGraphics(gPrint)
   trGdip_DisposeImage(pBitmap, 1)
   trGdip_DisposeImage(imgToPrint, 1)
}

AcquireWIAimage() {
    Static deviceu
    If (thumbsDisplaying=1)
       Return

    setImageLoading()
    prevOpenedWindow := []
    showTOOLtip("Acquiring image, please wait")
    prevOpenedWindow := [-1, A_ThisFunc, 1, editingSelectionNow, 0, userimgQuality]
    addJournalEntry("Window opened: " A_ThisFunc "() [ WIA standard dialogs ]")
    WinSet, Disable,, ahk_id %PVhwnd%

    Try obju := WIA_AcquireImage(deviceu)
    Catch errMsg
       Sleep, 1

    WinSet, Enable,, ahk_id %PVhwnd%
    If IsObject(obju)
    {
       pBitmap := obju[1]
       If !deviceu
          deviceu := obju[2]
       ; ToolTip, % "l=" deviceu , , , 2
    }

    If (StrLen(pBitmap)<4 && (IsObject(obju) || StrLen(errMsg.message)>3))
    {
       ResetImgLoadStatus()
       ; showTOOLtip("Failed to acquire image`n" errMsg.message)
       RemoveTooltip()
       infos := SubStr(errMsg.message, 1, InStr(errMsg.message, "`nhelpfile:") - 1)
       infos := StrReplace(infos, "`t", A_Space)
       infos := StrReplace(infos, "  ", A_Space)
       msgBoxWrapper(appTitle ": ERROR", "An error has occured. Failed to acquire image from device.`n`nError details: " infos, 0, 0, "error")
       Return
    } Else If (obju<0 && !IsObject(obju))
    {
       RemoveTooltip()
       ResetImgLoadStatus()
    } Else
    {
       createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 1, A_ThisFunc]
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       If (imgW<5 || imgH<5)
       {
          ResetImgLoadStatus()
          hbmp := trGdip_DisposeImage(pBitmap, 1)
          showTOOLtip("Failed to acquire the correct image data`nPossibly malformed image format.")
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
       SoundBeep , 900, 100
       PasteClipboardIMG("scanner", pBitmap)
    }
}

LoadWICimage(imgPath, noBPPconv, frameu, sizesDesired:=0, ByRef newBitmap:=0) {
   ; Return
   Static lastEdition := 1, hasRan := 0
   startZeit := A_TickCount
   ; lastEdition := !lastEdition
   VarSetCapacity(resultsArray, 8 * 6)

   If IsObject(sizesDesired[1])
   {
      w := sizesDesired[1, 1]
      h := sizesDesired[1, 2]
      keepAratio := sizesDesired[1, 3]
      ScaleAnySize := sizesDesired[1, 4]
      thisImgQuality := sizesDesired[1, 5]
      doFlipu := sizesDesired[1, 6]
      doGray := sizesDesired[1, 7]
      If (!w || !h)
         keepAratio := 2
   } else
   {
      doGray := doFlipu := w := h := ScaleAnySize := 0
      thisImgQuality := 5
      keepAratio := 2
   }

   ; fnOutputDebug("wic-load " imgPath)
   func2exec := (A_PtrSize=8) ? "LoadWICimage" : "_LoadWICimage@48"
   r := DllCall(whichMainDLL "\" func2exec, "Int", 0 ,"Int", noBPPconv, "Int", thisImgQuality, "Int", w, "Int", h, "int", keepAratio, "int", ScaleAnySize, "int", frameu, "int", doFlipu, "int", doGray, "Str", imgPath, "UPtr", &resultsArray, "Ptr")
   z := NumGet(resultsArray, 4 * 6, "uInt")
   If (r || z=1)
   {
      If r
         createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
      else
         r := 1
      mainLoadedIMGdetails.Width := NumGet(resultsArray, 4 * 0, "uInt")
      mainLoadedIMGdetails.Height := NumGet(resultsArray, 4 * 1, "uInt")
      mainLoadedIMGdetails.Frames := NumGet(resultsArray, 4 * 2, "uInt") - 1
      mainLoadedIMGdetails.PixelFormat := WicPixelFormats(NumGet(resultsArray, 4 * 3, "uInt"))
      mainLoadedIMGdetails.DPI := NumGet(resultsArray, 4 * 4, "uInt")
      mainLoadedIMGdetails.RawFormat := WICcontainerFmts(NumGet(resultsArray, 4 * 5, "uInt"))
      mainLoadedIMGdetails.TooLargeGDI := isImgSizeTooLarge(mainLoadedIMGdetails.Width, mainLoadedIMGdetails.Height)
      mainLoadedIMGdetails.HasAlpha := InStr(mainLoadedIMGdetails.PixelFormat, "argb") || InStr(mainLoadedIMGdetails.PixelFormat, "bgra") || InStr(mainLoadedIMGdetails.PixelFormat, "alpha") ? 1 : 0
      mainLoadedIMGdetails.OpenedWith := "Windows Imaging Component [WIC]"

      ; fnOutputDebug("images desired = " sizesDesired.Count() " | f=" findFlippedDupes)
      If (sizesDesired.Count()>1 && r && noBPPconv=0)
      {
         newBitmap := []
         Loop, % sizesDesired.Count()
         {
            ; ToolTip, % mainLoadedIMGdetails.width "==" mainLoadedIMGdetails.height "|" z "==" W "=f" frameu "==s" ScaleAnySize "==k" keepAratio , , , 2
            w := sizesDesired[A_Index + 1, 1]
            h := sizesDesired[A_Index + 1, 2]
            keepAratio := sizesDesired[A_Index + 1, 3]
            ScaleAnySize := sizesDesired[A_Index + 1, 4]
            thisImgQuality := sizesDesired[A_Index + 1, 5]
            doFlipu := sizesDesired[A_Index + 1, 6]
            doGray := sizesDesired[A_Index + 1, 7]
            ; fnOutputDebug("loop image size=" A_Index " | " w "x" h " | " doFlipu)
            newBitmap[A_Index] := DllCall(whichMainDLL "\" func2exec, "Int", 0 ,"Int", noBPPconv, "Int", thisImgQuality, "Int", w, "Int", h, "int", keepAratio, "int", ScaleAnySize, "int", frameu, "int", doFlipu, "int", doGray, "Str", imgPath, "UPtr", &resultsArray, "Ptr")
         }
      }
   }

   resultsArray := ""
   zeitu := A_TickCount - startZeit
   ; msgbox, % r "==" zeitu " = " pixfmt "=" rawFmt
   ; ToolTip, % WICmoduleHasInit " | " r "==" zeitu " = " mainLoadedIMGdetails.pixfmt "=" mainGdipWinThumbsGrid.RawFormat , , , 3
   ; https://stackoverflow.com/questions/8101203/wicbitmapsource-copypixels-to-gdi-bitmap-scan0
   ; https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/Win7Samples/multimedia/wic/wicviewergdi/WicViewerGdi.cpp#L354
   Return r
}

WicPixelFormats(pixFmt) {
   Static wicPixFmts := {2:"1-bpp - Indexed", 3:"2-bpp - Indexed", 4:"4-bpp - Indexed", 5:"8-bpp - Indexed", 6:"BlackWhite", 7:"2-bpp - Gray", 8:"4-bpp - Gray", 9:"8-bpp - Gray", 10:"8-bpp - Alpha", 11:"16-bpp - BGR555", 12:"16-bpp - BGR565", 13:"16-bpp - BGRA5551", 14:"16-bpp - Gray", 15:"24-bpp - BGR", 16:"24-bpp - RGB", 17:"32-bpp - BGR", 18:"32-bpp - BGRA", 19:"32-bpp - PBGRA"
         , 20:"32-bpp - GrayFloat", 21:"32-bpp - RGB", 22:"32-bpp - RGBA", 23:"32-bpp - PRGBA", 24:"48-bpp - RGB", 25:"48-bpp - BGR", 26:"64-bpp - RGB", 27:"64-bpp - RGBA", 28:"64-bpp - BGRA", 29:"64-bpp - PRGBA", 30:"64-bpp - PBGRA", 31:"16-bpp - GrayFixedPoint", 32:"32-bpp - BGR101010", 33:"48-bpp - RGBFixedPoint", 34:"48-bpp - BGRFixedPoint", 35:"96-bpp - RGBFixedPoint"
         , 36:"96-bpp - RGBFloat", 37:"128-bpp - RGBAFloat", 38:"128-bpp - PRGBAFloat", 39:"128-bpp - RGBFloat", 40:"32-bpp - CMYK", 41:"64-bpp - RGBAFixedPoint", 42:"64-bpp - BGRAFixedPoint", 43:"64-bpp - RGBFixedPoint", 44:"128-bpp - RGBAFixedPoint", 45:"128-bpp - RGBFixedPoint", 46:"64-bpp - RGBAHalf", 47:"64-bpp - PRGBAHalf", 48:"64-bpp - RGBHalf", 49:"48-bpp - RGBHalf"
         , 50:"32-bpp - RGBE", 51:"16-bpp - GrayHalf", 52:"32-bpp - GrayFixedPoint", 53:"32-bpp - RGBA1010102", 54:"32-bpp - RGBA1010102XR", 55:"32-bpp - R10G10B10A2", 56:"32-bpp - R10G10B10A2HDR10", 57:"64-bpp - CMYK", 58:"24-bpp - 3 channels", 59:"32-bpp - 4 channels", 60:"40-bpp - 5 channels", 61:"48-bpp - 6 channels", 62:"56-bpp - 7 channels", 63:"64-bpp - 8 channels"
         , 64:"48-bpp - 3 channels", 65:"64-bpp - 4 channels", 66:"80-bpp - 5 channels", 67:"96-bpp - 6 channels", 68:"112-bpp - 7 channels", 69:"128-bpp - 8 channels", 70:"40-bpp - CMYKAlpha", 71:"80-bpp - CMYKAlpha", 72:"32-bpp - 3 channels alpha", 73:"40-bpp - 4 channels alpha", 74:"48-bpp - 5 channels alpha", 75:"56-bpp - 6 channels alpha", 76:"64-bpp - 7 channels alpha"
         , 77:"72-bpp - 8 channels alpha", 78:"64-bpp - 3 channels alpha", 79:"80-bpp - 4 channels alpha", 80:"96-bpp - 5 channels alpha", 81:"112-bpp - 6 channels alpha", 82:"128-bpp - 7 channels alpha", 83:"144-bpp - 8 channels alpha", 84:"8-bpp - Y", 85:"8-bpp - Cb", 86:"8-bpp - Cr", 87:"16-bpp - CbCr", 88:"16-bpp - Y-Quantized-DCT-Coeffs"
         , 89:"16-bpp - Cb-Quantized-DCT-Coeffs", 90:"16-bpp - Cr-Quantized-DCT-Coeffs"}

   r := wicPixFmts[pixFmt]
   If !r
      r := "UNKNOWN"
   Return r
}

WICcontainerFmts(containerID) {
   Static containerFmts := {1:"BMP",2:"PNG",3:"ICO",4:"JPEG",5:"TIFF",6:"GIF",7:"WMP",8:"DDS",9:"ADNG",10:"HEIF",11:"WEBP",12:"RAW"}
   r := containerFmts[containerID]
   If !r
      r := "UNKNOWN"
   Return r
}

xxtestwhatever() {

   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x2
ppIDecoder := "lodekl"
   destroyGDIfileCache()
   wzFileName := getIDimage(currentFileIndex)

   thisObj := ComObjCreate("{cacaf262-9370-4615-a13b-9f5539da4c0a}", "{ec5ec8a9-c395-4314-9c77-54d7a935ff70}")
      thisObj.ThrowHRerrors := 1

   ; hr := DllCall(NumGet(NumGet(thisObj+0)+14*A_PtrSize), "ptr", thisObj, "ptr*", ppIWICStream)
   ;    WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)


   ; hr := DllCall(NumGet(NumGet(thisObj+0)+15*A_PtrSize), "ptr", thisObj, "str", wzFileName, "uint", dwDesiredAccess)
   ; if hr or ErrorLevel
   ;    WIC_hr(hr, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)

/*
   hr := DllCall(vtable(thisObj, 3)
         ,"ptr", thisObj
         ,"str", wzFilename
         ,"ptr", NULL ; WIC_GUID(GUID,pguidVendor)
         ,"uint", dwDesiredAccess
         ,"uint", metadataOptions
         ,"ptr*", ppIDecoder)
      WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)
   MsgBox, % thisObj "`n" ppIDecoder "`n" vtable(thisObj, 3) ;  "`n" WIC_hr(HR, "init")
*/
}


gtestwhatever() {
; # dwDesiredAccess
; WIC_GENERIC_READ = 0x80000000
; WIC_GENERIC_WRITE = 0x40000000

; # WICBitmapCreateCacheOption
; WICBitmapNoCache = 0x0
; WICBitmapCacheOnDemand = 0x1
; WICBitmapCacheOnLoad = 0x2

; # WICDecodeOptions
; WICDecodeMetadataCacheOnDemand = 0x0
; WICDecodeMetadataCacheOnLoad = 0x1


   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x1

   destroyGDIfileCache()
   imgPath := getIDimage(currentFileIndex)
   DllCall("windowscodecs.dll\WICCreateImagingFactory_Proxy", "Uint", WinCodecSKDversion, "UPtr*", pWICimgFactory)

   HR := DllCall("windowscodecs.dll\IWICImagingFactory_CreateDecoderFromFilename_Proxy", "UPtr", pWICimgFactory, "Wstr", imgPath, "Ptr", GuidVendor, "Uint", dwDesiredAccess, "Uint", metadataOptions, "UPtr*", ppIDecoder)
   MsgBox, % pWICimgFactory "`n" ppIDecoder
}

recentOpenedFolders() {
   If (allowRecordHistory=1)
   {
      historyList := readRecentEntries()
      historyList .= readRecentFileDesties()
      Loop, Parse, historyList, `n
      {
         If (A_Index>30)
            Break

         entryu := StrReplace(A_LoopField, "|")
         If (!entryu || RegExMatch(entryu, sldsPattern))
            Continue

         If FolderExist(entryu)
            entriesList .= entryu "`n"
      }
      Sort, entriesList, UD`n
   }
   Return Trimmer(entriesList)
}

testeGDIspeed() {
   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(2)
   pa := A_TickCount - startZeit

   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(10)

   pb := A_TickCount - startZeit
   MsgBox, % pa "`n" pb
}

isFileLocked(imgPath) {
   If !FileRexists(imgPath)
      Return -1

   myFile := fileOpen(imgPath, "a")
   If IsObject(myFile)
   {
      myFile.Close()
      Return 0
   } Else Return 1
}

trGdip_CreateBitmap(funcu, Width, Height, PixelFormat:=0, Stride:=0, Scan0:=0) {
    ; PixelFormat := (PixelFormat="0xE200B") ? coreDesiredPixFmt : PixelFormat
    r := Gdip_CreateBitmap(Width, Height, PixelFormat, Stride, Scan0)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() called by " funcu "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0))

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Else
       addJournalEntry(A_ThisFunc "() called by " funcu "() using w" Width " - h" Height " - pixFmt" PixelFormat " failed: " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateBitmapFromFile(sFile, useICM:=0) {
    r := Gdip_CreateBitmapFromFileSimplified(sFile, useICM)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() error: " Gdip_ErrorHandler(gdipLastError, 0) "`nFile to load:" sFile)

    Return r
}

trGdip_CreateBitmapFromHBITMAP(hBitmap, hPalette:=0) {
    r := Gdip_CreateBitmapFromHBITMAP(hBitmap, hPalette)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0))

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, hBitmap = " hBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateHBITMAPFromBitmap(funcu, pBitmap, bgr:=0) {
    r := Gdip_CreateHBITMAPFromBitmap(pBitmap, bgr)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If !r
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateARGBBitmapFromHBITMAP(hBitmap) {
    r := Gdip_CreateARGBBitmapFromHBITMAP(hBitmap)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed to create pBitmap from hBitmap = " hBitmap)

    Return r
}

trGdip_BitmapConvertGray(pBitmap, hue:=0, vibrance:=-40, brightness:=1, contrast:=0, KeepPixelFormat:=-1) {
    r := Gdip_BitmapConvertGray(pBitmap, hue, vibrance, brightness, contrast, KeepPixelFormat)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "(): failed, pBitmap = " pBitmap)
    Return r
}

trGdip_CloneBitmapArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:="0xE200B", KeepPixelFormat:=0) {
    k := createdGDIobjsArray["x" pBitmap, 4]
    fnOutputDebug("Clone BitmapArea: " k ". ID: " pBitmap ". Invoker: " funcu)
    ; If (PixelFormat="0xE200B" && userimgQuality=0)
    ;    PixelFormat := "0x26200A"

    r := Gdip_CloneBitmapArea(pBitmap, x, y, w, h, PixelFormat, KeepPixelFormat)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu " {" k "}"]
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CloneBitmap(funcu, pBitmap) {
    ; addJournalEntry(A_ThisFunc "() invoked by " funcu "() , pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))
    k := createdGDIobjsArray["x" pBitmap, 4]
    fnOutputDebug("BMP to clone: " k ". ID: " pBitmap ". Cloner invoked by: " funcu)
    r := Gdip_CloneBitmap(pBitmap)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu " {" k "}"]
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_BlurBitmap(pBitmap, BlurAmount, usePARGB:=0, quality:=7) {
    If !pBitmap
       addJournalEntry("WARNING: no bitmap given to blur")

    r := Gdip_BlurBitmap(pBitmap, BlurAmount, usePARGB, quality)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, pBitmap = " pBitmap)
    Return r
}

trGdip_RenderPixelsOpaque(pBitmap, pBrush:=0, alphaLevel:=0) {
    r := Gdip_RenderPixelsOpaque(pBitmap, pBrush, alphaLevel, coreDesiredPixFmt)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, pBitmap = " pBitmap)
    Return r
}

trGdip_RetrieveBitmapChannel(pBitmap, channel) {
    r := Gdip_RetrieveBitmapChannel(pBitmap, channel, coreDesiredPixFmt)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Return r
}

trGdip_ResizeBitmap(funcu, pBitmap, givenW, givenH, KeepRatio, InterpolationMode:="", KeepPixelFormat:=0, checkTooLarge:=0) {
    thisPixFmt := (KeepPixelFormat=-1) ? coreDesiredPixFmt : KeepPixelFormat
    k := createdGDIobjsArray["x" pBitmap, 4]
    r := Gdip_ResizeBitmap(pBitmap, givenW, givenH, KeepRatio, InterpolationMode, thisPixFmt, checkTooLarge)
    If StrLen(r)<3
    {
       baseMsg := "Unable to resize internal bitmap to given size: W" givenW " - H" givenH " for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error. Details: " k
       generalInternalErrorMsgBox(gdipLastError, baseMsg)
       Return
    } Else createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu " {" k "}"]
    Return r
}

trGdip_RotateBitmapAtCenter(funcu, pBitmap, Angle, pBrush:=0, InterpolationMode:=7, PixelFormat:=0) {
    If !Angle
    {
       newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc "() initially invoked by " funcu "()", pBitmap)
       Return newBitmap
    }

    thisPixFmt := (PixelFormat=-1) ? coreDesiredPixFmt : PixelFormat
    k := createdGDIobjsArray["x" pBitmap, 4]
    r := Gdip_RotateBitmapAtCenter(pBitmap, Angle, pBrush, InterpolationMode, thisPixFmt)
    If StrLen(r)<3
    {
       baseMsg := "Unable to rotate internal bitmap to given angle: " angle "° for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error. Details: " k
       generalInternalErrorMsgBox(gdipLastError, baseMsg)
       Return
    } Else createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu " {" k "}"]
    Return r
}

trGdip_DisposeImage(pBitmap, noErr:=1) {
    If StrLen(pBitmap)<2
       Return

    fnOutputDebug("BMP to dispose: " createdGDIobjsArray["x" pBitmap, 4] ". ID: " pBitmap)
    ; If (createdGDIobjsArray["x" pBitmap, 3]=1 && createdGDIobjsArray["x" pBitmap, 2]="bmp")
    r := Gdip_DisposeImage(pBitmap, 1)
    createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 0, 0]
    Return r
}

gdipObjectsStats(killAll:=0, filteru:=0) {
   For Key, Value in createdGDIobjsArray
   {
      If (value[2]="bmp")
      {
         totalBMPs++
         If (value[3]=1)
         {
            If (killAll=1)
            {
               If (!InStr(value[4], filteru) && filteru)
                  Continue

               If (userAlphaMaskBmpPainted=value[1])
                  Continue

               If !filteru
                  addJournalEntry("ERROR: Possible memory leak: " value[4])
               trGdip_DisposeImage(value[1], 1)
            }
            UnremovedBMPs++
         }
      }
   }

   If (killAll=1 && !filteru)
   {
      imgThumbsCacheArray := []
      imgThumbsCacheIDsArray := []
      imgsListArrayThumbs := []
   }

   If (killAll!=1)
      msgbox, % totalBMPs " // " UnremovedBMPs
}

giveWarningX64() {
   SoundBeep, 300, 100
   msgResult := msgBoxWrapper(appTitle ": WARNING", "You are currently running a 64-bits operating system, but you are executing " appTitle " developed for 32-bits operating systems. Please exit and run the 64-bits edition of QPV, for an optimal experience. The 32-bits edition is severely limited and prone to crash at any moment.`n`nThank you for your inevitable cooperation.", "&Yes|&Exit|&Ask later|Continue...", 1, "error")
   If InStr(msgResult, "Continue")
   {
      SoundBeep , 300, 900
      msgResult := msgBoxWrapper(appTitle ": WARNING", "Some Pandas are weeping now... enjoy!", "&Whatever|&Exit", 1, "error")
      If InStr(msgResult, "exit")
      {
         exitAppu()
      } Else
      {
         showTOOLtip("Oh, you are so naughty!")
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   } Else If InStr(msgResult, "ask")
      SetTimer, giveWarningX64, -29100
   Else
      exitAppu()
}

checkDLLfiles() {
   Static lastInvoked := 0
   If (lastInvoked>1)
      Return

   lastInvoked++
   DllPathA := FreeImage_FoxGetDllPath("freeimage.dll")
   If !FileExist(DllPathA)
      freeIMGmissin := 1
   
   DllPathB := FreeImage_FoxGetDllPath("sqlite3.dll")
   If !FileExist(DllPathB)
      sqlMissin := 1

   If (sqlMissin=1 || freeIMGmissin=1)
      msgResult := msgBoxWrapper(appTitle ": ERROR", "It seems " appTitle " DLL files are missing. Some features of the application will not work. Please download the QPV portable ZIP package.", "&Download|&Cancel", 1, "ERROR")

   If (msgResult="Download")
      Try Run, https://github.com/marius-sucan/Quick-Picto-Viewer
}

tlbrAddNewIcon(obju, wi, he, IconSpacing, noSpacing, simpleRefresh) {
    Global
    Static indexBtn := 1, pickoBeat := 0
    If (obju[5]="BTNdisabled" && TLBRtwoColumns=0)
       Return

    indexBtn++
    icoFile := obju[1]
    actu := StrLen(obju[2])>2 ? obju[2] : ""
    actu2 := StrLen(obju[4])>2 ? obju[4] : ""
    btnID := obju[5]
    paramu := obju[6]
    menuMode := obju[7]
    btnName := obju[3]
    If (TLBRtwoColumns=1 && !isWelcomeScreenu)
    {
       otherz := (pickoBeat=0) ? "xs y+" IconSpacing " " : "x+" IconSpacing " yp"
       If (indexBtn=1)
          otherz := "xm+" IconSpacing " y+" IconSpacing " Section"
    } Else otherz := (TLBRverticalAlign=1) ? "xm+" IconSpacing " y+" IconSpacing : "x+" IconSpacing " y" IconSpacing

    If (noSpacing=1)
    {
       indexBtn := 1
       pickoBeat := 1
       otherz := "x0 y0"
    }

    ; ToolTip, % pickoBeat " == " otherz , , , 2
    ; sleep, 950
    ; limitu := (indexBtn>3) ? 1 : 2
    ; If (indexBtn=4)
    ;    pickoBeat := 1
       pickoBeat := !pickoBeat
    ; pickoBeat := clampInRange(pickoBeat + 1, 0, limitu, 1)
    If (simpleRefresh=1)
    {
       hwndul := tlbrIconzList[indexBtn, 1]
       If (icoFile!=tlbrIconzList[indexBtn, 2])
          tlbrSetImageIcon(icoFile, hwndul, wi, he)
    } Else
    {
       Gui, OSDguiToolbar: Add, Text, h%he% w%wi% %otherz% BackgroundTrans +0xE +0x200 vtlbrValueIcon%IndexBtn% +hwndhwndul gtlbrInvokeFunction, icon%IndexBtn% ; Windows Narrator friendly buttons 
       tlbrSetImageIcon(icoFile, hwndul, wi, he)
    }

    ; Gui, OSDguiToolbar: Add, Text,  h%he% w%wi% %otherz% BackgroundTrans +0x1000 +0xE, %btnName% ; Windows Narrator friendly buttons 
    ; Gui, OSDguiToolbar: Add, Picture, vtlbrValueIcon%IndexBtn% AltSubmit  +hwndhwndul xp yp hp wp gtlbrInvokeFunction, %mainCompiledPath%\resources\toolbar\%icoFile%.png
    tlbrIconzList[IndexBtn] := [hwndul, icoFile, btnName, actu, indexBtn, actu2, wi, he, paramu, btnID, menuMode]
    tlbrIconzList[hwndul] := [hwndul, icoFile, btnName, actu, indexBtn, actu2, wi, he, paramu, btnID, menuMode]
    tlbrIconzList[btnID] := [hwndul, icoFile, btnName, actu, indexBtn, actu2, wi, he, paramu, btnID, menuMode]
}

tlbrSetImageIcon(icoFile, hwnd, W, H) {
    If (icoFile="colorz-swatch")
    {
       pBitmap := Gdip_CreateBitmap(512, 512)
       Gu := Gdip_GraphicsFromImage(pBitmap)
       Gdip_GraphicsClear(Gu, "0xFF" ToolbarBgrColor)
       If (BrushToolUseSecondaryColor=1)
       {
          BrushA := Gdip_BrushCreateSolid("0xFF" BrushToolBcolor)
          BrushB := Gdip_BrushCreateSolid("0xFF" BrushToolAcolor)
       } Else
       {
          BrushA := Gdip_BrushCreateSolid("0xFF" BrushToolAcolor)
          BrushB := Gdip_BrushCreateSolid("0xFF" BrushToolBcolor)
       }

       pPenA := Gdip_CreatePen("0xFFffFFff", 10)
       pPenB := Gdip_CreatePen("0xFF101010", 25)
       posYu := (TLBRverticalAlign!=1) ? 55 : 33
       Gdip_FillEllipse(Gu, BrushB, 412//2, posYu, 412//2, 400)
       Gdip_DrawEllipse(Gu, pPenB, 412//2, posYu, 412//2, 400)
       Gdip_FillEllipse(Gu, BrushA, 80, posYu, 412//2, 400)
       Gdip_DrawEllipse(Gu, pPenB, 80, posYu, 412//2, 400)
       Gdip_DrawEllipse(Gu, pPenA, 80, posYu, 412//2, 400)
       Gdip_DeleteGraphics(Gu)
       Gdip_DeleteBrush(BrushA)
       Gdip_DeleteBrush(BrushB)
       Gdip_DeletePen(pPenA)
       Gdip_DeletePen(pPenB)
    } Else pbitmap := Gdip_CreateBitmapFromFileSimplified(mainCompiledPath "\resources\toolbar\" icoFile ".png")

    If StrLen(pBitmap)>2
    {
       ; IndexBtn := tlbrIconzList[hwnd, 5]
       ; btnName := tlbrIconzList[hwnd, 3]
       ; Sleep, 500
       ; ToolTip, % indexBtn "=" btnName "=" hwnd , , , 2
       ; If btnName
       ;    ControlSetText, , % btnName, ahk_id %hwnd%   ; nothing seems to work to change the control's text ; I do not know why
       ;    GuiControl, OSDguiToolbar:, tlbrValueIcon%IndexBtn%, % btnName
       icoBMP := Gdip_ResizeBitmap(pBitmap, w, h, 0, 7, 0, 0, "0xFF" ToolbarBgrColor)
       hBitmap := Gdip_CreateHBITMAPFromBitmap(icoBMP)
       SetImage(hwnd, hBitmap)
       Gdip_DisposeImage(pBitmap, 1)
       Gdip_DisposeImage(icoBMP, 1)
       Gdi_DeleteObject(hBitmap)
    }
}

tlbrInvokeFunction(a, b, c) {
   interfaceThread.ahkFunction("mouseTurnOFFtooltip", 1)
   If (AnyWindowOpen && imgEditPanelOpened!=1 || runningLongOperation=1 || imageLoading=1 || slideShowRunning=1)
   || (A_TickCount - lastOtherWinClose<500)
      Return

   SetTimer, drawWelcomeImg, Off
   If (c!="kbd")
      isToolbarKBDnav := 0

   hwnd := (c="kbd") ? a : Format("0x{1:x}", a)
   funcu := InStr(b, "right") ? tlbrIconzList[hwnd, 6] : tlbrIconzList[hwnd, 4]
   ; ToolTip, % z "=" a "=" b "=" c "=" funcu , , , 2
   paramu := tlbrIconzList[hwnd, 9]
   If funcu
      addJournalEntry("Toolbar action: " tlbrIconzList[hwnd, 3] " | " funcu "(" paramu ")")

   WinGetPos, aX, aY,,, ahk_id %hwnd%
   interfaceThread.ahkFunction("ShowClickHalo", aX, aY, ToolBarBtnWidth, ToolBarBtnWidth, 1)
   globalMenuOptions := tlbrIconzList[hwnd, 10] ? "tlbrMenu|" aX "|" aY + ToolBarBtnWidth : 0
   ; ToolTip, % globalMenuOptions , , , 2
   lastTlbrClicked := hwnd
   If IsFunc(funcu)
   {
      If paramu
         z := %funcu%(hwnd, paramu)
      Else
         z := %funcu%()
   } Else
   {
      z := "m"
      If funcu
         invokeTlbrContextMenu("tlbr")
   }

   MouseGetPos, OutputVarX, OutputVarY, OutputVarWin, OutputVarControl, 2
   If ((InStr(b, "right") || OutputVarWin!=hQPVtoolbar) && c!="kbd")
      decideWinReactivation()
   ; If (InStr(b, "right") || z="m") && (c!="kbd")
   ; {
   ;    If (AnyWindowOpen && imgEditPanelOpened!=1) || (AnyWindowOpen && imgEditPanelOpened=1 && panelWinCollapsed!=1)
   ;       WinActivate, ahk_id %hSetWinGui%
   ;    Else
   ;       WinActivate, ahk_id %PVhwnd%
   ; }
}

OnLButtonDblClk(wParam, lParam, msg, hwnd) {
; function by Lexikos; work-around for double-click on Gui Picture Controls
; from https://autohotkey.com/board/topic/94962-doubleclick-on-gui-pictures-puts-their-path-in-your-clipboard/
    Critical, On
    WinGetClass, WinClass, ahk_id %hwnd%
    ; ToolTip, % WinClass , , , 2
    If (WinClass="Static")
    {
       If !A_Gui
          Return 0  ; Just prevent Clipboard change.
       ; Send a WM_COMMAND message to the Gui to trigger the control's g-label.
       Gui, +LastFound
       gID := DllCall("GetDlgCtrlID", "ptr", hwnd) ; Requires AutoHotkey v1.1.
       Static STN_DBLCLK := 1
       PostMessage, 0x111, gID | (STN_DBLCLK << 16), hwnd
       ; Return a value to prevent the default handling of this message.
       Return 0
    } Else If ((InStr(WinClass, "systabcontrol") || (WinClass="autohotkeygui") || WinClass="#32770") && panelWinCollapsed!=1 && imgEditPanelOpened=1 && AnyWindowOpen)
    {
       If (WinActive("A")=hSetWinGui)
          SetTimer, toggleImgEditPanelWindow, -50
       Return 0
    }
}

isImgEditingNow() {
   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   infoImgEditingNow := (StrLen(whichBitmap)>2 && imgPath && thumbsDisplaying!=1) ? 1 : 0
   Return infoImgEditingNow
}

tlbrInvokeEditMenu() {
   If (!AnyWindowOpen || imgEditPanelOpened=1)
   {
      If (drawingShapeNow=1)
         createContextMenuCustomShapeDrawing(0, 0, 0, 0, 0, "tlbr")
      Else If (isNowAlphaPainting() || imgEditPanelOpened=1)
         BuildMainMenu(0, "tlbr")
      Else If isImgEditingNow()
         invokeSelectionAreaMenu("DoubleClick", "tlbr")
      Else
         BuildSecondMenu("tlbr")
      Return "m"
   }
}

tlbrInvokeInterfaceMenu() {
   If (!AnyWindowOpen || imgEditPanelOpened=1)
   {
      If (drawingShapeNow=1)
         invokeImgSizeVP()
      Else
         OpenUImenu("tlbr")
      Return "m"
   }
}

OSDguiToolbarGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
   If isRightClick
      tlbrInvokeFunction(CtrlHwnd, "Right", 1)
}

tlbrPlaySlides() {
   If (thumbsDisplaying=1)
      ToggleThumbsMode()
 
   SetTimer, dummyInfoToggleSlideShowu, -250
}

tlbrInsertTextArea() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      PanelEditImgCaption()
      Return
   }

   If (isImgEditingNow()!=1 && thumbsDisplaying=1 && maxFilesIndex.1)
      PanelSearchIndex()
   Else If isImgEditingNow()
      PanelInsertTextArea()
}

tlbrEraserTool() {
   If (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24))
      toggleErasePasteInPlace()
   Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      singleInListEntriesRemover()
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
      PanelEraseSelectedArea()
}

tlbrActColorsSwatch() {
   If preventColorChange()
      Return

   oldColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   oldClrName := (BrushToolUseSecondaryColor=1) ? "BrushToolBcolor" : "BrushToolAcolor"
   whichWin := (AnyWindowOpen && panelWinCollapsed!=1) ? hSetWinGui : PVhwnd
   newColor := createStandardColorzDialog(oldColor, whichWin, oldClrName)
   If (newColor="-")
      Return

   If (BrushToolUseSecondaryColor=1)
      BrushToolBcolor := newColor
   Else 
      BrushToolAcolor := newColor

   updateToolColorsBasedToolbar(newColor, oldColor, oldClrName)
   updateTlbrColorsSwatch()
   delayedWriteTlbrColors(1)
   If (imgEditPanelOpened=1 && AnyWindowOpen && isImgEditingNow()=1)
      livePreviewsImageEditing()
}

updateToolColorsBasedToolbar(newColor, oldColor, ctrlName) {
    If (imgEditPanelOpened!=1 || isImgEditingNow()!=1)
       Return

    If (isVarEqualTo(AnyWindowOpen, 64, 24, 31) || isNowAlphaPainting())
    {
       GuiControl, SettingsGUIA: +Background%newColor%, % ctrlName
    } Else If (AnyWindowOpen=66)
    {
       FloodFillColor := newColor
       GuiControl, SettingsGUIA: +Background%newColor%, FloodFillColor
    } Else If (AnyWindowOpen=68)
    {
       FillBehindColor := newColor
       GuiControl, SettingsGUIA: +Background%newColor%, FillBehindColor
    } Else If (AnyWindowOpen=23)
    {
       If (oldColor=FillArea2ndColor)
       {
          FillArea2ndColor := newColor
          GuiControl, SettingsGUIA: +Background%newColor%, FillArea2ndColor
       } Else
       {
          FillAreaColor := newColor
          GuiControl, SettingsGUIA: +Background%newColor%, FillAreaColor
       }
    } Else If (AnyWindowOpen=30 || AnyWindowOpen=65)
    {
       GuiControl, SettingsGUIA: +Background%newColor%, DrawLineAreaColor
       DrawLineAreaColor := newColor
    } Else If (AnyWindowOpen=32)
    {
       If (oldColor=TextInAreaBgrColor)
       {
          TextInAreaBgrColor := newColor
          GuiControl, SettingsGUIA: +Background%newColor%, TextInAreaBgrColor
       } Else
       {
          TextInAreaFontColor := newColor
          GuiControl, SettingsGUIA: +Background%newColor%, TextInAreaFontColor
       }
    }
}

tlbrCutImg() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      MenuExplorerCutFiles()
      Return "m"
   } Else If (isImgEditingNow()=1 && editingSelectionNow=1 && !AnyWindowOpen)
      CutSelectedArea()
}

tlbrMoveFiles() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      PanelMoveCopyFiles()
}

tlbrClonerBrush() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(3, "e")
      Else
         toggleBrushTypeCloner()
   }
}

tlbrMainBrushSoft() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(2, "e")
      Else
         togglePresetsBrushes(4)
   }
}

tlbrMainBrushHard() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(1, "e")
      Else
         togglePresetsBrushes(5)
   }
}

tlbrFXbrush() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(5, "fx")
      Else
         togglePresetsBrushes(2)
   }
}

tlbrWetBrush() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(2, "w")
      Else
         coreTlbrSlider("tlbrChangeBrushWet", 200, 0)
   }
}

tlbrChangeBrushWet(dir) {
   togglePresetsBrushes(3, dir)
}

tlbrDecreaseWetBrush() {
   If (isImgEditingNow()=1 && AnyWindowOpen!=64)
      togglePresetsBrushes(3, -1)
}

tlbrChangeOSDfontSize() {
   If !AnyWindowOpen
      coreTlbrSlider("changeOSDfontSize", 125, 0)
}

tlbrDecreaseOSDfontSize() {
   If !AnyWindowOpen
      changeOSDfontSize(-1)
}

tlbrHelpBtn() {
   If !AnyWindowOpen
      AboutWindow()
}

tlbrAddFaves() {
   isWelcomeScreenu := (isImgEditingNow() || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
   If isWelcomeScreenu
      InvokeFavesMenu("tlbr")
   Else If !AnyWindowOpen
      ToggleImgFavourites()
}

coreTlbrSlider(thisFunc, delayu, invertDir) {
   GetPhysicalCursorPos(oX, oY)
   cX := cY := lastIndex := thisIndex := lastInvoked := 0
   setwhileLoopExec(1)
   While, (determineLClickstate()=1 || A_Index=1)
   {
      GetPhysicalCursorPos(mX, mY)
      dir := (oY<mY) ? -1 : 1
      If (delayu="brushSize")
      {
         delayu := (brushToolSize<100) ? 100 : 50
         If (brushToolSize<50)
            delayu := 150
         Else If (brushToolSize<25)
            delayu := 200
      }

      If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
      {
         If !isInRange(thisIndex, lastIndex - 2, lastIndex + 2)
         || (A_TickCount - lastInvoked>100 + delayu)
         {
            lastIndex := thisIndex
            MouseMove, % oX, % oY, 1
         }
         cX := mX, cY := mY
         Continue
      }

      If (invertDir=1)
         dir *= -1

      lastInvoked := A_TickCount
      cX := mX, cY := mY
      %thisFunc%(dir)
      Sleep, % delayu
      thisIndex++
   }
   setwhileLoopExec(0)
}

tlbrChangeBrushSoft() {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
   {
      If (BrushToolType!=1 && BrushToolTexture!=1)
         coreTlbrSlider("changeBrushSoftness", 100, 0)
      Else If (BrushToolTexture=1)
         showTOOLtip("WARNING: The current brush is based on a texture.`nSoftness does not apply for textures.")
      Else If (BrushToolType=1)
         showTOOLtip("WARNING: The current brush type does not have the softness property")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

tlbrDecreaseBrushSoft() {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
   {
      If (BrushToolType!=1 && BrushToolTexture!=1)
         changeBrushSoftness(-1)
      Else If (BrushToolTexture=1)
         showTOOLtip("WARNING: The current brush is based on a texture.`nSoftness does not apply for textures.")
      Else If (BrushToolType=1)
         showTOOLtip("WARNING: The current brush type does not have the softness property")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

tlbrChangeBrushOpacity() {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
      coreTlbrSlider("changeBrushOpacity", 150, 1)
}

tlbrDecreaseBrushOpacity() {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
      changeBrushOpacity(-1, 0)
}

tlbrChangeBrushSize() {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
      coreTlbrSlider("changeBrushSize", "brushSize", 0)
}

tlbrChangeBrushAngle() {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
      coreTlbrSlider("changeBrushAnglu", 100, 0)
}

tlbrChangeBrushRatio() {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()) && (BrushToolTexture=1 || BrushToolType=1))
   {
      coreTlbrSlider("changeBrushShapeRatio", 125, 0)
   } Else If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()) && BrushToolType>1)
   {
      showTOOLtip("WARNING: The current brush is based on a texture.`nThe aspect ratio cannot be changed")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

tlbrEraserBrush() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      DeletePicture()
   } Else If isImgEditingNow()
   {
      If (AnyWindowOpen=31 || AnyWindowOpen=24)
         toggleErasePasteInPlace()
      Else If (AnyWindowOpen!=64)
         PanelBrushTool(4, "e")
      Else
         toggleBrushTypeEraser()
   }
}

tlbrFloodFill() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=66)
         PanelFloodFillTool()
      Else If (editingSelectionNow=1)
         toggleBrushDrawInOutModes()
   }
}

tlbrInvertStuff() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen && markedSelectFile>0)
      invertFilesSelection()
   Else If isImgEditingNow()
      InvertSelectedArea()
}

tlbrBlurBrush() {
   If isImgEditingNow()
   {
      If (AnyWindowOpen!=64)
         PanelBrushTool(5, "b")
      Else
         coreTlbrSlider("tlbrChangeBrushFXblur", 200, 0)
   }
}

tlbrChangeBrushFXblur(dir) {
   togglePresetsBrushes(1, dir)
}

tlbrAmaskPanel() {
   If isImgEditingNow()
      PanelSoloAlphaMasker()
}

tlbrAmaskInvert() {
   If isImgEditingNow()
      toggleInvertAlphaMask()
}

tlbrAmaskCapture() {
   If (isImgEditingNow() && editingSelectionNow=1)
      SetImageAsAlphaMask()
}

tlbrAmaskView() {
   If (isImgEditingNow() && editingSelectionNow=1)
      ViewAlphaMaskNow()
}

tlbrAmaskRaster() {
   If isImgEditingNow()
      RasterizeAlphaMaskNow()
}

tlbrAmaskPaint() {
   If (isImgEditingNow() && isAlphaMaskWindow() && editingSelectionNow=1)
      toggleAlphaPaintingMode()
}

tlbrAmaskDiscard() {
   If isImgEditingNow()
      discardUserPaintedAlpha()
}

tlbrPenFill() {
   If isImgEditingNow()
   {
      MenuStartDrawingShapes()
      Return "m"
   }
}

tlbrPenOutline() {
   If isImgEditingNow()
   {
      MenuStartDrawingLines()
      Return "m"
   }
}

tlbrBtnViewToggle() {
    isWelcomeScreenu := (isImgEditingNow() || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
    If (isImgEditingNow()=1 && drawingShapeNow=1)
       togglePreviewVectorNewPoint()
    Else If !isWelcomeScreenu
       ToggleImgNavBox()
}

tlbrNavSizeBox() {
    If (isImgEditingNow()=1 && drawingShapeNow=1)
       togglePreviewVectorNewPoint()
    Else If !isWelcomeScreenu
       ToggleImgNavSizeBox()
}

tlbrPipette() {
   ; If (isImgEditingNow()=1 && AnyWindowOpen=64)
   If (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen)
      changeBrushColorPicker()
}

tlbrSwitchColors() {
   ; If isImgEditingNow()
   If (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen)
      ToggleBrushColors()
}

tlbrSelectAlignMenu() {
   ; If isImgEditingNow()
   If (isImgEditingNow() && imgEditPanelOpened=1)
   {
      deleteMenus()
      createMenuSelectionAlign()
      globalMenuOptions := StrReplace(globalMenuOptions, "tlbrMenu", "PVselAlign")
      showThisMenu("PVselAlign")
   }
}

tlbrCropImg() {
   If (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24))
   {
      togglePasteInPlaceCropShapes()
   } Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      PanelSimpleResizeRotate()
   } Else If (isImgEditingNow()=1 && !AnyWindowOpen)
   {
      If (editingSelectionNow=1)
         CropImageInViewPortToSelection()
      Else If !AnyWindowOpen
         PanelAdjustImageCanvasSize()
   }
}

tlbrSelAllVectorPoints() {
    Static lastState := 0
    If lastState
       MenuSelAllVectorPoints()
    Else
       MenuSelNoVectorPoints()
    lastState := !lastState
}

tlbrViewPortGridu() {
   Static lastInvoked := 1
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      toggleListViewModeThumbs()
   } Else If isImgEditingNow()
   {
      If (A_TickCount - lastInvoked<450)
         Return

      lastInvoked := A_TickCount
      If (GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P"))
      {
         toggleViewPortGridu()
         Return
      }

      vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
      coreTlbrSlider("changeGridSize", 10, 0)
      vpImgPanningNow := 0
   }
   ; Else If isImgEditingNow() 
   ;    toggleViewPortGridu()
}

tlbrConfigVPgrid() {
   If (isImgEditingNow()=1 && drawingShapeNow=1)
      toggleViewPortGridu()
   Else If (isImgEditingNow()=1 && (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen!=24 && AnyWindowOpen!=31))
      PanelConfigVPgrid()
}

tlbrResizeImage() {
   If (isImgEditingNow()=1 && editingSelectionNow!=1)
      ToggleEditImgSelection()
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
      ResizeIMGviewportSelection()
}

tlbrRotateImg() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      filesListFlipRotatePlus()
   } Else If (isImgEditingNow()=1 && editingSelectionNow=1)
   {
      If (GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P"))
      {
         VPselRotation := 0
         Return
      }

      If GetKeyState("Alt", "P")
         coreTlbrSlider("changeSelRotation", 5, 0)
      Else
         coreTlbrSlider("changeTlbrSelRotation", 25, 0)
   } Else If (isImgEditingNow()=1)
   {
      If (GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P"))
      {
         vpIMGrotation := 0
         Return
      }

      If GetKeyState("Alt", "P")
         coreTlbrSlider("changeLittleImgRotationInVP", 5, 0)
      Else
         coreTlbrSlider("changeImgRotationInVP", 25, 0)
   }
}

tlbrResetRotation() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      filesListFlipRotateMinus()
   } Else If (isImgEditingNow()=1 && editingSelectionNow=1 && VPselRotation!=0)
   {
      VPselRotation := 0
      SetTimer, dummyRefreshImgSelectionWindow, -10
      userFriendlyPrevImgSelAction := "RESET SELECTION AREA"
      SetTimer, dummyShowSelCoordsInfos, -20
   } Else If (isImgEditingNow()=1 && vpIMGrotation!=0)
      changeImgRotationInVP(1, 45, 1)
}

tlbrTransformSelection() {
   If (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24))
      togglePasteInPlaceAdaptModes()
   Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      importEditGivenImageFile()
   Else If (isImgEditingNow()=1 && editingSelectionNow=1)
   {
      If !AnyWindowOpen
      {
         PanelTransformSelectedArea()
      } Else If (imgEditPanelOpened=1)
      {
         showTOOLtip("WARNING: Action not permitted while the current tool is active.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

tlbrOpenImg() {
   If !AnyWindowOpen
      OpenDialogFiles()
   Return "m"
}

tlbrOpenMenu() {
   If !AnyWindowOpen
      InvokeOpenRecentMenu("tlbr")
   Return "m"
}

tlbrBlurArea() {
   If (isImgEditingNow()=1 && (!AnyWindowOpen || imgEditPanelOpened=1))
      PanelBlurSelectedArea()
}

tlbrSaveImg() {
   If (isImgEditingNow()=1 && !AnyWindowOpen)
      PanelSaveImg()
   Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      PanelSaveSlideShowu()
}

tlbrOpenAnnotations(){
   imgPath := getIDimage(currentFileIndex)
   If (isImgEditingNow()=1 && FileExist(imgPath) && (!AnyWindowOpen || imgEditPanelOpened=1))
      PanelEditImgCaption()
}

tlbrOpenVPcolors(){
   If (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24))
      togglePasteInPlaceColorsFX()
   Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      PanelSetThumbColumnOptions()
   Else If isImgEditingNow()
   {
      If GetKeyState("Alt", "P")
         PanelColorsAdjusterWindow()
      Else
         PanelColorsAdjusterImage()
   }
}

tlbrFlipSelectionH() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      VPflipImgH()
   Else If (isImgEditingNow()=1 && EllipseSelectMode=2 && editingSelectionNow=1 && drawingShapeNow!=1)
      flipWHcustomShape("H")
   Else If (isImgEditingNow()=1 && editingSelectionNow=1 && drawingShapeNow!=1)
      VPflipImgH()
}

tlbrFlipSelectionV() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      VPflipImgV()
   Else If (isImgEditingNow()=1 && EllipseSelectMode=2 && editingSelectionNow=1 && drawingShapeNow!=1)
      flipWHcustomShape("V")
   Else If (isImgEditingNow()=1 && editingSelectionNow=1 && drawingShapeNow!=1)
      VPflipImgV()
}

tlbrFlipStuffH(){
   editing := isImgEditingNow()
   If (editing=1 && drawingShapeNow=1)
      toggleBrushSymmetryModes()
   Else If (editing=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
      FlipHtransformedIMGpanel()
   Else If (editing=1 && isNowAlphaPainting())
      FlipHalphaMask()
   Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      filesListFlipHimage()
   Else If (editing=1 && editingSelectionNow=1)
      FlipSelectedAreaH()
   Else If (editing=1)
      VPflipImgH()
}

tlbrFlipStuffV(){
   editing := isImgEditingNow()
   If (editing=1 && drawingShapeNow=1)
      toggleBrushSymmetryModes()
   Else If (editing=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
      FlipVtransformedIMGpanel()
   Else If (editing=1 && isNowAlphaPainting())
      FlipValphaMask()
   Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      filesListFlipVimage()
   Else If (editing=1 && editingSelectionNow=1)
      FlipSelectedAreaV()
   Else If (editing=1)
      VPflipImgV()
}

tlbrFillShape() {
   If (isImgEditingNow()=1 && AnyWindowOpen=23)
   {
      UIcycleFillShapes()
   } Else If isImgEditingNow()
   {
      If (EllipseSelectMode=2)
         FillAreaShape := 7
      Else If (EllipseSelectMode=1)
         FillAreaShape := 3
      Else If (EllipseSelectMode=0)
         FillAreaShape := 1

      PanelFillSelectedArea("tlbr", FillAreaShape)
   }
}

tlbrFillBehind() {
   If isImgEditingNow()
      PanelFillBehindBgrImage()
}

tlbrOutlineShape() {
   If (isImgEditingNow()=1 && AnyWindowOpen=65)
   {
      UIcycleFillShapes()
   } Else If (isImgEditingNow()=1)
   {
      If (editingSelectionNow!=1)
         ToggleEditImgSelection()

      If (EllipseSelectMode=2)
         FillAreaShape := 7
      Else If (EllipseSelectMode=1)
         FillAreaShape := 3
      Else If (EllipseSelectMode=0)
         FillAreaShape := 1

      PanelDrawShapesInArea("tlbr", FillAreaShape)
   }
}

tlbrOpenLinesPanel() {
   If (isImgEditingNow()=1 && editingSelectionNow=1)
      PanelDrawLines()
}

tlbrZoomIN(dummy:=0) {
   If (thumbsDisplaying=1 && maxFilesIndex>3 && CurrentSLD)
   || (isImgEditingNow()=1)
   {
      If (GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P")) && (IMGresizingMode=4 && dummy!="navBox")
      {
         IMGdecalageX := IMGdecalageY := 0
         zoomLevel := 1
         dummyTimerDelayiedImageDisplay(50)
         Return
      }

      GetPhysicalCursorPos(oX, oY)
      cX := cY := lastIndex := thisIndex := lastInvoked := 0
      setwhileLoopExec(1)
      vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
      While, (determineLClickstate()=1 || A_Index=1)
      {
         GetPhysicalCursorPos(mX, mY)
         dir := (oY<mY) ? -1 : 1
         If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
         {
            If !isInRange(thisIndex, lastIndex - 2, lastIndex + 2)
            || (A_TickCount - lastInvoked>100)
            {
               lastIndex := thisIndex
               MouseMove, % oX, % oY, 1
            }
            Continue
         }
         lastInvoked := A_TickCount
         cX := mX, cY := mY
         ChangeZoom(dir, 0, 1, 1) 
         Sleep, % (thumbsDisplaying=1) ? 10 : -1
         thisIndex++
      }
      vpImgPanningNow := 0
      dummyTimerDelayiedImageDisplay(150)
      setwhileLoopExec(0)
   }
   Return "m"
}

tlbrZoomToggle() {
   If (thumbsDisplaying=1 && maxFilesIndex>3 && CurrentSLD)
      ToggleThumbsAratio()
   Else If (isImgEditingNow()=1)
      ToggleImageSizingMode()
}

tlbrPasteQuick() {
   If (thumbsDisplaying=1)
      MenuPasteHDropFiles()
   Else
      PasteClipboardIMG()
}

tlbrDropSelection() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) 
   {
      deleteMenus()
      createMenuFilesSelections("PVfileSel")
      showThisMenu("PVfileSel")
      Return "m"
   } Else If (isImgEditingNow()=1)
   {
      ToggleEditImgSelection() 
   }
}

tlbrSelectShape() {
   MenuCycleSelectionShapes()
}

MenuCycleSelectionShapes() {
   If (isImgEditingNow()=1 && editingSelectionNow=1)
   {
      imgLiveEdit := (!AnyWindowOpen) || (HKifs("liveEdit") && isVarEqualTo(AnyWindowOpen, 10, 25, 55, 64, 66, 68, 74)) ? 1 : 0
      If isVarEqualTo(AnyWindowOpen, 31, 24)
         toggleLiveEditObject()
      Else If isVarEqualTo(AnyWindowOpen, 65, 23)
         UIcycleFillShapes()
      Else If imgLiveEdit
         toggleEllipseSelection()
   } Else If (thumbsDisplaying=1 && currentFileIndex>0 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      markThisFileNow()
   } Else If (isImgEditingNow()=1)
      ToggleEditImgSelection()
   ; ToolTip, % EllipseSelectMode "=" hwnd "=" paramu , , , 2
}

decideIconBTNselectShape() {
   initialIcon := tlbrIconzList["BTNselectShape", 2]
   thisHwnd := tlbrIconzList["BTNselectShape", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := (EllipseSelectMode=1) ? "select-ellipse" : "select-rect"
   If (thumbsDisplaying=1)
      icoFile := "select-rect"
   Else If (EllipseSelectMode=2)
      icoFile := "select-freeform"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNselectShape", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}


decideIconBTNthumbsList() {
   initialIcon := tlbrIconzList["BTNthumbsList", 2]
   thisHwnd := tlbrIconzList["BTNthumbsList", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]

   If (thumbsListViewMode=1)
      icoFile := "thumbs-list"
   Else If (thumbsListViewMode=2)
      icoFile := "files-list-simple"
   Else ; If (thumbsListViewMode>=3)
      icoFile := "files-list-details"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNthumbsList", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

decideIconBTNmainTooler() {
   initialIcon := tlbrIconzList["BTNmainTooler", 2]
   thisHwnd := tlbrIconzList["BTNmainTooler", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := (AnyWindowOpen && imgEditPanelOpened=1 || drawingShapeNow=1) ? "apply-tool" : "go-back"
   If isVarEqualTo(AnyWindowOpen, 10, 64, 66, 70)
      icoFile := "main-tool"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNmainTooler", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

decideIconBTNpaintBrushSelect() {
   initialIcon := tlbrIconzList["BTNpaintSelection", 2]
   thisHwnd := tlbrIconzList["BTNpaintSelection", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := (BrushToolOutsideSelection=1) ? "paint-any" : "paint-inside"
   If (BrushToolOutsideSelection=3)
      icoFile := "paint-outside"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNpaintSelection", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

tlbrtoggleBrushDrawModes() {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || AnyWindowOpen=66))
      toggleBrushDrawInOutModes()
      ; ToolTip, % EllipseSelectMode "=" hwnd "=" paramu , , , 2
}

tlbrSaveList() {
   If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      PanelSaveSlideShowu()
}

tlbrSelectFreeform() {
   If isImgEditingNow()
   {
      If (editingSelectionNow!=1 || EllipseSelectMode!=2)
         MenuStartDrawingSelectionArea()
      Else
         MenuResumeDrawingShapes()
   }
   Return "m"
}

tlbrInvokeShapesMenu(givenCoords:=0) {
   If isImgEditingNow()
   {
      deleteMenus()
      createMenuSelectSizeShapes()
      globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVselSize") : givenCoords
      showThisMenu("PVselSize")
   }
   Return "m"
}

tlbrUndoAction() {
   If isImgEditingNow()
   {
      If (drawingShapeNow=1)
      {
         ImgVectorUndoAct()
         Return "m"
      }
      setwhileLoopExec(1)
      While, (determineLClickstate()=1 || A_Index=1)
      {
         ImgUndoAction()
         Sleep, % (A_Index<10) ? 200 : 90
      }
      setwhileLoopExec(0)
   }
   Return "m"
}

tlbrPanIMG() {
   Static lastInvoked := 1
   If (isImgEditingNow()=1 && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4)
   {
      IMGresizingMode := 4
      If (A_TickCount - lastInvoked<350)
      {
         IMGdecalageX := IMGdecalageY := 0
         dummyTimerDelayiedImageDisplay(10)
         Return
      }

      simplePanIMGonClick()
      lastInvoked := A_TickCount
   }
   Return "m"
}

tlbrCloseWindow() {
   If isNowAlphaPainting()
      toggleAlphaPaintingMode()
   Else If (isImgEditingNow()=1 && drawingShapeNow=1)
      stopDrawingShape("cancel")
   Else If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      ToggleThumbsMode()
   Else If (isImgEditingNow()=1 && imgEditPanelOpened=1)
      BtnCloseWindow()
   Return "m"
}

tlbrApplyImgEditFunc() {
   If (isImgEditingNow()=1 && drawingShapeNow=1)
   {
      stopDrawingShape()
   } Else If (isImgEditingNow()=1 && imgEditPanelOpened=1)
   {
      applyIMGeditFunction()
      ; SetTimer, BtnCloseWindow, -100
   } Else If !AnyWindowOpen
      openPreviousPanel()
   Return "m"
}

tlbrRedoAction() {
   If isImgEditingNow()
   {
      If (drawingShapeNow=1)
      {
         ImgVectorRedoAct()
         Return "m"
      }

      setwhileLoopExec(1)
      While, (determineLClickstate()=1 || A_Index=1)
      {
         ImgRedoAction()
         Sleep, % (A_Index<10) ? 200 : 90
      }
      setwhileLoopExec(0)
   }
   Return "m"
}

tlbrNewImage() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      addNewFile2list()
   Else If (!AnyWindowOpen || imgEditPanelOpened=1)
      PanelNewImage()
}

tlbrAcquireimage() {
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      addNewFolder2list()
   Else If !AnyWindowOpen
      AcquireWIAimage()
}

invokeSortListMenu(){
   If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      deleteMenus()
      createMenuFilesSort()
      globalMenuOptions := StrReplace(globalMenuOptions, "tlbrMenu", "PVsort")
      showThisMenu("PVsort")
      Return "m"
   }
}

tlbrFoldersTree() {
   If AnyWindowOpen
      Return

   isWelcomeScreenu := (StrLen(UserMemBMP)>2 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
   If isWelcomeScreenu
      InvokeOpenRecentMenu("tlbr")
   Else
      MenuPanelFoldersTree()
}

CoreGUItoolbar() {
    Static BTNrotateTlbr := ["rotate-tlbr", "TLBRswitchAlign", "Toggle vertical or horizontal toolbar alignment", "BTNrotateTlbr"]
         ; , localBtnID := [ico-file-name, primary-func-l-click, base-user-friendly-name, secontary-func-r-click, button-ID, param-func, menu-mode]
         , BTNdragTlbr := ["dragger", "TLBRdraggyNow", "Reposition toolbar", "invokeTlbrContextMenu", "BTNdragTlbr", 0, 1]
         , BTNdisabled := ["disabled", "dummy", "-", 0, "BTNdisabled"]
         , BTNcloseTlbr := ["close", "toggleAppToolbar", "Close toolbar", 0, "BTNcloseTlbr"]
         , BTNcancelTool := ["cancel-tool", "tlbrCloseWindow", "Cancel tool", 0, "BTNcancelTool"]
         , BTNsettings := ["menu", "tlbrInvokeEditMenu", "Quick settings menu", "tlbrInvokeInterfaceMenu", "BTNsettings", 0, 1]
         , BTNcopyImg := ["copy", "MenuCopyAction", "Copy to clipboard", "CopyImagePath", "BTNcopyImg"]
         , BTNnewImg := ["new-image", "tlbrNewImage", "New image", "tlbrAcquireimage", "BTNnewImg"]
         , BTNpasteImg := ["paste-clip", "tlbrPasteQuick", "Paste from clipboard", "PanelPasteInPlace", "BTNpasteImg"]
         , BTNundoImg := ["undo", "tlbrUndoAction", "Undo image action", "ImgSelUndoAct", "BTNundoImg"]
         , BTNredoImg := ["redo", "tlbrRedoAction", "Redo image action", "ImgSelRedoAct", "BTNredoImg"]
         , BTNtextTool := ["add-text", "tlbrInsertTextArea", "Insert text into image", "tlbrOpenAnnotations", "BTNtextTool"]
         , BTNeraserTool := ["eraser", "tlbrEraserBrush", "Eraser brush", "tlbrEraserTool", "BTNeraserTool"]
         , BTNblurTool := ["brush-blur", "tlbrBlurBrush", "Blur brush", "tlbrBlurArea", "BTNblurTool"]
         , BTNclonerTool := ["brush-cloner", "tlbrClonerBrush", "Cloner brush", "BtnSetClonerBrushSource", "BTNclonerTool"]
         , BTNbrushMtool := ["brush-main", "tlbrMainBrushSoft", "Brush tool", "tlbrMainBrushHard", "BTNbrushMtool"]
         , BTNFXbrush := ["brush-fx", "tlbrFXbrush", "Color effects soft brush", 0, "BTNFXbrush"]
         , BTNwetbrush := ["brush-wet", "tlbrWetBrush", "Soft edges wet Brush", "tlbrDecreaseWetBrush", "BTNwetbrush"]
         , BTNpenVector := ["pen-vector", "tlbrPenFill", "Draw freeform shape", "tlbrPenOutline", "BTNpenVector"]
         , BTNpipette := ["pipette", "tlbrPipette", "Pick color", "tlbrSwitchColors", "BTNpipette"]
         , BTNcolorsSwatch := ["colorz-swatch", "tlbrActColorsSwatch", "Choose colors", "tlbrSwitchColors", "BTNcolorsSwatch"]
         , BTNalphInvert := ["alpha-mask-invert", "tlbrAmaskInvert", "Invert alpha mask", 0, "BTNalphInvert"]
         , BTNalphRaster := ["alpha-mask-pixelize", "tlbrAmaskRaster", "Rasterize alpha mask", 0, "BTNalphRaster"]
         , BTNalphPaint := ["alpha-mask-paint", "tlbrAmaskPaint", "Paint alpha mask", 0, "BTNalphPaint"]
         , BTNalphCapture := ["alpha-mask-capture", "tlbrAmaskCapture", "Capture alpha mask", 0, "BTNalphCapture"]
         , BTNalphPanel := ["alpha-mask-panel", "tlbrAmaskPanel", "Alpha mask options panel", 0, "BTNalphPanel"]
         , BTNalphView := ["alpha-mask-view", "tlbrAmaskView", "View alpha mask", 0, "BTNalphView"]
         , BTNalphDiscard := ["alpha-mask-discard", "tlbrAmaskDiscard", "Discard alpha mask", 0, "BTNalphDiscard"]
         , BTNcrop := ["crop", "tlbrCropImg", "Crop image to selection", "tlbrResizeImage", "BTNcrop"]
         , BTNsave := ["save-disk", "tlbrSaveImg", "Save image to disk", "tlbrSaveList", "BTNsave"]
         , BTNopen := ["open", "tlbrOpenImg", "Open image", "tlbrOpenMenu", "BTNopen", 0, 1]
         , BTNcutImg := ["cut", "tlbrCutImg", "Cut selection", "tlbrMoveFiles", "BTNcutImg"]
         , BTNadjustColors := ["adjust-colors", "tlbrOpenVPcolors", "Adjust viewport colors", "ResetImageView", "BTNadjustColors"]
         , BTNtlbrflipH := ["flip-h", "tlbrFlipStuffH", "Flip horizontally", "tlbrFlipSelectionH", "BTNtlbrflipH"]
         , BTNtlbrflipV := ["flip-v", "tlbrFlipStuffV", "Flip vertically", "tlbrFlipSelectionV", "BTNtlbrflipV"]
         , BTNtransformArea := ["transform-img", "tlbrTransformSelection", "Transform selected area", 0, "BTNtransformArea"]
         , BTNrotateStuff := ["rotation", "tlbrRotateImg", "Rotate by 45 degrees", "tlbrResetRotation", "BTNrotateStuff"]
         , BTNfillShape := ["fill-shape", "tlbrFillShape", "Fill selection area", "tlbrFillBehind", "BTNfillShape"]
         , BTNoutlineShape := ["outline-shape", "tlbrOutlineShape", "Draw shape contours", "tlbrOpenLinesPanel", "BTNoutlineShape"]
         , BTNselectShape := ["select-rect", "tlbrSelectShape", "Create selection area", "tlbrDropSelection", "BTNselectShape"]
         , BTNselectFreeform := ["create-freeform", "tlbrSelectFreeform", "Create freeform selection", "tlbrInvokeShapesMenu", "BTNselectFreeform"]
         , BTNloupe := ["loupe", "tlbrZoomIN", "Zoom in / out", "tlbrZoomToggle", "BTNloupe"]
         , BTNpreviewBox := ["view", "tlbrBtnViewToggle", "Toggle image preview", "tlbrNavSizeBox", "BTNpreviewBox"]
         , BTNsearch := ["search", "PanelSearchIndex", "Search", "PanelSearchAndReplaceIndex", "BTNsearch"]
         , BTNmodifyEntry := ["modify-entry", "PanelRenameThisFile", "Rename file[s]", "PanelUpdateThisFileIndex", "BTNmodifyEntry"]
         , BTNfilterList := ["filter", "PanelEnableFilesFilter", "Filter files list", "MenuRemFilesListFilter", "BTNfilterList"]
         , BTNstatsList := ["statistics", "PanelWrapperFilesStats", "Indexed files statistics", "PanelFindDupes", "BTNstatsList"]
         , BTNsortList := ["sort-list", "invokeSortListMenu", "Sort files list", 0, "BTNsortList", 0, 1]
         , BTNrefreshList := ["refresh", "RefreshFilesList", "Refresh files list", "DeepRefreshThumbsNow", "BTNrefreshList"]
         , BTNfolderTree := ["folder-tree", "tlbrFoldersTree", "Folder tree view", "invokeFoldersListerMenu", "BTNfolderTree"]
         , BTNinfozHud := ["infos", "ToggleInfoBoxu", "Show image information", "PanelImageInfos", "BTNinfozHud"]
         , BTNmngFolderz := ["manage-folders", "PanelDynamicFolderzWindow", "Manage folders", "PanelStaticFolderzManager", "BTNmngFolderz"]
         , BTNfntSize := ["font-size", "tlbrChangeOSDfontSize", "Change OSD font size", "tlbrDecreaseOSDfontSize", "BTNfntSize"]
         , BTNfaves := ["star", "tlbrAddFaves", "Add/remove from favourites", "InvokeFavesMenu", "BTNfaves", 0, 1]
         , BTNpanImg := ["pan-img", "tlbrPanIMG", "Pan image in viewport", "ToggleImgNavBox", "BTNpanImg"]
         , BTNmainTooler := ["apply-tool", "tlbrApplyImgEditFunc", "Apply current tool", "tlbrCloseWindow", "BTNmainTooler"]
         , BTNplaySlides := ["play", "tlbrPlaySlides", "Play slideshow", "PanelDefineEntireSlideshowLength", "BTNplaySlides"]
         , BTNchangeBrushSoft := ["brush-set-soft", "tlbrChangeBrushSoft", "Change brush softness", "tlbrDecreaseBrushSoft", "BTNchangeBrushSoft"]
         , BTNchangeBrushOpacity := ["brush-set-opacity", "tlbrChangeBrushOpacity", "Change brush opacity", "tlbrDecreaseBrushOpacity", "BTNchangeBrushOpacity"]
         , BTNchangeBrushSize := ["brush-set-size", "tlbrChangeBrushSize", "Change brush size", "toggleBrushDoubleSize", "BTNchangeBrushSize"]
         , BTNchangeBrushAngle := ["brush-set-angle", "tlbrChangeBrushAngle", "Change brush angle", "toggleBrushMouseAngle", "BTNchangeBrushAngle"]
         , BTNchangeBrushRatio := ["brush-set-ratio", "tlbrChangeBrushRatio", "Change brush ratio", "resetBrushAsRatio", "BTNchangeBrushRatio"]
         , BTNvectSmooth := ["vector-smooth", "togglePathCurveTension", "Cycle path smoothness", 0, "BTNvectSmooth"]
         , BTNvectRemLast := ["vector-rem-last", "reduceCustomShapelength", "Remove last point in path", 0, "BTNvectRemLast"]
         , BTNvectRemPoints := ["vector-rem-points", "MenuRemSelVectorPoints", "Remove selected points in path", 0, "BTNvectRemPoints"]
         , BTNvectSelInvert := ["vector-select-invert", "MenuSelInvertVectorPoints", "Invert selected points in path", 0, "BTNvectSelInvert"]
         , BTNvectOpenPath := ["vector-open-path", "toggleOpenClosedLineCustomShape", "Toggle opened path", 0, "BTNvectOpenPath"]
         , BTNvectSelAll := ["vector-select-all", "tlbrSelAllVectorPoints", "Select all points in path", "MenuSelNoVectorPoints", "BTNvectSelAll"]
         , BTNpaintSelection := ["paint-outside", "tlbrtoggleBrushDrawModes", "Toggle brush selection area mode", 0, "BTNpaintSelection"]
         , BTNalignSel := ["select-align", "tlbrSelectAlignMenu", "Align selection area", 0, "BTNalignSel", 0, 1]
         , BTNhelp := ["help", "tlbrHelpBtn", "Help", 0, "BTNhelp"]
         , BTNfloodFill := ["flood-fill", "tlbrFloodFill", "Flood fill", 0, "BTNfloodFill"]
         , BTNcalculate := ["calculate", "CalculateSelectedFilesSizes", "Calculate file sizes", "PanelReviewSelectedFiles", "BTNcalculate"]
         , BTNinvertStuff := ["invert", "tlbrInvertStuff", "Invert image", 0, "BTNinvertStuff"]
         , BTNquickFacts := ["quick-file-acts", "PanelQuickMoveConfigure", "Quick file actions", "PanelJump2index", "BTNquickFacts"]
         , BTNvpGrid := ["vp-grid", "tlbrViewPortGridu", "Viewport grid", "tlbrConfigVPgrid", "BTNvpGrid"]
         , BTNthumbsList := ["thumbs-list", "tlbrViewPortGridu", "Viewport grid", "ToggleIMGalign", "BTNthumbsList"]
         , prevState := 0

    BTNmainTooler[1] := (AnyWindowOpen && imgEditPanelOpened=1 || drawingShapeNow=1) ? "apply-tool" : "go-back"
    If (AnyWindowOpen=10 || AnyWindowOpen=70 || AnyWindowOpen=64 || AnyWindowOpen=66)
       BTNmainTooler[1] := "main-tool"

    icoFile := (BrushToolOutsideSelection=1) ? "paint-any" : "paint-inside"
    If (BrushToolOutsideSelection=3)
       icoFile := "paint-outside"
    BTNpaintSelection[1] := icoFile

    icoFile := (EllipseSelectMode=1) ? "select-ellipse" : "select-rect"
    If (thumbsDisplaying=1)
       icoFile := "select-rect"
    Else If (EllipseSelectMode=2)
       icoFile := "select-freeform"
    BTNselectShape[1] := icoFile

    If (thumbsListViewMode=1)
       friendly := "thumbs-list"
    Else If (thumbsListViewMode=2)
       friendly := "files-list-simple"
    Else If (thumbsListViewMode>=3)
      friendly := "files-list-details"
    BTNthumbsList[1] := friendly

    TlbrGuiMarginH := ToolBarBtnWidth//5
    TlbrGuiMarginV := TlbrGuiMarginH
    IconSpacing := (TLBRverticalAlign=1) ? TlbrGuiMarginH//1.3 : TlbrGuiMarginH//1.3
    handleWidth := (TLBRverticalAlign=1) ? ToolBarBtnWidth + IconSpacing*2 : ToolBarBtnWidth//2
    handleHeight := (TLBRverticalAlign=1) ? ToolBarBtnWidth//3 : ToolBarBtnWidth + IconSpacing*2
    handleClrW := (TLBRverticalAlign=1) ? ToolBarBtnWidth + IconSpacing*2 : ToolBarBtnWidth
    handleClrH := (TLBRverticalAlign=1) ? ToolBarBtnWidth : ToolBarBtnWidth + IconSpacing*2
    If (TLBRtwoColumns=1 && !isWelcomeScreenu)
    {
       handleWidth := handleWidth*2 - IconSpacing*2
       handleClrW := handleWidth - IconSpacing*2
       handleClrH += IconSpacing
       handleHeight := Round(handleHeight*1.5)
    } Else If (TLBRverticalAlign!=1)
    {
       handleClrW := handleClrW*2 + IconSpacing*3
    } Else If (TLBRverticalAlign=1)
       handleClrH := handleClrH - Ceil(IconSpacing*2.5)

    isVectorMode := (drawingShapeNow=1 && editingSelectionNow=1 && EllipseSelectMode=2) ? 1 : 0
    isWelcomeScreenu := (isImgEditingNow() || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
    isTransPanel := (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24)) ? 1 : 0
    totalIconz := (isTransPanel=1) ? 20 : 32
    If isWelcomeScreenu
       totalIconz := 9
    TouchToolbarGUIcreated := 1
    thisState := "a" ToolBarBtnWidth totalIconz TLBRverticalAlign ToolbarScaleFactor TLBRtwoColumns  drawingShapeNow
    simpleRefresh := (thisState=prevState) ? 1 : 0
    If (simpleRefresh=0)
    {
       Gui, OSDguiToolbar: Destroy
       Sleep, 10
       Gui, OSDguiToolbar: Default
       Gui, OSDguiToolbar: Margin, 0, 0
       Gui, OSDguiToolbar: -DPIScale -Caption +ToolWindow +hwndhQPVtoolbar +Owner%PVhwnd%
       Gui, OSDguiToolbar: Color, % ToolbarBgrColor, % ToolbarBgrColor
    }
    ; Gui, OSDguiToolbar: Font, s1
    tlbrAddNewIcon(BTNdragTlbr, handleWidth, handleHeight, 0, 1, simpleRefresh)
    tlbrAddNewIcon(BTNsettings, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    tlbrAddNewIcon(BTNmainTooler, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    If (thumbsDisplaying=1)
    {
       tlbrAddNewIcon(BTNplaySlides, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNfntSize, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    } Else If !isWelcomeScreenu
    {
       If (isVectorMode=1)
       {
          tlbrAddNewIcon(BTNpreviewBox, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNcancelTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       }
       tlbrAddNewIcon(BTNundoImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNredoImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    }

    If (isVectorMode=1)
    {
       tlbrAddNewIcon(BTNvectSmooth, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNvectRemLast, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNvectRemPoints, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNvectSelInvert, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNvectOpenPath, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       tlbrAddNewIcon(BTNvectSelAll, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    } Else
    {
       addAlphaIcons := (isAlphaMaskPartialWin()=1 || isAlphaMaskWindow()=1) ? 1 : 0
       If (addAlphaIcons=1 && !isNowAlphaPainting())
       {
          tlbrAddNewIcon(BTNalphCapture, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNalphDiscard, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNalphInvert, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          If isAlphaMaskPartialWin()
             tlbrAddNewIcon(BTNalphPanel, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          Else
             tlbrAddNewIcon(BTNalphPaint, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)

          tlbrAddNewIcon(BTNalphView, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          If (AnyWindowOpen=66)
             tlbrAddNewIcon(BTNpaintSelection, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          Else
             tlbrAddNewIcon(BTNalphRaster, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       } Else If (AnyWindowOpen=64 || isNowAlphaPainting())
       {
          tlbrAddNewIcon(BTNchangeBrushSoft, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNchangeBrushOpacity, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNchangeBrushSize, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNchangeBrushAngle, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNchangeBrushRatio, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          If isNowAlphaPainting()
             tlbrAddNewIcon(BTNalphView, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          Else
             tlbrAddNewIcon(BTNpaintSelection, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       } Else
       {
          tlbrAddNewIcon(BTNopen, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          If !isWelcomeScreenu
          {
             tlbrAddNewIcon(BTNsave, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNcutImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNcopyImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }
          tlbrAddNewIcon(BTNpasteImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNnewImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       }

       If isVarEqualTo(AnyWindowOpen, 23, 25, 30, 32, 55, 65, 68, 74)
          tlbrAddNewIcon(BTNalignSel, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       Else If !isWelcomeScreenu
          tlbrAddNewIcon(BTNcrop, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)

       If !isWelcomeScreenu
          tlbrAddNewIcon(BTNselectShape, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)

       If (thumbsDisplaying!=1 && !isWelcomeScreenu)
       {
          If (isTransPanel!=1)
          {
             tlbrAddNewIcon(BTNselectFreeform, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNfillShape, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNoutlineShape, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNpipette, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNbrushMtool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNFXbrush, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNwetbrush, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNblurTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNclonerTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }
       } Else
       {
          tlbrAddNewIcon(BTNfaves, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          If !isWelcomeScreenu
          {
             tlbrAddNewIcon(BTNmngFolderz, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNsearch, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNmodifyEntry, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNfilterList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNstatsList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNsortList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNrefreshList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }
          tlbrAddNewIcon(BTNfolderTree, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       }

       If !isWelcomeScreenu
          tlbrAddNewIcon(BTNeraserTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)

       If (thumbsDisplaying=1)
       {
          tlbrAddNewIcon(BTNinfozHud, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNcalculate, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNquickFacts, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       } Else If !isWelcomeScreenu
       {
          If (isTransPanel!=1)
          {
             tlbrAddNewIcon(BTNpenVector, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNfloodFill, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }

          If isNowAlphaPainting()
             tlbrAddNewIcon(BTNalphInvert, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          Else If (isTransPanel=1)
             tlbrAddNewIcon(BTNalignSel, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          Else
             tlbrAddNewIcon(BTNinvertStuff, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       }

       If (isTransPanel!=1 && !isWelcomeScreenu)
          tlbrAddNewIcon(BTNtextTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    }

    If !isWelcomeScreenu
    {
       tlbrAddNewIcon(BTNtlbrflipV, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       If !isVectorMode
       {
          tlbrAddNewIcon(BTNtlbrflipH, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNtransformArea, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNrotateStuff, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNadjustColors, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       }

       tlbrAddNewIcon(BTNloupe, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       If (thumbsDisplaying=1)
       {
          tlbrAddNewIcon(BTNthumbsList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNpreviewBox, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       } Else
       {
          tlbrAddNewIcon(BTNvpGrid, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNpanImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       }
    }

    If (!isWelcomeScreenu && !isVectorMode)
       tlbrAddNewIcon(BTNcolorsSwatch, handleClrW, handleClrH, 0, 0, simpleRefresh)
    Else If !isVectorMode
       tlbrAddNewIcon(BtnHelp, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    ; tlbrAddNewIcon(BTNrotateTlbr, handleWidth, handleHeight, 0)
    toolbarY := UserToolbarY, toolbarX := UserToolbarX
    todisplay := (ShowAdvToolbar=1) ? "" : "hide"
    prevState := thisState
    If (simpleRefresh=0)
       Gui, OSDguiToolbar: Show, x0 y0 AutoSize, QPV toolbar
}

createGUItoolbar(dummy:=0) {
   Static prevState, hasEverDisplayed
   If (ShowAdvToolbar=0)
   {
      interfaceThread.ahkassign("ShowAdvToolbar", ShowAdvToolbar)
      interfaceThread.ahkassign("lockToolbar2Win", lockToolbar2Win)
      If (TouchToolbarGUIcreated=1)
         Gui, OSDguiToolbar: Hide
      Return
   }

   If !hasEverDisplayed
   {
      ; GetPhysicalCursorPos(UserToolbarX, UserToolbarY)
      JEE_ClientToScreen(hPicOnGui1, 1, 1, UserToolbarX, UserToolbarY)
      UserToolbarX--
      UserToolbarY--
      hasEverDisplayed := 1
      delayedWriteTlbrColors(0)
      IniAction(0, "ShowToolTipsToolbar", "General", 1)
      IniAction(0, "ToolbarScaleFactor", "General", 2, 0.2, 5)
      IniAction(0, "TLBRverticalAlign", "General", 1)
      IniAction(0, "TLBRtwoColumns", "General", 1)
      IniAction(0, "lockToolbar2Win", "General", 1)
   }

   isWelcomeScreenu := (isImgEditingNow() || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
   isPaintPanel := (AnyWindowOpen=64) ? 1 : 0
   isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
   addAlphaIcons := isAlphaMaskPartialWin()
   ToolBarBtnWidth := Round(OSDfontSize*1.5 * ToolbarScaleFactor)
   currState := "a" isTransPanel isWelcomeScreenu addAlphaIcons isNowAlphaPainting() isAlphaMaskWindow() ToolBarBtnWidth TLBRverticalAlign TLBRtwoColumns isPaintPanel thumbsDisplaying drawingShapeNow
   ; msgbox, %currstateSimple%`n%prevStateSimple%
   If (prevState!=currState || dummy="forced")
   {
      TouchToolbarGUIcreated := 0
      CoreGUItoolbar()
      prevState := currState
   }

   interfaceThread.ahkassign("hQPVtoolbar", hQPVtoolbar)
   interfaceThread.ahkassign("ShowAdvToolbar", ShowAdvToolbar)
   interfaceThread.ahkassign("lockToolbar2Win", lockToolbar2Win)
   If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
   {
      If (AnyWindowOpen && imgEditPanelOpened!=1 || mustCaptureCloneBrush=1 || slideShowRunning=1)
      {
         thisOpacity := 100
         WinSet, ExStyle, +0x20, ahk_id %hQPVtoolbar%
      } Else
      {
         thisOpacity := ToolbarOpacity
         WinSet, ExStyle, -0x20, ahk_id %hQPVtoolbar%
      }

      Sleep, 1
      ; WinMove, ahk_id %hQPVtoolbar%,, 100, 100
      WinSet, Transparent, %thisOpacity%, ahk_id %hQPVtoolbar%
      Gui, OSDguiToolbar: Show, NoActivate x%UserToolbarX% y%UserToolbarY%, QPV toolbar
      whichWin := (AnyWindowOpen && panelWinCollapsed!=1) ? hSetWinGui : PVhwnd
      If (WinActive("A")=hQPVtoolbar)
         WinActivate, ahk_id %whichWin%
   } Else If (ShowAdvToolbar=0)
   {
      Gui, OSDguiToolbar: Hide
   }

   WinGetPos, , , ToolbarWinW, ToolbarWinH, ahk_id %hQPVtoolbar%
}

tlbrResetPosition() {
  JEE_ClientToScreen(hPicOnGui1, 1, 1, UserToolbarX, UserToolbarY)
  UserToolbarX--
  UserToolbarY--
  Gui, OSDguiToolbar: Show, NoActivate x%UserToolbarX% y%UserToolbarY%, QPV toolbar
  Return "m"
}

tlbrDecideTooltips(hwnd) {
   icoFile := tlbrIconzList[hwnd, 2]
   btnID := tlbrIconzList[hwnd, 10]
   f := (markedSelectFile>1) ? "s" : ""
   If InStr(icoFile, "dragger")
   {
      msgu := "L: Reposition toolbar`nR: Toolbar options menu"
   } Else If InStr(icoFile, "menu")
   {
      msgu :=  (thumbsDisplaying=1) ? "L: Quick actions menu [Shift + AppsKey]`nR: Interface options menu" : "L: Edit image menu`nR: Interface options menu"
      If (drawingShapeNow=1)
         msgu := "L: Vector shape options`nR: Viewport options"
   } Else If InStr(icoFile, "copy")
   {
      friendly := (editingSelectionNow=1) ? "selection area " : ""
      msgu := (thumbsDisplaying=1) ? "L: Copy file" f " to... [C]`nR: Copy file" f " path" f " [Ctrl + Shift + C]" : "L: Copy image " friendly "to clipboard [Ctrl + C]`nR: Copy file" f " path" f " [Ctrl + Shift + C]"
   } Else If InStr(icoFile, "help")
   {
      msgu := "About Quick Picto Viewer v" appVersion
   } Else If InStr(icoFile, "quick-file-acts")
   {
      msgu := "L: Quick file actions settings`nR: Jump to given index [J]"
   } Else If InStr(icoFile, "alpha-mask-discard")
   {
      msgu := StrLen(userAlphaMaskBmpPainted)>2 ? "Discard user painted alpha mask bitmap" : "Set alpha mask as undefined"
   } Else If InStr(icoFile, "alpha-mask-view")
   {
      msgu := "Preview alpha mask [M]"
   } Else If InStr(icoFile, "alpha-mask-panel")
   {
      msgu := "Define alpha mask panel [M]"
   } Else If InStr(icoFile, "alpha-mask-paint")
   {
      msgu := "Paint in the alpha mask [Ctrl + K]"
   } Else If InStr(icoFile, "alpha-mask-capture")
   {
      msgu := "Capture image selected area as alpha mask"
   } Else If InStr(icoFile, "alpha-mask-pixelize")
   {
      msgu := "Rasterize / pixelize the alpha mask"
   } Else If InStr(icoFile, "alpha-mask-invert")
   {
      msgu := "Invert alpha mask [N]"
   } Else If InStr(icoFile, "new-image")
   {
      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "L: Import list or insert file[s] into list [Insert]`nR: Add folder[s] into current list [Shift + Insert]"
      Else
         msgu :="L: Create new image [Ctrl + N]`nR: Acquire image from scanner"
   } Else If InStr(icoFile, "paste-clip")
   {
      msgu := (thumbsDisplaying=1) ? "Paste files from clipboard into current list [Ctrl + V]" : "L: Paste image from clipboard [Ctrl + V]`nR: Paste into selection area [Ctrl + Shift + V]"
   } Else If InStr(icoFile, "undo")
   {
      If (isImgEditingNow()=1)
      {
         If undoLevelsRecorded
            infosA := ": " currentUndoLevel "/" undoLevelsRecorded
         If (totalSelUndos := undoSelLevelsArray.Count()) && (editingSelectionNow=1)
            infosB := ": " currentSelUndoLevel " / " totalSelUndos " ]"
      }

      msgu := "Undo image" infosA " [Ctrl + Z]"
      infosV := currentVectorUndoLevel " / "  Round(undoVectorShapesLevelsArray.Count())
      If (drawingShapeNow=1 && editingSelectionNow=1)
         msgu := "Undo vector editing: " infosV " [Ctrl + Z]"
      Else If (editingSelectionNow=1)
         msgu := "L: " msgu "`nR: Undo selection area" infosB " [Ctrl + Shift + Z]"
   } Else If InStr(icoFile, "redo")
   {
      If (isImgEditingNow()=1)
      {
         If undoLevelsRecorded
            infosA := ": " currentUndoLevel "/" undoLevelsRecorded
         If (totalSelUndos := undoSelLevelsArray.Count()) && (editingSelectionNow=1)
            infosB := ": " currentSelUndoLevel " / " totalSelUndos " ]"
      }

      msgu := "Redo image" infosA " [Ctrl + Y]"
      infosV := currentVectorUndoLevel " / "  Round(undoVectorShapesLevelsArray.Count())
      If (drawingShapeNow=1 && editingSelectionNow=1)
         msgu := "Redo vector editing: " infosV " [Ctrl + Y]"
      Else If (editingSelectionNow=1)
         msgu := "L: " msgu "`nR: Redo selection area" infosB " [Ctrl + Shift + Y]"
   } Else If InStr(icoFile, "add-text")
   {
      msgu := (thumbsDisplaying=1) ? "Edit image caption [Shift + N]" : "L: Insert text into image [Shift + T]`nR: Edit image caption [Shift + N]"
   } Else If InStr(icoFile, "eraser")
   {
      keyu := (AnyWindowOpen=64) ? " [R]" : ""
      msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "L: Delete file" f " [Delete]`nR: Remove focused index entry [Alt + Delete]" : "L: Eraser - soft brush" keyu
      If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu .= "`nR: Erase or fade image selected area [Delete]"
      If (isImgEditingNow()=1 && editingSelectionNow=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Erase initially selected image area"
   } Else If InStr(icoFile, "brush-blur")
   {
      friendly := (AnyWindowOpen=64) ? "brush: " BrushToolBlurStrength "%" : "brush"
      msgu := "L: Blur - soft " friendly "`nR: Blur or pixelize selected area"
   } Else If InStr(icoFile, "brush-cloner")
   {
      keyu := (AnyWindowOpen=64) ? " [J]" : ""
      friendly := (AnyWindowOpen=64 && BrushToolType=3) ? "Toggle dynamic cloner source coordinates" : "Cloner - soft brush"
      msgu := "L: " friendly keyu "`nR: Define cloner source [S]"
   } Else If InStr(icoFile, "brush-main")
   {
      keyu := (AnyWindowOpen=64) ? " [B]" : " [P]"
      msgu := "L: Soft paint brush" keyu "`nR: Hard paint brush" keyu
   } Else If InStr(icoFile, "brush-fx")
   {
      keyu := (AnyWindowOpen=64) ? " [Q]" : ""
      msgu := "Color effects - soft brush" keyu
   } Else If InStr(icoFile, "brush-wet")
   {
      msgu := "Soft wet brush: " BrushToolWetness
   } Else If InStr(icoFile, "flood-fill")
   {
      msgu := "L: Flood fill / color bucket [K]"
   } Else If InStr(icoFile, "calculate")
   {
      msgu := "L: Calculate total size of selected files [Alt + L]`nR: Review panel for selected files [R]"
   } Else If (btnID="BTNinvertStuff")
   {
      msgu := (thumbsDisplaying=1) ? "Invert files selection [Shift + I]" : "Invert image [Shift + I]"
   } Else If (btnID="BTNvectSelInvert")
   {
      msgu := "Invert selected points [Shift + I]"
   } Else If (btnID="BTNvectRemPoints")
   {
      msgu := "Delete selected points [Delete]"
   } Else If (btnID="BTNvectRemLast")
   {
      msgu := "Remove last added point [Backspace]"
   } Else If (btnID="BTNvectSelAll")
   {
      msgu := "L: Select all points [Ctrl + A]`nR: Deselect all points [Ctrl + D]"
   } Else If (btnID="BTNvectSmooth")
   {
      msgu := "Cycle shape smoothness levels [T]"
   } Else If (btnID="BTNvectOpenPath")
   {
      msgu := "Toggle open/closed path [O]"
   } Else If InStr(icoFile, "pen-vector")
   {
      msgu := "L: Draw freeform filled shape [Shift + P]`nR: Draw freeform poly or curve line [Alt + P]"
   } Else If InStr(icoFile, "pipette")
   {
      keyu := (imgEditPanelOpened=1 && AnyWindowOpen) ? " [C]" : ""
      keyu2 := (imgEditPanelOpened=1 && AnyWindowOpen) ? " [X]" : ""
      msgu := "L: Pick color" keyu "`nR: Switch primary / secondary color" keyu2
   } Else If InStr(icoFile, "colorz-swatch")
   {
      keyu2 := (imgEditPanelOpened=1 && AnyWindowOpen) ? " [X]" : ""
      msgu := "L: Choose color`nR: Switch primary / secondary color" keyu2
   } Else If InStr(icoFile, "crop")
   {
      If (isImgEditingNow()=1 && editingSelectionNow=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Cycle through shapes to clip the image object"
      Else If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu := "L: Crop image to selection area [Shift + Enter]`nR: Resize image to selection area [Alt + R]"
      Else
         msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "Resize / crop / rotate image" f " [Ctrl + R]" : "Adjust image canvas size [Alt + A]"
   } Else If InStr(icoFile, "save-disk")
   {
      imgPath := getIDimage(currentFileIndex)
      If InStr(imgPath, "\temporary memory object\")
      {
         fileStatus := "`n `nImage bitmap UNSAVED to disk"
      } Else If isImgEditingNow()
      {
         oldTimes := lastZeitIMGsaved[1]
         FormatTime, timea, % oldTimes , HH:mm
         If oldTimes
            InfosPreviousSave := "`n `nLast time saved: " timea "`n" lastZeitIMGsaved[4] "`nUndo levels state: " lastZeitIMGsaved[2] "/" lastZeitIMGsaved[3]

         If !FileExist(imgPath)
            fileStatus := "`n `nImage bitmap UNSAVED to disk"
         Else If (currentImgModified=1)
            fileStatus := "`n `nThe image has been MODIFIED"
         Else If (currentImgModified=2)
            fileStatus := "`n `nThe image has just been SAVED"
      }
      If (currentFilesListModified=1 && maxFilesIndex>1 && thumbsDisplaying=1)
         fileStatus := "`n `nThe files list has been MODIFIED"

      msgu := (thumbsDisplaying=1) ? "Save files list [Ctrl + S]" fileStatus : "L: Save image to disk [Ctrl + S]`nR: Save files list [Ctrl + Shift + S]" fileStatus InfosPreviousSave
   } Else If InStr(icoFile, "open")
   {
      msgu := "L: Open image or folder dialog [Ctrl + O]`nR: Recents menu"
   } Else If InStr(icoFile, "cut")
   {
      msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "L: Cut file" f " (Explorer mode) [Ctrl + X]`nR: Move file" f " to.. [M]" : "Cut image selected area [Ctrl + X]"
   } Else If InStr(icoFile, "adjust-colors")
   {
      If (isImgEditingNow()=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Toggle color adjustments for the image object [U]"
      Else If (thumbsDisplaying=1)
         msgu := "L: Adjust viewport colors and more [U]`nR: Reset viewport adjustments [ \ ]"
      Else
         msgu := "L: Adjust image colors [U]`nAlt+L: Adjust viewport colors and more [Shift+U]`nR: Reset viewport adjustments [ \ ]"
   } Else If InStr(icoFile, "transform-img")
   {
      msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "Import selected image into currently opened one" : "Transform image selected area [Ctrl + T]"
      If (isImgEditingNow()=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Cycle through image object dimensions adapt modes"
   } Else If InStr(icoFile, "flip-h")
   {
      editing := isImgEditingNow()
      If (editing=1 && isNowAlphaPainting())
         msgu := "Alpha mask bitmap - flip horizontally [Shift + H]"
      Else If (editing=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Image object - flip horizontally [Shift + H]"
      Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "Image file - flip horizontally [Shift + H]"
      Else If (editing=1 && editingSelectionNow=1)
         msgu := "Image selected area - flip horizontally [Shift + H]"
      Else If (editing=1)
         msgu := "Viewport - flip horizontally [H]"
      Else
         msgu := "Flip horizontally"

      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu2 := "Viewport - flip horizontally [H]"
      Else If (editing=1 && EllipseSelectMode=2 && editingSelectionNow=1)
         msgu2 := "Freeform selection shape - flip horizontally"
      Else If (editing=1 && editingSelectionNow=1)
         msgu2 := "Viewport - flip horizontally [H]"

      If msgu2
         msgu := "L: " msgu "`nR: " msgu2

   } Else If InStr(icoFile, "flip-v")
   {
      editing := isImgEditingNow()
      If (editing=1 && isNowAlphaPainting())
         msgu := "Alpha mask bitmap - flip vertically [Shift + V]"
      Else If (editing=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Image object - flip vertically [Shift + V]"
      Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "Image file - flip vertically [Shift + V]"
      Else If (editing=1 && editingSelectionNow=1)
         msgu := "Image selected area - flip vertically [Shift + V]"
      Else If (editing=1)
         msgu := "Viewport - flip vertically [V]"
      Else
         msgu := "Flip vertically"

      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu2 := "Viewport - flip vertically [V]"
      Else If (editing=1 && EllipseSelectMode=2 && editingSelectionNow=1)
         msgu2 := "Freeform selection shape - flip vertically"
      Else If (editing=1 && editingSelectionNow=1)
         msgu2 := "Viewport - flip vertically [V]"

      If msgu2
         msgu := "L: " msgu "`nR: " msgu2 
      If (drawingShapeNow=1)
         msgu := "Cycle symmetry modes [Y]"
   } Else If InStr(icoFile, "rotation")
   {
      friendly := (editingSelectionNow=1) ? "L: Image selection area" : "L: Viewport"
      keyu := (editingSelectionNow=1) ? " [Shift + 9, 0]" : " [9, 0]"
      keyu2 := (editingSelectionNow=1) ? " [Shift + \]" : " [\]"
      msgu := friendly " - rotate by 15°" keyu "`nR: Reset rotation" keyu2
      msgu .= "`nHold Alt to change rotation by 1° "
      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "L: Rotate image file by +90° [Shift + 0]`nR: Rotate image file by -90° [Shift + 9]"
   } Else If InStr(icoFile, "fill-shape")
   {
      msgu := (AnyWindowOpen=23) ? "L: Cycle through fill shapes [Alt + BackSpace]" : "L: Fill selection area [Alt + Backspace]"
      msgu .= "`nR: Fill behind image"
   } Else If InStr(icoFile, "outline-shape")
   {
      msgu := (AnyWindowOpen=65) ? "Cycle through shape contours" : "L: Draw shape contours [Ctrl + L]`nR: Draw simple predefined selection area related lines"
   } Else If (btnID="BTNselectShape")
   {
      friendly := (editingSelectionNow=1) ? "Cycle selection area types [Shift + E]" : "Create image selection area [E]"
      If (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Toggle image object visibility [D]"
      Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu :=  "L: Select / deselect focused index entry [Tab]`nR: Files selection options menu"
      Else
         msgu := (editingSelectionNow=1 && isImgEditingNow()=1) ? "L: " friendly "`nR: Toggle image selection area [E]" : friendly
   } Else If InStr(icoFile, "create-freeform")
   {
      friendly := (editingSelectionNow!=1 || EllipseSelectMode!=2) ? "Create new" : "Modify"
      msgu := "L: " friendly " freeform selection area [Shift + L]`nR: Selection area shapes options menu"
   } Else If InStr(icoFile, "loupe")
   {
      friendly := (thumbsDisplaying=1) ? "Cycle thumbnails aspect ratios" : "Cycle adapt image to window modes"
      friendly2 := (thumbsDisplaying=1) ? "thumbnails" : "image"
      msgu := "L: Zoom in / out " friendly2 " [-, =]`nR: " friendly " [T]"
   } Else If InStr(icoFile, "pan-img")
   {
      msgu := "L: Pan image in viewport`nR: Toggle image navigator [Z]"
   } Else If (btnID="BTNcancelTool")
   {
      msgu := "Cancel / exit current tool [Escape]"
   } Else If (btnID="BTNmainTooler")
   {
      friendly := (thumbsDisplaying=1) ? "image view [Enter]" : defineListViewModes() " list mode [Enter]"
      winIDu := prevOpenedWindow[1]
      thisFunc := prevOpenedWindow[2]
      allowReopen := prevOpenedWindow[3]
      If (IsFunc(thisfunc) && thisFunc && allowReopen=1 && winIDu)
         keyu := ": " thisFunc "(" winIDU ")"

      moreFriendly := isNowAlphaPainting() ? "Exit Alpha Painting mode [Enter / Escape]" : "L: Apply current tool [Enter]`nR: Abandon current tool [Escape]"
      msgu := !AnyWindowOpen ? "L: Open previous panel" keyu " [F8]`nR: Switch to " friendly : moreFriendly
      If (isImgEditingNow()=1 && drawingShapeNow=1)
         msgu := "Apply changes to the vector shape and exit vector drawing mode [Enter]"
   } Else If InStr(icoFile, "brush-set-soft")
   {
      msgu := "Change brush softness: " BrushToolSoftness "% [Shift + [, Shift + ]]"
   } Else If InStr(icoFile, "brush-set-opacity")
   {
      thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      msgu := "Change brush opacity: " Round((thisOpacity / 255) * 100) "% [ 0 - 9 ]"
   } Else If InStr(icoFile, "brush-set-size")
   {
      friendly := (brushToolDoubleSize=1) ? "RADIUS" : "DIAMETER"
      friendly2 := (brushToolDoubleSize!=1) ? "RADIUS" : "DIAMETER"
      msgu := "L: Change brush " friendly ": " brushToolSize " px [ [, ] ] `nR: Switch to setting the " friendly2 " [Shift+S]"
   } Else If InStr(icoFile, "brush-set-angle")
   {
      If (BrushToolAutoAngle=1)
         msgu := "Deactivate mouse movements based angle for the brush"
      Else
         msgu := "L: Change brush angle: " BrushToolAngle "°`nR: Activate mouse movements based angle"
   } Else If InStr(icoFile, "brush-set-ratio")
   {
      msgu := "L: Change brush aspect ratio: " BrushToolAspectRatio "`nR: Reset brush aspect ratio"
   } Else If (btnID="BTNpaintSelection")
   {
      friendly := (BrushToolOutsideSelection=1) ? "ANYWHERE" : "INSIDE"
      If (BrushToolOutsideSelection=3)
         friendly := "OUTSIDE"
      msgu := "Paint " Friendly " image selection area`nCycle through options [Shift + K]"
   } Else If InStr(icoFile, "vp-grid")
   {
      b := (drawingShapeNow=1) ? "Toggle" : "Configure"
      msgu := "L: Adjust viewport grid [Alt + - / +]`nR: " b " viewport grid"
   } Else If (btnID="BTNthumbsList")
   {
      msgu := "Cycle through list view modes [L]"
      If (thumbsListViewMode=1)
         msgu := "L: " msgu "`nR: Toggle centered alignment for thumbnails [A]"
   } Else If InStr(icoFile, "view") 
   {
       msgu := "L: Toggle image preview [Z]`nR: Toggle preview area double-size"
       If (drawingShapeNow=1)
          msgu := "Toggle live preview for new points [P]"
   } Else If InStr(icoFile, "search") 
   {
      msgu := "L: Search indexed files [Ctrl + F3]`nR: Search and replace in the files list [Ctrl + H]"
   } Else If InStr(icoFile, "modify-entry") 
   {
      msgu := "L: Rename file" f " [F2]`nR: Modify focused index entry [Ctrl + F2]"
   } Else If InStr(icoFile, "filter") 
   {
      If StrLen(filesFilter)>2
         friendly := "`n `nThe files list is filtered"
      msgu := "L: Filter files list [Ctrl + F]`nR: Deactivate files list filter [Ctrl + Space]" friendly
   } Else If InStr(icoFile, "statistics") 
   {
      msgu := "L: Files list statistics`nR: Find image duplicates"
   } Else If InStr(icoFile, "sort-list") 
   {
      msgu := "Sort files list menu"
   } Else If InStr(icoFile, "refresh") 
   {
      friendly := (markedSelectFile>1) ? "Refresh selected thumbnails on scroll" : "Refresh all thumbnails on scroll"
      msgu := "L: Refresh the files list [F5]`nR: " friendly " [Alt + F5]"
   } Else If InStr(icoFile, "folder-tree") 
   {
      msgu := "L: Folders tree view panel [F4]`nR: Explore file location menu [Shift + F4]"
      If isWelcomeScreenu
         msgu := "Recently opened files"
   } Else If InStr(icoFile, "infos") 
   {
      msgu := "L: Image and viewport details [I]`nR: Files information panel [Alt + Enter]"
   } Else If InStr(icoFile, "star") 
   {
      friendly := resultedFilesList[currentFileIndex, 5] ? "Remove from" : "Add to"
      msgu := "L: " friendly " favourites [B]`nR: Favourites menu"
      If isWelcomeScreenu
         msgu := "Favourited images"
   } Else If InStr(icoFile, "manage-folders") 
   {
      If (RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1)
         friendly := "`nR: Update files list selectively [Ctrl + U]"
      msgu := "L: Manage folders list to be indexed [Alt + U]" friendly
   } Else If InStr(icoFile, "font-size") 
   {
      msgu := "Change viewport font size: " OSDfontSize " [Ctrl + -/=]"
   } Else If InStr(icoFile, "select-align") 
   {
      msgu := "Align selection menu"
   } Else If InStr(icoFile, "play") 
   {
      friendly := DefineSlideShowType()
      msgu := "L: Play " friendly " slideshow`nR: Slideshow duration settings [Shift + /]"
   } ; Else msgu := "N/A"

   Return msgu
}

ResetLbtn() {
  If GetKeyState("LButton", "P")
     SetTimer, ResetLbtn, -60
  Else
     LbtnDwn := 0
}

WM_MOUSEMOVE(wP, lP, msg, hwnd) {
  Critical, off
  Static lastInvoked := 1, prevCtrlHover, prevState, prevMsg
       , hCursBusy := DllCall("user32\LoadCursorW", "Ptr", NULL, "Int", 32514, "Ptr")  ; IDC_WAIT

   If (A_TickCount - scriptStartTime < 900)
      Return

   If ((whileLoopExec=1 || runningLongOperation=1 || imageLoading=1 || slideShowRunning=1) && mustCaptureCloneBrush!=1 && colorPickerModeNow!=1)
   {
      If (MsgBox2hwnd!=WinActive("A"))
         Try DllCall("user32\SetCursor", "Ptr", hCursBusy)
      Return
   }

   If (drawingShapeNow!=1)
   {
      hwnd := Format("{1:#x}", hwnd)
      WinGetClass, ctrlClassNN, ahk_id %hwnd%
         ; ToolTip, % hwnd "|`n" whichHwnd "`n=" ctrlClassNN "`n=" ctrlClassNE , , , 2
      If (InStr(ctrlClassNN, "static") && !InStr(A_GuiControl, "tlbrValueIcon"))
      || (InStr(ctrlClassNN, "syslistview") && InStr(A_GuiControl, "color"))
      {
         If getTabStopStyle(A_GuiControl) ; I do not know why it works with A_GuiControl ; it should work with the hwnd
            changeMcursor("finger")
      }
  }

  ; ToolTip, % ctrlClassNN "=" A_GuiControl "=" whichHwnd , , , 2
  If (ShowAdvToolbar!=1) || (AnyWindowOpen && imgEditPanelOpened!=1)
     Return

  ; x := (lP >> 16) & 0xffff      ; returns the HIWORD
  ; y := lP & 0xffff              ; returns the LOWORD

  Az := WinActive("A")
  MouseGetPos, OutputVarX, OutputVarY, OutputVarWin, OutputVarControl, 2
  okay := (Az=hQPVtoolbar || identifyThisWin() || Az=hSetWinGui) ? 1 : 0
  thisState := "a" OutputVarWin OutputVarControl OutputVarX OutputVarY
  If (okay=1 && thisState!=prevState && OutputVarWin=hQPVtoolbar) && (A_TickCount - zeitSillyPrevent>150)
  {
     If (wP&0x1)
     {
        LbtnDwn := 1
        SetTimer, ResetLbtn, -55
     }
     ctrlHover := OutputVarControl
     msgu := tlbrDecideTooltips(ctrlHover)
     If (!msgu && ShowToolTipsToolbar=1)
        interfaceThread.ahkFunction("mouseTurnOFFtooltip", 1)

     If ((A_TickCount - lastInvoked > 155) && msgu) ; && (thisPos!=prevPos)
     {
        If (thumbsDisplaying!=1 && LbtnDwn!=1)
           dummyRefreshImgSelectionWindow()
        ; isThisWin :=(OutputVarWin=PVhwnd) ? 1 : 0
        If (imageLoading!=1 && runningLongOperation!=1)
        {
           ; WinGetPos, aX, aY,,, ahk_id %ctrlHover%
           ; interfaceThread.ahkPostFunction("ShowClickHalo", aX, aY, ToolBarBtnWidth, ToolBarBtnWidth, 1, msgu)
           IndexBtn := tlbrIconzList[ctrlHover, 5] - 1
           thisHwnd := tlbrIconzList[indexBtn, 1]
           k := tlbrIconzList[ctrlHover, 11]
           ; ToolTip, % A_GuiControl "==" A_Gui "==" indexBtn "==" thisHwnd "`n" k , , , 2
           If (A_Gui="OSDguiToolbar" && thisHwnd && IndexBtn>0 && k!=msgu)
           {
              WinSet, Style,-0x0E, ahk_id %thisHwnd%
              ; DllCall("user32\SetWindowText", "Ptr", thisHwnd, "Str", msgu)
              ControlSetText , , % StrReplace(msgu, "`n", ".`n") ".", ahk_id %thisHwnd%
              tlbrIconzList[ctrlHover, 11] := msgu
              ; GuiControl, OSDguiToolbar:, tlbrValueIcon%IndexBtn%, % msgu
              WinSet, Style,+0x0E, ahk_id %thisHwnd%
           }
        }

        If (slideShowRunning!=1 && imageLoading!=1 && runningLongOperation!=1 && prevCtrlHover!=ctrlHover && prevMsg!=msgu)
        {
           prevCtrlHover := ctrlHover
           prevMsg := msgu
           prevState := thisState
           thisSize := OSDfontSize//3 + 2
           If (ShowToolTipsToolbar=1)
              interfaceThread.ahkFunction("mouseCreateOSDinfoLine", msgu, thisSize)
        }
        ; prevPos := mX "-" mY
        lastInvoked := A_TickCount
     }
        ; ToolTip, % lastInvoked "=" ctrlHover "`n" msgu , , , 2

     ; A := WinActive("A")
     ; okay := (A=PVhwnd || A=hGDIwin || A=hGDIthumbsWin) ? 1 : 0
  }
}

externTooltiput(msg) {
   Static lastMsg := 0
   msg := Trim(msg)
   If !msg
      Return

   thisSize := OSDfontSize//3 + 2
   If (msg="-hide-")
   {
      lastMsg := ""
      interfaceThread.ahkFunction("mouseTurnOFFtooltip", 1)
   } Else If (lastMsg=msg)
   {
      interfaceThread.ahkFunction("showOSDinfoLineNow", 500)
   } Else
   {
      lastMsg := msg
      interfaceThread.ahkFunction("mouseCreateOSDinfoLine", msg, thisSize, 1)
   }
}

TglToolBarValign() {
  TLBRverticalAlign := !TLBRverticalAlign
  If (TLBRtwoColumns=1)
     TLBRverticalAlign := 0

  TLBRtwoColumns := 0
  ShowAdvToolbar := 1
  IniAction(1, "TLBRverticalAlign", "General")
  IniAction(1, "TLBRtwoColumns", "General")
  IniAction(1, "ShowAdvToolbar", "General")
  createGUItoolbar()
}

TLBRapplyTwoColumns() {
  TLBRverticalAlign := 1
  TLBRtwoColumns := !TLBRtwoColumns
  ShowAdvToolbar := 1
  IniAction(1, "TLBRverticalAlign", "General")
  IniAction(1, "TLBRtwoColumns", "General")
  IniAction(1, "ShowAdvToolbar", "General")
  createGUItoolbar()
}

TLBRdraggyNow() {

   GetPhysicalCursorPos(oX, oY)
   WinGetPos, winX, winY,,, ahk_id %hQPVtoolbar%
   Dx := Dy := 0
   lastInvoked := A_TickCount
   ; ToolTip, % "l=" thisZL , , , 2
   setwhileLoopExec(1)
   While, (determineLClickstate()=1)
   {
      Global zeitSillyPrevent := A_TickCount
      GetPhysicalCursorPos(mX, mY)
      Dx := mX - oX
      Dy := mY - oY
      WinMove, ahk_id %hQPVtoolbar%, , % winX + Dx, % winY + Dy
      Sleep, -1
   }

   setwhileLoopExec(0)
   WinGetPos, winX, winY,,, ahk_id %hQPVtoolbar%
   UserToolbarY := winY
   UserToolbarX := winX

   If (isInRange(Dx, -2, 2) && isInRange(Dy, -2, 2) && (A_tickcount - lastInvoked<300))
   {
      invokeTlbrContextMenu("tlbr")
      Return "m"
   }
   ; createGUItoolbar("forced")
}

invokeKbdToolbarAct(direction) {
   If (isToolbarKBDnav!=1)
   {
       isToolbarKBDnav := 0
       WinActivate, ahk_id %PVhwnd%
       Return
   }

   hwndu := tlbrIconzList[currentKbdBTNtlbr, 1]
   If hwndu
   {
      tlbrInvokeFunction(hwndu, direction, "kbd")
   } Else
   {
      currentKbdBTNtlbr := 0
      moveMouseToolbar(1, 1)
      displayNowToolbarHelp(1)
   }
}

displayNowToolbarHelp(msgu) {
   calcScreenLimits()
   v := OSDfontSize//2
   If (msgu=1)
      msgu := "The toolbar can be navigated with the arrow keys.`nPress Enter to execute the main action.`nPress Shift + Enter for the secondary action."
   Else If (msgu=2)
      msgu := "The toolbar has keyboard focus. Press H for help."
   Else If (msgu=3)
      msgu := "The main window has keyboard focus now"

   interfaceThread.ahkFunction("mouseCreateOSDinfoLine", msgu, v)
}

moveMouseToolbar(direction, stepu) {
   If (isToolbarKBDnav!=1)
   {
       isToolbarKBDnav := 0
       WinActivate, ahk_id %PVhwnd%
       Return
   }

   If (direction=1)
      currentKbdBTNtlbr += stepu
   Else
      currentKbdBTNtlbr -= stepu

   Global zeitSillyPrevent := A_TickCount
   hwndu := tlbrIconzList[currentKbdBTNtlbr, 1]
   If !hwndu
      currentKbdBTNtlbr := (direction=1) ? 1 : 2

   hwndu := tlbrIconzList[currentKbdBTNtlbr, 1]
   funcu := tlbrIconzList[currentKbdBTNtlbr, 4]
   ; ToolTip, % currentKbdBTNtlbr "=" funcu , , , 2
   If (hwndu && funcu)
   {
      w := tlbrIconzList[hwndu, 7]
      h := tlbrIconzList[hwndu, 8]
      WinGetPos, aX, aY, Width, Height, ahk_id %hwndu%
      x := aX, y := aY
      If (x>ResolutionWidth - ToolBarBtnWidth*2)
         x := ResolutionWidth - ToolBarBtnWidth*2
      If (y>ResolutionHeight - ToolBarBtnWidth*2)
         y := ResolutionHeight - ToolBarBtnWidth*2
      MouseMove, % X + w - 4, % Y + h - 4, 1
   }

   msgu := tlbrDecideTooltips(hwndu)
   thisSize := OSDfontSize//3 + 2
   interfaceThread.ahkFunction("ShowClickHalo", aX, aY, ToolBarBtnWidth, ToolBarBtnWidth, 1)
   If msgu
      interfaceThread.ahkFunction("mouseCreateOSDinfoLine", msgu, thisSize)
}

; to do
; - keyboard shortcuts for opacity ; tools

testBaseNumConversions() {
      initQPVmainDLL()
 m1 := "1111111111111111111111111111111111111111111111111111111111111111"
 m2 := "0000000000000000000000000000000000000000000000000000000000000000"
 m3 := "0000000000000000000000000000000000000000000000000000000000000001"
 m4 := "0000000000000000000000000000001000000000000000000000000000000000"
 m5 := "1000000000000000000000000000000000000000000000000000000000000000"
 m6 := "1000000000000000000000000000000000000000000000000000000000000001"
 m7 := "1000000000000000000000000000000100000000000000000000000000000001"
 VarSetCapacity(HbigArray, 8 * 7 + 1)

 Loop, 7
 {
    m%A_Index% := ConvertBase(2, 16, m%A_Index%)
    hash := "0x" m%A_Index%
    NumPut(hash, HbigArray,  (A_Index - 1) * 8, "uint64")
    m%A_Index% := ConvertBase(16, 10, m%A_Index%)
    fnOutputDebug(A_Index " h=" m%A_Index% "|")
 }

 thisFunc := (A_PtrSize=8) ? "hammingDistanceOverArray" : "_hammingDistanceOverArray@32"
 totalResults := DllCall(whichMainDLL "\" thisFunc, "UPtr", &HbigArray)
 Loop, 7
 {
    y%A_Index% := ConvertBase(16, 2,m%A_Index%)
    fnOutputDebug(A_Index " h=" y%A_Index% "|")
 }
 Return
}

testPhashalgo() {
   initQPVmainDLL()
   VarSetCapacity(givenArray, 4 * 1024 + 1)
   ; VarSetCapacity(resultsArray, 4 * 64 + 1)

   arrayChars := StrSplit(pixelz)
   pixelsArray := []
   Loop, % arrayChars.Count() ; 1024 ; 32*32
      pixelsArray[A_Index - 1] := Ord(arrayChars[A_Index]) - 161

   hashu := calcPHashAlgo(pixelsArray, 32, 2)
   hashuB := calcDLLpHashAlgo(arrayChars, givenArray, 2)
   hashuC := ConvertBase(10, 2, hashuB)


   msgbox, % hashuB "`n" hashuC "`n" hashu 
}

testHistoDLL() {
   initQPVmainDLL()
   VarSetCapacity(resultsArray, 4*7, 0)
   Gdip_GetImageDimensions(useGdiBitmap(), w, h)
   thisFunc := (A_PtrSize=8) ? "getPBitmapistoInfos" : "_hammingDistanceOverArray@32"
   err := DllCall(whichMainDLL "\" thisFunc, "UPtr", useGdiBitmap(), "int", w, "int", h, "UPtr", &resultsArray)

   avgu := NumGet(resultsArray, 0 * 4, "uint")
   medianValue := NumGet(resultsArray, 1 * 4, "uint")
   peakPointK := NumGet(resultsArray, 2 * 4, "uint")
   minBrLvlK := NumGet(resultsArray, 3 * 4, "uint")
   rmsu := NumGet(resultsArray, 4 * 4, "uint")
   modePointK := NumGet(resultsArray, 5 * 4, "uint")
   minPointK := NumGet(resultsArray, 6 * 4, "uint")

   fnOutputDebug("avgu: " avgu)
   fnOutputDebug("medianValue: " medianValue)
   fnOutputDebug("peakPointK: " peakPointK)
   fnOutputDebug("minBrLvlK: " minBrLvlK)
   fnOutputDebug("rmsu: " rmsu)
   fnOutputDebug("modePointK: " modePointK)
   fnOutputDebug("minPointK: " minPointK)
   resultsArray := ""
}


#If, GetKeyState("CapsLock", "T")

   ; \::
   ; SoundBeep 
   ; SendInput, {RButton}
   ; Sleep, 50
   ; SendInput, v
   ; Sleep, 590
   ; SendInput, {LButton}
   ; Sleep, 125
   ; SendInput, ^{f4}
   ; Sleep, 50

   ; Return

   ; LButton::
   ; If GetKeyState("CapsLock", "T")
   ; {
   ; Sleep, 50
   ; SendInput, {LButton}
   ; Sleep, 300
   ; SendInput, ^{PgDn}
   ; SoundBeep , 900, 100
   ; }
   ; Return
   ; #If

   ; LButton::
   ;    If GetKeyState("CapsLock", "T")
   ;    {
   ;       SendInput, {LButton}
   ;       Sleep, 550
   ;       SendInput, ^{F4}
   ;    }
   ; Return

#If


ListGlobalVars() {
; found on https://www.autohotkey.com/boards/viewtopic.php?t=9610
; by Lexikos
    static hwndEdit, pSFW, pSW, bkpSFW, bkpSW
    
    if !hwndEdit
    {
        dhw := A_DetectHiddenWindows
        DetectHiddenWindows, On
        Process, Exist
        ControlGet, hwndEdit, Hwnd,, Edit1, ahk_class AutoHotkey ahk_pid %ErrorLevel%
        DetectHiddenWindows, %dhw%
        
        astr := A_IsUnicode ? "astr":"str"
        ptr := A_PtrSize=8 ? "ptr":"uint"
        hmod := DllCall("GetModuleHandle", "str", "user32.dll")
        pSFW := DllCall("GetProcAddress", ptr, hmod, astr, "SetForegroundWindow")
        pSW := DllCall("GetProcAddress", ptr, hmod, astr, "ShowWindow")
        DllCall("VirtualProtect", ptr, pSFW, ptr, 8, "uint", 0x40, "uint*", 0)
        DllCall("VirtualProtect", ptr, pSW, ptr, 8, "uint", 0x40, "uint*", 0)
        bkpSFW := NumGet(pSFW+0, 0, "int64")
        bkpSW := NumGet(pSW+0, 0, "int64")
    }

    if (A_PtrSize=8)
    {
        NumPut(0x0000C300000001B8, pSFW+0, 0, "int64")  ; return TRUE
        NumPut(0x0000C300000001B8, pSW+0, 0, "int64")   ; return TRUE
    } else
    {
        NumPut(0x0004C200000001B8, pSFW+0, 0, "int64")  ; return TRUE
        NumPut(0x0008C200000001B8, pSW+0, 0, "int64")   ; return TRUE
    }
    
    ListVars
    NumPut(bkpSFW, pSFW+0, 0, "int64")
    NumPut(bkpSW, pSW+0, 0, "int64")
    ControlGetText, text,, ahk_id %hwndEdit%
    RegExMatch(text, "sm)(?<=^Global Variables \(alphabetical\)`r`n-{5~1}`r`n).*", text)
    final := ""
    Loop, Parse, text, `n,`r
    {
       If StrLen(A_LoopField)>1
       {
          If (z := InStr(A_LoopField, "["))
             line := Trimmer(SubStr(A_LoopField, 1, z - 1))
          Else
             line := Trimmer(A_LoopField)

          If (z := InStr(line, "{"))
             line := SubStr(line, 1, z - 1)
          
          line := StrReplace(line, "object object", "object")
          If !InStr(line, "`n")
             final .= line "`n"
       }
    }
    ToolTip, % final , , , 2
    Sleep, 100
    SendInput, {Esc}
    return final
}


