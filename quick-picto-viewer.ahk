; Original script details:
;   Name:     AHK Picture Viewer
;   Version:  1.0.0 on Oct 4, 2010 by SBC
;   Platform: Windows XP or later
;   Author:   SBC - http://sites.google.com/site/littlescripting/
;   Found on: https://autohotkey.com/board/topic/58226-ahk-picture-viewer/
;
; New script details:
;   Name:     Quick Picto Viewer
;   Version:  [see change logs file]
;   Platform: Windows XP*, Windows 7 or later; Preferred is Windows 10.
;   Author:   Marius Șucan - http://marius.sucan.ro/
;   GitHub:   https://github.com/marius-sucan/Quick-Picto-Viewer
;
; *It can run on Windows XP, but various features might not work.
; You must provide all the following files found in Windows 10
; installations x32/x64 in the same folder with the QPV binary:
; api-ms-win-core-*-l1-1-0.dll [43 files]
; api-ms-win-crt-*-l1-1-0.dll [15 files]
; api-ms-win-core-file-l1-2-0.dll
; api-ms-win-core-file-l2-1-0.dll
; api-ms-win-core-localization-l1-2-0.dll
; api-ms-win-core-synch-l1-2-0.dll
; ucrtbase.dll
;
; The following DLLs are included in the Quick Picto Viewer package:
; FreeImage.dll
; msvcr100.dll
; sqlite3.dll
; vcomp140.dll
; vcruntime140.dll
;
; Script main functionalities:
; Display images and creates slideshows using GDI+ and FreeImage
; 85 supported image formats: jpeg, jpg, bmp, png, gif, tif, emf
; hdr, exr, webp, raw and many more...
;
; Original Licence: GPL. Please reffer to this page for more information. http://www.gnu.org/licenses/gpl.html
; Current licence: I do not know , I do not care. Licences are for obedient entities.
;
;@Ahk2Exe-AddResource LIB Lib\module-interface.ahk
;@Ahk2Exe-AddResource LIB Lib\module-fim-thumbs.ahk
;@Ahk2Exe-SetName Quick Picto Viewer
;@Ahk2Exe-SetDescription Quick Picto Viewer
;@Ahk2Exe-SetVersion 4.8.9
;@Ahk2Exe-SetCopyright Marius Şucan (2019-2020)
;@Ahk2Exe-SetCompanyName marius.sucan.ro
;@Ahk2Exe-SetMainIcon qpv-icon.ico
;
;___________ Auto Execute Section ____

#NoEnv
#NoTrayIcon
#MaxHotkeysPerInterval, 500
#MaxThreads, 255
#MaxThreadsPerHotkey, 1
#MaxThreadsBuffer, Off
#MaxMem, 9924
#IfTimeout, 35
#SingleInstance, off
#UseHook, Off
SetWorkingDir, %A_ScriptDir%
#Include Lib\Gdip_All.ahk           ; graphics display interface plus v1.1
#Include Lib\Gdi.ahk                ; graphics display interface
#Include Lib\SGdiPrint.ahk
; #Include Lib\guicontroltips.ahk
#Include Lib\freeimage-wrapper.ahk  ; used to load exotic file formats
#Include Lib\MCI.ahk                ; media controller interface [ used for audio annotations/files associated with images ]
#Include Lib\wia.ahk                ; windows image acquisition [ used for acquiring images from scanners ]
; #Include Lib\wic.ahk              ; windows image component ; I would like to finish this implementation one day...
#Include Lib\Class_SQLiteDB.ahk     ; use for slideshow databases and maintaining a list of viewed images [if activated]
#Include Lib\msgbox2.ahk
#Include Lib\hashtable.ahk
#Include Lib\file-get-prop-lib.ahk  ; used to get file properties on Alt+Enter [ File Information panel ]

SetWinDelay, 1
SetBatchLines, -1

Global PVhwnd := 1, hGDIwin := 1, hGDIthumbsWin := 1, pPen4 := "", pPen5 := "", pPen6 := "", unCompiledExePath := "", pBrushZ := ""
   , glPG := "", glOBM := "", glHbitmap := "", glHDC := "", pPen1 := "", pPen1d, pPen2 := "", pPen3 := "", AmbientalTexBrush := ""
   , pBrushHatch := "", pBrushWinBGR := "", pBrushA := "", pBrushB := "", pBrushC := "", pBrushD := "", currentPixFmt := ""
   , pBrushE := "", pBrushHatchLow, hGuiTip := 1, hSetWinGui := 1, undoSelLevelsArray := []
   , prevFullThumbsUpdate := 1, winGDIcreated := 0, ThumbsWinGDIcreated := 0, currentFilesListModified := 0
   , hPicOnGui1 := "", scriptStartTime := A_TickCount, lastEditRHChange :=1, doubleBlurPreviewArea := 0
   , newStaticFoldersListCache := [], lastEditRWChange := 1, QPVjournal := []
   , mainCompiledExe := "", mainCompiledPath := "", wasInitFIMlib := 0, hGDIselectWin, allowNextSlide := 1
   , filteredMap2mainList := [], thumbsCacheFolder := A_ScriptDir "\thumbs-cache"
   , resultedFilesList := [], currentFileIndex := "", maxFilesIndex := 0, gdiBitmapIDentire := 0
   , appTitle := "Quick Picto Viewer", FirstRun := 1, hSNDmediaFile := "", mouseToolTipWinCreated := 0
   , bckpResultedFilesList := [], bckpMaxFilesIndex := 0, DynamicFoldersList := ""
   , animGIFplaying := 0, startPageIndex := 0, RandyIMGids := [], IMGdecalageY := 1, IMGdecalageX := 1
   , RandyIMGnow := 0, GDIPToken := "", gdiBitmapSmall := "", hSNDmedia := "", imgIndexEditing := 0
   , AprevGdiBitmap := "", BprevGdiBitmap := "", msgDisplayTime := 3000, gdiBitmapIDcall := ""
   , slideShowRunning := 0, CurrentSLD := "", markedSelectFile := 0, IMGlargerViewPort := 0
   , ResolutionWidth := "", ResolutionHeight := "", prevStartIndex := 1, mustReloadThumbsList := 0
   , gdiBitmap := "", mainSettingsFile := "quick-picto-viewer.ini", mainRecentsFile := "quick-picto-viewer-recents.ini"
   , mustOpenStartFolder := "", mainFavesFile := "quick-picto-viewer-favourites.ini", miniFavesFile := "quick-picto-viewer-minifaves.ini"
   , RegExFilesPattern := "i)^(.\:\\).*(\.(ico|dib|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif))$"
   , RegExFIMformPtrn := "i)(.\\*\.(DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f))$"
   , saveTypesRegEX := "i)(.\.(bmp|j2k|j2c|jp2|jxr|wdp|hdp|png|tga|tif|tiff|webp|gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|xpm))$"
   , saveTypesFriendly := ".BMP, .GIF, .HDP, .J2K, .JFIF, .JIF, .JNG, .JP2, .JPE, .JPG, .JXR, .PNG, .PPM, .TGA, .TIF, ..WDP, .WEBP or .XPM"
   , saveAlphaTypesRegEX := "i)(.\.(j2k|j2c|jp2|jxr|wdp|hdp|png|tga|tif|tiff|webp))$"
   , openFptrn1 := "*.png;*.bmp;*.gif;*.jpg;*.tif;*.tga;*.webp;*.jpeg", prevLoadedImageIndex := 0
   , openFptrn2 := "*.dds;*.emf;*.exr;*.g3;*.hdp;*.iff;*.j2c;*.j2k;*.jbg;*.jif;*.jng;*.jp2;*.jxr;*.koa;*.lbm;*.mng;*.pbm;*.pcd;*.pct;*.pcx;*.pfm;*.pgm;*.pic;*.ppm;*.psd;*.ras;*.sgi;*.wap;*.wbm;*.wbmp;*.wdp;*.wmf;*.xbm;*.xpm"
   , openFptrn3 := "*.3fr;*.arw;*.bay;*.bmq;*.cap;*.cine;*.cr2;*.crw;*.cs1;*.dc2;*.dcr;*.drf;*.dsc;*.erf;*.fff;*.hdr;*.ia;*.iiq;*.k25;*.kc2;*.kdc;*.mdc;*.mef;*.mos;*.mrw;*.nef;*.nrw;*.orf;*.pef;*.ptx;*.pxn;*.qtk;*.raf;*.raw;*.rdc;*.rw2;*.rwz;*.sr2;*.srf;*.x3f"
   , openFptrn4 := "*.tiff;*.targa;*.jpe;*.dib;*.pict;*.rle", userJpegQuality := 90
   , saveImgFormatsList := {1:"bmp", 2:"gif", 3:"hdp", 4:"j2k", 5:"jfif", 6:"jng", 7:"jp2", 8:"jpg", 9:"jxr", 10:"png", 11:"ppm", 12:"tga", 13:"tif", 14:"wdp", 15:"webp", 16:"xpm"}
   , dialogSaveFptrn := "Portable Network Graphics (*.png)|WebP (*.webp)|Common JPEG (*.jpg;*.jpeg)|TrueVision Targa (*.tga)|Tagged Image File Format (*.tif;*.tiff)|Non-animated Compuserve GIF (*.gif)|Windows Bitmap (*.bmp)|HD Photo (*.hdp)|JPEG File Interchange Format (*.jfif)|JNG (*.jng)|JPEG 2000 (*.jp2;*.j2k)|JPEG-XR (*.jxr)|Portable PixelMap (*.ppm)|WDP (*.wdp)|XPM (*.xpm)"
   , dialogSaveIndexes := {1:"png", 2:"webp", 3:"jpg", 4:"tga", 5:"tif", 6:"gif", 7:"bmp", 8:"hdp", 9:"jfif", 10:"jng", 11:"jp2", 12:"jxr", 13:"ppm", 14:"wdp", 15:"xpm"}
   , LargeUIfontValue := 14, AnyWindowOpen := 0, toolTipGuiCreated := 0, panelWinCollapsed :=0 
   , PrefsLargeFonts := 0, OSDbgrColor := "131209", OSDtextColor := "FFFEFA", initialCustomShapeCoords := ""
   , PasteFntSize := 35, OSDfntSize := 25, OSDFontName := "Arial", prevOpenFolderPath := ""
   , mustGenerateStaticFolders := 1, lastWinDrag := 1, img2resizePath := "", colorPickerModeNow := 0
   , prevFileMovePath := "", lastGIFdestroy := 1, prevAnimGIFwas := "", prevFilesSortMode
   , thumbsW := 300, thumbsH := 300, thumbsDisplaying := 0, scrollAxis := 0, userSeenSessionImagesArray := new hashtable()
   , othumbsW := 300, othumbsH := 300, ForceRegenStaticFolders := 0, vPselRotation := 0
   , CountFilesFolderzList := 0, RecursiveStaticRescan := 0, imgSelLargerViewPort := 0
   , UsrMustInvertFilter := 0, userActionConflictingFile := 1, LastPrevFastDisplay := 0
   , prevFileSavePath := "", imgHUDbaseUnit := Round(OSDfntSize*2.5), lastLongOperationAbort := 1
   , lastOtherWinClose := 1, UsrCopyMoveOperation := 2, editingSelectionNow := 0, EntryMarkedMoveIndex := 0
   , ForceNoColorMatrix := 0, prevFastDisplay := 1, hSNDmediaDuration, lastMenuBarUpdated := 1
   , imgSelX1 := 0, imgSelY1 := 0, imgSelX2 := -1, imgSelY2 := -1, adjustNowSel := 0
   , prevImgSelX1 := 0, prevImgSelY1 := 0, prevImgSelX2 := -1, prevImgSelY2 := -1, prevSelDotX := "", prevSelDotY := "", prevSelDotAx := "", prevSelDotAy := ""
   , selDotX := "", selDotY := "", selDotAx := "", selDotAy := "", selDotBx := "", selDotBy := "", selDotCx := "", selDotCy := "", selDotDx := "", selDotDy := ""
   , prcSelX1 := 0, prcSelX2 := 0.5, prcSelY1 := 0, prcSelY2 := 0.5, PannedFastDisplay := 1, pBrushF := ""
   , SelDotsSize := imgHUDbaseUnit//4, ViewPortBMPcache := "", startZeitIMGload := 0, cachedAllSessionsSeen := new hashtable()
   , imageLoading := 0, PrevGuiSizeEvent := 0, imgSelOutViewPort := 0, prevGUIresize := 1, prevLastImg := []
   , imgEditPanelOpened := 0, jpegDoCrop := 0, jpegDesiredOperation := 1, copyMoveDoLastOption := 0
   , rDesireWriteFMT := "jpg", FIMfailed2init := 0, prevMaxSelX := "", prevMaxSelY := "", prevDestPosX := "", prevDestPosY := ""
   , hCursBusy := DllCall("user32\LoadCursorW", "Ptr", NULL, "Int", 32514, "Ptr")  ; IDC_WAIT
   , CCLVO := "-E0x200 +Border -Hdr -Multi +ReadOnly Report AltSubmit gSetUIcolors", FontList := []
   , totalFramesIndex := "", pVwinTitle := "", AprevImgCall := "", BprevImgCall := "", prevSetWinPosX := "", prevSetWinPosY := ""
   , coreIMGzeitLoad := 0, desiredFrameIndex := 0, prevDrawingMode := 0, sqlFailedInit := 0, currentImgModified := 0
   , currIMGdetails := [], AbackupIMGdetails := [], BbackupIMGdetails := [], mainLoadedIMGdetails := []
   , diffIMGdecX := 0, diffIMGdecY := 0, prevGDIvpCache := "", oldZoomLevel := 0, fullPath2exe := "", hasMemThumbsCached := 0
   , hitTestSelectionPath := "", scrollBarHy := 0, scrollBarVx := 0, HistogramBMP := "", internalColorDepth := 0
   , drawModeBzeit := 1, drawModeAzeit := 1, drawModeCzeit := 1, prevColorAdjustZeit := 1, AutoCropBordersSize := 15
   , GDIfadeVPcache := "", executingCanceableOperation := 1, hCropCornersPic, UserMemBMP := "", userSearchString := ""
   , systemCores := 1, realSystemCores := 1, hasInitSpecialMode := 0, CountGIFframes := 0, prevSlideShowStop := 1
   , prevTryThumbsUpdate := 1, thumbsSizeQuality := 245, prevFullIndexThumbsUpdate := -1, userClipBMPpaste
   , UserNewWidth := 0, UserNewHeight := 0, UserNewDPI := 0, viewportStampBMP := "", tinyPrevAreaCoordY := 1
   , ThumbsStatusBarH := 0, activeSQLdb := "", SLDtypeLoaded := 0, sldsPattern := "i)(.\.(sld|sldb))$"
   , imgThumbsCacheIDsArray := [], imgThumbsCacheArray := [], viewportIDstampBMP := 0, qpvMainDll, sqlDBrowID := 1
   , prevVPselRotation, prevrotateSelBoundsKeepRatio, prevEllipseSelectMode, currentSelUndoLevel := 1
   , seenImagesDB := "", mustRecordSeenImgs := 0, hEditField := "", gdiBMPvPsize := "", maxGDIbmpSize := 533654021
   , GDIcacheSRCfileA := "", idGDIcacheSRCfileA := "", GDIcacheSRCfileB := "", idGDIcacheSRCfileB := "", prevOpenedWindow := []
   , startLongOperation := 1, thisIMGisDownScaled := 0, simpleOpRotationAngle := 1, UserTextArea := ""
   , runningLongOperation := 0, hasReachedMaxUndoLevels := 0, GIFframesPlayied := 0, allImagesWereSeen := 0
   , 2NDglHbitmap := "", 2NDglHDC := "", 2NDglOBM := "", 2NDglPG := "", mainThreadHwnd := "", imgDecLX := "", imgDecLY := ""
   , undoLevelsArray := [], currentUndoLevel := 0, maxUndoLevels := 50, undoLevelsRecorded := 0, hGDIinfosWin := ""
   , zeitSillyPrevent := 1, PrintPosX, PrintPosY, PrintPosW, PrintPosH, tinyPrevAreaCoordX := 1, UsrEditFileDestination := ""
   , hLVmainu := 0, tempBtnVisible := "null", tempBtnGuiBtnArray := [], lastRenameUndo := [], userMultiCoresLimit := 100
   , drawingShapeNow := 0, customShapePoints := [], prevResizedVPimgW := "", prevResizedVPimgH := "", PenuDrawLive := ""
   , initialDrawingStartCoords := [], drawingLiveMode := 0, cardinalCurveCustomShape := 0, openingPanelNow := 0
   , closedLineCustomShape := 1, tensionCurveCustomShape := 0.5, userDefinedSelCoords := 0, thisSearchString := ""
   , SelectionCoordsType := 1, PasteInPlaceAlphaFile := "", infoBoxGdiCached := "", watchFolderDetails := ""
   , FilteruMinRange, FilteruMaxRange, userFilterSizeProperty := 1, qpvCanvasHasInit := 0, coreDesiredPixFmt := "0xE200B"
   , FilteruDateMinRange, FilteruDateMaxRange, InternalFilterString, userFilterProperty := 1, userFindDupePresets := 1
   , HUDobjNavBoxu := [], HUDobjHistoBoxu := [], globalhFIFimg := 0, userAddedFavesCount := 0, bckpCurrentFileIndex := 0
   , maxFavesEntries := 98765, gdipLastError := 0, hasDrawnImageMap := 0, hasDrawnHistoMap := 0, lastZeitFileSelect := 1
   , isWinXP := (A_OSVersion="WIN_XP" || A_OSVersion="WIN_2003" || A_OSVersion="WIN_2000") ? 1 : 0, mustSnapLiveDrawPoints := 0
   , QPVpid := GetCurrentProcessId(), preventUndoLevels := 0, maxMemUndoLevels := 979394, delayiedHUDmsg := ""
   , delayiedHUDperc := 0, delayedfunc2exec := 0, lastOSDtooltipInvoked := 1, lastTimeToggleThumbs := 1
   , CurrentPanelTab := 0, debugModa := !A_IsCompiled, createdGDIobjsArray := [], countGDIobjects := 0, uiPasteInPlaceAlphaFile
   , oldCustomShape := [], preventDeleteMatchingSearch := 0, protectedFolderPath := "", preventDeleteFromProtectedPath := 0
   , TVlistFolders, hfdTreeWinGui, folderTreeWinOpen := 0, VPstampBMPx := 0, VPstampBMPy := 0
   , QPVregEntry := "HKEY_CURRENT_USER\SOFTWARE\Quick Picto Viewer"
   , appVersion := "4.8.9", vReleaseDate := "11/02/2021"

 ; User settings
   , askDeleteFiles := 1, enableThumbsCaching := 1, OnConvertKeepOriginals := 1
   , thumbsAratio := 3, thumbsZoomLevel := 1, zatAdjust := 0, lummyAdjust := 0
   , specialColorFXmode := 1, uiColorCurveFXmode := 2, uiColorCurveFXchannel := 4
   , WindowBgrColor := "010101", slideShowDelay := 3000, userMultiDelChoice := 2
   , IMGresizingMode := 1, SlideHowMode := 1, TouchScreenMode := 1, screenSaverMode := 0
   , lumosAdjust := 1, GammosAdjust := 0, userimgQuality := 0, userCustomImgSelRatio := 0
   , imgFxMode := 1, FlipImgH := 0, FlipImgV := 0, satAdjust := 1
   , imageAligned := 5, filesFilter := "", isAlwaysOnTop := 0, IntensityAlphaChannel := 1
   , noTooltipMSGs := 0, zoomLevel := 1, skipDeadFiles := 0, userHQraw  := 0
   , isTitleBarHidden := 1, lumosGrayAdjust := 0, GammosGrayAdjust := 0
   , MustLoadSLDprefs := 0, animGIFsSupport := 1, move2recycler := 1, deleteFileActAfter := 1
   , SLDcacheFilesList := 1, autoRemDeadEntry := 1, ResizeWithCrop := 1, ResizeMustPerform := 1
   , easySlideStoppage := 1, ResizeInPercentage := 0, usrAdaptiveThreshold := 1
   , ResizeKeepAratio := 1, ResizeQualityHigh := 1, ResizeRotationUser := "Rotate: 0°"
   , ResizeApplyEffects := 1, autoAdjustMode := 1, doSatAdjusts := 1, SimpleOperationsScaleXImgFactor := "100 %"
   , ResizeDestFolder, ResizeUseDestDir := 0, chnRdecalage := 0.0, chnGdecalage := 0.0
   , chnBdecalage := 0.0, alwaysOpenwithFIM := 0, bwDithering := 0, showHistogram := 0
   , userUnsprtWriteFMT := 1, userDesireWriteFMT := 9, hueAdjust := 0, syncSlideShow2Audios := 0
   , DisplayTimeUser := 3, FontBolded := 1, FontItalica := 0, showInfoBoxHUD := 0, usrAutoCropGenerateSelection := 0
   , usrTextureBGR := 0, realGammos := 1, imgThreshold := 0, relativeImgSelCoords := 1, usrAutoCropDeviation := 0
   , vpIMGrotation := 0, usrTextAlign := "Left", autoPlaySNDs := 0, usrAutoCropDeviationSnap := 1
   , ResizeCropAfterRotation := 1, usrColorDepth := 1, ColorDepthDithering := 1, mediaSNDvolume := 80
   , borderAroundImage := 0, performAutoCropNow := 0, usrAutoCropColorTolerance := 5, usrAutoCropImgThreshold := 0.005 
   , SimpleOperationsDoCrop := 0, SimpleOperationsRotateAngle := 1, SimpleOperationsScaleYImgFactor := "100 %"
   , SimpleOperationsNoPromptOnSave := 0, SimpleOperationsFlipV := 0, SimpleOperationsFlipH := 0, doSlidesTransitions := 0
   , usrAutoCropDeviationPixels := 0, multilineStatusBar := 0, AutoCropAdaptiveMode := 1, allowGIFsPlayEntirely := 0
   , allowMultiCoreMode := 1, AutoDownScaleIMGs := 0, minimizeMemUsage := 0, GIFspeedDelay := 35
   , maxMemThumbsCache := 300, resetImageViewOnChange := 0, FillAreaRemBGR := 0, blurAreaPixelizeMethod := 1
   , FillAreaDoContour := 0, FillAreaContourThickness := 20, EraseAreaFader := 0, EraseAreaOpacity := 190
   , FillAreaOpacity := 250, FillAreaColor := OSDbgrColor, FillAreaShape := 1, FillAreaInverted := 0
   , FillAreaRoundedCaps := 1, FillAreaDoubleLine := 0, blurAreaOpacity := 250, blurAreaAmount := 10
   , PasteInPlaceAlignment := 3, PasteInPlaceOpacity := 128, PasteInPlaceAdaptMode := 1, PasteInPlaceQuality := 1
   , PasteInPlaceOrientation := 1, showImgAnnotations := 0, blurAreaSoftEdges := 1, blurAreaInverted := 0
   , PasteInPlaceBlurAmount := 0, PasteInPlaceCropSel := 1, PasteInPlaceCropAngular := 0

Global PasteInPlaceGamma := 0, PasteInPlaceSaturation := 0, PasteInPlaceHue := 0, PasteInPlaceLight := 0
   , EllipseSelectMode := 0, thumbsListViewMode := 1, FillAreaContourAlign := 2, FillAreaDashStyle := 1
   , adjustCanvasCentered := 1, adjustCanvasMode := 1, adjustCanvasNoBgr := 1, LimitSelectBoundsImg := 1
   , DrawLineAreaColor := "ff3366", DrawLineAreaDashStyle := 1, DrawLineAreaContourAlign := 1, DrawLineAreaKeepBounds := 1
   , DrawLineAreaContourThickness := 20, DrawLineAreaOpacity := 255, DrawLineAreaBorderTop := 1, DrawLineAreaBorderBottom := 0
   , DrawLineAreaBorderLeft := 1, DrawLineAreaBorderRight := 0, DrawLineAreaBorderCenter := 1, DrawLineAreaBorderArcA := 0
   , DrawLineAreaBorderArcC := 0, DrawLineAreaBorderArcD := 1, DrawLineAreaCapsStyle := 1, DrawLineAreaDoubles := 0
   , PasteInPlaceEraseInitial := 1, PasteInPlaceLivePreview := 1, DrawLineAreaBorderArcB := 0, EraseAreaInvert := 0
   , PasteInPlaceToolMode := 0, NewDocUseColor := 1, PredefinedDocsSizes := 1, NewImageReverseDimensions := 0, FillAreaGlassy := 1
   , FillAreaColorMode := 1, FillAreaColorReversed := 0, FillArea2ndColor := "FF2211", FillArea2ndOpacity := 200, FillAreaGradientAngle := 0
   , FillAreaGradientSigma := 5, FillAreaGradientBlend := 100, FillAreaGradientScale := 100, FillAreaGradientWrapped := 1
   , thumbnailsListMode := 0, TextInAreaFontName := "Arial", TextInAreaFontSize := 15, TextInAreaBorderSize := 5
   , TextInAreaFontBold := 0, TextInAreaFontItalic := 0, TextInAreaFontUline := 0, TextInAreaAlign := 1, TextInAreaBgrUnified := 0
   , TextInAreaFontColor := "eeFFaa", TextInAreaFontOpacity := 250, TextInAreaRoundBoxBgr := 1, TextInAreaValign := 1
   , TextInAreaBgrColor := "229933", TextInAreaBgrOpacity := 100, TextInAreaOnlyBorder := 0, TextInAreaBlurAmount := 0
   , TextInAreaBorderOut := 1, TextInAreaBorderColor := "334400", TextInAreaBorderOpacity := "200", TextInAreaCharSpacing := 0
   , TextInAreaUsrMarginz := 0, TextInAreaBlurBorderAmount := 0, TextInAreaDoBlurs := 0, TextInAreaLineAngle := 0
   , TextInAreaFontLineSpacing := 0, TextInAreaCutOutMode := 0, TextInAreaBgrEntire := 0, TextInAreaFontStrike := 0
   , TextInAreaLivePreview := 1, showMainMenuBar := 1, markSearchMatches := 1, showSelectionGrid := 0, blurAreaTwice := 0
   , allowRecordHistory := 1, FillAreaLivePreview := 1, TextInAreaPaintBgr := 1, rotateSelBoundsKeepRatio := 1
   , highlightAlreadySeenImages := 1, useCachedSLDdata := 1, PreserveDateTimeOnSave := 0, PrintAdaptToFit := 1
   , PrintDimensionsXYWH := "0|0|50|50", PrintColorMode := 1, PrintOrientation := 0, PrintUseViewportColors := 1
   , userAllowWindowDrag := 0, FillAreaClosedPath := 1, FillAreaCustomShape := "", PasteInPlaceAlphaMaskMode := 1
   , PasteInPlaceAlphaMaskClrA := 0, PasteInPlaceAlphaMaskClrB := 255, closeEditPanelOnApply := 1, FillAreaCurveTension := 2
   , alphaMaskOffsetX := 0, alphaMaskOffsetY := 0, alphaMaskReplaceMode := 0, PasteInPlaceAlphaChannelFile := 5
   , blurAreaMode := 1, FillAreaBlendMode := 1, PasteInPlaceApplyColorFX := 0, blurAreaPixelizeAmount := 0
   , dynamicThumbsColumns := 0, thumbsColumns := 8, TextInAreaAutoWrap := 1, histogramMode := 2, cmrRAWtoneMapParamB := 0
   , showHUDnavIMG := 0, HUDnavBoxSize := 75, PrintTxtSize := 300, cmrRAWtoneMapAlgo := 1, cmrRAWtoneMapParamA := 1.85
   , mainWinPos := 0, mainWinMaximized := 2, mainWinSize := 0, UserExternalApp := "", UserExternalEditApp := ""
   , lockSelectionAspectRatio := 1, desiredSelAspectRatio := 0, adjustingSelDotNow := 0, cycleFavesOpenIMG := 0
   , slidesFXrandomize := 0, IDedgesCenterAmount := 1, IDedgesXuAmount := 2, IDedgesYuAmount := 1, IDedgesInvert := 0
   , IDedgesEmphasis := 0, IDedgesContrast := 0, IDedgesBlendMode := 0, IDedgesOpacity := 255, IDedgesAfterBlur := 1
   , IDedgesEmbossLvl := 1, UserAddNoiseIntensity := 35, UserAddNoiseMode := 0, reverseOrderOnSort := 0
   , userSearchWhat := 1, OnSortdoFilesCheck := 0, QuickFileActFolder1 := "", QuickFileActFolder2 := ""
   , QuickFileActFolder3 := "", QuickFileActFolder4 := "", QuickFileActFolder5 := "", QuickFileActAfter1 := 1
   , QuickFileActAfter2 := 1, QuickFileActAfter3 := 1, QuickFileActAfter4 := 1, QuickFileActAfter5 := 1
   , QuickFileActAfter6 := 1, QuickFileActFolder6 := "", userFilterWhat := 1, userFilterStringPos := 1
   , userFilterStringIsNot := 0, userFilterDoString := 1, UsrEditFilter, QuickFileActConflict := 4
   , preventDBentryRemoval := 0, findDupesPrecision := 5, hashInnerTrimLeft := 0, hashInnerTrimRight := 0
   , hashOuterTrimLeft := 0, hashOuterTrimRight := 0, hashSimpleTrimLeft := 0, hashSimpleTrimRight := 0
   , UIcheckinnerpixelz := 0, UIcheckouterpixelz := 0, UIcheckpixelzHash := 0, DesatureAreaAmount := 100
   , DesatureAreaHue := 0, DesatureAreaAlternate := 0, skipSeenImageSlides := 0, blurAreaSoftLevel := 2
   , BlurAreaBlendMode := 1, PasteInPlaceBlurEdgesSoft := 0

EnvGet, realSystemCores, NUMBER_OF_PROCESSORS
addJournalEntry("Application started: PID " QPVpid ".`nCPU cores identified: " realSystemCores ".")

If (realSystemCores>100)
   realSystemCores := 100

RegRead, InitCheckReg, %QPVregEntry%, Running
RegRead, InitTimeReg, %QPVregEntry%, LastStartTime
If (Abs(A_TickCount - InitTimeReg)<600 && IsNumber(InitTimeReg) && InitCheckReg=1 && InitTimeReg>1)
{
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}

If !A_IsCompiled
   Try Menu, Tray, Icon, qpv-icon.ico

DetectHiddenWindows, On
CoordMode, Mouse, Screen
CoordMode, ToolTip, Screen
OnExit, doCleanup

initCompiled(A_IsCompiled)
thisGDIPversion := Gdip_LibrarySubVersion()
GDIPToken := Gdip_Startup()
If (!GDIPToken || thisGDIPversion<1.85)
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+...`n`nThe program will now exit.`n`nRequired GDI+ library wrapper: v1.84 - extended compilation edition.
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}

; RegRead, initArgu, %QPVregEntry%, initArgu
If (InitCheckReg=2)
{
   initExternalCoreMode()
   Return
}

RegWrite, REG_SZ, %QPVregEntry%, Running, 1
RegWrite, REG_SZ, %QPVregEntry%, LastStartTime, % A_TickCount
IniRead, FirstRun, % mainSettingsFile, General, FirstRun, @
If (FirstRun!=0)
{
   writeMainSettings()
   FirstRun := 0
   IniWrite, % FirstRun, % mainSettingsFile, General, FirstRun
} Else loadMainSettings(0)

Loop, 9
    OnMessage(255+A_Index, "PreventKeyPressBeep")   ; 0x100 to 0x108

Global interfaceThread
If !A_IsCompiled
   interfaceThread := ahkthread("#Include *i Lib\module-interface.ahk")
Else If (sz := GetRes(data, 0, "MODULE-INTERFACE.AHK", "LIB"))
   interfaceThread := ahkThread(StrGet(&data, sz, "utf-8"))

; the interface is a separate thread to allow users 
; enjoy a more responsive user interface when the main thread
; is busy processing
externObj := WindowBgrColor "$" isAlwaysOnTop "$" mainCompiledPath "$" isTitleBarHidden "$" TouchScreenMode "$" userAllowWindowDrag "$" mainWinPos "$" mainWinSize "$" mainWinMaximized "$" IMGresizingMode
externObj .= "$" OSDbgrColor "$" OSDtextColor "$" LargeUIfontValue "$" PrefsLargeFonts "$" OSDFontName "$" FontBolded
initGUI := interfaceThread.ahkFunction("BuildGUI", externObj)
fnOutputDebug("extern UI HWNDs: " initGUI)
If !InStr(initGUI, "|")
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize the interface. The application will now exit...
   hasInitSpecialMode := 1
   ForceExitNow()
   Return
} Else
{
   handleUIhwnd(initGui)
   externObj := ""
}

createGDIPcanvas()
InitGDIpStuff()

Global multiCoreThumbsInitGood := "n",thumbThread1,thumbThread2,thumbThread3,thumbThread4,thumbThread5,thumbThread6,thumbThread7,thumbThread8,thumbThread9,thumbThread10,thumbThread11
,thumbThread12,thumbThread13,thumbThread14,thumbThread15,thumbThread16,thumbThread17,thumbThread18,thumbThread19,thumbThread20,thumbThread21
,thumbThread22,thumbThread23,thumbThread24,thumbThread25,thumbThread26,thumbThread27,thumbThread28,thumbThread29,thumbThread30,thumbThread31
,thumbThread32,thumbThread33,thumbThread34,thumbThread35,thumbThread36,thumbThread37,thumbThread38,thumbThread39,thumbThread40,thumbThread41
,thumbThread42,thumbThread43,thumbThread44,thumbThread45,thumbThread46,thumbThread47,thumbThread48,thumbThread49,thumbThread50,thumbThread51
,thumbThread52,thumbThread53,thumbThread54,thumbThread55,thumbThread56,thumbThread57,thumbThread58,thumbThread59,thumbThread60,thumbThread61
,thumbThread62,thumbThread63,thumbThread64,thumbThread65,thumbThread66,thumbThread67,thumbThread68,thumbThread69,thumbThread70,thumbThread71
,thumbThread72,thumbThread73,thumbThread74,thumbThread75,thumbThread76,thumbThread77,thumbThread78,thumbThread79,thumbThread80,thumbThread81
,thumbThread82,thumbThread83,thumbThread84,thumbThread85,thumbThread86,thumbThread87,thumbThread88,thumbThread89,thumbThread90,thumbThread91
,thumbThread92,thumbThread93,thumbThread94,thumbThread95,thumbThread96,thumbThread97,thumbThread98,thumbThread99,thumbThread100,

If (A_PtrSize=4)
{
   allowMultiCoreMode := 0
   minimizeMemUsage := 1
   maxUndoLevels := 2
   coreDesiredPixFmt := "0x21808"
}

; OnMessage(0x205, "WM_RBUTTONUP")
TriggerMenuBarUpdate()
addJournalEntry("Finished initialization of " appTitle " v" appVersion ".")
If (qpvCanvasHasInit=1)
   doWelcomeNow := intializeWithGivenArguments()

; MsgBox, % A_TickCount - scriptStartTime
If (doWelcomeNow=1 && qpvCanvasHasInit=1)
   SetTimer, drawWelcomeImg, -25

Return

;_____________________________________ Hotkeys _________________

identifyThisWin() {
  Static prevR, lastInvoked := 1
  If (A_TickCount - lastInvoked < 150)
     Return prevR

  prevR := WinActive("ahk_class AutoHotkeyGUI ahk_group QPVwindows") ? 1 : 0
  lastInvoked := A_TickCount
  Return prevR
}

HKifs(q:=0) {
   whichBitmap := useGdiBitmap() ? 1 : 0
   If (q="imgEditSolo")
      r := (!AnyWindowOpen && openingPanelNow!=1 && currentFileIndex=0 && !CurrentSLD && thumbsDisplaying!=1 && whichBitmap=1) ? 1 : 0
   Else If (q="imgsLoaded")
      r := (!AnyWindowOpen && openingPanelNow!=1 && CurrentSLD && maxFilesIndex>0) ? 1 : 0
   Else If (q="liveEdit")
      r := (AnyWindowOpen && openingPanelNow!=1 && imgEditPanelOpened=1 && whichBitmap=1) ? 1 : 0
   Else If (q="general")
      r := (!AnyWindowOpen && imgEditPanelOpened!=1) ? 1 : 0

   If (drawingShapeNow=1)
      r := 0

   Return r
}

#If (identifyThisWin()=1)
    ^vk4F::    ; Ctrl+O
       If HKifs("general")
          OpenDialogFiles()
    Return

    vk4F::    ; O
       imgPath := getIDimage(currentFileIndex)
       If HKifs("imgsLoaded")
          OpenThisFileMenu()
       Else If ((HKifs("general") && (!CurrentSLD || StrLen(gdiBitmap)<3)) && !FileRexists(imgPath))
          OpenDialogFiles()
    Return

    w::   ; to-do  to do
       ;  testMemCrash()
     ; a := "0x" ConvertBase(2, 16, "0100110110010110010010010010110010100010001000011111110101110101")
     ; b := "0x" ConvertBase(2, 16, "0101110110010110010010010010110010100010001000011011110101110111")
   ; x:= HammingDistanceNew2020dec(a, b)
   ; x:= HammingDistanceNew2020dec("0x4D96492CA221FD75","0x6D96493CA221BD75")
   ; ToolTip, % a "`n" b "`n" d "`n" g "`n" z "`n" x , , , 2
     ; crapBIGcrap()
     ; reorderStoredHash("010110000010101011111001111101010111", "1001011011111111010010010101")
    ; autoSelectDupesInGroups(1)
    ; If !activeSQLdb.Exec("ALTER TABLE images ADD entireHush TEXT;")
       ; TEMPgenerateHush()
    ; ToolTip, % extractSQLqueryFromFilter() , , , 2
       ; collectFileInfosNow()
            ; SoundBeep 
    ; testWICwhatever()
   ; ; testWICresizeSpeed()
   ;     testArkive()
   Sleep, 1
    Return

    ^+vk4E::    ; Ctrl+Shift+N
       If HKifs("general")
          OpenNewQPVinstance()
    Return

    ^vk4E::    ; Ctrl+N
       If HKifs("general")
          PanelNewImage()
    Return

    +vkC0::    ; Shift+[~]
       If AnyWindowOpen
          Return

       PanelJournalWindow()
    Return

    F12::
       If HKifs("general")
          openPrefsPanelWindow()
    Return

    vk50::    ; P
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          MenuStartDrawingLines("draw")
    Return

    +vk50::    ; Shift+P
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          MenuStartDrawingShapes("draw")
    Return

    ^vk50::    ; Ctrl+P
       If (!AnyWindowOpen && imageLoading!=1 && (HKifs("imgEditSolo") || HKifs("imgsLoaded")))
          PanelPrintImage()
    Return

    ^NumpadAdd::
    ^vkBB::    ; [=]
       changeOSDfontSize(1)
    Return

    ^NumpadSub::
    ^vkBD::   ; [-]
       changeOSDfontSize(-1)
    Return

    +vk4F::    ; Shift+O
       If HKifs("general")
          OpenFolders()
    Return

    ~F10::
    ~+F10::
    ~!F10::
       If (drawingShapeNow!=1)
          ToggleQuickBaru()
    Return

    ^AppsKey::
    +AppsKey::
    #AppsKey::
    !AppsKey::
    AppsKey::
       Suspend, Permit
       InitGuiContextMenu(A_ThisHotkey)
    Return

    ~RButton::
    ~^RButton::
    ~+RButton::
       Suspend, Permit
       InitGuiContextMenu(A_ThisHotkey)
    Return

    ~Insert Up::
       If (HKifs("general") && imageLoading!=1)
          addNewFile2list()
    Return

    ^vk56 Up::   ; Ctrl+V
       If (HKifs("general") && imageLoading!=1)
          PasteClipboardIMG()
    Return

    +Esc::
       restartAppu()
    Return

    F1::
       AboutWindow()
    Return

    ~F9 Up::
      If (HKifs("imgsLoaded") && folderTreeWinOpen=1)
         FolderTreeFindActiveFile()
    Return

    ^F4::
       If (drawingShapeNow=1)
       {
          stopDrawingShape()
          Return
       } Else If AnyWindowOpen
       {
          CloseWindow()
          Return
       } Else If (thumbsDisplaying=1)
       {
          MenuReturnIMGedit()
          Return
       }

       closeDocuments()
    Return

    !F4::
    Esc::
       escRoutine()
    Return

    ~vk44 Up::   ; D
      If (HKifs("liveEdit") && AnyWindowOpen!=10)
         hideLivePreviewObject()
    Return

    vk4C::     ; L
      If ((HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && editingSelectionNow=1 && thumbsDisplaying!=1)
         toggleLimitSelection()
      Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         toggleListViewModeThumbs()
    Return

    +^vk56 Up::   ; Ctrl+Shift+V
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelPasteInPlace()
    Return

    ~^vk44 Up::   ; Ctrl+D
      If (HKifs("imgsLoaded") && ((thumbsDisplaying=1) || (editingSelectionNow!=1 && markedSelectFile)))
         dropFilesSelection()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         resetImgSelection()
    Return

    ~^vk43 Up::    ; Ctrl+C
      If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
         MenuExplorerCopyFiles()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         CopyImage2clip()
    Return

    ~^vk58 Up::    ; Ctrl+X
      If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
         MenuExplorerCutFiles()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         CutSelectedArea()
    Return

    ^vk5A::    ; Ctrl+Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgUndoAction()
    Return

    vk5A::    ; Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgNavBox()
    Return

    ^vk59::    ; Ctrl+Y
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgRedoAction()
    Return

    ^+vk5A::    ; Ctrl+Shift+Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgSelUndoAct()
    Return

    ^+vk59::    ; Ctrl+Shift+Y
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgSelRedoAct()
    Return

    ^!vk5A::    ; Ctrl+Alt+Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgUndoAction("j")
    Return

    ^!vk59::    ; Ctrl+Alt+Y
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgRedoAction("j")
    Return

    vk45::   ; E
      If (HKifs("liveEdit") && AnyWindowOpen!=10)
         livePreviewsImageEditing(1, 1)
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         ToggleEditImgSelection()
         If (editingSelectionNow=1)
            CreateGuiButton("Selection options,,invokeSelectionAreaMenu", 0, msgDisplayTime//1.5 + 500)
      }
    Return

    +vk45::   ; Shift+E
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && currentFileIndex>0 && maxFilesIndex>2)
      {
         activateFilesListFilterBasedOnFolder(currentFileIndex)
      } Else
      {
         imgLiveEdit := (HKifs("liveEdit") && (AnyWindowOpen=25 || AnyWindowOpen=10 || AnyWindowOpen=55)) ? 1 : 0
         If (HKifs("imgEditSolo") || imgLiveEdit=1 || HKifs("imgsLoaded"))
            toggleEllipseSelection()
      }
    Return

    !vk45::   ; Alt+E
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelIMGselProperties()
    Return

    ~^vk53 Up::   ; Ctrl+S
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelSaveImg()
    Return

    ^vk4C::     ; Ctrl+L
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelDrawLines()
    Return

    +vk4C::     ; Shift+L
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded")) && (thumbsDisplaying!=1)
      {
         If (editingSelectionNow!=1 || EllipseSelectMode!=2)
            MenuStartDrawingSelectionArea()
         Else
            MenuResumeDrawingShapes()
      }
    Return

    !vk4C Up::     ; Alt+L
      If HKifs("imgsLoaded")
         CalculateSelectedFilesSizes()
    Return

    !BackSpace::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelFillSelectedArea()
    Return

    !vk59::   ; Alt+Y
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelImgAutoCrop()
    Return

    ~vk49::   ; I
      If HKifs("liveEdit")
         flipSelectionWH()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         ToggleInfoBoxu()
    Return

    vkDB::   ; [
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeLumos(-1)
    Return

    vkDD::   ; ]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeLumos(1)
    Return

    +vkDB::   ; Shift+[
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeGammos(-1)
    Return

    +vkDD::   ; Shift+]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeGammos(1)
    Return

    ^vkDB::   ; Ctrl+[
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeSaturation(-1)
    Return

    ^vkDD::   ; Ctrl+]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeSaturation(1)
    Return

    !vkDB::   ; Alt+[
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeRealGamma(-1)
    Return

    !vkDD::   ; Alt+]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeRealGamma(1)
    Return

    vkDC Up::   ; \
      If (HKifs("liveEdit") && AnyWindowOpen=10)
         MenuToggleColorAdjustments()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ResetImageView()
    Return

    ^vkDC Up::   ; Ctrl+\
      If (HKifs("liveEdit") && AnyWindowOpen=10)
         btnResetImageView()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         HardResetImageView()
    Return

    +vkDC Up::   ; Shift+\
      If HKifs("liveEdit")
      {
         resetSelectionRotation()
      } Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         If (editingSelectionNow=1 && vPselRotation>0)
            resetSelectionRotation()
         Else
            toggleColorAdjustments()
      }
    Return

    vkBF Up::   ; /
    NumpadDiv Up::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         IMGresizingMode := 0
         ToggleImageSizingMode()
      }
    Return

    NumpadMult Up::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         ; IMGresizingMode := 3
         IMGdecalageX := IMGdecalageY := zoomLevel := 1
         ToggleImageSizingMode("custom")
      }
    Return

    +NumpadAdd::
    +vkBB::    ; [=]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         changeSelectZoom(1)
    Return

    +NumpadSub::
    +vkBD::   ; [-]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         changeSelectZoom(-1)
    Return

    NumpadAdd::
    vkBB::    ; [=]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeZoom(1)
    Return

    NumpadSub::
    vkBD::   ; [-]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeZoom(-1)
    Return

    vk47::    ; G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgHistogram(1)
    Return

    +vk47::    ; Shift+G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgHistogram(-1)
    Return

    !vk47::    ; Alt+G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleHistogramMode()
    Return

    ~^vk52 Up::     ; Ctrl+R
      If HKifs("imgsLoaded")
         PanelSimpleResizeRotate()
    Return

    ~!vk52 Up::     ; Alt+R
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         ResizeIMGviewportSelection()
    Return

    vk52::     ; R
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         makeSquareSelection()
    Return

    +vk52::     ; Shift+R

      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         MenuSelRotation()
    Return

    ^vk54 Up::     ; Ctrl+T
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelTransformSelectedArea()
    Return

    +vk54 Up::     ; Shift+T
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelInsertTextArea()
    Return

    +vk49 Up::     ; Shift+I
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile>1)
         invertFilesSelection()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         InvertSelectedArea()
    Return

    ^vk47 Up::     ; Ctrl+G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelDesatureSelectedArea()
    Return

    +vk42 Up::     ; Shift+B
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelBlurSelectedArea()
    Return

    vk42 Up::     ; B
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         ToggleImgFavourites(0, 0, 1)
    Return

    ~^vk48::    ; Ctrl+H
      If (HKifs("imgsLoaded") && maxFilesIndex>1)
         PanelSearchAndReplaceIndex()
    Return

    ~vk48::    ; H
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         VPflipImgH()
    Return

    ~vk56::    ; V
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         VPflipImgV()
    Return

    ~+vk48::    ; Shift+H
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         filesListFlipHimage()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         FlipSelectedAreaH()
    Return

    ~+vk56::    ; Shift+V
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         filesListFlipVimage()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         FlipSelectedAreaV()
    Return

    ~vk55 Up::  ;  U
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelColorsAdjusterWindow()
    Return

    ~+vk55 Up::    ; Shift+U
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         filesListApplyColors()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ApplyColorAdjustsSelectedArea()
    Return

    ~^+vk55 Up::    ; Ctrl+Shift+U
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ApplyColorAdjustsSelectedArea("outside")
    Return

    vk46::     ; F
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgFX(-1)
    Return

    +vk46::     ; Shift+F
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgFX(1)
    Return

    +vk51::  ;  Shift+Q
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgColorDepth(1)
    Return

    vk51::  ;   Q
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgColorDepth(-1)
    Return

    ~Delete Up::
      If ((HKifs("imgEditSolo") || HKifs("liveEdit")) && thumbsDisplaying!=1 && editingSelectionNow=1)
         PanelEraseSelectedArea()
      Else If HKifs("imgsLoaded")
         deleteKeyAction()
    Return

    ~!Delete Up::
      If (HKifs("imgsLoaded") && maxFilesIndex>1 && currentFileIndex>0)
         singleInListEntriesRemover()
    Return

    ~+Delete Up::
      If HKifs("imgsLoaded")
      {
         DeleteActivePicture()
         Sleep, 350
         If (maxFilesIndex>1 && currentFileIndex>0)
            singleInListEntriesRemover()
      }
    Return

    vk41::     ; A
      If HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || (AnyWindowOpen>1)
         ToggleIMGalign()
    Return

    +vk41::     ; Shift+A
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         toggleImgSelectionAspectRatio()
    Return

    !vk41::     ; Alt+A
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelAdjustImageCanvasSize()
    Return

    ^vk41::     ; Ctrl+A
      If HKifs("liveEdit")
         selectEntireImage()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
            selectAllFiles()
         Else
            selectEntireImage()
      }
    Return

    vk39::    ; 9
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
      {
         filesListFlipRotateMinus()
      } Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         If (editingSelectionNow=1)
            changeSelRotation(-1)
         Else
            changeImgRotationInVP(-1)
      }
    Return

    vk30::    ; 0
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
      {
         filesListFlipRotatePlus()
      } Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         If (editingSelectionNow=1)
            changeSelRotation(1)
         Else
            changeImgRotationInVP(1)
      }
    Return

    Up::
    +Up::
      If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("U")
      Else If HKifs("imgsLoaded")
         ThumbsNavigator("Upu", A_ThisHotkey)
    Return

    Down::
    +Down::
      If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("D")
      Else If HKifs("imgsLoaded")
         ThumbsNavigator("Down", A_ThisHotkey)
    Return

    ^WheelUp::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeZoom(1, "WheelUp")
    Return

    ^WheelDown::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeZoom(-1, "WheelDown")
    Return

    !Left::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(-1, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-1, 1)
    Return

    !Right::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(1, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(1, 1)
    Return

    !Up::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(-2, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-2, 1)
    Return

    !Down::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(2, 1)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(2, 1)
    Return

    !+Left::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(-1, 2)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-1, 2)
    Return

    !+Right::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(1, 2)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(1, 2)
    Return

    !+Up::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(-2, 2)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-2, 2)
    Return

    !+Down::
      If (drawingShapeNow=1)
         arrowKeysAdjustPrevPointPath(2, 2)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(2, 2)
    Return

    F8::
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         openPreviousPanel()
    Return

    Space::
      If (HKifs("imgsLoaded") && drawingShapeNow!=1)
      {
         If ((thumbsDisplaying=1 || markedSelectFile) && slideShowRunning!=1)
            markThisFileNow()
         ; Else If (imageLoading!=1 && IMGlargerViewPort=1 && IMGresizingMode=4 && slideShowRunning!=1)
         ;    changeMcursor("move")
         Else If (slideShowRunning=1)
            dummyInfoToggleSlideShowu("stop")
         Else If (A_TickCount - lastOtherWinClose>350) && (A_TickCount - prevSlideShowStop>950) ; && (drawingShapeNow!=1)
            InfoToggleSlideShowu()
      } Else if (!CurrentSLD && !maxFilesIndex)
         toggleScreenSaverMode()
    Return 

    ^vk57::    ; Ctrl+W
      If HKifs("imgsLoaded")
         setImageWallpaper()
    Return

    +vk4E::    ; Shift+N
      If HKifs("imgsLoaded")
         PanelEditImgCaption()
    Return

    vk4E::    ; N
      If (HKifs("imgsLoaded") && thumbsDisplaying!=1)
         ToggleImgCaptions()
    Return

    ^vk31::   ; Ctrl+1
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortName, -150
    Return

    ^vk32::   ; Ctrl+2
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortPath, -150
    Return

    ^vk33::   ; Ctrl+3
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortFileName, -150
    Return

    ^vk34::   ; Ctrl+4
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortSize, -150
    Return

    ^vk35::   ; Ctrl+5
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortModified, -150
    Return

    ^vk36::   ; Ctrl+6
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ActSortCreated, -150
    Return

    ^vk37::   ; Ctrl+7
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, PanelResolutionSorting, -50
    Return

    ^vk38::   ; Ctrl+8
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, PanelHistogramSorting, -50
    Return

    ^vk30::   ; Ctrl+0
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         SetTimer, ReverseListNow, -150
    Return

    ~vk4A Up::    ; J
      If HKifs("imgsLoaded")
         PanelJump2index()
    Return

    ~+Insert Up::
      If HKifs("imgsLoaded")
         addNewFolder2list()
    Return

    ~Tab Up::
      If HKifs("liveEdit")
         toggleImgEditPanelWindow()
      Else If HKifs("imgsLoaded")
         markThisFileNow()
    Return

    ~+Tab Up::
      If HKifs("imgsLoaded")
         dropFilesSelection()
    Return

    ~^Tab Up::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile>1)
         filterToFilesSelection()
    Return

    ~F11::
      If !AnyWindowOpen
         ToggleFullScreenMode()
    Return

    +Enter::
      If HKifs("liveEdit")
         applyIMGeditKeepWin()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         CropImageInViewPortToSelection()
    Return

    ^Enter::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         OpenWithNewQPVinstance()
      Else If HKifs("imgsLoaded")
         SoloNewQPVinstance()
    Return

    Enter::
      If (drawingShapeNow=1)
         stopDrawingShape()
      Else If HKifs("liveEdit")
         applyIMGeditFunction()
      Else If (HKifs("imgsLoaded") && (A_TickCount - lastOtherWinClose>250))
         ToggleThumbsMode()
    Return

    !Enter::
      If HKifs("imgsLoaded")
         PanelImageInfos()
    Return

    ~vk43 Up::    ; C
      If HKifs("imgsLoaded")
         InvokeCopyFiles()
    Return

    ~^vk55 Up::    ; Ctrl+U
      If (HKifs("imgsLoaded") && RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
         PanelStaticFolderzManager()
    Return

    ~!vk55 Up::    ; Alt+U
      If HKifs("imgsLoaded")
         PanelDynamicFolderzWindow()
    Return

    ~^vk4B Up::    ; Ctrl+K
      If HKifs("imgsLoaded")
         PanelFileFormatConverter()
    Return

    ~vk4B Up::    ; K
      If HKifs("imgsLoaded")
      {
         If RegExMatch(getIDimage(currentFileIndex), "i)(.\.(jpg|jpeg))$") || markedSelectFile
            PanelJpegPerformOperation()
      }
    Return

    ~+vk43 Up::     ; Shift+C
      If HKifs("imgsLoaded")
         CopyImagePath()
    Return

    ~^vk45 Up::   ; Ctrl+E
      If (HKifs("imgsLoaded") || HKifs("imgLiveEdit"))
         OpenThisFileFolder()
    Return

    ~^vk46 Up::   ; Ctrl+F
      If HKifs("imgsLoaded")
         PanelEnableFilesFilter()
    Return

    ~vk53::   ; S
      If HKifs("imgsLoaded")
      {
         If (mustRecordSeenImgs=1 && thumbsDisplaying=1)
            ToggleSeenIMGstatus()
         Else
            SwitchSlideModes()
      }
    Return

    ~+^vk53 Up::   ; Ctrl+Shift+S
      If HKifs("imgsLoaded")
         PanelSaveSlideShowu()
    Return

    vk54 Up::   ; T
      If (drawingShapeNow=1)
      {
         togglePathCurveTension()
      } Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            ChangeThumbsAratio()
         Else
            ToggleImageSizingMode()
      }
    Return

    ~+Space::
      If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            dropFilesSelection()
         Else If (slideShowRunning=1)
            dummyInfoToggleSlideShowu("stop")
         Else If (A_TickCount - prevSlideShowStop>950)
            dummyInfoToggleSlideShowu()
      }
    Return

    ~^Space Up::
      If HKifs("imgsLoaded")
      {
         If (slideShowRunning=1)
            dummyInfoToggleSlideShowu("stop")
         Else If StrLen(filesFilter)>1
            MenuRemFilesListFilter()
      }
    Return

    ~BackSpace::
      If (drawingShapeNow=1)
         reduceCustomShapelength()
      Else If HKifs("imgsLoaded")
         PrevRandyPicture()
    Return

    ~+BackSpace::
      If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         RandomPicture()
      }
    Return

    ^BackSpace::
      If HKifs("imgsLoaded")
         jumpPreviousImage()
    Return

    vkBE::    ; [,]
      If HKifs("imgsLoaded")
         IncreaseSlideSpeed()
    Return

    vkBC::   ; [.]
      If HKifs("imgsLoaded")
         DecreaseSlideSpeed()
    Return

    +vkBF Up::   ; Shift+/
      If HKifs("imgsLoaded")
         PanelDefineEntireSlideshowLength()
    Return

    ~F5 Up::
      If HKifs("imgsLoaded")
         RefreshImageFileAction()
    Return

    ~!F5 Up::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         DeepRefreshThumbsNow()
    Return

    ~+F5 Up::
      If HKifs("imgsLoaded")
         RefreshFilesList()
    Return

    ~^F5 Up::
      If HKifs("imgsLoaded")
         invertCurrentFolderRecursiveness()
    Return

    ~F2 Up::
      If HKifs("imgsLoaded")
         PanelRenameThisFile()
    Return

    ~+F2 Up::
      If HKifs("imgsLoaded")
         SingularRenameFile()
    Return

    ~^F2 Up::
      If HKifs("imgsLoaded")
         PanelUpdateThisFileIndex()
    Return

    ~vk4D Up::     ; M
      If HKifs("imgsLoaded")
         PanelMoveCopyFiles()
    Return

    ^vk51::  ;  Ctrl+Q-
      If HKifs("imgsLoaded")
         ToggleImgDownScaling()
    Return

    vk58 Up::   ; X
      If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0)
            moveMarkedEntryNow(currentFileIndex)
         Else
            PlayAudioFileAssociatedNow()
      }
    Return

    +vk58 Up::   ; Shift+X
      If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0)
            moveMarkedEntryNow(currentFileIndex, "move")
         Else
            StopMediaPlaying()
      }
    Return

    vk31::
    vk32::
    vk33::
    vk34::
    vk35::
    vk36::
    vk37::
    +vk31::
    +vk32::
    +vk33::
    +vk34::
    +vk35::
    +vk36::
    +vk37::
      If HKifs("imgsLoaded")
         triggerQuickFileAction(A_ThisHotkey)
    Return

    vk38::   ; 8
      If HKifs("imgsLoaded")
         ChangeVolume(-1)
    Return

    +vk38::   ; Shift+8
      If HKifs("imgsLoaded")
         ChangeVolume(1)
    Return

    ^Left::
      If HKifs("imgsLoaded")
         navSelectedFiles(-1)
    Return

    ^Right::
      If HKifs("imgsLoaded")
         navSelectedFiles(1)
    Return

    F3::
      If HKifs("imgsLoaded")
         searchNextIndex(1)
    Return

    +F3::
      If HKifs("imgsLoaded")
         searchNextIndex(-1)
    Return

    ^F3::
      If HKifs("imgsLoaded")
         PanelSearchIndex()
    Return
    
    F4::
      ; If HKifs("imgsLoaded")
         PanelFoldersTree()
    Return

    +F4::
      If HKifs("imgsLoaded")
         invokeFoldersListerMenu()
    Return

    WheelUp::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         ThumbsNavigator("Upu", A_ThisHotkey)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (IMGresizingMode=4 && thumbsDisplaying!=1)
         ChangeZoom(1, "WheelUp")
      Else If (HKifs("imgsLoaded"))
         PreviousPicture("key-" A_ThisHotkey)
    Return

    WheelDown::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         ThumbsNavigator("Down", A_ThisHotkey)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (IMGresizingMode=4 && thumbsDisplaying!=1)
         ChangeZoom(-1, "WheelDown")
      Else If (HKifs("imgsLoaded"))
         NextPicture("key-" A_ThisHotkey)
    Return

    Right::
    +Right::
      If HKifs("imgsLoaded")
      {
         If (IMGlargerViewPort=1 && IMGresizingMode=4)
         {
            PanIMGonScreen("R")
         } Else
         {
            resetSlideshowTimer(0)
            If (thumbsDisplaying=1)
               ThumbsNavigator("Right", A_ThisHotkey)
            Else
               NextPicture("key-" A_ThisHotkey)
         }
      } Else If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("R")
    Return

    Left::
    +Left::
      If HKifs("imgsLoaded")
      {
         If (IMGlargerViewPort=1 && IMGresizingMode=4)
         {
            PanIMGonScreen("L")
         } Else
         {
            resetSlideshowTimer(0)
            If (thumbsDisplaying=1)
               ThumbsNavigator("Left", A_ThisHotkey)
            Else
               PreviousPicture("key-" A_ThisHotkey)
         }
      } Else If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("L")
    Return

    PgDn::
      If (drawingShapeNow=1)
      {
         adjustCustomShapePositionLive(-1)
      } Else If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(-1, 1)
         arrowKeysAdjustSelectionArea(-1, 2)
      } Else If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgDn", A_ThisHotkey)
         Else
            NextPicture()
      }
    Return

    PgUp::
      If (drawingShapeNow=1)
      {
         adjustCustomShapePositionLive(1)
      } Else If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(1, 1)
         arrowKeysAdjustSelectionArea(1, 2)
      } Else If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgUp", A_ThisHotkey)
         Else
            PreviousPicture()
      }
    Return

    +PgDn::
      If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgDn", A_ThisHotkey)
         Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
            changeDesiredFrame(-1)
      }
    Return

    +PgUp::
      If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgUp", A_ThisHotkey)
         Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
            changeDesiredFrame(1)
      }
    Return

    ^PgUp::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
         FileExploreUpDownLevel(-1)
    Return

    ^PgDn::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
         FileExploreUpDownLevel(1)
    Return

    !PgUp::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
         FileExploreSiblingsNav(-1)
    Return

    !PgDn::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
         FileExploreSiblingsNav(1)
    Return

    ~^Home Up::
      If HKifs("imgsLoaded")
         jumpToFilesSelBorder(-1)
    Return

    ~^End Up::
      If HKifs("imgsLoaded")
         jumpToFilesSelBorder(1)
    Return

    ~Home::
    ~+Home::
      If (drawingShapeNow=1)
      {
         adjustCustomShapePositionLive(2)
      } Else If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(-2, 1)
         arrowKeysAdjustSelectionArea(-2, 2)
      } Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            ThumbsNavigator("Home", A_ThisHotkey)
         Else
            FirstPicture()
      }
    Return

    ~End::
    ~+End::
      If (drawingShapeNow=1)
      {
         adjustCustomShapePositionLive(-2)
      } Else If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(2, 1)
         arrowKeysAdjustSelectionArea(2, 2)
      } Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            ThumbsNavigator("End", A_ThisHotkey)
         Else
            LastPicture()
      }
    Return
#If

;____________ Functions __________________

initQPVmainDLL() {
   If qpvMainDll
      Return

   DllPath := FreeImage_FoxGetDllPath("qpvmain.dll")
   ; If (A_PtrSize=8)
   ;    DllPath := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\qpv-main\x64\Release\qpvmain.dll"
   ; Else
   ;    DllPath := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\qpv-main\Release\qpvmain.dll"
   qpvMainDll := DllCall("LoadLibraryW", "WStr", DllPath, "UPtr")
}

intializeWithGivenArguments() {
   thisCounter := folderOpened := sldOpened := doWelcomeNow := 0
   disCount := A_Args.Count()
   Loop, % disCount
   {
      If (A_Index>=950)
      {
         doWelcomeNow := 1
         Break
      } Else If (RegExMatch(A_Args[A_Index], sldsPattern) && RegExMatch(A_Args[A_Index], "i)^(.\:\\..*)") && !sldOpened)
      {
         If FileExist(A_Args[A_Index])
            sldOpened := A_Args[A_Index]
      } Else If (RegExMatch(A_Args[A_Index], "i)^(fd\=\|?.\:\\..*)") && !folderOpened)
      {
         paramSet := SubStr(A_Args[A_Index], 4)
         If FolderExist(StrReplace(paramSet, "|"))
            folderOpened := paramSet
      } Else If (RegExMatch(A_Args[A_Index], RegExFilesPattern) && !folderOpened && !sldOpened)
      {
         filesListu .= A_Args[A_Index] "`n"
         thisCounter++
      } Else If RegExMatch(A_Args[A_Index], "i)^(.?qpv-debug)")
      {
         debugModa := 1
      } Else If RegExMatch(A_Args[A_Index], "i)^(set\_..*\=..*)")
      {
         paramSet := SubStr(A_Args[A_Index], 5, InStr(A_Args[A_Index], "=") - 5)
         paramSetValue := SubStr(A_Args[A_Index], InStr(A_Args[A_Index], "=") + 1)
         If (paramSet && paramSetValue!="")
            %paramSet% := paramSetValue
      } Else If RegExMatch(A_Args[A_Index], "i)^(call\_..*\(\))")
      {
         func2exec := SubStr(A_Args[A_Index], 6, InStr(A_Args[A_Index], "(") - 6)
         If (IsFunc(func2exec)=1 && StrLen(func2exec)>2)
            delayedfunc2exec := func2exec
      }
   }
   ; ToolTip, % "l=" disCount , , , 2
   If sldOpened
   {
      OpenSLD(sldOpened)
   } Else If folderOpened
   {
      If InStr(folderOpened, "|")
         tryOpenGivenFolder(folderOpened, 0)
      Else
         OpenFolders(folderOpened)
   } Else If (thisCounter=1 && !sldOpened && !folderOpened)
      OpenArgFile(Trimmer(filesListu))
   Else If (thisCounter>1 && !sldOpened && !folderOpened)
      GuiDroppedFiles(filesListu, nona, none, thisCounter, 0)
   Else Return 1

   If delayedfunc2exec
      SetTimer, runDelayedfunc2exec, -900

   Return doWelcomeNow
}

runDelayedfunc2exec() {
   If IsFunc(delayedfunc2exec)
      %delayedfunc2exec%()
}

OpenSLD(fileNamu, dontStartSlide:=0) {
  mustOpenStartFolder := ""
  If !FileExist(fileNamu)
  {
     showTOOLtip("ERROR: Failed to load files list")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  PopulateIndexFilesStatsInfos("kill")
  If (SLDtypeLoaded=3)
  {
     SLDtypeLoaded := 0
     activeSQLdb.CloseDB()
  }

  mustRemQuotes := 1
  setImageLoading()
  ForceRegenStaticFolders := 0
  renewCurrentFilesList()
  newStaticFoldersListCache := []
  DynamicFoldersList := CurrentSLD := filesFilter := ""
  zPlitPath(fileNamu, 0, OutFileName, OutDir)
  showTOOLtip("Loading slideshow, please wait`n" OutFileName "`n" OutDir "\")
  setWindowTitle("Loading slideshow, please wait", 1)
  If RegExMatch(fileNamu, "i)(.\.sldb)$")
  {
     r := sldbDataBaseOpen(fileNamu)
     If (maxFilesIndex>0 && r!=-1)
     {
        SLDcacheFilesList := 1
        mustGenerateStaticFolders := 0
        GenerateRandyList()
        SetTimer, ResetImgLoadStatus, -50
        CurrentSLD := fileNamu
        RecentFilesManager(CurrentSLD)
        SLDtypeLoaded := 3
        prevOpenFolderPath := OutDir
        INIaction(1, "prevOpenFolderPath", "General")
        RandomPicture()
        InfoToggleSlideShowu()
     } Else resetMainWin2Welcome()
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  FileReadLine, firstLine, % fileNamu, 1
  If InStr(firstLine, "[General]") 
  {
     mustRemQuotes := 0
     IniRead, testStaticFolderz, % fileNamu, Folders, Fi1, @
     IniRead, tstSLDcacheFilesList, % fileNamu, General, SLDcacheFilesList, @
     IniRead, testDynaFolderz, % fileNamu, DynamicFolderz, DF1, @
     If StrLen(testDynaFolderz)>4
        DynamicFoldersList := "|hexists|"
       ; DynamicFoldersList := coreLoadDynaFolders(fileNamu)

     If (tstSLDcacheFilesList=1 || tstSLDcacheFilesList=0)
        SLDcacheFilesList := tstSLDcacheFilesList
  }

  mustGenerateStaticFolders := (InStr(firstLine, "[General]") && StrLen(testStaticFolderz)>8) ? 0 : 1
  If (tstSLDcacheFilesList=0)
     mustGenerateStaticFolders := 0

  If (SLDcacheFilesList=1 && InStr(firstLine, "[General]")) || !InStr(firstLine, "[General]")
     res := sldGenerateFilesList(fileNamu, 0, mustRemQuotes)

  currentFilesListModified := 0
  interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
  prevOpenFolderPath := OutDir
  INIaction(1, "prevOpenFolderPath", "General")
  If (res="abandoned")
  {
     closeDocuments()
     showDelayedTooltip("Files list operation aborted by user")
     SoundBeep , 300, 100
     Return
  }

  If InStr(firstLine, "[General]") 
  {
     If (maxFilesIndex<3 && DynamicFoldersList="|hexists|")
        ReloadDynamicFolderz(fileNamu)

     If (MustLoadSLDprefs=1)
        readSlideSettings(fileNamu, 0)
  }

  GenerateRandyList()
  CurrentSLD := fileNamu
  SLDtypeLoaded := 2
  currentFileIndex := 1
  currentFilesListModified := 0
  RecentFilesManager(CurrentSLD)
  If (dontStartSlide=1)
  {
     SetTimer, RemoveTooltip, % -msgDisplayTime
     ResetImgLoadStatus()
     Return
  }

  ResetImgLoadStatus()
  If (maxFilesIndex>2)
  {
     RandomPicture()
     InfoToggleSlideShowu()
  } Else If (maxFilesIndex>0)
  {
     currentFileIndex := 1
     IDshowImage(1)
  } Else resetMainWin2Welcome()

  SetTimer, RemoveTooltip, % -msgDisplayTime
}

resetMainWin2Welcome() {
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
     { 
        seenImagesDB.Exec("COMMIT TRANSACTION;")
        Sleep, -1
        seenImagesDB.Exec("BEGIN TRANSACTION;")
     }

     ForceRegenStaticFolders := SLDtypeLoaded := 0
     editingSelectionNow := thumbsDisplaying := 0
     renewCurrentFilesList()
     activeSQLdb.CloseDB()
     bckpResultedFilesList := []
     filteredMap2mainList := []
     RandyIMGids := []
     updateUIctrl()
     newStaticFoldersListCache := []
     DynamicFoldersList := CurrentSLD := ""
     filesFilter := EntryMarkedMoveIndex := mustOpenStartFolder := ""
     ToggleVisibilityWindow("show", hGDIwin)
     interfaceThread.ahkassign("thumbsDisplaying", 0)
     interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
     ToggleVisibilityWindow("hide", hGDIthumbsWin)
     clearGivenGDIwin(glPG, glHDC, hGDIthumbsWin)
     clearGivenGDIwin(glPG, glHDC, hGDIwin)
     clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
     clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIselectWin)
     gdiBitmapIDcall := viewportIDstampBMP := AprevImgCall := BprevImgCall := ""
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     corePasteInPlaceActNow("kill")
     livePreviewInsertTextinArea("kill")
     coreFillSelectedArea("kill")
     livePreviewDesaturateArea("kill")
     coreCreateVPnavBox("kill")
     LoadCachableBitmapFromFile("kill")
     viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
     gdipObjectsStats(1, "QPV_ShowThumbnails")
     gdipObjectsStats(1)
     ForceRefreshNowThumbsList()
     prevOpenedWindow := ""
     drawWelcomeImg()
     SetTimer, ResetImgLoadStatus, -50
}

deleteKeyAction() {
    If !getIDimage(currentFileIndex)
       Return

    If (thumbsDisplaying!=1 && editingSelectionNow=1)
       PanelEraseSelectedArea()
    Else
       DeletePicture()
}

activateFilesListFilterBasedOnFolder(thisIndex) {
   If askAboutFileSave(" and the files list will be filtered to the current image containing folder")
      Return

   r := getIDimage(thisIndex)
   zPlitPath(r, 0, OutFileName, OutDir)
   userFilterProperty := userFilterDoString := 1
   userFilterWhat := 2
   userFilterStringPos := 3
   userFilterStringIsNot := 0
   UsrEditFilter := OutDir
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   showDelayedTooltip("Files list filtered to current image file path:`n" OutDir "\", 0, 325)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(100)
}

escRoutine() {
  Sleep, -1
  Return
}

GenerateRandyList() {
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   startZeit := A_TickCount
   RandyIMGids := []
   Loop, % maxFilesIndex
       RandyIMGids[A_Index] := A_Index
   RandyIMGids := Random_ShuffleArray(RandyIMGids)
   RandyIMGnow := 1
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
}

OpenThisFileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    resultu := getIDimage(currentFileIndex)
    If resultu
    {
       zPlitPath(resultu, 0, fileNamu, folderu)
       Try Run, "%folderu%"
       Catch wasError
       {
          If !AnyWindowOpen
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu, 0, 0, "error")
       }
    }
}

OpenQPVfileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    imgPath := getIDimage(currentFileIndex)
    If imgPath
    {
       zPlitPath(imgPath, 0, fileNamu, folderu)
       renewCurrentFilesList()
       mustOpenStartFolder := folderu
       currentFileIndex := 1
       resultedFilesList[1, 1] := imgPath
       currentFileIndex := doOpenStartFolder()
       dummyTimerDelayiedImageDisplay(50)
    }
}

setImageWallpaper() {
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If !RegExMatch(imgPath, "i)(.\.(bmp|jpg|jpeg|png|tif))$")
   {
      showTOOLtip("Converting Image file format for desktop wallpaper into JPEG")
      file2save := mainCompiledPath "\wallpaper-" OutNameNoExt ".jpg"
      r := coreConvertImgFormat(imgPath, file2save)
      If !r
         imgPath := file2save
      ResetImgLoadStatus()
   }

   GetPhysicalCursorPos(mainX, mainY)
   ActiveMon := MWAGetMonitorMouseIsIn(mainX, mainY)
   If !ActiveMon
      ActiveMon := 1

   dw := new IDesktopWallpaper
   dw.GetMonitorDevicePathAt(ActiveMon - 1, MonitorID)
   dw.SetWallpaper(MonitorID, imgPath)
   dw := Delete IDesktopWallpaper
   showTOOLtip("Image file is now set as desktop wallpaper`n" fileNamu "`n" folderu "\")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

OpenThisFileMenu() {
  Static lastInvoked := 1

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, Ext)
  labelu := "QPVimage." Ext

  RegRead, regEntryA, HKEY_CLASSES_ROOT\.%Ext%
  If (regEntryA=labelu)
     testA := 1

  RegRead, regEntryB, HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.%Ext%\UserChoice, ProgId
  If (regEntryB=labelu)
     testB := 1

  If (slideShowRunning=1)
     ToggleSlideShowu()

  DestroyGIFuWin()
  isAssociated := (testA=1 && testB=1) ? 1 : 0
  newInstanceOption := (A_IsCompiled) ? 1 : 0
  InvokeOpenWithMenu(imgPath, newInstanceOption)
}

SoloNewQPVinstance() {
   OpenWithNewQPVinstance("single")
}

OpenWithNewQPVinstance(dummy:=0, givenList:=0, givenCount:=0) {
   filesElected := getSelectedFiles(0, 1)
   markedSelectFile := filesElected
   If (givenList && givenCount && isNumber(givenCount))
      filesElected := givenCount

   ; ToolTip, % givenCount "--" dummy "--" filesElected "--" givenList , , , 2
   If (filesElected>25 && dummy!="single")
   {
      msgBoxWrapper(appTitle ": WARNING", "You are not allowed to spawn in one go more than 25 instances of " appTitle ".", 0, 0, "error")
      Return
   }

   If (filesElected>5 && dummy!="single")
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " filesElected ". Please confirm you want to spawn so many new instances of " appTitle ".", 4, 0, "question")
      If (msgResult="Yes")
         allGood := 1
   } Else allGood := 1

   maxLoops := (givenList && givenCount) ? givenCount + 2 : maxFilesIndex
   If (givenList && givenCount>0 && isNumber(givenCount) && dummy!="single" && allGood=1)
   {
      Loop, Parse, givenList, `n
      {
         imgPath := Trimmer(A_LoopField)
         If StrLen(imgPath)>4
         {
            Sleep, (A_Index>1) ? 700 : 300
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (markedSelectFile && filesElected>1 && dummy!="single" && allGood=1)
   {
      thisIndex := 0
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         thisIndex++
         imgPath := resultedFilesList[A_Index, 1]
         If StrLen(imgPath)>4
         {
            Sleep, (thisIndex>1) ? 700 : 300
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (!markedSelectFile || dummy="single")
   {
      imgPath := getIDimage(currentFileIndex)
      OpenNewQPVinstance(imgPath)
   }
}

OpenNewQPVinstance(imgPath:="") {
   imgPath := StrReplace(imgPath, "||")
   If FolderExist(imgPath)
      imgPath := "fd=" imgPath
   Else If !FileRexists(imgPath)
      imgPath := ""

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening a new instance of " appTitle ".", 0, 0, "error")
}

OpenWithDefaultApp() {
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    If !FileRexists(imgPath)
       informUserFileMissing()
    Sleep, 25
    If imgPath
    {
       Try Run, "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the default application.", 0, 0, "error")
    }
}

OpenFileProperties() {
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    If !FileRexists(imgPath)
       informUserFileMissing()
    Sleep, 25
    If imgPath
    {
       Try Run, Properties "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the system file properties.", 0, 0, "error")
    }
}

InvokeOpenWithMenu(imgPath, newInstanceOption) {
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    CurrentSLD := Trimmer(StrReplace(CurrentSLD, "|"))
    IniAction(0, "UserExternalApp", "General", 5)
    pathu := "&X. " PathCompact(UserExternalApp, 28)
    If StrLen(Trimmer(UserExternalApp))<6
       pathu := "NONE CHOSEN"

    IniAction(0, "UserExternalEditApp", "General", 5)
    pathu2 := "&Y. " PathCompact(UserExternalEditApp, 28)
    If StrLen(Trimmer(UserExternalEditApp))<6
       pathu2 := "NONE CHOSEN"
    CreateOpenWithMenu(imgPath)
    Menu, OpenWithMenu, Add,
    If (newInstanceOption=1 && !markedSelectFile)
       Menu, OpenWithMenu, Add, &0. Open file(s) in a new QPV instance, SoloNewQPVinstance
    Menu, OpenWithMenu, Add, &1. Open with default application, OpenWithDefaultApp
    Menu, OpenWithMenu, Add, &2. System «Open with» dialog, invokeSHopenWith
    Menu, OpenWithMenu, Add, &4. Explore containing folder`tCtrl+E, OpenThisFileFolder
    If (CurrentSLD!=OutDir)
       Menu, OpenWithMenu, Add, &5. Open containing folder in QPV, OpenQPVfileFolder
    Menu, OpenWithMenu, Add,
    Menu, OpenWithMenu, Add, &Choose external application, browseExternalApp
    Menu, OpenWithMenu, Add, %pathu%, OpenImgWithUserExternApp
    Menu, OpenWithMenu, Add, &Choose external editor application, browseExternalEditApp
    Menu, OpenWithMenu, Add, %pathu2%, OpenImgWithUserEditExternApp
    If (!pathu || pathu="none chosen")
       Menu, OpenWithMenu, Disable, %pathu%
    If (!pathu2 || pathu2="none chosen")
       Menu, OpenWithMenu, Disable, %pathu2%
    Menu, OpenWithMenu, Add,
    Menu, OpenWithMenu, Add, &Cancel, dummy
    showThisMenu("OpenWithMenu")
}

browseExternalApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalApp := imgPath
      IniAction(1, "UserExternalApp", "General")
      OpenImgWithUserExternApp()
   }
}

browseExternalEditApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalEditApp := imgPath
      IniAction(1, "UserExternalEditApp", "General")
      OpenImgWithUserEditExternApp()
   }
}

OpenImgWithUserEditExternApp() {
   destroyGDIfileCache()
   OpenImgWithUserExternApp("editor")
}

OpenImgWithUserExternApp(dummy:=0) {
   ; IniAction(0, "UserExternalApp", "General", 5)
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   thisAPPpath := (dummy="editor") ? UserExternalEditApp : UserExternalApp
   If !FileExist(thisAPPpath)
   {
      zPlitPath(thisAPPpath, 0, fileNamu, folderu, OutNameNoExt)
      showTOOLtip("ERROR: The file of the external application does not seem to exist anymore`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   Try Run, %thisAPPpath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the external application.", 0, 0, "error")
}

resetSlideshowTimer(showMsg, ignoreEasyStop:=0) {
   ; DestroyGIFuWin()
   If (slideShowRunning!=1 && showMsg!=1)
      Return

   If (easySlideStoppage=1 && slideShowRunning=1 && ignoreEasyStop=0)
      ToggleSlideShowu("stop")
   Else If (slideShowRunning=1)
      ToggleSlideShowu("start")

   If (showMsg=1)
   {
      friendly := (slideShowRunning=1) ? "RUNNING" : "STOPPED"
      delayu := DefineSlidesRate()
      etaTime := "Estimated time: " EstimateSlideShowLength()
      showTOOLtip("Slideshow speed: " delayu "`nTotal files: " groupDigits(maxFilesIndex) "`n" etaTime "`nSlideshow: " friendly)
      SetTimer, ResetImgLoadStatus, -50
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

IncreaseSlideSpeed() {
   If (slideShowDelay<1000)
   {
      slideShowDelay += 300
      SetTimer, dummyChangeSlideSpeed, -50
      Return
   }
   
   slideShowDelay += 1000
   If (slideShowDelay>59000)
      slideShowDelay := 59000

   SetTimer, dummyChangeSlideSpeed, -50
}

DecreaseSlideSpeed() {
   If (slideShowDelay<1001)
   {
      slideShowDelay -= 300
      If (slideShowDelay<200)
         slideShowDelay := 100

      SetTimer, dummyChangeSlideSpeed, -50
      Return
   }

   slideShowDelay -= 1000
   SetTimer, dummyChangeSlideSpeed, -50
}

dummyChangeSlideSpeed() {
   resetSlideshowTimer(1, 1)
   INIaction(1, "slideShowDelay", "General")
}

CalculateSelectedFilesSizes() {
  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  getSelectedFiles(0, 1)
  If !markedSelectFile
  {
     showTOOLtip("No files currently selected to calculate total files' size.")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  showTOOLtip("Calculating total files' size for selected entries, please wait")
  prevMSGdisplay := A_TickCount
  doStartLongOpDance()
  maxCdate := maxMdate := maxSizeu := 0
  minCdate := minMdate := minSizeu := 99999999999999
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  Loop, % maxFilesIndex
  {
     isSelected := resultedFilesList[A_Index, 2]
     If (isSelected!=1)
        Continue

     executingCanceableOperation := A_TickCount
     If (determineTerminateOperation()=1)
     {
        abandonAll := 1
        Break
     }

     countFiles++
     If (A_TickCount - prevMSGdisplay>1000)
     {
        etaTime := ETAinfos(countFiles, markedSelectFile, startOperation)
        If failedFiles
           etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

        showTOOLtip("Calculating total files' size, please wait" etaTime, 0, 0, countFiles/markedSelectFile)
        prevMSGdisplay := A_TickCount
     }

     fileInfos := GetFileAttributesEx(resultedFilesList[A_Index, 1])
     If !fileInfos.size
     {
        failedFiles++
        Continue
     }

     totalSize += fileInfos.size
     minSizeu := min(minSizeu, fileInfos.size)
     maxSizeu := max(maxSizeu, fileInfos.size)
     minMdate := min(minMdate, fileInfos.wtime)
     maxMdate := max(maxMdate, fileInfos.wtime)
     minCdate := min(minCdate, fileInfos.ctime)
     maxCdate := max(maxCdate, fileInfos.ctime)
  }
  ; ToolTip, % minCdate , , , 2
  totalSize := Round(totalSize/1024)
  If (totalSize>1023)
  {
     totalSize := Round(totalSize/1024, 1)
     If (totalSize>1023.9)
        totalSize := Round(totalSize/1024, 1) " GB"
     Else totalSize := totalSize " MB"

  } Else totalSize := totalSize " KB"

  minSizeu := Round(minSizeu/1024)
  minSizeu := (minSizeu>1023) ? Round(minSizeu/1024, 1) " MB" : minSizeu " KB"

  maxSizeu := Round(maxSizeu/1024)
  maxSizeu := (maxSizeu>1023) ? Round(maxSizeu/1024, 1) " MB" : maxSizeu " KB"
  CurrentSLD := backCurrentSLD
  Try FormatTime, minCdate, % minCdate, dd/MM/yyyy, HH:mm
  Try FormatTime, maxCdate, % maxCdate, dd/MM/yyyy, HH:mm
  Try FormatTime, minMdate, % minMdate, dd/MM/yyyy, HH:mm
  Try FormatTime, maxMdate, % maxMdate, dd/MM/yyyy, HH:mm
  If (abandonAll=1)
     someErrors := "Operation aborted by user`n"
  showTOOLtip(someErrors "Details for " groupDigits(countFiles) " selected files:`nTotal size: " totalSize "`nFile sizes range: " minSizeu " - " maxSizeu "`nDate modified: " minMdate " - " maxMdate "`nDate created: " minCdate " - " maxCdate)
  SetTimer, ResetImgLoadStatus, -200
  SetTimer, RemoveTooltip, % -msgDisplayTime * 2
}

CopyImageFolderPaths() {
    CopyImagePath("folderz")
}

CopyImagePath(dummy:=0) {
  If (currentFileIndex=0)
     Return

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  folderPathsOnly := (GetKeyState("CapsLock", "T") || dummy="folderz") ? 1 : 0
  friendly := (folderPathsOnly=1) ? "folder" : "file"
  showTOOLtip("Copying " friendly " path(s) to clipboard")
  getSelectedFiles(0, 1)
  If (markedSelectFile>1)
  {
     Loop, % maxFilesIndex
     {
        isSelected := resultedFilesList[A_Index, 2]
        If (isSelected!=1)
           Continue

        imgPath := StrReplace(resultedFilesList[A_Index, 1], "||")
        If (folderPathsOnly=1)
        {
           folderu := ""
           zPlitPath(imgPath, 1, fileNamu, folderu)
           listu .= folderu "`n"
        } Else listu .= imgPath "`n"
        countTFilez++
     }

     If countTFilez
     {
        If (folderPathsOnly=1)
           Sort, listu, UD`n
        Try Clipboard := listu
        Catch wasError
            Sleep, 1

        infoText := wasError ? "ERROR: Failed to copy to clipboard the selected file paths`nError code: " wasError : groupdigits(countTFilez) A_Space friendly " paths were copied to clipboard"
        showTOOLtip(infoText)
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     } Else markedSelectFile := 0
  }

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, fileNamu, folderu)
  imgPath := StrReplace(imgPath, "||")
  If (folderPathsOnly=1)
     Try Clipboard := folderu
  Else
     Try Clipboard := imgPath
  Catch wasError
      Sleep, 1

  infoText := wasError ? "ERROR: Failed to copy to clipboard the " friendly " path`nError code: " wasError "`n" : "The " friendly " path copied to clipboard`n"
  showTOOLtip(infoText fileNamu "`n" folderu "\")
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

ClipboardSetFiles(PathToCopy, Method:="copy") {
; function from https://autohotkey.com/board/topic/23162-how-to-copy-a-file-to-the-clipboard/page-4
; by maraskan_user and Lexikos
; modified by Marius Șucan

   FileCount := 0
   PathLength := 0

   ; Count files and total string length
   For i, File in PathToCopy
   {
      FileCount++
      PathLength += StrLen(File)
   }

   pid := DllCall("GetCurrentProcessId","uint")
   hwnd := WinExist("ahk_pid " . pid)
   ; 0x42 = GMEM_MOVEABLE(0x2) | GMEM_ZEROINIT(0x40)
   hPath := DllCall("GlobalAlloc","uint",0x42,"uint",20 + (PathLength + FileCount + 1) * 2, "UPtr")
   If !hPath
      Return

   pPath := DllCall("GlobalLock","UPtr", hPath)
   NumPut(20, pPath+0), pPath += 16 ; DROPFILES.pFiles = offset of file list
   NumPut(1, pPath+0), pPath += 4 ; fWide = 0 -->ANSI,fWide = 1 -->Unicode

   Offset := 0
   ; Rows are delimited by linefeeds (`r`n).
   for i, File in PathToCopy
       offset += StrPut(File, pPath + offset, StrLen(File)+1, "UTF-16") * 2

   If !DllCall("OpenClipboard","UPtr", hwnd)
      Return 0

   DllCall("GlobalUnlock","UPtr",hPath)
   DllCall("EmptyClipboard")
   err := DllCall("SetClipboardData","uint",0xF,"UPtr",hPath) ; 0xF = CF_HDROP

   ; Write Preferred DropEffect structure to clipboard to switch between copy/cut operations
   ; 0x42 = GMEM_MOVEABLE(0x2) | GMEM_ZEROINIT(0x40)
   mem := DllCall("GlobalAlloc","uint",0x42,"uint",4,"UPtr")
   If mem
   {
      str := DllCall("GlobalLock","UPtr",mem, "uptr")
   } Else
   {
      DllCall("CloseClipboard")
      Return
   }

   if (Method="copy")
   {
      DllCall("RtlFillMemory","UPtr",str,"UPtr",1,"Int",0x05)
   } else if (Method="cut")
   {
      DllCall("RtlFillMemory","UPtr",str,"UPtr",1,"Int",0x02)
   } else
   {
      DllCall("CloseClipboard")
      Return
   }

   DllCall("GlobalUnlock","UPtr",mem)

   cfFormat := DllCall("RegisterClipboardFormat","Str","Preferred DropEffect")
   DllCall("SetClipboardData","uint",cfFormat,"UPtr",mem)
   DllCall("CloseClipboard")
   return err
}

MenuExplorerCopyFiles() {
    CopyMoveFilesExplorer("copy")
}

MenuExplorerCutFiles() {
    destroyGDIfileCache()
    CopyMoveFilesExplorer("cut")
}

CopyMoveFilesExplorer(userOption:="copy") {
  userOption := (userOption="cut") ? "CUT" : "COPY"
  If (currentFileIndex=0)
     Return

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  showTOOLtip("Copying file path(s) to clipboard")
  getSelectedFiles(0, 1)
  newFilesList := []
  countTFilez := 0
  If (markedSelectFile>1)
  {
     Loop, % maxFilesIndex
     {
        isSelected := resultedFilesList[A_Index, 2]
        If (isSelected!=1)
           Continue

        file2rem := getIDimage(A_Index)
        file2rem := StrReplace(file2rem, "||")
        If StrLen(file2rem)<4
           Continue

        countTFilez++
        newFilesList[countTFilez] := file2rem
     }

     If countTFilez
     {
        dataHandle := ClipboardSetFiles(newFilesList, userOption)
        Sleep, 5
        Try testClipType := DllCall("IsClipboardFormatAvailable", "uint", 15)
        infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to store the selected files into the clipboard" : "On " countTFilez " files " userOption " was applied.`nThese can now be pasted in any file manager."
        showTOOLtip(infoText)
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     } Else markedSelectFile := 0
  }

  imgPath := getIDimage(currentFileIndex)
  newFilesList[1] := Trimmer(StrReplace(imgPath, "||"))
  dataHandle := ClipboardSetFiles(newFilesList, userOption)
  zPlitPath(imgPath, 0, fileNamu, folderu)
  Sleep, 5
  Try testClipType := DllCall("IsClipboardFormatAvailable", "uint", 15)
  infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to store files into clipboard" : "File " userOption " [Explorer mode]...`n"
  showTOOLtip(infoText fileNamu "`n" folderu "\")
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

throwErrorNoImageLoaded() {
   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   If (StrLen(whichBitmap)<3 || !imgPath)
   {
      showTOOLtip("WARNING: No image file is currently loaded")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return "fail"
   }
}

CopyImage2clip() {
  If (thumbsDisplaying=1)
     Return "fail"

  If throwErrorNoImageLoaded()
     Return "fail"

  whichBitmap := useGdiBitmap()
  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  friendly := (editingSelectionNow=1) ? "selected area" : ""
  If (editingSelectionNow=1 && StrLen(whichBitmap)>2)
  {
     If throwErrorSelectionOutsideBounds(whichBitmap)
        Return "fail"
  }

  setImageLoading()
  If StrLen(whichBitmap)>2
  {
     showTOOLtip("Copying image " friendly " to clipboard, please wait")
     If (editingSelectionNow=1)
        zBitmap := getselectedImageArea(whichBitmap, 1, 0, 2, 0)
     Else
        zBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, whichBitmap)))

     If StrLen(zBitmap)>2
     {
        hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, zBitmap)
        r := hBitmap ? Gdip_SetBitmapToClipboard(zBitmap, hBitmap) : addJournalEntry("get_last_err")
        ; If (zBitmap!=whichBitmap)
           trGdip_DisposeImage(zBitmap, 1)
     } Else r := "fail"
  } Else r := "fail"

  SetTimer, ResetImgLoadStatus, -100
  If r
     showTOOLtip("Failed to copy the image to clipboard`nError code: " r)
  Else
     showTOOLtip("Image " friendly " copied to clipboard")

  SoundBeep, % r ? 300 : 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return r
}

invertCurrentFolderRecursiveness() {
   If (RegExMatch(CurrentSLD, sldsPattern) || !CurrentSLD)
      Return

   isPipe := InStr(CurrentSLD, "|") ? 1 : 0
   CurrentSLD := StrReplace(CurrentSLD, "|")
   DynamicFoldersList := StrReplace(DynamicFoldersList, "|")
   If (isPipe!=1)
   {
      CurrentSLD := "|" CurrentSLD
      DynamicFoldersList := "|" DynamicFoldersList
   }

   RefreshFilesList()
}

MenuRemFilesListFilter() {
   remFilesListFilter()
   ; SetTimer, RandomPicture, -150
   dummyTimerDelayiedImageDisplay(50)
}

remFilesListFilter(dummy:=0) {
   If (dummy="simple")
   {
      addJournalEntry("Removing files list filter:`n" filesFilter)
      prevFilter := filesFilter
      filesFilter := ""
      FilterFilesIndex(0, 0, prevFilter)
      currentFileIndex := clampInRange(bckpCurrentFileIndex, 1, maxFilesIndex)
   } Else coreEnableFiltru("")
}


dummyTimerReloadThisPicture(timeru:=0) {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If (timeru>1)
     SetTimer, extraDummyReloadThisPicture, % -timeru, 950
}

extraDummyReloadThisPicture() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyReloadThisPicture, -15
     Return
  }
  ReloadThisPicture()
}

determineLClickstate() {
   If (slideShowRunning=1)
      Return 0

   LbtnDwn := interfaceThread.ahkgetvar.LbtnDwn
   If (GetKeyState("LButton") || LbtnDwn=1)
      Return 1
   Else
      Return 0
}

ReloadThisPicture() {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
  {
     delayu := (A_TickCount - prevFastDisplay < 500) ? 90 : 550
     If (determineLClickstate()=1 || GetKeyState("Space", "P"))
     {
        dummyTimerReloadThisPicture(delayu)
        Return
     }
     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing()
  }
}

coreReloadThisPicture() {
  If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
  {
     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing()
  }
}

FirstPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := 1
   dummyTimerDelayiedImageDisplay(50)
}

LastPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=maxFilesIndex)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := maxFilesIndex
   dummyTimerDelayiedImageDisplay(50)
}

SettingsGUIAGuiClose:
SettingsGUIAGuiEscape:
   CloseWindow()
Return

doCleanup:
   TrueCleanup()
Return

TrueCleanup(mustExit:=1) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 900) || (hasInitSpecialMode=1)
      Return

   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
      seenImagesDB.Exec("COMMIT TRANSACTION;")

   activeSQLdb.CloseDB()
   seenImagesDB.CloseDB()
   If AnyWindowOpen
      BtnCloseWindow()

   Sleep, 10
   WinSet, Region, 0-0 w1 h1, ahk_id %PVhwnd%
   RegWrite, REG_SZ, %QPVregEntry%, Running, 0
   If StrLen(hitTestSelectionPath)>1
   {
      editingSelectionNow := 0
      Gdip_DeletePath(hitTestSelectionPath)
      hitTestSelectionPath := ""
   }

   lastInvoked := A_TickCount
   RemoveTooltip()
   DestroyGIFuWin()

   Sleep, 1
   If (wasInitFIMlib=1)
      FreeImage_FoxInit(0) ; Unload Dll

   disposeCacheIMGs()
   destroyGDIfileCache()
   discardViewPortCaches()
   Gdip_DeleteBrush(pBrushWinBGR)
   Gdip_DeleteBrush(pBrushHatch)
   Gdip_DeleteBrush(pBrushHatchLow)
   Gdip_DeleteBrush(pBrushA)
   Gdip_DeleteBrush(pBrushB)
   Gdip_DeleteBrush(pBrushC)
   Gdip_DeleteBrush(pBrushD)
   Gdip_DeleteBrush(pBrushE)
   Gdip_DeleteBrush(pBrushF)
   Gdip_DeleteBrush(pBrushZ)
   Gdip_DeleteBrush(AmbientalTexBrush)
   Gdip_DeletePen(pPen1)
   Gdip_DeletePen(pPen1d)
   Gdip_DeletePen(pPen2)
   Gdip_DeletePen(pPen3)
   Gdip_DeletePen(pPen4)
   Gdip_DeletePen(pPen5)

   mainGdipWinThumbsGrid(1)
   destroyGDIPcanvas()
   Sleep, 1
   GDIPToken := Gdip_Shutdown(GDIPToken)  
   lastInvoked := A_TickCount
   ; If (mustExit=1)
   ;    writeMainSettings()
   lastInvoked := A_TickCount
   fnOutputDebug("Proper exit. Main thread. PID=" QPVpid)
   ForceExitNow("yay")
}

ForceExitNow(dummy:=0) {
   If GDIPToken
      Gdip_Shutdown(GDIPToken)  
   Sleep, 5
   If (dummy!="yay")
      fnOutputDebug("Forced exit. Main thread. PID=" QPVpid)
   Process, Close, % QPVpid
   ExitApp
}

dummySetWindowTitle() {
    setWindowTitle("lol", 0, 1)
}

setWindowTitle(msg, forceThis:=0, useLast:=0) {
    Static prevSet, prevMsg, lastInvoked := 1
    If (A_TickCount - zeitSillyPrevent<200) || (drawingShapeNow=1)
       Return

    msg := StrReplace(msg, "`n", " | ")
    If (useLast!=1)
       addJournalEntry("WinTitle: " msg)

    infoSlideDelay := (slideShowRunning=1 && slideShowDelay<2950) ? 1 : 0
    thisMsg := (useLast=1 && StrLen(prevMsg)>3) ? prevMsg : msg
    If (useLast!=1)
       prevMsg := msg

    If (A_TickCount - lastInvoked<200) && (useLast!=1 && forceThis!=1)
    {
       SetTimer, dummySetWindowTitle, -350
       Return
    }

    If (prevSet!=thisMsg && runningLongOperation!=1 && infoSlideDelay=0 && animGIFplaying!=1 && hasInitSpecialMode!=1) || (forceThis=1)
    {
       prevSet := thisMsg
       WinSetTitle, ahk_id %PVhwnd%,, % thisMsg
       ; fnOutputDebug("WinTitle: " thisMsg)
       lastInvoked := A_TickCount
    }
}

fnOutputDebug(msg) {
   Static prevMsg

   If (debugModa=1)
   {
      If (prevMsg!=msg && slideShowRunning!=1 && slideShowDelay>300)
      {
         prevMsg := msg
         msg := StrReplace(msg, "User journal: wintitle:", "WinTitle:")
         msg := StrReplace(msg, "User journal: dialog box:", "Dialog box:")
         msg := StrReplace(msg, "User journal: osd:", "OSD:")
         OutputDebug, % "QPV: " Trim(msg)
      }
   }
}

MenuDummyToggleThumbsMode() {
   lastOtherWinClose := 5
   ToggleThumbsMode()
}

initAHKhThumbThreads() {
    Static multiCoreInit := 0

    If (multiCoreInit=1 || allowMultiCoreMode!=1 || minimizeMemUsage=1)
       Return

    addJournalEntry("Attempting to initialize " realSystemCores " threads for thumbnails generation")
    initFIMGmodule()
    If (FIMfailed2init=1)
    {
       addJournalEntry("Failed to initialize the auxiliary threads because FreeImage failed to initialize")
       multiCoreThumbsInitGood := 0
    } Else
    {
       ; SoundBeep 300, 100
       If A_IsCompiled
          r := GetRes(dataFile, 0, "MODULE-FIM-THUMBS.AHK", "LIB")

       Loop, % realSystemCores + 1
       {
           If IsObject(thumbThread%A_Index%)
              Continue

           If !A_IsCompiled
              thumbThread%A_Index% := ahkthread("#Include *i Lib\module-fim-thumbs.ahk")
           Else If r
              thumbThread%A_Index% := ahkThread(StrGet(&dataFile, r, "utf-8"))

           Sleep, 1
       }

       Loop, % realSystemCores + 1
       {
           goodInit += thumbThread%A_Index%.ahkFunction("initThisThread", GDIPToken "|" mainCompiledPath)
           Sleep, 1
       }

       multiCoreThumbsInitGood := (goodInit>=realSystemCores+1) ? 1 : 0
       If (multiCoreThumbsInitGood=1)
          addJournalEntry("Succesfully initialized " goodInit " threads.")
       Else
          addJournalEntry("Failed to initialize the auxiliary threads (unknown cause).")
    }

    multiCoreInit := 1
}

getFolderDetails(pathu) {
   FileGetTime, fileMdate, % pathu, M
   FileGetTime, fileCdate, % pathu, C
   FileGetAttrib, fileAttribs, % pathu
   thisFolderDetails := "\" fileMdate "\" fileCdate "\" fileAttribs "\" pathu
   Return thisFolderDetails
}

ToggleThumbsMode() {
   Static multiCoreInit := 0, lastInvoked := 1, prevIndexu
   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (A_TickCount - lastInvoked<190) || (A_TickCount - lastOtherWinClose<190)
   {
      lastInvoked := A_TickCount
      Return
   }
 
   If (thumbsDisplaying=1 && currentFileIndex!=imgIndexEditing)
   {
      If askAboutFileSave(" and another image will be loaded")
      {
         MenuReturnIMGedit()
         Return
      }
   }

   If (SLDtypeLoaded=1 && FolderExist(StrReplace(CurrentSLD, "|")) && watchFolderDetails && maxFilesIndex>1 && thumbsDisplaying!=1)
   {
      thisFolderDetails := getFolderDetails(StrReplace(CurrentSLD, "|"))
      IF (thisFolderDetails!=watchFolderDetails && !markedSelectFile)
      {
         msgResult := msgBoxWrapper(appTitle ": Folder changed", "The folder currently opened seems to have been changed. Would you like to reload it?", 4, 0, "question")
         If InStr(msgResult, "yes")
            RefreshFilesList()
      }
      watchFolderDetails := thisFolderDetails
   }

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   lastInvoked := A_TickCount
   If (maxFilesIndex<2 && thumbsDisplaying!=1)
   {
      showTOOLtip("WARNING: Insufficient indexed files to activate the list view mode")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   interfaceThread.ahkassign("lastCloseInvoked", 0)
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   thisIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
   clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIselectWin)
   If (thumbsDisplaying=1)
   {
      lastTimeToggleThumbs := A_TickCount
      fnOutputDebug("Deactivating thumbs mode")
      If (thisIndexu!=prevIndexu)
         FadeMainWindow()

      thumbsDisplaying := 0
      ; fnOutputDebug("Showing hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("show", hGDIwin)
      interfaceThread.ahkassign("thumbsDisplaying", 0)
      interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
      ; fnOutputDebug("Hiding hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("hide", hGDIthumbsWin)
      fnOutputDebug("Image view initialized")
      dummyTimerDelayiedImageDisplay(50)
      interfaceThread.ahkPostFunction("UpdateUiStatusBar", 0, 0, "image")
      If hSNDmediaFile
         MCI_Resume(hSNDmedia)
      lastTimeToggleThumbs := A_TickCount
   } Else If (CurrentSLD && maxFilesIndex>1)
   {
      lastTimeToggleThumbs := A_TickCount
      fnOutputDebug("Initializing thumbnails/list view mode")
      prevLoadedImageIndex := currentFileIndex
      If (prevIndexu!=thisIndexu && noTooltipMSGs=0 && thumbnailsListMode!=1)
         CreateOSDinfoLine("Generating thumbnails, please wait", 0, 1)

      prevIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
      If (thumbnailsListMode!=1 && !isWinXP)
         initAHKhThumbThreads()

      If (getCaptionStyle(PVhwnd)=1)
         ToggleTitleBaruNow()
      If hSNDmediaFile
         MCI_Pause(hSNDmedia)

      ; fnOutputDebug("Hiding hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("hide", hGDIwin)
      ; fnOutputDebug("Showing hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("show", hGDIthumbsWin)
      fnOutputDebug("Recalculating thumbnail sizes")
      recalculateThumbsSizes()
      UpdateThumbsScreen()
      fnOutputDebug("hGDIinfosWin cleaned...  " hGDIinfosWin "  -- G= " 2NDglPG "  -- hDC= " 2NDglHDC " ")
      clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
      interfaceThread.ahkPostFunction("UpdateUiStatusBar", 0, 0, "list")
      RemoveTooltip()
      lastTimeToggleThumbs := A_TickCount
   }

   SetTimer, TriggerMenuBarUpdate, -250
   lastInvoked := A_TickCount
}

TriggerMenuBarUpdate() {
   If (showMainMenuBar!=1)
      Return

   lastMenuBarUpdated := A_TickCount
   fnOutputDebug("Updating menu bar")
   interfaceThread.ahkassign("thumbsDisplaying", thumbsDisplaying)
   interfaceThread.ahkPostFunction("UpdateMenuBar")
}

defineThumbsAratio() {
  friendly := (thumbsAratio=1) ? "Wide (1.81)" : "Tall (0.48)"
  If (thumbsAratio=3)
     friendly := "Square (1.00)"

  Return friendly
}

recalculateThumbsSizes() {
   If (thumbsAratio=1)
   {
      othumbsW := 300
      othumbsH := 165
   } Else If (thumbsAratio=2)
   {
      othumbsW := 144
      othumbsH := 300
   } Else If (thumbsAratio=3)
   {
      othumbsW := 300
      othumbsH := 300
   }
 
   If (thumbsZoomLevel<0.35)
     thumbsZoomLevel := 0.35
   Else If (thumbsZoomLevel>3)
     thumbsZoomLevel := 3
 
   thumbsH := Round(othumbsH*thumbsZoomLevel)
   thumbsW := Round(othumbsW*thumbsZoomLevel)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If (thumbsH>mainHeight || thumbsW>mainWidth)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//2 - 16, mainHeight//2 - 16, ResizedW, ResizedH)
      If ResizedH
         thumbsH := ResizedH
      If ResizedW
         thumbsW := ResizedW
   }

   If (thumbsColumns>0 && dynamicThumbsColumns=0)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//thumbsColumns, mainHeight, ResizedW, ResizedH)
      z := Round(mainHeight/ResizedH)
      If z
         thumbsH := mainHeight//z
      If ResizedW
         thumbsW := ResizedW

      thumbsW := clampInRange(thumbsW, 80 + Round(OSDfntSize/9), 2048)
      thumbsH := clampInRange(thumbsH, 80 + Round(OSDfntSize/9), 2048)
   }

   If isInRange(max(thumbsW, thumbsH), 0, 150)
      thumbsSizeQuality := 125
   Else If isInRange(max(thumbsW, thumbsH), 151, 290)
      thumbsSizeQuality := 245
   Else If (max(thumbsW, thumbsH)>650)
      thumbsSizeQuality := 755
   Else
      thumbsSizeQuality := 500

   If (thumbnailsListMode=1)
   {
      Static theString := "WAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAW", prevDimensions, columnsPossible
      theseDimensions := mainWidth "=" mainHeight "=" OSDfntSize "=" OSDFontName
      If (prevDimensions!=theseDimensions)
      {
         xBitmap := trGdip_CreateBitmap(A_ThisFunc, 30, 30)
         G := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
         borderSize := Floor(OSDfntSize*1.15)//4.5
         txtOptions := "x" borderSize " y" borderSize A_Space " Left cEE090909 r1 s" OSDfntSize
         dimensions := Gdip_TextToGraphics(G, theString, txtOptions, OSDFontName, mainWidth, mainHeight, 0, 0)
         txtRes := StrSplit(dimensions, "|")
         txtResW := Ceil(txtRes[3]) + borderSize*2
         Gdip_DeleteGraphics(G)
         trGdip_DisposeImage(xBitmap, 1)
         columnsPossible := Round(mainWidth/txtResW)
         prevDimensions := mainWidth "=" mainHeight "=" OSDfntSize "=" OSDFontName
      }

      thumbsW := mainWidth//columnsPossible - 15
      If (thumbsListViewMode=1)
         thumbsH := Round((OSDfntSize//1.25 + imgHUDbaseUnit//9) * 2.5)
      Else
         thumbsH := Round((OSDfntSize//1.25 + imgHUDbaseUnit//9) * 3.55)
   }
}


ChangeThumbsAratio() {
  If (thumbsDisplaying!=1)
     Return

  If (thumbnailsListMode=1)
  {
     ToggleImgNavSizeBox()
     Return
  }

  thumbsAratio++
  If (thumbsAratio>3)
     thumbsAratio := 1

  recalculateThumbsSizes()
  showTOOLtip("Thumbnails aspect ratio: " defineThumbsAratio() "`nSize: " thumbsW " x " thumbsH " (pixels)")
  SetTimer, RemoveTooltip, % -msgDisplayTime
  INIaction(1, "thumbsAratio", "General")
  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(90)
}

thumbsInfoYielder(ByRef maxItemsW, ByRef maxItemsH, ByRef maxItemsPage, ByRef maxPages, ByRef startIndex, ByRef mainWidth, ByRef mainHeight) {
   Static prevRealThumbsIndex := -1
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0) ; global vars:
   maxItemsW := mainWidth//thumbsW               ;    prevStartIndex
   If (maxItemsW<4 && thumbnailsListMode!=1)
      maxItemsW := mainWidth//Round(thumbsW*0.95)

   maxItemsH := mainHeight//thumbsH              ;    startPageIndex
   If (maxItemsH<7 && thumbnailsListMode!=1)
      maxItemsH := mainHeight//Round(thumbsH*0.95)

   If (maxItemsW<2)                                   ;    currentFileIndex ---
      maxItemsW := 1
   If (maxItemsH<2)
      maxItemsH := 1
 
   maxItemsPage := maxItemsW*maxItemsH
   maxPages := Ceil(maxFilesIndex/maxItemsPage)
   If (maxItemsH=1 && maxItemsW>1)
   {
      hasReversed := 1
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   maxItemsLine := maxItemsW ; *maxItemsH
   maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
   If (maxItemsW=1)
   {
      startIndex := Floor(currentFileIndex/maxItemsLine) * maxItemsLine
      If (startIndex<2)
         startIndex := 1

      ; ToolTip, % startIndex  " -- " prevRealThumbsIndex " || " maxItemsW " -- " maxItemsH , , , 2
      If isInRange(startIndex, prevRealThumbsIndex + maxItemsPage*2, prevRealThumbsIndex - maxItemsPage)
      {
         If isInRange(startIndex, prevRealThumbsIndex, prevRealThumbsIndex + maxItemsPage - maxItemsW)
            startIndex := prevRealThumbsIndex
         Else
            startIndex := (startIndex<prevRealThumbsIndex) ? startIndex : startIndex - maxItemsPage + maxItemsW
      } Else startIndex := Floor(currentFileIndex/maxItemsPage) * maxItemsPage

      maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      prevRealThumbsIndex := startIndex
   } Else
   {
      If (prevRealThumbsIndex=-1)
         prevRealThumbsIndex := currentFileIndex - maxItemsPage//2

      minIndex := prevRealThumbsIndex
      minIndex := ((minIndex//maxItemsLine) * maxItemsLine) + 1
      If (prevRealThumbsIndex != minIndex)
         prevRealThumbsIndex := minIndex
      
      maxIndex := prevRealThumbsIndex + maxItemsPage - 1
      ; DebugMsg("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; DebugMsg("diff check: " Abs(currentFileIndex-minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex-maxIndex) " / " maxItemsLine)
      ; fnOutputDebug("min/max Index: " minIndex " / " maxIndex)
      ; fnOutputDebug("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; fnOutputDebug("diff check: " Abs(currentFileIndex-minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex-maxIndex) " / " maxItemsLine)
      If (Abs(currentFileIndex-minIndex) <= maxItemsLine) || (Abs(currentFileIndex-maxIndex) <= maxItemsLine) || (currentFileIndex>=minIndex && currentFileIndex<=maxIndex)
      { ; just scrolling
          If (currentFileIndex< minIndex)     ; scrolling up
          {
             startIndex := prevRealThumbsIndex-maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("1: startIndex: " startIndex)
          } Else If (currentFileIndex>maxIndex) ; scrolling down
          {
             startIndex := prevRealThumbsIndex+maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("2: startIndex: " startIndex)
          } Else  ; when changing img index but not changing pages
          {
             startIndex := prevRealThumbsIndex
             ; fnOutputDebug("3: startIndex: " startIndex)
          }
      } Else ; this is for a jump
      {
         thisIndexu := currentFileIndex/maxFilesIndex
         startIndex := Floor(maxTotalLines*thisIndexu)*maxItemsW
         ; startIndex := ((currentFileIndex//maxItemsLine) * maxItemsLine) + 1
         prevRealThumbsIndex := startIndex
         ; fnOutputDebug("4: startIndex: " startIndex)
      }

      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      ; maxuStartIndex := (maxFilesIndex>maxItemsPage) ? maxFilesIndex - maxItemsPage + 1 : maxFilesIndex - 1
      ; fnOutputDebug(startIndex  "s -- " prevRealThumbsIndex "p -- " maxuStartIndex " || " maxItemsW "w -- h" maxItemsH)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      prevRealThumbsIndex := clampInRange(prevRealThumbsIndex, 1, maxuStartIndex)
   }
   If (hasReversed=1)
   {
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   ; DebugMsg("basics:`r`nmaxItemsPage: " maxItemsPage "`r`nmaxItemsLine: " maxItemsLine "`r`nmin: " minIndex "`r`nmax: " maxIndex "`r`ncurrentFileIndex : " currentFileIndex "`r`n")
   Return "a" startIndex maxItemsW maxItemsH maxItemsPage
}

DeepRefreshThumbsNow() {
   If (markedSelectFile>1)
      setForceRefreshThumbsFilesIndex(1)
   Else
      setForceRefreshThumbsFilesIndex(0)

   dummyTimerDelayiedImageDisplay(50)
}

RefreshThumbsList() {
   mustReloadThumbsList := 1
   dummyTimerDelayiedImageDisplay(50)
}

ForceRefreshNowThumbsList() {
   ; mustReloadThumbsList := 1
   prevStartIndex := -1
   ; dummyTimerDelayiedImageDisplay(50)
}

UpdateThumbsScreen(forceReload:=0) {
   Critical, on
   Static lastInvoked := 1, lastInvokeReload := 1
   SetTimer, dummyTimerDelayiedImageDisplay, Off
   SetTimer, dummyTimerReloadThisPicture, Off
   thumbsDisplaying := 1
   Gdip_ResetClip(glPG)
   interfaceThread.ahkassign("thumbsDisplaying", 1)
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   startPageIndex := thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
   createGDIPcanvas(mainWidth, mainHeight)
   Gdip_ResetWorldTransform(glPG)
   IMGlargerViewPort := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   mustShowNames := 0
   ;  ToolTip, % lastInvokeReload , , , 2
   If (A_TickCount - prevTryThumbsUpdate<200) && (mustReloadThumbsList!=1 && thumbnailsListMode!=1 && startPageIndex!=prevFullIndexThumbsUpdate)
   {
      ; lastInvokeReload++
      mustShowNames := 1
      ; If (startPageIndex!=prevFullIndexThumbsUpdate)
      prevFullThumbsUpdate := A_TickCount
      SetTimer, RefreshThumbsList, -300
   }

   mainGdipWinThumbsGrid(0, mustShowNames)
   If (mustShowNames!=1 && (prevStartIndex!=startPageIndex || mustReloadThumbsList=1 || forceReload=1))
   {
      r := QPV_ShowThumbnails()
      If r
         prevFullIndexThumbsUpdate := startPageIndex
      
      mustReloadThumbsList := 0
   } ; Else r := 1

   prevStartIndex := startPageIndex
   ; prevRealThumbsIndex := startIndex
   lastInvoked := A_TickCount
}

GDIwindowsPosCorrections(whichHwnd:="") {
    Static lastInvoked := 1
    If (A_OSVersion="WIN_7" || isWinXP=1) && (A_TickCount - lastInvoked>150) || (isWinXP=1 && editingSelectionNow=1)
    {
       GetPhysicalCursorPos(mainX, mainY)
       JEE_ClientToScreen(hPicOnGui1, 1, 1, mainX, mainY)
       If whichHwnd
       {
          WinMove, ahk_id %whichHwnd%,, %mainX%, %mainY%
       } Else
       {
          WinMove, ahk_id %hGDIwin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIthumbsWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIselectWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIinfosWin%,, %mainX%, %mainY%
       }
       lastInvoked := A_TickCount
    } Else If (A_OSVersion="WIN_7" || isWinXP=1)
       SetTimer, GDIwindowsPosCorrections, -50
}

panIMGonScrollBar() {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()
   GetMouseCoord2wind(PVhwnd, oX, oY)
   oDx := IMGdecalageX
   oDy := IMGdecalageY

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   While, (determineLClickstate()=1)
   {
      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (imageAligned=5)
      {
         prcW := (prcW>0.5) ? prcW - 0.5 : 0.5 - prcW
         prcH := (prcH>0.5) ? prcH - 0.5 : 0.5 - prcH
      }
      decX := Round(((imgW)*prcW) * zoomLevel)
      decY := Round(((imgH)*prcH) * zoomLevel)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (prcW>0.5 || imageAligned=1)
         decX := -decX
      If (prcH>0.5 || imageAligned=1)
         decY := -decY

      If (scrollAxis=1)
      {
         newDecX := (FlipImgH=1) ? -decX : decX
         IMGdecalageX := (A_Index=1) ? (newDecX + oDx)//2 : newDecX
         diffIMGdecX := mX - oX + 2
      } Else
      {
         newDecY := (FlipImgV=1) ? -decY : decY
         IMGdecalageY := (A_Index=1) ? (newDecY + oDy)//2 : newDecY
         diffIMGdecY := mY - oY + 2
      }

      If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
         coreReloadThisPicture()
      Else
         filterDelayiedImageDisplay()
      If (A_Index<3)
        Sleep, 50
   }
   diffIMGdecX := diffIMGdecY := 0
}

ThumbsScrollbar() {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   prevFileIndex := currentFileIndex
   While, (determineLClickstate()=1)
   {
      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      newIndex := ((mY-15)/mainHeight)*100
      newIndex := Ceil((maxFilesIndex/100)*newIndex)
      If (newIndex<1)
         newIndex := 1
      Else If (newIndex>maxFilesIndex)
         newIndex := maxFilesIndex-1

      currentFileIndex := newIndex
      filterDelayiedImageDisplay()
      mainGdipWinThumbsGrid(0, 1)
   }

   If (GetKeyState("Shift", "P"))
   {
      keyu := (currentFileIndex>prevFileIndex) ? "Down" : "Home"
      thumbsSelector(keyu, "+Shift", prevFileIndex)
   }

   dummyTimerDelayiedImageDisplay(250)
}

simplePanIMGonClick() {
   GetPhysicalCursorPos(oX, oY)
   oDx := IMGdecalageX
   oDy := IMGdecalageY
   lastInvoked := A_TickCount
   While, (GetKeyState("LButton", "P") || LbtnDwn=1)
   {
      GetPhysicalCursorPos(mX, mY)
      diffIMGdecX := Dx := mX - oX + 2
      diffIMGdecY := Dy := mY - oY + 2
      IMGdecalageX := (FlipImgH=1) ? oDx - Dx : oDx + Dx
      IMGdecalageY := (FlipImgV=1) ? oDy - Dy : oDy + Dy
      limitPanningDist(oDx, oDy)
      If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
         coreReloadThisPicture()
      Else
         filterDelayiedImageDisplay()
      ; ToolTip, % diffIMGdecX " == " diffIMGdecY , , , 2
      thisZeit := A_TickCount
      MouseGetPos,,, OutputVarWin
      If (OutputVarWin!=PVhwnd)
      {
         If (A_TickCount - lastInvoked>1550)
            Break
      } Else lastInvoked := A_TickCount
   }
   diffIMGdecX := diffIMGdecY := 0
   ResetImgLoadStatus()
}

limitPanningDist(ByRef oDx, ByRef oDy) {
   If (imageAligned=5)
   {
      If (oDx>0 && Abs(oDx)>Abs(imgDecLX//2))
         oDx := -imgDecLX//2
      Else If (oDx<0 && Abs(oDx)>Abs(imgDecLX//2))
         oDx := imgDecLX//2

      If (oDy>0 && Abs(oDy)>Abs(imgDecLY//2))
         oDy := -imgDecLY//2
      Else If (oDy<0 && Abs(oDy)>Abs(imgDecLY//2))
         oDy := imgDecLY//2
   } Else
   {
      If (oDx>=0)
         oDx := 0
      Else If (oDx<imgDecLX)
         oDx := imgDecLX

      If (oDy>=0)
         oDy := 0
      Else If (oDy<imgDecLY)
         oDy := imgDecLY
   }
}

panIMGonClick() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If isWinXP
   {
      simplePanIMGonClick()
      Return
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Sleep, 0
   GetPhysicalCursorPos(oX, oY)
   newPosZeit := A_TickCount
   oDx := IMGdecalageX, oDy := IMGdecalageY
   zX := oX, zY := oY
   thisZeit := A_TickCount
   While, (determineLClickstate()=1)
   {
      Sleep, 2
      GetPhysicalCursorPos(mX, mY)
      skipLoop := (isInRange(mX, zX - 5, zX + 5) && isInRange(mY, zY - 5, zY + 5)) ? 1 : 0
      diffIMGdecX := Dx := mX - oX + 2
      diffIMGdecY := Dy := mY - oY + 2
      IMGdecalageX := (FlipImgH=1) ? oDx - Dx : oDx + Dx
      IMGdecalageY := (FlipImgV=1) ? oDy - Dy : oDy + Dy
      ; ToolTip, % diffIMGdecX "--" diffIMGdecY " || " IMGdecalageX "--" IMGdecalageY " || " odX "--" odY , , , 2
      If (A_TickCount - newPosZeit>950) || (mX=oX && mY=oY)
      {
         newPosZeit := A_TickCount
         zX := mX, zY := mY
         If (skipLoop=1)
            Continue
      } Else If (skipLoop=1)
         Continue

      MouseMove, % oX, % oY, 0
      oDx := IMGdecalageX, oDy := IMGdecalageY
      limitPanningDist(oDx, oDy)
      If (A_TickCount - thisZeit>15) || (drawModeAzeit<100) || (drawModeBzeit<100)
      {
         ; If (A_TickCount - thisZeit>95)
         zeitSillyPrevent := A_TickCount
         If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
            coreReloadThisPicture()
         Else
            filterDelayiedImageDisplay()
         thisZeit := A_TickCount
      }
   }
   diffIMGdecX := diffIMGdecY := 0
   dummyTimerReloadThisPicture(70)
   SetTimer, ResetImgLoadStatus, -100
}

winSwipeAction(thisCtrlClicked) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   didSomething := 1
   infoImgEditingMode := (editingSelectionNow=1 || imgEditPanelOpened=1) ? 1 : 0
   GetPhysicalCursorPos(oX, oY)
   If (IMGlargerViewPort=1 && thumbsDisplaying!=1 && thisCtrlClicked="PicOnGUI2b")
   || (IMGlargerViewPort=1 && thumbsDisplaying!=1 && (thisCtrlClicked="PicOnGUI3" || thisCtrlClicked="PicOnGUI1") && infoImgEditingMode=1)
   {
      SetTimer, panIMGonClick, -15
      Return 0
   }

   lowerLimitRatio := (IMGresizingMode=4) ? 0.4 : 0.2
   While, (determineLClickstate()=1)
   {
      GetPhysicalCursorPos(mX, mY)
      diffx := Abs(mX - oX)
      diffy := Abs(mY - oY)
      dirX := (mX - oX) < 0 ? -1 : 1
      dirY := (mY - oY) < 0 ? -1 : 1
      ratioDiffs := diffx/diffy
      If (diffx>45 || diffy>45) && (ratioDiffs<lowerLimitRatio || ratioDiffs>3)
      {
         Sleep, 5
         zeitSillyPrevent := A_TickCount
         swipeAct := (ratioDiffs<lowerLimitRatio) ? 1 : 2
         If (ratioDiffs="")
            swipeAct := 0
         ; ToolTip, % swipeAct " - " thisCtrlClicked " - " ratioDiffs 
      } Else swipeAct := 0 ;  Tooltip
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If !swipeAct
   {
      zeitSillyPrevent := 1
      If (thisCtrlClicked="PicOnGUI3")
      {
         ; If (imgEditPanelOpened=1)
         ;    ImgRedoAction()
         If (infoImgEditingMode!=1)
            GoNextSlide()
         Else didSomething := 0
      } Else If (thisCtrlClicked="PicOnGUI1" )
      {
         ; If (imgEditPanelOpened=1)
         ;    ImgUndoAction()
         If (infoImgEditingMode!=1)
            GoPrevSlide()
         Else didSomething := 0
      } Else If (thisCtrlClicked="PicOnGUI2a" || thisCtrlClicked="PicOnGUI2c")
      {
         regSize := (editingSelectionNow=1) ? 7 : 5
         If (oY<mainHeight//regSize)
            ChangeZoom(1)
         Else If (oY>mainHeight - mainHeight//regSize)
            ChangeZoom(-1)
      } Else didSomething := 0
   } Else If (swipeAct=1)
   {
      stepFactor := (diffy/mainHeight)*1.65 + 1.25
      ChangeZoom(dirY, 0, stepFactor)
   } Else If (swipeAct=2 && infoImgEditingMode!=1)
   {
      If (dirX=1)
         GoNextSlide()
      Else If (dirX=-1)
         GoPrevSlide()
      Else didSomething := 0
   } Else didSomething := 0

   If !didSomething
      zeitSillyPrevent := 1

   Return didSomething
}

GetMouseCoord2wind(hwnd, ByRef nx, ByRef ny) {
    ; CoordMode, Mouse, Screen
    MouseGetPos, ox, oy
    JEE_ScreenToClient(hwnd, ox, oy, nx, ny)
}

dummyAutoClearSelectionHighlight() {
    GetMouseCoord2wind(hGDIwin, mX, mY)
    Gdip_SetPenWidth(pPen1d, SelDotsSize)
    hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
    If !hitB
    {
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
       pathBounds := Gdip_GetPathWorldBounds(hitTestSelectionPath)
       Gdip_FillEllipse(2NDglPG, pBrushD, pathBounds.x + pathBounds.w//2 - SelDotsSize//3, pathBounds.y + pathBounds.h//2 - SelDotsSize//3, SelDotsSize*0.7, SelDotsSize*0.7)
       Gdip_SetPenWidth(pPen1d, SelDotsSize//3)
       Gdip_DrawPath(2NDglPG, pPen1d, hitTestSelectionPath)
       r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
   }
}

LrydWinUpdt(hwnd, HDCu, opacity:=255) {
  Static xPox := 0, yPos := 0
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  If (A_OSVersion="WIN_7" || isWinXP=1)
  {
     ; GetPhysicalCursorPos(mainX, mainY)
     JEE_ClientToScreen(hPicOnGui1, 1, 1, xPos, yPos)
     ; WinMove, ahk_id %whichHwnd%,, %mainX%, %mainY%
  }

  Return UpdateLayeredWindow(hwnd, HDCu, xPos, yPos, mainWidth, mainHeight, opacity)
}

MouseMoveResponder() {
  Static prevState := "C"
  If (A_TickCount - lastOSDtooltipInvoked<625)
  {
     SetTimer, MouseMoveResponder, -350
     Return
  }

  If (StrLen(hitTestSelectionPath)>2 && editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1 && drawingShapeNow!=1)
  {
     ; ToolTip, % SelDotsSize , , , 2
     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     GetMouseCoord2wind(hGDIwin, mX, mY)
     hitA := Gdip_IsVisiblePathPoint(hitTestSelectionPath, mX, mY, 2NDglPG)
     Gdip_SetPenWidth(pPen1d, SelDotsSize)
     hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
     If (hitB=1)
        thisState := "B"
     Else If (hitA=1)
        thisState := "A"
     Else
        thisState := "C"

     If (thisState="B") ; && prevState!=thisState)
     {
        ; changeMcursor("finger")
        prevState := "B"
        trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
        dotActiveObj := determineSelAreaClickRect(mX, mY, SelDotsSize, mainWidth, mainHeight)
        Gdip_SetPenWidth(pPen1d, SelDotsSize//2)
        If (dotActiveObj.n=9)
        {
           Gdip_DrawPath(2NDglPG, pPen1d, hitTestSelectionPath)
        } Else
        {
           If InStr(dotActiveObj.cx1, "|")
           {
              Gdip_DrawLines(2NDglPG, pPen1d, dotActiveObj.cx1)
              Gdip_FillEllipse(2NDglPG, pBrushC, dotActiveObj.cx2 - SelDotsSize//2, dotActiveObj.cy2 - SelDotsSize//2, SelDotsSize*2, SelDotsSize*2)
           } Else
              Gdip_DrawLine(2NDglPG, pPen1d, dotActiveObj.cx1, dotActiveObj.cy1, dotActiveObj.cx2, dotActiveObj.cy2)
        }
        r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
     } Else If (thisState="A" && prevState!=thisState)
     {
        ; changeMcursor("move")
        prevState := "A"
        Gdip_SetPenWidth(pPen1d, SelDotsSize//2)
        trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
        pathBounds := Gdip_GetPathWorldBounds(hitTestSelectionPath)
        Gdip_FillEllipse(2NDglPG, pBrushD, pathBounds.x + pathBounds.w//2 - SelDotsSize//3, pathBounds.y + pathBounds.h//2 - SelDotsSize//3, SelDotsSize*0.7, SelDotsSize*0.7)
        Gdip_FillPath(2NDglPG, pBrushF, hitTestSelectionPath)
        Gdip_DrawPath(2NDglPG, pPen1d, hitTestSelectionPath)
        r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
        SetTimer, dummyAutoClearSelectionHighlight, -150
     } Else If (thisState="C" && prevState!=thisState)
     {
        clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevState := "C"
     }
  } Else
  {
     If (prevState!="C")
        clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
     prevState := "C"
  }
}

applyIMGeditKeepWin() {
   o := closeEditPanelOnApply
   closeEditPanelOnApply := 0
   GuiControl, SettingsGUIA:, closeEditPanelOnApply, 0
   applyIMGeditFunction()
   Sleep, 2
   CreateGuiButton("Undo action,,ImgUndoAction||Reopen panel,,openPreviousPanel", 0, msgDisplayTime//1.5 + 500)
   closeEditPanelOnApply := o
   GuiControl, SettingsGUIA:, closeEditPanelOnApply, % o
}

applyIMGeditFunction() {
    ; recordSelUndoLevelNow()
    If (AnyWindowOpen=24 || AnyWindowOpen=31)
       BtnPasteInSelectedArea()
    Else If (AnyWindowOpen=30)
       BtnDrawLinesSelectedArea()
    Else If (AnyWindowOpen=32)
       BtnInsertTextSelectedArea()
    Else If (AnyWindowOpen=23)
       BtnFillSelectedArea()
    Else If (AnyWindowOpen=25)
       BtnEraseSelectedArea()
    Else If (AnyWindowOpen=55)
       BtnGraySelectedArea()
    Else If (AnyWindowOpen=10) ; colors adjustments
       BtnCloseWindow()
    SetTimer, RemoveTooltip, -300
}

livePreviewsImageEditing(directCall:=0, hideHUD:=0) {
   Static toggleThisu := 0
   If (hideHUD=2 && imgEditPanelOpened=1 && directCall=1 && toggleThisu!=1)
   {
      toggleThisu := 1
      clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIselectwin)
      Return
   }

   If (imgEditPanelOpened!=1)
      Return

   toggleThisu := 0
   If (directCall=1 || scrollBarHy>0 || scrollBarVx>0)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

   If (directCall=1)
      setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)

   If (AnyWindowOpen=24 || AnyWindowOpen=31)
      corePasteInPlaceActNow(0, 0)
   Else If (AnyWindowOpen=30)
      coreDrawLinesSelectionArea()
   Else If (AnyWindowOpen=23)
      coreFillSelectedArea()
   Else If (AnyWindowOpen=32)
      livePreviewInsertTextinArea()
   Else If (AnyWindowOpen=25)
      livePreviewEraseArea()
   Else If (AnyWindowOpen=55)
      livePreviewDesaturateArea()

   If (hideHUD!=1 && AnyWindowOpen!=32)
      livePreviewsImageEditingDrawSelectionBox()

   If (directCall=1)
   {
      Gdip_ResetWorldTransform(2NDglPG)
      r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
   }

   If (scrollBarHy>0)
   {
      Gdip_SetClipRect(2NDglPG, 0, scrollBarHy, mainWidth, mainHeight - scrollBarHy)
      trGdip_GraphicsClear(A_ThisFunc, 2NDglPG)
   }

   If (scrollBarVx>0)
   {
      Gdip_SetClipRect(2NDglPG, scrollBarVx, 0, mainWidth - scrollBarVx, mainHeight)
      trGdip_GraphicsClear(A_ThisFunc, 2NDglPG)
   }

   If (scrollBarHy>0 || scrollBarVx>0)
      Gdip_ResetClip(2NDglPG)
}

livePreviewsImageEditingDrawSelectionBox() {
   dotsSize := SelDotsSize
   vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
   vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
   vPimgSelX := min(selDotX, selDotAx) + dotsSize//2
   vPimgSelY := min(selDotY, selDotAy) + dotsSize//2
 
   whichFunc := (vPselRotation!=0) ? "Ellipse" : "Rectangle"
   Gdip_Fill%whichFunc%(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
   Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
   Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
   Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
   If (vPselRotation!=0)
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)

   If (imgEditPanelOpened=1)
   {
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)
      Gdip_FillEllipse(2NDglPG, pBrushA, SelDotDx + 5, SelDotDy + 5, dotsSize, dotsSize)
   }

   thisThick := dotsSize//5 + 1
   Gdip_SetPenWidth(pPen4, thisThick)
   Gdip_SetPenWidth(pPen1d, thisThick)
   angleu := (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=55) ? VPselRotation : 0
   ImgSelPath := createImgSelPath(vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio)
   If (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=55)
      Gdip_DrawPath(2NDglPG, pPen4, ImgSelPath)

   Gdip_DrawRectangle(2NDglPG, pPen4, vPimgSelX + thisThick//3, vPimgSelY + thisThick//3, vPimgSelW, vPimgSelH)
   Gdip_DrawPath(2NDglPG, pPen1d, ImgSelPath)
   Gdip_DrawRectangle(2NDglPG, pPen4, vPimgSelX + thisThick//2, vPimgSelY + thisThick//2, vPimgSelW, vPimgSelH)
   Gdip_DeletePath(ImgSelPath)
}

selectFileLongTap() {
   If (thumbsDisplaying=1 && determineLClickstate() && (A_TickCount - lastOtherWinClose>350) && (A_TickCount - lastTimeToggleThumbs>350))
      markThisFileNow(currentFileIndex)
}

isDotInRect(mX, mY, x1, x2, y1, y2) {
  r := (isInRange(mX, x1, x2) && isInRange(mY, y1, y2)) ? 1 : 0
  Return r
}

determineSelAreaClickRect(mXoT, mYoT, dotsSize, mainWidth, mainHeight) {
   nSelDotX  := selDotX,  nSelDotAx := selDotAx
   nSelDotY  := selDotY,  nSelDotAy := selDotAy
   nSelDotBx := selDotBx, nSelDotCx := selDotCx
   nSelDotBy := selDotBy, nSelDotCy := selDotCy
   nSelDotDx := selDotDx, nSelDotDy := selDotDy

   If (FlipImgH=1)
   {
      nSelDotX := mainWidth - selDotX - dotsSize
      nSelDotAx := mainWidth - selDotAx - dotsSize
      nSelDotBx := mainWidth - selDotBx - dotsSize
      nSelDotCx := mainWidth - selDotCx - dotsSize
      nSelDotDx := mainWidth - selDotDx - dotsSize
   }

   If (FlipImgV=1)
   {
      nSelDotY := mainHeight - selDotY - dotsSize
      nSelDotAy := mainHeight - selDotAy - dotsSize
      nSelDotBy := mainHeight - selDotBy - dotsSize
      nSelDotCy := mainHeight - selDotCy - dotsSize
      nSelDotDy := mainHeight - selDotDy - dotsSize
   }
   d := dotsSize//2
   If isDotInRect(mXoT, mYoT, nselDotX, nselDotX + dotsSize, nselDotY, nselDotY + dotsSize)
   {
      cX1 := nselDotBx + d "," nselDotBy + d "|"
      cX1 .= nselDotX + d "," nselDotY + d "|"
      cX1 .= nselDotCx + d "," nselDotCy + d
      cX2 := nselDotX
      cY2 := nselDotY
      dotActive := 1
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotAx, nselDotAx + dotsSize, nselDotAy, nselDotAy + dotsSize)
   {
      cX1 := nselDotBx + d "," nselDotBy + d "|"
      cX1 .= nselDotAx + d "," nselDotAy + d "|"
      cX1 .= nselDotCx + d "," nselDotCy + d
      cX2 := nselDotAx
      cY2 := nselDotAy
      dotActive := 2
      DotPosX := imgSelX2
      DotPosY := imgSelY2
   } Else If isDotInRect(mXoT, mYoT, nselDotBx, nselDotBx + dotsSize, nselDotAy, nselDotBy + dotsSize)
   {
      cX1 := nselDotBx + dotsSize//2
      cX2 := nselDotBx + dotsSize//2
      cY1 := nselDotAy
      cY2 := nselDotBy
      dotActive := 8
      DotPosX := imgSelX2
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotCx, nselDotCx + dotsSize, nselDotCy, nselDotCy + dotsSize)
   {
      cX1 := nselDotX + d "," nselDotY + d "|"
      cX1 .= nselDotCx + d "," nselDotCy + d "|"
      cX1 .= nselDotAx + d "," nselDotAy + d
      cX2 := nselDotCx
      cY2 := nselDotCy
      dotActive := 4
      DotPosX := imgSelX1
      DotPosY := imgSelY2
   } Else If isDotInRect(mXoT, mYoT, nselDotX, nselDotBx, nselDotY, nselDotY + dotsSize)
   {
      cX1 := nselDotX
      cX2 := nselDotBx
      cY1 := nselDotY + dotsSize//2
      cY2 := nselDotY + dotsSize//2
      dotActive := 5
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotCx, nselDotBx, nselDotCy, nselDotCy + dotsSize)
   {
      cX1 := nselDotCx
      cX2 := nselDotBx
      cY1 := nselDotCy + dotsSize//2
      cY2 := nselDotCy + dotsSize//2
      dotActive := 6
      DotPosX := imgSelX1
      DotPosY := imgSelY2
   } Else If isDotInRect(mXoT, mYoT, nselDotX, nselDotX + dotsSize, nselDotY, nselDotCy)
   {
      cX1 := nselDotX + dotsSize//2
      cX2 := nselDotX + dotsSize//2
      cY1 := nselDotY
      cY2 := nselDotCy
      dotActive := 7
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotBx, nselDotBx + dotsSize, nselDotBy, nselDotAy)
   {
      cX1 := nselDotX + d "," nselDotY + d "|"
      cX1 .= nselDotBx + d "," nselDotBy + d "|"
      cX1 .= nselDotAx + d "," nselDotAy + d 
      cX2 := nselDotBx
      cY2 := nselDotBy
      dotActive := 3
      DotPosX := imgSelX2
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotDx, nselDotDx + dotsSize, nselDotDy, nselDotDy + dotsSize)
   {
      ; click the center dot of the selection area
      cX1 := nselDotDx
      cX2 := nselDotDx + dotsSize
      cY1 := nselDotDy
      cY2 := nselDotDy + dotsSize
      dotActive := 10
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mXoT, mYoT, nselDotX, nselDotBx, nselDotBy, nselDotAy)
   {
      ; click anywhere within the selection
      cX1 := nselDotX
      cX2 := nselDotBx
      cY1 := nselDotBy
      cY2 := nselDotAy
      dotActive := 9
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   }
   ; ToolTip, % "l=" dotActive , , , 2
   obju := []
   obju.x := DotPosX
   obju.y := DotPosY
   obju.n := dotActive
   obju.cX1 := cX1
   obju.cX2 := cX2
   obju.cY1 := cY1
   obju.cY2 := cY2
   Return obju
}

WinClickAction(mainParam:=0, thisCtrlClicked:=0) {
   Critical, on
   Static thisZeit := 1, prevTippu := 1, anotherZeit := 1
        , lastInvoked := 1, lastInvoked2 := 1, lastInvokedSwipe := 1

   If (AnyWindowOpen=1 || AnyWindowOpen=33 || AnyWindowOpen=39 || AnyWindowOpen=44 || AnyWindowOpen=48)
   {
      BtnCloseWindow()
      Return
   } Else If (AnyWindowOpen=43 || AnyWindowOpen=44 || AnyWindowOpen=26)
   {
      ; respond to clicks in viewport for panels with region based previews
      tinyPrevAreaCoordX := tinyPrevAreaCoordY := "C"
      dummyTimerDelayiedImageDisplay(50)
      Return
   }

   ; ToolTip, % mainParam " -- " thisCtrlClicked,,,2
   If (A_TickCount - lastLongOperationAbort < 550) || (A_TickCount - lastTimeToggleThumbs < 450) || (A_TickCount - executingCanceableOperation < 550)
      Return

   If (TouchScreenMode=1 && thumbsDisplaying=1)
      SetTimer, selectFileLongTap, Off

   If AnyWindowOpen
   {
      ; handle clicks in the viewport when another GUI is open
      If (imgEditPanelOpened!=1)
      {
         SoundPlay, *-1
         WinActivate, ahk_id %hSetWinGui%
         Return
      }
   }

   If (imageLoading=1 && thumbsDisplaying=1)
      Return

   MouseGetPos, , , OutputVarWin
   If (toolTipGuiCreated=1)
      RemoveTooltip()

   GetMouseCoord2wind(PVhwnd, mX, mY)
   ;  ToolTip, % HUDobjHistoBoxu[3] "==" HUDobjHistoBoxu[1] "==" mX "`n" HUDobjHistoBoxu[4] "==" HUDobjHistoBoxu[2] "==" mY , , , 2
   If (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1 && thumbsDisplaying!=1
   && isDotInRect(mX, mY, HUDobjNavBoxu[3], HUDobjNavBoxu[1] + HUDobjNavBoxu[3], HUDobjNavBoxu[4], HUDobjNavBoxu[2] + HUDobjNavBoxu[4]))
   {
      If (mainParam="DoubleClick")
      {
         ToggleImgNavSizeBox()
      } Else
      {
         While, (determineLClickstate()=1)
         {
            GetMouseCoord2wind(PVhwnd, mX, mY)
            ImageNavClickResponder(clampInRange(mX - HUDobjNavBoxu[3], 0, HUDobjNavBoxu[1]), clampInRange(mY - HUDobjNavBoxu[4], 0, HUDobjNavBoxu[2]), HUDobjNavBoxu[1], HUDobjNavBoxu[2])
            Sleep, 5
         }
      }
      Return
   } Else If (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1
   && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
   {
      If (mainParam="DoubleClick")
         ToggleImgNavSizeBox()
      Else
         Sleep, 25
      Return
   }

   If (thumbsDisplaying!=1 && drawingShapeNow!=1)
   {
      If (showHistogram>1 && imgEditPanelOpened!=1 && hasDrawnHistoMap=1
      && isDotInRect(mX, mY, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3], HUDobjHistoBoxu[4], HUDobjHistoBoxu[6] + HUDobjHistoBoxu[4]))
      {
         ToggleHistogramMode()
         Return
      } Else If (showHistogram>1 && hasDrawnImageMap=1 && hasDrawnHistoMap=1
      && isDotInRect(mX, mY, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3], HUDobjHistoBoxu[4], HUDobjHistoBoxu[2] + HUDobjHistoBoxu[4]))
      {
         If (showHistogram=6)
            showHistogram := 1
         If (mainParam="DoubleClick")
            showHistogram := 6
         ToggleImgHistogram(1)
         Return
      } 

      If (mainParam="DoubleClick" && StrLen(hitTestSelectionPath)>2 && editingSelectionNow=1 && adjustNowSel=0)
      {
         Gdip_SetPenWidth(pPen1d, SelDotsSize)
         hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
         hitA := Gdip_IsVisiblePathPoint(hitTestSelectionPath, mX, mY, 2NDglPG)
         If (hitB=1) || (hitA=1 && imgEditPanelOpened!=1 && (imgSelLargerViewPort=0 || EllipseSelectMode=2))
         {
            If (EllipseSelectMode=2 && hitB!=1)
               MenuResumeDrawingShapes()
            Else
               invokeSelectionAreaMenu("DoubleClick")
            Return
         } Else If (hitA=1 && imgEditPanelOpened!=1 && imgSelLargerViewPort=1)
         {
            toggleImgSelection()
            Return
         }
      }
   }

   If (thumbsDisplaying=1 && maxFilesIndex>0 && mainParam!="doubleclick")
   {
      ; handle clicks on thumbnails and the vertical scrollbar
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      scrollXpos := mainWidth - imgHUDbaseUnit//2
      statusBarYpos := Round(mainHeight - ThumbsStatusBarH)
      If (mX>scrollXpos)
      {
         If (mainParam!="rclick")
            SetTimer, ThumbsScrollbar, -25
         Return "scrollbar"
      } Else If (mY>statusBarYpos && noTooltipMSGs=0)
      {
         If (mainParam="rclick")
            Return "statusBar"
         Else
            ToggleMultiLineStatus()
         Return
      }

      thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
      rowIndex := 0, columnIndex := -1
      Loop, % maxItemsPage*2
      {
         columnIndex++
         If (columnIndex>=maxItemsW)
         {
            rowIndex++
            columnIndex := 0
         }
         DestPosX := thumbsW*columnIndex + thumbsW
         DestPosY := thumbsH*rowIndex + thumbsH
         If (DestPosX>mX && DestPosY>mY)
         {
            newIndex := startIndex + A_Index - 1
            Break
         }
      }

      maxWidu := maxItemsW*thumbsW - 1
      maxHeitu := maxItemsH*thumbsH  - 1

      If newIndex
      {
         If (GetKeyState("Ctrl", "P") && mainParam!="rClick")
            clickAct := "C"
         Else If (GetKeyState("Alt", "P") && mainParam!="rClick")
            clickAct := "A"
         Else If (GetKeyState("Shift", "P") && mainParam!="rClick")
            clickAct := "S"
         Else If (mainParam!="rClick" && newIndex=currentFileIndex) && (A_TickCount - lastInvoked>350)
         {
            ToggleThumbsMode()
            Return
         }

         newIndex := clampInRange(newIndex, 1, maxFilesIndex)
         If (clickAct="C")
         {
            disAllowLongTap := 1
            markThisFileNow(newIndex)
         } Else If (clickAct="A")
         {
            disAllowLongTap := 1
            moveMarkedEntryNow(newIndex)
         } Else If (clickAct="S")
         {
            disAllowLongTap := 1
            keyu := (newIndex>currentFileIndex) ? "Down" : "Upu"
            prevFileIndex := currentFileIndex
            currentFileIndex := newIndex
            thumbsSelector(keyu, "+Shift", prevFileIndex)
         } Else currentFileIndex := newIndex

         If (mainParam="rClick")
            mainGdipWinThumbsGrid()             ; DelayiedImageDisplay()
         Else
            dummyTimerDelayiedImageDisplay(25)

         longTapDelay := markedSelectFile ? 350 : 750
         If (mainParam!="rClick" && disAllowLongTap!=1 && TouchScreenMode=1)
            SetTimer, selectFileLongTap, % - longTapDelay
      }

      lastInvoked := A_TickCount
      Return
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   displayingImageNow := (thumbsDisplaying!=1 && useGdiBitmap()) ? 1 : 0
   If (mainParam="normal" && IMGlargerViewPort=1 && displayingImageNow=1 && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1) && thumbsDisplaying!=1)
   {
      ; handle H/V scrollbars for images larger than the viewport
      If (scrollBarHy>1) && ((mY>scrollBarHy && FlipImgV=0)
      || (mY<(mainHeight - scrollBarHy) && FlipImgV=1))
      {
         scrollAxis := 1
         SetTimer, panIMGonScrollBar, -25
         Return
      } Else If (scrollBarVx>1) && ((mX>scrollBarVx && FlipImgH=0)
      || (mX<(mainWidth - scrollBarVx) && FlipImgH=1))
      {
         scrollAxis := 0
         SetTimer, panIMGonScrollBar, -25
         Return
      }
   }

   spaceState := GetKeyState("Space", "P") ? 1 : 0
   If (drawingShapeNow=1 && spaceState!=1)
   {
      If (mainParam="rclick")
         stopDrawingShape()

      GetMouseCoord2wind(PVhwnd, mX, mY)
      ogmX := (FlipImgH=1) ? mainWidth - mX : mX
      ogmY := (FlipImgV=1) ? mainHeight - mY : mY
      gmX := ogmX ; + (initialDrawingStartCoords[1] - prevDestPosX)
      gmY := ogmY ; + (initialDrawingStartCoords[2] - prevDestPosY)
      Loop, % customShapePoints.Count()
      {
          thisIndex := A_Index
          c := customShapePoints[A_Index]
          xu := c[1] - (initialDrawingStartCoords[A_Index, 1] - prevDestPosX)
          yu := c[2] - (initialDrawingStartCoords[A_Index, 2] - prevDestPosY)
          If isDotInRect(ogmX, ogmY, xu - SelDotsSize//2, xu + SelDotsSize, yu - SelDotsSize//2, yu + SelDotsSize)
          {
             dontAddPoint := 1
             If (mainParam="DoubleClick")
             {
                customShapePoints[thisIndex] := [gmX + SelDotsSize, gmY + SelDotsSize]
                initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY]
                insertThis := [gmX - SelDotsSize, gmY - SelDotsSize]
                customShapePoints.InsertAt(thisIndex, insertThis)
                insertThis := [prevDestPosX, prevDestPosY]
                initialDrawingStartCoords.InsertAt(thisIndex, insertThis) 
             } Else If GetKeyState("Ctrl", "P")
             {
                customShapePoints.RemoveAt(thisIndex)
                initialDrawingStartCoords.RemoveAt(thisIndex)
             } Else
             {
                initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY]
                While, (determineLClickstate()=1)
                {
                     GetMouseCoord2wind(PVhwnd, mX, mY)
                     gmX := (FlipImgH=1) ? mainWidth - mX : mX
                     gmY := (FlipImgV=1) ? mainHeight - mY : mY
                     customShapePoints[thisIndex] := [gmX, gmY]
                     dummyRefreshImgSelectionWindow()
                }
             }
             Break
          }
      }
      ; If (FlipImgH=1 || FlipImgV=1)
         ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      If (dontAddPoint!=1 && mainParam!="DoubleClick")
      {
         If (mustSnapLiveDrawPoints=1 && thisIndex)
         {
            mustSnapLiveDrawPoints := 0
            gmX := VPstampBMPx, gmY := VPstampBMPy
         }

         mustSnapLiveDrawPoints := 0
         customShapePoints.Push([gmX, gmY])
         thisIndex := customShapePoints.MaxIndex()
         initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY]
         If (FillAreaCurveTension<3)
            SetTimer, addFluidPointsCustomShape, -200
      }

      SetTimer, dummyRefreshImgSelectionWindow, 75
      Return
   }

   If ((editingSelectionNow!=1) || (imgSelOutViewPort=1 && editingSelectionNow=1) || (imgSelLargerViewPort=1 && editingSelectionNow=1))
   && (displayingImageNow=1 && getCaptionStyle(PVhwnd)!=1 && mainParam="normal" && GetKeyState("LButton") && GetKeyState("Shift", "P"))
   {
      ; activate selection on single click + shift
      GetMouseCoord2wind(PVhwnd, mX, mY)
      MouseCoords2Image(mX - 200, mY - 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
      MouseCoords2Image(mX + 200, mY + 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
      Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
      defineRelativeSelCoords(rImgW, rImgH)
      ToggleEditImgSelection("show-edit")
      dummyTimerDelayiedImageDisplay(50)
      Return
   }

   If (mainParam="normal" && editingSelectionNow=1 && spaceState!=1 && displayingImageNow=1)
   {
      ; handle clicks on the image selection rectangle in the viewport
      mXoT := mX, mYoT := mY, dotsSize := SelDotsSize
      MouseGetPos, mXo, mYo
      zL := (zoomLevel>1) ? zoomLevel : 1/zoomLevel
      dotActiveObj := determineSelAreaClickRect(mXoT, mYoT, dotsSize, mainWidth, mainHeight)
      DotPosX := dotActiveObj.x
      DotPosY := dotActiveObj.y
      dotActive := dotActiveObj.n
      If (dotActive=10)
         anotherZeit := A_TickCount

      If (dotActive && imgSelOutViewPort=1)
      {
         dotActive := 9
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      }

      ; ToolTip, % "l=" dotActive , , , 2
      ovPselRotation := vPselRotation
      tDotPosX := DotPosX
      tDotPosY := DotPosY

      nImgSelX1 := tImgSelX1 := imgSelX1
      nImgSelY1 := tImgSelY1 := imgSelY1
      nImgSelX2 := tImgSelX2 := imgSelX2
      nImgSelY2 := tImgSelY2 := imgSelY2
      timgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      timgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      tavg := (timgSelW + timgSelH)//2
      timgSelX2 := tImgSelX1 + tavg
      timgSelY2 := tImgSelY1 + tavg
      otimgSelX2 := nImgSelX2
      otimgSelY2 := nImgSelY2
      timgSelRatio := timgSelW/timgSelH

      thisZeit := zX := zY := adjustNowSel := 1
      o_imageLoading := imageLoading
      ctrlState := (GetKeyState("Ctrl", "P") && dotActive=9) ? 1 : 0
      shiftState := GetKeyState("Shift", "P") ? 1 : 0
      altState := GetKeyState("Alt", "P") ? 1 : 0
      If (lockSelectionAspectRatio>1 && desiredSelAspectRatio && adjustGradientOffset!=1 && !altState && isInRange(dotActive, 1, 8) && !ctrlState)
         shiftState := 1

      If dotActive
      {
         drawImgSelectionOnWindow("init", 0, 0, 0, mainWidth, mainHeight)
         If isInRange(dotActive, 1, 8)
            adjustingSelDotNow := dotActive
      }

      newPosZeit := A_TickCount
      oldPosZeit := A_TickCount
      o_alphaMaskOffsetX := alphaMaskOffsetX
      o_alphaMaskOffsetY := alphaMaskOffsetY
      adjustGradientOffset := 0
      If (dotActive=9 && AnyWindowOpen=23 && !GetKeyState("Shift","P"))
      {
         GuiControlGet, FillAreaColorMode, SettingsGUIA:, FillAreaColorMode
         GuiControlGet, FillAreaDoContour, SettingsGUIA:, FillAreaDoContour
         GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
         If (CurrentPanelTab=2 && FillAreaColorMode>1 && FillAreaDoContour!=1 && FillAreaColorMode!=5)
            adjustGradientOffset := 1
      } Else If (dotActive=9 && (AnyWindowOpen=24 || AnyWindowOpen=31) && !GetKeyState("Shift","P"))
      {
         GuiControlGet, PasteInPlaceAlphaMaskMode, SettingsGUIA:, PasteInPlaceAlphaMaskMode
         GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
         If (CurrentPanelTab=3 && PasteInPlaceAlphaMaskMode>1 && PasteInPlaceAlphaMaskMode!=5)
            adjustGradientOffset := 1
      }

      While, (determineLClickstate()=1 && o_imageLoading!=1 && dotActive && ctrlState=0)
      {
          MouseGetPos, mX, mY, thisWind
          skipLoop := isDotInRect(mX, mY, zX - 5, zX + 5, zY - 5, zY + 5) ? 1 : 0
          If (A_TickCount - newPosZeit>950) ; || (mX=oX && mY=oY)
          {
             newPosZeit := A_TickCount
             zX := mX, zY := mY
             If (skipLoop=1)
                Continue
          } Else If (skipLoop=1)
             Continue

          zeitSillyPrevent := A_TickCount
          changePosX := (zoomLevel>1) ? Round((mX - mXo)/zL) : Round((mX - mXo)*zL)
          changePosY := (zoomLevel>1) ? Round((mY - mYo)/zL) : Round((mY - mYo)*zL)
          If (dotActive=10)
          {
             ; center dot - selection rotation
             tW := (A_TickCount - oldPosZeit)/2150 + 0.0001
             If (tW>=1)
                tW := 1

             rotAmount := (changePosX/(mainWidth*0.9))*tW
             rotAmount := rotAmount * 360
             nvPselRotation := Round(ovPselRotation + rotAmount, 2)
             If (nvPselRotation<0 || nvPselRotation>360)
                nvPselRotation := 360 - Abs(nvPselRotation)
             vPselRotation := nvPselRotation
             ; ToolTip, % TW " -- " rotAmount " -- " nvPselRotation " -- " ovPselRotation " -- " vPselRotation  , , , 2
             If (shiftState=1)
                vPselRotation := ovPselRotation + 45
             Else If (altState=1)
                vPselRotation := 0
             vPselRotation := clampInRange(vPselRotation, 0, 360)
          } Else If (dotActive=9 && adjustGradientOffset=1)
          {
             ; anywhere within selection click
             coords := 10
             movX := (FlipImgH=1) ? - changePosX/(mainWidth*1.2) : changePosX/(mainWidth*1.2)
             movY := (FlipImgV=1) ? - changePosY/(mainHeight*1.2) : changePosY/(mainHeight*1.2)
             alphaMaskOffsetX := clampInRange(o_alphaMaskOffsetX + movX, -0.9, 0.9)
             alphaMaskOffsetY := clampInRange(o_alphaMaskOffsetY + movY, -0.9, 0.9)
             If (altState=1)
                alphaMaskOffsetX := alphaMaskOffsetY := o_alphaMaskOffsetX := o_alphaMaskOffsetY := 0
          }

          If (shiftState=1 && dotActive=9 && adjustGradientOffset!=1)
          {
             ; drag selection
             maxPos := max(Abs(changePosX), Abs(changePosY))
             If (maxPos=Abs(changePosX))
                changePosY := 0
             Else If (maxPos=Abs(changePosY))
                changePosX := 0
          } Else If (adjustGradientOffset!=1 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; changePosX := Round(changePosX*timgSelRatio)
             If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -33000, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, 33000)
             } Else If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -33000, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, 33000)
             } Else If (dotActive=3)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -timgSelH + 2, 33000) : clampInRange(changePosY, -33000, timgSelH - 2)
             } Else If (dotActive=4)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -timgSelH + 2, 33000) : clampInRange(changePosY, -33000, timgSelH - 2)
             }
          }
 
          newSelDotX := (FlipImgH=1) ? tDotPosX - changePosX : tDotPosX + changePosX
          newSelDotY := (FlipImgV=1) ? tDotPosY - changePosY : tDotPosY + changePosY
          If (dotActive=1)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=2)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=3)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=4)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=5)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=6)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=7)
          {
             coords := 2
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=8)
          {
             coords := 2
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=9 && adjustGradientOffset!=1)
          {
             coords := 10
             imgSelX1 := (FlipImgH=1) ? nImgSelX1 - changePosX : nImgSelX1 + changePosX
             imgSelY1 := (FlipImgV=1) ? nImgSelY1 - changePosY : nImgSelY1 + changePosY
             imgSelX2 := (FlipImgH=1) ? nImgSelX2 - changePosX : nImgSelX2 + changePosX
             imgSelY2 := (FlipImgV=1) ? nImgSelY2 - changePosY : nImgSelY2 + changePosY
          }

          If (nImgSelX1>nImgSelX2 || nImgSelY1>nImgSelY2) && (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY2
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY1
          } Else If (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY1
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY2
          }
          If (imgSelX1=imgSelX2)
             imgSelX2 += 2
          If (imgSelY1=imgSelY2)
             imgSelY2 += 2

          imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
          imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          If (adjustGradientOffset!=1 && altState=1 && (dotActive=1 || dotActive=2 || dotActive=9))
          {
             ; rectangular selection mode
             avg := (imgSelW+imgSelH)//2
             If (dotActive=9)
             {
                cAvg := (changePosX+changePosY)//2
                imgSelX2 := timgSelX2 + cAvg
                imgSelY2 := timgSelY2 + cAvg
                imgSelX1 := timgSelX1 - cAvg
                imgSelY1 := timgSelY1 - cAvg
             } Else If (dotActive=2)
             {
                imgSelX2 := imgSelX1 + avg
                imgSelY2 := imgSelY1 + avg
             } Else
             {
                imgSelX1 := imgSelX2 - avg
                imgSelY1 := imgSelY2 - avg

             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          } Else If (adjustGradientOffset!=1 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; keep aspect ratio mode
             cAvg := (changePosX+changePosY)//2
             diffu := (timgSelRatio>1) ? min(timgSelW, timgSelH) : max(timgSelW, timgSelH)
             If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                imgSelX2 := clampInRange(timgSelX1 + Round((diffu + cAvg)*timgSelRatio), timgSelX1 + 5, 33000)
                imgSelY2 := clampInRange(timgSelY1 + (diffu + cAvg), timgSelY1 + 5, 33000)
             } Else If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                cAvg := -cAvg
                imgSelX1 := clampInRange(otimgSelX2 - Round((diffu + cAvg)*timgSelRatio), -33000, otimgSelX2 + 5)
                imgSelY1 := clampInRange(otimgSelY2 - (diffu + cAvg), -33000, otimgSelY2 + 5)
             } Else If (dotActive=3)
             {
                cAvg := -cAvg
                imgSelX2 := timgSelX1 + Round((diffu+cAvg)*timgSelRatio)
                imgSelY1 := otimgSelY2 - diffu - cAvg
             } Else If (dotActive=4)
             {
                ; cAvg := -cAvg
                imgSelY2 := timgSelY1 + diffu + cAvg
                imgSelX1 := otimgSelX2 - Round((diffu+cAvg)*timgSelRatio)
             }

             If (LimitSelectBoundsImg=1)
             {
                imgSelX1 := clampInRange(imgSelX1, 0, prevMaxSelX)
                imgSelY1 := clampInRange(imgSelY1, 0, prevMaxSelY)
                imgSelX2 := clampInRange(imgSelX2, 0, prevMaxSelX)
                imgSelY2 := clampInRange(imgSelY2, 0, prevMaxSelY)
             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          }

          ; ToolTip, % cAvg "=" dotActive "|" changePosX "|" changePosY "|" timgSelW "|" timgSelH , , , 2
          If (A_TickCount - thisZeit>25)
          {
             If (isInRange(dotActive, 1, 4) && noTooltipMSGs=0 && minimizeMemUsage!=1)
             {
                ARGBdec := Gdip_GetPixel(gdiBitmap, newSelDotX, newSelDotY)
                Gdip_FromARGB(ARGBdec, cA, cR, cG, cB)
                pixelColor := cR ", " cG ", " cB ", " cA
                addMsg := "`n `nCorner coordinates:`nX / Y: " newSelDotX ", " newSelDotY "`nColor: " pixelColor
             }

             theRatio := (lockSelectionAspectRatio>1) ? "`nLocked aspect ratio: " Round(desiredSelAspectRatio, 2) : "`nRatio: " Round(imgSelW/imgSelH, 2)
             ; If (imgEditPanelOpened=1)
                theRatio .= "`nRotation: " Round(vPselRotation, 2) "° "

             theMsg := "X / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) "`nW / H: " Round(imgSelW) ", " Round(imgSelH) theRatio addMsg
             If (adjustGradientOffset=1)
                theMsg := "Gradient center offset:`nX / Y: " Round(alphaMaskOffsetX, 2) ", " Round(alphaMaskOffsetY, 2) "`nGradient angle: " Round(FillAreaGradientAngle) "°"

             ; ToolTip, % theMsg, % mainX + 10, % mainY + 10
             drawImgSelectionOnWindow("live", theMsg, ARGBdec, dotActive, mainWidth, mainHeight)
             thisZeit := A_TickCount
          }
      }

      adjustingSelDotNow := adjustNowSel := 0
      If dotActive
         drawImgSelectionOnWindow("end")

      ToolTip
      If (dotActive && imgEditPanelOpened=1)
         anotherZeit := A_TickCount

      If (dotActive=9 && isInRange(Abs(changePosY), 0, 2) && isInRange(Abs(changePosX), 0, 2))
      {
         If (A_TickCount - anotherZeit<300) && (imgEditPanelOpened!=1)
            thisZeit := dotActive := ctrlState := 0
         anotherZeit := A_TickCount
      }

      If (dotActive || (A_TickCount - thisZeit<150)) && (ctrlState=0)
         Return
   }

   If (mainParam="doubleclick" && thumbsDisplaying!=1 && displayingImageNow=1 && spaceState!=1) && (A_TickCount - lastInvokedSwipe>500) && (A_TickCount - anotherZeit>600)
   {
      ; handle double clicks in the viewport when an image is being displayed
      If (editingSelectionNow=1 && imgEditPanelOpened!=1)
      {
         lastInvoked := A_TickCount
         toggleImgSelection()
         Return
      }

      lastInvoked := A_TickCount
      If (slideShowRunning=1)
         ToggleSlideShowu()
      Sleep, 1
      ToggleViewModeTouch()
   } Else If ((maxFilesIndex>1 || mustOpenStartFolder) && CurrentSLD && mainParam!="DoubleClick") && (A_TickCount - thisZeit>950)
   {
      ; handle single clicks in the viewport when multiple files are loaded
      didSomething := 0
      If (TouchScreenMode=0 || spaceState=1) && ((IMGlargerViewPort=1 || spaceState=1) && IMGresizingMode=4 && thumbsDisplaying!=1)
         SetTimer, panIMGonClick, -25
      Else If (TouchScreenMode=1 && drawingShapeNow!=1)
         didSomething := winSwipeAction(thisCtrlClicked)
      Else didSomething := 0

      lastInvoked := A_TickCount
      If didSomething
         lastInvokedSwipe := A_TickCount
   } Else If (!CurrentSLD || maxFilesIndex<1) && (A_TickCount - thisZeit>450)
   {
      ; when no image is loaded, on click, open files dialog
      lastInvoked := A_TickCount
      If StrLen(UserMemBMP)>2
         Return

      SetTimer, drawWelcomeImg, Off
      Sleep, 5
      If (A_TickCount - lastWinDrag>300)
         OpenDialogFiles()
   }
   lastInvoked := A_TickCount
}

JEE_ScreenToWindow(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472

  VarSetCapacity(RECT, 16)
  DllCall("user32\GetWindowRect", Ptr,hWnd, Ptr,&RECT)
  vWinX := NumGet(&RECT, 0, "Int")
  vWinY := NumGet(&RECT, 4, "Int")
  vPosX2 := vPosX - vWinX
  vPosY2 := vPosY - vWinY
}

JEE_ScreenToClient(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472
  VarSetCapacity(POINT, 8)
  NumPut(vPosX, &POINT, 0, "Int")
  NumPut(vPosY, &POINT, 4, "Int")
  DllCall("user32\ScreenToClient", Ptr,hWnd, Ptr,&POINT)
  vPosX2 := NumGet(&POINT, 0, "Int")
  vPosY2 := NumGet(&POINT, 4, "Int")
}

ToggleImageSizingMode(dummy:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50)
       Return

    lastInvoked := A_TickCount
    resetSlideshowTimer(0)
    If (imgEditPanelOpened!=1)
    {
       IMGdecalageX := IMGdecalageX := 1
       IMGresizingMode++
       If (IMGresizingMode>5)
          IMGresizingMode := 1

       If (IMGresizingMode=5)
       {
          editingSelectionNow := 0
          updateUIctrl()
       }
    } Else 
    {
       IMGresizingMode := (IMGresizingMode=1) ? 4 : 1
       If (IMGresizingMode=4)
          zoomLevel := 1
    }

    If (dummy="custom")
    {
       IMGresizingMode := 4
       zoomLevel := 1
    }

    friendly := DefineImgSizing()
    showTOOLtip("Rescaling mode:`n" friendly)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "zoomLevel", "General")
    interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
    SetTimer, coreReloadThisPicture, -50
    ; dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, IMGresizingMode, % IMGresizingMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

DefineImgSizing() {
   friendly := (IMGresizingMode=1) ? "ADAPT ALL INTO VIEW" : "ADAPT ONLY LARGE IMAGES"
   If (IMGresizingMode=3)
      friendly := "NONE (ORIGINAL SIZE)"
   Else If (IMGresizingMode=4)
      friendly := "CUSTOM ZOOM " Round(zoomLevel * 100) "%"
   If (IMGresizingMode=5)
      friendly := "STRETCHED TO WINDOW"

   Return friendly
}

VPimgFXrandomizer() {
    Static lastFX, FXmodes := {1:1, 2:2, 3:3, 4:4, 5:10}
    Random, OutputVar, 1, 5
    imgFxMode := FXmodes[OutputVar]
    If (imgFxMode=lastFX && lastFX=10)
    {
       Random, OutputVar, 1, 5
       imgFxMode := FXmodes[OutputVar]
    }

    Random, OutputVar, 1, 200
    satAdjust := OutputVar/100

    Random, OutputVar, 0.1, 0.9
    bwDithering := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 0.1, 0.9
    usrTextureBGR := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 0.1, 0.9
    FlipImgH := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 1, 7
    If (OutputVar=2)
       OutputVar := 1
    usrColorDepth := OutputVar
}

dummyInfoToggleSlideShowu(actu:=0) {
  Static lastInvoked := 1
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()

  GIFframesPlayied := 0
  r := ToggleSlideShowu(actu)
  If (r="lulz")
     Return

  If (slideShowRunning!=1 || actu="stop")
  {
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     ; userSeenSlideImages := (userSeenSlideImages>maxFilesIndex - 1) ? maxFilesIndex : userSeenSlideImages
     showTOOLtip("Slideshow: STOPPED`nImages seen in this session: " groupDigits(userSeenSlideImages))
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  } Else ;  If (A_TickCount - lastInvoked > 450)
  {
     delayu := DefineSlidesRate()
     friendly := DefineSlideShowType()
     etaTime := "`nEstimated time: " EstimateSlideShowLength()
     If (slidesFXrandomize=1)
        infosFX := "`nViewport colour effects are randomized for each image."
     showTOOLtip("Started " friendly " slideshow`nSpeed: " delayu "`nTotal files: " groupDigits(maxFilesIndex) etaTime infosFX)
     SetTimer, RemoveTooltip, % -msgDisplayTime, 900
     If (slideShowDelay < 900)
     {
        Sleep, 550
        RemoveTooltip()
     } Else SetTimer, RemoveTooltip, % -msgDisplayTime, 900
  } ; Else  SetTimer, dummyInfoToggleSlideShowu, Off

}

InfoToggleSlideShowu() {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 350) && (slideShowRunning!=1) || (maxFilesIndex<3 && StrLen(mustOpenStartFolder)<4)
   {
     lastInvoked := A_TickCount
     Return
   }

   lastInvoked := A_TickCount
   If !(IMGlargerViewPort=1 && IMGresizingMode=4)
      SetTimer, dummyInfoToggleSlideShowu, -80
   Return
}

preventScreenOff() {
  ; if the user is idle ;-)
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 10500) || (slideShowRunning!=1)
     Return

  lastInvoked := A_TickCount
  If (!GetKeyState("Space", "P") && slideShowRunning=1 && WinActive("A")=PVhwnd)
  {
     MouseMove, 2, 0, 2, R
     MouseMove, -2, 0, 2, R
     ; SendEvent, {Up}
  }
  ; z := DllCall("user32\SetCursor", "Ptr", hCursBusy)
  ; ToolTip, % "L=" z , , , 2
}

ToggleSlideShowu(actu:=0) {
  If (maxFilesIndex<3 && slideShowRunning!=1)
  {
     showTOOLtip("WARNING: Insufficient indexed files to start a slideshow")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "lulz"
  }

  If askAboutFileSave(" and the slideshow will begin")
     Return "lulz"
  Else
     terminateIMGediting()

  interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
  interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
  interfaceThread.ahkassign("slidesFXrandomize", slidesFXrandomize)
  If (slideShowRunning=1 || actu="stop") && (actu!="start")
  {
     slideShowRunning := 0
     ; ResetImgLoadStatus()
     ; SetTimer, theSlideShowCore, Off
     prevSlideShowStop := A_TickCount
     interfaceThread.ahkFunction("slideshowsHandler", 0, "stop", SlideHowMode)
     SetTimer, ResetImgLoadStatus, -150
  } Else If (thumbsDisplaying!=1 || actu="start")
  {
     If (A_TickCount - prevSlideShowStop<500) && (actu!="start")
        Return

     ResetImgLoadStatus()
     interfaceThread.ahkassign("allowNextSlide", 1)
     editingSelectionNow := 0
     updateUIctrl()
     slideShowRunning := 1
     If (hSNDmediaFile && hSNDmediaDuration && hSNDmedia)
        milisec := MCI_Length(hSNDmedia) 

     thisSlideSpeed := (milisec>slideShowDelay) ? milisec : slideShowDelay
     interfaceThread.ahkFunction("slideshowsHandler", thisSlideSpeed, "start", SlideHowMode)
     ; SetTimer, theSlideShowCore, % thisSlideSpeed
  }
  Return
}

theSlideShowCore() {
   If (slideShowRunning=1 && slidesFXrandomize=1)
      VPimgFXrandomizer()

   If (SlideHowMode=1)
     RandomPicture()
   Else If (SlideHowMode=2)
     PreviousPicture()
   Else If (SlideHowMode=3)
     NextPicture()
   Return
}

GoNextSlide() {
  Sleep, 15
  If GetKeyState("LButton")
  {
     SetTimer, GoNextSlide, -100
     Return
  }

  resetSlideshowTimer(0)
  If (SlideHowMode=1)
     RandomPicture()
  Else
     NextPicture()
}

GoPrevSlide() {
  Sleep, 15
  If GetKeyState("LButton")
  {
     SetTimer, GoPrevSlide, -100
     Return
  }

  resetSlideshowTimer(0)
  If (SlideHowMode=1)
     PrevRandyPicture()
  Else
     PreviousPicture()
}

coreSecToHHMMSS(Seco, ByRef Hrs, ByRef Min, ByRef Sec) {
  OldFormat := A_FormatFloat
  SetFormat, Float, 2.00
  Hrs := Seco//3600/1
  Min := Mod(Seco//60, 60)/1
  SetFormat, Float, %OldFormat%
  Sec := Round(Mod(Seco, 60), 2)
}

SecToHHMMSS(Seco) {
  coreSecToHHMMSS(Seco, Hrs, Min, Sec)
  If (hrs>26)
     dayz := Round(hrs/24, 2)
  If (dayz>=1.1)
  {
     If (dayz>32)
        Return "about " Round(dayz/30.5, 2) " months"
     r := dayz " days"
  } Else  r := (Hrs ? Hrs "h " : "") Min "m " Sec "s"

  If (!min && !hrs)
  {
     r := StrReplace(r, "0m ")
     r := Trimmer(r, "0")
  }
  r := StrReplace(r, ".00s", "s")
  If (min || hrs)
     r := RegExReplace(r, "\...s", "s")
  r := StrReplace(r, " 0s")
  r := StrReplace(r, "  ", A_Space)
  r := Trimmer(r)

  Return r
}

DefineSlideShowType() {
   friendly := (SlideHowMode=1) ? "RANDOM" : "BACKWARD"
   If (SlideHowMode=3)
      friendly := "FORWARD"
   Return friendly
}

SwitchSlideModes() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1)
      Return

   lastInvoked := A_TickCount
   SlideHowMode++
   If (SlideHowMode>3)
      SlideHowMode := 1

   resetSlideshowTimer(0, 1)
   friendly := DefineSlideShowType() "`nCurrently "
   friendly .= (slideShowRunning=1) ? "running" : "stopped"
   showTOOLtip("Slideshow mode: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "SlideHowMode", "General")
}

DefineVPselAreaMode() {
   If (EllipseSelectMode=2)
      friendly := "FREEFORM - T" FillAreaCurveTension
   Else If (EllipseSelectMode=1)
      friendly := "ELLIPTICAL"
   Else
      friendly := "RECTANGULAR"

   Return friendly
}

DefineFXmodes() {
   Static FXmodesLabels := {1:"ORIGINAL", 2:"PERSONALIZED", 3:"AUTO-ADJUSTED", 4:"GRAYSCALE", 5:"RED CHANNEL", 6:"GREEN CHANNEL", 7:"BLUE CHANNEL", 8:"ALPHA CHANNEL", 9:"INVERTED COLORS", 10:"SEPIA"}
        , otherFXLabels := {1:"ADAPTIVE", 2:"BRIGHTNESS", 3:"CONTRAST"}

   If FXmodesLabels.HasKey(imgFxMode)
      friendly := FXmodesLabels[imgFxMode]
   Else
      friendly := "Colors FX: " imgFxMode
   If (imgFxMode=3)
      friendly .= A_Space otherFXLabels[autoAdjustMode]

   If (bwDithering=1 && imgFxMode=4)
      friendly := "BLACK/WHITE DITHERED"

   If (imgFxMode=1 && isInRange(usrColorDepth, 2, 10))
      friendly := "ALTERED COLOR DEPTH"

   Return friendly
}

ToggleImgColorDepth(dir:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 && thumbnailsListMode=1)
       Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   If (imgFxMode=4 && bwDithering=1)
   {
      imgFxMode := 1
      Return
   }

   good2go := (imgFxMode=1 || imgFxMode=2 || imgFxMode=3 || imgFxMode=8) ? 1 : 0
   If (good2go!=1)
      imgFxMode := 1

   If (dir=1)
      usrColorDepth--
   Else
      usrColorDepth++

   usrColorDepth := clampInRange(usrColorDepth, 1, 9, 1)
   ForceRefreshNowThumbsList()
   infoColorDepth := (usrColorDepth>1) ? defineColorDepth() : "NONE"
   showTOOLtip("Image color depth simulated: " infoColorDepth, 0, 0, usrColorDepth/9)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "usrColorDepth", "General")
   INIaction(1, "imgFxMode", "General")
   SetTimer, RefreshImageFile, -50

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, usrColorDepth, % usrColorDepth
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineColorDepth() {
   Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:16}

   internalColorDepth := bitsOptions[usrColorDepth]
   r := internalColorDepth " bits [" 2**internalColorDepth " colors]"
   If (r<1)
      r := currIMGdetails.PixelFormat
   Else If (ColorDepthDithering=1)
      r .= " | DITHERED"

   If !r
      r := "NONE"
   Return r
}

ToggleImgFX(dir:=0) {
   Static lastInvoked := 1, moreFX := {1:"None", 2:"Blur", 3:"Sharpen", 4:"Brightness / Contrast", 5:"Hue / Saturation / Lightness", 6:"Levels adjust [High / Mid / Low]", 7:"Color tint [Hue / Amount]", 8:"Colors balance", 9:"Color curve per channel"}
        , curvesFX := {1:"Brightness (density)", 2:"Contrast", 3:"Highlights", 4:"Shadows", 5:"Midtones", 6:"White saturation", 7:"Black saturation"}
        , curvesChannels := {1:"Red", 2:"Green", 3:"Blue", 4:"All"}

   If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 && thumbnailsListMode=1 && showHUDnavIMG!=1)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=1)
      imgFxMode--
   Else
      imgFxMode++

   prevColorAdjustZeit := A_TickCount
   If (imgFxMode=3 && thumbsDisplaying=1)
   {
      If (dir=1)
         imgFxMode--
      Else
         imgFxMode++
   }

   imgFxMode := clampInRange(imgFxMode, 1, 10, 1)
   friendly := DefineFXmodes()
   If (imgFxMode=4)
      friendly .= "`nBrightness: " Round(lumosGrayAdjust, 3) "`nContrast: " Round(GammosGrayAdjust, 3)
   Else If (imgFxMode=2)
      friendly .= "`nBrightness: " Round(lumosAdjust, 3) "`nContrast: " Round(GammosAdjust, 3) "`nSaturation: " Round(satAdjust*100) "%"

   If (imgFxMode=2 || imgFxMode=4 || imgFxMode=9)
      friendly .= "`nGamma: " Round(realGammos, 3)
   
   If (imgFxMode=2 || imgFxMode=3 || (imgFxMode=4 && bwDithering=0) || imgFxMode=9 || imgFxMode=10) && (IntensityAlphaChannel!=1)
      friendly .= "`nAlpha channel: ALTERED"

   If (specialColorFXmode>1) && (imgFxMode=2 || imgFxMode=3 || imgFxMode=4 || imgFxMode=9)
   {
      friendly .= "`n" moreFX[specialColorFXmode]
      If (specialColorFXmode=9)
         friendly .= " [" curvesFX[uiColorCurveFXmode] "]: "  Round(lummyAdjust) " - " curvesChannels[uiColorCurveFXchannel]
      Else
         friendly .= ":`n" Round(hueAdjust) " / " Round(zatAdjust) " / " Round(lummyAdjust)
   }

   If (usrColorDepth>1 && imgFxMode=1)
      friendly .= "`nSimulated color depth: " defineColorDepth()

   If (imgFxMode=4 || imgFxMode=3 || imgFxMode=2)
      friendly .= "`n `nPress U to adjust colors display options."

   showTOOLtip("Image colors: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()

   If (imgFxMode=3 && thumbsDisplaying!=1)
   {
      imgPath := getIDimage(currentFileIndex)
      AdaptiveImgLight(useGdiBitmap(), imgPath, 1, 1)
   }

   INIaction(1, "imgFxMode", "General")
   If (o_bwDithering=0)
      o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0

   If (o_bwDithering=1 && thumbsDisplaying!=1)
      RefreshImageFile()
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, imgFxMode, % imgFxMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineImgAlign() {
   modes := {1:"Top-left corner", 2:"Top-center", 3:"Top-right corner", 4:"Left-center", 5:"Center", 6:"Right-center", 7:"Bottom-left corner", 8:"Bottom-center", 9:"Bottom-right corner"}
   ; thisAlign := (IMGresizingMode=4) ? 5 : imageAligned
   r := modes[imageAligned]
   StringUpper, r, r
   Return r
}

ToggleIMGalign() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (!useGdiBitmap() && thumbsDisplaying!=1)
      Return

   resetSlideshowTimer(1, 1)
   imageAligned := (imageAligned=5) ? 1 : 5
   ; imageAligned++
   ; If (imageAligned>9)
   ;    imageAligned := 1

   showTOOLtip("Image alignment: " defineImgAlign())
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "imageAligned", "General")
   dummyTimerReloadThisPicture(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   } Else if (thumbsDisplaying=1)
   {
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(50)
   }
}

toggleColorAdjustments(noReturn:=0) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

  lastInvoked := A_TickCount
  If (imgFxMode!=1 && thumbsDisplaying!=1)
  {
     prevColorAdjustZeit := A_TickCount
     resetSlideshowTimer(0)
     ForceNoColorMatrix := !ForceNoColorMatrix
     If (noReturn=0)
        AnyWindowOpen := (ForceNoColorMatrix=1) ? 10 : 0
     dummyTimerDelayiedImageDisplay(50)
     If (noReturn=0)
     {
        AnyWindowOpen := 10
        SetTimer, resetClrMatrix, -1500
     }
  }
}

resetClrMatrix() {
   resetSlideshowTimer(0)
   AnyWindowOpen := ForceNoColorMatrix := 0
   dummyTimerDelayiedImageDisplay(50)
}

ResetImageView() {
   Critical, on
   If throwErrorNoImageLoaded()
      Return

   ChangeLumos(2)
}

HardResetImageView() {
   Critical, on
   DestroyTempBtnGui("now")
   If (!useGdiBitmap() && !CurrentSLD)
      Return

   ChangeLumos(2, "k")
}

coreResetIMGview(dummy:=0) {
  If (imgFxMode=4 && lumosGrayAdjust=1 && GammosGrayAdjust=0)
     mustResetFxMode := 1

  If (dummy="k")
  {
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0
     imgThreshold := bwDithering := hueAdjust := zatAdjust := lummyAdjust := 0
     IntensityAlphaChannel := specialColorFXmode := 1
  }

  If (imgFxMode=4)
  {
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
  } Else If (imgFxMode=2)
  {
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || dummy="k")
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0

  realGammos := 1
  If (imgFxMode=1 || dummy="k")
  {
     zoomLevel := 1
     FlipImgH := FlipImgV := 0
     If (thumbsDisplaying!=1)
       vpIMGrotation := 0
  }

  If (dummy="k")
  {
     ; bwDithering := 0
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
     vpIMGrotation := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || imgFxMode>4 || mustResetFxMode=1)
     imgFxMode := 1

  If (thumbsDisplaying=1)
  {
     thumbsZoomLevel := 1
     thumbsColumns := 7
     recalculateThumbsSizes()
     ; thumbsH := othumbsH + 1
     ; thumbsW := othumbsW + 1
     ForceRefreshNowThumbsList()
  }

  interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
  If (dummy="k")
     usrColorDepth := internalColorDepth := 1
}

ChangeLumos(dir, dummy:=0) {
   Static prevValues, lastInvoked := 1

   If (thumbsDisplaying=1 && thumbnailsListMode=1)
      Return

   resetSlideshowTimer(0)
   If (imgFxMode!=2 && imgFxMode!=4 && dir!=2)
      imgFxMode := 2

   showHardReset := 0
   If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
      showHardReset := 1

   prevColorAdjustZeit := A_TickCount
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=2)
   {
      coreResetIMGview(dummy)
      SetTimer, WriteSettingsColorAdjustments, -95
   } Else If (imgFxMode=4)
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosGrayAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosGrayAdjust += stepu
      Else
         lumosGrayAdjust -= stepu

      lumosGrayAdjust := clampInRange(lumosGrayAdjust, 0.001, 25)
   } Else
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosAdjust += stepu
      Else
         lumosAdjust -= stepu

      lumosAdjust := clampInRange(lumosAdjust, 0.001, 25)
   }

   value2show := (imgFxMode=4) ? Round(lumosGrayAdjust, 3) : Round(lumosAdjust, 3)
   If (dir=2)
   {
      If (imgFxMode=4)
         addMsg := DefineFXmodes()
      If (imgFxMode=1 && usrColorDepth>1)
         addMsg .= "`nImage color depth: ALTERED [ " defineColorDepth() " ]"
      If (vpIMGrotation>0)
         addMsg .= "`nImage rotated: " vpIMGrotation "° degrees."
      If (thisIMGisDownScaled=1)
         addMsg .= "`nImage dimensions DOWNSCALED to screen resolution."

      addMsg .= defineIMGmirroring()
      If (dummy!="k" && showHardReset=1)
      {
         addMore := "`nReset all adjustments to defaults with Ctrl + \"
         CreateGuiButton("Reset all adjustments,,HardResetImageView", 0, msgDisplayTime//1.5 + 100)
      }
      showTOOLtip("Image display: UNALTERED " addMsg addMore)
   } Else showTOOLtip("Image brightness: " value2show, 0, 0, value2show / 25)

   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues && dir!=2)
      Return

   If (dir!=2)
      SetTimer, dummySaveLumGammos, -70

   prevValues := newValues
   If (o_bwDithering=1 || otherFX=1) ; && (thumbsDisplaying!=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

WriteSettingsColorAdjustments() {
    INIaction(1, "userimgQuality", "General")
    INIaction(1, "histogramMode", "General")
    INIaction(1, "usrTextureBGR", "General")
    INIaction(1, "autoAdjustMode", "General")
    INIaction(1, "doSatAdjusts", "General")
    INIaction(1, "usrAdaptiveThreshold", "General")
    INIaction(1, "showHistogram", "General")
    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "imgThreshold", "General")
    INIaction(1, "bwDithering", "General")
    INIaction(1, "usrColorDepth", "General")
    INIaction(1, "ColorDepthDithering", "General")
    INIaction(1, "imgFxMode", "General")
    INIaction(1, "IntensityAlphaChannel", "General")
    INIaction(1, "chnBdecalage", "General")
    INIaction(1, "chnGdecalage", "General")
    INIaction(1, "chnRdecalage", "General")
    INIaction(1, "FlipImgH", "General")
    INIaction(1, "FlipImgV", "General")
    INIaction(1, "GammosAdjust", "General")
    INIaction(1, "GammosGrayAdjust", "General")
    INIaction(1, "hueAdjust", "General")
    INIaction(1, "lumosAdjust", "General")
    INIaction(1, "lumosGrayAdjust", "General")
    INIaction(1, "realGammos", "General")
    INIaction(1, "satAdjust", "General")
    INIaction(1, "vpIMGrotation", "General")
    INIaction(1, "zatAdjust", "General")
    INIaction(1, "lummyAdjust", "General")
    INIaction(1, "zoomLevel", "General")
    INIaction(1, "specialColorFXmode", "General")
    INIaction(1, "uiColorCurveFXmode", "General")
    INIaction(1, "uiColorCurveFXchannel", "General")
}

defineIMGmirroring() {
    If (FlipImgH=1 || FlipImgV=1)
    {
       infoMirroring := "`nImage mirroring: "
       If (FlipImgV=1 && FlipImgH=0)
          infoMirroring :=  infoMirroring "VERTICAL"
       Else If (FlipImgV=0 && FlipImgH=1)
          infoMirroring := infoMirroring "HORIZONTAL"
       Else If (FlipImgV=1 && FlipImgH=1)
          infoMirroring := infoMirroring "VERTICAL, HORIZONTAL"
    }
    Return infoMirroring
}

defineFilesListType() {
    If (SLDtypeLoaded=1)
    {
       infou := !InStr(CurrentSLD, "|") ? "FOLDER RECURSIVELY" : "FOLDER"
    } Else If (SLDtypeLoaded=2)
    {
       infou := "PLAIN-TEXT | cached list"
       If (currentFilesListModified=1)
          infou .= " | unsaved changes"
    } Else If (SLDtypeLoaded=3)
       infou := "SQLITE DATABASE | cached list"
       
    Return infou
}

ChangeZoom(dir, key:=0, stepFactor:=1) {
   Static prevValues, lastInvoked := 1, lastInvoked2 := 1

   If InStr(key, "wheel")
   {
      MouseGetPos, , , OutputVarWin
      If (OutputVarWin!=PVhwnd)
         Return
   }

   resetSlideshowTimer(0)
   If (thumbsDisplaying=1)
   {
      If (thumbnailsListMode=1)
      {
         changeOSDfontSize(dir)
         Return
      }

      If (dynamicThumbsColumns=1)
      {
         If (dir=1)
            thumbsZoomLevel += 0.1
         Else
            thumbsZoomLevel -= 0.1
      } Else
      {
         If (dir=1)
            thumbsColumns += 1
         Else
            thumbsColumns -= 1
      }

      thumbsZoomLevel := clampInRange(thumbsZoomLevel, 0.35, 3)
      thumbsColumns := clampInRange(thumbsColumns, 2, 100)
      ForceRefreshNowThumbsList()
      recalculateThumbsSizes()
      If (thumbnailsListMode=1)
         ForceRefreshNowThumbsList()
      INIaction(1, "thumbsZoomLevel", "General")
      INIaction(1, "thumbsColumns", "General")
      ; INIaction(1, "dynamicThumbsColumns", "General")
      If (dynamicThumbsColumns=1)
         showTOOLtip("Thumbnails zoom level: " Round(thumbsZoomLevel*100) "%`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", 0, 0, thumbsZoomLevel/3)
      Else
         showTOOLtip("Thumbnails columns: " thumbsColumns "`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", 0, 0, thumbsColumns/100)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      dummyTimerDelayiedImageDisplay(95)
      Return
   }

   oldZoomLevel := zoomLevel
   If (zoomLevel>5)
      changeFactor := 0.50
   Else If (zoomLevel>1)
      changeFactor := 0.15
   Else If (zoomLevel<0.01)
      changeFactor := 0.005
   Else If (zoomLevel<=0.1)
      changeFactor := 0.01
   Else
      changeFactor := 0.05

   If (dir=1)
      zoomLevel += changeFactor * stepFactor
   Else
      zoomLevel -= changeFactor * stepFactor

   o_IMGresizingMode := IMGresizingMode
   IMGresizingMode := 4
   interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
   zoomLevel := clampInRange(zoomLevel, 0.01, 20)
   prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)

   If (zoomLevel>3 && thisIMGisDownScaled=1 && AutoDownScaleIMGs=1)
   {
      imgPath := getIDimage(currentFileIndex)
      op := GetImgFileDimension(imgPath, Wi, He)
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      xu := (imgW*zoomLevel)/Wi
      hasThisChangedYo := 1
      zoomLevel := xu
      AutoDownScaleIMGs := 2
   }

   MouseGetPos, , , OutputVarWin
   If (OutputVarWin=PVhwnd && InStr(key, "wheel"))
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      prcW := mX/mainWidth
      prcH := mY/mainHeight

      prcW := (prcW>0.5) ? prcW - 0.5 : 0.5 - prcW
      prcH := (prcH>0.5) ? prcH - 0.5 : 0.5 - prcH
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      decX := Round(((imgW)*prcW) * zoomLevel)
      decY := Round(((imgH)*prcH) * zoomLevel)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (prcW>0.5 || imageAligned=1)
         decX := -decX
      If (prcH>0.5 || imageAligned=1)
         decY := -decY

      IMGdecalageX := IMGdecalageX + decX//35
      IMGdecalageY := IMGdecalageY + decY//35
   }

   ; tooltip, % IMGdecalageX " -- " IMGdecalageY "`n" decX " -- " decY "`n"prcW " -- " prcH
   If (A_TickCount - lastInvoked2<150)
   {
      zeitSillyPrevent := A_TickCount
      SetTimer, dummyZoomInfo, -80
   } Else
   {
      dummyZoomInfo()
      lastInvoked2 := A_TickCount
   }

   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")

   newValues := "a" zoomLevel thumbsZoomLevel IMGresizingMode imageAligned getIDimage(currentFileIndex)
   If (prevValues=newValues && hasThisChangedYo!=1)
      Return

   prevValues := newValues
   If (drawModeBzeit>150 && (A_TickCount - lastInvoked < 10) && (LastPrevFastDisplay!=1)) || (hasThisChangedYo=1)
      GdipCleanMain(6)

   lastInvoked := A_TickCount
   If (AutoDownScaleIMGs=2 && hasThisChangedYo=1)
      SetTimer, RefreshImageFileAction, -150
   Else If (o_IMGresizingMode=1 && enableThumbsCaching=1) || (LastPrevFastDisplay=1)
      SetTimer, coreReloadThisPicture, -10
   Else
      dummyTimerDelayiedImageDisplay(10)
}

dummyZoomInfo() {
   If (thisIMGisDownScaled=1)
      friendly := "`nThe image is downscaled.`nPress F5 or increase zoom above 300%`nto load the original file."

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, IMGresizingMode, % IMGresizingMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }

   showTOOLtip("Zoom level: " Round(zoomLevel*100) "%" friendly, 0, 0, zoomLevel/20)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ; SetTimer, ResetImgLoadStatus, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

ChangeGammos(dir) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 && thumbnailsListMode=1)
      Return

   resetSlideshowTimer(0)
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (imgFxMode!=2 && imgFxMode!=4)
      imgFxMode := 2

   value2Adjust := (imgFxMode=4) ? GammosGrayAdjust : GammosAdjust
   value2AdjustB := (imgFxMode=4) ? lumosGrayAdjust : lumosAdjust
   stepu := (A_tickcount - lastInvoked<300) && (value2Adjust<-2) ? 0.06 : 0.03
   If (dir=1)
   {
      value2Adjust += stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB -= stepu
   } Else
   {
      value2Adjust -= stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB += stepu
   }

   value2Adjust := clampInRange(value2Adjust, -25, 1)
   value2AdjustB := clampInRange(value2AdjustB, 0.001, 25)
   If (imgFxMode=4)
   {
      GammosGrayAdjust := value2Adjust
      lumosGrayAdjust := value2AdjustB
   } Else
   {
      GammosAdjust := value2Adjust
      lumosAdjust := value2AdjustB
   }

   prevColorAdjustZeit := A_TickCount
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image contrast: " Round(value2Adjust, 3), 0, 0, Abs(value2Adjust - 1)/26)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues)
      Return

   SetTimer, dummySaveLumGammos, -70
   prevValues := newValues
   If (o_bwDithering=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

dummySaveLumGammos() {
   INIaction(1, "GammosAdjust", "General")
   INIaction(1, "GammosGrayAdjust", "General")
   INIaction(1, "lumosAdjust", "General")
   INIaction(1, "lumosGrayAdjust", "General")
   INIaction(1, "imgFxMode", "General")
   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")
}

ChangeSaturation(dir) {
   Static prevValues

   If (thumbsDisplaying=1 && thumbnailsListMode=1)
      Return

   resetSlideshowTimer(0)
   If (imgFxMode=4)
      satAdjust := 0

   imgFxMode := 2
   prevColorAdjustZeit := A_TickCount
   value2Adjust := satAdjust
   If (dir=1)
      value2Adjust += 0.05
   Else
      value2Adjust -= 0.05

   value2Adjust := clampInRange(value2Adjust, 0, 3)
   satAdjust := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image saturation: " Round(value2Adjust*100) "%", 0, 0, value2Adjust/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" satAdjust imgFxMode currentFileIndex
   If (prevValues=newValues)
      Return

   INIaction(1, "satAdjust", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

ChangeRealGamma(dir) {
   Static prevValues

   If (thumbsDisplaying=1 && thumbnailsListMode=1)
      Return

   resetSlideshowTimer(0)
   prevColorAdjustZeit := A_TickCount
   imgFxMode := 2
   value2Adjust := realGammos
   If (value2Adjust>2)
      stepu := 0.2
   Else If (value2Adjust<0.1)
      stepu := 0.01
   Else
      stepu := 0.05

   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   value2Adjust := clampInRange(value2Adjust, 0.01, 10)
   realGammos := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image gamma: " Round(value2Adjust*100) "%", 0, 0, value2Adjust/8)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" realGammos imgFxMode
   If (prevValues=newValues)
      Return

   INIaction(1, "realGammos", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

ChangeVolume(dir) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (thumbsDisplaying=1)
      Return

   resetSlideshowTimer(0, 1)
   value2Adjust := mediaSNDvolume
   If (dir=1)
      value2Adjust += 5
   Else
      value2Adjust -= 5

   value2Adjust := clampInRange(value2Adjust, 1, 100)
   If !hSNDmedia
      infoMedia := "`nNo audio is currently playing..."

   mediaSNDvolume := value2Adjust
   INIaction(1, "mediaSNDvolume", "General")
   SetVolume(mediaSNDvolume)
   showTOOLtip("Audio volume: " value2Adjust "%" infoMedia, 0, 0, value2Adjust/100)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

MenuChangeImgRotationInVP() {
   changeImgRotationInVP(1, 45)
}

changeSelRotation(dir) {
   If (thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   value2Adjust := vPselRotation
   If (dir=1)
      value2Adjust += 2
   Else
      value2Adjust -= 2

   value2Adjust := clampInRange(value2Adjust, 0, 360 - 2, 1)
   vPselRotation := value2Adjust
   SetTimer, dummyRefreshImgSelectionWindow, -10
   SetTimer, dummyShowSelCoordsInfos, -20
}

changeImgRotationInVP(dir, stepu:=15) {
   If (thumbsDisplaying=1)
      Return

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   If StrLen(whichBitmap)>3
   {
      Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
      Gdip_GetRotatedDimensions(imgW, imgH, 45, ResizedW, ResizedH)
      If ((ResizedW*ResizedH>maxGDIbmpSize) || (ResizedW>32500) || (ResizedH>32500)) && (vpIMGrotation=0)
      {
         vpIMGrotation := 0
         SoundBeep, 300, 100
         showTOOLtip("ERROR: The document dimensions exceed the maximum limits`nThe image cannot be rotated.")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   } Else Return

   resetSlideshowTimer(0)
   value2Adjust := vpIMGrotation
   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   value2Adjust := clampInRange(value2Adjust, 0, 360 - stepu, 1)
   vpIMGrotation := value2Adjust
   SetTimer, dummyChangeVProtation, -10
   SetTimer, RefreshImageFile, -750
}

dummyChangeVProtation() {
   showTOOLtip("Image rotation: " vpIMGrotation "° ", 0, 0, vpIMGrotation/360)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "vpIMGrotation", "General")
   GdipCleanMain(4)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, vpIMGrotation, % vpIMGrotation
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

nextDesiredFrame() {
    changeDesiredFrame(1)
}

prevDesiredFrame() {
    changeDesiredFrame(-1)
}

changeDesiredFrame(dir:=1) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 || !totalFramesIndex)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If askAboutFileSave(" and the current image frame will be changed")
      Return

   DestroyGIFuWin()
   resetSlideshowTimer(0)
   value2Adjust := desiredFrameIndex
   If (dir=1)
      value2Adjust++
   Else
      value2Adjust--

   If (dir=-1 && value2Adjust<1)
      value2Adjust := 0

   value2Adjust := clampInRange(value2Adjust, 0, totalFramesIndex, 1)
   desiredFrameIndex := value2Adjust
   If (A_TickCount - lastInvoked > 350) || (dir=-1)
   {
      showCurrentFrameIndex()
      lastInvoked := A_TickCount
   } Else SetTimer, showCurrentFrameIndex, -400

   newValues := value2Adjust currentFileIndex
   If (prevValues!=newValues)
   {
      SetTimer, RefreshImageFile, % (dir=-1) ? -95 : -5
      prevValues := newValues
   }
}

autoChangeDesiredFrame(act:=0, imgPath:=0) {
   Critical, on
   Static prevImgPath, lastInvoked := 1, lastFrameChange := 1
   If (thumbsDisplaying=1 || act="stop" || AnyWindowOpen || animGIFsSupport!=1 || !maxFilesIndex || !CurrentSLD)
   {
      If (animGIFplaying=1)
      {
         SetTimer, autoChangeDesiredFrame, Off
         SetTimer, ResetImgLoadStatus, -10
         prevAnimGIFwas := prevImgPath
         prevImgPath := ""
         Global lastGIFdestroy := A_TickCount
         lastFrameChange := A_TickCount
         animGIFplaying := 0
         ; lastInvoked := A_TickCount
         interfaceThread.ahkassign("animGIFplaying", 0)
         ; dummyTimerDelayiedImageDisplay(50)
      }
      Return
   }

   If (prevImgPath!=imgPath && StrLen(imgPath)>2)
      lastInvoked := A_TickCount

   If (act="start" && imgPath && prevImgPath!=imgPath)
   {
      SetTimer, ResetImgLoadStatus, -15
      lastFrameChange := A_TickCount
      prevImgPath := imgPath
      allowNextSlide := 0
      animGIFplaying := 1
      interfaceThread.ahkassign("animGIFplaying", 1)
      interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
      Return
   } Else
   {
      Sleep, -1
      animGIFplaying := interfaceThread.ahkgetvar.animGIFplaying
      If !animGIFplaying
      {
         SetTimer, ResetImgLoadStatus, -10
         SetTimer, autoChangeDesiredFrame, Off
         animGIFplaying := 0
         allowNextSlide := 1
         interfaceThread.ahkassign("animGIFplaying", 0)
         interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
         prevAnimGIFwas := prevImgPath
         prevImgPath := ""
         lastFrameChange := A_TickCount
         Global lastGIFdestroy := A_TickCount
         Return
      }
   }

   allowNextSlide := 0
   desiredFrameIndex++
   GIFframesPlayied++
   If (allowGIFsPlayEntirely=1 && GIFframesPlayied>totalFramesIndex-1) || (totalFramesIndex<3) || (allowGIFsPlayEntirely!=1)
      allowNextSlide := 1
   ; ToolTip, % allowGIFsPlayEntirely "--" allowNextSlide , , , 2
   desiredFrameIndex := clampInRange(desiredFrameIndex, 0, totalFramesIndex, 1)
   prevAnimGIFwas := ""
   totalZeit := A_TickCount - startZeitIMGload
   thisFrameDelay := (totalZeit>25 && totalFramesIndex>20) ? GIFspeedDelay//2 : GIFspeedDelay
   If (totalZeit>70 && totalFramesIndex>15) || (totalZeit>25 && totalFramesIndex>180)
      thisFrameDelay := 10
   If (thisFrameDelay<12 && totalZeit<40 && totalFramesIndex<14)
      thisFrameDelay := 11
   If (totalZeit>100 && totalFramesIndex>95)
      thisFrameDelay := 1

   If (slideShowRunning=1 && (A_TickCount - lastInvoked>slideShowDelay + 1) && allowNextSlide=1)
   {
      ; allowNextSlide := 0
      lastInvoked := A_TickCount
      prevImgPath := ""
      interfaceThread.ahkPostFunction("theSlideShowCore", "force")
      ; theSlideShowCore()
      invokeExternalSlideshowHandler()
   } Else If (A_TickCount - lastFrameChange > thisFrameDelay)
   {
      lastFrameChange := A_TickCount
      SetTimer, RefreshImageFile, -1
   }
   interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
}

showCurrentFrameIndex() {
    showTOOLtip("Image frame index: " desiredFrameIndex " / " totalFramesIndex, 0, 0, desiredFrameIndex/totalFramesIndex)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

VPflipImgV() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   ForceRefreshNowThumbsList()
   FlipImgV := !FlipImgV
   friendly := (FlipImgV=1) ? "ON" : "off"
   showTOOLtip("Vertical mirroring: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgV", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgV, % FlipImgV
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

setMainCanvasTransform(W, H, G:=0, forceH:=0, forceV:=0) {
    If (thumbsDisplaying=1)
       Return

    If !G
       G := glPG

    If (FlipImgH=1 && forceH=0) || (forceH=1)
    {
       Gdip_ScaleWorldTransform(G, -1, 1)
       Gdip_TranslateWorldTransform(G, -W, 0)
    }

    If (FlipImgV=1 && forceV=0) || (forceV=1)
    {
       Gdip_ScaleWorldTransform(G, 1, -1)
       Gdip_TranslateWorldTransform(G, 0, -H)
    }
}

VPflipImgH() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   ForceRefreshNowThumbsList()
   FlipImgH := !FlipImgH
   friendly := (FlipImgH=1) ? "ON" : "off"
   showTOOLtip("Horizontal mirroring: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgH", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgH, % FlipImgH
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

doOpenStartFolder() {
   If StrLen(mustOpenStartFolder)>3
   {
      If askAboutFileSave(" and files found in " mustOpenStartFolder "\ will be indexed")
         Return currentFileIndex

      SLDtypeLoaded := 1
      imgPath := getIDimage(currentFileIndex)
      coreOpenFolder("|" mustOpenStartFolder, 0)
      If FileRexists(imgPath)
         startIndex := detectFileID(imgPath)
   } Else startIndex := currentFileIndex
   Return startIndex
}

coreNextPrevImage(direction, startIndex, randomMode) {
   Static countSeen, prevStatus
   If (thumbsDisplaying!=1 && maxFilesIndex>1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return currentFileIndex
   }

   If StrLen(mustOpenStartFolder)>3
      startIndex := currentFileIndex := doOpenStartFolder()

   thisState := "a" maxFilesIndex CurrentSLD SLDtypeLoaded
   If (thisState!=prevStatus || countSeen>maxFilesIndex)
      countSeen := 0

   prevStatus := thisState
   If (startIndex>=maxFilesIndex && direction=1 && thumbsDisplaying=1 && randomMode!=1)
      Return maxFilesIndex
   Else If (startIndex<2 && direction=-1 && thumbsDisplaying=1 && randomMode!=1)
      Return 1

   startZeit := A_TickCount
   If (startIndex=1 && direction=-1)
      startIndex := maxFilesIndex + 1
   Else If (startIndex=maxFilesIndex && direction=1)
      startIndex := 0

   delayu := (slideShowDelay>3500) ? Round(slideShowDelay*0.25) : Round(slideShowDelay*0.5)
   ; canResetSeen := 0
   Loop, % maxFilesIndex + 1
   {
        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        If (thisIndex>maxFilesIndex)
           thisIndex -= maxFilesIndex
        Else If (thisIndex<1)
           thisIndex := startIndex + Abs(thisIndex)

        newIndex := thisIndex
        If (randomMode=1)
        {
           z := RandyIMGids[thisIndex]
           r := getIDimage(z)
        } Else r := getIDimage(thisIndex)
        If !r
           Continue

        If (A_TickCount - startZeit>delayu)
           Break

        r := StrReplace(r, "||")
        If (mustRecordSeenImgs=1 && skipSeenImageSlides=1 && slideShowRunning=1 && allImagesWereSeen!=1)
        {
           If retrieveSeenImageDBentry(r, thisIndex)
           {
              countSeen++
              Continue
           }
        }

        ignoreFileCheck := (InStr(AprevImgCall, r) || InStr(BprevImgCall, r)) ? 1 : 0
        If (skipDeadFiles=1 && thumbsDisplaying!=1 && ignoreFileCheck!=1)
        {
           If !FileRexists(r)
              Continue
           Else
              Break
        } Else Break
   }

   ; ToolTip, % thisIndex "==" countSeen "==" delayu , , , 2
   If newIndex
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)

   If (countSeen >= maxFilesIndex - 1) || (!newIndex) ; || (allImagesWereSeen=1)
   {
      allImagesWereSeen := 1
      newIndex := (direction=-1) ? startIndex - 1 : startIndex + 1
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)
   }

   If (randomMode=1)
   {
      RandyIMGnow := newIndex
      newIndex := RandyIMGids[RandyIMGnow]
      if (newIndex>maxFilesIndex)
      {
         Random, thisIndex, 1, % maxFilesIndex
         RandyIMGids[RandyIMGnow] := thisIndex
         newIndex := thisIndex
      }
   }
   Return newIndex
}

PreviousPicture(dummy:=0, inLoop:=0, selForbidden:=0) {
   If (StrLen(UserMemBMP)>2 && editingSelectionNow=1 && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && thumbsDisplaying!=1 && slideShowRunning!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(-1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Left", "+Left", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

NextPicture(dummy:=0, inLoop:=0, selForbidden:=0) {
   If (StrLen(UserMemBMP)>2 && editingSelectionNow=1 && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && slideShowRunning!=1 && thumbsDisplaying!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Right", "+Right", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

Fnt_GetMultilineStringSizeDT(hFont, p_String, NoWrap, l_Width, ByRef r_Width, ByRef r_Height) {
    Static Dummy64026703
          ,DEFAULT_GUI_FONT:=17
          ,HWND_DESKTOP    :=0
          ,OBJ_FONT        :=6
          ,SIZE

          ;-- DrawText format
          ,DT_NOCLIP:=0x100
                ;-- Draws without clipping.  DrawText is somewhat faster when
                ;   DT_NOCLIP is used.

          ,DT_CALCRECT:=0x400
                ;-- Determines the width and height of the rectangle.  The text
                ;   is not drawn.

          ,DT_NOPREFIX:=0x800
                ;-- Turns off processing of prefix characters.

          ,DT_WORDBREAK:=0x10

    If (NoWrap=1)
       s_DTFormat:=DT_NOCLIP|DT_CALCRECT|DT_NOPREFIX
    Else
       s_DTFormat:=DT_NOCLIP|DT_CALCRECT|DT_NOPREFIX|DT_WORDBREAK

    r_Width := r_Height := 0
    ;-- If needed, get the handle to the default GUI font
    if (Gdi_GetObjectType(hFont)!="FONT")
       hFont := Gdi_GetStockObject(DEFAULT_GUI_FONT)

    ;-- Select the font into the device context for the desktop
    hDC      := Gdi_GetDC(HWND_DESKTOP)
    old_hFont:= Gdi_SelectObject(hDC, hFont)
    If !l_Width
       l_Width := 0

    ;-- Calculate the size of the string
    VarSetCapacity(RECT,16,0)
    NumPut(l_Width,RECT,8,"Int")                       ;-- right
    ; Gdi_SetTextCharSpacing(hDC, TextInAreaCharSpacing)
    E := DllCall("DrawText"
        ,"Ptr",hDC                                      ;-- hdc [in]
        ,"Str",p_String                                 ;-- lpchText [in, out]
        ,"Int",StrLen(p_String)                         ;-- cchText [in]
        ,"Ptr",&RECT                                    ;-- lprc [in, out]
        ,"UInt",s_DTFormat)                             ;-- uFormat [in]

    ;-- Release the objects needed by the DrawText function
    Gdi_SelectObject(hDC, old_hFont)
        ;-- Necessary to avoid memory leak

    Gdi_ReleaseDC(hDC, HWND_DESKTOP)
    r_Width := NumGet(RECT,8,"Int")
    r_Height := NumGet(RECT,12,"Int")
    Return E
}

drawTextInBox(theString, fntName, theFntSize, maxW, maxH, txtColor, bgrColor, NoWrap, flippable:=0, thisTextAlign:=0, BGRopacity:="0xDD") {
    startZeit := A_TickCount
    ; pBr0 := Gdip_BrushCreateSolid(bgrColor)
    If (FontBolded=1)
       txtStyle .= " Bold"
    If (FontItalica=1 && NoWrap=0)
       txtStyle .= " Italic"
    Else If (NoWrap=1)
       txtStyle .= " NoWrap"

    If !thisTextAlign
       thisTextAlign := (flippable=1 && FlipImgH=1) ? "Right" : "Left"
    Else
       thisTextAlign := Trimmer(thisTextAlign)

    borderSize := (NoWrap=1) ? Floor(theFntSize*1.2) : Floor(theFntSize*1.5)
    borderSize := borderSize//3
    txtOptions := []
    txtOptions.x := borderSize
    txtOptions.y := borderSize
    txtOptions.w := maxW - borderSize*2
    txtOptions.h := maxH - borderSize*2
    txtOptions.Styles := txtStyle
    txtOptions.Align := thisTextAlign
    txtOptions.Color := "0xEE" txtColor
    txtOptions.Size := theFntSize
    mainObju := TextToGraphics(G, "initing", txtOptions, fntName, "begin", units)
    ; ToolTip, % mainObju.hfnt "`n" mainObju.hStrFmt "`n" mainObju.hBrush , , , 2

    dims := TextToGraphics(2NDglPG, theString, nul, fntName, "measure", units, mainObju)
    dimsFw := clampInRange(dims.w + borderSize*2, 5, maxW)
    dimsFh := clampInRange(dims.h + borderSize*2, 5, maxH)

    clipBMPa := trGdip_CreateBitmap(A_ThisFunc, dimsFw, dimsFh, "0xE200B")
    If clipBMPa
       G := trGdip_GraphicsFromImage(A_ThisFunc, clipBMPa, 5, 1)

    If (!G || !clipBMPa)
    {
       trGdip_DisposeImage(clipBMPa, 1)
       Return
    }

    fontQuality := (theFntSize>90) ? 2 : 3
    If (theFntSize<20)
       fontQuality := 4

    Gdip_SetTextRenderingHint(G, fontQuality)
    trGdip_GraphicsClear(A_ThisFunc, G, BGRopacity bgrColor)
    ; Gdip_FillRectangle(G, pBr0, -2, -2, dimsFw + 3, dimsFh + 3)
    _E := TextToGraphics(G, theString, txtOptions, fntName, "draw", units, mainObju)
    ; ToolTip, % dims.w "--" dims.h "--" _E , , , 2
    If (flippable=1)
       flipBitmapAccordingToViewPort(clipBMPa, 1)

    Gdip_DeleteGraphics(G)
    ; Gdip_DeleteBrush(pBr0)
    Gdip_DeleteBrush(mainObju.hBrush)
    Gdip_DeleteStringFormat(mainObju.hStrFmt)
    Gdip_DeleteFont(mainObju.hFnt)
    Gdip_DeleteFontFamily(mainObju.hFntFam)
    ; fnOutputDebug("draw text in box: " A_TickCount - startZeit " ms")
    Return clipBMPa
}

TextToGraphics(pGraphics, Text, OptionsObj, Font:="Arial", initMode:=0, Unit:=0, inObj:=0) {

   Static Styles := "Regular|Bold|Italic|BoldItalic|Underline|Strikeout"
        , Alignments := "Near|Left|Centre|Center|Far|Right"

   If (initMode="begin")
   {
      xpos := OptionsObj.x,  ypos := OptionsObj.y
      Width := OptionsObj.w, Height := OptionsObj.w
      Size := OptionsObj.Size

      Style := 0
      For eachStyle, valStyle in StrSplit(Styles, "|")
      {
         If RegExMatch(OptionsObj.Styles, "\b" valStyle)
            Style |= (valStyle != "StrikeOut") ? (A_Index-1) : 8
      }

      Align := 0
      For eachAlignment, valAlignment in StrSplit(Alignments, "|")
      {
         If RegExMatch(OptionsObj.Align, "\b" valAlignment)
            Align |= A_Index//2.1   ; 0|0|1|1|2|2
      }

      hFontFamily := Gdip_FontFamilyCreate(Font)
      If !hFontFamily
         hFontFamily := Gdip_FontFamilyCreateGeneric(1)

      ; ToolTip, % options "`n" size " == " colour , , , 2
      hFont := Gdip_FontCreate(hFontFamily, Size, Style, Unit)
      FormatStyle := InStr(OptionsObj.Styles, "NoWrap") ? 0x4000 | 0x1000 : 0x4000
      hStringFormat := Gdip_StringFormatCreate(FormatStyle)
      If !hStringFormat
         hStringFormat := Gdip_StringFormatGetGeneric(1)

      pBrush := Gdip_BrushCreateSolid(OptionsObj.Color)
      if !(hFontFamily && hFont && hStringFormat && pBrush)
      {
         E := !pGraphics ? -2 : !hFontFamily ? -3 : !hFont ? -4 : !hStringFormat ? -5 : !pBrush ? -6 : 0
         If pBrush
            Gdip_DeleteBrush(pBrush)
         If hStringFormat
            Gdip_DeleteStringFormat(hStringFormat)
         If hFont
            Gdip_DeleteFont(hFont)
         If hFontFamily
            Gdip_DeleteFontFamily(hFontFamily)
         return E
      }

      Gdip_SetStringFormatAlign(hStringFormat, Align)
      If InStr(OptionsObj.Styles, "autotrim")
         Gdip_SetStringFormatTrimming(hStringFormat, 3)

      obju := []
      obju.hfnt := hFont
      obju.hfntFam := hFontFamily
      obju.hStrFmt := hStringFormat
      obju.hBrush := pBrush
      obju.x := xpos,  obju.y := ypos
      obju.w := width, obju.h := height
      ; ToolTip, % hfont "`n" hStringFormat "`n" pBrush , , , 2
      Return obju
   }

   If (initMode="measure")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ; TOOLTIP, % inObj.x "--" inObj.y "--" inObj.w "--" inObj.h , , , 2
      ReturnRC := Gdip_MeasureString(pGraphics, Text, inObj.hFnt, inObj.hStrFmt, RC)
      val := StrSplit(ReturnRC, "|")
      measure := []
      measure.x := Floor(val[1]), measure.y := Floor(val[2])
      measure.w := Ceil(val[3]), measure.h := Ceil(val[4])
      Return measure
   }

   If (initMode="draw")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ReturnRC := Gdip_MeasureString(pGraphics, Text, inObj.hFnt, inObj.hStrFmt, RC)
      ReturnRCtest := StrSplit(ReturnRC, "|")
      testX := Floor(ReturnRCtest[1]) - 2
      If (testX>xpos) ; error correction for different text alignments
      {
         nxpos := Floor(inObj.x - (testX - inObj.x))
         CreateRectF(RC, nxpos, inObj.y, inObj.w, inObj.h)
         ; ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
         ; MsgBox, % nxpos "--" xpos "--" ypos "`n" width "--" height "`n" ReturnRC
      }

      _E := Gdip_DrawString(pGraphics, Text, inObj.hFnt, inObj.hStrFmt, inObj.hBrush, RC)
      Return _E
   }

   return _E ? _E : ReturnRC
}

HardWrapTextFontBased(TextToWrap, hFont, maxW, maxH, lineHeight) {
   ; Critical, on
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
        , maxCharsInWidth := 2048

   if (StrLen(TextToWrap)<=2)
      return TextToWrap

   TextToWrap := Trimmer(TextToWrap)
   thisIndex := thisH := linez := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   hDC := Gdi_GetDC()
   old_hFont := Gdi_SelectObject(hDC, hFont)
   maxLinez := Round(maxH/lineHeight) - 1
   thisCharSpacing := (TextInAreaCharSpacing>0) ? TextInAreaCharSpacing : 0
   Loop, Parse, TextToWrap
   {
       If (maxLinez<linez && linez>1)
          Break

       thisIndex++
       thisLineu .= A_LoopField
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
       {
          linez++
          thisLineu := ""
          thisIndex := hasMatchedRegEx := 0
          Continue
       }

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
          whereHasMatchedinLine := thisIndex
       }

       ; thisObj := Gdi_TruncateStringToFitWidth(hFont, A_Space thisLineu A_Space, maxW - TextInAreaCharSpacing * (StrLen(thisLineu) + 1))
       E := Gdi_GetTextExtentExPoint(hDC, A_Space thisLineu A_Space, maxW - thisCharSpacing * (StrLen(thisLineu) + 1), fitLength, w, h)
       ; ToolTip, % thisObj.fitLength "==" thisObj.width "==" thisObj.height "==" thisObj.stringLength "`n" thisLineu, , , 2
       stringLength := StrLen(thisLineu) + 1
       If (hasMatchedRegEx=1 && (stringLength>fitLength || stringLength>maxCharsInWidth))
       {
          linez++
          offsetu++
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          hasMatchedRegEx := 0
          If (thisLineu=A_Space)
             thisLineu := ""
          thisLineu := SubStr(thisLineu, whereHasMatchedinLine)
          thisIndex := StrLen(thisLineu)
       } Else If (stringLength>fitLength || stringLength>maxCharsInWidth)
       {
          linez++
          thisLineu := ""
          newLinez .= "`n"
          thisIndex := hasMatchedRegEx := 0
       }
   }
   w := Gdi_SelectObject(hDC, old_hFont)
   g := Gdi_ReleaseDC(hDC, 0)
   ; ToolTip, % w "|" g "." foundPos "==" startPos, , , 2
   return newLinez
}

SimpleHardWrapText(TextToWrap, LengthLim) {
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
   LengthLim := Round(LengthLim)
   if (LengthLim<2)
      return TextToWrap
   if (StrLen(TextToWrap) <= LengthLim + 1)
      return TextToWrap

   thisIndex := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   
   Loop, Parse, TextToWrap
   {
       thisIndex++
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
          thisIndex := hasMatchedRegEx := 0

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
       }

       If (thisIndex=LengthLim && hasMatchedRegEx=1)
       {
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          offsetu++
          thisIndex := hasMatchedRegEx := 0
       } Else If (thisIndex=LengthLim)
       {
          newLinez .= "`n"
          thisIndex := hasMatchedRegEx := 0
       }
   }

   ; ToolTip, % foundPos "==" startPos, , , 2
   return newLinez
}

Gdi_DrawTextInBox(theString, hFont, maxW, maxH, txtColor, bgrColor, borderSize:=0, NoWrap:=1, scaleuPreview:=1) {
    startZeit := A_TickCount
    ; dimsu := otherGetStringSize(fntName, theFntSize, 0, theString, NoWrap, maxW)
    ; ToolTip, % dimsu.w "--" dimsu.h " == " NoWrap "`n" theString , , , 2
    thisCharSpacing := Round(TextInAreaCharSpacing / scaleuPreview)
    Gdi_MeasureString(hFont, theString, 1, oW, oH)
    ; Fnt_GetMultilineStringSizeDT(hFont, theString, 1, 0, oW, oH)
    reAdjustWtxtspacing := (Abs(thisCharSpacing)//2) * StrLen(theString)
    reAdjustWtxtspacing := clampInRange(reAdjustWtxtspacing, 1, oW - 5)
    If (thisCharSpacing<0)
       oW := oW - reAdjustWtxtspacing
    Else
       oW := oW + thisCharSpacing * StrLen(theString)
    ; ToolTip, % oW "==" oH "==" reAdjustWtxtspacing , , , 2
    Gdip_GetRotatedDimensions(oW, oH, TextInAreaLineAngle/10, rWidth, rHeight)
    scaleu := Abs(TextInAreaLineAngle/900)
    scaleu2 := Abs((TextInAreaLineAngle*scaleu)/900)
    r_Width := rWidth + borderSize*2
    r_Height := rHeight + borderSize*2
    offsetY := (TextInAreaLineAngle<0) ? r_Width//2 - rWidth//2 : r_Height//2 - rHeight//2 + clampValue(Floor(rHeight*(scaleu*1.9)), "-", rHeight)
    offsetX := (TextInAreaLineAngle<0) ? r_Height//2 - rHeight//2 + Floor(rWidth*scaleu2)  : r_Width//2 - rWidth//2
    If (offsetY<(rHeight - oH + borderSize) && TextInAreaLineAngle>0)
       offsetY := Abs(rHeight - oH + borderSize)

    If (offsetX<borderSize)
       offsetX := borderSize

    If (TextInAreaOnlyBorder!=1 || TextInAreaBorderOut=1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDc, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), "0x" rgb2bgr(bgrColor))
       pBitmap := trGdip_CreateBitmapFromHBITMAP(hbm)
       Gdi_SelectObject(hDc, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hdc)
    }

    If (TextInAreaBorderSize>0 && TextInAreaBorderOut>1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDC, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextOutline(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), Round(TextInAreaBorderSize/scaleuPreview))
       If (TextInAreaBorderOut=3)
          Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x000000")
       pBitmap2 := trGdip_CreateBitmapFromHBITMAP(hbm)
       Gdi_SelectObject(hDC, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hDC)
    }

    ; Gdip_GetImageDimensions(pBitmap, imgW, imgH)
     ; ToolTip, % r_width "=" r_height "`n" hbm "==" hdc "==" obm "`n" imgW "==" imgH, , , 2
    ; fnOutputDebug("draw text in box with GDI: " A_TickCount - startZeit " ms")
    Return [pBitmap, pBitmap2, r_Width, r_Height]
}

coreInsertTextInAreaBox(theString, maxW, maxH, previewMode) {
    Static OBJ_FONT := 6, testString := "This is going to a test"

    Gdip_FromARGB("0xFF" TextInAreaFontColor, A, R, G, B)
    txtColor := Gdip_ToARGB(TextInAreaFontOpacity, R, G, B)
    Gdip_FromARGB("0xFF" TextInAreaBgrColor, A, R, G, B)
    bgrColor := Gdip_ToARGB(TextInAreaBgrOpacity, R, G, B)
    Gdip_FromARGB("0xFF" TextInAreaBorderColor, A, R, G, B)
    borderColor := Gdip_ToARGB(TextInAreaBorderOpacity, R, G, B)

    fntQuality := (previewMode=1) ? 1 : 4
    fntWeight := (TextInAreaFontBold=1) ? 800 : 400
    thisFactor := (zoomLevel<0.45 || TextInAreaFontSize>300) ? 10 : 5
    If (TextInAreaFontSize>650)
       thisFactor := 15

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    thisFactor := ((mainWidth + mainHeight)//150 + thisFactor)//2 + TextInAreaFontSize//200
    If (zoomLevel>0.8 && thisFactor>3)
       thisFactor := 3
    If (TextInAreaFontSize<35)
       thisFactor := 1

    thisLineAngle := (TextInAreaLineAngle<0) ? 3600 + TextInAreaLineAngle : TextInAreaLineAngle
    If !isNumber(thisLineAngle)
       thisLineAngle := 0

    hFontPreview := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize//thisFactor, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    hFont := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    If (Gdi_GetObjectType(hFont)!="FONT")
       Return "fail"

    thisBlurAmount := max(TextInAreaBlurAmount, TextInAreaBlurBorderAmount) // 2
    borderSize := (TextInAreaUsrMarginz>0) ? TextInAreaUsrMarginz : TextInAreaBorderSize//2 + thisBlurAmount
    Gdi_MeasureString(hFont, testString, 1, testWa, testHa)
    Gdi_MeasureString(hFontPreview, testString, 1, testWb, testHb)
    If (TextInAreaAutoWrap=1)
       theString := Trimmer(HardWrapTextFontBased(theString, hFont, maxW - borderSize * 2, maxH + 2, clampInRange(testHa + TextInAreaFontLineSpacing, 2, maxH + 10)))
    Else
       theString := Trimmer(theString)

    scaleuPreview := (previewMode=1) ? testWa/testWb : 1
    ; ToolTip, % thisFactor "==" scaleuPreview , , , 2
    ; ToolTip, % testWa "==" testHa "`n" testWb "==" testHb "`n" testWa/testWb , , , 2
    maxW := Round(maxW / scaleuPreview) ; + Round(5*TextInAreaFontSize*scaleuPreview)
    maxH := Round(maxH / scaleuPreview) ; + TextInAreaFontSize*2
    mainBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, "0xE200B")
    If warnUserFatalBitmapError(mainBMP, A_ThisFunc)
       Return "fail"

    thisBlur := Round(TextInAreaBlurAmount / scaleuPreview)
    If (thisBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
       pEffect := Gdip_CreateEffect(1, thisBlur, 0, 0)

    thisBorderBlur := Round(TextInAreaBlurBorderAmount / scaleuPreview)
    If (thisBorderBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
       zEffect := Gdip_CreateEffect(1, thisBorderBlur, 0, 0)

    zBrush := Gdip_BrushCreateSolid(bgrColor)
    thisQuality := (previewMode=1) ? 5 : 7
    G := trGdip_GraphicsFromImage(A_ThisFunc, mainBMP, thisQuality)
    ; If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
    ;    trGdip_GraphicsClear(A_ThisFunc, G, "0xFF000000")

    thisY := thisX := 0
    maxedW := maxedH := 0
    minedX := maxW, minedY := maxH
    doConturDraw := (TextInAreaBorderSize>0 && TextInAreaBorderOut>1) ? 1 : 0
    If (previewMode=1)
       borderSize := Round(borderSize/scaleuPreview)

    thisHFont := (previewMode=1) ? hFontPreview : hFont
    rescaleWidthCharSpacing := (TextInAreaCharSpacing<0) ? (100 - Abs(TextInAreaCharSpacing))/90 : 1
    threads := (previewMode=1) ? realSystemCores//2 : 0
    Loop, Parse, theString, `n
    {
       ; If !Trimmer(A_LoopField)
       ;    Continue

       objBMPs := Gdi_DrawTextInBox(A_Space A_LoopField A_Space, thisHFont, maxW, maxH, "FFffFF", "000000", borderSize, 1, scaleuPreview)
       imgW := objBMPs[3], imgH := objBMPs[4]
       pBitmap := (doConturDraw=1 && TextInAreaOnlyBorder=1 && objBMPs[2]) ? objBMPs[2] : objBMPs[1]
       If (doConturDraw=1 && objBMPs[1] && TextInAreaOnlyBorder=1)
          trGdip_DisposeImage(objBMPs[1])

       pBitmapContours := objBMPs[2]
       If (TextInAreaAlign=2)
          thisX := maxW//2 - imgW//2
       If (TextInAreaAlign=3)
          thisX := maxW - imgW

       If (pEffect && (TextInAreaBgrUnified!=1 || TextInAreaPaintBgr!=1))
          Gdip_BitmapApplyEffect(pBitmap, pEffect)

       thisBMP := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
       If StrLen(thisBMP)<3
       {
          fattalErr := 1
          trGdip_DisposeImage(pBitmap, 1)
          Break
       }

       G2 := trGdip_GraphicsFromImage(A_ThisFunc, thisBMP)
       If (TextInAreaCutOutMode=1 && TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1)
       {
          ; trGdip_GraphicsClear(A_ThisFunc, G2)
          Gdip_FillRectangle(G2, zBrush, 0, 0, imgW, imgH)
          QPV_SetAlphaChannel(thisBMP, pBitmap, 1, 0, 1, threads)
          thisOpacity := TextInAreaBgrOpacity/255
       } Else
       {
          thisColor := (TextInAreaOnlyBorder=1) ? borderColor : txtColor
          trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
          QPV_SetAlphaChannel(thisBMP, pBitmap, 0, 0, 1, threads)
          thisOpacity := 1
       }

       If (TextInAreaBgrUnified!=1 && TextInAreaPaintBgr=1)
       {
          If (TextInAreaCutOutMode!=1)
             Gdip_FillRectangle(G, zBrush, thisX, thisY, imgW, imgH)

          If (TextInAreaBgrEntire=1)
          {
             Gdip_SetClipRect(G, 0, thisY, maxW, imgH)
             Gdip_SetClipRect(G, thisX, thisY, imgW, imgH, 4)
             Gdip_FillRectangle(G, zBrush, 0, thisY, maxW, imgH)
             Gdip_ResetClip(G)
          }
       }

       forceW := (imgW>=maxW) ? maxW : imgW
       If (rescaleWidthCharSpacing<1)
       {
          phorceW := Round(forceW*rescaleWidthCharSpacing)
          forceW -= (forceW - phorceW)//2.5
       }

       If (doConturDraw=1 && TextInAreaOnlyBorder!=1 && pBitmapContours)
       {
          If zEffect
             Gdip_BitmapApplyEffect(pBitmapContours, zEffect)
          thizBMP := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
          G5 := trGdip_GraphicsFromImage(A_ThisFunc, thizBMP)
          trGdip_GraphicsClear(A_ThisFunc, G5, borderColor)
          QPV_SetAlphaChannel(thizBMP, pBitmapContours, 0, 0, 1, threads)
          trGdip_DrawImage(A_ThisFunc, G, thizBMP, thisX, thisY,forceW,imgH,,,,, thisOpacity)
          trGdip_DisposeImage(pBitmapContours, 1)
          trGdip_DisposeImage(thizBMP, 1)
          Gdip_DeleteGraphics(G5)
       }

       maxedW := max(forceW, maxedW)
       maxedH := max(thisY + imgH, maxedH)
       minedX := min(thisX, minedX)
       minedY := min(thisY, minedY)
       drawFail := trGdip_DrawImage(A_ThisFunc, G, thisBMP, thisX, thisY,forceW,imgH,,,,, thisOpacity)
       If (previewMode=1)
          thisY += imgH + Round(TextInAreaFontLineSpacing / scaleuPreview)
       Else
          thisY += imgH + TextInAreaFontLineSpacing
       trGdip_DisposeImage(pBitmap, 1)
       trGdip_DisposeImage(thisBMP, 1)
       Gdip_DeleteGraphics(G2)
       If (drawFail="fail")
       {
          fattalErr := 1
          Break
       }
    }

    If (fattalErr=1)
       warnUserFatalBitmapError("no-gdip", A_ThisFunc)

    Gdi_DeleteObject(hFont)
    Gdi_DeleteObject(hFontPreview)
    minedX := clampInRange(minedX, 0, maxW)
    minedY := clampInRange(minedY, 0, maxH)
    maxedW := clampInRange(maxedW, 1, maxW)
    maxedH := clampInRange(maxedH, 1, maxH)
    ; ToolTip, % maxedW "==" maxedH " = " minedX "==" minedY , , , 2
    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
    {
       newBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, "0xE200B")
       warnUserFatalBitmapError(newBMP, A_ThisFunc)
    }

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1 && StrLen(newBMP)>2)
    {
       If pEffect
          Gdip_BitmapApplyEffect(mainBMP, pEffect)

       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBMP)
       If (TextInAreaRoundBoxBgr=1)
       {
          radius := Round(((maxedW + borderSize*2 + maxedH)//2.5)*0.1) + 1
          kPath := Gdip_CreatePath()
          Gdip_AddPathRoundedRectangle(kPath, minedX, minedY, maxedW, maxedH, radius)
          Gdip_SetClipPath(G3, kPath)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
          Gdip_DeletePath(kPath)
       } Else
       {
          Gdip_SetClipRect(G3, minedX, minedY, maxedW, maxedH)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
       }
       Gdip_ResetClip(G3)
       trGdip_DrawImage(A_ThisFunc, G3, mainBMP, 0, 0)
       ; QPV_SetAlphaChannel(newBMP, mainBMP, TextInAreaCutOutMode)
       trGdip_DisposeImage(mainBMP, 1)
       mainBMP := newBMP
       Gdip_DeleteGraphics(G3)
    }

    Gdip_DeleteGraphics(G)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    Gdip_DeleteBrush(zBrush)
    obju := [mainBMP, minedX, minedY, maxedW, maxedH, scaleuPreview]
    Return obju
}

drawHistogram(dataArray, maxYlimit, LengthX, Scale, fgrColor, bgrColor, borderSize, infoBoxBMP) {
    Static graphHeight := 300 ; graph height
         , barWidth := 2
    ; ToolTip, % maxYlimit " || " LengthX  , , , 2
    PointsList .= -1 "," graphHeight + 1 "|"
    Loop, % LengthX
    {
        skipThis := 0
        y1 := dataArray[A_Index - 1]/maxYlimit
        If !y1
        {
           y1 := 0
           skipThis := 1
        }

        y1 := graphHeight - Round(graphHeight * y1)
        If (y1<0)
           y1 := 0
        Else If (y1>graphHeight - 1) && (skipThis=0)
           y1 := graphHeight - 1
        thisIndex := A_Index * barWidth - barWidth
        PointsList .= thisIndex - 1 ","  y1 "|" thisIndex ","  y1 "|"
    }

    PointsList .= thisIndex + 1 "," graphHeight + 1
    graphPath := Gdip_CreatePath()
    Gdip_AddPathPolygon(graphPath, PointsList) ; , 0.000001)
    pMatrix := Gdip_CreateMatrix()
    Gdip_ScaleMatrix(pMatrix, Scale/2, Scale/2, 1)
    Gdip_TransformPath(graphPath, pMatrix)
    thisRect := Gdip_GetPathWorldBounds(graphPath)
    imgW := Ceil(thisRect.w), imgH := Ceil(thisRect.h) + 1
    clipBMPa := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
    If StrLen(clipBMPa)<2
    {
       Gdip_DeletePath(graphPath)
       Gdip_DeleteMatrix(pMatrix)
       Return
    }

    G := trGdip_GraphicsFromImage(A_ThisFunc, clipBMPa, 7, 4)
    If G
    {
       If infoBoxBMP
          Gdip_GetImageDimensions(infoBoxBMP, imgW2, imgH2)

       clipBMP := trGdip_CreateBitmap(A_ThisFunc, imgW + borderSize * 2, imgH + Round(imgH2) + Round(borderSize*1.5), "0xE200B")
       If StrLen(clipBMP)<2
       {
          Gdip_DeletePath(graphPath)
          Gdip_DeleteMatrix(pMatrix)
          trGdip_DisposeImage(clipBMPa, 1)
          Gdip_DeleteGraphics(G)
          Return
       }

       G3 := trGdip_GraphicsFromImage(A_ThisFunc, clipBMP)
       If G3
       {
          pBr1 := Gdip_BrushCreateSolid(fgrColor)
          Gdip_FillPath(G, pBr1, graphPath)
          Gdip_GetImageDimensions(clipBMP, maxW, maxH)
          lineThickns := borderSize//8
          Gdip_SetPenWidth(pPen1d, lineThickns)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
          ; Gdip_FillRectangle(G3, pBr0, -2, -2, maxW + borderSize*2+12, maxH + borderSize*3)
          Gdip_FillRectangle(G3, pBrushE, borderSize, borderSize, imgW, imgH)
          Gdip_DrawRectangle(G3, pPen1d, borderSize - lineThickns, borderSize - lineThickns, imgW + lineThickns*2, imgH + lineThickns*2)
          HUDobjHistoBoxu[5] := imgW + lineThickns*2 + borderSize
          HUDobjHistoBoxu[6] := imgH + lineThickns*2 + borderSize
          trGdip_DrawImage(A_ThisFunc, G3, clipBMPa, borderSize, borderSize)
          trGdip_DrawImage(A_ThisFunc, G3, infoBoxBMP, borderSize//3, imgH + borderSize*1.25)
          Gdip_DeleteGraphics(G3)
       }

       Gdip_DeleteGraphics(G)
       Gdip_DeletePath(graphPath)
       Gdip_DeleteMatrix(pMatrix)
       Gdip_DeleteBrush(pBr1)
    } Else clipBMP := ""
    trGdip_DisposeImage(clipBMPa, 1)
    ; ToolTip, % clipBMPa  "`n" clipBmp , , , 2
    ; tooltip, % maxYlimit ", " LengthX " || "  maxW "," maxH  ;  `n" PointsList
    Return clipBMP
}

PasteInPlaceNow() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : useGdiBitmap()
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       corePasteInPlaceActNow("kill")
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    startZeit := A_TickCount
    If (UserMemBMP!=whichBitmap)
    {
       whichBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)
       wasClone := whichBitmap
    } Else If warnUserFatalBitmapError(whichBitmap, A_ThisFunc)
    {
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    If StrLen(whichBitmap)<3
    {
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    ; pixFmt := Gdip_GetImagePixelFormat(whichBitmap, 2)
       ; E := Gdip_BitmapSetColorDepth(whichBitmap, 32, ColorDepthDithering)

    thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, thisImgQuality, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(wasClone, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    recordUndoLevelNow("init", 0)
    ; setImageLoading()
    r1 := corePasteInPlaceActNow(G2, whichBitmap)
    If (PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1)
       currIMGdetails.HasAlpha := 1

    Gdip_DeleteGraphics(G2)
    corePasteInPlaceActNow("kill")
    If (r1!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    zeitOperation := A_TickCount - startZeit

    addJournalEntry(A_ThisFunc "(): transformations ended. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    SetTimer, RefreshImageFile, -25
}

realtimePasteInPlaceRotater(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState, hasRotated
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation vPselRotation prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex PasteInPlaceBlurEdgesSoft
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return hasRotated
    }

    hasRotated := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return 0

    Gdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    Gdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := JimgW/vpImgW

    Gdip_GetImageDimensions(clipBMP, eImgW, eImgH)
    If (PasteInPlaceOrientation=2)
       ER := Gdip_ImageRotateFlip(clipBMP, 4)
    Else If (PasteInPlaceOrientation=3)
       ER := Gdip_ImageRotateFlip(clipBMP, 6)
    Else If (PasteInPlaceOrientation=4)
       ER := Gdip_ImageRotateFlip(clipBMP, 2)

    Gdip_GetRotatedDimensions(JimgW, JimgH, vPselRotation, testW, testH)
    If (testW*testH>maxGDIbmpSize) || (testW>32500) || (testH>32500)
       notOkayRotate := 1

    If (vPselRotation>0 && notOkayRotate!=1 && !ER)
    {
       setWindowTitle("Rotating image at " vPselRotation "°")
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, clipBMP, vPselRotation,"", thisImgQuality)
       If StrLen(xBitmap)>3
       {
          hasRotated := 1
          ; If (previewMode=1)
             clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
    }

    If (prevEllipseSelectMode>0 && PasteInPlaceToolMode=1 && vPselRotation>0 && hasRotated=1)
    {
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       Gdip_GetRotatedEllipseDimensions(eImgW, eImgH, vPselRotation, pBw, pBh)
       gFx := pBw/rimgW
       gFy := pBh/rimgH
       zwImgW := Round(rImgW * gFx)
       zwImgH := Round(rImgH * gFy)
       dX := (rImgW - zwImgW)//2
       dY := (rImgH - zwImgH)//2
       xBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP, dX, dY, zwImgW, zwImgH)
       If StrLen(xBitmap)>3
       {
          clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
       ; ToolTip, % gFx " --- " gFy "`n" zwImgW " --- " zwImgH "`n" rImgW " --- " rImgH "`n" dX " --- " dY "`n" clipBMP , , , 2
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    Return hasRotated
}

createSelectionBlurryMask() {
    wPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    pB := GetPathRelativeBounds(wPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h
    Gdip_DeletePath(wPath)
    bRa := (EllipseSelectMode>0 || VPselRotation>0) ? blurAreaAmount*2 : blurAreaAmount
    gImgselPx := imgSelPx - bRa
    gImgselPy := imgSelPy - bRa
    gImgSelW := imgSelW + bRa * 2
    gImgselH := imgSelH + bRa * 2
}

realtimePasteInPlaceBlurrator(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState
    newBitmap := ""

    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }
    thisState := "a" userClipBMPpaste PasteInPlaceBlurEdgesSoft viewportStampBMP previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex PasteInPlaceAdaptMode
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return
    }
 
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    clipBMP := trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return "fail"

    Gdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    Gdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := vpImgW/JimgW
    thisAmount := 0
    If (PasteInPlaceBlurAmount>0)
    {
       setWindowTitle("Applying blur filter on image")
       If (previewMode!=1)
          QPV_SetGivenAlphaLevel(clipBMP, 1, 1)
       thisAmount := (previewMode=1) ? Round(PasteInPlaceBlurAmount * fScale) : PasteInPlaceBlurAmount
       thisAmount := clampInRange(thisAmount, 1, 255)
       pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, clipBMP, thisAmount, pEffect, previewMode)
       Gdip_DisposeEffect(pEffect)
    }

    If (PasteInPlaceToolMode=1) ; && (prevVPselRotation>0 || prevEllipseSelectMode>0))
    {
       eimgW := max(prevImgSelX1, prevImgSelX2) - min(prevImgSelX1, prevImgSelX2)
       eimgH := max(prevImgSelY1, prevImgSelY2) - min(prevImgSelY1, prevImgSelY2)
       decX := prevImgSelX1 - VPstampBMPx
       decY := prevImgSelY1 - VPstampBMPy
       If (previewMode=1)
       {
          Gdip_GetImageDimensions(clipBMP, wImgW, wImgH)
          Gdip_GetImageDimensions(userClipBMPpaste, gImgW, gImgH)
          scaleu := gImgW/wImgW
          eimgW := Round(eimgW/scaleu)
          eimgH := Round(eimgH/scaleu)
          decX := Round(decX/scaleu)
          decY := Round(decY/scaleu)
       }

       pPath := createImgSelPath(0, 0, eImgW, eImgH, prevEllipseSelectMode, prevVPselRotation, prevrotateSelBoundsKeepRatio)
       If pPath
       {
          carvePathFromBitmap(clipBMP, pPath, -decX, -decY, 4, PasteInPlaceBlurEdgesSoft + 1, thisAmount)
          Gdip_DeletePath(pPath)
       }
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    Return
}

realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlphaBMP, rImgW, rImgH, thisImgQuality:=0) {
    Static prevBMPu, prevState
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisBMP := userAlphaBMP
    thisChan := (PasteInPlaceAlphaChannelFile=5) ? 1 : 0
    thisState := "a" previewMode PasteInPlaceAlphaFile getIDimage(currentFileIndex) currentFileIndex FillAreaGradientAngle thisChan
    If (thisState=prevState && prevBMPu)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       trGdip_DisposeImage(thisBMP, 1)
       Return newBitmap
    }

    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    If (PasteInPlaceAlphaChannelFile=5)
    {
       bmpGray := retrieveImgChannel(thisBMP, PasteInPlaceAlphaChannelFile)
       If StrLen(bmpGray)>1
       {
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := bmpGray
       }
    }

    If (FillAreaGradientAngle>0 && thisBMP)
    {
       changeMcursor()
       thisMono := (FillAreaColorReversed!=1) ? "0xFF000000" : "0xFFFFFFFF"
       thisMonoBrush := Gdip_BrushCreateSolid(thisMono)
       xMask := trGdip_RotateBitmapAtCenter(A_ThisFunc, thisBMP, FillAreaGradientAngle, thisMonoBrush, thisImgQuality)
       If StrLen(xMask)>2
       {
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := xMask
       } Else ER := "fail"
       Gdip_DeleteBrush(thisMonoBrush)
    } Else If !thisBMP
       ER := "fail"

    If ER
    {
       trGdip_DisposeImage(thisBMP, 1)
       Return
    }

    alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, thisBMP, rImgW, rImgH, 0, thisImgQuality, -1)
    trGdip_DisposeImage(thisBMP, 1)

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : alphaMaskGray
    prevState := thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? alphaMaskGray : trGdip_CloneBitmap(A_ThisFunc, alphaMaskGray)
    Return newBitmap
}

useGdiBitmap() {
   If StrLen(gdiBitmap)>3
      Return gdiBitmap
   Else If StrLen(UserMemBMP)>3
      Return UserMemBMP
   Else Return
}

retrieveImgChannel(pBitmap, convertGray) {
   If isInRange(convertGray, 1, 4)
   {
      bmpGray := trGdip_RetrieveBitmapChannel(pBitmap, convertGray)
   } Else If (convertGray=5)
   {
      thisValue := (isWinXP=1) ? 0 : -45
      bmpGray := trGdip_BitmapConvertGray(pBitmap, 0, thisValue, 1, 0, "0xE200B")
   }
   Return bmpGray
}

LoadCachableBitmapFromFile(imgPath) {
   Static prevBMPu, prevState
   If (imgPath="kill")
   {
      prevState := 0
      prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
      Return
   }

   thisState := "a" generateThumbName(imgPath, 1) "=-=b"
   If (thisState=prevState && prevBMPu && FileRexists(imgPath))
   {
      newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
      Return newBitmap
   }

   prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
   pBitmap := LoadBitmapFromFileu(imgPath)
   If pBitmap
   {
      zBitmap := cloneGDItoMem(A_ThisFunc, pBitmap)
      If zBitmap
      {
         trGdip_DisposeImage(pBitmap, 1)
         pBitmap := zBitmap
      }
   } Else
   {
      addJournalEntry(A_ThisFunc "() failed: unable to load image file")
      Return
   }

   prevBMPu := (minimizeMemUsage=1) ? 0 : pBitmap
   prevState := (pBitmap && minimizeMemUsage!=1) ? thisState : 0

   If pBitmap
      newBitmap := (minimizeMemUsage=1) ? pBitmap : trGdip_CloneBitmap(A_ThisFunc, pBitmap)
   Return newBitmap
}

QPV_SetAlphaChannel(pBitmap, pBitmapMask, invertAlphaMask:=0, replaceSourceAlphaChannel:=0, whichChannel:=1, threads:=0) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_SetAlphaChannel(pBitmap, pBitmapMask, invertAlphaMask, replaceSourceAlphaChannel, whichChannel)
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmapMask, w2, h2)
  If (w2!=w || h2!=h || !pBitmap || !pBitmapMask)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  E2 := Gdip_LockBits(pBitmapMask, 0, 0, w, h, stride, mScan, mData)
  func2exec := (A_PtrSize=8) ? "SetAlphaChannel" : "_SetAlphaChannel@32"
  If (!E1 && !E2)
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", invertAlphaMask, "Int", replaceSourceAlphaChannel, "Int", whichChannel, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmapMask, mData)
  ; ToolTip, % "qpv_alpha " A_TickCount - thisStartZeit, , , 2
  return r
}


QPV_SetGivenAlphaLevel(pBitmap, givenLevel, fillMissingOnly, threads:=0) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If isWinXP
     Return

  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !pBitmap)
  {
     addJournalEntry(A_ThisFunc "(): failed - possibly malformed pBitmap given: " pBitmap)
     Return 0
  }

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  func2exec := (A_PtrSize=8) ? "SetGivenAlphaLevel" : "_SetGivenAlphaLevel@32"
  If !E1
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", givenLevel, "Int", fillMissingOnly, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  ; ToolTip, % "qpv_alpha " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_BlendBitmaps(pBitmap, pBitmap2Blend, blendMode, threads) {
  initQPVmainDLL()
  If (!qpvMainDll || isWinXP=1)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BlendBitmaps(pBitmap, pBitmap2Blend, clampInRange(blendMode, 1, 18))
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmap2Blend, w2, h2)
  ; ToolTip, % w "=" w2 "||" h "=" h2 , , , 2
  If (w2!=w || h2!=h || !pBitmap || !pBitmap2Blend)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  E2 := Gdip_LockBits(pBitmap2Blend, 0, 0, w, h, stride, mScan, mData)
  func2exec := (A_PtrSize=8) ? "BlendBitmaps" : "_BlendBitmaps@24"
  If (!E1 && !E2)
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", blendMode, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmap2Blend, mData)
  ; ToolTip, % "r=" r " ; qpv == " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_CreateBitmapNoise(W, H, intensity, mode, threads) {
  initQPVmainDLL()
  If (!qpvMainDll || isWinXP=1)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BlendBitmaps(pBitmap, pBitmap2Blend, clampInRange(blendMode, 1, 18))
  }

  thisStartZeit := A_TickCount
  If (!w || !h)
     Return 0

  pBitmap := trGdip_CreateBitmap(A_ThisFunc, W, H, "0xE200B")
  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  func2exec := (A_PtrSize=8) ? "RandomNoise" : "_RandomNoise@24"
  If !E1
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", intensity, "Int", mode, "Int", threads)

  ; ToolTip, % E1 "==" r " == " pBitmap "==" W "x" H, , , 2
  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  ; ToolTip, % "r=" r " ; qpv == " A_TickCount - thisStartZeit, , , 2
  return pBitmap
}

QPV_InStr(strBase, str2find) {
  return DllCall("qpvmain.dll\isInString", "WStr", strBase, "WStr", str2find)
  ; ToolTip, % r " = r" , , , 2
}

realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState
    If (previewMode="kill")
    {
       prevState := 0
       realtimePasteInPlaceAlphaMaskRotator("kill", 0, 0, 0)
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    If (coreDesiredPixFmt="0x21808")
       Return

    thisState := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation vPselRotation PasteInPlaceAlphaMaskClrA PasteInPlaceAlphaMaskClrB PasteInPlaceAlphaMaskMode PasteInPlaceAlphaFile alphaMaskReplaceMode FillAreaGradientWrapped FillAreaColorReversed FillAreaGradientScale FillAreaGradientAngle FillAreaGradientSigma FillAreaGradientBlend alphaMaskOffsetX alphaMaskOffsetY PasteInPlaceAlphaChannelFile
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return
    }

    setWindowTitle("Applying alpha mask to image")
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)

    If (PasteInPlaceAlphaFile="self" || PasteInPlaceAlphaFile="this")
       PasteInPlaceAlphaFile := currentFileIndex
    Else If (PasteInPlaceAlphaFile="prev")
       PasteInPlaceAlphaFile := currentFileIndex - 1
    Else If (PasteInPlaceAlphaFile="next")
       PasteInPlaceAlphaFile := currentFileIndex + 1
    Else If (PasteInPlaceAlphaFile="last")
       PasteInPlaceAlphaFile := maxFilesIndex
    Else If (PasteInPlaceAlphaFile="first" || PasteInPlaceAlphaFile=0)
       PasteInPlaceAlphaFile := 1
    Else If (PasteInPlaceAlphaFile="obj")
       PasteInPlaceAlphaFile := -1

    thisAlphaFile := IsNumber(PasteInPlaceAlphaFile) ? getIDimage(PasteInPlaceAlphaFile) : PasteInPlaceAlphaFile
    If (isFileLocked(thisAlphaFile) && currentFileIndex!=PasteInPlaceAlphaFile)
       thisAlphaFile := ""

    ; ToolTip, % "l" PasteInPlaceAlphaMaskMode "==" thisAlphaFile "==" clipBMP "==" PasteInPlaceAlphaFile, , , 2
    clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return

    If (PasteInPlaceAlphaMaskMode=5 && (FileRexists(thisAlphaFile) || PasteInPlaceAlphaFile=-1))
    {
       If (PasteInPlaceAlphaFile=-1)
          userAlpha := (previewMode=1) ? trGdip_CloneBitmap(A_ThisFunc, viewportStampBMP) : trGdip_CloneBitmap(A_ThisFunc, userClipBMPpaste)
       Else
          userAlpha := (useGdiBitmap() && PasteInPlaceAlphaFile=currentFileIndex) ? trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap()) : LoadCachableBitmapFromFile(thisAlphaFile)

       ; ToolTip, % thisAlphaFile "--" PanelPasteInPlace "--" userAlpha , , , 2
       Gdip_GetImageDimensions(userAlpha, testImgW, testImgH)
       threads := (previewMode=1) ? realSystemCores//2 : 0
       If (StrLen(userAlpha)>2 && testImgW && testImgH)
       {
          Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
          brLvl := Round(PasteInPlaceAlphaMaskClrA/255*510-255)
          contrLvl := Round(PasteInPlaceAlphaMaskClrB/255*100)
          thisAlphaBlur := Round((FillAreaGradientScale - 1)/305 * 255)
          alphaMaskGray := realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlpha, rImgW, rImgH, thisImgQuality)
          If !alphaMaskGray
          {
             addJournalEntry(A_ThisFunc ": failed to rotate alpha mask.")
             Return
          }

          pEffect := Gdip_CreateEffect(5, brLvl, contrLvl)
          pBlurEffect := Gdip_CreateEffect(1, thisAlphaBlur, 0)
          Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
          If (thisAlphaBlur>1)
             Gdip_BitmapApplyEffect(alphaMaskGray, pBlurEffect)
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeEffect(pBlurEffect)
          thisChannel := (PasteInPlaceAlphaChannelFile=5) ? 1 : PasteInPlaceAlphaChannelFile
          QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode, thisChannel, threads)
          ; ToolTip, % clipBMP "--" alphaMaskGray "--" userAlpha , , , 2
          ResetImgLoadStatus()
          trGdip_DisposeImage(alphaMaskGray, 1)
       } Else addJournalEntry(A_ThisFunc ": failed to retrieve alpha mask image.")
       SetTimer, ResetImgLoadStatus, -100
    } Else If (PasteInPlaceAlphaMaskMode=6 && customShapePoints.Count()>1)
    {
       tensionLvl := Round(PasteInPlaceAlphaMaskClrB/255, 2)
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       alphaMaskGray := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
       If warnUserFatalBitmapError(alphaMaskGray, A_ThisFunc)
          Return "fail"

       pEffect := Gdip_CreateEffect(1, PasteInPlaceAlphaMaskClrA, 0)
       alphaPath := Gdip_CreatePath()
       fAgScal := (FillAreaGradientScale + 2)/100
       tempArray := StrSplit(initialCustomShapeCoords, "|")
       calcIMGdimensions(tempArray[3], tempArray[4], rImgW, rImgH, rW, rH)
       tRimgW := (tempArray[3]>1) ? Round(rW*fAgScal) : Round(rImgW*fAgScal)
       tRimgH := (tempArray[4]>1) ? Round(rH*fAgScal) : Round(rImgH*fAgScal)
       offX := rImgW - tRimgW + Round((rImgW*alphaMaskOffsetX)*(fAgScal+1))
       offY := rImgH - tRimgH + Round((rImgH*alphaMaskOffsetY)*(fAgScal+1))
       PointsList := convertCustomShape2givenArea(customShapePoints, 1 + offX//2, 1 + offY//2, tRimgW - 2, tRimgH - 2)
       If (PasteInPlaceAlphaMaskClrB<15 && alphaPath)
          Gdip_AddPathPolygon(alphaPath, PointsList)
       Else If alphaPath
          Gdip_AddPathClosedCurve(alphaPath, PointsList, tensionLvl)

       If (FillAreaGradientAngle>0 && alphaPath)
          Gdip_RotatePathAtCenter(alphaPath, FillAreaGradientAngle)

       G4 := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray, 7, 4)
       trGdip_GraphicsClear(A_ThisFunc, G4, "0xFF000000")
       ; BrushA := Gdip_BrushCreateSolid("0xFF000000")
       ; Gdip_FillRectangle(G4, BrushA, -2, -2, rImgW + 2, rImgH + 2)
       If G4
       {
          BrushB := Gdip_BrushCreateSolid("0xFFFFFFFF")
          Gdip_FillPath(G4, BrushB, alphaPath)
          Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
          QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode, threads)
       }
       ResetImgLoadStatus()
       Gdip_DisposeEffect(pEffect)
       Gdip_DeletePath(alphaPath)
       ; Gdip_DeleteBrush(BrushA)
       Gdip_DeleteBrush(BrushB)
       Gdip_DeleteGraphics(G4)
       trGdip_DisposeImage(alphaMaskGray, 1)
       SetTimer, ResetImgLoadStatus, -100
       ; trGdip_DisposeImage(clipBmp, 1)
       ; clipBmp := alphaMaskGray
    } Else If isInRange(PasteInPlaceAlphaMaskMode, 2, 4)
    {
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       alphaMaskGray := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
       If warnUserFatalBitmapError(alphaMaskGray, A_ThisFunc)
          Return "fail"

       zpw := PasteInPlaceAlphaMaskClrA
       zpu := PasteInPlaceAlphaMaskClrB
       thisColorA := Gdip_ToARGB("0xFF", zpw, zpw, zpw)
       thisColorB := Gdip_ToARGB("0xFF", zpu, zpu, zpu)
       ; ToolTip, % thisColorA "`n" thisColorB, , , 2
       brImgSelW := rImgW*(FillAreaGradientScale/100)
       brImgSelH := rImgH*(FillAreaGradientScale/100)
       brimgSelPx := 0 - (brImgSelW - rImgW)//2
       brimgSelPy := 0 - (brImgSelH - rImgH)//2
       gradientWrapMode := (FillAreaGradientWrapped=1) ? 3 : 4
       If (PasteInPlaceAlphaMaskMode=2)
       {
          gradBrush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + Round(brImgSelW*alphaMaskOffsetX), brimgSelPy + Round(brImgSelH*alphaMaskOffsetY), brimgSelW, brimgSelH, thisColorA, thisColorB, 1, FillAreaGradientWrapped)
          If gradBrush
          {
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, 0, FillAreaGradientSigma/100, FillAreaGradientBlend/100, 1, thisColorA, thisColorA, thisColorB, thisColorB)
             Gdip_RotateLinearGrBrushAtCenter(gradBrush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
             Gdip_SetLinearGrBrushWrapMode(gradBrush, gradientWrapMode)
          }
       } Else If (PasteInPlaceAlphaMaskMode=3 || PasteInPlaceAlphaMaskMode=4)
       {
          grpPath := Gdip_CreatePath()
          If (PasteInPlaceAlphaMaskMode=3 && grpPath)
             Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
          Else If grpPath
             Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

          If grpPath
             gradBrush := Gdip_PathGradientCreateFromPath(grpPath)

          If gradBrush
          {
             Gdip_PathGradientSetCenterPoint(gradBrush, 0 + rImgW//2 + Round(rImgW*alphaMaskOffsetX), 0 + rImgH//2 + Round(rImgH*alphaMaskOffsetY))
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, 0, FillAreaGradientSigma/100, FillAreaGradientBlend/100, 1, thisColorA, thisColorA, thisColorB, thisColorB)
             Gdip_RotatePathGradientAtCenter(gradBrush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
             Gdip_PathGradientSetWrapMode(gradBrush, gradientWrapMode)
          }

          Gdip_DeletePath(grpPath)
       }

       thisEllipsMod := (PasteInPlaceToolMode>0) ? prevEllipseSelectMode : EllipseSelectMode
       Ga := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray)
       ; thisColorC := (FillAreaColorReversed=1) ? 
       If Ga
       {
          pPath := createImgSelPath(-Round(rImgW*0.2), -Round(rImgH*0.2), Round(rImgW*1.45), Round(rImgH*1.45), thisEllipsMod)
          trGdip_GraphicsClear(A_ThisFunc, Ga, thisColorB)
          If pPath
             Gdip_FillPath(Ga, gradBrush, pPath)

          QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode, threads)
       }

       Gdip_DeletePath(pPath)
       Gdip_DeleteBrush(gradBrush)
       Gdip_DeleteGraphics(Ga)
       ; trGdip_DisposeImage(clipBMP, 1)
       ; clipBMP := newBitmap
       trGdip_DisposeImage(alphaMaskGray, 1)
       ; clipBMP := alphaMask
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    Return
}

addBorder2Bitmap(ByRef pBitmap, aX, aY, bgrColor:=0) {
    Gdip_GetImageDimensions(pBitmap, imgW, imgH)
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW + aX*2, imgH + aY*2, "0xE200B")
    If newBitmap
    {
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
       {
          If bgrColor
             trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor, 1)

          r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap, 0, 0, imgW + aX*2, imgH + aY*2)
          r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap, aX, aY)
          If (r2!="fail")
          {
             trGdip_DisposeImage(pBitmap, 1)
             pBitmap := newBitmap
             Return 1
          }
          Gdip_DeleteGraphics(G3)
       }
    }
}

corePasteInPlaceActNow(G2:=0, whichBitmap:=0) {
    Static prevImgCall, prevClipBMP, eImgW, eImgH, hasRotated, thisHasRan
         , lastInvoked := 1

    If (G2="kill" && thisHasRan=1)
    {
       ; fnOutputDebug("remove transform tool caches")
       thisHasRan := 0
       LoadCachableBitmapFromFile("kill")
       realtimePasteInPlaceRotater("kill", 2, lol)
       realtimePasteInPlaceBlurrator("kill", 2, lol)
       realtimePasteInPlaceAlphaMasker("kill", 2, lol)
       getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    If (PasteInPlaceLivePreview!=1 && !G2) || (G2="kill")
       Return

    If (G2)
    {
       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       If (userClipBMPpaste && PasteInPlaceBlurAmount>1 && PasteInPlaceToolMode=0)
          QPV_SetGivenAlphaLevel(userClipBMPpaste, 1, 1)
       ; Else If (userClipBMPpaste && PasteInPlaceBlurAmount>1 && PasteInPlaceToolMode=1)
       ;    rz := addBorder2Bitmap(userClipBMPpaste, PasteInPlaceBlurAmount, PasteInPlaceBlurAmount)

       clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)
       If StrLen(clipBMP)<3
          Return "fail"

       If (PasteInPlaceToolMode!=1)
          flipBitmapAccordingToViewPort(clipBMP, 1)

       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
       previewMode := 0
    } Else
    {
       ; If (A_TickCount - lastInvoked < 60)
       ;    Return
       lastInvoked := A_TickCount
       G2 := 2NDglPG
       thisImgQuality := 5
       previewMode := 1
       Gdip_ResetClip(G2)
       trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
       ; Gdip_GetImageDimensions(gdiBitmap, imgW, imgH)
       ; calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
       imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
       imgSelW := max(X1, X2) - min(X1, X2)
       imgSelH := max(Y1, Y2) - min(Y1, Y2)
       thisImgCall := getIDimage(currentFileIndex) currentFileIndex viewportStampBMP viewportIDstampBMP PasteInPlaceOrientation vPselRotation PasteInPlaceBlurAmount PasteInPlaceAlphaMaskMode PasteInPlaceAlphaMaskClrA PasteInPlaceAlphaMaskClrB FillAreaColorReversed FillAreaGradientScale FillAreaGradientSigma FillAreaGradientBlend FillAreaGradientWrapped FillAreaGradientAngle PasteInPlaceAlphaFile alphaMaskOffsetX alphaMaskOffsetY PasteInPlaceLight PasteInPlaceHue PasteInPlaceSaturation PasteInPlaceGamma PasteInPlaceApplyColorFX FillAreaBlendMode PasteInPlaceAlphaChannelFile PasteInPlaceBlurEdgesSoft
       If (prevImgCall=thisImgCall && StrLen(prevClipBMP)>2)
       {
          hasCached := 1
          clipBMP := prevClipBMP
       } Else
       {
          prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
          clipBMP := trGdip_CloneBitmap(A_ThisFunc, viewportStampBMP)
       }
    }
 
    thisHasRan := 1
    If (hasCached!=1)
    {
       If (PasteInPlaceBlurAmount>0) || (PasteInPlaceToolMode=1 && (prevVPselRotation>0 || prevEllipseSelectMode>0))
       {
          realtimePasteInPlaceBlurrator(previewMode, clipBMP, newBitmap)
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       If (PasteInPlaceOrientation>1 || vPselRotation>0)
       {
          hasRotated := realtimePasteInPlaceRotater(previewMode, clipBMP, newBitmap)
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       } Else hasRotated := 0

       If (PasteInPlaceAlphaMaskMode>1)
       {
          ; thisStartZeit := A_TickCount
          realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, newBitmap)
          ; ToolTip, % A_TickCount - thisStartZeit, , , 2
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       canApplyFX := (PasteInPlaceHue!=0 || PasteInPlaceSaturation!=0) ? 1 : 0
       If (!isWinXP && canApplyFX=1 && PasteInPlaceApplyColorFX=1)
       {
          zEffect := Gdip_CreateEffect(6, PasteInPlaceHue, PasteInPlaceSaturation, 0)
          Gdip_BitmapApplyEffect(clipBMP, zEffect)
          Gdip_DisposeEffect(zEffect)
       }

       canApplyFX := (PasteInPlaceLight!=0 || PasteInPlaceGamma!=0) ? 1 : 0
       If (!isWinXP && canApplyFX=1 && PasteInPlaceApplyColorFX=1)
       {
          zEffect := Gdip_CreateEffect(5, PasteInPlaceLight, PasteInPlaceGamma)
          Gdip_BitmapApplyEffect(clipBMP, zEffect)
          Gdip_DisposeEffect(zEffect)
       }
    }

    Gdip_GetImageDimensions(clipBMP, oImgW, oImgH)
    ; fnOutputDebug("hello4")
    calcIMGdimensions(oImgW, oImgH, imgSelW, imgSelH, ResizedW, ResizedH)
    If (previewMode=1)
    {
       Gdip_GetImageDimensions(userClipBMPpaste, qImgW, qImgH)
       If (vPselRotation>0 && hasRotated=1)
       {
          If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
             Gdip_GetRotatedEllipseDimensions(qImgW, qImgH, vPselRotation, qImgW, qImgH)
          Else
             Gdip_GetRotatedDimensions(qImgW, qImgH, vPselRotation, qImgW, qImgH)
       }
    }

    If (PasteInPlaceAdaptMode=3)
    {
       ResizedW := oImgW
       ResizedH := oImgH
       If (previewMode=1)
       {
          If (PasteInPlaceAdaptMode=3)
          {
             ; fnOutputDebug("hello9")
             Gdip_GetImageDimensions(userClipBMPpaste, ResizedW, ResizedH)
             ; fnOutputDebug("hello09")
             If (vPselRotation>0 && hasRotated=1)
             {
                If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
                   Gdip_GetRotatedEllipseDimensions(ResizedW, ResizedH, vPselRotation, ResizedW, ResizedH)
                Else
                   Gdip_GetRotatedDimensions(ResizedW, ResizedH, vPselRotation, ResizedW, ResizedH)
             }
          }
          ResizedW := ResizedW * zoomLevel
          ResizedH := ResizedH * zoomLevel
       }
    } Else If (PasteInPlaceAdaptMode=2)
    {
       ResizedW := imgSelW
       ResizedH := imgSelH
    }

    If (PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1)
       PasteInPlaceEraseArea(G2, previewMode)

    If (ResizedW*ResizedH>maxGDIbmpSize)
       calcIMGdimensions(ResizedW, ResizedH, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), ResizedW, ResizedH)

    If (ResizedW>32500 || ResizedH>32500)
       calcIMGdimensions(ResizedW, ResizedH, 32500, 32500, ResizedW, ResizedH)

    Gdip_ResetClip(G2)
    vPobju := testSelectionLargerThanViewport()
    If (previewMode=1)
       Gdip_SetClipRect(G2, 0, 0, vPobju.mainWidth, vPobju.mainHeight, 0)

    If (PasteInPlaceCropSel>1)
    {
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, PasteInPlaceCropSel - 1)
       If (PasteInPlaceCropSel=4 || PasteInPlaceCropSel=5)
          PersonalizedRotatePath(pPath, vPselRotation + PasteInPlaceCropAngular, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       Else
          Gdip_RotatePathAtCenter(pPath, vPselRotation + PasteInPlaceCropAngular, 1, 1, rotateSelBoundsKeepRatio)

       ; If (PasteInPlaceBlurAmount>1 && PasteInPlaceBlurEdgesSoft=1 && previewMode!=1)
       ;    carvePathFromBitmap(clipBmp, pPath, imgSelPx, imgSelPy, 4, PasteInPlaceBlurEdgesSoft + 1, clampInRange(PasteInPlaceBlurAmount, 1, 255))
       ; Else
          Gdip_SetClipPath(G2, pPath, 1)
    }

    If (PasteInPlaceAlignment=2)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
    } Else If (PasteInPlaceAlignment=3)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)//2
       imgSelPy := imgSelPy + (imgSelH - ResizedH)//2
    } Else If (PasteInPlaceAlignment=4)
    {
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    } Else If (PasteInPlaceAlignment=5)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    }

    If (FillAreaBlendMode>1 && isNumber(FillAreaBlendMode))
    {
       ; fnOutputDebug("hello5")
       thisImgTempQuality := (userimgQuality=1) ? 3 : 5
       If (oImgW*oImgH>ResizedW*ResizedH)
       {
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, clipBMP, ResizedW, ResizedH, 0, thisImgQuality, 0, 0)
          If StrLen(tempBMP)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := tempBMP
          }

          Gdip_GetImageDimensions(clipBMP, oImgW, oImgH)
       }

       If (FillAreaGlassy=2)
          BlurAmount := 15
       Else If (FillAreaGlassy=3)
          BlurAmount := 50
       Else If (FillAreaGlassy=4)
          BlurAmount := 120
       Else If (FillAreaGlassy=5)
          BlurAmount := 180
       Else If (FillAreaGlassy=6)
          BlurAmount := 250
       Else
          BlurAmount := 0

       If (imgSelOutViewPort=1 || vPobju.isLarger=1)
          BlurAmount := 0

       bgrBMP := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, ResizedW, ResizedH, BlurAmount)
       If StrLen(bgrBMP)>2
       {
          setWindowTitle("Applying blending mode")
          thisStartZeit := A_TickCount
          factoru := (previewMode=1) ? 2 : 3
          delayu := (previewMode=1) ? -1 : 2
          threads := (previewMode=1) ? realSystemCores//2 : 0
          QPV_BlendBitmaps(bgrBMP, clipBMP, FillAreaBlendMode - 1, threads)
          ; Gdip_GetImageDimensions(clipBMP, gimgW, gimgH)
          ; Gdip_BlendBitmaps(bgrBMP, clipBMP, FillAreaBlendMode - 1)
          ; ToolTip, % gImgW "===" gImgH "`n" ResizedW "===" ResizedH , , , 2
       }
    }

    thisOpacity := (PasteInPlaceOpacity>128) ? (PasteInPlaceOpacity - 128) : PasteInPlaceOpacity
    thisOpacity := (PasteInPlaceOpacity>128) ? thisOpacity/128 * 25 + 1 : thisOpacity/128
    setWindowTitle("Scaling image to selection area")
    thisBMP := (bgrBMP && FillAreaBlendMode>1) ? bgrBMP : clipBMP
    If (thisBMP && G2)
       r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, ResizedW, ResizedH, 0, 0, oImgW, oImgH, thisOpacity)

    trGdip_DisposeImage(bgrBMP, 1)
    Gdip_ResetClip(G2)
    If (bgrBMP=thisBMP && PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1)
       PasteInPlaceEraseArea(G2, previewMode)

    setWindowTitle(pVwinTitle, 1)
    If (previewMode=1)
    {
       If (PasteInPlaceCropSel>1)
       {
          Gdip_SetPenWidth(pPen1d, imgHUDbaseUnit//11)
          Gdip_DrawPath(G2, pPen1d, pPath)
       }
       lastInvoked := A_TickCount
       thisImgQuality := (userimgQuality=1) ? 7 : 5
       prevImgCall := thisImgCall
       prevClipBMP := clipBMP
       ; trGdip_DisposeImage(clipBmp, 1)
       ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    } Else
    {
       trGdip_DisposeImage(clipBMP, 1)
       ; userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       ; viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    }
    Gdip_DeletePath(pPath)
}

getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, imgSelW, imgSelH, BlurAmount:=0) {
    Static prevBMPu, prevBlurredBMP, prevState, prevFXid
    If (previewMode="kill")
    {
       prevState := prevFXid := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
       Return
    }

    If (previewMode=1)
    {
       thisFXid := decideGDIPimageFX(matrix, imageAttribs, pEffect)
       thisFXid .= (BlurAmount>1) ? "." BlurAmount zoomLevel : "."
       thisFXid .= "Z" FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode

       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       thisState := "a" currentFileIndex getIDimage(currentFileIndex) imgSelPx imgSelPx oImgW oImgH imgSelW imgSelH currentUndoLevel currentSelUndoLevel FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode
       If (thisFXid=prevFXid && thisState=prevState && StrLen(prevBMPu)>2)
       {
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeImageAttributes(imageAttribs)
          newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
          Return newBitmap
       }

       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       If (thisFXid!=prevFXid || StrLen(prevBlurredBMP)<3)
       {
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
          prevBlurredBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          If (pEffect && prevBlurredBMP)
          {
             Gdip_BitmapApplyEffect(prevBlurredBMP, pEffect)
             Gdip_DisposeEffect(pEffect)
          }

          If (imageAttribs && prevBlurredBMP)
          {
             G2 := trGdip_GraphicsFromImage(A_ThisFunc, prevBlurredBMP, 3)
             If G2
                r1 := trGdip_DrawImage(A_ThisFunc, G2, prevBlurredBMP,,,,,,,,,,, imageAttribs)
             Gdip_DeleteGraphics(G2)
             Gdip_DisposeImageAttributes(imageAttribs)
          }

          If (BlurAmount>1 && prevBlurredBMP)
          {
             BlurAmount := Round(BlurAmount*zoomLevel)
             BlurAmount := clampInRange(BlurAmount, 1, 255)
             zEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, prevBlurredBMP, BlurAmount, zEffect, 1)
             Gdip_DisposeEffect(zEffect)
          }
          prevFXid := thisFXid
       } Else
       {
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeImageAttributes(imageAttribs)
       }

       thisBMP := prevBlurredBMP
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0,1)

       If (minimizeMemUsage=1 && StrLen(prevBlurredBMP)>2)
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
       ; ToolTip, % zBitmap "==" imgSelPx "==" imgSelPy "`n" imgSelW "--" imgSelH , , , 2
       thisImgTempQuality := (userimgQuality=1) ? 3 : 5
       If ((oImgW!=imgSelW || oImgH!=imgSelH) && zBitmap)
       {
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, oImgW, oImgH, 0, thisImgQuality, 0, 0)
          If tempBMP
          {
             trGdip_DisposeImage(zBitmap, 1)
             zBitmap := tempBMP
          }
       }

       prevState := (minimizeMemUsage=1) ? 0 : thisState
       newBitmap := (minimizeMemUsage=1) ? zBitmap : trGdip_CloneBitmap(A_ThisFunc, zBitmap)
       prevBMPu := (minimizeMemUsage=1) ? 0 : zBitmap
       Return newBitmap
    }

    whichBitmap := StrLen(UserMemBMP)>3 ? UserMemBMP : useGdiBitmap()
    If (imgFxMode>1)
       whichBitmap := useGdiBitmap()

    If !whichBitmap
    {
       SoundBeep , 300, 100
       addJournalEntry(A_ThisFunc "(): ERROR. No bitmap to process.")
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, aimgW, aimgH)
    MouseCoords2Image(imgSelPx, imgSelPy, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX1, imgY1)
    MouseCoords2Image(imgSelPx + imgSelW, imgSelPy + imgSelH, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX2, imgY2)

    ; givenCoords := imgSelPx//zoomLevel "|" imgSelPy//zoomLevel "|" Round((imgSelPx + imgSelW)/zoomLevel) "|" Round((imgSelPy + imgSelH)/zoomLevel)
    givenCoords := imgX1 "|" imgY1 "|" imgX2 "|" imgY2 
    calcImgSelection2bmp(1, aimgW, aimgH, Round(aimgW*zoomLevel), Round(aimgH*zoomLevel), dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0)
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, oImgW, oImgH, "0xE200B")
    If warnUserFatalBitmapError(newBitmap, A_ThisFunc)
       Return

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1)
    QPV_SetGivenAlphaLevel(zBitmap, 2, 1)

    If (pEffect && zBitmap)
       Gdip_BitmapApplyEffect(zBitmap, pEffect)

    Gdip_DisposeEffect(pEffect)
    Gdip_GetImageDimensions(zBitmap, gimgW, gimgH)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 3)
    If G2
       r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0, oImgW, oImgH, 0, 0, gimgW, gimgH,,, imageAttribs)

    trGdip_DisposeImage(zBitmap, 1)
    Gdip_DeleteGraphics(G2)
    Gdip_DisposeImageAttributes(imageAttribs)
    If (!G2 || !zBitmap)
    {
       trGdip_DisposeImage(newBitmap, 1)
       Return
    }

    If (BlurAmount>1 && G2)
    {
       BlurAmount := Round(BlurAmount)
       BlurAmount := clampInRange(BlurAmount, 2, 254)
       zEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, newBitmap, BlurAmount, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    prevState := 0
    Return newBitmap
}

destroyGDIfileCache(remAll:=1, makeBackup:=0) {
    If (remAll=0)
    {
       imgPath := getIDimage(currentFileIndex)
       MD5name := generateThumbName(imgPath, 1)
       If InStr(gdiBitmapIDcall, "1" MD5name imgPath)
       {
          If (makeBackup=1)
          {
             mainCall := SubStr(gdiBitmapIDcall, 2)
             gdiBitmapIDcall := "0" . mainCall
             xBitmap := cloneGDItoMem(A_ThisFunc, gdiBitmap)
             gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
             gdiBitmap := xBitmap
             gdiBitmapIDentire := gdiBitmapIDcall xBitmap
          } Else gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
       }

       If InStr(BprevImgCall, "1" MD5name imgPath)
       {
          BprevImgCall := ""
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       }

       If InStr(AprevImgCall, "1" MD5name imgPath)
       {
          AprevImgCall := ""
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       }

       If (!AprevImgCall && mainCall && makeBackup=1)
       {
          AprevImgCall := gdiBitmapIDcall
          AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       } Else If (!BprevImgCall && mainCall && makeBackup=1)
       {
          BprevImgCall := gdiBitmapIDcall
          BprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       }

       If InStr(idGDIcacheSRCfileA, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileA := ""
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       }

       If InStr(idGDIcacheSRCfileB, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileB := ""
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       }
    } Else
    {
       If (SubStr(idGDIcacheSRCfileA, 1, 1)=1)
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       If (SubStr(idGDIcacheSRCfileB, 1, 1)=1)
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       If (SubStr(BprevImgCall, 1, 1)=1)
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       If (SubStr(AprevImgCall, 1, 1)=1)
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       If (SubStr(gdiBitmapIDcall, 1, 1)=1)
          gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)

       idGDIcacheSRCfileA := idGDIcacheSRCfileB := ""
       BprevImgCall := AprevImgCall := ""
       GDIcacheSRCfileA := GDIcacheSRCfileB := gdiBitmapIDcall := ""
    }
}

discardViewPortCaches() {
    ; GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
    ; GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
    AprevImgCall := BprevImgCall := ""
    BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
    AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
    prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)
}

disposeCacheIMGs(dummy:=0) {
    gdiBitmapIDcall := ""
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
    If (dummy!="soft")
       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)

    prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)
    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
    infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
}

MenuReturnIMGedit() {
   If (StrLen(UserMemBMP)>2 && imgIndexEditing>0)
      currentFileIndex := imgIndexEditing
   Else If prevLastImg[1, 1]
      currentFileIndex := clampInRange(prevLastImg[1, 1], 1, maxFilesIndex)

   MenuDummyToggleThumbsMode()
}

recordSelUndoLevelNow() {
   selectionCoords := imgSelX1 "|" imgSelY1 "|" imgSelX2 "|" imgSelY2 "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" vPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid
   ; ToolTip, % currentSelUndoLevel  " = l" , , , 2
   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (undoSelLevelsArray[totalSelUndos, 1]!=selectionCoords)
   {
      currentSelUndoLevel := totalSelUndos + 1
      undoSelLevelsArray[totalSelUndos + 1] := [selectionCoords]
   }
}

decideUndoLevelsAccepted(imgW, imgH) {
   If (A_PtrSize!=4) 
      Return

   pixelz := imgW*imgH
   memUsage := (coreDesiredPixFmt="0x21808") ? pixelz*3 : pixelz*4
   memUsage := memUsage//1000
   preventUndoLevels := (memUsage*5>maxMemUndoLevels) ? 1 : 0
   ; ToolTip, % preventUndoLevels " = mem = " memUsage , , , 2
}

recordUndoLevelNow(actionu, recordedBitmap, dX:=0, dY:=0, forceAlpha:="x") {
   Static prevAct, lastInvoked := 1
   If (preventUndoLevels=1)
      Return

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   thisAct := actionu recordedBitmap whichBitmap minimizeMemUsage currentFileIndex getIDimage(currentFileIndex)
   if (prevAct=thisAct)
   {
      ; SoundBeep, 900, 900
      addJournalEntry(A_ThisFunc "(" actionu "): already recorded undo state")
      Return
   }

   HasAlpha := (forceAlpha!="x") ? forceAlpha : currIMGdetails.HasAlpha
   selectionCoords := imgSelX1 "|" imgSelY1 "|" imgSelX2 "|" imgSelY2 "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" vPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid
   If (StrLen(undoLevelsArray[1, 1])<3 && StrLen(whichBitmap)>2 && minimizeMemUsage!=1)
   {
      thisBMP := trGdip_CloneBitmap(A_ThisFunc "(init)", whichBitmap)
      If thisBMP
      {
         prevAct := thisAct
         recordSelUndoLevelNow()
         undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
         currentUndoLevel := 1
         If (undoLevelsRecorded=0)
            undoLevelsRecorded := 1
      }
   }

   If (actionu="init")
   {
      setImageLoading()
      If (minimizeMemUsage=1)
      {
         trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
         thisBMP := trGdip_CloneBitmap(A_ThisFunc "(init)", whichBitmap)
         If thisBMP
         {
            prevAct := thisAct
            currentUndoLevel := 1
            If (undoLevelsRecorded=0)
               undoLevelsRecorded := 1
            undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
         }
      }

      lastInvoked := A_TickCount
      Return
   }

   prevAct := 0
   HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
   If (A_PtrSize=8 && undoLevelsRecorded>3)
   {
      systemMemInfo := GlobalMemoryStatusEx()
      mamUsage := GetProcessMemoryUsage(QPVpid)
      thisMemoryLoad := Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
      If isWinXP
         thisMemoryLoad := 99

      If (thisMemoryLoad<85 && systemMemInfo.MemoryLoad<85 && hasReachedMaxUndoLevels=0)
         maxUndoLevels := 100
      Else
         maxUndoLevels := hasReachedMaxUndoLevels := undoLevelsRecorded
   }

   ; currentSelUndoLevel := totalSelUndos := Round(undoSelLevelsArray.Count() + 1)
   ; undoSelLevelsArray[totalSelUndos] := [selectionCoords]
   recordSelUndoLevelNow()
   ; ToolTip, % currentSelUndoLevel " = p" , , , 2
   If (minimizeMemUsage=1)
   {
      currentUndoLevel := 2
      undoLevelsRecorded := 2
      trGdip_DisposeImage(undoLevelsArray[2, 1], 1)
      undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(L2)", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
   } Else
   {
      If (currentUndoLevel>=maxUndoLevels)
      {
         trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
         undoLevelsArray.RemoveAt(1)
         undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(Lmax)", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
      } Else
      {
         currentUndoLevel++
         undoLevelsRecorded++
         If (undoLevelsRecorded>currentUndoLevel)
            undoLevelsRecorded := currentUndoLevel

         undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(Lx" currentUndoLevel ")", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
         Loop, % maxUndoLevels + 1 - currentUndoLevel
         {
             trGdip_DisposeImage(undoLevelsArray[currentUndoLevel + A_Index, 1], 1)
             undoLevelsArray[currentUndoLevel + A_Index, 1] := ""
         }
      }
   }

   currentImgModified := 1
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   ResetImgLoadStatus()
   If (A_TickCount - lastInvoked>950)
      SoundBeep , 900, 100
}

terminateIMGediting() {
   If (StrLen(UserMemBMP)<3 && undoLevelsRecorded>0 && currentFileIndex!=imgIndexEditing && minimizeMemUsage=1)
   {
      UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
      userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
      viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
      viewportIDstampBMP := ""
      Loop, 3
      {
          trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
          undoLevelsArray[A_Index, 1] := ""
      }

      gdipObjectsStats(1, "recordUndoLevelNow")
      currentImgModified := 0
      undoSelLevelsArray := []
      currentSelUndoLevel := 1
      currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
      interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
      interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
      Return
   }

   If (StrLen(UserMemBMP)<3 && undoLevelsRecorded<1) || (currentFileIndex=imgIndexEditing && undoLevelsRecorded>1 && currentImgModified=2)
      Return

   currentImgModified := 0
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
   viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
   viewportIDstampBMP := ""

   Loop, 200
   {
       trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
       undoLevelsArray[A_Index, 1] := ""
   }

   gdipObjectsStats(1, "recordUndoLevelNow")
   fnOutputDebug(A_ThisFunc "(): undo/redo levels purged")
   currentSelUndoLevel := 1
   undoSelLevelsArray := []
   currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   maxUndoLevels := (A_PtrSize=8) ? 100 : 2
}

ImgUndoAction(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1)
      Return

   If (StrLen(undoLevelsArray[currentUndoLevel - 1, 1])<3) || (imageLoading=1)
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not recorded, to limit memory usage`n" : ""
      showTOOLtip(friendly "Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel - howFar, 1, undoLevelsRecorded)
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, undoLevelsArray[currentUndoLevel, 1])
   currIMGdetails.HasAlpha := undoLevelsArray[currentUndoLevel, 5]
   ; restorePreviousSelections(undoLevelsArray[currentUndoLevel, 4])

   SetTimer, RefreshImageFile, -325
   showTOOLtip("Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgSelUndoAct(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (StrLen(undoSelLevelsArray[currentSelUndoLevel - 1, 1])<3 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel - howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgSelRedoAct(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (StrLen(undoSelLevelsArray[currentSelUndoLevel + 1, 1])<3 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel + howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

restorePreviousSelections(thisLevel) {
   selectionCoords := undoSelLevelsArray[thisLevel, 1]
   ; ToolTip, % thisLevel " = k" , , , 2
   If !selectionCoords
      Return

   selectionPrefsArray := StrSplit(selectionCoords, "|")
   imgSelX1 := selectionPrefsArray[1], imgSelY1 := selectionPrefsArray[2]
   imgSelX2 := selectionPrefsArray[3], imgSelY2 := selectionPrefsArray[4]
   prcSelX1 := selectionPrefsArray[5], prcSelY1 := selectionPrefsArray[6]
   prcSelX2 := selectionPrefsArray[7], prcSelY2 := selectionPrefsArray[8]
   vPselRotation := selectionPrefsArray[9]
   rotateSelBoundsKeepRatio := selectionPrefsArray[10]
   EllipseSelectMode := selectionPrefsArray[11]
   LimitSelectBoundsImg := selectionPrefsArray[12]
   showSelectionGrid := selectionPrefsArray[13]
   currentSelUndoLevel := thisLevel
   currentImgModified := 1
}

ImgRedoAction(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1)
      Return

   If (StrLen(undoLevelsArray[currentUndoLevel + 1, 1])<3) || (imageLoading=1)
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not recorded, to limit memory usage`n" : ""
      showTOOLtip(friendly "Redo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel + howFar, 1, undoLevelsRecorded)
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, undoLevelsArray[currentUndoLevel, 1])
   currIMGdetails.HasAlpha := undoLevelsArray[currentUndoLevel, 5]
   ; restorePreviousSelections(undoLevelsArray[currentUndoLevel, 4])
   SetTimer, RefreshImageFile, -325
   showTOOLtip("Redo [ "  currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ToggleCorePixFmt() {
   friendly := (A_PtrSize=4 && A_is64BitOS) ? "`n`nPlease use the 64-bits edition of this application to enjoy a better experience for image editing and image viewing." : ""
   friendly .= "`n`nUpon application restart, the 32-bits RGBA mode will no longer be activated."
   coreDesiredPixFmt := (coreDesiredPixFmt="0x21808") ? "0xE200B" : "0x21808"
   If (A_PtrSize=4 && coreDesiredPixFmt="0xE200B")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now activated. " appTitle " will now have an increased memory usage. The maximum amount of usable memory on your system is 2 GB." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=4 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. " appTitle " will use less memory, but various image editing options are disabled." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=8 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. Please note, various image editing options are disabled in 24-bits RGB mode, including proper alpha channel support.`n`nUpon application restart, the 32-bits RGBA mode will be reactivated. This option is only meant help reduce memory usage for old systems.", 0, 0, "exclamation")

   RefreshImageFileAction()
}

alertReduceColorDepth() {
   If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1 && StrLen(UserMemBMP)<3)
      msgBoxWrapper(appTitle ": WARNING" , "PLEASE NOTE! The image you are about to edit is downscaled by " appTitle ". Press F5 to reload the original and then begin again to edit the image, at its original dimensions.`n`nTo disabled altogether downscaling, press Ctrl+Q in the main window.", 0, 0, "exclamation")

   pixFmt := currIMGdetails.PixelFormat  " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      r := msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel.", "&OK|&Activate 32-RGBA", 1, "exclamation")
   
   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit is at an unsupported color depth for editing: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost.", 0, 0, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", 0, 0, "exclamation")

   If InStr(r, "activate")
   {
      coreDesiredPixFmt := "0xE200B"
      If !undoLevelsRecorded
         RefreshImageFileAction()
   }

   If (currIMGdetails.TooLargeGDI=1 && StrLen(UserMemBMP)<3)
   {
      infoRes := "`nOriginal resolution: " currIMGdetails.Width " x " currIMGdetails.Height " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      ; whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " imgW " x " imgH " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will edit it now at an automatically downscaled resolution:" newRes, 0, 0, "exclamation")
   }
}

alertReduceSaveColorDepth() {
   msgResult := "continue"
   If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1 && StrLen(UserMemBMP)<3)
      msgResult := msgBoxWrapper(appTitle ": WARNING" , "PLEASE NOTE! The image you are about to save is downscaled by " appTitle ". Press F5 to reload the original and then save the modified image, at original dimensions.`n`nTo disabled altogether downscaling, press Ctrl+Q in the main window.", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   pixFmt := currIMGdetails.PixelFormat  " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel before editing or saving the image.", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave is originally at an unsupported color depth: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost. ", "&Continue|C&ancel", 1, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (currIMGdetails.TooLargeGDI=1 && StrLen(UserMemBMP)<3)
   {
      infoRes := "`nOriginal resolution: " currIMGdetails.Width " x " currIMGdetails.Height " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      ; whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " imgW " x " imgH " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will be saving an automatically downscaled resolution:" newRes, "&Continue|C&ancel", 1, "exclamation")
   }
   If !InStr(msgResult, "continue")
      Return 1
}

mergeViewPortEffectsImgEditing(funcu:=0, recordUndoAfter:=1, applyOnArea:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    funcuInfo := funcu ? "`n" funcu "()" : ""
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug("error - mergeViewPortEffectsImgEditing() invoked by " funcu "() operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return 1
    }

    If testSelectOutsideImgEntirely(whichBitmap)
    {
       SoundBeep, 300, 100
       showDelayedTooltip("WARNING: Invalid image selection area" funcuInfo, 0, 450)
       Return 1
    }

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    If (imgW*imgH>maxGDIbmpSize) || (imgW>32500) || (imgH>32500)
    {
       SoundBeep, 300, 100
       showDelayedTooltip("ERROR: Image editing is disabled`nThe document size is too large" funcuInfo, 0, 450)
       Return 1
    }

    alertReduceColorDepth()
    ; mustOpenStartFolder := ""
    imgIndexEditing := currentFileIndex
    currentImgModified := 1
    setImageLoading()
    showTOOLtip("Processing image, please wait" funcuInfo)
    ; If markedSelectFile
    ;    dropFilesSelection()

    discardViewPortCaches()
    ; msgbox % UserMemBMP "---" gdiBitmap
    If StrLen(gdiBitmap)>2
    {
       UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
       UserMemBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, gdiBitmap)
    } 

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If (pEffect || imageAttribs)
       recordUndoLevelNow("init", 0)

    Gdip_GetImageDimensions(UserMemBMP, imgW, imgH)
    If (editingSelectionNow=1 && applyOnArea=1)
    {
       nImgSelX1 := min(imgSelX1, imgSelX2)
       nImgSelY1 := min(imgSelY1, imgSelY2)
       kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
       kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
       isEntire := (kimgSelW=imgW && kimgSelH=imgH && nImgSelX1=0 && nImgSelY1=0) ? 1 : 0
       allowOnArea := !isEntire
    }

    If (allowOnArea=1)
    {
       calcImgSelection2bmp(1, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       pPath := createImgSelPath(1, 0, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
       If pPath
       {
          pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
          dummyBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, UserMemBMP, pB.xa, pB.ya, pB.w, pB.h, 0, 0, 1)
       }

       If dummyBMP
       {
          dummyBMP := applyVPeffectsOnBMP(dummyBMP)
          carvePathFromBitmap(dummyBMP, pPath, pB.x, pB.y, 4)
          carvePathFromBitmap(UserMemBMP, pPath, pB.x, pB.y, 0)
          G4 := trGdip_GraphicsFromImage(A_ThisFunc, UserMemBMP)
          r1 := trGdip_DrawImage(A_ThisFunc, G4, dummyBMP, pB.xa, pB.ya)
          Gdip_DeleteGraphics(G4)
          trGdip_DisposeImage(dummyBMP, 1)
       } Else r1 := "fail"

       Gdip_DeletePath(pPath)
    } Else UserMemBMP := applyVPeffectsOnBMP(UserMemBMP)
   
    Gdip_DisposeImageAttributes(imageAttribs)
    Gdip_DisposeEffect(pEffect)
    If ((pEffect || imageAttribs) && StrLen(UserMemBMP)>2 && recordUndoAfter!=0 && r1!="fail")
    {
       recordUndoLevelNow(0, UserMemBMP)
       disposeCacheIMGs("soft")
       ; gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, UserMemBMP)
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime//2
    usrColorDepth := imgFxMode := 1
    vpIMGrotation := 0 ; FlipImgH := FlipImgV := 0
}

CutSelectedArea() {
   If (thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   r := CopyImage2clip()
   If r
      Return

   EraseAreaFader := 0
   Sleep, 350
   EraseSelectedArea()
   ; EraseSelectedArea(1)
}

ApplyColorAdjustsSelectedArea(modus:=0) {
    Static prevFXmode := "n"
    If InStr(modus, "outside")
       modus := "outside"

    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    o_imgFxMode := imgFxMode
    If (imgFxMode>1)
       prevFXmode := imgFxMode
    Else If (prevFXmode!="n")
       imgFxMode := prevFXmode

    If (imgFxMode=1)
    {
       showTOOLtip("No viewport color adjustments to be applied on image`n`nPress F to cycle through modes`nor press U to open color adjustments panel")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisMode := (modus="outside") ? 0 : 1
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 0, thisMode)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       imgFxMode := o_imgFxMode
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(-1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       imgFxMode := o_imgFxMode
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    If !pPath
    {
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area`nUnable to create selection path")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    thisMode := (modus="outside") ? 0 : 4
    Gdip_SetClipPath(G2, pPath, thisMode)
    zBitmap := (preventUndoLevels=1) ? gdiBitmap : undoLevelsArray[currentUndoLevel, 1] 
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    If (r0!="fail" && r1!="fail" && G2)
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    SetTimer, RefreshImageFile, -25
    Return r1
}

InsertTextSelectedArea() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 ||!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    startOperation := A_TickCount
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 0)
    If obju[1]
    {
       textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
       trGdip_DisposeImage(obju[1], 1)
    }

    coreDesiredPixFmt := o_coreFmt
    Gdip_GetImageDimensions(textBoxu, nImgW, nImgH)
    Gdip_GetRotatedDimensions(nImgW, nImgH, vPselRotation, rnImgW, rnImgH)
    If (TextInAreaAlign=3)
       imgSelPx := X2 - rnImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx + imgSelW//2 - rnImgW//2

    If (TextInAreaValign=3)
       imgSelPy := Y2 - rnImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + imgSelH//2 - rnImgH//2

    If (vPselRotation>0)
    {
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, vPselRotation, ".")
       If StrLen(xBitmap)>3
       {
          trGdip_DisposeImage(textBoxu, 1)
          textBoxu := xBitmap
          Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
       }
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, nimgW, nimgH, 0, 0, nimgW, nimgH)
    livePreviewInsertTextinArea("kill")
    trGdip_DisposeImage(textBoxu, 1)
    Gdip_DeleteGraphics(G2)
    zeitOperation := A_TickCount - startOperation
    If (r1!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    etaTime := SecToHHMMSS(Round(zeitOperation/1000, 3))
    addJournalEntry("Text drawn on image in: " etaTime)
    SetTimer, RefreshImageFile, -25
}

livePreviewInsertTextinArea(actionu:=0) {
    Static lastInvoked := 1, prevBMPu, prevState, scaleuPreview := 1
    If (actionu="kill")
    {
       prevState := 0
       If StrLen(prevBMPu)>2
          prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    If (TextInAreaLivePreview!=1 || !AnyWindowOpen)
       Return

    ; setImageLoading()
    G2 := 2NDglPG
    Gdip_ResetClip(G2)
    trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    thisState := "a" UserTextArea TextInAreaAlign TextInAreaValign TextInAreaDoBlurs TextInAreaBlurAmount TextInAreaBlurBorderAmount TextInAreaUsrMarginz TextInAreaBgrColor TextInAreaBgrEntire TextInAreaBgrUnified TextInAreaCutOutMode TextInAreaBgrOpacity TextInAreaBorderSize TextInAreaBorderOut TextInAreaBorderColor TextInAreaBorderOpacity TextInAreaFontBold TextInAreaFontColor TextInAreaFontItalic TextInAreaFontName TextInAreaFontLineSpacing TextInAreaFontOpacity TextInAreaFontSize TextInAreaFontStrike TextInAreaFontUline TextInAreaOnlyBorder TextInAreaPaintBgr TextInAreaRoundBoxBgr imgSelW imgSelH mainWidth mainHeight TextInAreaLineAngle TextInAreaCharSpacing TextInAreaAutoWrap
    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    If (A_TickCount - lastInvoked < 50) || (thisState=prevState)
    {
       textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       If (thisState!=prevState)
          mustGoTimer := 1
    } Else
    {
       obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 1)
       If obju[1]
       {
          prevState := thisState
          trGdip_DisposeImage(prevBMPu, 1)
          textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
          trGdip_DisposeImage(obju[1], 1)
          scaleuPreview := obju[6]
          prevBMPu := textBoxu
          textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       }
    }

    startZeit := A_TickCount
    coreDesiredPixFmt := o_coreFmt
    imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
    imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
    imgSelW := max(X1, X2) - min(X1, X2)
    imgSelH := max(Y1, Y2) - min(Y1, Y2)

    Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
    zImgW := Round((nImgW*zoomLevel)*scaleuPreview)
    zImgH := Round((nImgH*zoomLevel)*scaleuPreview)

    Gdip_GetRotatedDimensions(zImgW, zImgH, vPselRotation, rnImgW, rnImgH)
    If (TextInAreaAlign=3)
       imgSelPx := X2 - rnImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx + imgSelW//2 - rnImgW//2

    If (TextInAreaValign=3)
       imgSelPy := Y2 - rnImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + imgSelH//2 - rnImgH//2

    If (vPselRotation>0)
    {
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, vPselRotation, "-", 5)
       If StrLen(xBitmap)>2
       {
          trGdip_DisposeImage(textBoxu, 1)
          textBoxu := xBitmap
       }
       Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
       zImgW := Round((nImgW*zoomLevel)*scaleuPreview)
       zImgH := Round((nImgH*zoomLevel)*scaleuPreview)
    }

    Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, zimgW, zimgH, 0, 0, nimgW, nimgH)
    trGdip_DisposeImage(textBoxu, 1)
    Gdip_ResetClip(G2)
    livePreviewsImageEditingDrawSelectionBox()
    thisImgQuality := (userimgQuality=1) ? 7 : 5
    r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    If (A_TickCount - startZeit<65) && (mustGoTimer=1)
       livePreviewsImageEditing()
    Else If (mustGoTimer=1)
       SetTimer, livePreviewInsertTextinArea, -100
    ; Else
       ; SetTimer, ResetImgLoadStatus, -200
    lastInvoked := A_TickCount
}

FillSelectedArea() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (X1<4)
       X1MarginSnap := 1
    If (X2>imgW - 4)
       X2MarginSnap := 1
    If (Y1<4)
       Y1MarginSnap := 1
    If (Y2>imgH - 4)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && FillAreaShape=1 && FillAreaInverted=1 && FillAreaDoContour!=1 && vPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelFillSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    startZeit := A_TickCount
    If (FillAreaDoContour=1)
       FillAreaRemBGR := 0

    recordUndoLevelNow("init", 0)
    mustRemBackground := FillAreaRemBGR
    If (UserMemBMP!=whichBitmap && mustRemBackground!=1)
       disposableBMP := whichBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)

    kBitmap := whichBitmap
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If (mustRemBackground=1 && FillAreaDoContour!=1)
       pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
    Else
       pBitmap := whichBitmap

    If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
    {
       trGdip_DisposeImage(disposableBMP, 1)
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4)
    pPath := coreFillSelectedArea(G2, whichBitmap, kBitmap)
    If (pPath="fail")
    {
       Gdip_DeleteGraphics(G2)
       trGdip_DisposeImage(disposableBMP, 1)
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    Gdip_ResetClip(G2)
    modus := (FillAreaInverted=1) ? 0 : 4
    If (mustRemBackground=1 && FillAreaDoContour!=1 && pPath)
       Gdip_SetClipPath(G2, pPath, modus)

    If (mustRemBackground=1 && FillAreaDoContour!=1)
    {
       currIMGdetails.HasAlpha := 1
       r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap)
       If (UserMemBMP=whichBitmap)
          UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    }

    Gdip_DeleteGraphics(G2)
    coreFillSelectedArea("kill")
    UserMemBMP := pBitmap
    recordUndoLevelNow(0, UserMemBMP)
    zeitOperation := A_TickCount - startZeit
    addJournalEntry("Fill selected area operation. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    SetTimer, RefreshImageFile, -25
}

coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, shape) {
    pPath := Gdip_CreatePath()
    If (shape=1) ; rect
    {
       Gdip_AddPathRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (shape=2) ; rounded rect
    {
       radius := Round(((imgSelW + imgSelH)//2)*0.1) + 1
       Gdip_AddPathRoundedRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, radius)
    } Else If (shape=3) ; ellipse
    {
       Gdip_AddPathEllipse(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (shape=4) ; triangle
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, cX1 "," cY1 "|" cX2 "," cY2 "|" cX3 "," cY3)
    } Else If (shape=5) ; right triangle
    {
       cX1 := imgSelPx
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, cX1 "," cY1 "|" cX2 "," cY2 "|" cX3 "," cY3)
    } Else If (shape=6) ; rhombus
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH//2
       cX3 := imgSelPx + imgSelW//2
       cY3 := imgSelPy + imgSelH
       cX4 := imgSelPx + imgSelW
       cY4 := imgSelPy + imgSelH//2
       Gdip_AddPathPolygon(pPath, cX1 "," cY1 "|" cX2 "," cY2 "|" cX3 "," cY3 "|" cX4 "," cY4)
    } Else If (shape=7 && FillAreaCurveTension=1)
    {
       PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx + 1, imgSelPy + 1, imgSelW, imgSelH)
       ; ToolTip, % customShapePoints "`nLOL" PointsList , , , 2
       If (FillAreaDoContour!=1 || FillAreaClosedPath=1)
          Gdip_AddPathPolygon(pPath, PointsList)
       Else
          Gdip_AddPathLines(pPath, PointsList)
    } Else If (shape=7)
    {
       PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx + 1, imgSelPy + 1, imgSelW, imgSelH)
       If (FillAreaDoContour!=1 || FillAreaClosedPath=1)
          Gdip_AddPathClosedCurve(pPath, PointsList, tensionCurveCustomShape)
       Else
          Gdip_AddPathCurve(pPath, PointsList, tensionCurveCustomShape)
    }
    Return pPath
}

DrawRoundedRectangle2(pGraphics, pPen, x, y, w, h, r, Angle:=0) {
; extracted from: https://github.com/tariqporter/Gdip2/blob/master/lib/Object.ahk
; and adapted by Marius Șucan

   penWidth := Gdip_GetPenWidth(pPen)
   pw := penWidth / 2
   if (w <= h && (r + pw > w / 2))
   {
      r := (w / 2 > pw) ? w / 2 - pw : 0
   } else if (h < w && r + pw > h / 2)
   {
      r := (h / 2 > pw) ? h / 2 - pw : 0
   } else if (r < pw / 2)
   {
      r := pw / 2
   }

   r2 := r * 2
   path1 := Gdip_CreatePath(0)
   Gdip_AddPathArc(path1, x + pw, y + pw, r2, r2, 180, 90)
   Gdip_AddPathLine(path1, x + pw + r, y + pw, x + w - r - pw, y + pw)
   Gdip_AddPathArc(path1, x + w - r2 - pw, y + pw, r2, r2, 270, 90)
   Gdip_AddPathLine(path1, x + w - pw, y + r + pw, x + w - pw, y + h - r - pw)
   Gdip_AddPathArc(path1, x + w - r2 - pw, y + h - r2 - pw, r2, r2, 0, 90)
   Gdip_AddPathLine(path1, x + w - r - pw, y + h - pw, x + r + pw, y + h - pw)
   Gdip_AddPathArc(path1, x + pw, y + h - r2 - pw, r2, r2, 90, 90)
   Gdip_AddPathLine(path1, x + pw, y + h - r - pw, x + pw, y + r + pw)
   Gdip_ClosePathFigure(path1)
   If (Angle>0)
      Gdip_RotatePathAtCenter(path1, Angle, 1, 1, rotateSelBoundsKeepRatio)
   _E := Gdip_DrawPath(pGraphics, pPen, path1)
   Gdip_DeletePath(path1)
   return _E
}

PersonalizedRotatePath(pPath, angle, x, y, w, h, withinBounds:=0, withinBkeepRatio:=1, EllipseMode:=1) {
  dummyPath := Gdip_CreatePath()
  If (EllipseMode=1)
     Gdip_AddPathEllipse(dummyPath, x, y, w, h)
  Else
     Gdip_AddPathRectangle(dummyPath, x, y, w, h)

  MatrixOrder := 1
  Rect := Gdip_GetPathWorldBounds(dummyPath)
  cX := Rect.x + (Rect.w / 2)
  cY := Rect.y + (Rect.h / 2)
  pMatrix := Gdip_CreateMatrix()
  Gdip_TranslateMatrix(pMatrix, -cX , -cY)
  Gdip_RotateMatrix(pMatrix, Angle, MatrixOrder)
  Gdip_TranslateMatrix(pMatrix, cX, cY, MatrixOrder)
  E := Gdip_TransformPath(dummyPath, pMatrix)
  E := Gdip_TransformPath(pPath, pMatrix)
  Gdip_DeleteMatrix(pMatrix)
  If (withinBounds=1 && !E && Angle!=0)
  {
     nRect := Gdip_GetPathWorldBounds(dummyPath)
     ncX := nRect.x + (nRect.w / 2)
     ncY := nRect.y + (nRect.h / 2)
     pMatrix := Gdip_CreateMatrix()
     Gdip_TranslateMatrix(pMatrix, -ncX , -ncY)
     sX := Rect.w / nRect.w
     sY := Rect.h / nRect.h
     If (withinBkeepRatio=1)
     {
        sX := min(sX, sY)
        sY := min(sX, sY)
     }
     Gdip_ScaleMatrix(pMatrix, sX, sY, MatrixOrder)
     Gdip_TranslateMatrix(pMatrix, ncX, ncY, MatrixOrder)
     If (sX!=0 && sY!=0)
     {
        E := Gdip_TransformPath(pPath, pMatrix)
        E := Gdip_TransformPath(dummyPath, pMatrix)
     }
     Gdip_DeleteMatrix(pMatrix)
  }
  Gdip_DeletePath(dummyPath)
}

coreFillGlassFX(whichBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, thisQuality, G2, pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, BlurAmount, previewMode:=0) {
    Static prevState, prevBMPu
    If (whichBitmap="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" whichBitmap dimgSelPx dimgSelPy dimgSelW dimgSelH thisQuality G2 imgSelPx imgSelPy imgSelW imgSelH mainWidth mainHeight BlurAmount
    If (thisState!=prevState || G2!=2NDglPG || !prevBMPu)
    {
       ; ToolTip, % thisState , , , 2
       doFakeBgr := (2NDglPG=G2) ? 0 : 1
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, 0, 0, 1)
       If (doFakeBgr=1)
          QPV_SetGivenAlphaLevel(zBitmap, 2, 1)

       thisBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, dimgSelW//2+2, dimgSelH//2 + 2, 0, thisQuality, -1)
       If !warnUserFatalBitmapError(thisBMP, A_ThisFunc)
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := thisBMP
          setWindowTitle("Blurring image, please wait")
          afterVPresize := (AnyWindowOpen && G2=2NDglPG) ? Round(dimgSelW*zoomLevel) * Round(dimgSelH*zoomLevel) : 1
          preVPresize := dimgSelW//2 * dimgSelH//2
          applyBlurAfter := (afterVPresize<preVPresize && afterVPresize!=1) ? 1 : 0
          If (applyBlurAfter=0 || G2!=2NDglPG)
          {
             BlurAmountA := BlurAmount + 1
             BlurAmountA := clampInRange(BlurAmountA, 2, 255)
             pzEffect := Gdip_CreateEffect(1, BlurAmountA, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, zBitmap, BlurAmountA, pzEffect, previewMode)
          }
       }

       If (AnyWindowOpen && G2=2NDglPG)
       {
          thisBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, Round(dimgSelW*zoomLevel), Round(dimgSelH*zoomLevel), 0, thisQuality, -1)
          If (applyBlurAfter=1)
          {
             BlurAmountB := Round(BlurAmount*zoomLevel)*2
             BlurAmountB := clampInRange(BlurAmountB, 2, 254)
             zEffect := Gdip_CreateEffect(1, BlurAmountB, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, thisBMP, BlurAmountB, zEffect, previewMode)
          }

          trGdip_DisposeImage(zBitmap, 1)
       } Else thisBMP := zBitmap
       prevBMPu := thisBMP
       prevState := thisState
       thisPBitmap := trGdip_CloneBitmap(A_ThisFunc, thisBMP)
    } Else thisPBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)

    Gdip_SetClipPath(G2, pPath, 0)
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If pEffect
       Gdip_BitmapApplyEffect(thisPBitmap, pEffect)

    If (AnyWindowOpen && G2=2NDglPG)
       Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisPBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,,,, imageAttribs)
    trGdip_DisposeImage(thisPBitmap, 1)
    Gdip_ResetClip(G2)
    setWindowTitle(pVwinTitle, 1)
    Gdip_DisposeImageAttributes(imageAttribs)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    Gdip_DisposeEffect(pzEffect)
}

testSelectionLargerThanViewport() {
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    obju := []
    obju.mainWidth := mainWidth
    obju.mainHeight := mainHeight
    vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx) + SelDotsSize//2
    vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy) + SelDotsSize//2
    VPmpx := Round((vPimgSelW*vPimgSelH)/1000000, 3)
    MAINmpx := Round((mainWidth*mainHeight)/1000000, 3) + 0.01
    obju.isLarger := (MAINmpx<VPmpx) ? 1 : 0
    Return obju
}

testSelectionLargerThanGiven(imgW, imgH) {
    nImgSelX1 := min(imgSelX1, imgSelX2)
    nImgSelY1 := min(imgSelY1, imgSelY2)
    nimgSelX2 := max(imgSelX1, imgSelX2)
    nimgSelY2 := max(imgSelY1, imgSelY2)
    If (nImgSelX1<0 || nImgSelY1<0 || nImgSelX2>imgW || nImgSelY2>imgH)
       Return 1
    Return 0
}

trGdip_DrawImage(funcu, pGraphics, pBitmap, dx:="", dy:="", dw:="", dh:="", sx:="", sy:="", sw:="", sh:="", Matrix:=1, Unit:=2, ImageAttr:=0) {
  If (!pGraphics || !pBitmap)
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() using pG=" pGraphics ", pBMP=" pBitmap)
     Return "fail"
  }

  r := Gdip_DrawImage(pGraphics, pBitmap, dx, dy, dw, dh, sx, sy, sw, sh, Matrix, Unit, ImageAttr)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to draw the processed image in the internal graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics " and pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(r, baseMsg)
     Return "fail"
  }
}

trGdip_GraphicsFromImage(funcu, pBitmap, InterpolationMode:="", SmoothingMode:="", PageUnit:="", CompositingQuality:="") {
  If !pBitmap
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() for pBitmap = " pBitmap)
     Return
  }

  r := Gdip_GraphicsFromImage(pBitmap, InterpolationMode, SmoothingMode, PageUnit, CompositingQuality)
  If (!r || gdipLastError)
  {
     baseMsg := "Unable to create virtual graphics object required for processing the image... Error occured in " A_ThisFunc "() invoked by " funcu "() for pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(gdipLastError, baseMsg)
     Return
  } Else Return r
}

trGdip_DrawImageFX(funcu, pGraphics, pBitmap, dX:="", dY:="", sX:="", sY:="", sW:="", sH:="", matrix:="", pEffect:="", ImageAttr:=0, hMatrix:=0, Unit:=2) {
  If (!pGraphics || !pBitmap)
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() using " pGraphics ", " pBitmap)
     Return "fail"
  }

  r := Gdip_DrawImageFX(pGraphics, pBitmap, dX, dY, sX, sY, sW, sH, matrix, pEffect, ImageAttr, hMatrix, Unit)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to modify the image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "(). "
     generalInternalErrorMsgBox(r, baseMsg)
     Return "fail"
  }
}

trGdip_GraphicsClear(funcu, pGraphics, coloru:=0x00ffFFff, silentMode:=0) {
  If !pGraphics
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() on graphics = " pGraphics ". ")
     Return "fail"
  }

  r := Gdip_GraphicsClear(pGraphics, coloru)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to apply operations on image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics ". "
     generalInternalErrorMsgBox(r, baseMsg, silentMode)
     Return "fail"
  }
}

QPV_SaveImageFile(funcu, pBitmap, file2save, jpegQuality) {
   r := Gdip_SaveBitmapToFile(pBitmap, file2save, jpegQuality)
   If (r=-5)
      r := Gdip_ErrorHandler(gdipLastError, 0)
   Else If r
      r .= " / " A_LastError

   If r
   {
      addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with GDI+: " file2save "`nError code: " r)
      zr := SaveFIMfile(file2save, pBitmap)
      If (!zr && wasInitFIMlib=1)
         r := zr
      Else If (wasInitFIMlib=1)
         addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with FreeImage: " file2save "`nError code: " zr)
   }

   Return r
}

warnUserFatalBitmapError(pBitmap, funcu) {
    If (StrLen(pBitmap)<3 || pBitmap="err" || pBitmap="fail")
    {
       r := (pBitmap="no-gdip") ? 0 : gdipLastError
       baseMsg := "Unable to create internal bitmap to apply operations on image... Error occured in Gdip_CreateBitmap() invoked by " funcu  "(). "
       generalInternalErrorMsgBox(r, baseMsg)
       Return "fail"
    }
}

coreFillSelectedArea(G2:=0, whichBitmap:=0, ywbmp:=0) {
    Static prevPath, noRepeat := 0
    If (G2="kill")
    {
       Gdip_DeletePath(prevPath)
       Gdip_ResetClip(2NDglPG)
       prevPath := ""
       coreFillGlassFX("kill", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
       coredrawWelcomeImg("kill", 0, 0, 0, 0, 0, 5, 5, 0, 0, 0)
       Return
    }

    decXu := decYu := decWu := decHu := 0
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    vPimgSelW := (!G2 && FillAreaInverted=1) ? mainWidth : max(selDotX, selDotAx) - min(selDotX, selDotAx) + SelDotsSize//2
    vPimgSelH := (!G2 && FillAreaInverted=1) ? mainHeight : max(selDotY, selDotAy) - min(selDotY, selDotAy) + SelDotsSize//2
    VPmpx := Round((vPimgSelW*vPimgSelH)/1000000, 3)
    MAINmpx := Round((mainWidth*mainHeight)/1000000, 3) + 0.01
    dropSpecialFX := (MAINmpx<VPmpx && !G2) ? 1 : 0
    If (FillAreaBlendMode>1 && FillAreaDoContour!=1 && FillAreaRemBGR!=1)
    {
       If whichBitmap
          Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

       If (vPimgSelW>mainWidth)
          decWu := mainWidth - vPimgSelW
       If (vPimgSelH>mainHeight)
          decHu := mainHeight - vPimgSelH

       ; vPimgSelW := clampInRange(vPimgSelW, 2, mainWidth)
       ; vPimgSelH := clampInRange(vPimgSelH, 2, mainHeight)
       o_whichBitmap := whichBitmap
       If !G2
          whichBitmap := trGdip_CreateBitmap(A_ThisFunc, vPimgSelW, vPimgSelH, "0xE200B")
       Else
          whichBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")

       If warnUserFatalBitmapError(whichBitmap, A_ThisFunc)
          Return "fail"

       o_G2 := G2 ? G2 : 2NDglPG
       If !G2
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 5, 3)
       Else
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)

       mustDoBlendMode := 1
    } Else
    {
       If !whichBitmap
          whichBitmap := useGdiBitmap()
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    maxLength := (imgSelW + imgSelH)//2
    thisThick := (FillAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : FillAreaContourThickness
    If (!G2 || 2NDglPG=o_G2)
    {
       previewMode := 1
       thisThick := thisThick*zoomLevel
       If (mustDoBlendMode=1)
       {
          imgSelPx := x1 := SelDotsSize//2, x2 := vPimgSelW
          imgSelPy := y1 := SelDotsSize//2, y2 := vPimgSelH
          imgSelW := imgW := vPimgSelW ; + decWu
          imgSelH := imgH := vPimgSelH ; + decHu
          If (imgSelPx>selDotX + SelDotsSize)
             decXu := imgSelPx - selDotX - SelDotsSize

          If (imgSelPy>selDotY + SelDotsSize)
             decYu := imgSelPy - selDotY - SelDotsSize
       } Else
       {
          o_G2 := G2 := 2NDglPG
          imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
          imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
          imgSelW := max(X1, X2) - min(X1, X2)
          imgSelH := max(Y1, Y2) - min(Y1, Y2)
          imgW := mainWidth
          imgH := mainHeight
       }

       Gdip_ResetClip(o_G2)
       trGdip_GraphicsClear(A_ThisFunc, o_G2, "0x00" WindowBGRcolor)
       Gdip_SetClipRect(o_G2, 0, 0, mainWidth, mainHeight)
       If (decXu>1 || decYu>1 || decWu>1 || decHu>1) && (mustDoBlendMode=1)
       {
          diffu := SelDotsSize
          thisW := min(vPimgSelW, mainWidth) + diffu
          thisH := min(vPimgSelH, mainHeight) + diffu
          thisX := max(- diffu//2, selDotX) ; + SelDotsSize//2
          thisY := max(- diffu//2, selDotY) ; + SelDotsSize//2
          If (FillAreaInverted!=1)
             Gdip_SetClipRect(G2, decXu, decYu, thisW, thisH)
       }
    } Else previewMode := 0

    dR := (FillAreaContourAlign=3) ? thisThick//2 : 0
    If (FillAreaContourAlign=1)
       dR := -thisThick//2

    If (FillAreaDoContour!=1)
    {
       dR := thisThick := 0
    } Else
    {
       imgSelPx -= dR
       imgSelPy -= dR
       imgSelW += dR*2
       imgSelH += dR*2
    }

    If (FillAreaGlassy=2)
       BlurAmount := 15
    Else If (FillAreaGlassy=3)
       BlurAmount := 50
    Else If (FillAreaGlassy=4)
       BlurAmount := 120
    Else If (FillAreaGlassy=5)
       BlurAmount := 180
    Else If (FillAreaGlassy=6)
       BlurAmount := 250
    Else
       BlurAmount := 0

    ; If (FillAreaColorMode=5 && FillAreaBlendMode=1)
    ;    BlurAmount := 0

    ; prepare the brush
    Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
    this1stOpacity := (FillAreaColorMode=5) ? clampInRange(FillAreaOpacity, 1, 215) : FillAreaOpacity
    thisColorA := Gdip_ToARGB(this1stOpacity, R, G, B)

    Gdip_FromARGB("0xFF" FillArea2ndColor, A, R, G, B)
    this2ndOpacity := (FillAreaColorMode=5) ? clampInRange(FillArea2ndOpacity, 1, 215) : FillArea2ndOpacity
    thisColorB := Gdip_ToARGB(this2ndOpacity, R, G, B)
    If (FillAreaColorReversed=1 && FillAreaColorMode>1 && FillAreaDoContour!=1)
    {
       tempu := thisColorA
       thisColorA := thisColorB
       thisColorB := tempu
    }

    If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
    {
       rimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx) ; + SelDotsSize//2
       rimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy) ; + SelDotsSize//2
       rimgSelX := selDotX + SelDotsSize//2
       rimgSelY := selDotY + SelDotsSize//2
       brImgSelW := Round(rImgSelW*(FillAreaGradientScale/100))
       brImgSelH := Round(rImgSelH*(FillAreaGradientScale/100))
       brimgSelPx := rimgSelX - (brImgSelW - rimgSelW)//2
       brimgSelPy := rimgSelY - (brImgSelH - rimgSelH)//2
    } Else
    {
       brImgSelW := Round(ImgSelW*(FillAreaGradientScale/100))
       brImgSelH := Round(ImgSelH*(FillAreaGradientScale/100))
       brimgSelPx := imgSelPx - (brImgSelW - imgSelW)//2
       brimgSelPy := imgSelPy - (brImgSelH - imgSelH)//2
    }

    If (previewMode=1)
    {
       dpX := (FillAreaInverted=1) ? prevDestPosX : imgSelPx
       dpY := (FillAreaInverted=1) ? prevDestPosY : imgSelPy
       kW := (FillAreaInverted=1) ? prevResizedVPimgW : imgSelW
       kH := (FillAreaInverted=1) ? prevResizedVPimgH : imgSelH
    } Else
    {
       dpX := (FillAreaInverted=1) ? 0 : imgSelPx
       dpY := (FillAreaInverted=1) ? 0 : imgSelPy
       kW := (FillAreaInverted=1) ? imgW : imgSelW
       kH := (FillAreaInverted=1) ? imgH : imgSelH
    }

    If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
       pPath := coreCreateFillAreaShape(rimgSelX, rimgSelY, rimgSelW, rimgSelH, FillAreaShape)
    Else
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape)

    If (vPselRotation>0 && pPath)
    {
       If (FillAreaShape=4 || FillAreaShape=5)
       {
          If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
             PersonalizedRotatePath(pPath, vPselRotation, rimgSelX, rimgSelY, rimgSelW, rimgSelH, 1, rotateSelBoundsKeepRatio, 0)
          Else
             PersonalizedRotatePath(pPath, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       } Else
          Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
    }

    If (FillAreaColorMode=1 || FillAreaDoContour=1)
    {
       Brush := Gdip_BrushCreateSolid(thisColorA)
    } Else If (FillAreaColorMode=2)
    {
       Brush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + Round(brImgSelW*alphaMaskOffsetX), brimgSelPy + Round(brImgSelH*alphaMaskOffsetY), brimgSelW, brimgSelH, thisColorA, thisColorB, 1, FillAreaGradientWrapped)
       Gdip_RotateLinearGrBrushAtCenter(Brush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
       ; Gdip_SetLinearGrBrushSigmaBlend(Brush, FillAreaGradientSigma/100, 1)
       Gdip_SetLinearGrBrushPresetBlend(Brush, 0, FillAreaGradientSigma/100, FillAreaGradientBlend/100, 1, thisColorA, thisColorA, thisColorB, thisColorB)
    } Else If (FillAreaColorMode=3 || FillAreaColorMode=4)
    {
       grpPath := Gdip_CreatePath()
       If (FillAreaColorMode=3)
          Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
       Else
          Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

       Brush := Gdip_PathGradientCreateFromPath(grpPath)
       If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
          Gdip_PathGradientSetCenterPoint(Brush, rimgSelX + rimgSelW//2 + Round(brImgSelW*alphaMaskOffsetX), rimgSelY + rimgSelH//2 + Round(brImgSelH*alphaMaskOffsetY))
       Else
          Gdip_PathGradientSetCenterPoint(Brush, imgSelPx + imgSelW//2 + Round(brImgSelW*alphaMaskOffsetX), imgSelPy + imgSelH//2 + Round(brImgSelH*alphaMaskOffsetY))
       Gdip_SetLinearGrBrushPresetBlend(Brush, 0, FillAreaGradientSigma/100, FillAreaGradientBlend/100, 1, thisColorA, thisColorA, thisColorB, thisColorB)
       Gdip_RotatePathGradientAtCenter(Brush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
       Gdip_PathGradientSetWrapMode(Brush, FillAreaGradientWrapped - 1)
       Gdip_DeletePath(grpPath)
    } Else If (FillAreaColorMode=5) ; based on welcome screens
    {
       iterations := Round(100*(FillAreaGradientScale/300)) + 1
       modelu := Round(7*(FillAreaGradientBlend/100))
       moduz := Round(9*(FillAreaGradientSigma/100))
       sweepRand := Round(9*(FillAreaGradientAngle/360))
       Brush := Gdip_BrushCreateSolid(thisColorA)
       bruB := Gdip_BrushCreateSolid(thisColorB)
       thisBMPwelcome := coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, Ceil(imgSelW), Ceil(imgSelH), 5, 5, 0, previewMode, !previewMode)
       Gr := trGdip_GraphicsFromImage(A_ThisFunc, thisBMPwelcome)
       Gdip_FillRectangle(Gr, bruB, 0, 0, imgSelW, imgSelH)
       Gdip_DeleteGraphics(Gr)
       If (FillAreaGradientWrapped=1)
          clrMatrix := GenerateColorMatrix(2)

       ; Gdip_DeleteBrush(bruA)
       Gdip_DeleteBrush(bruB)
    }

    ; draw the shape
    mustRemBackground := FillAreaRemBGR
    If (FillAreaInverted=1 && FillAreaDoContour!=1)
    {
       Gdip_SetClipPath(G2, pPath, 4)
       If (FillAreaGlassy>1 && FillAreaRemBGR!=1 && BlurAmount>1) || (mustDoBlendMode=1)
       {
          If (previewMode=1)
          {
             bgrBMPu := getImgSelectedAreaEditMode(1, 0, 0, mainWidth, mainHeight, mainWidth, mainHeight, BlurAmount)
          } Else
          {
             bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, ywbmp)
             If (BlurAmount>1)
             {
                zrEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
                ApplySpecialFixedBlur(A_ThisFunc, bgrBMPu, BlurAmount, zrEffect)
                Gdip_DisposeEffect(zrEffect)
             }
          }

          If StrLen(bgrBMPu)>3
          {
             If (previewMode!=1)
                trGdip_GraphicsClear(A_ThisFunc, G2)

             If (mustDoBlendMode=1)
             {
                threads := (previewMode=1) ? realSystemCores//2 : 0
                If (thisBMPwelcome && FillAreaColorMode=5)
                {
                   If (previewMode=1)
                      Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)

                   Gdip_FillRectangle(G2, Brush, dpX, dpY, kW, kH)
                   trGdip_DrawImage(A_ThisFunc, G2, thisBMPwelcome, dpX, dpY, kW, kH,,,,, clrMatrix)
                   thisBMPwelcome := trGdip_DisposeImage(thisBMPwelcome, 1)
                } Else Gdip_FillRectangle(G2, Brush, -2, -2, imgW + 2, imgH + 2)

                QPV_BlendBitmaps(bgrBMPu, whichBitmap, FillAreaBlendMode - 1, threads)
                thisG2 := (previewMode=1) ? 2NDglPG : o_G2
                trGdip_DrawImage(A_ThisFunc, thisG2, bgrBMPu)
                trGdip_DisposeImage(whichBitmap, 1)
                Gdip_DeleteGraphics(G2)
             } Else trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu)
             trGdip_DisposeImage(bgrBMPu, 1)
          }
       }

       If (mustRemBackground=1 && AnyWindowOpen && (o_G2=2NDglPG || G2=2NDglPG))
          Gdip_FillRectangle(G2, useHatchedBrush(), -2, -2, imgW + 2, imgH + 2)

       If (thisBMPwelcome && FillAreaColorMode=5 && mustDoBlendMode!=1)
       {
          If (previewMode=1)
             Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)
          Gdip_FillRectangle(G2, Brush, dpX, dpY, kW, kH)
          trGdip_DrawImage(A_ThisFunc, G2, thisBMPwelcome, dpX, dpY, kW, kH,,,,, clrMatrix)
          thisBMPwelcome := trGdip_DisposeImage(thisBMPwelcome, 1)
       } Else If (mustDoBlendMode!=1)
          Gdip_FillRectangle(G2, Brush, -2, -2, imgW + 2, imgH + 2)
    } Else If (FillAreaDoContour=1)
    {
       radius := Round(((imgSelW + imgSelH)//2)*0.1) + 1
       thisPen := Gdip_CreatePen(thisColorA, thisThick)
       If (FillAreaRoundedCaps=1)
          Gdip_SetPenLineCaps(thisPen, 2, 2, 2)

       compoundArray := "0.0|0.33|0.67|1.0"
       Gdip_SetPenDashStyle(thisPen, FillAreaDashStyle - 1)
       If (FillAreaDoubleLine=1)
          Gdip_SetPenCompoundArray(thisPen, compoundArray)

       If (FillAreaShape=2)
          DrawRoundedRectangle2(G2, thisPen, imgSelPx - thisThick//2, imgSelPy - thisThick//2, imgSelW + thisThick, imgSelH + thisThick, radius, vPselRotation)
       Else
          Gdip_DrawPath(G2, thisPen, pPath)

       Gdip_DeletePen(thisPen)
    } Else
    {
       If (mustRemBackground=1 && AnyWindowOpen && G2=2NDglPG)
          Gdip_FillPath(G2, useHatchedBrush(), pPath)
       
       thisQuality := (G2=2NDglPG && AnyWindowOpen) ? 5 : 3
       canBlur := (G2=2NDglPG && AnyWindowOpen && FillAreaLivePreview=1 || G2!=2NDglPG) ? 1 : 0
       opacityLevels := (FillAreaColorMode=1 && FillAreaOpacity<253) || (FillAreaColorMode>1 && (FillAreaOpacity<253 || FillArea2ndOpacity<253)) ? 1 : 0
       ; MsgBox, % "a" canBlur "=" mustRemBackground "=" FillAreaGlassy "=" opacityLevels

       If (BlurAmount>1 && canBlur=1 && dropSpecialFX!=1 && FillAreaBlendMode=1 && FillAreaRemBGR!=1 && !testSelectOutsideImgEntirely(whichBitmap) && FillAreaGlassy>1 && opacityLevels=1)
       {
          Gdip_GetImageDimensions(whichBitmap, aimgW, aimgH)
          calcImgSelection2bmp(1, aimgW, aimgH, Round(aimgW*zoomLevel), Round(aimgH*zoomLevel), dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0)
          If (G2!=2NDglPG)
          {
             pB := GetPathRelativeBounds(pPath, dimgSelPx, dimgSelPy)
             dimgSelPx := pB.x,  dimgSelPy := pB.y
             dimgSelW  := pB.w,  dimgSelH  := pB.h
             imgSelPx := pB.x,   imgSelPy := pB.y
             imgSelW  := pB.w,   imgSelH  := pB.h
          }

          coreFillGlassFX(whichBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, thisQuality, G2, pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, BlurAmount, previewMode)
          If (!AnyWindowOpen && G2!=2NDglPG)
             coreFillGlassFX("kill", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
       }

       If (AnyWindowOpen && G2=2NDglPG)
          Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)

       ; thisStartZeit := A_TickCount
       If (thisBMPwelcome && FillAreaColorMode=5)
       {
          Gdip_FillPath(G2, Brush, pPath)
          Gdip_SetClipPath(G2, pPath)
          trGdip_DrawImage(A_ThisFunc, G2, thisBMPwelcome, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, clrMatrix)
          thisBMPwelcome := trGdip_DisposeImage(thisBMPwelcome, 1)
       } Else Gdip_FillPath(G2, Brush, pPath)
       ; ToolTip, % brImgSelW "--" brImgSelH "==" thisW "--" thisH "==" A_TickCount - thisStartZeit , , , 2

       If (FillAreaDoContour=0 && (FillAreaColorMode=4 || FillAreaColorMode=3) && (FillAreaGradientScale>=99 || FillAreaGradientWrapped!=1))
       {
          sBrush := Gdip_BrushCreateSolid(thisColorB)
          grpPath := Gdip_CreatePath()
          If (sBrush && grpPath)
          {
             If (FillAreaColorMode=3)
                Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
             Else
                Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

             Gdip_RotatePathAtCenter(grpPath, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
             Gdip_SetClipRect(G2, imgSelPx, imgSelPy, imgSelW, imgSelH)
             Gdip_SetClipPath(G2, grpPath, 4)
             Gdip_FillPath(G2, sBrush, pPath)
             Gdip_DeleteBrush(sBrush)
             Gdip_DeletePath(grpPath)
          }
       }

       If (mustDoBlendMode=1)
       {
          thisBlurAmount := 0
          If (BlurAmount>1 && FillAreaGlassy>1 && previewMode=1 && FillAreaLivePreview=1 && dropSpecialFX!=1)
             thisBlurAmount := clampInRange(BlurAmount, 1, 255)

          If (previewMode=1)
          {
             Gdip_ResetClip(o_G2)
             G3 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap)
             modus := (FillAreaInverted=1) ? 0 : 4
             Gdip_SetClipPath(G3, pPath, modus)
             trGdip_GraphicsClear(A_ThisFunc, G3)
             Gdip_DeleteGraphics(G3)

             diffu := SelDotsSize
             thisW := min(vPimgSelW, mainWidth) + diffu
             thisH := min(vPimgSelH, mainHeight) + diffu
             thisX := max(- diffu//2, selDotX) ; + SelDotsSize//2
             thisY := max(- diffu//2, selDotY) ; + SelDotsSize//2
             kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, decXu, decYu, thisW, thisH, 0, 0, 1)
             trGdip_DisposeImage(whichBitmap)
             whichBitmap := kBitmap
             bgrBMPu := getImgSelectedAreaEditMode(1, thisX, thisY, thisW, thisH, thisW, thisH, thisBlurAmount)
          } Else
             bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, o_whichBitmap)

          If (BlurAmount>1 && FillAreaGlassy>1 && FillAreaRemBGR!=1 && previewMode!=1)
          {
             BlurAmount := clampInRange(BlurAmount, 2, 254)
             zrEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, bgrBMPu, BlurAmount, zrEffect)
             Gdip_DisposeEffect(zrEffect)
          }

          If (previewMode!=1)
          {
             G3 := trGdip_GraphicsFromImage(A_ThisFunc, bgrBMPu)
             modus := (FillAreaInverted=1) ? 0 : 4
             Gdip_SetClipPath(G3, pPath, modus)
             trGdip_GraphicsClear(A_ThisFunc, G3)
             Gdip_DeleteGraphics(G3)
          }

          threads := (previewMode=1) ? realSystemCores//2 : 0
          QPV_BlendBitmaps(bgrBMPu, whichBitmap, FillAreaBlendMode - 1, threads)
          If (previewMode=1)
             r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, bgrBMPu, thisX, thisY)
          Else
             r1 := trGdip_DrawImage(A_ThisFunc, o_G2, bgrBMPu)

          trGdip_DisposeImage(bgrBMPu, 1)
          trGdip_DisposeImage(whichBitmap, 1)
          Gdip_DeleteGraphics(G2)
       }
    }

    Gdip_DeleteBrush(Brush)
    If (previewMode=1)
    {
       Gdip_DeletePath(pPath)
       ; fnOutputDebug("about to reset clip for " G2)
       Gdip_ResetClip(2NDglPG)
       ; fnOutputDebug("done - reset clip for " G2)
       r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
       pPath := ""
    }

    prevPath := pPath
    Return pPath
}

carvePathFromBitmap(ByRef pBitmap, pPath, cX, cY, modus, safeWay:=0, blurLevel:=0, doBorder:=1) {
    If (safeWay=2 && blurLevel>1)
    {
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
       r2 := trGdip_GraphicsClear(A_ThisFunc, G3, "0xFFFFFFFF")

       zPath := Gdip_ClonePath(pPath)
       pMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(pMatrix, -cX , -cY)
       ; Gdip_TranslateMatrix(pMatrix, blurLevel , blurLevel)
       E := Gdip_TransformPath(zPath, pMatrix)
       Gdip_SetClipPath(G3, zPath, modus)

       BrushB := Gdip_BrushCreateSolid("0xFF000000")
       r3 := Gdip_FillRectangle(G3, BrushB, 0, 0, imgW, imgH)
       Gdip_ResetClip(G3)
       Gdip_SetClipRect(G3, blurLevel, blurLevel, imgW - blurLevel*2, imgH - blurLevel*2, 4)
       If (doBorder=1)
          r3 := Gdip_FillRectangle(G3, BrushB, 0, 0, imgW, imgH)

       Gdip_DeleteGraphics(G3)
       thisAmount := clampInRange(blurLevel, 1, 255)
       pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, newBitmap, thisAmount, pEffect, 0)
       Gdip_DisposeEffect(pEffect)
       If (blurLevel>257)
       {
          thisAmount := clampInRange(blurLevel - 255, 1, 255)
          pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
          ApplySpecialFixedBlur(A_ThisFunc, newBitmap, thisAmount, pEffect, 0)
          Gdip_DisposeEffect(pEffect)
       }
       r0 := QPV_SetAlphaChannel(pBitmap, newBitmap)
       Gdip_DeletePath(zPath)
       Gdip_DeletePath(wPath)
       Gdip_DeleteBrush(BrushB)
       Gdip_DeleteMatrix(pMatrix)
       trGdip_DisposeImage(newBitmap, 1)
       ; ToolTip, % newBitmap "==" G3 "==" BrushB "`n" r2 "==" r3 "==" r0 , , , 2
       Return
    } Else safeWay := 0

    If (safeWay=1)
    {
       Gdip_GetImageDimensions(pBitmap, imgW, imgH)
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0x26200A")
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
    } Else
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)

    If (G3 && (newBitmap || safeWay!=1))
    {
       ; Gdip_GetImageDimensions(pBitmap, qImgW, qImgH)
       zPath := Gdip_ClonePath(pPath)
       pMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(pMatrix, -cX , -cY)
       E := Gdip_TransformPath(zPath, pMatrix)
       If (safeWay=1)
       {
          Gdip_SetCompositingQuality(G3, 4)
          Gdip_SetCompositingMode(G3, 1)
          Gdip_SetPixelOffsetMode(G3, 4)
          thinBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, pBitmap,,,,, "0x26200A")
          pEffect := Gdip_CreateEffect(5, -25, 0, 0)
          Gdip_BitmapApplyEffect(thinBMP, pEffect)

          QPV_SetGivenAlphaLevel(thinBMP, 1, 0)
          trGdip_DrawImage(A_ThisFunc, G3, thinBMP) ; ,,,,,,,,,10)
          modus := (modus=4) ? 0 : 4
       }

       Gdip_SetClipPath(G3, zPath, modus)
       If (safeWay!=1)
          r1 := trGdip_GraphicsClear(A_ThisFunc, G3)

       r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap)
       Gdip_DeletePath(zPath)
       Gdip_DeleteMatrix(pMatrix)
       Gdip_DeleteGraphics(G3)
       If (safeWay=1)
       {
          trGdip_DisposeImage(thinBMP, 1)
          If !r2
          {
             trGdip_DisposeImage(pBitmap, 1)
             pBitmap := newBitmap
          } Else Return "Fail"
       }
    }

    If (!G3 || r1="fail")
       Return "fail"
}

GraySelectedArea() {
   EraseOrInvertOrGraySelectedArea("desaturate", A_ThisFunc)
}

InvertSelectedArea() {
   EraseOrInvertOrGraySelectedArea("invert", A_ThisFunc)
}

EraseSelectedArea() {
   EraseOrInvertOrGraySelectedArea("erase", A_ThisFunc)
}

FlipSelectedAreaH() {
    EraseOrInvertOrGraySelectedArea("flip-h", A_ThisFunc)
}

FlipSelectedAreaV() {
    EraseOrInvertOrGraySelectedArea("flip-v", A_ThisFunc)
}

EraseOrInvertOrGraySelectedArea(actionu, funcu) {
    If (editingSelectionNow!=1 && thumbsDisplaying!=1 && actionu!="erase")
       selectEntireImage("r")

    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(funcu)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!LimitSelectBoundsImg, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (X1<4)
       X1MarginSnap := 1
    If (X2>imgW - 4)
       X2MarginSnap := 1
    If (Y1<4)
       Y1MarginSnap := 1
    If (Y2>imgH - 4)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && EraseAreaInvert=1 && actionu="erase" && EllipseSelectMode=0 && vPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelEraseSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    G2 := trGdip_GraphicsFromImage(funcu, whichBitmap, 7, 4)
    infoFriendly := (actionu="flip" || actionu="flip" ) ? actionu : actionu " the colours in"
    If !G2
    {
       showTOOLtip("Failed to " infoFriendly " the selected area")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    recordUndoLevelNow("init", 0)
    If (!gdiBitmap && preventUndoLevels=1)
    {
       hasCloned := 1
       o_gdiBitmap := Gdip_CloneBmpPargbArea(funcu, UserMemBMP)
    } Else o_gdiBitmap := gdiBitmap

    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    If !pPath
    {
       showTOOLtip("Failed to " infoFriendly " the selected area`nUnable to create selection path")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    modus := (EraseAreaInvert=1 && actionu="erase") ? 4 : 0
    Gdip_SetClipPath(G2, pPath, modus)
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    If !r0
       currIMGdetails.HasAlpha := 1

    If (actionu="erase")
    {
       matrix := (EraseAreaFader=1) ? EraseAreaOpacity / 256 : 0
    } Else If (actionu="invert")
    {
       matrix := GenerateColorMatrix(6, 1, 0, 1)
    } Else If (actionu="desaturate")
    {
       coreDesatureAreaFX(matrix, pEffect)
    } Else If InStr(actionu, "flip")
    {
       matrix := 1
       thisW := imgSelW + imgSelPx*2
       thisH := imgSelH + imgSelPy*2
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
       If (actionu="flip-h")
       {
          Gdip_ScaleWorldTransform(G2, -1, 1)
          Gdip_TranslateWorldTransform(G2, -thisW, 0)
       } Else If (actionu="flip-v")
       {
          Gdip_ScaleWorldTransform(G2, 1, -1)
          Gdip_TranslateWorldTransform(G2, 0, -thisH)
       }
    }

    zBitmap := (preventUndoLevels=1) ? o_gdiBitmap : undoLevelsArray[currentUndoLevel, 1] 
    If (!pEffect && matrix)
       r1 := trGdip_DrawImage(funcu, G2, zBitmap, 0, 0,,,,,,, matrix)
    Else If pEffect
       r1 := trGdip_DrawImageFX(funcu, G2, zBitmap,,,,,,, matrix, pEffect)

    Gdip_DeletePath(pPath)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeleteGraphics(G2)
    If hasCloned
       trGdip_DisposeImage(o_gdiBitmap, 1)

    If (r0!="fail" && r1!="fail" && G2)
    {
       currIMGdetails.HasAlpha := 0
       isInside := (imgSelX1>=0 && imgSelY1>=0 && imgSelX2<=imgW && imgSelY2<=imgH) ? 1 : 0
       If (actionu="erase") || (InStr(actionu, "flip") && isInside=0)
          currIMGdetails.HasAlpha := 1

       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    SetTimer, RefreshImageFile, -25
}

ResizeIMGviewportSelection() {
    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 ||!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    thisQuality := (userimgQuality=1) ? 7 : 5
    newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgSelW, imgSelH, 0, thisQuality, -1)
    If StrLen(newBitmap)<2
    {
       SetTimer, ResetImgLoadStatus, -150
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    UserMemBMP := newBitmap

    editingSelectionNow := 0
    vpIMGrotation := 0
    updateUIctrl()
    MouseMoveResponder()
    recordUndoLevelNow(0, newBitmap)
    SetTimer, RefreshImageFile, -25
    SetTimer, dummyInfoImgResizeVP, -125
}

dummyInfoImgResizeVP() {
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW*imgH)/1000000, 2)
   showTOOLtip("Image resized to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px ("  mpx " MPx)" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

getTransformToolSelectedArea(applyVPfx, doCarving, fakeBGR) {
    Return getselectedImageArea(useGdiBitmap(), doCarving, 0, applyVPfx, fakeBGR)
/*
    If (applyVPfx=1)
    {
       stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
       whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
       If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
          Return
    } Else whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(-1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    Return zBitmap
*/

}

DrawLinesInSelectedArea() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
       Return

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    If (slideShowRunning=1)
       ToggleSlideShowu()

    coreDrawLinesSelectionArea(G2, whichBitmap)
    Gdip_DeleteGraphics(G2)
    UserMemBMP := whichBitmap
    recordUndoLevelNow(0, UserMemBMP)
    SetTimer, RefreshImageFile, -25
}

coreDrawLinesSelectionArea(G2:=0, whichBitmap:=0) {
    If (G2)
    {
       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       maxLength := (imgSelW + imgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : DrawLineAreaContourThickness
    } Else
    {
       G2 := 2NDglPG
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
       Gdip_GetImageDimensions(gdiBitmap, qimgW, qimgH)
       calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
       imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
       imgSelW := max(X1, X2) - min(X1, X2)
       imgSelH := max(Y1, Y2) - min(Y1, Y2)
       maxLength := (qimgSelW + qimgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : DrawLineAreaContourThickness
       thisThick := thisThick*zoomLevel
    }

    dR := (DrawLineAreaContourAlign=3) ? thisThick//2 : 0
    If (DrawLineAreaContourAlign=1)
       dR := -thisThick//2

    imgSelPx -= dR
    imgSelPy -= dR
    imgSelW += dR*2
    imgSelH += dR*2
    x1 -= dR
    y1 -= dR
    x2 += dR
    y2 += dR

    pPathArcs := Gdip_CreatePath()
    If (DrawLineAreaBorderArcA=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 180, 90)
    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcB=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 270, 90)
    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcC=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 90, 90)
    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcD=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 0, 90)

    pPathBrders := Gdip_CreatePath()
    If (DrawLineAreaBorderTop=1)
       Gdip_AddPathLine(pPathBrders, x1, y1, x2, y1)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderBottom=1)
       Gdip_AddPathLine(pPathBrders, x1, y2, x2, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderLeft=1)
       Gdip_AddPathLine(pPathBrders, x1, y1, x1, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderRight=1)
       Gdip_AddPathLine(pPathBrders, x2, y1, x2, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=2 || DrawLineAreaBorderCenter=7)
       Gdip_AddPathLine(pPathBrders, x1 + imgSelW//2, y1, x1 + imgSelW//2, y2)
    
    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=3 || DrawLineAreaBorderCenter=7)
       Gdip_AddPathLine(pPathBrders, x1, y1 + imgSelH//2, x2, y1 + imgSelH//2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=4 || DrawLineAreaBorderCenter=6)
       Gdip_AddPathLine(pPathBrders, x1, y2, x2, y1)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=5 || DrawLineAreaBorderCenter=6)
       Gdip_AddPathLine(pPathBrders, x1, y1, x2, y2)

    Gdip_FromARGB("0xFF" DrawLineAreaColor, A, R, G, B)
    thisColor := Gdip_ToARGB(DrawLineAreaOpacity, R, G, B)
    thisPen := Gdip_CreatePen(thisColor, thisThick)
    Gdip_SetPenDashStyle(thisPen, DrawLineAreaDashStyle - 1)
    If (DrawLineAreaCapsStyle=1)
       Gdip_SetPenLineCaps(thisPen, 2, 2, 2)

    compoundArray := "0.0|0.33|0.67|1.0"
    If (DrawLineAreaDoubles=1)
       Gdip_SetPenCompoundArray(thisPen, compoundArray)

    If (DrawLineAreaKeepBounds!=1)
    {
       applyLimits :=  Gdip_GetPathPointsCount(pPathBrders)>2 ? 1 : 0
       Gdip_RotatePathAtCenter(pPathBrders, vPselRotation, 1, applyLimits, rotateSelBoundsKeepRatio)
       Gdip_RotatePathAtCenter(pPathArcs, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
    } Else
    {
       PersonalizedRotatePath(pPathBrders, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       PersonalizedRotatePath(pPathArcs, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
    }


    Gdip_DrawPath(G2, thisPen, pPathBrders)
    Gdip_DrawPath(G2, thisPen, pPathArcs)
 
    Gdip_DeletePath(pPathBrders)
    Gdip_DeletePath(pPathArcs)
    Gdip_DeletePen(thisPen)
    If (AnyWindowOpen && G2=2NDglPG)
    {
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    }
}

ChangeImageCanvasSize(userW, userH, userAddT, userAddB, userAddL, userAddR, userAddC, vpMode) {
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If (vpMode=1)
    {
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       newW := imgSelW, newH := imgSelH
       If (newW*newH>maxGDIbmpSize)
       {
          calcIMGdimensions(imgSelW, imgSelH, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), newW, newH)
          SoundBeep, 300, 100
          addJournalEntry("Image canvas too large: " imgSelW " x " imgSelH ". Dimensions capped to: " newW " x " newH ".")
       } Else If (newW>32500 || newH>32500)
       {
          calcIMGdimensions(imgSelW, imgSelH, 32500, 32500, newW, newH)
          SoundBeep, 300, 100
          addJournalEntry("Image canvas too large: " imgSelW " x " imgSelH ". Dimensions capped to: " newW " x " newH ".")
       }

       If (isInRange(imgSelW, imgW - 2, imgW + 2) && isInRange(imgSelH, imgH - 2, imgH + 2) && !imgSelPx && !imgSelPy)
          Return

       imgSelPx := - imgSelPx
       imgSelPy := - imgSelPy
       editingSelectionNow := 0
       updateUIctrl()
       MouseMoveResponder()
    } Else If (adjustCanvasMode=1)
    {
       newW := userAddL + userAddR + userAddC + imgW
       newH := userAddT + userAddB + userAddC + imgH
       imgSelPx := userAddL + (userAddC + 1)//2
       imgSelPy := userAddT + (userAddC + 1)//2
    } Else
    {
       newW := userW
       newH := userH
       imgSelPx := (adjustCanvasCentered=1) ? newW//2 - imgW//2 : 0
       imgSelPy := (adjustCanvasCentered=1) ? newH//2 - imgH//2 : 0
    }

    xBitmap := trGdip_CreateBitmap(A_ThisFunc, newW, newH, 0xE200B)
    If warnUserFatalBitmapError(xBitmap, A_ThisFunc)
    {
       ResetImgLoadStatus()
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap, 7, 4)
    If !G2
    {
       ResetImgLoadStatus()
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    currIMGdetails.HasAlpha := 1
    If (adjustCanvasNoBgr!=1)
    {
       Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
       thisColor := Gdip_ToARGB(FillAreaOpacity, R, G, B)
       Gdip_SetClipRect(G2, 0, 0, newW, newH, 0)
       Gdip_SetClipRect(G2, imgSelPx, imgSelPy, imgW, imgH, 4)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       If r0
          addJournalEntry(A_ThisFunc "(): failed to set background color through trGdip_GraphicsClear()")
       Gdip_ResetClip(G2)
    }
    ; MsgBox, % newW "--" newH "--" imgSelPx "--" imgSelPy
    ; r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, imgSelPx, imgSelPy, imgW, imgH, 0, 0, imgW, imgH)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, imgSelPx, imgSelPy)
    If (vpMode=1)
       pPath := createImgSelPath(0, 0, newW, newH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)

    If pPath
    {
       Gdip_SetClipPath(G2, pPath, 4)
       Gdip_DeletePath(pPath)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    }

    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(whichBitmap, 1)
    If (r1!="fail")
    {
       UserMemBMP := xBitmap
       recordUndoLevelNow(0, UserMemBMP)
    } Else trGdip_DisposeImage(xBitmap, 1)
    SetTimer, RefreshImageFile, -25
}

ApplySpecialFixedBlur(funcu, zBitmap, radius, pEffect, previewMode:=0) {
    If (!pEffect || !zBitmap)
    {
       addJournalEntry("Internal error: " A_ThisFunc "() has failed: " pEffect " | " zBitmap ". Caller: " funcu "()")
       Return
    }

    If (radius>19 || previewMode=1)
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Return
    }

    If (radius=19)
       radius += 18
    Else If (radius=18)
       radius += 15
    Else If (radius=17)
       radius += 12
    Else If (radius=16)
       radius += 10
    Else If (radius=15)
       radius += 8
    Else If (radius=14)
       radius += 6
    Else If (radius=13)
       radius += 4
    Else If (radius=12)
       radius += 2
    Else If (radius=11)
       radius += 1

    If (radius<=1)
       radius := 2

    zA := Gdip_CreateEffect(1, radius//2, 0, 0)
    zB := Gdip_CreateEffect(1, radius//2, 0, 0)
    Gdip_ImageRotateFlip(zBitmap, 1)
    Gdip_BitmapApplyEffect(zBitmap, zA)
    Gdip_ImageRotateFlip(zBitmap, 3)
    Gdip_BitmapApplyEffect(zBitmap, zB)
    Gdip_DisposeEffect(zA)
    Gdip_DisposeEffect(zB)
}

BlurSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    extendedClone := 1 ; testSelectionLargerThanGiven(imgW, imgH)
    decXbr := (X1<0) ? Abs(X1) : 0
    decYbr := (Y1<0) ? Abs(Y1) : 0
    If (X1<5)
       X1MarginSnap := 1
    If (X2>imgW - 5)
       X2MarginSnap := 1
    If (Y1<5)
       Y1MarginSnap := 1
    If (Y2>imgH - 5)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && blurAreaInverted=1 && EllipseSelectMode=0 && vPselRotation=0)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelBlurSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    } Else If (blurAreaAmount<2 && blurAreaPixelizeAmount<2)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "You have set both pixelize amount and blur amount to zero. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelBlurSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h

    If (blurAreaSoftEdges!=1 && pPath)
    {
       modus := (blurAreaInverted=1) ? 4 : 0
       If (blurAreaInverted=1 && pPath)
          Gdip_SetClipPath(G2, pPath, 4)
       Else If pPath
          Gdip_SetClipPath(G2, pPath, modus)
    }

    If (blurAreaInverted=1)
    {
       imgSelPx := imgSelPy := 0
       imgSelW := imgW
       imgSelH := imgH
    }

    thisOpacity := blurAreaOpacity/255
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    QPV_SetGivenAlphaLevel(zBitmap, 1, 1)

    If (blurAreaPixelizeAmount>1 && blurAreaPixelizeMethod>1)
    {
       thisAmount := blurAreaPixelizeAmount
       thisImgW := (blurAreaPixelizeAmount>1) ? Ceil(imgSelW/blurAreaPixelizeAmount) : imgSelW
       thisImgH := (blurAreaPixelizeAmount>1) ? Ceil(imgSelH/blurAreaPixelizeAmount) : imgSelH
       setWindowTitle("PIXELIZING IMAGE, please wait", 1)
       thisPixiQuality := (blurAreaPixelizeMethod=2) ? 5 : 7
       pixiBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, thisImgW, thisImgH, 0, thisPixiQuality)
       If pixiBMP
          newBitmap := trGdip_ResizeBitmap(A_ThisFunc, pixiBMP, imgSelW, imgSelH, 0, 5)

       If (newBitmap && pixiBMP)
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := newBitmap
       }
       trGdip_DisposeImage(pixiBMP, 1)
    } Else If (blurAreaPixelizeAmount>1)
    {
       setWindowTitle("PIXELIZING IMAGE, please wait", 1)
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH, "0xE200B")
       If warnUserFatalBitmapError(pixiBMP, A_ThisFunc)
       {
          SetTimer, ResetImgLoadStatus, -100
          trGdip_DisposeImage(zBitmap, 1)
          Gdip_DeletePath(pPath)
          Gdip_DeleteGraphics(G2)
          Return "fail"
       }

       thisStartZeit := A_TickCount
       QPV_PixelateBitmap(zBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, min(imgSelW, imgSelH)))
       ; ToolTip, % A_TickCount - thisStartZeit , , , 2
       trGdip_DisposeImage(zBitmap, 1)
       zBitmap := pixiBMP
    }

    thisBlurMode := blurAreaMode
    pEffect := Gdip_CreateEffect(1, blurAreaAmount, 0, 0)
    If (blurAreaTwice=1)
    {
       setWindowTitle("EXTRA-BLURRING IMAGE, please wait", 1)
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, imgSelW//2, imgSelH//2, 1, 3, -1)
       If StrLen(xBitmap)>2
       {
          trGdip_DisposeImage(zBitmap, 1)
          dhMatrix := Gdip_CreateMatrix()
          Gdip_ScaleMatrix(dhMatrix, 2, 2, 1)
          Gdip_TranslateMatrix(dhMatrix, imgSelPx, imgSelPy, 1)
          If (thisBlurMode=3)
          {
             QPV_BoxBlurBitmap(xBitmap, Round(blurAreaAmount/2))
          } Else If (thisBlurMode=2)
          {
             gBitmap := trGdip_BlurBitmap(xBitmap, blurAreaAmount/2.5, 1, 6)
             If !isWinXP
                ApplySpecialFixedBlur(A_ThisFunc, xBitmap, blurAreaAmount, pEffect)

             Gu := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
             If (Gu && gBitmap)
             {
                trGdip_DrawImage(A_ThisFunc, Gu, gBitmap)
                Gdip_DeleteGraphics(Gu)
             }
             trGdip_DisposeImage(gBitmap, 1)
          } Else If (thisBlurMode=1)
             ApplySpecialFixedBlur(A_ThisFunc, xBitmap, blurAreaAmount, pEffect)

          ; trGdip_DisposeImage(zBitmap, 1)
          zBitmap := trGdip_ResizeBitmap(A_ThisFunc, xBitmap, imgSelW, imgSelH, 1, 3, -1)
          trGdip_DisposeImage(xBitmap, 1)
       }
    }

    If (blurAreaAmount<2)
       thisBlurMode := 0
    Else
       setWindowTitle("BLURRING IMAGE, please wait", 1)

    If (thisBlurMode=3) ; box blur
    {
       QPV_BoxBlurBitmap(zBitmap, Round(blurAreaAmount/2))
       gEffect := Gdip_CreateEffect(5, Round(blurAreaAmount/2.5), blurAreaAmount//6)
       If gEffect  ; light readjustments
          Gdip_BitmapApplyEffect(zBitmap, gEffect)

       Gdip_DisposeEffect(gEffect)
    } Else If (thisBlurMode=2)  ; alternate mode
    {
       gBitmap := trGdip_BlurBitmap(zBitmap, blurAreaAmount/2.5, 1, 6)
       If !isWinXP
          ApplySpecialFixedBlur(A_ThisFunc, zBitmap, blurAreaAmount, pEffect)

       Gu := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
       If (Gu && gBitmap)
       {
          trGdip_DrawImage(A_ThisFunc, Gu, gBitmap)
          Gdip_DeleteGraphics(Gu)
       }
       trGdip_DisposeImage(gBitmap, 1)
    } Else If (thisBlurMode=1) ; high quality
       ApplySpecialFixedBlur(A_ThisFunc, zBitmap, blurAreaAmount, pEffect)

    If (BlurAreaBlendMode>1)
       bgrBMPu := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

    If (blurAreaOpacity>252 && blurAreaSoftEdges!=1)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    If (blurAreaSoftEdges=1)
    {
       setWindowTitle("APPLYING SOFT EDGES MASK, please wait", 1)
       thisAmount := (blurAreaTwice=1) ? blurAreaAmount*2 : blurAreaAmount
       thisAmount := (blurAreaSoftLevel>3) ? Round(thisAmount*(blurAreaSoftLevel - 1)) : Round(thisAmount*(blurAreaSoftLevel/3))
       modus := (blurAreaInverted!=1) ? 4 : 0
       carvePathFromBitmap(zBitmap, pPath, imgSelPx , imgSelPy, modus, 2, thisAmount, !blurAreaInverted)
    }

    If (BlurAreaBlendMode>1)
    {
       setWindowTitle("APPLYING BLENDING MODE, please wait", 1)
       rz := QPV_BlendBitmaps(bgrBMPu, zBitmap, BlurAreaBlendMode - 1, 0)
       ou := zBitmap
       zBitmap := bgrBMPu
       bgrBMPu := ou
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    Gdip_DeleteMatrix(dhMatrix)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    If (r1!="fail" && r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

detectEdgesSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    thisCount := (isNumber(IDedgesEmbossLvl) && IDedgesBlendMode>1) ? clampInRange(IDedgesEmbossLvl, 1, 10) : 1
    Loop, % thisCount
    {
       setWindowTitle("DETECTING EDGES - iteration " A_Index "/" thisCount ", please wait", 1)
       r0 := coreDetectEdgesSelectedArea(whichBitmap, 0, G2)
       If r0
          Break
    }

    Gdip_DeleteGraphics(G2)
    If (r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

coreDetectEdgesSelectedArea(whichBitmap, previewMode, Gu:=0) {
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (previewMode!=1)
    {
       G2 := Gu
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelPx := pB.x,  imgSelPy := pB.y
       imgSelW  := pB.w,  imgSelH  := pB.h
    } Else
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
       {
          SetTimer, ResetImgLoadStatus, -100
          Return "fail"
       }
       imgSelPx := imgSelPy := 0
       imgSelW := imgW, imgSelH := imgH
    }

    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    fBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    If (IDedgesBlendMode>1)
       gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)

    If (IDedgesCenterAmount>1)
    {
       pEffect := Gdip_CreateEffect(1, IDedgesCenterAmount, 0, 0)
       If pEffect
          ApplySpecialFixedBlur(A_ThisFunc, zBitmap, IDedgesCenterAmount, pEffect)

       Gdip_DisposeEffect(pEffect)
    }

    G3 := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
    r0 := trGdip_DrawImage(A_ThisFunc, G3, zBitmap, IDedgesXuAmount, IDedgesYuAmount)
    QPV_BlendBitmaps(fBitmap, zBitmap, 16, 0) ; difference mode

    zEffect := Gdip_CreateEffect(6, 0, -100, 0)  ; desaturate image
    If zEffect
       Gdip_BitmapApplyEffect(fBitmap, zEffect)
    Gdip_DisposeEffect(zEffect)

    If (IDedgesEmphasis!=0 || IDedgesContrast!=0)
       wEffect := Gdip_CreateEffect(5, IDedgesEmphasis, IDedgesContrast, 0)

    If wEffect
       Gdip_BitmapApplyEffect(fBitmap, wEffect)

    Gdip_DisposeEffect(wEffect)
    If (IDedgesInvert=1)
    {
       zEffect := Gdip_CreateEffect(7, 0, 0, 100)
       If zEffect
          Gdip_BitmapApplyEffect(fBitmap, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (IDedgesAfterBlur>1)
    {
       pEffect := Gdip_CreateEffect(1, IDedgesAfterBlur*2, 0, 0)
       If pEffect
          ApplySpecialFixedBlur(A_ThisFunc, fBitmap, IDedgesAfterBlur*2, pEffect)

       Gdip_DisposeEffect(pEffect)
    }

    If (IDedgesBlendMode>1)
    {
       QPV_BlendBitmaps(gBitmap, fBitmap, IDedgesBlendMode - 1, 0)
       If (previewMode!=1)
          r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    }

    thisOpacity := IDedgesOpacity/255
    thisBMP := (IDedgesBlendMode>1 && gBitmap) ? gBitmap : fBitmap
    If (previewMode!=1)
       carvePathFromBitmap(thisBMP, pPath, pB.x, pB.y, 4)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(fBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G3)
    If (previewMode=1)
       Gdip_DeleteGraphics(G2)
    er := r1 ? r1 : r0
    Return er
}

addNoiseSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    setWindowTitle("ADDING NOISE, please wait", 1)
    r0 := coreAddNoiseSelectedArea(whichBitmap, 0, G2)

    Gdip_DeleteGraphics(G2)
    If (r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

coreAddNoiseSelectedArea(whichBitmap, previewMode, Gu:=0) {
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (previewMode!=1)
    {
       G2 := Gu
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelPx := pB.x,  imgSelPy := pB.y
       imgSelW  := pB.w,  imgSelH  := pB.h
    } Else
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
       {
          SetTimer, ResetImgLoadStatus, -100
          Return "fail"
       }
       imgSelPx := imgSelPy := 0
       imgSelW := imgW, imgSelH := imgH
    }

    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    thisPixelize := (doubleBlurPreviewArea=1 && previewMode=1) ? blurAreaPixelizeAmount/2 : blurAreaPixelizeAmount
    thisImgW := (thisPixelize>1) ? Ceil(imgSelW/thisPixelize) : imgSelW
    thisImgH := (thisPixelize>1) ? Ceil(imgSelH/thisPixelize) : imgSelH
    noiseBMP := QPV_CreateBitmapNoise(thisImgW, thisImgH, UserAddNoiseIntensity, UserAddNoiseMode, 1)
    If (thisPixelize>1)
    {
       newBitmap := trGdip_ResizeBitmap(A_ThisFunc, noiseBMP, imgSelW, imgSelH, 0, 5)
       If newBitmap
       {
          trGdip_DisposeImage(noiseBMP, 1)
          noiseBMP := newBitmap
       }
    }

    fBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    thisBlurAmount := (doubleBlurPreviewArea=1 && previewMode=1) ? blurAreaAmount//2 : blurAreaAmount
    If (thisBlurAmount>1)
    {
       pEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, noiseBMP, thisBlurAmount, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If (IDedgesEmphasis!=0 || IDedgesContrast!=0)
       wEffect := Gdip_CreateEffect(5, IDedgesEmphasis, IDedgesContrast, 0)

    If wEffect
       Gdip_BitmapApplyEffect(noiseBMP, wEffect)

    Gdip_DisposeEffect(wEffect)
    If (IDedgesInvert=1)
    {
       zEffect := Gdip_CreateEffect(7, 0, 0, 100)
       If zEffect
          Gdip_BitmapApplyEffect(noiseBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (IDedgesBlendMode>1)
    {
       gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
       If gBitmap
          QPV_BlendBitmaps(gBitmap, noiseBMP, IDedgesBlendMode - 1, 0)
    }

    ; r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    thisOpacity := IDedgesOpacity/255
    thisBMP := (IDedgesBlendMode>1 && gBitmap) ? gBitmap : noiseBMP
    If (previewMode!=1)
       carvePathFromBitmap(thisBMP, pPath, pB.x, pB.y, 4)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    trGdip_DisposeImage(fBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    Gdip_DeletePath(pPath)
    If (previewMode=1)
       Gdip_DeleteGraphics(G2)

    er := r1 ? r1 : r0
    Return er
}

livePreviewsPanelNoEffects() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, "0xE200B")
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    Gdip_DeleteGraphics(G)

    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
 }

livePreviewIDedges() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, "0xE200B")
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    Gdip_DeleteGraphics(G)

    thisCount := (isNumber(IDedgesEmbossLvl) && IDedgesBlendMode>1) ? clampInRange(IDedgesEmbossLvl, 1, 10) : 1
    Loop, % thisCount
    {
       r0 := coreDetectEdgesSelectedArea(cornersBMP, 1)
       If r0
          Break
    }

    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
}

livePreviewAddNoiser() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    whichBitmap := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, "0xE200B")
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    Gdip_DeleteGraphics(G)

    r0 := coreAddNoiseSelectedArea(cornersBMP, 1)

    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
}

QPV_BoxBlurBitmap(pBitmap, passes) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BoxBlurBitmap(pBitmap, passes)
  }

  If !pBitmap
     Return 0

  Gdip_GetImageDimensions(pBitmap, w, h)
  If (w<1 || h<1)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  If E1
     Return 0

  func2exec := (A_PtrSize=8) ? "BoxBlurBitmap" : "_BoxBlurBitmap@20"
  r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", stride, "Int", passes)
  Gdip_UnlockBits(pBitmap, iData)
  ; DllCall("GlobalFree", "ptr", mCodeFunc)
  return r
}

QPV_PixelateBitmap(pBitmap, ByRef pBitmapOut, BlockSize) {
   initQPVmainDLL()
   If !qpvMainDll
   {
      addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
      Return Gdip_PixelateBitmap(pBitmap, ByRef pBitmapOut, BlockSize)
   }

   if (!pBitmap || !pBitmapOut)
      return -3

   Gdip_GetImageDimensions(pBitmap, Width, Height)
   If (width<1 || height<1)
      Return 0

   if (Width!=Gdip_GetImageWidth(pBitmapOut) || Height!=Gdip_GetImageHeight(pBitmapOut))
      return -1

   if (BlockSize>Width || BlockSize>Height)
      return -2

   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   E2 := Gdip_LockBits(pBitmapOut, 0, 0, Width, Height, Stride2, Scan02, BitmapData2)

   func2exec := (A_PtrSize=8) ? "PixelateBitmap" : "_PixelateBitmap@24"
   if (!E1 && !E2)
      r := DllCall("qpvmain.dll\" func2exec, "UPtr", Scan01, "UPtr", Scan02, "int", Width, "int", Height, "int", Stride1, "int", BlockSize)
   
   If !E1
      Gdip_UnlockBits(pBitmap, BitmapData1)

   If !E2
      Gdip_UnlockBits(pBitmapOut, BitmapData2)
   return r
}

applyVPeffectsOnBMP(zBitmap) {
    Gdip_GetImageDimensions(zBitmap, imgW, imgH)
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If pEffect
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If imageAttribs
    {
       bluba := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
       If StrLen(bluba)>2
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, bluba)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap,,,,,,,,,,, imageAttribs)
          Gdip_DeleteGraphics(G2)
          If (r1!="fail" && G2)
          {
             trGdip_DisposeImage(zBitmap, 1)
             zBitmap := bluba
          }
       }
       Gdip_DisposeImageAttributes(imageAttribs)
    }
    Return zBitmap
}

GetPathRelativeBounds(pPath, imgSelPx, imgSelPy) {
    pB := Gdip_GetPathWorldBounds(pPath)
    pB.xa := Round(imgSelPx + pB.x)
    pB.ya := Round(imgSelPy + pB.y)
    pB.w := Round(pB.w)
    pB.h := Round(pB.h)
    Return pB
}

getselectedImageArea(whichBitmap, doCarving, limitBounds, applyVPfx, fakeBGR) {
    If StrLen(whichBitmap)<3
    {
       addJournalEntry(A_ThisFunc "(): failed; no bitmap given")
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!limitBounds, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    pPath := createImgSelPath(0, 0, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
    If pPath
    {
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       pBxa := (limitBounds=1) ? clampInRange(pB.xa, 0, imgW - 1) : pB.xa
       pBya := (limitBounds=1) ? clampInRange(pB.ya, 0, imgH - 1) : pB.ya
       pBw := (limitBounds=1) ? clampInRange(pB.w, pB.xa + 1, imgW) : pB.w
       pBh := (limitBounds=1) ? clampInRange(pB.h, pB.ya + 1, imgH) : pB.h

       ; ToolTip, % imgSelPx "===" imgSelPy "`n" pBw "===" pBh , , , 2
       ; extendedClone := !limitBounds ; (A_PtrSize=8) ? 1 : 0
       dummyBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, pBxa, pBya, pBw, pBh, 0, 0, 1, 0)
       If (applyVPfx>0)
          dummyBMP := applyVPeffectsOnBMP(dummyBMP)

       If (doCarving=1 && dummyBMP)
          carvePathFromBitmap(dummyBMP, pPath, pB.x, pB.y, 4, fakeBGR)

       If (applyVPfx=2)
          flipBitmapAccordingToViewPort(dummyBMP)

       ; QPV_SetGivenAlphaLevel(dummyBMP, 1, 1)
       Gdip_DeletePath(pPath)
       Return dummyBMP
    } Else addJournalEntry(A_ThisFunc "(): failed to create GDI+ object path")
}

CropImageInViewPortToSelection() {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If throwErrorSelectionOutsideBounds(whichBitmap)
       Return

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (UserMemBMP=whichBitmap)
       xBitmap := UserMemBMP

    If (EllipseSelectMode=0 && isInRange(imgSelW, imgW - 2, imgW + 2) && isInRange(imgSelH, imgH - 2, imgH + 2) && !imgSelPx && !imgSelPy)
    {
       MouseMoveResponder()
       SetTimer, RefreshImageFile, -25
       Return
    }

    recordUndoLevelNow("init", 0)
    dummyBMP := getselectedImageArea(whichBitmap, 1, 0, 0, 0)
    If StrLen(dummyBMP)>1
    {
       If (EllipseSelectMode>0 || VPselRotation>0)
          currIMGdetails.HasAlpha := 1
       UserMemBMP := dummyBMP
    } Else
    {
       showTOOLtip("Failed to crop image to selected area.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    recordUndoLevelNow(0, UserMemBMP)
    editingSelectionNow := 0
    updateUIctrl()
    trGdip_DisposeImage(xBitmap, 1)
    vpIMGrotation := 0
    MouseMoveResponder()
    SetTimer, RefreshImageFile, -25
    SetTimer, dummyInfoImgCropVP, -125
}

dummyInfoImgCropVP() {
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW*imgH)/1000000, 2)
   showTOOLtip("Image canvas size set to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px ("  mpx " MPx)" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

MenuPasteHDropFiles() {
   r := PasteHDropFiles(1)
   If !r
   {
      showTOOLtip("No image files identified in the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PasteHDropFiles(allowFilesPaste) {
   Try testClipTypeImgA := DllCall("IsClipboardFormatAvailable", "uint", 8)
   Try testClipTypeImgB := DllCall("IsClipboardFormatAvailable", "uint", 2)
   If (testClipTypeImgA=1 || testClipTypeImgB=1)
      Return

   Try testClipType := DllCall("IsClipboardFormatAvailable", "uint", 15)
   Try imgsListu := Clipboard
   If (testClipType!=1)
   {
      filesFound := 0
      Loop, Parse, imgsListu, `n,`r
      {
           If FileExist(Trimmer(A_LoopField))
              filesFound := 1
      } Until (A_Index>5)

      If (filesFound!=1)
      {
         ResetImgLoadStatus()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   If (testClipType=1 || filesFound=1) && (allowFilesPaste=0)
   {
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }

   countFiles := ST_Count(Trimmer(imgsListu), "`n")
   If (countFiles>0 && StrLen(imgsListu)>4)
   {
      showTOOLtip("Files identified in the clipboard")
      msgResult := msgBoxWrapper(appTitle ": Paste files", "You have " countFiles " file entries stored in the clipboard by your file explorer or manager.`n`nWould you like to import the image files (if any) into the files list of " appTitle "?", 4, 0, "question", "Select newly inserted index entries")
   }

   If InStr(msgResult.btn, "yes")
   {
      initialIndex := maxFilesIndex
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir, msgResult.check)
      If (initialIndex!=maxFilesIndex)
      {
         currentFileIndex := maxFilesIndex - 1
         GenerateRandyList()
         dummyTimerDelayiedImageDisplay(50)
         ForceRefreshNowThumbsList()
         newFiles := max(initialIndex, maxFilesIndex) - min(initialIndex, maxFilesIndex)
         showTOOLtip("Finished adding " newFiles " image files from the clipboard")
      } Else showTOOLtip("No image files identified in the clipboard`nFiles list unchanged.")
   } Else RemoveTooltip()

   ResetImgLoadStatus()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return 1
}

corePasteClipboardImg(modus, imgW, imgH, allowFilesPaste) {
    clipBMP := Gdip_CreateBitmapFromClipboard()
    If clipBMP
       createdGDIobjsArray["x" clipBMP] := [clipBMP, "bmp", 1, A_ThisFunc]

    If (isInRange(Abs(clipBMP), 1, 5) || !clipBMP)
    {
       If PasteHDropFiles(allowFilesPaste)
          Return

       Try toPaste := Trimmer(Clipboard)
       If StrLen(toPaste)>2
       {
          textMode := 1
          toPaste := SubStr(toPaste, 1, 9500)
          clipBMP := drawTextInBox(toPaste, OSDFontName, PasteFntSize, imgW, imgH, OSDtextColor, OSDbgrColor, 0, 0, usrTextAlign, "0xFF")
          If (modus=1)
             showTOOLtip("Text clipboard content rendered as image`nOSD font and colors used")
          SetTimer, RemoveTooltip, % -msgDisplayTime
       } Else
       {
          Tooltip
          showTOOLtip("ERROR: Unable to retrieve image from clipboard")
          SetTimer, ResetImgLoadStatus, -25
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    }

    ; disposeCacheIMGs()
    If !InStr(Gdip_GetImagePixelFormat(clipBMP, 1), "0xE200")
    {
       krpBmp := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
       If krpBmp
       {
          trGdip_DisposeImage(clipBMP, 1)
          clipBMP := krpBmp
       }
    }
    ; MsgBox, % Gdip_GetImagePixelFormat(clipBMP, 1)
    Return clipBMP
}

tlbrPasteClipboardIMG() {
   If (editingSelectionNow=1)
      PanelPasteInPlace()
   Else
      PasteClipboardIMG()
}

PasteClipboardIMG() {
    Static clippyCount := 0

    If (AnyWindowOpen>0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    If askAboutFileSave(" and the clipboard image or files entries are going to be pasted")
       Return

    showTOOLtip("Retrieving clipboard, please wait")
    setImageLoading()
    If PasteHDropFiles(1)
       Return

    changeMcursor()
    calcScreenLimits()
    clipBMP := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 1)
    If !clipBMP
    {
       ResetImgLoadStatus()
       Return
    }

    terminateIMGediting()
    UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    clippyCount++
    If (editingSelectionNow=1)
       toggleImgSelection()

    discardViewPortCaches()
    UserMemBMP := clipBMP
    If (!currentFileIndex || !CurrentSLD || !maxFilesIndex)
    {
       maxFilesIndex := currentFileIndex := 0
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\Clipboard-" clippyCount ".img"
    }

    currIMGdetails.HasAlpha := 1
    isUniform := Gdip_TestBitmapUniformity(clipBMP, 7, maxLevelIndex)
    If (isUniform=1 && isInRange(maxLevelIndex, 252, 255))
       currIMGdetails.HasAlpha := 0
    ; ToolTip, % currIMGdetails.HasAlpha " = lol" , , , 2
    imgIndexEditing := currentFileIndex
    usrColorDepth := imgFxMode := 1
    vpIMGrotation := FlipImgH := FlipImgV := 0
    dropFilesSelection(1)
    RemoveTooltip()
    SetTimer, ResetImgLoadStatus, -50
    SetTimer, RefreshImageFile, -50
}

thumbsSelector(keyu, aKey, prevFileIndex) {
  Static lastInvoked := 1

  ; ToolTip, % prevFileIndex "--" markedSelectFile "`n" lola
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Upu" || keyu="Home") && prevFileIndex<=1)
  || (InStr(aKey, "+") && (keyu="Right" || keyu="Down" || keyu="End") && prevFileIndex>=maxFilesIndex)
     Return

  selA := resultedFilesList[currentFileIndex, 2]
  selB := resultedFilesList[prevFileIndex, 2]
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Right"))
  {
     testIndex := (keyu="Left") ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (keyu="Left") ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
        markedSelectFile++
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 1
     } Else If (selA=1 && selB=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 0
        markedSelectFile -= 2
     }

     markedSelectFile++
     lastZeitFileSelect := A_TickCount
  } Else If InStr(aKey, "+") ; && (keyu="Upu" || keyu="Down"))
  {
     direction := (keyu="Down" || keyu="PgDn" || keyu="End") ? 1 : 0
     testIndex := (direction!=1) ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (direction!=1) ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
        lastZeitFileSelect := A_TickCount
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 1)
        lastZeitFileSelect := A_TickCount
     } Else If (selA=1 && selB=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 0)
        resultedFilesList[currentFileIndex, 2] := 1
        lastZeitFileSelect := A_TickCount
        markedSelectFile++
     }
  }

  If (markedSelectFile=1 && InStr(aKey, "+"))
  {
     markedSelectFile := 0
     lastZeitFileSelect := A_TickCount
     resultedFilesList[currentFileIndex, 2] := 0
  }
}

generateNumberRangeString(pA, pB) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
        stringRange .= "," mA + A_Index - 1 "|"

    Return stringRange
}

selectFilesRange(pA, pB, sel) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
    {
        oSel := resultedFilesList[mA + A_Index - 1, 2]
        resultedFilesList[mA + A_Index - 1, 2] := sel
        If (sel=1 && oSel!=1)
           markedSelectFile++
        Else If (sel!=1 && oSel=1)
           markedSelectFile--
    }
    lastZeitFileSelect := A_TickCount
    Return rangeC
}

jumpSelectRangeGiven(pA, pB) {
   mB := max(pA, pB)
   mA := min(pA, pB)
   rangeC := mB - mA + 1
   changeMcursor()
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection. The given range is: " mA " - " mB, "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel")
      {
         SetTimer, RemoveTooltip, -250
         Return
      }
   }

   If (msgResult="replace" || !msgResult)
   {
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   Loop, % rangeC
      resultedFilesList[mA + A_Index - 1, 2] := (msgResult="add" || !msgResult) ? 1 : 0

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ResetImgLoadStatus()
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   Return rangeC
}

ThumbsNavigator(keyu, aKey) {
  resetSlideshowTimer(0)
  If (thumbsDisplaying!=1 && maxFilesIndex>1)
  {
     If askAboutFileSave(" and another image will be loaded")
        Return
  }

  prevFileIndex := currentFileIndex
  thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
  If (keyu="Down")
  {
     currentFileIndex := currentFileIndex + maxItemsW - 1
     NextPicture(0, 0, 1)
  } Else If (keyu="Upu")
  {
     currentFileIndex := currentFileIndex - maxItemsW + 1
     PreviousPicture(0, 0, 1)
  } Else If (keyu="PgUp")
  {
     currentFileIndex := currentFileIndex - maxItemsPage + 1
     PreviousPicture()
  } Else If (keyu="PgDn")
  {
     Loop, % maxItemsH
     {
        currentFileIndex := currentFileIndex + maxItemsW - 1
        NextPicture(0, 0, 1)
        thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
     }
     ; currentFileIndex := currentFileIndex + maxItemsPage - 1
     ; NextPicture()
  } Else If (keyu="Left")
     PreviousPicture()
  Else If (keyu="Right")
     NextPicture()
  Else If (keyu="End")
     LastPicture()
  Else If (keyu="Home")
     FirstPicture()

  thumbsSelector(keyu, aKey, prevFileIndex)
  If (thumbsDisplaying!=1 && InStr(aKey, "+"))
     dummyTimerDelayiedImageDisplay(50)
}

PanIMGonScreen(direction) {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (GetKeyState("Left", "P")!=1 && GetKeyState("Right", "P")!=1)
   && (GetKeyState("Down", "P")!=1 && GetKeyState("Up", "P")!=1)
      Return

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   zL := (zoomLevel<0.7) ? 0.7 : zoomLevel
   If (zoomLevel>2)
      zL := 2
   stepu := GetKeyState("Shift", "P") ? 0.3 : 0.1 * zL
   stepu := (Round(mainHeight*stepu) + Round(mainWidth*stepu))//2 + 1
   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY + stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX + stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX - stepu

   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      diffIMGdecY := stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      diffIMGdecY := - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      diffIMGdecX := stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      diffIMGdecX := - stepu

; ReloadThisPicture()
   If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
      SetTimer, coreReloadThisPicture, -5
   Else
      dummyTimerDelayiedImageDisplay(10)
}

dummyTimerDelayiedImageDisplay(timeru:=0) {
  If (timeru>1)
     SetTimer, extraDummyDelayiedImageDisplay, % -timeru ; , 950
}

extraDummyDelayiedImageDisplay() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -15
     Return
  }
  DelayiedImageDisplay()
}

filterDelayiedImageDisplay() {
  Static lastInvoked := 1
  If (A_tickcount - lastInvoked < 60)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -50
     Return
  }
  lastInvoked := A_TickCount
  DelayiedImageDisplay()
  lastInvoked := A_TickCount
}

DelayiedImageDisplay() {
   If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
   {
      r := IDshowImage(currentFileIndex)
      If !r
         informUserFileMissing()
   }
}

DonateNow() {
   Try Run, https://www.paypal.me/MariusSucan/10
}

openSettingsDir() {
   Try Run, % mainCompiledPath
}

DeleteAllSettings() {
    SoundBeep, 300, 300
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete ALL personalized settings?`n`n" appTitle " will automatically restart if you choose to do so. This action is irreversible.", "&Restore defaults|&Cancel", 2, "exclamation")
    If (msgResult="restore defaults")
    {
       FileSetAttrib, -R, % mainSettingsFile
       FileDelete, % mainSettingsFile
       terminateIMGediting()
       restartAppu()
    }
}

externalinvokedSettingsContextMenu() {
    hwndA := WinActive("ahk_id " hSetWinGui)
    hwndB := WinActive("ahk_id " MsgBox2hwnd)
    hwnd := ((hwndA=hSetWinGui || hwndB=MsgBox2hwnd) && AnyWindowOpen) ? 1 : 0
    If (hwnd!=1)
       Return

    If (AnyWindowOpen && MsgBox2hwnd=hwndB)
       GuiControlGet, OutputVar, WinMsgBox: Focus
    Else If AnyWindowOpen
       GuiControlGet, OutputVar, SettingsGUIA: Focus
    ; ToolTip, % OutputVar , , , 2
    If InStr(OutputVar, "edit")
       Return

    If (AnyWindowOpen=3 && InStr(OutputVar, "listview"))
       invokePanelDynaFoldersContextMenu()
    Else If (AnyWindowOpen=2 && InStr(OutputVar, "listview"))
       invokePanelStaticFoldersContextMenu()
    Else If AnyWindowOpen
       invokePrefsPanelsContextMenu()
}

SettingsGUIAGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1

    If (mouseToolTipWinCreated=1)
    {
       mouseTurnOFFtooltip()
       Return
    }

    If (GuiHwnd!=hSetWinGui)
       Return

    If (AnyWindowOpen=3 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelDynaFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen=2 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelStaticFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen && !InStr(A_GuiControl, "lview") && IsRightClick=1) ; || (MsgBox2hwnd && A_IsSuspended)
    {
       If SettingsToolTips()
          Return
    }

    If (CtrlHwnd && IsRightClick=1) || ((A_TickCount - lastInvoked>250) && IsRightClick=0) || (mouseToolTipWinCreated=1)
    {
       lastInvoked := A_TickCount
       Return
    }

    lastInvoked := A_TickCount
    invokePrefsPanelsContextMenu()
    Return
}

invokePrefsPanelsContextMenu() {
    Menu, ContextMenu, UseErrorLevel
    Menu, ContextMenu, Delete
    Sleep, 5
    Menu, ContextMenu, Add, &Large UI fonts, ToggleLargeUIfonts
    Menu, ContextMenu, Add, &Close panel`tESC, CloseWindow
    If (imgEditPanelOpened=1)
       Menu, ContextMenu, Add, C&ollapse panel`tF8, toggleImgEditPanelWindow
    Menu, ContextMenu, Add, 
    If (PrefsLargeFonts=1)
       Menu, ContextMenu, Check, &Large UI fonts

    Menu, ContextMenu, Add, O&pen settings folder, openSettingsDir
    Menu, ContextMenu, Add, Restore ALL defaults, DeleteAllSettings
    Menu, ContextMenu, Add
    Menu, ContextMenu, Add, &Visit official site, OpenGitHub
    Menu, ContextMenu, Add, &Make a donation, DonateNow
    Menu, ContextMenu, Add
    Menu, ContextMenu, Add, &New instance, OpenNewQPVinstance
    Menu, ContextMenu, Add, &Restart %appTitle%, restartAppu
    showThisMenu("ContextMenu")
}

WinMsgBoxGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1
    If (mouseToolTipWinCreated=1) ; || (A_TickCount - lastInvoked<90)
    {
       mouseTurnOFFtooltip()
       Return
    }

    isFakeWin := (prevOpenedWindow[5]=1 && AnyWindowOpen>0) ? 1 : 0
    If !MsgBox2hwnd
       Return

    If (isRightClick=1)
    {
       If SettingsToolTips()
          Return
       Else If AnyWindowOpen
          invokePrefsPanelsContextMenu()
    }

    lastInvoked := A_TickCount
    Return
}

WM_RBUTTONUP() {
    ; Tooltip, %A_GuiControl%
    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()
    Else If (AnyWindowOpen && !InStr(A_GuiControl, "lview")) || (MsgBox2hwnd && A_IsSuspended)
       SettingsToolTips()
}

SettingsToolTips() {
   ActiveWin := WinExist("A")
   thisHwnd := (ActiveWin=hSetWinGui && hSetWinGui!=PVhwnd) || (ActiveWin=MsgBox2hwnd && A_IsSuspended) ? 1 : 0
   If (thisHwnd!=1)
      Return

   If (mouseToolTipWinCreated=1)
      mouseTurnOFFtooltip()
 
   GuiControlGet, value, , %A_GuiControl%
   GuiControlGet, hwnd, hwnd, %A_GuiControl%
   ControlGetText, info,, ahk_id %hwnd%
   ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
   ControlGet, ctrlActiveState, Enabled,,, ahk_id %hwnd%
   If (info=value)
      info := ""

   If StrLen(info)>0
      info .= "`n"

   If (posuk := InStr(value, "&"))
      hotkeyu := "`nAlt+" SubStr(value, posuk + 1, 1)
   Else If (posuk := InStr(A_GuiControl, "&"))
      hotkeyu := "`nAlt+" SubStr(A_GuiControl, posuk + 1, 1)
   
   StringUpper, hotkeyu, hotkeyu
   value := StrReplace(value, "&")
   ctrlu := StrReplace(A_GuiControl, "&")
   If (ctrlu=value)
      value := ""

   ; btnType := GetButtonType(hwnd)
   If StrLen(value)>0
   {
      thisValueNumber := isNumber(Trimmer(value))
      value .= " = "
   }

   MouseGetPos, , , id, controla, 2
   If !hwnd
      ControlGetText, info, , ahk_id %controla%

   WinGetClass, OutputVar, ahk_id %hwnd%
   If OutputVar
   {
      If InStr(OutputVar, "_trackbar")
      {
         SendMessage, 0x0401,,,, ahk_id %hwnd%   ; TBM_GETRANGEMIN
         minu := ErrorLevel
         SendMessage, 0x0402,,,, ahk_id %hwnd%   ; TBM_GETRANGEMAX
         maxu := ErrorLevel
         OutputVar := "Slider: " minu "; " maxu
      } Else If (InStr(OutputVar, "Button") && thisValueNumber=1 && InStr(value, "="))
         OutputVar := "Checkbox"
      Else If InStr(OutputVar, "_updown")
      {
         SendMessage, 0x0400+102,,,, ahk_id %hwnd%   ; UDM_GETRANGE
         UDM_GETRANGE := ErrorLevel
         minu := UDM_GETRANGE >> 16
         maxu := UDM_GETRANGE & 0xFFFF
         OutputVar := "Up/Down range: " minu "; " maxu
      } Else If InStr(OutputVar, "edit")
      {
         OutputVar := "Edit field"
      } Else If (InStr(OutputVar, "static") && value)
      {
         OutputVar := "Clickable" ; value  " - " ctrlu
         controlType := "`n[" OutputVar "]"
      }
      If !InStr(OutputVar, "static")
         controlType := "`n[" OutputVar "]"
   }

   msg2show := info value A_GuiControl controlType hotkeyu
   ; If (ctrlActiveState!=1 && StrLen(msg2show)>2 && btnType)
   ;    msg2show .= "`n[CONTROL DISABLED]"
   If StrLen(listBoxOptions)>3
   {
      countListBoxOptions := ST_Count(listBoxOptions, "`n") + 1
      If (countListBoxOptions>10)
         listBoxOptions := "[too many to list]"
      msg2show .= "`n`nLIST OPTIONS: " countListBoxOptions "`n" listBoxOptions
   }

   ; If (!value && btnType)
   ;    msg2show .= "`n`nCONTROL TYPE:`n" btnType
   If InStr(msg2show, "lib\") || InStr(msg2show, "a href=")
      Return

   mouseCreateOSDinfoLine(msg2show, PrefsLargeFonts)
   Return msg2show
}

ST_Count(Haystack, searchFor) {
    StrReplace(Haystack, searchFor,, OutputVarCount)
    Return OutputVarCount
}

SetParentID(Window_ID, theOther) {
  r := DllCall("SetParent", "uint", theOther, "uint", Window_ID) ; success = handle to previous parent, failure =null 
  Return r
}

CreateGuiButton(btnList, killWin:=0, delayu:=950) {
    Critical, On
    Static lastCreated := 1, bgrColor := 112288, txtColor := "ddeeFF", thisOpacity := 200
         , prevBtnList := "z"
    Global BtnTemp1, BtnTemp2
    
    If (killWin=1)
    {
       prevBtnList := ""
       Gui, TempBtnGui: Destroy
       tempBtnVisible := "null"
       interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
       Return
    }

    If (prevBtnList=btnList && tempBtnVisible!="null" && killWin!=1)
       Return

    If (TouchScreenMode!=1 && killWin!="force") ; || MsgBox2hwnd
       Return
 
    thisFntSize := OSDfntSize
    thisFntSize := Round(thisFntSize*0.45)
    If (thisFntSize<9)
       thisFntSize := 9
    Gui, TempBtnGui: Destroy
    Sleep, 25

    roundedCsize := Round(thisFntSize/1.7) + 15
    Gui, TempBtnGui: -DPIScale -Caption +ToolWindow +E0x8000000 +hwndhGuiBtn +Owner%PVhwnd%
    Gui, TempBtnGui: Margin, % thisFntSize + 10, % thisFntSize
    Gui, TempBtnGui: Color, c%bgrColor%
    Gui, TempBtnGui: Font, s%thisFntSize% Bold Q5, Arial
    btnArray := StrSplit(btnList, "||")
    tempBtnGuiBtnArray := []
    Loop, % btnArray.Count()
    {
        thisBtnArr := StrSplit(btnArray[A_Index], ",,")
        ; ToolTip, % thisBtnArr[1] "==" thisBtnArr[2] , , , 2
        If (A_Index=1)
           Gui, TempBtnGui: Add, Text, c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
        Else If thisBtnArr[1]
           Gui, TempBtnGui: Add, Text, x+%OSDfntSize% c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
 
        tempBtnGuiBtnArray[A_Index] := thisBtnArr[2]
    }

    WinGetPos, winPosX, winPosY, Wid, Heig, ahk_id %PVhwnd%
    Gui, TempBtnGui: Show, NoActivate AutoSize Hide x%winPosX% y%winPosY%, QPVGuiActionBtn
    WinGetPos,,, gWid, gHeig, ahk_id %hGuiBtn%
    If (gWid>Wid - thisFntSize*2.2)
       gWid := Wid - Round(thisFntSize * 2.25) - 5
    If (gWid<5)
       gWid := 5

    ; compatMode := (A_OSVersion="WIN_XP" || A_OSVersion="WIN_7") ? 1 : 0
    compatMode := 1
    If (compatMode=0)
       winPosX := winPosY := 1

    offsetuY := scrollBarHy ? Heig - scrollBarHy : 0
    Final_x := winPosX + thisFntSize * 2
    Final_y := winPosY + Heig - thisFntSize * 2 - gHeig - offsetuY//2
    If (compatMode=1)
    {
       WinSet, Transparent, %thisOpacity%, ahk_id %hGuiBtn%
       WinSet, AlwaysOnTop, On, ahk_id %hGuiBtn%
    }

    WinSet, Region, 0-0 R%roundedCsize%-%roundedCsize% w%gWid% h%gHeig%, QPVGuiActionBtn
    If (compatMode=0)
       SetParentID(PVhwnd, hGuiBtn)

    GroupAdd, QPVwindows, ahk_id %hGuiBtn%
    Gui, TempBtnGui: Show, NoActivate AutoSize x%Final_x% y%Final_y%, GuiActionBtn
    tempBtnVisible := hGuiBtn
    If InStr(btnList, ",,")
       prevBtnList := btnList
    interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
    SetTimer, DestroyTempBtnGui, % - delayu
    lastCreated := A_TickCount
}

tempGuiBtnCall1() {
    coretempGuiBtnCalls(1)
}

tempGuiBtnCall2() {
    coretempGuiBtnCalls(2)
}

tempGuiBtnCall3() {
    coretempGuiBtnCalls(3)
}

tempGuiBtnCall4() {
    coretempGuiBtnCalls(4)
}

tempGuiBtnCall5() {
    coretempGuiBtnCalls(5)
}

coretempGuiBtnCalls(indexu) {
    SetTimer, DestroyTempBtnGui, -950
    If (WinActive("A")!=PVhwnd)
       WinActivate, ahk_id %PVhwnd%
    thisFunc := tempBtnGuiBtnArray[indexu]
    ; ToolTip, % thisfunc "===" indexu , , , 2
    %thisFunc%()
    If (drawingShapeNow!=1)
       SetTimer, DestroyTempBtnGui, -950
}

DestroyTempBtnGui(dummy:=0) {
    Critical, On
    MouseGetPos, , , OutputVarWin
    thisWin := WinActive("A")
    okay := (thisWin=PVhwnd || thisWin=hSetWinGui) ? 1 : 0
    ; ToolTip, % OutputVarWin , , , 2
    If (OutputVarWin!=tempBtnVisible) || (okay!=1) || (dummy="now")
       CreateGuiButton("Die dummy", 1)  ;   ;-)
    Else
       SetTimer, DestroyTempBtnGui, -950
}

openPreviousPanel(mode:="") {
   thisFunc := prevOpenedWindow[2]
   allowReopen := prevOpenedWindow[3]
   If (IsFunc(thisfunc) && thisFunc && allowReopen=1) || (thisFunc && mode="forced")
   {
      %thisFunc%()
   } Else
   {
      showTOOLtip("No previously opened panel")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

mouseTurnOFFtooltip() {
   Gui, mouseToolTipGuia: Destroy
   mouseToolTipWinCreated := 0
}

mouseCreateOSDinfoLine(msg:=0, largus:=0) {
    Critical, On
    Static prevMsg, lastInvoked := 1
    Global TippyMsg

    thisHwnd := (AnyWindowOpen>0 && prevOpenedWindow[5]!=1) ? hSetWinGui : MsgBox2hwnd
    If (StrLen(msg)<3) || (prevMsg=msg && mouseToolTipWinCreated=1) || (A_TickCount - lastInvoked<100) || !thisHwnd
       Return

    lastInvoked := A_TickCount
    Gui, mouseToolTipGuia: Destroy
    thisFntSize := (largus=1) ? Round(LargeUIfontValue*1.55) : LargeUIfontValue
    If (thisFntSize<12)
       thisFntSize := 12
    bgrColor := OSDbgrColor
    txtColor := OSDtextColor
    isBold := (FontBolded=1) ? " Bold" : ""
    Sleep, 25

    Gui, mouseToolTipGuia: -DPIScale -Caption +Owner%thisHwnd% +ToolWindow +hwndhGuiTip
    Gui, mouseToolTipGuia: Margin, % thisFntSize, % thisFntSize
    Gui, mouseToolTipGuia: Color, c%bgrColor%
    Gui, mouseToolTipGuia: Font, s%thisFntSize% %isBold% Q5, %OSDFontName%
    Gui, mouseToolTipGuia: Add, Text, c%txtColor% gmouseTurnOFFtooltip vTippyMsg, %msg%
    Gui, mouseToolTipGuia: Show, NoActivate AutoSize Hide x1 y1, QPVOguiTipsWin

    GetPhysicalCursorPos(mX, mY)
    tipX := mX + 15
    tipY := mY + 15
    ResWidth := adjustWin2MonLimits(hGuiTip, tipX, tipY, Final_x, Final_y, Wid, Heig)
    MaxWidth := Floor(ResWidth*0.85)
    If (MaxWidth<Wid && MaxWidth>10)
    {
       GuiControl, mouseToolTipGuia: Move, TippyMsg, w1 h1
       GuiControl, mouseToolTipGuia:, TippyMsg,
       Gui, mouseToolTipGuia: Add, Text, xp yp c%txtColor% gmouseTurnOFFtooltip w%MaxWidth%, %msg%
       Gui, mouseToolTipGuia: Show, NoActivate AutoSize Hide x1 y1, QPVguiTipsWin
       ResWidth := adjustWin2MonLimits(hGuiTip, tipX, tipY, Final_x, Final_y, Wid, Heig)
    }

    prevMsg := msg
    mouseToolTipWinCreated := 1
    WinSet, AlwaysOnTop, On, ahk_id %hGuiTip%
    WinSet, Transparent, 225, ahk_id %hGuiTip%
    Gui, mouseToolTipGuia: Show, NoActivate AutoSize x%Final_x% y%Final_y%, QPVguiTipsWin
    delayu := StrLen(msg) * 70 + 900
    If (delayu<msgDisplayTime/2)
       delayu := msgDisplayTime//2 + 1
    SetTimer, mouseTurnOFFtooltip, % -delayu
}

adjustWin2MonLimits(winHwnd, winX, winY, ByRef rX, ByRef rY, ByRef Wid, ByRef Heig) {
   GetWinClientSize(Wid, Heig, winHwnd, 1)
   ActiveMon := MWAGetMonitorMouseIsIn(winX, winY)
   If ActiveMon
   {
      SysGet, bCoord, Monitor, %ActiveMon%
      rX := max(bCoordLeft, min(winX, bCoordRight - Wid))
      rY := max(bCoordTop, min(winY, bCoordBottom - Heig*1.2))
      ResWidth := Abs(max(bCoordRight, bCoordLeft) - min(bCoordRight, bCoordLeft))
      ; ResHeight := Abs(max(bCoordTop, bCoordBottom) - min(bCoordTop, bCoordBottom))
   } Else
   {
      rX := winX
      rY := winY
   }

   Return ResWidth
}

createSettingsGUI(IDwin, thisCaller:=0, allowReopen:=1) {
    thisBtnHeight := (PrefsLargeFonts=1) ? 34 : 24
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()

    ; If (editingSelectionNow=1 && imgEditPanelOpened!=1)
    ;    ToggleEditImgSelection()

    panelWinCollapsed := 0
    interfaceThread.ahkassign("panelWinCollapsed", panelWinCollapsed)
    interfaceThread.ahkassign("imgEditPanelOpened", imgEditPanelOpened)
    If (imgEditPanelOpened=1)
    {
       If (folderTreeWinOpen=1)
          fdTreeClose()

       o_ImgQuality := userimgQuality
       If (userimgQuality=1)
         ToggleImgQuality("lowu")

       initQPVmainDLL()
       recordSelUndoLevelNow()
       INIaction(0, "closeEditPanelOnApply", "General", 1)
       interfaceThread.ahkassign("AnyWindowOpen", IDwin)
       TriggerMenuBarUpdate()
       If AnyWindowOpen
          Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%
       DestroyGIFuWin()
       Gui, SettingsGUIA: Destroy
       Sleep, 5
    } Else CloseWindow()
    Sleep, 15
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: -MaximizeBox -MinimizeBox +Owner%PVhwnd% hwndhSetWinGui
    Gui, SettingsGUIA: Margin, 15, 15
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    AnyWindowOpen := IDwin
    interfaceThread.ahkassign("AnyWindowOpen", IDwin)
    interfaceThread.ahkassign("hSetWinGui", hSetWinGui)
    If (allowReopen=1)
    {
       prevOpenedWindow := []
       prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 0, o_ImgQuality]
    }

    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    Return thisBtnHeight
}

PanelSeenStats() {
    Global LViewMetaD, LViewMetaM, LViewMetaH, infoLine
    showTOOLtip("Generating statistics, please wait")
    thisBtnHeight := createSettingsGUI(39, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 199
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3,, Daily|Monthly|Hourly|Options
    Gui, Tab, 1 ; Daily
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD AltSubmit gSeenStatsLVaction, #|Date|Images|`%
    Gui, Tab, 2 ; Monthly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaM AltSubmit gSeenStatsLVaction, #|Date|Images|`%
    Gui, Tab, 3 ; Hourly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaH, #|Hour|Images|`%
    Gui, Tab, 4 ; Options
    Gui, Add, Button, x+15 y+15 h%thisBtnHeight% gCleanDeadFilesSeenImagesDB, &Purge records of inexistent files
    Gui, Add, Button, y+5 hp geraseSeenIMGsDB, &Erase the entire list
    Gui, Add, Button, y+5 hp gBtnCopySeenStats, &Copy statistics to clipboard
    Gui, Add, Button, y+5 hp gBtnALLviewedImages2List, &Retrieve list of recorded seen images
    Gui, Add, Text, y+10 w%lstWid%, TIP: To retrieve the images seen on a given day or month, double click on the date in the list.
    Gui, Add, Text, y+10 h%thisBtnHeight% +0x200 w%lstWid% vinfoLine, Please wait...

    Gui, Tab
    Gui, Add, Button, xp y+5 h%thisBtnHeight% w1 h1 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Images seen statistics: " appTitle)
    PopulateSeenStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
}

PanelIndexedImagesStats() {
    Global LViewMetaD, LViewMetaG, LViewMetaU, LViewMetaM, LViewMetaY, LViewMetaS, LViewMetaT, LViewMetaA, LViewMetaI
         , LViewMetaR, StatsUIhistoThingy := 1

    showTOOLtip("Generating image files statistics, please wait")
    thisBtnHeight := createSettingsGUI(48, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3,, Megapixels|Aspect ratios|DPI|Frames|Pixel formats|Histogram
    Gui, Tab, 1
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD AltSubmit gIndexStatsLVaction, #|MPx|Images|`%
    Gui, Tab, 2
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaY AltSubmit gIndexStatsLVaction, #|W/H ratios|Images|`%
    Gui, Tab, 3
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaU AltSubmit gIndexStatsLVaction, #|DPI|Images|`%
    Gui, Tab, 4
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaM AltSubmit gIndexStatsLVaction, #|Frames|Images|`%
    Gui, Tab, 5
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaS AltSubmit gIndexStatsLVaction, #|Formats|Images|`%
    Gui, Tab, 6
    Gui, Add, DropDownList, y+15 w%lstWid% AltSubmit Choose1 gSwitchUIdlHistoStats vStatsUIhistoThingy, Averages|Medians|Peak (range)|Minimum (range)|Total range
    Gui, Add, ListView, y+10 w%lstWid% r6 Grid vLViewMetaG AltSubmit gIndexStatsLVaction, #|Medians|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaA AltSubmit gIndexStatsLVaction, #|Max|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaI AltSubmit gIndexStatsLVaction, #|Min|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaT AltSubmit gIndexStatsLVaction, #|Avg|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaR AltSubmit gIndexStatsLVaction, #|Range|Images|`%

    Gui, Tab
    Gui, Add, Button, xp Section y+5 h%thisBtnHeight% w2 gBtnCloseWindow, C&lose
    Gui, Add, Button, x+5 hp gPanelWrapperFilesStats, Bac&k
    Gui, Add, Text, x+5 hp w%lstWid% vinfoLine +0x200 -wrap, Please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Indexed images statistics: " appTitle)
    ; If (SLDtypeLoaded=3)
    ;    PopulateIndexSQLFilesStatsInfos()
    ; Else
       PopulateImagesIndexStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
    SetTimer, SwitchUIdlHistoStats, -300
}

SwitchUIdlHistoStats() {
   If (AnyWindowOpen=48)
   {
      GuiControlGet, StatsUIhistoThingy
      If (StatsUIhistoThingy=1)
      {
         GuiControl, SettingsGUIA: Show, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=2)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Show, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=3)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Show, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=4)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Show, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=5)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Show, LViewMetaR
      }
   }
}

PanelIndexedFilesStats() {
    Global LViewMetaD, LViewMetaM, LViewMetaY, LViewMetaS, LViewMetaT
    showTOOLtip("Generating statistics, please wait")
    thisBtnHeight := createSettingsGUI(44, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3,, Days|Months|Years|Sizes|Types
    Gui, Tab, 1 ; Daily
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD AltSubmit gIndexStatsLVaction, #|Date|Images|`%
    Gui, Tab, 2 ; Monthly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaM AltSubmit gIndexStatsLVaction, #|Date|Images|`%
    Gui, Tab, 3 ; Yearly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaY AltSubmit gIndexStatsLVaction, #|Year|Images|`%
    Gui, Tab, 4 ; Sizes
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaS AltSubmit gIndexStatsLVaction, #|File size ranges|Total size [MB]|Images|`%
    Gui, Tab, 5 ; Types
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaT AltSubmit gIndexStatsLVaction, #|File types|Images|`%

    Gui, Tab
    Gui, Add, Button, xp Section y+5 h%thisBtnHeight% w2 gBtnCloseWindow, C&lose
    Gui, Add, Button, x+2 h%thisBtnHeight% gPanelWrapperFilesStats, Bac&k
    Gui, Add, Text, x+5 yp hp +0x200 -wrap, Modified file date used for statistics
    Gui, Add, Text, xs w%lstWid% vinfoLine +0x200, Please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Indexed files statistics: " appTitle)
    If (SLDtypeLoaded=3)
       PopulateIndexSQLFilesStatsInfos()
    Else
       PopulateIndexFilesStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
}

PanelWrapperFilesStats() {
    thisBtnHeight := createSettingsGUI(49, A_ThisFunc)
    btnWid := 105
    txtWid := 370
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 165
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 w%txtWid%, The statistics panel allows users to filter the indexed files to various criteria by double-clicking on list view entries. It is meant to facilitate the identification of small files, low resolution images, low key or high key, or washed out images in your collection.
    Gui, Add, Text, y+15 Section, File details: size, date modified, type.
    Gui, Add, Button, xp+15 y+5 h%thisBtnHeight% gPanelIndexedFilesStats, Open &file statistics panel
    Gui, Add, Button, x+5 hp gBtnCollectFileInfos, &Collect data
    Gui, Add, Text, xs y+35 Section, Image properties: resolution, frames, histogram and more.
    Gui, Add, Button, xp+15 y+5 h%thisBtnHeight% gPanelIndexedImagesStats, Open &images statistics panel
    Gui, Add, Button, xp+15 y+5 hp gBtnCollectImageInfos, Collect image &properties
    Gui, Add, Text, y+5, File details are collected as well.
    Gui, Add, Button, y+15 h%thisBtnHeight% gBtnCollectHistoInfos, Collect image &histograms properties
    Gui, Add, Text, y+5, Image fingerprints and properties are collected as well.

    Gui, Tab
    Gui, Add, Button, xs y+35 w90 h%thisBtnHeight% gBtnCloseWindow, C&lose
    Gui, Add, Button, x+5 h%thisBtnHeight% gPanelEnableFilesFilter, &Create custom filter
    If (SLDtypeLoaded=3)
       Gui, Add, Button, x+5 hp gPanelPurgeCachedSQLdata, Purge cached data

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Statistics: " appTitle)
}

SeenStatsLVaction(CtrlHwnd:=0) {
    GuiControlGet, varu, SettingsGUIA: FocusV
    isOkay := (A_GuiEvent="k" && A_EventInfo=32) || (A_GuiEvent="DoubleClick") ? 1 : 0
    ; ToolTip, % A_GuiEvent "=" A_EventInfo , , , 2
    If (!InStr(varu, "LViewMeta") || !isOkay)
       Return

    ; MouseGetPos, , , OutputVarWin, OutputVarControl, 3
    RowNumber := LV_EX_GetNextItem(CtrlHwnd, -1)
    folderu := LV_EX_GetSubItemText(CtrlHwnd, RowNumber + 1, 2)
    If (StrLen(folderu)<3 || folderu="date")
       Return

    BtnALLviewedImages2List(folderu "|filteru|")
}

IndexStatsLVaction(CtrlHwnd:=0) {
    GuiControlGet, varu, SettingsGUIA: FocusV
    isOkay := (A_GuiEvent="k" && A_EventInfo=32) || (A_GuiEvent="DoubleClick") ? 1 : 0
    ; ToolTip, % A_GuiEvent "=" A_EventInfo , , , 2
    If (!InStr(varu, "LViewMeta") || !isOkay)
       Return

    ; MouseGetPos, , , OutputVarWin, OutputVarControl, 3
    RowNumber := LV_EX_GetNextItem(CtrlHwnd, -1)
    dateu := LV_EX_GetSubItemText(CtrlHwnd, RowNumber + 1, 2)
    If (StrLen(dateu)<1 || dateu="date" || InStr(dateu, "file"))
       Return

    r := BtnIndexStatsToList(RowNumber + 1, dateu, varu, 0)
    If (SLDtypeLoaded!=3 && r)
    {
       coreEnableFiltru(r)
       SetTimer, RandomPicture, -100
    }
}

BtnIndexStatsToList(RowNumber, dateu, LVvaru, givenQuery) {
      Static minz := {1:0, 2:4999, 3:10002, 4:25002, 5:50002, 6:100002, 7:250002, 8:500002, 9:1000002, 10:2500002, 11:5000002, 12:10000002, 13:25000002, 14:50000002, 15:100000002, 16:250000002}
           , maxz := {1:4998, 2:10001, 3:25001, 4:50001, 5:100001, 6:250001, 7:500001, 8:1000001, 9:2500001, 10:5000001, 11:10000001, 12:25000001, 13:50000001, 14:100000001, 15:250000001, 16:500000001}

      ; ToolTip, % RowNumber "==" dateu "==" LVvaru , , , 2
      winOpen := AnyWindowOpen
      If (AnyWindowOpen && LVvaru!="none")
         BtnCloseWindow()

      If askAboutFileSave(" and the files list will be filtered to given criteria")
         Return -1

      setImageLoading()
      If (LVvaru="none" && SLDtypeLoaded=3)
      {
         showTOOLtip("Retrieving entire files list SQL index, please wait")
      } Else
      {
         showTOOLtip("Gathering entries matching " dateu ", please wait")
         setWindowTitle("Gathering entries matching " dateu ", please wait...", 1)
         If (InStr(LVvaru, "metaT") && winOpen!=48)
         {
            If (SLDtypeLoaded=3)
            {
               givenQuery := "WHERE imgfile LIKE '%." dateu "'"
               LVvaru := "custom"
            } Else
            {
               UsrEditFilter := "(\." dateu ")$"
               userFilterProperty := userFilterWhat := userFilterDoString := 1
               userFilterStringPos := 4
               coreEnableFiltru("\>" UsrEditFilter)
               Return
            }
         }
      }

      oDateu := dateu
      arDateu := StrSplit(oDateu, "-")
      RecordSet := ""
      If (winOpen!=48)
         dateu := StrReplace(dateu, "-")

      minRange := (winOpen=48) ? arDateu[1] : minz[RowNumber]
      maxRange := (winOpen=48) ? arDateu[2] : maxz[RowNumber]
      If !dataColumn
         dataColumn := InStr(LVvaru, "metaS") ? "fsize" : "fmodified"

      sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
      reorder := StrLen(prevFilesSortMode)>3 ? " ORDER BY " prevFilesSortMode sortMode ";" : " ORDER BY imgidu;"
      k := 14 - StrLen(dateu)
      If (LVvaru="custom")
      {
         theQuery := givenQuery
         theQueryNonDB := givenQuery
      } Else If (LVvaru="none")
      {
         theQuery := ""
         theQueryNonDB := ""
      } Else If (winOpen=48)
      {
         If InStr(LVvaru, "metaM")
         {
            userFilterProperty := 9
            userFilterDoString := 0
            FilteruMinRange := FilteruMaxRange := Round(dateu)
            theQuery := "WHERE imgframes='" dateu "'"
            theQueryNonDB := "QPV::query::imgframes::" dateu ":: " dateu
         } Else If InStr(LVvaru, "metaS")
         {
            userFilterDoString := 0
            theQuery := "WHERE imgpixfmt LIKE '" dateu "'"
            theQueryNonDB := "QPV::query::imgpixfmt::" dateu "::" dateu
         } Else If InStr(LVvaru, "metaD")
         {
            userFilterProperty := 5
            userFilterDoString := 0
            FilteruMinRange := Floor(dateu)
            FilteruMAxRange := Ceil(dateu)
            theQuery := "WHERE Round(imgmegapix, 1) BETWEEN " dateu " AND " dateu
            theQueryNonDB := "QPV::query::imgmegapix::" dateu "::" dateu
         } Else If InStr(LVvaru, "metaU")
         {
            userFilterProperty := 10
            userFilterDoString := 0
            FilteruMinRange := FilteruMAxRange := Round(dateu)
            theQuery := "WHERE imgdpi='" dateu "'"
            theQueryNonDB := "QPV::query::imgdpi::" dateu "::" dateu
         } Else If InStr(LVvaru, "metaY")
         {
            userFilterProperty := 8
            FilteruMinRange := Round(dateu*10)
            FilteruMAxRange := Round(dateu*10)
            theQuery := "WHERE Round(imgwhratio, 1) BETWEEN " dateu " AND " dateu
            theQueryNonDB := "QPV::query::imgwhratio::" dateu ":: " dateu
         } Else If (InStr(LVvaru, "metaA") || InStr(LVvaru, "metaR") || InStr(LVvaru, "metaI") || InStr(LVvaru, "metaT") || InStr(LVvaru, "metaG"))
         {
            If InStr(LVvaru, "metaA")
            {
               userFilterProperty := 13
               dataColumn := "imghpeak"
            } Else If InStr(LVvaru, "metaI")
            {
               userFilterProperty := 14
               dataColumn := "imghlow"
            } Else If InStr(LVvaru, "metaR")
            {
               userFilterProperty := 15
               dataColumn := "imghrange"
            } Else If InStr(LVvaru, "metaT")
            {
               userFilterProperty := 11
               dataColumn := "imgavg"
            } Else If InStr(LVvaru, "metaG")
            {
               userFilterProperty := 12
               dataColumn := "imgmedian"
            }

            userFilterDoString := 0
            FilteruMinRange := Round(minRange)
            FilteruMaxRange := Round(maxRange)
            minRange := Round((minRange + 1)/256, 3)
            maxRange := Round((maxRange + 1)/256, 3)
            theQuery := "WHERE Round(" dataColumn ", 2) BETWEEN " minRange " AND " maxRange
            theQueryNonDB := "QPV::query::" dataColumn "::" minRange "::" maxRange
         }
      } Else
      {
         If (InStr(LVvaru, "metaD") || InStr(LVvaru, "metaM") || InStr(LVvaru, "metaY") || InStr(LVvaru, "LIKE"))
         {
            userFilterProperty := 3
            userFilterDoString := 0
            FilteruDateMaxRange := FilteruDateMinRange := Format("{1}{2:" k "}", dateu, 0)
            theQuery := "WHERE " dataColumn " LIKE '" dateu "%'"
            theQueryNonDB := "QPV::query::" dataColumn "::" FilteruDateMinRange "::" FilteruDateMaxRange
            theQueryNonDB := StrReplace(theQueryNonDB, A_Space, 0)
         } Else If (InStr(LVvaru, "metaS") || InStr(LVvaru, "BETWEEN"))
         {
            userFilterProperty := 2
            userFilterSizeProperty := 1
            userFilterDoString := 0
            FilteruMinRange := Round(minRange/1024)
            FilteruMaxRange := Round(maxRange/1024)
            theQuery := "WHERE " dataColumn " BETWEEN " minRange " AND " maxRange
            theQueryNonDB := "QPV::query::" dataColumn "::" minRange "::" maxRange
         }
      }

      If (SLDtypeLoaded=3)
      {
         If !getMaxRowIDsqlDB()
            Return -1

         SQLstr := "SELECT imgidu, fullPath FROM images " theQuery reorder
         ; ToolTip, % SQLstr , , , 2
         If !activeSQLdb.GetTable(SQLstr, RecordSet)
         {
            throwSQLqueryDBerror(A_ThisFunc)
            Return -1
         }
      } Else Return theQueryNonDB

      If (RecordSet.RowCount<1)
      {
         showTOOLtip("WARNING: No records found in the database matching the query:`n" SQLstr)
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      markedSelectFile := 0
      startOperation := A_TickCount
      ; ToolTip, % filesFilter , , , 2
      If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:") && LVvaru!="none")
         remFilesListFilter("simple")

      If (StrLen(filesFilter)<2 && LVvaru!="none")
      {
         bckpResultedFilesList := []
         bckpResultedFilesList := resultedFilesList.Clone()
         bckpMaxFilesIndex := maxFilesIndex
      }

      If (LVvaru!="none")
         showTOOLtip("Generating files list index for " oDateu)

      renewCurrentFilesList()
      Loop, % RecordSet.RowCount
      {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[2]
         {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex, 1] := Rowu[2]
             resultedFilesList[maxFilesIndex, 12] := Rowu[1]
          }
      }

      RecordSet.Free()
      If (LVvaru!="none")
         filesFilter := "SQL:query:" theQuery
      ;  MsgBox, % maxFilesIndex " --- " RecordSet.RowCount
      ForceRefreshNowThumbsList()
      GenerateRandyList()
      CurrentSLD := backCurrentSLD
      If (LVvaru!="none")
      {
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -500
         SetTimer, ResetImgLoadStatus, -50
         RandomPicture()
      }
}

BtnCopySeenStats() {
   textu .= "`nMONTHLY SEEN IMAGES:`n"
   Gui, SettingsGUIA: ListView, LViewMetaM
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1 || aC=2) ? " | " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   textu .= "`nDAILY SEEN IMAGES:`n"
   Gui, SettingsGUIA: ListView, LViewMetaD
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1 || aC=2) ? " | " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   textu .= "`nHOURLY SEEN IMAGES:`n"
   Gui, SettingsGUIA: ListView, LViewMetaH
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1 || aC=2) ? " | " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Failed to copy to clipboard")
         SoundBeep , 300, 100
      } Else showTOOLtip("Images seen statistics copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateSeenStatsInfos() {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  entriesCount := 0
  RecordSet := ""
  SQL := "SELECT imgViewDate, COUNT(*) FROM images GROUP BY imgViewDate;"
  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entriesD := []
  entriesM := []
  entriesH := []
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[1]
      {
         dateuD := "z" StrReplace(SubStr(Rowu[1], 1, 10), "-")
         dateuM := "z" StrReplace(SubStr(Rowu[1], 1, 7), "-")
         dateuH := "z" StrReplace(SubStr(Rowu[1], 12, 2), "-")
         entriez%dateuD% += Rowu[2]
         entriez%dateuM% += Rowu[2]
         entriez%dateuH% += Rowu[2]
         entriesCount += Rowu[2]
         entriesD[dateuD] := [entriez%dateuD%, SubStr(Rowu[1], 1, 10)]
         entriesM[dateuM] := [entriez%dateuM%, SubStr(Rowu[1], 1, 7)]
         entriesH[dateuH] := [entriez%dateuH%, SubStr(Rowu[1], 12, 2)]
      }
  }

  RecordSet.Free()
  Gui, SettingsGUIA: ListView, LViewMetaD
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesD
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaH
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesH
      LV_Add(A_Index, A_Index, Value[2] ":00", Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  entriesCount := groupDigits(entriesCount)
  GuiControl, SettingsGUIA:, infoLine, Total seen images: %entriesCount%
}

QPV_FileGetSizeTime(imgPath, type, imgIndex, b:=0) {
    Switch type
    {
       Case "S":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 6] : resultedFilesList[imgIndex, 6]
       Case "M":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 7] : resultedFilesList[imgIndex, 7]
       Case "C":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 8] : resultedFilesList[imgIndex, 8]
       Case "R":
          r := 0
    }

    If !r
    {
       ; If !runningLongOperation
       ; SoundBeep 
       obju := GetFileAttributesEx(imgPath)
       If (b=1)
       {
          bckpResultedFilesList[imgIndex, 6] := obju.size
          bckpResultedFilesList[imgIndex, 7] := obju.wTime
          bckpResultedFilesList[imgIndex, 8] := obju.cTime
       } Else
       {
          resultedFilesList[imgIndex, 6] := obju.size
          resultedFilesList[imgIndex, 7] := obju.wTime
          resultedFilesList[imgIndex, 8] := obju.cTime
       }

       Switch type
       {
          Case "S":
             r := (b=1) ? bckpResultedFilesList[imgIndex, 6] : resultedFilesList[imgIndex, 6]
          Case "M":
             r := (b=1) ? bckpResultedFilesList[imgIndex, 7] : resultedFilesList[imgIndex, 7]
          Case "C":
             r := (b=1) ? bckpResultedFilesList[imgIndex, 8] : resultedFilesList[imgIndex, 8]
       }
    }
    Return r
}

GetFileAttributesEx(inFile) {
; https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesexw
; coded by TheArkive and modified by Marius Șucan
; https://www.autohotkey.com/boards/viewtopic.php?t=83269
; https://github.com/TheArkive
; THANK YOU VERY MUCH @ TheArkive

    If (StrLen(inFile)>32766 || StrLen(inFile)<4)
       return

    Static GetFileExInfoStandard := 0, GetFileExMaxInfoLevel := 1 ; https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ne-minwinbase-get_fileex_info_levels
    Static attr := { Archive:0x20 ; https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants
            , Compressed:0x800, Device:0x40, Directory:0x10, Encrypted:0x4000, Hidden:0x2, integ_stream:0x8000, Normal:0x80, NotContentIndexed:0x2000
            , NoScrubData:0x20000, Offline:0x1000, ReadOnly:0x1, RecallOnDataAccess:0x400000, RecallOnOpen:0x40000, ReparsePoint:0x400, SparseFile:0x200
            , System:0x4, Temporary:0x100, Virtual:0x10000}
    
    VarSetCapacity(bFileAttribs,((A_PtrSize=8)?40:36),0) ; AHK v1
    p2 := &bFileAttribs
    r := DllCall("GetFileAttributesExW", "Str", "\\?\" inFile,"Int", 0, "Ptr", p2)
/*
    iAttribs := NumGet(bFileAttribs,"UInt")
    AttrList := []
    For attrib, value in attr
    {
        If (value & iAttribs)
           AttrList[A_Index] := attrib
    }
*/

    cTime := FileTimeToSystemTime(p2+4)  ;   CreationTimePtr
    wTime := FileTimeToSystemTime(p2+20) ;   LastWriteTime
    ; aTime := FileTimeToSystemTime(p2+12)
    
    ; sizeHigh << 32 | sizeLow 
    fileSize := (NumGet(bFileAttribs,28,"UInt") << 32) | NumGet(bFileAttribs,32,"UInt")
    return {attr:AttrList, cTime:cTime, aTime:aTime, wTime:wTime, size:fileSize}
}

FileTimeToSystemTime(ptr) {         
    VarSetCapacity(SYSTEMTIME,16,0)
    r := DllCall("FileTimeToSystemTime","Ptr",ptr,"Ptr",&SYSTEMTIME)

    VarSetCapacity(SYSTIME2,16,0)
    r := DllCall("SystemTimeToTzSpecificLocalTime","Ptr",0,"Ptr",&SYSTEMTIME,"Ptr",&SYSTIME2) ; https://docs.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltime

    ; dayOfWeek := NumGet(SYSTIME2,4,"UShort")
    ; mil := NumGet(SYSTIME2,14,"UShort")
    
    year := NumGet(SYSTIME2,0,"UShort")
    month := Format("{:02d}", NumGet(SYSTIME2,2,"UShort"))
    day := Format("{:02d}", NumGet(SYSTIME2,6,"UShort"))
    hour := Format("{:02d}", NumGet(SYSTIME2,8,"UShort"))
    minute := Format("{:02d}", NumGet(SYSTIME2,10,"UShort"))
    second := Format("{:02d}", NumGet(SYSTIME2,12,"UShort"))

    return year month day hour minute second
    ; return {year:year, month:month, day:day, dayOfWeek:dayOfWeek, hour:hour, minute:minute, second:second, mil:mil}
}

ETAinfos(countTFilez, filesElected, startOperation) {
   Static prevTick := 0, prevStartu, prevTimes := [], prevCountTFilez := 0, prevAvg := 0, prevZeit := 0, prevTotal
   If (prevStartu!=startOperation || countTFilez<prevCountTFilez || prevTotal!=filesElected)
   {
      prevTimes := []
      prevZeit := prevCountTFilez := prevTick := prevAvg := 0
   }

   prevTick++
   thisAmount := countTFilez - prevCountTFilez
   prevTimes.Push([thisAmount, A_TickCount])
   If (prevTick=5)
      prevTimes.RemoveAt(1)

   prevCountTFilez := countTFilez
   theSum := 0
   loops := prevTimes.Count()
   Loop, % loops
       theSum += prevTimes[A_Index, 1]

   theAvg := Round(theSum/loops, 6)
   If prevAvg
      theAvg := Round((prevAvg+theAvg)/2, 6)

   prevAvg := theAvg
   intervalA := prevTimes[2, 2] - prevTimes[1, 2]
   intervalB := prevTimes[3, 2] - prevTimes[2, 2]
   intervalC := prevTimes[4, 2] - prevTimes[3, 2]
   interval := Round((1 + intervalA + intervalB + intervalC)/3, 6)
   zeitLeftA := Round(((filesElected - countTFilez)/theAvg)*interval)
   prevTotal := filesElected
   ; ToolTip, % loops " == " prevTick " == " theSum " == " theAvg , , , 2

   prevTick := clampInRange(prevTick, 1, 4)
   prevStartu := startOperation

   zeitOperation := A_TickCount - startOperation
   percDone := " ( " Round((countTFilez / filesElected) * 100, 1) "% )"
   percLeft := (1 - countTFilez / filesElected) * 100
   zeitLeftB := (zeitOperation/countTFilez) * filesElected - zeitOperation
   etaTime := "`n" groupDigits(countTFilez) " / " groupDigits(filesElected) percDone
   If (A_TickCount - startOperation<2500)
      zeitC := (zeitLeftA+zeitLeftB)/2
   If (A_TickCount - startOperation<5000)
      zeitC := (zeitLeftA+zeitLeftA+zeitLeftB)/3
   Else If (A_TickCount - startOperation<9500)
      zeitC := (zeitLeftA+zeitLeftA+zeitLeftA+zeitLeftB)/4
   Else
      zeitC := zeitLeftA

   zeitF := prevZeit ? (zeitC + prevZeit)/2 : zeitC
   prevZeit := zeitC
   etaTime .= "`nEstimated time left: " SecToHHMMSS(Round(zeitF/1000, 3))
   ; etaTime .= "`nEstimated B time left: " SecToHHMMSS(Round(zeitLeft2/1000, 3))
   etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
   Return etaTime
}

collectImageInfosNow(queryString:=0, modus:=0, simple:=0) {
    ; If StrLen(filesFilter)>1
    ;    remFilesListFilter("simple")

    doStartLongOpDance()
    If (simple=1)
    {
       backCurrentSLD := CurrentSLD
       CurrentSLD := ""
    }

    showTOOLtip("Collecting image details, please wait`n0 / " groupDigits(maxFilesIndex))
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
    isFilter := StrLen(filesFilter)>2 ? 1 : 0
    failedFiles := abandonAll := 0
    zEffect := (modus=11) ? Gdip_CreateEffect(6, 0, -99, 0) : 0
    Loop, % thisMaxCount
    {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
          If failedFiles
             etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

          showTOOLtip("Collecting image details, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
          prevMSGdisplay := A_TickCount
       }

       If (modus=9)
          testThis := !isFilter ? resultedFilesList[A_Index, 9] : bckpResultedFilesList[A_Index, 9]
       Else
          testThis := !isFilter ? resultedFilesList[A_Index, 11] : bckpResultedFilesList[A_Index, 11]

       If testThis
          Continue

       imgPath := !isFilter ? resultedFilesList[A_Index, 1] : bckpResultedFilesList[A_Index, 1]
       If queryString
       {
          If !coreSearchIndex(imgPath, queryString, userFilterWhat, userFilterStringIsNot)
             Continue
       }

       thisIndex := A_Index
       If (modus=9)
          r := GetCachableImgFileDetails(imgPath, A_Index, 0, 0, isFilter)
       Else
          r := GetCachableHistogramFile(imgPath, A_Index, 0, 0, 1, isFilter, zEffect)

       If !r
          failedFiles++
       ; ; ToolTip, % s "`n" m "`n" , , , 2
       ; Sleep, 200
    }
    ; k := resultedFilesList[3, 7]
    ; ToolTip, % k , , , 2

    Gdip_DisposeEffect(zEffect)
    PopulateIndexFilesStatsInfos("kill")
    SetTimer, ResetImgLoadStatus, -150
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    If (abandonAll!=1)
       SoundBeep, 900, 100

    If (simple=1)
    {
       CurrentSLD := backCurrentSLD
       percDone := " ( " Round((thisIndex / thisMaxCount) * 100, 1) "% )"
       If failedFiles
          percDone .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

       If (abandonAll=1)
       {
          showTOOLtip("Operation abandoned. " groupDigits(thisIndex) " / " groupDigits(thisMaxCount)) percDone
          SoundBeep, 300, 100
       } Else If (abandonAll=1)
          showTOOLtip("Finished collecting data for " groupDigits(thisMaxCount)) " files"

       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -150
       Return
    }
    Return abandonAll
}

collectFileInfosNow(queryString:=0) {
    ; If StrLen(filesFilter)>1
    ;    remFilesListFilter("simple")

    doStartLongOpDance()
    showTOOLtip("Collecting file details, please wait`n0 / " groupDigits(maxFilesIndex))
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
    isFilter := StrLen(filesFilter)>2 ? 1 : 0
    abandonAll := 0
    Loop, % thisMaxCount
    {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
          showTOOLtip("Collecting file details, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
          prevMSGdisplay := A_TickCount
       }

       testThis := !isFilter ? resultedFilesList[A_Index, 6] : bckpResultedFilesList[A_Index, 6]
       If testThis
          Continue

       If queryString
       {
          r := !isFilter ? resultedFilesList[A_Index, 1] : bckpResultedFilesList[A_Index, 1]
          If !coreSearchIndex(r, queryString, userFilterWhat, userFilterStringIsNot)
             Continue
       }

       If !isFilter
       {
          obju := GetFileAttributesEx(resultedFilesList[A_Index, 1])
          resultedFilesList[A_Index, 6] := obju.size ? obju.size : 1
          resultedFilesList[A_Index, 7] := obju.wTime
          resultedFilesList[A_Index, 8] := obju.cTime
       } Else
       {
          obju := GetFileAttributesEx(bckpResultedFilesList[A_Index, 1])
          bckpResultedFilesList[A_Index, 6] := obju.size ? obju.size : 1
          bckpResultedFilesList[A_Index, 7] := obju.wTime
          bckpResultedFilesList[A_Index, 8] := obju.cTime
       }
       ; ; ToolTip, % s "`n" m "`n" , , , 2
       ; Sleep, 200
    }
    ; k := resultedFilesList[3, 7]
    ; ToolTip, % k , , , 2
    PopulateIndexFilesStatsInfos("kill")
    SetTimer, ResetImgLoadStatus, -150
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    If (abandonAll!=1)
       SoundBeep, 900, 100

    Return abandonAll
}

PopulateIndexFilesStatsInfos(dummy:=0) {
  Static entriesD, entriesM, entriesY, entriesT, prevState, entriesCount, totalSizeu
      , sizer1, sizeTr1, sizer2, sizeTr2, sizer3, sizeTr3, sizer4, sizeTr4
      , sizer5, sizeTr5, sizer6, sizeTr6, sizer7, sizeTr7, sizer8, sizeTr8
      , sizer9, sizeTr9, sizer10, sizeTr10, sizer11, sizeTr11, sizer12, sizer16
      , sizeTr12, sizer13, sizeTr13, sizer14, sizeTr14, sizer15, sizeTr15, sizeTr16

  startZeit := A_TickCount
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  isFilter := StrLen(filesFilter)>2 ? 1 : 0

  If (dummy!="kill")
  {
     doStartLongOpDance()
     showTOOLtip("Generating statistics, please wait`n0/" groupDigits(thisMaxCount))
     setImageLoading()
     thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  } Else prevState := ""

  If (thisState!=prevState || dummy="kill")
  {
     entriesCount := 0, sizer1:=0, sizeTr1:=0, sizer2:=0, sizeTr2:=0, sizer3:=0, sizeTr3:=0, sizer4:=0, sizeTr4:=0
     sizer5:=0, sizeTr5:=0, sizer6:=0, sizeTr6:=0, sizer7:=0, sizeTr7:=0, sizer8:=0, sizeTr8:=0, sizer9:=0, sizeTr9:=0
     sizer10:=0, sizeTr10:=0, sizer11:=0, sizeTr11:=0, sizer12:=0, sizeTr12:=0, sizer13:=0, sizeTr13:=0, sizer14:=0
     sizeTr14:=0, sizer15:=0, sizeTr15:=0, sizer16:=0, sizeTr16:=0, totalSizeu := 0

     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     If (dummy="kill")
     {
        ; bckpResultedFilesList := []
        ; filteredMap2mainList := []
        ; filesFilter := ""
        ; bckpMaxFilesIndex := 0
        PopulateIndexSQLFilesStatsInfos(dummy)
        PopulateImagesIndexStatsInfos(dummy)
        Return
     }

     prevMSGdisplay := A_TickCount
     Loop, % thisMaxCount
     {
         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(A_Index, thisMaxCount, startZeit)
            showTOOLtip("Generating statistics, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }

         If (isFilter=1)
         {
            imgPath := bckpResultedFilesList[A_Index, 1]
            dateu := bckpResultedFilesList[A_Index, 7]
            sizeu := bckpResultedFilesList[A_Index, 6]
         } Else
         {
            imgPath := resultedFilesList[A_Index, 1]
            dateu := resultedFilesList[A_Index, 7]
            sizeu := resultedFilesList[A_Index, 6]
         }

         ; ToolTip, % imgPath "`n" dateu "`n" sizeu , , , 2
         foundPos := InStr(imgPath, ".", 0, -1)
         If foundPos
         {
            fileEXT := SubStr(imgPath, foundPos + 1)
            entriez%fileEXT%++
            entriesT[fileEXT] := [entriez%fileEXT%, fileEXT]
         }

         If dateu
         {
            dateuD := "z" SubStr(dateu, 1, 8)
            dateuM := "z" SubStr(dateu, 1, 6)
            dateuY := "z" SubStr(dateu, 1, 4)
            entriez%dateuD%++
            entriez%dateuM%++
            entriez%dateuY%++
            entriesD[dateuD] := [entriez%dateuD%, dateuD]
            entriesM[dateuM] := [entriez%dateuM%, dateuM]
            entriesY[dateuY] := [entriez%dateuY%, dateuY]
         }

         If sizeu
         {
            entriesCount++
            totalSizeu += Round(sizeu/(1024**2), 4)
            If (sizeu<=5000001)
            {
               If isInRange(sizeu, 0, 4998)
               {
                  sizeTr1 += sizeu
                  sizer1++
               } Else If isInRange(sizeu, 4999, 10001)
               {
                  sizeTr2 += sizeu
                  sizer2++
               } Else If isInRange(sizeu, 10002, 25001)
               {
                  sizeTr3 += sizeu
                  sizer3++
               } Else If isInRange(sizeu, 25002, 50001)
               {
                  sizeTr4 += sizeu
                  sizer4++
               } Else If isInRange(sizeu, 50002, 100001)
               {
                  sizeTr5 += sizeu
                  sizer5++
               } Else If isInRange(sizeu, 100002, 250001)
               {
                  sizeTr6 += sizeu
                  sizer6++
               } Else If isInRange(sizeu, 250002, 500001)
               {
                  sizeTr7 += sizeu
                  sizer7++
               } Else If isInRange(sizeu, 500002, 1000001)
               {
                  sizeTr8 += sizeu
                  sizer8++
               } Else If isInRange(sizeu, 1000002, 2500001)
               {
                  sizeTr9 += sizeu
                  sizer9++
               } Else If isInRange(sizeu, 2500002, 5000001)
               {
                  sizeTr10 += sizeu
                  sizer10++
               }
            } Else
            {
               If isInRange(sizeu, 5000002, 10000001)
               {
                  sizeTr11 += sizeu
                  sizer11++
               } Else If isInRange(sizeu, 10000002, 25000001)
               {
                  sizeTr12 += sizeu
                  sizer12++
               } Else If isInRange(sizeu, 25000002, 50000001)
               {
                  sizeTr13 += sizeu
                  sizer13++
               } Else If isInRange(sizeu, 50000002, 100000001)
               {
                  sizeTr14 += sizeu
                  sizer14++
               } Else If isInRange(sizeu, 100000002, 250000001)
               {
                  sizeTr15 += sizeu
                  sizer15++
               } Else If isInRange(sizeu, 250000002, 500000001)
               {
                  sizeTr16 += sizeu
                  sizer16++
               }
            }
         }

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }
     If (abandonAll!=1)
        prevState := thisState
  }

  entriesCount := StrReplace(entriesCount, A_Space)
  ; msgBox, % entriesCount "=" thisMaxCount
  If (entriesCount<Round(thisMaxCount - 1)) && (abandonAll!=1)
  {
     msgResult := msgBoxWrapper(appTitle ": Statistics", appTitle " has not yet indexed the files' details. These are required to populate this panel with statistics. Would you like to collect the data now? This may take awhile...", 4, 0, "question")
     If (msgResult="Yes")
     {
        prevState := ""
        RemoveTooltip()
        BtnCloseWindow()
        r := collectFileInfosNow()
        If !r
           SetTimer, PanelIndexedFilesStats, -250
        Return
     }
  }

  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     executingCanceableOperation := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaD
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
  {
      stringu := ST_Insert("-", SubStr(Value[2], 2), 5)
      stringu := ST_Insert("-", stringu, 8)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
  {
      stringu := ST_Insert("-", SubStr(Value[2], 2), 5)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, SubStr(Value[2], 2), Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  showTOOLtip("Generating statistics, please wait", 0, 0, 3/10)
  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  LV_Add(1, 1, "<5 KB", Round(sizeTr1/(1024**2), 1), sizer1, Round((sizer1/thisMaxCount)*100, 1))
  LV_Add(2, 2, "5-10 KB", Round(sizeTr2/(1024**2), 1), sizer2, Round((sizer2/thisMaxCount)*100, 1))
  LV_Add(3, 3, "10-25 KB", Round(sizeTr3/(1024**2), 1), sizer3, Round((sizer3/thisMaxCount)*100, 1))
  LV_Add(4, 4, "25-50 KB", Round(sizeTr4/(1024**2), 1), sizer4, Round((sizer4/thisMaxCount)*100, 1))
  LV_Add(5, 5, "50-100 KB", Round(sizeTr5/(1024**2), 1), sizer5, Round((sizer5/thisMaxCount)*100, 1))
  LV_Add(6, 6, "100-250 KB", Round(sizeTr6/(1024**2), 1), sizer6, Round((sizer6/thisMaxCount)*100, 1))
  LV_Add(7, 7, "250-500 KB", Round(sizeTr7/(1024**2), 1), sizer7, Round((sizer7/thisMaxCount)*100, 1))
  LV_Add(8, 8, "0.5-1.0 MB", Round(sizeTr8/(1024**2), 1), sizer8, Round((sizer8/thisMaxCount)*100, 1))
  LV_Add(9, 9, "1.0-2.5 MB", Round(sizeTr9/(1024**2), 1), sizer9, Round((sizer9/thisMaxCount)*100, 1))
  LV_Add(10, 10, "2.5-5.0 MB", Round(sizeTr10/(1024**2), 1), sizer10, Round((sizer10/thisMaxCount)*100, 1))
  LV_Add(11, 11, "5-10 MB", Round(sizeTr11/(1024**2), 1), sizer11, Round((sizer11/thisMaxCount)*100, 1))
  LV_Add(12, 12, "10-25 MB", Round(sizeTr12/(1024**2), 1), sizer12, Round((sizer12/thisMaxCount)*100, 1))
  LV_Add(13, 13, "25-50 MB", Round(sizeTr13/(1024**2), 1), sizer13, Round((sizer13/thisMaxCount)*100, 1))
  LV_Add(14, 14, "50-100 MB", Round(sizeTr14/(1024**2), 1), sizer14, Round((sizer14/thisMaxCount)*100, 1))
  LV_Add(15, 15, "100-250 MB", Round(sizeTr15/(1024**2), 1), sizer15, Round((sizer15/thisMaxCount)*100, 1))
  LV_Add(16, 16, "250-500 MB", Round(sizeTr16/(1024**2), 1), sizer16, Round((sizer16/thisMaxCount)*100, 1))

  Loop, 5
     LV_ModifyCol(A_Index, "AutoHdr Center")

  entriesCount := groupDigits(entriesCount)
  totalFsize := Round(totalSizeu/1024, 1)
  GuiControl, SettingsGUIA:, infoLine, Total images: %entriesCount% [%totalFsize% GB]
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

PopulateImagesIndexStatsInfos(dummy:=0) {
  Static entriesR, entriesD, entriesS, entriesU, entriesM, entriesY, entriesT, entriesA, entriesI, entriesG, prevState, entriesCount, prevMaxu

  startZeit := A_TickCount
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  isFilter := StrLen(filesFilter)>2 ? 1 : 0
  If (dummy!="kill")
  {
     doStartLongOpDance()
     showTOOLtip("Generating statistics, please wait`n0/" groupDigits(thisMaxCount))
     setImageLoading()
     thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  } Else prevState := ""

  If (thisState!=prevState || dummy="kill")
  {
     entriesCount := totalSizeu := entriezHM1 := entriezHM2 := entriezHM3 := entriezHM4 := entriezHM5 := prevMaxu := 0
     entriezHL1 := entriezHP1 := entriezHA1 := entriezHL2 := entriezHP2 := entriezHA2 := entriezHL3 := entriezHP3 := entriezHA3 := entriezHL4 := entriezHP4 := entriezHA4 := entriezHL5 := entriezHP5 := entriezHA5 := 0

     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     entriesA := []
     entriesG := []
     entriesU := []
     entriesI := []
     entriesR := []
     If (dummy="kill")
        Return

     If (SLDtypeLoaded=3)
     {
        SQL := "SELECT imgframes, imgpixfmt, Round(imgmegapix, 1), Round(imgwhratio, 1), imgavg, imgmedian, imghpeak, imghlow, imghrange, imgdpi FROM images WHERE imgwidth IS NOT NULL;"
        yay := RecordSet := ""
        If !activeSQLdb.GetTable(SQL, RecordSet)
        {
           fnOutputDebug(A_ThisFunc "() - failed query in database: " fullPath)
           Return 0
        }
        ; ToolTip, % "l= " RecordSet.RowCount , , , 2
        thisMaxCount := RecordSet.RowCount
        prevMaxu := thisMaxCount
        If !thisMaxCount
           Return 0
     }

     prevMSGdisplay := A_TickCount
     Loop, % thisMaxCount
     {
         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(A_Index, thisMaxCount, startZeit)
            showTOOLtip("Generating statistics, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }

         entriesCount++
         If (SLDtypeLoaded=3)
         {
            Rowu := RecordSet.Rows[A_Index]
            mgpx := Rowu[3]
            frames := Rowu[1]
            ratio := Rowu[4]
            pixfmt := Rowu[2]
            havg := Rowu[5]
            hmed := Rowu[6]
            hpeak := Rowu[7]
            hlow := Rowu[8]
            hrange := Rowu[9]
            dpiu := Rowu[10]
         } Else If (isFilter=1)
         {
            mgpx := bckpResultedFilesList[A_Index, 17]
            frames := bckpResultedFilesList[A_Index, 9]
            ratio := bckpResultedFilesList[A_Index, 16]
            pixfmt := bckpResultedFilesList[A_Index, 15]
            havg := bckpResultedFilesList[A_Index, 18]
            hmed := bckpResultedFilesList[A_Index, 19]
            hpeak := bckpResultedFilesList[A_Index, 20]
            hlow := bckpResultedFilesList[A_Index, 21]
            dpiu := bckpResultedFilesList[A_Index, 22]
            hrange := bckpResultedFilesList[A_Index, 25]
         } Else
         {
            mgpx := resultedFilesList[A_Index, 17]
            frames := resultedFilesList[A_Index, 9]
            ratio := resultedFilesList[A_Index, 16]
            pixfmt := resultedFilesList[A_Index, 15]
            havg := resultedFilesList[A_Index, 18]
            hmed := resultedFilesList[A_Index, 19]
            hpeak := resultedFilesList[A_Index, 20]
            hlow := resultedFilesList[A_Index, 21]
            dpiu := resultedFilesList[A_Index, 22]
            hrange := resultedFilesList[A_Index, 25]
         }

         mgpx := Round(mgpx, 1)
         ratio := Round(ratio, 1)
         havg := Round(256*havg)
         hmed := Round(256*hmed)
         hpeak := Round(256*hpeak)
         hlow := Round(256*hlow)
         hrange := Round(256*hrange)
         If isInRange(havg, 0, 50)
         {
            entriezHA1++
            entriesT[1] := [entriezHA1, "0-50"]
         } Else If isInRange(havg, 50, 100)
         {
            entriezHA2++
            entriesT[2] := [entriezHA2, "50-100"]
         } Else If isInRange(havg, 100, 150)
         {
            entriezHA3++
            entriesT[3] := [entriezHA3, "100-150"]
         } Else If isInRange(havg, 150, 200)
         {
            entriezHA4++
            entriesT[4] := [entriezHA4, "150-200"]
         } Else If isInRange(havg, 200, 256)
         {
            entriezHA5++
            entriesT[5] := [entriezHA5, "200-255"]
         }

         If isInRange(hmed, 0, 50)
         {
            entriezHM1++
            entriesG[1] := [entriezHM1, "0-50"]
         } Else If isInRange(hmed, 50, 100)
         {
            entriezHM2++
            entriesG[2] := [entriezHM2, "50-100"]
         } Else If isInRange(hmed, 100, 150)
         {
            entriezHM3++
            entriesG[3] := [entriezHM3, "100-150"]
         } Else If isInRange(hmed, 150, 200)
         {
            entriezHM4++
            entriesG[4] := [entriezHM4, "150-200"]
         } Else If isInRange(hmed, 200, 256)
         {
            entriezHM5++
            entriesG[5] := [entriezHM5, "200-255"]
         }

         If isInRange(hpeak, 0, 50)
         {
            entriezHP1++
            entriesA[1] := [entriezHP1, "0-50"]
         } Else If isInRange(hpeak, 50, 100)
         {
            entriezHP2++
            entriesA[2] := [entriezHP2, "50-100"]
         } Else If isInRange(hpeak, 100, 150)
         {
            entriezHP3++
            entriesA[3] := [entriezHP3, "100-150"]
         } Else If isInRange(hpeak, 150, 200)
         {
            entriezHP4++
            entriesA[4] := [entriezHP4, "150-200"]
         } Else If isInRange(hpeak, 200, 256)
         {
            entriezHP5++
            entriesA[5] := [entriezHP5, "200-255"]
         }

         If isInRange(hlow, 0, 50)
         {
            entriezHL1++
            entriesI[1] := [entriezHL1, "0-50"]
         } Else If isInRange(hlow, 50, 100)
         {
            entriezHL2++
            entriesI[2] := [entriezHL2, "50-100"]
         } Else If isInRange(hlow, 100, 150)
         {
            entriezHL3++
            entriesI[3] := [entriezHL3, "100-150"]
         } Else If isInRange(hlow, 150, 200)
         {
            entriezHL4++
            entriesI[4] := [entriezHL4, "150-200"]
         } Else If isInRange(hlow, 200, 256)
         {
            entriezHL5++
            entriesI[5] := [entriezHL5, "200-255"]
         }

         If isInRange(hRange, 0, 50)
         {
            entriezHR1++
            entriesR[1] := [entriezHR1, "0-50"]
         } Else If isInRange(hRange, 50, 100)
         {
            entriezHR2++
            entriesR[2] := [entriezHR2, "50-100"]
         } Else If isInRange(hRange, 100, 150)
         {
            entriezHR3++
            entriesR[3] := [entriezHR3, "100-150"]
         } Else If isInRange(hRange, 150, 200)
         {
            entriezHR4++
            entriesR[4] := [entriezHR4, "150-200"]
         } Else If isInRange(hRange, 200, 256)
         {
            entriezHR5++
            entriesR[5] := [entriezHR5, "200-255"]
         }

         pixu := "z" StringToASC(pixfmt)
         ratiou := StrReplace(ratio, ".", "q")
         mgpxu := StrReplace(mgpx, ".", "q")
         entriez%ratiou%++
         entriez%pixu%++
         entriezMP%mgpxu%++
         entriezFram%frames%++
         entriezU%dpiu%++
         entriesD[mgpxu] := [entriezMP%mgpxu%, mgpx]
         entriesS[pixu] := [entriez%pixu%, pixFmt]
         entriesY[ratiou] := [entriez%ratiou%, ratio]
         entriesM["z" frames] := [entriezFram%frames%, frames]
         entriesU["z" dpiu] := [entriezU%dpiu%, dpiu]

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }
     If (SLDtypeLoaded=3)
        RecordSet.Free()

     If (abandonAll!=1)
        prevState := thisState
  }

  If (SLDtypeLoaded=3 && prevMaxu)
     thisMaxCount := prevMaxu

  entriesCount := StrReplace(entriesCount, A_Space)
  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     executingCanceableOperation := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaD
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  Loop, 4
     LV_ModifyCol(A_Index, "Integer")

  For Key, Value in entriesM
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaU
  Loop, 4
     LV_ModifyCol(A_Index, "Integer")

  For Key, Value in entriesU
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaA
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesA
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaG
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesG
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  Gui, SettingsGUIA: ListView, LViewMetaR
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesR
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")
  Gui, SettingsGUIA: ListView, LViewMetaI
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesI
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")
  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesS
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 5
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")

  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  percDone := " ( " Round((entriesCount / thisMaxCount) * 100, 1) "% )"
  entriesCount := groupDigits(entriesCount)
  thisMaxCount := groupDigits(thisMaxCount)
  GuiControl, SettingsGUIA:, infoLine, Total indexed images: %entriesCount% / %thisMaxCount%%percDone%
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

PopulateIndexSQLFilesStatsInfos(dummy:=0) {
  Static entriesD, entriesM, entriesY, entriesT, prevState, entriesCount

  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  startZeit := A_TickCount

  If (thisState!=prevState || dummy="kill")
  {
     cachedMode := entriesCount := 0
     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     zr := PanelFileIndexStatsRetrieveSizeRangeDB(1, q, 1, ":-)", 0, 1)
     If (dummy="kill")
        Return

     If (sqlFailedInit=1)
        Return 0

     RecordSet := ""
     SQL := "SELECT substr(fmodified, 1, 8), COUNT(*) FROM images GROUP BY substr(fmodified, 1, 8);"
     If !activeSQLdb.GetTable(SQL, RecordSet)
     {
        throwSQLqueryDBerror(A_ThisFunc)
        Return 0
     }

     doStartLongOpDance()
     showTOOLtip("Generating statistics, please wait", 0, 0, 0.4/10)
     setImageLoading()

     Loop, % RecordSet.RowCount
     {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[1]
         {
            dateuD := "z" Rowu[1] ; SubStr(Row[1], 1, 8)
            dateuM := "z" SubStr(Rowu[1], 1, 6)
            dateuY := "z" SubStr(Rowu[1], 1, 4)
            entriez%dateuD% += Rowu[2]
            entriez%dateuM% += Rowu[2]
            entriez%dateuY% += Rowu[2]
            entriesCount += Rowu[2]
            entriesD[dateuD] := [entriez%dateuD%, Rowu[1]] ; SubStr(Row[1], 1, 8)]
            entriesM[dateuM] := [entriez%dateuM%, SubStr(Rowu[1], 1, 6)]
            entriesY[dateuY] := [entriez%dateuY%, SubStr(Rowu[1], 1, 4)]
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }
         }
     }
     If (abandonAll!=1)
        prevState := thisState

     RecordSet.Free()
  } Else cachedMode := 1

  entriesCount := StrReplace(entriesCount, A_Space)
  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  showTOOLtip("Generating statistics, please wait", 0, 0, 1.5/10)
  Gui, SettingsGUIA: ListView, LViewMetaD
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
  {
      stringu := ST_Insert("-", Value[2], 5)
      stringu := ST_Insert("-", stringu, 8)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(2, "SortDesc")
  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
  {
      stringu := ST_Insert("-", Value[2], 5)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(2, "SortDesc")
  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  isFilter := StrLen(filesFilter)>2 ? 1 : 0
  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  showTOOLtip("Generating statistics, please wait", 0, 0, 3/10)
  Loop, % thisMaxCount
  {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (isFilter=1)
         imgPath := bckpResultedFilesList[A_Index, 1]
      Else
         imgPath := resultedFilesList[A_Index, 1]

      foundPos := InStr(imgPath, ".", 0, -1)
      If foundPos
      {
         fileEXT := SubStr(imgPath, foundPos + 1)
         entriez%fileEXT%++
         entriesT[fileEXT] := [entriez%fileEXT%, fileEXT]
      }
  }

  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  If (abandonAll=1 || determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastOtherWinClose := A_TickCount
     interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  zr := (cachedMode=1) ? "c" : 0
  j := 0
  showTOOLtip("Generating statistics, please wait", 0, 0, 4/10)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 1, "<5 KB", 0, 4998)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 2, "5-10 KB", 4999, 10001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 3, "10-25 KB", 10002, 25001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 4, "25-50 KB", 25002, 50001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 6/10)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 5, "50-100 KB", 50002, 100001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 6, "100-250 KB", 100002, 250001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 7, "250-500 KB", 250002, 500001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 8, "0.5-1.0 MB", 500002, 1000001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 8/10)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 9, "1.0-2.5 MB", 1000002, 2500001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 10, "2.5-5.0 MB", 2500002, 5000001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 11, "5-10 MB", 5000002, 10000001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 12, "10-25 MB", 10000002, 25000001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 9/10)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 13, "25-50 MB", 25000002, 50000001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 14, "50-100 MB", 50000002, 100000001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 15, "100-250 MB", 100000002, 250000001)
  zr := PanelFileIndexStatsRetrieveSizeRangeDB(zr, j, 16, "250-500 MB", 250000002, 500000001)
  Loop, 5
     LV_ModifyCol(A_Index, "AutoHdr Center")

  entriesCount := groupDigits(entriesCount)
  totalFsize := Round(j/1024, 1)
  GuiControl, SettingsGUIA:, infoLine, Total images: %entriesCount% [%totalFsize% GB]
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

PanelFileIndexStatsRetrieveSizeRangeDB(zr, ByRef totalSizeu, indexu, labelu, minu, maxu) {
  Static cacheInfos := []

  thisCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  If (zr=1)
  {
     cacheInfos := []
     Return
  } Else If (zr="c")
  {
     LV_Add(indexu, indexu, labelu, cacheInfos[indexu, 1], cacheInfos[indexu, 2], Round((cacheInfos[indexu, 2]/thisCount)*100, 1))
     totalSizeu += cacheInfos[indexu, 1]
     Return "c"
  }

  SQL := "SELECT sum(fsize), COUNT(*) FROM images WHERE fsize BETWEEN " minu " AND " maxu ";"
  If activeSQLdb.GetTable(SQL, RecordSet)
  {
     abandonAll := thisSizeFiles := thisTotalSizeRange := 0
     Loop, % RecordSet.RowCount
     {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[1]
         {
            thisSizeFiles := Rowu[2]
            thisTotalSizeRange := Rowu[1]
            ; thisSizeFiles++
            ; thisTotalSizeRange += Row[1]
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }
         }
     }
     RecordSet.Free()
     totalSizeu += Round(thisTotalSizeRange/(1024**2), 4)
     cacheInfos[indexu] := [Round(thisTotalSizeRange/(1024**2), 1), thisSizeFiles]
     LV_Add(indexu, indexu, labelu, Round(thisTotalSizeRange/(1024**2), 1), thisSizeFiles, Round((thisSizeFiles/thisCount)*100, 1))
  }

  Return abandonAll
}

PanelImageInfos() {
    Global LViewMetaD, LViewMetaOthers
    If (thumbsDisplaying=1)
       MenuDummyToggleThumbsMode()

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, fileNamu, folderu)
    If !FileRexists(imgPath)
    {
       showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(5, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 230
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Tab3,, General|Others
    Gui, Tab, 1 ; general
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD, Property|Data
    Gui, Tab, 2 ; general
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaOthers, Property|Data
    Gui, Tab
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w40 gInfoBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gInfoBtnNextImg, >>
    Gui, Add, Button, x+15 hp w%btnWid% gcopyIMGinfos2clip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid% gOpenThisFileFolder, &Explore folder
    Gui, Add, Button, x+5 hp w%btnWid% gOpenFileProperties, &File properties
    Gui, Add, Button, x+5 hp w90 Default gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file details: " appTitle)
    PopulateImgInfos()
}

MenuPanelFoldersTree() {
   if (folderTreeWinOpen=1)
      GoSub, fdTreeGuiaGuiClose
   Else
      PanelFoldersTree()
}

PanelFoldersTree() {
    Static hasRan, prevSize := 0
    Global fdTreeInfoLine
    If MsgBox2hwnd
       Return

    If (hasRan=1 && prevSize!=PrefsLargeFonts)
    {
       hasRan := 0
       Gui, fdTreeGuia: Destroy
    }

    If (hasRan=1)
    {
       Gui, fdTreeGuia: Show
       folderTreeWinOpen := 1
       interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
       Return
    }

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: +Resize -DPIScale -MaximizeBox -MinimizeBox +Owner%PVhwnd% +hwndhfdTreeWinGui +ToolWindow
    Gui, fdTreeGuia: Margin, 1, 1
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    prevSize := PrefsLargeFonts
    thisBtnHeight := (PrefsLargeFonts=1) ? 45 : 35
    btnWid := 105
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 230
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, TreeView, r10 vTVlistFolders AltSubmit +hwndhTVlistFolders gFolderTreeResponder
    Gui, Add, Button, xp y+1 w%thisBtnHeight% h%thisBtnHeight% gfolderTreeMiniBtn vbtnFldr, \\
    Gui, Add, Text, x+2 vfdTreeInfoLine +0x200 h%thisBtnHeight% gfolderTreeCopyPath -wrap, Folder tree status bar...
    Gui, Add, Button, x+1 y+1 w1 h1 -wantTab -TabStop Default gfolderTreeDefaultAction, &Default

    winPos := (prevSetWinPosY && prevSetWinPosX) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("fdTreeGuia", hfdTreeWinGui, 0, "Folders tree view: " appTitle, winPos)
    folderTreeWinOpen := 1
    interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
    hasRan := 1
    SetTimer, FolderTreeRepopulate, -100
}

folderTreeMiniBtn() {
   r := invokeFoldersListerMenu()
   If (r="err")
      folderTreeExpandCollapseAll()
}

folderTreeCopyPath(dummy:=0) {
   Static lastInvoked := 0
   If (A_TickCount - lastInvoked<356) || (dummy="forced")
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      folderPath := folderTreeGetSelectedPath(c)
      If !folderPath
         Return

      Try Clipboard := folderPath
      Catch wasError
          Sleep, 1

      If !wasError
         showTOOLtip("Folder tree path copied to the clipboard:`n" folderPath)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else lastInvoked := A_TickCount
}

folderTreeSetFolderProtected() {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      folderPath := folderTreeGetSelectedPath(c)
      If !folderPath
         Return
      setContaintFolderAsProtected(folderPath)
}

folderTreeDefaultAction() {
   If askAboutFileSave(" and another folder will be operned")
      Return

   If askAboutSlidesListSave()
      Return

   z := 0
   If GetKeyState("Shift", "P")
      z := 2
   Else If GetKeyState("Ctrl", "P")
      z := 1

   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   folderPath := folderTreeGetSelectedPath(c)
   If (z=1 && folderPath)
   {
      Try Run, "%folderPath%"
      Catch wasError
      {
         If !AnyWindowOpen
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu, 0, 0, "error")
      }
   } Else If (z=2 && folderPath)
      OpenNewQPVinstance(folderPath)
   Else If folderPath
      tryOpenGivenFolder(folderPath, CurrentSLD)

   Sleep, 1
   WinActivate, ahk_id %hfdTreeWinGui%
}

fdTreeGuiaGuiSize() {     
   ; (GuiHwnd, EventInfo, Width, Height) {
   GetWinClientSize(Width, Height, hfdTreeWinGui, 0)
   If (!width || !height || folderTreeWinOpen!=1)
      Return

   thisBtnHeight := (PrefsLargeFonts=1) ? 45 : 35
   height -= thisBtnHeight
   GuiControl, fdTreeGuia: Move, TVlistFolders, w%width% h%height%
   width -= thisBtnHeight
   yPos := height + 1
   GuiControl, fdTreeGuia: Move, fdTreeInfoLine, y%yPos% w%width% 
   GuiControl, fdTreeGuia: Move, btnFldr, y%yPos% 
   ; SoundBeep , 900, 100
   SetTimer, fdTreeGuiaGuiSize, -100
}

fdTreeClose() {
   Gosub, fdTreeGuiaGuiClose
}

fdTreeGuiaGuiClose:
fdTreeGuiaGuiEscape:
   lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   Gui, fdTreeGuia: Hide
   folderTreeWinOpen := 0
   interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
Return

FolderTreeResponder(a, b, c) {
   Static lastInvoked, prevCu
   ; ToolTip, % A_DefaultTreeView "==" c , , , 2
   If (b="Normal" && StrLen(c)>3)
   {
      TV_Modify(c)
      zeit := A_TickCount - lastInvoked
      ; ToolTip, % zeit "==" prevCu "==" c , , , 2
      If (zeit<1234 && prevCu=c)
      {
         If TV_Get(c, "Expand")
            TV_Modify(c, "-Expand")
         Else
            TV_Modify(c, "+Expand")
      }
      lastInvoked := A_TickCount
      prevCu := c
   } Else If (b="K" && c=115) ; F4
   {
      WinActivate, ahk_id %PVhwnd%
   } Else If (b="K" && c=116) ; F5
   {
      FolderTreeRepopulate()
   } Else If (b="K" && c=112) ; F1
   {
      AboutWindow()
   } Else If (b="K" && c=113) ; F2
   {
      folderTreeRenameFolder()
   } Else If (b="K" && c=114) ; F3
   {
      folderTreeAppendFiles()
   } Else If (b="K" && c=118) ; F7
   {
      folderTreeCreateFolder()
   } Else If (b="K" && (c=119 || c=46)) ; F8
   {
      folderTreeDeleteFolder()
   } Else If (b="K" && c=120) ; F9
   {
      FolderTreeFindActiveFile()
      folderTreeInfoLineUpdater()
   } Else If (b="DoubleClick")
   {
      TV_Modify(c)
      folderTreeDefaultAction()
   } Else If (b="RightClick") || (b="K" && c=93) ; Apps/Menu key
   {
      If (b!="K")
         TV_Modify(c)

      folderTreeContextMenu()
   } Else If (b="d") || (b="K" && c=32) ; Space
   {
      If (b="K")
         c := TV_GetSelection()
      TV_Modify(c)
      folderTreeScanSubbies()
   }
   SetTimer, folderTreeInfoLineUpdater, -125
   ; ToolTip, % a "==" b "==" c "`n" folderPath , , , 2
}

folderTreeInfoLineUpdater() {
    If (folderTreeWinOpen!=1)
       Return

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    c := TV_GetSelection()

    If c
       thisFolder := folderTreeGetSelectedPath(c)

    thisfolder := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1))
    If (!thisFolder && c)
       TV_GetText(OutputVar, c)
    Else If !thisFolder
       thisFolder := driveInfo "Folder tree: " TV_GetCount() " elements"

    If InStr(OutputVar, ":\")
    {
       Try DriveGet, info, Label, %OutputVar%
       Try DriveGet, size, Capacity, %OutputVar%
       Try DriveSpaceFree, FreeSpace, %OutputVar%
       perc := Round((FreeSpace/size)*100, 1) "%"
       driveInfo .= info " - " perc " free | "
       thisFolder := driveInfo "Folder tree: " TV_GetCount() " elements"
    }

    GuiControl, fdTreeGuia:, fdTreeInfoLine, % thisFolder
    SetTimer, fdTreeGuiaGuiSize, -50
}

folderTreeGetSelectedPath(c) {
   If StrLen(c)<2
      Return

   TV_GetText(folderPath, c)
   r := c
   Loop
   {
      r := TV_GetParent(r)
      If !r
         Break
      TV_GetText(thisu, r)
      folderPath := thisu folderPath
   }

   folderPath := StrReplace(folderPath, "\\", "\")
   If StrLen(folderPath)<5
      folderPath := ""

   Return folderPath
}

FolderTreeFindActiveFile(givenPath:=0) {
    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    showTOOLtip("Scanning folders, please wait")
    z := 0 ; TV_GetNext()
    oimgPath := resultedFilesList[currentFileIndex, 1]
    imgPath := SubStr(oimgPath, 1, InStr(oimgPath, "\", 0, -1) - 1)
    If FolderExist(givenPath)
    {
       imgPath := givenPath
       wasGiven := 1
    }

    sliced := StrSplit(imgPath, "\")
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...

    g := iterateFDtreeView(1, 0, sliced)
    lvl := g[1]
    z := g[2] ? g[2] : 0
    hasAdded := 0
    ; ToolTip, % lvl "=" gu , , , 2
    Loop, % sliced.Count()
    {
          thisIndex := A_Index - 1 + lvl
          If !sliced[thisIndex]
             Continue

          hasAdded := 1
          If (thisIndex=1)
             z := TV_Add(sliced[thisIndex] "\", z, "Expand Select VisFirst")
          Else
             z := TV_Add("\" sliced[thisIndex], z, "Expand Select VisFirst")
    }

    If (hasAdded!=1 && z)
       TV_Modify(z, "Expand Select VisFirst")

    initialSibling := SubStr(imgPath, InStr(imgPath, "\", 0, -1) + 1)
    If z
       w := TV_GetParent(z)
    ; ToolTip, % initialSibling , , , 2
    mustSkip := new hashtable()
    mustDelete := new hashtable()
    If (w && !wasGiven)
    {
       r := w
       r := TV_GetChild(w)
       Loop
       {
          If (A_Index>1)
             r := TV_GetNext(r)
          If r
             x := TV_GetChild(r)
          Else
             x := ""

          If !r
             Break

          If x
          {
             labelu := ""
             TV_GetText(labelu, r)
             If (Trimmer(labelu, "\")!=initialSibling)
             {
                h := Trimmer(labelu, "\")
                mustSkip[h] := 1
                Continue
             }
          }
 
          mustDelete[r] := 1
       }
    }

    If !wasGiven
    {
       For Key, Value in mustDelete
          TV_Delete(Key)
    }

    mustDelete := ""
    subPath := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
    If (FolderExist(subPath) && w && !wasGiven)
    {
       Loop, Files, % subPath "\*", D
       {
          If (A_LoopFileName!="")
          {
             If mustSkip.hasKey(A_LoopFileName)
                Continue

             P%A_Index% := TV_Add("\" A_LoopFileName, w)
             If (A_LoopFileName=initialSibling)
                subsParent := P%A_Index%
          }
       }
    }

    mustSkip := ""
    If (subsParent && !wasGiven)
    {
       TV_Modify(subsParent, "Select VisFirst")
       folderTreeScanSubbies()
    }

    TV_Modify(w, "Sort")
    If !wasGiven
    {
       GuiControl, fdTreeGuia: +Redraw, TVlistFolders
       SetTimer, folderTreeInfoLineUpdater, -100
       SetTimer, RemoveTooltip, -100
    }
}

iterateFDtreeView(lvl, z, sliced) {
    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders

    Loop
    {
       labelu := ""
       If z
          TV_GetText(labelu, z)

       If (Trimmer(labelu, "\")=sliced[lvl] && labelu)
       {
          lvl++
          gu := z
          r := TV_GetChild(z)
          If (r!=0)
          {
             g := iterateFDtreeView(lvl, r, sliced)
             lvl := g[1]
             If g[2]
                gu := g[2]
          }
       }

       r := TV_GetNext(z)
       If (r=0)
          Break

       z := r
    }
    Return [lvl, gu]
}

FolderTreeRepopulate(dummy:=0, listuGiven:=0) {
    If (dummy="given" && listuGiven)
    {
       PanelFoldersTree()
       Try SetTimer, FolderTreeRepopulate, Off
    }

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...

    If (!HKifs("imgsLoaded") || (dummy="given" && listuGiven))
    {
       If (dummy="given" && listuGiven)
       {
          aListu := listuGiven
          TV_Delete()
       } Else
       {
          aListu := readRecentEntries(0, 0)
          aListu .= readRecentFileDesties()
          If FolderExist(prevFileSavePath)
             aListu .= "`n" prevFileSavePath "`n"
          If FolderExist(prevFileMovePath)
             aListu .= "`n" prevFileMovePath "`n"
          If FolderExist(prevOpenFolderPath)
             aListu .= "`n" prevOpenFolderPath "`n"
    
          Sort, aListu, UD`n
       }

       Loop, Parse, aListu, `n
       {
          countItemz++
          testThis := StrReplace(A_LoopField, "|")
          If (StrLen(A_LoopField)<4 || !FileExist(testThis))
             Continue
 
          If RegExMatch(testThis, sldsPattern)
             testThis := SubStr(testThis, 1, InStr(testThis, "\", 0, -1) - 1)
 
          bListu .= testThis "`n"
       }
 
       Loop, Parse, bListu, `n
       {
          If A_LoopField
             FolderTreeFindActiveFile(A_LoopField)
       }
       TV_Modify(0, "Select VisFirst")
       folderTreeExpandCollapseAll("collapse")
       GuiControl, fdTreeGuia: +Redraw, TVlistFolders
       SetTimer, folderTreeInfoLineUpdater, -100
       SetTimer, RemoveTooltip, -100
       Return
    }

    z := TV_GetNext()
    If z
       TV_Delete(z)

    showTOOLtip("Scanning folders, please wait")
    parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
    parentsLevels := parentsObj.Count()
    ; ToolTip, % parentsLevels " == " currentParent , , , 2
    Loop, % parentsLevels
    {
       If (A_Index>currentParent)
          Continue
   
       If (A_Index=1 && !InStr(parentsObj[1], ":"))
          Break

       pu := A_Index - 1
       If (A_Index=1)
          P1 := TV_Add(parentsObj[A_Index] "\",, "Expand")
       Else If (A_Index!=currentParent)
          P%A_Index% := TV_Add("\" parentsObj[A_Index], P%pu%, "Expand")

       If (A_Index=currentParent)
          siblingsParent := P%pu%
    }

    sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
    Loop, % sibsObj.Count()
    {
       If !siblingsParent
          Continue

       pu := A_Index - 1
       If (A_Index=currentSib)
          subsParent := TV_Add("\" sibsObj[A_Index], siblingsParent, "Expand Bold")
       Else
          P%A_Index% := TV_Add("\" sibsObj[A_Index], siblingsParent)
    }

    If siblingsParent
       TV_Modify(siblingsParent, "Expand Sort")

    thisFolder := StrReplace(Trimmer(CurrentSLD), "|")
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", D
       {
          If (A_LoopFileName!="")
          {
             P%A_Index% := TV_Add("\" A_LoopFileName, subsParent)
             hasAddedSubs := 1
          }
       }
    }

    If subsParent
       TV_Modify(subsParent, "Expand Sort")

    countu := TV_GetCount()
    If !countu
       FolderTreeFindActiveFile()

    GuiControl, fdTreeGuia: +Redraw, TVlistFolders
    SetTimer, folderTreeInfoLineUpdater, -100
    SetTimer, RemoveTooltip, -100
}

folderTreeContextMenu() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   If c
      TV_GetText(labelu, c)

   Try Menu, PVfdTree, Delete
   Menu, PVfdTree, Add, Re&generate tree view`tF5, FolderTreeRepopulate
   Menu, PVfdTree, Add, &Populate tree view with active file path`tF9, FolderTreeFindActiveFile
   If c
      Menu, PVfdTree, Add, &Scan for sub-folders`tSpace, folderTreeScanSubbies

   If (c && !InStr(labelu, ":"))
   {
      Menu, PVfdTree, Add
      Menu, PVfdTree, Add, Open`tEnter, folderTreeDefaultAction
      Menu, PVfdTree, Add, &Append images from folder to current list`tF3, folderTreeAppendFiles
      Menu, PVfdTree, Add
      Menu, PVfdTree, Add, &Create new folder`tF7, folderTreeCreateFolder
      Menu, PVfdTree, Add, &Rename folder`tF2, folderTreeRenameFolder
      Menu, PVfdTree, Add, &Delete folder`tDelete, folderTreeDeleteFolder
      Menu, PVfdTree, Add, &Set as the protected folder, folderTreeSetFolderProtected
      Menu, PVfdTree, Add
      Menu, PVfdTree, Add, &Paste clipboard file(s) into..., folderTreePasteClippy
      Menu, PVfdTree, Add
      Menu, PVfdTree, Add, Selected/active file(s), dummy
      Menu, PVfdTree, Disable, Selected/active file(s)
      Menu, PVfdTree, Add, Cop&y into...`t7, FolderTreeMenuCopyFiles
      Menu, PVfdTree, Add, &Move into...`tShift+7, FolderTreeMenuMoveFiles
      Menu, PVfdTree, Add
   }
   Menu, PVfdTree, Add, Large UI fonts, folderTreeToggleLargeUIfonts
   Menu, PVfdTree, Add, Close panel`tEscape, fdTreeGuiaGuiClose
   If (PrefsLargeFonts=1)
      Menu, PVfdTree, Check, Large UI fonts
   showThisMenu("PVfdTree")
}

folderTreeToggleLargeUIfonts() {
    ToggleLargeUIfonts()
    PanelFoldersTree()
}

FolderTreeMenuCopyFiles() {
   triggerQuickFileAction("vk37")
}

FolderTreeMenuMoveFiles() {
   triggerQuickFileAction("+vk37")
}

folderTreeCreateFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   fakeWinCreator(51, A_ThisFunc, 0)
   msgResult := msgBoxWrapper("panelu|Create folder: " appTitle, "Create new folder in:`n" thisFolder "\`n`nPlease type the new folder name.", "&Create folder|C&ancel", 1, "modify-file", 0, 0, 0, "limit9050", "")
   If InStr(msgResult.btn, "Create")
   {
      newFileName := Trimmer(msgResult.edit)
      If FolderExist(thisFolder "\" newFileName)
      {
         showTOOLtip("WARNING: A folder with the given name already exists:`n" thisFolder "\`n" newFileName "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      newFileName := filterFileName(newFileName)
      If !newFileName
      {
         showTOOLtip("WARNING: Incorrect folder name given.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      FileCreateDir, %thisFolder%\%newFileName%
      If !ErrorLevel
      {
         Gui, fdTreeGuia: Default
         Gui, fdTreeGuia: TreeView, TVlistFolders
         TV_Add("\" newFileName, c)
         TV_Add(c, "Expand Sort")
         GuiControl, fdTreeGuia: +Redraw, TVlistFolders
      } Else
      {
         showTOOLtip("ERROR: An unknown error occured creating the new folder in:`n" thisFolder "\")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

folderTreeDeleteFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If FolderExist(thisFolder)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected:`n`n" thisFolder "\`n`nPlease confirm you want to DELETE entirely this folder.", "&Delete|&Cancel", 2, "question")
      If (msgResult="delete")
      {
         destroyGDIfileCache()
         showTOOLtip("Deleting folder, please wait`n" thisFolder "\*")
         FileRemoveDir, % thisFolder, 1
         If !ErrorLevel
         {
            Gui, fdTreeGuia: Default
            Gui, fdTreeGuia: TreeView, TVlistFolders
            SoundBeep , 900, 100
            RemoveTooltip()
            TV_Delete(c)
            GuiControl, fdTreeGuia: +Redraw, TVlistFolders
         } Else
         {
            showTOOLtip("Failed to delete selected folder:`n" thisFolder "\")
            SoundBeep , 300, 100
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }
   }
}

folderTreeRenameFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   fakeWinCreator(51, A_ThisFunc, 0)
   thisParent := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
   msgResult := msgBoxWrapper("panelu|Rename folder: " appTitle, "Folder location:`n" thisFolder "\`n`nPlease type the new folder name for:`n" thisParent, "&Rename folder|C&ancel", 1, "modify-file", 0, 0, 0, "limit9050", thisParent)
   If InStr(msgResult.btn, "Rename")
   {
      newFileName := Trimmer(msgResult.edit)
      If !newFileName
         Return

      newFileName := filterFileName(newFileName)
      If !newFileName
      {
         showTOOLtip("WARNING: Incorrect folder name given.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If FolderExist(thisFolder "\" newFileName)
      {
         showTOOLtip("WARNING: A folder with the given name already exists:`n" thisFolder "\`n" newFileName "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      oldPath := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1) - 1)
      FileMoveDir, % thisFolder, % oldPath "\" newFileName, R
      If !ErrorLevel
      {
         Gui, fdTreeGuia: Default
         Gui, fdTreeGuia: TreeView, TVlistFolders
         TV_Modify(c, "Select Vis Sort", "\" newFileName)
         GuiControl, fdTreeGuia: +Redraw, TVlistFolders
      } Else
      {
         showTOOLtip("ERROR: An unknown error occured renaming the folder:`n" thisFolder "\")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

folderTreeAppendFiles() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   changeMcursor()
   linea := folderTreeGetSelectedPath(c)
   If (!linea || !FolderExist(linea) || InStr(DynamicFoldersList, linea "`n"))
      Return

   If !CurrentSLD
      CurrentSLD := linea

   GetFilesList(linea "\*")
   DynamicFoldersList .= linea "`n"
   If (SLDtypeLoaded=3)
      addDynamicFolderSQLdb(linea, 0, "dynamicfolders")
   SoundBeep 900, 100
   ResetImgLoadStatus()
   currentFileIndex := maxFilesIndex - 1
   dummyTimerDelayiedImageDisplay(50)
}

folderTreeExpandCollapseAll(forceMode:=0) {
   Static prevState := 1
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetNext()
   If !c
      Return

   If (forceMode="collapse")
      prevState := 1
   Else If (forceMode="expand")
      prevState := 0

   act := (prevState=1) ? "-Expand" : "Expand"
   friendly := (prevState=1) ? "COLLAPSED" : "EXPANDED"
   c := TV_Modify(c, act)
   Loop
   {
       c := TV_GetNext(c, "F")
       TV_Modify(c, act)
       If !c
          Break
   }

   c := TV_GetNext()
   c := TV_Modify(c, "VisFirst Select")
   prevState := !prevState
   showTOOLtip("Folder tree: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

folderTreeScanSubbies() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   ; c := prevTVelement

   If !c
      Return

   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
   {
      TV_GetText(thisFolder, c)
      thisFolder := Trimmer(thisFolder, "\")
   }

   If !thisFolder
      Return

    showTOOLtip("Scanning folders, please wait")
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...
    ; ToolTip, % A_DefaultTreeView "==" A_DefaultGUI "==" c , , , 2
    changeMcursor()
    mustSkip := new hashtable()
    mustDelete := new hashtable()
    r := c
    r := TV_GetChild(c)
    Loop
    {
       If (A_Index>1)
          r := TV_GetNext(r)

       If r
          x := TV_GetChild(r)
       Else
          x := ""

       If !r
          Break

       If x
       {
          labelu := ""
          TV_GetText(labelu, r)
          If (Trimmer(labelu, "\") && FolderExist(thisFolder labelu))
          {
             h := Trimmer(labelu, "\")
             mustSkip[h] := 1
             Continue
          }
       }

       mustDelete[r] := 1
    }

    For Key, Value in mustDelete
       TV_Delete(Key)

   mustDelete := ""
   If FolderExist(thisFolder)
   || (StrLen(thisFolder)=2 && InStr(thisFolder, ":"))
   {
      Loop, Files, % thisFolder "\*", D
      {
         If mustSkip.hasKey(A_LoopFileName)
            Continue

         If (A_LoopFileName!="")
         {
            P%A_Index% := TV_Add("\" A_LoopFileName, c)
            hasAddedSubs := 1
         }
      }
   }

   mustSkip := ""
   RemoveTooltip()
   TV_Modify(c, "Expand Vis Select Sort")
   GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   SetTimer, folderTreeInfoLineUpdater, -100
   SetTimer, ResetImgLoadStatus, -125
}

folderTreePasteClippy() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   If !c
      Return

   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If FolderExist(thisFolder)
      PasteFilesIntoGivenFolder(thisFolder)
}

PasteFilesIntoGivenFolder(folderPath) {
   showTOOLtip("Importing clipboard content...")
   Try listu := Clipboard
   SetTimer, RemoveTooltip, -200
   If StrLen(listu)<5
      Return
   
   msgResult := msgBoxWrapper(appTitle ": Paste files", "The files from the clipboard will be pasted into the selected folder. Please choose what operation to perform. Destination folder:`n`n" folderPath "\", "&Copy|&Move|C&ancel", 1, "question")
   SetTimer, RemoveTooltip, -200
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   If InStr(msgResult, "Copy")
   {
      friendly := "Copying"
      filesActu := 1
   } Else If InStr(msgResult, "Move")
   {
      friendly := "Moving"
      filesActu := 2
   } Else
   {
      WinActivate, ahk_id %hfdTreeWinGui%
      Return
   }

   foundFiles := ST_Count(listu, "`n")
   finalDest := folderPath
   filezMoved := countTFilez := 0
   doStartLongOpDance()
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   Loop, Parse, listu, `n,`r
   {
      If !A_LoopField
         Continue

      file2rem := A_LoopField
      zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)

      countTFilez++
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If (OldOutDir=finalDest)
      {
         skippedFiles++
         Continue
      }

      FileGetTime, originalMtime, % file2rem, M
      FileGetTime, originalCtime, % file2rem, C
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, foundFiles, startOperation)
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"
         If (failedFiles>0)
            etaTime .= "`nFailed to perform action on " groupDigits(failedFiles) " files"

         showTOOLtip(friendly " files to`n" finalDest "\" etaTime, 0, 0, countTFilez/foundFiles)
         prevMSGdisplay := A_TickCount
      }

      file2save := finalDest "\" OldOutFileName
      thisFileExists := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
      {
         thisFileExists := 1
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, 0, performOverwrite)
      }
  
      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }
  
      If (thisFileExists=1)
      {
         If (performOverwrite=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 2
            FileRecycle, %file2save%
            Sleep, 2
            mustPerformOperation := 1
         } Else If (performOverwrite!=2)
         {
            skippedFiles++
            Continue
         } Else mustPerformOperation := 1
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (filesActu=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
         }

         filezMoved++
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped"
   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " failedFiles " files"

   If (filesActu=2)
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BtnCloseWindow() {
   Critical, on
   CloseWindow("yes")
   If AnyWindowOpen
      BtnCloseWindow()
}

InfoBtnNextImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  NextPicture()
  Sleep, 1
  PopulateImgInfos()
}

InfoBtnPrevImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  PreviousPicture()
  Sleep, 1
  PopulateImgInfos()
}

copyIMGinfos2clip() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaD
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>2)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1) ? ": " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>95)
          Break
   }

   textu := Trimmer(textu) "`NOTHER DETAILS:`n"
   Gui, SettingsGUIA: ListView, LViewMetaOthers
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>2)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1) ? ": " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>99)
          Break
   }

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Unable to copy to clipboard file details")
         SoundBeep , 300, 100
      } Else showTOOLtip("File details copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateImgInfos() {
   resultu := getIDimage(currentFileIndex)
   If !FileExist(resultu)
   {
      informUserFileMissing()
      Return
   }

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaOthers
   LV_Delete()
   Try PropList := FGP_List(resultu)            ; Gets all of a file's non-blank properties.
   Loop, Parse, % PropList.CSV,`n
   {
       If !A_LoopField
          Continue
       lineArru := StrSplit(A_LoopField, ",")
       LV_Add(A_Index, lineArru[2], lineArru[3])
   }

   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")

   Gui, SettingsGUIA: ListView, LViewMetaD
   LV_Delete()
   FileGetSize, FileSizu, % resultu, K
   FileGetTime, FileDateM, % resultu, M
   FileGetTime, FileDateC, % resultu, C
   FormatTime, FileDateM, % FileDateM, dddd, d MMMM yyyy, HH:mm:ss
   FormatTime, FileDateC, % FileDateC, dddd, d MMMM yyyy, HH:mm:ss

   zPlitPath(resultu, 0, fileNamu, folderu)
   zoomu := Round(zoomLevel*100)
   If (thisIMGisDownScaled=1)
      infoDownScale := " [DOWNSCALED] "

   Gdip_GetImageDimensions(useGdiBitmap(), Width, Height)
   If (currIMGdetails.TooLargeGDI=1)
      infoRes := "`nOriginal resolution (W x H)||" groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " (in pixels)"

   generalInfos := "File name||" fileNamu "`nLocation||" folderu "\`nFile size||" groupDigits(fileSizu) " kilobytes`nDate created||" FileDateC "`nDate modified||" FileDateM infoRes "`nResolution (W x H)||" groupDigits(Width) " x " groupDigits(Height) " (in pixels)`nCurrent zoom level||" zoomu " % (" DefineImgSizing() infoDownScale ")"
   Loop, Parse, generalInfos, `n
   {
       lineArru := StrSplit(A_LoopField, "||")
       LV_Add(A_Index, lineArru[1], lineArru[2])
   }

   LV_Add(A_Index, "Colors display mode", DefineFXmodes())
   Gdip_GetHistogram(useGdiBitmap(), 2, ArrChR, ArrChG, ArrChB)
   Loop, 256
   {
       sumTotalR += ArrChR[A_Index] * A_Index
       sumTotalG += ArrChG[A_Index] * A_Index
       sumTotalB += ArrChB[A_Index] * A_Index
   }

   diffRGBtotal := max(sumTotalR, sumTotalG, sumTotalB) - min(sumTotalR, sumTotalG, sumTotalB)
   diffRGBtotal := diffRGBtotal/max(sumTotalR, sumTotalG, sumTotalB)
   If (diffRGBtotal<0.0001 || diffRGBtotal="")
      LV_Add(A_Index, "Grayscale image", 1)
   Else
      LV_Add(A_Index, "Grayscale image", 0)

   LV_Add(A_Index, "Image file format", currIMGdetails.RawFormat)
   LV_Add(A_Index, "Image pixel format", currIMGdetails.PixelFormat)

   CountFrames := currIMGdetails.Frames
   If (CountFrames>1)
      LV_Add(A_Index, "Embedded frames", CountFrames)

   If (currIMGdetails.OpenedWith="GDI+")
   {
      thumbBMP := trGdip_CreateBitmapFromFile(getIDimage(currentFileIndex))
      If StrLen(thumbBMP)>2
         MoreProperties := Gdip_GetAllPropertyItems(thumbBMP)
      For ID, Val In MoreProperties
      {
         If ID Is Integer
         {
            PropName := Gdip_GetPropertyTagName(ID)
            PropType := Gdip_GetPropertyTagType(Val.Type)
            If (val.value && StrLen(PropName)>1 && PropName!="unknown" && PropType!="undefined" && PropType!="byte")
            {
               If (InStr(PropName, "nancetable") || InStr(PropName, "jpeg") || InStr(PropName, "thumbnail")
               || InStr(PropName, "printflag") || InStr(PropName, "strip") || InStr(PropName, "chromatic"))
                  Continue
 
               If (PropName="frame delay") || (PropName="bits per sample")
               {
                  valu := SubStr(Val.Value, 1, InStr(Val.Value, A_Space))
                  LV_Add(A_Index, PropName, valu)
               } Else LV_Add(A_Index, PropName, Val.Value)
            }
         }
      }
      trGdip_DisposeImage(thumbBMP, 1)
   }
   LV_Add(A_Index, "Image loaded with ", currIMGdetails.OpenedWith)

   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")
}

Trimmer(string, whatTrim:="") {
   If (whatTrim!="")
      string := Trim(string, whatTrim)
   Else
      string := Trim(string, "`r `n `t`f`v`b")
   Return string
}

FileRexists(filePath) {
   obju := GetFileAttributesEx(filePath)
   ; MsgBox, % fileAttribs "`n" fileSizu "`nA" filePath "A"
   If (obju.size<120 || !obju.size)
      Return 0
   Else
      Return 1
}

hFindIsFolder(ByRef fileInfos) {
   Static FILE_ATTRIBUTE_DIRECTORY := 0x10
   Return NumGet(&fileInfos,0,"UInt") & FILE_ATTRIBUTE_DIRECTORY
}

hFindGetName(ByRef fileInfos) {
   cFileName := StrGet(&fileInfos + 44, 260, "UTF-16")
   If (cFileName="." || cFileName="..")
      cFileName := ""
   Return cFileName
}

testGetFile(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 1512, 0)

    hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")
    cFileName := hFindGetName(Win32FindData)
    If (hFindIsFolder(Win32FindData) && cFileName)
    {
    ;  MsgBox, folderrr
       testGetFile(filePath "\" cFileName)
    } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
    {
       maxFilesIndex++
       resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
    }

   ; MsgBox, % filePath "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError


 ;   instance.nFileSizeHigh := NumGet(&Win32FindData, 28,  "UInt")
;    instance.nFileSizeLow := NumGet(&Win32FindData, 32,  "UInt")

    While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData)) {
          cFileName := hFindGetName(Win32FindData)
          If hFindIsFolder(Win32FindData) && cFileName
          {
             testGetFile(filePath "\" cFileName)
          } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
          {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
          }
    ; MsgBox, % filePath "`n" r "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
    }

   ; maxFilesIndex := resultedFilesList.Length()
    ; SoundBeep 
    Return
}

testGetFile2(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 318+1024, 0)
    if (hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")) {
        cFileName := StrGet(&Win32FindData + 44, 260, "UTF-16")
        cAlternateFileName := StrGet(&Win32FindData + 564, 14, "UTF-16")
        
        MsgBox, %  hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
        While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData)) {
            cFileNamea := StrGet(&Win32FindData + 44, 260, "UTF-16")
            cAlternateFileNamea := StrGet(&Win32FindData + 564, 14, "UTF-16")
            MsgBox, %  r "`n" cFileNameA "`n" cAlternateFileNameA "`n" ErrorLevel "`n" A_LastError
        }
    }
    Return
}

testFileExistence(imgPath) {
  ; https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-getfilesize
  ; H := DllCall("kernel32\GetFileAttributesW", "Str", imgPath)
  ; H := DllCall("shlwapi.dll\PathFileExistsW", "Str", imgPath)
  ; If (h>0)
  ;    Return 256
  VarSetCapacity(dummy, 1024, 0)
  H := DllCall("kernel32\FindFirstFileW", "Str", imgPath, "Ptr", &dummy, "Ptr")
  Return H
}

informUserFileMissing() {
   Critical, on
   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, fileNamu, folderu)
   showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
   winTitle := "[*] " currentFileIndex "/" maxFilesIndex " | " fileNamu " | " folderu
   setWindowTitle(winTitle, 1)
   SoundBeep, 300, 100
   If (autoRemDeadEntry=1)
      remCurrentEntry(0, 1)
   If (thumbsDisplaying=1 && maxFilesIndex>0)
      mainGdipWinThumbsGrid()

   SetTimer, RemoveTooltip, % -msgDisplayTime
}

JEE_StrRegExLiteral(vText) {
  Loop, Parse, vText
  {
    If InStr("\.+[{()^$", A_LoopField)
      vOutput .= "\" A_LoopField
    Else If InStr("?*", A_LoopField)
      vOutput .= "." A_LoopField
    Else
      vOutput .= A_LoopField
  }

  Return vOutput
}

FiltersComboAction() {
  If (A_GuiControlEvent="DoubleClick")
     BtnApplyFilesFilter()
}


readRecentFiltersEntries() {
   Loop, 20
   {
       IniRead, newEntry, % mainRecentsFile, RecentFilters, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (InStr(entriesList, newEntry "`n") || !newEntry)
          Continue

       addSel := (newEntry=testFilteru) ? "`n" : ""
       If StrLen(newEntry)>1
          entriesList .= newEntry "`n" addSel
   }

   Return entriesList
}

EraseFilterzHisto() {
  IniDelete, % mainRecentsFile, RecentFilters
  CloseWindow()
  Sleep, 50
  PanelEnableFilesFilter()
}

PanelEnableFilesFilter() {
    Global FilterTypeu := 0
    If (maxFilesIndex<3 && !filesFilter)
       Return

    thisBtnHeight := createSettingsGUI(6, A_ThisFunc)
    btnWid := 80
    txtWid := 360
    EditWid := 390
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 200
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    If !filesFilter
    {
       userFilterProperty := 1 
       userFilterDoString := 0
    }

    listu := readRecentFiltersEntries()
    If (!InStr(listu, "`n`n") && StrLen(UsrEditFilter)>0 && userFilterDoString=1 && StrLen(filesFilter)>1)
       listu := UsrEditFilter "`n`n" listu

    Gui, +Delimiter`n
    Gui, Add, Tab3,, Text`nFile and image
    Gui, Tab, 1
    Gui, Add, Checkbox, x+15 y+15 Section w%txtWid% gupdateUIFiltersPanel Checked%userFilterDoString% vuserFilterDoString, Filter files list with given string
    Gui, Add, ComboBox, y+7 w%EditWid% gupdateUIFiltersPanel vUsrEditFilter, % listu
    Gui, Add, DropDownList, y+7 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterStringPos% vuserFilterStringPos, Anywhere`nBegins with`nEnds with`nRegEx
    Gui, Add, DropDownList, x+2 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterWhat% vuserFilterWhat, Full path`nFolder path`nFile name`nParent folder
    Gui, Add, Checkbox, xs y+7 gupdateUIFiltersPanel Checked%userFilterStringIsNot% vuserFilterStringIsNot, &Must not contain given string
    Gui, Add, Button, xs y+7 vbtnFldr h%thisBtnHeight% w%btnWid% gEraseFilterzHisto, Erase &history
    Gui, Add, Text, xs y+15 vbtnFldr2 w%txtWid%, TIP: You can use | for OR and the *, ? wildcards in the filter to match more files.
    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 Section w%txtWid%, Please choose the type of criteria and set minimum and maximum range.
    Gui, Add, DropDownList, xs y+7 w%btnWid% gupdateUIFiltersPanel AltSubmit Choose%userFilterProperty% vuserFilterProperty, None`nFile size`nModified date`nCreated date`nMegapixels`nWidth`nHeight`nAspect ratio`nFrames`nDPI`nAverage`nMedian`nPeak range`nMinimum range`nTotal range`nMode`nMinimum`nRoot-mean suqare`nSelected files`nAlready seen
    Gui, Add, Text, x+5 wp vFilterTypeu, 
    Gui, Add, Edit, xs y+7 wp number limit5 +hwndhEditA gupdateUIFiltersPanel vFilteruMinRange, % FilteruMinRange
    Gui, Add, Edit, x+5 wp number limit5 +hwndhEditB gupdateUIFiltersPanel vFilteruMaxRange, % FilteruMaxRange
    Gui, Add, DropDownList, x+5 wp gupdateUIFiltersPanel AltSubmit Choose%userFilterSizeProperty% vuserFilterSizeProperty, Kilobytes`nMegabytes
    Gui, Add, DateTime, xs y+7 wp gupdateUIFiltersPanel vFilteruDateMinRange, yyyy/MM/dd
    Gui, Add, DateTime, x+5 wp gupdateUIFiltersPanel vFilteruDateMaxRange, yyyy/MM/dd
    Gui, Tab
    Gui, Add, Edit, xs y+10 w%EditWid% r2 +0x0800 vInternalFilterString, % filesFilter
    ; Gui, Add, Text, y+7 w%txtWid%, Tip: you can begin the string with \> to use RegEx.

    Gui, Add, Button, xs+0 y+10 h%thisBtnHeight% w%btnWid% Default gBtnApplyFilesFilter, &Apply filter
    Gui, Add, Button, x+5 hp wp+5 gPanelWrapperFilesStats, &Statistics
    If StrLen(filesFilter)>1
       Gui, Add, Button, x+5 hp wp+20 gBTNuiremFilesListFilter, &Remove filters
    Gui, Add, Button, x+5 hp w85 gPanelSearchIndex, &Search
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Files list filtering: " appTitle)
    EM_SETCUEBANNER(hEditA, "Minimum")
    EM_SETCUEBANNER(hEditB, "Maximum")
    ; EM_SETCUEBANNER(hEditC, "String to match")
    SetTimer, updateUIFiltersPanel, -300
}

BTNuiremFilesListFilter() {
   BtnCloseWindow()
   remFilesListFilter()
   SetTimer, RandomPicture, -90
}

SQLescapeStr(str, likeu:=0) {
   str := StrReplace(str, "'", "''")
   If (likeu=1)
   {
      str := StrReplace(str, "_", ">_")
      str := StrReplace(str, "%", ">%")
      str := StrReplace(str, "[", ">[")
   }
   Return str
}

updateUIFiltersPanel(dummy:=0) {
   Static columnsList := {2:"fsize", 3:"fmodified", 4:"fcreated", 5:"imgmegapix", 6:"imgwidth", 7:"imgheight", 8:"imgwhratio", 9:"imgframes", 10:"imgdpi", 11:"imgavg", 12:"imgmedian", 13:"imghpeak", 14:"imghlow", 15:"imghrange", 16:"imghmode", 17:"imghminu", 18:"imghrms"}

   If (dummy!="external")
   {
      If (AnyWindowOpen=6)
         Gui, SettingsGUIA: Default
      Else
         Return

      GuiControlGet, UsrEditFilter
      GuiControlGet, userFilterDoString
      GuiControlGet, userFilterStringIsNot
      GuiControlGet, userFilterStringPos
      GuiControlGet, userFilterWhat
      GuiControlGet, userFilterProperty
      GuiControlGet, userFilterSizeProperty
      GuiControlGet, FilteruMinRange
      GuiControlGet, FilteruMaxRange
      GuiControlGet, FilteruDateMaxRange
      GuiControlGet, FilteruDateMinRange

      If (userFilterStringPos!=4)
      {
         Loop, Parse, % "<>/"
            UsrEditFilter := StrReplace(UsrEditFilter, A_LoopField)

         If (userFilterWhat=3)
         {
            Loop, Parse, % ":\"
               UsrEditFilter := StrReplace(UsrEditFilter, A_LoopField)
         }
         UsrEditFilter := StrReplace(UsrEditFilter, "||")
      }

      actu := (userFilterDoString=1) ?  "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, userFilterWhat
      GuiControl, % actu, userFilterStringPos
      GuiControl, % actu, userFilterStringIsNot
      GuiControl, % actu, UsrEditFilter
      GuiControl, % actu, btnFldr
      GuiControl, % actu, btnFldr2

      If (userFilterProperty=2)
         GuiControl, SettingsGUIA: Enable,  userFilterSizeProperty
      Else
         GuiControl, SettingsGUIA: Disable,  userFilterSizeProperty

      If (userFilterProperty=3 || userFilterProperty=4)
      {
         GuiControl, SettingsGUIA: Enable, FilteruDateMaxRange
         GuiControl, SettingsGUIA: Enable, FilteruDateMinRange
      } Else
      {
         GuiControl, SettingsGUIA: Disable, FilteruDateMaxRange
         GuiControl, SettingsGUIA: Disable, FilteruDateMinRange
      }

      If (userFilterProperty=2 || isInRange(userFilterProperty, 5, 18))
      {
         GuiControl, SettingsGUIA: Enable, FilteruMinRange
         GuiControl, SettingsGUIA: Enable, FilteruMaxRange
      } Else
      {
         GuiControl, SettingsGUIA: Disable, FilteruMinRange
         GuiControl, SettingsGUIA: Disable, FilteruMaxRange
      }

      If isInRange(userFilterProperty, 2, 4)
      {
         GuiControl, SettingsGUIA:, FilterTypeu, File property
      } Else If isInRange(userFilterProperty, 5, 10)
      {
         GuiControl, SettingsGUIA:, FilterTypeu, Image property
      } Else If isInRange(userFilterProperty, 11, 18)
      {
         ; FilteruMaxRange := Round(FilteruMaxRange*1.05)
         ; FilteruMinRange := Round(FilteruMinRange*1.05)
         GuiControl, SettingsGUIA:, FilterTypeu, Histogram details
      } Else
      {
         GuiControl, SettingsGUIA:, FilterTypeu, -
      }
   }

   ; testRegEx := SubStr(UsrEditFilter, 1, 2)
   thisStringFilter := ""
   If (userFilterDoString=1 && SLDtypeLoaded=3)
   {
      thisStringFilter := SQLescapeStr(UsrEditFilter, 1)
      If (userFilterStringPos=4 && thisStringFilter)
         thisStringFilter := thisStringFilter
      Else If (userFilterStringPos=3 && thisStringFilter) 
         thisStringFilter := "%" thisStringFilter
      Else If (userFilterStringPos=2 && thisStringFilter)
         thisStringFilter := thisStringFilter "%"
      Else If UsrEditFilter
         thisStringFilter := "%" thisStringFilter "%"

      thisStringFilter := StrReplace(thisStringFilter, "?", "_")
      thisStringFilter := StrReplace(thisStringFilter, "*", "_")
      thisStringFilter := StrReplace(thisStringFilter, "|")
   } Else If (userFilterDoString=1 && SLDtypeLoaded!=3)
   {
      If (userFilterStringPos=4 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)" UsrEditFilter
      Else If (userFilterStringPos=3 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")$"
      Else If (userFilterStringPos=2 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)^(" JEE_StrRegExLiteral(UsrEditFilter) ")"
      Else If UsrEditFilter
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")"
   }

   columnu := columnsList[userFilterProperty]
   minRange := min(FilteruMinRange, FilteruMaxRange)
   maxRange := max(FilteruMinRange, FilteruMaxRange)
   minDrange := min(FilteruDateMinRange, FilteruDateMaxRange)
   maxDrange := max(FilteruDateMinRange, FilteruDateMaxRange)
   If (userFilterProperty>1 && minRange!="")
   {
      If (userFilterProperty=2)
      {
         minRange := (userFilterSizeProperty=2) ? minRange*(1024**2) : minRange*1024
         maxRange := (userFilterSizeProperty=2) ? maxRange*(1024**2) : maxRange*1024
      } Else If (userFilterProperty=3 || userFilterProperty=4)
      {
         minRange := SubStr(minDrange, 1, 8) "010101"
         maxRange := SubStr(maxDrange, 1, 8) "010101"
      } Else If (userFilterProperty=8)
      {
         minRange := Round(minRange/10, 1)
         maxRange := Round(maxRange/10, 1)
      } Else If (userFilterProperty>10)
      {
         minRange := Round(clampInRange(minRange, 1, 256)/256, 5)
         maxRange := Round(clampInRange(maxRange, 1, 256)/256, 5)
      }

      If (SLDtypeLoaded=3)
      {
         isOrNot := (userFilterStringIsNot=1) ? " NOT " : ""
         2ndColumn := (userFilterWhat=1) ? "fullPath" : "imgfolder"
         If (userFilterProperty=8)
            columnu := "Round(imgwhratio, 1)"
         If (userFilterProperty=5)
            columnu := "Round(imgmegapix)"

         If (userFilterWhat=3)
            2ndColumn := "imgfile"
         finalFilteru := "SQL:query:WHERE " columnu " BETWEEN " minRange " AND " maxRange
         If thisStringFilter
            finalFilteru .= " AND " 2ndColumn isOrNot " LIKE '" thisStringFilter "' ESCAPE '>'"
      } Else
      {
         finalFilteru := "QPV::query::" columnu "::" minRange "::" maxRange
         If thisStringFilter
            finalFilteru .= "::" thisStringFilter
      }
   } Else
   {
      If (SLDtypeLoaded=3 && thisStringFilter)
      {
         isOrNot := (userFilterStringIsNot=1) ? " NOT " : ""
         2ndColumn := (userFilterWhat=1) ? "fullPath" : "imgfolder"
         If (userFilterWhat=3)
            2ndColumn := "imgfile"
         finalFilteru := "SQL:query:WHERE " 2ndColumn isOrNot " LIKE '" thisStringFilter "' ESCAPE '>'"
      } Else If thisStringFilter
         finalFilteru := "\>" thisStringFilter
   }

   newFilter := Trimmer(finalFilteru)
   newFilter := StrReplace(newFilter, "||", "|")
   newFilter := Trimmer(newFilter, "|")
   If (userFilterProperty=19)
      newFilter := (SLDtypeLoaded=3) ? "SQL:query:||Prev-Files-Selection||" : "||Prev-Files-Selection||"
   Else If (userFilterProperty=20)
      newFilter := "||Already-Seen-Images||"

   If (dummy!="external")
      GuiControl, SettingsGUIA:, InternalFilterString, % newFilter

   Return newFilter
}

BtnApplyFilesFilter() {
   Gui, SettingsGUIA: Default
   GuiControlGet, UsrEditFilter
   newFilter := updateUIFiltersPanel()
   Gui, SettingsGUIA: Submit, NoHide
   If !newFilter
   {
      SoundBeep , 300, 100
      showTOOLtip("WARNING: No filter has been defined")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (userFilterProperty=19)
   {
      getSelectedFiles(0, 1)
      If !markedSelectFile
      {
         msgBoxWrapper(appTitle ": WARNING", "You currently have no selected image in the files list. The filter is therefore inapplicable.", 0, 0, "warning")
         Return
      } Else userFilterDoString := 0
   } Else If (userFilterProperty=20)
   {
      BtnCloseWindow()
      userFilterDoString := 0
      retrieveAlreadySeenImageFromCurrentList()
      Return
   }

   BtnCloseWindow()
   If askAboutFileSave(" and the files list will be renewed based on the provided filter criteria")
   {
      UsrEditFilter := ""
      Return
   }

   If (userFilterDoString=1 && UsrEditFilter)
      RecentFiltersManager(UsrEditFilter)

   coreEnableFiltru(newFilter)
   dummyTimerDelayiedImageDisplay(50)
}

RecentFiltersManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentFiltersEntries()
  If (StrLen(entry2add)<3 || InStr(entry2add, "{ no filter }"))
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>20)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentFilters, E%countItemz%
  }
}

msgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, checkBoxuCaption:="", checkState:=0, dropListu:="",edithu:="", edithuDef:="", listEditMode:=0, setWidth:=0, 2ndDropListu:=0, 2ndlistEditMode:=0) {
    Static msgBoxed := 0
    If (msgBoxed=1 && MsgBox2hwnd)
       Return

    msgBoxed := 1
    SetTimer, dummyUnSuspendu, Delete
    doSuspendu(1)
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", iconz)

    panelMode := 0
    fontSize := (PrefsLargeFonts=1) ? LargeUIfontValue : 0
    hwnd := (AnyWindowOpen>0) ? hSetWinGui : PVhwnd
    If (InStr(winTitle, "panelu|") && AnyWindowOpen>0 && prevOpenedWindow[5]=1)
    {
       winTitle := StrReplace(winTitle, "panelu|")
       panelMode := 1
       hwnd := PVhwnd
    } Else DestroyTempBtnGui("now")

    zr := MsgBox2(msg, winTitle, buttonz, defaultBTN, iconz, nullFnt, PrefsLargeFonts, fontSize, hwnd, hwnd, checkBoxuCaption, checkState, dropListu, edithu, edithuDef, listEditMode, setWidth, 2nddropListu, 2ndlistEditMode)
    r := zr.btn

    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    If (buttonz!=-1)
       addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
    Else
       addJournalEntry("HELP BOX CLOSED: " winTitle)

    If (panelMode=1) ; fake window panel
    {
       AnyWindowOpen := 0
       interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    }

    lastLongOperationAbort := A_TickCount
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", "normal")
    SetTimer, dummyUnSuspendu, -200, 900
    msgBoxed := 0
    Return (checkBoxuCaption || dropListu || edithu) ? zr : r
}

simpleMsgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, modality:=0, optionz:=0) {
   ; Buttonz options:
   ; 0 = OK (that is, only an OK button is displayed)
   ; 1 = OK/Cancel
   ; 2 = Abort/Retry/Ignore
   ; 3 - Yes/No/Cancel
   ; 4 = Yes/No
   ; 5 = Retry/Cancel
   ; 6 = Cancel/Try Again/Continue

   ; Iconz options:
   ; 16 = Icon Hand (stop/error)
   ; 32 = Icon Question
   ; 48 = Icon Exclamation
   ; 64 = Icon Asterisk (info)

   ; Modality options:
   ; 4096 = System Modal (always on top)
   ; 8192 = Task Modal
   ; 262144 = Always-on-top (style WS_EX_TOPMOST - like System Modal but omits title bar icon)

   If AnyWindowOpen
   {
      If (defaultBTN=2)
         defaultBTN := 255
      Else If (defaultBTN=3)
         defaultBTN := 512
      Else
         defaultBTN := 0
 
      If (iconz=1 || iconz="hand" || iconz="error" || iconz="stop")
         iconz := 16
      Else If (iconz=2 || iconz="question")
         iconz := 32
      Else If (iconz=3 || iconz="exclamation")
         iconz := 48
      Else If (iconz=4 || iconz="info")
         iconz := 64
      Else
         iconz := 0
 
      theseOptionz := buttonz + iconz + defaultBTN + modality
      If optionz
         theseOptionz := optionz
 
      Gui, SettingsGUIA: +OwnDialogs
      MsgBox, % theseOptionz, % winTitle, % msg
      IfMsgBox, Yes
           r := "Yes"
      IfMsgBox, No
           r := "No"
      IfMsgBox, OK
           r := "OK"
      IfMsgBox, Cancel
           r := "Cancel"
      IfMsgBox, Abort
           r := "Abort"
      IfMsgBox, Ignore
           r := "Ignore"
      IfMsgBox, Retry
           r := "Retry"
      IfMsgBox, Continue
           r := "Continue"
      IfMsgBox, TryAgain
           r := "TryAgain"
   } Else r := interfaceThread.ahkFunction("msgBoxWrapper", winTitle, msg, buttonz, defaultBTN, iconz, modality, optionz)

   ; addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
   ; lastLongOperationAbort := A_TickCount
   Return r
}

coreEnableFiltru(stringu, noStringProcessing:=0) {
  If (stringu="\>")
     stringu := filesFilter := ""

  prevFilter := filesFilter
  backCurrentSLD := CurrentSLD
  userSearchString := CurrentSLD := ""
  friendly := (StrLen(stringu)>1) ? "Applying filter on the list of files, please wait`n" stringu : "Deactivating the files list filter, please wait..."
  showTOOLtip(friendly)
  setImageLoading()

  If StrLen(filesFilter)<2
  {
     thereWasFilter := 0
     bckpResultedFilesList := []
     bckpResultedFilesList := resultedFilesList.Clone()
     bckpCurrentFileIndex := currentFileIndex
     bckpMaxFilesIndex := maxFilesIndex
  } Else thereWasFilter := 1

  If (stringu="||Already-Seen-Images||")
  {
     CurrentSLD := backCurrentSLD
     retrieveAlreadySeenImageFromCurrentList()
     Return
  }

  If (noStringProcessing=0)
  {
     testRegEx := SubStr(stringu, 1, 2)
     If (InStr(stringu, "QPV::query") || InStr(stringu, "SQL:query"))
        filesFilter := stringu
     Else If (testRegEx!="\>")
        filesFilter := JEE_StrRegExLiteral(stringu)
     Else
        filesFilter := SubStr(stringu, 3)
  } Else filesFilter := stringu

  FilterFilesIndex(thereWasFilter, doExactFolderMatch, prevFilter)
  If (maxFilesIndex<1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "No files matched your filtering criteria:`n" stringu "`n`nThe application will now restore the complete list of files.", 0, 1, "exclamation")
     filesFilter := ""
     FilterFilesIndex(0, 0, 0)
  } Else SoundBeep, 900, 100

  CurrentSLD := backCurrentSLD
  If !filesFilter
  {
     ; ToolTip, haha , , , 2
     currentFileIndex := clampInRange(bckpCurrentFileIndex, 1, maxFilesIndex)
     If (maxFilesIndex>0 && doRandom=1)
        dummyTimerDelayiedImageDisplay(50)
  } Else If (maxFilesIndex>0 && doRandom=1)
  {
     ; SoundBeep 1200, 100
     currentFileIndex := 1
     dummyTimerDelayiedImageDisplay(50)
     ; RandomPicture()
  }

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

FilterFilesIndex(thereWasFilter:=0, doExactFolderMatch:=0, prevFilter:="") {
   If (InStr(prevFilter, "SQL:query:") && !InStr(filesFilter, "SQL:query:"))
   {
      BtnIndexStatsToList(0, 0, "none", 0) 
      If StrLen(filesFilter)<2
         Return
   }

   startZeit := A_TickCount
   selectedFiles := newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   mustDoQuery := 0
   If InStr(filesFilter, "QPV::query::")
   {
      queryObj := StrSplit(filesFilter, "::")
      queryType := queryObj[3]
      If (queryObj[5]="")
         queryObj[5] := queryObj[4]

      If (queryType="imgpixfmt" && queryObj[4])
      {
         queryMin := queryMax := queryObj[4]
         mustDoQuery := 1
      } Else If (queryType && !isNumber(queryType) && isNumber(queryObj[4]) && isNumber(queryObj[5]))
      {
         queryMin := min(Abs(queryObj[4]), Abs(queryObj[5]))
         queryMax := max(Abs(queryObj[4]), Abs(queryObj[5]))
         mustDoQuery := 1
      }

      queryString := Trimmer(queryObj[6])
      userFilterDoString := StrLen(queryString)>0 ? 1 : 0
      If (userFilterDoString!=1)
         queryString := 0

      If (mustDoQuery=1)
      {
         If RegExMatch(queryType, "i)(fsize|fmodified|fcreated)")
            r := collectFileInfosNow(queryString)
         Else If RegExMatch(queryType, "i)(imgpixfmt|imgwidth|imgheight|imgwhratio|imgmegapix|imgframes|imgdpi)")
            r := collectImageInfosNow(queryString, 9, 0)
         Else If RegExMatch(queryType, "i)(imgavg|imgmedian|imghpeak|imghlow|imghminu|imghmode|imghrms|imghrange)")
            r := collectImageInfosNow(queryString, 11, 0)

         If (r=1)
         {
            resultedFilesList := []
            resultedFilesList := bckpResultedFilesList.Clone()
            bckpResultedFilesList := []
            filesFilter := ""
            SoundBeep, 300, 100
            showTOOLtip("Operation abandoned. The files list was not filtered, because data collection did not complete.")
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }
      ; ToolTip, % queryType "=" queryMin "=" queryMax , , , 2
   }

   ; ToolTip, % filesFilter " = " userFilterWhat " = " userFilterStringIsNot , , , 2
   If (InStr(filesFilter, "SQL:query:WHERE") && SLDtypeLoaded=3)
   {
      If isInRange(userFilterProperty, 2, 4)
         collectSQLFileInfosNow("fsize", 0, 1, 0)
      Else If isInRange(userFilterProperty, 5, 10)
         collectSQLFileInfosNow("imgmegapix", 0, 1, 0)
      Else If isInRange(userFilterProperty, 11, 18)
         collectSQLFileInfosNow("imgmedian", 0, 1, 0)

      markedSelectFile := 0
      filteredMap2mainList := []
      extraFilter := extractSQLqueryFromFilter()
      r := BtnIndexStatsToList(0, extraFilter, "custom", extraFilter)
      If (r=-1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": WARNING", "No files matched the provided filter options:`n" filesFilter "`n`nThe application will now restore the complete list of files.", 0, 1, "exclamation")
         remFilesListFilter("simple")
      } Else bckpResultedFilesList := []
      Return
   } Else If InStr(filesFilter, "||Prev-Files-Selection||")
   {
      Loop, % maxFilesIndex + 1
      {
            r := resultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            If (resultedFilesList[A_Index, 2]!=1) ; is selected ?
               Continue

            newFilesIndex++
            newFilesList[newFilesIndex] := resultedFilesList[A_Index]
            If resultedFilesList[A_Index, 2]
               selectedFiles++

            If (thereWasFilter=1)
            {
               oldIndex := filteredMap2mainList[A_Index]
               newMappingList[newFilesIndex] := oldIndex
            } Else newMappingList[newFilesIndex] := A_Index
      }
   } Else
   {
      Loop, % bckpMaxFilesIndex + 1
      {
            r := bckpResultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            thisIndex++
            If (mustDoQuery=1)
            {
               If (userFilterDoString=1)
               {
                  If !coreSearchIndex(r, queryString, userFilterWhat, userFilterStringIsNot)
                     Continue
               }

               Switch queryType
               {
                  Case "fmodified":
                     valu := bckpResultedFilesList[A_Index, 7]
                  Case "fcreated":
                     valu := bckpResultedFilesList[A_Index, 8]
                  Case "fsize":
                     valu := bckpResultedFilesList[A_Index, 6]
                  Case "imgmegapix":
                     valu := Round(bckpResultedFilesList[A_Index, 17], 1)
                  Case "imgwidth":
                     valu := bckpResultedFilesList[A_Index, 13]
                  Case "imgheight":
                     valu := bckpResultedFilesList[A_Index, 14]
                  Case "imgpixfmt":
                     valu := bckpResultedFilesList[A_Index, 15]
                  Case "imgdpi":
                     valu := bckpResultedFilesList[A_Index, 22]
                  Case "imgframes":
                     valu := bckpResultedFilesList[A_Index, 9]
                  Case "imgwhratio":
                     valu := Round(bckpResultedFilesList[A_Index, 16], 1)
                  Case "imgmedian":
                     valu := bckpResultedFilesList[A_Index, 19]
                  Case "imgavg":
                     valu := bckpResultedFilesList[A_Index, 18]
                  Case "imghpeak":
                     valu := bckpResultedFilesList[A_Index, 20]
                  Case "imghlow":
                     valu := bckpResultedFilesList[A_Index, 21]
                  Case "imghrms":
                     valu := bckpResultedFilesList[A_Index, 24]
                  Case "imghrange":
                     valu := bckpResultedFilesList[A_Index, 25]
                  Case "imghmode":
                     valu := bckpResultedFilesList[A_Index, 26]
                  Case "imghminu":
                     valu := bckpResultedFilesList[A_Index, 27]
               }

               If !isInRange(valu, queryMin, queryMax)
                  Continue
            } Else If StrLen(filesFilter)>1
            {
               If !coreSearchIndex(r, filesFilter, userFilterWhat, userFilterStringIsNot)
                  Continue
            }

            newFilesIndex++
            newFilesList[newFilesIndex] := bckpResultedFilesList[A_Index]
            If bckpResultedFilesList[A_Index, 2]
               selectedFiles++

            If StrLen(filesFilter)>1
               newMappingList[newFilesIndex] := A_Index
      }
   }

   filteredMap2mainList := []
   renewCurrentFilesList()
   If StrLen(filesFilter)>1
      filteredMap2mainList := newMappingList.Clone()
   resultedFilesList := newFilesList.Clone()
   markedSelectFile := selectedFiles
   maxFilesIndex := newFilesIndex
   newFilesList := []
   newMappingList := []
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
   GenerateRandyList()
}

throwMSGwriteError() {
  Static lastInvoked := 1
  If (ErrorLevel=1) && (A_TickCount - lastInvoked>45100)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the settings files: permission denied.", 0, 0, "error")
     lastInvoked := A_TickCount
  }
}

updateMainUnfilteredList(indexu, indexProperty, value) {
   If (SLDtypeLoaded=3)
   {
      If InStr(filesFilter, "SQL:query:")
         Return
   }

   If StrLen(filesFilter)>1
      bckpResultedFilesList[filteredMap2mainList[indexu], indexProperty] := value
}

singleInListEntriesRemover() {
   InListMultiEntriesRemover("single")
}

InListMultiEntriesRemover(dummy:=0, dontAsk:=0) {
   filesElected := getSelectedFiles(0, 1)
   If (markedSelectFile>1)
      itMultiFiles := 1

   If (itMultiFiles!=1 || dummy="single")
   {
      remCurrentEntry(0, 0)
      Return
   }

   If (filesElected>500 && dontAsk!="y")
   {
      msgResult := msgBoxWrapper(appTitle, "Are you sure you want to remove " groupDigits(filesElected) " entries from the slideshow files list?", 4, 0, "question")
      If (msgResult!="yes")
         Return
   }

   startOperation := A_TickCount
   showTOOLtip("Removing " filesElected " index entries, please wait")
   prevMSGdisplay := A_TickCount
   ForceRefreshNowThumbsList()
   countTFilez := 0
   doStartLongOpDance()
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   updateMainu := (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:")) ? 1 : 0
   Loop, % maxFilesIndex + 1
   {
      thisFileIndex := A_Index ; - countTFilez
      isSelected := resultedFilesList[thisFileIndex, 2]
      imgPath := resultedFilesList[thisFileIndex, 1]
      If (preventDeleteMatchingSearch=1 && imgPath && userSearchString)
      {
         If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
            isSelected := 0
      }

      If (preventDeleteFromProtectedPath=1 && protectedFolderPath)
      {
         zPlitPath(imgPath, 0, OutFileName, OutDir)
         If (protectedFolderPath=OutDir)
            isSelected := 0
      }

      If (isSelected!=1 && imgPath)
      {
         newFilesIndex++
         newFilesList[newFilesIndex] := resultedFilesList[thisFileIndex]
         If (updateMainu=1)
            newMappingList[newFilesIndex] := filteredMap2mainList[thisFileIndex]

         Continue
      } Else If !imgPath
         Continue

      If (SLDtypeLoaded=3 && preventDBentryRemoval!=1)
         deleteSQLdbEntry(StrReplace(imgPath, "||"), resultedFilesList[thisFileIndex, 12])

      countTFilez++
      If (updateMainu=1)
         updateMainUnfilteredList(thisFileIndex, 1, "")

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If !startPoint
         startPoint := thisFileIndex
   }

   resultedFilesList := []
   resultedFilesList := newFilesList.Clone()
   maxFilesIndex := newFilesIndex
   newFilesList := []
   filteredMap2mainList := []
   If (updateMainu=1)
      filteredMap2mainList := newMappingList.Clone()

   newMappingList := []
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   } Else currentFilesListModified := 1

   GenerateRandyList()
   getSelectedFiles(0, 1)
   zeitOperation := A_TickCount - startOperation
   etaTime := "Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countTFilez " index entries were removed until now`n" etaTime)
   Else
      showTOOLtip(countTFilez " index entries removed`n" etaTime)

   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         changeMcursor()
         ; showTOOLtip("Removing files list index filter, please wait")
         remFilesListFilter("simple")
         dummyTimerDelayiedImageDisplay(50)
      } Else handleEmptyFilesList(CurrentSLD)
   } Else
   {
      startPoint--
      If (startPoint<2)
         startPoint := 1
      currentFileIndex := startPoint
      dummyTimerDelayiedImageDisplay(50)
   }

   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

remCurrentEntry(dummy, silentus:=0, whichIndex:=0) {
   Critical, on
   thisFileIndex := !whichIndex ? currentFileIndex : whichIndex
   file2remZ := resultedFilesList.RemoveAt(thisFileIndex)
   ; file2remA := file2remZ[1]
   If StrLen(filesFilter)>1
   {
      ; oldIndex :=  filteredMap2mainList[thisFileIndex]
      updateMainUnfilteredList(thisFileIndex, 1, "")
      file2remC := filteredMap2mainList.RemoveAt(thisFileIndex)
      ; file2remB := bckpResultedFilesList[oldIndex, 1]
      ; Sleep, 200
      ; ToolTip, % file2remC " b " oldIndex " a " file2remB "`n" file2remA, , , 2
   }

   If (SLDtypeLoaded=3 && preventDBentryRemoval!=1)
      deleteSQLdbEntry(StrReplace(file2remZ[1], "||"), file2remZ[12])

   currentFilesListModified := 1
   maxFilesIndex--
   ForceRefreshNowThumbsList()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (silentus!=1)
   {
      If (thumbsDisplaying!=1)
         Sleep, 100

      zPlitPath(StrReplace(file2remZ[1], "||"), 1, OutFileName, OutDir)
      showDelayedTooltip("Index entry removed: " groupDigits(thisFileIndex) "`n" OutFileName "`n" OutDir "\", 0, 250)
   }

   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         ; showTOOLtip("Removing files list index filter, please wait")
         remFilesListFilter("simple")
         dummyTimerDelayiedImageDisplay(50)
         ; RandomPicture()
      } Else handleEmptyFilesList(CurrentSLD)
   } Else 
   {
      currentFileIndex--
      NextPicture()
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

addSQLdbEntry(fileNamu, imgPath, fileSizu, fileMdate, fileCdate, simple:=0) {
   fileMdate := SubStr(fileMdate, 1, 12)
   fileCdate := SubStr(fileCdate, 1, 12)
   If (simple=1)
      SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder) VALUES (" sqlDBrowID ", 0, '" fileNamu "', '" imgPath "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
   Else
      SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder, fsize, fmodified, fcreated) VALUES (" sqlDBrowID ", 0, '" fileNamu "', '" imgPath "', '" fileSizu "', '" fileMdate "', '" fileCdate "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"

      ; ToolTip, % activeSQLdb.ErrorMsg " === " sqlDBrowID , , , 2
   If !activeSQLdb.Exec(SQLStr)
   {
      If InStr(activeSQLdb.ErrorMsg, "constraint failed")
         Return "err"

      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      If (simple=1)
         SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder) VALUES (" sqlDBrowID ", 0, " fileNamu ", " imgPath ") ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
      Else
         SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder, fsize, fmodified, fcreated) VALUES (" sqlDBrowID ", 0, " fileNamu ", " imgPath ", '" fileSizu "', '" fileMdate "', '" fileCdate "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
 
      If activeSQLdb.Exec(SQLStr)
         sqlDBrowID++
      Else Return "err"
   } Else sqlDBrowID++
}

updateSQLdbEntryImgRes(fullPath, imgResu, fileInfos, dbIndex, indexu:=0) {
   If (imgResu=1)
      thisPart := " imgpixfmt='" resultedFilesList[indexu, 15] "', imgframes='" resultedFilesList[indexu, 9] "', imgdpi='" resultedFilesList[indexu, 22] "', imgwidth='" resultedFilesList[indexu, 13] "', imgheight='" resultedFilesList[indexu, 14] "'"
   Else If (imgResu=2)
      thisPart := " imgpixfmt='" bckpResultedFilesList[indexu, 15] "', imgframes='" bckpResultedFilesList[indexu, 9] "', imgdpi='" bckpResultedFilesList[indexu, 22] "', imgwidth='" bckpResultedFilesList[indexu, 13] "', imgheight='" bckpResultedFilesList[indexu, 14] "'"
   Else
      thisPart := " imgdpi='" imgResu.dpi "', imgpixfmt='" imgResu.pixFmt "', imgframes='" imgResu.frames "', imgwidth='" imgResu.w "', imgheight='" imgResu.h "'"

   If (fileInfos=1)
      thisPart .= ", fsize='" resultedFilesList[indexu, 6] "', fmodified='" SubStr(resultedFilesList[indexu, 7], 1, 12) "', fcreated='" SubStr(resultedFilesList[indexu, 8], 1, 12) "'"
   Else If (fileInfos=2)
      thisPart .= ", fsize='" bckpResultedFilesList[indexu, 6] "', fmodified='" SubStr(bckpResultedFilesList[indexu, 7], 1, 12) "', fcreated='" SubStr(bckpResultedFilesList[indexu, 8], 1, 12) "'"
   Else If IsObject(fileInfos)
      thisPart .= ", fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      ; ToolTip, % A_ThisFunc "() failed to update l=" dbIndex , , , 2
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         fnOutputDebug(A_ThisFunc "() - failed commit in database: " fullPath)
         Return 0
      }
   } Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)

   Return 1
}

updateSQLdbEntryFileInfos(fullPath, fileInfos, dbIndex) {
   thisPart := " fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"
   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      ; ToolTip, % A_ThisFunc "() failed to update l=" dbIndex , , , 2
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         fnOutputDebug(A_ThisFunc "() - failed commit in database: " fullPath)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)
   Return 1
}

updateSQLdbEntryImgHisto(fullPath, obju, imgResu, fileInfos, dbIndex, indexu:=0) {
   If (obju=1)
      thisPart := " imgmedian='" resultedFilesList[indexu, 19] "', imgavg='" resultedFilesList[indexu, 18] "', imghpeak='" resultedFilesList[indexu, 20] "', imghlow='" resultedFilesList[indexu, 21] "', imghrms='" resultedFilesList[indexu, 24] "', imghrange='" resultedFilesList[indexu, 25] "',  imghmode='" resultedFilesList[indexu, 26] "', imghminu='" resultedFilesList[indexu, 27] "', outerpixelz='" resultedFilesList[indexu, 29] "', entireHush='" resultedFilesList[indexu, 30] "', innerpixelz='" resultedFilesList[indexu, 28] "'"
   Else If (obju=2)
      thisPart := " imgmedian='" bckpResultedFilesList[indexu, 19] "', imgavg='" bckpResultedFilesList[indexu, 18] "', imghpeak='" bckpResultedFilesList[indexu, 20] "', imghlow='" bckpResultedFilesList[indexu, 21] "', imghrms='" bckpResultedFilesList[indexu, 24] "', imghrange='" bckpResultedFilesList[indexu, 25] "',  imghmode='" bckpResultedFilesList[indexu, 26] "', imghminu='" bckpResultedFilesList[indexu, 27] "', outerpixelz='" bckpResultedFilesList[indexu, 29] "', entireHush='" bckpResultedFilesList[indexu, 30] "', innerpixelz='" bckpResultedFilesList[indexu, 28] "'"
   Else
      thisPart := " imgmedian='" obju.median "', imgavg='" obju.avg "', imghpeak='" obju.peak "', imghlow='" obju.low "', imghrms='" obju.rms "', imghrange='" obju.range "',  imghmode='" obju.mode "', imghminu='" obju.minu "', outerpixelz='" obju.outerpixelz "', entireHush='" obju.entireH "', innerpixelz='" obju.innerpixelz "'"

   If (imgResu=1)
      thisPart .= ", imgpixfmt='" resultedFilesList[indexu, 15] "', imgframes='" resultedFilesList[indexu, 9] "', imgdpi='" resultedFilesList[indexu, 22] "', imgwidth='" resultedFilesList[indexu, 13] "', imgheight='" resultedFilesList[indexu, 14] "'"
   Else If (imgResu=2)
      thisPart .= ", imgpixfmt='" bckpResultedFilesList[indexu, 15] "', imgframes='" bckpResultedFilesList[indexu, 9] "', imgdpi='" bckpResultedFilesList[indexu, 22] "', imgwidth='" bckpResultedFilesList[indexu, 13] "', imgheight='" bckpResultedFilesList[indexu, 14] "'"
   Else If IsObject(imgResu)
      thisPart .= ", imgdpi='" imgResu.dpi "', imgpixfmt='" imgResu.pixFmt "', imgframes='" imgResu.frames "', imgwidth='" imgResu.W "', imgheight='" imgResu.H "'"

   If (fileInfos=1)
      thisPart .= ", fsize='" resultedFilesList[indexu, 6] "', fmodified='" SubStr(resultedFilesList[indexu, 7], 1, 12) "', fcreated='" SubStr(resultedFilesList[indexu, 8], 1, 12) "'"
   Else If (fileInfos=2)
      thisPart .= ", fsize='" bckpResultedFilesList[indexu, 6] "', fmodified='" SubStr(bckpResultedFilesList[indexu, 7], 1, 12) "', fcreated='" SubStr(bckpResultedFilesList[indexu, 8], 1, 12) "'"
   Else If IsObject(fileInfos)
      thisPart .= ", fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         fnOutputDebug(A_ThisFunc "() - failed commit in database: " fullPath)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)

   Return 1
}

updateSQLdbEntryCaption(imgPath, txtData, whatSet) {
   activeSQLdb.EscapeStr(imgPath)
   activeSQLdb.EscapeStr(txtData)
   SQLstr := "INSERT INTO imagesData (imgfile) VALUES (" imgPath ");"
   activeSQLdb.Exec(SQLStr)
   SQLstr := "UPDATE imagesData SET " whatSet "=" txtData " WHERE imgfile=" imgPath ";"
   If !activeSQLdb.Exec(SQLStr)
      Return -1
}

retrieveSQLdbEntryCaption(imgPath, whatRetrieve) {
  If (SLDtypeLoaded!=3)
     Return

  RecordSet := ""
  activeSQLdb.EscapeStr(imgPath)
  SQL := "SELECT " whatRetrieve " FROM imagesData WHERE imgfile=" imgPath ";"
  If !activeSQLdb.GetTable(SQL, RecordSet)
     Return

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      entries .= Rowu[1] A_Space
  }

  RecordSet.Free()
  Return Trimmer(entries)
}

retrieveSQLdbEntryImgInfos(fullPath, imgIndex, dbIndex, modus) {
   Critical, on
   If (SLDtypeLoaded!=3)
      Return 0

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
   SQL := "SELECT imgwidth, imgheight, imgframes, imgpixfmt, imgmedian, imgavg, imghpeak, imghlow, imgdpi FROM images" wherePart
   yay := RecordSet := ""

   If !activeSQLdb.GetTable(SQL, RecordSet)
   {
      fnOutputDebug(A_ThisFunc "() - failed query in database: " fullPath)
      Return 0
   }
   ; ToolTip, % "l= " RecordSet.RowCount , , , 2
   If !RecordSet.RowCount
      Return 0

   Loop, % RecordSet.RowCount
   {
     Rowu := RecordSet.Rows[A_Index]
     If (Rowu[5] || Rowu[6] || Rowu[7])
     {
        countLoops++
        resultedFilesList[imgIndex, 19] := Rowu[5]
        resultedFilesList[imgIndex, 18] := Rowu[6]
        resultedFilesList[imgIndex, 20] := Rowu[7]
        resultedFilesList[imgIndex, 21] := Rowu[8]
     }

     ; ToolTip, % Row[1] " = " Row[5] , , , 2
     If (Rowu[1] && Rowu[2])
     {
        countLoops++
        resultedFilesList[imgIndex, 13] := Rowu[1]
        resultedFilesList[imgIndex, 14] := Rowu[2]
        resultedFilesList[imgIndex, 15] := Rowu[4]
        resultedFilesList[imgIndex, 9] := Rowu[3]
        resultedFilesList[imgIndex, 22] := Rowu[9]
     }
   }

  RecordSet.Free()
  If !countLoops
     fnOutputDebug(A_ThisFunc "() - no cache in database: " fullPath)

  Return yay
}

updateSQLdbEntry(oldEntry, newEntry, updateDates, dbIndex) {
   If (updateDates=1)
      obju := GetFileAttributesEx(newEntry)

   If !dbIndex
      activeSQLdb.EscapeStr(oldEntry)

   zPlitPath(newEntry, 1, newFileName, newFilePath)
   extra := (updateDates=1) ? ", fmodified=" SubStr(obju.wTime, 1, 12) ", fcreated=" SubStr(obju.cTime, 1, 12) ", fsize=" obju.size : ""
   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" oldEntry ";"
   SQLstr := "UPDATE images SET isDeleted=0, imgfile='" SQLescapeStr(newFileName) "', imgfolder='" SQLescapeStr(newFilePath) "'" extra wherePart
   If !activeSQLdb.Exec(SQLstr)
   {
      zPlitPath(oldEntry, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      activeSQLdb.EscapeStr(newFileName)
      activeSQLdb.EscapeStr(newFilePath)
      SQLstr := "UPDATE images SET isDeleted=0, imgfile=" newFileName ", imgfolder=" newFilePath extra " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
         Return 0
   }
   Return 1
}

SQLdeleteEntriesMarked() {
    SQLstr := "DELETE FROM images WHERE isDeleted=1;"
    If !activeSQLdb.Exec(SQLStr)
       throwSQLqueryDBerror(A_ThisFunc)
    Else
       getMaxRowIDsqlDB()
}

deleteSQLdbEntry(fullPath, dbIndex) {
  If !dbIndex
     activeSQLdb.EscapeStr(fullPath)

  wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath ";"
  SQLstr := "DELETE FROM images" wherePart
  If !activeSQLdb.Exec(SQLStr)
  {
     zPlitPath(fullPath, 1, fileNamu, imgPath)
     activeSQLdb.EscapeStr(fileNamu)
     activeSQLdb.EscapeStr(imgPath)
     SQLstr := "DELETE FROM images WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
     activeSQLdb.Exec(SQLStr)
  }
}

openFileDialogWrapper(p_Type, optionz, startPath, msg, pattern, ByRef n_FilterIndex:="", chooseFilterIndex:=1, defaultEditField:="") {
   doSuspendu(1)
   thisHwnd := (AnyWindowOpen) ? hSetWinGui : PVhwnd
   ; If (p_type="o")
   ;    pattern .= "|All files (*.*)"

   If FolderExist(startPath)
      pathSymbol := "\"

   If !chooseFilterIndex
      chooseFilterIndex := 1

   optionz .= " NoChangeDir HideReadOnly"
   If InStr(p_type, "o")
   {
      entriesList := defaultu "`n" recentOpenedFolders()
      If (p_type="o1")
      {
         thisCombo := "Open selected file only"
         thisCombo .= "`nOpen in a new QPV instance"
         thisCombo .= "`nIndex all images in current folder as well"
         thisCombo .= "`nPerform recursive folder(s) scan to index images"
         thisGroup := "Open mode"
      }

      FileMustExist := InStr(optionz, "FileMustExist") ? 1 : 0
      zr := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, thisCombo, 1, thisGroup, entriesList, 0, pattern, chooseFilterIndex, FileMustExist, defaultEditField)
      r := zr.SelectedDir
      n_FilterIndex := zr.SelectedCombo
   } Else
   {
      If InStr(p_type, "m")
         p_Type := "o"

      r := Dlg_OpenSaveFile(p_Type, thisHwnd, msg, pattern, chooseFilterIndex, startPath pathSymbol, "", optionz)
      n_FilterIndex := NumGet(optionz, (A_PtrSize=8) ? 44:24,"UInt")
   }
   r := Trimmer(r)
   If StrLen(r)<4
      r := ""

   SetWorkingDir, % mainCompiledPath
   SetTimer, dummyUnSuspendu, -150, 900
   lastLongOperationAbort := A_TickCount
   Return r
}

WritePrefsIntoSLD() {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   startPath := !CurrentSLD ? prevOpenFolderPath : CurrentSLD
   file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save slideshow settings into file...", "Slideshow plain-text (*.sld)")
   If file2save
   {
      If !RegExMatch(file2save, sldsPattern)
         file2save .= ".sld"

      FileReadLine, firstLine, % file2save, 1
      If InStr(firstLine, "[General]")
      {
         Sleep, 10
         writeSlideSettings(file2save)
      } Else 
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgBoxWrapper(appTitle ": ERROR", "The selected file appears not to have the correct file format.`nPlease select a .SLD file already saved by this application.`n`n" OutFileName, 0, 0, "error")
      }
   }
}

recreateDynaFoldersSQLdbList(saveDynaFolders) {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM dynamicfolders;")
   Loop, Parse, saveDynaFolders, `n
   {
       If StrLen(A_LoopField)>2
          addDynamicFolderSQLdb(Trimmer(A_LoopField), 0, "dynamicfolders")
   }

   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

saveSlideSettingsInDB() {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM settings;")
   IniSLDBWrite("SLDcacheFilesList", 1)
   IniSLDBWrite("IMGresizingMode", IMGresizingMode)
   IniSLDBWrite("imgFxMode", imgFxMode)
   IniSLDBWrite("SlideHowMode", SlideHowMode)
   IniSLDBWrite("slideShowDelay", slideShowDelay)
   IniSLDBWrite("slidesFXrandomize", slidesFXrandomize)
   IniSLDBWrite("zoomLevel", zoomLevel)
   IniSLDBWrite("vpIMGrotation", vpIMGrotation)
   IniSLDBWrite("doSlidesTransitions", doSlidesTransitions)
   IniSLDBWrite("WindowBgrColor", WindowBgrColor)
   IniSLDBWrite("FlipImgH", FlipImgH)
   IniSLDBWrite("FlipImgV", FlipImgV)
   IniSLDBWrite("usrColorDepth", usrColorDepth)
   IniSLDBWrite("ColorDepthDithering", ColorDepthDithering)
   IniSLDBWrite("lumosAdjust", lumosAdjust)
   IniSLDBWrite("GammosAdjust", GammosAdjust)
   IniSLDBWrite("lumosGrayAdjust", lumosGrayAdjust)
   IniSLDBWrite("GammosGrayAdjust", GammosGrayAdjust)
   IniSLDBWrite("satAdjust", satAdjust)
   IniSLDBWrite("imageAligned", imageAligned)
   IniSLDBWrite("doSatAdjusts", doSatAdjusts)
   IniSLDBWrite("autoAdjustMode", autoAdjustMode)
   IniSLDBWrite("chnRdecalage", chnRdecalage)
   IniSLDBWrite("chnGdecalage", chnGdecalage)
   IniSLDBWrite("chnBdecalage", chnBdecalage)
   IniSLDBWrite("IntensityAlphaChannel", IntensityAlphaChannel)
   IniSLDBWrite("usrAdaptiveThreshold", usrAdaptiveThreshold)
   ; IniSLDBWrite("noTooltipMSGs", noTooltipMSGs)
   IniSLDBWrite("TouchScreenMode", TouchScreenMode)
   IniSLDBWrite("skipDeadFiles", skipDeadFiles)
   IniSLDBWrite("isAlwaysOnTop", isAlwaysOnTop)
   IniSLDBWrite("bwDithering", bwDithering)
   IniSLDBWrite("zatAdjust", zatAdjust)
   IniSLDBWrite("hueAdjust", hueAdjust)
   IniSLDBWrite("realGammos", realGammos)
   IniSLDBWrite("imgThreshold", imgThreshold)
   IniSLDBWrite("isTitleBarHidden", isTitleBarHidden)
   IniSLDBWrite("animGIFsSupport", animGIFsSupport)
   IniSLDBWrite("thumbsAratio", thumbsAratio)
   IniSLDBWrite("thumbsZoomLevel", thumbsZoomLevel)
   IniSLDBWrite("easySlideStoppage", easySlideStoppage)
   IniSLDBWrite("appVersion", appVersion)
   IniSLDBWrite("usrTextureBGR", usrTextureBGR)
   IniSLDBWrite("syncSlideShow2Audios", syncSlideShow2Audios)
   IniSLDBWrite("autoPlaySNDs", autoPlaySNDs)
   IniSLDBWrite("mediaSNDvolume", mediaSNDvolume)
   IniSLDBWrite("reverseOrderOnSort", reverseOrderOnSort)
   IniSLDBWrite("borderAroundImage", borderAroundImage)
   IniSLDBWrite("resetImageViewOnChange", resetImageViewOnChange)
   IniSLDBWrite("showImgAnnotations", showImgAnnotations)
   IniSLDBWrite("allowGIFsPlayEntirely", allowGIFsPlayEntirely)
   IniSLDBWrite("prevFilesSortMode", prevFilesSortMode)
   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

IniSLDBwrite(what, value, whichTable:="settings") {
    SQLstr := "INSERT INTO " whichTable " (paramz, valuez) VALUES ('" what "', '" value "');"
    Return activeSQLdb.Exec(SQLStr)
}

IniSLDBreadAll(givenFilter:="", whichTable:="settings") {
  startOperation := A_TickCount
  SQL := "SELECT paramz, valuez FROM " whichTable ";"
  RecordSet := ""

  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "(): failed to read settings from SQL database")
     Return -1
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If StrLen(Rowu[1])>2
      {
         paramu := Rowu[1]
         valu := Rowu[2]
         If (StrLen(valu)>0 && (MustLoadSLDprefs=1 || paramu=givenFilter))
            %paramu% := valu
      }
  }

  If (isWinXP=1 || minimizeMemUsage=1)
     doSlidesTransitions := 0

  RecordSet.Free()
}

SQLdbGenerateStaticFolders() {
   If (SLDtypeLoaded=2)
   {
      BTNignoreSelFolder("update-all")
      Return
   }

   If AnyWindowOpen
      BtnCloseWindow()
   Sleep, 5
   activeSQLdb.Exec("DELETE FROM staticfolders;")
   SQL := "SELECT DISTINCT imgfolder FROM images;"
   RecordSet := ""
   FoldersArray := []
   If !activeSQLdb.GetTable(SQL, RecordSet)
   {
      SoundBeep, 300, 100
      addJournalEntry("Failed to execute SQL command in order to generate the static folders list from the indexed files.")
      Return
   }

   activeSQLdb.Exec("BEGIN TRANSACTION;")
   Loop, % RecordSet.RowCount
   {
       Rowu := RecordSet.Rows[A_Index]
       thisFolder := Trimmer(Rowu[1])
       If StrLen(thisFolder)>2
          addDynamicFolderSQLdb(thisFolder, 0, "staticfolders")
   }

   RecordSet.Free()
   If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      throwSQLqueryDBerror(A_ThisFunc)
}

getDynamicFoldersList(fileu:=0) {
   If !fileu
      fileu := RegExMatch(CurrentSLD, sldsPattern) ? CurrentSLD : ""

   listu := (fileu && FileExist(fileu) && InStr(DynamicFoldersList, "|hexists|")) ? coreLoadDynaFolders(fileu) : DynamicFoldersList
   listu := StrReplace(listu, "|hexists|")
   Sort, listu, UD`n
   Return listu
}

SaveDBfilesList(enforceFile:=0) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (maxFilesIndex>1)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save slideshow", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nTo save as a slideshow the entire list of files, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel")
            Return
      }
      If !FileRexists(enforceFile)
      {
         fileWasGiven := 0
         zPlitPath(CurrentSLD, 0, OutFileName, OutDir, OutFileNameNoExt)
         file2save := openFileDialogWrapper("S", "PathMustExist", OutDir "\" OutFileNameNoExt, "Save files list as SQL slideshow database...", "Slideshow database (*.sldb)")
         If (!RegExMatch(file2save, "i)(.\.sldb)$") && file2save)
            file2save .= ".sldb"
      } Else
      {
         fileWasGiven := 1
         file2save := enforceFile
      }
   } Else Return

   If !file2save
      Return

   o_SLDtypeLoaded := SLDtypeLoaded
   If AnyWindowOpen
      BtnCloseWindow()
   Sleep, 10
   startOperation := A_TickCount
   If ((SLDtypeLoaded=1 || SLDtypeLoaded=2) && file2save)
   {
      activeSQLdb.CloseDB()
      If FileExist(file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult="Yes")
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            Try FileDelete, %file2save%
            Catch wasErrorB
                  Sleep, 1
         } Else
         {
            SetTimer, PanelSaveSlideShowu, -200
            Return
         }

         If wasErrorB
         {
            msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file. Permission denied.", 0, 0, "error")
            SetTimer, PanelSaveSlideShowu, -200
            Return
         }
      }

      err := SLDbInitSQLdb(file2save)
      If err
      {
         msgBoxWrapper(appTitle ": ERROR", "Unable to create SQL database file. Fatal error. Please choose the plain-text format to save the files list (slideshow).`n`nError details: " err, 0, 0, "error")
         SetTimer, PanelSaveSlideShowu, -200
         Return
      }

      setImageLoading()
      setWindowTitle("Saving SQL files list database, please wait", 1)
      showTOOLtip("Saving list of " groupDigits(maxFilesIndex) " entries into SQL database`n" file2save "`nPlease wait")
      saveDynaFolders := getDynamicFoldersList()
      recreateDynaFoldersSQLdbList(saveDynaFolders)
      saveSlideSettingsInDB()
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      staticFoldersListu := ""
      currentFilesListModified := 0
      If (SLDcacheFilesList=1 && SLDtypeLoaded=2 && ForceRegenStaticFolders!=1)
      {
         populatedStaticFolders := 1
         rawstaticFoldersListu := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
         Loop, % countStaticFolders
         {
             staticFoldersListu .= rawstaticFoldersListu[A_Index, 1] "`n"
             addStaticFolderSQLdb(rawstaticFoldersListu[A_Index, 1], rawstaticFoldersListu[A_Index, 2], 0)
         }
      }

      showTOOLtip("Saving list of " groupDigits(maxFilesIndex) " entries in the SQL database`n" file2save "`nPlease wait", 0, 0, 3/100)
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)

      doStartLongOpDance()
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      prevMSGdisplay := A_TickCount
      sqlDBrowID := 1
      Loop, % maxFilesIndex
      {
         imgPath := resultedFilesList[A_Index, 1]
         zPlitPath(imgPath, 1, OutFileName, OutDir)
         
         ; fileInfos := GetFileAttributesEx(imgPath)
         If (resultedFilesList[A_Index, 6] && resultedFilesList[A_Index, 7])
            addSQLdbEntry(OutFileName, OutDir, resultedFilesList[A_Index, 6], resultedFilesList[A_Index, 7], resultedFilesList[A_Index, 8])
         Else
            addSQLdbEntry(OutFileName, OutDir, 0, 0, 0, 1)

         resultedFilesList[A_Index, 12] := sqlDBrowID
         If (resultedFilesList[A_Index, 11] && resultedFilesList[A_Index, 13])
         {
            updateSQLdbEntryImgHisto(imgPath, 1, 1, 0, sqlDBrowID, A_Index)
         } Else
         {
            If resultedFilesList[A_Index, 11]
               updateSQLdbEntryImgHisto(imgPath, 1, 0, 0, sqlDBrowID, A_Index)
            If resultedFilesList[A_Index, 13]
               updateSQLdbEntryImgRes(imgPath, 1, 0, sqlDBrowID, A_Index)
         }

         If (A_TickCount - prevMSGdisplay>1500)
         {
            etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
            showTOOLtip("Inserting entries into the SQL database`n" file2save etaTime, 0, 0, A_Index/maxFilesIndex)
            prevMSGdisplay := A_TickCount
         }

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
          }
      }

      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)

      ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
      If (populatedStaticFolders!=1)
         SQLdbGenerateStaticFolders()

      If (abandonAll!=1)
      {
         getMaxRowIDsqlDB()
         CurrentSLD := file2save
         SLDtypeLoaded := 3
      } Else activeSQLdb.CloseDB()

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      dummyTimerDelayiedImageDisplay(50)
      RemoveTooltip()
   } Else If (CurrentSLD=file2save && SLDtypeLoaded=3)
   {
      showTOOLtip("Saving SQL files list database, please wait")
      If (ForceRegenStaticFolders=1 && fileWasGiven=0)
      {
         showTOOLtip("Regenerating static folders index")
         SQLdbGenerateStaticFolders()
      }

      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      getMaxRowIDsqlDB()
      showTOOLtip("Slideshow database saved")
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else If (CurrentSLD!=file2save && SLDtypeLoaded=3)
   {
      activeSQLdb.CloseDB()
      Sleep, 5
      FileCopy, % CurrentSLD, % file2save, 1
      Sleep, 5
      activeSQLdb := new SQLiteDB
      If !activeSQLdb.OpenDB(file2save)
      {
         showTOOLtip("ERROR: Failed to save the slideshow database")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return -1
      }

      If (ForceRegenStaticFolders=1)
      {
         showTOOLtip("Regenerating static folders index")
         SQLdbGenerateStaticFolders()
      }

      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      CurrentSLD := file2save
      getMaxRowIDsqlDB()
      showTOOLtip("Slideshow database saved")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }

   etaTime := "Elapsed time to save the SQL database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

SaveFilesList(enforceFile:=0) {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (!CurrentSLD || maxFilesIndex<2)
   {
      showTOOLtip("WARNING: No files presently indexed")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (maxFilesIndex>0)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save slideshow", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nTo save as a slideshow the entire list of files, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel")
            Return
      }
      If !FileRexists(enforceFile)
      {
         fileWasGiven := 0
         zPlitPath(CurrentSLD, 0, OutFileName, OutDir, OutFileNameNoExt)
         file2save := openFileDialogWrapper("S", "PathMustExist", OutDir "\" OutFileNameNoExt, "Save files list as plain-text slideshow...", "Slideshow plain-text (*.sld)")
         If (!RegExMatch(file2save, "i)(.\.sld)$") && file2save)
            file2save .= ".sld"
      } Else
      {
         fileWasGiven := 1
         file2save := enforceFile
      }
   } Else
   {
      showTOOLtip("WARNING: Insufficient files added to index")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir)
      If FileExist(file2save)
      {
         If !fileWasGiven
            msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")

         If (msgResult="Yes" || fileWasGiven=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            If (file2save=CurrentSLD)
            {
               newTmpFile := file2save "-bkcp"
               Try FileMove, %file2save%, %newTmpFile%, 1
               Catch wasErrorA
                     Sleep, 1
            } Else
            {
               Try FileDelete, %file2save%
               Catch wasErrorB
                     Sleep, 1
            }

            If (wasErrorA || wasErrorB)
            {
               msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file. Permission denied or another error occured.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
               Return
            }
         } Else Return
      }

      Sleep, 2
      BtnCloseWindow()
      writeSlideSettings(file2save)
      mainFile := FileOpen(file2save, "a", "UTF-16")
      If !IsObject(mainFile)
      {
         msgBoxWrapper(appTitle ": ERROR", "Unable to write file in the given location. Permission denied or another error occured.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
         Return
      }

      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setImageLoading()
      Sleep, 10
      setWindowTitle("Saving files list index, please wait", 1)
      If (SLDcacheFilesList=1)
         showTOOLtip("Saving list of " groupDigits(maxFilesIndex) " entries into`n" file2save "`nPlease wait")
      Else
         showTOOLtip("Saving folders index in`n" file2save "`nPlease wait")

      thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
      ; ToolTip, % thisTmpFile "=" , , , 2

      saveDynaFolders := getDynamicFoldersList(thisTmpFile)
      mainFile.Write("`n[DynamicFolderz]`n")
      Loop, Parse, saveDynaFolders, `n
      {
          fileTest := StrReplace(A_LoopField, "|")
          If !FolderExist(fileTest)
             Continue

          countDynas++
          mainFile.Write("DF" countDynas "=" A_LoopField "`n")
          changeMcursor()
      }

      If (SLDcacheFilesList=0)
         ForceRegenStaticFolders := mustGenerateStaticFolders := 0

      foldersListArray := new hashtable()
      If (mustGenerateStaticFolders=1 || ForceRegenStaticFolders=1) && (SLDcacheFilesList=1)
      {
         ; filesListu .= printLargeStrArray(resultedFilesList, maxFilesIndex + 1, "`n")
         Loop, % maxFilesIndex + 1
         {
              r := getIDimage(A_Index)
              If (InStr(r, "||") || !r)
                 Continue

              changeMcursor()
              zPlitPath(r, 1, irrelevantVar, OutDir)
              foldersListArray[Format("{:L}", OutDir)] := 1
         }
      }

      changeMcursor()
      mainFile.Write("`n[Folders]`n")
      If (mustGenerateStaticFolders=1 || ForceRegenStaticFolders=1) && (SLDcacheFilesList=1)
      {
         ForceRegenStaticFolders := 0
         ; Loop, Parse, foldersList, `n
         For Key, Value in foldersListArray
         {
             If !Key
                Continue

             FileGetTime, dirDate, % Key, M
             mainFile.Write("Fi" A_Index "=" dirDate "*&*" Key "`n")
             changeMcursor()
         }
      } Else If (SLDcacheFilesList=1)
      {
         thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
         arrayList := LoadStaticFoldersCached(thisTmpFile, countStaticFolders, 1)
         Loop, % countStaticFolders
               mainFile.Write("Fi" A_Index "=" arrayList[A_Index, 2] "*&*" arrayList[A_Index, 1] "`n")
      }

      foldersListArray := ""
      mainFile.Write("`n[FilesList]`n")
      If (SLDcacheFilesList=1)
      {
         Loop, % maxFilesIndex
         {
            r := resultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue
            mainFile.Write(r "`n")
         }
      }

      mainFile.Close()
      currentFilesListModified := 0
      SLDtypeLoaded := 2
      FileDelete, % newTmpFile
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      CurrentSLD := file2save
      DynamicFoldersList := "|hexists|"
      mustGenerateStaticFolders := 0
      etaTime := "Elapsed time to save plain-text files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
      addJournalEntry(etaTime)
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % wasErrorC ? 300 : 900, 100
      If wasErrorC
         msgBoxWrapper(appTitle ": ERROR", "Errors occured when writing the files list to disk. Permission denied or not enough disk space.", 0, 0, "error")
      dummyTimerDelayiedImageDisplay(50)
   }
}

LoadStaticFoldersCached(fileNamu, ByRef countStaticFolders, asArray:=0) {
    countStaticFolders := 0
    arrayList := []
    If (SLDtypeLoaded=3)
    {
       SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
       If !activeSQLdb.GetTable(SQL, RecordSet)
       {
          throwSQLqueryDBerror(A_ThisFunc)
          Return 0
       }

       newStaticFoldersListCache := []
       hash := new hashtable()
       Loop, % RecordSet.RowCount
       {
           Rowu := RecordSet.Rows[A_Index]
           z := Format("{:L}", Rowu[1])
           If (StrLen(Rowu[1])>3 && hash[z]!=1)
           {
              hash[z] := 1
              countStaticFolders++
              newStaticFoldersListCache[countStaticFolders] := [Rowu[1], Rowu[2]]
           }
       }

       RecordSet.Free()
       hash := ""
       Return newStaticFoldersListCache.Clone()
    }

    If StrLen(newStaticFoldersListCache[1, 1])>4
    {
       countStaticFolders := newStaticFoldersListCache.Count()
       Return newStaticFoldersListCache.Clone()
    }

    FileRead, tehFileVar, %fileNamu%
    newStaticFoldersListCache := []
    hash := new hashtable()
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(Fi[0-9].*\=.{14}\*\&\*[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
       {
          lineArru := StrSplit(line, "*&*")
          folderu := lineArru[2]
          oldDateu := lineArru[1]
          oldDateu := SubStr(oldDateu, InStr(oldDateu, "=")+1)
          z := Format("{:L}", folderu)
          If (StrLen(folderu)>3 && StrLen(oldDateu)>3 && hash[z]!=1)
          {
             hash[z] := 1
             countStaticFolders++
             newStaticFoldersListCache[countStaticFolders] := [folderu, oldDateu]
             changeMcursor()
          }
       }
    }
    hash := ""
    changeMcursor("normal")
    Return newStaticFoldersListCache.Clone()
}

determineTerminateOperation() {
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 200)
     Return 0

  lastInvoked := A_TickCount
  theEnd := interfaceThread.ahkgetvar.mustAbandonCurrentOperations
  If theEnd
     lastLongOperationAbort := A_TickCount
  Return theEnd
}

doStartLongOpDance() {
     startLongOperation := A_TickCount
     imageLoading := runningLongOperation := 1
     interfaceThread.ahkassign("mustAbandonCurrentOperations", 0)
     interfaceThread.ahkassign("lastCloseInvoked", 0)
     interfaceThread.ahkassign("imageLoading", 1)
     interfaceThread.ahkassign("runningLongOperation", 1)
     interfaceThread.ahkassign("executingCanceableOperation", A_TickCount)
     interfaceThread.ahkPostFunction("setTaskbarIconState", "anim")
}

cleanDeadFilesList(dummy:=0) {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (maxFilesIndex>1)
   {
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      startOperation := A_TickCount
      friendlyLabel := (dummy="noFilesCheck") ? "Removing duplicate entries" : "Scanning for missing files"
      setWindowTitle(friendlyLabel ", please wait", 1)
      showTOOLtip(friendlyLabel ", please wait")
      prevMSGdisplay := A_TickCount
      doStartLongOpDance()
      If (InStr(backCurrentSLD, mainCompiledPath "\viewed-images-history-") && !InStr(backCurrentSLD, "-viewed-images-history-current-session"))
         CleanDeadFilesSeenImagesDB("yesu", StrReplace(backCurrentSLD, mainCompiledPath))
      Else If (SLDtypeLoaded=3)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      countTFilez := deadFiles := newFilesIndex := 0
      newFilesList := []
      newMappingList := []
      hash := new hashtable(maxFilesIndex)
      updateMainu := (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:")) ? 1 : 0
      skipDuplicatesCheck := (SLDtypeLoaded=3) ? 1 : 0
      Loop, % maxFilesIndex
      {
            imgPath := resultedFilesList[A_Index, 1]
            If !imgPath
               Continue

            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               skipDuplicatesCheck := 1
               abandonAll := 1
               Break
            }

            If (A_TickCount - prevMSGdisplay>1500)
            {
               etaTime := ETAinfos(countTFilez + deadFiles, maxFilesIndex, startOperation)
               showTOOLtip(friendlyLabel ", please wait" etaTime "`nFound " groupDigits(deadFiles) " dead files", 0, 0, (countTFilez+deadFiles)/maxFilesIndex)
               prevMSGdisplay := A_TickCount
            }

            If (skipDuplicatesCheck!=1)
            {
               z := Format("{:L}", imgPath)
               w := hash[z]
            }

            If ((w!=1 || skipDuplicatesCheck=1) && !InStr(imgPath, "||"))
            {
               If (skipDuplicatesCheck!=1 && w!=1)
                  hash[z] := 1

               If (dummy="noFilesCheck")
                  okayu := 1
               Else
                  okayu := (abandonAll=1) ? -2 : FileRexists(imgPath)

               If (okayu=-2 || okayu=1)
               {
                  countTFilez++
                  newFilesList[countTFilez] := resultedFilesList[A_Index]
                  If (updateMainu=1)
                     newMappingList[countTFilez] := filteredMap2mainList[A_Index]
                  Continue
               } Else deadFiles++
            } Else deadFiles++

            If (SLDtypeLoaded=3)
               deleteSQLdbEntry(StrReplace(imgPath, "||"), resultedFilesList[A_Index, 12])

            If (updateMainu=1)
               updateMainUnfilteredList(A_Index, 1, "")

            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               skipDuplicatesCheck := 1
               abandonAll := 1
               Break
            }
      }

      hash := ""
      If (abandonAll!=1)
      {
         resultedFilesList := []
         resultedFilesList := newFilesList.Clone()
         maxFilesIndex := countTFilez
         newFilesList := []
         filteredMap2mainList := []
         If (updateMainu=1)
            filteredMap2mainList := newMappingList.Clone()

         newMappingList := []
         GenerateRandyList()
      }

      If (SLDtypeLoaded=3)
      {
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            throwSQLqueryDBerror(A_ThisFunc)
      }

      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(deadFiles) " index entries were removed until now" etaTime)
      Else
         showTOOLtip(groupDigits(deadFiles) " index entries removed" etaTime)

      If (maxFilesIndex<1 && StrLen(filesFilter)>1)
      {
         remFilesListFilter("simple")
      } Else If (maxFilesIndex<1 && StrLen(filesFilter)<2)
      {
         handleEmptyFilesList(backCurrentSLD)
         Return
      }

      ForceRefreshNowThumbsList()
      getSelectedFiles(0, 1)
      If deadFiles
         currentFilesListModified := 1
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      CurrentSLD := backCurrentSLD
      currentFileIndex := clampInRange(currentFileIndex, 1, maxFilesIndex)
      dummyTimerDelayiedImageDisplay(50)
      ; RandomPicture()
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

handleEmptyFilesList(thisSLD, extraInfo:=""){
   FadeMainWindow()
   SoundBeep, 300, 100
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
   showButtons := ((RegExMatch(thisSLD, sldsPattern) && FileExist(thisSLD)) || FolderExist(thisSLD) || InStr(thisSLD, "\QPV\favourite-images-list.SLD")) ? "&Reload current list|&Continue" : 0

   If showButtons
      info := "`n`nCurrent files list:`n" thisSLD

   msgResult := msgBoxWrapper(appTitle ": WARNING", "No files left in the index of " appTitle ", please load a files list or folder." info extraInfo, showButtons, 0, "info")
   If InStr(msgResult, "reload")
   {
      CurrentSLD := thisSLD
      currentFilesListModified := 0
      RefreshFilesList()
   } Else ; If (thumbsDisplaying=1)
   {
      currentFilesListModified := 0
      ; ToggleThumbsMode()
      ; FadeMainWindow()
      closeDocuments()
      ; resetMainWin2Welcome()
   }
}

removeFilesListSeenImages() {
   ; Critical, on
   Static hasAskedFilter := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   countSeen := 0
   WnoFilesCheck := (noFilesCheck=2) ? 2 : 0
   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and already seen images will be removed from the files list")
         Return

      If (StrLen(filesFilter)>1 && hasAskedFilter=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Remove seen images from index", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nOnly the files matched by current filter will be scanned.`n`nTo remove all seen image files from the index, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel")
            Return
         Else hasAskedFilter := 1
      }

      remFromDb := 1
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setWindowTitle("Removing already seen images, please wait", 1)
      showTOOLtip("Removing already seen images`nGathering data, please wait")
      setImageLoading()
      seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)
      If (totalSeenIMGs<3)
      {
         seenEntries := ""
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         CurrentSLD := backCurrentSLD
         If (SLDtypeLoaded=3)
         {
            If !activeSQLdb.Exec("COMMIT TRANSACTION;")
               throwSQLqueryDBerror(A_ThisFunc)
         }
         dummyTimerDelayiedImageDisplay(50)
         etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
         showTOOLtip("Finished removing already seen images`nNo image was removed from the files list" etaTime)
         SetTimer, RemoveTooltip, % -msgDisplayTime//2
         Return
      }

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      showTOOLtip("Removing already seen images, please wait" etaTime)
      doStartLongOpDance()
      newArrayu := []
      newFilesIndex := 0
      If (SLDtypeLoaded=3)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      Loop, % maxFilesIndex + 1
      {
          r := getIDimage(A_Index)
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Checking for already seen images, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          If (seenEntries[Format("{:L}", r)]=1)
          {
             If (SLDtypeLoaded=3 && remFromDb=1)
                deleteSQLdbEntry(r, resultedFilesList[A_Index, 12])

             If StrLen(filesFilter)>1
                updateMainUnfilteredList(A_Index, 1, "")

             countSeen++
             Continue
          }

          newFilesIndex++
          newArrayu[newFilesIndex] := resultedFilesList[A_Index]
          If resultedFilesList[A_Index, 2]
             selectedFiles++

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (!activeSQLdb.Exec("COMMIT TRANSACTION;") && SLDtypeLoaded=3)
         throwSQLqueryDBerror(A_ThisFunc)

      If (abandonAll=1)
      {
         If (SLDtypeLoaded=3)
            showTOOLtip("Operation aborted. " groupDigits(countSeen) " already removed until now from the database.")
         Else
            showTOOLtip("Operation aborted. Files list left unchanged, no index entries removed.")

         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         newArrayu := ""
         dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         Return
      }

      If (newFilesIndex<1)
      {
         showTOOLtip("WARNING: All images files were seen.`nTherefore, the files list is left unchanged.")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         dummyTimerDelayiedImageDisplay(50)
         SetTimer, ResetImgLoadStatus, -150
         Return
      }

      ; renewCurrentFilesList()
      currentFilesListModified := 1
      maxFilesIndex := newFilesIndex
      resultedFilesList := newArrayu.Clone()
      markedSelectFile := selectedFiles
      ForceRefreshNowThumbsList()
      newArrayu := ""
      GenerateRandyList()
      getSelectedFiles(0, 1)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      RandomPicture()
      showDelayedTooltip("Finished removing already seen images`n" groupDigits(countSeen) " images were removed from the files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

retrieveAlreadySeenImageFromCurrentList() {
   ; Critical, on

   If (slideShowRunning=1)
      ToggleSlideShowu()

   initSeenImagesListDB()
   If (sqlFailedInit=1)
   {
      showTOOLtip("ERROR: Failed to initialize the SQL database engine.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 0
   }

   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and already seen images will be removed from the files list")
         Return

      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      showTOOLtip("Retrieving already seen images matching entire files list`nPlease wait")
      setImageLoading()
      seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)
      If (totalSeenIMGs<2)
      {
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         CurrentSLD := backCurrentSLD
         dummyTimerDelayiedImageDisplay(50)
         etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
         showTOOLtip("No records found matching the criteria" etaTime)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If (StrLen(filesFilter)>1 && filesFilter!="||Already-Seen-Images||")
         remFilesListFilter("simple")

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      doStartLongOpDance()
      newFilesList := []
      countSeen := selectedFiles := newFilesIndex := 0
      Loop, % maxFilesIndex + 1
      {
          r := resultedFilesList[A_Index, 1]
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Checking for already seen images, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          If (seenEntries[Format("{:L}", r)]=1)
          {
             newFilesIndex++
             newFilesList[newFilesIndex] := resultedFilesList[A_Index]
             If resultedFilesList[A_Index, 2]
                selectedFiles++
 
             newMappingList[newFilesIndex] := A_Index
             countSeen++
          }

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (abandonAll=1 || countSeen<2)
      {

         If (abandonAll=1)
            showTOOLtip("Operation aborted. Files list left unchanged, no filter applied.")
         Else
            showTOOLtip("No seen images identified. Files list left unchanged, no filter applied.")

         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         newFilesList := []
         newMappingList := []
         dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         Return
      }

      ; renewCurrentFilesList()
      filteredMap2mainList := newMappingList.Clone()
      bckpResultedFilesList := resultedFilesList.Clone()
      resultedFilesList := newFilesList.Clone()
      If !filesFilter
         bckpMaxFilesIndex := maxFilesIndex
      maxFilesIndex := newFilesIndex
      markedSelectFile := selectedFiles
      filesFilter := "||Already-Seen-Images||"
      userFilterProperty := 20
      userFilterDoString := 0
      ForceRefreshNowThumbsList()
      newFilesList := []
      newMappingList := []
      GenerateRandyList()
      getSelectedFiles(0, 1)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      RandomPicture()
      showDelayedTooltip("Finished the identification process of already seen images`n" groupDigits(countSeen) " images were found in the initial files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

extractSQLqueryFromFilter() {
    If InStr(filesFilter, "SQL:query:WHERE")
    {
       extraFilter := StrReplace(filesFilter, "`n", A_Space)
       extraFilter := SubStr(extraFilter, InStr(extraFilter, ":WHERE ") + 1)
       If InStr(extraFilter, " ORDER BY ")
          extraFilter := SubStr(extraFilter, 1, InStr(extraFilter, " ORDER BY "))
       Return extraFilter
    }
}

collectSQLFileInfosNow(scu, modus, asku, doFilterExtra:=1) {
   Static noQuestion := 0
   If (asku=1 && noQuestion=1)
   {
      addJournalEntry(A_ThisFunc "(): user chose to never be asked to collect data in this session.")
      Return 0
   }

   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   If (doFilterExtra=1)
      extraFilter := extractSQLqueryFromFilter()

   friendly := extraFilter ? "`nCurrent files list filter:`n" extraFilter : ""
   showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait" friendly)

   If RegExMatch(scu, "i)(imgmedian|imgavg|imghpeak|imghlow|imghmode|imghminu|imghrange|imghrms|innerpixelz|outerpixelz|pixelzHash)")
      adaptedSortCriteria := 3
   Else If RegExMatch(scu, "i)(imgmegapix|imgdpi|imgwidth|imgframes|imgpixfmt|imgheight|imgwhratio)")
      adaptedSortCriteria := 2
   Else If RegExMatch(scu, "i)(fcreated|fmodified|fsize|kbfsize)")
      adaptedSortCriteria := 1
   Else
      adaptedSortCriteria := 0

   failedFiles := failedSQLfiles := 0
   If adaptedSortCriteria
   {
      If !getMaxRowIDsqlDB()
      {
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      thisWhere := extraFilter ? extraFilter " AND " scu " IS NULL;" : "WHERE " scu " IS NULL;"
      SQLstr := "SELECT imgidu, fullPath FROM images " thisWhere
      ; addJournalEntry(SQLstr)
      If !activeSQLdb.GetTable(SQLstr, RecordSet)
      {
         throwSQLqueryDBerror(A_ThisFunc)
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      failedFiles := countTFilez := 0
      filesToBeSorted := RecordSet.RowCount
      thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
      alreadySorted := thisMaxCount - filesToBeSorted
      If (alreadySorted<5)
         noQuestion := 1

      zEffect := (adaptedSortCriteria=3 && filesToBeSorted>0) ? Gdip_CreateEffect(6, 0, -99, 0) : 0
      If (asku=1 && noQuestion=0 && filesToBeSorted>10)
      {
         thisFriendly := (SLDtypeLoaded=3) ? "`n`nThe data will be automatically cached in the database and you can stop and resume this process at anytime." : ""
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected to perform an operation that relies on collected file and image details. " appTitle " needs to scan " groupDigits(filesToBeSorted) " out of " groupDigits(thisMaxCount) " files. By refusing to the collect data, the operation you chose (sort, filter, generate statistics or find duplicates) will likely give incomplete or erroneous results." thisFriendly, "Collect &data now|&Continue with incomplete data", 0, "question", "&Do not collect file data and never ask again in this session", 0)

         If (InStr(msgResult.btn, "incomplete") || msgResult.Check=1)
         {
            noQuestion := msgResult.Check
            CurrentSLD := backCurrentSLD
            SetTimer, RemoveTooltip, % -msgDisplayTime
            SetTimer, ResetImgLoadStatus, -200
            Return 0
         }
      }

      If (filesToBeSorted>0)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      prevMSGdisplay := A_TickCount
      Loop, % RecordSet.RowCount
      {
          Row := RecordSet.Rows[A_Index]
          If Row[2]
          {
             rs := 1
             countTFilez++
             If (adaptedSortCriteria=1)
             {
                If FileExist(Row[2])
                   rs := updateSQLdbEntryFileInfos(Row[2], GetFileAttributesEx(Row[2]), Row[1])
                Else
                   failedFiles++
             } Else If (adaptedSortCriteria=2)
             {
                objul := GetCachableImgFileDetails(Row[2], Row[1], 0, 1)
                If IsObject(objul[1])
                   rs := updateSQLdbEntryImgRes(Row[2], objul[1], objul[2], Row[1])
                Else
                   failedFiles++
             } Else If (adaptedSortCriteria=3)
             {
                objul := GetCachableHistogramFile(Row[2], Row[1], 0, 1, 1, 0, zEffect)
                If IsObject(objul[1])
                   rs := updateSQLdbEntryImgHisto(Row[2], objul[1], objul[2], 0, Row[1])
                Else
                   failedFiles++
             }
             If !rs
                failedSQLfiles++
          }

          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
             If (failedFiles>0)
                etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"
             If (failedSQLfiles>0)
                etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

             showTOOLtip("Gathering files information, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
             prevMSGdisplay := A_TickCount
          }

          executingCanceableOperation := A_TickCount
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      Gdip_DisposeEffect(zEffect)
      RecordSet.Free()
      If (filesToBeSorted>0)
      {
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            ErrorMsg := "ERROR: failed to commit collected data to the SQL database`n" activeSQLdb.ErrorMsg "`n"
      }
   }

   PopulateIndexFilesStatsInfos("kill")
   CurrentSLD := backCurrentSLD
   someErrors := ""
   If (failedFiles>0)
      someErrors .= "`nFailed to collect data for " groupDigits(failedFiles) " files"
   If (failedSQLfiles>0)
      someErrors .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      If (modus=1)
         showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone "`nFiles list not sorted, because data collection did not complete.")
      Else
         showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   If (modus!=1)
   {
      showTOOLtip(ErrorMsg "Finished collecting data for " groupDigits(filesToBeSorted) " files`nFor " groupDigits(alreadySorted) " files the data was already collected" someErrors)
      SoundBeep 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
   }
   Return 0
}

generateSQLimagesExtraHash() {
   Static noQuestion := 0
   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   showTOOLtip("Generating image hashes for " groupDigits(maxFilesIndex) " files, please wait" friendly)
   failedFiles := failedSQLfiles := 0
   If !getMaxRowIDsqlDB()
   {
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   SQLstr := "SELECT imgidu, innerpixelz||outerpixelz AS hashu FROM images WHERE innerpixelz IS NOT NULL AND pixelzHash IS NULL;"
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   failedFiles := countTFilez := 0
   filesToBeSorted := RecordSet.RowCount
   If (filesToBeSorted>0)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   prevMSGdisplay := A_TickCount
   Loop, % RecordSet.RowCount
   {
       Row := RecordSet.Rows[A_Index]
       If Row[1]
       {
          rs := 1
          countTFilez++
          arr := StrSplit(Row[2])
          g := ST_Count(Row[2], "0")
          newHash := (g//2)*2
          newHash .= ((64 - g)//2)*2
          If (StrLen(newHash)!=4)
             newHash .= 9

          thisIndex := 0
          Loop, 32
          {
             thisIndex++
             x := arr[thisIndex] + arr[thisIndex+1]
             thisIndex++
             newHash .= x
          }

          SQLstr := "UPDATE images SET pixelzHash='" newHash "' WHERE imgidu=" Row[1] ";"
          If !activeSQLdb.Exec(SQLstr)
             failedSQLfiles++
       }

       If (A_TickCount - prevMSGdisplay>2000)
       {
          etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
          If (failedSQLfiles>0)
             etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

          showTOOLtip("Generating image hashes, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
          prevMSGdisplay := A_TickCount
       }

       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }
   }

   RecordSet.Free()
   If (filesToBeSorted>0)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         ErrorMsg := "ERROR: failed to commit generated hashes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
   }

   CurrentSLD := backCurrentSLD
   someErrors := ""
   If (failedSQLfiles>0)
      someErrors .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   ; showTOOLtip(ErrorMsg "Finished generating hashes for " groupDigits(filesToBeSorted) " files" someErrors)
   ; SoundBeep, 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -200
   Return 0
}

TEMPgenerateHush() {
   Static noQuestion := 0
   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   showTOOLtip("Generating image hashes for " groupDigits(maxFilesIndex) " files, please wait" friendly)
   failedFiles := failedSQLfiles := 0
   If !getMaxRowIDsqlDB()
   {
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   SQLstr := "SELECT imgidu, innerpixelz, outerpixelz FROM images WHERE innerpixelz IS NOT NULL;"
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   failedFiles := countTFilez := 0
   filesToBeSorted := RecordSet.RowCount
   If (filesToBeSorted>0)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   prevMSGdisplay := A_TickCount
   Loop, % RecordSet.RowCount
   {
       Row := RecordSet.Rows[A_Index]
       If Row[1]
       {
          newHash := reorderStoredHashes(Row[2], Row[3])
          ; newHash := ConvertBase(2, 16, newHash)

          countTFilez++
          SQLstr := "UPDATE images SET entireHush='" newHash "' WHERE imgidu=" Row[1] ";"
          If !activeSQLdb.Exec(SQLstr)
             failedSQLfiles++
       }

       If (A_TickCount - prevMSGdisplay>2000)
       {
          etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
          If (failedSQLfiles>0)
             etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

          showTOOLtip("Generating image hashes, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
          prevMSGdisplay := A_TickCount
       }

       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }
   }

   RecordSet.Free()
   If (filesToBeSorted>0)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         ErrorMsg := "ERROR: failed to commit generated hashes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
   }

   CurrentSLD := backCurrentSLD
   someErrors := ""
   If (failedSQLfiles>0)
      someErrors .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   ; showTOOLtip(ErrorMsg "Finished generating hashes for " groupDigits(filesToBeSorted) " files" someErrors)
   ; SoundBeep, 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -200
   Return 0
}

BtnCollectFileInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow("fsize", 0, 0)
   Else
      collectFileInfosNow()
   PanelWrapperFilesStats()
}

BtnCollectImageInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow("imgmegapix", 0, 0)
   Else
      collectImageInfosNow(0, 9, 1)
   PanelWrapperFilesStats()
}

BtnCollectHistoInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow("imgavg", 0, 0)
   Else
      collectImageInfosNow(0, 11, 1)

   openPreviousPanel()
}

dbSortingCached(SortCriterion) {
   If (maxFilesIndex>0)
   {
      If AnyWindowOpen
         BtnCloseWindow()

      If askAboutFileSave(" and the files list will be sorted")
         Return

      abandonAll := collectSQLFileInfosNow(SortCriterion, 1, 1)
      If (!getMaxRowIDsqlDB() || abandonAll=1)
      {
         SetTimer, ResetImgLoadStatus, -200
         Return
      }

      sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
      prevFilesSortMode := SortCriterion
      IniSLDBWrite("prevFilesSortMode", SortCriterion)
      setWindowTitle("Sorting files list by " SortCriterion ", please wait", 1)
      If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
      {
         retrieveDupesByProperties(0, 0, SortCriterion)
         Return
      }

      setImageLoading()
      doStartLongOpDance()
      startOperation := A_TickCount
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait")
      extraFilter := extractSQLqueryFromFilter()
      SQLstr := "SELECT imgidu, fullPath FROM images " extraFilter " ORDER BY " SortCriterion sortMode ";"
      If !activeSQLdb.GetTable(SQLstr, RecordSet)
      {
         throwSQLqueryDBerror(A_ThisFunc)
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      countTFilez := RecordSet.RowCount
      If !countTFilez
      {
         showTOOLtip("No image records found in the database matching:`n" SQLstr)
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      addJournalEntry("Sorting database using query: " SQLstr)
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      markedSelectFile := 0
      previmgPath := getIDimage(currentFileIndex)
      If StrLen(filesFilter)>1
         backFilesFilter := filesFilter

      showTOOLtip("Generating sorted files list index")
      renewCurrentFilesList()
      prevMSGdisplay := A_TickCount - 900
      Loop, % RecordSet.RowCount
      {
          Rowu := RecordSet.Rows[A_Index]
          If Rowu[2]
          {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex, 1] := Rowu[2]
             resultedFilesList[maxFilesIndex, 12] := Rowu[1]
          }

          If (A_TickCount - prevMSGdisplay>1500)
          {
             changeMcursor()
             etaTime := ETAinfos(A_Index, countTFilez, startOperation)
             showTOOLtip("Generating sorted files list index" etaTime, 0, 0, A_Index/countTFilez)
             prevMSGdisplay := A_TickCount
          }
      }
  
      RecordSet.Free()
      ForceRefreshNowThumbsList()
      If extraFilter
         filesFilter := "SQL:query:" extraFilter

      CurrentSLD := backCurrentSLD
      If (StrLen(backfilesFilter)>1 && !extraFilter && !InStr(backFilesFilter, "SQL:query:JOIN"))
         coreEnableFiltru(backFilesFilter, 1)
      Else
         GenerateRandyList()

      zeitOperation := A_TickCount - startOperation
      addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 25
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      IDshowImage(currentFileIndex)
      MsgBox, % maxFilesIndex "=" CurrentSLD
  }
  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}

ActSortName() {
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder, imgfile")
   Else
      SortFilesList("name-entire")
}

ActSortSize() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fsize")
   Else
      SortFilesList("size")
   etaTime := "Elapsed time to sort files list by file size: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortPath() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder")
   Else
      SortFilesList("name-folder")
   etaTime := "Elapsed time to sort files list by folder name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortDupeGroups() {
   startOperation := A_TickCount
   If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
      retrieveDupesByProperties(0, 0, 1)

   etaTime := "Elapsed time to sort files list by duplicates image group IDs: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortFileName() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfile")
   Else
      SortFilesList("name-file")
   etaTime := "Elapsed time to sort files list by file name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortModified() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fmodified")
   Else
      SortFilesList("modified")
   etaTime := "Elapsed time to sort files list by file modified date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortCreated() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fcreated")
   Else
      SortFilesList("created")
   etaTime := "Elapsed time to sort files list by file created date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortHistogram(modus) {
   Static listuA := {1:"imgavg", 2:"imgmedian", 3:"imghpeak", 4:"imghlow", 5:"imghrange", 6:"imghmode", 7:"imghminu", 8:"imghrms"}
        , listuB := {1:"avg", 2:"median", 3:"peak", 4:"low", 5:"range", 6:"mode", 7:"minu", 8:"hrms"}

   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1 && listuA[modus])
      dbSortingCached(listuA[modus])
   Else If listuB[modus]
      SortFilesList("histogram-" listuB[modus])

   etaTime := "Elapsed time to sort files list by histogram mode " modus ": " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortImageProperties(modus) {
   Static listuA := {1:"imgmegapix", 2:"imgwidth", 3:"imgheight", 4:"imgwhratio", 5:"imgdpi", 6:"imgframes"}
        , listuB := {1:"resolution", 2:"width", 3:"height", 4:"wh-ratio", 5:"dpi", 6:"frames"}

   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1 && listuA[modus])
      dbSortingCached(listuA[modus])
   Else If listuB[modus]
      SortFilesList("image-" listuB[modus])

   etaTime := "Elapsed time to sort files list by image properties mode " modus ": " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

warnXPhistoSort() {
   If isWinXP
   {
      msgBoxWrapper(appTitle ": ERROR", "There is no support in GDI+ for extracting histogram data from images on your system... Therefore, you cannot sort the images by histogram.", 0, 0, "error")
      Return 1
   }
}

SortFilesList(SortCriterion) {
   ; Critical, on
   Static hasAskedFilter := 0

   If AnyWindowOpen
      BtnCloseWindow()

   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and the files list will be sorted")
         Return

      filesToBeSorted := maxFilesIndex
      If (StrLen(filesFilter)>1 && hasAskedFilter=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Sort operation", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nOnly the files matched by current filter will be sorted, not all the files.`n`nTo sort all files, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel")
            Return
         Else hasAskedFilter := 1
      }

      startOperation := A_TickCount
      setImageLoading()
      previmgPath := getIDimage(currentFileIndex)
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait")
      setWindowTitle("Sorting files list, please wait", 1)
      backCurrentSLD := CurrentSLD
      CurrentSLD := filterBehaviour := ""
      newIndex :=  := 0
      If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:"))
      {
         filterBehaviour := 1
         showTOOLtip("Preparing the files list, please wait")
         Loop, %maxFilesIndex%   ; marking index entries to be sorted
             updateMainUnfilteredList(A_Index, 10, 1)

         backfilesFilter := filesFilter
         remFilesListFilter("simple")
         Sleep, 25
         RemoveTooltip()
      }

      newFilesList := []
      prevMSGdisplay := A_TickCount
      adaptedSortCriteria := StrReplace(SortCriterion, "image-")
      adaptedSortCriteria := StrReplace(adaptedSortCriteria, "histogram-")

      sortPages := sortedFiles := 0
      unSortPages := unSortedFiles := 0
      If ((OnSortdoFilesCheck=1 || InStr(SortCriterion, "image-") || InStr(SortCriterion, "histogram-")) && SLDtypeLoaded=3)
      {
         activeSQLdb.Exec("BEGIN TRANSACTION;")
         If InStr(SortCriterion, "histogram")
            zEffect := Gdip_CreateEffect(6, 0, -99, 0)
      }

      countTFilez := 0
      ; doFilesCheck := InStr(SortCriterion, "name-") ? 0 : OnSortdoFilesCheck
      doStartLongOpDance()
      Loop, % maxFilesIndex + 1
      {
          r := resultedFilesList[A_Index, 1]
          If (InStr(r, "||") || !r)
             Continue

          If (filterBehaviour=1 || filterBehaviour=2)
          {
             If !resultedFilesList[A_Index, 10]
             {
                ; building the sorted new files list array; this is the unsorted section
                newIndex++
                newFilesList[newIndex] := resultedFilesList[A_Index]
                Continue
             }
          }

          changeMcursor()
          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
             If (failedFiles>0)
                etaTime .= "`nFailed to sort " groupDigits(failedFiles) " files"

             showTOOLtip("Gathering files information, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
             prevMSGdisplay := A_TickCount
          }

          If (OnSortdoFilesCheck=1)
          {
             If !FileRexists(r)
             {
                resultedFilesList[A_Index, 10] := 0
                If (SLDtypeLoaded=3)
                   deleteSQLdbEntry(r, resultedFilesList[A_Index, 12])

                failedFiles++
                Continue
             }
          }

          If (SortCriterion="size")
          {
             SortBy := QPV_FileGetSizeTime(r, "S", A_Index)
          } Else If (SortCriterion="modified")
          {
             SortBy := QPV_FileGetSizeTime(r, "M", A_Index)
          } Else If (SortCriterion="created")
          {
             SortBy := QPV_FileGetSizeTime(r, "C", A_Index)
          } Else If (SortCriterion="name-folder")
          {
             zPlitPath(r, 1, OutFileName, OutDir)
             SortBy := OutDir
          } Else If (SortCriterion="name-file")
          {
             zPlitPath(r, 1, OutFileName, OutDir)
             SortBy := OutFileName
          } Else If (SortCriterion="name-entire")
          {
             SortBy := r
          } Else If InStr(SortCriterion, "image-")
          {
             If !resultedFilesList[A_Index, 9]
                GetCachableImgFileDetails(r, A_Index)

             If resultedFilesList[A_Index, 13]
             {
                If (SLDtypeLoaded=3)
                   updateSQLdbEntryImgRes(r, 1, 1, resultedFilesList[A_Index, 12], A_Index)

                Switch adaptedSortCriteria
                {
                   Case "resolution":
                      SortBy := resultedFilesList[A_Index, 17]
                   Case "width":
                      SortBy := resultedFilesList[A_Index, 13]
                   Case "height":
                      SortBy := resultedFilesList[A_Index, 14]
                   Case "wh-ratio":
                      SortBy := resultedFilesList[A_Index, 16]
                   Case "dpi":
                      SortBy := resultedFilesList[A_Index, 22]
                   Case "frames":
                      SortBy := resultedFilesList[A_Index, 9]
                }
             } Else
             {
                failedFiles++
                SortBy := 0
             }
          } Else If InStr(SortCriterion, "histogram")
          {
             If !resultedFilesList[A_Index, 11]
                GetCachableHistogramFile(r, A_Index, 0, 0, 1, 0, zEffect)

             If (resultedFilesList[A_Index, 11])
             {
                If (SLDtypeLoaded=3)
                   updateSQLdbEntryImgHisto(r, 1, 1, 0, resultedFilesList[A_Index, 12], A_Index)

                Switch adaptedSortCriteria
                {
                   Case "median":
                      SortBy := resultedFilesList[A_Index, 19]
                   Case "avg":
                      SortBy := resultedFilesList[A_Index, 18]
                   Case "peak":
                      SortBy := resultedFilesList[A_Index, 20]
                   Case "low":
                      SortBy := resultedFilesList[A_Index, 21]
                   Case "hrms":
                      SortBy := resultedFilesList[A_Index, 24]
                   Case "range":
                      SortBy := resultedFilesList[A_Index, 25]
                   Case "mode":
                      SortBy := resultedFilesList[A_Index, 26]
                   Case "minu":
                      SortBy := resultedFilesList[A_Index, 27]
                }
             } Else
             {
                failedFiles++
                SortBy := 0
             }
          }

          executingCanceableOperation := A_TickCount
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }

          sortedFiles++
          filesListu%sortPages% .= SortBy "|!\!|" A_Index "`n"
          If (sortedFiles>3102)
          {
             sortedFiles := 0
             sortPages++
          }
      }

      If ((OnSortdoFilesCheck=1 || InStr(SortCriterion, "image-") || InStr(SortCriterion, "histogram-")) && SLDtypeLoaded=3)
      {
         Gdip_DisposeEffect(zEffect)
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            addJournalEntry(A_ThisFunc "() failed to commit transactions to SQL database")
      }

      If (abandonAll=1)
      {
         If errorOccured
            msgInfos := "`nErrors occured. Multi-threading error."
         If (failedFiles && SLDtypeLoaded=3 && OnSortdoFilesCheck=1)
            msgInfos .= "`n" failedFiles " inexistent files were removed from the SQL database index"

         If StrLen(backfilesFilter)>1
         {
            ; rebuilding the filtered files list index, as it was
            thisIndex := 0
            newFilesList := []
            newMappingList := []
            filesFilter := backfilesFilter
            Loop, % maxFilesIndex + 1
            {
               r := resultedFilesList[A_Index, 1]
               If (InStr(r, "||") || !r)
                  Continue

               If resultedFilesList[A_Index, 10]
               {
                  thisIndex++
                  newFilesList[thisIndex] := resultedFilesList[A_Index]
                  newMappingList[thisIndex] := A_Index
                  If resultedFilesList[A_Index, 2]
                     selectedFiles++
               }
            }

            filteredMap2mainList := []
            filteredMap2mainList := newMappingList.Clone()
            newMappingList := []
            bckpResultedFilesList := resultedFilesList.Clone()
            resultedFilesList := newFilesList.Clone()
            newFilesList := []
            bckpMaxFilesIndex := maxFilesIndex
            maxFilesIndex := thisIndex
            markedSelectFile := selectedFiles
         }

         showTOOLtip("Operation aborted. Files list unchanged. " msgInfos)
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         lastLongOperationAbort := A_TickCount
         SetTimer, ResetImgLoadStatus, -50
         Return
      }

      showTOOLtip("Preparing gathered data`n" unSortPages " / " sortPages)
      prevMSGdisplay := A_TickCount
      changeMcursor()
      Loop, % sortPages + 1
      {
         thisIndex := A_Index - 1
         entireString .= filesListu%thisIndex%
      }

      showTOOLtip("Sorting gathered data")
      sortMode := (reverseOrderOnSort=1) ? "R" : ""
      If InStr(SortCriterion, "name-")
         Sort, entireString, %sortMode% D`n
      Else
         Sort, entireString, %sortMode% N D`n

      If (A_TickCount - prevMSGdisplay>1500)
         showTOOLtip("Generating sorted files list index")

      2ndnewIndex := 0
      2ndnewFilesList := []
      newMappingList := []
      histoObj := []
      prevMSGdisplay := A_TickCount
      Loop, Parse, entireString,`n,`r
      {
          If !A_LoopField
             Continue

          2ndnewIndex++
          line := StrSplit(A_LoopField, "|!\!|")
          2ndnewFilesList[2ndnewIndex] := resultedFilesList[line[2]]
          If filterBehaviour
          {
             2ndnewFilesList[2ndnewIndex, 10] := 0
             newMappingList[2ndnewIndex] := A_Index
          }

          If (A_TickCount - prevMSGdisplay>1500)
          {
             changeMcursor()
             etaTime := ETAinfos(A_Index, countTFilez, startOperation)
             showTOOLtip("Generating sorted files list index" etaTime, 0, 0, A_Index/countTFilez)
             prevMSGdisplay := A_TickCount
          }
      }

      ; and now build the final files list array with sorted and unsorted sections of the initial array
      finalNewList := []
      Loop, % 2ndnewIndex   ; the sorted section
         finalNewList[A_Index] := 2ndnewFilesList[A_Index]

      If filterBehaviour
      {
         Loop, % newIndex    ; the unsorted section
            finalNewList[A_Index + 2ndnewIndex] := newFilesList[A_Index]

         filteredMap2mainList := newMappingList.Clone()
         bckpResultedFilesList := finalNewList.Clone()
         bckpMaxFilesIndex := newIndex + 2ndnewIndex
      }

      maxFilesIndex := 2ndnewIndex
      resultedFilesList := 2ndnewFilesList.Clone()
      newFilesList := []
      2ndnewFilesList := []
      finalNewList := []
      ForceRefreshNowThumbsList()
      If StrLen(backfilesFilter)>1
         filesFilter := backfilesFilter

      GenerateRandyList()
      entireString := entireNotSortedString := ""
      currentFilesListModified := 1
      zeitOperation := A_TickCount - startOperation
      addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 5
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      If (maxFilesIndex<1 && StrLen(filesFilter)>1)
         remFilesListFilter("simple")
      Else If (maxFilesIndex<1)
         handleEmptyFilesList(CurrentSLD)
      Else
         IDshowImage(currentFileIndex)
   }
}

getSelectedFilesListString(maxList, ByRef countTFilez, ByRef filesListu) {
  trenchSize := maxList//systemCores
  countTFilez := 0
  filesListu := []
  selectedFilesArray := []
  showTOOLtip("Preparing workload for multi-threaded processing")

  Loop, % maxFilesIndex
  {
      isSelected := resultedFilesList[A_Index, 2]
      If !isSelected
         Continue

      r := resultedFilesList[A_Index, 1]
      If (InStr(r, "||") || !r)
         Continue

      countTFilez++
      selectedFilesArray[countTFilez] := A_Index "?" r "`n"
  }

  maxList := selectedFilesArray.Count()
  trenchSize := maxList//systemCores
  r := 0
  Loop, % systemCores - 1
  {
      thisIndex := A_Index
      Loop, % trenchSize
      {
          realIndex := trenchSize*(thisIndex-1) + A_Index
          line := selectedFilesArray[realIndex]
          If !line
             Continue

          filesListu[thisIndex] .= line
      }
  }

  Loop, % maxList - trenchSize*(systemCores-1)
  {
      realIndex := trenchSize*(systemCores-1) + A_Index
      line := selectedFilesArray[realIndex]
      If !line
         Continue

      filesListu[systemCores] .= line
  }
}

WorkLoadMultiCoresJpegLL(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-jpegll||" jpegDesiredOperation "=" jpegDoCrop "=" relativeImgSelCoords "=" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  setForceRefreshThumbsFilesIndex(1)
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }
            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to process " groupDigits(failedFiles) " files"
            If (skippedFiles>0)
               etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image files processing, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Performing JPEG lossless operations, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

   Loop, % systemCores
       FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt

   processedFiles := skippedFiles := failedFiles := 0
   Loop, % systemCores
   {
      RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
      filesStatusArr := StrSplit(filesStatus, "/")
      If (filesStatusArr[1]>0)
         processedFiles += filesStatusArr[1]
      If (filesStatusArr[2]>0)
         failedFiles += filesStatusArr[2]
      If (filesStatusArr[3]>0)
         skippedFiles += filesStatusArr[3]
   }

   zeitOperation := A_TickCount - startOperation
   someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
   If (failedFiles>0)
      someErrors .= "`nFailed to process " groupDigits(failedFiles) " files"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"
    
  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. JPEG lossless processing aborted. `n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countFilez) " selected files were processed until now." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  CurrentSLD := backCurrentSLD
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " groupDigits(markedSelectFile) " selected files were processed until now" someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected JPEG files were processed" someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  Return r
}

testProcessExists(pid) {
   If StrLen(pid)<2
      Return 0

   Process, Exist, % pid
   R := (ErrorLevel=pid) ? 1 : 0
   Return R
}

WorkLoadMultiCoresConvertFormat(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-fmtconv"
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := theseFailures := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  theseFailures += filesStatusArr[3]
               If (filesStatusArr[4]>0)
                  skippedFiles += filesStatusArr[4]
            }

            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to convert " groupDigits(failedFiles) " files"
            If (theseFailures>0)
               etaTime .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
            If (skippedFiles>0)
               etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image file formats conversion, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Converting to ." rDesireWriteFMT " format, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := theseFailures := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        theseFailures += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  Loop, Parse, theFinalList,`n,`r
  {
       If StrLen(A_LoopField)>2
       {
          lineArr := StrSplit(A_LoopField, "?")
          thisIndex := lineArr[1]
          imgPath := lineArr[2]
          If (imgPath && thisIndex)
             resultedFilesList[thisIndex, 1] := imgPath
       }
  }

  zeitOperation := A_TickCount - startOperation
  percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFailed to convert " groupDigits(failedFiles) " files"
  If (theseFailures>0)
     someErrors .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
  If (skippedFiles>0)
     someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

  If (fatalError=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     ; RemoveTooltip()
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image file formats conversion aborted.`n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countFilez) " selected files were processed until now." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " markedSelectFile " selected files were converted to ." rDesireWriteFMT " until now" someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were converted to ." rDesireWriteFMT someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  CurrentSLD := backCurrentSLD
  Return r
}

WorkLoadMultiCoresSimpleImgProcessing(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-simpleimgproc||" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2 "=" editingSelectionNow "=" simpleOpRotationAngle
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
         ; sleep, 450
         ; ToolTip, % jobsRunning "//" jobDone "//" threadsCrashed "//" totalEnded , , , 2
         ; ToolTip, % thisThreadStatus " // " isPIDalive , , , 2
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }

            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to process " groupdigits(failedFiles) " files"
            If (skippedFiles>0)
               etaTime .= "`n" groupdigits(skippedFiles) " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image files processing, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Processing image files, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := skippedFiles := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        skippedFiles += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
  zeitOperation := A_TickCount - startOperation
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFailed to process " groupDigits(failedFiles) " files"
  If (skippedFiles>0)
     someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image processing aborted. `n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were processed until now..." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " groupDigits(markedSelectFile) " selected files were processed until now." someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were processed" someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  CurrentSLD := backCurrentSLD
  Return r
}

multiCoresJpegLL(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  jpegOperation := argumentsArray[1]
  mustCrop := argumentsArray[2]
  relativeImgSelCoords := argumentsArray[3]
  imgSelX1 := argumentsArray[4]
  imgSelX2 := argumentsArray[5]
  imgSelY1 := argumentsArray[6]
  imgSelY2 := argumentsArray[7]
  prcSelX1 := argumentsArray[8]
  prcSelX2 := argumentsArray[9]
  prcSelY1 := argumentsArray[10]
  prcSelY2 := argumentsArray[11]
  failedFiles := skippedFiles := countFilez := operationDone := 0
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       If !RegExMatch(imgPath, "i)(.\.(jpeg|jpg|jpe))$")
       {
          skippedFiles++
          Continue
       }

       r := coreJpegLossLessAction(imgPath, jpegOperation, mustCrop)
       If !r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

multiCoresSimpleImgProcessing(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  ReadSettingsImageProcessing()
  imgSelX1 := argumentsArray[1]
  imgSelX2 := argumentsArray[2]
  imgSelY1 := argumentsArray[3]
  imgSelY2 := argumentsArray[4]
  prcSelX1 := argumentsArray[5]
  prcSelX2 := argumentsArray[6]
  prcSelY1 := argumentsArray[7]
  prcSelY2 := argumentsArray[8]
  editingSelectionNow := argumentsArray[9]
  simpleOpRotationAngle := argumentsArray[10]
  skippedFiles := failedFiles := countFilez := operationDone := 0
  thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       imgPath := StrReplace(imgPath, "||")
       If !RegExMatch(imgPath, thisRegEX)
       {
          skippedFiles++
          Continue
       }

       zPlitPath(imgPath, 0, OutFileName, OutDir)
       destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
       file2save := destImgPath "\" OutFileName
       If (ResizeUseDestDir=1)
       {
          If (FileExist(file2save) && !FolderExist(file2save))
             file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)
       }

       If !file2save
       {
          skippedFiles++
          Continue
       }

       r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
       If r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

ReadSettingsFormatConvert() {
    IniAction(0, "OnConvertKeepOriginals", "General", 1)
    IniAction(0, "userActionConflictingFile", "General", 2, 1, 3)
    IniAction(0, "userHQraw", "General", 1)
    IniAction(0, "userJpegQuality", "General", 2, 1, 100)
    IniAction(0, "userDesireWriteFMT", "General", 2, 1, 16)
    IniAction(0, "ResizeUseDestDir", "General", 1)
    IniAction(0, "ResizeDestFolder", "General", 5)
    IniAction(0, "PreserveDateTimeOnSave", "General", 1)

    rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
}

ReadSettingsImageProcessing() {
    IniAction(0, "ResizeDestFolder", "General", 5)
    IniAction(0, "ResizeApplyEffects", "General", 1)
    IniAction(0, "ResizeCropAfterRotation", "General", 1)
    IniAction(0, "ResizeInPercentage", "General", 1)
    IniAction(0, "ResizeKeepAratio", "General", 1)
    IniAction(0, "ResizeQualityHigh", "General", 1)
    IniAction(0, "ResizeRotationUser", "General", 2, 0, 359)
    IniAction(0, "ResizeUseDestDir", "General", 1)
    IniAction(0, "ResizeWithCrop", "General", 1)
    IniAction(0, "userHQraw", "General", 1)
    IniAction(0, "SimpleOperationsFlipV", "General", 1)
    IniAction(0, "SimpleOperationsFlipH", "General", 1)
    IniAction(0, "SimpleOperationsDoCrop", "General", 1)
    IniAction(0, "SimpleOperationsRotateAngle", "General", 2, 1, 4)
    IniAction(0, "SimpleOperationsScaleXimgFactor", "General", 2, 1, 32000)
    IniAction(0, "SimpleOperationsScaleYimgFactor", "General", 2, 1, 32000)
    IniAction(0, "ResizeMustPerform", "General", 1)
    IniAction(0, "userJpegQuality", "General", 2, 1, 100)
    IniAction(0, "userActionConflictingFile", "General", 2, 1, 3)
    cleanResizeUserOptionsVars()
}

multiCoresFormatConvert(coreThread, filesList) {
  resultsList := ""
  failedFiles := theseFailures := countFilez := operationDone := 0
  ; FileRead, filesList, %thumbsCacheFolder%\tempList%coreThread%.txt
  ReadSettingsFormatConvert()
  initFIMGmodule()
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

      If (RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") || InStr(imgPath, "||") || !imgPath)
      {
         skippedFiles++
         Continue
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT

      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         countFilez++

      wasSucces := r ? 0 : 1
      If (OnConvertKeepOriginals!=1 && !r)
      {
         FileSetAttrib, -R, %imgPath%
         Sleep, 2
         FileRecycle, %imgPath%
         If ErrorLevel
            theseFailures++

         If (wasSucces=1)
            resultsList .= lineArr[1] "?" file2save "`n"
      }

      RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   }

   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   If resultsList
      Try FileAppend, % resultsList, %thumbsCacheFolder%\tempList%coreThread%.txt, UTF-16
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

readSlideSettings(readThisFile, act) {
     IniAction(act, "allowGIFsPlayEntirely", "General", 1,0,0,, readThisFile)
     IniAction(act, "animGIFsSupport", "General", 1,0,0,, readThisFile)
     IniAction(act, "autoAdjustMode", "General", 2,1,3,, readThisFile)
     IniAction(act, "autoPlaySNDs", "General", 1,0,0,, readThisFile)
     IniAction(act, "borderAroundImage", "General", 1,0,0,, readThisFile)
     IniAction(act, "bwDithering", "General", 1,0,0,, readThisFile)
     IniAction(act, "chnBdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "chnGdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "chnRdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "ColorDepthDithering", "General", 1,0,0,, readThisFile)
     IniAction(act, "doSatAdjusts", "General", 1,0,0,, readThisFile)
     IniAction(act, "doSlidesTransitions", "General", 1,0,0,, readThisFile)
     IniAction(act, "easySlideStoppage", "General", 1,0,0,, readThisFile)
     IniAction(act, "FlipImgH", "General", 1,0,0,, readThisFile)
     IniAction(act, "FlipImgV", "General", 1,0,0,, readThisFile)
     IniAction(act, "GammosAdjust", "General", 2,-25,1,, readThisFile)
     IniAction(act, "GammosGrayAdjust", "General", 2,-25,1,, readThisFile)
     IniAction(act, "hueAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "imageAligned", "General", 2,1,5,, readThisFile)
     IniAction(act, "imgFxMode", "General", 2,1,10,, readThisFile)
     IniAction(act, "IMGresizingMode", "General", 2,1,5,, readThisFile)
     IniAction(act, "imgThreshold", "General", 2,0,1,, readThisFile)
     IniAction(act, "IntensityAlphaChannel", "General", 2,-30,30,, readThisFile)
     IniAction(act, "isAlwaysOnTop", "General", 1,0,0,, readThisFile)
     IniAction(act, "isTitleBarHidden", "General", 1,0,0,, readThisFile)
     IniAction(act, "lummyAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "lumosAdjust", "General", 2,0.001,25,, readThisFile)
     IniAction(act, "lumosGrayAdjust", "General", 2,0.001,25,, readThisFile)
     IniAction(act, "mediaSNDvolume", "General", 2,1,100,, readThisFile)
     IniAction(act, "realGammos", "General", 2,0.01,10,, readThisFile)
     IniAction(act, "resetImageViewOnChange", "General", 1,0,0,, readThisFile)
     IniAction(act, "satAdjust", "General", 2,0,3,, readThisFile)
     IniAction(act, "showHUDnavIMG", "General", 1,0,0,, readThisFile)
     IniAction(act, "showImgAnnotations", "General", 1,0,0,, readThisFile)
     IniAction(act, "skipDeadFiles", "General", 1,0,0,, readThisFile)
     IniAction(act, "SLDcacheFilesList", "General", 1,0,0,, readThisFile)
     IniAction(act, "SlideHowMode", "General", 2,1,3,, readThisFile)
     IniAction(act, "slidesFXrandomize", "General", 1,0,0,, readThisFile)
     IniAction(act, "slideShowDelay", "General", 2,90,25000,, readThisFile)
     IniAction(act, "specialColorFXmode", "General", 2,1,9,, readThisFile)
     IniAction(act, "syncSlideShow2Audios", "General", 1,0,0,, readThisFile)
     IniAction(act, "thumbsAratio", "General", 2,1,3,, readThisFile)
     IniAction(act, "thumbsZoomLevel", "General", 2,0.35,3,, readThisFile)
     IniAction(act, "TouchScreenMode", "General", 1,0,0,, readThisFile)
     IniAction(act, "uiColorCurveFXchannel", "General", 2,1,4,, readThisFile)
     IniAction(act, "uiColorCurveFXmode", "General", 2,1,7,, readThisFile)
     IniAction(act, "usrAdaptiveThreshold", "General", 2,-9500,9500,, readThisFile)
     IniAction(act, "usrColorDepth", "General", 2,0,9,, readThisFile)
     IniAction(act, "usrTextureBGR", "General", 1,0,0,, readThisFile)
     IniAction(act, "vpIMGrotation", "General", 2,0,359,, readThisFile)
     IniAction(act, "WindowBgrColor", "General", 3,0,0,, readThisFile)
     IniAction(act, "zatAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "zoomLevel", "General", 2,0.01,20,, readThisFile)

     If (act=0)
     {
        If (isWinXP=1 || minimizeMemUsage=1)
           doSlidesTransitions := 0

        If (imageAligned!=1)
           imageAligned := 5

        If (scriptInit=1)
           interfaceThread.ahkFunction("updateWindowColor")

        defineColorDepth()
        recalculateThumbsSizes()
    } Else
    {
       IniAction(1, "appVersion", "General", 0,0,0,, readThisFile)
    }
}

writeMainSettings() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 350)
    {
       lastInvoked := A_TickCount
       SetTimer, writeMainSettings, -500
       Return
    }

    loadMainSettings(1)
    lastInvoked := A_TickCount
}

loadMainSettings(act) {
    EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
    readSlideSettings(mainSettingsFile, act)
    IniAction(act, "allowMultiCoreMode", "General", 1)
    IniAction(act, "allowRecordHistory", "General", 1)
    IniAction(act, "alwaysOpenwithFIM", "General", 1)
    IniAction(act, "askDeleteFiles", "General", 1)
    IniAction(act, "deleteFileActAfter", "General", 2, 1, 3)
    IniAction(act, "skipSeenImageSlides", "General", 1)
    IniAction(act, "reverseOrderOnSort", "General", 1)
    IniAction(act, "OnSortdoFilesCheck", "General", 1)
    IniAction(act, "AutoDownScaleIMGs", "General", 1)
    IniAction(act, "autoRemDeadEntry", "General", 1)
    IniAction(act, "cmrRAWtoneMapAlgo", "General", 2, 1, 3)
    IniAction(act, "cmrRAWtoneMapParamA", "General", 2, -8, 10)
    IniAction(act, "cmrRAWtoneMapParamB", "General", 2, -8, 10)
    IniAction(act, "cycleFavesOpenIMG", "General", 1)
    IniAction(act, "DisplayTimeUser", "General", 2, 1, 99)
    ; IniAction(act, "dynamicThumbsColumns", "General", 1)
    IniAction(act, "EllipseSelectMode", "General", 1)
    IniAction(act, "enableThumbsCaching", "General", 1)
    IniAction(act, "FontBolded", "General", 1)
    IniAction(act, "FontItalica", "General", 1)
    IniAction(act, "highlightAlreadySeenImages", "General", 1)
    IniAction(act, "histogramMode", "General", 2, 1, 3)
    IniAction(act, "LimitSelectBoundsImg", "General", 1)
    IniAction(act, "mainWinMaximized", "General", 1)
    IniAction(act, "mainWinPos", "General", 5)
    IniAction(act, "mainWinSize", "General", 5)
    IniAction(act, "maxMemThumbsCache", "General", 2, 6, 950)
    IniAction(act, "minimizeMemUsage", "General", 1)
    IniAction(act, "multilineStatusBar", "General", 1)
    IniAction(act, "MustLoadSLDprefs", "General", 1)
    IniAction(act, "OSDbgrColor", "General", 3)
    IniAction(act, "OSDtextColor", "General", 3)
    IniAction(act, "OSDfntSize", "General", 2, 10, 350)
    IniAction(act, "PasteFntSize", "General", 2, 10, 350)
    IniAction(act, "OSDFontName", "General", 5)
    IniAction(act, "PrefsLargeFonts", "General", 1)
    IniAction(act, "prevFileMovePath", "General", 5)
    IniAction(act, "prevFileSavePath", "General", 5)
    IniAction(act, "prevOpenFolderPath", "General", 5)
    IniAction(act, "ResizeDestFolder", "General", 5)
    IniAction(act, "rotateSelBoundsKeepRatio", "General", 1)
    IniAction(act, "showHistogram", "General", 2, 1, 6)
    IniAction(act, "showInfoBoxHUD", "General", 2, 0, 2)
    IniAction(act, "showMainMenuBar", "General", 1)
    IniAction(act, "showSelectionGrid", "General", 1)
    IniAction(act, "mustRecordSeenImgs", "General", 1)
    IniAction(act, "thumbnailsListMode", "General", 1)
    IniAction(act, "thumbsColumns", "General", 2, 2, 100)
    IniAction(act, "thumbsListViewMode", "General", 2, 1, 3)
    IniAction(act, "useCachedSLDdata", "General", 1)
    IniAction(act, "userAllowWindowDrag", "General", 1)
    IniAction(act, "userHQraw", "General", 1)
    IniAction(act, "userimgQuality", "General", 1)
    IniAction(act, "userMultiCoresLimit", "General", 2, 2, thisSystemCores)
    IniAction(act, "usrTextAlign", "General", 5)

    If (act=0)
    {
       If (LimitSelectBoundsImg=1)
          lockSelectionAspectRatio := 1

       If (cmrRAWtoneMapAlgo=1)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, 0, 9.9)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, -8, 8)
       } Else If (cmrRAWtoneMapAlgo=2)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, -8, 8)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, 0, 1)
       } Else If (cmrRAWtoneMapAlgo=3)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, 0, 1)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, 0, 1)
       }

       If !InStr(mainWinPos, "|")
          mainWinPos := ""
       If !InStr(mainWinSize, "|")
          mainWinSize := ""

       imgQuality := (userimgQuality=1) ? 7 : 5
       isTxtAlignOkay := (usrTextAlign="Left" || usrTextAlign="Right" || usrTextAlign="Center") ? 1 : 0
       If !isTxtAlignOkay
          usrTextAlign := "Left"

       If !prevOpenFolderPath
          prevOpenFolderPath := A_WorkingDir

       If !ResizeDestFolder
       {
          If prevOpenFolderPath
             ResizeDestFolder := prevOpenFolderPath
          Else
             ResizeDestFolder := A_WorkingDir
       }

       realSystemCores := userMultiCoresLimit
       SetVolume(mediaSNDvolume)
       calcHUDsize()
       msgDisplayTime := DisplayTimeUser*1000
    }
}

calcHUDsize() {
   imgHUDbaseUnit := (PrefsLargeFonts=1) ? Round(OSDfntSize*2.5) : Round(OSDfntSize*2)
}

writeSlideSettings(file2save) {
    readSlideSettings(file2save, 1)
    ; throwMSGwriteError()
}

readRecentEntries(forceNewList:=0, doFiltering:=1) {
   Static lastInvoked := 1, historyList

   If (StrLen(forceNewList)>4)
   {
      historyList := forceNewList
      lastInvoked := A_TickCount
      Return
   }

   If (StrLen(historyList)>4 && (A_TickCount - lastInvoked<5500))
   {
      lastInvoked := A_TickCount
      Return historyList
   }

   historyList := ""
   Loop, 10
   {
       IniRead, newEntry, % mainRecentsFile, RecentOpen, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>4 && doFiltering=1)
          historyList .= newEntry "`n"
       Else If (doFiltering!=1)
          historyList .= newEntry "`n"
   }
  
   List_MakeUnique(historyList, "`n", 0, 1)
   lastInvoked := A_TickCount
   Return historyList
}

List_MakeUnique(ByRef oList, Delimiter:="`n", Case_Sensitive:=0, keepAsEmpty:=0) {
; By [VxE], removes duplicate entries from a list. Special thanks to SKAN.
; SOURCE: https://autohotkey.com/board/topic/34715-removing-duplicates-from-the-list-without-sorting-it/page-2
; modified by Marius Șucan

   ; VarSetCapacity( New_List, StrLen( List ) )
   New_List := Delimiter
   entriesCount := 0
   Loop, Parse, oList, % Delimiter
   {
      If (keepAsEmpty!=1 && !A_LoopField)
         Continue

      If (!InStr(New_List, Delimiter . A_LoopField . Delimiter, !!Case_Sensitive))
         New_List .= A_LoopField . Delimiter
      Else If (keepAsEmpty=1)
         New_List .= A_Space . Delimiter

      entriesCount++
   }
   oList := SubStr(New_List, 2, -1)
   Return entriesCount
}

readMiniFavesEntries() {
   Static lastInvoked := 1, prevList, prevCall

   fileInfos := GetFileAttributesEx(mainFavesFile)
   thisCall := "zzz" fileInfos.size "=" fileInfos.wTime "=" fileInfos.cTime
   If (thisCall!=prevCall || !prevList)
   {
      FileRead, contentu, % miniFavesFile
      Loop, Parse, contentu, `n, `r
      {
           If RegExMatch(A_LoopField, RegExFilesPattern)
           {
              thisIndex++
              historyList .= A_LoopField "`n"
           }

           If (thisIndex>16)
              Break
      }

      prevList := historyList
      prevCall := thisCall
      ; FileRead, historyList, % mainFavesFile
   } Else historyList := prevList

   lastInvoked := A_TickCount
   Return historyList
}

RecentFilesManager(entry2add) {
  If (StrLen(entry2add)<5 || !allowRecordHistory)
     Return

  historyList := readRecentEntries()
  historyList := entry2add "`n" historyList
  List_MakeUnique(historyList, "`n", 0, 0)
  Loop, Parse, historyList, `n, `r
  {
      If (A_Index>11)
         Break

      If (StrLen(A_LoopField)<5 || !FileExist(StrReplace(A_LoopField, "|")))
         Continue

      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentOpen, E%countItemz%
      newHistoryList .= A_LoopField "`n"
  }

  readRecentEntries(newHistoryList)
}

ToggleImgFavourites(thisImg:=0, actu:=0, directCall:=0) {
  Static lastInvoked := 1, prevImg, prevRemSpeed := 1
  imgPath := thisImg ? thisImg : getIDimage(currentFileIndex)
  isPipe := InStr(imgPath, "||")
  imgPath := StrReplace(imgPath, "||")
  If (A_TickCount - lastInvoked<550) && (directCall=1 && prevImg=imgPath)
     Return

  If (!FileRexists(imgPath) && actu!="rem")
  {
     showTOOLtip("ERROR: The file seems to not exist.`nYou cannot add to favourites inexistent files")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  prevImg := imgPath
  isFaved := isPipe ? 0 : resultedFilesList[currentFileIndex, 5]
  If (!isFaved && actu!="rem")
  {
     If !userAddedFavesCount
        IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)

     If (userAddedFavesCount>maxFavesEntries - 1)
     {
        showTOOLtip("WARNING: You have reached the maximum allowed favourite images: " maxFavesEntries " entries.")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime//2
        Return
     }

     lastInvoked := A_TickCount
     whichFile := (userAddedFavesCount>19) ? mainFavesFile : miniFavesFile
     FileAppend, % imgPath "`n", % mainFavesFile, UTF-8
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list`nThe image was not added to favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     userAddedFavesCount++
     IniAction(1, "userAddedFavesCount", "General")
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     showTOOLtip("Image ADDED to favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " userAddedFavesCount, 0, 0, userAddedFavesCount/maxFavesEntries)
     resultedFilesList[currentFileIndex, 5] := 1
     updateMainUnfilteredList(currentFileIndex, 5, 1)
     If !thisImg
     {
        resultedFilesList[currentFileIndex, 1] := imgPath
        updateMainUnfilteredList(currentFileIndex, 1, imgPath)
     }

     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  } Else
  {
     If (!thisImg && InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
     {
        If !userAddedFavesCount
           IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)

        userAddedFavesCount--
        resultedFilesList[currentFileIndex, 5] := 0
        resultedFilesList[currentFileIndex, 1] := "||" imgPath
        updateMainUnfilteredList(currentFileIndex, 5, 0)
        zPlitPath(imgPath, 0, OutFileName, OutDir)
        IniAction(1, "userAddedFavesCount", "General")
        showTOOLtip("Image REMOVED from favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " userAddedFavesCount, 0, 0, userAddedFavesCount/maxFavesEntries)
        currentFilesListModified := 1
        dummyTimerDelayiedImageDisplay(50)
        lastInvoked := A_TickCount
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     ToolTip, Please wait...
     startZeit := A_TickCount
     lastInvoked := A_TickCount
     IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)
     FileRead, historyList, % mainFavesFile
     FileRead, miniList, % miniFavesFile
     If ErrorLevel
     {
        Tooltip
        showTOOLtip("Failed to read the favourites list file`nUnable to remove image from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     historyList := StrReplace(miniList, imgPath) "`n" StrReplace(historyList, imgPath)
     hash := new hashtable()
     arrayList := []
     doDeduplication := (prevRemSpeed<765 && userAddedFavesCount<12345) ? 1 : 0
     miniF:= fileOpen(miniFavesFile, "w")
     If IsObject(miniF)
        mainF:= fileOpen(mainFavesFile, "w", "UTF-8")

     If (!IsObject(miniF) || !IsObject(mainF))
     {
        Tooltip
        showTOOLtip("Failed to read and write the favourites list file`nUnable to remove image from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If !thisImg
     {
        resultedFilesList[currentFileIndex, 5] := 0
        If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
           resultedFilesList[currentFileIndex, 1] := "||" imgPath

        updateMainUnfilteredList(currentFileIndex, 5, 0)
     }

     ; ToolTip, % doDeduplication "==" prevRemSpeed , , , 2
     Loop, Parse, historyList,`n,`r
     {
         If (realCount>maxFavesEntries)
            Break

         If !RegExMatch(A_LoopField, RegExFilesPattern)
            Continue

         If (doDeduplication=1)
         {
            z := Format("{:L}", A_LoopField)
            w := hash[z]
         }

         If (w!=1)
         {
            realCount++
            If (doDeduplication=1)
               hash[z] := 1

            lineu := A_LoopField "`n"
            If (realCount<20)
               miniF.Write(lineu)
            Else
               mainF.Write(lineu)
         }
     }

     mainF.Close()
     miniF.Close()
     hash := ""
      ; List_MakeUnique(historyList, "`n", 0, 0)
     userAddedFavesCount := realCount
     IniAction(1, "userAddedFavesCount", "General")
     Tooltip
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list file`nThe image was not succesfully removed from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If (doDeduplication=1)
        prevRemSpeed := A_TickCount - startZeit
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     showTOOLtip("Image REMOVED from favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " realCount, 0, 0, realCount/maxFavesEntries)
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  }

  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

retrieveFavesAsList(dummy:=0) {
    If GetKeyState("Ctrl", "P")
       ctrlState := 1

    If askAboutFileSave(". The current files list will be discarded as well")
       Return
 
    If AnyWindowOpen
       BtnCloseWindow()

    If askAboutSlidesListSave()
       Return
 
    showTOOLtip("Loading favourites list, please wait")
    FileRead, historyList, % mainFavesFile
    FileRead, miniList, % miniFavesFile
    historyList := miniList "`n" historyList
    thisList := []
    IniAction(0, "userAddedFavesCount", "General", 4)
    doDeduplication := (userAddedFavesCount<12345) ? 1 : 0
    hash := new hashtable(userAddedFavesCount+50)
    If !ctrlState
       ctrlState := (GetKeyState("Ctrl", "P") || userAddedFavesCount<20101) ? 1 : 0

    ; ToolTip, % "f=" userAddedFavesCount , , , 2
    mustRenewList := countItemz := thisIndexu := 0
    ;  realCount := List_MakeUnique(historyList, "`n", 0, 0)
    Loop, Parse, historyList, `n,`r
    {
       imgu := Trimmer(A_LoopField)
       If (StrLen(imgu)<4 || !RegExMatch(imgu, RegExFilesPattern))
       {
          If A_LoopField
             mustRenewList := 1
          Continue
       }

       posu := InStr(imgu, ":\", 0, -1)
       If (posu>4)
       {
          oimgu := imgu
          imgu := SubStr(imgu, 1, posu - 2)
          bonus := SubStr(oimgu, posu - 1)
          thisIndexu++
          thisList[thisIndexu] := [bonus]
          thisList[thisIndexu, 5] := 1
       }

       If (doDeduplication=1)
       {
         z := Format("{:L}", imgu)
         w := hash[z]
       }

       If (w!=1)
       {
          thisIndexu++
          thisList[thisIndexu] := [imgu]
          thisList[thisIndexu, 5] := 1
          ; If (ctrlState=1)
          If (doDeduplication=1)
             hash[z] := 1
       } Else mustRenewList := 1
    }

   hash := ""
   If (thisIndexu> maxFavesEntries - 1)
      msgBoxWrapper(appTitle ": WARNING", "Please take note, you have exceeded the limit of favourite image entries: " maxFavesEntries ".", 0, 0, "exclamation")

   userAddedFavesCount := thisIndexu
   IniAction(1, "userAddedFavesCount", "General")
   If (thisIndexu<2)
   {
      SoundBeep , 300, 100
      showTOOLtip("Found insufficient favourite images")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   If (SLDtypeLoaded=3)
   {
      SLDtypeLoaded := 0
      activeSQLdb.CloseDB()
   }

   PopulateIndexFilesStatsInfos("kill")
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := "\QPV\favourite-images-list.SLD"
   resultedFilesList := thisList.Clone()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SLDtypeLoaded := 2
   maxFilesIndex := thisList.Count()
   currentFileIndex := (isNumber(dummy)=1 && dummy>0) ? dummy : clampInRange(maxFilesIndex - 2, 1, maxFilesIndex)
   seenEntries := []
   If (mustRenewList=1 || !miniList)
      renewFavesListBasedOnIndexList()

   currentFilesListModified := 0
   If (thumbsDisplaying!=1 && !isNumber(dummy))
      MenuDummyToggleThumbsMode()

   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   GenerateRandyList()
   dummyTimerDelayiedImageDisplay(50)
   showDelayedTooltip("Favourites list loaded`nTotal entries: " groupDigits(maxFilesIndex), 0, 200)
   ; RandomPicture()
}

renewFavesListBasedOnIndexList() {
   ; If StrLen(filesFilter)>1
   ;    Return
   newListu := ""
   realCount := 0
   showTOOLtip("Saving favourites list, please wait")
   Loop, % maxFilesIndex
   {
       ; isFaved := resultedFilesList[currentFileIndex, 5]
       ; If !isFaved
       ;    Continue

       If (realCount>maxFavesEntries)
          Break

       If StrLen(filesFilter)>1
          thisImg := bckpResultedFilesList[filteredMap2mainList[A_Index], 1]
       Else
          thisImg := resultedFilesList[A_Index, 1]

       If (StrLen(thisImg)>3 && !InStr(thisImg, "||"))
       {
          realCount++
          If (A_Index<20)
             miniList .= thisImg "`n"
          Else
             newListu .= thisImg "`n"
       }
   }

   FileDelete, % mainFavesFile
   FileDelete, % miniFavesFile
   Sleep, 150
   ; realCount := List_MakeUnique(newListu, "`n", 0, 0)
   userAddedFavesCount := realCount
   IniAction(1, "userAddedFavesCount", "General")
   FileAppend, % newListu "`n", % mainFavesFile, UTF-8
   FileAppend, % miniList "`n", % miniFavesFile, UTF-8
   If ErrorLevel
   {
      showTOOLtip("ERROR: Unable to save the favourites list file. Unknown cause.")
      SoundBeep, 300, 100
   } Else
   {
      showTOOLtip("Favourites list saved")
      SoundBeep, 900, 100
   }

   currentFilesListModified := 0
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

eraseAllFavedIMGs() {
  msgResult := msgBoxWrapper(appTitle ": Favourites", "Are you sure you want to remove all the entries from the favourites list?", 4, 0, "question")
  If !InStr(msgResult, "yes")
     Return
  
  FileDelete, % mainFavesFile
  FileDelete, % miniFavesFile
  userAddedFavesCount := 0
  IniAction(1, "userAddedFavesCount", "General")
  showTOOLtip("All entries from the favourites list were removed.")
  SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

RandomPicture(dummy:=0, inLoop:=0) {
   ; Static inLoop := 0
   If (maxFilesIndex=0 || maxFilesIndex="") && (!CurrentSLD)
      Return

   currentFileIndex := coreNextPrevImage(1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

PrevRandyPicture(dummy:=0, inLoop:=0) {
   resetSlideshowTimer(0)
   currentFileIndex := coreNextPrevImage(-1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

getSelectedFiles(getItem:=0, forceSort:=0) {
   Static firstItem, lastItem, lastIDcount := 0

   If (getItem=0 && forceSort=0)
      Return markedSelectFile

   If (getItem=1 && markedSelectFile)
      Return firstItem

   If (getItem="L" && markedSelectFile)
      Return lastItem

   If (forceSort=1 && getItem=0)
   {
      thisIDcount := CurrentSLD maxFilesIndex bckpMaxFilesIndex markedSelectFile lastZeitFileSelect
      If (lastIDcount=thisIDcount)
         Return markedSelectFile

      ; ToolTip, % thisIDcount "`n" lastIDcount , , , 2
      lastIDcount := thisIDcount
      firstItem := lastItem := markedSelectFile := 0
      changeMcursor()
      startZeit := A_TickCount
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]=1)
         {
            markedSelectFile++
            lastItem := A_Index
            If !firstItem
               firstItem := A_Index
         }
      }

      If (markedSelectFile=1)
      {
         markedSelectFile := 0
         resultedFilesList[firstItem, 2] := 0
         lastZeitFileSelect := A_TickCount
         If (thumbsDisplaying=1)
            mainGdipWinThumbsGrid()
      }
      changeMcursor("normal")
      Return markedSelectFile
   }
}

filterToFilesSelection() {
   userFilterProperty := 19
   userFilterDoString := 0
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   dummyTimerDelayiedImageDisplay(50)
}

invertFilesSelection(silentMode:=0) {
   If (thumbsDisplaying!=1 || maxFilesIndex<3)
      Return

   markedSelectFile := 0
   Loop, % maxFilesIndex
   {
       sel := resultedFilesList[A_Index, 2]
       resultedFilesList[A_Index, 2] := !sel
       If (sel!=1)
          markedSelectFile++
   }

   lastZeitFileSelect := A_TickCount
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)

   showTOOLtip("Files selection inverted`n" markedSelectFile " files are now selected")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dropFilesSelection(silentMode:=0) {
   If (!markedSelectFile && silentMode=1)
      Return

   EntryMarkedMoveIndex := markedSelectFile := 0
   Loop, % maxFilesIndex
       resultedFilesList[A_Index, 2] := 0

   lastZeitFileSelect := A_TickCount
   ; selectAllFiles("none")
   ; ToolTip, % A_TickCount - startZeit, , , 2
   If (silentMode!=1)
   {
      showTOOLtip("Files selection dropped")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (thumbsDisplaying=1)
         mainGdipWinThumbsGrid()
      Else
         dummyTimerDelayiedImageDisplay(50)
   }
}

MenuMarkThisFileNow() {
   markThisFileNow()
}

markThisFileNow(thisFileIndex:=0) {
  If (currentFileIndex=0  || maxFilesIndex<2 || AnyWindowOpen>0)
     Return

  If !thisFileIndex
     thisFileIndex := currentFileIndex

  oSel := resultedFilesList[thisFileIndex, 2]
  sel := oSel ? 0 : 1
  resultedFilesList[thisFileIndex, 2] := sel
  sel := (oSel && !sel) ? 0 : 1

  If sel
     markedSelectFile++
  Else
     markedSelectFile--

  lastZeitFileSelect := A_TickCount
  If (markedSelectFile<0)
     getSelectedFiles(0, 1)
  Else If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
  Else
     dummyTimerDelayiedImageDisplay(25)
}

jumpToFilesSelBorderFirst() {
   jumpToFilesSelBorder(-1)
}

jumpToFilesSelBorderLast() {
   jumpToFilesSelBorder(1)
}

jumpToFilesSelBorder(destination) {
  Static prevImgIndex, prevIndexu

  If (slideShowRunning=1)
     ToggleSlideShowu()

  totalCount := getSelectedFiles(0, 1)
  If !totalCount
  {
     RandyIMGnow := currentFileIndex := (destination=-1) ? RandyIMGids[1] : RandyIMGids[maxFilesIndex]
     dummyTimerDelayiedImageDisplay(50)
     Return
  }

  theFirst := getSelectedFiles(1)
  theLast := getSelectedFiles("L")
  currentFileIndex := (destination=-1) ? theFirst : theLast
  FriendlyName := (destination=-1) ? "First" : "Last"
  dummyTimerDelayiedImageDisplay(50)
  showTOOLtip(FriendlyName " selected element index: " currentFileIndex "`n" markedSelectFile " total images selected")
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

navSelectedFilesNext() {
   navSelectedFiles(1)
}

navSelectedFilesPrev() {
   navSelectedFiles(1)
}

navSelectedFiles(direction) {
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   changeMcursor()

   If !markedSelectFile
   {
      getSelectedFiles(0, 1)
      If !markedSelectFile
      {
         changeMcursor("normal")
         CurrentSLD := backCurrentSLD
         showTOOLtip("No files are currently selected")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   startIndex := currentFileIndex
   newIndex := 0
   Loop, % maxFilesIndex
   {
        thisIndex := (direction=-1) ? currentFileIndex - A_Index : currentFileIndex + A_Index
        r := getIDimage(thisIndex)
        isSelected := resultedFilesList[thisIndex, 2]
        If (isSelected!=1 || !r || InStr(r, "||"))
           Continue

        If (skipDeadFiles=1)
        {
           If !FileRexists(r)
           {
              Continue
           } Else
           {
              newIndex := thisIndex
              Break
           }
        } Else
        {
           newIndex := thisIndex
           Break
        }
   }

   CurrentSLD := backCurrentSLD
   changeMcursor("normal")
   If (!newIndex && direction=-1)
   {
      jumpToFilesSelBorderLast()
      Return
   } Else If (!newIndex && direction=1)
   {
      jumpToFilesSelBorderFirst()
      Return
   }

   currentFileIndex := (newIndex) ? newIndex : startIndex
   dummyTimerDelayiedImageDisplay(25)
}

coreSearchIndex(imgPath, givenRegEx, whatu, invertu:=0) {
   If !givenRegEx
      Return
   ; ToolTip, % imgPath "`n" givenRegEx , , , 2
   If (whatu=1)
   {
     stringu := imgPath
   } Else ; If (userSearchWhat=1)
   {
     parentu := zPlitPath(imgPath, 1, OutFileName, OutDir)
     If (whatu=2)
        stringu := OutDir
     Else If (whatu=3)
        stringu := OutFileName
     Else If (whatu=4)
        stringu := parentu
   }

   ; ToolTip, % stringu "`n" thisSearchString "`n" z , , , 2
   If !invertu
      Return RegExMatch(stringu, givenRegEx)
   Else
      Return RegExMatch(stringu, givenRegEx) ? 0 : 1
}

processSearchIndexString(inputu) {
   testRegEx := SubStr(inputu, 1, 2)
   If (testRegEx="\>" && StrLen(inputu)>2)
   {
      thisFilter := SubStr(inputu, 3)
   } Else If (InStr(inputu, ">") && StrLen(inputu)>1)
   {
      thisFilter := StrReplace(inputu, ">")
      If thisFilter
         thisFilter := "i)(" JEE_StrRegExLiteral(thisFilter) ")$"
   } Else If (InStr(inputu, "/") && StrLen(inputu)>1)
   {
      thisFilter := StrReplace(inputu, "/")
      If thisFilter
         thisFilter := "i)^(" JEE_StrRegExLiteral(thisFilter) ")"
   } Else If inputu
      thisFilter := "i)(" JEE_StrRegExLiteral(inputu) ")"

   Return thisFilter
}

searchNextIndex(direction, inLoop:=0) {
   thisFilter := processSearchIndexString(userSearchString)
   If !thisFilter
   {
      thisSearchString := userSearchString := ""
      SetTimer, PanelSearchIndex, -100
      Return
   }

   thisSearchString := thisFilter
   friendly := (direction=-1) ? "previous" : "next"
   showTOOLtip("Searching " friendly " in index matching:`n" userSearchString)
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   originalIndex := startIndex := currentFileIndex
   If (inLoop=1)
      startIndex := (direction=1) ? 0 : maxFilesIndex

   newIndex := 0
   setImageLoading()
   Loop, % maxFilesIndex
   {
        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        imgPath := getIDimage(thisIndex)
        If (!coreSearchIndex(imgPath, thisSearchString, userSearchWhat) || !imgPath)
           Continue

        If (skipDeadFiles=1 && thumbsDisplaying!=1)
        {
           If !FileExist(imgPath)
           {
              Continue
           } Else
           {
              newIndex := thisIndex
              Break
           }
        } Else
        {
           newIndex := thisIndex
           Break
        }
   }

   ResetImgLoadStatus()
   CurrentSLD := backCurrentSLD
   If (!newIndex && inLoop!=1)
   {
      searchNextIndex(direction, 1)
      Return
   }

   If (!newIndex && inLoop=1)
   {
      showTOOLtip("WARNING: No indexed file matched the search criteria:`n" userSearchString)
      userSearchString := ""
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep , 900, 100
      Return
   }

   RemoveTooltip()
   currentFileIndex := newIndex ? newIndex : originalIndex
   dummyTimerDelayiedImageDisplay(25)
}

setContaintFolderAsProtected(givenPath:=0) {
     imgPath := FolderExist(givenPath) ? givenPath : getIDimage(currentFileIndex)
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     protectedFolderPath := OutDir
     preventDeleteFromProtectedPath := 1
     IniAction(1, "protectedFolderPath", "General")
     IniAction(1, "preventDeleteFromProtectedPath", "General")
     showTOOLtip("The protected folder path is now:`n" OutDir "\")
     SetTimer, RemoveTooltip, % -msgDisplayTime
}

PanelMultiFileDelete() {
    Static lastInvoked := 1

    thisBtnHeight := createSettingsGUI(16, A_ThisFunc, 0)
    filesElected := getSelectedFiles(0, 1)
    btnWid := 120
    txtWid := 290
    If (PrefsLargeFonts=1)
    {
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    IniAction(0, "userMultiDelChoice", "General", 2, 1, 3)
    IniAction(0, "preventDeleteFromProtectedPath", "General", 1)
    IniAction(0, "protectedFolderPath", "General")
    If (A_TickCount - lastInvoked>10500)
       move2recycler := 1 

    If !userSearchString
       preventDeleteMatchingSearch := 0

    If !protectedFolderPath
       preventDeleteFromProtectedPath := 0

    lastInvoked := A_TickCount
    thisInfo := protectedFolderPath ? protectedFolderPath "\" : "NONE"
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please choose what to remove:
    Gui, Add, DropDownList, y+10 wp gTglMultiDelChoice AltSubmit Choose%userMultiDelChoice% vuserMultiDelChoice, Delete selected files|Remove file entries from the list|Do both: remove files and the index entries
    Gui, Add, Checkbox, y+10 gTglOptionMove2recycler Checked%move2recycler% vmove2recycler, Move to Recycle Bin the deleted files
    Gui, Add, Checkbox, y+10 Checked%preventDBentryRemoval% vpreventDBentryRemoval, Do not remove the entries from the database 
    Gui, Add, Checkbox, y+10 Checked%preventDeleteMatchingSearch% vpreventDeleteMatchingSearch, Skip the files that match the files list search criteria
    Gui, Add, Checkbox, y+10 Checked%preventDeleteFromProtectedPath% vpreventDeleteFromProtectedPath, Skip the files found in the protected folder:
    Gui, Add, Text, xp+15 y+10 w%txtWid%, % thisInfo
    Gui, Font, Bold
    Gui, Add, Text, xs y+20, % "Selected entries: " groupDigits(filesElected) "." 
    Gui, Font, Normal
    If (SLDtypeLoaded!=3 || userMultiDelChoice=1)
       GuiControl, Disable, preventDBentryRemoval

    If (userMultiDelChoice=2)
       GuiControl, Disable, move2recycler

    If !protectedFolderPath
       GuiControl, Disable, preventDeleteFromProtectedPath

    If !userSearchString
       GuiControl, Disable, preventDeleteMatchingSearch

    Gui, Add, Button, xs y+15 h%thisBtnHeight% w%btnWid% gBTNactiveFileDel, &Delete active file only
    Gui, Add, Button, x+5 hp w95 gBTNmultiDel Default, &Proceed
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Delete files: " appTitle)
}

BTNactiveFileDel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, preventDBentryRemoval

   BtnCloseWindow()
   DeleteActivePicture()
   getSelectedFiles(0, 1)
   preventDBentryRemoval := 0
}

DeleteActivePicture() {
   DeletePicture("single")
   getSelectedFiles(0, 1)
}

BTNmultiDel() {
   Critical, on
   Gui, SettingsGUIA: Default
   GuiControlGet, preventDBentryRemoval
   GuiControlGet, preventDeleteMatchingSearch
   GuiControlGet, preventDeleteFromProtectedPath
   IniAction(1, "preventDeleteFromProtectedPath", "General")
   Sleep, 10
   TglOptionMove2recycler()
   If (userMultiDelChoice=3 || userMultiDelChoice=1)
      r := batchFileDelete()
   Else r := 0

   If (userMultiDelChoice=3 || userMultiDelChoice=2) && (r=0)
   {
      If (userMultiDelChoice=3)
      {
         BtnCloseWindow()
         Sleep, 500
      }
      InListMultiEntriesRemover(0, "y")
   }
   preventDBentryRemoval := 0
   If (r=0)
      BtnCloseWindow()
}

TglMultiDelChoice() {
  TglOptionMove2recycler()
}

TglOptionMove2recycler() {
  Gui, SettingsGUIA: Default
  GuiControlGet, move2recycler
  GuiControlGet, userMultiDelChoice
  If (SLDtypeLoaded=3)
  {
     GuiControlGet, preventDBentryRemoval
     If (userMultiDelChoice=1)
        GuiControl, SettingsGUIA: Disable, preventDBentryRemoval
     Else
        GuiControl, SettingsGUIA: Enable, preventDBentryRemoval
  }

  INIaction(1, "userMultiDelChoice", "General")
  If (userMultiDelChoice=1 || userMultiDelChoice=3)
     GuiControl, SettingsGUIA: Enable, move2recycler
  Else
     GuiControl, SettingsGUIA: Disable, move2recycler
}

batchFileDelete() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected<2)
      Return
   
   If (filesElected>50 && move2recycler!=1) || (filesElected>95 && move2recycler=1)
   {
      msgInfos := (move2recycler=1) ? " " : "`n`nThe files will be PERMANENTLY deleted."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete " groupDigits(filesElected) " files?" msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return 1
   }

   If AnyWindowOpen
      BtnCloseWindow()

   friendly := (move2recycler=1) ? "Moving to recycle bin" : "Permanently deleting"
   showTOOLtip(friendly A_Space groupDigits(filesElected) " files, please wait")
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   destroyGDIfileCache()
   doStartLongOpDance()
   filesRemoved := abandonAll := failedFiles := skippedFiles := 0
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If failedFiles
            etaTime .= "`nFailed to remove " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip(friendly " selected files, please wait" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      file2rem := StrReplace(file2rem, "||")
      If (preventDeleteMatchingSearch=1 && file2rem && userSearchString)
      {
         If coreSearchIndex(file2rem, thisSearchString, userSearchWhat)
         {
            skippedFiles++
            Continue
         }
      }

      If (preventDeleteFromProtectedPath=1 && protectedFolderPath)
      {
         zPlitPath(file2rem, 0, OutFileName, OutDir)
         If (protectedFolderPath=OutDir)
         {
            skippedFiles++
            Continue
         }
      }

      Try FileSetAttrib, -R, %file2rem%
      Sleep, 0
      changeMcursor()
      If (move2recycler=1)
         FileRecycle, %file2rem%
      Else
         FileDelete, %file2rem%

      If !ErrorLevel
      {
         filesRemoved++
         resultedFilesList[thisFileIndex, 1] := "||" file2rem
         ; resultedFilesList[thisFileIndex, 2] := 1
         updateMainUnfilteredList(thisFileIndex, 1, "||" file2rem)
      } Else failedFiles++
   }

   currentFilesListModified := 1
   If failedFiles
      someErrors := "Failed to delete " groupDigits(failedFiles) " files`n"
   If skippedFiles
      someErrors .= groupDigits(skippedFiles) " files were skipped`n"

   watchFolderDetails := ""
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   If (abandonAll=1)
   {
      SoundBeep, 300, 100
      showTOOLtip(someErrors "Operation aborted. " groupDigits(filesRemoved) " out of " groupDigits(countTFilez) " selected files deleted until now")
   } Else
   {
      SoundBeep, 900, 100
      showTOOLtip(someErrors groupDigits(filesRemoved) " out of " groupDigits(countTFilez) " selected files deleted")
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return abandonAll
}

DeletePicture(dummy:=0) {
  Static lastInvoked := 1, prevDelFileIndex := -1
  getSelectedFiles(0, 1)
  If (markedSelectFile>1 && dummy!="single")
  {
     PanelMultiFileDelete()
     Return
  }

  If (slideShowRunning=1)
  {
     ToggleSlideShowu()
     Return
  }

  If (A_TickCount - lastInvoked<200) && (askDeleteFiles!=1)
  {
     lastInvoked := A_TickCount
     Return
  }

  file2rem := getIDimage(currentFileIndex)
  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir)
  If (askDeleteFiles=1 && dummy!="single") || (editingSelectionNow=1 && thumbsDisplaying!=1)
  {
     msgTimer := A_TickCount
     fakeWinCreator(37, A_ThisFunc, 1)
     msgResult := msgBoxWrapper(appTitle "panelu|: Confirmation", "Please confirm you want to delete this image file.`n`n" OutFileName "`n`n" OutDir "\", "&Remove index entry|&Delete|&Cancel", 3, "trash", "Permanently delete file, do not move to recycle bin", 0, "Always prompt before file delete`f`fNo longer prompt before file delete in this session`fNever prompt before file delete")
     If InStr(msgResult.btn, "Delete")
     {
        good2go := 1
     } Else If InStr(msgResult.btn, "remove index")
     {
        remCurrentEntry(0, 0)
        Return
     }

     If (A_TickCount - msgTimer < 550) && InStr(msgResult.btn, "Delete")
     {
        showTOOLtip("Operation aborted. User answered ""Yes"" too fast.")
        SetTimer, RemoveTooltip, % -msgDisplayTime
        good2go := 0
        Return
     }
  } Else good2go := 1

  If (msgResult.list>1 && good2go=1 && msgResult.check!=1)
  {
     askDeleteFiles := 0
     If (msgResult.list=3)
        INIaction(1, "askDeleteFiles", "General")
  }

  If (good2go!=1) || (imageLoading=1 && animGIFplaying!=1)
  {
     SetTimer, ResetImgLoadStatus, -50
     Return
  }

  Sleep, 2
  If (animGIFplaying=1)
  {
     DestroyGIFuWin()
     showDelayedTooltip("GIF animation stopped", 0, 250)
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  Sleep, 2
  if (!UserMemBMP && thumbsDisplaying!=1)
  {
     prevDelFileIndex := currentFileIndex
     UserMemBMP := cloneGDItoMem(A_ThisFunc, gdiBitmap)
  }

  destroyGDIfileCache(0, 1)
  Try FileSetAttrib, -R, %file2rem%
  Sleep, 1

  shiftState := (GetKeyState("Shift", "P") && askDeleteFiles!=1) ? 1 : 0
  If (msgResult.check=1) || (shiftState=1)
     FileDelete, %file2rem%
  Else
     FileRecycle, %file2rem%

  If ErrorLevel
  {
     If (thumbsDisplaying=1 && !FileExist(file2rem))
     {
        If (prevDelFileIndex=currentFileIndex)
           terminateIMGediting()

        remCurrentEntry(0, 0)
     } Else
     {
        showTOOLtip("ERROR: File already deleted or access denied`n" OutFileName "`n" OutDir "\")
        SoundBeep, 300, 100
     }
  } Else
  {
     If (SLDtypeLoaded=3)
        selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

     resultedFilesList[currentFileIndex, 1] := "||" file2rem
     updateMainUnfilteredList(currentFileIndex, 1, "||" file2rem)
     If (msgResult.check=1) || (shiftState=1)
        showTOOLtip("File permanently deleted`n" OutFileName "`n" OutDir "\")
     Else
        showTOOLtip("File moved to recycle bin`n" OutFileName "`n" OutDir "\")

     If (deleteFileActAfter=2)
        NextPicture(0, 0, 1)
     Else If (deleteFileActAfter=3)
        PreviousPicture(0, 0, 1)
  }

  preventDBentryRemoval := 0
  Sleep, 2
  watchFolderDetails := ""
  lastInvoked := A_TickCount
  SetTimer, RemoveTooltip, % -msgDisplayTime
  SetTimer, ResetImgLoadStatus, -50
  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

readRecentMultiRenameEntries() {
   entriesList := ""
   Loop, 35
   {
       IniRead, newEntry, % mainRecentsFile, RecentMultiRename, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>1 && !InStr(entriesList, newEntry "`n"))
          entriesList .= newEntry "`n"
   }
   Return entriesList
}

PanelMultiRenameFiles() {
    Global UsrEditNewFileName
    If (maxFilesIndex<2)
       Return

    thisBtnHeight := createSettingsGUI(8, A_ThisFunc, 0)
    btnWid := 100
    txtWid := 390
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       txtWid := txtWid + 220
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "PreserveDateTimeOnSave", "General", 1)
    getSelectedFiles(0, 1)
    listu := readRecentMultiRenameEntries()
    Gui, +Delimiter`n
    Gui, Add, Text, x15 y15 w%txtWid%, Selected files: %markedSelectFile%. Type a pattern to rename the files.
    Gui, Add, ComboBox, y+10 w%EditWid% gMultiRenameComboAction vUsrEditNewFileName, % listu
    Gui, Add, ListView, xp y+1 wp -multi r12 Grid vLViewOthers +hwndhLVmainu, #`nOriginal file name`nNew file name`nFolder
    Gui, Add, Checkbox, y+7 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Text, y+10, In case of file name collisions, you will be prompted.

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gcoreBatchMultiRenameFiles, &Rename files
    Gui, Add, Button, x+5 hp w%btnWid% gEraseMultiRenameHisto, Erase &history
    Gui, Add, Button, x+5 hp w85 gBtnHelpMultiRename, H&elp
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Rename multiple files: " appTitle)
}

BtnHelpMultiRename() {
    GuiControlGet, PreserveDateTimeOnSave
    INIaction(1, "PreserveDateTimeOnSave", "General")
    msgBoxWrapper(appTitle ": HELP", "File extensions remain unchanged regardless of the pattern used. File rename patterns possible:`n`na) Whatever file prefix [this] or suffix with tokens`n[this] - file name`n[pfdname] - parent folder name`n[fDateM] or [fDateC] - file modified/created date`n[counter] - files counter.`ntrim{X,Y} - a function usable only once in the pattern. X and Y designate how many letters to trim from the beginning and/or end of the original file name.`n`nb) Replace string//with this one`nUse // to perform search and replace in file names. Begin with \> to use RegEx. Trim function and the tokens mentioned earlier can be used only after //.`n`nc) abcdefgh01234>>any string`nEvery enumerated character before >> will be replaced with a single character or a string specified after >>. The tokens from a) can be used after >>.`n`nd) any file name without tokens`nThe files will be counted according to their containing folder. This is to avoid naming conflicts and applies only if [this], >> and // are not used.", -1, 0, 0)
}

MultiRenameComboAction() {
   If (A_GuiControlEvent="DoubleClick")
      coreBatchMultiRenameFiles()
   Else
      PopulateLVmultiRename()
}

decideMultiRename(ByRef OriginalNewFileName) {
  obju := []
  obju.renamingCount := 0
  obju.TrimmingMode := 0
  obju.rechecherRemplaceMode := 0
  obju.charsRemplaceMode := 0
  obju.regExRemplaceMode := 0
  obju.IndexModeCount := 0
  If (Trimmer(OriginalNewFileName)="[counter]")
     OriginalNewFileName := "[this] ([counter])"

  matchFoundPosA := RegExMatch(OriginalNewFileName, "i)trim\{..?.?\, ?..?.?\}", matchedStringu)
  If InStr(OriginalNewFileName, "//")
     strArr := StrSplit(OriginalNewFileName, "//")
  Else If InStr(OriginalNewFileName, "\\")
     strArr := StrSplit(OriginalNewFileName, "\\")
  Else If InStr(OriginalNewFileName, ">>")
     chrStrArr := StrSplit(OriginalNewFileName, ">>")
  Else If (!InStr(OriginalNewFileName, "[this]") && !matchedStringu)
     obju.renamingCount := 1

  If (InStr(OriginalNewFileName, "[counter]") && obju.renamingCount!=1)
     obju.IndexModeCount := 1

  If (IsObject(strArr) && obju.renamingCount!=1)
  {
     testRegEx := SubStr(strArr[1], 1, 2)
     If (testRegEx="\>")
     {
        obju.regExRemplaceMode := 1
        obju.strArrA := SubStr(strArr[1], 3)
        obju.strArrB := strArr[2]
     } Else
     {
        obju.strArrA := filterFileName(strArr[1]) ? strArr[1] : ""
        obju.strArrB := filterFileName(strArr[2]) ? strArr[2] : ""
     }

     If (obju.strArrA="")
        Return "err"
     ; If (obju.strArrB="" && StrLen(obju.strArr[2])>0)
     ;    Return "err"

     obju.rechecherRemplaceMode := 1 
  } Else If (IsObject(chrStrArr) && obju.renamingCount!=1)
  {
     obju.strArrA := filterFileName(chrStrArr[1]) ? chrStrArr[1] : ""
     obju.strArrB := filterFileName(chrStrArr[2]) ? chrStrArr[2] : ""
     If (obju.strArrA="")
        Return "err"

     obju.charsRemplaceMode := 1 
  } Else obju.newName := filterFileName(OriginalNewFileName)

  If (obju.renamingCount!=1)
  {
     obju.origMatchedStringu := matchedStringu
     matchedStringu := StrReplace(matchedStringu, A_Space)
     matchedStringu := StrReplace(matchedStringu, A_Space)
     matchedStringu := StrReplace(matchedStringu, .)
     matchedStringu := StrReplace(matchedStringu, "trim{")
     matchedStringu := StrReplace(matchedStringu, "}")
     If InStr(matchedStringu, ",")
     {
        trimuObj := StrSplit(matchedStringu, ",")
        obju.leftTrimu := trimuObj[1]
        obju.righttTrimu := trimuObj[2]
        obju.TrimmingMode := (isNumber(obju.leftTrimu) && isNumber(obju.righttTrimu)) ? 1 : 0
     }
     ; ToolTip, % obju.origMatchedStringu "`n" matchedStringu "`n" trimuObj[1] "==" trimuObj[2] , , , 2
  }

  Return obju
}

ChrReplace(string, chars, replacer) {
   If (chars!="")
      Loop, Parse, chars
           string := StrReplace(string, A_LoopField, replacer)

   Return string
}

decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez, parentFolderName, imgPath, obju) {
   If (obju.regExRemplaceMode=1)
      newFileName := RegExReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.rechecherRemplaceMode=1)
      newFileName := StrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.charsRemplaceMode=1)
      newFileName := ChrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (!InStr(OriginalNewFileName, "[this]") && obju.TrimmingMode!=1)
      newFileName := OriginalNewFileName " (" countFilez ")"
   Else ; If (obju.TrimmingMode=1)
      newFileName := OriginalNewFileName

   If (InStr(newFileName, "[pfdname]") && InStr(OriginalNewFileName, "[pfdname]"))
      newFileName := StrReplace(newFileName, "[pfdname]", parentFolderName)

   If (InStr(newFileName, "[counter]") && InStr(OriginalNewFileName, "[counter]") && obju.IndexModeCount=1)
      newFileName := StrReplace(newFileName, "[counter]", countFilez)

   If (InStr(newFileName, "[fDateM]") && InStr(OriginalNewFileName, "[fDateM]"))
   {
      FileGetTime, dateu, % imgPath, M
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateM]", dateu)
   }

   If (InStr(newFileName, "[fDateC]") && InStr(OriginalNewFileName, "[fDateC]"))
   {
      FileGetTime, dateu, % imgPath, C
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateC]", dateu)
   }

   If (InStr(newFileName, "[this]") && InStr(OriginalNewFileName, "[this]"))
      newFileName := StrReplace(newFileName, "[this]", fileNamuNoEXT)

   If (obju.TrimmingMode=1 && obju.origMatchedStringu && obju.renamingCount!=1)
   {
      clampedL := clampInRange(obju.leftTrimu + 1, 0, StrLen(fileNamuNoEXT) - 1)
      trimmedFileName := SubStr(fileNamuNoEXT, clampedL)
      clampedR := clampInRange(obju.righttTrimu, 1, StrLen(trimmedFileName) - 1)
      If (obju.righttTrimu>0)
         trimmedFileName := SubStr(trimmedFileName, 1, StrLen(trimmedFileName) - clampedR)
      newFileName := StrReplace(newFileName, obju.origMatchedStringu, trimmedFileName)
      ; ToolTip, % clampedL "==" clampedR "`n" trimmedFileName "`n" newFileName , , , 2
   }
   ; ToolTip, % obju.TrimmingMode "==" obju.origMatchedStringu "==" obju.renamingCount , , , 2

   Return newFileName
}

PopulateLVmultiRename() {
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditNewFileName
  Gui, SettingsGUIA: ListView, LViewOthers
  LV_Delete()

  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  If (OriginalNewFileName="[this]" || OriginalNewFileName="trim{" || OriginalNewFileName="\\" || OriginalNewFileName="//")
     Return

  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp="err")
     Return

  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName
  
  loopzu := 0
  If (StrLen(OriginalNewFileName)>1)
  {
     filesElected := getSelectedFiles(0, 1)
     If (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"


     Loop, % maxFilesIndex
     {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         thisFileIndex := A_Index
         imgPath := getIDimage(thisFileIndex)
         parentFolderName := zPlitPath(imgPath, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)

         If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
         {
            OutDirAsc := StringToASC(OutDir)
            Try countFilez%OutDirAsc%++
         }

         If (objuTemp.IndexModeCount=1)
            countFilez%OutDirAsc%++

         newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez%OutDirAsc%, parentFolderName, imgPath, objuTemp)
         file2save := OutDir "\" newFileName "." fileEXTu

         If (file2save=imgPath || newFileName="" || newFileName=A_Space)
            Continue

         loopzu++
         LV_Add(A_Index, thisFileIndex, OutFileName, newFileName "." fileEXTu, OutDir "\")
         ; ToolTip, % A_Index , , , 2
         If (loopzu>=999)
            Break
     }
  }

  ; Loop, 3
  ;    LV_ModifyCol(A_Index, "AutoHdr Left")

}

coreBatchMultiRenameFiles() {
  Critical, on
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditNewFileName
  GuiControlGet, PreserveDateTimeOnSave

  INIaction(1, "PreserveDateTimeOnSave", "General")
  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  If (OriginalNewFileName="[this]" || OriginalNewFileName="trim{" || OriginalNewFileName="\\" || OriginalNewFileName="//")
     Return

  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp="err")
     Return

  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName

  If (StrLen(OriginalNewFileName)>1)
  {
     filesElected := getSelectedFiles(0, 1)
     If (filesElected>100)
     {
        msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to rename the selected files.`n`nYou have selected " filesElected " files to be renamed...", 4, 0, "question")
        If (msgResult!="Yes")
           Return
     }

     BtnCloseWindow()
     showTOOLtip("Renaming " filesElected " files, please wait`nPattern: " OriginalNewFileName)
     startOperation := A_TickCount
     prevMSGdisplay := A_TickCount
     destroyGDIfileCache()
     RecentMultiRenamesManager(OriginalNewFileName)
     doStartLongOpDance()
     If (SLDtypeLoaded=3)
        activeSQLdb.Exec("BEGIN TRANSACTION;")

     filezRenamed := countFilez := 0
     countTFilez := skippedFiles := failedFiles := overwrittenFiles := 0
     nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
     if (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"

     BtnCloseWindow()
     Loop, % maxFilesIndex
     {
         wasError := 0
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         changeMcursor()
         thisFileIndex := A_Index
         file2rem := getIDimage(thisFileIndex)
         parentFolderName := zPlitPath(file2rem, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)
         countTFilez++
         If !FileExist(file2rem)
         {
            failedFiles++
            Continue
         }

         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            someErrors := ETAinfos(countTFilez, filesElected, startOperation)
            If (failedFiles>0)
               someErrors .= "`n" groupDigits(failedFiles) " files failed to rename"
            If (skippedFiles>0)
               someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"
            If (overwrittenFiles>0)
               someErrors .= "`n" groupDigits(overwrittenFiles) " files were overwritten"

            showTOOLtip("Renaming selected files, please wait`nPattern: " OriginalNewFileName someErrors, 0, 0, countTFilez/filesElected)
            prevMSGdisplay := A_TickCount
         }

         If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
         {
            OutDirAsc := (objuTemp.IndexModeCount=1) ? "a" : StringToASC(OutDir)
            Try countFilez%OutDirAsc%++
         }

         If (objuTemp.IndexModeCount=1)
            countFilez%OutDirAsc%++

         newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez%OutDirAsc%, parentFolderName, file2rem, objuTemp)
         file2save := OutDir "\" newFileName "." fileEXTu
         If (file2save=file2rem || newFileName="" || newFileName=A_Space)
         {
            skippedFiles++
            Continue
         }

         thisFileExists := 0
         If (PreserveDateTimeOnSave=1)
         {
            FileGetTime, originalMtime, %file2save%, M
            FileGetTime, originalCtime, %file2save%, C
         }

         If (FileExist(file2save) && !FolderExist(file2save))
         {
            thisFileExists := 1
            file2save := askAboutFileCollision(file2rem, file2save, 1, 0, 0, performOverwrite)
            If !file2save
            {
               skippedFiles++
               Continue
            } Else If (file2save="abort")
            {
               abandonAll := 1
               Break
            }
         }

         If (thisFileExists=1)
         {
            If (performOverwrite=1 && objuTemp.renamingCount!=1)
            {
               overwrittenFiles++
               FileSetAttrib, -R, %file2save%
               Sleep, 1
               FileRecycle, %file2save%
               If ErrorLevel
                  wasError++
               Sleep, 1
            } Else If (performOverwrite!=2)
            {
               skippedFiles++
               Continue
            }
         }

         FileSetAttrib, -R, %file2rem%
         Sleep, 1
         FileMove, %file2rem%, %file2save%
         If ErrorLevel
         {
            failedFiles++
            wasError++
         } Else
         {
            updateDates := 1
            If (originalMtime && PreserveDateTimeOnSave=1)
            {
               Sleep, 0
               FileSetTime, % originalMtime, % file2save, M
               FileSetTime, % originalCtime, % file2save, C
               updateDates := 0
            } 

            filezRenamed++
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[thisFileIndex, 12])

            resultedFilesList[thisFileIndex, 1] := file2save
            ; resultedFilesList[thisFileIndex, 2] := 1
            updateMainUnfilteredList(thisFileIndex, 1, file2save)
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }

     someErrors := ""
     If (SLDtypeLoaded=3)
     {
        If !activeSQLdb.Exec("COMMIT TRANSACTION;")
           someErrors .= "Failed to commit changes to the SQL database`n"
     }

     If (failedFiles>0)
        someErrors .= "`n" groupDigits(failedFiles) " files failed to rename"
     If (skippedFiles>0)
        someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"
     If (overwrittenFiles>0)
        someErrors .= "`n" groupDigits(overwrittenFiles) " files were overwritten"

     watchFolderDetails := ""
     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(100)
     If (abandonAll=1)
        showTOOLtip("Operation aborted. " groupDigits(filezRenamed) " out of " groupDigits(filesElected) " selected files were renamed" someErrors)
     Else
        showTOOLtip("Finished renaming " groupDigits(filezRenamed) " out of " groupDigits(filesElected) " selected files" someErrors)
     SetTimer, ResetImgLoadStatus, -50
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
  }
}

RecentMultiRenamesManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentMultiRenameEntries()
  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>35)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentMultiRename, E%countItemz%
  }
}

EraseMultiRenameHisto() {
  IniDelete, % mainRecentsFile, RecentMultiRename
  CloseWindow()
  Sleep, 1
  PanelRenameThisFile()
}

PanelOlderThanEraseThumbsCache() {
   If AnyWindowOpen
      Return

   fakeWinCreator(11, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Clear cached thumbnails: " appTitle, "Erase thumbnails cached older than... (in days)", "&Clean old cache|&Empty entire cache|C&ancel", 3, "trash", "&Always cache generated thumbnails", enableThumbsCaching, 0, "limit3 number -multi", 0)
   remCacheOldDays := Trimmer(msgResult.edit)
   If InStr(msgResult.btn, "old")
   {
      enableThumbsCaching := msgResult.check
      If !remCacheOldDays
         SetTimer, PanelOlderThanEraseThumbsCache, -150 ; allows for this execution line to cease peacefully ^_^ 
      Else
         EraseThumbsCache("daysITis", remCacheOldDays)
   } Else If InStr(msgResult.btn, "entire")
   {
      enableThumbsCaching := msgResult.check
      EraseThumbsCache()
   }
}

defineSQLdbSort() {
   reorder := StrLen(prevFilesSortMode)>3 ? "z" prevFilesSortMode ";" : ";"
   If InStr(reorder, "fsize")
      defaultSort := "File size"
   Else If InStr(reorder, "imgfolder, imgfile;")
      defaultSort := "Path and name"
   Else If InStr(reorder, "imgfolder;")
      defaultSort := "Folder path"
   Else If InStr(reorder, "zimgfile;")
      defaultSort := "File name"
   Else If InStr(reorder, "fmodified")
      defaultSort := "Modified date"
   Else If InStr(reorder, "fcreated")
      defaultSort := "Created date"
   Else If InStr(reorder, "imgwidth")
      defaultSort := "Image width"
   Else If InStr(reorder, "imgheight")
      defaultSort := "Image height"
   Else If InStr(reorder, "imgmegapix")
      defaultSort := "Megapixels"
   Else If InStr(reorder, "imgframes")
      defaultSort := "Frames / pages"
   Else If InStr(reorder, "imgwhratio")
      defaultSort := "Aspect ratio [W/H]"
   Else If InStr(reorder, "imgdpi")
      defaultSort := "Image DPI"
   Else If InStr(reorder, "imgdpi")
      defaultSort := "Image DPI"
   Else If InStr(reorder, "imgavg")
      defaultSort := "Histogram average"
   Else If InStr(reorder, "imgmedian")
      defaultSort := "Histogram median"
   Else If InStr(reorder, "imghrms")
      defaultSort := "Histogram RMS"
   Else If InStr(reorder, "imghmode")
      defaultSort := "Histogram mode"
   Else If InStr(reorder, "imghpeak")
      defaultSort := "Histogram max [range]"
   Else If InStr(reorder, "imghlow")
      defaultSort := "Histogram min [range]"
   Else If InStr(reorder, "imghrange")
      defaultSort := "Histogram range"
   Else If InStr(reorder, "imghminu")
      defaultSort := "Histogram minimum"
   Else If (StrLen(prevFilesSortMode)>2 && !Instr(reorder, "imgidu"))
      defaultSort := prevFilesSortMode
   Else 
      defaultSort := "None/manual"

   Return defaultSort
}

moveMarkedEntryNow(indexu, modus:=0) {
   If (thumbsDisplaying!=1 || maxFilesIndex<2)
      Return

   If !EntryMarkedMoveIndex
   {
      EntryMarkedMoveIndex := indexu
   } Else If (EntryMarkedMoveIndex=indexu)
   {
      EntryMarkedMoveIndex := 0
   } Else If isNumber(EntryMarkedMoveIndex)
   {
      If (modus="move")
         reorderIndexEntryManually(EntryMarkedMoveIndex, indexu)
      Else
         moveIndexEntry(EntryMarkedMoveIndex, indexu)

      currentFileIndex := EntryMarkedMoveIndex
      EntryMarkedMoveIndex := 0
   }

   mainGdipWinThumbsGrid()
}

reorderIndexEntryManually(oldIndex, newFileIndex)  {
   Static countu :=0 

   old := resultedFilesList.RemoveAt(oldIndex)
   resultedFilesList.InsertAt(newFileIndex, old)
   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   currentFileIndex := newFileIndex
   dummyTimerDelayiedImageDisplay(100)
   If (SLDtypeLoaded=3 && countu<5)
   {
      countu++
      showTOOLtip("Reordering of index entries is temporary.`nThe changes are not saved in the database.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

moveIndexEntry(newFileIndex, oldIndex) {
   If (SLDtypeLoaded=3)
   {
      SQLstr := "UPDATE images SET imgidu=999999999 WHERE imgidu=" newFileIndex ";"
      If activeSQLdb.Exec(SQLStr)
      {
         SQLstr := "UPDATE images SET imgidu=" newFileIndex " WHERE imgidu=" oldIndex ";"
         If activeSQLdb.Exec(SQLStr)
         {
            SQLstr := "UPDATE images SET imgidu=" oldIndex " WHERE imgidu=999999999;"
            If !activeSQLdb.Exec(SQLStr)
            {
               addJournalEntry("Failed to change index entry position in the SQL database.")
               Return
            } ; Else ToggleDBdefaultSQLsort()
         }
      }
   }

   tempA := resultedFilesList[oldIndex, 1]
   tempB := resultedFilesList[newFileIndex, 1]
   ; ToolTip, % tempA "`n" tempB "`n" oldIndex "===" newFileIndex , , , 2
   resultedFilesList[oldIndex, 1] := tempB
   resultedFilesList[newFileIndex, 1] := tempA
   If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:"))
   {
      tempA := bckpResultedFilesList[filteredMap2mainList[oldIndex], 1]
      tempB := bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1]
      bckpResultedFilesList[filteredMap2mainList[oldIndex], 1] := tempB
      bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1] := tempA
   }

   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   currentFileIndex := newFileIndex
   dummyTimerDelayiedImageDisplay(100)
}

PanelUpdateThisFileIndex(dummy:=0) {
    Global newFileName
    If (currentFileIndex=0)
       Return

   imgPath := getIDimage(currentFileIndex)
   fakeWinCreator(21, A_ThisFunc, 1)
   sqlSort := defineSQLdbSort()
   friendlyIndex := (maxFilesIndex>1) ? currentFileIndex "|" : ""
   If (!InStr(sqlSort, "none") && SLDtypeLoaded=3)
      friendlyIndex := ""

   If friendlyIndex
      msgInfos := "`n`nYou can type a new index number before | to move this entry elsewhere in the list."

   msgResult := msgBoxWrapper("panelu|Update files list index entry: " appTitle, "Please type the new file path and name.`nCurrent index: " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) "." msgInfos, "&Update entry|&Erase entry|&Browse file|C&ancel", 1, "modify-entry", 0, 0, 0, "limit9050", friendlyIndex imgPath)
   If InStr(msgResult.btn, "update")
   {
      newFileName := Trimmer(msgResult.edit)
      If (newFileName=imgPath) || (newFileName=currentFileIndex "|" imgPath)
         Return

      If askAboutFileSave(" and the current index entry will be updated")
         Return

      If (posu := InStr(newFileName, "|"))
      {
         newFileIndex := SubStr(newFileName, 1, posu - 1)
         newFileIndex := StrReplace(newFileIndex, ".")
         newFileIndex := StrReplace(newFileIndex, ",")
         If !isNumber(newFileIndex)
            newFileIndex := 0
         Else
            newFileIndex := clampInRange(newFileIndex, 1, maxFilesIndex)
 
         If (newFileIndex=currentFileIndex || maxFilesIndex<2)
            newFileIndex := 0
 
         newFileName := SubStr(newFileName, posu + 1)
         newFileName := Trimmer(newFileName)
      }

      If (!newFileName && maxFilesIndex>1)
      {
         remCurrentEntry(0, 0)
         Return
      } Else If (newFileName!=imgPath && newFileName)
         r := UpdateIndexBTNaction(newFileName, currentFileIndex)

      If (!r && newFileName!=imgPath && newFileName)
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      } Else If (newFileIndex!=currentFileIndex && newFileIndex && friendlyIndex)
         moveIndexEntry(newFileIndex, currentFileIndex)
   } Else If (InStr(msgResult.btn, "erase") && maxFilesIndex>1)
   {
      If askAboutFileSave(" and the current index entry will be erased")
         Return

      remCurrentEntry(0, 0)
   } Else If InStr(msgResult.btn, "browse")
      BrowseReplaceIndexEntry()
   Else If (dummy="reopen")
      PanelRenameThisFile()
}


PanelBrowseAudioAnnotation() {
    If (currentFileIndex=0 || SLDtypeLoaded!=3 || AnyWindowOpen)
       Return

   fakeWinCreator(38, A_ThisFunc, 1)
   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
   AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
   editFieldAudioFileu := AudioFileu ? AudioFileu : OutDir "\" OutNameNoExt ". WAV or MP3 or WMA"

   msgResult := msgBoxWrapper("panelu|Associate audio file with image: " appTitle, "Please type or browse the file path of an audio files to associate with the current image.", "&Update entry|&Browse file|&Disassociate|C&ancel", 1, "audio-file", 0, 0, 0, "limit9050", editFieldAudioFileu)
   If InStr(msgResult.btn, "update")
   {
      AudioFileu := Trimmer(msgResult.edit)
      If InStr(AudioFileu, OutDir "\" OutNameNoExt ".") || !FileExist(AudioFileu)
      {
         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         showTOOLtip("ERROR: Incorrect file path or inexistent audio file:`n" OutFileName "`n" OutDir "\")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelBrowseAudioAnnotation, -150
         Return
      }

      updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
   } Else If InStr(msgResult.btn, "disassociate")
   {
      updateSQLdbEntryCaption(imgPath, "", "imgAudio")
   } Else If InStr(msgResult.btn, "browse")
   {
      patternObj := {}
      patternObj["Audio files"] := "*.wav;*.mp3;*.wma"
      startPath := AudioFileu ? AudioFileu : imgPath
      AudioFileu := openFileDialogWrapper("O", "FileMustExist", startPath, "Browse sound file...", patternObj, chosenOption, 2)
      AudioFileu := Trimmer(AudioFileu)
      If StrLen(AudioFileu)>3
      {
         If AnyWindowOpen
            BtnCloseWindow()
         Sleep, 25
         updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
      }
      SetTimer, PanelBrowseAudioAnnotation, -150
   }
}

BrowseReplaceIndexEntry() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   ; pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn3 ")"
   ; pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"

   patternObj := {}
   patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
   patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4
   imgPath := openFileDialogWrapper("O", "FileMustExist", prevOpenFolderPath, "Replace index entry...", patternObj, chosenOption, 2)
   imgPath := Trimmer(imgPath)
   If !imgPath
   {
      SetTimer, PanelUpdateThisFileIndex, -150
      Return "cancel"
   }

   If AnyWindowOpen
      BtnCloseWindow()
   Sleep, 25
   If StrLen(imgPath)>3
   {
      zPlitPath(imgPath, 0, OutFileName, SelectedDir)
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      If askAboutFileSave(" and the current index entry will be updated")
         Return

      r := UpdateIndexBTNaction(imgPath, currentFileIndex)
      If !r
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      }
   }
   ResetImgLoadStatus()
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

SingularRenameFile() {
   PanelRenameThisFile("single")
}

askAboutFileCollision(srcFile, destFile, allowSkip, doLastOption, forceOption, ByRef performOverwrite) {
   Static lastOption, useLastOption := 0

   If (doLastOption=3)
   {
      lastOption := useLastOption := 0
      Return
   }

   zPlitPath(srcFile, 0, sOutFileName, sOutDir)
   zPlitPath(destFile, 0, dOutFileName, dOutDir, dfileNamuNoEXT, dFileExt)
   If (doLastOption=2)
      useLastOption := 1
   Else If (doLastOption=1)
      useLastOption := 0

   skipBtn := (allowSkip=1) ? "&Skip file|" : ""
   checkBtn := (allowSkip=1) ? "&Do not prompt again, apply the same option for all the subsequent conflicts" : ""
   If (useLastOption=1 && lastOption)
   {
      msgResult := lastOption
   } Else If !isInRange(forceOption, 1, 3)
   {
      FileGetSize, destFileSizu, % destFile, K
      FileGetSize, srcFileSizu, % srcFile, K
      FileGetTime, srcFileDateM, % srcFile, M
      FileGetTime, destFileDateM, % destFile, M
      FormatTime, srcFileDateM, % srcFileDateM, dddd, d MMMM yyyy, HH:mm
      FormatTime, destFileDateM, % destFileDateM, dddd, d MMMM yyyy, HH:mm
      msgResult := msgBoxWrapper(appTitle ": File name conflict", "SOURCE FILE:`n" sOutFileName "`n" groupDigits(srcFileSizu) " Kilobytes (" srcFileDateM ")`n" sOutDir "\`n`nFile name conflict. Do you want to overwrite the destination file?`n`nDESTINATION FILE:`n" dOutFileName "`n" groupDigits(destFileSizu) " Kilobytes (" destFileDateM ")`n" dOutDir "\", "&Overwrite|&Auto-rename|" skipBtn "C&ancel", 2, "question", checkBtn, doLastOption)
   }

   If IsObject(msgResult)
      useLastOption := msgResult.check

   If (forceOption=1)
      msgResult := "skip"
   Else If (forceOption=2)
      msgResult := "auto-rename"
   Else If (forceOption=3)
      msgResult := "overwrite"

   performOverwrite := 0
   msgR := IsObject(msgResult) ? msgResult.btn : msgResult
   If InStr(msgR, "rename")
   {
      performOverwrite := 2
      Loop
      {
          r := dOutDir "\" dfileNamuNoEXT " [" A_Index "]." dFileExt
          If !FileExist(r)
             Break
      } Until (A_Index>9500)
   } Else If InStr(msgR, "overwrite")
   {
      performOverwrite := 1
      r := destFile
   } Else If InStr(msgR, "skip")
      r := ""
   Else If InStr(msgR, "cancel")
      r := "abort"
   Else
      lastOption := r := msgR := ""

   lastOption := (r="abort") ? "" : msgR
   Return r
}

PanelRenameThisFile(dummy:=0) {
    Global newFileName
    Static doLastOption := 0
    If (currentFileIndex=0)
       Return

    getSelectedFiles(0, 1)
    If (markedSelectFile>1 && dummy!="single")
    {
       PanelMultiRenameFiles()
       Return
    }

    Sleep, 2
    file2rem := getIDimage(currentFileIndex)
    zPlitPath(file2rem, 0, OutFileName, OutDir)
    If !FileExist(file2rem)
    {
       showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Sleep, 900
       PanelUpdateThisFileIndex()
       Return
    }

   fakeWinCreator(7, A_ThisFunc, 1)
   undoBtn := FileExist(lastRenameUndo[2]) ? "&Undo previous|" : ""
   msgResult := msgBoxWrapper("panelu|Rename file: " appTitle, "File location:`n" OutDir "\`n`nPlease type the new file name.", "&Rename file|" undoBtn "&Modify index entry|C&ancel", 1, "modify-file", "On file name collision, use previously given answer", doLastOption, 0, "limit9050", OutFileName)
   If InStr(msgResult.btn, "Rename")
   {
      doLastOption := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      file2rem := getIDimage(currentFileIndex)
      zPlitPath(file2rem, 0, OutFileName, OutDir)
      If ((Trimmer(OutFileName)=newFileName) || !newFileName)
         Return

      If askAboutFileSave(" and the current file will be renamed and reloaded")
         Return

      r := RenameBTNaction(Trimmer(msgResult.edit), file2rem, doLastOption + 1)
      If !r 
      {
         Sleep, 100
         PanelRenameThisFile(dummy)
      } Else CreateGuiButton("Undo rename,,undoFileRenameAction", 0, msgDisplayTime//1.5 + 500)
   } Else If InStr(msgResult.btn, "modify")
      PanelUpdateThisFileIndex("reopen")
    Else If InStr(msgResult.btn, "undo")
      undoFileRenameAction()
}

PanelSetThumbCols() {
   fakeWinCreator(40, A_ThisFunc, 1)
   dropListu := "Wide (1.81)`fTall (0.48)`fSquare (1.00)`f`f"
   sizu := (PrefsLargeFonts=1) ? 800 : 450
   msgResult := msgBoxWrapper("panelu|Set thumbnails columns: " appTitle, "Please type how many columns you want for the thumbnails list. You can adjust this number with the -/+ keys in the main window.`n`nBelow you can set thumbnails aspect ratio.", "&Apply|&Cancel", 1, 0, 0, 0, dropListu, "limit9050 number", thumbsColumns, 2, sizu)
   If InStr(msgResult.btn, "apply")
   {
      thumbsAratio := msgResult.list
      ; dynamicThumbsColumns := msgResult.check
      thumbsColumns := Trimmer(msgResult.edit)
      thumbsColumns := clampInRange(thumbsColumns, 2, 100)
      recalculateThumbsSizes()
      ForceRefreshNowThumbsList()
      ; IniAction(1, "dynamicThumbsColumns", "General")
      IniAction(1, "thumbsColumns", "General")
      dummyTimerDelayiedImageDisplay(50)
   }
}

PanelSetSystemCores() {
   EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
   fakeWinCreator(41, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Multi-threading options: " appTitle, "Please specify the number of threads to use when generating thumbnails or batch processing files. Maximum allowed threads on this system is " thisSystemCores ".`n`nAfter changing this value, a restart of QPV might be necessary.", "&Apply|&Cancel", 1, "gear", "Allow multi-threaded processing", allowMultiCoreMode, 0, "limit2 number", userMultiCoresLimit)
   If InStr(msgResult.btn, "apply")
   {
      allowMultiCoreMode := msgResult.check
      userMultiCoresLimit := Trimmer(msgResult.edit)
      userMultiCoresLimit := clampInRange(userMultiCoresLimit, 2, thisSystemCores)
      INIaction(1, "allowMultiCoreMode", "General")
      INIaction(1, "userMultiCoresLimit", "General")
      realSystemCores := userMultiCoresLimit
      If (thumbsDisplaying=1 && thumbnailsListMode!=1 && multiCoreThumbsInitGood="n")
         initAHKhThumbThreads()
      ; dummyTimerDelayiedImageDisplay(50)
   }
}

PanelSaveSlideShowu() {
    Global usePrevSaveFolder := 0, userDesiredSlideFMT := 1

    If (maxFilesIndex<2)
    {
       showTOOLtip("WARNING: Insufficient image files are indexed")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    thisBtnHeight := createSettingsGUI(36, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 360
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "prevFileSavePath", "General", 5)
    userDesiredSlideFMT := (SLDtypeLoaded=3) ? 2 : 1
    If (SLDtypeLoaded=3)
       SLDcacheFilesList := 1

    Gui, Add, Text, x15 y15 Section, Slideshow format:
    Gui, Add, DropDownList, xs y+5 w%EditWid% gUItoggleSLDformat AltSubmit Choose%userDesiredSlideFMT% vuserDesiredSlideFMT, .SLD - Plain-text format|.SLDB - SQLite Database format (file details cached)
    Gui, Add, Checkbox, xs y+10 Checked%SLDcacheFilesList% vSLDcacheFilesList, Cache files list (ensures rapid slideshow loading)`nIf this is left unchecked, only the dynamic folders list will be saved.
    If (SLDtypeLoaded=3)
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList

    Gui, Add, Checkbox, xs y+10 Checked%ForceRegenStaticFolders% vForceRegenStaticFolders, Regenerate static folders list`nThe static folders list enables partial files list later updates
    Gui, Add, Text, xs y+10 w%EditWid%, Regardless of the chosen format, the current %appTitle% settings will be stored.
    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
       infoThisSLD := "Currently opened: «Favourite images list»."
    Else If (SLDtypeLoaded=2)
       infoThisSLD := "Currently opened: plain-text files list`n" CurrentSLD
    Else If (SLDtypeLoaded=3)
       infoThisSLD := "Currently opened: SQLite database files list`nMost actions applied on the files index are automatically saved. Under rare circumstances resaving is required.`n" CurrentSLD
    Else
       infoThisSLD := "No saved files list currently opened."

    If (SLDtypeLoaded=2 && currentFilesListModified=1)
       infoThisSLD .= "`nFiles list has been modified. The changes are unsaved."

    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Text, xs y+20 w%EditWid%, % infoThisSLD
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% gBTNopenPanelDynamicFolderzWindow, &Manage folders
    If (SLDtypeLoaded>1 && FileRexists(CurrentSLD)) || InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
    {
       thisDefault := ""
       Gui, Add, Button, x+5 hp w%btnWid2% Default gBTNsaveCurrentSlideshow, &Save...
       Gui, Add, Button, x+0 hp w35 gBTNsaveSlideshowPanel, &AS
    } Else
    {
       Gui, Add, Button, x+5 hp w%btnWid2% Default gBTNsaveSlideshowPanel, Save &as
    }

    Gui, Add, Button, x+15 hp w%btnWid2% gBTNhelpSlideshows, &Help
    Gui, Add, Button, x+5 hp wp-5 gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save indexed files list: " appTitle)
}

BTNhelpSlideshows() {
    msgBoxWrapper(appTitle ": HELP", "In the plain-text SLD format one can store:`n- QPV settings pertaining to viewport and slideshow options`n- a folders list [so-called «main» folders list]; this is the source of the files list and can be [re]scanned at any time.`n- the actual files list. If it is not cached / present when the SLD is opened, the main folders list will be scanned for images to populate the files list index.`n- a «static» folders list; this list is automatically generated when the SLD is saved based on the indexed files' paths - only if the user chooses to cache the files list. In later sessions, one can rescan any of these folders, allowing users to selectively update the files list whenever needed.`n`nIn addition to all of the above, the SQL-Lite database SLDB format can store:`n- image captions [no need for external text files] and also allows users to attach audio files to image files without the constraint of having them located in the same folder(s) with the image(s).`n- file and image details cache: file size, file date created, modified, image information (resolution, pixel format, histogram details and so on)`n`nThe caching of data facilitates management of large image collections, because files list sorting, image and file statistics are performed MUCH faster once the data is cached. The cached data is stored and reused between sessions and can be generated gradually in multiple QPV sessions.", -1, 0, 0)
}

BTNopenPanelDynamicFolderzWindow() {
    PanelDynamicFolderzWindow("reopen")
}

BTNsaveCurrentSlideshow() {
    BtnCloseWindow()
    Sleep, 1
    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
       renewFavesListBasedOnIndexList()
    Else If (SLDtypeLoaded=2 && FileRexists(CurrentSLD) && maxFilesIndex>0)
       SaveFilesList(CurrentSLD)
    Else If (SLDtypeLoaded=3 && FileRexists(CurrentSLD) && maxFilesIndex>0)
       SaveDBfilesList(CurrentSLD)
    BtnCloseWindow()
}

UItoggleSLDformat() {
    GuiControlGet, userDesiredSlideFMT
    If (userDesiredSlideFMT=1)
    {
       GuiControl, SettingsGUIA: Enable, SLDcacheFilesList
    } Else
    {
       SLDcacheFilesList := 1
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList
       GuiControl, , SLDcacheFilesList, 1
    }
}

BTNsaveSlideshowPanel() {
    Gui, SettingsGUIA: Default
    GuiControlGet, SLDcacheFilesList
    GuiControlGet, userDesiredSlideFMT
    GuiControlGet, ForceRegenStaticFolders
    If (userDesiredSlideFMT=1)
       SaveFilesList()
    Else
       SaveDBfilesList()
}

FolderExist(filePath) {
   If StrLen(filePath)<4
      Return

   Return InStr(FileExist(filePath), "D")
}

PanelSaveImg() {
    Global userDestinationFolder, editF5, UserCropOnSave, usePrevSaveFolder := 0

    If (thumbsDisplaying=1)
    {
       PanelSaveSlideShowu()
       Return
    }

    If throwErrorNoImageLoaded()
       Return

    thisBtnHeight := createSettingsGUI(35, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := (PrefsLargeFonts=1) ?  btnWid - 40 : btnWid - 25
    INIaction(0, "userDesireWriteFMT", "General", 2, 1, 16)
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)

    INIaction(0, "prevFileSavePath", "General", 5)
    INIaction(0, "usePrevSaveFolder", "General", 1)
    INIaction(0, "PreserveDateTimeOnSave", "General", 1)
    INIaction(0, "userJpegQuality", "General", 2, 1, 100)

    ; Gui, Add, Text,, Default destination format:
    ; Gui, Add, DropDownList, x+10 w85 gTglDesiredSaveFormat AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, .BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM
    entriesList := StrReplace(recentOpenedFolders(), "`n", "|")
    delim := InStr(entriesList, prevFileSavePath "|") ? "|" : ""
    entriesList := StrReplace(entriesList, prevFileSavePath delim, prevFileSavePath "||")
    If StrLen(entriesList)<4
    {
       usePrevSaveFolder := 0
       GuiControl, Disable, usePrevSaveFolder
    } Else If !InStr(entriesList, "||")
       entriesList .= "|"

    UserCropOnSave := 0
    ; Gui, Add, Checkbox, Checked%UserCropOnSave% vUserCropOnSave, C&rop image to selected area on save
    Gui, Add, Checkbox, x15 y15 Section Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Checkbox, y+7 Section gTglUsePrevSaveFoderu Checked%usePrevSaveFolder% vusePrevSaveFolder, &Open file dialog in a previous location
    Gui, Add, DropDownList, xp+15 y+7 wp+135 vuserDestinationFolder, % entriesList
    Gui, Add, Text, xs y+15, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    Gui, Add, Text, xs+15 y+7, This applies only for JPG, JP2, J2K, JXR and WEBP files.
    If (editingSelectionNow!=1 || testSelectOutsideImgEntirely(useGdiBitmap()))
       GuiControl, Disable, UserCropOnSave

    If !usePrevSaveFolder
       GuiControl, Disable, userDestinationFolder

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBTNsaveImgPanel, &Save image
    Gui, Add, Button, x+0 h%thisBtnHeight% w35 gBTNsaveBrowseImgPanel, &AS
    Gui, Add, Button, x+15 hp w%btnWid% gBtnCopyImageClip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid2% gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save image file: " appTitle)
}

PanelSearchAndReplaceIndex() {
    Global editF5, editF6, performInSeenDB

    thisBtnHeight := createSettingsGUI(51, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    If (SLDtypeLoaded=3)
       infos := "`n`nThis action will affect only folder paths."

    If (mustRecordSeenImgs!=1 || performInSeenDB="")
       performInSeenDB := 0

    imgPath := resultedFilesList[currentFileIndex, 1]
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    Gui, Add, Text, x15 y15 w%txtWid% Section, Please type what to search for and what to replace it with. This panel is meant to help you fix broken files lists. e.g., files moved to a different folder. RegEx, tokens or wildcards are not supported. %infos%
    Gui, Add, Text, y+15 wp, Search for:
    Gui, Add, Edit, y+5 wp veditF5 r1, % OutDir
    Gui, Add, Text, y+15 wp, Replace with:
    Gui, Add, Edit, y+5 wp veditF6,
    Gui, Add, Checkbox, y+15 Checked%performInSeenDB% vperformInSeenDB, Perform action in seen images database 
    If (mustRecordSeenImgs!=1)
       GuiControl, Disable, performInSeenDB

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBTNperformIndexSearchReplace, &Perform
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Search and replace through the files index: " appTitle)
}

BTNperformIndexSearchReplace() {
   Gui, SettingsGUIA: Default
   GuiControlGet, editF5
   GuiControlGet, editF6
   GuiControlGet, performInSeenDB
   If !Trimmer(editF5)
   {
      showTOOLtip("WARNING: No search criteria given")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   If (mustRecordSeenImgs=1 && performInSeenDB=1)
      SearchAndReplaceSeenDB(Trimmer(editF5), Trimmer(editF6))
   Else
      SearchAndReplaceThroughIndex(Trimmer(editF5), Trimmer(editF6), 0, 0)
}

PanelQuickMoveConfigure() {
    Global btnFldr1, btnFldr2, btnFldr3, btnFldr4, btnFldr5, btnFldr6
    Static afterActionsList := "Do nothing after|Go to next image |Go to previous image"

    thisBtnHeight := createSettingsGUI(47, A_ThisFunc, 1)
    btnWid := 60
    txtWid := 395
    EditWid := 305
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 100
       btnWid := btnWid + 30
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    tiny := (PrefsLargeFonts=1) ? 55 : 30
    tiny2 := (PrefsLargeFonts=1) ? 85 : 50
    ReadSettingsQuickKeysActsPanel()
    Gui, Add, Text, x15 y15 Section w%txtWid%, The keys from 1 to 6 on the keyboard can be associated to quick actions to facilitate the move or copy of images to predefined destination folders.
    Gui, Add, Text, xs y+15 w%tiny%, [ 1 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder1, % QuickFileActFolder1
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr1, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter1% vQuickFileActAfter1, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 2 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder2, % QuickFileActFolder2
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr2, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter2% vQuickFileActAfter2, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 3 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder3, % QuickFileActFolder3
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr3, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter3% vQuickFileActAfter3, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 4 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder4, % QuickFileActFolder4
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr4, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter4% vQuickFileActAfter4, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 5 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder5, % QuickFileActFolder5
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr5, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter5% vQuickFileActAfter5, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ 6 ]
    Gui, Add, Edit, x+5 w%EditWid% r1 -wrap vQuickFileActFolder6, % QuickFileActFolder6
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr6, Browse
    Gui, Add, DropDownList, x+5 wp+65 AltSubmit Choose%QuickFileActAfter6% vQuickFileActAfter6, % afterActionsList

    Gui, Add, Text, xs y+15 w%tiny%, [ Del ]
    Gui, Add, Checkbox, x+5 Checked%askDeleteFiles% vaskDeleteFiles, &Prompt before delete
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%deleteFileActAfter% vdeleteFileActAfter, % afterActionsList
    Gui, Add, Text, xs y+15 w%txtWid%, Use Shift to move to given destination folder. Use Alt to open it in Explorer.

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBtnApplyQuickActionsPanel, &Apply
    Gui, Add, Button, x+5 hp wp gBtnHelpCopyMovePanel, Hel&p
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    Gui, Add, Text, x+5 hp +0x200, On file name conflicts:
    Gui, Add, DropDownList, x+5 w135 AltSubmit Choose%QuickFileActConflict% vQuickFileActConflict, Skip files|Auto-rename|Overwrite|Ask user
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Configure quick action keys: " appTitle)
}

BtnApplyQuickActionsPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, QuickFileActAfter1
   GuiControlGet, QuickFileActAfter2
   GuiControlGet, QuickFileActAfter3
   GuiControlGet, QuickFileActAfter4
   GuiControlGet, QuickFileActAfter5
   GuiControlGet, QuickFileActAfter6
   GuiControlGet, QuickFileActFolder1
   GuiControlGet, QuickFileActFolder2
   GuiControlGet, QuickFileActFolder3
   GuiControlGet, QuickFileActFolder4
   GuiControlGet, QuickFileActFolder5
   GuiControlGet, QuickFileActFolder6
   GuiControlGet, askDeleteFiles
   GuiControlGet, deleteFileActAfter
   GuiControlGet, QuickFileActConflict
   WriteSettingsQuickKeysActsPanel()
   BtnCloseWindow()
}

BTNchooseQuickActDestFolder(CtrlHwnd) {
   Static lastFolder
   If !lastFolder
      lastFolder := ResizeDestFolder ? ResizeDestFolder : A_ScriptDir

   GuiControlGet, varu, SettingsGUIA: Name, % CtrlHwnd
   ; ToolTip, % varu "`n" a "|" b "|" c , , , 2

   thisVar := SubStr(varu, 0)
   SelectImg := openFoldersDialogWrapper("S2", lastFolder)
   OutDir := Trimmer(SelectImg)
   If !FolderExist(OutDir)
   {
      WinActivate, ahk_id %hSetWinGui%
      Return
   } Else
   {
      lastFolder := SelectImg
      GuiControl, SettingsGUIA:, QuickFileActFolder%thisVar%, % OutDir
   }
}

triggerQuickFileAction(keyu) {
   Static hasLoadedSettings := 0, lastInvoked := 1

   If (slideShowRunning=1)
   {
      ToggleSlideShowu()
      Return
   }

   If ((!resultedFilesList[currentFileIndex, 1] || AnyWindowOpen || drawingShapeNow=1)
   || (A_TickCount - lastInvoked<250))
   {
      lastInvoked := A_TickCount
      Return
   }

   If !hasLoadedSettings
   {
      ReadSettingsQuickKeysActsPanel()
      hasLoadedSettings := 1
   }

   thisVar := SubStr(keyu, 0)
   UsrCopyMoveOperation := InStr(keyu, "+") ? 2 : 3   ; 2 = move ; 3 = copy
   UsrEditFileDestination := QuickFileActFolder%thisVar%
   If (thisVar=7)
   {
      If !folderTreeWinOpen
         Return

      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      UsrEditFileDestination := folderTreeGetSelectedPath(c)
      If FolderExist(UsrEditFileDestination)
      {
         prevFileMovePath := UsrEditFileDestination
         INIaction(1, "prevFileMovePath", "General")
         RecentCopyMoveManager(UsrEditFileDestination)
      }
      If !UsrEditFileDestination
         Return
   }

   If StrLen(UsrEditFileDestination)<5
   {
      PanelQuickMoveConfigure()
      Return
   }

   altState := GetKeyState("Alt", "P")
   ctrlState := GetKeyState("Ctrl", "P")
   lastInvoked := A_TickCount
   If (altState=1 && ctrlState!=1)
   {
      Try Run, "%UsrEditFileDestination%"
      UsrEditFileDestination := ""
      Return
   } Else If (ctrlState=1 && altState=1)
   {
      OpenNewQPVinstance(UsrEditFileDestination)
      UsrEditFileDestination := ""
      Return
   }

   copyMoveDoLastOption := 1
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   afterAct := QuickFileActAfter%thisVar%
   r := BtnCopyMoveAction("quick-actu")
   lastInvoked := A_TickCount
   If (afterAct=2 && StrLen(UserMemBMP)<3 && r=1)
      NextPicture(0, 0, 1)
   Else If (afterAct=3 && StrLen(UserMemBMP)<3 && r=1)
      PreviousPicture(0, 0, 1)

   UsrEditFileDestination := ""
   lastInvoked := A_TickCount
}

WriteSettingsQuickKeysActsPanel() {
    ReadSettingsQuickKeysActsPanel(1)
}

ReadSettingsQuickKeysActsPanel(act:=0) {
   INIaction(act, "QuickFileActAfter1", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter2", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter3", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter4", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter5", "General", 2, 1, 3)
   INIaction(act, "QuickFileActAfter6", "General", 2, 1, 3)
   INIaction(act, "QuickFileActFolder1", "General", 5)
   INIaction(act, "QuickFileActFolder2", "General", 5)
   INIaction(act, "QuickFileActFolder3", "General", 5)
   INIaction(act, "QuickFileActFolder4", "General", 5)
   INIaction(act, "QuickFileActFolder5", "General", 5)
   INIaction(act, "QuickFileActFolder6", "General", 5)
   INIaction(act, "deleteFileActAfter", "General", 2, 1, 3)
   INIaction(act, "QuickFileActConflict", "General", 2, 1, 4)
   INIaction(act, "askDeleteFiles", "General", 1)
}

TglUsePrevSaveFoderu() {
   GuiControlGet, usePrevSaveFolder
   If !usePrevSaveFolder
      GuiControl, Disable, userDestinationFolder
   Else
      GuiControl, Enable, userDestinationFolder

   INIaction(1, "usePrevSaveFolder", "General")
}

BTNsaveImgPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   ; GuiControlGet, UserCropOnSave
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality
   GuiControlGet, userDestinationFolder
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "usePrevSaveFolder", "General")
   INIaction(1, "PreserveDateTimeOnSave", "General")
   imgPath := getIDimage(currentFileIndex)
   If InStr(imgPath, "\temporary memory object\")
      SaveClipboardImage(userDestinationFolder, 0)
   Else
      SaveClipboardImage("current", 0, 1)

   If (minimizeMemUsage=1)
   {
      HardResetImageView()
      SetTimer, RefreshImageFileAction, -125
   }
}

BTNsaveBrowseImgPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   ; GuiControlGet, UserCropOnSave
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality
   GuiControlGet, userDestinationFolder
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "usePrevSaveFolder", "General")
   INIaction(1, "PreserveDateTimeOnSave", "General")
   imgPath := getIDimage(currentFileIndex)
   If (usePrevSaveFolder=1 || InStr(imgPath, "\temporary memory object\"))
      SaveClipboardImage(userDestinationFolder, 0)
   Else
      SaveClipboardImage("current", 0)
}

BtnCopyImageClip() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   GuiControlGet, userJpegQuality
   GuiControlGet, PreserveDateTimeOnSave
   INIaction(1, "PreserveDateTimeOnSave", "General")
   INIaction(1, "userJpegQuality", "General")
   BtnCloseWindow()
   Sleep, 5
   CopyImage2clip()
}

fakeWinCreator(idWin, thisCaller, allowReopen) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()

    AnyWindowOpen := idWin
    interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    prevOpenedWindow := []
    prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 1]
    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    ; hSetWinGui := PVhwnd
}

PanelAutoSelectDupes() {
   Static SearchedStringz
   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to search for")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
   {
      Sleep, 1
   } Else
   {
      showTOOLtip("WARNING: The files list does not seem to contain pairs of images identified as duplicates")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   fakeWinCreator(50, A_ThisFunc, 1)
   SearchedStringz := Trimmer(SearchedStringz)
   widthu := (PrefsLargeFonts=1) ? 1060 : 560
   msgResult := msgBoxWrapper("panelu|Auto-select duplicate images " appTitle, "When Automatic mode is selected, the smallest image in (MPx) will be selected. If all dupes in the group have the same resolution, then the smallest file will be selected. If both size and resolution are equal, the images' folder paths that match the string below will NOT be selected.`n`nYou can use | as the OR operator for multiple keywords. Wildcards ? and * are supported as well. Begin with \> to use Regular Expressions.`n`nUse one of the following symbols to...`n   / match folder paths that begin with given string`n   > match folder paths that end with given string.", "&Select files|&Find duplicates|C&ancel", 1, "search", "", 0, SearchedStringz "`f`f", nullEdit,nullEdit, 1, widthu, "Automatic`f`fSmallest files`fSmallest resolution (MPx)", 2)
   If InStr(msgResult.btn, "select")
   {
      thisString := Trimmer(msgResult.list)
      thisString := StrReplace(thisString, "||", "|")
      thisString := Trimmer(thisString, "|")
      thisString := processSearchIndexString(thisString)
      If thisString
         SearchedStringz .= thisString "`f"
      autoSelectDupesInGroups(msgResult.2ndlist, thisString)
   } Else If InStr(msgResult.btn, "find")
      PanelFindDupes()
}

SearchIndexSelectAll() {
   thisFilter := processSearchIndexString(userSearchString)
   If !thisFilter
   {
      thisSearchString := userSearchString := ""
      SetTimer, PanelSearchIndex, -100
      Return
   }

   showTOOLtip("Searching index for matching files:`n" userSearchString)
   thisSearchString := thisFilter
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection based on the search criteria.", "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel")
      {
         SetTimer, RemoveTooltip, -250
         thisSearchString := userSearchString := ""
         Return
      }
   }

   If (msgResult="replace" || !msgResult)
   {
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   Loop, % maxFilesIndex
   {
      imgPath := resultedFilesList[A_Index, 1]
      If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
         resultedFilesList[A_Index, 2] := (msgResult="add" || !msgResult) ? 1 : 0
   }

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ForceRefreshNowThumbsList()
   If !markedSelectFile
      showDelayedTooltip("No matches found. No files were selected.")
   Else
      navSelectedFiles(1)

   dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

PanelSearchIndex() {
   Static SearchedStringz
   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to search for")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (AnyWindowOpen=6)
      BtnCloseWindow()
   Else If AnyWindowOpen
      Return
   
   fakeWinCreator(29, A_ThisFunc, 1)
   SearchedStringz := Trimmer(SearchedStringz) "`f"
   prevSearchString := Trimmer(userSearchString) ? userSearchString : Chr(160)
   widthu := (PrefsLargeFonts=1) ? 1160 : 660
   msgResult := msgBoxWrapper("panelu|Search indexed files: " appTitle, "Please type the string to search for in the indexed files. Use | as the OR operator. Wildcards ? and * are supported as well.`n`nUse one of the following tokens to...`n   / match strings that begin with given string`n   > match strings that end with given string.`n`nBegin with \> to use Regular Expressions.", "&Search next|Select &all matches|&Filter list panel|&Close", 1, "search", "&Highlight matching files in list view mode", markSearchMatches, SearchedStringz prevSearchString "`f`f", nullEdit,nullEdit, 1, widthu, "Full path`f`fFolder path`fFile name`fParent folder", 2)
   If InStr(msgResult.btn, "filter list")
   {
      OpenFilterPanelBTNaction()
   } Else If (InStr(msgResult.btn, "search") || InStr(msgResult.btn, "select"))
   {
      If askAboutFileSave(" and the files index search will be performed")
         Return

      markSearchMatches := msgResult.check
      userSearchWhat := msgResult.2ndlist
      INIaction(1, "markSearchMatches", "General")
      userSearchString := Trimmer(msgResult.list)
      userSearchString := StrReplace(userSearchString, "||", "|")
      userSearchString := Trimmer(userSearchString, "|")
      If userSearchString
      {
         SearchedStringz .= userSearchString "`f"
         Sort, SearchedStringz, UD`f
         If InStr(msgResult.btn, "search")
            searchNextIndex(1)
         Else If InStr(msgResult.btn, "select")
            SearchIndexSelectAll()
      } Else userSearchString := ""
   }
}

OpenFilterPanelBTNaction() {
   userSearchString := ""
   CloseWindow()
   PanelEnableFilesFilter()
}

PanelEditImgCaption(dummy:=0) {
    Global newFileName, UsrStoreCaptionDB := 1
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If !FileExist(imgPath)
    {
       showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Return
    }

    INIaction(0, "UsrStoreCaptionDB", "General", 1)
    If (SLDtypeLoaded=3)
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")
    Else
       UsrStoreCaptionDB := 0

    If !textFileContent
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       Try FileRead, textFileContent, % textFile
    }

    thisBtnHeight := createSettingsGUI(22, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 w%txtWid%, Please type the caption or annotation you want associated with this image file...
    Gui, Add, Edit, y+7 w%EditWid% r15 limit1024 -wantTab vnewFileName, % textFileContent
    Gui, Add, Checkbox, y+7 Checked%UsrStoreCaptionDB% vUsrStoreCaptionDB, Store image caption into the SQL slideshow database
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w90 Default gSaveCaptionBTNaction, &Save
    Gui, Add, Button, x+5 hp wp gDeleteCaptionBTNaction, &Delete
    Gui, Add, Button, x+5 hp wp gBTNhelpCaptions, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    If (SLDtypeLoaded!=3)
       GuiControl, Disable, UsrStoreCaptionDB

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Edit image caption: " appTitle)
}

BTNhelpCaptions() {
    msgBoxWrapper(appTitle ": HELP", "Image file captions [annotations] are stored in .TXT files [as plain text], where the image file is located, under the same file name.`n`nFor example:`nC:\example-folder\image-file.jpg`nC:\example-folder\image-file.txt`n`nIf you are using SQLite slideshow databases, you have the option to store the captions in the database, not as individual files for each image. However, please keep in mind, when the files list is renewed or regenerated, the captions or audio annotations might get lost.", -1, 0, 0)
}

DeleteCaptionBTNaction() {
    GuiControlGet, UsrStoreCaptionDB
    INIaction(1, "UsrStoreCaptionDB", "General")
    BtnCloseWindow()
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"
    If FileExist(textFile)
       mustShowError := 1

    Try FileDelete, % textFile
    Catch wasError
          Sleep, 2

    If (mustShowError && wasError)
    {
       showTOOLtip("ERROR: Unable to delete text file:`n" OutNameNoExt ".txt`n" OutDir "\")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    If (SLDtypeLoaded=3)
       updateSQLdbEntryCaption(imgPath, "", "imgCaption")

    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

SaveCaptionBTNaction() {
    GuiControlGet, newFileName
    GuiControlGet, UsrStoreCaptionDB
    INIaction(1, "UsrStoreCaptionDB", "General")
    newFileName := Trimmer(newFileName)
    If !newFileName
       Return

    BtnCloseWindow()
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3 && UsrStoreCaptionDB=1)
    {
       updateSQLdbEntryCaption(imgPath, newFileName, "imgCaption")
    } Else
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       FileDelete, % textFile
       Sleep, 2
       Try FileAppend, % newFileName, % textFile, UTF-16
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "Failed to write text file... Permission denied.`n" OutNameNoExt ".txt`n" OutDir "\", 0, 0, "error")
    }

    showImgAnnotations := 1
    If (showImgAnnotations!=1)
       INIaction(1, "showImgAnnotations", "General")

    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

InvokeUpdateIndexPanelBTNaction() {
   CloseWindow()
   Sleep, 1
   PanelUpdateThisFileIndex()
}

filterFileName(ostring) {
  Static forbiddenCharsREGex := "\<|\>|\:|\""|\/|\\|\||\?|\*"
  Static forbiddenNames := "CON|PRN|AUX|NUL|COM1|COM2|COM3|COM4|COM5|COM6|COM7|COM8|COM9|LPT1|LPT2|LPT3|LPT4|LPT5|LPT6|LPT7|LPT8|LPT9"
  string := Trimmer(ostring)
  string := StrReplace(string, "/", "\")
  string := RegExReplace(string, "\\{2,}", "\")
  If RegExMatch(string, forbiddenCharsREGex)
     Return

  Loop, Parse, forbiddenNames, |
  {
     If (A_LoopField=string)
        Return
  }

  Return string
}

undoFileRenameAction() {
   RenameBTNaction(lastRenameUndo[1], lastRenameUndo[2], 1)
   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   lastRenameUndo := []
}

RenameBTNaction(newFileName, file2rem, doLastOption) {
  newFileName := filterFileName(newFileName)
  If (StrLen(newFileName)>3)
  {
     zPlitPath(file2rem, 0, OutFileName, OutDir)
     If (Trimmer(OutFileName)=newFileName)
        Return 1

     If !FileExist(file2rem)
        Return 0

     destroyGDIfileCache()
     FileGetTime, originalMtime, % file2rem, M
     FileGetTime, originalCtime, % file2rem, C
     file2save := OutDir "\" newFileName
     thisFileExists := 0
     If (FileExist(file2save) && !FolderExist(file2save))
     {
        thisFileExists := 1
        file2save := askAboutFileCollision(file2rem, file2save, 0, doLastOption + 1, 0, performOverwrite)
     }

     If (file2save="abort" || !file2save)
     {
        SetTimer, SingularRenameFile, -150
        Return
     }

     If (thisFileExists=1)
     {
        If (performOverwrite=1)
        {
           FileSetAttrib, -R, %file2save%
           Sleep, 2
           FileRecycle, %file2save%
           Sleep, 2
        } Else If (performOverwrite!=2)
        {
           showTOOLtip("Rename operation abandoned.`nA file with the provided name already exists.`nFile name conflict`n" newFileName)
           SetTimer, RemoveTooltip, % -msgDisplayTime
           Return 0
        }
     }

     FileSetAttrib, -R, %file2rem%
     Sleep, 2
     FileMove, %file2rem%, %file2save%, 1
     If ErrorLevel
     {
        showTOOLtip("ERROR: Access denied... The file could not be renamed.`n" OutFileName "`n" OutDir "\")
        SoundBeep, 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     } Else
     {
        updateDates := 1
        If originalMtime
        {
           Sleep, 0
           FileSetTime, % originalMtime, % file2save, M
           FileSetTime, % originalCtime, % file2save, C
           updateDates := 0
        }

        lastRenameUndo := []
        lastRenameUndo := [OutFileName, file2save]
        If (SLDtypeLoaded=3)
           updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[currentFileIndex, 12])

        currentFilesListModified := 1
        resultedFilesList[currentFileIndex, 1] := file2save
        updateMainUnfilteredList(currentFileIndex, 1, file2save)
        watchFolderDetails := ""
        dummyTimerDelayiedImageDisplay(50)
        showTOOLtip("File renamed succesfully to:`n" newFileName "`n" OutDir "\")
        Return 1
     }
  } Else Return 0
}

UpdateIndexBTNaction(newFileName, whichIndex) {
  ; GuiControlGet, newFileName
  newFileName := Trimmer(newFileName)
  newFileName := StrReplace(newFileName, "/", "\")
  newFileName := RegExReplace(newFileName, "\\{2,}", "\")
  allGood := 1
  If !RegExMatch(newFileName, "i)^(.\:\\.)")
     allGood := 0

  strArr := StrSplit(newFileName, "\")
  Loop, % strArr.Count()
  {
      testThis := filterFileName(strArr[A_Index])
      If (!testThis && A_Index>1)
         allGood := 0
  }

  If !RegExMatch(newFileName, RegExFilesPattern)
     allGood := 0

  If !FileRexists(newFileName)
  {
     If (allGood=1)
        fileNotFound := 1
     allGood := 0
  }

  If (StrLen(newFileName)>2 && allGood=1)
  {
     oldFileName := resultedFilesList[whichIndex, 1]
     resultedFilesList[whichIndex, 1] := newFileName
     resultedFilesList[whichIndex, 4] := 1
     If (SLDtypeLoaded=3)
        updateSQLdbEntry(oldFileName, newFileName, 0, resultedFilesList[whichIndex, 12])

     updateMainUnfilteredList(whichIndex, 1, OutDir "\" newFileName)
     ForceRefreshNowThumbsList()
     currentFilesListModified := 1
     dummyTimerDelayiedImageDisplay(150)
     showTOOLtip("File index entry updated")
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return 1
  } Else If (StrLen(newFileName)>2)
  {
     If (fileNotFound=1)
        showTOOLtip("ERROR: The file index entry was not updated.`nFile not found or access denied`n" newFileName)
     Else
        showTOOLtip("ERROR: The file index entry was not updated.`nIncorrect file name provided:`n" newFileName)
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return 0
  }
}

BtnBrowseAlphaMaskFile() {
    patternObj := {}
    patternObj["All files"] := "*.*"
    patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
    patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.sld*"
    patternObj["QPV slideshows"] := "*.sld;*.sldb"
    If isWinXP
       FileSelectFile, imgPath, 3, % prevOpenFolderPath, Open Image file, % pattern
    Else
       imgPath := openFileDialogWrapper("O", "FileMustExist", prevOpenFolderPath, "Open image or slideshow...", patternObj, chosenOption, 3)

    If !imgPath
       Return
 
    PasteInPlaceAlphaFile := imgPath
    GuiControl, SettingsGUIA:, PasteInPlaceAlphaFile, % imgPath
    SetTimer, updateUIpastePanel, -50
}

updateUIpastePanel(actionu:=0) {
    Static lastInvoked := 1
    isWinOpen := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
    If (isWinOpen=1)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, PasteInPlaceAdaptMode
    GuiControlGet, PasteInPlaceAlphaChannelFile
    GuiControlGet, PasteInPlaceAlignment
    GuiControlGet, PasteInPlaceOpacity
    GuiControlGet, PasteInPlaceCropSel
    GuiControlGet, PasteInPlaceCropAngular
    GuiControlGet, PasteInPlaceQuality
    GuiControlGet, PasteInPlaceOrientation
    GuiControlGet, PasteInPlaceApplyColorFX
    GuiControlGet, PasteInPlaceBlurAmount
    GuiControlGet, PasteInPlaceLivePreview
    GuiControlGet, PasteInPlaceHue
    GuiControlGet, PasteInPlaceSaturation
    GuiControlGet, PasteInPlaceLight
    GuiControlGet, PasteInPlaceGamma
    GuiControlGet, PasteInPlaceAlphaMaskClrA
    GuiControlGet, PasteInPlaceAlphaMaskClrB
    GuiControlGet, PasteInPlaceAlphaMaskMode
    GuiControlGet, PasteInPlaceBlurEdgesSoft
    GuiControlGet, uiPasteInPlaceAlphaFile
    GuiControlGet, alphaMaskReplaceMode
    GuiControlGet, FillAreaGradientAngle
    GuiControlGet, FillAreaGradientSigma
    GuiControlGet, FillAreaGradientBlend
    GuiControlGet, FillAreaGradientScale
    GuiControlGet, FillAreaGradientWrapped
    GuiControlGet, FillAreaColorReversed
    GuiControlGet, FillAreaBlendMode
    GuiControlGet, FillAreaGlassy

    PasteInPlaceAlphaFile := uiPasteInPlaceAlphaFile
    If (AnyWindowOpen=31)
       GuiControlGet, PasteInPlaceEraseInitial
    Else
       GuiControl, SettingsGUIA: Disable, PasteInPlaceEraseInitial

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIpastePanel, -150
       Return
    }

    If (coreDesiredPixFmt="0x21808")
    {
       PasteInPlaceAlphaMaskMode := 1
       GuiControl, Disable, PasteInPlaceAlphaMaskMode
       GuiControl, Choose, PasteInPlaceAlphaMaskMode, 1
    }

    thisOpacity := Round((PasteInPlaceOpacity / 128) * 100)
    GuiControl, SettingsGUIA:, infoPasteOpacity, Image opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoPasteHue, Hue: %PasteInPlaceHue%°
    GuiControl, SettingsGUIA:, infoPasteSat, Saturation: %PasteInPlaceSaturation%`%
    GuiControl, SettingsGUIA:, infoPasteLight, Brightness: %PasteInPlaceLight%
    GuiControl, SettingsGUIA:, infoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    GuiControl, SettingsGUIA:, infoPasteBlur, Image blur level: %PasteInPlaceBlurAmount% ; (inaccurate live preview)
    GuiControl, SettingsGUIA:, infoFillAreaSigma, Pos. A: %FillAreaGradientSigma%`%
    GuiControl, SettingsGUIA:, infoFillAreaBlend, Pos. B: %FillAreaGradientBlend%`%
    GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%°
    If (PasteInPlaceAlphaMaskMode=5)
    {
       thisAlphaBlur := Round((FillAreaGradientScale - 1)/305 * 255)
       GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Blur amount: %thisAlphaBlur%
    } Else GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%

    If (PasteInPlaceAlphaMaskMode>=5 || PasteInPlaceAlphaMaskMode=1)
       GuiControl, SettingsGUIA: Disable, FillAreaGradientWrapped
    Else
       GuiControl, SettingsGUIA: Enable, FillAreaGradientWrapped

    If (FillAreaBlendMode>1)
       GuiControl, SettingsGUIA: Enable, FillAreaGlassy
    Else
       GuiControl, SettingsGUIA: Disable, FillAreaGlassy

    If (PasteInPlaceBlurAmount>1)
       GuiControl, SettingsGUIA: Enable, PasteInPlaceBlurEdgesSoft
    Else
       GuiControl, SettingsGUIA: Disable, PasteInPlaceBlurEdgesSoft

    actu2 := (PasteInPlaceApplyColorFX=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, PasteInPlaceLight
    GuiControl, % actu2, PasteInPlaceGamma
    GuiControl, % actu2, PasteInPlaceHue
    GuiControl, % actu2, PasteInPlaceSaturation
    GuiControl, % actu2, infoPasteLight
    GuiControl, % actu2, infoPasteGamma
    GuiControl, % actu2, infoPasteHue
    GuiControl, % actu2, infoPasteSat

    actu := (PasteInPlaceAlphaMaskMode>1 && PasteInPlaceAlphaMaskMode!=5 && PasteInPlaceAlphaMaskMode!=6) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, alphaMaskReplaceMode
    GuiControl, % actu, infoFillAreaSigma
    GuiControl, % actu, infoFillAreaBlend
    GuiControl, % actu, FillAreaGradientSigma
    GuiControl, % actu, FillAreaGradientBlend
    GuiControl, % actu, FillAreaColorReversed

    actu := (PasteInPlaceAlphaMaskMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, infoFillAreaGradientScale
    GuiControl, % actu, FillAreaGradientScale

    actu := (PasteInPlaceAlphaMaskMode=5) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, uiPasteInPlaceAlphaFile
    GuiControl, % actu, PasteInPlaceAlphaChannelFile
    GuiControl, % actu, btnFldr
    GuiControl, % actu, infoAlphaFile
    If (PasteInPlaceAdaptMode=2)
       GuiControl, SettingsGUIA: Disable, PasteInPlaceAlignment
    Else
       GuiControl, SettingsGUIA: Enable, PasteInPlaceAlignment

    If (PasteInPlaceCropSel>1)
    {
       GuiControl, SettingsGUIA: Enable, PasteInPlaceCropAngular
       GuiControl, SettingsGUIA: Enable, editF5
       GuiControl, SettingsGUIA: Enable, infoAngleu
    } Else
    {
       GuiControl, SettingsGUIA: Disable, PasteInPlaceCropAngular
       GuiControl, SettingsGUIA: Disable, editF5
       GuiControl, SettingsGUIA: Disable, infoAngleu
    }

    If (PasteInPlaceAlphaMaskMode=6)
    {
       brLvl := PasteInPlaceAlphaMaskClrA
       contrLvl := Round(PasteInPlaceAlphaMaskClrB/255, 3)
       GuiControl, SettingsGUIA:, infoPasteAlphaClrA, Blur amount: %brLvl%
       GuiControl, SettingsGUIA:, infoPasteAlphaClrB, Curve tension: %contrLvl%
    } Else If (PasteInPlaceAlphaMaskMode=5)
    {
       brLvl := Round(PasteInPlaceAlphaMaskClrA/255*510-255)
       contrLvl := Round(PasteInPlaceAlphaMaskClrB/255*100)
       GuiControl, SettingsGUIA:, infoPasteAlphaClrA, Brightness: %brLvl%
       GuiControl, SettingsGUIA:, infoPasteAlphaClrB, Contrast: %contrLvl%
    } Else
    {
       GuiControl, SettingsGUIA:, infoPasteAlphaClrA, Intensity A: %PasteInPlaceAlphaMaskClrA%
       GuiControl, SettingsGUIA:, infoPasteAlphaClrB, Intensity B: %PasteInPlaceAlphaMaskClrB%
    }

    actu := (PasteInPlaceAlphaMaskMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, alphaMaskReplaceMode
    GuiControl, % actu, FillAreaColorReversed
    GuiControl, % actu, PasteInPlaceAlphaMaskClrA
    GuiControl, % actu, PasteInPlaceAlphaMaskClrB
    GuiControl, % actu, infoPasteAlphaClrA
    GuiControl, % actu, infoPasteAlphaClrB
    GuiControl, % actu, FillAreaGradientAngle
    GuiControl, % actu, infoFillAreaGradientAngle

    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing(1)

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsPasteInPlacePanel, -350
}

WriteSettingsPasteInPlacePanel() {
   ReadSettingsPasteInPlace(1)
}

throwErrorSelectionOutsideBounds(whichBitmap:=0) {
    whichBitmap := StrLen(whichBitmap)>1 ? whichBitmap : useGdiBitmap()
    If testSelectOutsideImgEntirely(whichBitmap)
    {
       SoundBeep , 300, 100
       showDelayedTooltip("WARNING: Invalid image selection area. It seems to be entirely outside the image boundaries.")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return 1
    }
}

BtnPasteInSelectedArea() {
    If throwErrorSelectionOutsideBounds()
       Return

    updateUIpastePanel("noPreview")
    Sleep, 1
    CloseWindow(0, 0)
    ToggleEditImgSelection("show-edit")
    Sleep, 1
    ; viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    PasteInPlaceNow()
}

importGivenFile() {
   If !prevLoadedImageIndex
      Return

   imgPath := getIDimage(currentFileIndex)
   currentFileIndex := prevLoadedImageIndex
   MenuReturnIMGedit()
   Sleep, 2
   ToggleEditImgSelection("show-edit")
   Sleep, 2
   PanelPasteInPlace(imgPath)
}

ReadSettingsPasteInPlace(act:=0) {
    If (customShapePoints.Count()<3 && act=0)
    {
       INIaction(0, "FillAreaCustomShape", "General", 5)
       INIaction(0, "initialCustomShapeCoords", "General", 5)
       customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
    }
    INIaction(act, "alphaMaskReplaceMode", "General", 1)
    INIaction(act, "FillAreaBlendMode", "General", 2, 1, 21)
    INIaction(act, "FillAreaColorReversed", "General", 1)
    INIaction(act, "FillAreaGlassy", "General", 2, 1, 6)
    INIaction(act, "FillAreaGradientAngle", "General", 2, 0, 360)
    INIaction(act, "FillAreaGradientBlend", "General", 2, 0, 100)
    INIaction(act, "FillAreaGradientScale", "General", 2, 1, 300)
    INIaction(act, "FillAreaGradientSigma", "General", 2, 0, 100)
    INIaction(act, "FillAreaGradientWrapped", "General", 1)
    INIaction(act, "PasteInPlaceAdaptMode", "General", 2, 1, 3)
    INIaction(act, "PasteInPlaceAlphaMaskClrA", "General", 2, 0, 255)
    INIaction(act, "PasteInPlaceAlphaMaskClrB", "General", 2, 0, 255)
    INIaction(act, "PasteInPlaceAlphaMaskMode", "General", 2, 1, 6)
    INIaction(act, "PasteInPlaceApplyColorFX", "General", 1)
    INIaction(act, "PasteInPlaceBlurAmount", "General", 2, 0, 255)
    INIaction(act, "PasteInPlaceBlurEdgesSoft", "General", 1)
    INIaction(act, "PasteInPlaceAlignment", "General", 2, 1, 5)
    INIaction(act, "PasteInPlaceCropSel", "General", 2, 1, 7)
    INIaction(act, "PasteInPlaceCropAngular", "General", 2, 0, 359)
    INIaction(act, "PasteInPlaceEraseInitial", "General", 1)
    INIaction(act, "PasteInPlaceGamma", "General", 2, -100, 100)
    INIaction(act, "PasteInPlaceHue", "General", 2, -180, 180)
    INIaction(act, "PasteInPlaceLight", "General", 2, -255, 255)
    INIaction(act, "PasteInPlaceSaturation", "General", 2, -100, 100)
    INIaction(act, "PasteInPlaceLivePreview", "General", 1)
    INIaction(act, "PasteInPlaceOpacity", "General", 2, 1, 256)
    INIaction(act, "PasteInPlaceOrientation", "General", 2, 1, 4)
    INIaction(act, "PasteInPlaceQuality", "General", 1)
}

PanelTransformSelectedArea() {
   MainPanelTransformArea(0, "transform")
}

PanelPasteInPlace(dummy:="") {
   MainPanelTransformArea(dummy, "paste")
}

BTNresetPasteInPlaceCropAngle() {
   GuiControl, SettingsGUIA:, editF5, 0
   updateUIpastePanel()
}

MainPanelTransformArea(dummy:="", toolu:="") {

    userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    imgPath := getIDimage(currentFileIndex)
    calcScreenLimits()
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || openingPanelNow=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    If throwErrorSelectionOutsideBounds()
       Return

    openingPanelNow := 1
    DestroyGIFuWin()
    changeMcursor()
    setImageLoading()
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    If (toolu="transform")
    {
       showTOOLtip("Retrieving image selected area, please wait")
       userClipBMPpaste := getTransformToolSelectedArea(1, 0, 1)
       If StrLen(userClipBMPpaste)>2
       {
          Gdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
          Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)
          QPV_SetGivenAlphaLevel(viewportStampBMP, 1, 1)
       }
    } Else If (toolu="paste")
    {
       showTOOLtip("Retrieving clipboard image, please wait")
       If FileRexists(dummy)
       {
          thisPBitmap := LoadBitmapFromFileu(dummy)
          userClipBMPpaste := Gdip_CloneBmpPargbArea(A_ThisFunc, thisPBitmap)
          trGdip_DisposeImage(thisPBitmap, 1)
       } Else
          userClipBMPpaste := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 0)

       If StrLen(userClipBMPpaste)>2
       {
          Gdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
          Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)

          QPV_SetGivenAlphaLevel(viewportStampBMP, 1, 1)
       }
    }

    If (StrLen(userClipBMPpaste)<3 || StrLen(viewportStampBMP)<3)
    {
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       SetTimer, resetOpeningPanel, -200
       showTOOLtip("ERROR: Failed to retrieve image")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return
    }

    imgEditPanelOpened := 1
    viewportIDstampBMP := A_TickCount
    If (toolu="transform")
    {
       recordSelUndoLevelNow()
       prevVPselRotation := vPselRotation
       prevrotateSelBoundsKeepRatio := rotateSelBoundsKeepRatio
       prevEllipseSelectMode := EllipseSelectMode
       prevImgSelX1 := imgSelX1, prevImgSelX2 := imgSelX2
       prevImgSelY1 := imgSelY1, prevImgSelY2 := imgSelY2
       
       Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelX1 := pB.x, imgSelY1 := pB.y
       imgSelX2 := pB.x + pB.w
       imgSelY2 := pB.y + pB.h
       VPstampBMPx := pB.x, VPstampBMPy := pB.y
       vPselRotation := 0
       PasteInPlaceToolMode := 1
       dummyRefreshImgSelectionWindow()
       thisBtnHeight := createSettingsGUI(31, "PanelTransformSelectedArea")
    } Else If (toolu="paste")
    {
       flipBitmapAccordingToViewPort(viewportStampBMP)
       PasteInPlaceToolMode := 0
       thisBtnHeight := createSettingsGUI(24, "PanelPasteInPlace")
    }

    EllipseSelectMode := vPselRotation := 0
    ResetImgLoadStatus()
    ReadSettingsPasteInPlace()
    If isWinXP
       FillAreaBlendMode := 1

    If (coreDesiredPixFmt="0x21808")
       PasteInPlaceAlphaMaskMode := 1

    btnWid := 90,  txtWid := 310
    EditWid := 60, slideWid := 150
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 55
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid2 := txtWid//2
    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (toolu="transform")
       prevModeViewPortSelectionManager(prevDestPosX, prevDestPosY, oImgW, oImgH)

    thisOpacity := Round((PasteInPlaceOpacity / 128) * 100)
    Global infoPasteBlur, infoPasteOpacity, infoPasteHue, infoPasteSat, infoPasteLight, infoPasteGamma
         , infoFillAreaSigma, infoFillAreaBlend, infoFillAreaGradientAngle, infoFillAreaGradientScale
         , infoPasteAlphaClrA, infoPasteAlphaClrB, infoAlphaFile, infoAngleu

    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, Main|Adjust colors|Alpha mask
    Gui, Tab, 1 ; general
    If (toolu="transform")
    {
       Gui, Add, Text, x+15 y+15 Section w%txtWid%, Canvas: %oImgW% x %oImgH% px.`nTransformed object: %imgW% x %imgH% px.
    } Else If (toolu="paste")
    {
       Gui, Add, Text, x+15 y+15 w%txtWid%, Please choose how to paste the clipboard content.
       Gui, Add, Text, y+7 Section wp, Canvas: %oImgW% x %oImgH% px.`nClipboard object: %imgW% x %imgH% px.
    }

    Gui, Add, DropDownList, xs y+7 wp gupdateUIpastePanel AltSubmit Choose%PasteInPlaceAdaptMode% vPasteInPlaceAdaptMode, Adjust image to selection|Fill selection area entirely (ignore aspect ratio)|Original image size
    Gui, Add, DropDownList, xs y+7 gupdateUIpastePanel w%txtWid2% AltSubmit Choose%PasteInPlaceOrientation% vPasteInPlaceOrientation, No mirroring|Flip horizontal|Flip vertical|Flip horizontal and vertical
    Gui, Add, DropDownList, x+2 gupdateUIpastePanel wp AltSubmit Choose%PasteInPlaceAlignment% vPasteInPlaceAlignment, Top-left|Top-right|Centered|Bottom-left|Bottom-right
    Gui, Add, DropDownList, xs y+7 wp AltSubmit Choose%PasteInPlaceCropSel% vPasteInPlaceCropSel gupdateUIpastePanel, No cropping|Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus
    Gui, Add, Text, x+2 hp +0x200 vinfoAngleu gBTNresetPasteInPlaceCropAngle, Angle:
    Gui, Add, Edit, x+2 w70 number -multi limit3 veditF5, % PasteInPlaceCropAngular
    Gui, Add, UpDown, vPasteInPlaceCropAngular Range0-359 gupdateUIpastePanel, % PasteInPlaceCropAngular
    ; If (toolu="transform")
       Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceEraseInitial% vPasteInPlaceEraseInitial, &Erase initially selected area
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceQuality% vPasteInPlaceQuality, &High quality image resampling
    Gui, Add, Text, xs y+10 w%txtWid2% gBtnResetPanelsSpecificControl vinfoPasteBlur, Image blur level: %PasteInPlaceBlurAmount% ; (inaccurate live preview)
    Gui, Add, Checkbox, x+5 hp gupdateUIpastePanel Checked%PasteInPlaceBlurEdgesSoft% vPasteInPlaceBlurEdgesSoft, &Soft edges
    Gui, Add, Slider, xs y+1 gupdateUIpastePanel AltSubmit ToolTip w%txtWid% vPasteInPlaceBlurAmount Range0-255, % PasteInPlaceBlurAmount
    If (coreDesiredPixFmt="0x21808")
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+10 w%txtWid%, WARNING: 32-bits RGBA mode is not activated. This tool may yield erroneous results.
       Gui, Font, Normal
    }

    Gui, Tab, 2 ; colors
    Gui, Add, Checkbox, x+15 y+15 Section gupdateUIpastePanel Checked%PasteInPlaceApplyColorFX% vPasteInPlaceApplyColorFX, Apply color adjustments
    Gui, Add, DropDownList, x+10 wp-40 gupdateUIpastePanel AltSubmit Choose%FillAreaBlendMode% vFillAreaBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Text, xs y+5 w%txtWid% gBtnResetPanelsSpecificControl vinfoPasteHue, Hue: %PasteInPlaceHue%°
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceHue Range-180-180, % PasteInPlaceHue
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteSat, Saturation: %PasteInPlaceSaturation%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceSaturation Range-100-100, % PasteInPlaceSaturation
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteLight, Brightness: %PasteInPlaceLight%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceLight Range-255-255, % PasteInPlaceLight
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceGamma Range-100-100, % PasteInPlaceGamma
    Gui, Add, Text, y+4 gBtnResetPanelsSpecificControl vinfoPasteOpacity , Image opacity: 100`% - ; %thisOpacity%
    Gui, Add, DropDownList, x+25 wp AltSubmit Choose%FillAreaGlassy% vFillAreaGlassy gupdateUIpastePanel, No glass effect|Weak|Mild|Moderate|Strong|Extreme
    Gui, Add, Slider, xs y+1 w%txtWid% AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceOpacity Range1-256, % PasteInPlaceOpacity

    Gui, Tab, 3 ; alpha mask
    friendlyMaskInfo := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "No alpha mask"
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid2% AltSubmit Choose%PasteInPlaceAlphaMaskMode% vPasteInPlaceAlphaMaskMode gupdateUIpastePanel, %friendlyMaskInfo%|Linear gradient|Radial gradient|Box gradient|Image file|Custom shape
    Gui, Add, Checkbox, x+2 hp Checked%FillAreaColorReversed% vFillAreaColorReversed gupdateUIpastePanel, &Invert
    Gui, Add, Checkbox, x+2 hp Checked%FillAreaGradientWrapped% vFillAreaGradientWrapped gupdateUIpastePanel, &Tiled
    Gui, Add, Checkbox, x+2 hp Checked%alphaMaskReplaceMode% valphaMaskReplaceMode gupdateUIpastePanel, &Replace
    Gui, Add, Text, xs y+10 w%slideWid% +0x200 gBtnResetPanelsSpecificControl vinfoPasteAlphaClrA, Intensity A: 0
    Gui, Add, Text, x+5 hp wp +0x200 gBtnResetPanelsSpecificControl vinfoPasteAlphaClrB, Intensity B: 0
    Gui, Add, Slider, xs y+1 NoTicks wp gupdateUIpastePanel ToolTip AltSubmit vPasteInPlaceAlphaMaskClrA Range0-255, % PasteInPlaceAlphaMaskClrA
    Gui, Add, Slider, x+5 NoTicks wp gupdateUIpastePanel ToolTip AltSubmit vPasteInPlaceAlphaMaskClrB Range0-255, % PasteInPlaceAlphaMaskClrB

    Gui, Add, Text, xs y+15 w%slideWid% gBtnResetPanelsSpecificControl vinfoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%° 
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientAngle Range0-360, % FillAreaGradientAngle
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientScale Range1-300, % FillAreaGradientScale

    Gui, Add, Text, xs y+10 wp gBtnResetPanelsSpecificControl vinfoFillAreaSigma, Sigma: %FillAreaGradientSigma%`%
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaBlend, Blend: %FillAreaGradientBlend%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientSigma Range0-100, % FillAreaGradientSigma
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientBlend Range0-100, % FillAreaGradientBlend
    Gui, Add, Text, xs y+10 wp vinfoAlphaFile, Image file path or list index number:
    Gui, Add, Combobox, xs y+10 w%txtWid2% vuiPasteInPlaceAlphaFile, obj|%uiPasteInPlaceAlphaFile%||this|prev|next|first|last
    Gui, Add, DropDownList, x+5 wp-95 AltSubmit Choose%PasteInPlaceAlphaChannelFile% vPasteInPlaceAlphaChannelFile gupdateUIpastePanel, Red|Green|Blue|Alpha|All gray
    Gui, Add, Button, x+5 hp wp gBtnBrowseAlphaMaskFile vbtnFldr, B&rowse

    Gui, Tab
    friendlyBtn := (toolu="paste") ? "&Paste" : "&Transform"
    friendlyTitle := (toolu="paste") ? "Paste in place: " : "Transform selected area: "
    Gui, Add, Button, xm+0 y+15 Section h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w115 hp Default gapplyIMGeditFunction, % friendlyBtn
    Gui, Add, Button, x+5 hp w75 gBtnPasteResetOptions, &Reset
    Gui, Add, Button, x+5 hp wp gBtnHelpTransform, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xs y+7 gupdateUIpastePanel Checked%PasteInPlaceLivePreview% vPasteInPlaceLivePreview, &Live preview (low quality)
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, friendlyTitle appTitle, winPos)
    SetTimer, updateUIpastePanel, -350
    SetTimer, resetOpeningPanel, -300
}

BtnHelpTransform() {
    msgBoxWrapper(appTitle ": HELP", "The transform tool is a multi-functional one. You can clone, crop, resize, rotate, colour adjust and blend images with this tool.`n`nClone image area. Once you have selected an area in the image and opened this panel, deselect «Erase initially selected area» found in the Main tab.`n`nRotate the image. Locate a gray dot with the mouse cursor in the center of the selection area in the viewport, and click 'n drag to adjust the rotation angle.`n`nCrop an image. Set the first drop-down found in the Main tab, to «Original image size», make the selection as small as you need it to be, and set to your preferences the other drop-downs that designate the cropping shape, its angle and the alignment.`n`nAdjust colours and blend images. In the «Adjust colours» tab one can activate the colour adjustments check-box, adjust opacity and choose different blending modes.`n`nWhen alpha masking is activated and the tab pertaining to this is also activated, users can click 'n drag inside the selection area to adjust the mask's gradient center. To reset the position, press Alt+L-Click inside the selection area.", -1, 0, 0)
}

BtnResetPanelsSpecificControl(CtrlHwnd, b, c) {
   ; GuiControlGet, varu, SettingsGUIA: FocusV
   If (AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControlGet, modus, SettingsGUIA:, PasteInPlaceAlphaMaskMode

   GuiControlGet, varu, SettingsGUIA: Name, % CtrlHwnd
   ; ToolTip, % varu "`n" a "|" b "|" c , , , 2
   If (varu="infoPasteBlur")
   {
      PasteInPlaceBlurAmount := 0
      GuiControl, SettingsGUIA:, PasteInPlaceBlurAmount, % PasteInPlaceBlurAmount
   }

   If (varu="infoPasteHue")
   {
      PasteInPlaceHue := 0
      GuiControl, SettingsGUIA:, PasteInPlaceHue, % PasteInPlaceHue
   }

   If (varu="infoPasteSat")
   {
      PasteInPlaceSaturation := 0
      GuiControl, SettingsGUIA:, PasteInPlaceSaturation, % PasteInPlaceSaturation
   }

   If (varu="infoPasteLight")
   {
      PasteInPlaceLight := 0
      GuiControl, SettingsGUIA:, PasteInPlaceLight, % PasteInPlaceLight
   }

   If (varu="infoPasteGamma")
   {
      PasteInPlaceGamma := 0
      GuiControl, SettingsGUIA:, PasteInPlaceGamma, % PasteInPlaceGamma
   }

   If (varu="infoPasteOpacity")
   {
      PasteInPlaceOpacity := 128
      GuiControl, SettingsGUIA:, PasteInPlaceOpacity, % PasteInPlaceOpacity
   }

   If (varu="infoPasteAlphaClrA")
   {
      PasteInPlaceAlphaMaskClrA := (modus=5) ? 128 : 0
      GuiControl, SettingsGUIA:, PasteInPlaceAlphaMaskClrA, % PasteInPlaceAlphaMaskClrA
   }

   If (varu="infoPasteAlphaClrB")
   {
      PasteInPlaceAlphaMaskClrB := (modus=5) ? 0 : 255
      GuiControl, SettingsGUIA:, PasteInPlaceAlphaMaskClrB, % PasteInPlaceAlphaMaskClrB
   }

   If (varu="infoFillAreaGradientAngle")
   {
      FillAreaGradientAngle := 0
      GuiControl, SettingsGUIA:, FillAreaGradientAngle, % FillAreaGradientAngle
   }

   If (varu="infoFillAreaGradientScale")
   {
      FillAreaGradientScale := (modus=5) ? 1 : 100
      GuiControl, SettingsGUIA:, FillAreaGradientScale, % FillAreaGradientScale
   }

   If (varu="infoFillAreaSigma")
   {
      FillAreaGradientSigma := 0
      GuiControl, SettingsGUIA:, FillAreaGradientSigma, % FillAreaGradientSigma
   }

   If (varu="infoFillAreaBlend")
   {
      FillAreaGradientBlend := 100
      GuiControl, SettingsGUIA:, FillAreaGradientBlend, % FillAreaGradientBlend
   }

   If (varu="infoFillAreaContour")
   {
      FillAreaContourThickness := 10
      GuiControl, SettingsGUIA:, FillAreaContourThickness, % FillAreaContourThickness
   }

   If (AnyWindowOpen=24 || AnyWindowOpen=31)
      SetTimer, updateUIpastePanel, -50
   Else If (AnyWindowOpen=23)
      SetTimer, updateUIfillPanel, -50
}

BtnPasteResetOptions() {
   PasteInPlaceBlurAmount := PasteInPlaceHue := PasteInPlaceSaturation := PasteInPlaceLight := FillAreaGradientAngle := 0
   PasteInPlaceCropSel := PasteInPlaceOrientation := PasteInPlaceAdaptMode := PasteInPlaceAlphaMaskMode := 1
   PasteInPlaceAlignment := 3
   PasteInPlaceApplyColorFX := PasteInPlaceGamma := 0
   PasteInPlaceOpacity := 128
   If (AnyWindowOpen=24)
      GuiControl, SettingsGUIA:, PasteInPlaceBlurAmount, % PasteInPlaceBlurAmount
   GuiControl, SettingsGUIA:, PasteInPlaceHue, % PasteInPlaceHue
   GuiControl, SettingsGUIA:, PasteInPlaceApplyColorFX, % PasteInPlaceApplyColorFX
   GuiControl, SettingsGUIA:, PasteInPlaceSaturation, % PasteInPlaceSaturation
   GuiControl, SettingsGUIA:, PasteInPlaceLight, % PasteInPlaceLight
   GuiControl, SettingsGUIA:, PasteInPlaceGamma, % PasteInPlaceGamma
   GuiControl, SettingsGUIA:, PasteInPlaceOpacity, % PasteInPlaceOpacity
   GuiControl, SettingsGUIA:, FillAreaGradientAngle, % FillAreaGradientAngle
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAlphaMaskMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAlignment, 3
   GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAdaptMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceCropSel, 1
   ; WriteSettingsPasteInPlacePanel()
   updateUIpastePanel()
}

ReadSettingsFillAreaPanel(act:=0) {
    If (act=0)
    {
       INIaction(0, "initialCustomShapeCoords", "General", 5)
       INIaction(0, "FillAreaCustomShape", "General", 5)
       If (drawingShapeNow!=1)
          INIaction(0, "FillAreaCurveTension", "General", 2, 1, 4)
    } Else If (act=1)
    {
       INIaction(1, "FillAreaCurveTension", "General")
       If InStr(FillAreaCustomShape, "|")
          INIaction(1, "FillAreaCustomShape", "General")
    }

    INIaction(act, "FillArea2ndColor", "General", 3)
    INIaction(act, "FillArea2ndOpacity", "General", 2, 1, 255)
    INIaction(act, "FillAreaBlendMode", "General", 2, 1, 21)
    INIaction(act, "FillAreaClosedPath", "General", 1)
    INIaction(act, "FillAreaColor", "General", 3)
    INIaction(act, "FillAreaColorMode", "General", 2, 1, 5)
    INIaction(act, "FillAreaColorReversed", "General", 1)
    INIaction(act, "FillAreaContourAlign", "General", 2, 1, 3)
    INIaction(act, "FillAreaContourThickness", "General", 2, 1, 450)
    INIaction(act, "FillAreaDashStyle", "General", 2, 1, 4)
    INIaction(act, "FillAreaDoContour", "General", 1)
    INIaction(act, "FillAreaDoubleLine", "General", 1)
    INIaction(act, "FillAreaGlassy", "General", 2, 1, 6)
    INIaction(act, "FillAreaGradientAngle", "General", 2, 0, 360)
    INIaction(act, "FillAreaGradientBlend", "General", 2, 0, 100)
    INIaction(act, "FillAreaGradientScale", "General", 2, 1, 300)
    INIaction(act, "FillAreaGradientSigma", "General", 2, 0, 100)
    INIaction(act, "FillAreaGradientWrapped", "General", 1)
    INIaction(act, "FillAreaInverted", "General", 1)
    INIaction(act, "FillAreaOpacity", "General", 2, 1, 255)
    INIaction(act, "FillAreaRemBGR", "General", 1)
    INIaction(act, "FillAreaRoundedCaps", "General", 1)
    INIaction(act, "FillAreaShape", "General", 2, 1, 7)
    INIaction(act, "FillAreaLivePreview", "General", 1)
}

LEDguiGuiClose:
LEDguiGuiEscape:
   colorPickerModeNow := 0
   Gui, LEDgui: Destroy
Return

StopColorPicker() {
   Critical, on
   colorPickerModeNow := 0
}

StartPickingColor() {
   g := A_Gui, ctrl := A_GuiControl
   ctrl := StrReplace(ctrl, "picku")
   If (isWinXP=1 || A_OSVersion="WIN_7")
   {
      msgBoxWrapper(appTitle ": ERROR", "The color picker functionality is not yet implemented for Windows XP or Windows 7... Please use the color selector associated.", 0, 0, "error")
      Return
   }

   hideLivePreviewObject()
   Sleep, 2
   pBitmap := Gdip_BitmapFromHWND(PVhwnd, 1)
   Gdip_GetImageDimensions(pBitmap, imgW, imgH)
   If StrLen(pBitmap)>2
   {
      createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 1, A_ThisFunc]
   } Else
   {
      showTOOLtip("Failed to capture main window bitmap`n`nPlease try again to pick a color")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   diffH := diffW := 0
   LEDu := imgHUDbaseUnit
   Gui, LEDgui: -DPIScale +AlwaysOnTop -Caption +Owner +ToolWindow +E0x20 +hwndhColorPrev
   Gui, LEDgui: Color, 000000
   WinSet, AlwaysOnTop, On, ahk_id %hColorPrev%
   Gui, LEDgui: Add, Text, x1 y1 w%LEDu% h%LEDu% gStopColorPicker, -
   Gui, LEDgui: Show, NoActivate x1 y1 w%LEDu% h%LEDu%, QPVcolorPicker
   Sleep, 1
   colorPickerModeNow := 1
   toggleImgEditPanelWindow("forced")
   errorOccured := 0
   While, (colorPickerModeNow=1)
   {
      If (errorOccured>700)
         Break

      Sleep, -1
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := clampInRange(mX + diffW, 0, imgW)
      mY := clampInRange(mY + diffH, 0, imgH)
      ; ToolTip, % imgW " | " imgH "`n" winW " | " winH "`n" diffW " | " diffH "`n" mX " | " mY , , , 2
      h := Gdip_GetPixelColor(pBitmap, mX, mY, 4)
      If !h
      {
         Sleep, 5
         errorOccured++
         Continue
      }

      ; createColorPrevWin(h)
      Gui, LEDgui: Color, %h%
      GetPhysicalCursorPos(pX, pY)
      pX -= LEDu//2, pY -= LEDu//2
      Gui, LEDgui: Show, NoActivate x%pX% y%pY%
      Sleep, 5
      hwnd := WinActive("A")
      ; ToolTip, % h "`n" z "`n" w , , , 2
      If (A_Index>1950)
      {
         errorOccured := 750
         Break
      }

      If (GetKeyState("RButton") || GetKeyState("MButton") || GetKeyState("Enter") || GetKeyState("Escape")
         || GetKeyState("Space") || GetKeyState("Tab") || GetKeyState("Numpad5") || hwnd=hColorPrev)
         Break
   }

   colorPickerModeNow := 0
   Gui, LEDgui: Destroy
   toggleImgEditPanelWindow("forced")

   trGdip_DisposeImage(pBitmap, 1)
   If (errorOccured>690)
      Return

   ; https://autohotkey.com/board/topic/43945-fast-pixelgetcolor-workaround-for-aero-windows-7-and-vista/
   o := %ctrl%
   SoundBeep, 900, 100
   ; ToolTip, % r "`n" ctrl "`n" o "`n" z , , , 2
   %ctrl% := h

   INIaction(1, ctrl, "General")
   GuiControl, %g%:+Background%h%, %ctrl%
   If (imgEditPanelOpened=1)
      livePreviewsImageEditing(1)
}

openPanelFillSelectionAfterDrawing() {
   PanelFillSelectedArea("hasDrawn")
}

openPanelDesatureAfterDrawing() {
   PanelDesatureSelectedArea("hasDrawn")
}

cancelDrawingShape() {
   stopDrawingShape("cancel")
}

stopDrawingShape(dummy:="") {
    If (drawingShapeNow!=1)
       Return

    zeitSillyPrevent := A_TickCount
    If (dummy="cancel")
       customShapePoints := oldCustomShape.Clone()
    Else
       customShapePoints := convertCustomShape2relativeCoords(customShapePoints)

    SetTimer, dummyRefreshImgSelectionWindow, -50
    If (!AnyWindowOpen && customShapePoints.Count()>2 && drawingLiveMode!=3)
    {
       If (prevOpenedWindow[1]=23)
          SetTimer, openPanelFillSelectionAfterDrawing, -150
       Else If (prevOpenedWindow[1]=55)
          SetTimer, openPanelDesatureAfterDrawing, -150
       Else
          SetTimer, openPreviousPanel, -150
    }

    If (drawingLiveMode=1 || drawingLiveMode=3)
       Gdip_DeletePen(PenuDrawLive)
    Else
       Gdip_DeleteBrush(PenuDrawLive)

    drawingShapeNow := 0
    PenuDrawLive := ""
    DestroyTempBtnGui("now")
    If (customShapePoints.Count()<3)
    {
       If (drawingLiveMode=3)
          EllipseSelectMode := 0
       Else If !AnyWindowOpen
          editingSelectionNow := 0

       showDelayedTooltip("Drawing abandoned")
       ; SetTimer, RemoveTooltip, % -msgDisplayTime
    } Else
    {
       If (drawingLiveMode=3 || prevOpenedWindow[1]!=23)
       {
          FillAreaCustomShape := convertShapePointsArrayToStr(customShapePoints)
          INIaction(1, "FillAreaCustomShape", "General")
          INIaction(1, "FillAreaCurveTension", "General")
          editingSelectionNow := 1
       }
       dummyTimerDelayiedImageDisplay(100)
    }

    Global zeitSillyPrevent := A_TickCount
    Global lastOtherWinClose := A_TickCount
    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    interfaceThread.ahkassign("drawingShapeNow", 0)
    updateUIctrl()
    MouseMoveResponder()
}

addFluidPointsCustomShape() {
   If (drawingShapeNow!=1 || mustSnapLiveDrawPoints=1)
      Return

   lastInvoked := 1
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   newArrayu := new hashtable()
   While, (determineLClickstate()=1)
   {
      If (mustSnapLiveDrawPoints=1)
         Break

      If (A_TickCount - lastInvoked<50)
         Continue

      GetMouseCoord2wind(PVhwnd, mX, mY)
      ogmX := (FlipImgH=1) ? mainWidth - mX : mX
      ogmY := (FlipImgV=1) ? mainHeight - mY : mY
      If (newArrayu[ogmX ogmY]=1)
         Continue

      mustSnapLiveDrawPoints := 0
      customShapePoints.Push([ogmX, ogmY])
      thisIndex := customShapePoints.MaxIndex()
      initialDrawingStartCoords[thisIndex] := [prevDestPosX, prevDestPosY]
      lastInvoked := A_TickCount
      newArrayu[ogmX ogmY] := 1
      newArrayu[ogmX + 1 ogmY + 1] := 1
      newArrayu[ogmX - 1 ogmY - 1] := 1
      newArrayu[ogmX + 1 ogmY - 1] := 1
      newArrayu[ogmX - 1 ogmY + 1] := 1
      lastZeitFileSelect := A_TickCount
      dummyRefreshImgSelectionWindow()
   }
   newArrayu := []
   SetTimer, addFluidPointsCustomShape, Off
}

startDrawingShape(modus, dummy:=0, forcePanel:=0) {
     If (thumbsDisplaying=1 || StrLen(gdiBitmap)<3)
        Return

     If (getCaptionStyle(PVhwnd)=1)
     {
        ToggleTitleBaruNow()
        Return
     }

     If (dummy="resume" && customShapePoints.Count()<3)
        dummy := ""

     If (AnyWindowOpen && imgEditPanelOpened=1)
     {
        If (AnyWindowOpen=55)
           prevOpenedWindow := [55, "PanelDesatureSelectedArea", 1]

        isWinOpen := AnyWindowOpen
        BtnCloseWindow()
        If (dummy="resume")
        {
           If (isWinOpen=23)
              modus := (FillAreaDoContour=1) ?  "line" : "shape"
           Else If (isWinOpen=25 || isWinOpen=10 || isWinOpen=55)
              modus := "shape"
        }
     }

     Sleep, 5
     If (editingSelectionNow=1)
        recordSelUndoLevelNow()

     If InStr(forcePanel, "draw")
        prevOpenedWindow := [23, "PanelFillSelectedArea", 1]

     drawingShapeNow := 1
     If (customShapePoints.Count()>2)
        oldCustomShape := customShapePoints.Clone()
     interfaceThread.ahkassign("drawingShapeNow", 1)
     If (dummy="resume")
     {
        zImgSelX1 := imgSelX1*zoomLevel
        zImgSelY1 := imgSelY1*zoomLevel
        zImgSelX2 := imgSelX2*zoomLevel
        zImgSelY2 := imgSelY2*zoomLevel
        vPimgSelPx := prevDestPosX + min(zImgSelX1, zImgSelX2)
        vPimgSelPy := prevDestPosY + min(zImgSelY1, zImgSelY2)
        vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
        vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
        If (VPselRotation>0)
        {
           pPath := createImgSelPath(vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 1)
           PointsList := Gdip_GetPathPoints(pPath)
           customShapePoints := convertShapePointsStrToArray(PointsList)
           Gdip_DeletePath(pPath)
        } Else
        {
           PointsList := convertCustomShape2givenArea(customShapePoints, vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH)
           customShapePoints := convertShapePointsStrToArray(PointsList)
        }
        ; ToolTip, % customShapePoints.Count() "===" PointsList , , , 2
     } Else 
     {
        customShapePoints := ""
        customShapePoints := []
        ToggleEditImgSelection("show-edit")
     }

     INIaction(0, "FillAreaColor", "General", 3)
     INIaction(0, "FillAreaCurveTension", "General", 2, 1, 4)
     INIaction(0, "closedLineCustomShape", "General", 1)
     decideCustomShapeStyle()
     thisColorA := (modus="line") ? "0xAA" FillAreaColor : "0x88" FillAreaColor
     If (modus="line")
     {
        PenuDrawLive := (isWinOpen=10) ? Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10) : Gdip_CreatePen(thisColorA, imgHUDbaseUnit//7)
        drawingLiveMode := 1
     } Else If (modus="shape")
     {
        If (isWinOpen=55)
           PenuDrawLive := Gdip_CloneBrush(pBrushF)
        Else
           PenuDrawLive := (isWinOpen=25) ? Gdip_CloneBrush(useHatchedBrush()) : Gdip_BrushCreateSolid(thisColorA)
        drawingLiveMode := 2
     } Else If (modus="selection")
     {
        PenuDrawLive := Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10)
        drawingLiveMode := 3
        EllipseSelectMode := 2
        LimitSelectBoundsImg := VPselRotation := 0
        closedLineCustomShape := lockSelectionAspectRatio := 1
     }

     initialDrawingStartCoords := []
     Loop, % customShapePoints.Count()
        initialDrawingStartCoords[A_Index] := [prevDestPosX, prevDestPosY]

     LabelCurve := (cardinalCurveCustomShape=1) ? "curved" : "polygonal"
     LabelType := (drawingLiveMode=1) ? "path" : "filled shape"
     If (drawingLiveMode=1)
     {
        LabelOpenLine := (closedLineCustomShape=1) ? "closed " : "open "
     } Else If (drawingLiveMode=3)
     {
        LabelOpenLine := "selection area"
        LabelCurve := LabelType := ""
     }

     showTOOLtip("Draw freeform " LabelOpenLine LabelCurve A_Space LabelType "`nPress Right Click to end.")
     showQuickActionButtonsDrawingShape()
     SetTimer, dummyRefreshImgSelectionWindow, 75
     SetTimer, RemoveTooltip, % -msgDisplayTime
}

reduceCustomShapelength() {
   ; foundPos := InStr(customShapePoints, "|", 0, -1)
   ; customShapePoints := SubStr(customShapePoints, 1, foundPos)
   customShapePoints.Pop()
   SetTimer, showQuickActionButtonsDrawingShape, -100
   If (drawingShapeNow=1)
     SetTimer, dummyRefreshImgSelectionWindow, 75
   ; SetTimer, DestroyTempBtnGui, % -msgDisplayTime*10000
}

ToggleCardinalCurveMode() {
   cardinalCurveCustomShape := !cardinalCurveCustomShape
   INIaction(1, "cardinalCurveCustomShape", "General")
   showQuickActionButtonsDrawingShape()
   If (drawingShapeNow=1)
      SetTimer, dummyRefreshImgSelectionWindow, 75
}

toggleOpenClosedLineCustomShape() {
   closedLineCustomShape := !closedLineCustomShape
   INIaction(1, "closedLineCustomShape", "General")
   showQuickActionButtonsDrawingShape()
   If (drawingShapeNow=1)
      SetTimer, dummyRefreshImgSelectionWindow, 75
}

showQuickActionButtonsDrawingShape() {
     LabelCurve := (cardinalCurveCustomShape=1) ? "Polygonal" : "Curve"
     If (drawingLiveMode=1)
     {
        LabelOpenLine := (closedLineCustomShape=1) ? "Open path" : "Closed path"
        btnOpenLine := "||" LabelOpenLine ",,toggleOpenClosedLineCustomShape"
     }

     LabelTension := "||Points tension " FillAreaCurveTension ",,togglePathCurveTension"
     CreateGuiButton("Undo,,reduceCustomShapelength||Cancel,,cancelDrawingShape||Done,,stopDrawingShape" btnOpenLine LabelTension, "Forced", msgDisplayTime*10000)
}

decideCustomShapeStyle() {
   If (FillAreaCurveTension=4)
      tensionCurveCustomShape := 0.95
   Else If (FillAreaCurveTension=3)
      tensionCurveCustomShape := 0.5
   Else If (FillAreaCurveTension=2)
      tensionCurveCustomShape := 0.2
   Else
      tensionCurveCustomShape := 0.1

   cardinalCurveCustomShape := (FillAreaCurveTension>1) ? 1 : 0
}

togglePathCurveTension() {
   FillAreaCurveTension := clampInRange(FillAreaCurveTension + 1, 1, 4, 1)
   decideCustomShapeStyle()
   INIaction(1, "FillAreaCurveTension", "General")
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, 75
}

BtnTabsInfoUpdate() {
   GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
}

PanelFillSelectedArea(dummy:=0) {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(23, A_ThisFunc)
    ReadSettingsFillAreaPanel()
    If (FillAreaShape<=3 || FillAreaShape=7)
    {
       If (EllipseSelectMode=1)
          FillAreaShape := 3
       Else If (EllipseSelectMode=0 && (FillAreaShape=3 || FillAreaShape=7))
          FillAreaShape := 1
       Else If (EllipseSelectMode=2)
          FillAreaShape := 7
    }

    If (dummy="hasDrawn")
    {
       FillAreaShape := 7
       FillAreaDoContour := (drawingLiveMode=1) ? 1 : 0
       FillAreaClosedPath := closedLineCustomShape
       FillAreaCustomShape := convertShapePointsArrayToStr(customShapePoints)
       INIaction(1, "FillAreaClosedPath", "General")
       INIaction(1, "FillAreaCustomShape", "General")
       ; INIaction(1, "FillAreaShape", "General")
       INIaction(1, "FillAreaDoContour", "General")
    } Else customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)


    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60, EllipseSelectMode := 0

    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    minislideWid := slideWid//2
    If (FillAreaDoContour=1)
       FillAreaRemBGR := 0

    If isWinXP
    {
       FillAreaBlendMode := 1
       FillAreaGlassy := 1
    }

    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    this2ndOpacity := Round((FillArea2ndOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoFillArea2ndOpacity, infoFillAreaContour, infoFillAreaGradientScale, infoFillAreaGradientAngle
         , infoFillAreaSigma, infoFillAreaBlend, PickuFillAreaColor, PickuFillArea2ndColor

    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, Main|Colors and gradients
    Gui, Tab, 1
    Gui, Add, DropDownList, x+10 y+10 Section w%slideWid% AltSubmit Choose%FillAreaShape% vFillAreaShape gupdateUIfillPanel, Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape
    Gui, Add, DropDownList, x+5 w%slideWid% AltSubmit Choose%FillAreaGlassy% vFillAreaGlassy gupdateUIfillPanel, No glass effect|Weak|Mild|Moderate|Strong|Extreme
    Gui, Add, Checkbox, xs y+7 wp hp Checked%FillAreaInverted% vFillAreaInverted gupdateUIfillPanel, &Invert selection area
    Gui, Add, DropDownList, x+5 w%slideWid% AltSubmit Choose%FillAreaCurveTension% vFillAreaCurveTension gupdateUIfillPanel, Polygonal|Smooth corners|Curve|Round curve
    Gui, Add, Checkbox, xs y+7 hp Checked%FillAreaRemBGR% vFillAreaRemBGR gupdateUIfillPanel, &Erase background behind the new object
    Gui, Add, Checkbox, xs y+7 hp Checked%FillAreaDoContour% vFillAreaDoContour gupdateUIfillPanel, &Draw only an outline / a contour
    Gui, Add, DropDownList, xs+15 y+7 w%btnWid% AltSubmit Choose%FillAreaContourAlign% vFillAreaContourAlign gupdateUIfillPanel, Inside|Centered|Outside
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%FillAreaDashStyle% vFillAreaDashStyle gupdateUIfillPanel, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, Checkbox, x+2 hp gupdateUIfillPanel Checked%FillAreaClosedPath% vFillAreaClosedPath, &Closed path
    Gui, Add, Checkbox, xs+15 y+6 wp hp Checked%FillAreaDoubleLine% vFillAreaDoubleLine gupdateUIfillPanel, &Double line
    Gui, Add, Checkbox, x+2 hp gupdateUIfillPanel Checked%FillAreaRoundedCaps% vFillAreaRoundedCaps, &Rounded caps
    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetPanelsSpecificControl vinfoFillAreaContour, Contour thickness: %FillAreaContourThickness% pixels
    Gui, Add, Slider, xs y+1 gupdateUIfillPanel ToolTip AltSubmit w%txtWid% vFillAreaContourThickness Range1-450, % FillAreaContourThickness

    Gui, Tab, 2
    Gui, Add, DropDownList, x+10 y+10 Section w200 AltSubmit Choose%FillAreaColorMode% vFillAreaColorMode gupdateUIfillPanel, Solid color|Linear gradient|Radial gradient|Box gradient|Random patterns
    Gui, Add, Checkbox, x+5 hp Checked%FillAreaGradientWrapped% vFillAreaGradientWrapped gupdateUIfillPanel, &Tiling pattern
    Gui, Add, Slider, xs y+10 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vFillAreaOpacity Range1-255, % FillAreaOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoFillAreaOpacity, %thisOpacity%`%
    Gui, Add, Slider, xs y+1 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vFillArea2ndOpacity Range1-255, % FillArea2ndOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillArea2ndColor, P
    Gui, Add, ListView, x+5 hp w60%CCLVO% Background%FillArea2ndColor% vFillArea2ndColor hwndhLVfill2ndColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoFillArea2ndOpacity, Opacity: %this2ndOpacity%00`%

    Gui, Add, Text, xs y+15 w%slideWid% gBtnResetPanelsSpecificControl vinfoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%° 
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientAngle Range0-360, % FillAreaGradientAngle
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientScale Range1-300, % FillAreaGradientScale

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "No blending mode"
    Gui, Add, Text, xs y+10 wp gBtnResetPanelsSpecificControl vinfoFillAreaSigma, Sigma: %FillAreaGradientSigma%`%
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaBlend, Blend: %FillAreaGradientBlend%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientSigma Range0-100, % FillAreaGradientSigma
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientBlend Range0-100, % FillAreaGradientBlend
    Gui, Add, Checkbox, xs y+5 Checked%FillAreaColorReversed% vFillAreaColorReversed gupdateUIfillPanel, &Reverse colors
    Gui, Add, DropDownList, x+10 wp gupdateUIfillPanel AltSubmit Choose%FillAreaBlendMode% vFillAreaBlendMode, %infoBlend%|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference

    Gui, Tab
    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%FillAreaLivePreview% vFillAreaLivePreview gupdateUIfillPanel, &Live preview
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Fill/draw shapes in selected area: " appTitle, winPos)
    SetTimer, updateUIfillPanel, -50
}

ToggleClosePanelApply() {
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   INIaction(1, "closeEditPanelOnApply", "General")
}

ReadSettingsDrawLinesArea(act:=0) {
    INIaction(act, "DrawLineAreaColor", "General", 3)
    INIaction(act, "DrawLineAreaOpacity", "General", 2, 1, 255)
    INIaction(act, "DrawLineAreaKeepBounds", "General", 1)
    INIaction(act, "DrawLineAreaCapsStyle", "General", 1)
    INIaction(act, "DrawLineAreaDoubles", "General", 1)
    INIaction(act, "DrawLineAreaContourAlign", "General", 2, 1, 3)
    INIaction(act, "DrawLineAreaDashStyle", "General", 2, 1, 4)
    INIaction(act, "DrawLineAreaContourThickness", "General", 2, 1, 450)
    INIaction(act, "DrawLineAreaBorderTop", "General", 1)
    INIaction(act, "DrawLineAreaBorderBottom", "General", 1)
    INIaction(act, "DrawLineAreaBorderLeft", "General", 1)
    INIaction(act, "DrawLineAreaBorderRight", "General", 1)
    INIaction(act, "DrawLineAreaBorderArcA", "General", 1)
    INIaction(act, "DrawLineAreaBorderArcB", "General", 1)
    INIaction(act, "DrawLineAreaBorderArcC", "General", 1)
    INIaction(act, "DrawLineAreaBorderArcD", "General", 1)
    INIaction(act, "DrawLineAreaBorderCenter", "General", 2, 1, 7)
}

PanelDrawLines() {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(30, A_ThisFunc)
    ReadSettingsDrawLinesArea()
    EllipseSelectMode := 0
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid := 165
    BtnHeight := thisBtnHeight - 5
    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    Global infoDrawLineAreaOpacity, infoDrawLineAreaContour, PickuDrawLineAreaColor
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please configure what lines to draw and how.
    Gui, Add, Text, y+10 Section w%txtWid%, Line style. Alignment.
    Gui, Add, DropDownList, xs y+7 w%btnWid% gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaDashStyle% vDrawLineAreaDashStyle, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, DropDownList, x+10 wp gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaContourAlign% vDrawLineAreaContourAlign, Inside|Centered|Outside

    Gui, Add, Checkbox, xs y+10 w55 h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcA% vDrawLineAreaBorderArcA,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderTop% vDrawLineAreaBorderTop,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcB% vDrawLineAreaBorderArcB,○
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, Rounded caps
    Gui, Add, Checkbox, xs y+1 w55 h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderLeft% vDrawLineAreaBorderLeft,▏
    Gui, Add, Text, x+1 wp hp Center,.
    ; Gui, Add, Checkbox, x+1 wp hp +0x1000 Checked%DrawLineAreaBorderCenter% vDrawLineAreaBorderCenter,▏
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderRight% vDrawLineAreaBorderRight,▏
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles, Double line
    Gui, Add, Checkbox, xs y+1 w55 h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcC% vDrawLineAreaBorderArcC,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderBottom% vDrawLineAreaBorderBottom,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcD% vDrawLineAreaBorderArcD,○
    Gui, Add, ListView, x+10 w%btnWid% hp %CCLVO% Background%DrawLineAreaColor% vDrawLineAreaColor,
    Gui, Add, Button, x+1 hp w25 gStartPickingColor vPickuDrawLineAreaColor, P

    Gui, Add, DropDownList, xs y+0 w%btnWid% gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaBorderCenter% vDrawLineAreaBorderCenter,No center line|Vertical|Horizontal|Slash|Backslash|Both diagonals|Both H/V lines
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaKeepBounds% vDrawLineAreaKeepBounds, &Within bounds

    Gui, Add, Text, xs y+10 w%txtWid% vinfoDrawLineAreaOpacity, Opacity: %thisOpacity%`%
    Gui, Add, Slider, xs y+1 gupdateUIDrawLinesPanel AltSubmit ToolTip w%txtWid% vDrawLineAreaOpacity Range3-255, % DrawLineAreaOpacity
    Gui, Add, Text, xs y+10 wp vinfoDrawLineAreaContour, Contour thickness: %DrawLineAreaContourThickness% pixels
    Gui, Add, Slider, xs y+1 gupdateUIDrawLinesPanel AltSubmit ToolTip w%txtWid% vDrawLineAreaContourThickness Range1-450, % DrawLineAreaContourThickness

    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w110 hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Draw lines or arcs in selected area: " appTitle, winPos)
    SetTimer, updateUIDrawLinesPanel, -50
}

PanelDesatureSelectedArea(dummy:=0) {
    If (thumbsDisplaying=1)
       Return

    If throwErrorNoImageLoaded()
      Return "fail"

    If (editingSelectionNow!=1 && dummy!="hasDrawn")
       selectEntireImage("r")
    Else
       ToggleEditImgSelection("show-edit")

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(55, A_ThisFunc)
    INIaction(0, "DesatureAreaAmount", "General", 2, 1, 100)
    INIaction(0, "DesatureAreaHue", "General", 2, -180, 180)
    INIaction(0, "DesatureAreaAlternate", "General", 1)
    ; INIaction(0, "EraseAreaInvert", "General", 1)
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    If isWinXP
       DesatureAreaAlternate := 0

    thisOpacity := DesatureAreaAmount
    Global infoAmount, infohueAdjust
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please decide the intensity and mode of image desaturation.
    Gui, Add, Checkbox, xs y+10 Checked%DesatureAreaAlternate% vDesatureAreaAlternate gupdateUIdesaturatePanel, &Alternate mode
    ; Gui, Add, Checkbox, x+10 hp Checked%EraseAreaInvert% vEraseAreaInvert gupdateUIdesaturatePanel, &Invert selection area
    Gui, Add, Text, xs+15 y+10 wp gBtnResetAmountDesature vinfoAmount, intensity: %thisOpacity%`%
    Gui, Add, Slider, xp y+5 AltSubmit gupdateUIdesaturatePanel ToolTip w%txtWid% vDesatureAreaAmount Range1-100, % DesatureAreaAmount
    Gui, Add, Text, xs+15 y+10 wp gBtnResetDesatureHue vinfohueAdjust, Relight: %DesatureAreaHue%°
    Gui, Add, Slider, xp y+5 AltSubmit gupdateUIdesaturatePanel ToolTip w%txtWid% vDesatureAreaHue Range-180-180, % DesatureAreaHue

    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w95 hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Desaturate selected area: " appTitle, winPos)
    SetTimer, updateUIdesaturatePanel, -150
}

PanelEraseSelectedArea() {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(25, A_ThisFunc)
    INIaction(0, "EraseAreaFader", "General", 1)
    INIaction(0, "EraseAreaOpacity", "General", 2, 4, 251)
    INIaction(0, "EraseAreaInvert", "General", 1)
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((EraseAreaOpacity / 255) * 100)
    Global infoEraseOpacity
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please decide how to erase or fade selected area:
    Gui, Add, Checkbox, xs y+10 hp Checked%EraseAreaFader% vEraseAreaFader gupdateUIerasePanel, &Fade selected area
    Gui, Add, Checkbox, x+10 hp Checked%EraseAreaInvert% vEraseAreaInvert gupdateUIerasePanel, &Invert selection area
    Gui, Add, Text, xs+15 y+10 wp hp vinfoEraseOpacity, Opacity: %thisOpacity%`%
    Gui, Add, Slider, xp y+5 AltSubmit gupdateUIerasePanel ToolTip w%txtWid% vEraseAreaOpacity Range5-250, % EraseAreaOpacity

    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    ; Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Erase selected area: " appTitle, winPos)
    SetTimer, updateUIerasePanel, -150
}

livePreviewEraseArea() {
      trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
      Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
      calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
      imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
      imgSelW := max(X1, X2) - min(X1, X2)
      imgSelH := max(Y1, Y2) - min(Y1, Y2)
      pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)

      thisOpacity := (EraseAreaFader=1) ? EraseAreaOpacity : 0
      thisBase := (coreDesiredPixFmt="0x21808") ? "0xFF000000" : "0xFF999999"
      Gdip_FromARGB(thisBase, A, R, G, B)
      thisColorA := Gdip_ToARGB(255 - thisOpacity, R, G, B)
      Gdip_FromARGB("0xFF111111", A, R, G, B)
      thisColorB := Gdip_ToARGB(255 - thisOpacity, R, G, B)
      thisBrush := Gdip_BrushCreateHatch(thisColorA, thisColorB, 50)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      dpX := clampInRange(prevDestPosX, 0, mainWidth)
      dpY := clampInRange(prevDestPosY, 0, mainHeight)
      kW := clampInRange(prevResizedVPimgW, 0, mainWidth)
      kH := clampInRange(prevResizedVPimgH, 0, mainHeight)

      If (EraseAreaInvert=1)
      {
         Gdip_SetClipPath(2NDglPG, pPath, 4)
         Gdip_FillRectangle(2NDglPG, thisBrush, dpX, dpY, kW, kH)
         Gdip_ResetClip(2NDglPG)
      } Else Gdip_FillPath(2NDglPG, thisBrush, pPath)

      Gdip_DeletePath(pPath)
      Gdip_DeleteBrush(thisBrush)
      r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
}

PasteInPlaceEraseArea(G2, mode) {
      If (mode=1)
      {
         imgSelPx := x1 := prevSelDotX + SelDotsSize//2, x2 := prevSelDotAx + SelDotsSize//2
         imgSelPy := y1 := prevSelDotY + SelDotsSize//2, y2 := prevSelDotAy + SelDotsSize//2
         imgSelW := max(X1, X2) - min(X1, X2)
         imgSelH := max(Y1, Y2) - min(Y1, Y2)
      } Else
      {
         Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
         calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 1)
      }

      pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, prevEllipseSelectMode, prevVPselRotation, prevrotateSelBoundsKeepRatio)
      If (mode=1)
      {
         If pPath
            Gdip_FillPath(G2, useHatchedBrush(), pPath)
      } Else
      {
         If pPath
            Gdip_SetClipPath(G2, pPath)
         trGdip_GraphicsClear(A_ThisFunc, G2)
         Gdip_ResetClip(G2)
      }
      Gdip_DeletePath(pPath)
}

WriteSettingsBlurPanel() {
    ReadSettingsBlurPanel(1)
}

ReadSettingsBlurPanel(act:=0) {
    INIaction(act, "blurAreaAmount", "General", 2, 0, 255)
    INIaction(act, "blurAreaMode", "General", 2, 1, 3)
    INIaction(act, "blurAreaPixelizeAmount", "General", 2, 0, 1024)
    INIaction(act, "blurAreaPixelizeMethod", "General", 2, 1, 3)
    INIaction(act, "blurAreaOpacity", "General", 2, 3, 255)
    INIaction(act, "blurAreaInverted", "General", 1)
    INIaction(act, "blurAreaSoftEdges", "General", 1)
    INIaction(act, "blurAreaSoftLevel", "General", 2, 1, 7)
    INIaction(act, "BlurAreaBlendMode", "General", 2, 1, 21)
    INIaction(act, "blurAreaTwice", "General", 1)
}

PanelBlurSelectedArea() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(26, A_ThisFunc)
    ReadSettingsBlurPanel()
    btnWid := 75
    txtWid := 280
    EditWid := 60
    thisW := 135
    If (PrefsLargeFonts=1)
    {
       EditWid += 50
       btnWid += 40
       txtWid += 105
       thisW += 40
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    Global infoBlurOpacity, infoBlurAmount, infoPixelize
    If (wasSelect!=1)
    {
       blurAreaSoftEdges := 0
       blurAreaInverted := 0
    }

    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125
    If (isWinXP=1 && blurAreaMode=1)
    {
       blurAreaMode := 2
       blurAreaSoftEdges := 0
    }
    
    If (coreDesiredPixFmt="0x21808")
       blurAreaSoftEdges := 0

    friendly := (isWinXP=1) ? " (unsupported)" : ""
    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic, Preview area
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag, or in the viewport, to change the preview area.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "No blending mode"
    If (coreDesiredPixFmt="0x21808")
       BlurAreaBlendMode := 1

    Gui, +DPIScale
    Gui, Add, Checkbox, x+20 ys Section Checked%blurAreaSoftEdges% vblurAreaSoftEdges gupdateUIblurPanel, &Soft edges%friendly%
    Gui, Add, DropDownList, x+5 w50 AltSubmit Choose%blurAreaSoftLevel% gupdateUIblurPanel vblurAreaSoftLevel, 0.3x|0.6x|1x|2x|3x|4x|5x
    Gui, Add, Checkbox, xs y+10 hp Checked%blurAreaTwice% vblurAreaTwice gupdateUIblurPanel, &Blur twice in one go (for large images)
    Gui, Add, Text, xs y+10 w%thisW% gBTNresetBlurAmount vinfoBlurAmount, Blur amount: %blurAreaAmount%
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%blurAreaMode% gupdateUIblurPanel vblurAreaMode, High quality%friendly%|Alternate blur|Box blur (slow)
    Gui, Add, Slider, xs y+5 gupdateUIblurPanel AltSubmit ToolTip w%txtWid% vblurAreaAmount Range0-255, % blurAreaAmount
    Gui, Add, Text, xs y+10 w%thisW% gBTNresetPixelizationAmount vinfoPixelize, Pixelize level: %blurAreaPixelizeAmount%
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%blurAreaPixelizeMethod% gupdateUIblurPanel vblurAreaPixelizeMethod, Method 1|Method 2|Method 3
    Gui, Add, Slider, xs y+5 gupdateUIblurPanel AltSubmit ToolTip w%txtWid% vblurAreaPixelizeAmount Range0-1024, %blurAreaPixelizeAmount%
    Gui, Add, Text, xs y+10 w%thisW% gBTNresetBlurOpacity vinfoBlurOpacity, Opacity: %thisOpacity%`%
    Gui, Add, DropDownList, x+5 wp gupdateUIblurPanel AltSubmit Choose%BlurAreaBlendMode% vBlurAreaBlendMode, %infoBlend%|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference

    Gui, Add, Slider, xs y+5 gupdateUIblurPanel AltSubmit ToolTip w%txtWid% vblurAreaOpacity Range5-255, % blurAreaOpacity
    If (wasSelect!=1 && EllipseSelectMode=0)
       GuiControl, Disable, blurAreaInverted

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnBlurSelectedArea, &Blur area
    Gui, Add, Checkbox, x+1 +0x1000 hp Checked%blurAreaInverted% vblurAreaInverted gupdateUIblurPanel, &Invert selection
    Gui, Add, Button, x+6 hp w%btnWid% gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Blur/pixelize selected area: " appTitle, winPos)
    SetTimer, updateUIblurPanel, -100
}

BTNresetBlurOpacity() {
   GuiControl, SettingsGUIA:, blurAreaOpacity, 255
   If (AnyWindowOpen=44)
      updateUIaddNoisePanel()
   Else
      updateUIblurPanel()
}

BTNresetPixelizationAmount() {
   GuiControl, SettingsGUIA:, blurAreaPixelizeAmount, 0
   If (AnyWindowOpen=44)
      updateUIaddNoisePanel()
   Else
      updateUIblurPanel()
}

BTNresetBlurAmount() {
   If (AnyWindowOpen=44)
   {
      GuiControl, SettingsGUIA:, blurAreaAmount, 0
      updateUIaddNoisePanel()
   } Else
   {
      GuiControl, SettingsGUIA:, blurAreaAmount, 25
      updateUIblurPanel()
   }
}

WriteSettingsEdgesPanel() {
    ReadSettingsEdgesPanel(1)
}

WriteSettingsAddNoisePanel() {
    ReadSettingsAddNoisePanel(1)
}

ReadSettingsEdgesPanel(act:=0) {
    INIaction(act, "IDedgesOpacity", "General", 2, 3, 255)
    INIaction(act, "IDedgesEmphasis", "General", 2, -255, 255)
    INIaction(act, "IDedgesContrast", "General", 2, -100, 100)
    INIaction(act, "IDedgesBlendMode", "General", 2, 1, 21)
    INIaction(act, "IDedgesCenterAmount", "General", 2, 1, 6)
    INIaction(act, "IDedgesXuAmount", "General", 2, -3, 3)
    INIaction(act, "IDedgesYuAmount", "General", 2, -3, 3)
    INIaction(act, "IDedgesAfterBlur", "General", 2, 1, 5)
    INIaction(act, "IDedgesEmbossLvl", "General", 2, 1, 6)
    INIaction(act, "IDedgesInvert", "General", 1)
}

ReadSettingsAddNoisePanel(act:=0) {
    INIaction(act, "IDedgesOpacity", "General", 2, 3, 255)
    INIaction(act, "IDedgesEmphasis", "General", 2, -255, 255)
    INIaction(act, "IDedgesContrast", "General", 2, -100, 100)
    INIaction(act, "IDedgesInvert", "General", 1)
    INIaction(act, "IDedgesBlendMode", "General", 2, 1, 21)
    INIaction(act, "UserAddNoiseMode", "General", 1)
    INIaction(act, "UserAddNoiseIntensity", "General", 2, 1, 100)
    INIaction(act, "blurAreaAmount", "General", 2, 0, 200)
    INIaction(act, "blurAreaPixelizeAmount", "General", 2, 0, 100)
}

PanelDetectEdgesImage() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(43, A_ThisFunc)
    ReadSettingsEdgesPanel()
    btnWid := 100
    txtWid := 270
    thisW := 100
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    2ndcol := (PrefsLargeFonts=1) ? 155 : 130

    thisOpacity := Round((IDedgesOpacity / 255) * 100)
    Global infoEdgesOpacity, infoBright, infoContrst
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125

    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic, Preview area
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag, or in the viewport, to change the preview area.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    Gui, +DPIScale
    Gui, Add, Text, x+20 ys Section, Direction and iterations:
    Gui, Add, DropDownList, x+6 w45 gupdateUIedgesPanel AltSubmit Choose%IDedgesEmbossLvl% vIDedgesEmbossLvl, 1|2|3|4|5|6
    Gui, Add, Text, xs y+10 w90, X
    Gui, Add, Text, x+3 wp, Y
    Gui, Add, Text, x+3 wp, C
    Gui, Add, DropDownList, xs y+7 wp gupdateUIedgesPanel vIDedgesXuAmount, -3|-2|-1|0|1|2|3|%IDedgesXuAmount%||
    Gui, Add, DropDownList, x+3 wp gupdateUIedgesPanel vIDedgesYuAmount, -3|-2|-1|0|1|2|3|%IDedgesYuAmount%||
    Gui, Add, DropDownList, x+3 wp gupdateUIedgesPanel AltSubmit Choose%IDedgesCenterAmount% vIDedgesCenterAmount, 0|1|2|3|4|5

    Gui, Add, Text, xs y+10 w%2ndcol% gBTNresetEdgesBright vinfoBright, Brightness: %IDedgesEmphasis%
    Gui, Add, Checkbox, x+7 gupdateUIedgesPanel Checked%IDedgesInvert% vIDedgesInvert, &Invert image
    Gui, Add, Slider, xs y+2 ToolTip AltSubmit w%txtWid% gupdateUIedgesPanel vIDedgesEmphasis Range-255-255, % IDedgesEmphasis
    Gui, Add, Text, xs y+7 w%2ndcol% gBTNresetEdgesContrast vinfoContrst, Contrast: %IDedgesContrast%
    Gui, Add, DropDownList, x+7 wp AltSubmit gupdateUIedgesPanel Choose%IDedgesAfterBlur% vIDedgesAfterBlur, After blur|4|6|8|10
    Gui, Add, Slider, xs y+2 ToolTip AltSubmit w%txtWid% gupdateUIedgesPanel vIDedgesContrast Range-100-100, % IDedgesContrast
    Gui, Add, Text, xs y+7 w%2ndcol% gBTNresetEdgesOpacity vinfoEdgesOpacity, Opacity: %thisOpacity%`%
    Gui, Add, DropDownList, x+7 wp gupdateUIedgesPanel AltSubmit Choose%IDedgesBlendMode% vIDedgesBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Slider, xs y+2 ToolTip AltSubmit w%txtWid% gupdateUIedgesPanel vIDedgesOpacity Range5-255, % IDedgesOpacity

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default gBtnIDedgesNow w%btnWid%, &Process image
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Detect edges in selected area: " appTitle, winPos)
    SetTimer, updateUIedgesPanel, -200
}

PanelAddNoiserImage() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(44, A_ThisFunc)
    ReadSettingsAddNoisePanel()
    btnWid := 100
    txtWid := 270
    thisW := 100
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    2ndcol := (PrefsLargeFonts=1) ? 155 : 130
    thisOpacity := Round((IDedgesOpacity / 255) * 100)
    Global infoEdgesOpacity, infoBright, infoContrst, infoNoiseLvl, infoBlurAmount, infoPixelize
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125

    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gPanelsLivePreviewResponder +hwndhCropCornersPic, Preview area
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag, or in the viewport, to change the preview area.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    Gui, +DPIScale
    Gui, Add, Checkbox, x+20 ys Section gupdateUIaddNoisePanel Checked%UserAddNoiseMode% vUserAddNoiseMode, &Grayscale noise
    Gui, Add, Text, x+5 hp gBTNresetNoiseLevel vinfoNoiseLvl -wrap, Noise cut-off: 1000
    Gui, Add, Slider, xs y+5 AltSubmit ToolTip NoTicks w%txtWid% gupdateUIaddNoisePanel vUserAddNoiseIntensity Range1-100, % UserAddNoiseIntensity
    
    Gui, Add, Text, xs y+10 w%2ndcol% gBTNresetEdgesBright vinfoBright, Brightness: %IDedgesEmphasis%
    Gui, Add, Checkbox, x+7 gupdateUIaddNoisePanel Checked%IDedgesInvert% vIDedgesInvert, &Invert noise
    Gui, Add, Slider, xs y+2 AltSubmit ToolTip NoTicks w%txtWid% gupdateUIaddNoisePanel vIDedgesEmphasis Range-255-255, % IDedgesEmphasis
    Gui, Add, Text, xs y+7 w%txtWid% gBTNresetEdgesContrast vinfoContrst, Contrast: %IDedgesContrast%
    Gui, Add, Slider, xs y+2 AltSubmit ToolTip NoTicks w%txtWid% gupdateUIaddNoisePanel vIDedgesContrast Range-100-100, % IDedgesContrast

    Gui, Add, Text, xs y+7 wp gBTNresetPixelizationAmount vinfoPixelize, Pixelize: %blurAreaPixelizeAmount%
    Gui, Add, Slider, xs y+2 AltSubmit gupdateUIaddNoisePanel ToolTip NoTicks w%txtWid% vblurAreaPixelizeAmount Range0-100, %blurAreaPixelizeAmount%
    Gui, Add, Text, xs y+7 w%txtWid% gBTNresetBlurAmount vinfoBlurAmount, Blur: %blurAreaAmount%
    Gui, Add, Slider, xs y+2 AltSubmit gupdateUIaddNoisePanel ToolTip NoTicks w%txtWid% vblurAreaAmount Range0-200, % blurAreaAmount

    Gui, Add, Text, xs y+7 w%2ndcol% gBTNresetEdgesOpacity vinfoEdgesOpacity, Opacity: %thisOpacity%`%
    Gui, Add, DropDownList, x+7 wp gupdateUIaddNoisePanel AltSubmit Choose%IDedgesBlendMode% vIDedgesBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Slider, xs y+2 AltSubmit ToolTip NoTicks w%txtWid% gupdateUIaddNoisePanel vIDedgesOpacity Range5-255, % IDedgesOpacity

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default gBtnAddNoiseNow w%btnWid%, &Add noise
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Add noise in selected area: " appTitle, winPos)
    SetTimer, updateUIaddNoisePanel, -200
}

BTNresetEdgesOpacity() {
    GuiControl, SettingsGUIA:, IDedgesOpacity, 255
    If (AnyWindowOpen=43)
       updateUIedgesPanel()
    Else If (AnyWindowOpen=44)
       updateUIaddNoisePanel()
}

BTNresetNoiseLevel() {
    GuiControl, SettingsGUIA:, UserAddNoiseIntensity, 30
    updateUIaddNoisePanel()
}

BTNresetEdgesBright() {
    GuiControl, SettingsGUIA:, IDedgesEmphasis, 0
    If (AnyWindowOpen=43)
       updateUIedgesPanel()
    Else If (AnyWindowOpen=44)
       updateUIaddNoisePanel()
}

BTNresetEdgesContrast() {
    GuiControl, SettingsGUIA:, IDedgesContrast, 0
    If (AnyWindowOpen=43)
       updateUIedgesPanel()
    Else If (AnyWindowOpen=44)
       updateUIaddNoisePanel()
}

BtnIDedgesNow() {
    updateUIedgesPanel("no")
    CloseWindow()
    detectEdgesSelectedArea()
}

BtnAddNoiseNow() {
    updateUIaddNoisePanel("no")
    CloseWindow()
    addNoiseSelectedArea()
}

updateUIedgesPanel(dummy:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=43)
       Gui, SettingsGUIA: Default
    Else
       Return

    If (A_TickCount - lastInvoked < 70) 
    {
       SetTimer, updateUIedgesPanel, -125
       Return
    }

    GuiControlGet, IDedgesOpacity
    GuiControlGet, IDedgesEmphasis
    GuiControlGet, IDedgesContrast
    GuiControlGet, IDedgesCenterAmount
    GuiControlGet, IDedgesAfterBlur
    GuiControlGet, IDedgesEmbossLvl
    GuiControlGet, IDedgesXuAmount
    GuiControlGet, IDedgesYuAmount
    GuiControlGet, IDedgesInvert
    GuiControlGet, IDedgesBlendMode

    GuiControl, SettingsGUIA:, infoBright, Brightness: %IDedgesEmphasis%
    GuiControl, SettingsGUIA:, infoContrst, Contrast: %IDedgesContrast%`%
    GuiControl, SettingsGUIA:, infoEdgesOpacity, % "Opacity: " Round((IDedgesOpacity / 255) * 100) "%"
    If (dummy!="no")
    {
       SetTimer, WriteSettingsEdgesPanel, -150
       SetTimer, livePreviewIDedges, -50
    }
    lastInvoked := A_TickCount
}

updateUIaddNoisePanel(dummy:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=44)
       Gui, SettingsGUIA: Default
    Else
       Return

    If (A_TickCount - lastInvoked < 70) 
    {
       SetTimer, updateUIaddNoisePanel, -125
       Return
    }

    GuiControlGet, IDedgesOpacity
    GuiControlGet, IDedgesEmphasis
    GuiControlGet, IDedgesContrast
    GuiControlGet, IDedgesInvert
    GuiControlGet, IDedgesBlendMode
    GuiControlGet, blurAreaAmount
    GuiControlGet, blurAreaPixelizeAmount
    GuiControlGet, UserAddNoiseIntensity
    GuiControlGet, UserAddNoiseMode

    GuiControl, SettingsGUIA:, infoBright, Brightness: %IDedgesEmphasis%
    GuiControl, SettingsGUIA:, infoContrst, Contrast: %IDedgesContrast%`%
    GuiControl, SettingsGUIA:, infoEdgesOpacity, % "Opacity: " Round((IDedgesOpacity / 255) * 100) "%"
    GuiControl, SettingsGUIA:, infoNoiseLvl, % "Noise cut-off: " UserAddNoiseIntensity "%"
    GuiControl, SettingsGUIA:, infoBlurAmount, % "Blur: " blurAreaAmount
    GuiControl, SettingsGUIA:, infoPixelize, % "Pixelize: " blurAreaPixelizeAmount
    If (dummy!="no")
    {
       SetTimer, WriteSettingsAddNoisePanel, -150
       SetTimer, livePreviewAddNoiser, -50
    }
}

PanelNewImage() {
    If (thumbsDisplaying=1)
       Return

    thisBtnHeight := createSettingsGUI(27, A_ThisFunc)
    INIaction(0, "NewDocUseColor", "General", 1)
    INIaction(0, "PredefinedDocsSizes", "General", 2, 1, 13)
    INIaction(0, "NewImageReverseDimensions", "General", 1)
    INIaction(0, "FillAreaColor", "General", 3)
    INIaction(0, "FillAreaOpacity", "General", 2, 1, 255)
    If (!UserNewWidth || !UserNewHeight || !UserNewDPI)
       PredefinedDocsSizes := 1
    Else If (UserNewWidth && UserNewHeight &&UserNewDPI)
       PredefinedDocsSizes := 13

    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoResultRes, PickuFillAreaColor
    Gui, Add, Text, x15 y15 Section, Create new RGBA image. Please set image dimensions.
    Gui, Add, DropDownList, y+10 wp gupdateUInewImagePanel AltSubmit Choose%PredefinedDocsSizes% vPredefinedDocsSizes, Viewport size|Screen size|Current image size|640x480|800x600|1024x768|HD 480p|HD 720p|HD 1080p|HD 2160p [4K]|A4 @ 300 dpi|A4 @ 150 dpi|Previously used dimensions
    Gui, Add, Text, xs y+10 w%EditWid%, Width (px)
    Gui, Add, Text, x+1 wp, Height (px)
    Gui, Add, Text, x+1 wp, DPI
    Gui, Add, Edit, xs y+7 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewWidth, % UserNewWidth
    Gui, Add, Edit, x+5 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewHeight, % UserNewHeight
    Gui, Add, Edit, x+5 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewDPI, % UserNewDPI
    Gui, Add, Checkbox, xs y+10 Checked%NewImageReverseDimensions% vNewImageReverseDimensions, Rotate canvas 90° degrees
    Gui, Add, Checkbox, xs y+10 gupdateUInewImagePanel Checked%NewDocUseColor% vNewDocUseColor, Fill background with color
    Gui, Add, ListView, xs y+10 h30 w%editWid% %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P
    Gui, Add, Text, x+5 hp +0x200 vinfoFillAreaOpacity, Opacity: %thisOpacity%00`%
    Gui, Add, Slider, xs y+1 hp w%txtWid% gupdateUInewImagePanel ToolTip AltSubmit vFillAreaOpacity Range3-255, % FillAreaOpacity
    ; Gui, Add, Text, xs y+10, Resulted dimensions:
    ; Gui, Add, Text, xs y+10 w%txtWid% vinfoResultRes, --`n--

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnNewImage, &Create new image
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Button, x+25 hp w%btnWid% gOpenNewQPVinstance, &New instance
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "New image: " appTitle)
    SetTimer, updateUInewImagePanel, -150
}

ReadSettingsPrintPanel(act:=0) {
    INIaction(act, "TextInAreaAlign", "General", 2, 1, 3)
    INIaction(act, "TextInAreaValign", "General", 2, 1, 3)
    INIaction(act, "TextInAreaFontColor", "General", 3)
    INIaction(act, "TextInAreaFontName", "General", 5)
    INIaction(act, "TextInAreaFontBold", "General", 1)
    INIaction(act, "TextInAreaFontItalic", "General", 1)
    INIaction(act, "TextInAreaFontUline", "General", 1)
    INIaction(act, "PrintTxtSize", "General", 2, 24, 999)
    INIaction(act, "PrintDimensionsXYWH", "General", 5)
    INIaction(act, "PrintOrientation", "General", 2, 0, 359)
    INIaction(act, "PrintDoFlipuH", "General", 1)
    INIaction(act, "PrintDoFlipuV", "General", 1)
    INIaction(act, "PrintColorMode", "General", 1)
    INIaction(act, "PrintAdaptToFit", "General", 1)
    INIaction(act, "PrintUseViewportColors", "General", 1)
}

PanelPrintImage() {
    Global PrintPosEditX, PrintPosEditY, PrintPosEditW, PrintPosEditH, PrintPosTxtX, PrintPosTxtY, PrintPosTxtW, PrintPosTxtH
         , PrintCopies, SelectedPrinteru, PrintDoFlipuH, PrintDoFlipuV, PrinterPageInfos, UserTextArea, editF1, PickuTextInAreaFontColor

    If (thumbsDisplaying=1)
       ToggleThumbsMode()

    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

    If StrLen(useGdiBitmap())>2
       viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, useGdiBitmap(), 450, 450, 1, 3, -1)

    thisBtnHeight := createSettingsGUI(37, A_ThisFunc)
    ReadSettingsPrintPanel()
    printDims := StrSplit(PrintDimensionsXYWH, "|")
    PrintPosX := printDims[1]
    PrintPosY := printDims[2]
    PrintPosW := printDims[3]
    PrintPosH := printDims[4]
    
    btnWid := 70
    txtWid := 350
    EditWid := 50
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    printerlist := SGDIPrint_GetDefaultPrinter() "||" SGDIPrint_EnumPrinters("|") 
    Gui, -DPIScale
    Gui, Add, Text, x20 y20 w248 h351 Section +0x1000 +0xE +hwndhCropCornersPic, Print preview
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, -`n-`n-`n-
    Gui, +DPIScale

    Gui, Add, Tab3, x+20 ys Section, General|Text line

    Gui, Tab, 1
    Gui, Add, Text, x+15 y+15 Section, Please choose printer:
    Gui, Add, DropDownList, y+7 wp+90 gupdatePrintPreview vSelectedPrinteru, %printerlist%
    Gui, Add, Button, x+5 hp gBtnSetPrinterDefault, Set as &default
    Gui, Add, Edit, xs y+10 w50 r1 limit3 +number -multi -wantTab -wrap vPrintCopies, 1
    Gui, Add, Text, x+5 hp +0x200, copies to print
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintAdaptToFit% vPrintAdaptToFit, Automatically adapt image to cover page
    Gui, Add, Text, xs y+10 vPrintPosTxtY w%EditWid%, Top
    Gui, Add, Text, x+1 vPrintPosTxtX wp, Left
    Gui, Add, Text, x+1 vPrintPosTxtW wp, Width
    Gui, Add, Text, x+1 vPrintPosTxtH wp, Height
    Gui, Add, Text, x+1 wp, Angle
    Gui, Add, Edit, xs y+7 wp gupdatePrintPreview vPrintPosEditY number -multi limit3, % PrintPosY
    Gui, Add, UpDown, vPrintPosY Range0-98, % PrintPosY
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vPrintPosEditX number -multi limit3, % PrintPosX
    Gui, Add, UpDown, vPrintPosX Range0-98, % PrintPosX
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vPrintPosEditW number -multi limit3, % PrintPosW
    Gui, Add, UpDown, vPrintPosW Range2-100, % PrintPosW
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vPrintPosEditH number -multi limit3, % PrintPosH
    Gui, Add, UpDown, vPrintPosH Range2-100, % PrintPosH
    Gui, Add, Edit, x+2 wp gupdatePrintPreview number -multi limit3, % PrintOrientation
    Gui, Add, UpDown, vPrintOrientation Range0-360, % PrintOrientation
    Gui, Add, Text, xs y+10 hp +0x200, Flip image:
    Gui, Add, Checkbox, x+10 hp gupdatePrintPreview Checked%PrintDoFlipuH% vPrintDoFlipuH, vertically
    Gui, Add, Checkbox, x+10 hp gupdatePrintPreview Checked%PrintDoFlipuV% vPrintDoFlipuV, horizontally
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintColorMode% vPrintColorMode, Print using colors
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintUseViewportColors% vPrintUseViewportColors, Apply viewport color adjustments

    Gui, Tab, 2
    EditWid2 := (PrefsLargeFonts!=1) ? 290 : 450
    Gui, Add, Text, x+15 y+15 Section, Text to insert on the page:
    Gui, Add, Edit, xs y+5 w%EditWid2% r2 gupdatePrintPreview vUserTextArea limit2048, % UserTextArea
    Gui, Add, Text, xs y+15 wp, Font name:
    Gui, Add, DropDownList, xs y+5 wp Sort gupdatePrintPreview Choose1 vTextInAreaFontName, % TextInAreaFontName
    Gui, Add, Text, xs y+15, Text size and color:
    Gui, Add, Edit, xs+0 y+5 w%editWid% gupdatePrintPreview r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF1 , % PrintTxtSize
    Gui, Add, UpDown, vPrintTxtSize gupdatePrintPreview Range25-999, % PrintTxtSize
    Gui, Add, ListView, x+2 w%editWid% hp gupdatePrintPreview %CCLVO% Background%TextInAreaFontColor% vTextInAreaFontColor hwndhLV3,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaFontColor, P
    Gui, Add, Text, xs y+15, Text alignment and style:
    Gui, Add, DropDownList, xs y+5 w%editWid% gupdatePrintPreview Choose%TextInAreaAlign% AltSubmit vTextInAreaAlign, Left|Center|Right
    Gui, Add, DropDownList, x+2 wp gupdatePrintPreview Choose%TextInAreaValign% AltSubmit vTextInAreaValign, Top|Center|Bottom
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontBold% vTextInAreaFontBold, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontItalic% vTextInAreaFontItalic, I
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontUline% vTextInAreaFontUline, U

    Gui, Tab
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnStartPrintingNow, &Print now
    ; Gui, Add, Button, x+5 hp gupdatePrintPreview, &Preview
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, &Cancel

    PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Print image: " appTitle)
    ; SetTimer, updatePrintPreview, -500
}

BtnSetPrinterDefault() {
   Gui, SettingsGUIA: Default
   GuiControlGet, SelectedPrinteru
   If !SGDIPrint_SetDefaultPrinter(SelectedPrinteru)
      msgBoxWrapper(appTitle ": ERROR", "Failed to set " SelectedPrinteru " as default.", 0, 0, "error")
}

printSettingsObj() {
   Gui, SettingsGUIA: Default
   GuiControlGet, PrintAdaptToFit
   GuiControlGet, PrintPosX
   GuiControlGet, PrintPosY
   GuiControlGet, PrintPosW
   GuiControlGet, PrintPosH
   GuiControlGet, PrintColorMode
   GuiControlGet, PrintCopies
   GuiControlGet, SelectedPrinteru
   GuiControlGet, PrintOrientation
   GuiControlGet, PrintDoFlipuH
   GuiControlGet, PrintDoFlipuV
   GuiControlGet, PrintUseViewportColors
   GuiControlGet, TextInAreaAlign
   GuiControlGet, TextInAreaValign
   GuiControlGet, TextInAreaFontName
   GuiControlGet, TextInAreaFontBold
   GuiControlGet, TextInAreaFontItalic
   GuiControlGet, TextInAreaFontUline
   GuiControlGet, PrintTxtSize
   GuiControlGet, UserTextArea

   PrintOptions := []
   PrintOptions.pPrinterName := SelectedPrinteru
   PrintOptions.adaptFit := PrintAdaptToFit
   PrintOptions.userImgX := PrintPosX
   PrintOptions.userImgY := PrintPosY
   PrintOptions.userImgW := PrintPosW
   PrintOptions.userImgH := PrintPosH
   PrintOptions.colorsMode := PrintColorMode
   PrintOptions.imgOrient := PrintOrientation
   PrintOptions.copiez := PrintCopies
   PrintOptions.flipuV := PrintDoFlipuH
   PrintOptions.flipuH := PrintDoFlipuV
   PrintOptions.applyFX := PrintUseViewportColors
   PrintOptions.text := Trimmer(UserTextArea)
   PrintDimensionsXYWH := PrintPosX "|" PrintPosY "|" PrintPosW "|" PrintPosH
   SetTimer, WriteSettingsPrintPanel, -200
   act := (PrintAdaptToFit=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"

   GuiControl, % act, PrintPosX
   GuiControl, % act, PrintPosY
   GuiControl, % act, PrintPosW
   GuiControl, % act, PrintPosH
   GuiControl, % act, PrintPosEditX
   GuiControl, % act, PrintPosEditY
   GuiControl, % act, PrintPosEditW
   GuiControl, % act, PrintPosEditH
   GuiControl, % act, PrintPosTxtX
   GuiControl, % act, PrintPosTxtY
   GuiControl, % act, PrintPosTxtW
   GuiControl, % act, PrintPosTxtH
   Return PrintOptions
}

WriteSettingsPrintPanel() {
    ReadSettingsPrintPanel(2)
}

updatePrintPreview() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<350)
   {
      SetTimer, updatePrintPreview, -500
      Return
   }

   PrintOptions := printSettingsObj()
   printImageNow(viewportStampBMP, PrintOptions, 1)
   lastInvoked := A_TickCount
}

BtnStartPrintingNow() {
   PrintOptions := printSettingsObj()
   BtnCloseWindow()
   Sleep, 2
   showTOOLtip("Please wait, preparing to print image")
   Sleep, 2
   printImageNow(useGdiBitmap(), PrintOptions, 0)
   Sleep, 2
   RemoveTooltip()
}

PanelIMGselProperties() {
    If (thumbsDisplaying=1)
       Return

    If (editingSelectionNow!=1)
       toggleImgSelection()

    thisBtnHeight := createSettingsGUI(34, A_ThisFunc)
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := EditWid//2 - 2
    Global NewPosX1, NewPosY1, NewPosX2, NewPosY2, NewVProt
         , BtnPosX1m, BtnPosX1p, BtnPosY1m, BtnPosY1p, BtnPosX2m, BtnPosX2p, BtnPosY2m, BtnPosY2p
         , BtnPosXm, BtnPosXp, BtnPosYm, BtnPosYp, BtnPosZm, BtnPosZp

    If !userCustomImgSelRatio
       INIaction(0, "userCustomImgSelRatio", "General", 2, 1, 7)

    INIaction(0, "lockSelectionAspectRatio", "General", 2, 1, 7)
    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    Gui, Add, Text, x15 y15 Section, Current image size: %imgW% x %imgH% px.
    Gui, Add, Checkbox, y+7 gupdateUIselPropPanel Checked%userDefinedSelCoords% vuserDefinedSelCoords, Define image selection coordinates in...
    Gui, Add, DropDownList, x+2 w150 AltSubmit gupdateUIchangeSelectionType vSelectionCoordsType, Pixels||Percentages
    Gui, Add, Text, xs y+10 w%EditWid%, X1
    Gui, Add, Text, x+3 wp, Y1
    Gui, Add, Text, x+3 wp, X2
    Gui, Add, Text, x+3 wp, Y2
    Gui, Add, Text, x+3 wp, Rotation
    Gui, Add, Edit, xs y+7 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosX1, % imgSelX1
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosY1, % imgSelY1
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosX2, % imgSelX2
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosY2, % imgSelY2
    Gui, Add, ComboBox, x+3 wp limit9 -multi -wrap gupdateUIselPropPanel vNewVProt, 0|45|90|105|135|150|180|200|225|250|270|300|315|%vPselRotation%||
    Gui, Add, Text, xs y+10, Adjust current selection coordinates:
    Gui, Add, Text, xs y+5 w%EditWid%, X1
    Gui, Add, Text, x+3 wp, Y1
    Gui, Add, Text, x+3 wp, X2
    Gui, Add, Text, x+3 wp, Y2
    Gui, Add, Button, xs y+7 w%btnWid2% gOffsetSelProperPanel vBtnPosX1m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosX1p, +
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY1m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY1p, +
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosX2m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosX2p, +
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY2m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY2p, +
    Gui, Add, Button, xs y+7 wp+8 gOffsetSelProperPanel vBtnPosXm, Up
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosXp, Down
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosYm, Left
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosYp, Right
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosZm, Contract
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosZp, Enlarge
    Gui, Add, Checkbox, xs y+15 gupdateUIselPropPanel Checked%LimitSelectBoundsImg% vLimitSelectBoundsImg, &Limit selection to image boundaries
    Gui, Add, Checkbox, xs y+10 gupdateUIselPropPanel Checked%rotateSelBoundsKeepRatio% vrotateSelBoundsKeepRatio, &Keep aspect ratio on rotation
    Gui, Add, DropDownList, xs y+10 wp gupdateUIselPropPanel AltSubmit Choose%lockSelectionAspectRatio% vlockSelectionAspectRatio, Aspect ratio is not locked|Aspect ratio: 1:1|Aspect ratio: 4:3|Aspect ratio: 3:2|Aspect ratio: 15:9|Aspect ratio: 16:10|Custom aspect ratio
    Gui, Add, Edit, x+5 w65 -wrap gupdateUIselPropPanel vuserCustomImgSelRatio, % userCustomImgSelRatio
    ; ToggleEditImgSelection("show-edit")
    ; dummyTimerDelayiedImageDisplay(50)
    Gui, Add, Button, xs y+20 w100 h%thisBtnHeight% gBTNselectEntireImg, &Select all
    Gui, Add, Button, x+10 w125 hp gBTNselectNoneImg, &Select none
    Gui, Add, Button, x+10 w90 hp gBtnCloseWindow Default, &Close
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Selection properties: " appTitle, winPos)
    SetTimer, updateUIselPropPanel, -350
}

BTNselectNoneImg() {
   BtnCloseWindow()
   editingSelectionNow := 0
   updateUIctrl()
   MouseMoveResponder()
   dummyTimerDelayiedImageDisplay(50)
}

dummyOffsetSelProperPanel() {
    If (determineLClickstate()=1)
    {
       SetTimer, dummyOffsetSelProperPanel, -25
       OffsetSelProperPanel("usePrev")
    }
}

OffsetSelProperPanel(dummy:=0) {
   Static prevVaru, lastInvoked := 1
   stepu := (A_TickCount - lastInvoked<350) ? 4 : 2
   If (dummy!="usePrev")
      GuiControlGet, varu, SettingsGUIA: FocusV
   Else
      varu := prevVaru

   If (varu="BtnPosYm")
   {
      arrowKeysAdjustSelectionArea(-1, 1, stepu)
      arrowKeysAdjustSelectionArea(-1, 2, stepu)
   } Else If (varu="BtnPosYp")
   {
      arrowKeysAdjustSelectionArea(1, 1, stepu)
      arrowKeysAdjustSelectionArea(1, 2, stepu)
   } Else If (varu="BtnPosXm")
   {
      arrowKeysAdjustSelectionArea(-2, 1, stepu)
      arrowKeysAdjustSelectionArea(-2, 2, stepu)
   } Else If (varu="BtnPosXp")
   {
      arrowKeysAdjustSelectionArea(2, 1, stepu)
      arrowKeysAdjustSelectionArea(2, 2, stepu)
   } Else If (varu="BtnPosYp")
   {
      arrowKeysAdjustSelectionArea(1, 1, stepu)
      arrowKeysAdjustSelectionArea(1, 2, stepu)
   } Else If (varu="BtnPosZm")
      changeSelectZoom(-1)
   Else If (varu="BtnPosZp")
      changeSelectZoom(1)
   Else If (varu="BtnPosX1m")
      arrowKeysAdjustSelectionArea(-1, 1, stepu)
   Else If (varu="BtnPosX1p")
      arrowKeysAdjustSelectionArea(1, 1, stepu)
   Else If (varu="BtnPosY1m")
      arrowKeysAdjustSelectionArea(-2, 1, stepu)
   Else If (varu="BtnPosY1p")
      arrowKeysAdjustSelectionArea(2, 1, stepu)
   Else If (varu="BtnPosX2m")
      arrowKeysAdjustSelectionArea(-1, 2, stepu)
   Else If (varu="BtnPosX2p")
      arrowKeysAdjustSelectionArea(1, 2, stepu)
   Else If (varu="BtnPosY2m")
      arrowKeysAdjustSelectionArea(-2, 2, stepu)
   Else If (varu="BtnPosY2p")
      arrowKeysAdjustSelectionArea(2, 2, stepu)
   lastInvoked := A_TickCount
   prevVaru := varu
   SetTimer, dummyOffsetSelProperPanel, -250
}

updateUIchangeSelectionType() {
    If (AnyWindowOpen=34)
       Gui, SettingsGUIA: Default
    Else
       Return

   GuiControlGet, SelectionCoordsType
   GuiControlGet, userDefinedSelCoords
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   GuiControl, SettingsGUIA:, NewPosX1, 0
   GuiControl, SettingsGUIA:, NewPosY1, 0
   If (SelectionCoordsType=1)
   {
      GuiControl, SettingsGUIA:, NewPosX2, % imgW//2
      GuiControl, SettingsGUIA:, NewPosY2, % imgH//2
   } Else
   {
      GuiControl, SettingsGUIA:, NewPosX2, 50
      GuiControl, SettingsGUIA:, NewPosY2, 50
   }
   updateUIselPropPanel()
}

BTNselectEntireImg() {
   BtnCloseWindow()
   selectEntireImage()
}

updateUIselPropPanel() {
   If (AnyWindowOpen=34)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, NewPosX1, SettingsGUIA:, NewPosX1
   GuiControlGet, NewPosY1, SettingsGUIA:, NewPosY1
   GuiControlGet, NewPosX2, SettingsGUIA:, NewPosX2
   GuiControlGet, NewPosY2, SettingsGUIA:, NewPosY2
   GuiControlGet, NewVProt, SettingsGUIA:, NewVProt
   GuiControlGet, lockSelectionAspectRatio, SettingsGUIA:, lockSelectionAspectRatio
   GuiControlGet, userCustomImgSelRatio, SettingsGUIA:, userCustomImgSelRatio
   GuiControlGet, userDefinedSelCoords, SettingsGUIA:, userDefinedSelCoords
   GuiControlGet, SelectionCoordsType, SettingsGUIA:, SelectionCoordsType
   GuiControlGet, LimitSelectBoundsImg, SettingsGUIA:, LimitSelectBoundsImg
   GuiControlGet, rotateSelBoundsKeepRatio, SettingsGUIA:, rotateSelBoundsKeepRatio
   
   userCustomImgSelRatio := Trimmer(userCustomImgSelRatio)
   If RegExMatch(userCustomImgSelRatio, "(.\:.|.\\.)")
   {
      If InStr(userCustomImgSelRatio, ":")
         obju := StrSplit(userCustomImgSelRatio, ":")
      Else If InStr(userCustomImgSelRatio, "\")
         obju := StrSplit(userCustomImgSelRatio, "\")

      If (obju[1] && obju[2])
         userCustomImgSelRatio := Round(obju[1] / obju[2], 3)
   }

   If (lockSelectionAspectRatio>1)
   {
      userDefinedSelCoords := 0
      LimitSelectBoundsImg := 0
      GuiControl, SettingsGUIA:, userDefinedSelCoords, 0
      GuiControl, SettingsGUIA:, LimitSelectBoundsImg, 0
      GuiControl, SettingsGUIA: Disable, userDefinedSelCoords
      GuiControl, SettingsGUIA: Disable, LimitSelectBoundsImg
   } Else
   {
      GuiControl, SettingsGUIA: Enable, userDefinedSelCoords
      GuiControl, SettingsGUIA: Enable, LimitSelectBoundsImg
   }

   defineSelectionAspectRatios()
   If (lockSelectionAspectRatio=7)
      GuiControl, SettingsGUIA: Enable, userCustomImgSelRatio
   Else
      GuiControl, SettingsGUIA: Disable, userCustomImgSelRatio

   ; ToggleEditImgSelection("show-edit")
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   actuA := (userDefinedSelCoords=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   actuB := (userDefinedSelCoords=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   INIaction(1, "userCustomImgSelRatio", "General")
   INIaction(1, "lockSelectionAspectRatio", "General")
   INIaction(1, "LimitSelectBoundsImg", "General")
   ; If (userDefinedSelCoords=1)
   ;    lockSelectionAspectRatio := 0

   If (lockSelectionAspectRatio>1)
   {
      GuiControl, SettingsGUIA: Disable, BtnPosX1m
      GuiControl, SettingsGUIA: Disable, BtnPosX1p
      GuiControl, SettingsGUIA: Disable, BtnPosX2m
      GuiControl, SettingsGUIA: Disable, BtnPosX2p
   } Else
   {
      GuiControl, % actuA, BtnPosX1m
      GuiControl, % actuA, BtnPosX1p
      GuiControl, % actuA, BtnPosX2m
      GuiControl, % actuA, BtnPosX2p
   }
   GuiControl, % actuA, BtnPosY1m
   GuiControl, % actuA, BtnPosY1p
   GuiControl, % actuA, BtnPosY2m
   GuiControl, % actuA, BtnPosY2p
   GuiControl, % actuA, BtnPosXm
   GuiControl, % actuA, BtnPosXp
   GuiControl, % actuA, BtnPosYm
   GuiControl, % actuA, BtnPosYp
   GuiControl, % actuA, BtnPosZm
   GuiControl, % actuA, BtnPosZp
   GuiControl, % actuB, NewPosX1
   GuiControl, % actuB, NewPosY1
   GuiControl, % actuB, NewPosX2
   GuiControl, % actuB, NewPosY2
   GuiControl, % actuB, SelectionCoordsType
   If (userDefinedSelCoords=1)
   {
      If (SelectionCoordsType=1)
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := imgW//2
         If !IsNumber(NewPosY2)
            NewPosY2 := imgH//2
         imgSelX1 := Round(NewPosX1), imgSelY1 := Round(NewPosY1)
         imgSelX2 := Round(NewPosX2), imgSelY2 := Round(NewPosY2)
      } Else
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := 50
         If !IsNumber(NewPosY2)
            NewPosY2 := 50
         wNewPosX1 := min(NewPosX1, NewPosX2)
         wNewPosX2 := max(NewPosX1, NewPosX2)

         wNewPosY1 := min(NewPosY1, NewPosY2)
         wNewPosY2 := max(NewPosY1, NewPosY2)
         imgSelX1 := Round(imgW*(Abs(wNewPosX1)/100), 3), imgSelY1 := Round(imgH*(Abs(wNewPosY1)/100), 3)
         imgSelX2 := Round(imgW*(Abs(wNewPosX2)/100), 3), imgSelY2 := Round(imgH*(Abs(wNewPosY2)/100), 3)
      }
   }

   If !IsNumber(NewVProt)
      NewVProt := 0

   vPselRotation := clampInRange(Round(NewVProt), 0, 360, 1)
   dummyTimerDelayiedImageDisplay(50)
   Return
}

updateUInewImagePanel() {
    If (AnyWindowOpen=27)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, PredefinedDocsSizes
    GuiControlGet, NewDocUseColor
    GuiControlGet, FillAreaOpacity
    GuiControlGet, NewImageReverseDimensions

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoFillAreaOpacity, Opacity: %thisOpacity%`%
    If (NewDocUseColor!=1)
    {
       GuiControl, SettingsGUIA: Disable, infoFillAreaOpacity
       GuiControl, SettingsGUIA: Disable, FillAreaOpacity
       GuiControl, SettingsGUIA: Disable, FillAreaColor
       GuiControl, SettingsGUIA: Disable, PickuFillAreaColor
    } Else
    {
       GuiControl, SettingsGUIA: Enable, infoFillAreaOpacity
       GuiControl, SettingsGUIA: Enable, FillAreaOpacity
       GuiControl, SettingsGUIA: Enable, FillAreaColor
       GuiControl, SettingsGUIA: Enable, PickuFillAreaColor
    }

    If (PredefinedDocsSizes=1)
    {
       GetWinClientSize(UserNewWidth, UserNewHeight, PVhwnd, 0)
       UserNewDPI := A_ScreenDPI
    } Else If (PredefinedDocsSizes=2)
    {
       calcScreenLimits()
       UserNewWidth := ResolutionWidth
       UserNewHeight := ResolutionHeight
       UserNewDPI := A_ScreenDPI
    } Else If (PredefinedDocsSizes=3)
    {
       If useGdiBitmap()
       {
          Gdip_BitmapGetDPIResolution(useGdiBitmap(), dpix, dpiy)
          Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
          UserNewDPI := (dpix + dpiy)//2
       } Else
       {
          GetWinClientSize(imgW, imgH, PVhwnd, 0)
          UserNewDPI := A_ScreenDPI
       }
       UserNewWidth := imgW
       UserNewHeight := imgH
    } Else If (PredefinedDocsSizes=4)
    {
       UserNewWidth := 640
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=5)
    {
       UserNewWidth := 800
       UserNewHeight := 600
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=6)
    {
       UserNewWidth := 1024
       UserNewHeight := 768
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=7)
    {
       UserNewWidth := 858
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=8)
    {
       UserNewWidth := 1280
       UserNewHeight := 720
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=9)
    {
       UserNewWidth := 1920
       UserNewHeight := 1080
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=10)
    {
       UserNewWidth := 3860
       UserNewHeight := 2160
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=11)
    {
       UserNewWidth := 2480
       UserNewHeight := 3508
       UserNewDPI := 300
    } Else If (PredefinedDocsSizes=12)
    {
       UserNewWidth := 1240
       UserNewHeight := 1754
       UserNewDPI := 150
    }

    If (PredefinedDocsSizes<13)
    {
       GuiControl, SettingsGUIA:, UserNewWidth, % UserNewWidth
       GuiControl, SettingsGUIA:, UserNewHeight, % UserNewHeight
       GuiControl, SettingsGUIA:, UserNewDPI, % UserNewDPI
    }
}

NewImageEditResponder() {
    If (AnyWindowOpen=27)
       Gui, SettingsGUIA: Default
    Else
       Return

   GuiControlGet, UserNewWidth
   GuiControlGet, UserNewHeight
   GuiControlGet, UserNewDPI
   GuiControlGet, whichFocused, FocusV

   If (whichFocused="UserNewWidth" || whichFocused="UserNewHeight" || whichFocused="UserNewDPI")
   {
      PredefinedDocsSizes := 13
      GuiControl, SettingsGUIA: Choose, PredefinedDocsSizes, 13
   }
}

BtnNewImage() {
    Static clippyCount
    If (AnyWindowOpen=27)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, UserNewWidth
    GuiControlGet, UserNewHeight
    GuiControlGet, UserNewDPI
    GuiControlGet, NewDocUseColor
    GuiControlGet, FillAreaOpacity
    GuiControlGet, NewImageReverseDimensions

    If (UserNewWidth<5 || UserNewHeight<5 || UserNewDPI<5)
    {
       SoundBeep, 300, 100
       showTOOLtip("WARNING: Incorrect dimensions provided for the new image")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (UserNewWidth*UserNewHeight>maxGDIbmpSize) || (UserNewWidth>32500) || (UserNewHeight>32500)
    {
       SoundBeep, 300, 100
       showTOOLtip("ERROR: The document dimensions exceed the maximum limits")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    INIaction(1, "NewDocUseColor", "General")
    INIaction(1, "PredefinedDocsSizes", "General")
    INIaction(1, "NewImageReverseDimensions", "General")
    INIaction(1, "FillAreaColor", "General")
    INIaction(1, "FillAreaOpacity", "General")

    DestroyGIFuWin()
    CloseWindow()
    PredefinedDocsSizes := 13
    showTOOLtip("Creating the new image, please wait")
    setImageLoading()
    calcScreenLimits()

    mustOpenStartFolder := ""
    terminateIMGediting()
    discardViewPortCaches()
    clippyCount++
    If (NewImageReverseDimensions=1)
    {
       tUserNewWidth := UserNewHeight
       tUserNewHeight := UserNewWidth
    } Else
    {
       tUserNewWidth := UserNewWidth
       tUserNewHeight := UserNewHeight
    }

    UserMemBMP := trGdip_CreateBitmap(A_ThisFunc, tUserNewWidth, tUserNewHeight, "0xE200B")
    If warnUserFatalBitmapError(UserMemBMP, A_ThisFunc)
    {
       showTOOLtip("Failed to create new image")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       clippyCount--
       Return
    }

    Gdip_BitmapSetResolution(UserMemBMP, UserNewDPI, UserNewDPI)
    If (NewDocUseColor=1)
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, UserMemBMP)
       Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
       thisColor := Gdip_ToARGB(FillAreaOpacity, R, G, B)
       trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       Gdip_DeleteGraphics(G2)
    }

    If (!currentFileIndex || !CurrentSLD || !maxFilesIndex)
    {
       maxFilesIndex := currentFileIndex := 0
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\New-" clippyCount ".img"
    }

    currIMGdetails.HasAlpha := 1
    If (NewDocUseColor=1 && FillAreaOpacity>253)
       currIMGdetails.HasAlpha := 0

    imgIndexEditing := currentFileIndex
    usrColorDepth := imgFxMode := 1
    vpIMGrotation := FlipImgH := FlipImgV := 0
    dropFilesSelection(1)
    RemoveTooltip()
    SetTimer, ResetImgLoadStatus, -50
    SetTimer, RefreshImageFile, -50
}

BtnDrawLinesSelectedArea() {
  If throwErrorSelectionOutsideBounds()
     Return

  updateUIDrawLinesPanel("noPreview")
  GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply

  If (DrawLineAreaBorderTop=0 && DrawLineAreaBorderBottom=0 && DrawLineAreaBorderLeft=0 && DrawLineAreaBorderRight=0
  && DrawLineAreaBorderCenter=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=0)
  {
     SoundBeep , 300, 100
     showTOOLtip("WARNING: No lines to draw selected")
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If (closeEditPanelOnApply=1)
     BtnCloseWindow()
  Sleep, 1
  ToggleEditImgSelection("show-edit")
  pPath := DrawLinesInSelectedArea()
  Gdip_DeletePath(pPath)
  SetTimer, RemoveTooltip, -250
}

updateUIDrawLinesPanel(actionu=0) {
    If (AnyWindowOpen=30)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, DrawLineAreaOpacity
    GuiControlGet, DrawLineAreaKeepBounds
    GuiControlGet, DrawLineAreaDashStyle
    GuiControlGet, DrawLineAreaCapsStyle
    GuiControlGet, DrawLineAreaContourAlign
    GuiControlGet, DrawLineAreaDoubles
    GuiControlGet, DrawLineAreaBorderTop
    GuiControlGet, DrawLineAreaBorderBottom
    GuiControlGet, DrawLineAreaBorderLeft
    GuiControlGet, DrawLineAreaBorderRight
    GuiControlGet, DrawLineAreaBorderCenter
    GuiControlGet, DrawLineAreaBorderArcA
    GuiControlGet, DrawLineAreaBorderArcB
    GuiControlGet, DrawLineAreaBorderArcC
    GuiControlGet, DrawLineAreaBorderArcD
    GuiControlGet, DrawLineAreaContourThickness

    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoDrawLineAreaOpacity, Opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoDrawLineAreaContour, Contour thickness: %DrawLineAreaContourThickness% pixels
    ToggleEditImgSelection("show-edit")
    If (DrawLineAreaBorderTop=0 && DrawLineAreaBorderBottom=0 && DrawLineAreaBorderLeft=0 && DrawLineAreaBorderRight=0
    && DrawLineAreaBorderCenter=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=0)
       dummyRefreshImgSelectionWindow()
    Else If (actionu!="noPreview")
       livePreviewsImageEditing(1)
    Else
       SetTimer, WriteSettingsDrawLinesPanel, -250
}

WriteSettingsDrawLinesPanel() {
    ReadSettingsDrawLinesArea(1)
}

updateUIblurPanel() {
    Static lastInvoked := 1
    If (AnyWindowOpen=26)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, blurAreaAmount
    GuiControlGet, blurAreaPixelizeAmount
    GuiControlGet, blurAreaPixelizeMethod
    GuiControlGet, blurAreaInverted
    GuiControlGet, BlurAreaBlendMode
    GuiControlGet, blurAreaSoftEdges
    GuiControlGet, blurAreaOpacity
    GuiControlGet, blurAreaTwice
    GuiControlGet, blurAreaMode
    GuiControlGet, blurAreaSoftLevel
    If (coreDesiredPixFmt="0x21808")
    {
       blurAreaSoftEdges := 0
       BlurAreaBlendMode := 0
       GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Disable, BlurAreaBlendMode
       GuiControl, SettingsGUIA: Choose, BlurAreaBlendMode, 1
       GuiControl, SettingsGUIA:, blurAreaSoftEdges, 0
    }

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIblurPanel, -105
       Return
    }

    If (blurAreaPixelizeAmount>1)
       GuiControl, SettingsGUIA: Enable, blurAreaPixelizeMethod
    Else
       GuiControl, SettingsGUIA: Disable, blurAreaPixelizeMethod

    If (blurAreaAmount>1)
    {
       GuiControl, SettingsGUIA: Enable, blurAreaMode
       GuiControl, SettingsGUIA: Enable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Enable, blurAreaSoftLevel
       GuiControl, SettingsGUIA: Enable, blurAreaTwice
    } Else
    {
       GuiControl, SettingsGUIA: Disable, blurAreaMode
       GuiControl, SettingsGUIA: Disable, blurAreaTwice
       GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Disable, blurAreaSoftLevel
    }

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoBlurOpacity, Opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoBlurAmount, Blur amount: %blurAreaAmount%
    GuiControl, SettingsGUIA:, infoPixelize, Pixelize level: %blurAreaPixelizeAmount%
    lastInvoked := A_TickCount
    SetTimer, livePreviewBlurPanel, -50
}

PanelsLivePreviewResponder(a, b) {
   SetTimer, PanelsPanIMGpreviewClick, -15
}

PanelsPanIMGpreviewClick() {
   Static noPreview := 0
   keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Sleep, 0
   GetPhysicalCursorPos(oX, oY)
   newPosZeit := A_TickCount
   oDx := tinyPrevAreaCoordX, oDy := tinyPrevAreaCoordY
   zX := oX, zY := oY
   thisZeit := A_TickCount
   hasRun := 0
   While, (determineLClickstate()=1)
   {
      Sleep, 1
      If !keysState
         keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

      GetPhysicalCursorPos(mX, mY)
      skipLoop := (isInRange(mX, zX - 2, zX + 2) && isInRange(mY, zY - 2, zY + 2)) ? 1 : 0
      Dx := mX - oX + 1
      Dy := mY - oY + 1
      tinyPrevAreaCoordX := oDx - Dx
      tinyPrevAreaCoordY := oDy - Dy
      tinyPrevAreaCoordX := clampInRange(tinyPrevAreaCoordX, 120, imgW)
      tinyPrevAreaCoordY := clampInRange(tinyPrevAreaCoordY, 120, imgH)

      ; ToolTip, % diffIMGdecX "--" diffIMGdecY " || " IMGdecalageX "--" IMGdecalageY " || " odX "--" odY , , , 2
      If (A_TickCount - newPosZeit>750) || (mX=oX && mY=oY)
      {
         newPosZeit := A_TickCount
         zX := mX, zY := mY
         If (skipLoop=1)
            Continue
      } Else If (skipLoop=1)
         Continue

      If (A_TickCount - thisZeit>15)
      {
         hasRun := 1
         noPreview := 0
         ; If (A_TickCount - thisZeit>95)
         ; zeitSillyPrevent := A_TickCount
         If (AnyWindowOpen=26)
            livePreviewBlurPanel()
         Else If (AnyWindowOpen=43)
            livePreviewIDedges()
         Else If (AnyWindowOpen=44)
            livePreviewAddNoiser()
         thisZeit := A_TickCount
      }
   }

   If !keysState
      keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

   If (keysState=1 && hasRun=0 && noPreview=0)
   {
      noPreview := 1
      livePreviewsPanelNoEffects()
   } Else If !hasRun
   {
      If (noPreview=0)
         doubleBlurPreviewArea := !doubleBlurPreviewArea

      noPreview := 0
      If (AnyWindowOpen=26)
         updateUIblurPanel()
      Else If (AnyWindowOpen=43)
         updateUIedgesPanel()
      Else If (AnyWindowOpen=44)
         updateUIaddNoisePanel()
   }
}

livePreviewBlurPanel() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    WriteSettingsBlurPanel()
    whichBmp := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, "0xE200B")
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }


    Gdip_GetImageDimensions(whichBmp, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    thisBlurMode := blurAreaMode
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    thisOpacity := blurAreaOpacity/255
    thisBlurAmount := (doubleBlurPreviewArea=1) ? blurAreaAmount//2 : blurAreaAmount
    If (thisBlurMode=1)
       bEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
    Else If (thisBlurMode=2)
       bEffect := Gdip_CreateEffect(1, Round(thisBlurAmount*0.85), 0, 0)

    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    If (BlurAreaBlendMode>1)
       bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, cornersBMP)

    If pEffect
       Gdip_BitmapApplyEffect(cornersBMP, pEffect)

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    r1 := trGdip_DrawImage(A_ThisFunc, G, zBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize, uiboxSize, 1, 2, imageAttribs)
    yBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)

    If (blurAreaPixelizeAmount>1)
    {
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, "0xE200B")
       QPV_PixelateBitmap(yBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, uiboxSize))
       prevBMPu := yBitmap
       yBitmap:= pixiBMP
    }

    If (blurAreaTwice=1)
    {
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, uiboxSize//2, uiboxSize//2, 1, 3, -1)
       If xBitmap
       {
          prevBMPa := yBitmap
          yBitmap := xBitmap
       }

       If (bEffect && (thisBlurMode=1 || thisBlurMode=2))
          ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
       Else If (thisBlurMode=3)
          QPV_BoxBlurBitmap(yBitmap, Round(thisBlurAmount/2))

       cBitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, uiboxSize, uiboxSize, 1, 3, -1)
       If cBitmap
       {
          prevBMPc := yBitmap
          yBitmap := cBitmap
          sF := 1
       } Else sF := 1
    } Else sF := 1

    If (bEffect && (thisBlurMode=1 || thisBlurMode=2))
       ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
    Else If (thisBlurMode=3)
       QPV_BoxBlurBitmap(yBitmap, Round(thisBlurAmount/2))

    If (BlurAreaBlendMode>1)
    {
       rz := QPV_BlendBitmaps(bgrBMPu, yBitmap, BlurAreaBlendMode - 1, 0)
       ; ToolTip, % "l=" rz , , , 2
       ou := yBitmap
       yBitmap := bgrBMPu
       bgrBMPu := ou
    }

    ; thisBMP := (BlurAreaBlendMode>1) ? bgrBMPu : cornersBMP
    r1 := trGdip_DrawImage(A_ThisFunc, G, yBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize // sF, uiboxSize // sF, thisOpacity)
    If (r1!="fail")
       hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)

    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    Gdip_DeleteGraphics(G)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(yBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    trGdip_DisposeImage(prevBMPu, 1)
    trGdip_DisposeImage(prevBMPa, 1)
    trGdip_DisposeImage(prevBMPc, 1)
    trGdip_DisposeImage(cornersBMP, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(bEffect)
}

updateUIerasePanel(actionu:=0) {
    If (AnyWindowOpen=25)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, EraseAreaFader
    GuiControlGet, EraseAreaInvert
    GuiControlGet, EraseAreaOpacity

    INIaction(1, "EraseAreaOpacity", "General")
    INIaction(1, "EraseAreaFader", "General")
    INIaction(1, "EraseAreaInvert", "General")
    thisOpacity := Round((EraseAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoEraseOpacity, Opacity: %thisOpacity%`%
    If (EraseAreaFader=1)
    {
       GuiControl, SettingsGUIA: Enable, infoEraseOpacity
       GuiControl, SettingsGUIA: Enable, EraseAreaOpacity
    } Else
    {
       GuiControl, SettingsGUIA: Disable, infoEraseOpacity
       GuiControl, SettingsGUIA: Disable, EraseAreaOpacity
    }

    If (actionu!="noPreview")
       livePreviewsImageEditing(1)
}

BtnResetAmountDesature() {
   GuiControl, SettingsGUIA:, DesatureAreaAmount, 100
   updateUIdesaturatePanel()
}

BtnResetDesatureHue() {
   GuiControl, SettingsGUIA:, DesatureAreaHue, 0
   updateUIdesaturatePanel()
}

updateUIdesaturatePanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=55)
       Gui, SettingsGUIA: Default
    Else
       Return

    If (A_TickCount - lastInvoked<90)
    {
       SetTimer, updateUIdesaturatePanel, -100
       Return
    }

    GuiControlGet, DesatureAreaAmount
    GuiControlGet, DesatureAreaAlternate
    GuiControlGet, DesatureAreaHue

    INIaction(1, "DesatureAreaAmount", "General")
    INIaction(1, "DesatureAreaAlternate", "General")
    INIaction(1, "DesatureAreaHue", "General")
    thisOpacity := DesatureAreaAmount
    GuiControl, SettingsGUIA:, infoAmount, Intensity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infohueAdjust, Relight: %DesatureAreaHue%°
    If (DesatureAreaAlternate!=1 && !isWinXP && DesatureAreaAmount>87)
    {
       GuiControl, SettingsGUIA: Enable, infohueAdjust
       GuiControl, SettingsGUIA: Enable, DesatureAreaHue
    } Else
    {
       GuiControl, SettingsGUIA: Disable, infohueAdjust
       GuiControl, SettingsGUIA: Disable, DesatureAreaHue
    }

    If (actionu!="noPreview")
       livePreviewsImageEditing(1)
    lastInvoked := A_TickCount
}

BtnEraseSelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   updateUIerasePanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()

   ToggleEditImgSelection("show-edit")
   EraseSelectedArea()
}

coreDesatureAreaFX(ByRef matrix, ByRef pEffect) {
    matrix := GenerateColorMatrix(1, 1, 0, 1 - (DesatureAreaAmount/100))
    thisAmount2 := (DesatureAreaAlternate=1) ? DesatureAreaAmount : 0
    If (DesatureAreaAlternate=1)
       thisHAmount := 0
    Else If (DesatureAreaHue>0)
    {
       thisHAmount := DesatureAreaHue - (100 - DesatureAreaAmount)*16
       thisHAmount := clampInRange(thisHAmount, 0, 180)
    } Else
    {
       thisHAmount := (100 - DesatureAreaAmount)*16 + DesatureAreaHue
       thisHAmount := clampInRange(thisHAmount, -180, 0)
    }

    If (!isWinXP && (thisHAmount!=0 || thisAmount2!=0))
       pEffect := Gdip_CreateEffect(6, thisHAmount, thisAmount2, 0)
}

livePreviewDesaturateArea(modus:=0) {
   Static prevState, prevBMP

   If (modus="kill")
   {
      trGdip_DisposeImage(prevBMP, 1)
      prevBMP := prevState := ""
      Return
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
   calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
   imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
   imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
   imgSelW := max(X1, X2) - min(X1, X2)
   imgSelH := max(Y1, Y2) - min(Y1, Y2)

   trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   coreDesatureAreaFX(matrix, pEffect)
   pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio)
   Gdip_SetClipPath(2NDglPG, pPath, 0)
   pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
   imgSelPx := pB.x, imgSelPy := pB.y
   imgSelW := pB.w
   imgSelH := pB.h

   thisState := "a" imgSelPx imgSelPy imgSelW imgSelH mainWidth mainHeight zoomLevel prevDestPosX prevDestPosY IMGresizingMode imageAligned ForceNoColorMatrix imgFxMode bwDithering lumosGrayAdjust GammosGrayAdjust lumosAdjust GammosAdjust satAdjust IntensityAlphaChannel useGdiBitmap()
   If (prevState!=thisState)
   {
      trGdip_DisposeImage(prevBMP, 1)
      pBitmap := getTransformToolSelectedArea(1, 0, 0)
      zBitmap := Gdip_ResizeBitmap(pBitmap, imgSelW, imgSelH, 0, 5)
      trGdip_DisposeImage(pBitmap, 1)
      prevBMP := zBitmap
      prevState := thisState
   } Else zBitmap := prevBMP


   If pEffect
      r1 := trGdip_DrawImageFX(funcu, 2NDglPG, zBitmap, imgSelPx, imgSelPy,,,,, matrix, pEffect)
   Else
      r1 := trGdip_DrawImage(funcu, 2NDglPG, zBitmap, imgSelPx, imgSelPy,,,,,,, matrix)

   r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
   Gdip_ResetClip(2NDglPG)
   ; trGdip_DisposeImage(zBitmap, 1)
}

BtnGraySelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   updateUIdesaturatePanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()

   ToggleEditImgSelection("show-edit")
   GraySelectedArea()
}

BtnBlurSelectedArea() {
  updateUIblurPanel()
  BtnCloseWindow()
  ToggleEditImgSelection("show-edit")
  BlurSelectedArea()
}

updateUIfillPanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=23)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, FillAreaClosedPath
    GuiControlGet, FillAreaBlendMode
    GuiControlGet, FillAreaCurveTension
    GuiControlGet, FillAreaOpacity
    GuiControlGet, FillAreaShape
    GuiControlGet, FillAreaInverted
    GuiControlGet, FillAreaRemBGR
    GuiControlGet, FillAreaDoContour
    GuiControlGet, FillAreaDashStyle
    GuiControlGet, FillAreaRoundedCaps
    GuiControlGet, FillAreaDoubleLine
    GuiControlGet, FillAreaContourAlign
    GuiControlGet, FillAreaContourThickness
    GuiControlGet, FillAreaColorMode
    GuiControlGet, FillAreaColorReversed
    GuiControlGet, FillArea2ndOpacity
    GuiControlGet, FillAreaGradientAngle
    GuiControlGet, FillAreaGradientSigma
    GuiControlGet, FillAreaGradientBlend
    GuiControlGet, FillAreaGradientScale
    GuiControlGet, FillAreaGradientWrapped
    GuiControlGet, FillAreaGlassy
    GuiControlGet, FillAreaLivePreview

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIfillPanel, -150
       Return
    }

    decideCustomShapeStyle()
    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    this2ndOpacity := Round((FillArea2ndOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoFillAreaOpacity, %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoFillArea2ndOpacity, %this2ndOpacity%`%
    GuiControl, SettingsGUIA:, infoFillAreaContour, Contour thickness: %FillAreaContourThickness% pixels
    If (FillAreaColorMode=5)
    {
       iterations := Round(100*(FillAreaGradientScale/300)) + 1
       modelu := Round(7*(FillAreaGradientBlend/100))
       moduz := Round(9*(FillAreaGradientSigma/100))
       sweepRand := Round(9*(FillAreaGradientAngle/360))
       GuiControl, SettingsGUIA:, infoFillAreaSigma, Style deviation: %moduz%
       GuiControl, SettingsGUIA:, infoFillAreaBlend, Pattern style: %modelu%
       GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Petals sweep: %sweepRand%
       GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Iterations: %iterations%
       GuiControl, SettingsGUIA:, FillAreaGradientWrapped, Grayscale
    } Else
    {
       GuiControl, SettingsGUIA:, FillAreaGradientWrapped, Tiling pattern
       GuiControl, SettingsGUIA:, infoFillAreaSigma, Pos. A: %FillAreaGradientSigma%`%
       GuiControl, SettingsGUIA:, infoFillAreaBlend, Pos. B: %FillAreaGradientBlend%`%
       GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%°
       GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
    }

    If (FillAreaDoContour=1)
       GuiControl, SettingsGUIA: Disable, FillAreaBlendMode

    If (FillAreaRemBGR=1 || FillAreaDoContour=1)
    {
       GuiControl, SettingsGUIA: Disable, FillAreaGlassy
       GuiControl, SettingsGUIA: Disable, FillAreaLivePreview
       GuiControl, SettingsGUIA: Disable, FillAreaBlendMode
    } Else
    {
       If (FillAreaDoContour!=1)
       {
          GuiControl, SettingsGUIA: Enable, FillAreaGlassy
          GuiControl, SettingsGUIA: Enable, FillAreaBlendMode
       }

       If (FillAreaGlassy>1)
          GuiControl, SettingsGUIA: Enable, FillAreaLivePreview
       Else
          GuiControl, SettingsGUIA: Disable, FillAreaLivePreview
    }

    actu := (FillAreaColorMode=1 || FillAreaDoContour=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
    GuiControl, % actu, FillArea2ndColor
    GuiControl, % actu, infoFillArea2ndOpacity
    GuiControl, % actu, infoFillAreaSigma
    GuiControl, % actu, infoFillAreaBlend
    GuiControl, % actu, infoFillAreaGradientAngle
    GuiControl, % actu, infoFillAreaGradientScale
    GuiControl, % actu, FillAreaGradientAngle
    GuiControl, % actu, FillAreaGradientSigma
    GuiControl, % actu, FillAreaGradientBlend
    GuiControl, % actu, FillAreaGradientScale
    GuiControl, % actu, FillAreaGradientWrapped
    GuiControl, % actu, FillAreaColorReversed
    GuiControl, % actu, FillArea2ndOpacity

    If (FillAreaShape=7)
       GuiControl, SettingsGUIA: Enable, FillAreaCurveTension
    Else
       GuiControl, SettingsGUIA: Disable, FillAreaCurveTension

    actu2 := (FillAreaDoContour=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    If (FillAreaDoContour=1)
    {
       GuiControl, SettingsGUIA: Disable, FillAreaRemBGR
       GuiControl, SettingsGUIA: Disable, FillAreaColorMode
       GuiControl, SettingsGUIA: Disable, FillAreaInverted
       If (FillAreaShape>=7)
          GuiControl, SettingsGUIA: Enable, FillAreaClosedPath
       Else
          GuiControl, SettingsGUIA: Disable, FillAreaClosedPath
    } Else
    {
       GuiControl, SettingsGUIA: Enable, FillAreaRemBGR
       GuiControl, SettingsGUIA: Enable, FillAreaColorMode
       GuiControl, SettingsGUIA: Enable, FillAreaInverted
       GuiControl, SettingsGUIA: Disable, FillAreaClosedPath
    }

    GuiControl, % actu2, FillAreaContourAlign
    GuiControl, % actu2, FillAreaContourThickness
    GuiControl, % actu2, FillAreaRoundedCaps
    GuiControl, % actu2, FillAreaDoubleLine
    GuiControl, % actu2, infoFillAreaContour
    GuiControl, % actu2, FillAreaDashStyle
    If (FillAreaDoContour=1 && FillAreaDashStyle>1)
       GuiControl, SettingsGUIA: Enable, FillAreaRoundedCaps
    Else
       GuiControl, SettingsGUIA: Disable, FillAreaRoundedCaps

    If (coreDesiredPixFmt="0x21808")
       GuiControl, SettingsGUIA: Disable, FillAreaBlendMode

    ; ToggleEditImgSelection("show-edit")
    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing(1)

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsFillAreaPanel, -350
}

WriteSettingsFillAreaPanel() {
    ReadSettingsFillAreaPanel(1)
}

BtnFillSelectedArea() {
    If throwErrorSelectionOutsideBounds()
       Return

    Gui, SettingsGUIA: Default
    updateUIfillPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply

    Sleep, 1
    If (closeEditPanelOnApply=1)
       CloseWindow("yes", 0)
    ; Sleep, 1
    ToggleEditImgSelection("show-edit")
    FillSelectedArea()
    SetTimer, RemoveTooltip, -250
}


BtnInsertTextSelectedArea() {
    If throwErrorSelectionOutsideBounds()
       Return

    Gui, SettingsGUIA: Default
    updateUIInsertTextPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    Sleep, 1
    If (closeEditPanelOnApply=1)
       BtnCloseWindow()
    ; Sleep, 1
    ToggleEditImgSelection("show-edit")
    InsertTextSelectedArea()
    SetTimer, RemoveTooltip, -250
}

BtnViewedImages2List() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (userSeenSlideImages<3)
      Return

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   BtnCloseWindow()
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := mainCompiledPath "\viewed-images-history-current-session.SLD"
   For Key, Value in userSeenSessionImagesArray
       resultedFilesList[A_Index] := [Key]

   SLDtypeLoaded := 2
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   RandomPicture()
}

BtnALLviewedImages2List(dummy:=0) {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   BtnCloseWindow()
   startOperation := A_TickCount
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   showTOOLtip("Gathering seen images list, please wait")
   setImageLoading()
   friendly := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : "ALL"
   dummy := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : ""
   seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 1, dummy)
   If (totalSeenIMGs<3)
   {
      seenEntries := ""
      SetTimer, ResetImgLoadStatus, -50
      CurrentSLD := backCurrentSLD
      If (SLDtypeLoaded=3)
         activeSQLdb.Exec("COMMIT TRANSACTION;")
      showTOOLtip("Found no already seen images in the database")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   PopulateIndexFilesStatsInfos("kill")
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := mainCompiledPath "\viewed-images-history-" friendly ".SLD"
   For Key, Value in seenEntries
       resultedFilesList[A_Index] := [Key,,1]

   seenEntries := ""
   SLDtypeLoaded := 2
   currentFilesListModified := 0
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   etaTime := "Elapsed time to retrieve seen images list from the database:`n" SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   RandomPicture()
}

PanelJournalWindow(tabu:=1) {
    If (AnyWindowOpen=1)
       CloseWindow()

    thisBtnHeight := createSettingsGUI(33, A_ThisFunc)
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 40
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid := Round(editWid*6.25)
    totalIndex := QPVjournal.Count()
    For Key, Value in QPVjournal
    {
        currentEntry := totalIndex - A_Index
        line := Trimmer(Value)
        If line
           textList .= "(" currentEntry ") " Trimmer(line) "`n`n"
    }

    userSeenSlideImages := userSeenSessionImagesArray.Count()
    WinGetTitle, thisTitle, ahk_id %PVhwnd%
    If (mustRecordSeenImgs=1)
    {
       choosu := (tabu=2) ? "||" : ""
       Gui, Add, Tab3,, Journal|Seen images database options%choosu%
       Gui, Tab, 1
       Gui, Add, Button, x+15 y+15 w1 h1 gBtnCloseWindow Default, Clo&se
    } Else
       Gui, Add, Button, x15 y15 w1 h1 gBtnCloseWindow Default, Clo&se

    Gui, Add, Edit, x+1 y+1 Section ReadOnly w%txtWid% r15, % "WinTitle: " thisTitle "`n`n" textList
       ; Gui, Add, Button, xs y+2 h%thisBtnHeight% gPanelSeenIMGsOptions, &Seen images database options

    If (mustRecordSeenImgs=1)
    {
       Gui, Tab, 2
       Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.

       Gui, Add, Button, xs y+15 h%thisBtnHeight% gBtnALLviewedImages2List, &Retrieve list of all recorded seen images
       Gui, Add, Button, y+5 hp wp gCleanDeadFilesSeenImagesDB, &Purge records of inexistent files
       Gui, Add, Button, y+5 hp wp geraseSeenIMGsDB, &Erase the entire list
       Gui, Add, Button, y+5 hp wp gPanelSeenStats, &Seen images statistics
       Gui, Add, Text, y+5 wp, TIP: To retrieve the images seen on a given day or month, open the statistics panel.
    } Else
    {
       Gui, Add, Button, xp y+2 h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.
    }

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Application journal: " appTitle)
    SetTimer, ResetImgLoadStatus, -100
}

PanelSeenIMGsOptions() {
    PanelJournalWindow(2)
    Return
}

ReadSettingsTextInArea(act:=0) {
    INIaction(act, "TextInAreaAlign", "General", 2, 1, 3)
    INIaction(act, "TextInAreaLineAngle", "General", 2, -900, 900)
    INIaction(act, "TextInAreaCharSpacing", "General", 2, -100, 255)
    INIaction(act, "TextInAreaValign", "General", 2, 1, 3)
    INIaction(act, "TextInAreaBlurAmount", "General", 2, 1, 255)
    INIaction(act, "TextInAreaBlurBorderAmount", "General", 2, 1, 255)
    INIaction(act, "TextInAreaUsrMarginz", "General", 2, 0, 500)
    INIaction(act, "TextInAreaBgrColor", "General", 3)
    INIaction(act, "TextInAreaBgrEntire", "General", 1)
    INIaction(act, "TextInAreaBgrUnified", "General", 1)
    INIaction(act, "TextInAreaCutOutMode", "General", 1)
    INIaction(act, "TextInAreaBgrOpacity", "General", 2, 3, 255)
    INIaction(act, "TextInAreaBorderSize", "General", 2, 1, 650)
    INIaction(act, "TextInAreaBorderOut", "General", 2, 1, 3)
    INIaction(act, "TextInAreaBorderColor", "General", 3)
    INIaction(act, "TextInAreaBorderOpacity", "General", 2, 3, 255)
    INIaction(act, "TextInAreaFontBold", "General", 1)
    INIaction(act, "TextInAreaFontColor", "General", 3)
    INIaction(act, "TextInAreaFontItalic", "General", 1)
    INIaction(act, "TextInAreaFontName", "General", 5)
    INIaction(act, "TextInAreaFontLineSpacing", "General", 2, -950, 950)
    INIaction(act, "TextInAreaFontOpacity", "General", 2, 3, 255)
    INIaction(act, "TextInAreaFontSize", "General", 2, 5, 950)
    INIaction(act, "TextInAreaFontStrike", "General", 1)
    INIaction(act, "TextInAreaFontUline", "General", 1)
    INIaction(act, "TextInAreaOnlyBorder", "General", 1)
    INIaction(act, "TextInAreaPaintBgr", "General", 1)
    INIaction(act, "TextInAreaRoundBoxBgr", "General", 1)
    INIaction(act, "TextInAreaAutoWrap", "General", 1)
    INIaction(act, "TextInAreaLivePreview", "General", 1)
}

PanelInsertTextArea() {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(32, A_ThisFunc)
    ReadSettingsTextInArea()
    btnWid := 100
    txtWid := 350
    columnBpos := 190
    slideWid := 150
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos := columnBpos + 85
       slideWid := slideWid + 55
       EditWid := EditWid + 40
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    ddWid := Round(editWid*3.25)
    txtWid := Round(editWid*6.25)
    EllipseSelectMode := 0

    Global editF1, editF2, editF3, editF4, editF5, editF6,  editF7, editF8, editF9, editF10, editF11
         , editF12, PickuTextInAreaFontColor, PickuTextInAreaBgrColor, PickuTextInAreaBorderColor

    Gui, Add, Tab3,, Text|Styling|Colors
    Gui, Tab, 1
    Gui, Add, Edit, x+15 y+15 Section w%txtWid% r10 gupdateUIInsertTextPanel vUserTextArea, % UserTextArea
    Gui, Add, Text, , Font name:
    Gui, Add, DropDownList, x+5 w%ddWid% Sort Choose1 gupdateUIInsertTextPanel vTextInAreaFontName, % TextInAreaFontName
    Gui, Add, Checkbox, x+5 gupdateUIInsertTextPanel Checked%TextInAreaAutoWrap% vTextInAreaAutoWrap, Auto line wrapping

    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 Section, Line angle / letter spacing
    Gui, Add, Text, xs yp+30, Font size / leading / margins
    Gui, Add, Text, xs yp+30, Text alignment and style 
    Gui, Add, Text, xs yp+30, Border style / thickness
    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaDoBlurs% vTextInAreaDoBlurs, Blur amount for text / outline
    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaPaintBgr% vTextInAreaPaintBgr, Draw background

    Gui, Add, Edit, xs+%columnBpos% ys+0 Section w%editWid% r1 gupdateUIInsertTextPanel limit4 -multi -wantCtrlA -wantTab -wrap veditF11, % TextInAreaLineAngle
    Gui, Add, UpDown, vTextInAreaLineAngle Range-900-900, % TextInAreaLineAngle
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIInsertTextPanel limit4 -multi -wantCtrlA -wantTab -wrap veditF12, % TextInAreaCharSpacing
    Gui, Add, UpDown, vTextInAreaCharSpacing Range-100-255, % TextInAreaCharSpacing

    Gui, Add, Edit, xs+0 yp+30 w%editWid% r1 gupdateUIInsertTextPanel limit3 -multi number -wantCtrlA -wantTab -wrap veditF1 , % TextInAreaFontSize
    Gui, Add, UpDown, vTextInAreaFontSize Range5-950, % TextInAreaFontSize
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit4 -multi -wantCtrlA -wantTab -wrap veditF9, % TextInAreaFontLineSpacing
    Gui, Add, UpDown, vTextInAreaFontLineSpacing Range-950-950, % TextInAreaFontLineSpacing
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF10, % TextInAreaUsrMarginz
    Gui, Add, UpDown, vTextInAreaUsrMarginz Range0-500, % TextInAreaUsrMarginz

    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIInsertTextPanel Choose%TextInAreaAlign% AltSubmit vTextInAreaAlign, Left|Center|Right
    Gui, Add, DropDownList, x+2 wp gupdateUIInsertTextPanel Choose%TextInAreaValign% AltSubmit vTextInAreaValign, Top|Center|Bottom
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontBold% vTextInAreaFontBold, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontItalic% vTextInAreaFontItalic, I
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontUline% vTextInAreaFontUline, U
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontStrike% vTextInAreaFontStrike, S

    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIInsertTextPanel Altsubmit Choose%TextInAreaBorderOut% vTextInAreaBorderOut, None|Center|Outset
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIInsertTextPanel limit3 -multi number -wantCtrlA -wantTab -wrap veditF2, % TextInAreaBorderSize
    Gui, Add, UpDown, vTextInAreaBorderSize Range1-650, % TextInAreaBorderSize
    Gui, Add, Checkbox, x+2 hp gupdateUIInsertTextPanel Checked%TextInAreaOnlyBorder% vTextInAreaOnlyBorder, Only outline

    Gui, Add, Edit, xs yp+30 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF6, % TextInAreaBlurAmount
    Gui, Add, UpDown, vTextInAreaBlurAmount Range1-255, % TextInAreaBlurAmount
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF8, % TextInAreaBlurBorderAmount
    Gui, Add, UpDown, vTextInAreaBlurBorderAmount Range1-255, % TextInAreaBlurBorderAmount

    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaBgrUnified% vTextInAreaBgrUnified, Unified
    Gui, Add, Checkbox, x+3 yp hp gupdateUIInsertTextPanel Checked%TextInAreaRoundBoxBgr% vTextInAreaRoundBoxBgr, Rounded
    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaCutOutMode% vTextInAreaCutOutMode, Cut-out mode
    Gui, Add, Checkbox, x+3 gupdateUIInsertTextPanel Checked%TextInAreaBgrEntire% vTextInAreaBgrEntire, Fill entire line(s)

    Gui, Tab, 3
    Gui, Add, Text, x+15 y+15 Section, Text opacity / color
    Gui, Add, Slider, xs+20 y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaFontOpacity Range1-255, % TextInAreaFontOpacity
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaFontColor% vTextInAreaFontColor hwndhLV3,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaFontColor, P

    Gui, Add, Text, xs y+20, Border opacity / color
    Gui, Add, Slider, xs+20 y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaBorderOpacity Range1-255, % TextInAreaBorderOpacity
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaBorderColor% vTextInAreaBorderColor hwndhLV45,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaBorderColor, P

    Gui, Add, Text, xs y+20, Background opacity / color
    Gui, Add, Slider, xs+20 y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaBgrOpacity Range1-255, % TextInAreaBgrOpacity
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaBgrColor% vTextInAreaBgrColor hwndhLV2,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaBgrColor, P

    Gui, Tab
    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%TextInAreaLivePreview% vTextInAreaLivePreview gupdateUIInsertTextPanel, Live preview (low quality)
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Insert text into selected area: " appTitle, winPos)
    SetTimer, updateUIInsertTextPanel, -250
}

PopulateFontsList(thisCtrl, guiu) {
    If !FontList._NewEnum()[k, v]
    {
       Fnt_GetListOfFonts()
       FontList := trimArray(FontList)
    }

    Loop, % FontList.Count()
    {
        fontNameInstalled := FontList[A_Index]
        If (fontNameInstalled ~= "i)(@|biz ud|ud digi kyo|oem|extb|symbol|marlett|wst_|glyph|reference specialty|system|terminal|mt extra|small fonts|cambria math|this font is not|fixedsys|emoji|hksc| mdl|wingdings|webdings)") || (fontNameInstalled=OSDFontName)
           Continue
        GuiControl, %guiu%:, %thisCtrl%, %fontNameInstalled%
    }
}

updateUIInsertTextPanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen=32)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, TextInAreaAlign
    GuiControlGet, TextInAreaAutoWrap
    GuiControlGet, TextInAreaValign
    GuiControlGet, TextInAreaBlurAmount
    GuiControlGet, TextInAreaBlurBorderAmount
    GuiControlGet, TextInAreaDoBlurs
    GuiControlGet, TextInAreaUsrMarginz
    GuiControlGet, TextInAreaBgrOpacity
    GuiControlGet, TextInAreaBgrEntire
    GuiControlGet, TextInAreaBgrUnified
    GuiControlGet, TextInAreaFontLineSpacing
    GuiControlGet, TextInAreaCharSpacing
    GuiControlGet, TextInAreaCutOutMode
    GuiControlGet, TextInAreaBorderSize
    GuiControlGet, TextInAreaBorderOut
    GuiControlGet, TextInAreaBorderOpacity
    GuiControlGet, TextInAreaFontBold
    GuiControlGet, TextInAreaFontItalic
    GuiControlGet, TextInAreaFontName
    GuiControlGet, TextInAreaFontOpacity
    GuiControlGet, TextInAreaFontSize
    GuiControlGet, TextInAreaFontUline
    GuiControlGet, TextInAreaFontStrike
    GuiControlGet, TextInAreaOnlyBorder
    GuiControlGet, TextInAreaPaintBgr
    GuiControlGet, TextInAreaLineAngle
    GuiControlGet, TextInAreaRoundBoxBgr
    GuiControlGet, TextInAreaLivePreview
    GuiControlGet, UserTextArea

    If !isNumber(TextInAreaFontLineSpacing)
       TextInAreaFontLineSpacing := 0

    If (TextInAreaBorderSize>=TextInAreaFontSize*2)
       TextInAreaBorderSize := TextInAreaFontSize*2

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIInsertTextPanel, -200
       Return
    }

    GuiControl, SettingsGUIA:, infoTextBlur, Blur amount: %TextInAreaBlurAmount%
    actu := (TextInAreaPaintBgr=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, TextInAreaBgrOpacity
    GuiControl, % actu, TextInAreaBgrColor
    GuiControl, % actu, PickuTextInAreaBgrColor
    GuiControl, % actu, TextInAreaBgrUnified
    GuiControl, % actu, TextInAreaBgrEntire
    GuiControl, % actu, TextInAreaCutOutMode

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1)
    {
       GuiControl, SettingsGUIA: Enable, TextInAreaBgrEntire
       GuiControl, SettingsGUIA: Enable, TextInAreaCutOutMode
    } Else
    {
       GuiControl, SettingsGUIA: Disable, TextInAreaBgrEntire
       GuiControl, SettingsGUIA: Disable, TextInAreaCutOutMode
    }

    actu2 := (TextInAreaBorderOut>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, editF7
    GuiControl, % actu2, editF2
    GuiControl, % actu2, TextInAreaBorderSize
    GuiControl, % actu2, TextInAreaBorderColor
    GuiControl, % actu2, TextInAreaBorderOpacity
    GuiControl, % actu2, TextInAreaBlurBorderAmount
    GuiControl, % actu2, PickuTextInAreaBorderColor
    GuiControl, % actu2, TextInAreaOnlyBorder

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
       GuiControl, SettingsGUIA: Enable, TextInAreaRoundBoxBgr
    Else
       GuiControl, SettingsGUIA: Disable, TextInAreaRoundBoxBgr

    If (actionu!="noPreview" && TextInAreaLivePreview=1)
       livePreviewsImageEditing(1)

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsTextAreaPanel, -300
}

WriteSettingsTextAreaPanel() {
     ReadSettingsTextInArea(1)
}

openPrefsPanelWindow() {
    If AnyWindowOpen
       Return

    thisBtnHeight := createSettingsGUI(14, A_ThisFunc)
    btnWid := 100
    txtWid := 350
    columnBpos2 := 205
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos2 := columnBpos2 + 50
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Global editF4, editF5, editF6, PickuWindowBGRcolor, PickuOSDbgrColor, PickuOSDtextColor

    Gui, Add, Text, x15 y15 w%txtWid%, The text style options apply to the On-Screen Display in the viewport. The same text style is used to render as images texts pasted from the clipboard.
    Gui, Add, Text, y+15 Section, Font name
    Gui, Add, Text, xs yp+30, Font size (OSD / clipboard)
    Gui, Add, Text, xs yp+30, Text color and style
    Gui, Add, Text, xs yp+30, Alignment (captions / paste)
    Gui, Add, Text, xs yp+30, OSD background color
    Gui, Add, Text, xs yp+30, Display time (in sec.)
    Gui, Add, Text, xs yp+30, Window background color

    Gui, Add, DropDownList, xs+%columnBpos2% ys+0 Section w190 gupdateUIsettings Sort Choose1 vOSDFontName, %OSDFontName%
    Gui, Add, Edit, xs+0 yp+30 w%editWid% r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF5, %OSDfntSize%
    Gui, Add, UpDown, vOSDfntSize Range10-350, %OSDfntSize%
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF4, %PasteFntSize%
    Gui, Add, UpDown, vPasteFntSize Range12-350, %PasteFntSize%

    Gui, Add, ListView, xs yp+30 w%editWid% h28 %CCLVO% Background%OSDtextColor% vOSDtextColor hwndhLV1,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuOSDtextColor, P
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIsettings Checked%FontBolded% vFontBolded, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIsettings Checked%FontItalica% vFontItalica, I
    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIsettings vusrTextAlign, %usrTextAlign%||Left|Right|Center
    Gui, Add, ListView,  xs+0 yp+30 gupdateUIsettings w%editWid% hp %CCLVO% Background%OSDbgrColor% vOSDbgrColor hwndhLV2,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuOSDbgrColor, P
    Gui, Add, Edit, xs+0 yp+30 gupdateUIsettings w%editWid% hp r1 limit2 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF6, %DisplayTimeUser%
    Gui, Add, UpDown, vDisplayTimeUser Range1-99, %DisplayTimeUser%
    Gui, Add, ListView, xs+0 yp+30 w%editWid% hp %CCLVO% Background%WindowBGRcolor% vWindowBGRcolor hwndhLV3,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuWindowBGRcolor, P
    Gui, Add, Checkbox, x15 y+10 gupdateUIsettings Checked%borderAroundImage% vborderAroundImage, Highlight image borders in the viewport

    PopulateFontsList("OSDFontName", "SettingsGUIA")
    Gui, Add, Button, xm+0 y+20 h%thisBtnHeight% w%btnWid% gOpenUImenu, &More options
    Gui, Add, Button, x+5 hp w90 gPrefsCloseBTN Default, Clo&se
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Interface settings: " appTitle)
}

PanelAdjustToneMapping() {
    If AnyWindowOpen
       Return

    IniAction(0, "cmrRAWtoneMapAlgo", "General", 2, 1, 3)
    IniAction(0, "cmrRAWtoneMapParamA", "General", 2, -8, 10)
    IniAction(0, "cmrRAWtoneMapParamB", "General", 2, -8, 10)
    thisBtnHeight := createSettingsGUI(42, A_ThisFunc)
    btnWid := 100
    txtWid := 500
    columnBpos2 := 205
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos2 := columnBpos2 + 50
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 20
       Gui, Font, s%LargeUIfontValue%
    }

    If (cmrRAWtoneMapAlgo=1)
    {
       prcA := cmrRAWtoneMapParamA/9.9
       paramA := Round(200*prcA)
       prcB := (cmrRAWtoneMapParamB + 8)/16
       paramB := Round(200*prcB)
    } Else If (cmrRAWtoneMapAlgo=2)
    {
       prcA := (cmrRAWtoneMapParamA + 8)/16
       paramA := Round(200*prcA)
       paramB := 200*cmrRAWtoneMapParamB
    } Else If (cmrRAWtoneMapAlgo=3)
    {
       paramA := 200*cmrRAWtoneMapParamA
       paramB := 200*cmrRAWtoneMapParamB
    }

    showTOOLtip("Initializing tone-mapping panel, please wait")
    Global SliderA, SliderB, infoSliderA, infoSliderB
    Gui, -DPIScale
    Gui, Add, Text, x15 y15 w460 h320 +0x1000 +0xE +hwndhLVmainu, Image before 
    Gui, Add, Text, x480 y15 w460 h320 +0x1000 +0xE +hwndhCropCornersPic, Image after
    ; Gui, Add, Text, xp-480 y+1 w2 h2 +0x1000 +0xE, -
    Gui, +DPIScale
    Gui, Add, Text, x15 y+10 Section w%txtWid%, High-dynamic range images (HDRIs) must be converted to 32 bits to be displayed on screen. You can choose the algorithm to use for this and also configure it.
    Gui, Add, DropDownList, xs y+10 w%txtWid% AltSubmit gupdateUItoneMappingPanel Choose%cmrRAWtoneMapAlgo% vcmrRAWtoneMapAlgo, Adaptive logarithmic mapping (F. Drago, 2003)|HDR reduction inspired by photoreceptors physiology (E. Reinhard, 2005)|Gradient domain HDR compression (R. Fattal, 2002)
    Gui, Add, Text, xs y+10 wp vinfoSliderA, ParamA
    Gui, Add, Slider, xs y+5 wp gupdateUItoneMappingPanel AltSubmit ToolTip NoTicks vsliderA Range1-200, % ParamA
    Gui, Add, Text, xs y+10 wp vinfoSliderB, ParamB
    Gui, Add, Slider, xs y+5 wp gupdateUItoneMappingPanel AltSubmit ToolTip NoTicks vsliderB Range1-200, % ParamB
    friendly := (PrefsLargeFonts=1) ? "`n" : ""
    Gui, Add, Checkbox, xs y+10 gupdateUItoneMappingPanel Checked%userHQraw% vuserHQraw, Load camera RAW images at high quality`nEnable this to have tone-mapping apply%friendly%on RAW images as well

    initializeFimPreviewIMG(getIDimage(currentFileIndex))
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% gBTNtoneMapRefresh Default, &Update viewport
    Gui, Add, Button, x+5 hp w90 gBTNresetToneMap, &Reset
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, Clo&se
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "HDR tone-mapping options: " appTitle)
    RemoveTooltip()
    SetTimer, updateUItoneMappingPanel, -350
}

initializeFimPreviewIMG(imgPath) {
  Static uiBoxW := 460, uiBoxH := 320
  initFIMGmodule()
  If !wasInitFIMlib
     Return 0

  tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, "0xE200B")
  If !tempBMP
     Return 0

  Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
  If !Gu
  {
     trGdip_DisposeImage(tempBMP, 1)
     Return 0
  }

  Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
  calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
  thisX := uiBoxW//2 - thisW//2
  thisY := uiBoxH//2 - thisH//2
  Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
  r1 := trGdip_DrawImage(A_ThisFunc, Gu, useGdiBitmap(), thisX, thisY, thisW, thisH)
  hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
  SetImage(hLVmainu, hBitmap)
  Gdi_DeleteObject(hBitmap)
  trGdip_DisposeImage(tempBMP, 1)
  Gdip_DeleteGraphics(Gu)

  If globalhFIFimg
  {
     FreeImage_UnLoad(globalhFIFimg)
     globalhFIFimg := ""
  }

  loadArgs := 0
  GFT := FreeImage_GetFileType(imgPath)
  If (GFT=34 && loadArgs=0)
     loadArgs := 0
  Else If (GFT=2 && loadArgs=0)
     loadArgs := 8

  hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
  If hFIFimgA
  {
     FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
     calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
     hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, 0)
  }

  If !hFIFimgB
  {
     FreeImage_UnLoad(globalhFIFimg)
     globalhFIFimg := ""
     Return 0
  }

  globalhFIFimg := hFIFimgB ? hFIFimgB : 0
  If !globalhFIFimg
     Return 0
  Else
     Return 1
}

updateUIfimToneMappedIMG() {
   Static uiBoxW := 460, uiBoxH := 320
   hFIFimgE := FreeImage_ToneMapping(globalhFIFimg, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
   imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgE), "-"))
   If (imgBPPc!=32)
      hFIFimgD := FreeImage_ConvertTo(hFIFimgE, "32Bits")

   hFIFimgZ := hFIFimgD ? hFIFimgD : hFIFimgE
   pBitmap := ConvertFIMtoPBITMAP(hFIFimgZ)

   tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, "0xE200B")
   If !tempBMP
   {
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      trGdip_DisposeImage(tempBMP, 1)
      Return
   }

   Gdip_GetImageDimensions(pBitmap, imgW, imgH)
   calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
   thisX := uiBoxW//2 - thisW//2
   thisY := uiBoxH//2 - thisH//2
   Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
   r1 := trGdip_DrawImage(A_ThisFunc, Gu, pBitmap, thisX, thisY, thisW, thisH)
   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
   SetImage(hCropCornersPic, hBitmap)
   Gdi_DeleteObject(hBitmap)
   trGdip_DisposeImage(tempBMP, 1)
   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(pBitmap, 1)

   FreeImage_UnLoad(hFIFimgE)
   If hFIFimgD
      FreeImage_UnLoad(hFIFimgD)
}

BTNtoneMapRefresh() {
   updateUItoneMappingPanel()
   discardViewPortCaches()
   disposeCacheIMGs()
   RefreshImageFileAction()
}

BTNresetToneMap() {
   If (AnyWindowOpen=42)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControl, SettingsGUIA: Choose, cmrRAWtoneMapAlgo, 1
   GuiControl, SettingsGUIA:, SliderA, 38
   GuiControl, SettingsGUIA:, SliderB, 100
   Sleep, 1
   updateUItoneMappingPanel()
}

updateUItoneMappingPanel() {
   Static lastInvoked := 1
   If (AnyWindowOpen=42)
      Gui, SettingsGUIA: Default
   Else
      Return

   If (A_TickCount - lastInvoked<100)
   {
      SetTimer, updateUItoneMappingPanel, -250
      Return
   }

   GuiControlGet, cmrRAWtoneMapAlgo
   GuiControlGet, SliderA
   GuiControlGet, SliderB
   GuiControlGet, userHQraw
   prcA := SliderA/200
   prcB := SliderB/200
   If (cmrRAWtoneMapAlgo=1)
   {
      cmrRAWtoneMapParamA := 9.9*prcA
      GuiControl, SettingsGUIA:, infoSliderA, Gamma: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := 16*prcB - 8
      GuiControl, SettingsGUIA:, infoSliderB, Exposure: %cmrRAWtoneMapParamB%
   } Else If (cmrRAWtoneMapAlgo=2)
   {
      cmrRAWtoneMapParamA := 16*prcA - 8
      GuiControl, SettingsGUIA:, infoSliderA, Intensity: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := prcB
      GuiControl, SettingsGUIA:, infoSliderB, Contrast: %cmrRAWtoneMapParamB%
   } Else If (cmrRAWtoneMapAlgo=3)
   {
      cmrRAWtoneMapParamA := prcA
      GuiControl, SettingsGUIA:, infoSliderA, Saturation: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := prcB
      GuiControl, SettingsGUIA:, infoSliderB, Attenuation: %cmrRAWtoneMapParamB%
   }

   updateUIfimToneMappedIMG()
   IniAction(1, "cmrRAWtoneMapAlgo", "General")
   IniAction(1, "cmrRAWtoneMapParamA", "General")
   IniAction(1, "cmrRAWtoneMapParamB", "General")
   lastInvoked := A_TickCount
}

updateUIsettings() {
    If (AnyWindowOpen=14)
       Gui, SettingsGUIA: Default
    Else
       Return

     GuiControlGet, DisplayTimeUser
     GuiControlGet, OSDFontName
     GuiControlGet, OSDfntSize
     GuiControlGet, PasteFntSize
     GuiControlGet, FontBolded
     GuiControlGet, FontItalica
     GuiControlGet, usrTextAlign
     GuiControlGet, borderAroundImage

     calcHUDsize()
     msgDisplayTime := DisplayTimeUser*1000
     SetTimer, WriteSettingsUI, -90
}

WriteSettingsUI() {
  INIaction(1, "DisplayTimeUser", "General")
  INIaction(1, "OSDFontName", "General")
  INIaction(1, "WindowBgrColor", "General")
  INIaction(1, "OSDbgrColor", "General")
  INIaction(1, "OSDtextColor", "General")
  INIaction(1, "OSDfntSize", "General")
  INIaction(1, "PasteFntSize", "General")
  INIaction(1, "FontBolded", "General")
  INIaction(1, "FontItalica", "General")
  INIaction(1, "usrTextAlign", "General")
  INIaction(1, "borderAroundImage", "General")
}

PrefsCloseBTN() {
     updateUIsettings()
     interfaceThread.ahkFunction("updateWindowColor")
     CloseWindow()
}

SetUIcolors(hC, event, c, err=0) {
; Function by Drugwash
; Critical MUST be disabled below! If that's not done, script will enter a deadlock !
  Static
  If (event="RightClick")
  {
     mouseTurnOFFtooltip()
     StartPickingColor()
     SetTimer, mouseTurnOFFtooltip, -50
     Return
  } Else If (event!="Normal")
     Return

  oc := A_IsCritical
  Critical, Off

  ; ToolTip, % event , , , 2
  g := A_Gui, ctrl := A_GuiControl
  r := %ctrl% := hexRGB(Dlg_Color(%ctrl%, hC))
  Critical, %oc%
  GuiControl, %g%:+Background%r%, %ctrl%
  INIaction(1, ctrl, "General")
  If (AnyWindowOpen=14)
  {
     interfaceThread.ahkFunction("updateWindowColor")
     updateUIsettings()
     refreshWinBGRbrush()
     dummyTimerDelayiedImageDisplay(50)
  } Else If (imgEditPanelOpened=1)
     livePreviewsImageEditing(1)
}

hexRGB(c) {
; unknown source
  r := ((c&255)<<16)+(c&65280)+((c&0xFF0000)>>16)
  c := "000000"
  DllCall("msvcrt\sprintf", "AStr", c, "AStr", "%06X", "UInt", r, "CDecl")
  Return c
}

Hex2Str(val, len, x:=false, caps:=true) {
; Function by Drugwash
    VarSetCapacity(out, (len+1)*2, 32), c := caps ? "X" : "x"
    DllCall("msvcrt\sprintf", "AStr", out, "AStr", "%0" len "ll" c, "UInt64", val, "CDecl")
    Result := x ? "0x" out : out
    Return Result
}

getCustomColorsFromImage(whichBitmap) {
  Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
  calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
  c := []
  c[1] := Gdip_GetPixelColor(whichBitmap, X1, Y1, 3)
  c[2] := Gdip_GetPixelColor(whichBitmap, X2, Y2, 3)
  c[3] := Gdip_GetPixelColor(whichBitmap, X1, Y2, 3)
  c[4] := Gdip_GetPixelColor(whichBitmap, X2, Y1, 3)
  c[5] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1 + imgSelH//2, 3)
  c[6] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1, 3)
  c[7] := Gdip_GetPixelColor(whichBitmap, X1, Y1 + imgSelH//2, 3)
  c[8] := Gdip_GetPixelColor(whichBitmap, X2, Y2 - imgSelH//2, 3)
  c[9] := Gdip_GetPixelColor(whichBitmap, X2 - imgSelW//2, Y2, 3)
  c[10] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//4, Y1 + imgSelH//4, 3)
  c[11] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2 + imgSelW//4, Y1 + imgSelH//2 + imgSelH//4, 3)
  c[12] := Gdip_GetPixelColor(whichBitmap, 1, 1, 3)
  c[13] := Gdip_GetPixelColor(whichBitmap, 1, imgH - 1, 3)
  c[14] := Gdip_GetPixelColor(whichBitmap, imgW - 1, imgH - 1, 3)
  c[15] := Gdip_GetPixelColor(whichBitmap, imgW - 1, 1, 3)
  c[16] := Gdip_GetPixelColor(whichBitmap, imgW//2, imgH//2, 3)
  Return c
}

Dlg_Color(Color,hwnd) {
; Function by maestrith 
; from: [AHK 1.1] Font and Color Dialogs 
; https://autohotkey.com/board/topic/94083-ahk-11-font-and-color-dialogs/
; Modified by Marius Șucan and Drugwash


  VarSetCapacity(CUSTOM,64,0)
  size := VarSetCapacity(CHOOSECOLOR,9*A_PtrSize,0)

  cclrs := getCustomColorsFromImage(useGdiBitmap())
  Loop, 16
  {
     ; BGR HEX
 ;    thisColor := "0x" SubStr(cclrs[A_Index], -1) SubStr(cclrs[A_Index], 7, 2) SubStr(cclrs[A_Index], 5, 2)
     NumPut(cclrs[A_Index], &CUSTOM, (A_Index-1)*4, "UInt")
  }

  oldColor := Color
  Color := "0x" hexRGB(InStr(Color, "0x") ? Color : Color ? "0x" Color : 0x0)
  NumPut(size,CHOOSECOLOR,0,"UInt")
  NumPut(hwnd,CHOOSECOLOR,A_PtrSize,"Ptr")
  NumPut(Color,CHOOSECOLOR,3*A_PtrSize,"UInt")
  NumPut(0x3,CHOOSECOLOR,5*A_PtrSize,"UInt")
  NumPut(&CUSTOM,CHOOSECOLOR,4*A_PtrSize,"Ptr")
  If !ret := DllCall("comdlg32\ChooseColorW","Ptr",&CHOOSECOLOR,"UInt")
     Exit

  SetFormat, Integer, H
  Color := NumGet(CHOOSECOLOR,3*A_PtrSize,"UInt")
  SetFormat, Integer, D
  Return Color
}

OpenUImenu() {
   deleteMenus()
   createMenuInterfaceOptions()
   showThisMenu("PvUIprefs")
}

PanelDefineEntireSlideshowLength() {
    Global userHourDur, userMinDur, userSecDur, infoLine, userDefinedSpeedSlideshow
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (maxFilesIndex<3 || thumbsDisplaying=1)
       Return

    thisBtnHeight := createSettingsGUI(19, A_ThisFunc)
    btnWid := 130
    txtWid := 350
    EditWid := 35
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 2
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    infoSliSpeed := DefineSlidesRate()
    etaTime := EstimateSlideShowLength()

    Gui, Add, Text, x15 y15 Section w%txtWid%, Define the total time of the slideshow`nfor %maxFilesIndex% images.
    Gui, Add, Text, y+15 w80, Hours
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserHourDur, % Round(Hrs)
    Gui, Add, Text, xs y+5 wp, Minutes
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserMinDur, % Round(Min)
    Gui, Add, Text, xs y+5 wp, Seconds
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserSecDur, % Round(Sec)
    Gui, Add, Text, xs y+5 wp, Speed
    Gui, Add, DropDownList, x+5 wp gChooseSlideSpeed AltSubmit vuserDefinedSpeedSlideshow, ---||30 FPS|15 FPS|7 FPS|2 FPS|1 sec.|2 sec.|4 sec.|8 sec.|16 sec.
    Gui, Add, Button, x+5 hp w75 gTimeLapseInfoBox, Infos
    Gui, Add, Button, x+5 hp w95 gSetTimeLapseMode, Timelapse

    Gui, Add, Text, xs y+15 w%txtWid% vinfoLine, One image every: %infoSliSpeed%`nEstimated slideshow duration: %etaTime%
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gStartSlideINtotalTimeBTNaction, &Start slideshow
    Gui, Add, Button, x+5 hp w90 gResetSlideSpeed, De&fault
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Define total slideshow time: " appTitle)
}

TimeLapseInfoBox() {
    msgBoxWrapper(appTitle ": HELP", "The slideshow durations displayed in the panel include the time estimated to load each image. Based on previously loaded images, it takes about " drawModeCzeit " miliseconds to load an image.`n `nFor optimal timelapses [or very fast slideshows] set zoom at 100`%, disable image rotation and color adjustments and «skip already seen images».", -1, 0, 0)
    ; coreResetSlideSpeed(33, 1)
    ; GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 2
}

SetTimeLapseMode() {
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to set slideshow mode to timelapse? This will set zoom level to 100% and disable any image effect or adjustment.`n`nThe slideshow speed will be set at ~30 FPS [33 images/sec.].", 4, 0, "question")
    If (msgResult="Yes")
    {
       IMGresizingMode := 4
       interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
       mustRecordSeenImgs := 0
       imgFxMode := usrColorDepth := zoomLevel := 1
       vpIMGrotation := FlipImgH := FlipImgV := 0
       coreResetSlideSpeed(33, 1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 2
       dummyTimerDelayiedImageDisplay(50)
    }
}

ResetSlideSpeed() {
    coreResetSlideSpeed(4000, 1)
    GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 8
}

ChooseSlideSpeed() {
    GuiControlGet, userDefinedSpeedSlideshow
    If (userDefinedSpeedSlideshow=2)
       coreResetSlideSpeed(33, 1)
    Else If (userDefinedSpeedSlideshow=3)
       coreResetSlideSpeed(67, 1)
    Else If (userDefinedSpeedSlideshow=4)
       coreResetSlideSpeed(143, 1)
    Else If (userDefinedSpeedSlideshow=5)
       coreResetSlideSpeed(500, 1)
    Else If (userDefinedSpeedSlideshow=6)
       coreResetSlideSpeed(1000, 1)
    Else If (userDefinedSpeedSlideshow=7)
       coreResetSlideSpeed(2000, 1)
    Else If (userDefinedSpeedSlideshow=8)
       coreResetSlideSpeed(4000, 1)
    Else If (userDefinedSpeedSlideshow=9)
       coreResetSlideSpeed(8000, 1)
    Else If (userDefinedSpeedSlideshow=10)
       coreResetSlideSpeed(16000, 1)
}

coreResetSlideSpeed(varu, noDDLjump:=0) {
    slideShowDelay := varu
    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    GuiControl, SettingsGUIA:, userHourDur, % Round(Hrs)
    GuiControl, SettingsGUIA:, userMinDur, % Round(Min)
    GuiControl, SettingsGUIA:, userSecDur, % Round(Sec)
    If (noDDLjump!=1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    DefineSlidesTotalTimeBTNaction(0)
}

DefineSlidesRate() {
   slidesDuration := slideShowDelay
   ; slidesDuration := (slideShowDelay<drawModeCzeit) ? Round((drawModeCzeit*0.7+slideShowDelay)//2) : slideShowDelay
  ; If (slidesDuration<1995 && slidesDuration!=1000)
  ;    miliSec := slidesDuration " milisec."
   ; Else
      duration := SecToHHMMSS(Round(slidesDuration/1000, 3))
   Return miliSec ? miliSec : duration
}

StartSlideINtotalTimeBTNaction() {
   DefineSlidesTotalTimeBTNaction(0)
   CloseWindow()
   dummyInfoToggleSlideShowu()
}

UpdateSlideshowPanel() {
    Static lastInvoked := 1
    DefineSlidesTotalTimeBTNaction()
    GuiControlGet, WhatsFocused, SettingsGUIA: FocusV
    If (WhatsFocused="userHourDur" || WhatsFocused="userMinDur" || WhatsFocused="userSecDur")
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    lastInvoked := A_TickCount
}

DefineSlidesTotalTimeBTNaction(doDDLjump:=1) {
    GuiControlGet, userHourDur
    GuiControlGet, userMinDur
    GuiControlGet, userSecDur
    slideShowDelay := 0    
    slideShowDelay += userSecDur*1000
    slideShowDelay += (userMinDur*60)*1000
    slideShowDelay += ((userHourDur*60)*60)*1000
    slideShowDelay := Round(slideShowDelay/maxFilesIndex)
    If (slideShowDelay<16)
       slideShowDelay := 16

    etaTime := EstimateSlideShowLength()
    infoSliSpeed := DefineSlidesRate()
    GuiControl, SettingsGUIA:, InfoLine, One image every: %approxMarker%%infoSliSpeed%`nEstimated slideshow duration: %approxMarker%%etaTime%
}

EstimateSlideShowLength(noPrecision:=0) {
    slidesDuration := (slideShowDelay<drawModeCzeit) ? (drawModeCzeit + slideShowDelay)/2 : drawModeCzeit*0.9 + slideShowDelay
    ; slidesDuration := (slideShowDelay<drawModeCzeit) ? drawModeCzeit : slideShowDelay
    approxMarker := (slideShowDelay<drawModeCzeit) ? "~" : ""
    infoFilesSel := (maxFilesIndex>0) ? maxFilesIndex : 1
    slidesDuration := Round(slidesDuration/1000, 3) * infoFilesSel
    ; MsgBox, % etaTime "--" slidesDuration "--" slideShowDelay "--" drawModeCzeit "--" maxFilesIndex
    etaTime := approxMarker SecToHHMMSS(slidesDuration)
    If (noPrecision=1)
       etaTime := RegExReplace(etaTime, "\...s", "s")
    Return etaTime
}

jumpPreviousImage() {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If askAboutFileSave(" and another image will be loaded")
       Return

    currentFileIndex := clampInRange(prevLastImg[2, 1], 1, maxFilesIndex)
    dummyTimerDelayiedImageDisplay(50)
}

PanelJump2index() {
   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to open panel")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   imgPath := getIDimage(currentFileIndex)
   isAnim := (RegExMatch(imgPath, "i)(.\.(gif))$") && totalFramesIndex>1) ? "`fSkip to given frame index" : ""
   fakeWinCreator(13, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Skip to given index: " appTitle, "Please type a number to skip at in the files list and choose the action. Total entries: " groupDigits(maxFilesIndex) ".", "&Skip to...|C&ancel", 1, "fast-forward", 0, 0, "Skip to given file index`f`fSelect from current file index to given index" isAnim, "limit9050 +number", currentFileIndex, 2)
   If InStr(msgResult.btn, "skip")
   {
      usrJumpIndex := Trimmer(msgResult.edit)
      If !usrJumpIndex
         Return

      newJumpIndex := clampInRange(usrJumpIndex, 1, maxFilesIndex)
      If (newJumpIndex=currentFileIndex && newJumpIndex>0 && msgResult.list!=3)
         Return

      If askAboutFileSave(" and another image will be loaded")
         Return

      If (IsNumber(newJumpIndex) && newJumpIndex>=1)
      {
         If (msgResult.list=3)
         {
            desiredFrameIndex := clampInRange(usrJumpIndex, 1, totalFramesIndex)
            RefreshImageFile()
            Return
         } Else If (msgResult.list=2)
            jumpSelectRangeGiven(currentFileIndex, newJumpIndex)

         currentFileIndex := newJumpIndex
         dummyTimerDelayiedImageDisplay(50)
      }
   }
}

SaveClipboardImage(dummy:=0, allowCropping:=0, noDialog:=0) {
   Static lastInvoked := 1

   If throwErrorNoImageLoaded()
      Return

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   initFIMGmodule()
   INIaction(0, "userDesireWriteFMT", "General", 2, 1, 16)
   INIaction(0, "prevFileSavePath", "General", 5)
   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
   defaultu := (dummy="current") ? OutDir "\" OutNameNoExt : prevFileSavePath "\" OutNameNoExt
   If !defaultu
      defaultu := prevFileSavePath "\" OutNameNoExt
   If FolderExist(dummy)
      defaultu := dummy "\" OutNameNoExt

   Loop, Parse, dialogSaveFptrn, |
   {
        If InStr(A_LoopField, "." oEXT)
           defFMTindex := A_Index
   }

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (imgW*imgH>maxGDIbmpSize)
   {
      SoundBeep, 300, 100
      showTOOLtip("ERROR: The image size is too large. Image file saving disabled.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If alertReduceSaveColorDepth()
      Return

   If (noDialog=1)
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "PathMustExist", defaultu, "Save image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)

   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      If (FileExist(file2save) && imgPath!=file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      If FileExist(imgPath)
      {
         FileGetTime, originalMtime, % imgPath, M
         FileGetTime, originalCtime, % imgPath, C
         Sleep, 1
         FileSetAttrib, -R, % file2save
      }

      ForceRefreshNowThumbsList()
      If (AnyWindowOpen=35)
         BtnCloseWindow()

      showTOOLtip("Saving image, please wait`n" OutFileName)
      newBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap())))
      prevFileSavePath := OutDir
      INIaction(1, "prevFileSavePath", "General")
      lastInvoked := A_TickCount
      If StrLen(newBitmap)>2
      {
         destroyGDIfileCache(1, 1)
         changeMcursor()
         r := QPV_SaveImageFile(A_ThisFunc, newBitmap, file2save, userJpegQuality)
         trGdip_DisposeImage(newBitmap, 1)
      } Else r := "err-no-main-bmp"

      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         resultedFilesList[currentFileIndex, 4] := 1
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
      }

      If r
      {
         msgBoxWrapper(appTitle ": ERROR", appTitle " was unable to save the image file due to an undetermined cause.`n`n" OutFileName "`n" OutDir "\`nError code: " r, 0, 0, "error")
         showTOOLtip("Failed to save image file`n" OutFileName "`n" OutDir "\")
      } Else
      {
         showTOOLtip("Image file succesfully saved`n" OutFileName "`n" OutDir "\")
         testMem := getIDimage(currentFileIndex)
         resultedFilesList[currentFileIndex, 1] := file2save
         If (currentFileIndex=0) || (InStr(testMem, "\temporary memory object\") && maxFilesIndex<2)
         {
            currentFileIndex := maxFilesIndex := 1
            resultedFilesList[1, 1] := file2save
            DynamicFoldersList := OutDir "`n"
            prevOpenFolderPath := OutDir
            CurrentSLD := "|" OutDir
            SLDtypeLoaded := 1
         } Else If (imgPath!=file2save)
            resultedFilesList.InsertAt(currentFileIndex, [file2save])
         Else If (SLDtypeLoaded=3)
            selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

         imgIndexEditing := currentFileIndex
         currentImgModified := 2
      }

      SoundBeep, % r ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -50
   }
}

BtnCpyMvChooseFilesDest() {
   If (currentFileIndex=0)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   SelectedDir := openFoldersDialogWrapper("S2", prevFileMovePath)
   SelectedDir := Trimmer(SelectedDir)
   If FolderExist(SelectedDir)
   {
      BtnCloseWindow()
      Sleep, 15
      prevFileMovePath := SelectedDir
      RecentCopyMoveManager(SelectedDir)
      Sleep, 15
      CopyMovePanelWindow()
   } Else
   {
      WinActivate, ahk_id %hSetWinGui%
      Return
   }
}

zPlitPath(inputu, fastMode, ByRef fileNamu, ByRef folderu, ByRef fileNamuNoEXT:=0, ByRef fileEXT:=0) {
    If (fastMode=0)
    {
       inputu := Trimmer(StrReplace(inputu, "|"))
       FileGetAttrib, OutputAttribs, %inputu%
    } Else StringRight, OutputVar, inputu, 1

    If InStr(OutputAttribs, "D") || (OutputVar="\")
    {
       ; ToolTip, % OutputVar , , , 2
       ; SoundBeep , 300, 100
       folderu := inputu
       fileEXT := fileNamuNoEXT := fileNamu := ""
    } Else
    {
       lineArr := StrSplit(inputu, "\")
       maxuIndex := lineArr.Count()
       fileNamu := lineArr[maxuIndex]
       fileParentFolder := lineArr[maxuIndex - 1]
       ; folderu := SubStr(inputu, 1, StrLen(inputu) - StrLen(fileNamu) - 1)
       ; fileEXTpos := RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
       fileEXTpos := InStr(fileNamu, ".", 0, -1) ; RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
       If fileEXTpos
          fileEXT := Trimmer(SubStr(fileNamu, fileEXTpos+1))

       If (!fileExt || StrLen(fileExt)>4)
       {
          fileNamu := fileEXTpos := ""
          folderu := Trim(Trimmer(inputu), "\")
       } Else
       {
          folderu := ""
          Loop, % maxuIndex - 1
          {
             If lineArr[A_Index]
                folderu .= lineArr[A_Index] "\"
          }
          folderu := Trim(folderu, "\")
       }

       ; fileNamuNoEXT := fileEXTpos ? RegExReplace(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$") : fileNamu
       fileNamuNoEXT := fileEXTpos ? SubStr(fileNamu, 1, fileEXTpos - 1) : fileNamu
    }
    Return fileParentFolder
}

StringToASC(string) {
   Static lastInvoked, lastAsc
   If !String
      Return

   If (string=lastInvoked)
      Return lastAsc

   ; AscString := StrLen(string)
   Loop, Parse, string 
      AscString .= RegExMatch(A_LoopField, "[[:alnum:]]") ? A_LoopField : Ord(A_LoopField)

   ; ToolTip, % AscString , , , 2 
   lastInvoked := string
   lastAsc := AscString
   Return AscString
}

readRecentFileDesties(modus:=0) {
   listu := ""
   If (modus!=1)
   {
      If FolderExist(prevFileMovePath)
         listu .= prevFileMovePath "`n"
      If FolderExist(prevFileSavePath)
         listu .= prevFileSavePath "`n"
      If FolderExist(prevOpenFolderPath)
         listu .= prevOpenFolderPath "`n"
   }

   Loop, 15
   {
       IniRead, newEntry, % mainRecentsFile, RecentFDestinations, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (FolderExist(newEntry) && !InStr(listu, newEntry "`n"))
          listu .= newEntry "`n"
   }
   Return listu
}

PanelMoveCopyFiles() {
   UsrCopyMoveOperation := 2
   CopyMovePanelWindow()
}

InvokeCopyFiles() {
   UsrCopyMoveOperation := 3
   If (maxFilesIndex>0)
      CopyMovePanelWindow()
}

CopyMovePanelWindow() {
    Global BtnCpyMv, lastInvoked := 1
    ; Static prevmainDynaFoldersListu, prevCurrentSLD

    openingPanelNow := 1
    thisBtnHeight := createSettingsGUI(9, A_ThisFunc)
    btnWid := 125
    btnWid2 := 60
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       btnWid2 += 60
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    ToolTip, Please wait...,,, 2
    listu := readRecentFileDesties()
    listu .= "--={ other destinations }=--`n"
    setImageLoading()
    historyList := readRecentEntries()
    Loop, Parse, historyList, `n
    {
       If (A_Index>10)
          Break 

       If StrLen(A_LoopField<4)
          Continue 

       changeMcursor()
       OutDir := StrReplace(A_LoopField, "|")
       If InStr(listu, OutDir "`n") || !FolderExist(OutDir)
          Continue

       listu .= OutDir "`n"
    } 

    thisDynaList := getDynamicFoldersList()
    ; DynamicFoldersList := mainDynaFoldersListu
    prevCurrentSLD := CurrentSLD
    lastInvoked := A_TickCount

    Loop, Parse, thisDynaList, `n
    {
        If (A_Index>15)
           Break

        If StrLen(A_LoopField)<4
           Continue

        changeMcursor()
        folderu := StrReplace(A_LoopField, "|")
        If InStr(listu, folderu "`n") || !FolderExist(folderu)
           Continue

        listu .= folderu "`n"
    }

    List_MakeUnique(listu, "`n", 0, 0)
    Loop, Parse, listu, `n
    {
        If !A_LoopField
           Continue

        changeMcursor()
        indexu := InStr(A_LoopField, "{ other dest") ? "" : A_Index - 1 "; "
        finalListu .= indexu A_LoopField "`n"
        If (A_Index=1)
           finalListu .= "`n"
    }

    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       finalListu .= "[group-by-month-year]`n[group-by-years]`n[group-by-file-types]"
       copyMoveDoLastOption := 0
       infoSelection := "Selected files: " markedSelectFile ". "
    }

    Gui, +Delimiter`n
    Gui, Add, Text, x15 y15 Section, %infoSelection%Please select or type destination folder...
    Gui, Add, ComboBox, xs y+10 w%EditWid% gCopyMoveComboAction r12 Simple vUsrEditFileDestination, % finalListu
    Gui, Add, Checkbox, y+10 Checked%copyMoveDoLastOption% vcopyMoveDoLastOption, When file name(s) collide, use previously given answer
    If (markedSelectFile>1)
       GuiControl, Disable, copyMoveDoLastOption

    ToolTip,,,,2
    SetTimer, ResetImgLoadStatus, -50
    btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
    Gui, Add, DropDownList, xs y+20 w%btnWid% gchangeCopyMoveAction AltSubmit Choose%UsrCopyMoveOperation% vUsrCopyMoveOperation, Action to perform...`nMove file(s)`nCopy file(s)
    Gui, Add, Button, x+5 hp w%btnWid% gBtnCpyMvChooseFilesDest, &Choose a new folder
    Gui, Add, Button, x+5 hp w90 gBtnHelpCopyMovePanel, Hel&p

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBtnCopyMoveAction vBtnCpyMv, &Proceed
    Gui, Add, Button, x+5 hp wp+30 gEraseCopyMoveHisto, Erase &history
    Gui, Add, Button, x+5 hp wp+60 gBtnMarkFilesExplorer, &Mark file(s) (Explorer)
    Gui, Add, Button, x+5 hp w70 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, btnName " file(s) to...: " appTitle)
    SetTimer, resetOpeningPanel, -300
}

BtnHelpCopyMovePanel() {
  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  If (AnyWindowOpen=9)
     moreInfo := "`n`nIf you click on «Mark files (Explorer)» button, the selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle "."

  msgBoxWrapper(appTitle ": HELP", "Recognized patterns:`n`na) " btnName " files to parent folder: .\`n`nb) " btnName " files to a new or existing sub-folder: \given-folder`n`nc) " btnName " files into a new or exiting folder within the parent folder: .\given-folder`n`nThe destination folder for all selected files [if any] will be calculated relative to the currently active file index entry: " groupDigits(currentFileIndex) ".`n" OutDir "`n`nUse [group-by-month-year], [group-by-years] or [group-by-file-types] as folder name to automatically group files in newly created folders named based on files' modification date or file types." moreInfo, -1, 0, 0)
}

changeCopyMoveAction() {
  GuiControlGet, UsrCopyMoveOperation
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  ; GuiControl, SettingsGUIA:, BtnCpyMv, &%btnName% file(s)
  Gui, SettingsGUIA: Show,, %btnName% file(s) to...: %appTitle%
  If (UsrCopyMoveOperation=1)
     GuiControl, SettingsGUIA: Disable, BtnCpyMv
  Else
     GuiControl, SettingsGUIA: Enable, BtnCpyMv
}

CopyMoveComboAction() {
  Static lastInvoked := 1
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditFileDestination
  If (A_GuiControlEvent="DoubleClick")
  {
     BtnCopyMoveAction()
  } Else If (A_GuiControlEvent="Normal") && (A_TickCount - lastInvoked > 50) && StrLen(UsrEditFileDestination)<5
    && !InStr(UsrEditFileDestination, ":\") && InStr(UsrEditFileDestination, ";")
  {
     SendInput, {Up}
     lastInvoked := A_TickCount
  }
}

EraseCopyMoveHisto() {
  IniDelete, % mainRecentsFile, RecentFDestinations
  BtnCloseWindow()
  CopyMovePanelWindow()
}

BtnMarkFilesExplorer() {
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
  GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
  GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
  If (UsrCopyMoveOperation=1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "Please choose an action to perform: copy or move.`n`nThe selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle ".", 0, 0, "exclamation")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  BtnCloseWindow()
  If (UsrCopyMoveOperation=3)
     MenuExplorerCopyFiles()
  Else
     MenuExplorerCutFiles()
}

BtnCopyMoveAction(dummy:=0) {
  If (dummy!="quick-actu")
  {
     Gui, SettingsGUIA: Default
     GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
     GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
     GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
     If (UsrCopyMoveOperation=1)
     {
        showTOOLtip("WARNING: Please choose an action to perform: copy or move")
        SoundBeep, 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     }
  }

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  folderu := Trimmer(UsrEditFileDestination)
  folderu := StrReplace(folderu, "/", "\")
  folderu := RegExReplace(folderu, "\\{2,}", "\")
  groupingMode := 0
  If (folderu="[group-by-month-year]" || folderu="[group-by-years]" || folderu="[group-by-file-types]")
  {
     ; group files by given criteria
     groupingMode := 1
     folderu := OutDir "\" folderu
  } Else If (folderu=".\")
  {
     ; move files one level up
     folderu := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
  } Else If RegExMatch(folderu, "^(\\.)")
  {
     ; move files to a given sub-folder
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)
     If folderu
        folderu := OutDir "\" folderu
  } Else If RegExMatch(folderu, "^(\.\\.)")
  {
    ; move files to a given sibling folder
     OutDir := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)
     If folderu
        folderu := OutDir "\" folderu
  }

  folderu := StrReplace(folderu, "\\", "\")
  folderu := Trimmer(folderu, "\")
  folderu := Trimmer(folderu, ".")
  If (b := InStr(folderu, "; "))
     folderu := SubStr(folderu, b+2)

  wrongNames := 0
  testFolderu := SubStr(folderu, 4)
  Loop, Parse, testFolderu, \
  {
      IF (!filterFileName(A_LoopField) && A_LoopField)
         wrongNames := 1
  }

  If (InStr(folderu, "[group-by-month-year]") || InStr(folderu, "[group-by-file-types]") || InStr(folderu, "[group-by-years]"))
     groupingMode := 1

  If (!RegExMatch(folderu, "^(.\:\\.)") || wrongNames=1)
  {
     showTOOLtip("WARNING: Incorrect file path given:`n" folderu)
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return 0
  }

  If (FolderExist(folderu) || groupingMode=1)
  {
     Sleep, 2
     r := QuickMoveFile2Dest(folderu, copyMoveDoLastOption, groupingMode, dummy)
  } Else If (StrLen(folderu)>4)
  {
     If (dummy!="quick-actu")
        msgResult := msgBoxWrapper(appTitle, "Destination folder does not seem to exist:`n" folderu "\`n`nDo you want to create the folder?", 4, 0, "question")

     If (msgResult="yes" || dummy="quick-actu")
     {
        FileCreateDir, % folderu
        If ErrorLevel
        {
           SoundBeep , 300, 100
           If (dummy="quick-actu")
              showTOOLtip("Failed to create the destination folder:`n" folderu "\")
           Else
              msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n" folderu "\", 0, 0, "error")
           Return 0
        } Else
        {
           Sleep, 2
           r := QuickMoveFile2Dest(folderu, copyMoveDoLastOption, groupingMode, dummy)
        }
     }
  }
  ; MsgBox, %folderu% -- %newentry%
  Return r
}

RecentCopyMoveManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentFileDesties(1)

  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu,`n
  {
      If (A_LoopField=entry2add)
      {
         isAddedAlready := 1
         Break
      }
  }

  If (isAddedAlready=1)
     Return

  mainListu := entry2add "`n" mainListu
  Loop, Parse, mainListu, `n
  {
      If (A_Index>15)
         Break

      folderu := Trimmer(A_LoopField)
      folderu := Trimmer(folderu, "\")
      If (!FolderExist(folderu) || !InStr(folderu, ":\"))
         Continue

      countItemz++
      IniWrite, % folderu, % mainRecentsFile, RecentFDestinations, E%countItemz%
  }
}

QuickMoveFile2Dest(finalDest, goLastOption, groupingMode:=0, dummy:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()
 
    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       batchCopyMoveFile(finalDest, groupingMode, dummy)
       Return 0
    } 

    file2rem := getIDimage(currentFileIndex)
    zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
    If !FileExist(file2rem)
    {
       ResetImgLoadStatus()
       SoundBeep, 300, 100 
       If (dummy="quick-actu")
          showTOOLtip("Failed to perform action. File not found or access denied.`n" OldOutFileName "`n" OldOutDir "\")
       Else
          msgBoxWrapper(appTitle ": ERROR", "Failed to perform action. File not found or access denied.`n`n" OldOutFileName "`n" OldOutDir "\", 0, 0, "error")
       Return 0
    }

    If (groupingMode=1)
    {
       FileGetTime, originalMtime, % file2rem, M
       finalDest := determineCreateFileGroupFolder(finalDest, originalMtime, OutFileExt)
    }

    If (OldOutDir=finalDest)
    {
       SetTimer, ResetImgLoadStatus, -200
       SoundBeep, 300, 100 
       If (dummy="quick-actu")
          showTOOLtip("WARNING: Illegal operation. The destination folder is the same with the initial location:`n" finalDest "\")
       Else
          msgBoxWrapper(appTitle ": WARNING", "Illegal operation. The destination folder is the same with the initial location:`n" finalDest "\", 0, 0, "exclamation")
       Return 0
    }

    BtnCloseWindow()
    Sleep, 2
    destroyGDIfileCache()
    FileGetTime, originalCtime, % file2rem, C
    file2save := finalDest "\" OldOutFileName

    thisFileExists := 0
    forceConflictOption := (dummy="quick-actu") ? QuickFileActConflict : 0
    If (FileExist(file2save) && !FolderExist(file2save))
    {
       thisFileExists := 1
       file2save := askAboutFileCollision(file2rem, file2save, 0, goLastOption + 1, forceConflictOption, performOverwrite)
       If !file2save
       {
          showTOOLtip("WARNING: Another file with the same file name already exists in the destination folder:`n" OldOutFileName "`n" finalDest "\`nOperation aborted.")
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SetTimer, ResetImgLoadStatus, -200
          Return 0
       }
    }

    If (file2save="abort" || !file2save) && (dummy!="quick-actu")
    {
       If (UsrCopyMoveOperation!=2)
          SetTimer, InvokeCopyFiles, -150
       Else
          SetTimer, PanelMoveCopyFiles, -150
       Return 0
    }

    If (thisFileExists=1)
    {
       If (performOverwrite=1)
       {
          FileSetAttrib, -R, %file2save%
          Sleep, 5
          FileRecycle, %file2save%
          Sleep, 5
          mustPerformOperation := 1
       } Else If (performOverwrite!=2)
       {
          showTOOLtip("Operation aborted. A file with the same name already exists in the destination folder.`n" OldOutFileName "`n" finalDest "\")
          SoundBeep, 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SetTimer, ResetImgLoadStatus, -25
          Return
       } Else mustPerformOperation := 1
    } Else mustPerformOperation := 1

    If (mustPerformOperation=1)
    {
       operationExecuted := 1
       If (UsrCopyMoveOperation=2)
          FileMove, %file2rem%, %file2save%
       Else
          FileCopy, %file2rem%, %file2save%
       If ErrorLevel
          wasError := 1
    }

    If (wasError!=1 && operationExecuted=1)
    {
       updateDates := 1
       If (originalMtime)
       {
          FileSetTime, % originalMtime, % file2save, M
          FileSetTime, % originalCtime, % file2save, C
          updateDates := 0
       }

       If (dummy!="quick-actu")
       {
          prevFileMovePath := finalDest
          INIaction(1, "prevFileMovePath", "General")
          RecentCopyMoveManager(finalDest)
       }

       actName := (UsrCopyMoveOperation=2) ? "MOVED" : "COPIED"
       zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
       showTOOLtip("File " actName " to`n" OldOutFileName "`n" finalDest "\")
       If (UsrCopyMoveOperation=2)
       {
          resultedFilesList[currentFileIndex, 1] := file2save
          updateMainUnfilteredList(currentFileIndex, 1, file2save)
          If (SLDtypeLoaded=3)
             updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[currentFileIndex, 12])
       }
       Sleep, 1
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -25
       Return 1
    } Else If (operationExecuted=1)
    {
       actName := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
       showTOOLtip("ERROR: Failed to " actName " file:`n" OldOutFileName "To destination:`n" finalDest "\")
       SoundBeep, 300, 100
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -25
    Return 0
}

determineCreateFileGroupFolder(oFinalDest, originalMtime, OutFileExt) {
   If ((InStr(oFinalDest, "[group-by-month-year]") && originalMtime)
   || (InStr(oFinalDest, "[group-by-file-types]") && OutFileExt)
   || (InStr(oFinalDest, "[group-by-years]") && originalMtime))
   {
      FormatTime, grouper, % originalMtime, yyyy-MM-MMMM
      FormatTime, groupery, % originalMtime, yyyy
      finalDest := StrReplace(oFinalDest, "[group-by-month-year]", grouper)
      finalDest := StrReplace(finalDest, "[group-by-file-types]", OutFileExt)
      finalDest := StrReplace(finalDest, "[group-by-years]", groupery)
      If !FolderExist(finalDest)
      {
         FileCreateDir, % finalDest
         Sleep, 2
      }
   } Else finalDest := oFinalDest 
   Return FinalDest
}

batchCopyMoveFile(finalDest, groupingMode:=0, dummy:=0) {
   Static lastInvoked := 1
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>150) ; ((A_TickCount - lastInvoked > 29500) && dummy!="quick-actu")
   {
      wording := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to " wording " the selected files.`n`nSelected " groupDigits(filesElected) " files`nDestination: " finalDest "\", 4, 0, "question")
      If (msgResult!="Yes")
         Return 0
   }

   BtnCloseWindow()
   lastInvoked := A_TickCount
   friendly := (UsrCopyMoveOperation=2) ? "Moving " : "Copying "
   showTOOLtip(friendly groupDigits(filesElected) " files to`n" finalDest "\`nPlease wait")
   If (dummy!="quick-actu")
   {
      prevFileMovePath := finalDest
      RecentCopyMoveManager(finalDest)
   }

   destroyGDIfileCache()
   Sleep, 25
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   countTFilez := filezMoved := failedFiles := skippedFiles := 0
   oFinalDest := finalDest
   forceConflictOption := (dummy="quick-actu") ? QuickFileActConflict : 0
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      changeMcursor()
      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
      countTFilez++
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If (OldOutDir=finalDest)
      {
         skippedFiles++
         Continue
      }

      FileGetTime, originalMtime, % file2rem, M
      FileGetTime, originalCtime, % file2rem, C
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"
         If (failedFiles>0)
            etaTime .= "`nFailed to perform action on " groupDigits(failedFiles) " files"

         showTOOLtip(friendly " files to`n" finalDest "\" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      ; grouper := ""
      If (groupingMode=1)
         finalDest := determineCreateFileGroupFolder(oFinalDest, originalMtime, OutFileExt)

      file2save := finalDest "\" OldOutFileName
      thisFileExists := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
      {
         thisFileExists := 1
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, forceConflictOption, performOverwrite)
      }
  
      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }
  
      If (thisFileExists=1)
      {
         If (performOverwrite=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 2
            FileRecycle, %file2save%
            Sleep, 2
            mustPerformOperation := 1
         } Else If (performOverwrite!=2)
         {
            skippedFiles++
            Continue
         } Else mustPerformOperation := 1
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (UsrCopyMoveOperation=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         updateDates := 1
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
            updateDates := 0
         }

         filezMoved++
         ; zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
         If (UsrCopyMoveOperation=2)
         {
            resultedFilesList[thisFileIndex, 1] := file2save
            ; resultedFilesList[thisFileIndex, 2] := 1
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[thisFileIndex, 12])

            updateMainUnfilteredList(thisFileIndex, 1, file2save)
         }
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         someErrors .= "`nFailed to commit changes to the SQL database"
   }

   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped"
   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " failedFiles " files"

   watchFolderDetails := ""
   If (UsrCopyMoveOperation=2)
      currentFilesListModified := 1

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (UsrCopyMoveOperation=2)
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   Return 0
}

batchConvert2format() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to convert " groupDigits(filesElected) " files to the ." rDesireWriteFMT " format ? "
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      If (userActionConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."
      If (OnConvertKeepOriginals!=1)
         msgInfos .= "`n`nThe original files will be ERASED."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
   BtnCloseWindow()
   setImageLoading()
   showTOOLtip("Converting to ." rDesireWriteFMT " format " groupDigits(filesElected) " files, please wait")

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>2) ? 1 : 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresConvertFormat(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("JPEG lossless processing: failed to initialize multi-threaded processing")

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   initFIMGmodule()
   skipDeadFiles := theseFailures := failedFiles := countTFilez := filesConverted := 0
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If (RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") || InStr(imgPath, "||") || !imgPath)
      {
         skippedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to convert " groupDigits(failedFiles) " files"
         If (theseFailures>0)
            etaTime .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip("Converting to ." rDesireWriteFMT " format, please wait" etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      countTFilez++
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If !file2save
      {
         skippedFiles++
         Continue
      }

      changeMcursor()
      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         filesConverted++

      If (OnConvertKeepOriginals!=1 && !r)
      {
         FileSetAttrib, -R, % imgPath
         Sleep, 2
         FileRecycle, % imgPath
         If ErrorLevel
            theseFailures++

         resultedFilesList[thisFileIndex, 1] := file2save
         ; resultedFilesList[thisFileIndex, 2] := 1
         updateMainUnfilteredList(thisFileIndex, 1, file2save)
         If (SLDtypeLoaded=3)
            updateSQLdbEntry(imgPath, file2save, 1, resultedFilesList[thisFileIndex, 12])
      }
   }

   currentFilesListModified := 1
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   }

   If (failedFiles>0)
      someErrors := "`nFailed to convert " groupDigits(failedFiles) " files"
   If (theseFailures>0)
      someErrors .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files were converted to ." rDesireWriteFMT " until now" someErrors)
   Else
      showTOOLtip("Finished converting to ." rDesireWriteFMT " format`n" groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

coreConvertImgFormat(imgPath, file2save) {
   If (PreserveDateTimeOnSave=1)
   {
      ; fnOutputDebug("got original date")
      FileGetTime, originalMtime, % imgPath, M
      FileGetTime, originalCtime, % imgPath, C
   }

   maxLimitReached := 0 ; (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
   If (FIMfailed2init=1 || maxLimitReached=1)
   {
      If FileExist(file2save)
         FileSetAttrib, -R, %file2save%

      pBitmap := LoadBitmapFromFileu(imgPath)
      If StrLen(pBitmap)<3
         Return -1

      rawFmt := Gdip_GetImageRawFormat(pBitmap)
      If (rawFmt="JPEG")
         RotateBMP2exifOrientation(pBitmap)

      changeMcursor()
      r := Gdip_SaveBitmapToFile(pBitmap, file2save, 90)
      trGdip_DisposeImage(pBitmap, 1)
      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
         ; fnOutputDebug("original date ... set")
      } ; Else fnOutputDebug("set original date skipped...  " PreserveDateTimeOnSave "  ---  " r "  ---  " originalMtime "  -- fim-fail  " FIMfailed2init " ")
   } Else
   {
      loadArgs := 0
      GFT := FreeImage_GetFileType(imgPath)
      If (GFT=34)
         loadArgs := (userHQraw=1) ? 0 : 5
      Else If (GFT=2)
         loadArgs := 8

      hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
      If !hFIFimgA
         Return -1

      imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
      ColorsType := FreeImage_GetColorType(hFIFimgA)
      mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba")) || (imgBPP>64) ? 1 : 0
      If (mustApplyToneMapping=1)
      {
         ; setWindowTitle("Applying adaptive logarithmic tone mapping to display high color depth image")
         changeMcursor()
         hFIFimgB := FreeImage_ToneMapping(hFIFimgA, 0, 1.85, 0)
      }

      hFIFimgC := hFIFimgB ? hFIFimgB : hFIFimgA
      If (FileExist(file2save) && hFIFimgC)
      {
         Try FileSetAttrib, -R, % file2save
         Sleep, 1
         FileMove, % file2save, % file2save "-tmp"
         If !ErrorLevel
            tempFileExists := 1

         Sleep, 1
      }

      saveArg := 0
      If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
         saveArg := clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
      Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
         saveArg := clampInRange(Round(userJpegQuality), 1, 100)

      imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgC), "-"))
      If (RegExMatch(file2save, "i)(.\.(gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|wbm|xpm))$") && hFIFimgC)
      {
         changeMcursor()
         hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "24Bits")
         changeMcursor()
         r := FreeImage_Save(hFIFimgD, file2save, saveArg)
         FreeImage_UnLoad(hFIFimgD)
      } Else If hFIFimgC
      {
         r := FreeImage_Save(hFIFimgC, file2save, saveArg)
         If (!r && imgBPP!=32)
         {
            FileDelete, % file2save
            Sleep, 1
            changeMcursor()
            hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "32Bits")
            changeMcursor()
            r := FreeImage_Save(hFIFimgD, file2save, saveArg)
            FreeImage_UnLoad(hFIFimgD)
          }
      }

      FreeImage_UnLoad(hFIFimgA)
      FreeImage_UnLoad(hFIFimgB)
      If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
      {
         r := 0
         FileDelete, % file2save
         Sleep, 1
         FileMove, % file2save "-tmp", % file2save
      } Else If (tempFileExists=1)
         FileDelete, % file2save "-tmp"

      r := !r
      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
         ; fnOutputDebug("original date ... set")
      } ; Else fnOutputDebug("set original date skipped...  " PreserveDateTimeOnSave "  ---  " r "  ---  " originalMtime " ")
   }
   Return r
}

convert2format() {
  Critical, on
  If (currentFileIndex=0)
     Return "err"

  If (slideShowRunning=1)
     ToggleSlideShowu()

  file2rem := getIDimage(currentFileIndex)
  If RegExMatch(file2rem, "i)(.\.(" rDesireWriteFMT "))$")
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "The image file seems to be already in the given file format: ." rDesireWriteFMT ". Please choose another format.", 0, 0, "exclamation")
     Return "err"
  }

  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If FileExist(file2save)
  {
     ToolTip
     zPlitPath(file2save, 0, OutFileName, OutDir)
     msgResult := msgBoxWrapper(appTitle ": Confirmation", "A file with the same name already exists in the destination folder... Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
     forceOverwrite := (msgResult="Yes") ? 1 : 0
     If !forceOverwrite
        Return
  }

  BtnCloseWindow()
  destroyGDIfileCache()
  Sleep, 1
  setImageLoading()
  showTOOLtip("Converting image file, please wait")
  If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
     FileCreateDir, % ResizeDestFolder

  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If FileExist(file2save)
     FileSetAttrib, -R, %file2save%

  r := coreConvertImgFormat(file2rem, file2save)
  SetTimer, ResetImgLoadStatus, -50
  If r
     showTOOLtip("Failed to convert file`n" OutFileName "`n" OutDir "\")
  Else
     showTOOLtip("File converted succesfully to ." rDesireWriteFMT "`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\")

  SoundBeep, % r ? 300 : 900, 100
  If (OnConvertKeepOriginals!=1 && !r)
  {
     Try FileSetAttrib, -R, %file2rem%
     Sleep, 1
     FileRecycle, %file2rem%
     If ErrorLevel
        showTOOLtip("Failed to remove original file, however the file was converted succesfully to ." rDesireWriteFMT "`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\")

     resultedFilesList[currentFileIndex, 1] := file2save
     resultedFilesList[currentFileIndex, 4] := 1
     If (SLDtypeLoaded=3)
        updateSQLdbEntry(file2rem, file2save, 1, resultedFilesList[currentFileIndex, 12])

     updateMainUnfilteredList(currentFileIndex, 1, file2save)
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

OpenFolders(dummy:=0) {
   If (AnyWindowOpen || imageLoading=1)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If FolderExist(dummy)
      SelectedDir := dummy
   Else
      SelectedDir := openFoldersDialogWrapper(2, prevOpenFolderPath, "Select the folder to open recursively")

   If (SelectedDir)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return

      If askAboutSlidesListSave()
         Return

      newStaticFoldersListCache := []
      prevOpenFolderPath := StrReplace(SelectedDir, "|")
      INIaction(1, "prevOpenFolderPath", "General")
      coreOpenFolder(SelectedDir, 1, 1, 1)
      If (maxFilesIndex>0)
         SLDtypeLoaded := 1
      ; Else resetMainWin2Welcome()
   }
}

openFoldersDialogWrapper(optionz, startPath, msg:="") {
   Static defaultu := "<Use current folder>"
   doSuspendu(1)
   thisHwnd := (AnyWindowOpen>0) ? hSetWinGui : PVhwnd
   entriesList := defaultu "`n" recentOpenedFolders()
   r := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, entriesList, 1, "History", entriesList)
   If (!InStr(r.SelectedCombo, defaultu) && StrLen(r.SelectedCombo)>3)
      z := r.SelectedCombo
   Else If StrLen(r.SelectedDir)>4
      z := r.SelectedDir

   SetTimer, dummyUnSuspendu, -150, 900
   lastLongOperationAbort := A_TickCount
   Return z
}

renewCurrentFilesList() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
   }

   prevRandyIMGs := []
   resultedFilesList := []
   lastRenameUndo := []
   prevLastImg := []
   markedSelectFile := EntryMarkedMoveIndex := maxFilesIndex := 0
   lastZeitFileSelect := editingSelectionNow := prevRandyIMGnow := 0
   ForceRefreshNowThumbsList()
   updateUIctrl()
   currentFileIndex := 1
   prevLoadedImageIndex := ""
   currentImgModified := allImagesWereSeen := 0
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   destroyGDIfileCache()
   discardViewPortCaches()
   disposeCacheIMGs()
   thisSearchString := userSearchString := ""
   terminateIMGediting()
   If hSNDmedia
      StopMediaPlaying()
}

FileExploreUpDownLevel(direction, returnObj:=0, ByRef iLevel:=0, forceLevel:=0) {
   Static thisLevel := 0, prevPathArray := []
   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   oldFolder := baseFolder
   initialLevel := thisLevel
   thisFolder := StrReplace(Trimmer(baseFolder), "|")
   prevMaxLevels := prevPathArray.Length()
   If (prevMaxLevels=thisLevel)
   {
      Loop, Files, % thisFolder "\*", D
      {
         If (A_LoopFileName!="" && A_Index=1)
         {
            thisFolder .= "\" A_LoopFileName
            Break
         }
      }

      If (direction=1)
      {
         Loop, Files, % thisFolder "\*", D
         {
            If (A_LoopFileName!="" && A_Index=1)
            {
               thisFolder .= "\" A_LoopFileName
               Break
            }
         }
      }
   }

   thisFolder := StrReplace(thisFolder, "\\", "\")
   thisFolder := Trimmer(thisFolder, "\")
   folderPathArray := StrSplit(thisFolder, "\")
   maxLevels := folderPathArray.Length()
   Loop, % maxLevels
   {
        If (folderPathArray[A_Index]!=prevPathArray[A_Index])
        {
           thisLevel := 0
           prevPathArray := folderPathArray.Clone()
           Break
        }
   }

   thisParent := SubStr(oldFolder, InStr(oldFolder, "\", 0, -1) + 1)
   If !thisLevel
   {
      Loop, % maxLevels + 1
      {
           If (folderPathArray[A_Index]=thisParent)
           {
              thisLevel := A_Index
              Break
           }
      }
   }

   oldIndex := currentFileIndex
   prevMaxLevels := prevPathArray.Length()
   If (returnObj=1)
   {
      iLevel := thisLevel
      Return prevPathArray
   }

   If (direction=-1)
      thisLevel := clampInRange(thisLevel - 1, 1, prevMaxLevels)
   Else
      thisLevel := clampInRange(thisLevel + 1, 1, prevMaxLevels)

   If forceLevel
      thisLevel := forceLevel

   Loop, % prevMaxLevels
   {
      newFolder .= prevPathArray[A_Index] "\"
      If (A_Index=thisLevel)
         Break
   }

   newFolder := Trimmer(newFolder, "\")
   If (initialLevel!=thisLevel)
      tryOpenGivenFolder(newFolder, oldFolder)
}

FileExploreSiblingsNav(direction, isInLoop:=0, returnObj:=0, ByRef iLevel:=0, forceLevel:=0) {
   Static thisLevel, prevFolder, subFoldersArray := []
   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   initialLevel := thisLevel
   oldFolder := baseFolder
   thisFolder := StrReplace(Trimmer(baseFolder), "|")
   initialSibling := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
   thisFolder := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1) - 1)
   If (thisFolder!=prevFolder)
   {
      subFoldersArray := []
      prevFolder := thisFolder
      Loop, Files, % thisFolder "\*", D
      {
         If (A_LoopFileName=initialSibling)
            thisLevel := A_Index

         If (A_LoopFileName!="")
            subFoldersArray[A_Index] := A_LoopFileName
      }
   }

   oldIndex := currentFileIndex
   maxLevels := subFoldersArray.Count()
   If (maxLevels<2)
   {
      showTOOLtip("No sibling folders found")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (returnObj=1)
   {
      iLevel := thisLevel
      Return subFoldersArray
   }

   If (direction=-1)
      thisLevel := clampInRange(thisLevel - 1, 1, maxLevels, 1)
   Else
      thisLevel := clampInRange(thisLevel + 1, 1, maxLevels, 1)

   If forceLevel
      thisLevel := forceLevel

   If (subFoldersArray[thisLevel]!="")
   {
      newFolder := thisFolder "\" subFoldersArray[thisLevel]
   } Else If (isInLoop<maxLevels)
   {
      isInLoop++
      FileExploreSiblingsNav(direction, isInLoop)
      Return
   } Else
   {
      showTOOLtip("No sibling folders found")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (initialLevel!=thisLevel && FolderExist(newFolder))
   {
      r := tryOpenGivenFolder(newFolder, oldFolder)
      If (r=1)
      {
         subFoldersArray[thisLevel] := ""
         thisLevel := initialLevel
      } Else showDelayedTooltip("Sibling folders navigation: " thisLevel " / " maxLevels "`n.\" subFoldersArray[thisLevel] "\")
   } Else If !FolderExist(newFolder)
   {
      ; subFoldersArray[thisLevel] := ""
      FileExploreSiblingsNav(direction, 1)
   }
}

coreOpenFolder(thisFolder, doOptionals:=1, openFirst:=0, doReset:=0, safeMode:=0) {
   testThis := StrReplace(thisFolder, "|")
   mustOpenStartFolder := ""
   If FolderExist(testThis)
   {
      If (A_TickCount - scriptStartTime>350)
         BtnCloseWindow()

      filesFilter := CurrentSLD := ""
      setWindowTitle("Indexing files, please wait...", 1)
      renewCurrentFilesList()
      ; activeSQLdb.Exec("DELETE FROM images;")
      r := GetFilesList(thisFolder "\*")
      If (maxFilesIndex<1 || !maxFilesIndex) && (safeMode=0)
      {
         If (!CurrentSLD || doReset=1)
            resetMainWin2Welcome()
         Else
            FadeMainWindow()

         showTOOLtip("ERROR: Found no recognized image files in the folder`n" thisFolder "\")
         SoundBeep, 300, 100
         setWindowTitle(appTitle " v" appVersion, 1)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      GenerateRandyList()
      mustGenerateStaticFolders := 1
      DynamicFoldersList := thisFolder "`n"
      CurrentSLD := thisFolder
      watchFolderDetails := ""
      If (safeMode=0)
         RecentFilesManager(CurrentSLD)

      If (r=1)
      {
         clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
         RemoveTooltip()
      } Else SetTimer, RemoveTooltip, % -msgDisplayTime

      If (doOptionals=1)
      {
         If (maxFilesIndex>0 && r!=1)
            RandomPicture()
         Else
            dummyTimerDelayiedImageDisplay(25)
      }
   } Else
   {
      setWindowTitle(appTitle " v" appVersion, 1)
      If (!CurrentSLD || maxFilesIndex<2 || !maxFilesIndex)
         resetMainWin2Welcome()
      Else
         FadeMainWindow()

      showTOOLtip("ERROR: The folder seems to be inexistent`n" testThis "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

addDynamicFolderSQLdb(whichFolder, renewList, whichTable) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM dynamicfolders;")

    folderu := StrReplace(whichFolder, "|")
    If !FolderExist(folderu)
       Return

    FileGetTime, fileMdate, % folderu, M
    SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES ('" SQLescapeStr(whichFolder) "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Return 0
    }
    Return 1
}

addStaticFolderSQLdb(whichFolder, fileMdate, renewList) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM staticfolders;")

    SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES ('" whichFolder "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Sleep, 0
    }
}

RefreshImageFileAction() {
   isThumbMode := (thumbsDisplaying=1 && maxFilesIndex>1) ? 1 : 0
   ; imgPath := getIDimage(currentFileIndex)
   ; If (!useGdiBitmap() && !imgPath && isThumbMode!=1) || !imgPath

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (thumbsDisplaying!=1)
   {
      If throwErrorNoImageLoaded()
         Return

      If InStr(imgPath, "\temporary memory object\")
      {
         showTOOLtip("WARNING: This image is currently unsaved. Unable to refresh object.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If askAboutFileSave(" and the original file will be reloaded")
         Return

      currentImgModified := 0
      discardViewPortCaches()
      terminateIMGediting()
      If (AutoDownScaleIMGs=1)
         AutoDownScaleIMGs := 2

      r := IDshowImage(currentFileIndex, 3)
      If !r
         informUserFileMissing()
      Else If (toolTipGuiCreated!=1)
         showTOOLtip("Image file reloaded")

      thisIMGisDownScaled := 0
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   } Else If (thumbsDisplaying=1)
      RefreshFilesList()
}

RefreshImageFile() {
   ; disposeCacheIMGs()
   r := IDshowImage(currentFileIndex, 3)
   If !r
      informUserFileMissing()
}

RefreshFilesList() {
  If !CurrentSLD
  {
     showTOOLtip("WARNING: No folder or files list index currently opened")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
  {
     retrieveFavesAsList()
     Return
  } Else If InStr(CurrentSLD, "\viewed-images-history-")
  {
     showTOOLtip("The current files list index is: `n" CurrentSLD)
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If RegExMatch(CurrentSLD, sldsPattern)
  {
     If askAboutFileSave(" and the files list will be reloaded")
        Return

     If askAboutSlidesListSave()
        Return

     thisIndex := currentFileIndex
     OpenSLD(CurrentSLD, 1)
     currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
     dummyTimerDelayiedImageDisplay(50)
  } Else If StrLen(CurrentSLD)>3
     RegenerateEntireList()
     ; coreOpenFolder(CurrentSLD)
}

OpenDialogFiles(dummy:=0) {
    Static lastInvoked := A_TickCount
    If (AnyWindowOpen || imageLoading=1) || (A_TickCount - lastInvoked<150)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.sld*)"
    ; pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
    ; pattern .= "|QPV slideshows (*.sld;*.sldb)"

    patternObj := {}
    patternObj["All files"] := "*.*"
    patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
    patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.ico;*.sld*"
    patternObj["QPV slideshows"] := "*.sld;*.sldb"
    If isWinXP
       FileSelectFile, imgPath, 3, % prevOpenFolderPath, Open Image file, % pattern
    Else
       imgPath := openFileDialogWrapper("O1", "-", prevOpenFolderPath, "Open image or slideshow...", patternObj, chosenOption, 3, "open-folder")

    lastInvoked := A_TickCount
    If !imgPath
       Return

    If (askAboutFileSave(" and another image will be loaded") && !InStr(chosenOption, "instance"))
       Return

   zPlitPath(imgPath, 0, OutFileName, SelectedDir)
   If FolderExist(SelectedDir)
   {
      If InStr(chosenOption, "instance")
      {
         If RegExMatch(imgPath, RegExFilesPattern)
            OpenWithNewQPVinstance(0, imgPath, 2)
         Else
            OpenNewQPVinstance(SelectedDir)
         Return
      }

      newStaticFoldersListCache := []
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      lastInvoked := A_TickCount
      If RegExMatch(imgPath, sldsPattern)
      {
         OpenSLD(imgPath)
         Return
      }

      PopulateIndexFilesStatsInfos("kill")
      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      doNotRecursive := InStr(chosenOption, "perform") ? "" : "|"
      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath) && InStr(chosenOption, "selected"))
      {
         SLDtypeLoaded := 1
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg
         MenuOpenLastImg(imgPath)
         currentFilesListModified := 0
      } Else 
      {
         coreOpenFolder(doNotRecursive SelectedDir, 0, 0, 1)
         currentFilesListModified := 0
         If (doNotRecursive && maxFilesIndex<1)
         {
            msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " SelectedDir "\ to open without recursive scanning. QPV found no supported image files in the folder.`n`nWould you like to recursively scan the given folder for supported image files?", 4, 0, "question")
            If (msgResult="Yes")
               coreOpenFolder(SelectedDir, 0, 0, 1)
         }
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         If FileRexists(imgPath)
         {
            currentFileIndex := detectFileID(imgPath)
            If (allowRecordHistory=1)
               IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

            IDshowImage(currentFileIndex)
         } Else If OutFileName
         {

            FriendlyName := FileExist(imgPath) ? "malformed" : "inexistent"
            msgBoxWrapper(appTitle ": ERROR", "Error opening file: " OutFileName ". It seems to be " FriendlyName " .`n`nAnother file from the folder will be displayed now. Files indexed: " groupDigits(maxFilesIndex) ".", 0, 0, "error")
            RandomPicture()
         }
      } Else If (maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         RandomPicture()
      } ; Else resetMainWin2Welcome()
   }
   lastInvoked := A_TickCount
}

askAboutSlidesListSave() {
   Static lastInvoked := 1, prevAnswer
   If (A_TickCount - lastInvoked<300)
      Return prevAnswer

   r := 0
   If (currentFilesListModified=1 && RegExMatch(CurrentSLD, "i)(.\.sld)$") && FileExist(CurrentSLD) && maxFilesIndex>1 && SLDtypeLoaded=2)
   || (currentFilesListModified=1 && maxFilesIndex>1 && InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      msgResult := msgBoxWrapper(appTitle ": Save files list", "The currently opened files list has been modified and the changes have not been saved. To continue with the action you chose, select the Discard button.`n`nWould like to save the currently opened files list?", "&Save|&Discard|&Cancel", 0, "question")
      If (msgResult="Save")
      {
         ; If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
         ;    renewFavesListBasedOnIndexList()
         ; Else
            SetTimer, PanelSaveSlideShowu, -150
         r := 1
      } Else If (msgResult="Discard")
         r := 0
      Else ; If (msgResult="Ok")
         r := 1

      lastInvoked := A_TickCount
   }

   prevAnswer := r
   Return r
}

askAboutFileSave(msg:="", lvls:=1, dummy:=0) {
   Static lastInvoked := 1, prevAnswer
   lvls := (minimizeMemUsage=1 || A_PtrSize=4) ? 1 : 2
   If (preventUndoLevels=1)
      lvls := -1

   If (StrLen(UserMemBMP)>3 && undoLevelsRecorded>lvls && currentImgModified=1) && (A_TickCount - lastInvoked<300)
      Return prevAnswer

   r := 0
   If (StrLen(UserMemBMP)>3 && undoLevelsRecorded>lvls && currentImgModified=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      msgResult := msgBoxWrapper(appTitle ": Save image", "The currently modified image is about to be discarded" msg ".`n`nWould you like to save the current image?", "&Save|&Discard|&Cancel", 0, "question")
      If (msgResult="Save")
      {
         SetTimer, PanelSaveImg, -150
         r := 1
      } Else If (msgResult="Discard")
         r := 0
      Else ; If (msgResult="Ok")
         r := 1

      lastInvoked := A_TickCount
   }

   prevAnswer := r
   Return r
}

MenuOpenLastImg(forceOpenGiven:=0) {
   If (thumbsDisplaying=1)
   {
      MenuDummyToggleThumbsMode()
      Sleep, 25
   }

   If !FileRexists(forceOpenGiven)
   {
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      LastOpenedImg := Trimmer(LastOpenedImg)
   } Else LastOpenedImg := Trimmer(forceOpenGiven)

   If RegExMatch(LastOpenedImg, RegExFilesPattern) && FileRexists(LastOpenedImg)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return

     If askAboutSlidesListSave()
        Return

      If (thumbsDisplaying=1)
         ToggleThumbsMode()

      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      PopulateIndexFilesStatsInfos("kill")
      renewCurrentFilesList()
      setImageLoading()
      currentFileIndex := maxFilesIndex := 1
      resultedFilesList[1, 1] := LastOpenedImg
      IDshowImage(currentFileIndex)
      zPlitPath(LastOpenedImg, 0, OutFileName, OutDir)
      DynamicFoldersList := OutDir "`n"
      prevOpenFolderPath := OutDir
      CurrentSLD := "|" OutDir
      SLDtypeLoaded := 1
      currentFilesListModified := 0
      interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
      interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
      updateUIctrl()
      INIaction(1, "prevOpenFolderPath", "General")
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
      winPrefix := defineWinTitlePrefix()
  
      SetTimer, GDIupdaterResize, Off
      mustOpenStartFolder := OutDir
      ; currentFileIndex := detectFileID(LastOpenedImg)
      pVwinTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
      setWindowTitle(pVwinTitle, 1)
      SetTimer, RemoveTooltip, -250
      SetTimer, ResetImgLoadStatus, -50
      If (RegExMatch(OutFileName, "i)(\.gif)$") && totalFramesIndex>1 && animGIFsSupport=1)
      {
         animGIFplaying := 0
         allowNextSlide := 1
         prevAnimGIFwas := ""
         dummyTimerDelayiedImageDisplay(250)
      }
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   }
}

OpenArgFile(inputu) {
    setImageLoading()
    Global scriptStartTime := A_TickCount
    currentFileIndex := maxFilesIndex := 1
    interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
    interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)

    ; usrColorDepth := imgFxMode := 1
    ; vpIMGrotation := FlipImgH := FlipImgV := 0
    resultedFilesList[1, 1] := inputu
    IDshowImage(currentFileIndex)
    Global scriptStartTime := A_TickCount
    zPlitPath(inputu, 0, OutFileName, OutDir)
    DynamicFoldersList := OutDir "`n"
    zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
    winPrefix := defineWinTitlePrefix()

    SetTimer, GDIupdaterResize, Off
    mustOpenStartFolder := OutDir
    ; coreOpenFolder("|" OutDir, 0)
    Global scriptStartTime := A_TickCount
    ; currentFileIndex := detectFileID(inputu)
    winTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
    setWindowTitle(winTitle, 1)
    SetTimer, RemoveTooltip, -250
    SetTimer, ResetImgLoadStatus, -50
    CurrentSLD := "|" OutDir
    prevOpenFolderPath := OutDir
    INIaction(1, "prevOpenFolderPath", "General")
    If (allowRecordHistory=1 && FileRexists(inputu))
       IniWrite, % inputu, % mainSettingsFile, General, LastOpenedImg

    updateUIctrl()
    SLDtypeLoaded := 1
    If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
       CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)

    ; Else resetMainWin2Welcome()
    ; IDshowImage(currentFileIndex)
}

addNewFile2list() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ")"
   pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
   If (SLDtypeLoaded!=3)
      pattern .= "|QPV slideshows plain-text (*.sld)"

   imgsListu := openFileDialogWrapper("M", "AllowMultiSelect FileMustExist", prevOpenFolderPath, "Add image file(s) to the list...", pattern, null, 1)
   If !imgsListu
      Return "cancel"

   If AnyWindowOpen
      BtnCloseWindow()
   Sleep, 25
   If askAboutFileSave(" and the selected file(s) will be added to the list")
      Return

   showTOOLtip("Processing files list, please wait")
   setImageLoading()
   If InStr(imgsListu, "`n")
      firstFile := Trimmer(SubStr(imgsListu, 1, InStr(imgsListu, "`n")))
   Else
      firstFile := Trimmer(imgsListu)

   zPlitPath(firstFile, 0, OutFileName, SelectedDir)
   countFiles := ST_Count(imgsListu, "`n") + 1
   ; msgbox, % firstFile "a`n" countFiles "`n" imgsListu
   If StrLen(SelectedDir)>3
   {
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
   }

   If (RegExMatch(firstFile, "i)(.\.sld)$") && SLDtypeLoaded!=3)
   {
      If StrLen(filesFilter)>1
      {
         markedSelectFile := 0
         showTOOLtip("Deactivating the files list filter, please wait")
         remFilesListFilter("simple")
         Sleep, 10
         RemoveTooltip()
      }

      mustOpenStartFolder := ""
      showTOOLtip("Importing slideshow file, please wait`n" OutFileName "`n" SelectedDir "\")
      If (SLDtypeLoaded=2)
         DynamicFoldersList := getDynamicFoldersList()

      FileReadLine, firstLine, % firstFile, 1
      mustRemQuotes := InStr(firstLine, "[General]") ? 0 : 1
      If !mustRemQuotes
      {
         IniRead, testDynaFolderz, % firstFile, DynamicFolderz, DF1, @
         If StrLen(testDynaFolderz)>4
            DynamicFoldersList .= "`n" coreLoadDynaFolders(firstFile)
      }

      Sort, DynamicFoldersList, UD`n
      res := sldGenerateFilesList(firstFile, 0, mustRemQuotes, 0)
      SoundBeep , 900, 100
      currentFilesListModified := 1
      GenerateRandyList()
      RandomPicture()
   } Else If StrLen(imgsListu)>3
   {
      showTOOLtip("Processing files list, please wait")
      setImageLoading()
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir)
      GenerateRandyList()
      currentFileIndex := maxFilesIndex - 1
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(50)
   }

   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

coreAddNewFiles(imgsListu, countFiles, SelectedDir, selectNewOnes:=0) {
    If CurrentSLD
       dropFilesSelection(1)

    showTOOLtip("Adding " countFiles " files into the current files list")
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    Loop, Parse, imgsListu, `n`r
    {
       line := Trimmer(A_LoopField)
       If StrLen(line)<3
          Continue

       changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          If (SLDtypeLoaded=3 && maxFilesIndex>0)
          {
             zPlitPath(line, 1, OutFileName, OutDir)
             erru := addSQLdbEntry(OutFileName, OutDir, 0, 0, 0, 1)
          }

          If !erru
          {
             added++
             maxFilesIndex++
             If (selectNewOnes=1)
                markedSelectFile++

             resultedFilesList[maxFilesIndex] := [line, selectNewOnes]
             If (SLDtypeLoaded=3 && maxFilesIndex>0)
                resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
          }
       }

    }
    If added
       currentFilesListModified := 1

    If (!CurrentSLD && maxFilesIndex>0)
       CurrentSLD := SelectedDir "\newFile.SLD"

    mustOpenStartFolder := ""
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

addNewFolder2list() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   SelectImg := openFoldersDialogWrapper("S2", prevOpenFolderPath, "Add new folder(s) to the list")
   If !Trim(SelectImg)
      Return "cancel"
   SelectedDir := Trimmer(SelectImg)
   If SelectedDir
   {
      If askAboutFileSave(" and new files will be added from the selected folder")
         Return

      If InStr(DynamicFoldersList, SelectedDir "`n")
      {
         msgResult := msgBoxWrapper(appTitle, "The folder you want to add, seems to be already indexed. Are you sure you want to add it again? This action will likely lead to duplicate entries in the list.`n`n" SelectedDir "\", 4, 0, "question")
         If (msgResult!="yes")
            Return "cancel"
      }

      msgResult := msgBoxWrapper(appTitle, "Do you want to scan for image files recursively, through all its subfolders?`n`n" SelectedDir "\", 3, 0, "question")
      If (msgResult="no")
         isRecursive := "|"
      Else If (msgResult="cancel")
         Return "cancel"

      BtnCloseWindow()
      mustOpenStartFolder := ""
      Sleep, 1
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      coreAddNewFolder(isRecursive SelectedDir, 1)
      If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=2)
      {
         FileReadLine, firstLine, % CurrentSLD, 1
         If (!InStr(firstLine, "[General]") || SLDcacheFilesList!=1)
            good2go := "null"
      } Else good2go := "null"
      If (SLDtypeLoaded=3)
         good2go := 0

      modus := isRecursive ? 1 : 0
      If (mustGenerateStaticFolders=0 && good2go!="null" && RegExMatch(CurrentSLD, sldsPattern))
         updateCachedStaticFolders(SelectedDir, modus)
      Else mustGenerateStaticFolders := 1

      listu := DynamicFoldersList "`n" isRecursive SelectedDir "`n"
      Sort, listu, UD`n
      DynamicFoldersList := listu
      If (SLDtypeLoaded=3)
         recreateDynaFoldersSQLdbList(listu)

      If !CurrentSLD
      {
         CurrentSLD := SelectedDir "\newFile.SLD"
         RandomPicture()
      }
   }
}

coreAddNewFolder(SelectedDir, remAll, noRandom:=0, forReal:=1) {
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    thisFolder := (remAll=1) ? StrReplace(SelectedDir, "|") : SelectedDir
    If (forReal=0 && SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    remFilesFromList(thisFolder, 1, forReal)
    GetFilesList(SelectedDir "\*")
    GenerateRandyList()
    SoundBeep, 900, 100
    CurrentSLD := backCurrentSLD
    If (noRandom=1)
    {
       currentFileIndex := maxFilesIndex - 1
       IDshowImage(currentFileIndex)
    } Else RandomPicture()
}

detectFileID(imgPath) {
    Loop, % maxFilesIndex + 1
    {
       If (resultedFilesList[A_Index, 1]=imgPath)
       {
          good := A_Index
          Break
       }
    }
    If !good
       good := 1

    Return good
}

GuiDroppedFiles(imgsListu, foldersListu, sldFile, countFiles, isCtrlDown) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<900)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   lastInvoked := A_TickCount
   If (imgsListu && isCtrlDown=1)
   {
      OpenWithNewQPVinstance(0, imgsListu, countFiles)
      Return
   }

   If sldFile
   {
      OpenSLD(sldFile)
      lastInvoked := A_TickCount
      Return
   }

   If (CurrentSLD && maxFilesIndex>1 && StrLen(foldersListu)>3)
      msgResult := msgBoxWrapper(appTitle ": Import files", "Would you like to import the dropped folder(s) to the current files list?", "&Import|&New list|&Cancel", 1, "question")

   If (msgResult="cancel")
   {
      lastInvoked := A_TickCount
      Return
   } Else If InStr(msgResult, "new")
   {
      mainFoldersListu := CurrentSLD := DynamicFoldersList := ""
      renewCurrentFilesList()
      AnyWindowOpen := 1000
      resetMainWin2Welcome()
      AnyWindowOpen := ""
   }

   updateUIctrl()
   If StrLen(foldersListu)>3
   {
      mustOpenStartFolder := ""
      mainFoldersListu := getDynamicFoldersList()
      doStartLongOpDance()
      dropFilesSelection(1)
      showTOOLtip("Opening folders, please wait")
      If StrLen(filesFilter)>1
         remFilesListFilter("simple")

      Loop, Parse, foldersListu,`n
      {
          linea := Trimmer(A_LoopField)
          If StrLen(linea)<4
             Continue

          changeMcursor()
          warningMsg := 0
          Loop, Parse, mainFoldersListu, `n
          {
              line := Trimmer(A_LoopField)
              If StrLen(line)<4
                 Continue

              If (line=linea)
                 warningMsg := 1
          }

          If (warningMsg=1)
             Continue

          stuffAdded := 1
          GetFilesList(linea "\*")
          DynamicFoldersList .= linea "`n"
          lastOne := linea
          If (SLDtypeLoaded=3)
             addDynamicFolderSQLdb(linea, 0, "dynamicfolders")
      }

      If (stuffAdded=1)
      {
         Sort, DynamicFoldersList, UD`n
         newStaticFoldersListCache := []
         mustGenerateStaticFolders := 1
         GenerateRandyList()
      }

      If !CurrentSLD
      {
         If FolderExist(StrReplace(Trimmer(DynamicFoldersList), "|"))
         {
            SLDtypeLoaded := 1
            CurrentSLD := Trimmer(DynamicFoldersList)
         } Else
         {
            SLDtypeLoaded := 2
            CurrentSLD := lastOne "\newFile.SLD"
         }
      }
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      RandomPicture()
   } Else If (imgsListu && countFiles=1 && !CurrentSLD)
   {
      imgPath := Trimmer(imgsListu)
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      If !OutDir
      {
         lastInvoked := A_TickCount
         Return
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath))
      {
         SLDtypeLoaded := 1
         lastInvoked := A_TickCount
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

         MenuOpenLastImg(imgPath)
         lastInvoked := A_TickCount
         Return
      }

      showTOOLtip("Opening file`n" imgPath)
      newStaticFoldersListCache := []
      dropFilesSelection(1)
      If StrLen(filesFilter)>1
         remFilesListFilter("simple")

      If !InStr(msgResult, "new")
      {
         prevMaxFilesIndex := maxFilesIndex
         prevFoldersDyna := DynamicFoldersList
         bckpResultedFilesList := resultedFilesList.Clone()
      }

      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      coreOpenFolder("|" OutDir, 0)
      If prevMaxFilesIndex
      {
         DynamicFoldersList .= prevFoldersDyna
         Loop, % prevMaxFilesIndex
         {
             r := bckpResultedFilesList[A_Index, 1]
             If (r && !InStr(r, "||"))
             {
                maxFilesIndex++
                resultedFilesList[maxFilesIndex, 1] := r
             }
         }
         bckpResultedFilesList := []
      }

      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         currentFileIndex := detectFileID(imgPath)
         IDshowImage(currentFileIndex)
      } Else resetMainWin2Welcome()
   } Else If StrLen(imgsListu)>3
   {
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, prevOpenFolderPath)
      mustGenerateStaticFolders := 1
      GenerateRandyList()
      SetTimer, ResetImgLoadStatus, -50
      If (A_TickCount - lastInvoked>2000)
         SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      currentFileIndex := maxFilesIndex
      dummyTimerDelayiedImageDisplay(50)
   }
   lastInvoked := A_TickCount
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyPrevShowToolTip() {
   showTOOLtip("nully")
}

dummyDelayShowToolTip() {
   showTOOLtip(delayiedHUDmsg, 0, 0, delayiedHUDperc)
}

showDelayedTooltip(msg, perc:=0, delayu:=450, expire:=0) {
    delayiedHUDmsg := msg
    delayiedHUDperc := perc
    SetTimer, dummyDelayShowToolTip, % -delayu
    expire := (expire<100) ? msgDisplayTime + delayu : expire + delayu
    SetTimer, RemoveTooltip, % -expire
}

showTOOLtip(msg, l:=0, z:=0, perc:=0) {
   Critical, on
   Static prevMsg
   If (msg="nully" && prevMsg)
      msg := prevMsg

   prevMsg := msg
   If (noTooltipMSGs=0 || thumbsDisplaying=1)
   {
      CreateOSDinfoLine(msg, 0, 0, perc)
      If (AnyWindowOpen>0 && WinActive("A")=hSetWinGui)
      {
         GetPhysicalCursorPos(mX, mY)
         ToolTip, % msg, % mX + 25, % mY + 25
      } Else If (AnyWindowOpen>0)
         ToolTip
   } Else
   {
      msg := StrReplace(msg, "`n", "  ")
      setWindowTitle(msg, 1)
   }
}

RemoveTooltip() {
   Tooltip
   lastOSDtooltipInvoked := 1
   CreateOSDinfoLine(1, 1)
   If (noTooltipMSGs=1)
   {
      clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
      winTitle := (CurrentSLD) ? pVwinTitle : appTitle
      setWindowTitle(winTitle, 1)
   }
}

PanelAssociateQPV() {
   fakeWinCreator(52, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Associate " appTitle, "Please choose what to associate " appTitle " with.", "&Proceed|C&ancel", 1, "settings", "Add file explorer context menu entry for folders: Open in QPV", 0, "Associate with common image formats`f`fAssociate with all supported image formats`fAssociate with QPV slideshow / files list formats`fRemove QPV files associations`fDo not change files associations", 0, 0)
   If InStr(msgResult.btn, "Proceed")
   {
      If !A_IsCompiled
      {
         msgBoxWrapper(appTitle ": ERROR", "This feature is only available when this application is compiled.", 0, 0, "error")
         Return
      }

      associateWithImages(msgResult.list)
      If (msgResult.check=1)
         associateWithExplorer(1)
      Else
         associateWithExplorer(3)
   }
}

associateWithExplorer(modus) {
   Static q := Chr(34)
   zPlitPath(fullPath2exe, 0, OutFileName, OutDir)
   Cmd := q fullPath2exe q A_Space q "%1" q
   Cmd := StrReplace(Cmd, "\", "\\")
   Cmd := StrReplace(Cmd, """", "\""")

   regFile := "Windows Registry Editor Version 5.00`n`n"
   If (modus=1)
   {
      regFile .= "[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer]`n""Icon""=" q StrReplace(fullPath2exe, "\", "\\") q "`n"
      regFile .= "@=""Open in QPV""`n"
      regFile .= "[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer\Command]`n"
      regFile .= "@=""\" q StrReplace(fullPath2exe, "\", "\\") "\"" fd=|\""%1\" q q "`n"
   } Else If (modus=3) ; remove explorer context menu
   {
      regFile .= "[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer]`n"
   } Else If (modus=4) ; remove file associations
   {
      regFile .= "[-HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "]`n"
      regFile .= "[-HKEY_CLASSES_ROOT\QPVslideshow]`n"
      regFile .= "[-HKEY_LOCAL_MACHINE\Software\Classes\QPVslideshow]`n"
      allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")
      Loop, Parse, allFormats, |
      {
         If !A_LoopField
            Continue

         regFile .= "[-HKEY_CLASSES_ROOT\QPVimage." A_LoopField "]`n"
         regFile .= "[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\QPVimage." A_LoopField "]`n"
      }
   } Else
   {
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "]`n" q "FriendlyAppName""=" q appTitle q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell]`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell\open]`n" q "FriendlyAppName""=" q appTitle q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell\open\command]`n@=" q Cmd q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\SupportedTypes]`n"
      allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")
      Loop, Parse, allFormats, |
      {
         If !A_LoopField
            Continue

         regFile .= q "." A_LoopField q "=" q q "`n"
      }
   }

   If !FolderExist(mainCompiledPath "\regFiles")
   {
      FileCreateDir, %mainCompiledPath%\regFiles
      If ErrorLevel
         errorOccured := 1

      Sleep, 1
   }

   FileDelete, %mainCompiledPath%\regFiles\RegExplGeneral.reg
   FileDelete, %mainCompiledPath%\regFiles\runThis.bat
   Sleep, 1
   FileAppend, % regFile, %mainCompiledPath%\regFiles\RegExplGeneral.reg, UTF-16
   If ErrorLevel
      errorOccured := 1

   runTarget := "Reg Import " q mainCompiledPath "\regFiles\RegExplGeneral.reg" q "`n"
   FileAppend, % runTarget, %mainCompiledPath%\regFiles\runThis.bat
   If ErrorLevel
      errorOccured := 1

   ;  msgbox, % "loool=" A_ThisFunc "==" modus
   If !errorOccured
      Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
   Sleep, 1
   FileDelete, %mainCompiledPath%\regFiles\RegExplGeneral.reg
   FileDelete, %mainCompiledPath%\regFiles\runThis.bat
   If (errorOccured && modus!=2)
      msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while associating " appTitle " with Explorer context menu options.", 0, 0, "error")
}

associateSLDsNow() {
    z := FileAssociate("QPVslideshow",".sld", fullPath2exe)
    If z
       FileAssociate("QPVslideshow",".sldb", fullPath2exe)
    Else
       msgBoxWrapper(appTitle ": ERROR", "An unknown error occured when associating " appTitle " with slideshow / files list formats.", 0, 0, "error")
}

associateWithImages(modus) {
  Static FileFormatsCommon := "|png|bmp|gif|jpg|tif|tga|webp|jpeg|tiff|exr|hdr|psd|"
       , allFormats := 0 ; "dib|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif"

  If !allFormats
     allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")

  If (modus=3)
  {
     associateSLDsNow()
     Return
  } Else If (modus=4)
  {
     associateWithExplorer(4)
     Return
  } Else Return

  Loop, Parse, FileFormatsCommon, |
  {
      If !A_LoopField
         Continue

      z := FileAssociate("QPVimage." A_LoopField,"." A_LoopField, fullPath2exe,,1)
      If !z
      {
         errorOccured := 1
         Break
      }

  }

  Sleep, 25
  If !errorOccured
     Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
  Sleep, 5
  FileDelete, %mainCompiledPath%\regFiles\*.reg
  FileDelete, %mainCompiledPath%\regFiles\*.bat

  ; msgResult := msgBoxWrapper(appTitle, appTitle " was now associated with common image file formats. Would you like to associate it with all the 85 supported file formats?", 4, 0, "question")
  ; If (msgResult="yes")
  If (modus=2 && !errorOccured)
  {
     Loop, Parse, allFormats, |
     {
         If (!A_LoopField || InStr(FileFormatsCommon, "|" A_LoopField "|"))
            Continue
 
         z := FileAssociate("QPVimage." A_LoopField,"." A_LoopField, fullPath2exe,,1)
         If !z
         {
            errorOccured := 1
            Break
         }
     }
 
     Sleep, 25
     If !errorOccured
        Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
     Sleep, 5
     FileDelete, %mainCompiledPath%\regFiles\*.reg
     FileDelete, %mainCompiledPath%\regFiles\*.bat
  }

  If errorOccured
  {
     msgBoxWrapper(appTitle ": ERROR", "An unknown error occured during associating " appTitle " with image file formats.", 0, 0, "error")
     Return
  } Else associateWithExplorer(2)

  addJournalEntry(appTitle " has been associated with image file formats")
}

closeDocuments() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (animGIFplaying=1)
   {
      DestroyGIFuWin()
      Return
   }

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   PopulateIndexFilesStatsInfos("kill")
   resetMainWin2Welcome()
   addJournalEntry("All images/documents closed.")
   ResetImgLoadStatus()
}

restartAppu() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will restart")
      Return

   If askAboutSlidesListSave()
      Return

   ; writeMainSettings()
   If A_IsCompiled
      Try Run, "%fullPath2exe%"
   Else
      Try Run, %unCompiledExePath%

   TrueCleanup(0)
   Sleep, 5
   ExitApp
}

exitAppu(dummy:=0) {
   If (A_IsSuspended && MsgBox2hwnd && dummy="external")
   {
      interfaceThread.ahkPostFunction("dummyTimerExit")
      terminateIMGediting()
      TrueCleanup()
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will exit")
      Return

   If askAboutSlidesListSave()
      Return

   terminateIMGediting()
   TrueCleanup()
}

InitGuiContextForcedMenu() {
   InitGuiContextMenu("forced")
}

InitGuiContextMenu(keyu:=0) {
   Static lastInvoked := 1
   Critical, off

   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   If (keyu!="forced")
   {
      If (A_TickCount - lastInvoked<250) && (keyu="extern") || (A_TickCount - zeitSillyPrevent<250)
         Return

      Au := WinActive("A")
      If !InStr(keyu, "appsk")
         MouseGetPos, , , Bu
      Else
         Bu := Au

      If (AnyWindowOpen=2 || AnyWindowOpen=3)
      {
         GuiControlGet, varu, SettingsGUIA: FocusV
         If (InStr(varu, "LView") && Au=hSetWinGui && Bu=hSetWinGui)
         {
            MenuFolderzFilterList()
            Return
         }
      }

      okay := (Au=PVhwnd || Au=hGDIwin || Au=hGDIthumbsWin) && (Bu=PVhwnd || Bu=hGDIwin || Bu=hGDIthumbsWin) ? 1 : 0
      If (okay!=1)
         Return 1

      If (slideShowRunning=1)
         ToggleSlideShowu()

      DestroyGIFuWin()
      If (StrLen(hitTestSelectionPath)>2 && editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1)
      {
         GetMouseCoord2wind(PVhwnd, mX, mY)
         Gdip_SetPenWidth(pPen1d, SelDotsSize)
         hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
         If (hitB=1)
         {
            lastInvoked := A_TickCount
            invokeSelectionAreaMenu("DoubleClick")
            Return
         }
      }

      delayu := 1
      If (thumbsDisplaying=1 && maxFilesIndex>1 && !InStr(keyu, "appskey"))
      {
         delayu := 10
         r := WinClickAction("rclick", "nona")
         dummyTimerDelayiedImageDisplay(50)
      }
   }

   If (r="scrollbar")
      SetTimer, invokeNavigationMenu, -10
   Else If (r="StatusBar")
      SetTimer, MenuPanelFoldersTree, -10
   Else If (InStr(keyu, "+") || InStr(keyu, "^"))
      SetTimer, BuildSecondMenu, % -10 - delayu
   Else
      SetTimer, BuildMainMenu, % -10 - delayu

   lastInvoked := A_TickCount
   ; WinActivate, ahk_id %PVhwnd%
}

Win_SetMenu(Hwnd, hMenu=0) {
   hPrevMenu := DllCall("GetMenu", "uint", hwnd, "Uint")
   DllCall("SetMenu", "uint", hwnd, "uint", hMenu)
   return hPrevMenu
}

PathCompact(givenPath, CharMax) {
    If (StrLen(givenPath)>CharMax+3)
    {
       lastSlash := InStr(givenPath, "\", 0, 0)
       partB := SubStr(givenPath, lastSlash)
       If (StrLen(partB)>CharMax+2)
          partB := SubStr(givenPath, -CharMax)

       partA := SubStr(givenPath, 1, Max(CharMax - StrLen(partB), 3)) "..."
       Return partA partB
    } Else Return givenPath
}

createMenuSelectionArea(modus:=0) {
   If (modus="DoubleClick")
   {
      Menu, PVselv, Add, Main menu, InitGuiContextForcedMenu
      Menu, PVselv, Add, 
   }

   If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
   {
      Menu, PVselv, Add, &Undo`tCtrl+Shift+Z, ImgSelUndoAct
      Menu, PVselv, Add, &Redo`tCtrl+Shift+Y, ImgSelRedoAct
      Menu, PVselv, Add,
   }

   Menu, PVselv, Add, &Show selection area`tE, toggleImgSelection
   If (editingSelectionNow=1)
      Menu, PVselv, Check, &Show selection area`tE

   whichMenu := (modus="DoubleClick") ? "PVselSize" : "PVselv"
   infoSelShape := DefineVPselAreaMode()
   Menu, % whichMenu, Add, &Drop and reset`tCtrl+D, resetImgSelection
   If (modus!="DoubleClick")
      Menu, PVselv, Add, &Reset, newImgSelection

   Menu, % whichMenu, Add, &Select all`tCtrl+A, selectEntireImage
   If (modus!="DoubleClick")
      Menu, PVselv, Add, 

   Menu, % whichMenu, Add, &Flip width / height, flipSelectionWH
   If (lockSelectionAspectRatio>1)
      Menu, % whichMenu, Disable, &Flip width / height

   infoKbd := (EllipseSelectMode=0) ? "`tShift+L" : ""
   Menu, % whichMenu, Add, Selection s&hape: %infoSelShape%`tShift+E, toggleEllipseSelection
   Menu, % whichMenu, Add, &Define new freeform shape%infoKbd%, MenuStartDrawingSelectionArea
   If (EllipseSelectMode=2)
      Menu, % whichMenu, Add, &Modify selection shape`tShift+L, MenuResumeDrawingShapes

   Menu, % whichMenu, Add, Limit to image bo&undaries`tL, toggleLimitSelection
   If (LimitSelectBoundsImg=1)
      Menu, % whichMenu, Check, Limit to image bo&undaries`tL

   If (modus!="DoubleClick")
      Menu, PVselv, Add, 

   whichMenu := (modus="DoubleClick") ? "PVselRatio" : "PVselv"
   defiSelAR := defineSelectionAspectRatios()
   Menu, % whichMenu, Add, R&otate by 45°`tShift+R, MenuSelRotation
   Menu, % whichMenu, Add, R&eset rotation`tShift+\, resetSelectionRotation
   Menu, % whichMenu, Add, &Keep aspect ratio on rotation, ToggleSelKeepRatioRotation
   Menu, % whichMenu, Add, Loc&k aspect ratio`tShift+A, toggleImgSelectionAspectRatio
   Menu, % whichMenu, Add, %defiSelAR%, dummy
   Menu, % whichMenu, Disable, %defiSelAR%
   Menu, % whichMenu, Add, Set to s&quare ratio (1:1)`tR, makeSquareSelection

   If (lockSelectionAspectRatio>1)
      Menu, % whichMenu, Check, Loc&k aspect ratio`tShift+A
   If (rotateSelBoundsKeepRatio=1)
      Menu, % whichMenu, Check, &Keep aspect ratio on rotation

   If (modus="DoubleClick")
   {
      Menu, PVselv, Add, Si&ze and shape, :PVselSize
      Menu, PVselv, Add, Rotation and &aspect ratio, :PVselRatio
   }

   Menu, PVselv, Add, 
   Menu, PVselv, Add, Sho&w grid, ToggleSelectGrid
   Menu, PVselv, Add, Selection properties`tAlt+E, PanelIMGselProperties
   If (showSelectionGrid=1)
      Menu, PVselv, Check, Sho&w grid

   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   infoImgEditingNow := (StrLen(whichBitmap)>2 && imgPath) ? 1 : 0
   If (infoImgEditingNow=1 && modus="DoubleClick")
   {
      createMenuImageEditSubMenus()
      Menu, PVselv, Add
      Menu, PVselv, Add, C&ut selected area`tCtrl+X, CutSelectedArea
      Menu, PVselv, Add, &Copy to clipboard`tCtrl+C, CopyImage2clip
      Menu, PVselv, Add, &Paste in place`tCtrl+Shift+V, PanelPasteInPlace
      Menu, PVselv, Add
      Menu, PVselv, Add, &Filters,:PVimgFilters
      Menu, PVselv, Add, &Draw,:PVimgDraw
      Menu, PVselv, Add, &Transform, :PVimgTransform

   }
}

createMenuImageEditSubMenus() {
   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   infoImgEditingNow := (StrLen(whichBitmap)>2 && imgPath) ? 1 : 0
   If (thumbsDisplaying!=1 && infoImgEditingNow=1)
   {
      Menu, PVimgTransform, Add, &Adjust canvas size`tAlt+A, PanelAdjustImageCanvasSize
      Menu, PVimgTransform, Add, A&uto-crop image`tAlt+Y, PanelImgAutoCrop
      Menu, PVimgDraw, Add, Draw f&reeform filled shape`tShift+P, MenuStartDrawingShapes
      Menu, PVimgDraw, Add, Draw freeform &outline`tP, MenuStartDrawingLines
      Menu, PVimgFilters, Add, &Blur/pixelize`tShift+B, PanelBlurSelectedArea
      Menu, PVimgFilters, Add, &Invert colors`tShift+I, InvertSelectedArea
      Menu, PVimgFilters, Add, Desaturate color&s`tCtrl+G, PanelDesatureSelectedArea
      Menu, PVimgFilters, Add, &Detect edges filter, PanelDetectEdgesImage
      Menu, PVimgFilters, Add, &Add noise filter, PanelAddNoiserImage
      Menu, PVimgDraw, Add, &Erase or fade area`tDelete, PanelEraseSelectedArea
      Menu, PVimgDraw, Add, &Fill area or draw shapes`tAlt+Bksp, PanelFillSelectedArea
      Menu, PVimgDraw, Add, &Draw simple lines or arcs`tCtrl+L, PanelDrawLines
      Menu, PVimgDraw, Add, Insert te&xt into selection`tShift+T, PanelInsertTextArea
      Menu, PVimgTransform, Add, &Advanced live transform`tCtrl+T, PanelTransformSelectedArea
      Menu, PVimgTransform, Add, 
      Menu, PVimgTransform, Add, Flip selected &horizontally`tShift+H, FlipSelectedAreaH
      Menu, PVimgTransform, Add, Flip selected &vertically`tShift+V, FlipSelectedAreaV
      Menu, PVimgTransform, Add, &Crop image to selection`tShift+Enter, CropImageInViewPortToSelection
      Menu, PVimgTransform, Add, &Resize image to selection`tAlt+R, ResizeIMGviewportSelection
      Menu, PVimgFilters, Add, &Apply viewport colors inside selection`tShift+U, ApplyColorAdjustsSelectedArea
      Menu, PVimgFilters, Add, &... outside the selection`tCtrl+Shift+U, ApplyColorAdjustsSelectedArea
      If (editingSelectionNow!=1)
      {
         Menu, PVimgDraw, Disable, &Erase or fade area`tDelete
         Menu, PVimgDraw, Disable, &Fill area or draw shapes`tAlt+Bksp
         Menu, PVimgDraw, Disable, &Draw simple lines or arcs`tCtrl+L
         Menu, PVimgDraw, Disable, Insert te&xt into selection`tShift+T
         Menu, PVimgTransform, Disable, &Advanced live transform`tCtrl+T
         Menu, PVimgTransform, Disable, Flip selected &horizontally`tShift+H
         Menu, PVimgTransform, Disable, Flip selected &vertically`tShift+V
         Menu, PVimgTransform, Disable, &Crop image to selection`tShift+Enter
         Menu, PVimgTransform, Disable, &Resize image to selection`tAlt+R
         Menu, PVimgFilters, Disable, &Apply viewport colors inside selection`tShift+U
         Menu, PVimgFilters, Disable, &... outside the selection`tCtrl+Shift+U
      }
   }
}

createMenuNavigation() {
   If (thumbsDisplaying!=1)
   {
      Menu, PVnav, Add, &Skip missing files, ToggleSkipDeadFiles
      If (skipDeadFiles=1)
         Menu, PVnav, Check, &Skip missing files
      Menu, PVnav, Add,
   }

   Menu, PVnav, Add, &First`tHome, FirstPicture
   Menu, PVnav, Add, &Previous`tPage down, PreviousPicture
   Menu, PVnav, Add, &Next`tPage up, NextPicture
   Menu, PVnav, Add, &Last`tEnd, LastPicture
   If (totalFramesIndex>0 && thumbsDisplaying!=1)
   {
      Menu, PVnav, Add,
      Menu, PVnav, Add, Previous &frame`tShift+Page Down, prevDesiredFrame
      Menu, PVnav, Add, Ne&xt frame`tShift+Page Up, nextDesiredFrame
   }

   If (markedSelectFile>1 && thumbsDisplaying!=1)
   {
      Menu, PVnav, Add,
      Menu, PVnav, Add, F&irst selected`tCtrl+Home, jumpToFilesSelBorderFirst
      Menu, PVnav, Add, Pr&evious selected`tCtrl+Left, navSelectedFilesPrev
      Menu, PVnav, Add, Nex&t selected`tCtrl+Right, navSelectedFilesNext
      Menu, PVnav, Add, L&ast selected`tCtrl+End, jumpToFilesSelBorderLast
   }

   thisFolder := StrReplace(Trimmer(CurrentSLD), "|")
   Menu, PVnav, Add,
   Menu, PVnav, Add, &Skip to index`tJ, PanelJump2index
   Menu, PVnav, Add, &Random`tShift+Bksp, RandomPicture
   Menu, PVnav, Add, Pre&v. random image`tBksp, PrevRandyPicture
   If (SLDtypeLoaded=1 && FolderExist(thisFolder))
   {
      Menu, PVnav, Add,
      Menu, PVnav, Add, Folders explorer menu`tShift+F4, chainInvokerFoldersListMenu
   }
}

chainInvokerFoldersListMenu() {
   Global lastOtherWinClose := 1
   SetTimer, invokeFoldersListerMenu, -60
}

createMenuCurrentFile() {
   Menu, PVtFile, Add, Cop&y file path(s) as text`tShift+C, CopyImagePath
   If markedSelectFile
      Menu, PVtFile, Add, Copy folder paths as text, CopyImageFolderPaths

   If (thumbsDisplaying=1 || markedSelectFile)
   {
      infoKbd := (thumbsDisplaying=1) ? "`tCtrl+C" : ""
      Menu, PVtFile, Add, Copy file(s) (for Explorer)%infoKbd%, MenuExplorerCopyFiles
      infoKbd := (thumbsDisplaying=1) ? "`tCtrl+X" : ""
      Menu, PVtFile, Add, C&ut file(s) (for Explorer)%infoKbd%, MenuExplorerCutFiles
   }

   Menu, PVtFile, Add, 
   If !markedSelectFile
      Menu, PVtFileOpen, Add, &Open with external app`tO, OpenThisFileMenu

   ; If (thumbsDisplaying=1)
   friendly := markedSelectFile ? "Open files in new &QPV instances" : "Open file in a new &QPV instance"
   friendlyAct := markedSelectFile ? "OpenWithNewQPVinstance" : "SoloNewQPVinstance"
   Menu, PVtFileOpen, Add, %friendly%`tCtrl+Enter, % friendlyAct
   If (!markedSelectFile && RegExMatch(CurrentSLD, sldsPattern))
      Menu, PVtFileOpen, Add, &Open in QPV the containing folder, OpenQPVfileFolder

   If !markedSelectFile
      Menu, PVtFileOpen, Add, &Explore the containing folder`tCtrl+E, OpenThisFileFolder

   If (thumbsDisplaying=1 && !markedSelectFile)
      Menu, PVtFileOpen, Add, &Import into currently loaded image, importGivenFile

   If !markedSelectFile
   {
      Menu, PVtFile, Add, &Open..., :PVtFileOpen
      Menu, PVtFile, Add, Set as &wallpaper`tCtrl+W, setImageWallpaper
   } Else
      Menu, PVtFile, Add, %friendly%`tCtrl+Enter, % friendlyAct

   Menu, PVtFile, Add, 
   Menu, PVtFile, Add, Con&vert file format(s) to...`tCtrl+K, PanelFileFormatConverter
   ; If markedSelectFile
   ; {
      file2rem := getIDimage(currentFileIndex)
      Menu, PVtFileImgAct, Add, &JPEG lossless operations`tK, PanelJpegPerformOperation
      If !RegExMatch(file2rem, "i)(.\.(jpg|jpeg))$")
         Menu, PVtFileImgAct, Disable, &JPEG lossless operations`tK
      Menu, PVtFileImgAct, Add, Resi&ze/rotate/crop image(s)`tCtrl+R, PanelSimpleResizeRotate
      If markedSelectFile
         Menu, PVtFileImgAct, Add, &Auto-crop image(s)`tAlt+Y, PanelImgAutoCrop

      If (thumbsDisplaying=1 || markedSelectFile)
      {
         infoKbd := (thumbsDisplaying=1) ? "`tShift+U" : ""
         Menu, PVtFileImgAct, Add, Apply vie&wport color adjustments%infoKbd%, filesListApplyColors
         infoKbd := (thumbsDisplaying=1) ? "`tShift+H" : ""
         Menu, PVtFileImgAct, Add, Flip image horizontally%infoKbd%, filesListFlipHimage
         infoKbd := (thumbsDisplaying=1) ? "`tShift+V" : ""
         Menu, PVtFileImgAct, Add, Flip image vertically%infoKbd%, filesListFlipVimage
         infoKbd := (thumbsDisplaying=1) ? "`t0" : ""
         Menu, PVtFileImgAct, Add, Rotate image by 90 degrees%infoKbd%, filesListFlipRotatePlus
         infoKbd := (thumbsDisplaying=1) ? "`t9" : ""
         Menu, PVtFileImgAct, Add, Rotate image by -90 degrees%infoKbd%, filesListFlipRotateMinus
      }
   ; }

   Menu, PVtFile, Add, Modify image(s), :PVtFileImgAct
   Menu, PVtFile, Add, 
   If markedSelectFile
      Menu, PVtFile, Add, Remove file inde&x entries`tDelete, InListMultiEntriesRemover
   Menu, PVtFile, Add, &Delete file(s)`tDelete, DeletePicture
   Menu, PVtFile, Add, &Rename file(s)`tF2, PanelRenameThisFile
   Menu, PVtFile, Add, &Move file(s) to...`tM, PanelMoveCopyFiles
   Menu, PVtFile, Add, &Copy file(s) to...`tC, InvokeCopyFiles
   Menu, PVtFile, Add,
   If !markedSelectFile
      Menu, PVtFile, Add, &File information`tAlt+Enter, PanelImageInfos
   Else
      Menu, PVtFile, Add, &Calculate total files size`tAlt+L, CalculateSelectedFilesSizes

   If !markedSelectFile
      Menu, PVtFile, Add, &Select / deselect file`tTab, MenuMarkThisFileNow
   If (mustRecordSeenImgs=1 && thumbsDisplaying=1)
      Menu, PVtFile, Add, &Toggle SEEN status`tS, ToggleSeenIMGstatus
}

createMenuSoloFile() {
   Menu, PVtActFile, Add, &Open with external app`tO, OpenThisFileMenu
   Menu, PVtActFile, Add, Open file in a new &QPV instance, SoloNewQPVinstance
   If RegExMatch(CurrentSLD, sldsPattern)
      Menu, PVtActFile, Add, &Open in QPV containing folder, OpenQPVfileFolder

   Menu, PVtActFile, Add, &Explore containing folder`tCtrl+E, OpenThisFileFolder
   Menu, PVtActFile, Add, Set containing folder as the protected folder, setContaintFolderAsProtected
   Menu, PVtActFile, Add, Set as &wallpaper`tCtrl+W, setImageWallpaper

   If (thumbsDisplaying=1)
      Menu, PVtActFile, Add, &Import into currently loaded image, importGivenFile

   Menu, PVtActFile, Add, 
   If !markedSelectFile
      Menu, PVtActFile, Add, &Select / deselect file`tTab, MenuMarkThisFileNow
   Menu, PVtActFile, Add, Remove index entry`tAlt+Delete, singleInListEntriesRemover
   Menu, PVtActFile, Add, Modify index entry`tCtrl+F2, PanelUpdateThisFileIndex
   Menu, PVtActFile, Add, 
   Menu, PVtActFile, Add, &Delete file`tDelete, DeleteActivePicture
   Menu, PVtActFile, Add, &Rename file`tShift+F2, SingularRenameFile
   Menu, PVtActFile, Add, &File information`tAlt+Enter, PanelImageInfos
}

MenuSelectAllAction() {
   selectEntireImage("rm")
}

MenuDoOpenStartFolder() {
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()
   dummyTimerDelayiedImageDisplay(50)
   RemoveTooltip()
}

MenuToggleColorAdjustments() {
   If (imgFxMode=1)
   {
      ColorPanelTriggerImageUpdate("ignore-zoom")
   } Else
   {
      o_usrColorDepth := usrColorDepth
      imgFxMode := usrColorDepth := 1
      If (o_usrColorDepth=1)
         dummyTimerDelayiedImageDisplay(50)
      Else
         dummyTimerReloadThisPicture(50)
   }
}

MenuStartDrawingSelectionArea() {
   startDrawingShape("selection")
}

MenuStartDrawingShapes(dummy:=0) {
   startDrawingShape("shape", 0, dummy)
}

MenuResumeDrawingShapes() {
   startDrawingShape("selection", "resume")
}

MenuStartDrawingLines(dummy:=0) {
   startDrawingShape("line", 0, dummy)
}

BuildImgLiveEditMenu() {
      If (editingSelectionNow!=1 && !AnyWindowOpen) || (thumbsDisplaying=1)
         Return

      deleteMenus()
      Menu, PVedit, Add, Live tools, dummy
      Menu, PVedit, Disable, Live tools
      Menu, PVedit, Add, &Erase or fade area`tDelete, PanelEraseSelectedArea
      Menu, PVedit, Add, &Fill area or draw shapes`tAlt+Bksp, PanelFillSelectedArea
      Menu, PVedit, Add, &Draw predetermined lines or arcs`tCtrl+L, PanelDrawLines
      Menu, PVedit, Add, Draw f&reeform filled shape`tShift+P, MenuStartDrawingShapes
      Menu, PVedit, Add, Draw freeform &outline`tP, MenuStartDrawingLines
      Menu, PVedit, Add, &Insert te&xt`tShift+T, PanelInsertTextArea
      Menu, PVedit, Add, &Adjust vie&wport colours and effects`tU, PanelColorsAdjusterWindow
      Menu, PVedit, Add, Desaturate color&s`tCtrl+G, PanelDesatureSelectedArea
      If (AnyWindowOpen=10)
         Menu, PVedit, Check, &Adjust vie&wport colours and effects`tU
      Else If (AnyWindowOpen=23)
         Menu, PVedit, Check, &Fill area or draw shapes`tAlt+Bksp
      Else If (AnyWindowOpen=25)
         Menu, PVedit, Check, &Erase or fade area`tDelete
      Else If (AnyWindowOpen=30)
         Menu, PVedit, Check, &Draw predetermined lines or arcs`tCtrl+L
      Else If (AnyWindowOpen=32)
         Menu, PVedit, Check, &Insert te&xt`tShift+T
      Else If (AnyWindowOpen=55)
         Menu, PVedit, Check, Desaturate color&s`tCtrl+G

      Menu, PVedit, Add,
      Menu, PVedit, Add, Other operations, dummy
      Menu, PVedit, Disable, Other operations
      Menu, PVedit, Add, Flip selected &horizontally`tShift+H, FlipSelectedAreaH
      Menu, PVedit, Add, Flip selected &vertically`tShift+V, FlipSelectedAreaV
      Menu, PVedit, Add, &Invert colors`tShift+I, InvertSelectedArea
      If (AnyWindowOpen!=10)
      {
         Menu, PVedit, Add, &Apply color effects inside selection`tShift+U, ApplyColorAdjustsSelectedArea
         Menu, PVedit, Add, &... outside the selection`tCtrl+Shift+U, ApplyColorAdjustsSelectedArea
      }

      Menu, PVmenu, Add, &Toggle tool panel`tM-Click\F8, toggleImgEditPanelWindow
      Menu, PVmenu, Add, &Cancel / close panel`tEsc, BtnCloseWindow
      Menu, PVmenu, Add,

      If (AnyWindowOpen!=24 && AnyWindowOpen!=31 && editingSelectionNow=1)
         Menu, PVmenu, Add, S&witch tool, :PVedit
      If (AnyWindowOpen=23 && FillAreaShape=7) || ((AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=55) && EllipseSelectMode=2 && editingSelectionNow=1)
         Menu, PVmenu, Add, &Modify custom shape, MenuResumeDrawingShapes

      If (AnyWindowOpen=10)
      {
         Menu, PVmenu, Add,
         If (editingSelectionNow=1)
         {
            Menu, PVmenu, Add, &Apply color effects inside selection`tShift+U, ApplyColorAdjustsSelectedArea
            Menu, PVmenu, Add, &... outside the selection`tCtrl+Shift+U, ApplyColorAdjustsSelectedArea
         }

         Menu, PVmenu, Add, &Activate viewport color adjustments`t\, MenuToggleColorAdjustments
         If (ForceNoColorMatrix!=1 && imgFxMode!=1)
            Menu, PVmenu, Check, &Activate viewport color adjustments`t\
         Menu, PVmenu, Add, &Reset all adjustments to defaults`tCtrl+\, BtnResetImageView
      } Else
      {
         Menu, PVmenu, Add, 
         Menu, PVmenu, Add, &Apply tool`tEnter, applyIMGeditFunction
      }

      If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
      {
         Menu, PVmenu, Add, 
         Menu, PVmenu, Add, &Undo`tCtrl+Z, ImgUndoAction
         Menu, PVmenu, Add, &Redo`tCtrl+Y, ImgRedoAction
      }

      If (AnyWindowOpen=10)
      {
         Menu, PVmenu, Add, &Show selection`tE, tlbrToggleImgSelection
         If (editingSelectionNow=1)
            Menu, PVmenu, Check, &Show selection`tE

         If (editingSelectionNow=1)
         {
            Menu, PVselv, Add, &Reset selection, newImgSelection
            Menu, PVselv, Add, Sho&w grid, ToggleSelectGrid
            If (showSelectionGrid=1)
               Menu, PVselv, Check, Sho&w grid
         } Else Menu, PVmenu, Add, &Select all`tCtrl+A, MenuSelectAllAction
      }

      If (undoLevelsRecorded>1 && undoLevelsRecorded!="" && editingSelectionNow=1)
      {
         Menu, PVselv, Add, 
         Menu, PVselv, Add, &Undo selection`tCtrl+Shift+Z, ImgSelUndoAct
         Menu, PVselv, Add, &Redo selection`tCtrl+Shift+Y, ImgSelRedoAct
      }

      Menu, PVselv, Add, 
      Menu, PVselv, Add, &Select all`tCtrl+A, MenuSelectAllAction
      If (lockSelectionAspectRatio<2)
         Menu, PVselv, Add, S&quare ratio selection [1:1]`tR, makeSquareSelection

      If (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=55)
      {
         infoSelShape := DefineVPselAreaMode()
         Menu, PVselv, Add, Selection shape: %infoSelShape%`tShift+E, toggleEllipseSelection
      }

      Menu, PVselv, Add, &Flip selection W/H`tI, flipSelectionWH
      Menu, PVselv, Add, &Limit selection to image area`tL, toggleLimitSelection
      Menu, PVselv, Add, 
      Menu, PVselv, Add, R&otate by 45°`tShift+R, MenuSelRotation
      Menu, PVselv, Add, R&eset rotation`tShift+\, resetSelectionRotation
      Menu, PVselv, Add, &Keep aspect ratio on rotation, ToggleSelKeepRatioRotation

      defiSelAR := defineSelectionAspectRatios()
      Menu, PVselv, Add, Loc&k aspect ratio`tShift+A, toggleImgSelectionAspectRatio
      Menu, PVselv, Add, %defiSelAR%, dummy
      Menu, PVselv, Disable, %defiSelAR%

      If (lockSelectionAspectRatio>1)
         Menu, PVselv, Check, Loc&k aspect ratio`tShift+A
      If (rotateSelBoundsKeepRatio=1)
         Menu, PVselv, Check, &Keep aspect ratio on rotation
      If (LimitSelectBoundsImg=1)
         Menu, PVselv, Check, &Limit selection to image area`tL


      Menu, PVmenu, Add, 
      If (editingSelectionNow=1)
         Try Menu, PVmenu, Add, &Selection area, :PVselv

      If !AnyWindowOpen
         Menu, PVmenu, Add, Selection &properties`tAlt+E, PanelIMGselProperties

      Menu, PVmenu, Add, 
      Menu, PVmenu, Add, A&dapt image to window`t/, ToggleImageSizingMode
      If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
         Menu, PVmenu, Add, &Hide dynamic object`tD, hideLivePreviewObject
      If (IMGresizingMode=1)
         Menu, PVmenu, Check, A&dapt image to window`t/

      showThisMenu("PVmenu")
}

hideLivePreviewObject() {
   livePreviewsImageEditing(1, 2)
}

MenuCopyAction() {
   If (thumbsDisplaying=1)
      InvokeCopyFiles()
   Else
      CopyImage2clip()
}

MenuSelectAction() {
   If (thumbsDisplaying=1)
      MenuMarkThisFileNow()
   Else
      tlbrToggleImgSelection()
}

MenuChangeZoomMinus() {
  changeZoom(-1)
}

MenuChangeZoomPlus() {
  changeZoom(1)
}

BuildSecondMenu() {
   ; main menu
   If (thumbsDisplaying=1)
   {
      invokeFileOptionsMenu()
      Return
   } Else If (editingSelectionNow=1 && useGdiBitmap() && StrLen(getIDimage(currentFileIndex))>4)
   {
      invokeSelectionAreaMenu("DoubleClick")
      Return
   }

   deleteMenus()
   If (imgEditPanelOpened=1)
   {
      Menu, PVmenu, Add, Collapse panel`tF11, toggleImgEditPanelWindow
      Menu, PVmenu, Add, 
      If (AnyWindowOpen=10)
      {
         Menu, PVmenu, Add, Apply vie&wport effects inside selection`tEnter, ApplyColorAdjustsSelectedArea
         Menu, PVmenu, Add, &... outside the selection`tCtrl+Shift+U, ApplyColorAdjustsSelectedArea
      } Else Menu, PVmenu, Add, &Apply tool`tEnter, applyIMGeditFunction
      Menu, PVmenu, Add, % (AnyWindowOpen=10) ? "Close panel`tESC" : "Cancel tool`tESC", CloseWindow
      Menu, PVmenu, Add, 
      Menu, PVmenu, Add, Undo`tCtrl+Z, ImgUndoAction
      Menu, PVmenu, Add, Redo`tCtrl+Y, ImgRedoAction
      Menu, PVmenu, Add, 
      If (AnyWindowOpen=10)
         Menu, PVmenu, Add, Select area`tE, tlbrToggleImgSelection
      Else
         Menu, PVmenu, Add, Select all`tCtrl+A, MenuSelectAllAction
      Menu, PVmenu, Add, Square`tR, makeSquareSelection
      Menu, PVmenu, Add, Flip selection W/H`tI, flipSelectionWH
      Menu, PVmenu, Add, Limit selection to image boundaries`tL, toggleLimitSelection
      Menu, PVmenu, Add, 
      If (AnyWindowOpen!=10)
         Menu, PVmenu, Add, &Rotate selection by 45°`tShift+R, MenuSelRotation
      If (AnyWindowOpen=10)
         Menu, PVmenu, Add, Reset image vie&w, BtnResetImageView
      Else
         Menu, PVmenu, Add, &Reset selection rotation`tShift+\, resetSelectionRotation
      Menu, PVmenu, Add, 
      Menu, PVmenu, Add, Adapt image to viewport`t/, ToggleImageSizingMode
      If (AnyWindowOpen=10)
         Menu, PVmenu, Add, Toggle FX, MenuToggleColorAdjustments
      Else
         Menu, PVmenu, Add, Hide tool object`tD, livePreviewsImageEditing

      showThisMenu("PVmenu")
      Return
   }

   infoThumbsMode := (thumbsDisplaying=1) ? "Image view" : "List view"
   t := (thumbsDisplaying=1) ? "file(s) to" : ""
   t2 := (thumbsDisplaying=1) ? "list" : "image"
   Menu, PVmenu, Add, Main menu, InitGuiContextForcedMenu
   Menu, PVmenu, Add, 
   Menu, PVmenu, Add, &Open`tCtrl+O, OpenDialogFiles
   Menu, PVmenu, Add, &Save %t2%`tCtrl+S, PanelSaveImg
   Menu, PVmenu, Add, &Refresh %t2%`tF5, RefreshImageFileAction
   Menu, PVmenu, Add, 

   If (thumbsDisplaying=1)
      Menu, PVmenu, Add, S&elect file`tSpace, MenuSelectAction
   Else
      Menu, PVmenu, Add, S&election area`tE, MenuSelectAction
   Menu, PVmenu, Add, &All / none`tCtrl+A, MenuSelectAllAction
   Menu, PVmenu, Add, 
   If (thumbsDisplaying!=1)
   {
      Menu, PVmenu, Add, &Copy image`tCtrl+C, CopyImage2clip
      If (editingSelectionNow=1)
         Menu, PVmenu, Add, Cut area`tCtrl+X, CutSelectedArea

      Menu, PVmenu, Add, &Paste image`tCtrl+V, tlbrPasteClipboardIMG
   } Else
   {
      Menu, PVmenu, Add, Cut file(s) (for E&xplorer)`tCtrl+X, MenuExplorerCutFiles
      Menu, PVmenu, Add, &Copy file(s) to`tC, InvokeCopyFiles
      Menu, PVmenu, Add, &Move file(s) to`tM, PanelMoveCopyFiles
      Menu, PVmenu, Add, Pas&te file(s)`tCtrl+V, MenuPasteHDropFiles
   }

   Menu, PVmenu, Add, Er&ase`tDelete, deleteKeyAction
   Menu, PVmenu, Add, 
   If (maxFilesIndex>1)
   {
      Menu, PVmenu, Add, Searc&h index`tF3, PanelSearchIndex
      Menu, PVmenu, Add, &Jump to`tJ, PanelJump2index
   }
   Menu, PVmenu, Add, Reset %t2% vie&w`t\, ResetImageView
   If (thumbsDisplaying=1)
   {
      Menu, PVmenu, Add, 
      Menu, PVmenu, Add, &Toggle list modes`tL, toggleListViewModeThumbs
      If (thumbnailsListMode=1)
      {
         Menu, PVmenu, Add, Increase text size`t+, MenuChangeZoomPlus
         Menu, PVmenu, Add, Decrease text size`t-, MenuChangeZoomMinus
      } Else
      {
         Menu, PVmenu, Add, More columns`t+, MenuChangeZoomPlus
         Menu, PVmenu, Add, Fewer columns`t-, MenuChangeZoomMinus
      }
   } Else
   {
      Menu, PVmenu, Add, 
      If (maxFilesIndex>1)
      {
         Menu, PVmenu, Add, %infoThumbsMode%`tEnter, MenuDummyToggleThumbsMode
         Menu, PVmenu, Add, Start slideshow`tSpace, dummyInfoToggleSlideShowu
      }
      Menu, PVmenu, Add, Image information`tI, ToggleHistoInfoBoxu
      Menu, PVmenu, Add, Open previous panel`tF8, openPreviousPanel
   }

   showThisMenu("PVmenu")
}

BuildMainMenu() {
   Static lastInvoked := 1
   If (toolTipGuiCreated=2)
      RemoveTooltip()

   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   If (imgEditPanelOpened=1)
   {
      deleteMenus()
      BuildImgLiveEditMenu()
      Return
   }

   If (AnyWindowOpen>0)
   {
      If ((A_TickCount - lastInvoked < 650) && !MsgBox2hwnd)
         CloseWindow()
      Else
         WinActivate, ahk_id %hSetWinGui%
      lastInvoked := A_TickCount
      Return
   }

   SetTimer, drawWelcomeImg, Off
   deleteMenus()
   createMenuCurrentFile()
   ResetImgLoadStatus()
   Global lastWinDrag := A_TickCount
   sliSpeed := Round(slideShowDelay/1000, 2) " sec."
   Menu, PVslide, Add, &Start slideshow`tSpace, dummyInfoToggleSlideShowu
   Menu, PVslide, Add, Smoot&h transitions, ToggleSlidesTransitions
   Menu, PVslide, Add, &Easy slideshow stopping, ToggleEasySlideStop
   Menu, PVslide, Add, &Randomize colour effects, ToggleSlidesFXmode
   Menu, PVslide, Add, &Wait for GIFs to play once, ToggleGIFsPlayEntirely
   If (animGIFsSupport!=1 || alwaysOpenwithFIM=1)
      Menu, PVslide, Disable, &Wait for GIFs to play once
   If (slidesFXrandomize=1)
      Menu, PVslide, Check, &Randomize colour effects

   Menu, PVslide, Add, S&kip already seen images, ToggleSkipSeenIMGs
   If (mustRecordSeenImgs!=1)
      Menu, PVslide, Disable, S&kip already seen images
   Else If (skipSeenImageSlides=1)
      Menu, PVslide, Check, S&kip already seen images
   Menu, PVslide, Add, 
   Menu, PVslide, Add, De&fine slideshow duration`tShift+/, PanelDefineEntireSlideshowLength
   Menu, PVslide, Add, % EstimateSlideShowLength(1), dummy
   Menu, PVslide, Disable, % EstimateSlideShowLength(1)
   Menu, PVslide, Add,
   Menu, PVslide, Add, &Toggle slideshow mode`tS, SwitchSlideModes
   Menu, PVslide, Add, % DefineSlideShowType(), SwitchSlideModes
   Menu, PVslide, Disable, % DefineSlideShowType()
   Menu, PVslide, Add,
   Menu, PVslide, Add, &Increase speed`tComma [`,], IncreaseSlideSpeed
   Menu, PVslide, Add, &Decrease speed`tDot [.], DecreaseSlideSpeed
   Menu, PVslide, Add, Current speed: %sliSpeed%, DecreaseSlideSpeed
   Menu, PVslide, Disable, Current speed: %sliSpeed%
   If (allowGIFsPlayEntirely=1)
      Menu, PVslide, Check, &Wait for GIFs to play once
   If (doSlidesTransitions=1)
      Menu, PVslide, Check, Smoot&h transitions
   If (minimizeMemUsage=1)
      Menu, PVslide, Disable, Smoot&h transitions
   If (easySlideStoppage=1)
      Menu, PVslide, Check, &Easy slideshow stopping

   infolumosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(lumosAdjust, 2) : Round(lumosGrayAdjust, 2)
   infoGammosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(GammosAdjust, 2) : Round(GammosGrayAdjust, 2)
   infoSatAdjust := (imgFxMode=4) ? zatAdjust : Round(satAdjust*100)
   thisAlignInfo := defineImgAlign()

   If (thumbsDisplaying=1)
   {
      infoThumbZoom := thumbsColumns " | " thumbsW "x" thumbsH " px" ; " (" Round(thumbsZoomLevel*100) "%)"
      Menu, PVview, Add, Thumbnails &alignment`tA, ToggleIMGalign
      Menu, PVview, Add, %thisAlignInfo%, ToggleIMGalign
      Menu, PVview, Disable, %thisAlignInfo%
      Menu, PVview, Add,
      Menu, PVview, Add, &Toggle aspect ratio`tT, PanelSetThumbCols
      Try Menu, PVview, Add, % defineThumbsAratio(), ChangeThumbsAratio
      Try Menu, PVview, Disable, % defineThumbsAratio()
      Menu, PVview, Add,
      Menu, PVview, Add, Columns and size, PanelSetThumbCols
      ; Menu, PVview, Disable, Thumbnails columns and size:
      Menu, PVview, Add, % infoThumbZoom, ChangeThumbsAratio
      Menu, PVview, Disable, % infoThumbZoom
   } Else
   {
      If InStr(currIMGdetails.PixelFormat, "TONE-MAPPED")
         Menu, PVview, Add, &HDR tone-mapping, PanelAdjustToneMapping

      Menu, PVview, Add, Viewport and color adjustments panel`tU, PanelColorsAdjusterWindow
      If (editingSelectionNow!=1)
         Menu, PVview, Add, &Show selection area`tE, ToggleEditImgSelection

      friendlyPix := (coreDesiredPixFmt="0x21808") ? "24-RGB" : "32-RGBA"
      Menu, PVview, Add,
      If (A_PtrSize=4)
         Menu, PVview, Add, Pixel format mode: %friendlyPix%, ToggleCorePixFmt
      Menu, PVview, Add, Image &alignment: %thisAlignInfo%`tA, ToggleIMGalign
      Menu, PVview, Add, Image &rotation: %vpIMGrotation%°`t9`, 0, MenuChangeImgRotationInVP
      Menu, PVview, Add,
      Menu, PVview, Add, &Toggle resizing mode`tT, ToggleImageSizingMode
      Menu, PVview, Add, % DefineImgSizing(), ToggleImageSizingMode
      Menu, PVview, Disable, % DefineImgSizing()
   }

   Menu, PVview, Add,
   Menu, PVview, Add, &Toggle simulated color depth`tQ, ToggleImgColorDepth
   Menu, PVview, Add, % defineColorDepth(), ToggleImgColorDepth
   Try Menu, PVview, Disable, % defineColorDepth()
   Menu, PVview, Add, &Toggle colors display mode`tF, ToggleImgFX
   Menu, PVview, Add, % DefineFXmodes(), ToggleImgFX
   Menu, PVview, Disable, % DefineFXmodes()
   If (imgFxMode=2 || imgFxMode=3 || imgFxMode=4)
   {
      Menu, PVview, Add, Br: %infolumosAdjust% / Ctr: %infoGammosAdjust% / dS: %infoSatAdjust%, ToggleImgFX
      Menu, PVview, Disable, Br: %infolumosAdjust% / Ctr: %infoGammosAdjust% / dS: %infoSatAdjust%
   }

   Menu, PVview, Add,
   Menu, PVview, Add, Mirror &horizontally`tH, VPflipImgH
   Menu, PVview, Add, Mirror &vertically`tV, VPflipImgV
   Menu, PVview, Add,
   Menu, PVview, Add, Reset vie&wport adjustments`t\, ResetImageView
   If (FlipImgV=1)
      Menu, PVview, Check, Mirror &vertically`tV
   If (FlipImgH=1)
      Menu, PVview, Check, Mirror &horizontally`tH

   If (thumbsDisplaying!=1)
   {
      Menu, PVview, Add, Reset adjustments on image change, ToggleAutoResetImageView
      If (resetImageViewOnChange=1)
         Menu, PVview, Check, Reset adjustments on image change
   } Else
   {
      Menu, PVview, Add
      friendly := (markedSelectFile>1) ? "Force refresh of selected thumbnails on scroll" : "Force refresh of thumbnails on scroll"
      If (thumbsDisplaying=1 && thumbnailsListMode!=1)
         Menu, PVview, Add, %friendly%`tAlt+F5, DeepRefreshThumbsNow
      If (enableThumbsCaching=1)
         Menu, PVview, Add, Generate all thumbnails no&w, generateAllThumbsNow
   }

   createMenuNavigation()
   createMenuSelectionArea()
   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   infoImgEditingNow := (StrLen(whichBitmap)>2 && imgPath) ? 1 : 0
   Menu, PVedit, Add, New image`tCtrl+N, PanelNewImage
   If (thumbsDisplaying!=1 && infoImgEditingNow=1)
   {
      Menu, PVedit, Add, &Save image as...`tCtrl+S, PanelSaveImg
      Menu, PVedit, Add, C&ut selected area`tCtrl+X, CutSelectedArea
      If (editingSelectionNow!=1)
         Menu, PVedit, Disable, C&ut selected area`tCtrl+X
      Menu, PVedit, Add, &Copy to clipboard`tCtrl+C, CopyImage2clip
   }

   Menu, PVedit, Add, P&aste clipboard`tCtrl+V, PasteClipboardIMG
   If (thumbsDisplaying!=1 && infoImgEditingNow=1)
   {
      Menu, PVedit, Add, &Paste in place`tCtrl+Shift+V, PanelPasteInPlace
      If (editingSelectionNow!=1)
         Menu, PVedit, Disable, &Paste in place`tCtrl+Shift+V
   }
   Menu, PVedit, Add,
   If (thumbsDisplaying!=1 && infoImgEditingNow=1)
      Menu, PVedit, Add, Print image`tCtrl+P, PanelPrintImage
   Menu, PVedit, Add, Ac&quire image (WIA), AcquireWIAimage

   Menu, PVedit, Add, 
   If (thumbsDisplaying!=1 && editingSelectionNow!=1 && imgSelX2=-1 && imgSelY2=-1 && (CurrentSLD || StrLen(UserMemBMP)>2))
      Menu, PVedit, Add, Create &selection area`tE, newImgSelection
   Else If (thumbsDisplaying!=1 && editingSelectionNow!=1 && infoImgEditingNow=1)
      Menu, PVedit, Add, Sho&w selection area`tE, ToggleEditImgSelection

   createMenuImageEditSubMenus()
   ; Try Menu, PVedit, Add, &Create,:PVimgCreate
   Try Menu, PVedit, Add, &Filters,:PVimgFilters
   Try Menu, PVedit, Add, &Draw,:PVimgDraw
   Try Menu, PVedit, Add, &Transform, :PVimgTransform
   
   StringRight, infoPrevMovePath, prevFileMovePath, 25
   Menu, PVsort, Add, File details, dummy
   Menu, PVsort, Disable, File details
   Menu, PVsort, Add, &Path and name`tCtrl+1, ActSortName
   Menu, PVsort, Add, &Folder path`tCtrl+2, ActSortPath
   Menu, PVsort, Add, &File name`tCtrl+3, ActSortFileName
   Menu, PVsort, Add, File si&ze`tCtrl+4, ActSortSize
   Menu, PVsort, Add, &Modified date`tCtrl+5, ActSortModified
   Menu, PVsort, Add, &Created date`tCtrl+6, ActSortCreated
   If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
   {
      Menu, PVsort, Add
      Menu, PVsort, Add, &Duplicates ID group, ActSortDupeGroups
   }

   Menu, PVsort, Add
   Menu, PVsort, Add, &Reversed order on sort, TglRvrSort
   If (reverseOrderOnSort=1)
      Menu, PVsort, Check, &Reversed order on sort

   Menu, PVsort, Add, &Remove inexistent files on sort, TglCheckDeadFilesSort
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      Menu, PVsort, Disable, &Remove inexistent files on sort
   Else If (OnSortdoFilesCheck=1)
      Menu, PVsort, Check, &Remove inexistent files on sort

   If (SLDtypeLoaded=3)
   {
      Menu, PVsort, Add, &Purge cached data, PanelPurgeCachedSQLdata
      Menu, PVsort, Add, &Use cached data, TglUseCacheSLDinfo
      If (useCachedSLDdata=1)
         Menu, PVsort, Check, &Use cached data

      defaultSort := defineSQLdbSort()
      StringUpper, defaultSort, defaultSort
      Menu, PVsort, Add
      Menu, PVsort, Add, Default sorting:, ToggleDBdefaultSQLsort
      Menu, PVsort, Add, % "[" defaultSort "]", ToggleDBdefaultSQLsort
      Menu, PVsort, Disable, % "[" defaultSort "]"
   }

   Menu, PVsort, Add
   Menu, PVsort, Add, Image information, dummy
   Menu, PVsort, Disable, Image information
   Menu, PVsort, Add, &Resolution`tCtrl+7, PanelResolutionSorting
   Menu, PVsort, Add, &Histogram`tCtrl+8, PanelHistogramSorting
   Menu, PVsort, Add, 
   Menu, PVsort, Add, R&everse list`tCtrl+0, ReverseListNow
   Menu, PVsort, Add, R&andomize list, RandomizeListNow

   defMenuRefresh := RegExMatch(CurrentSLD, sldsPattern) ? "&Reload .SLD file" : "&Refresh opened folder(s)"
   StringRight, defMenuRefreshItm, CurrentSLD, 30
   If defMenuRefreshItm
   {
      Menu, PVfList, Add, %defMenuRefresh%`tShift+F5, RefreshFilesList
      If RegExMatch(CurrentSLD, sldsPattern)
      {
         Menu, PVfList, Add, %defMenuRefreshItm%, RefreshFilesList
         Menu, PVfList, Disable, %defMenuRefreshItm%
      }
   }

   Menu, PVfList, Add,
   ; If (maxFilesIndex>1)
   ; {
      Menu, PVfList, Add, Insert file(s)`tInsert, addNewFile2list
      Menu, PVfList, Add, Add folder(s)`tShift+Insert, addNewFolder2list
      Menu, PVfList, Add, Manage folder(s) list`tAlt+U, PanelDynamicFolderzWindow
   ; }

   If (maxFilesIndex>2)
   {
      Menu, PVfList, Add, Save files list as .SLD`tCtrl+Shift+S, PanelSaveSlideShowu
      Menu, PVfList, Add,
      If !markedSelectFile
      {
         Menu, PVfList, Add, Remove active index entry`tAlt+Delete, singleInListEntriesRemover
         Menu, PVfList, Add, Modify active index entry`tCtrl+F2, PanelUpdateThisFileIndex
      }

      Menu, PVfList, Add, Auto-remove entries of dead files, ToggleAutoRemEntries
      If (autoRemDeadEntry=1)
         Menu, PVfList, Check, Auto-remove entries of dead files

      Menu, PVfList, Add,
      ; If RegExMatch(CurrentSLD, sldsPattern)
      Menu, PVfList, Add, &Clean duplicate/inexistent entries, cleanDeadFilesList
      If StrLen(DynamicFoldersList)>6
         Menu, PVfList, Add, &Regenerate the entire list, RegenerateEntireList
      If (RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
         Menu, PVfList, Add, &Update files list selectively`tCtrl+U, PanelStaticFolderzManager
      If (mustRecordSeenImgs=1)
         Menu, PVfList, Add, Remove already seen ima&ges, removeFilesListSeenImages

      Menu, PVfList, Add, 
      Menu, PVfList, Add, &Find duplicate images, PanelFindDupes
      Menu, PVfList, Add, &Statistics, PanelWrapperFilesStats
      Menu, PVfList, Add, Searc&h index`tCtrl+F3, PanelSearchIndex
      Menu, PVfList, Add, Search and replace`tCtrl+H, PanelSearchAndReplaceIndex
      Menu, PVfList, Add, &Index filters`tCtrl+F, PanelEnableFilesFilter
      If StrLen(filesFilter)>1
         Menu, PVfList, Check, &Index filters`tCtrl+F

      ; If (thumbsDisplaying!=1)
      ; {
      ;    Menu, PVfList, Add,
      ;    Menu, PVfList, Add, &Sort by, :PVsort
      ; }
   }

   Menu, PVperfs, Add, &Limit memory usage, ToggleLimitMemUsage
   Menu, PVperfs, Add, &Do not record undo levels, TogglePreventUndos
   If (preventUndoLevels=1)
      Menu, PVperfs, Check, &Do not record undo levels
   Menu, PVperfs, Add, &Allow multi-threaded processing (%realSystemCores%), PanelSetSystemCores
   If (minimizeMemUsage=1)
      Menu, PVperfs, Disable, &Allow multi-threaded processing (%realSystemCores%)

   If (A_PtrSize=4)
   {
      Menu, PVperfs, Disable, &Allow multi-threaded processing (%realSystemCores%)
      Menu, PVperfs, Disable, &Limit memory usage
      Menu, PVperfs, Check, &Limit memory usage
   }

   Menu, PVperfs, Add, &High quality image resampling, ToggleImgQuality
   If (thumbsDisplaying!=1)
   {
      Menu, PVperfs, Add, &Downscale images to viewport dimensions`tCtrl+Q, ToggleImgDownScaling
      If (AutoDownScaleIMGs=1)
         Menu, PVperfs, Check, &Downscale images to viewport dimensions`tCtrl+Q
   }
   Menu, PVperfs, Add, &Perform dithering on color depth changes, ToggleImgColorDepthDithering
   Menu, PVperfs, Add, &Load Camera RAW files in high quality, ToggleRAWquality
   If (minimizeMemUsage=1)
      Menu, PVperfs, Check, &Limit memory usage
   If (allowMultiCoreMode=1)
      Menu, PVperfs, Check, &Allow multi-threaded processing (%realSystemCores%)
   If (ColorDepthDithering=1)
      Menu, PVperfs, Check, &Perform dithering on color depth changes
   If (userimgQuality=1)
      Menu, PVperfs, Check, &High quality image resampling
   If (userHQraw=1)
      Menu, PVperfs, Check, &Load Camera RAW files in high quality

   Menu, PVprefs, Add, Save settings into a .SLD file, WritePrefsIntoSLD
   Menu, PVprefs, Add, &Never load settings from a .SLD, ToggleIgnoreSLDprefs
   Menu, PVprefs, Add, Associate QPV with image formats, PanelAssociateQPV

   Menu, PVprefs, Add, 
   Menu, PVprefs, Add, Load an&y image format using FreeImage, ToggleAlwaysFIMus
   ; If (thumbsDisplaying!=1 && CurrentSLD && maxFilesIndex>0)
   Menu, PVprefs, Add, Performance options, :PVperfs
   Menu, PVprefs, Add, 
   If (thumbsDisplaying!=1)
   {
      Menu, PVprefs, Add, Auto-play an&imated GIFs, ToggleAnimGIFsupport
      If (animGIFsSupport=1)
         Menu, PVprefs, Check, Auto-play an&imated GIFs
      If (alwaysOpenwithFIM=1)
         Menu, PVprefs, Disable, Auto-play an&imated GIFs
   }

   Menu, PVprefs, Add, &Quick file actions, PanelQuickMoveConfigure
   Menu, PVprefs, Add, &Record seen images, ToggleRecordSeenImages
   If (mustRecordSeenImgs=1)
      Menu, PVprefs, Check, &Record seen images
   Menu, PVprefs, Add, &Prompt before file delete, TogglePromptDelete
   If (askDeleteFiles=1)
      Menu, PVprefs, Check, &Prompt before file delete
   If (MustLoadSLDprefs=0)
      Menu, PVprefs, Check, &Never load settings from a .SLD

   Menu, PVprefs, Add, 
   If (mustRecordSeenImgs=1)
      Menu, PVprefs, Add, Seen images database options, PanelSeenIMGsOptions
   If FolderExist(thumbsCacheFolder)
      Menu, PVprefs, Add, Erase cached thumbnails, PanelOlderThanEraseThumbsCache

   Menu, PVprefs, Add, Cache generated thumbnails, ToggleThumbsCaching
   If (alwaysOpenwithFIM=1)
      Menu, PVprefs, Check, Load an&y image format using FreeImage
   If (enableThumbsCaching=1)
   {
      If (thumbsDisplaying=1)
         Menu, PVprefs, Add, Generate all thumbnails no&w, generateAllThumbsNow

      Menu, PVprefs, Check, Cache generated thumbnails
   }

   favesList := readMiniFavesEntries()
   Loop, Parse, favesList, `n
   {
      If (A_Index>15)
         Break

      countItemz++
      If !Trimmer(A_LoopField)
         Continue

      entryu := PathCompact(A_LoopField, 30)
      If StrLen(entryu)>3
      {
         countFaved++
         Menu, PVfaves, Add, &%countItemz%. %entryu%, OpenFavesEntry
      }
   }

   If !countFaved
   {
      Menu, PVfaves, Add, No image added to favourites, dummy
      Menu, PVfaves, Disable, No image added to favourites
   } Else If (userAddedFavesCount>15)
   {
      moru := userAddedFavesCount - 15
      Menu, PVfaves, Add, ... and another %moru% images, dummy
      Menu, PVfaves, Disable, ... and another %moru% images
   }

   Menu, PVfaves, Add
   Menu, PVfaves, Add, &Cycle favourites list on open, ToggleCycleFavesOpen
   If (cycleFavesOpenIMG=1)
      Menu, PVfaves, Check, &Cycle favourites list on open

   Menu, PVfaves, Add, &Add/remove current image to favourites`tB, ToggleImgFavourites
   If !(maxFilesIndex>0 && CurrentSLD)
      Menu, PVfaves, Disable, &Add/remove current image to favourites`tB

   If !countFaved
      IniAction(0, "userAddedFavesCount", "General", 4)

   If (countFaved>1 || userAddedFavesCount>1)
      Menu, PVfaves, Add, &Manage the favourites list, retrieveFavesAsList
   Menu, PVfaves, Add, &Remove all from favourites, eraseAllFavedIMGs

   If !(countFaved>2)
      Menu, PVfaves, Disable, &Remove all from favourites

   Menu, PVopenF, Add, &Image or slideshow`tCtrl+O, OpenDialogFiles
   Menu, PVopenF, Add, &Folder recursively`tShift+O, OpenFolders

   countItemz := 0
   Menu, PVopenF, Add, &New QPV instance`tCtrl+Shift+N, OpenNewQPVinstance
   If (maxFilesIndex<1 || !CurrentSLD)
      Menu, PVopenF, Add, Insert file(s)`tInsert, addNewFile2list

   If (allowRecordHistory=1)
   {
      Menu, PVopenF, Add,
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      If (RegExMatch(Trimmer(LastOpenedImg), RegExFilesPattern) && FileRexists(Trimmer(LastOpenedImg)))
         Menu, PVopenF, Add, % "&0. " PathCompact(Trimmer(LastOpenedImg), 30), MenuOpenLastImg

      historyList := readRecentEntries(0, 0)
      Loop, Parse, historyList, `n
      {
         If (A_Index>10)
            Break

         countItemz++
         testThis := StrReplace(A_LoopField, "|")
         If (StrLen(A_LoopField)<4 || !FileExist(testThis))
            Continue

         entryu := PathCompact(testThis, 30)
         If InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= "\" ; entryu
         If !InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= " (*)"
         If RegExMatch(A_LoopField, sldsPattern)
            entryu := "# " entryu

         Menu, PVopenF, Add, &%countItemz%. %entryu%, OpenRecentEntry
      }

      Menu, PVopenF, Add, 
      If FolderExist(prevFileSavePath)
         aListu := prevFileSavePath "`n"
      If (FolderExist(prevFileMovePath) && !InStr(aListu, prevFileMovePath "`n"))
         aListu .= prevFileMovePath "`n"
      If (FolderExist(prevOpenFolderPath) && !InStr(aListu, prevOpenFolderPath "`n"))
         aListu .= prevOpenFolderPath "`n"

      Loop, Parse, aListu, `n
      {
         If !A_LoopField
            Continue
         Menu, PVopenF, Add, % "O" A_Index ". " PathCompact(A_LoopField, 30), OpenRecentEntry
         ; Menu, PVopenF, Add, % "O" A_Index ". " SubStr(A_LoopField, -30), OpenRecentEntry
      }
   }

   Menu, PVopenF, Add, 
   If (countItemz>0)
      Menu, PVopenF, Add, &Erase opened history, EraseOpenedHistory

   Menu, PVopenF, Add, &Record recently opened, ToggleRecordOpenHistory
   If (allowRecordHistory=1)
      Menu, PVopenF, Check, &Record recently opened

   Menu, PVsounds, Add, &Edit image caption`tShift+N, PanelEditImgCaption
   Menu, PVsounds, Add, &Show image captions`tN, ToggleImgCaptions
   If (showImgAnnotations=1)
      Menu, PVsounds, Check, &Show image captions`tN

   Menu, PVsounds, Add, 
   If (SLDtypeLoaded=3)
      Menu, PVsounds, Add, Choose audio file, PanelBrowseAudioAnnotation
   Menu, PVsounds, Add, Play associated sound file`tX, PlayAudioFileAssociatedNow
   Menu, PVsounds, Add, Stop playing`tShift+X, StopMediaPlaying
   If !hSNDmedia
      Menu, PVsounds, Disable, Stop playing`tShift+X
   Menu, PVsounds, Add, 
   Menu, PVsounds, Add, Auto-play sound files, ToggleAutoPlaySND
   If (autoPlaySNDs=1)
      Menu, PVsounds, Check, Auto-play sound files
   Menu, PVsounds, Add, Slideshow speed based on audio length, ToggleSyncSlide2sndDuration
   If (syncSlideShow2Audios=1)
      Menu, PVsounds, Check, Slideshow speed based on audio length
   If (autoPlaySNDs!=1)
      Menu, PVsounds, Disable, Slideshow speed based on audio length
   Menu, PVsounds, Add, 
   Menu, PVsounds, Add, Change audio volume`t8, ChangeVolume
   Menu, PVsounds, Add, Audio volume: %mediaSNDvolume%`%, dummy
   Menu, PVsounds, Disable, Audio volume: %mediaSNDvolume%`%

   Menu, PVfileSel, Add, &First`tCtrl+Home, jumpToFilesSelBorderFirst
   Menu, PVfileSel, Add, &Previous`tCtrl+Left, navSelectedFilesPrev
   Menu, PVfileSel, Add, &Next`tCtrl+Right, navSelectedFilesNext
   Menu, PVfileSel, Add, &Last`tCtrl+End, jumpToFilesSelBorderLast
   Menu, PVfileSel, Add, 
   Menu, PVfileSel, Add, Select/deselect file`tTab / Space, MenuMarkThisFileNow
   Menu, PVfileSel, Add, Select all`tCtrl+A, selectAllFiles
   Menu, PVfileSel, Add, Select none`tCtrl+D, dropFilesSelection
   Menu, PVfileSel, Add, Select random, PanelSelectRandomFiles
   Menu, PVfileSel, Add, Invert selection`tShift+I, invertFilesSelection
   Menu, PVfileSel, Add, 
   Menu, PVfileSel, Add, Filter files list to selected`tCtrl+Tab, filterToFilesSelection

; main menu
   Menu, PVmenu, Add, &Open..., :PVopenF
   Menu, PVmenu, Add, Fa&vourites, :PVfaves
   If StrLen(mustOpenStartFolder)>3
      Menu, PVmenu, Add, &Scan files in folder`tSpace/Wheel, MenuDoOpenStartFolder
   If (thumbsDisplaying=1)
      Menu, PVmenu, Add, &Paste files`tCtrl+V, PasteClipboardIMG

   If (StrLen(UserMemBMP)>2 && thumbsDisplaying!=1)
   {
      Menu, PVmenu, Add,
      If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
      {
         Menu, PVmenu, Add, &Undo`tCtrl+Z, ImgUndoAction
         Menu, PVmenu, Add, &Redo`tCtrl+Y, ImgRedoAction
      }
      Menu, PVmenu, Add, &Save image`tCtrl+S, PanelSaveImg
      If CurrentSLD
         Menu, PVmenu, Add, &Revert changes...`tF5, RefreshImageFileAction
   } Else If (StrLen(UserMemBMP)>2 && thumbsDisplaying=1)
      Menu, PVmenu, Add, &Return to image editing, MenuReturnIMGedit

   Menu, PVmenu, Add,
   If (thumbsDisplaying!=1)
      Menu, PVmenu, Add, &Edit image, :PVedit

   createMenuSoloFile()
   If (maxFilesIndex>0 && CurrentSLD)
   {
      infoThisFile := markedSelectFile ? "S&elected files" : "C&urrent file"
      If (thumbsDisplaying!=1 && editingSelectionNow=1)
         Menu, PVmenu, Add, Selec&tion area, :PVselv

      Menu, PVmenu, Add, % infoThisFile, :PVtFile
      If markedSelectFile
         Menu, PVmenu, Add, &Active file, :PVtActFile

      If (thumbsDisplaying=1) || (thumbsDisplaying!=1 && editingSelectionNow!=1)
         Menu, PVmenu, Add, Files index/l&ist, :PVfList

      If (thumbsDisplaying=1 && maxFilesIndex>1)
         Menu, PVmenu, Add, &Sort list by..., :PVsort

      friendly := (thumbsDisplaying=1) ? "T&humbnails view" : "Image vie&w"
      If (thumbsDisplaying!=1) || (thumbsDisplaying=1 && thumbnailsListMode!=1)
         Menu, PVmenu, Add, % friendly, :PVview

      If (thumbsDisplaying!=1 && StrLen(UserMemBMP)<3 && currentFileIndex!=0)
         Menu, PVmenu, Add, &Annotation, :PVsounds

      If (maxFilesIndex>2 || mustOpenStartFolder)
      {
         Menu, PVmenu, Add, Navi&gation, :PVnav
         If (thumbsDisplaying!=1 && editingSelectionNow!=1)
            Menu, PVmenu, Add, Slideshow, :PVslide
      }
      Menu, PVmenu, Add,
   } Else If StrLen(UserMemBMP)>2
   {
      If (editingSelectionNow=1 && thumbsDisplaying!=1)
      {
         Menu, PVmenu, Add, Selec&tion, :PVselv
         Menu, PVmenu, Add, &Edit image, :PVedit
      }
      If (thumbsDisplaying!=1) || (thumbsDisplaying=1 && thumbnailsListMode!=1)
         Menu, PVmenu, Add, Image vie&w, :PVview
   }

   If (markedSelectFile && thumbsDisplaying!=1)
      Menu, PVmenu, Add, Dro&p files selection`tShift+Tab, dropFilesSelection
   Else If (markedSelectFile && thumbsDisplaying=1)
      Menu, PVmenu, Add, F&iles selection, :PVfileSel

   createMenuInterfaceOptions()

   If StrLen(filesFilter)>1
   {
      Menu, PVmenu, Add,
      Menu, PVmenu, Add, Remove files list filter`tCtrl+Space, MenuRemFilesListFilter
      If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
         Menu, PVmenu, Add, Auto-select duplicates, PanelAutoSelectDupes
      Menu, PVmenu, Add,
   } Else If (SLDtypeLoaded=2 && currentFilesListModified=1 && CurrentSLD && maxFilesIndex>1)
   {
      Menu, PVmenu, Add,
      thisKey := (thumbsDisplaying=1) ? "Ctrl+S" : "Ctrl+Shift+S"
      Menu, PVmenu, Add, Save files list now`t%thisKey%, BTNsaveCurrentSlideshow
      Menu, PVmenu, Add,
   }

   Menu, PVmenu, Add, Inter&face, :PvUIprefs
   Menu, PVmenu, Add, Prefe&rences, :PVprefs
   If StrLen(UserMemBMP)<3
      Menu, PVmenu, Add, Help / About`tF1, AboutWindow
   Menu, PVmenu, Add,
   Menu, PVmenu, Add, Restart`tShift+Esc, restartAppu
   Menu, PVmenu, Add, Exit`tEsc, exitAppu
   showThisMenu("PVmenu")
}

showThisMenu(menarg) {
   If (A_TickCount - lastOtherWinClose<10)
      Return

   doSuspendu(1)
   addJournalEntry("Invoked UI menu: " menarg)
   interfaceThread.ahkassign("allowMenuReader", "yes")
   Menu, % menarg, Show
   interfaceThread.ahkassign("allowMenuReader", "no")
   ; showDelayedTooltip("Menu item selected:`n" A_ThisMenuItem " [" A_ThisMenu "]")
   isFakeWin := (prevOpenedWindow[5]=1 && AnyWindowOpen>0) ? 1 : 0
   If (isFakeWin=0)
      SetTimer, dummyUnSuspendu, -150
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
   Global lastWinDrag := A_TickCount
   Global lastOtherWinClose := A_TickCount
}

dummyUnSuspendu() {
   doSuspendu(0)
}

deleteMenus() {
    Static menusList := "PVmenu|PVtFileOpen|PVtFileImgAct|PVselSize|PVselRatio|PVimgTransform|PVimgCreate|PVimgFilters|PVimgDraw|PVperfs|PVfileSel|PVslide|PVnav|PVview|PVfList|PVtActFile|PVtFile|PVprefs|PvUIprefs|PVfaves|PVopenF|PVsort|PVedit|PVselv|PVsounds"
    Loop, Parse, menusList, |
        Try Menu, % A_LoopField, Delete
}

ToggleDBdefaultSQLsort() {
   prevFilesSortMode := 0
   IniSLDBWrite("prevFilesSortMode", prevFilesSortMode)
   INIaction(1, "prevOpenFolderPath", "General")
   showTOOLtip("Default sorting of the files is now set to none.`nTo set it otherwise,please choose a sorting mode in the Sort menu.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createMenuInterfaceOptions() {
   infoThumbsList := defineListViewModes()
   infoThumbsMode := (thumbsDisplaying=1) ? "Switch to image view" : "Switch to " infoThumbsList " list view"
   If (thumbsDisplaying=1)
      Menu, PvUIprefs, Add, Toggle view modes`tL, toggleListViewModeThumbs

   If (maxFilesIndex>1 && !AnyWindowOpen)
      Menu, PvUIprefs, Add, %infoThumbsMode%`tEnter/MClick, MenuDummyToggleThumbsMode
   If (maxFilesIndex>1 && !AnyWindowOpen && prevOpenedWindow[2])
      Menu, PvUIprefs, Add, Open pre&vious panel`tF8, openPreviousPanel

   If (thumbsDisplaying!=1 && !AnyWindowOpen)
      Menu, PvUIprefs, Add, &Toggle full-screen mode`tF11, ToggleFullScreenMode

   If (thumbsDisplaying!=1)
   {
      Menu, PvUIprefs, Add, &Touch screen mode, ToggleTouchMode
      If (TouchScreenMode=1)
         Menu, PvUIprefs, Check, &Touch screen mode
   }

   Menu, PvUIprefs, Add, &Large UI fonts, ToggleLargeUIfonts
   Menu, PvUIprefs, Add, &Always on top, ToggleAllonTop
   Menu, PvUIprefs, Add, Show &folders tree panel`tF4, MenuPanelFoldersTree
   Menu, PvUIprefs, Add, Show &quick bar`tF10, ToggleQuickBaru
   If (folderTreeWinOpen=1)
      Menu, PvUIprefs, Check, Show &folders tree panel`tF4
   If (showMainMenuBar=1)
      Menu, PvUIprefs, Check, Show &quick bar`tF10

   If (thumbsDisplaying!=1)
   {
      Menu, PvUIprefs, Add, &Hide title bar, ToggleTitleBaru
      If (getCaptionStyle(PVhwnd)=1)
         Menu, PvUIprefs, Check, &Hide title bar
   } Else If (thumbnailsListMode!=1 && thumbsDisplaying=1 && !AnyWindowOpen)
      Menu, PvUIprefs, Add, &Set thumbnails columns, PanelSetThumbCols

   Menu, PvUIprefs, Add,
   If (mustRecordSeenImgs=1 && thumbsDisplaying=1)
   {
      Menu, PvUIprefs, Add, &Highlight already seen images, ToggleMarkSeenIMGs
      If (highlightAlreadySeenImages=1)
         Menu, PvUIprefs, Check, &Highlight already seen images
   }

   If (maxFilesIndex>0 && CurrentSLD)
   {
      Menu, PvUIprefs, Add, &Viewport and image details`tI, ToggleInfoBoxu
      If (showInfoBoxHUD>=1)
         Menu, PvUIprefs, Check, &Viewport and image details`tI
   }

   If (maxFilesIndex>0 && CurrentSLD && thumbsDisplaying!=1)
   {
      ; Menu, PvUIprefs, Add, No OSD messages, ToggleInfoToolTips
      Menu, PvUIprefs, Add, I&mage histogram`tShift+G, ToggleImgHistogram
      Menu, PvUIprefs, Add, &Ambiental textured background, ToggleTexyBGR

      If (showHistogram>1)
         Menu, PvUIprefs, Check, I&mage histogram`tShift+G
 
      If (usrTextureBGR=1)
         Menu, PvUIprefs, Check, &Ambiental textured background
   }

   If (maxFilesIndex>0 && CurrentSLD)
   {
      friendly := (thumbsDisplaying=1) ? "Image previe&w box`tZ" : "Auto-display image navi&gator`tZ"
      Menu, PvUIprefs, Add, % friendly, ToggleImgNavBox
      If (showHUDnavIMG=1)
         Menu, PvUIprefs, Check, % friendly
   }

   Menu, PvUIprefs, Add, 
   If !AnyWindowOpen
   {
      Menu, PvUIprefs, Add, Additional settings`tF12, openPrefsPanelWindow
      Menu, PvUIprefs, Add, Journal / session log`tShift + ``, PanelJournalWindow
   }

   If (PrefsLargeFonts=1)
      Menu, PvUIprefs, Check, &Large UI fonts
   If (getTopMopStyle(PVhwnd)=1)
      Menu, PvUIprefs, Check, &Always on top
}

EraseOpenedHistory() {
   Loop, 15
       IniWrite, 0, % mainRecentsFile, RecentOpen, E%A_Index%
   IniWrite, 0, % mainSettingsFile, General, LastOpenedImg
}

OpenRecentEntry(menuItem) {
  testOs := menuItem
  If askAboutFileSave(" and another image will be loaded")
     Return

  If askAboutSlidesListSave()
     Return

  startZeit := A_TickCount
  If RegExMatch(testOs, "i)^(o1\. )")
     openThisu := prevFileSavePath
  Else If RegExMatch(testOs, "i)^(o2\. )")
     openThisu := prevFileMovePath
  Else If RegExMatch(testOs, "i)^(o3\. )")
     openThisu := prevOpenFolderPath

  If openThisu
  {
     If (SLDtypeLoaded=3)
     {
        SLDtypeLoaded := 0
        activeSQLdb.CloseDB()
     }

     PopulateIndexFilesStatsInfos("kill")
     coreOpenFolder("|" openThisu, 1, 0, 1)
     currentFilesListModified := 0
     interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
     If (maxFilesIndex>0)
        SLDtypeLoaded := 1
     ; Else resetMainWin2Welcome()
     Return
  }

  openThisu := SubStr(testOs, 2, InStr(testOs, ". ")-2)
  IniRead, newEntry, % mainRecentsFile, RecentOpen, E%openThisu%, @
  ; MsgBox, %openthisu% -- %newentry%
  newEntry := Trimmer(newEntry)
  If StrLen(newEntry)>4
  {
     If (SLDtypeLoaded=3)
     {
        SLDtypeLoaded := 0
        activeSQLdb.CloseDB()
     }

     If RegExMatch(newEntry, sldsPattern)
     {
        OpenSLD(newEntry)
     } Else
     {
        PopulateIndexFilesStatsInfos("kill")
        prevOpenFolderPath := StrReplace(newEntry, "|")
        If FolderExist(prevOpenFolderPath)
           INIaction(1, "prevOpenFolderPath", "General")
        coreOpenFolder(newEntry, 1, 0, 1)
        currentFilesListModified := 0
        interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
        If (maxFilesIndex>0)
           SLDtypeLoaded := 1
        ; Else resetMainWin2Welcome()
     }
  }
  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

OpenFavesEntry(menuItem) {
  testOs := menuItem
  openThisu := SubStr(testOs, 2, InStr(testOs, ". ")-2)
  If (InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") && maxFilesIndex>500)
  {
     currentFileIndex := openThisu
     dummyTimerDelayiedImageDisplay(50)
     Return
  }

  If askAboutFileSave(" and the selected image from favourites will be loaded")
     Return

  If askAboutSlidesListSave()
     Return

  startZeit := A_TickCount
  contentu := readMiniFavesEntries()
  Loop, Parse, contentu, `n, `r
  {
      If (openThisu=A_Index)
      {
         newEntry := Trimmer(A_LoopField)
         Break
      }
   }

  ; IniRead, newEntry, % mainRecentsFile, favourites, E%openThisu%, @
  If !FileRexists(newEntry)
  {
     msgResult := msgBoxWrapper(appTitle ": ERROR", "The file you are trying to open seems to no longer exist. Would you like to remove it from the favourites list?", 4, 0, "question")
     If InStr(msgResult, "yes")
        ToggleImgFavourites(newEntry, "rem")
  } Else If (cycleFavesOpenIMG=1 && newEntry!="@" && StrLen(newEntry)>2)
  {
     retrieveFavesAsList(openThisu)
     Return
  } Else If (newEntry!="@" && StrLen(newEntry)>2)
  {
     MenuOpenLastImg(newEntry)
     resultedFilesList[currentFileIndex, 5] := 1
     currentImgModified := 0
     interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
  }

  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

INIaction(act, var, section, type:=0, mini:=0, maxy:=0, forcedDef:="", iniFile:="") {
   thisIniFile := iniFile ? iniFile : mainSettingsFile
   varValue := %var%
   If (act=1)
   {
      If (var="FillAreaCustomShape")
         varValue := SubStr(varValue, 1, 64321)
      IniWrite, %varValue%, % thisIniFile, %section%, %var%
      If ErrorLevel
         fnOutputDebug("Error saving INI settings: " var )
   } Else
   {
      defaultu := (forcedDef!="") ? forcedDef : %var%
      IniRead, %var%, % thisIniFile, %section%, %var%, %varValue%
      If ErrorLevel
         fnOutputDebug("Error loading INI settings: " var )

      loadedValue := %var%
      If (type=1) ; binary
      {
         loadedValue := (Round(loadedValue)=0 || Round(loadedValue)=1) ? Round(loadedValue) : defaultu
         %var% := loadedValue
      } Else If (type=2)  ; range min/max
      {
         If !isNumber(loadedValue)
         {
            %var% := defaultu
         } Else
         {
            loadedValue := clampInRange(loadedValue, mini, maxy)
            %var% := loadedValue
         }
      } Else If (type=3)  ; HEX colour
      {
         loadedValue := Trimmer(loadedValue)
         If (loadedValue ~= "[^[:xdigit:]]") || (StrLen(loadedValue)!=6)
            loadedValue := defaultu
         %var% := loadedValue
      } Else If (type=4)  ; isNumber
      {
         If !isNumber(loadedValue)
            %var% := defaultu
      } Else If (loadedValue="error" && type=5)
         %var% := defaultu
   }
}

ToggleFullScreenMode() {
   Static prevState := 1, o_TouchScreenMode := "a"
   If (thumbsDisplaying=1)
   {
      ; o_TouchScreenMode := TouchScreenMode
      ToggleThumbsMode()
      Return
   }

  ; If (tempBtnVisible!="null")
     ; DestroyTempBtnGui("now")

  prevState := !prevState
  If (prevState=0)
  {
     If (showMainMenuBar=1)
     {
        showMainMenuBar := 0
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        Win_SetMenu(PVhwnd, 0)
        TriggerMenuBarUpdate()
     }
     ; o_TouchScreenMode := TouchScreenMode
     If (userAllowWindowDrag=1)
        TouchScreenMode := 0
     isTitleBarHidden := 0
     If (editingSelectionNow=1)
       ToggleEditImgSelection()
     WinSet, Style, -0xC00000, ahk_id %PVhwnd%
     WinMaximize, ahk_id %PVhwnd%
  } Else
  {
     ; If (o_TouchScreenMode!="a")
     ;    TouchScreenMode := o_TouchScreenMode
     isTitleBarHidden := 1
     WinSet, Style, +0xC00000, ahk_id %PVhwnd%
     WinRestore, ahk_id %PVhwnd%
     INIaction(0, "showMainMenuBar", "General", 1)
     INIaction(0, "TouchScreenMode", "General", 1)
     If (showMainMenuBar=1)
     {
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        TriggerMenuBarUpdate()
     }
  }

  interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
  interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
  interfaceThread.ahkassign("userAllowWindowDrag", userAllowWindowDrag)
  ; INIaction(1, "isTitleBarHidden", "General")
  ; INIaction(1, "TouchScreenMode", "General")

  SetTimer, dummyFullScreenButtons, -350
}

dummyFullScreenButtons() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  friendly .= (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1) ? "`nAllow window dragging: ENABLED" : "`nAllow window dragging: DISABLED"
  friendly := Trimmer(friendly)
  If (editingSelectionNow=1 || showHistogram>1 || showInfoBoxHUD>=1)
  {
     2ndLabel := "Hide viewport elements"
     2ndact := "turnOffViewportStuff"
  }

  If (userAllowWindowDrag=1 && isTitleBarHidden=0)
  {
     1stLabel := "Deactivate window dragging"
     1stact := "toggleWindowDraggableMode"
  } Else If (userAllowWindowDrag=0 && isTitleBarHidden=0)
  {
     1stLabel := "Allow window dragging"
     1stact := "toggleWindowDraggableMode"
  } Else ; If (isTitleBarHidden=1)
  {
     1stLabel := "Interface options"
     1stact := "OpenUImenu"
  }

  showTOOLtip(friendly)
  CreateGuiButton(1stLabel ",," 1stact "||" 2ndLabel ",," 2ndact, "force", msgDisplayTime + 500)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleWindowDraggableMode() {
   userAllowWindowDrag := !userAllowWindowDrag
   If (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1)
      TouchScreenMode := 0
   Else If (userAllowWindowDrag=0)
      INIaction(0, "TouchScreenMode", "General", 1)

   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
   interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
   interfaceThread.ahkassign("userAllowWindowDrag", userAllowWindowDrag)
   INIaction(1, "userAllowWindowDrag", "General")
}

turnOffViewportStuff() {
   If (showHistogram>1 || showInfoBoxHUD>=1)
      ToggleHistoInfoBoxu()
   If (editingSelectionNow=1)
      toggleImgSelection()
   DestroyTempBtnGui("now")
}

ToggleAllonTop() {
   isAlwaysOnTop := !isAlwaysOnTop
   WinSet, AlwaysOnTop, % isAlwaysOnTop, ahk_id %PVhwnd%
   INIaction(1, "isAlwaysOnTop", "General")
   interfaceThread.ahkassign("isAlwaysOnTop", isAlwaysOnTop)
}

ToggleEasySlideStop() {
   easySlideStoppage := !easySlideStoppage
   INIaction(1, "easySlideStoppage", "General")
}

ToggleSlidesFXmode() {
   slidesFXrandomize := !slidesFXrandomize
   INIaction(1, "slidesFXrandomize", "General")
   interfaceThread.ahkassign("slidesFXrandomize", slidesFXrandomize)
}

ToggleSelKeepRatioRotation() {
   rotateSelBoundsKeepRatio := !rotateSelBoundsKeepRatio
   INIaction(1, "rotateSelBoundsKeepRatio", "General")
   If (editingSelectionNow=1 && thumbsDisplaying!=1)
      SetTimer, dummyRefreshImgSelectionWindow, -10
}

ToggleGIFsPlayEntirely() {
   allowGIFsPlayEntirely := !allowGIFsPlayEntirely
   INIaction(1, "allowGIFsPlayEntirely", "General")
}

ToggleRecordSeenImages() {
   mustRecordSeenImgs := !mustRecordSeenImgs
   If (sqlFailedInit=1 && mustRecordSeenImgs=1)
   {
      mustRecordSeenImgs := 0
      msgBoxWrapper(appTitle ": ERROR", "An unknown error occured when attempting to initialize SqlLite Database.`n`nFeature not available.", 0, 0, "error")
   }

   INIaction(1, "mustRecordSeenImgs", "General")
}

ToggleSkipSeenIMGs() {
   skipSeenImageSlides := !skipSeenImageSlides
   INIaction(1, "skipSeenImageSlides", "General")
}

ToggleAutoResetImageView() {
   If (AnyWindowOpen=10)
      GuiControlGet, resetImageViewOnChange, SettingsGUIA:, resetImageViewOnChange
   Else
      resetImageViewOnChange := !resetImageViewOnChange

   INIaction(1, "resetImageViewOnChange", "General")
}

toggleListViewModeThumbs() {
   If (thumbsDisplaying!=1)
      Return

   If (thumbnailsListMode!=1)
   {
      thumbsListViewMode := 1
      thumbnailsListMode := 1
   } Else
   {
      thumbnailsListMode := 1
      thumbsListViewMode++
      If (thumbsListViewMode>=4)
         thumbsListViewMode := thumbnailsListMode := 0
   }

   INIaction(1, "thumbnailsListMode", "General")
   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   If (thumbnailsListMode!=1)
      initAHKhThumbThreads()
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)

   friendly := defineListViewModes()
   If (StrLen(userSearchString)>1 && thumbnailsListMode=1)
      friendly .= "`nHighlighting files matching search criteria:`n" userSearchString

   showTOOLtip("List view: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

defineListViewModes() {
   infoThumbsSize := (thumbsDisplaying=1) ? " (" thumbsW " x " thumbsH " px )" : ""
   If (thumbnailsListMode!=1)
      friendly := "THUMBNAILS"
   Else If (thumbnailsListMode=1 && thumbsListViewMode=1)
      friendly := "COMPACT"
   Else If (thumbnailsListMode=1 && thumbsListViewMode=2)
      friendly := "FILE DETAILS"
   Else If (thumbnailsListMode=1 && thumbsListViewMode=3)
      friendly := "IMAGE DETAILS"

   Return friendly
}

ToggleAutoPlaySND() {
   autoPlaySNDs := !autoPlaySNDs
   INIaction(1, "autoPlaySNDs", "General")
}

ToggleSyncSlide2sndDuration() {
   syncSlideShow2Audios := !syncSlideShow2Audios
   INIaction(1, "syncSlideShow2Audios", "General")
}

ToggleSlidesTransitions() {
   doSlidesTransitions := !doSlidesTransitions
   INIaction(1, "doSlidesTransitions", "General")
}

ToggleMarkSeenIMGs() {
   highlightAlreadySeenImages := !highlightAlreadySeenImages
   INIaction(1, "highlightAlreadySeenImages", "General")
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      dummyTimerDelayiedImageDisplay(50)
}

TglUseCacheSLDinfo() {
   useCachedSLDdata := !useCachedSLDdata
   INIaction(1, "useCachedSLDdata", "General")
   If (useCachedSLDdata=1)
      showTOOLtip("SQL database cached data will be used to sort the files list")
   Else
      showTOOLtip("SQL database cached data will not be used to sort the files list")

   SetTimer, RemoveTooltip, % -msgDisplayTime + 1500
}

TglRvrSort() {
   reverseOrderOnSort := !reverseOrderOnSort
   INIaction(1, "reverseOrderOnSort", "General")
}

TglCheckDeadFilesSort() {
   OnSortdoFilesCheck := !OnSortdoFilesCheck
   INIaction(1, "OnSortdoFilesCheck", "General")
}

ToggleHistoInfoBoxu() {
   prevState := (showHistogram>1 || showInfoBoxHUD>=1) ? 1 : 0
   imgPath := getIDimage(currentFileIndex)
   If (prevState!=1)
   {
      If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
         Return
   }

   showHistogram := (prevState=0) ? 1 : 0
   showInfoBoxHUD := (prevState=0) ? 1 : 2
   ToggleImgHistogram(1)
   ToggleInfoBoxu()
   RemoveTooltip()
}

ToggleInfoBoxu() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 85) ; || (thumbsDisplaying=1)
       Return

    lastInvoked := A_TickCount
    showInfoBoxHUD++
    showInfoBoxHUD := clampInRange(showInfoBoxHUD, 0, 2, 1)
    INIaction(1, "showInfoBoxHUD", "General")
    If (thumbsDisplaying=1)
       SetTimer, mainGdipWinThumbsGrid, -50
    Else
       SetTimer, dummyRefreshImgSelectionWindow, -50
    ; dummyTimerDelayiedImageDisplay(50)
}

ToggleImgCaptions() {
    Static lastInvoked := 1
    If (thumbsDisplaying=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    showImgAnnotations := !showImgAnnotations
    INIaction(1, "showImgAnnotations", "General")
    SetTimer, dummyRefreshImgSelectionWindow, -50
    If (showImgAnnotations=1)
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       textFile := OutDir "\" OutNameNoExt ".txt"
       If (SLDtypeLoaded=3)
          textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

       If (!FileExist(textFile) && SLDtypeLoaded!=3) || (!textFileContent && SLDtypeLoaded=3)
          showTOOLtip("Display image captions: ACTIVATED`n" OutNameNoExt ".txt (NOT FOUND)`nNo image caption / annotation file associated`nPress Shift+N to create/edit one.")
       Else
          showTOOLtip("Display image captions: ACTIVATED")
    } Else showTOOLtip("Display image captions: DEACTIVATED")
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMultiLineStatus() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 55)
       Return

    lastInvoked := A_TickCount
    multilineStatusBar := !multilineStatusBar
    INIaction(1, "multilineStatusBar", "General")
    dummyTimerDelayiedImageDisplay(50)
    CreateGuiButton("File options,,invokeFileOptionsMenu", 0, msgDisplayTime//1.5 + 500)
}

invokeFileOptionsMenu() {
   deleteMenus()
   createMenuCurrentFile()
   showThisMenu("PVtFile")
}

invokeSelectionAreaMenu(modus:=0) {
   deleteMenus()
   createMenuSelectionArea(modus)
   showThisMenu("PVselv")
}

invokeNavigationMenu() {
   deleteMenus()
   createMenuNavigation()
   showThisMenu("PVnav")
}

folderzNavLoadAllSiblings() {
   initialFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)
   baseFolder := StrReplace(baseFolder, "|")
   If FolderExist(baseFolder)
      OpenFolders(baseFolder)
}

invokeFoldersListerMenu() {
    Static menusList := "PVmFsibs|PVmFsubs|PVmFparents|PVmFexplorer"

    Loop, Parse, menusList, |
        Try Menu, % A_LoopField, Delete

    baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
    If (SLDtypeLoaded!=1)
       baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

    If !InStr(baseFolder, ":\")
       Return "err"

    sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
    parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
    If (sibsObj.Count()>1)
    {
       Try Menu, PVmFsibs, Add, &See all, folderzNavLoadAllSiblings
       Try Menu, PVmFsibs, Add,
    }

    Loop, % sibsObj.Count()
    {
       Try Menu, PVmFsibs, Add, % A_Index ". " sibsObj[A_Index], folderzNavInvokeSib
       If (A_Index=currentSib)
          Try Menu, PVmFsibs, Check, % A_Index ". " sibsObj[A_Index]
    }

    Loop, % parentsObj.Count()
    {
       Try Menu, PVmFparents, Add, % A_Index ". " parentsObj[A_Index], folderzNavInvokeParents
       If (A_Index=1)
          Try Menu, PVmFparents, Disable, % A_Index ". " parentsObj[A_Index]

       If (A_Index=currentParent)
          Try Menu, PVmFparents, Check, % A_Index ". " parentsObj[A_Index]
    }

    thisFolder := StrReplace(Trimmer(baseFolder), "|")
    If (SLDtypeLoaded=1)
    {
       Menu, PVmFsubs, Add, &See all`tCtrl+F5, invertCurrentFolderRecursiveness
       If !InStr(CurrentSLD, "|")
          Menu, PVmFsubs, Check, &See all`tCtrl+F5
       Menu, PVmFsubs, Add,
    }

    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", D
       {
          If (A_LoopFileName!="")
          {
             Try Menu, PVmFsubs, Add, % A_Index ". " A_LoopFileName, folderzNavInvokeSubs
             hasAddedSubs := 1
          }
       }
    }

    friendly := (SLDtypeLoaded=1) ? "Currently opened" : "Selected file"
    Menu, PVmFexplorer, Add, %friendly% folder:, dummy
    Menu, PVmFexplorer, Disable, %friendly% folder:
    Try Menu, PVmFexplorer, Add, % PathCompact(baseFolder, 40), OpenQPVfileFolder
    If (SLDtypeLoaded=1)
       Try Menu, PVmFexplorer, Disable, % PathCompact(baseFolder, 40)

    Menu, PVmFexplorer, Add
    If (FolderExist(thisFolder) && hasAddedSubs=1)
    {
       Try Menu, PVmFexplorer, Add, Sub-folders, :PVmFsubs
    } Else
    {
       Try Menu, PVmFexplorer, Add, No sub-folders, dummy
       Try Menu, PVmFexplorer, Disable, No sub-folders
    }

    If (parentsObj.Count()>0)
    {
       Menu, PVmFexplorer, Add
       Try Menu, PVmFexplorer, Add, Breadcrumb folders hierarchy, :PVmFparents
       If (parentsObj.Count()>1 && SLDtypeLoaded=1)
       {
          Menu, PVmFexplorer, Add, Next breadcrumb`tCtrl+Page Down, MenuFolderExplorerUpDown
          Menu, PVmFexplorer, Add, Previous breadcrumb`tCtrl+Page Up, MenuFolderExplorerUpDown
       }
    }

    If (sibsObj.Count()>0)
    {
       Menu, PVmFexplorer, Add
       Try Menu, PVmFexplorer, Add, Sibling folders, :PVmFsibs
       If (SLDtypeLoaded=1)
       {
          Menu, PVmFexplorer, Add, Next sibling`tAlt+Page Down, MenuFolderExplorerSiblings
          Menu, PVmFexplorer, Add, Previous sibling`tAlt+Page Up, MenuFolderExplorerSiblings
       }
    } Else
    {
       Try Menu, PVmFexplorer, Add, No sibling folders, dummy
       Try Menu, PVmFexplorer, Disable, No sibling folders
    }

    Menu, PVmFexplorer, Add
    If (folderTreeWinOpen!=1)
    {
       Menu, PVmFexplorer, Add, Folders tree view`tF4, MenuPanelFoldersTree
    } Else
    {
       Menu, PVmFexplorer, Add, Copy folder tree path, folderTreeCopyPath
       Menu, PVmFexplorer, Add, Collapse/expand entire folder tree, folderTreeExpandCollapseAll
    }

    showThisMenu("PVmFexplorer")
}

MenuFolderExplorerUpDown(menuItem) {
   If InStr(menuItem, "next")
      FileExploreUpDownLevel(1)
   Else
      FileExploreUpDownLevel(-1)
}

MenuFolderExplorerSiblings(menuItem) {
   If InStr(menuItem, "next")
      FileExploreSiblingsNav(1)
   Else
      FileExploreSiblingsNav(-1)
}

folderzNavInvokeSubs(menuItem) {
    baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
    If (SLDtypeLoaded!=1)
       baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

    oldFolder := baseFolder
    openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
    thisFolder := StrReplace(Trimmer(baseFolder), "|")
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", D
       {
          If (A_Index=openThisu)
          {
             hasFound := 1
             thisFolder .= "\" A_LoopFileName
             Break
          }
       }
    }
    If (hasFound!=1)
       Return

    tryOpenGivenFolder(thisFolder, oldFolder)
}

tryOpenGivenFolder(thisFolder, oldFolder) {
   oldFolderu := StrReplace(oldFolder, "|")
   thisFolder := StrReplace(thisFolder, "|")
   thisFolder := StrReplace(Trimmer(thisFolder, "\"), "\\", "\")
   If !FolderExist(thisFolder)
   {
      showTOOLtip("ERROR: Folder not found or access denied:`n" thisFolder)
      SoundBeep , 300, 100
      Return
   }

   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   initially := thisFolder
   maxFilesIndex := 0
   SLDtypeLoaded := 1
   coreOpenFolder("|" thisFolder, 0, 0, 0, 1)
   If (maxFilesIndex<1)
   {
      addJournalEntry("Failed to find image files in: |" thisFolder)
      If !FolderExist(oldFolderu)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have attempted to open: " thisFolder "\. QPV found no supported image files in the folder.`n`nWould you like to recursively scan the given folder for supported image files?", 4, 0, "question")
      Else msgResult := "Yes"

      If (msgResult="Yes" || !FolderExist(oldFolderu))
      {
         coreOpenFolder(thisFolder, 0, 0, 0, 1)
         CurrentSLD := thisFolder
      }
   } Else CurrentSLD := "|" thisFolder

   hasFailed := 0
   If (maxFilesIndex<1 && FolderExist(oldFolderu))
   {
      addJournalEntry("Failed to recursively find image files in: " thisFolder "\`nReopening initial folder: " oldFolder)
      coreOpenFolder(oldFolder, 0, 0, 0, 1)
      CurrentSLD := oldFolder
      hasFailed := 1
   } Else If (maxFilesIndex<1)
      resetMainWin2Welcome()

   If (maxFilesIndex>1)
      prevOpenFolderPath := StrReplace(CurrentSLD, "|")

   currentFilesListModified := 0
   currentFileIndex := clampInRange(oldIndex, 1, maxFilesIndex)
   If maxFilesIndex
      dummyTimerDelayiedImageDisplay(50)

   If (hasFailed=1 || maxFilesIndex<1)
   {
      showDelayedTooltip("WARNING: No image files found in the folder:`n" initially)
      SoundBeep , 300, 100
   } Else RemoveTooltip()
   Return hasFailed
}

folderzNavInvokeSib(menuItem) {
   sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
   openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
   FileExploreSiblingsNav(1, 0, 0, iLevel, openThisu)
   ; ToolTip, % menuItem "-" openThisu "-" c , , , 2

}

folderzNavInvokeParents(menuItem) {
   parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
   openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
   FileExploreUpDownLevel(1, 0, prevMaxLevels, openThisu)
   ; ToolTip, % menuItem "==" openThisu "==" c , , , 2
}

toggleImgSelCoords() {
   relativeImgSelCoords := !relativeImgSelCoords
   calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)
   INIaction(1, "relativeImgSelCoords", "General")
}

ToggleSelectGrid() {
   showSelectionGrid := !showSelectionGrid
   INIaction(1, "showSelectionGrid", "General")
   If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
}

toggleEllipseSelection() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   EllipseSelectMode := clampInRange(EllipseSelectMode + 1, 0, 2, 1)
   If (customShapePoints.Count()<3 && EllipseSelectMode=2)
   {
      INIaction(0, "FillAreaCustomShape", "General", 5)
      INIaction(0, "FillAreaCurveTension", "General", 2, 1, 4)
      customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
      decideCustomShapeStyle()
      If (customShapePoints.Count()<3)
      {
         MenuStartDrawingSelectionArea()
         Return
      }
   }

   If (imgEditPanelOpened=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)

   INIaction(1, "EllipseSelectMode", "General")
   showTOOLtip("Selection area: " DefineVPselAreaMode())
   If (EllipseSelectMode=2)
      dummy := "||Points tension " FillAreaCurveTension ",,togglePathCurveTension"

   CreateGuiButton("Draw new form,,MenuStartDrawingSelectionArea" dummy, 0, msgDisplayTime//1.5 + 500)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleImgSelectionAspectRatio() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   If !userCustomImgSelRatio
      INIaction(0, "userCustomImgSelRatio", "General", 2, 1, 7)

   lockSelectionAspectRatio++
   If (lockSelectionAspectRatio>7)
      lockSelectionAspectRatio := 1

   friendly := defineSelectionAspectRatios()
   If (LimitSelectBoundsImg=1)
      infou := "WARNING: The selection area is now no longer limited to the image boundaries"

   LimitSelectBoundsImg := 0
   ; INIaction(1, "desiredSelAspectRatio", "General")
   INIaction(1, "lockSelectionAspectRatio", "General")
   INIaction(1, "LimitSelectBoundsImg", "General")
   showTOOLtip(infou "Selection area aspect ratio locked to:`n" friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyRefreshImgSelectionWindow()
}

defineSelectionAspectRatios() {
   Static types := {0:"NONE", 1:"NONE", 2:"SQUARE [1:1]", 3:"SDTV [4:3]", 4:"35MM FILM [3:2]", 5:"HDTV [16:9]", 6:"WIDE SCREENS [16:10]", 7:"CUSTOM"}
   If (!lockSelectionAspectRatio || !isNumber(lockSelectionAspectRatio))
      lockSelectionAspectRatio := 1

   If (lockSelectionAspectRatio=2)
      desiredSelAspectRatio := 1
   Else If (lockSelectionAspectRatio=3)
      desiredSelAspectRatio := 4/3
   Else If (lockSelectionAspectRatio=4)
      desiredSelAspectRatio := 3/2
   Else If (lockSelectionAspectRatio=5)
      desiredSelAspectRatio := 16/9
   Else If (lockSelectionAspectRatio=6)
      desiredSelAspectRatio := 16/10
   Else If (lockSelectionAspectRatio=7)
      desiredSelAspectRatio := userCustomImgSelRatio
   Else
      desiredSelAspectRatio := 0

   If (lockSelectionAspectRatio=7)
      friendly := " [" userCustomImgSelRatio "]"

   Return types[lockSelectionAspectRatio] friendly
}

ToggleRecordOpenHistory() {
   allowRecordHistory := !allowRecordHistory
   INIaction(1, "allowRecordHistory", "General")
   ; If !allowRecordHistory
   ;    EraseOpenedHistory()
}

toggleLimitSelection() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   LimitSelectBoundsImg := !LimitSelectBoundsImg
   If (lockSelectionAspectRatio>1)
      infou := "WARNING: The selection area aspect ratio is now no longer locked.`n"

   lockSelectionAspectRatio := 1
   INIaction(1, "lockSelectionAspectRatio", "General")
   INIaction(1, "LimitSelectBoundsImg", "General")
   friendly := (LimitSelectBoundsImg=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip(infou "Limit selection area to image boundaries: " friendly)

   If (imgEditPanelOpened=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAlwaysFIMus() {
   alwaysOpenwithFIM := !alwaysOpenwithFIM
   r := initFIMGmodule()
   If InStr(r, "err - 126")
      friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2015."
   Else If InStr(r, "err - 404")
      friendly := "`n`nThe FreeImage.dll file seems to be missing..."

   INIaction(1, "alwaysOpenwithFIM", "General")
   If (FIMfailed2init=1)
      msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Various image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
   Else If (thumbsDisplaying!=1 && CurrentSLD && maxFilesIndex>0 && StrLen(UserMemBMP)<4)
      RefreshImageFileAction()
}

ToggleAnimGIFsupport() {
   animGIFsSupport := !animGIFsSupport
   INIaction(1, "animGIFsSupport", "General")
}

ToggleAutoRemEntries() {
   autoRemDeadEntry := !autoRemDeadEntry
   INIaction(1, "autoRemDeadEntry", "General")
}

TogglePromptDelete() {
   askDeleteFiles := !askDeleteFiles
   INIaction(1, "askDeleteFiles", "General")
}

ToggleTitleBaruNow(dummy:=0) {
   If (getCaptionStyle(PVhwnd)=0)
   {
      isTitleBarHidden := 0
      If (userAllowWindowDrag=1)
         TouchScreenMode := 0
      ; If (editingSelectionNow=1)
      ;    ToggleEditImgSelection()
      WinSet, Style, -0xC00000, ahk_id %PVhwnd%
   } Else
   {
      isTitleBarHidden := 1
      WinSet, Style, +0xC00000, ahk_id %PVhwnd%
   }
   interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
   interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
   INIaction(1, "isTitleBarHidden", "General")
   ; INIaction(1, "TouchScreenMode", "General")
   ; If (isTitleBarHidden=0)
   If (drawingShapeNow!=1)
      SetTimer, dummyToggleTitleBarActionBtns, -350
}

dummyToggleTitleBarActionBtns() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  friendly .= (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1) ? "`nAllow window dragging: ENABLED" : "`nAllow window dragging: DISABLED"
  friendly := Trimmer(friendly)
  1stLabel := (userAllowWindowDrag=1 && isTitleBarHidden=0) ? "Deactivate window dragging" : "Allow window dragging"
  1stact := "toggleWindowDraggableMode"
  If (TouchScreenMode!=1)
  {
     2ndLabel := "Activate touch screen mode"
     2ndact := "ToggleTouchMode"
  }
  If (getCaptionStyle(PVhwnd)!=1)
  {
     1stLabel := "Interface options"
     1stact := "OpenUImenu"
  }

  ; If (isTitleBarHidden=0)
  CreateGuiButton(1stLabel ",," 1stact "||" 2ndLabel ",," 2ndact, "force", msgDisplayTime + 500)
  showTOOLtip(friendly)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleQuickBaru() {
   Static lastInvoked := 1
   showMainMenuBar := !showMainMenuBar
   INIaction(1, "showMainMenuBar", "General")
   interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
   If !showMainMenuBar
      Win_SetMenu(PVhwnd, 0)

   TriggerMenuBarUpdate()
   If (A_TickCount - lastInvoked > 900)
      CreateGuiButton("Interface options,,OpenUImenu", 0, msgDisplayTime//1.5 + 500)

   lastInvoked := A_TickCount
}

ToggleTitleBaru() {
   SetTimer, ToggleTitleBaruNow, -150
}

ToggleInfoToolTips() {
    noTooltipMSGs := !noTooltipMSGs
    INIaction(1, "noTooltipMSGs", "General")
}

ToggleLargeUIfonts() {
    PrefsLargeFonts := !PrefsLargeFonts
    ; If (AnyWindowOpen=14)
    ;    openPrefsPanelWindow()

    calcHUDsize()
    INIaction(1, "PrefsLargeFonts", "General")
    interfaceThread.ahkassign("PrefsLargeFonts", PrefsLargeFonts)
    thisFunc := prevOpenedWindow[2]
    If (AnyWindowOpen && thisfunc)
    {
       BtnCloseWindow()
       Sleep, 5
       openPreviousPanel("forced")
    }
}

ToggleTexyBGR() {
    usrTextureBGR := !usrTextureBGR
    INIaction(1, "usrTextureBGR", "General")
    RefreshImageFile()
}

ToggleImgNavBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50)
       Return

    showHUDnavIMG := !showHUDnavIMG
    INIaction(1, "showHUDnavIMG", "General")
    dummyTimerDelayiedImageDisplay(25)
    SetTimer, dummyNavBoxInfo, -150
    lastInvoked := A_TickCount
}

ToggleImgNavSizeBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (showHUDnavIMG!=1)
       Return

    HUDnavBoxSize := (HUDnavBoxSize=75) ? 125 : 75
    If (thumbsDisplaying=1)
       mainGdipWinThumbsGrid()
    Else
       dummyTimerDelayiedImageDisplay(25)
    lastInvoked := A_TickCount
}

dummyNavBoxInfo() {
    friendly := (IMGlargerViewPort=1) ? "" : "`nThe navigator will be displayed`nwhen the image is larger than the viewport."
    If (thumbsDisplaying=1)
       friendly := (thumbnailsListMode=1) ? "" : "`nImage preview box will be displayed in other list modes`nPress L to toggle between modes"

    labelu := (thumbsDisplaying=1) ? "preview" : "navigator"
    If (showHUDnavIMG=1)
       showTOOLtip("Image " labelu " display: AUTO" friendly)
    Else
       showTOOLtip("Image " labelu ": OFF")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgHistogram(direction) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1)
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    If (direction=1)
       showHistogram++
    Else
       showHistogram--

    showHistogram := clampInRange(showHistogram, 1, 6, 1)
    INIaction(1, "showHistogram", "General")
    If (showHistogram>1)
       showTOOLtip("Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode())
    Else
       showTOOLtip("Histogram: NONE")

    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, showHistogram, % showHistogram
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
    lastInvoked := A_TickCount
}

ToggleHistogramMode() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 || showHistogram<=1)
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    lastInvoked := A_TickCount
    histogramMode++
    histogramMode := clampInRange(histogramMode, 1, 3, 1)
    INIaction(1, "histogramMode", "General")
    showTOOLtip("Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode())
    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, histogramMode, % histogramMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

defineHistogramType() {
    If (showHistogram=1)
       friendly := "NONE"
    Else If (showHistogram=2)
       friendly := "LUMINANCE"
    Else If (showHistogram=3)
       friendly := "RED"
    Else If (showHistogram=4)
       friendly := "GREEN"
    Else If (showHistogram=5)
       friendly := "BLUE"
    Else If (showHistogram=6)
       friendly := "ALL MIXED"

    Return friendly
}

defineHistogramMode() {
    If (histogramMode=1)
       friendly := "LOWS"
    Else If (histogramMode=2)
       friendly := "BALANCED"
    Else If (histogramMode=3)
       friendly := "PEAKS"

    Return friendly
}

ToggleThumbsCaching() {
    enableThumbsCaching := !enableThumbsCaching
    INIaction(1, "enableThumbsCaching", "General")
}

ToggleSkipDeadFiles() {
    skipDeadFiles := !skipDeadFiles
    INIaction(1, "skipDeadFiles", "General")
}

ToggleIgnoreSLDprefs() {
    MustLoadSLDprefs := !MustLoadSLDprefs
    INIaction(1, "MustLoadSLDprefs", "General")
}

ToggleCycleFavesOpen() {
    cycleFavesOpenIMG := !cycleFavesOpenIMG
    INIaction(1, "cycleFavesOpenIMG", "General")
}

ToggleImgQuality(modus:=0) {
    userimgQuality := !userimgQuality
    If (modus="lowu")
       userimgQuality := 0
    Else If (modus="highu")
       userimgQuality := 1
    Else
       INIaction(1, "userimgQuality", "General")

    fnOutputDebug("Set viewport quality: " modus "--" forceIT "==" userimgQuality)
    imgQuality := (userimgQuality=1) ? 7 : 5
    PixelMode := (userimgQuality=1) ? 2 : 0
    smoothMode := (userimgQuality=1) ? 4 : 1
    compositingQuality := (userimgQuality=1) ? 0 : 1

    Gdip_SetInterpolationMode(glPG, imgQuality)
    Gdip_SetPixelOffsetMode(glPG, PixelMode)
    Gdip_SetSmoothingMode(glPG, smoothMode)
    Gdip_SetCompositingQuality(glPG, compositingQuality)

    Gdip_SetInterpolationMode(2NDglPG, imgQuality)
    Gdip_SetPixelOffsetMode(2NDglPG, PixelMode)
    Gdip_SetSmoothingMode(2NDglPG, smoothMode)
    Gdip_SetCompositingQuality(2NDglPG, compositingQuality)
}

toggleScreenSaverMode() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked<600)
       Return

    screenSaverMode := !screenSaverMode
    SoundBeep , % (screenSaverMode=1) ? 900 : 300, 100
    If (screenSaverMode=1)
       SetTimer, drawWelcomeImg, -50
    Else
       SetTimer, drawWelcomeImg, Off

    lastInvoked := A_TickCount
}

ToggleRAWquality() {
    userHQraw := !userHQraw
    INIaction(1, "userHQraw", "General")
}

ToggleMultiCoreSupport() {
    allowMultiCoreMode := !allowMultiCoreMode
    INIaction(1, "allowMultiCoreMode", "General")
    If (thumbsDisplaying=1 && thumbnailsListMode!=1 && multiCoreThumbsInitGood="n")
       initAHKhThumbThreads()
}

ToggleLimitMemUsage() {
    minimizeMemUsage := !minimizeMemUsage
    INIaction(1, "minimizeMemUsage", "General")
    If (minimizeMemUsage=1)
    {
       msgBoxWrapper(appTitle ": WARNING", "By limiting memory usage, the performance of Quick Picto Viewer will likely be drastically reduced. Additionally, some features or functions might be disabled.", 0, 0, "exclamation")
       discardViewPortCaches()
    }
}

TogglePreventUndos() {
    preventUndoLevels := !preventUndoLevels
    maxMemUndoLevels := (preventUndoLevels=1) ? 100 : 979394
}

ToggleImgColorDepthDithering() {
    ColorDepthDithering := !ColorDepthDithering
    INIaction(1, "ColorDepthDithering", "General")
    If (thumbsDisplaying!=1)
       RefreshImageFile()
}

ToggleImgDownScaling() {
    If (thumbsDisplaying=1 || StrLen(UserMemBMP)>3)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    AutoDownScaleIMGs := !AutoDownScaleIMGs
    INIaction(1, "AutoDownScaleIMGs", "General")
    If (AutoDownScaleIMGs=1)
       showTOOLtip("Images larger than the screen resolution will be`ndownscaled prior to any potential effect.")
    Else
       showTOOLtip("Downscaling: DISABLED")
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, RefreshImageFileAction, -300
}

ToggleTouchMode() {
    DestroyTempBtnGui("now")
    TouchScreenMode := !TouchScreenMode
    updateUIctrl()
    interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
    interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
    INIaction(1, "TouchScreenMode", "General")
    INIaction(1, "isTitleBarHidden", "General")
    If (getCaptionStyle(PVhwnd)=1 && TouchScreenMode=1 && userAllowWindowDrag=1)
       toggleWindowDraggableMode()
}

defineWinTitlePrefix() {
   Static FXmodesLabels := {2:"cP", 3:"cAUTO", 4:"cGR", 5:"cR", 6:"cG", 7:"cB", 8:"cA", 9:"cI"}

   If StrLen(UserMemBMP)>1
      winPrefix .= "IMAGE EDITING | "

   If StrLen(filesFilter)>1
      winPrefix .= "F "

   If hSNDmedia
      winPrefix .= "(A) "

   If (editingSelectionNow=1)
      winPrefix .= "SEL "

   If (slideShowRunning=1)
   {
      winPrefix .= "s"
      If (SlideHowMode=1)
         winPrefix .= "R "
      Else If (SlideHowMode=2)
         winPrefix .= "B "
      Else If (SlideHowMode=3)
         winPrefix .= "F "
   }

   If (usrColorDepth>1)
      winPrefix .= internalColorDepth  " bits "

   If (FlipImgV=1)
      winPrefix .= "V "
   If (FlipImgH=1)
      winPrefix .= "H "

   If (thisIMGisDownScaled=1)
      winPrefix .= "DWS "

   If FXmodesLabels.HasKey(imgFxMode)
      winPrefix .= FXmodesLabels[imgFxMode] A_Space

   If (IMGresizingMode=3)
      winPrefix .= "O "
   Else If (IMGresizingMode=4)
      winPrefix .= "Z "

   Return winPrefix
}

calculateTouchMargins(ByRef thisX, ByRef thisY, ByRef thisW, ByRef thisH) {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   thisX := (editingSelectionNow=1) ? mainWidth//8 : mainWidth//7
   thisY := (editingSelectionNow=1) ? mainHeight//6 : mainHeight//5
   thisW := mainWidth - thisX*2
   thisH := mainHeight - thisY*2
}

drawWelcomeImg() {
    Critical, on
    If StrLen(UserMemBMP)>2
       thisClippyIMG := 1

    If (maxFilesIndex>0 || thisClippyIMG=1 || StrLen(CurrentSLD)>1 || AnyWindowOpen>0)
    {
       screenSaverMode := 0
       Return
    }

    If (A_TickCount - scriptStartTime>550)
    {
       If (identifyThisWin()!=1)
       {
          screenSaverMode := 0
          Return
       }
    }

    thisZeit := A_TickCount
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    Random, modelu, 1, 8
    If (modelu=8)
       Random, modelu, 1, 8

    Random, moduz, 1, 9
    Random, iterations, 10, 30
    Random, sweepRand, 1, 9

    ; pBr4 := Gdip_BrushCreateSolid("0x55030201")
    BMPcache := coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, mainWidth, mainHeight, 5, 5, 1)
    If !BMPcache
    {
       Gdip_DeleteBrush(pBr4)
       addJournalEntry("Welcome screen failed to render... mainBMP=" BMPcache " -- pG=" G)
       setWindowTitle(appTitle " v" appVersion, 1)
       SetTimer, drawWelcomeImg, Off
       Return
    }

    getColors := (imgFxMode=3 || imgFxMode=8) ? 0 : 1
    If (getColors=1)
       decideGDIPimageFX(matrix, imageAttribs, zEffect)

    If !isWinXP
       pEffect := Gdip_CreateEffect(1, 3, 0, 0)

    If pEffect
       Gdip_BitmapApplyEffect(BMPcache, pEffect)

    r1 := trGdip_DrawImage(A_ThisFunc, glPG, BMPcache, 0, 0, mainWidth, mainHeight, 0, 0, mainWidth, mainHeight,,, imageAttribs)
    Gdip_AddPathGradient(glPG, 0, 0, mainWidth, mainHeight, mainWidth//2, mainHeight//2, "0x00000000", "0x65010101", 1, 0, 0, 1)
    If (TouchScreenMode=1 && screenSaverMode!=1)
    {
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//11
       Penuha := Gdip_CreatePen("0x34334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x05EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x10778877)
       Gdip_FillRectangle(glPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(glPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(glPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)

       Gdip_SetClipRect(glPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(glPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(glPG)
       Gdip_DrawRectangle(glPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(glPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)
    }

    trGdip_DisposeImage(BMPcache, 1)
    r2 := LrydWinUpdt(hGDIwin, glHDC)
    Gdip_DeleteBrush(pBr4)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    Gdip_DisposeImageAttributes(imageAttribs)

    Gdip_DeleteGraphics(G)
    updateUIctrl()
    addJournalEntry("Welcome screen rendered in " A_TickCount - thisZeit " ms." r2 " - " r1)
    setWindowTitle(appTitle " v" appVersion, 1)
    If (A_TickCount - thisZeit<250) || (screenSaverMode=1)
       SetTimer, drawWelcomeImg, -3500
    Else
       SetTimer, drawWelcomeImg, Off
}

coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, mainWidth, mainHeight, minX, minY, startMode, previewMode:=0, usePrevious:=0) {
    Static prevObj := [], prevBMPu, prevState

    If (modelu="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    thisState := "a" kimgSelW kimgSelH AnyWindowOpen vPselRotation FillAreaInverted modelu iterations moduz sweepRand minX minY startMode previewMode usePrevious
    If (thisState=prevState && previewMode=1 && StrLen(prevBMPu)>2)
       Return trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
 
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    BMPcache := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, "0xE200B")
    If BMPcache
    {
       If (userimgQuality!=1 && previewMode=1) || (previewMode=1) || (startMode=1 && userimgQuality!=1)
          G := trGdip_GraphicsFromImage(A_ThisFunc, BMPcache, 1, 3)
       Else
          G := trGdip_GraphicsFromImage(A_ThisFunc, BMPcache, 7, 4)
    }

    If (!BMPcache || !G)
    {
       prevState := 0
       trGdip_DisposeImage(BMPcache, 1)
       Return
    }

    If (usePrevious=1 && prevObj.type!=modelu)
       usePrevious := 0

    If (usePrevious!=1)
    {
       scaleuX := scaleuY := 1
       prevObj.type := modelu
       prevObj.mW := mainWidth
       prevObj.mH := mainHeight
       Random, a, 22, 66
       Random, b, 22, 66
       Random, c, 22, 66
       Random, d, 66, 99
       Random, anglu, 0.0, 24.5
       If (startMode!=1)
          anglu := vPselRotation + anglu/12
       prevObj.a := a
       prevObj.b := b
       prevObj.c := c
       prevObj.d := d
       prevObj.anglu := anglu
    } Else
    {
       scaleuX := prevObj.mW/mainWidth
       scaleuY := prevObj.mH/mainHeight
    }

    pBr1 := Gdip_BrushCreateSolid("0x" prevObj.a "882211")
    pBr2 := Gdip_BrushCreateSolid("0x" prevObj.b "112288")
    pBr3 := Gdip_BrushCreateSolid("0x" prevObj.c "118822")
    pBr5 := Gdip_BrushCreateSolid("0x" prevObj.d "939291")
    ; MsgBox, % minX "--" minY "`n" mainWidth "--" mainHeight "`n" bgrBrush
    If (GetKeyState("CapsLock", "T") && startMode=1)
       Gdip_FillRectangle(G, pBr5, 0, 0, mainWidth, mainHeight)
    ; Else If (startMode!=1)
    ;    Gdip_FillRectangle(G, bgrBrush, 0, 0, mainWidth, mainHeight)

    If (startMode=1)
       trGdip_GraphicsClear(A_ThisFunc, G, "0xFF" WindowBgrColor)

    Gdip_SetClipRect(G, 0, 0, mainWidth, mainHeight)
    cX := 0 + (mainWidth / 2)
    cY := 0 + (mainHeight / 2)
    pMatrix := Gdip_CreateMatrix()
    Gdip_TranslateMatrix(pMatrix, -cX , -cY)
    Gdip_RotateMatrix(pMatrix, prevObj.anglu, 1)
    Gdip_TranslateMatrix(pMatrix, cX, cY, 1)
    Gdip_SetWorldTransform(G, pMatrix)
    Gdip_DeleteMatrix(pMatrix)

    If (modelu=1)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % minY, % mainHeight
             Random, w, % minX, % mainWidth
             Random, h, % minY, % mainHeight
             w += 10
             h += 10
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          ; MsgBox, % xPos "--" yPos "`n" w "--" h "`n" tBrsh
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=2)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % minY, % mainHeight
             Random, w, % minX, % mainWidth//2 + mainHeight//2
             w += 5
             h := w
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=3 || modelu=5)
    {
       ; Random, moduz, 1, 9
       Loop, % iterations
       {  
          If (usePrevious!=1)
          {
             Random, w, 5, % mainWidth//1.5 + mainHeight//1.5
             w += 5
             h := w
             Random, deviation, -25, 25
             If (modelu=5)
                Random, moduz, 1, 9

             If (moduz=1)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else If (moduz=2)
             {
                xPos := 1 - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else If (moduz=3)
             {
                xPos := 1 - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=4)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=5)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=6)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             } Else If (moduz=7)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             } Else If (moduz=8)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else
             {
                xPos := 1 - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             }
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }

          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=6)
    {
       ; maurer rose; based on the implemention by hellbent found on AHK Forums
       If (startMode!=1)
          iterations := Ceil(iterations/10)
       Else
          Random, iterations, 2, 5

       o_sweepRand := sweepRand
       PetalPenA := Gdip_CreatePenFromBrush(pBr5, thickness)
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, thickness, 2.0, 3.5
             Random, tBrsh, 1, 3
             Random, ttBrsh, 1, 3
             If (startMode!=1)
                Random, sweepRand, 1, 9
             Else If (A_Index=1)
                sweepRand := o_sweepRand - 1
             Else If (A_Index=2)
                sweepRand := o_sweepRand + 1
             Else
                sweepRand := o_sweepRand

             Random, Petals, 2, 7
             If (startMode!=1)
                Petals := clampInRange(moduz + 1, 2, 9)

             prevObj[A_Index] := [thickness, Petals, sweepRand, ttBrsh, tBrsh]
          } Else
          {
             thickness := prevObj[A_Index, 1] / ((scaleuX + scaleuY)/2)
             Petals := prevObj[A_Index, 2]
             sweepRand := prevObj[A_Index, 3]
             ttBrsh := prevObj[A_Index, 4]
             tBrsh := prevObj[A_Index, 5]
          }

          PetalPen := Gdip_CreatePenFromBrush(pBr%ttBrsh%, thickness)
          SweepPen := Gdip_CreatePenFromBrush(pBr%tBrsh%, thickness)
          PetalList := SweepList := mainWidth//2 "," mainHeight//2 "|", Sweep := sweepRand
          Loop, 360
          {
              SweepList .= CalculateSweep(A_Index*Sweep, Petals, mainWidth//2, mainHeight//2)
              PetalList .= CalculateSweep(A_Index*3.14159/180, Petals, mainWidth//2, mainHeight//2)
          }
          PetalList .= mainWidth//2 "," mainHeight//2
          SweepList .= mainWidth//2 "," mainHeight//2
          Gdip_DrawLines(G, PetalPenA, PetalList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          ; Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, PetalPen, PetalList)
          Gdip_DeletePen(PetalPen)
          Gdip_DeletePen(SweepPen)
       }
       Gdip_DeletePen(PetalPenA)
    } Else If (modelu=4)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % -mainHeight, % minY
             Random, w, % minX, % mainWidth//2
             w += 5
             h := mainHeight*3
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }

          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=8)
    {
       Random, z, 0.02, 0.09 ; scale
       Random, l, 0.1, 0.45 ; opacity
       Gdip_SetInterpolationMode(G, 5)
       Gdip_SetPixelOffsetMode(G, 2)
       Gdip_ResetWorldTransform(G)
       noiseBMP := QPV_CreateBitmapNoise(Ceil(mainWidth*z), Ceil(mainHeight*z), 1, 0, 1)
       trGdip_DrawImage(A_ThisFunc, G, noiseBMP, 0, 0, mainWidth, mainHeight,,,,, l)
       trGdip_DisposeImage(noiseBMP, 1)
    } Else ; If (modelu=6)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % -mainWidth, % minY
             Random, yPos, % minY, % mainHeight
             w := mainWidth*3
             Random, h, % minY, % mainHeight//2
             h += 5
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    }
    
    Gdip_ResetWorldTransform(G)
    ; If (startMode!=1)
       ; Gdip_FillRectangle(G, overBrush, 0, 0, mainWidth, mainHeight)

    If (startMode!=1 && previewMode=1)
    {
       prevBMPu := trGdip_CloneBitmap(A_ThisFunc, BMPcache)
       prevState := thisState
    } Else prevState := 0

    Gdip_DeleteBrush(pBr1)
    Gdip_DeleteBrush(pBr2)
    Gdip_DeleteBrush(pBr3)
    Gdip_DeleteBrush(pBr5)
    Gdip_DeleteGraphics(G)
    Return BMPcache
}

CalculateSweep(InputValue, Petals, w, h) {
   r:=((w+h)//2)*Sin(Petals*InputValue)
   x:=r*cos(InputValue)+w
   y:=r*sin(InputValue)+h
   return x "," y "|"
}

addJournalEntry(msg) {
    Static currentEntry := 0, maxEntries := 256, lastError, prevEntry
    If (slideShowRunning=1 && slideShowDelay<300)
       Return

    If (msg="get_last_err")
       Return lastError

    If (msg="WinTitle: " pVwinTitle) || InStr(msg, "WinTitle: " appTitle " v" appVersion) || (msg="Loading") || (slideShowRunning=1 && slideShowDelay<600) || (animGIFplaying=1)
       Return

    ; mamUsage := GetProcessMemoryUsage(QPVpid)
    ; If (A_PtrSize=8)
    ;    systemMemInfo := GlobalMemoryStatusEx()
    ; thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
    ; memUsage := "Mem: " Round(max(mamUsage[1], mamUsage[8]) / 1024**2, 1) " MB " 
    ; ToolTip, % memUsage , , , 2

    If (hasInitSpecialMode=1 || prevEntry=msg)
       Return

    fnOutputDebug("User journal: " StrReplace(msg, "`n", " | "))
    If ((InStr(msg, "error") || InStr(msg, "fail")) && !InStr(msg, "dialog box:"))
       lastError := msg

    currentEntry++
    prevEntry := msg
    QPVjournal.InsertAt(1, getCurrentDate() ":`n" msg "`n")
    If (currentEntry>maxEntries)
    {
       currentEntry := maxEntries
       QPVjournal.Pop()
    }
}

getCurrentDate() {
   FormatTime, CurrentTimeB,, H:mm:ss
   FormatTime, CurrentDateB,, ShortDate
   Return CurrentDateB ", " CurrentTimeB
}

destroyGDIPcanvas() {
    qpvCanvasHasInit := 0
    Gdi_SelectObject(glHDC, glOBM)
    If glHbitmap
       Gdi_DeleteObject(glHbitmap)
    If glHDC
       Gdi_DeleteDC(glHDC)
    If glPG
       Gdip_DeleteGraphics(glPG)

    Gdi_SelectObject(2NDglHDC, 2NDglOBM)
    If 2NDglHbitmap
       Gdi_DeleteObject(2NDglHbitmap)
    If 2NDglHDC
       Gdi_DeleteDC(2NDglHDC)
    If 2NDglPG
       Gdip_DeleteGraphics(2NDglPG)

    glHbitmap := 2NDglHbitmap := ""
    glHDC := 2NDglHDC := ""
    glPG := 2NDglPG := ""
}

createGDIPcanvas(W:=0, H:=0) {
   Critical, on
   Static prevDimensions, hasInit
   If (A_TickCount - lastMenuBarUpdated<700)
      Return

   If (W=0 && H=0)
      GetWinClientSize(W, H, PVhwnd, 0)

   newDimensions := "w" W "-h" H "-mbar" showMainMenuBar
   doAgain := (prevDimensions!=newDimensions) ? 1 : 0
   If (!qpvCanvasHasInit || doAgain=1)
   {
      If (hasInit=1)
         destroyGDIPcanvas()

      ; gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
      imgQuality := (userimgQuality=1) ? 7 : 5
      If (minimizeMemUsage=1)
         imgQuality := ""    ; interpolation mode

      PixelMode := (userimgQuality=1) ? 2 : 0
      smoothMode := (userimgQuality=1) ? 4 : 1
      compositingQuality := (userimgQuality=1) ? 4 : 1
      glHDC := Gdi_CreateCompatibleDC()
      glHbitmap := Gdi_CreateDIBSection(W, H)
      glOBM := Gdi_SelectObject(glHDC, glHbitmap)
      glPG := Gdip_GraphicsFromHDC(glHDC, 0, imgQuality, smoothMode, 2, compositingQuality)
      Gdip_SetPixelOffsetMode(glPG, PixelMode)

      2NDglHDC := Gdi_CreateCompatibleDC()
      2NDglHbitmap := Gdi_CreateDIBSection(W, H)
      2NDglOBM := Gdi_SelectObject(2NDglHDC, 2NDglHbitmap)
      2NDglPG := Gdip_GraphicsFromHDC(2NDglHDC, 0, imgQuality, smoothMode, 2, compositingQuality)
      Gdip_SetPixelOffsetMode(2NDglPG, PixelMode)

      hasInit := 1
      prevDimensions := newDimensions
      addJournalEntry("Canvas infos: " prevDimensions " - glPG:" glPG " - glHDC:" glHDC " - glOBM:" glOBM " - glHbmp:" glHbitmap " - 2NDglPG:" 2NDglPG " - 2NDglHDC:" 2NDglHDC " - 2NDglOBM:" 2NDglOBM " - 2NDglHbmp:" 2NDglHbitmap)
      If (!glPG || !glHDC || !glHbitmap || !glOBM || !2NDglPG || !2NDglHDC || !2NDglOBM || !2NDglHbitmap)
      {
         qpvCanvasHasInit := 0
         prevDimensions := "r"
         ; MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+ window...`n`nThe program will probably malfunction or crash.
         handleFatalWinInitErrors()
      } Else
      {
         qpvCanvasHasInit := 1
         addJournalEntry("Main canvas created: " W " x " H " px.")
      }
   }
}

handleFatalWinInitErrors() {
   msgResult := msgBoxWrapper(appTitle ": FATAL ERROR", appTitle " was unable to initialize the GDI+ windows required to display images.`n`nWould you like to try initialize it again? By choosing to continue, the application may malfunction.", "&Try again|&Continue|&Exit", 1, "error")
   If InStr(msgResult, "again")
   {
      restartEntireGui()
   } Else If InStr(msgResult, "exit")
   {
      hasInitSpecialMode := 1
      ForceExitNow()
   }
}

restartEntireGui() {
   destroyGDIPcanvas()
   interfaceThread.ahkFunction("destroyAllGUIs")
   Sleep, 25
   externObj := WindowBgrColor "$" isAlwaysOnTop "$" mainCompiledPath "$" isTitleBarHidden "$" TouchScreenMode "$" userAllowWindowDrag "$" mainWinPos "$" mainWinSize "$" mainWinMaximized
   initGUI := interfaceThread.ahkFunction("BuildGUI", externObj)
   fnOutputDebug("RESTARTED extern UI HWNDs: " initGUI)
   If InStr(initGui, "|")
      handleUIhwnd(InitGui)

   createGDIPcanvas()
}

handleUIhwnd(initGui) {
   externObj := StrSplit(initGUI, "|")
   PVhwnd := externObj[1]
   hGDIinfosWin := externObj[2]
   hGDIwin := externObj[3]
   hGDIthumbsWin := externObj[4]
   hGDIselectWin := externObj[5]
   hPicOnGui1 := externObj[6]
   winGDIcreated := externObj[7]
   ThumbsWinGDIcreated := externObj[8]
   If (!PVhwnd || !hGDIinfosWin || !hGDIwin || !hGDIthumbsWin || !hGDIselectWin || !hPicOnGui1)
   {
      handleFatalWinInitErrors()
   } Else
   {
      GroupAdd, QPVwindows, ahk_id %PVhwnd%
      GroupAdd, QPVwindows, ahk_id %hGDIthumbsWin%
      GroupAdd, QPVwindows, ahk_id %hGDIwin%
      GroupAdd, QPVwindows, ahk_id %hGDIselectWin%
      GroupAdd, QPVwindows, ahk_id %hGDIinfosWin%
      updateUIctrl()
   }
}

InitGDIpStuff() {
; create pens and brushes
   pPen1 := Gdip_CreatePen("0xCCbbccbb", 3)
   pPen1d := Gdip_CreatePen("0xCCbbccbb", 3)
   Gdip_SetPenDashArray(pPen1d, "1.1,1.1")
   pPen2 := Gdip_CreatePen("0xBBffccbb", 3)
   pPen3 := Gdip_CreatePen("0x66334433", imgHUDbaseUnit//8)
   pPen4 := Gdip_CreatePen("0x88998899", imgHUDbaseUnit//11)
   pPen5 := Gdip_CreatePen("0x880088FF", imgHUDbaseUnit//11.5)
   pPen6 := Gdip_CreatePen("0xDD998822", imgHUDbaseUnit//6)
   Gdip_SetPenDashArray(pPen4, "0.5,0.5")
   pBrushA := Gdip_BrushCreateSolid("0x90898898")
   pBrushB := Gdip_BrushCreateSolid("0xBB898898")
   pBrushC := Gdip_BrushCreateSolid("0x77898898")
   pBrushD := Gdip_BrushCreateSolid("0xDDbbccFF")
   pBrushE := Gdip_BrushCreateSolid("0x77333333")
   pBrushF := Gdip_BrushCreateSolid("0x33667766")
   pBrushZ := Gdip_BrushCreateSolid("0xFF000000")

   ; createCheckersBrush(20)
   pBrushHatchLow := Gdip_BrushCreateHatch("0xff999999", "0xff111111", 50)
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
}

useHatchedBrush(dummy:=0) {
   If (dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha!=1)
      Return
   Else If (coreDesiredPixFmt="0x21808" || dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha=1)
      Return pBrushZ
   Else 
      Return pBrushHatchLow
}

ToggleSeenIMGstatus() {
   initSeenImagesListDB()
   If (thumbsDisplaying!=1 || sqlFailedInit=1)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   mustRem := 0 
   imgPath := getIDimage(currentFileIndex)
   cachedAllSessionsSeen[Format("{:L}", imgPath)] := "-"
   resultedFilesList[currentFileIndex, 3] := ""
   seenImagesDB.Exec("COMMIT TRANSACTION;")
   If retrieveSeenImageDBentry(imgPath, currentFileIndex)
      mustRem := 1 
   
   If markedSelectFile
   {
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      countFilez := 0
      getSelectedFiles(0, 1)
      friendly := (mustRem=1) ? "UNSEEN" : "SEEN"
      showTOOLtip("Marking as " friendly markedSelectFile " images, please wait")
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      doStartLongOpDance()
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue
      
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(countFilez, markedSelectFile, startOperation)
            showTOOLtip("Marking as " friendly " images, please wait" etaTime, 0, 0, countFilez / markedSelectFile)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countFilez++
         resultedFilesList[A_Index, 3] := ""
         imgPath := resultedFilesList[A_Index, 1]
         cachedAllSessionsSeen[Format("{:L}", imgPath)] := "-"
         If (mustRem=1)
            deleteSQLseenEntry(imgPath, A_Index)
         Else
            recordSeenIMGdbEntry(imgPath, A_Index, 0)
      }

      If !seenImagesDB.Exec("COMMIT TRANSACTION;")
         someERR := "Failed to commit changes to the SQL database`n"

      If (abandonAll=1)
         showTOOLtip(someERR "Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected images were marked as " friendly ".")
      Else
         showTOOLtip(someERR "Finished marking " groupDigits(countFilez) " images as " friendly ".")

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % (abandonAll=1) ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      If (mustRem=1)
         deleteSQLseenEntry(imgPath, currentFileIndex)
      Else
         recordSeenIMGdbEntry(imgPath, currentFileIndex, 0)

      If !seenImagesDB.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   }

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
}

CleanDeadFilesSeenImagesDB(doPartial:=0, partu:=0) {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If AnyWindowOpen
     BtnCloseWindow()


   If (doPartial!="yesu")
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to purge no longer existent files from the list of seen images?`n`nThis action is irreversible and may take awhile...", "&Continue|C&ancel", 2, "question")
      If !InStr(msgResult, "continue")
         Return
   }

  startOperation := A_TickCount
  showTOOLtip("Removing entries of inexistent files from the already seen images database, please wait")
  doStartLongOpDance()
  prevMSGdisplay := A_TickCount
  startOperation := A_TickCount
  entriesCount := entriesScanned := entriesDoneCount := 0
  RecordSet := ""
  npartu := StrReplace(partu, "\viewed-images-history-")
  npartu := StrReplace(npartu, ".sld")
  If (doPartial="yesu" && !InStr(partu, "-viewed-images-history-current-session"))
     SQL := "SELECT imgfile FROM images WHERE imgViewDate LIKE '" npartu "%';"
  Else
     SQL := "SELECT imgfile FROM images;"

  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entries := []
  seenImagesDB.Exec("BEGIN TRANSACTION;")
  entriesCount := RecordSet.RowCount
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      item := Trimmer(Rowu[1])
      If !FileExist(item)
      {
         deleteSQLseenEntry(item, 0)
         entriesDoneCount++
      }

      entriesScanned++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(entriesScanned, entriesCount, startOperation)
         showTOOLtip("Removing entries of inexistent files from the seen images database, please wait" etaTime "`n" groupDigits(entriesDoneCount) " entries to inexistent files removed", 0, 0, entriesScanned / entriesCount)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
  }

  RecordSet.Free()
  If !seenImagesDB.Exec("COMMIT TRANSACTION;")
     throwSQLqueryDBerror(A_ThisFunc)

  If (doPartial!="yesu")
     seenImagesDB.Exec("VACUUM main;")

  zeitOperation := A_TickCount - startOperation
  etaTime := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
  If (abandonAll=1)
     etaTime .= "`nOperation aborted. " groupDigits(entriesScanned) " / " groupDigits(entriesCount) " entries were scanned until now"

  showTOOLtip(groupDigits(entriesDoneCount) " entries of inexistent files were removed from the database" etaTime)
  SetTimer, ResetImgLoadStatus, -50
  SoundBeep, 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return entries
}

retrieveEntireSeenImagesDB(ByRef entriesCount, doSorting, applyFilter:=0) {
  entriesCount := 0
  RecordSet := ""
  filteru := Strlen(applyFilter)>1 ? " WHERE imgViewDate LIKE '" applyFilter "%'" : ""
  orderu := (doSorting=1) ? " ORDER BY imgViewDate;" : ";"
  SQL := "SELECT imgfile FROM images" filteru orderu
  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entries := new hashtable(RecordSet.RowCount)
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      ; entries[CalcStringHash(Row[1], 0x8003)] := Row[1]
      If RegExMatch(Rowu[1], RegExFilesPattern)
      {
         entriesCount++
         entries[Format("{:L}", Rowu[1])] := 1
      }
  }

  RecordSet.Free()
  addJournalEntry("Recorded seen images: " entriesCount "`nRetrieved entries: " entries.Count())
  Return entries
}

deleteSQLseenEntry(imgPath, thisIndex) {
  SQLstr := "DELETE FROM images WHERE (imgfile='" imgPath "');"
  If !seenImagesDB.Exec(SQLStr)
  {
     stringA := imgPath
     seenImagesDB.EscapeStr(stringA)
     SQLstr := "DELETE FROM images WHERE (imgfile=" stringA ");"
     seenImagesDB.Exec(SQLStr)
  }

  resultedFilesList[thisIndex, 3] := 0
}

retrieveSeenImageDBentry(imgPath, thisIndex) {
  Static lastInvoked := 1

  If (!imgPath || (A_TickCount - lastInvoked<350) && (slideShowRunning!=1))
     Return 0

  If (resultedFilesList[thisIndex, 3]=1)
     Return 1
  Else If (resultedFilesList[thisIndex, 3]=0 && thumbsDisplaying=1)
     Return 0

  zu := cachedAllSessionsSeen[Format("{:L}", imgPath)]
  If (zu=1 && imgPath)
  {
     resultedFilesList[thisIndex, 3] := 1
     Return 1
  } Else If (thumbsDisplaying=1 && zu=0)
     Return 0
 
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  RecordSet := ""
  stringA := imgPath
  seenImagesDB.EscapeStr(stringA)
  SQL := "SELECT imgfile FROM images WHERE imgfile=" stringA " COLLATE NOCASE;"
  If !seenImagesDB.GetTable(SQL, RecordSet)
     Return 0

  entries := 0
  Loop, % RecordSet.RowCount
  {
     Rowu := RecordSet.Rows[A_Index]
     If (Trimmer(Rowu[1])=imgPath)
        entries := "yay"
  }

  RecordSet.Free()
  If entries
  {
     cachedAllSessionsSeen[Format("{:L}", imgPath)] := 1
     resultedFilesList[thisIndex, 3] := 1
     Return 1
  } Else
  {
     cachedAllSessionsSeen[Format("{:L}", imgPath)] := 0
     resultedFilesList[thisIndex, 3] := 0
     Return 0
  }

  lastInvoked := A_TickCount
}

recordSeenIMGdbEntry(imgPath, thisIndex, doCommits:=1) {
   Static invoked := 0
   If (resultedFilesList[thisIndex, 3]=1)
      Return

   If (doCommits=1)
      initSeenImagesListDB()

   If (sqlFailedInit=1)
      Return

   FormatTime, currDate, , yyyy-MM-dd@HH
   ; MD5name := currDate
   resultedFilesList[thisIndex, 3] := 1
   cachedAllSessionsSeen[Format("{:L}", imgPath)] := 1

   SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES ('" imgPath "', '" currDate "');"
   If !seenImagesDB.Exec(SQLStr)
   {
      stringA := imgPath
      seenImagesDB.EscapeStr(stringA)
      stringB := currDate
      seenImagesDB.EscapeStr(stringB)
      ; MsgBox, % stringA "--" stringB 
      SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES (" stringA ", " stringB ");"
      seenImagesDB.Exec(SQLStr)
   }

   If (invoked>15 && doCommits=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      invoked := 0
   }

   invoked++
}

eraseSeenIMGsDB() {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If !seenImagesDB
      Return

   msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete the list of seen images?`n`nThis action is irreversible. The actual files will be untouched, only the list of seen images is going to be erased.", "&Erase list|&Cancel", 2, "exclamation")
   If !InStr(msgResult, "erase list")
      Return

   If AnyWindowOpen
      BtnCloseWindow()

   seenImagesDB.CloseDB()
   FileDelete, % mainCompiledPath "\seenImagesList.db"
   Sleep, 5
   seenImagesDB := ""
   showTOOLtip("Already seen images list is now empty.`nEntries will be added only if the option`nto skip seen images is activated.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (mustRecordSeenImgs=1)
      initSeenImagesListDB()
}

initSeenImagesListDB() {
   If (sqlFailedInit=-1 || sqlFailedInit=1)
      Return

   If FileExist(mainCompiledPath "\seenImagesList.db")
      alreadyExisting := 1

   seenImagesDB := new SQLiteDB
   sqlFailedInit := seenImagesDB.hasFailedInit
   If !seenImagesDB.OpenDB(mainCompiledPath "\seenImagesList.db")
   {
      mustRecordSeenImgs := 0
      sqlFailedInit := 1
   } Else If (alreadyExisting!=1)
   {
      SQL := "CREATE TABLE images (imgfile TEXT COLLATE NOCASE UNIQUE ON CONFLICT IGNORE, imgViewDate TEXT, PRIMARY KEY(imgfile ASC)); CREATE INDEX imgsIndex ON images (imgfile COLLATE NOCASE);"
      If !seenImagesDB.Exec(SQL)
      {
         mustRecordSeenImgs := 0
         sqlFailedInit := 1
      } Else
      {
         sqlFailedInit := -1
         seenImagesDB.Exec("BEGIN TRANSACTION;")
      }
   } Else
   {
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      sqlFailedInit := -1
   }
}

SLDBinitSQLdb(fileNamu) {
   activeSQLdb.CloseDB()
   Sleep, 5
   activeSQLdb := new SQLiteDB
   activeSQLdb.OpenDB(fileNamu)
      ; Return -1

   SQL := "CREATE TABLE images (imgidu NUMERIC PRIMARY KEY NOT NULL, imgfile TEXT COLLATE NOCASE NOT NULL, imgfolder TEXT COLLATE NOCASE NOT NULL, fullPath TEXT AS (imgfolder||'\'||imgfile), fsize INT, kbfsize FLOAT AS (round(cast(fsize AS float)/1024,1)), fmodified INT, fcreated INT, imgwidth INT, imgheight INT, imgframes INT, imgdpi INT, imgpixfmt TEXT COLLATE NOCASE, imgwhratio FLOAT AS (round(cast(imgwidth AS float)/imgheight, 5)), imgmegapix FLOAT AS (round((cast(imgwidth AS float)*imgheight)/1000000, 5)), imgmedian FLOAT, imgavg FLOAT, imghpeak FLOAT, imghlow FLOAT, imghmode FLOAT, imghrms FLOAT, imghminu FLOAT, imghrange FLOAT, innerpixelz TEXT, outerpixelz TEXT, entireHush TEXT, pixelzHash TEXT, isDeleted INT DEFAULT 0, UNIQUE (fullPath));"
   SQL .= "CREATE TABLE imagesData (imgfile TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, imgCaption TEXT, imgAudio TEXT COLLATE NOCASE, PRIMARY KEY(imgfile ASC));"
   SQL .= "CREATE TABLE dynamicfolders (imgfolder TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, fmodified INT, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE staticfolders (imgfolder TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, fmodified INT, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE settings (paramz TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, valuez TEXT COLLATE NOCASE, PRIMARY KEY(paramz ASC, valuez ASC));"
   If !activeSQLdb.Exec(SQL)
      Return activeSQLdb.ErrorMsg
}

createCheckersBrush(size) {
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, size, size, "0xE200B")
   If !pBitmap
      Return

   pBr1 := Gdip_BrushCreateSolid("0x99ffFFff")
   pBr2 := Gdip_BrushCreateSolid("0x99515151")
   pBr3 := Gdip_BrushCreateHatch("0xff999999", "0xff111111", 50)

   G := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   Gdip_FillRectangle(G, pBr3, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr2, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr1, 0, 0, size//2, size//2)
   Gdip_FillRectangle(G, pBr1, size//2, size//2, size//2, size//2)
   Gdip_DeleteGraphics(G)
   pBrushHatch := Gdip_CreateTextureBrush(pBitmap, 0, 0, 0, size, size)
   trGdip_DisposeImage(pBitmap, 1)
   Gdip_DeleteBrush(pBr1)
   Gdip_DeleteBrush(pBr2)
   Gdip_DeleteBrush(pBr3)
}

refreshWinBGRbrush() {
   If pBrushWinBGR
      Gdip_DeleteBrush(pBrushWinBGR)
   Sleep, 0
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
}

dummy() {
  Sleep, 0
}

setImageLoading() {
  If (slideShowRunning=1 || animGIFplaying=1 || drawingShapeNow=1 || hasInitSpecialMode=1)
     Return

  imageLoading := 1
  changeMcursor("busy-img")
}

ResetImgLoadStatus() {
  If (slideShowRunning=1 || animGIFplaying=1) && (imageLoading!=1 && runningLongOperation!=1)
  {
     If (imageLoading=1)
        SetTimer, ResetImgLoadStatus, -70
     Return
  }

  If !GetKeyState("LButton")
  {
     changeMcursor("normal-extra")
     runningLongOperation := 0
     mustAbandonCurrentOperations := imageLoading := 0
  } Else If (imageLoading=1)
     SetTimer, ResetImgLoadStatus, -70
}

ShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
  Static prevImgPath, lastInvoked := 1

  If (slideShowRunning=1)
  {
     slideShowRunning := interfaceThread.ahkgetvar.slideShowRunning
     If (slideShowRunning!=1)
        prevSlideShowStop := A_TickCount
  }

  doIT := ((A_TickCount - lastInvoked<125) && (drawModeAzeit>180 && LastPrevFastDisplay!=1 && prevDrawingMode=1)) || (drawModeBzeit>200 && prevDrawingMode=3 && LastPrevFastDisplay!=1) || ((A_TickCount - lastInvoked<65) && (prevImgPath!=imgPath && drawModeAzeit>50)) || ((A_TickCount - lastInvoked<10) && prevDrawingMode=1) ? 1 : 0
  If (A_TickCount - prevColorAdjustZeit<90) || (animGIFplaying=1 || slideShowRunning=1)
     doIT := 0

  If (usePrevious=0 && ForceIMGload=0 && AnyWindowOpen!=10
  && doIT=1 && !diffIMGdecX && !diffIMGdecY && thumbsDisplaying!=1)
  {
     ; ToolTip, % Exception("", -1).Line "`n" Exception("", -1).What, , , 2
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     If (vpIMGrotation>0)
        zoomu := " @ " vpIMGrotation "°"
     If (IMGresizingMode=4)
        zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
     winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
     winPrefix := defineWinTitlePrefix()
     pVwinTitle := winPrefix winTitle
     setWindowTitle(pVwinTitle, 1)
     lastInvoked := A_TickCount
     dummyFastImageChangePlaceHolder(OutFileName, OutDir)
     ; SetTimer, dummyFastImageChangePlaceHolder, -15
     dummyTimerReloadThisPicture(550)
     prevImgPath := imgPath
  } Else
  {
     If (animGIFplaying=1)
        usePrevious := 0

     prevImgPath := imgPath
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount

     coreShowTheImage(imgPath, usePrevious, ForceIMGload)
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount
  }

  lastInvoked := A_TickCount
}

coreShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
   Critical, on
   Static prevImgPath, lastInvoked2 := 1, counteru
        , lastInvoked := 1, prevPicCtrl := 1

   WinGet, winStateu, MinMax, ahk_id %PVhwnd%
   If (winStateu=-1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()
      DestroyGIFuWin()
      Return
   }

   startZeitIMGload := A_TickCount
   SetTimer, ResetImgLoadStatus, Off
   ThisPrev := (ForceIMGload=1 || usePrevious=2) ? 1 : 0
   If (imgPath=prevImgPath && StrLen(prevImgPath)>3 && ThisPrev!=1)
      usePrevious := 1

   If (usePrevious=2 || ForceIMGload=1)  ; force no caching
   {
      If (ForceIMGload=1)
         prevImgPath := 1
      usePrevious := 0
   }

   zPlitPath(imgPath, 0, OutFileName, OutDir)
   If (vpIMGrotation>0)
      zoomu := " @ " vpIMGrotation "°"
   If (IMGresizingMode=4)
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"

   winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
   If (thumbsDisplaying=1)
   {
      filesSelInfo := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
      SetTimer, UpdateThumbsScreen, -10
      pVwinTitle := filesSelInfo "THUMBS: " winTitle
      setWindowTitle(pVwinTitle, 1)
      If (imageLoading=1)
         SetTimer, ResetImgLoadStatus, -15
      Return
   }

   If !gdiBitmap
   {
      usePrevious := 0
      ForceIMGload := 1
   }
   ; ToolTip, % AprevImgCall "`n" BprevImgCall "`n" imgPath,,,2
   If (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath)) && (ForceIMGload=0) || StrLen(UserMemBMP)>1
      ignoreFileCheck := 1

   If (!FileRexists(imgPath) && usePrevious=0 && ignoreFileCheck!=1)
   {
      destroyGDIfileCache()
      DestroyGIFuWin()
      If (hSNDmedia && autoPlaySNDs!=1)
         StopMediaPlaying()
      If (slideShowRunning=1)
         invokeExternalSlideshowHandler()

      If (WinActive("A")=PVhwnd)
      {
         winTitle := "[*] " winTitle
         pVwinTitle := winTitle
         setWindowTitle(pVwinTitle, 1)
         showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }

      If (imgPath!=prevImgPath)
      {
         If (minimizeMemUsage=1)
            terminateIMGediting()

         If (A_TickCount - lastInvoked2>125) && (A_TickCount - lastInvoked>95)
         {
            SoundBeep, 300, 50
            lastInvoked2 := A_TickCount
         }
 
         If (autoRemDeadEntry=1)
            remCurrentEntry(0, 1)
         lastInvoked := A_TickCount
         SetTimer, ResetImgLoadStatus, -15
         Return "fail"
      }
   }

   If (A_TickCount - lastInvoked>85) && (A_TickCount - lastInvoked2>85)
   || (slideShowRunning=1 || animGIFplaying=1 || usePrevious=1 || oldZoomLevel || ForceIMGload=1 || diffIMGdecX || diffIMGdecY || LastPrevFastDisplay=1)
   {
       lastInvoked := A_TickCount
       r2 := ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload)
       ; msgbox, % r2
       If InStr(r2, "error")
       {
          DestroyGIFuWin()
          destroyGDIfileCache()
          If (hSNDmedia && autoPlaySNDs!=1)
             StopMediaPlaying()
          If (slideShowRunning=1)
             invokeExternalSlideshowHandler()

          friendly := (A_PtrSize=4) ? "`nOr, insufficient memory." : ""
          errMsg := "ERROR: Unable to display the image: " groupDigits(currentFileIndex) "`nPossibly malformed image file format." friendly "`n" r2 "`n" OutFileName "`n" OutDir "\"

          If (WinActive("A")=PVhwnd)
          {
             showTOOLtip(errMsg)
             SetTimer, RemoveTooltip, % -msgDisplayTime
          } Else addJournalEntry(errMsg)
          winTitle := "[*] " winTitle
          pVwinTitle := winTitle
          setWindowTitle(pVwinTitle, 1)
          SetTimer, ResetImgLoadStatus, -15
          If (slideShowRunning!=1)
             SoundBeep, 300, 100
          Return "fail"
       } Else prevImgPath := imgPath
       lastInvoked := A_TickCount
   } Else
   {
      winPrefix := defineWinTitlePrefix()
      pVwinTitle := winPrefix winTitle
      setWindowTitle(pVwinTitle, 1)
      delayu := (A_TickCount - prevFastDisplay < 500) ? 110 : 325
      dummyFastImageChangePlaceHolder(OutFileName, OutDir)
      dummyTimerReloadThisPicture(delayu)
   }
   ; SetTimer, ResetImgLoadStatus, -15
   lastInvoked2 := A_TickCount
}

dummyFastImageChangePlaceHolder(OutFileName, OutDir) {
   Static lastInvoked := 1, prevImgPath
   If (A_TickCount - lastInvoked<50) || (noTooltipMSGs=1)
      Return

   lastInvoked := A_TickCount
   entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
   If (entireString=prevImgPath)
      Return

   prevImgPath := entireString
   CreateOSDinfoLine(entireString, 0, 1, currentFileIndex/maxFilesIndex)
   SetTimer, RemoveTooltip, -500
}

calcImgSize(modus, imgW, imgH, GuiW, GuiH, ByRef ResizedW, ByRef ResizedH) {
   PicRatio := Round(imgW/imgH, 5)
   GuiRatio := Round(GuiW/GuiH, 5)
   If (imgW <= GuiW) && (imgH <= GuiH)
   {
      ResizedW := GuiW
      ResizedH := Round(ResizedW / PicRatio)
      If (ResizedH>GuiH)
      {
         ResizedH := (imgH <= GuiH) ? GuiH : imgH         ;set the maximum picture height to the original height
         ResizedW := Round(ResizedH * PicRatio)
      }   

      If (modus=2)
      {
         ResizedW := imgW
         ResizedH := imgH
      }
   } Else If (PicRatio > GuiRatio)
   {
      ResizedW := GuiW
      ResizedH := Round(ResizedW / PicRatio)
   } Else
   {
      ResizedH := (imgH >= GuiH) ? GuiH : imgH         ;set the maximum picture height to the original height
      ResizedW := Round(ResizedH * PicRatio)
   }

   If (modus=5)
   {
      ResizedW := GuiW
      ResizedH := GuiH
   }
}

ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload) {
    Critical, on
    Static oImgW, oImgH, prevImgPath, lastTitleChange := 1
         , IDprevImgPath, tinyW, tinyH, wscale

    setImageLoading()
    If (editingSelectionNow=1 && IMGresizingMode=5)
    {
       IMGresizingMode := 1
       interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
    }

    setWindowTitle("Loading file | " imgPath)
    changeMcursor()
    calcScreenLimits()
    ; If (winGDIcreated!=1)
    ;   createGDIwin()
    ; o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    o_AutoDownScaleIMGs := (AutoDownScaleIMGs>0) ? 1 : 0
    extraID := ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation usrTextureBGR usrColorDepth bwDithering
    IDthisImgPath := imgPath "-" userHQraw extraID
    If (imgPath!=prevImgPath || IDthisImgPath!=IDprevImgPath || !gdiBitmap || ForceIMGload=1)
    {
       gdiBMPchanged := 1
       ; ToolTip, % ForceIMGload, , , 2
       If (imgPath!=prevImgPath) && (currentFileIndex!=0)
       {
          terminateIMGediting()
          desiredFrameIndex := 0
          If (AutoDownScaleIMGs=2)
             AutoDownScaleIMGs := 1
       }

       mustReloadIMG := (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath) || (ForceIMGload=1) ? 1 : 0
       If (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath)
       {
          usePrevious := 0
          mustReloadIMG := ForceIMGload := 1
          If (currentFileIndex!=0)
             GdipCleanMain(6)
       }

       disposeCacheIMGs()
       changeMcursor()
       r1 := CloneMainBMP(imgPath, oImgW, oImgH, mustReloadIMG, hasFullReloaded)
       abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
       If (imgFxMode=3 && r1!="error" && abortImgLoad<3)
       {
          setWindowTitle("Calculating auto-color adjustments")
          AdaptiveImgLight(gdiBitmap, imgPath, oImgW, oImgH)
       }

       If (abortImgLoad>2)
       {
          o_ImgQuality := userimgQuality
          If (userimgQuality=1)
             ToggleImgQuality("lowu")
          If (desiredFrameIndex<1 && (usrColorDepth>1 || vpIMGrotation>0))
          {
             setWindowTitle("Image processing aborted")
             showTOOLtip("Image processing aborted")
             SetTimer, RemoveTooltip, % -msgDisplayTime//2
          }
       }
    }

    If (!gdiBitmap || r1="error")
    {
       If (o_ImgQuality=1)
          ToggleImgQuality("highu")
       If (AutoDownScaleIMGs=2)
          AutoDownScaleIMGs := 1

       prevImgPath := ""
       interfaceThread.ahkassign("canCancelImageLoad", 0)
       FadeMainWindow()
       SetTimer, ResetImgLoadStatus, -15
       r := (r1="error") ? r1 : 0
       Return r
    }

   prevImgPath := imgPath
   IDprevImgPath := imgPath "-" userHQraw extraID
   GetWinClientSize(GuiW, GuiH, PVhwnd, 0)
   imgW := oImgW
   imgH := oImgH
   decideUndoLevelsAccepted(imgW, imgH)

   calcImgSize(IMGresizingMode, oimgW, oimgH, GuiW, GuiH, ResizedW, ResizedH)
   If (IMGresizingMode=3) ; original [100%]
   {
      lGuiW := (GuiW>imgW) ? imgW : GuiW
      lGuiH := (GuiH>imgH) ? imgH : GuiH
      ws := Round(ResizedW / imgW * 100)
      If (ws<100)
      {
         ws := Round(((lGuiW*lGuiH) / (imgW*imgH)) * 100)
         ws .= "% visible"
      } Else If (ws>100)
      {
         ws := "100%"
      } Else ws .= "%"
      zoomLevel := 1
      ResizedW := imgW
      ResizedH := imgH
   } Else If (IMGresizingMode=4) ; custom zoom level
   {
      ResizedW := Round(imgW * zoomLevel, 3)
      ResizedH := Round(imgH * zoomLevel, 3)
      ws := Round(zoomLevel * 100) "%"
   } Else
   {
      zoomLevel := Round(ResizedW / imgW, 3)
      ws := Round(ResizedW / imgW * 100) "%"
   }

   ; ToolTip, % imgW ", " oImgW ", " roImgW ", " ResizedW ,,, 2
   IMGlargerViewPort := ((ResizedH-5>GuiH+1) || (ResizedW-5>GuiW+1)) ? 1 : 0
   If (vpIMGrotation>0)
      zoomu := " @ " vpIMGrotation "°"

   zPlitPath(imgPath, 0, OutFileName, OutDir)
   winPrefix := defineWinTitlePrefix()
   winTitle := winPrefix currentFileIndex "/" maxFilesIndex " [" ws zoomu "] | " OutFileName " | " OutDir "\"
   If (A_TickCount - lastTitleChange>300)
      setWindowTitle("Adapting image to viewport")

   prevResizedVPimgW := ResizedW := Round(ResizedW)
   prevResizedVPimgH := ResizedH := Round(ResizedH)
   prevMaxSelX := roImgW ? roImgW : oImgW
   prevMaxSelY := roImgH ? roImgH : oImgH
   If (editingSelectionNow=1 && relativeImgSelCoords=1 && gdiBMPchanged=1)
      calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

   GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
   If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && animGIFplaying!=1 && slideShowDelay>950)
      GDIfadeVPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)

   changeMcursor()
   pVwinTitle := infoFilesSel infoFrames winTitle
   r := QPV_ShowImgonGui(ResizedW, ResizedH, GuiW, GuiH, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged, wasPrevious)
   delayu := (A_TickCount - prevFastDisplay < 300) ? 90 : 550
   If (wasPrevious=1 && animGIFplaying!=1)
      dummyTimerReloadThisPicture(delayu)

   infoFilesSel := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
   If (totalFramesIndex>0)
      infoFrames := "["  desiredFrameIndex "/" totalFramesIndex "] "

   setWindowTitle(pVwinTitle, 1)
   lastTitleChange := A_TickCount
   If (o_ImgQuality=1)
      ToggleImgQuality("highu")

   SetTimer, ResetImgLoadStatus, -15
   Return r
}

drawinfoBox(mainWidth, mainHeight, directRefresh:=0) {
    Static prevMsg, prevOSDfnt
    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    infoFilesSel := (markedSelectFile>0) ? "`nFiles selected: " groupDigits(markedSelectFile) : ""
    If (totalFramesIndex>0 || currIMGdetails.Frames>1) && (thumbsDisplaying!=1)
    {
       thisFramesInfo := (totalFramesIndex>0) ? totalFramesIndex : currIMGdetails.Frames
       infoFrames := "`nMultiple pages: " desiredFrameIndex " / " thisFramesInfo
    }

    zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
    If FileExist(imgPath)
    {
       QPV_FileGetSizeTime(imgPath, "R", currentFileIndex)
       fileSizu := Round(resultedFilesList[currentFileIndex, 6]/1024)
       fileSizu := (fileSizu>1023) ? Round(fileSizu/1024, 1) " MB" : fileSizu " KB"
       FileDateM := resultedFilesList[currentFileIndex, 7]
       Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
       fileMsg := "`n" fileSizu " | " FileDateM
    } Else If (currentFileIndex!=0)
       fileMsg := "`nFile not found or access denied..."

    fileRelatedInfos := (StrLen(folderu)>3) ? folderu "\`n[ " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) " ] " fileNamu fileMsg : ""
    If (thumbsDisplaying!=1)
    {
       If (vpIMGrotation>0)
          infoRotate := " @ " vpIMGrotation "°"

       infoSizing := "`nRescaling mode: " DefineImgSizing()
       If (IMGresizingMode!=5)
       {
          infoSizing .= (IMGresizingMode!=4) ? " | " Round(zoomLevel*100) "%" infoRotate : infoRotate
          If (showInfoBoxHUD=2)
             infoSizing .= "`nViewport alignment: " defineImgAlign()
       }

       infoRes := "`nResolution: " groupDigits(maxSelX) " x " groupDigits(maxSelY) " px | " Round((maxSelX*maxSelY)/1000000,2) " MPx"
       If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1)
          infoRes .= " | DOWNSCALED"
       If (currIMGdetails.TooLargeGDI=1)
          infoRes .= "`nOriginal resolution: " groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
       ; infoRes := "`nResolution (W x H): " thisW " x " thisH " px [ " Round(zoomLevel*100) "%" infoRotate " ]"
    } Else
    {
       thisFileIndex := currentFileIndex
       If (showInfoBoxHUD=2)
       {
          infoSizing := "`nThumbnails alignment: " defineImgAlign() "`nThumbnails size: " thumbsW " x " thumbsH " px | " defineThumbsAratio()
          thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
          infoSizing .= "`nThumbnails grid: " maxItemsW " x " maxItemsH " = " maxItemsPage
       }

       If (!resultedFilesList[thisFileIndex, 9] && notFound!=1)
       {
          If !retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12], 1)
             GetCachableImgFileDetails(imgPath, thisFileIndex)
          If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
             updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
       }

       If (notFound!=1)
       {
          infoRes := "`nImage resolution: " groupDigits(resultedFilesList[thisFileIndex, 13]) " x " groupDigits(resultedFilesList[thisFileIndex, 14]) " px | " resultedFilesList[thisFileIndex, 17] " MPx"
          infoRes .= (resultedFilesList[thisFileIndex, 9]>1) ? "`nImage frames: " resultedFilesList[thisFileIndex, 9] : ""
          infoRes .= "`nImage pixel format: " resultedFilesList[thisFileIndex,15]
       }
    }

    If StrLen(UserMemBMP)>2
    {
       infoEditing := "IMAGE EDITING MODE`n"
       If (showInfoBoxHUD=2 && thumbsDisplaying!=1)
          infoEditing .= "Undo levels recorded: " currentUndoLevel " / " undoLevelsRecorded "`n"
    }

    If (showInfoBoxHUD=1 || slideShowRunning=1)
    {
       entireString := infoEditing fileRelatedInfos infoRes infoSizing infoFrames
       thisOSDfnt := OSDFontName FlipImgH FlipImgV OSDfntSize OSDbgrColor OSDtextColor
       If (prevMsg!=entireString || prevOSDfnt!=thisOSDfnt)
       {
          prevOSDfnt := thisOSDfnt
          infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
          infoBoxGdiCached := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 1, !thumbsDisplaying)
          prevMsg := entireString
       }
       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxGdiCached)
       Return
    }

    If (thumbsDisplaying!=1)
       infoRes .= " | " currIMGdetails.dpi " DPI"

    mamUsage := GetProcessMemoryUsage(QPVpid)
    If (A_PtrSize=8)
       systemMemInfo := GlobalMemoryStatusEx()
    thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/1500063598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
    totalMemoryLoad := (A_PtrSize=8) ? "/ " Round(systemMemInfo.TotalPhys/1024**3, 1) " GB" : "/ 1.5 GB"
    memUsage := "`nMemory usage: " Round(max(mamUsage[1], mamUsage[8]) / 1024**2, 1) " MB " totalMemoryLoad " | " thisMemoryLoad "%"
    If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
       memUsage.= "`nFile matched search criteria: " thisSearchString

    sliSpeed := Round(slideShowDelay/1000, 2) " sec."
    If (slideShowRunning=1)
       infoSlider := "`nSlideshow running: " DefineSlideShowType() " @ " sliSpeed

    infoMirroring := defineIMGmirroring()
    If (editingSelectionNow=1 && thumbsDisplaying!=1)
    {
       imgSelW := groupDigits(max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2))
       imgSelH := groupDigits(max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2))
       If (relativeImgSelCoords=1)
       {
          x1 := " [ " Round(prcSelX1 * 100) "%, "
          y1 := Round(prcSelY1 * 100) "% ]"
          wP := " [ " Round((prcSelX2 - prcSelX1) * 100) "%, "
          hP := Round((prcSelY2 - prcSelY1) * 100) "% ]"
          ; moreSelInfo := "`nCoordinates relative to image size"
       }

       infoLocked := (lockSelectionAspectRatio>1) ? "`n  Locked aspect ratio: " defineSelectionAspectRatios() : "`n  Aspect ratio: " Round(imgSelW/imgSelH, 2)
       infoLocked .= (LimitSelectBoundsImg=1) ? "`n  Selection area limited to image boundaries" : ""
       infoSelection := "`n `n" DefineVPselAreaMode() " selection coordinates:`n  X / Y: " ImgSelX1 ", " ImgSelY1 x1 y1 "`n  W / H: " imgSelW ", " imgSelH wP hP moreSelInfo "`n  Rotation: " vPselRotation "°" infoLocked
    } Else If (editingSelectionNow=1)
       infoSelection := "`nSelection area activated in image view"

    ; If (SLDtypeLoaded=2)
    infoThisSLD := "`nFiles list opened: " defineFilesListType()
    If (SLDtypeLoaded>1)
       infoThisSLD .= "`n" PathCompact(CurrentSLD, 40)

    If (usrColorDepth>1)
       infoColorDepth := "`nSimulated color depth: " defineColorDepth()

    If StrLen(filesFilter)>1
       infoFilteru := "`nFiles list filtered from " groupDigits(bckpMaxFilesIndex) " down to " groupDigits(maxFilesIndex) ".`nFilter pattern used:`n" SubStr(filesFilter, 1, 45)

    totalZeit := A_TickCount - startZeitIMGload + 2
    InfoLoadTime := "`nViewport size: " groupDigits(mainWidth) " x " groupDigits(mainHeight) " px"
    If (totalZeit>=10 && thumbsDisplaying!=1 && directRefresh=1)
    {
       InfoLoadTime .= "`nViewport refresh speed: ~" totalZeit " milisec."
       If (currIMGdetails.HasAlpha=1)
          InfoLoadTime .= " (*)"
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " | " sndMediaPos hSNDmediaDuration
       }
       infoAudio := "`nAudio file associated: " OutFileName mediaDuration statusMedia
    }

    If (animGIFplaying=1)
       infoAnim := "`nGIF animation playing at " GIFspeedDelay " ms / frame."

    If (imgFxMode>1 || usrColorDepth>1)
       infoColors := "`nColors display mode: " DefineFXmodes()

    If (thumbsDisplaying!=1)
       infoPixFmt := "`nImage pixel format: " currIMGdetails.PixelFormat " | " currIMGdetails.RawFormat

    If (resultedFilesList[currentFileIndex, 5]=1)
       infoFaved := "`nImage in favourites list"

    If (thumbsDisplaying=1)
    {
       If (resultedFilesList[currentFileIndex, 3]=1)
          infoFaved .= "`nImage already seen"

       maxLimitReached := (minimizeMemUsage=1) && (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
       mustDoMultiCore := (allowMultiCoreMode=1 && maxLimitReached!=1 && multiCoreThumbsInitGood=1) ? 1 : 0
       friendlyCoreInfo := (mustDoMultiCore=1) ? "ACTIVATED" : "DEACTIVATED"
       memUsage .= "`nMulti-threaded mode: " friendlyCoreInfo
    }

    entireString := infoEditing fileRelatedInfos infoFaved infoRes infoPixFmt memUsage infoSizing infoMirroring infoColors infoColorDepth infoFrames infoAnim InfoLoadTime infoThisSLD infoFilesSel infoAudio infoSlider infoFilteru infoSelection 
    thisOSDfnt := OSDFontName FlipImgH FlipImgV OSDfntSize OSDbgrColor OSDtextColor
    If (prevMsg!=entireString || prevOSDfnt!=thisOSDfnt)
    {
       prevOSDfnt := thisOSDfnt 
       infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
       infoBoxGdiCached := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 1, !thumbsDisplaying)
       prevMsg := entireString
    }

    If infoBoxGdiCached
       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxGdiCached)
    entireString := ""
}

drawAnnotationBox(mainWidth, mainHeight) {
    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    imgPath := getIDimage(currentFileIndex)

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " (" sndMediaPos hSNDmediaDuration  ")"
       }
       If mediaDuration
          infoAudio := "Audio file associated" mediaDuration statusMedia "`n"
    } ; Else If (autoPlaySNDs=1)
      ;  infoAudio := "No audio file associated.`n"


    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"

    If (SLDtypeLoaded=3)
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

    If !textFileContent
    {
       Try FileRead, textFileContent, % textFile
       If StrLen(textFileContent)<1
          textFileContent := ""
    }

    entireString := infoAudio textFileContent
    If !entireString
       Return

    infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0, 1, usrTextAlign)
    Gdip_GetImageDimensions(infoBoxBMP, imgW, imgH)
    thisPosY := (scrollBarHy>0) ? scrollBarHy - imgH : mainHeight - imgH
    thisPosX := (scrollBarVx>0) ? scrollBarVx - imgW : mainWidth - imgW
    If (usrTextAlign="Left")
       thisPosX := 0
    Else If (usrTextAlign="Center")
       thisPosX := (scrollBarVx>0) ? scrollBarVx//2 - imgW//2 : mainWidth//2 - imgW//2

    If infoBoxBMP
       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, thisPosX, thisPosY)
    infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
}

clampInRange(value, min, max, reverse:=0) {
   If (reverse=1)
   {
      If (value>max)
         value := min
      Else If (value<min)
         value := max
   } Else
   {
      If (value>max)
         value := max
      Else If (value<min)
         value := min
   }

   Return value
}

clampValue(value, min, max) {
   If (value>max && max!="-")
      value := max
   Else If (value<min && min!="-")
      value := min

   Return value
}

changeOSDfontSize(direction) {
  stepu := (OSDfntSize>30) ? 5 : 2
  If (direction=1)
     OSDfntSize += stepu
  Else
     OSDfntSize -= stepu

  OSDfntSize := clampInRange(OSDfntSize, 15, 350)
  INIaction(1, "OSDfntSize", "General")
  showTOOLtip("OSD font size: " OSDfntSize, 0, 0, OSDfntSize/350)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  calcHUDsize()
  recalculateThumbsSizes()
  interfaceThread.ahkassign("OSDfntSize", OSDfntSize)
  If (thumbnailsListMode=1 && thumbsDisplaying=1)
  {
     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(25)
  } Else If (thumbsDisplaying=1)
     SetTimer, mainGdipWinThumbsGrid, -25
  Else If (CurrentSLD && maxFilesIndex>0)
     SetTimer, dummyRefreshImgSelectionWindow, -25
}

determineGDIsmallCacheSize() {
  Resized := []
  Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
  Size := ((imgW//10)*(imgH//10)>98765) ? 10 : 6
  If ((imgW//10)*(imgH//10)>234567)
     Size := 15
  If ((imgW//10)*(imgH//10)>345678)
     Size := 20
  If ((imgW//10)*(imgH//10)>678901)
     Size := 25
  If ((imgW//10)*(imgH//10)>1597654)
     Size := 30
  If ((imgW//10)*(imgH//10)<44765)
     Size := 3

  If (minimizeMemUsage=1)
     Size := Size*2

  Resized.W := Round(imgW//Size) + 2
  Resized.H := Round(imgH//Size) + 2
  Resized.T := Resized.W//2 + Resized.H//2
  Resized.imgW := imgW
  Resized.imgH := imgH
  Resized.TGDI := imgW//2 + imgH//2
  Return Resized
}

RescaleBMPtiny() {
  Critical, on
  Static prevImgPath
  If (Strlen(gdiBitmapSmall)>3 && prevImgPath=gdiBitmapIDentire)
     Return gdiBitmapSmall

  gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
  Resized := determineGDIsmallCacheSize()
  If StrLen(gdiBMPvPsize)>3 
  {
     Gdip_GetImageDimensions(gdiBMPvPsize, otherW, otherH)
     otherTotalIMGres := otherW//2 + otherH//2
  }

  thisImgQuality := (userimgQuality=1) ? 3 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  whichBitmap := (StrLen(gdiBMPvPsize)>3 && otherTotalIMGres>Resized.T*1.1) ? gdiBMPvPsize : gdiBitmap
  changeMcursor()
  gdiBitmapSmall := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, Resized.W, Resized.H, 0, thisImgQuality, -1)
  ; gdiBitmapSmall := Gdi_ResizeBitmap(whichBitmap, Resized.W, Resized.H, 0, 4)

  prevImgPath := gdiBitmapIDentire
  If StrLen(gdiBitmapSmall)>3
     Return gdiBitmapSmall
}

RescaleBMPtinyVPsize(GuiW, GuiH) {
  Critical, on

  Static prevImgPath
  If (StrLen(gdiBMPvPsize)>3 && prevImgPath=gdiBitmapIDentire)
     Return gdiBMPvPsize

  gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
  thisImgQuality := (userimgQuality=1) ? 7 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  changeMcursor()
  initQPVmainDLL()
  gdiBMPvPsize := trGdip_ResizeBitmap(A_ThisFunc, gdiBitmap, Floor(GuiW*1.2), Floor(GuiH*1.2), 0, thisImgQuality, -1)
  prevImgPath := gdiBitmapIDentire
  If StrLen(gdiBMPvPsize)>3
     Return gdiBMPvPsize
}

setGIFframesDelay() {
   GIFspeedDelay := (totalFramesIndex>75) ? 35 : 45
   If (totalFramesIndex>195)
      GIFspeedDelay := 20
   Else If (totalFramesIndex<15)
      GIFspeedDelay := 60

   If (totalFramesIndex<8)
      GIFspeedDelay := 85
}

multiPageFileManaging(oBitmap) {
   rawFmt := Gdip_GetImageRawFormat(oBitmap)
   totalFramesIndex := Gdip_GetBitmapFramesCount(oBitmap) - 1
   If (totalFramesIndex<0)
      totalFramesIndex := 0

   If (desiredFrameIndex>=totalFramesIndex)
      desiredFrameIndex := totalFramesIndex

   setGIFframesDelay()
   If (totalFramesIndex>0 && slideShowRunning=1 && SlideHowMode=1 && animGIFsSupport!=1)
      Random, desiredFrameIndex, 0, % totalFramesIndex

   If RegExMatch(rawFmt, "i)(gif|tiff)$")
      Gdip_BitmapSelectActiveFrame(oBitmap, desiredFrameIndex)
}

LoadFileWithWIA(imgPath, fastMode, noBMP:=0, forceW:=0, forceH:=0, keepAratio:=0) {
   oBitmap := 0
   Try wiaImg := WIA_LoadImage(imgPath)
   If IsObject(wiaImg)
   {
      mainLoadedIMGdetails.File := imgPath
      mainLoadedIMGdetails.dpi := Round((wiaImg.HorizontalResolution + wiaImg.VerticalResolution)/2)
      mainLoadedIMGdetails.Width := wiaImg.Width
      mainLoadedIMGdetails.Height := wiaImg.Height
      mainLoadedIMGdetails.Frames := wiaImg.FrameCount
      mainLoadedIMGdetails.HasAlpha := wiaImg.IsAlphaPixelFormat
      If (wiaImg.IsAlphaPixelFormat=1)
         extraPixelFormat := "A"
      If (wiaImg.IsIndexedPixelFormat)
         extraPixelFormat .= " [INDEXED-" wiaImg.IsIndexedPixelFormat "]"
      If (wiaImg.IsExtendedPixelFormat)
         extraPixelFormat .= " [EXTENDED-" wiaImg.IsExtendedPixelFormat "]"
      mainLoadedIMGdetails.PixelFormat := wiaImg.PixelDepth "-bit RGB" extraPixelFormat
      mainLoadedIMGdetails.RawFormat := WIA_GetImageFormatID(wiaImg)
      mainLoadedIMGdetails.OpenedWith := "Windows Image Acquisition (WIA)"
      mainLoadedIMGdetails.TooLargeGDI := 0
      If (noBMP=1)
         oBitmap := 1
   } Else
   {
      addJournalEntry("Failed to load image file using WIA`n" imgPath)
      Return
   }

   If (fastMode!=1 && IsObject(wiaImg))
   {
      If (forceW && forceH)
      {
         If (imgW>forceW || imgH>forceH)
            Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, forceW, forceH, keepAratio)
      } Else
      {
         capMaxGDIbmpSize32bits()
         If (wiaImg.width*wiaImg.height>maxGDIbmpSize)
         {
            setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits")
            changeMcursor()
            Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), 1)
            If (!IsObject(ScaledWiaIMG) && A_PtrSize=4)
               Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, Round(Sqrt(maxGDIbmpSize//2)), Round(Sqrt(maxGDIbmpSize//2)), 1)
         }

         If (wiaImg.width>32500 || wiaImg.height>32500)
         {
            setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits")
            changeMcursor()
            Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, 32500, 32500, 1)
            If (!IsObject(ScaledWiaIMG) && A_PtrSize=4)
               Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, Round(Sqrt(maxGDIbmpSize//2)), Round(Sqrt(maxGDIbmpSize//2)), 1)
         }

         If IsObject(ScaledWiaIMG)
            mainLoadedIMGdetails.TooLargeGDI := 1
      }
   }

   If (IsObject(wiaImg) && noBMP=0)
   {
      Try PicObj := ScaledWiaIMG.Height ? WIA_GetImageBitmap(ScaledWiaIMG) : WIA_GetImageBitmap(wiaImg)

      If (PicObj.Handle)
      {
         setWindowTitle("Converting WIA image format to GDI+ bitmap")
         changeMcursor()
         If wiaImg.IsAlphaPixelFormat
            oBitmap := trGdip_CreateARGBBitmapFromHBITMAP(PicObj.Handle)
         Else
            oBitmap := trGdip_CreateBitmapFromHBITMAP(PicObj.Handle)
         Gdi_DeleteObject(PicObj.Handle)
      }
   }

   wiaImg := ""
   ScaledWiaIMG := ""
   PicObj := ""
   Return oBitmap
}

LoadBitmapFromFileu(imgPath, noBPPconv:=0, forceGDIp:=0, allowCaching:=0, allowMemBMP:=0, forceW:=0, forceH:=0, keepAratio:=0) {
  Static prevMD5nameA, prevMD5nameB

  GDIbmpFileConnected := 1
  totalFramesIndex := 0
  coreIMGzeitLoad := A_TickCount
  If (allowMemBMP=1 && StrLen(UserMemBMP)>2)
  {
     currIMGdetails.PixelFormat := Gdip_GetImagePixelFormat(UserMemBMP, 2)
     If (currIMGdetails.HasAlpha!=1)
        currIMGdetails.PixelFormat := StrReplace(currIMGdetails.PixelFormat, "A")

     currIMGdetails.RawFormat := Gdip_GetImageRawFormat(UserMemBMP)
     ; currIMGdetails.HasAlpha := InStr(currIMGdetails.PixelFormat, "argb") ? 1 : 0
     currIMGdetails.Frames := 1
     prevMD5nameA := prevMD5nameB := ""
     ; If (minimizeMemUsage=1)
        destroyGDIfileCache()
     Return trGdip_CloneBitmap(A_ThisFunc, UserMemBMP)
  }

  If (allowCaching=1)
  {
     MD5name := generateThumbName(imgPath, 1)
     thisMD5name := MD5name imgPath userHQraw alwaysOpenwithFIM cmrRAWtoneMapAlgo cmrRAWtoneMapParamA cmrRAWtoneMapParamB
     If (thisMD5name=prevMD5nameA && StrLen(GDIcacheSRCfileA)>2 && StrLen(prevMD5nameA)>2)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileA "`n" imgPath)
        multiPageFileManaging(GDIcacheSRCfileA)
        currIMGdetails := AbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileA)
     } Else If (thisMD5name=prevMD5nameB && StrLen(GDIcacheSRCfileB)>2 && StrLen(prevMD5nameB)>2)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileB "`n" imgPath)
        multiPageFileManaging(GDIcacheSRCfileB)
        currIMGdetails := BbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileB)
     }
  }

  If RegExMatch(imgPath, RegExFIMformPtrn) || (alwaysOpenwithFIM=1 && forceGDIp=0)
  {
     If (thumbsDisplaying!=1 && noBPPconv=0 && runningLongOperation!=1 && slideShowRunning!=1)
        setWindowTitle("Loading file using the FreeImage library")

     oBitmap := LoadFimFile(imgPath, noBPPconv, 0, forceW, forceH, keepAratio)
     If (thumbsDisplaying!=1 && noBPPconv=0 && runningLongOperation!=1 && slideShowRunning!=1)
        addJournalEntry("Image loaded with FreeImage:`n" imgPath)
     GDIbmpFileConnected := 0
  } Else
  {
     changeMcursor()
     oBitmap := trGdip_CreateBitmapFromFile(imgPath)
     capMaxGDIbmpSize32bits()
     If StrLen(oBitmap)>2
     {
        pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
        Gdip_GetImageDimensions(oBitmap, imgW, imgH)
        Gdip_BitmapGetDPIResolution(oBitmap, dpix, dpiy)
        mainLoadedIMGdetails.File := imgPath
        mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
        mainLoadedIMGdetails.Width := imgW
        mainLoadedIMGdetails.Height := imgH
        mainLoadedIMGdetails.Frames := Gdip_GetBitmapFramesCount(oBitmap) - 1
        mainLoadedIMGdetails.HasAlpha := InStr(pixFmt, "argb") ? 1 : 0
        mainLoadedIMGdetails.PixelFormat := pixFmt
        mainLoadedIMGdetails.RawFormat := Gdip_GetImageRawFormat(oBitmap)
        mainLoadedIMGdetails.OpenedWith := "GDI+"
        mainLoadedIMGdetails.TooLargeGDI := 0
        ; ToolTip, % imgW "-" imgH "-" pixFmt , , , 2
        If (InStr(pixFmt, "CMYK") || InStr(pixFmt, "48-") || InStr(pixFmt, "64-"))
           ER := Gdip_BitmapConvertFormat(oBitmap, 0x26200A, 2, 1, 0, 0, 0, 0, 0)

        If (!imgW || !imgH || ER || InStr(pixFmt, "0x"))
        {
           mustOpenWithWia := 1
        } Else If ((imgW*imgH>maxGDIbmpSize) || (imgW>32500) || (imgH>32500)) && (noBPPconv=0)
        {
           setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits")
           If (imgW*imgH>maxGDIbmpSize) && (A_PtrSize!=4)
              nBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), 1, 3, -1)
           Else If (imgW>32500) || (imgH>32500) && (A_PtrSize!=4)
              nBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 32500, 32500, 1, 3, -1)

           If StrLen(nBitmap)>3
           {
              mainLoadedIMGdetails.TooLargeGDI := 1
              oBitmap := trGdip_DisposeImage(oBitmap, 1)
              oBitmap := nBitmap
           } Else mustOpenWithWia := 1
        }
     } Else mustOpenWithWia := 1

     If (mustOpenWithWia=1 && noBPPconv=0) ; || (allowCaching=1)
     {
        loadedWith := 2
        oBitmap := trGdip_DisposeImage(oBitmap, 1)
        setWindowTitle("Loading file through WIA: " imgPath)
        oBitmap := LoadFileWithWIA(imgPath, noBPPconv, 0, forceW, forceH, keepAratio)
        GDIbmpFileConnected := 0
     }

     If StrLen(oBitmap)<4 ; || InStr(pixFmt, "0x"))
     {
        loadedWith := 3
        GDIbmpFileConnected := 0
        oBitmap := LoadFimFile(imgPath, noBPPconv, forceW, forceH, keepAratio)
     } Else If (allowMemBMP=1 && !InStr(pixFmt, "0x"))
        multiPageFileManaging(oBitmap)

     If (thumbsDisplaying!=1 && noBPPconv=0 && runningLongOperation!=1 && slideShowRunning!=1)
     {
        If (loadedWith=2)
           addJournalEntry("Image loaded with WIA:`n" imgPath)
        Else If (loadedWith=3)
           addJournalEntry("Image loaded with FreeImage:`n" imgPath)
        Else
           addJournalEntry("Image loaded with GDI+:`n" imgPath)
     }
  }

  If (allowCaching=1 && StrLen(oBitmap)>2)
  {
     If (slideShowRunning!=1) || (slideShowRunning=1 && slideShowDelay>700)
        userSeenSessionImagesArray[Format("{:L}", imgPath)] := 1

     prevMD5nameB := prevMD5nameA
     prevMD5nameA := thisMD5name
     idGDIcacheSRCfileB := idGDIcacheSRCfileA
     idGDIcacheSRCfileA := GDIbmpFileConnected MD5name imgPath
     GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
     GDIcacheSRCfileB := GDIcacheSRCfileA
     GDIcacheSRCfileA := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
     BbackupIMGdetails := AbackupIMGdetails.Clone()
     AbackupIMGdetails := mainLoadedIMGdetails.Clone()
  }

  If (allowMemBMP=1)
     currIMGdetails := mainLoadedIMGdetails.Clone()
  Return oBitmap
}

RotateBMP2exifOrientation(oBitmap) {
   exifOrientation := Gdip_GetPropertyItem(oBitmap, 0x112)
   orientation := exifOrientation.Value
   ; MsgBox, % orientation
   If (orientation=6)
      Gdip_ImageRotateFlip(oBitmap, 1)
   Else If (orientation=8)
      Gdip_ImageRotateFlip(oBitmap, 3)
   Else If (orientation=3)
      Gdip_ImageRotateFlip(oBitmap, 2)
   Else If (orientation=2)
      Gdip_ImageRotateFlip(oBitmap, 4)
   Else If (orientation=5)
      Gdip_ImageRotateFlip(oBitmap, 5)
   Else If (orientation=4)
      Gdip_ImageRotateFlip(oBitmap, 6)
   Else If (orientation=7)
      Gdip_ImageRotateFlip(oBitmap, 7)
}

capMaxGDIbmpSize32bits() {
  If (A_PtrSize=4)
  {
     mamUsage := GetProcessMemoryUsage(QPVpid)
     If !mamUsage[1]
        Return

     maxGDIbmpSize := ((2115473648 - mamUsage[1] - mamUsage[8]//2)//4)//1.9
     If (maxGDIbmpSize<10101)
        maxGDIbmpSize := 10101
  }
}

Gdip_CloneBmpPargbArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:=0, KeepPixelFormat:=0, ignoreBounds:=0, addBgr:=0) {
   thisPixFmt := !PixelFormat ? coreDesiredPixFmt : PixelFormat
   If (ignoreBounds=1 && w>0 && h>0)
   {
       newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, w, h, thisPixFmt)
       If StrLen(newBitmap)>2
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc "() initially invoked by " funcu, newBitmap, 3)
          If G2
          {
             r1 := trGdip_DrawImage(A_ThisFunc "() initially invoked by " funcu, G2, pBitmap, 0, 0, w, h, x, y, w, h)
             If (addBgr=1)
             {
                Gdip_GetImageDimensions(pBitmap, imgW, imgH)
                x1 := (x<0) ? Abs(x) : 0
                y1 := (y<0) ? Abs(y) : 0
                x2 := (x+w>imgW) ? x1 + w - ((x + w) - imgW) : x1 + w
                y2 := (y+h>imgH) ? y1 + h - ((y + h) - imgH) : y1 + h
                Gdip_SetClipRect(G2, x1, y1, w, h, 4)
                ; r1 := trGdip_DrawImage(A_ThisFunc "() initially invoked by " funcu, G2, pBitmap, 0, 0, w, h, x3, y3, w2, h2)
                ; ToolTip, % x1 "=" y1 "=" x2 "=" y2 "`n" w "=" h , , , 2
                trGdip_GraphicsClear(A_ThisFunc "() initially invoked by " funcu, G2, "0x01828282")
             }
          }

          Gdip_DeleteGraphics(G2)
          If (r1="fail" || !G2)
          {
             trGdip_DisposeImage(newBitmap, 1)
             newBitmap := ""
          }
       }
   } Else
     newBitmap := trGdip_CloneBitmapArea(A_ThisFunc "<-" funcu, pBitmap, x, y, w, h, thisPixFmt, KeepPixelFormat)

   If StrLen(newBitmap)<3
   {
      baseMsg := "Unable to create internal PARGB bitmap clone to apply operations on image... Error occured in " A_ThisFunc "() invoked by " funcu  "() for pBMP=" pBitmap ". "
      generalInternalErrorMsgBox(gdipLastError, baseMsg)
      newBitmap := ""
   }

   Return newBitmap
}

generalInternalErrorMsgBox(err, baseMsg, silentMode:=0) {
   Static forceSilent := 0

   If err
      message := "`n`n" Gdip_ErrorHandler(err, 0)

   friendly := (A_PtrSize=4) ? "`n`nPossible cause: memory limit reached." : ""
   friendly .= (A_PtrSize=4 && A_is64BitOS) ? " Please use the 64-bits edition of this application." : ""
   If (InStr(message, "out_of_memory") && maxMemUndoLevels>12012)
      maxMemUndoLevels -= 100000

   addJournalEntry(baseMsg message friendly)
   If (runningLongOperation!=1 && hasInitSpecialMode!=1 && silentMode!=1 && forceSilent!=1)
   {
      If (imgEditPanelOpened=1)
         TextInAreaLivePreview := FillAreaLivePreview := PasteInPlaceLivePreview := 0
      ; SoundBeep, 300, 100
      simpleMsgBoxWrapper(appTitle ": ERROR", baseMsg message friendly, 0, 0, "error")
      If (InStr(baseMsg, glPG) || InStr(baseMsg, 2NDglPG))
      {
         info := (debugModa=1) ? "" : "You can start QPV with /qpv-debug to view all error messages in a debug viewer."
         msgResult := msgBoxWrapper(appTitle, "It seems you are receving errors related to core viewport components. Would you like to no longer receive GDI+ error messages ?`n`nAnyhow, the application will likely continue to malfunction, but at least in silence.", 4, 0, "question")
         If (msgResult="yes")
            forceSilent := 1
      }
   }
}

CloneMainBMP(imgPath, ByRef imgW, ByRef imgH, mustReloadIMG, ByRef hasFullReloaded) {
  Critical, on
  Static AprevImgDownScaled := 0, BprevImgDownScaled := 0, lastInvoked := 1

  totalFramesIndex := 0
  GDIbmpFileConnected := 1
  hasFullReloaded := CountGIFframes := 0
  MD5name := generateThumbName(imgPath, 1)
  o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
  o_AutoDownScaleIMGs := (AutoDownScaleIMGs>0) ? 1 : 0
  thisImgCall := MD5name imgPath o_bwDithering ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation
  If !FileRexists(imgPath) && (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath))
     thisImgCall := InStr(AprevImgCall, imgPath) ? SubStr(AprevImgCall, 2) : SubStr(BprevImgCall, 2)

  prevLastImg[2] := prevLastImg[1]
  prevLastImg[1] := [currentFileIndex, resultedFilesList[currentFileIndex, 1]]
  gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
  file2load := thumbsCacheFolder "\big-" alwaysOpenwithFIM userHQraw MD5name ".png"
  ignoreCache := (RegExMatch(imgPath, "i)(.\.gif)$") && animGIFsSupport=1) || (minimizeMemUsage=1) || StrLen(UserMemBMP)>2 ? 1 : mustReloadIMG
  ; MsgBox, % imgPath "`n" AbackupIMGdetails.File "`n" BbackupIMGdetails.File "`n" CbackupIMGdetails.File
  If (SubStr(AprevImgCall, 2)=thisImgCall && StrLen(AprevGdiBitmap)>2 && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     thisIMGisDownScaled := AprevImgDownScaled
     Gdip_GetImageDimensions(AprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, AprevGdiBitmap)
     addJournalEntry("Used cached GDI bitmap ID: " AprevGdiBitmap "`n" imgPath)
     gdiBitmapIDcall := AprevImgCall
     gdiBitmapIDentire := AprevImgCall gdiBitmap
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     extractAmbientalTexture()
     Return 
  } Else If (SubStr(BprevImgCall, 2)=thisImgCall && StrLen(BprevGdiBitmap)>2 && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     thisIMGisDownScaled := BprevImgDownScaled
     Gdip_GetImageDimensions(BprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, BprevGdiBitmap)
     gdiBitmapIDcall := BprevImgCall
     gdiBitmapIDentire := BprevImgCall gdiBitmap
     addJournalEntry("Used cached GDI bitmap ID: " BprevGdiBitmap "`n" imgPath)
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     extractAmbientalTexture()
     Return
  }

  If (slideShowRunning!=1 && desiredFrameIndex<1) && (A_TickCount - lastInvoked>250)
     GdipCleanMain(6)

  interfaceThread.ahkassign("canCancelImageLoad", 1)
  changeMcursor()
  preventDownScaling := (IMGresizingMode=3) || (StrLen(UserMemBMP)>2) || (currentFileIndex=0) || (IMGresizingMode=4 && zoomLevel>1.5) ? 1 : 0
  thisImgPath := (preventDownScaling!=1 && FileExist(file2load) && AutoDownScaleIMGs=1) ? file2load : imgPath
  thisIMGisDownScaled := (thisImgPath!=imgPath && AutoDownScaleIMGs=1) ? 1 : 0
  allowCaching := !minimizeMemUsage
  If StrLen(UserMemBMP)>2
     thisIMGisDownScaled := allowCaching := 0

  oBitmap := LoadBitmapFromFileu(thisImgPath, 0, 0, allowCaching, 1)
  ; MsgBox, % obitmap
  If !oBitmap
     Return "error"

  lastInvoked := A_TickCount
  slowFileLoad := (A_TickCount - coreIMGzeitLoad > 450) ? 1 : 0
  hasFullReloaded := 1

  rawFmt := Gdip_GetImageRawFormat(oBitmap)
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (RegExMatch(rawFmt, "i)(bmp|png|tiff)$") && currIMGdetails.HasAlpha=1 && StrLen(UserMemBMP)<3)
  {
     ERR := Gdip_GetHistogram(oBitmap, 7, histoArray, 0, 0)
     If !ERR
     {
        HasAlpha := 0
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && isInRange(A_Index, 0, 254))
               HasAlpha := 1
        }

        currIMGdetails.HasAlpha := HasAlpha
     }
     ; ToolTip, % ERR " = " HasAlpha " = " rawFmt , , , 2
  }

  If (RegExMatch(rawFmt, "i)(gif|tiff)$") && totalFramesIndex>0)
     multiFrameImg := 1
  Else If (rawFmt="JPEG")
     RotateBMP2exifOrientation(oBitmap)

  If (rawFmt="gif" && totalFramesIndex>0)
  {
     gifLoaded := 1
     CountGIFframes := (animGIFsSupport=1) ? totalFramesIndex : 0
  }

  If (rawFmt="MEMORYBMP")
     GDIbmpFileConnected := 0

  If (AnyWindowOpen=17 && performAutoCropNow=1 && usrAutoCropGenerateSelection=0)
  {
     GDIbmpFileConnected := 0
     hasAutoCropped := 1
     setWindowTitle("Auto-cropping image")
     xBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, oBitmap)
     kBitmap := AutoCropAction(oBitmap, usrAutoCropColorTolerance, usrAutoCropImgThreshold)
     FlipImgV := FlipImgH := vpIMGrotation := performAutoCropNow := 0
     trGdip_DisposeImage(xBitmap, 1)
     If StrLen(kBitmap)>3
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
        oBitmap := kBitmap
     }
  }

  Gdip_GetImageDimensions(oBitmap, imgW, imgH)
  totalIMGres := imgW + imgH
  totalScreenRes := ResolutionWidth + ResolutionHeight
  thisImgQuality := (userimgQuality=1) ? 7 : 5
  preventDownScaling := (multiFrameImg=1) || (IMGresizingMode=3) || StrLen(UserMemBMP)>2 || (currentFileIndex=0) || (IMGresizingMode=4 && zoomLevel>1.5) ? 1 : 0
  If (hasAutoCropped!=1 && preventDownScaling!=1 && !FileExist(file2load) && AutoDownScaleIMGs=1 && totalIMGres/totalScreenRes>1.3)
  {
     setWindowTitle("Downscaling large image to viewport")
     thisImgQuality := (userimgQuality=1) ? "" : 5
     roImgW := imgW, roImgH := imgH
     calcIMGdimensions(imgW, imgH, ResolutionWidth, ResolutionHeight, newW, newH)
     imgW := newW, imgH := newH
     totalIMGres := newW + newH
     slowFileLoad := 0
     thisIMGisDownScaled := 1
     mustSaveFile := (multiFrameImg!=1 && enableThumbsCaching=1) ? 1 : 0
  } ; Else thisIMGisDownScaled := 0
  If (minimizeMemUsage=1 && rawFmt!="MEMORYBMP")
     thisImgQuality := ""

  If !newW
     newW := imgW
  If !newH
     newH := imgH

  BprevImgDownScaled := AprevImgDownScaled
  AprevImgDownScaled := thisIMGisDownScaled
  If (currIMGdetails.HasAlpha!=1 || gifLoaded=1)
     brushRequired := 1

  changeMcursor()
  If (thisIMGisDownScaled=1 || animGIFplaying=1 || gifLoaded=1 || minimizeMemUsage!=1 && rawFmt!="MEMORYBMP")
  {
     rBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, newW, newH, 0, thisImgQuality, -1)
     If rBitmap
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
        If (mustSaveFile=1 && thisIMGisDownScaled=1)
           z := Gdip_SaveBitmapToFile(rBitmap, file2load, 90)
     } Else rBitmap := oBitmap
  } Else
  {
     If (currIMGdetails.HasAlpha=1)
        rBitmap := cloneGDItoMem(A_ThisFunc, oBitmap)
     If rBitmap
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
     } Else rBitmap := oBitmap
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && vpIMGrotation>0)
  {
     setWindowTitle("Rotating image at " vpIMGrotation "°")
     brushu := (brushRequired=1) ? pBrushWinBGR : ""
     ; nBitmap := simpleFreeImgRotate(rBitmap, vpIMGrotation)
     changeMcursor()
     nBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, rBitmap, vpIMGrotation, brushu, imgQuality, -1)
     If StrLen(nBitmap)>3
     {
        Gdip_GetImageDimensions(nBitmap, imgW, imgH)
        newW := imgW, newH := imgH
        trGdip_DisposeImage(rBitmap, 1)
        rBitmap := nBitmap
     } Else vpIMGrotation := 0
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && bwDithering=1 && imgFxMode=4)
  {
     GDIbmpFileConnected := 0
     setWindowTitle("Converting image to black and white with dithering")
     If (currIMGdetails.HasAlpha=1)
        E := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)

     zBitmap := trGdip_BitmapConvertGray(rBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
     trGdip_DisposeImage(rBitmap, 1)
     rBitmap := zBitmap
     E := Gdip_BitmapSetColorDepth(rBitmap, "BW", 1)
  } Else If (usrColorDepth>1)
  {
     infoColorDepth := defineColorDepth()
     setWindowTitle("Converting image to " infoColorDepth)
     If (currIMGdetails.HasAlpha=1)
        E := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)
     E := Gdip_BitmapSetColorDepth(rBitmap, internalColorDepth, ColorDepthDithering)
  }

  BprevImgCall := AprevImgCall
  AprevImgCall := GDIbmpFileConnected MD5name imgPath o_bwDithering ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation
  gdiBitmapIDcall := AprevImgCall
  gdiBitmapIDentire := AprevImgCall rBitmap
  gdiBitmap := rBitmap
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  extractAmbientalTexture(abortImgLoad)
  BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
  If (allowCaching=1)
  {
     BprevGdiBitmap := AprevGdiBitmap
     AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
  }
  imgW := newW, imgH := newH
}

extractAmbientalTexture(abortImgLoad:=0) {
    confirmTexBGR := (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270) ? 1 : 0
    If (abortImgLoad<3 && usrTextureBGR=1 && IMGresizingMode!=5 && confirmTexBGR=1)
    {
       setWindowTitle("Extracting image texture for the window background")
       decideGDIPimageFX(matrix, imageAttribs, pEffect)
       AmbientalTexBrush := Gdip_CreateTextureBrush(useGdiBitmap(), 3, 3, 3, 150, 150, matrix, 0, 0, 0, imageAttribs)
       Gdip_DisposeImageAttributes(imageAttribs)
       Gdip_DisposeEffect(pEffect)
    }

    preventScreenOff()
    OnImgFileChangeActions(0)
    If (autoPlaySNDs=1)
    {
       AutoPlayAudioFileAssociated()
       identifyAudioMediaLength()
    }
}

OnImgFileChangeActions(forceThis) {
  Static prevImgPath := ""
  imgPath := currentFileIndex "=" getIDimage(currentFileIndex)
  If (imgPath=prevImgPath && forceThis=0)
  {
     Return
  } Else
  {
     SetTimer, RemoveTooltip, -200
     If (LimitSelectBoundsImg!=1 && editingSelectionNow=1)
        correctActiveSelectionAreaViewPort()
     GIFframesPlayied := 0
     allowNextSlide := 1
     If (A_TickCount - lastGIFdestroy > 950)
        prevAnimGIFwas := ""
     If (AutoDownScaleIMGs=2)
        AutoDownScaleIMGs := 1
     If (hSNDmedia && autoPlaySNDs!=1)
        StopMediaPlaying()
     If (slideShowRunning=1) ;  && (animGIFplaying!=1 || totalFramesIndex<2))
        invokeExternalSlideshowHandler()
  }

  prevImgPath := imgPath
}

invokeExternalSlideshowHandler() {
   allowNextSlide := 1
   interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
   interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
   interfaceThread.ahkPostFunction("dummySlideshow")
}

identifyAudioMediaLength() {
   If hSNDmedia
   {
      milisec := MCI_Length(hSNDmedia)
      hSNDmediaDuration := MCI_ToHHMMSS(milisec)
      If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(0, 1)
   } Else If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(0, 1)
}

IdentifyAudioFileAssociated() {
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3)
    {
       AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
       If StrLen(AudioFileu)>3 && FileExist(AudioFileu)
          Return AudioFileu
    }

    audioFile1 := OutDir "\" OutNameNoExt ".WAv"
    audioFile2 := OutDir "\" OutNameNoExt ".WMA"
    audioFile3 := OutDir "\" OutNameNoExt ".MP3"

    If FileRexists(audioFile1)
       thisSNDfile := audioFile1
    Else If FileRexists(audioFile2)
       thisSNDfile := audioFile2
    Else If FileRexists(audioFile3)
       thisSNDfile := audioFile3
    Else
       thisSNDfile := 0
    Return thisSNDfile
}

PlayAudioFileAssociatedNow() {
    If (thumbsDisplaying=1)
       Return

    ohSNDmediaFile := hSNDmediaFile
    ohSNDmedia := hSNDmedia
    StopMediaPlaying()
    If (ohSNDmediaFile && ohSNDmedia)
    {
       zPlitPath(ohSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("Media file stopped: `n" OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       dummyTimerDelayiedImageDisplay(50)
       Return
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       identifyAudioMediaLength()
       zPlitPath(hSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       thisMsg := (E || !hSNDmedia) ? "ERROR: " E " - " hSNDmedia ". Unable to play media file: `n" : "Media file now playing: `n(" hSNDmediaDuration ") " 
       showTOOLtip(thisMsg OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime

       If (E || !hSNDmedia)
          StopMediaPlaying()
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("WARNING: No media file found to play`n" OutNameNoExt " (.WAV / .WMA / .MP3)`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
}

AutoPlayAudioFileAssociated() {
    Static prevAudioFile
    thisSNDfile := IdentifyAudioFileAssociated()
    If (thisSNDfile=prevAudioFile && StrLen(thisSNDfile)>3)
       Return

    StopMediaPlaying()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       If (E || !hSNDmedia)
          StopMediaPlaying()
       Else
          prevAudioFile := hSNDmediaFile
    } Else prevAudioFile := ""
}

StopMediaPlaying() {
    If hSNDmedia
    {
       MCI_Stop(hSNDmedia)
       hSNDmediaDuration := hSNDmedia := hSNDmediaFile := ""
    }
}

createHistogramBMP(whichBitmap) {
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   mpxu := Round((imgW*imgH)/1000000,2)
   If (mpxu>7.5 && StrLen(whichBitmap)>2)
      whichBMP := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, 520, 520, 1, 3, -1)
   Else
      whichBMP := whichBitmap

   If StrLen(whichBMP)<3
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram - no bitmap given")
      Return
   }

   If (showHistogram=2)
   {
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
   } Else If (showHistogram=3)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlArray, 0, 0)
   } Else If (showHistogram=4)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlArray, 0)
   } Else If (showHistogram=5)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlArray)
   } Else If (showHistogram=6)
   {
      setWindowTitle("Calculating histogram")
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlR, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlG, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlB)
      brLvlFakeArray := []
      Loop, 257
      {
          thisIndex := A_Index - 1
          thisMax := max(brLvlR[thisIndex], brLvlG[thisIndex], brLvlB[thisIndex])
          brLvlFakeArray[thisIndex] := Round(thisMax/1.25)
          ; MsgBox, % thisMax
      }
   }

   If ERR
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram... " Gdip_ErrorHandler(err, 0))
      Return
   }

   Gdip_GetImageDimensions(whichBMP, imgW, imgH)
   zr2ndMaxV := r2ndMaxV := 0
   minBrLvlV := TotalPixelz := imgW * imgH
   Loop, 256
   {
       thisIndex := A_Index - 1
       nrPixelz := brLvlArray[thisIndex]
       If (nrPixelz="")
          Continue

       stringArray .= nrPixelz "." (thisIndex+1) "`n"
       If (nrPixelz>0)
       {
          thisSum += nrPixelz
          If (thisSum>TotalPixelz//2 && medianValue="")
             medianValue := thisIndex
       }

       If (nrPixelz>1)
          stringArray3 .= (thisIndex+1) "." nrPixelz "`n"
       sumTotalBr += nrPixelz * (thisIndex+1)
       SimpleSumTotalBr += nrPixelz
       If (nrPixelz>modePointV)
       {
          modePointV := nrPixelz
          modePointK := thisIndex
       }

       If (nrPixelz<modePointV && nrPixelz>r2ndMaxV)
          r2ndMaxV := nrPixelz
       If (nrPixelz>zr2ndMaxV)
          zr2ndMaxV := nrPixelz

       If (nrPixelz<minBrLvlV && nrPixelz>2)
       {
          minBrLvlV := nrPixelz
          minBrLvlK := thisIndex
       }
   }

   Sort, stringArray, ND`n
   RstringArray := stringArray
   Sort, RstringArray, RND`n
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   avgBrLvlK := Round(sumTotalBr/TotalPixelz - 1, 1)
   thisVal := minu := maxu := 0
   Loop, 256
   {
      thisVal := brLvlArray[Round(avgBrLvlK) - A_Index]
      If (thisVal>0 && !minu)
      {
         minu := thisVal
         Break
      }
   }

   Loop, 256
   {
      thisVal := brLvlArray[A_Index + Round(avgBrLvlK)]
      If (thisVal>0 && !maxu)
      {
         maxu := thisVal
         Break
      }
   }

   avgBrLvlV := (minu + maxu)//2 ;  brLvlArray[Round(avgBrLvlK)]
   modePointK3 := ST_ReadLine(RstringArray, 2)
   modePointK3 := StrSplit(modePointK3, ".")
   modePointK4 := ST_ReadLine(RstringArray, 3)
   modePointK4 := StrSplit(modePointK4, ".")
   modePointK5 := ST_ReadLine(RstringArray, 4)
   modePointK5 := StrSplit(modePointK5, ".")
   rangeA := ST_ReadLine(stringArray3, 1)
   rangeA := StrSplit(rangeA, ".")
   rangeB := ST_ReadLine(stringArray3, "L")
   rangeB := StrSplit(rangeB, ".")
   Loop, 256
   {
       minBrLvlK2 := ST_ReadLine(stringArray, A_Index)
       minBrLvlK2 := StrSplit(minBrLvlK2, ".")
       If (minBrLvlK2[1]=0)
          Continue
       If (minBrLvlK2[2]>0)
          Break
   }

   rangeC := rangeB[1] - rangeA[1] + 1
   meanValue := SimpleSumTotalBr/rangeC
   meanValuePrc := Round(meanValue/TotalPixelz * 100)
   meanValuePrc := (meanValuePrc>0) ? " (" meanValuePrc "%) " : ""
   2ndMaxVa := (r2ndMaxV + avgBrLvlV)//2 + minBrLvlV
   2ndMaxVb := (r2ndMaxV + meanValue)//2 + minBrLvlV
   Loop, 256
   {
       lookMean := ST_ReadLine(stringArray, A_Index)
       lookMean := StrSplit(lookMean, ".")
       thisMean := lookMean[1]
       If (thisMean>meanValue)
       {
          meanValueK := Round((prevMean + lookMean[2] - 1)/2, 1)
          Break
       } prevMean := lookMean[2]
   }

   meanValueK := !meanValueK ? "" : " | Mean: " meanValueK meanValuePrc
   modePointKm := ST_ReadLine(stringArray, 2)
   modePointKm := StrSplit(modePointKm, ".")
   ; f2ndMaxV := (2ndMaxVa + 2ndMaxVb)//2 + avgBrLvlV//2
   f2ndMaxV := (histogramMode=2) ? (avgBrLvlV + (modePointK3[1] + modePointK4[1] + modePointK5[1])//3)//2 : (r2ndMaxV + zr2ndMaxV)//2    ; + modePointKm[1]//2
   If (f2ndMaxV>r2ndMaxV && histogramMode=2)
      f2ndMaxV := (r2ndMaxV + f2ndMaxV)//2
   If (histogramMode=1)
      f2ndMaxV := (avgBrLvlV + minBrLvlK2[1])//2
   ; ToolTip, % avgBrLvlV "--" minBrLvlK2[1] "--" r2ndMaxV , , , 2
   peakPrc := Round(modePointV/TotalPixelz * 100)
   peakPrc := (peakPrc>0) ? " (" peakPrc "%)" : ""
   minPrc := Round(minBrLvlK2[1]/TotalPixelz * 100)
   minPrc := (minPrc>0) ? " (" minPrc "%)" : ""
   medianPrc := Round(lookValue[2]/TotalPixelz * 100)
   medianPrc := (medianPrc>0) ? " (" medianPrc "%)" : ""
   avgPrc := Round(avgBrLvlV/TotalPixelz * 100)
   avgPrc := (avgPrc>0) ? " (" avgPrc "%)" : ""
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   TotalPixelzSpaced := groupDigits(imgW*imgH)

   infoRange := "(" defineHistogramMode() ") " defineHistogramType() " range: " rangeA[1] - 1 " - " rangeB[1] - 1 " (" rangeC ")"
   infoPeak := "`nMode: " modePointK peakPrc
   infoAvg := " | Avg: " avgBrLvlK avgPrc " | Min: " minBrLvlK2[2] - 1 minPrc
   infoMin := "`nMedian: " medianValue medianPrc meanValueK
   entireString := infoRange infoPeak infoAvg infoMin "`nTotal pixels: " TotalPixelzSpaced
   If (slideShowRunning=1)
      infoBoxBMP := trGdip_CreateBitmap(A_ThisFunc, 5, 5)
   Else
      infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.5, mainWidth//1.3, mainHeight//1.3, OSDtextColor, OSDbgrColor, 1, 0)
   ; tooltip, % "|" TotalPixelz "|" modePointV ", " 2ndMaxV ", " avgBrLvlV " || "  maxW "," maxH  ;  `n" PointsList
   Scale := (slideShowRunning=1) ? imgHUDbaseUnit/50 : imgHUDbaseUnit/40
   If (rangeC<2)
      f2ndMaxV := modePointK
   If (f2ndMaxV<250)
      f2ndMaxV := 250

   thisData := (showHistogram=6) ? brLvlFakeArray : brLvlArray
   thisOpacity := (showHistogram=6) ? "0xCC" : "0xFF"
   If (showHistogram=3)
      thisGraphColor := "0xFFFF3300"
   Else If (showHistogram=4)
      thisGraphColor := "0xFF33FF33"
   Else If (showHistogram=5)
      thisGraphColor := "0xFF3366FF"
   Else
      thisGraphColor := thisOpacity OSDtextColor

   HistogramBMP := drawHistogram(thisData, f2ndMaxV, 256, Scale, thisGraphColor, "0xEE" OSDbgrColor, imgHUDbaseUnit//3, infoBoxBMP)
   trGdip_DisposeImage(infoBoxBMP, 1)
   If (whichBMP!=whichBitmap && StrLen(whichBMP)>2)
      trGdip_DisposeImage(whichBMP, 1)
}

groupDigits(nrIn, delim:=" ") {
   If StrLen(nrin)>3
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 2)
   If StrLen(nrin)>7
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 6)
   If StrLen(nrin)>11
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 10)
   If StrLen(nrin)>15
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 14)
   Return nrIn
}

defineRelativeSelCoords(maxSelX, maxSelY) {
   prcSelX1 := imgSelX1/maxSelX
   prcSelY1 := imgSelY1/maxSelY
   prcSelX2 := imgSelX2/maxSelX
   prcSelY2 := imgSelY2/maxSelY
}

capSelectionRelativeCoords() {
   If (prcSelX1<0)
      prcSelX1 := 0
   Else If (prcSelX1>=1)
      prcSelX1 := 0.99

   If (prcSelY1<0)
      prcSelY1 := 0
   Else If (prcSelY1>=1)
      prcSelY1 := 0.99

   If (prcSelX2<0.001)
      prcSelX2 := 0.001
   Else If (prcSelX2>1)
      prcSelX2 := 1

   If (prcSelY2<0.001)
      prcSelY2 := 0.001
   Else If (prcSelY2>1)
      prcSelY2 := 1
}

calcRelativeSelCoords(whichBitmap, imgW:=0, imgH:=0) {
   If (imgSelX1=0 && imgSelY1=0 && imgSelX2=-1 && imgSelY2=-1)
      Return

   If (!imgW || !imgH)
      Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

   imgSelX1 := Round(prcSelX1*imgW)
   imgSelY1 := Round(prcSelY1*imgH)
   imgSelX2 := Round(prcSelX2*imgW)
   imgSelY2 := Round(prcSelY2*imgH)
   nImgSelX1 := imgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := imgSelY1 := min(imgSelY1, imgSelY2)
   nimgSelX2 := max(imgSelX1, imgSelX2)
   nimgSelY2 := max(imgSelY1, imgSelY2)

   kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
   kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
   If (kimgSelW>32500)
      nImgSelX2 := nImgSelX1 + 32500
   If (kimgSelH>32500)
      nImgSelY2 := nImgSelY1 + 32500

   If (kimgSelH*kimgSelW>23125**2)
   {
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      scaleu := (kimgSelH*kimgSelW)/(23125**2)
      nImgSelX2 := nImgSelX1 + Floor(kimgSelW/scaleu)
      nImgSelY2 := nImgSelY1 + Floor(kimgSelH/scaleu)
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      If (kimgSelW>32500)
         nImgSelX2 := nImgSelX1 + 32500
      If (kimgSelH>32500)
         nImgSelY2 := nImgSelY1 + 32500
   }

   ImgSelX2 := nImgSelX2
   ImgSelY2 := nImgSelY2
}

AdaptiveImgLight(whichImg, imgPath, Width, Height) {
   If isWinXP
   {
      addJournalEntry("Automatic colors adjustments is deactivated on " A_OSVersion)
      Return
   }

   startZeit := A_TickCount
   If (Width=1 && Height=1)
      Gdip_GetImageDimensions(whichImg, Width, Height)

   mustRem := 0
   If ((Width//10*Height//10)>18500)
   {
      ; calcIMGdimensions(Width, Height, 900, 900, newWidth, newHeight)
      rBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichImg, 900, 900, 1, 3, -1)
      If !rBitmap
         Return -1
      Else
         mustRem := 1

      whichImg := rBitmap
   }

   Gdip_GetImageDimensions(whichImg, Width, Height)
   xCrop := Width//11
   yCrop := Height//11
   wCrop := Width - xCrop*2 + 1
   hCrop := Height - yCrop*2 + 1

   cropBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichImg, xCrop, yCrop, wCrop, hCrop)
   If !cropBMP
      Return -1

   brLvlArray := [], ArrChR := [], ArrChG := [], ArrChB := []
   rMinBrLvl := minBrLvl := 256
   modePointV := lumosAdjust := 1
   maxBrLvl := sumTotalBr := countTotalPixelz := thisBrLvl := 0
   GammosAdjust := countBrightPixelz := countMidPixelz := countDarkPixelz := 0

   ERR := Gdip_GetHistogram(cropBMP, 2, ArrChR, ArrChG, ArrChB)
   pEffect := Gdip_CreateEffect(6, 0, -99, 0)
   If !ERR
   {
      If pEffect
         rT := Gdip_BitmapApplyEffect(cropBMP, pEffect)
   
      Gdip_DisposeEffect(pEffect)
      ERR := Gdip_GetHistogram(cropBMP, 3, brLvlArray, 0, 0)
   }

   trGdip_DisposeImage(cropBMP, 1)
   If (mustRem=1)
      trGdip_DisposeImage(rBitmap, 1)

   If ERR
      Return -1

   rTotalPixelz := Width*Height
   TotalPixelz := wCrop*hCrop
   otherThreshold := (usrAdaptiveThreshold>0) ? usrAdaptiveThreshold : 2
   minMaxThreshold := Floor(rTotalPixelz*0.000015) + usrAdaptiveThreshold
   If (minMaxThreshold<1)
      minMaxThreshold := 1

   ; gather image histogram statistics
   Loop, 256
   {
       thisIndex := A_Index - 1
       nrPixelz := brLvlArray[thisIndex]
       If !nrPixelz
          Continue

       sumTotalBr += nrPixelz * thisIndex
       If (nrPixelz>modePointV)
       {
          modePointV := nrPixelz
          modePointK := thisIndex
       }

       If (thisIndex>maxBrLvl && nrPixelz>minMaxThreshold)
          maxBrLvl := thisIndex

       If (thisIndex<minBrLvl && nrPixelz>minMaxThreshold)
          minBrLvl := thisIndex

       If (thisIndex<rMinBrLvl && nrPixelz>otherThreshold)
          rMinBrLvl := thisIndex

       If (isInRange(thisIndex, 4, 40))
          countDarkPixelz += nrPixelz
       Else If (isInRange(thisIndex, 170, 253))
          countBrightPixelz += nrPixelz
       Else If (isInRange(thisIndex, 50, 165))
          countMidPixelz += nrPixelz
   }

   avgBrLvl := Round(sumTotalBr/TotalPixelz)
   Loop, 23
   {
       nrPixelz := brLvlArray[avgBrLvl - 11 + A_Index]
       If nrPixelz
          countFlatties += nrPixelz
   }

   Loop, 11
   {
       nrPixelz := brLvlArray[modePointK - 6 + A_Index]
       If nrPixelz
          countModies += nrPixelz
   }

   aMinBrLvl := (rMinBrLvl + minBrLvl)//2
   Loop, 10
   {
       nrPixelz := brLvlArray[aMinBrLvl + A_Index]
       If nrPixelz
          countLowestPx += nrPixelz
   }
   percmodePx := Round((countModies/TotalPixelz)*100, 4)
   percBrgPx := Round((countBrightPixelz/TotalPixelz) * 100, 4)
   percLowPx := Round((countLowestPx/TotalPixelz) * 100, 4)
   percDrkPx := Round((countDarkPixelz/TotalPixelz) * 100, 4)
   percMidPixu := Round((countMidPixelz/TotalPixelz) * 100, 4)
   oPercAvgPx := Round((countFlatties/TotalPixelz) * 100, 4)
   If (percmodePx<=0.00015)
      percmodePx += 0.000156
   If (percMidPixu<=0.00015)
      percMidPixu += 0.000156
   If (percBrgPx<=0.00025)
      percBrgPx += 0.000256
   If (percDrkPx<=0.001)
      percDrkPx += 0.01512
   percAvgPx := Round((oPercAvgPx + percmodePx + percMidPixu)/3, 4)
   percMidPx := 100 - percBrgPx - percDrkPx
   If (percMidPx<=0.00025)
      percMidPx += 0.000256

   ; make the image brighter if max. luminance [maxBrLvl] is less than 255
   multiplieruA := 255.1/maxBrLvl + (percDrkPx + (255.1 - avgBrLvl)/3 + (255.1 - (modePointK+avgBrLvl)/2)/3)/(500 + maxBrLvl*2 + avgBrLvl*10)
   If (percBrgPx>1.25)
      multiplieruA := multiplieruA - Round(percMidPx/450, 4)

   multiplieruB := 255.1/maxBrLvl + (percDrkPx/8 + (255.1 - avgBrLvl)/15 + (255.1 - modePointK)/10)/50 - percBrgPx/25 - ((percMidPixu + percMidPx)/2)/40
   multiplieru := (multiplieruA + multiplieruB)/2

   If (multiplieru<=1)
      multiplieru := 1.0002
   If (multiplieru<=1.15)
   {
      multiplieruC := 255.1/maxBrLvl + (percDrkPx + (255.1 - avgBrLvl)/3 + (255.1 - (modePointK+avgBrLvl)/2)/3)/(500 + maxBrLvl*2 + avgBrLvl*10)
      If (percBrgPx>1.25)
         multiplieruC := multiplieruC - Round(percMidPx/450, 4)
      multiplieru := multiplieruC/1.25
      If (multiplieru<=1)
         multiplieru := 1.0002
   }

   lumosAdjust := multiplieru
   GammosAdjust := - lumosAdjust/40 + 0.025 + ((percDrkPx + percAvgPx)/(900 + percBrgPx*100 + avgBrLvl*2))/3.25
   realGammos := Round(1 - ((percDrkPx + percAvgPx)/(900 + percBrgPx*100 + avgBrLvl*2))/1.25, 3)

   ; make the image darker when lacking contrast or min. luminance level [minBrLvl] is higher than 1
   darkerOffsetA := rMinBrLvl*multiplieru
   darkerOffsetA := (darkerOffsetA - 3)/105
   darkerOffsetB := (aMinBrLvl/multiplieru/(200 - percBrgPx/4) + percBrgPx/percDrkPx/avgBrLvl/300)/1.5
   darkerOffsetC := (minBrLvl/multiplieru)/250 + avgBrLvl/(600 - avgBrLvl/10)
   darkerOffset := (darkerOffsetA + darkerOffsetB)/2 - percLowPx/700
   testGammosAdjust := GammosAdjust - darkerOffset/1.1
   If (testGammosAdjust>-0.02 && aMinBrLvl>3)
      darkerOffset := darkerOffsetC/1.5
   If (darkerOffset<=0)
      darkerOffset := 0.00001

   lumosAdjust := lumosAdjust + darkerOffset
   GammosAdjust := GammosAdjust - darkerOffset/1.1

   If (autoAdjustMode=2)
   {
      lumosAdjust := multiplieru := 255.1/maxBrLvl
      GammosAdjust := - lumosAdjust/40 + 0.025
   } Else If (autoAdjustMode=3)
   {
      darkerOffset := rMinBrLvl/255
      lumosAdjust := 1 + darkerOffset*1.1
      GammosAdjust := 0 - darkerOffset*1.3
   }

   ; adjust saturation
   If (doSatAdjusts=1)
   {
      Loop, 256
      {
          thisIndex := A_Index
          nrPixR := ArrChR[thisIndex]
          nrPixG := ArrChG[thisIndex]
          nrPixB := ArrChB[thisIndex]
          If (nrPixR="" || nrPixG="" || nrPixB="")
             Continue
 
          sumTotalR += nrPixR * thisIndex
          sumTotalG += nrPixG * thisIndex
          sumTotalB += nrPixB * thisIndex
          BrLvlDifs := max(NrPixR, NrPixG, NrPixB) - min(NrPixR, NrPixG, NrPixB)
          If (BrLvlDifs<minMaxThreshold*2) || (nrPixR+nrPixB+nrPixB<minMaxThreshold*3)
             Continue
          tNrPixR += nrPixR
          tNrPixG += nrPixG
          tNrPixB += nrPixB
          tNrPixAll += max(NrPixR, NrPixG, NrPixB)
          AllBrLvlDifs += BrLvlDifs
      }
   }
   BrLvlDiffX := max(tNrPixR, tNrPixG, tNrPixB) - min(tNrPixR, tNrPixG, tNrPixB)
   PrcLvlDiffX := Round((BrLvlDiffX/tNrPixAll)*100, 4)
   PrcLvlDiffXa := Round((AllBrLvlDifs/tNrPixAll)*100, 4)

   v1a := ArrChR[maxBrLvl]
   v2a := ArrChG[maxBrLvl]
   v3a := ArrChB[maxBrLvl]
   v1b := ArrChR[maxBrLvl - 1]
   v2b := ArrChG[maxBrLvl - 1]
   v3b := ArrChB[maxBrLvl - 1]
   v1e := ArrChR[modePointK]
   v2e := ArrChG[modePointK]
   v3e := ArrChB[modePointK]
   ; hmmu := max(v1a, v2a, v3a) " -- " min(v1a, v2a, v3a) " -- " v1a "," v2a "," v3a

   BrLvlDiffA := max(v1a, v2a, v3a) - min(v1a, v2a, v3a)
   BrLvlDiffB := max(v1b, v2b, v3b) - min(v1b, v2b, v3b)
   BrLvlDiffE := max(v1e, v2e, v3e) - min(v1e, v2e, v3e)
   PrcLvlDiffA := Round((BrLvlDiffA/max(v1a, v2a, v3a))*100, 4)
   PrcLvlDiffB := Round((BrLvlDiffB/max(v1b, v2b, v3b))*100, 4)
   PrcLvlDiffE := Round((BrLvlDiffE/max(v1e, v2e, v3e))*100, 4)
   avgLvlsDiff := (PrcLvlDiffA + PrcLvlDiffB + PrcLvlDiffE)/3

   satAdjust := 1
   satLevel := (lumosAdjust - GammosAdjust - 1)/15 - percDrkPx/50
   If (satLevel<0)
      satLevel := 0
   satAdjust := 1 - satLevel
   If (satAdjust<0.5)
      satAdjust := 0.5
   Else If (PrcLvlDiffX>0.5)
      satAdjust := satAdjust - PrcLvlDiffX/50 + 0.02

   If (PrcLvlDiffX<0.2)
   {
      PrcLvlDiffX := Round((3*BrLvlDiffX/TotalPixelz)*100, 4)
      satAdjust := satAdjust + PrcLvlDiffX/40 + 0.02
   }

   If (avgLvlsDiff>95)
      satAdjust := satAdjust - (avgLvlsDiff - 95)/100 + 0.02
   Else If (avgLvlsDiff<20)
      satAdjust := satAdjust + (20 - avgLvlsDiff)/100

   If (PrcLvlDiffXa>50)
      satAdjust -= PrcLvlDiffXa/1000
   Else
      satAdjust += PrcLvlDiffXa/700

   avgBrLvlR := Round(sumTotalR/TotalPixelz)
   avgBrLvlG := Round(sumTotalG/TotalPixelz)
   avgBrLvlB := Round(sumTotalB/TotalPixelz)
   chnlDiffs := max(avgBrLvlR, avgBrLvlG, avgBrLvlB) - min(avgBrLvlR, avgBrLvlG, avgBrLvlB)
   chnlDiffs := Round((chnlDiffs/maxBrLvl)*100, 4)
   If (avgBrLvlR>240 || avgBrLvlG>240 || avgBrLvlB>240) && (avgBrLvlR!=avgBrLvlB || avgBrLvlR!=avgBrLvlG ||  avgBrLvlB!=avgBrLvlG)
      satAdjust -= 0.05

   If (satAdjust<0.86)
      satAdjust += percDrkPx/800
   If (satAdjust<0.70)
      satAdjust := 0.70

   If (satAdjust>0.8 && chnlDiffs>=20)
      satAdjust -= chnlDiffs>50 ? chnlDiffs/825 : chnlDiffs/950
   Else If (chnlDiffs<11)
      satAdjust += (100 - chnlDiffs)/950

   otherz := (avgBrLvlG + avgBrLvlB)//1.5
   rLevelu := (avgBrLvlR>otherz+5 && avgBrLvlR<100 && otherz/avgBrLvlR<0.5) ? 1 - otherz/avgBrLvlR : 0
   satAdjust -= rLevelu/11
   otherz := (avgBrLvlR + avgBrLvlB)//1.5
   gLevelu := (avgBrLvlG>otherz+5 && avgBrLvlG<100 && otherz/avgBrLvlG<0.5) ? 1 - otherz/avgBrLvlG : 0
   satAdjust -= gLevelu/11
   otherz := (avgBrLvlG + avgBrLvlR)//1.5
   bLevelu := (avgBrLvlB>otherz+5 && avgBrLvlB<100 && otherz/avgBrLvlB<0.5) ? 1 - otherz/avgBrLvlB : 0
   satAdjust -= bLevelu/11
   If (doSatAdjusts!=1)
      satAdjust := 1

   ; execTime := A_TickCount - startZeit
   ; ToolTip, % redLevelu ",avgRGB=" avgBrLvlR ", " avgBrLvlG ", " avgBrLvlB ", ChnlDiff=" chnlDiffs  ", AvgLvlDif=" avgLvlsDiff " %, diffA=" PrcLvlDiffA " %, diffE=" PrcLvlDiffE " %, diffX=" PrcLvlDiffX "/" PrcLvlDiffXa "% `nTh=" minMaxThreshold ", min=" minBrLvl "/" rMinBrLvl ", max=" maxBrLvl ", A=" avgBrLvl ", mP=" modePointK " [" modePointV " / " percmodePx "% ]"  ",`nL=" percBrgPx "%, D=" percDrkPx "%, Dl=" percLowPx "%, Mr=" percMidPx "% / Mo=" percMidPixu "%, oAvg=" oPercAvgPx "%, fAvg=" percAvgPx "%`ncL=" lumosAdjust ", cG=" GammosAdjust ", cS=" satAdjust ", T=" execTime "ms",,, 2
}

VPnavBoxWrapper(mainWidth, mainHeight, isDirectCall:=0) {
    Critical, on
    createVPnavBox(navBoxu, imgW, imgH, diffX, diffY, zImgW, zImgH)
    thisPosX := (imageAligned=1 && thumbsDisplaying=1) ? mainWidth - imgW - imgHUDbaseUnit//3.25 : 0
    thisPosY := (scrollBarHy>0) ? scrollBarHy - imgH : mainHeight - imgH
    If navBoxu
       ERR := trGdip_DrawImage(A_ThisFunc, 2NDglPG, navBoxu, thisPosX, thisPosY)

    hasDrawnImageMap := (navBoxu && !ERR) ? 1 : 0
    If (FlipImgH=1)
       thisPosX := mainWidth - imgW
    ; ToolTip, % scrollBarVx "==" scrollBarHy , , , 2
    If (FlipImgV=1)
       thisPosY := 0 + Round(mainHeight - scrollBarHy)

    If navBoxu
       HUDobjNavBoxu := [zImgW, zImgH, thisPosX + diffX, thisPosY + diffY, imgW, imgH, thisPosX, thisPosY]

    trGdip_DisposeImage(navBoxu, 1)
    If (isDirectCall=1)
    {
       SetTimer, ResetImgLoadStatus, -25
       r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    }
}

createVPnavBox(ByRef pBitmap, ByRef imgW, ByRef imgH, ByRef posX, ByRef posY, ByRef fImgW, ByRef fImgH) {
   Static lastState := 1
   pBitmap := ""
   navBoxu := coreCreateVPnavBox()
   If StrLen(navBoxu)<3
      Return

   Gdip_GetImageDimensions(navBoxu, fImgW, fImgH)
   Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   imgW := imgH := Ceil(HUDnavBoxSize * imgHUDbaseUnit/20)
   posX := imgW//2 - fImgW//2
   posY := imgH//2 - fImgH//2

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
   If StrLen(pBitmap)<3
   {
      pBitmap := ""
      trGdip_DisposeImage(navBoxu, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      pBitmap := ""
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)
   E := trGdip_DrawImage(A_ThisFunc, Gu, navBoxu, posX, posY, fImgW, fImgH)
   If (E="fail")
   {
      pBitmap := ""
      Gdip_DeleteGraphics(Gu)
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gdip_SetClipRect(Gu, posX, posY, fImgW, fImgH, 4)
   borderu := Round(imgW*0.0099)
   Gdip_FillRectangle(Gu, pBrushE, posX - borderu, posY - borderu, fImgW + borderu*2, fImgH + borderu*2)
   Gdip_ResetClip(Gu)

   If (editingSelectionNow=1 && thumbsDisplaying!=1)
   {
      calcImgSelection2bmp(1, oimgW, oimgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      If (zImgSelW<borderu*2 || zImgSelH<borderu*2)
         Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

      If (zImgSelW<borderu*2)
         zImgSelW := borderu*2
      If (zImgSelH<borderu*2)
         zImgSelH := borderu*2

      pPath := createImgSelPath(posX + zimgSelPx, posY + zimgSelPy, zimgSelW, zimgSelH, EllipseSelectMode, vPselRotation, rotateSelBoundsKeepRatio)
      Gdip_SetClipPath(Gu, pPath, 0)
      If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
         thisBrush := lastState ? pBrushA : pBrushD
      Else
         thisBrush := pBrushA

      Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      Gdip_DeletePath(pPath)
      Gdip_ResetClip(Gu)
   }

   If (thumbsDisplaying!=1)
   {
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      obju := createImgSelection2Win(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, prevMaxSelX, prevMaxSelY, mainWidth, mainHeight, 1)
      coords := obju.x1 "|" obju.y1 "|" obju.x2 "|" obju.y2
      calcImgSelection2bmp(1, oimgW, oimgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, coords)
      If (zImgSelW<borderu*2)
         zImgSelW := borderu*2
      If (zImgSelH<borderu*2)
         zImgSelH := borderu*2

      If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
         thisBrush := lastState ? pBrushC : pBrushD
      Else
         thisBrush := pBrushC

      Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      Gdip_SetClipRect(Gu, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH, 4)
      borderu := Round(imgW*0.006)
      Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

      Gdip_ResetClip(Gu)
      Gdip_SetClipRect(Gu, borderu, borderu, imgW - borderu*2, imgH - borderu*2, 4)
      Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)
   }

   lastState := !lastState
   Gdip_DeleteGraphics(Gu)
   Return pBitmap
}

coreCreateVPnavBox(modus:=0) {
   Static lastCall, prevBMP
   If (modus="kill")
   {
      prevBMP := trGdip_DisposeImage(prevBMP, 1)
      prevBMP := lastCall := ""
      Return
   }

   whichBitmap := useGdiBitmap()
   If (thumbsDisplaying=1)
   {
      imgPath := StrReplace(getIDimage(currentFileIndex), "||")
      If !FileRexists(imgPath)
         Return

      MD5name := generateThumbName(imgPath, 1, 1)
      file2save := thumbsCacheFolder "\500-" MD5name ".jpg"
      If FileExist(file2save)
      {
         whichBitmap := LoadCachableBitmapFromFile(file2save)
      } Else
      {
         changeMcursor()
         oBitmap := LoadBitmapFromFileu(imgPath)
         whichBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 500, 500, 1, 7)
         trGdip_DisposeImage(oBitmap, 1)
         Gdip_SaveBitmapToFile(whichBitmap, file2save, 94)
         ResetImgLoadStatus()
      }
      whichBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(whichBitmap))
   }

   thisCall := "a" whichBitmap MD5name imgPath thumbsDisplaying gdiBitmapIDcall currentFileIndex getIDimage(currentFileIndex) currentUndoLevel undoLevelsRecorded UserMemBMP imgHUDbaseUnit OSDfntSize HUDnavBoxSize FlipImgH FlipImgV imgFxMode
   If (thisCall=lastCall)
      Return prevBMP

   If !whichBitmap
      Return

   prevBMP := trGdip_DisposeImage(prevBMP, 1)
   imgW := imgH := Ceil(HUDnavBoxSize * imgHUDbaseUnit/20)
   Gdip_GetImageDimensions(whichBitmap, rImgW, rImgH)
   calcIMGdimensions(rImgW, rImgH, imgW, imgH, ResizedW, ResizedH)

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, "0xE200B")
   If !pBitmap
   {
      If (thumbsDisplaying=1)
         trGdip_DisposeImage(whichBitmap, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      If (thumbsDisplaying=1)
         trGdip_DisposeImage(whichBitmap, 1)
      Return
   }
   ; Gdip_FillRectangle(Gu, pBrushE, 0, 0, ResizedW, ResizedH)
   posX := posY := 0
   E := trGdip_DrawImage(A_ThisFunc, Gu, whichBitmap, posX, posY, ResizedW, ResizedH)
   Gdip_DeleteGraphics(Gu)
   prevBMP := (E!="fail") ? pBitmap : ""
   lastCall := (E!="fail") ? thisCall : ""
   If (E="fail")
      pBitmap := trGdip_DisposeImage(pBitmap, 1)

   If (thumbsDisplaying=1)
      trGdip_DisposeImage(whichBitmap, 1)

   Return pBitmap
}

ImageNavClickResponder(mX, mY, mainWidth, mainHeight) {
   f := (imageAligned=1) ? 0 : 0.5
   If (FlipImgV=1)
      mY := mainHeight - mY
   If (FlipImgH=1)
      mX := mainWidth - mX

   prcW := mX/mainWidth
   prcH := mY/mainHeight
   ; ToolTip, % mX "==" mY "==" mainWidth "==" mainHeight "==" prcW "==" prcH , , , 2
   prcW := (prcW>f) ? prcW - f : f - prcW
   prcH := (prcH>f) ? prcH - f : f - prcH
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   decX := Round(((imgW)*prcW) * zoomLevel)
   decY := Round(((imgH)*prcH) * zoomLevel)
   prcW := mX/mainWidth
   prcH := mY/mainHeight
   If (prcW>f || imageAligned=1)
      decX := -decX
   If (prcH>f || imageAligned=1)
      decY := -decY

   IMGdecalageX := decX
   IMGdecalageY := decY

   If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
      coreReloadThisPicture()
   Else
      filterDelayiedImageDisplay()

   ; dummyTimerDelayiedImageDisplay(50)
}

drawHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath) {
    Static prevImgPath, lastInvoked := 1

    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    pBrush := (mode=2) ? pBrushB : pBrushA
    indicWidth := 150
    lineThickns := imgHUDbaseUnit
    lineThickns2 := lineThickns//4
    If (showHistogram>1 && drawingShapeNow!=1)
    {
       thisImgCall := imgPath currentFileIndex zoomLevel IMGresizingMode imgFxMode showHistogram gdiBitmap undoLevelsRecorded currentUndoLevel UserMemBMP OSDfntSize histogramMode
       thisSizingModes := (IMGresizingMode=1 || IMGresizingMode=2 || IMGresizingMode=5) || (IMGresizingMode=4 && IMGlargerViewPort!=1) ? 1 : 0
       If (imgFxMode!=1 || thisSizingModes!=1 || animGIFplaying=1 || desiredFrameIndex>0)
       {
          prevImgPath := 0
          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          tempBMP := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
          If StrLen(tempBMP)>2
          {
             thisPosX := (DestPosX<0) ? 0 : DestPosX
             thisPosY := (DestPosY<0) ? 0 : DestPosY
             thisW := (newW>mainWidth) ? mainWidth : newW
             thisH := (newH>mainHeight) ? mainHeight : newH
             thisVPimg := Gdip_CloneBmpPargbArea(A_ThisFunc, tempBMP, thisPosX + 1, thisPosY + 1, thisW - 2, thisH - 2)
             createHistogramBMP(thisVPimg)
             trGdip_DisposeImage(thisVPimg, 1)
             trGdip_DisposeImage(tempBMP, 1)
          }
       } Else If (prevImgPath!=thisImgCall) && (A_TickCount - lastInvoked>50)
       {
          lastInvoked := A_TickCount
          prevImgPath := thisImgCall
          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          If StrLen(gdiBitmap)>3
             createHistogramBMP(gdiBitmap)
       }
    } Else prevImgCall := 0

    If (mode=2 && IMGresizingMode=4 && IMGlargerViewPort=1 && slideShowRunning!=1)
    {
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//10
       Gdip_SetPenWidth(pPen1d, thisThick)
       Gdip_DrawRectangle(glPG, pPen1d, thisX, thisY, thisW, thisH)
    } Else If (mode=1 && slideShowRunning!=1)
    {
       thisThick := imgHUDbaseUnit//11
       If (showSelectionGrid=1 || imgSelLargerViewPort=1) && (editingSelectionNow=1)
       {
          Gdip_SetPenWidth(pPen4, thisThick)
          Gdip_DrawRectangle(glPG, pPen4, DestPosX + newW//2 - thisThick//4, DestPosY, thisThick//2, newH)
          Gdip_DrawRectangle(glPG, pPen4, DestPosX, DestPosY + newH//2 - thisThick//4, newW, thisThick//2)
       }

       If (borderAroundImage=1) || (editingSelectionNow=1 && LimitSelectBoundsImg=1)
          Gdip_DrawRectangle(glPG, pPen4, DestPosX - thisThick/2, DestPosY - thisThick/2, newW + thisThick, newH + thisThick)
    }

; visual markers for image viewing conditions

    If (markedSelectFile || FlipImgV=1 || FlipImgH=1 || IMGlargerViewPort=1 || imgFxMode>1) && (slideShowRunning!=1)
    {
       If (FlipImgH=1 && mode=2)
          Gdip_FillRoundedRectangle2(glPG, pBrush, mainWidth//2 - indicWidth//2, mainHeight//2 - lineThickns2//2, indicWidth, lineThickns2, lineThickns2//2)
       If (FlipImgV=1 && mode=2)
          Gdip_FillRoundedRectangle2(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//2, lineThickns2, indicWidth, lineThickns2//2)

       If (imgFxMode>1 && mode=2)
       {
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//4, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2, 0, 180)
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//8, mainHeight//2 - indicWidth//8, indicWidth//4, indicWidth//4, 180, 360)
       }

       If (IMGlargerViewPort=1)
       {
          marginErr := (mode=2) ? 12 : 25
          lineThickns2 := (mode=2) ? lineThickns : lineThickns//3
          If (newH>mainHeight)
          {
             If (DestPosY<-marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, 0, mainWidth, lineThickns2//2)
              If (DestPosY>-newH+mainHeight+marginErr)
                 Gdip_FillRectangle(glPG, pBrush, 0, mainHeight - lineThickns2//2, mainWidth, lineThickns2//2)
          }

          If (newW>mainWidth)
          {
             If (DestPosX<-marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, 0, lineThickns2//2, mainHeight)
              If (DestPosX>-newW+mainWidth+marginErr)
                 Gdip_FillRectangle(glPG, pBrush, mainWidth - lineThickns2//2, 0, lineThickns2//2, mainHeight)
          }
       }

       If resultedFilesList[currentFileIndex, 2]
       {
          thisThick := (mode=2) ? lineThickns//2.5 : lineThickns//4.2
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen3, 0, 0, mainWidth, mainHeight)
          Gdip_DrawRectangle(glPG, pPen1d, 0, 0, mainWidth, mainHeight)
       } Else If (markedSelectFile)
       {
          sqSize := (mode=2) ? lineThickns + lineThickns2 : lineThickns
          sqPosX := mainWidth - sqSize
          Gdip_FillRectangle(glPG, pBrush, sqPosX, 0, sqSize, sqSize)
          thisThick := lineThickns//9
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen1d, sqPosX, 0, sqSize, sqSize)
       }
    }

    lineThickns := imgHUDbaseUnit//9
    If (mode=2)
       lineThickns :=  imgHUDbaseUnit//10

; highlight usePrevious=1 mode

    If (mode=2 && imgFxMode=1)
    {
       indicWidth := (zoomLevel<1) ? Round(120 * zoomLevel) : 110
       If (indicWidth<50)
          indicWidth := 50
       Gdip_SetPenWidth(pPen2, lineThickns)
       Gdip_FillRectangle(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
       Gdip_DrawRectangle(glPG, pPen2, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
    }

; draw the scrollbar indicators

    prcVisX := mainWidth/newW
    prcVisY := mainHeight/newH
    knobW := Round(mainWidth*prcVisX)
    knobH := Round(mainHeight*prcVisY)
    If (knobH<15)
       knobH := 15
    If (knobW<15)
       knobW := 15

    Ax := (DestPosX<0) ? Abs(DestPosX)/newW : 0
    Ax := Round(Ax*maxSelX)
    Ay := (DestPosY<0) ? Abs(DestPosY)/newH : 0
    Ay := Round(Ay*maxSelY)
    knobX := Round((Ax/maxSelX)*mainWidth)
    knobY := Round((Ay/maxSelY)*mainHeight) 
    knobSize := (mode=2) ? imgHUDbaseUnit//2 : imgHUDbaseUnit//3
    If (knobW<mainWidth - 5) && (IMGresizingMode=4 && slideShowRunning!=1)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, knobX, 0, knobW, knobSize)
       scrollBarHy := mainHeight - knobSize
       Gdip_FillRectangle(glPG, pBrushE, 0, scrollBarHy, mainWidth, knobSize)
       Gdip_FillRectangle(glPG, pBrushD, knobX, scrollBarHy + 5, knobW, knobSize)
    } Else scrollBarHy := 0

    If (knobH<mainHeight - 5) && (IMGresizingMode=4 && slideShowRunning!=1)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, 0, knobY, knobSize, knobH)
       scrollBarVx := mainWidth - knobSize
       Gdip_FillRectangle(glPG, pBrushE, scrollBarVx, 0, knobSize, mainHeight)
       Gdip_FillRectangle(glPG, pBrushD, scrollBarVx + 5, knobY, knobSize, knobH)
    } Else scrollBarVx := 0

; highlight number of frames and the current frame in multi-frame images [tiff and gif]

    If (totalFramesIndex>0)
    {
        bulletSize := imgHUDbaseUnit//3
        totalBulletsWidth := bulletSize * totalFramesIndex
        If (totalBulletsWidth>mainWidth)
           bulletsPerc := Round(desiredFrameIndex/totalFramesIndex, 3)
        maxBullets := Round(mainWidth/bulletSize)
        centerPos := bulletsPerc ? 0 : mainWidth//2 - totalBulletsWidth//2
        If (centerPos<0)
           centerPos := 0
        Loop, % totalFramesIndex + 1
        {
            If bulletsPerc
               whichBrush := (A_Index/maxBullets<bulletsPerc) || (desiredFrameIndex=totalFramesIndex) ? pBrushA : pBrushE
            Else
               whichBrush := (A_Index - 1 <= desiredFrameIndex) ? pBrushA : pBrushE
            Gdip_FillEllipse(glPG, whichBrush, centerPos + bulletSize * (A_Index - 1), mainHeight - bulletSize, bulletSize, bulletSize)
            If (A_index>maxBullets)
               Break
        }
    }

    If (adjustNowSel=1)
       Return

    If (showHistogram>1 && StrLen(HistogramBMP)>3)
    { 
       Gdip_GetImageDimensions(HistogramBMP, imgW, imgH)
       thisPosX := (scrollBarVx>0) ? scrollBarVx - imgW : mainWidth - imgW
       thisPosY := (scrollBarHy>0) ? scrollBarHy - imgH : mainHeight - imgH
       If (FlipImgH=1 || FlipImgV=1)
       {
          tempBMP := trGdip_CloneBitmap(A_ThisFunc, HistogramBMP)
          flipBitmapAccordingToViewPort(tempBMP, 1)
          E := trGdip_DrawImage(A_ThisFunc, glPG, tempBMP, thisPosX, thisPosY)
          trGdip_DisposeImage(tempBMP, 1)
       } Else E := trGdip_DrawImage(A_ThisFunc, glPG, HistogramBMP, thisPosX, thisPosY,,,,,,, 0.9)

       If (FlipImgH=1)
          thisPosX := 0 + Round(mainWidth - scrollBarVx)
       If (FlipImgV=1)
          thisPosY := 0 + Round(mainHeight - scrollBarHy)

       HUDobjHistoBoxu[1] := imgW, HUDobjHistoBoxu[2] := imgH
       HUDobjHistoBoxu[3] := thisPosX, HUDobjHistoBoxu[4] := thisPosY
       hasDrawnHistoMap := (E="fail") ? 0 : 1
    } Else hasDrawnHistoMap := 0

    additionalHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, 1)
}

snapPoints(gmX, gmY, dulaX, dulaY, ByRef guX, ByRef guY) {
    mustSnapLiveDrawPoints := 1
    guY := gmY, guX := gmX
    zY := Abs(gmY),   zX := Abs(gmX)
    wY := Abs(dulaY), wX := Abs(dulaX)
    maxX := max(zX, wX), maxY := max(zY, wY)
    minX := min(zX, wX), minY := min(zY, wY)
    lenX := maxX - minX
    lenY := maxY - minY
    lenAvg := (lenX + lenY)//2
    thisAngle := getAngleBetweenTwoPoints(gmX, gmY, dulaX, dulaY, 2)
    ; ToolTip, % thisAngle , , , 2
    If isInRange(thisAngle, 30, 60)
    {
       guX := dulaX + lenAvg
       guY := dulaY - lenAvg
    } Else If isInRange(thisAngle, 120, 150)
    {
       guX := dulaX - lenAvg
       guY := dulaY - lenAvg
    } Else If isInRange(thisAngle, 210, 240)
    {
       guX := dulaX - lenAvg
       guY := dulaY + lenAvg
    } Else If isInRange(thisAngle, 300, 330)
    {
       guX := dulaX + lenAvg
       guY := dulaY + lenAvg
    } Else If (lenX>lenY)
       guY := dulaY
    Else
       guX := dulaX
}

getAngleBetweenTwoPoints(x1, y1, x2, y2, mode:=1) {
   ; function from tidbit
   ; based on http://stackoverflow.com/questions/2339487/calculate-angle-of-2-points
   ; returns 0-359.999
  angle := APIatan2(y1-y2, x1-x2)*(180/3.14159)*-1
  if (mode=2)
     angle += (angle<0) ? 360 : 0 ; or should it be 359? whatever.
  return angle
}

APIatan2(y,x) { 
   Return dllcall("msvcrt\atan2","Double",y, "Double",x, "CDECL Double")
}

drawLiveCreateShape() {
    If StrLen(HistogramBMP)>2
       HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)

    newShape := ""
    newArrayu := []
    Loop, % customShapePoints.Count()
    {
       maxPoints := A_Index
       splitu := customShapePoints[A_Index]
       xu := splitu[1] - (initialDrawingStartCoords[A_Index, 1] - prevDestPosX)
       yu := splitu[2] - (initialDrawingStartCoords[A_Index, 2] - prevDestPosY)
       newArrayu[A_Index] := [xu, yu]
       newShape .= xu "," yu "|"
    }

    SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
    PointsList := newShape
    GetMouseCoord2wind(PVhwnd, mX, mY)
    If (FlipImgH=1 || FlipImgV=1)
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

    gmX := (FlipImgH=1) ? mainWidth - mX : mX
    gmY := (FlipImgV=1) ? mainHeight - mY : mY
    dontAddPoint := 0
    If (IMGlargerViewPort=1 && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1))
    {
       ; handle H/V scrollbars for images larger than the viewport
       If (scrollBarHy>1) && ((mY>scrollBarHy && FlipImgV=0)
       || (mY<(mainHeight - scrollBarHy) && FlipImgV=1))
       {
          dontAddPoint := -1
       } Else If (scrollBarVx>1) && ((mX>scrollBarVx && FlipImgH=0)
       || (mX<(mainWidth - scrollBarVx) && FlipImgH=1))
       {
          dontAddPoint := -1
       }
    }

    If GetKeyState("Space", "P")
       dontAddPoint := -1
    Else If (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1 && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
       dontAddPoint := -1

    MouseGetPos, , , OutputVarWin
    If (OutputVarWin!=PVhwnd) || (A_TickCount - zeitSillyPrevent<100)
       dontAddPoint := -1

    If (dontAddPoint!=-1)
    {
       Loop, % newArrayu.Count()
       {
          If (A_Index=1 && drawingLiveMode=1)
             Continue

          xu := newArrayu[A_Index, 1]
          yu := newArrayu[A_Index, 2]
          If isDotInRect(gmX, gmY, xu - SelDotsSize//2, xu + SelDotsSize, yu - SelDotsSize//2, yu + SelDotsSize)
             dontAddPoint := A_Index
       }
    }

    mustSnapLiveDrawPoints := 0
    If (GetKeyState("Shift", "P") && dontAddPoint=0 && maxPoints)
    {
       snapPoints(gmX, gmY, newArrayu[maxPoints, 1], newArrayu[maxPoints, 2], gmX, gmY)
       VPstampBMPx := gmX, VPstampBMPy := gmY
    }

    If (dontAddPoint=0)
       PointsList .= gmX "," gmY "|"
    ; ToolTip, % gmX "--" gmY , , , 2
    ; ToolTip, % tensionCurveCustomShape "=t" , , , 2
    PointsList := Trimmer(PointsList, "|")
    If (PenuDrawLive && ST_Count(PointsList, "|")<=1)
    {
       Gdip_SetPenWidth(pPen4, imgHUDbaseUnit//11)
       Gdip_DrawLines(2NDglPG, pPen4, PointsList)
    } Else If (PenuDrawLive)
    {
       If (drawingLiveMode=1 || drawingLiveMode=3)
       {
          If (closedLineCustomShape=1)
          {
             If (cardinalCurveCustomShape=1)
                Gdip_DrawClosedCurve(2NDglPG, PenuDrawLive, PointsList, tensionCurveCustomShape)
             Else
                Gdip_DrawPolygon(2NDglPG, PenuDrawLive, PointsList)
          } Else
          {
             If (cardinalCurveCustomShape=1)
                Gdip_DrawCurve(2NDglPG, PenuDrawLive, PointsList, tensionCurveCustomShape)
             Else
                Gdip_DrawLines(2NDglPG, PenuDrawLive, PointsList)
          }
       } Else
       {
          If (cardinalCurveCustomShape=1)
             Gdip_FillClosedCurve(2NDglPG, PenuDrawLive, PointsList, tensionCurveCustomShape)
          Else
             Gdip_FillPolygon(2NDglPG, PenuDrawLive, PointsList)
       }
    }

    If (dontAddPoint!=-1 && (A_TickCount - lastZeitFileSelect>250))
    {
       Loop, % customShapePoints.Count()
       {
           xu := newArrayu[A_Index, 1]
           yu := newArrayu[A_Index, 2]
           If (A_Index=dontAddPoint)
              Gdip_FillRectangle(2NDglPG, pBrushE, xu - SelDotsSize, yu - SelDotsSize, SelDotsSize*2, SelDotsSize*2)

           whichBrush := (A_Index=1 || A_Index=maxPoints) ? pBrushC : pBrushD
           Gdip_FillRectangle(2NDglPG, whichBrush, xu - SelDotsSize//2, yu - SelDotsSize//2, SelDotsSize, SelDotsSize)
       }
    }
}

convertCustomShape2relativeCoords(PointsListArray) {
    If (PointsListArray.Count()<3)
       Return

    minXu := minYu := 99993234489
    maxXu := maxYu := -99993234489
    newArrayu := []
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       xu := c[1] - (initialDrawingStartCoords[A_Index, 1] - prevDestPosX)
       yu := c[2] - (initialDrawingStartCoords[A_Index, 2] - prevDestPosY)
       minXu := min(xu, minXu), minYu := min(yu, minYu)
       maxXu := max(xu, maxXu), maxYu := max(yu, maxYu)
       newArrayu[thisIndex] := [xu, yu]
    }

    MouseCoords2Image(minXu, minYu, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX1, imgSelY1)
    MouseCoords2Image(maxXu, maxYu, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX2, imgSelY2)
    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    defineRelativeSelCoords(imgW, imgH)
    initialCustomShapeCoords := imgSelX1 "|" imgSelY1 "|" bounds.w "|" bounds.h
    INIaction(1, "initialCustomShapeCoords", "General")
    mX := maxXu - minXu
    mY := maxYu - minYu

    newShape := []
    Loop, % newArrayu.Count()
    {
       xu := (newArrayu[A_Index, 1] - minXu) / mX
       yu := (newArrayu[A_Index, 2] - minYu) / mY
       newShape[A_Index] := [xu, yu]
       ; newShapa .= xu "," yu "|"
    }

    ; ToolTip, % newShapa , , , 2
    Return newShape
    ; SetTimer, dummyRefreshImgSelectionWindow, -150
}

adjustCustomShapePositionLive(dir:=0) {
    Static lastInvoked := 1
    If (customShapePoints.Count()<3)
       Return

    stepuX := stepuY := 0
    If (Abs(dir)=1)
       stepuX := (dir=1) ? 2 : -2

    If (Abs(dir)=2)
       stepuY := (dir=2) ? 2 : -2

    If (A_TickCount - lastInvoked<400)
    {
       stepuX *= 2
       stepuY *= 2
    }

    newArrayu := []
    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       xu := c[1] - stepuX
       yu := c[2] - stepuY
       newArrayu[thisIndex] := [xu, yu]
    }
    lastZeitFileSelect := A_TickCount
    If (thisIndex>2)
       customShapePoints := newArrayu.Clone()
    lastInvoked := A_TickCount
}

convertCustomShape2givenArea(PointsListArray, refX, refY, refW, refH) {
    ; drawingShapeNow := 0
    If (PointsListArray.Count()<3)
       Return

    newShape := ""
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       xu := refW * c[1] + refX
       yu := refH * c[2] + refY
       If (xu="" || yu="")
          Continue

       newShape .= xu "," yu "|"
       ; newShape .= Round(xu) "," Round(yu) "|"
    }
    ; ToolTip, % newShape , , , 2
    Return Trimmer(newShape, "|")
}

convertShapePointsArrayToStr(PointsListArray) {
    If (PointsListArray.Count()<3)
       Return

    newShape := ""
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       newShape .= c[1] "," c[2] "|"
    }

    Return Trimmer(newShape, "|")
}

convertShapePointsStrToArray(PointsList) {
    If !InStr(PointsList, "|")
       Return

    newShape := []
    Loop, Parse, PointsList, "|"
    {
       c := StrSplit(A_LoopField, ",")
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       newShape[thisIndex] := [c[1], c[2]]
    }

    If (newShape.Count()<3)
       Return
    ; ToolTip, % A_ThisFunc "=" thisIndex , , , 2
    Return newShape
}

additionalHUDelements(mode:=0, mainWidth:=0, mainHeight:=0, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0, directRefresh:=0) {
    Critical, on

    trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
    setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)

    If (drawingShapeNow=1)
       drawLiveCreateShape()
    Else If (editingSelectionNow=1 && mode=2)
       drawImgSelectionOnWindow("prev", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=1)
       drawImgSelectionOnWindow("active", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=3)
       drawImgSelectionOnWindow("return", "-", "-", "-", mainWidth, mainHeight)

    If (showImgAnnotations=1 && !AnyWindowOpen && drawingShapeNow!=1 && currentUndoLevel<3)
       drawAnnotationBox(mainWidth, mainHeight)

    If (showInfoBoxHUD>=1 && drawingShapeNow!=1)
       drawinfoBox(mainWidth, mainHeight, directRefresh)

    If (imgEditPanelOpened=1 && AnyWindowOpen!=10 && drawingShapeNow!=1 && imgSelOutViewPort!=1 && mode!=2)
       livePreviewsImageEditing()

    If (showHUDnavIMG=1 && IMGlargerViewPort=1 && slideShowRunning!=1)
       VPnavBoxWrapper(mainWidth, mainHeight)

    Gdip_ResetWorldTransform(2NDglPG)
    r2 := LrydWinUpdt(hGDIselectwin, 2NDglHDC)
}

dummyLivePreviewsImageEditing() {
   livePreviewsImageEditing(1)
}

getColorMatrix() {
    Static prevMatrix, prevState

    thisState := "a" ForceNoColorMatrix AnyWindowOpen imgFxMode bwDithering lumosGrayAdjust GammosGrayAdjust lumosAdjust GammosAdjust satAdjust IntensityAlphaChannel chnRdecalage chnGdecalage chnBdecalage
    If (thisState=prevState)
       Return prevMatrix

    matrix := ""
    fraction := (isWinXP=1) ? 0.0001 : 0
    If (ForceNoColorMatrix=1 && AnyWindowOpen=10) || (imgFxMode=1)
       Return matrix

    If (imgFxMode=4 && bwDithering=0)       ; grayscale
       matrix := GenerateColorMatrix(2, lumosGrayAdjust, GammosGrayAdjust + fraction, , IntensityAlphaChannel)
    Else If (imgFxMode=5)       ; grayscale R
       matrix := GenerateColorMatrix(3)
    Else If (imgFxMode=6)       ; grayscale G
       matrix := GenerateColorMatrix(4)
    Else If (imgFxMode=7)       ; grayscale B
       matrix := GenerateColorMatrix(5)
    Else If (imgFxMode=8)  ; alpha channel
       matrix := GenerateColorMatrix(7)
    Else If (imgFxMode=9)  ; negative / invert
       matrix := GenerateColorMatrix(6, , , , IntensityAlphaChannel)
    Else If (imgFxMode=10)  ; sepia
       matrix := GenerateColorMatrix(8, , , , IntensityAlphaChannel)
    Else If (imgFxMode=2 || imgFxMode=3) ; personalized
       matrix := GenerateColorMatrix(1, lumosAdjust, GammosAdjust + fraction, satAdjust, IntensityAlphaChannel, chnRdecalage, chnGdecalage, chnBdecalage)

    prevMatrix := matrix
    prevState := thisState
    Return matrix
}

decideGDIPimageFX(ByRef matrix, ByRef imageAttribs, ByRef pEffect) {
    Static colorzFX := {1:0, 2:1, 3:2, 4:5, 5:6, 6:7, 7:8, 8:9, 9:11}
    matrix := imageAttribs := pEffect := ""
    matrix := getColorMatrix()
    If (thumbsDisplaying=1 && (imgFxMode=3 || imgFxMode=8))
       matrix := ""

    thisFXapplies := (imgFxMode=2 || imgFxMode=3 || imgFxMode=4 || imgFxMode=9 || imgFxMode=10) ? 1 : 0
    mustCreateAttribs := (realGammos!=1 && imgThreshold=0 && !matrix) || (ForceNoColorMatrix=1 || imgFxMode=1) ? 0 : 1
    If (mustCreateAttribs=1)
    {
       imageAttribs := Gdip_CreateImageAttributes()
       Gdip_SetImageAttributesColorMatrix(matrix, imageAttribs)
       If (imgThreshold>0 && thisFXapplies=1 && ForceNoColorMatrix=0)
          Gdip_SetImageAttributesThreshold(imageAttribs, imgThreshold)
       If (realGammos!=1 && thisFXapplies=1 && ForceNoColorMatrix=0)
          Gdip_SetImageAttributesGamma(imageAttribs, realGammos)
    }

    If (isWinXP=1)
       Return "a" thisFXapplies applyAdjusts o_bwDithering lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold thisZatAdjust mustCreateAttribs imgFxMode ForceNoColorMatrix matrix zatAdjust

    o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    applyAdjusts := (ForceNoColorMatrix=1) ? 0 : 1
    thisZatAdjust := (imgFxMode=4 && bwDithering=0 && zatAdjust=0) ? -40 : zatAdjust
    If (thisZatAdjust=0 && hueAdjust=0 && lummyAdjust=0) || !colorzFX[specialColorFXmode]
       applyAdjusts := 0

    If (thisFXapplies=1 && applyAdjusts=1 && o_bwDithering=0 && specialColorFXmode>1)
    {
       paramA := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXmode : hueAdjust
       paramB := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXchannel : thisZatAdjust
       If (colorzFX[specialColorFXmode]=1)
          paramB := 0

       pEffect := Gdip_CreateEffect(colorzFX[specialColorFXmode], paramA, paramB, lummyAdjust)
    }

    Return "a" paramA paramB thisFXapplies applyAdjusts o_bwDithering specialColorFXmode uiColorCurveFXchannel uiColorCurveFXmode lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold thisZatAdjust mustCreateAttribs imgFxMode ForceNoColorMatrix matrix zatAdjust
}

QPV_ShowImgonGuiPrev(whichBitmap, newW, newH, mainWidth, mainHeight, usePrevious, imgPath) {
    Critical, on
    Static prevUpdate, displayFastWas := 1
    If (A_TickCount - prevUpdate > 700)
       displayFastWas := 1

    prevUpdate := A_TickCount
    thisZeit := A_TickCount
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    ; whichImg := (usePrevious=1 && gdiBitmapSmall && imgFxMode!=8 && animGIFplaying!=1) || (usePrevious=3) ? gdiBitmapSmall : gdiBitmap
    If (imgFxMode=8)
       whichBitmap := gdiBitmap

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcIMGcoord(usePrevious, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    thisIMGres := imgW + imgH
    thisWinRes := mainWidth + mainHeight
    interpoImgQuality := (userimgQuality=1) ? 7 : 5
    If ((pEffect || displayFastWas=0) && userimgQuality=1) || (usePrevious=3 && slideShowRunning!=1)
    {
       thisLowMode := 1
       Gdip_SetInterpolationMode(glPG, 5)
    }

    dpX := clampInRange(DestPosX + 1, 0, mainWidth)
    dpY := clampInRange(DestPosY + 1, 0, mainHeight)
    kW := clampInRange(newW - 2, 0, mainWidth)
    kH := clampInRange(newH - 2, 0, mainHeight)

    bonus := 0
    setMainCanvasTransform(mainWidth, mainHeight)
    zL := (zoomLevel<1) ? 1 : zoomLevel*2
    Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
    trGdip_GraphicsClear(A_ThisFunc, glPG, "0xFF" WindowBgrColor)
    If (imgFxMode!=8 && animGIFplaying!=1 && currIMGdetails.HasAlpha=1)
    || (currIMGdetails.HasAlpha=1 && imgFxMode=8)
       Gdip_FillRectangle(glPG, useHatchedBrush("vp"), dpX, dpY, kW, kH)

    If (newW>mainWidth || newH>mainHeight)
    {
       bonus := Round(5*zoomLevel)
       newW += bonus, newH += bonus
       mainWidth += bonus, mainHeight += bonus

       x1 := (DestPosX<0) ? Abs(DestPosX)/newW : 0
       PointX1 := Round(x1*imgW)
       y1 := (DestPosY<0) ? Abs(DestPosY)/newH : 0
       PointY1 := Round(y1*imgH)
       prcW := mainWidth/newW
       prcH := mainHeight/newH
       PointX2 := Round(PointX1 + imgW*prcW)
       PointY2 := Round(PointY1 + imgH*prcH)
       If (PointX2>imgW)
          PointX2 := imgW
       If (PointY2>imgH)
          PointY2 := imgH
       ; tooltip, % PointX1 "," pointY1 " | " PointX2 "," PointY2 " | " thisW "," thisH
    } ; Else r1 := trGdip_DrawImage(A_ThisFunc, glPG, whichBitmap, DestPosX, DestPosY, newW, newH, 0, 0, imgW, imgH, matrix, 2, imageAttribs)

    dPosX := (newW>mainWidth) ? 0 : DestPosX
    dPosY := (newH>mainHeight) ? 0 : DestPosY
    dW := (newW>mainWidth) ? mainWidth : newW
    dH := (newH>mainHeight) ? mainHeight : newH
    sPosX := (newW>mainWidth) ? PointX1 : 0
    sPosY := (newH>mainHeight) ? PointY1 : 0
    sW := (newW>mainWidth) ? PointX2 - PointX1 : imgW
    sH := (newH>mainHeight) ? PointY2 - PointY1 : imgH
    ; ToolTip, % mainHeight "--" dH "--" sH ,,,2

    thisScalarX := (newW>mainWidth) ? 1 : 0
    thisScalarY := (newH>mainHeight) ? 1 : 0
    If (pEffect && !isWinXP)
    {
       dhMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(dhMatrix, dPosX - sPosX, dPosY - sPosY, 1)
       Gdip_ScaleMatrix(dhMatrix, dW/sW, 1, thisScalarX)
       Gdip_ScaleMatrix(dhMatrix, 1, dH/sH, thisScalarY)
    }

    If (pEffect && dhMatrix && !isWinXP)
       r1 := trGdip_DrawImageFX(A_ThisFunc, glPG, whichBitmap,,, sPosX, sPosY, sW, sH, matrix, pEffect, imageAttribs, dhMatrix)
    Else ; If (pEffect || imageAttribs)
       r1 := trGdip_DrawImage(A_ThisFunc, glPG, whichBitmap, dPosX, dPosY, dW, dH, sPosX, sPosY, sW, sH, matrix, 2, imageAttribs)

    newW -= bonus, newH -= bonus
    mainWidth -= bonus, mainHeight -= bonus
    confirmTexBGR := (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270) ? 1 : 0
    If (usrTextureBGR=1 && confirmTexBGR=1)
    {
       Gdip_SetClipRect(glPG, DestPosX, DestPosY, newW, newH, 4)
       Gdip_FillRectangle(glPG, AmbientalTexBrush, 0, 0, mainWidth, mainHeight)
       ; pBrush := Gdip_BrushCreateSolid("0x22000000")
       ; Gdip_FillRectangle(glPG, pBrush, 0, 0, mainWidth, mainHeight)
       ; Gdip_DeleteBrush(pBrush)
       Gdip_ResetClip(glPG)
    }

    Gdip_DeleteMatrix(dhMatrix)
    If (thisLowMode=1)
       Gdip_SetInterpolationMode(glPG, interpoImgQuality)

    diffIMGdecX := diffIMGdecY := 0
    ; ToolTip, %imgW% -- %imgH% == %newW% -- %newH%
    If (usePrevious!=3)
    {
       prevDestPosX := DestPosX
       prevDestPosY := DestPosY
    }

    whichMode := (usePrevious=3 || imgFxMode=8 || animGIFplaying=1) ? 1 : 2
    drawHUDelements(whichMode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath)
    Gdip_ResetWorldTransform(glPG)

    Gdip_DisposeImageAttributes(imageAttribs)
    If (thisLowMode!=1)
       displayFastWas := (A_TickCount - thisZeit < 100) ? 1 : 0

    prevDrawingMode := (thisLowMode=1 || userimgQuality=0) ? 3 : 2
    drawModeBzeit := A_TickCount - thisZeit
    If (CountGIFframes>1 && !AnyWindowOpen && animGIFsSupport=1 && prevAnimGIFwas!=imgPath)
    {
       setGIFframesDelay()
       autoChangeDesiredFrame("start", imgPath)
       SetTimer, autoChangeDesiredFrame, % GIFspeedDelay
    } Else autoChangeDesiredFrame("stop")
    
    r2 := LrydWinUpdt(hGDIwin, glHDC)
    r := (r1!=0 || !r2) ? 0 : 1
    If (r1!=0)
       r := Gdip_ErrorHandler(r1, 0, A_ThisFunc)
    Else If !r2
       r := "UpdateLayeredWindow_Error"

    Return r
}

testSelectOutsideImgEntirely(pBitmap) {
     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nimgSelX2 := max(imgSelX1, imgSelX2)
     nimgSelY2 := max(imgSelY1, imgSelY2)

     Gdip_GetImageDimensions(pBitmap, imgW, imgH)
     If (nimgSelX1<0)
        nimgSelX1 := 0
     If (nimgSelY1<0)
        nimgSelY1 := 0

     If (nimgSelX2<5)
        nimgSelX2 := 1
     If (nimgSelY2<5)
        nimgSelY2 := 1

     If (nimgSelX1>imgW-5)
        nimgSelX1 := ImgW-1
     If (nimgSelY1>ImgH-5)
        nimgSelY1 := imgH-1

     If (nimgSelX2>imgW)
        nimgSelX2 := imgW
     If (nimgSelY2>imgH)
        nimgSelY2 := imgH

     isOutside := 0
     imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     If (imgSelW<3 || imgSelH<3)
        isOutside := 1

     ; If (nimgSelX1<2 && nimgSelY1<2 && nimgSelX2<5 && nimgSelY2<5)
     ;    isOutside := 1

     ; If (nimgSelX1>ImgW-5 && nimgSelY1>imgH-5 && nimgSelX2>imgW && nimgSelY2>imgH)
     ;    isOutside := 1
     Return isOutside
}

distanceBetweenTwoPoints(x1,y1,x2,y2) {
   Return Sqrt((x2 - x1)**2+(y2 - y1)**2)
}

ViewPortSelectionManageCoords(mainWidth, mainHeight, dpX, dpY, maxSelX, maxSelY, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, ByRef zImgSelX1, ByRef zImgSelY1, ByRef zImgSelX2, ByRef zImgSelY2, ByRef vPimgSelW, ByRef vPimgSelH, ByRef vPimgSelPx, ByRef vPimgSelPy) {
     If (LimitSelectBoundsImg=1)
     {
        If (imgSelX1<0)
           imgSelX1 := 0
        If (imgSelY1<0)
           imgSelY1 := 0
 
        If (imgSelX2<2)
           imgSelX2 := 2
        If (imgSelY2<2)
           imgSelY2 := 2
     }

     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nimgSelX2 := max(imgSelX1, imgSelX2)
     nimgSelY2 := max(imgSelY1, imgSelY2)

     If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     kimgSelRatio := Round(kimgSelW/kimgSelH, 2)

     If (LimitSelectBoundsImg!=1 && lockSelectionAspectRatio>1 && kimgSelRatio!=Round(desiredSelAspectRatio, 2) && desiredSelAspectRatio && !adjustingSelDotNow)
     {
        avgWH := min(kimgSelW, kimgSelH)
        nimgSelX2 := nimgSelX1 + Round(avgWH*desiredSelAspectRatio)
        nimgSelY2 := nimgSelY1 + avgWH
     }

     If (kimgSelW>32500)
        nImgSelX2 := nImgSelX1 + 32500
     If (kimgSelH>32500)
        nImgSelY2 := nImgSelY1 + 32500
     If (kimgSelH*kimgSelW>23125**2)
     {
        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        scaleu := (kimgSelH*kimgSelW)/(23125**2)
        nImgSelX2 := nImgSelX1 + Floor(kimgSelW/scaleu)
        nImgSelY2 := nImgSelY1 + Floor(kimgSelH/scaleu)
        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        If (kimgSelW>32500)
           nImgSelX2 := nImgSelX1 + 32500
        If (kimgSelH>32500)
           nImgSelY2 := nImgSelY1 + 32500
     }

     If (editingSelectionNow=1)
        defineRelativeSelCoords(maxSelX, maxSelY)

     If (LimitSelectBoundsImg=1)
        capSelectionRelativeCoords()

     zImgSelX1 := Round(nImgSelX1*zoomLevel)
     zImgSelX2 := Round(nImgSelX2*zoomLevel)
     zImgSelY1 := Round(nImgSelY1*zoomLevel)
     zImgSelY2 := Round(nImgSelY2*zoomLevel)

     minSizu := SelDotsSize*2
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<minSizu)
        vPimgSelW := minSizu
     If (vPimgSelH<minSizu)
        vPimgSelH := minSizu

     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)

     minMargin := 2 ; (mainWidth*0.025 + mainHeight*0.205)//2
     imgSelLargerViewPort := (vPimgSelPx<minMargin && vPimgSelPy<minMargin) && (vPimgSelPx + vPimgSelW>mainWidth - minMargin) && (vPimgSelPy + vPimgSelH>mainHeight - minMargin) ? 1 : 0
     imgSelOutViewPort := 0
     If (vPimgSelPx>mainWidth - minSizu)
     {
        vPimgSelPx := mainWidth - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy>mainHeight - minSizu)
     {
        vPimgSelPy := mainHeight - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPx + vPimgSelW<minSizu)
     {
        vPimgSelW := minSizu*2
        vPimgSelPx := -minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy + vPimgSelH<minSizu)
     {
        vPimgSelH := minSizu*2
        vPimgSelPy := -minSizu
        imgSelOutViewPort := 1
     }

     dotsSize := SelDotsSize
     selDotX := vPimgSelPx - dotsSize//2
     selDotY := vPimgSelPy - dotsSize//2
     selDotAx := vPimgSelPx + vPimgSelW - dotsSize//2
     selDotAy := vPimgSelPy + vPimgSelH - dotsSize//2
     selDotBx := vPimgSelPx + vPimgSelW - dotsSize//2
     selDotBy := vPimgSelPy - dotsSize//2
     selDotCx := vPimgSelPx - dotsSize//2
     selDotCy := vPimgSelPy + vPimgSelH - dotsSize//2
     selDotDx := vPimgSelPx + vPimgSelW//2 - dotsSize//2
     selDotDy := vPimgSelPy + vPimgSelH//2 - dotsSize//2

     If (AnyWindowOpen=31 && PasteInPlaceToolMode=1 && imgEditPanelOpened=1)
        prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY)
}

prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY) {
     If (LimitSelectBoundsImg=1)
     {
        If (previmgSelX1<0)
           previmgSelX1 := 0
        If (previmgSelY1<0)
           previmgSelY1 := 0
 
        If (previmgSelX2<2)
           previmgSelX2 := 2
        If (previmgSelY2<2)
           previmgSelY2 := 2
     }

     nImgSelX1 := min(previmgSelX1, previmgSelX2)
     nImgSelY1 := min(previmgSelY1, previmgSelY2)
     nimgSelX2 := max(previmgSelX1, previmgSelX2)
     nimgSelY2 := max(previmgSelY1, previmgSelY2)

     If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     zImgSelX1 := Round(nImgSelX1*zoomLevel)
     zImgSelX2 := Round(nImgSelX2*zoomLevel)
     zImgSelY1 := Round(nImgSelY1*zoomLevel)
     zImgSelY2 := Round(nImgSelY2*zoomLevel)
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<2)
        vPimgSelW := 2
     If (vPimgSelH<2)
        vPimgSelH := 2

     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)
     dotsSize := SelDotsSize
     prevSelDotX := vPimgSelPx - dotsSize//2
     prevSelDotY := vPimgSelPy - dotsSize//2
     prevSelDotAx := vPimgSelPx + vPimgSelW - dotsSize//2
     prevSelDotAy := vPimgSelPy + vPimgSelH - dotsSize//2
}

createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, ellipse, angleu:=0, keepBounds:=0, zeroTension:=0) {
   ImgSelPath := Gdip_CreatePath()
   If (ellipse=2 && ImgSelPath)
   {
      PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx, imgSelPy, imgSelW, imgSelH)
      If (FillAreaCurveTension=1 || zeroTension=1)
         Gdip_AddPathPolygon(ImgSelPath, PointsList)
      Else
         Gdip_AddPathClosedCurve(ImgSelPath, PointsList, tensionCurveCustomShape)
   } Else If (ellipse=1)
      Gdip_AddPathEllipse(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
   Else
      Gdip_AddPathRectangle(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)

   If (angleu && ImgSelPath)
      Gdip_RotatePathAtCenter(ImgSelPath, angleu, 1, 1, keepBounds)

   Sleep, -1
   Return ImgSelPath
}

drawImgSelectionOnWindow(operation, theMsg:="", colorBox:="", dotActive:="", mainWidth:=0, mainHeight:=0, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0) {
     Static prevMsg, infoBoxBMP, lineThickns, infoW, infoH, pBr0, zPen
          , infoPosX, infoPosY, prevuDPx, prevuDPy, prevNewW, prevNewH

     SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
     maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
     angleu := (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=55) ? VPselRotation : 0
     ; ForceRefreshNowThumbsList()
     If (operation="return")
     {
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        operation := "active"
        newW := prevNewW, newH := prevNewH
        ; DestPosX := prevuDPx, DestPosY := prevuDPy
        DestPosX := prevDestPosX, DestPosY := prevDestPosY
        ; clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
     }

     If !zPen
     {
        zPen := Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10)
        ; Gdip_SetPenDashArray(zPen, "0.2,0.2")
     }

     If ((AnyWindowOpen=44 || AnyWindowOpen=43 || AnyWindowOpen=26) && tinyPrevAreaCoordX="C")
        updateTinyPreviewArea(DestPosX, DestPosY, newW, newH)

     If (operation="init")
     {
        clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
        If StrLen(hitTestSelectionPath)>1
        {
           Gdip_DeletePath(hitTestSelectionPath)
           hitTestSelectionPath := ""
        }

        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
        InfoW := InfoH := ""
        lineThickns := imgHUDbaseUnit//9
        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//13)
     } Else If (operation="prev")
     {
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)
        clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        lineThickns :=  imgHUDbaseUnit//10
        Gdip_SetPenWidth(pPen1, lineThickns)
        ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio)
        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//7)
        Gdip_DrawPath(2NDglPG, zPen, ImgSelPath)
        Gdip_DrawPath(2NDglPG, pPen1, ImgSelPath)

        Gdip_ResetClip(2NDglPG)
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)
     } Else If (operation="active")
     {
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        lineThickns := (editingSelectionNow!=1) ? imgHUDbaseUnit//13 : imgHUDbaseUnit//9

        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//12)
        pPen := (editingSelectionNow=1) ? pPen1d : pPen1
        Gdip_SetPenWidth(pPen, lineThickns)
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)

        ViewPortSelectionManageCoords(mainWidth, mainHeight, DestPosX, DestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 

        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio)
        If (showSelectionGrid=1)
           pathBounds := Gdip_GetPathWorldBounds(ImgSelPath)
        ; Gdip_FillRectangle(2NDglPG, pBrushC, imgSelPx, imgSelPy, imgSelW, imgSelH)
        whichPen := (EllipseSelectMode>0) ? zPen : pPen
        Gdip_DrawPath(2NDglPG, whichPen, ImgSelPath)
        ; If (EllipseSelectMode=1) || ((showSelectionGrid=1 || imgSelLargerViewPort=1) && (EllipseSelectMode!=1))
           ; Gdip_DrawEllipse(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        If (EllipseSelectMode>0)
           Gdip_DrawPath(2NDglPG, pPen, ImgSelPath)

        thisExterior := (editingSelectionNow=1) ? pBrushE : pBrushF
        Gdip_SetClipPath(2NDglPG, ImgSelPath, 4)
        If (imgEditPanelOpened!=1)
           Gdip_FillRectangle(2NDglPG, pBrushF, 0, 0, mainWidth, mainHeight)

        Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        If (imgEditPanelOpened!=1 && showSelectionGrid=1)
           Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)

        Gdip_ResetClip(2NDglPG)
        If (showSelectionGrid=1 || imgSelLargerViewPort=1)
        {
           If (imgSelLargerViewPort=1)
           {
              Gdip_DrawRectangle(2NDglPG, whichPen, 1, 1, mainWidth - 1, mainHeight - 1)
              Gdip_DrawRectangle(2NDglPG, pPen, mainWidth*0.15, mainHeight*0.15, mainWidth - mainWidth*0.3, mainHeight - mainHeight*0.3)
           }
           Gdip_SetClipRect(2NDglPG, imgSelPx, imgSelPy, imgSelW, imgSelH, 0)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2)
           Gdip_ResetClip(2NDglPG)
        }

        If StrLen(hitTestSelectionPath)>1
        {
           Gdip_DeletePath(hitTestSelectionPath)
           hitTestSelectionPath := ""
        }

        If (FlipImgV=1)
           imgSelPy := mainHeight - imgSelPy - imgSelH
        If (FlipImgH=1)
           imgSelPx := mainWidth - imgSelPx - imgSelW

        If (imgSelLargerViewPort!=1)
        {
           hitTestSelectionPath := Gdip_CreatePath()
           Gdip_AddPathRectangle(hitTestSelectionPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
        }
        whichFunc := (vPselRotation!=0) ? "Ellipse" : "Rectangle"
        ; Gdip_RotatePathAtCenter(hitTestSelectionPath, vPselRotation)
        Gdip_Fill%whichFunc%(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
        Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
        Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
        Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
        If (vPselRotation!=0)
           Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)
        Gdip_FillEllipse(2NDglPG, pBrushE, SelDotDx, SelDotDy, dotsSize, dotsSize)

        Gdip_DeletePath(ImgSelPath)
     } Else If (operation="live")
     {
        lineThickns := imgHUDbaseUnit/9
        trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
        ViewPortSelectionManageCoords(mainWidth, mainHeight, prevuDPx, prevuDPy, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 

        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio)
        Gdip_SetPenWidth(pPen1d, lineThickns//2 + 1)
        Gdip_SetClipPath(2NDglPG, ImgSelPath, 4)
        If (imgEditPanelOpened!=1)
           Gdip_FillRectangle(2NDglPG, pBrushE, 0, 0, mainWidth, mainHeight)
        Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        Gdip_DrawLine(2NDglPG, zPen, zImgSelX1 + prevDestPosX, 0, zImgSelX1 + prevDestPosX, mainHeight)
        Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY1 + prevDestPosY, mainWidth, zImgSelY1 + prevDestPosY)
        Gdip_DrawLine(2NDglPG, zPen, zImgSelX2 + prevDestPosX, 0, zImgSelX2 + prevDestPosX, mainHeight)
        Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY2 + prevDestPosY, mainWidth, zImgSelY2 + prevDestPosY)
        Gdip_DrawRectangle(2NDglPG, pPen1d, imgSelPx, imgSelPy, imgSelW, imgSelH)
        pathBounds := Gdip_GetPathWorldBounds(ImgSelPath)
        Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)
        Gdip_ResetClip(2NDglPG)
        If (IMGlargerViewPort!=1)
           Gdip_DrawRectangle(2NDglPG, pPen4, prevuDPx, prevuDPy, prevResizedVPimgW, prevResizedVPimgH)

        If (imgSelW>125 && imgSelH>125 && noTooltipMSGs=0 && minimizeMemUsage!=1 && dotActive!=10 && !InStr(theMsg, "offset"))
        {
           cornersPreview := coreCaptureImgCorners(useGdiBitmap(), 6, 100)
           Gdip_GetImageDimensions(cornersPreview, cImgW, cImgH)
           cX := imgSelPx + imgSelW//2 - cImgW//2
           cY := imgSelPy + imgSelH//2 - cImgH//2
           cX := clampInRange(cX, 0, mainWidth - cImgW)
           cY := clampInRange(cY, 0, mainHeight - cImgH)
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, cornersPreview, cX, cY)
           trGdip_DisposeImage(cornersPreview, 1)
        }

        If (noTooltipMSGs=0 && minimizeMemUsage!=1)
        {
            If (dotActive=10)
            {
               theMsg := SubStr(theMsg, InStr(theMsg, "rotation"))
               fScale := 0.9
            } Else fScale := 1.3

           infoBoxBMP := drawTextInBox(theMsg, OSDFontName, OSDfntSize//fScale, mainWidth//2, mainHeight//2, OSDtextColor, OSDbgrColor, 1, 1)
           colorBoxH := colorBox ? imgHUDbaseUnit//7 : 1
           Gdip_GetImageDimensions(infoBoxBMP, infoW, infoH)
           If (imgSelPy + imgSelH + 5 < mainHeight - infoH)
           {
              infoPosY := (imgSelPy + imgSelH<5) ? 5 : imgSelPy + imgSelH + 20
              If (infoPosY + infoH + colorBoxH>mainHeight)
                 infoPosY := mainHeight - infoH - colorBoxH
           } Else
           {
              otherPos := 1
              infoPosY := (imgSelPy - infoH - colorBoxH <20) ? 5 : imgSelPy - infoH - colorBoxH - 20
              If (infoPosY + infoH + colorBoxH>mainHeight)
                 infoPosY := mainHeight - infoH - colorBoxH
           }
 
           If (dotActive=4 || otherPos=1) && (dotActive!=3)
           {
              infoPosX := imgSelPx  + imgSelW - infoW - 25
              If (infoPosX + infoW>mainWidth)
                 infoPosX := mainWidth - infoW
           } Else
           { 
              infoPosX := (imgSelPx<5) ? 5 : imgSelPx + 25
              If (infoPosX + infoW>mainWidth)
                 infoPosX := mainWidth - infoW
           }
 
           If colorBox
           {
              pBr0 := Gdip_BrushCreateSolid(colorBox)
              Gdip_FillRectangle(2NDglPG, pBr0, infoPosX, infoPosY + infoH, infoW, colorBoxH)
              Gdip_DeleteBrush(pBr0)
           }
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, infoPosX, infoPosY,,,,,,, 0.8)
           infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        }

        ; Gdip_FillRectangle(2NDglPG, pBrushC, imgSelPx, imgSelPy, imgSelW, imgSelH)
        If (showSelectionGrid=1 || imgSelLargerViewPort=1 || EllipseSelectMode>0)
        {
           whichPen := (EllipseSelectMode>0) ? pPen : zPen
           ; Gdip_DrawEllipse(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        }
        pPen := (editingSelectionNow=1) ? pPen1d : pPen1
        Gdip_SetPenWidth(pPen, lineThickns)
        Gdip_DrawPath(2NDglPG, pPen, ImgSelPath)

        If (showSelectionGrid=1 || imgSelLargerViewPort=1)
        {
           Gdip_SetClipRect(2NDglPG, imgSelPx, imgSelPy, imgSelW, imgSelH, 0)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2)
           Gdip_ResetClip(2NDglPG)
        }

        Gdip_FillRectangle(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
        Gdip_FillRectangle(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
        Gdip_FillRectangle(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
        Gdip_FillRectangle(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
        If (dotActive=10)
        {
            ; Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize*2, dotsSize*2)
            Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)
        }
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)

        If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
        {
           r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
           livePreviewsImageEditing()
        } Else r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
     } Else If (operation="end")
     {
        InfoW := InfoH := ""
        ; Gdip_ResetWorldTransform(2NDglPG)
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        If pBr0
        {
           Gdip_DeleteBrush(pBr0)
           pBr0 := ""
        }

        Gdip_ResetWorldTransform(2NDglPG)
        SetTimer, dummyRefreshImgSelectionWindow, -25
     }

     If (AnyWindowOpen=44 || AnyWindowOpen=43 || AnyWindowOpen=26)
     {
        ImageCoords2Window(tinyPrevAreaCoordX, tinyPrevAreaCoordY, DestPosX, DestPosY, dotsSize, outX, outY)
        Gdip_FillRectangle(2NDglPG, pBrushE, outX, outY, dotsSize, dotsSize)
        Gdip_DrawRectangle(2NDglPG, pPen1d, outX, outY, dotsSize, dotsSize)
     }
}

dummyRefreshImgSelectionWindow() {
     Static prevStatus, loopsOccured := 0
     If (editingSelectionNow=1 && IMGresizingMode=5)
     {
        thisu := 1
        IMGresizingMode := 1
        interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
     }

     ; ToolTip, % "l=" drawingShapeNow "==" editingSelectionNow "==" drawingLiveMode , , , 2
     If (drawingShapeNow!=1 && imgSelX2=-1 && imgSelY2=-1 && editingSelectionNow=1) || (thisu=1)
     {
        dummyTimerDelayiedImageDisplay(25)
        Return
     }

     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     If (drawingShapeNow=1)
        GetMouseCoord2wind(PVhwnd, mX, mY)

     thisState := "a" mX mY mainWidth mainHeight closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count()lastZeitFileSelect
     If (thisState!=prevStatus) || (drawingShapeNow!=1)
     {
        loopsOccured++
        ; ToolTip, % loopsOccured "==" thisState " -- " A_TickCount , , , 2
        additionalHUDelements(3, mainWidth, mainHeight)
        prevStatus := thisState
     }
}

QPV_ShowImgonGui(newW, newH, mainWidth, mainHeight, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged, ByRef wasPrevious) {
    Critical, on
    Static IDviewPortCache, PREVtestIDvPcache, prevImgAlphaChn
    If (ForceIMGload=1)
       IDviewPortCache := PREVtestIDvPcache := ""

    prevLoadedImageIndex := currentFileIndex
    createGDIPcanvas(mainWidth, mainHeight)
    testIDvPcache := imgPath zoomLevel IMGresizingMode imageAligned IMGdecalageX IMGdecalageY mainWidth mainHeight desiredFrameIndex gdiBitmap
    If (CountGIFframes>1 && !AnyWindowOpen && animGIFsSupport=1 && prevAnimGIFwas!=imgPath)
       mustPlayAnim := 1
    Else
       DestroyGIFuWin()

    If StrLen(gdiBMPvPsize)>3
    {
       Gdip_GetImageDimensions(gdiBMPvPsize, gImgW, gImgH)
    } Else
    {
       gImgW := mainWidth
       gImgH := mainHeight
    }

    totalNewSize := newW//2 + newH//2
    totalVPsize := mainWidth//2 + mainHeight//2
    totalVPcacheSize := gImgW//2 + gImgH//2
    gdiSmallSize := determineGDIsmallCacheSize()
    totalMainGDIsize := gdiSmallSize.TGDI
    If (usePrevious=1)
    {
       smallestSize := min(totalVPcacheSize, gdiSmallSize.T)
       largestSize := max(totalVPcacheSize, gdiSmallSize.T)
       If (totalNewSize>smallestSize*16)
          mustGenerate := (largestSize=totalVPcacheSize) ? 1 : 2
       Else
          mustGenerate := (smallestSize=totalVPcacheSize) ? 1 : 2

       If (totalNewSize>totalMainGDIsize*6)
       {
          whichBitmap := gdiBitmap
          mustGenerate := 0
       }
       ; msgbox, % "lol " mustGenerate
    } Else
    {
       Strarrayu := Round(totalVPcacheSize*2) "|" gdiBMPvPsize "|1`n"
       Strarrayu .= gdiSmallSize.T "|" gdiBitmapSmall "|2`n"
       Strarrayu .= totalMainGDIsize "|" gdiBitmap "|0`n"
       Strarrayu .= totalNewSize "|new|0"
       Sort, Strarrayu, ND`n
       arrayu := StrSplit(Strarrayu, "`n")
       Loop, 6
       {
            If InStr(arrayu[A_Index], "|new")
            {
               thisIndex := A_Index
               Break
            }
       }
       If (thisIndex=4)
          ItemArrayu := StrSplit(arrayu[3], "|")
       Else
          ItemArrayu := StrSplit(arrayu[thisIndex + 1], "|")
       ; MsgBox, % Strarrayu "`nlol" thisIndex
       mustGenerate := ItemArrayu[3]
    }
    If (IMGresizingMode=3 || zoomLevel=1)
       mustGenerate := 0
    If (mustGenerate=1 && minimizeMemUsage=1 && usePrevious=1)
       mustGenerate := 2
    If (minimizeMemUsage=1 && usePrevious!=1)
       mustGenerate := 0

    If (mustGenerate=1)
       whichBitmap := RescaleBMPtinyVPsize(mainWidth, mainHeight)
    Else If (mustGenerate=2)
       whichBitmap := RescaleBMPtiny()
    Else
       whichBitmap := gdiBitmap

    ; Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    ; ToolTip, % "lol " mustGenerate "`n" imgW "--" imgH , , , 2
    If (usePrevious=1 && testIDvPcache!=PREVtestIDvPcache) || (mustPlayAnim=1) || (imgFxMode=8 && currIMGdetails.HasAlpha=1)
    {
       ; SoundBeep , 900, 100
       If (mustRecordSeenImgs=1 && gdiBMPchanged=1)
          recordSeenIMGdbEntry(imgPath, currentFileIndex)

       wasPrevious := usePrevious
       IDviewPortCache := PREVtestIDvPcache := ""
       r := QPV_ShowImgonGuiPrev(whichBitmap, newW, newH, mainWidth, mainHeight, usePrevious, imgPath)
       oldZoomLevel := ""
       interfaceThread.ahkassign("canCancelImageLoad", 0)
       Return r
    } Else wasPrevious := 0

    interfaceThread.ahkassign("canCancelImageLoad", 0)
    startZeit := A_TickCount
    oldZoomLevel := matrix := ""
    prevDrawingMode := 1
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcIMGcoord(usePrevious, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    remDestPosX := DestPosX - prevDestPosX
    remDestPosY := DestPosY - prevDestPosY
    If (diffIMGdecX || diffIMGdecY) && (remDestPosX || remDestPosY)
    {
       diffIMGdecX := remDestPosX
       diffIMGdecY := remDestPosY
    } Else diffIMGdecX := diffIMGdecY := 0
    If (minimizeMemUsage=1)
       diffIMGdecX := diffIMGdecY := 0

    dpX := clampInRange(DestPosX + 1, 0, mainWidth)
    dpY := clampInRange(DestPosY + 1, 0, mainHeight)
    kW := clampInRange(newW - 2, 0, mainWidth)
    kH := clampInRange(newH - 2, 0, mainHeight)
    Gdip_ResetClip(glPG)
    If (imgFxMode!=8 && currIMGdetails.HasAlpha=1)
       Gdip_FillRectangle(glPG, useHatchedBrush("vp"), dpX, dpY, kW, kH)

    thisThingMatrix := (IntensityAlphaChannel!=1 && (imgFxMode=2 || imgFxMode=3 || (imgFxMode=4 && bwDithering=0) || imgFxMode=9 || imgFxMode=10)) ? 1 : 0
    thisIDviewPortCache := "a" IntensityAlphaChannel thisThingMatrix imgPath zoomLevel IMGresizingMode imageAligned IMGdecalageX IMGdecalageY mainWidth mainHeight usePrevious desiredFrameIndex gdiBitmap whichBitmap
    thisImgAlphaChn := "a" IntensityAlphaChannel thisThingMatrix
    ; ToolTip, % thisIDviewPortCache "==" zr "rr==" gdipLastError "==" currIMGdetails.HasAlpha "==" undoLevelsArray[currentUndoLevel, 5] "==" pBrushHatchLow, , , 2
    If (prevImgAlphaChn!=thisImgAlphaChn)
    {
       usePrevious := IDviewPortCache := diffIMGdecX := diffIMGdecY := 0
       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    }

    If (thisIDviewPortCache!=IDviewPortCache || !ViewPortBMPcache || CountGIFframes>1) && (usePrevious!=1)
    {
       prevImgAlphaChn := thisImgAlphaChn
       prevDestPosX := DestPosX
       prevDestPosY := DestPosY
       canvasClipped := (diffIMGdecX || diffIMGdecY) && (IMGresizingMode=4) ? 1 : 0
       nZL := (zoomLevel<1) ? 1 : zoomLevel / 2
       marginErr := (canvasClipped=1) ? 1.25*nZL : 0
       thisMainWidth := (canvasClipped=1 && diffIMGdecX) ? Abs(diffIMGdecX) + 1 : mainWidth
       thisMainHeight := (canvasClipped=1 && diffIMGdecY) ? Abs(diffIMGdecY) + marginErr : mainHeight
       If (thisMainWidth<mainWidth && thisMainHeight<mainHeight)
       {
          ignoreSomeOptimizations := 1
          thisMainWidth := mainWidth
          thisMainHeight := mainHeight
       }

       If ((newW>thisMainWidth) || (newH>thisMainHeight))
       {
          x1 := (DestPosX<0) ? Abs(DestPosX)/newW : 0
          PointX1 := (x1*imgW)
          y1 := (DestPosY<0) ? Abs(DestPosY)/newH : 0
          PointY1 := (y1*imgH)
          prcW := thisMainWidth/newW
          prcH := thisMainHeight/newH
          oPrcW := (mainWidth - thisMainWidth)/newW
          oPrcH := (mainHeight - thisMainHeight)/newH
          If (diffIMGdecX<0 && canvasClipped=1 && ignoreSomeOptimizations!=1)
             PointX1 := (PointX1 + imgW*oPrcW)
          If (diffIMGdecY<0 && canvasClipped=1 && ignoreSomeOptimizations!=1)
             PointY1 := (PointY1 + imgH*oPrcH)
          PointX2 := (PointX1 + imgW*prcW)
          PointY2 := (PointY1 + imgH*prcH)
          If (PointX2>imgW)
             PointX2 := imgW
          If (PointY2>imgH)
             PointY2 := imgH
       } ; Else r1 := trGdip_DrawImage(A_ThisFunc, glPG, whichBitmap, DestPosX, DestPosY, newW, newH, 0, 0, imgW, imgH, matrix, 2, imageAttribs)

       dPosX := (newW>thisMainWidth) ? 0 : DestPosX
       If (canvasClipped=1 && thisMainWidth!=mainWidth && diffIMGdecX<0)
          dPosX := mainWidth - thisMainWidth
 
       dPosY := (newH>thisMainHeight) ? 0 : DestPosY
       If (canvasClipped=1 && thisMainHeight!=mainHeight && diffIMGdecY<0)
          dPosY := mainHeight - thisMainHeight 
 
       dW := (newW>thisMainWidth) ? thisMainWidth : newW
       dH := (newH>thisMainHeight) ? thisMainHeight : newH
       If (canvasClipped=1 && thisMainHeight!=mainHeight && userimgQuality=0)
          dH += nZL

       sPosX := (newW>thisMainWidth) ? (PointX1) : 0
       sPosY := (newH>thisMainHeight) ? (PointY1) : 0
       sW := (newW>thisMainWidth) ? (PointX2 - PointX1) : imgW
       sH := (newH>thisMainHeight) ? (PointY2 - PointY1) : imgH
       If (canvasClipped=1 && ignoreSomeOptimizations=1)
       {
          If ViewPortBMPcache
             r0 := trGdip_DrawImage(A_ThisFunc, glPG, ViewPortBMPcache, 0, 0, mainWidth, mainHeight, 0, 0, mainWidth, mainHeight, matrix, 2, imageAttribs)

          Gdip_SetClipRect(glPG, diffIMGdecX, diffIMGdecY, mainWidth, mainHeight, 4)
       }

       thisMatrix := (thisThingMatrix=1) ? IntensityAlphaChannel : 1
       r1 := trGdip_DrawImage(A_ThisFunc, glPG, whichBitmap, dPosX, dPosY, dW, dH, sPosX, sPosY, sW, sH,thisMatrix,2)
       ; Tooltip, % dPosX "," dPosY "|" dW "," dH "`n" sPosX "," sPosY "|" sW "," sH "`n" newW "," newH "|" thisMainWidth "," thisMainHeight "|" mainWidth "," mainHeight "`n" diffIMGdecX "," diffIMGdecY " || " canvasClipped "," ignoreSomeOptimizations
       If (canvasClipped=1 && ignoreSomeOptimizations=1)
          Gdip_ResetClip(glPG)

       ; ToolTip, %imgW% -- %imgH% == %newW% -- %newH%
       ; mustDisplay := 1
       If (usePrevious!=1)
       {
          If (IMGresizingMode=4 && canvasClipped=1 && ViewPortBMPcache)
          {
             prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)
             prevGDIvpCache := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          }

          ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
          IDviewPortCache := thisIDviewPortCache
          PREVtestIDvPcache := testIDvPcache
          ViewPortBMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       }
    } ; Else mustDisplay := 1
    ; tooltip, % dontMove " - " diffIMGdecX " - " diffIMGdecY " - " r3

    If (diffIMGdecX || diffIMGdecY) && (prevGDIvpCache && canvasClipped=1)
    {
       r3 := trGdip_DrawImage(A_ThisFunc, glPG, prevGDIvpCache, diffIMGdecX, diffIMGdecY)
       mustRecache := 1
    }

    diffIMGdecX := diffIMGdecY := 0
    If (mustRecache=1)
    {
       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
       ViewPortBMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
    } Else prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)

    ; Gdip_SetClipRect(glPG, DestPosX, DestPosY, newW, newH)
    setMainCanvasTransform(mainWidth, mainHeight)
    Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight, 0)
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
   ; gp := Gdip_GetImagePixelFormat(ViewPortBMPcache, 2) 
   ; ToolTip, % gp , , , 2
    If pEffect
       r4 := trGdip_DrawImageFX(A_ThisFunc, glPG, ViewPortBMPcache, 0, 0, 0, 0, mainWidth, mainHeight, matrix, pEffect, imageAttribs)
    Else
       r4 := trGdip_DrawImage(A_ThisFunc, glPG, ViewPortBMPcache, 0, 0, mainWidth, mainHeight, 0, 0, mainWidth, mainHeight, matrix, 2, imageAttribs)

    Gdip_SetClipRect(glPG, DestPosX + 1, DestPosY + 1, newW - 2, newH - 2, 4)
    confirmTexBGR := (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270) ? 1 : 0
    If (usrTextureBGR=1 && confirmTexBGR=1)
    {
       Gdip_FillRectangle(glPG, AmbientalTexBrush, 0, 0, mainWidth, mainHeight)
       ; pBrush := Gdip_BrushCreateSolid("0x11000000")
       ; Gdip_FillRectangle(glPG, pBrush, 0, 0, mainWidth, mainHeight)
       ; Gdip_DeleteBrush(pBrush)
    } Else trGdip_GraphicsClear(A_ThisFunc, glPG, "0xFF" WindowBgrColor)

    Gdip_ResetClip(glPG)
    drawHUDelements(1, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath)
    Gdip_ResetWorldTransform(glPG)
    If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && slideShowDelay>950 && GDIfadeVPcache && animGIFplaying!=1)
    {
       setWindowTitle(pVwinTitle, 1)
       ForceRefreshNowThumbsList()
       tempBMP := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
       r2 := LrydWinUpdt(hGDIthumbsWin, glHDC)
       ToggleVisibilityWindow("show", hGDIthumbsWin)

       trGdip_DrawImage(A_ThisFunc, glPG, GDIfadeVPcache)
       r2 := LrydWinUpdt(hGDIwin, glHDC)
       Loop, 255
       {
           opacity := 255 - A_Index*12
           If (opacity<2)
              Break

           dummyPos := (A_OSVersion!="WIN_7") ? 0 : ""
           r2 := UpdateLayeredWindow(hGDIwin, glHDC, dummyPos, dummyPos, mainWidth, mainHeight, opacity)
           Sleep, 1
       }
       trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
       trGdip_DisposeImage(tempBMP, 1)
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xFF" WindowBGRcolor)
       imageHasFaded := 1
    }

    r2 := LrydWinUpdt(hGDIwin, glHDC)
    If (imageHasFaded=1)
       r2 := LrydWinUpdt(hGDIthumbsWin, 2NDglHDC)

    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeImageAttributes(imageAttribs)

    if (r0!=0)
       fR := r0
    Else if (r1!=0)
       fR := r1
    Else if (r3!=0)
       fR := r3
    Else if (r4!=0)
       fR := r4

    If (fR!=0)
       r := Gdip_ErrorHandler(fR, 0, A_ThisFunc)
    Else If !r2
       r := "UpdateLayeredWindow_Error"

    totalZeit := A_TickCount - startZeitIMGload
    thisZeit := A_TickCount - startZeit
    If (totalZeit<150)
       prevFastDisplay := A_TickCount

    ; prevFullIMGload := A_TickCount
    LastPrevFastDisplay := (totalZeit<125 && usePrevious=0) ? 1 : 0
    PannedFastDisplay := (thisZeit<100 && usePrevious=0 && canvasClipped=1) || (canvasClipped!=1 && minimizeMemUsage!=1) ? 1 : 0
    drawModeAzeit := A_TickCount - startZeit
    If (hasFullReloaded=1 && imageHasFaded!=1)
    {
       fullLoadZeit := A_TickCount - startZeitIMGload
       fullLoadZeit2 := (fullLoadZeit + drawModeCzeit)//2
       drawModeCzeit := max(fullLoadZeit, fullLoadZeit2)
    }
    If (mustRecordSeenImgs=1 && gdiBMPchanged=1 && !InStr(r, "error"))
       recordSeenIMGdbEntry(imgPath, currentFileIndex)

    ; ToolTip, % thisZeit ", " totalZeit ", " drawModeCzeit "==" prevGDIvpCache ,,,2
    Return r
}

getCaptionStyle(hwnd) {
  WinGet, Stylu, Style, ahk_id %hwnd%
  r := (Stylu & 0xC00000) ? 0 : 1
  Return r
}

getTopMopStyle(hwnd) {
  WinGet, Stylu, ExStyle, ahk_id %hwnd%
  r := (Stylu & 0x8) ? 1 : 0
  Return r
}

updateUIctrl() {
    interfaceThread.ahkassign("editingSelectionNow", editingSelectionNow)
    interfaceThread.ahkassign("isAlwaysOnTop", isAlwaysOnTop)
    interfaceThread.ahkPostFunction("updateUIctrl")
}

coreselectRandomFiles(howMany, a, b) {
   newArrayu := []
   a := clampInRange(a, 1, maxFilesIndex)
   b := clampInRange(b, 1, maxFilesIndex)
   maxu := max(a, b) - min(a, b)
   If (maxu<3)
      Return

   thisHowMany := clampInRange(howMany, 1, maxu)
   Loop
   {
      Random, Randy, %a%, %b%
      newArrayu[Randy] := 1
      If (newArrayu.Count()=thisHowMany)
         Break
   }

   For Key, Value in newArrayu
      resultedFilesList[Key, 2] := 1
}

selectRandomFiles(howMany, replaceAll, modus) {
   If (replaceAll=1)
      dropFilesSelection(1)

   If (modus=1)
   {
      coreselectRandomFiles(howMany, 1, maxFilesIndex)
   } Else
   {
      thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
      Loop, % Ceil(maxFilesIndex / maxItemsPage)
         coreselectRandomFiles(howMany, (A_Index - 1) * maxItemsPage, A_Index * maxItemsPage)
   }

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   dummyTimerReloadThisPicture(50)
}

PanelSelectRandomFiles() {
   Static a := 1, b := 5, dropListu := "Entire files list`f`fOn every page of thumbnails"

   fakeWinCreator(54, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Select random files: " appTitle, "Please specify how many files to select.", "&Apply|&Cancel", 1, "modify-entry", "Replace pre-existing selection", a, dropListu, "limit6 number", b)

   If InStr(msgResult.btn, "apply")
   {
      a := msgResult.check
      c := msgResult.list
      b := Trimmer(msgResult.edit)
      b := clampInRange(b, 2, maxFilesIndex - 2)
      selectRandomFiles(b, a, c)
      ; dummyTimerDelayiedImageDisplay(50)
   }
}

selectAllFiles(dummy:=0) {
    ; Static selMode := 0
    If (maxFilesIndex<3)
       Return

    selMode := (markedSelectFile < maxFilesIndex || !markedSelectFile) ? 1 : 0
    Loop, % maxFilesIndex
        resultedFilesList[A_Index, 2] := selMode

    lastZeitFileSelect := A_TickCount
    markedSelectFile := (selMode=1) ? maxFilesIndex : 0
    SetTimer, mainGdipWinThumbsGrid, -10
}

ToggleEditImgSelection(dummy:=0) {
  Critical, on
  imgPath := getIDimage(currentFileIndex)
  If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  DestroyGIFuWin()
  If (editingSelectionNow!=1)
     correctActiveSelectionAreaViewPort()

  ; If (relativeImgSelCoords=1)
     calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

  If (getCaptionStyle(PVhwnd)=1)
     ToggleTitleBaruNow()

  editingSelectionNow := (dummy="show-edit") ? 1 : !editingSelectionNow
  updateUIctrl()
  clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
  MouseMoveResponder()
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(25)
}

selectEntireImage(act:=0) {
   imgPath := getIDimage(currentFileIndex)
   If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
      Return

   If (getCaptionStyle(PVhwnd)=1)
      ToggleTitleBaruNow()

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (editingSelectionNow=1)
      recordSelUndoLevelNow()

   vpr := (act="r") ? 0 : vPselRotation
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (ImgSelX2=imgW && imgSelY2=imgH
   && imgSelX1=0 && imgSelY1=0 && editingSelectionNow=1)
   {
      resetImgSelection()
      If (act="rm" && imgEditPanelOpened!=1)
         Return
   } Else
   {
      ImgSelX2 := imgW, imgSelY2 := imgH
      imgSelX1 := imgSelY1 := 0
   }

   vPselRotation := vpr
   editingSelectionNow := 1
   updateUIctrl()
   clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
   ; SetTimer, MouseMoveResponder, -50
   SetTimer, dummyRefreshImgSelectionWindow, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

changeSelectZoom(direction) {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    If (direction=-1)
    {
       imgSelW -= Round(imgSelW*0.02)
       imgSelH -= Round(imgSelH*0.02)
       imgSelX1 += Round(imgSelW*0.01)
       imgSelY1 += Round(imgSelH*0.01)
    } Else
    {
       imgSelW += Round(imgSelW*0.02)
       imgSelH += Round(imgSelH*0.02)
       imgSelX1 -= Round(imgSelW*0.01)
       imgSelY1 -= Round(imgSelH*0.01)
    }

    imgSelX2 := Round(imgSelX1 + imgSelW)
    imgSelY2 := Round(imgSelY1 + imgSelH)
    SetTimer, dummyRefreshImgSelectionWindow, -10
    SetTimer, dummyShowSelCoordsInfos, -25
}

arrowKeysAdjustSelectionArea(direction, modus, extraUmphf:=1) {
    If (thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    factoru := (zoomLevel>2) ? 1 : 2 - zoomLevel
    stepu := Round(2 * (factoru + 0.1))
    If (stepu<2)
       stepu := 2

    stepu := stepu * extraUmphf
    If (FlipImgH=1 && InStr(direction, "1"))
       direction := (direction=1) ? -1 : 1

    If (FlipImgV=1 && InStr(direction, "2"))
       direction := (direction=2) ? -2 : 2

    If (modus=1) ; reposition selection
    {
       If (direction=1)
          imgSelX1 += stepu
       Else If (direction=-1)
          imgSelX1 -= stepu
       Else If (direction=2)
          imgSelY1 += stepu
       Else If (direction=-2)
          imgSelY1 -= stepu
    } Else If (modus=2)
    {
       If (direction=1)
          imgSelX2 += stepu
       Else If (direction=-1)
          imgSelX2 -= stepu
       Else If (direction=2)
          imgSelY2 += stepu
       Else If (direction=-2)
          imgSelY2 -= stepu
    }
    SetTimer, dummyRefreshImgSelectionWindow, -10
    SetTimer, dummyShowSelCoordsInfos, -25
}


arrowKeysAdjustPrevPointPath(direction, modus, extraUmphf:=1) {
    Static lastInvoked := 1
    If (drawingShapeNow!=1)
       Return

    maxu := (modus=1) ? 1 : customShapePoints.Count()
    cX1 := customShapePoints[maxu, 1]
    cY1 := customShapePoints[maxu, 2]

    stepu := (A_TickCount - lastInvoked<400) ? 1 : 2
    If (direction=1)
       cX1 += stepu
    Else If (direction=-1)
       cX1 -= stepu
    Else If (direction=2)
       cY1 += stepu
    Else If (direction=-2)
       cY1 -= stepu

    customShapePoints[maxu, 1] := cX1
    customShapePoints[maxu, 2] := cY1
    lastZeitFileSelect := A_TickCount
    dummyRefreshImgSelectionWindow()
    lastInvoked := A_TickCount
}

dummyShowSelCoordsInfos() {
    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)

    theRatio := "`nRatio: " Round(imgSelW/imgSelH, 2)
    theRatio .= "`nRotation: " Round(vPselRotation, 2) "° "

    theMsg := "X / Y: " ImgSelX1 ", " ImgSelY1 "`nW / H: " imgSelW ", " imgSelH theRatio
    showTOOLtip(theMsg)
    SetTimer, RemoveTooltip, -500
}

toggleImgSelection() {
  If (thumbsDisplaying=1)
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()
  
  If (editingSelectionNow!=1)
     correctActiveSelectionAreaViewPort()

  If (relativeImgSelCoords=1)
     calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

  editingSelectionNow := !editingSelectionNow
  updateUIctrl()
  clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(25)
}

tlbrToggleImgSelection() {
  If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD)
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If (imgSelX2=-1 && imgSelY2=-1)
  {
     ToggleEditImgSelection()
     Return
  }

  If (editingSelectionNow!=1)
     correctActiveSelectionAreaViewPort()

  If (relativeImgSelCoords=1)
     calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

  If (editingSelectionNow=1)
     recordSelUndoLevelNow()

  editingSelectionNow := !editingSelectionNow
  updateUIctrl()
  clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(25)
}

resetImgSelection() {
  If (thumbsDisplaying=1)
     Return

  If (slideShowRunning=1 && editingSelectionNow!=1)
     Return

  imgSelX1 := imgSelY1 := vPselRotation := 0
  imgSelX2 := imgSelY2 := -1
  editingSelectionNow := 0
  updateUIctrl()
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(50)
}

newImgSelection() {
  IMGdecalageX := IMGdecalageY := vPselRotation := 0
  resetImgSelection()
  Sleep, -1
  ToggleEditImgSelection()
}

createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight) {
    If (imgSelX2="C" && imgSelY2="C" && useGdiBitmap())
    {
       GetMouseCoord2wind(PVhwnd, mX, mY)
       MouseCoords2Image(mX - 200, mY - 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
       MouseCoords2Image(mX + 200, mY + 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
       Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
       defineRelativeSelCoords(rImgW, rImgH)
    } Else If (imgSelX2=-1 && imgSelY2=-1)
    {
       obju := createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, 2)
       imgSelX1 := obju.x1, imgSelY1 := obju.y1
       imgSelX2 := obju.x2, imgSelY2 := obju.y2
    }
}

createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, factor) {
    obju := []
    x1 := (DestPosX<0) ? Abs(DestPosX)/newW : 0
    SelX1 := Round(x1*maxSelX)
    y1 := (DestPosY<0) ? Abs(DestPosY)/newH : 0
    SelY1 := Round(y1*maxSelY)
    SelX2 := Round(SelX1 + (mainWidth/factor)/zoomLevel) + 5
    SelY2 := Round(SelY1 + (mainHeight/factor)/zoomLevel) + 5
    If (SelX2>maxSelX/factor && newW<mainWidth)
       SelX2 := maxSelX//factor
    If (SelY2>maxSelY/factor && newH<mainHeight)
       SelY2 := maxSelY//factor

    obju.x1 := SelX1, obju.y1 := SelY1
    obju.x2 := SelX2, obju.y2 := SelY2
    Return obju  
}

correctActiveSelectionAreaViewPort() {
    Static prevDimensions
    If (imgSelX2=-1 && imgSelY2=-1)
       Return

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    theseDimensions := imgW "," imgH
    If (theseDimensions=prevDimensions)
       Return

    capSelectionRelativeCoords()
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    ; msgbox, % x1 "--" x2 "--" y1 "--" y2
    imgSelX1 := X1, imgSelY1 := Y1
    imgSelX2 := X2, imgSelY2 := Y2
    prevDimensions := imgW "," imgH
}

coremakeSquareSelection(imgW, imgH) {
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    avg := (imgSelW+imgSelH)//2
    avg := clampInRange(avg, 5, min(imgW, imgH))
    imgSelX2 := X1 + avg
    imgSelY2 := Y1 + avg
    prcSelX2 := imgSelX2/prevMaxSelX
    If (prcSelX2>1)
       prcSelX2 := 1

    prcSelY2 := imgSelY2/prevMaxSelY
    If (prcSelY2>1)
       prcSelY2 := 1

    Sleep, 1
    If (LimitSelectBoundsImg=1)
       dummyRefreshImgSelectionWindow()
}

makeSquareSelection() {
    If (thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If (lockSelectionAspectRatio>1)
    {
       lockSelectionAspectRatio := 1
       toggleImgSelectionAspectRatio()
       Return
    }

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    doLoops := (LimitSelectBoundsImg=1) ? 20 : 1
    Loop, % doLoops
       coremakeSquareSelection(imgW, imgH)

    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

resetSelectionRotation() {
   vPselRotation := 0
   SetTimer, dummyRefreshImgSelectionWindow, -10
   SetTimer, dummyShowSelCoordsInfos, -20
}

MenuSelRotation() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   VPselRotation := Round(VPselRotation) + 45
   If (VPselRotation>350)
      VPselRotation := 0

   SetTimer, dummyRefreshImgSelectionWindow, -10
   SetTimer, dummyShowSelCoordsInfos, -20
}

flipSelectionWH() {
    If (thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    Gdip_GetRotatedDimensions(imgSelW, imgSelH, 90, rimgSelW, rimgSelH)
    imgSelX2 := X1 + Floor(rimgSelW)
    imgSelY2 := Y1 + Floor(rimgSelH)
    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

ImageCoords2Window(inputX, inputY, DestPosX, DestPosY, dotSize, ByRef outX, ByRef outY) {
   outX := Round(inputX*zoomLevel) + DestPosX - dotSize//2
   outY := Round(inputY*zoomLevel) + DestPosY - dotSize//2
}

MouseCoords2Image(mX, mY, limitBounds, dPosX, dPosY, newW, newH, ByRef x, ByRef y) {
    x1 := (dPosX<0) ? mX + Abs(dPosX) : mX - Abs(dPosX)
    y1 := (dPosY<0) ? mY + Abs(dPosY) : mY - Abs(dPosY)
    If (limitBounds=1)
    {
       x1 := clampInRange(x1, 0, newW)
       y1 := clampInRange(y1, 0, newH)
    }
    prcx1 := x1/newW
    prcy1 := y1/newH
    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    x := Round(imgW * prcx1)
    y := Round(imgH * prcy1)
    ; ToolTip, % mX " -- " mY "`n" x " -- " y "`n" DestPosX " -- " DestPosY "`n" newW " -- " newH "`n" prcx1 " -- " prcy1, , , 2
}

updateTinyPreviewArea(DestPosX, DestPosY, newW, newH) {
    If (tinyPrevAreaCoordX="C" || tinyPrevAreaCoordY="C")
    {
       GetMouseCoord2wind(hGDIwin, mX, mY)
       MouseCoords2Image(mX, mY, 1, DestPosX, DestPosY, newW, newH, x, y)
       tinyPrevAreaCoordX := x, tinyPrevAreaCoordY := y
       WinActivate, ahk_id %hSetWinGui%
       If (AnyWindowOpen=26)
          SetTimer, livePreviewBlurPanel, -100
       Else If (AnyWindowOpen=43)
          SetTimer, livePreviewIDedges, -100
       Else If (AnyWindowOpen=44)
          SetTimer, livePreviewAddNoiser, -100
    } 
}

destroyBlacked() {
  If (imageLoading=1)
  {
     SetTimer, destroyBlacked, -50
     Return
  }
  BlackedCreator(1, 1)
}


ToggleVisibilityWindow(actu, winIDu) {
   Static prevState
   thisState := actu "-" winIDu
   If (thisState=prevState)
      Return

   If (actu="show")
      WinSet, Region,, ahk_id %winIDu%
   Else
      WinSet, Region, 0-0 w1 h1, ahk_id %winIDu%

   prevState := thisState
}

FadeMainWindow() {
   r2 := LrydWinUpdt(hGDIwin, glHDC, 150)
}

GdipCleanMain(modus:=0) {
    If (modus=2)
    {
       ; BlackedCreator(128)
       ; SetTimer, destroyBlacked, -100
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       Gdi_FillShape(glHDC, 0, 0, mainWidth, mainHeight, WindowBgrColor, 1)
       r2 := LrydWinUpdt(hGDIwin, glHDC, 200)
       Return
    }

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    opacity := (modus=1) ? "0xFF" : "0x50"
    If (modus=4 || modus=5 || modus=6)
    {
       ; BMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       If (modus=4)
       {
          graphPath := Gdip_CreatePath()
          x1 := mainWidth//2 - 45
          x2 := mainWidth//2 + 45
          x3 := mainWidth//2
          y1 := mainHeight//2
          y2 := mainHeight//2
          y3 := mainHeight//2 - 200
          PointsList := x1 "," y1 "|" x2 "," y2 "|" x3 "," y3
          Gdip_AddPathPolygon(graphPath, PointsList)
          Gdip_RotatePathAtCenter(graphPath, vpIMGrotation)
       }

       ; trGdip_DrawImage(A_ThisFunc, glPG, BMPcache)
       If (modus=5 || modus=6)
       {
          If (vpIMGrotation>0)
             zoomu := " @ " vpIMGrotation "°"
          zoomu := Round(zoomLevel * 100) "%" zoomu
          thisInfo := max(oldZoomLevel, zoomLevel) - min(oldZoomLevel, zoomLevel)
          If (modus=6)
             thisInfo := zoomu := "( - )"

          If thisInfo
          {
             thisFntSize := (modus!=6) ? OSDfntSize*1.25 : OSDfntSize*0.75
             infoBoxBMP := drawTextInBox(zoomu, OSDFontName, thisFntSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             Gdip_GetImageDimensions(infoBoxBMP, Wi, He)
             If (modus=5)
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2)
             Else
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2,,,,,,, 0.45)
             trGdip_DisposeImage(infoBoxBMP, 1)
          } Else
          {
             imgPath := getIDimage(currentFileIndex)
             zPlitPath(imgPath, 0, OutFileName, OutDir)
             entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
             infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfntSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP)
             trGdip_DisposeImage(infoBoxBMP, 1)
             oldZoomLevel := zoomLevel
          }
       }

       If (modus=4)
       {
          thisW := thisH := 250
          Gdip_FillEllipse(glPG, pBrushE, mainWidth//2 - thisW//2, mainHeight//2 - thisH + 30, thisW, thisH)
          Gdip_FillPath(glPG, pBrushD, graphPath)
          Gdip_DeletePath(graphPath)
       }
       thisOpacity := (modus!=6) ? "0x22" : "0x33"
       Random, hu, 6, 8
       Random, ha, 6, 8
       clr := thisOpacity . ha . hu . ha . hu . ha . hu
       widthu := imgHUDbaseUnit//3
       yPen := Gdip_CreatePen(clr, widthu)
       Gdip_DrawRectangle(glPG, yPen, 0, 0, mainWidth, mainHeight)
       Gdip_DeletePen(yPen)
       r2 := LrydWinUpdt(hGDIwin, glHDC, 225)
       ; trGdip_DisposeImage(BMPcache)
    } Else 
    {
       trGdip_GraphicsClear(A_ThisFunc, glPG, opacity WindowBgrColor)
       r2 := LrydWinUpdt(hGDIwin, glHDC)
    }
}

clearGivenGDIwin(Gu, DCu, hwnd) {
    trGdip_GraphicsClear(A_ThisFunc, Gu, "0x00" WindowBgrColor, 1)
    r := LrydWinUpdt(hwnd, DCu)
    Return r
}

GetCachableImgFileDetails(imgPath, imgIndex, thumbBMP:=0, returnObj:=0, isFilter:=0) {
     If (!imgPath || !imgIndex)
     {
        fnOutputDebug(A_ThisFunc "() - wow error: " imgIndex " = " imgPath)
        Return
     }

     wasGiven := r := 0
     ; fnOutputDebug(A_ThisFunc "() - no cache: " imgIndex " = " imgPath)
     If !thumbBMP
     {
        ; mainLoadedIMGdetails := []
        If RegExMatch(imgPath, RegExFIMformPtrn)
        {
           r := LoadFimFile(imgPath, 1, 1)
        } Else
        {
           oBitmap := trGdip_CreateBitmapFromFile(imgPath)
           If StrLen(oBitmap)>2
           {
              Gdip_GetImageDimensions(oBitmap, imgW, imgH)
              If (!imgW || !imgH)
              {
                 trGdip_DisposeImage(oBitmap, 1)
                 r := LoadFileWithWIA(imgPath, 1, 1)
              }
              r := 1
              Gdip_BitmapGetDPIResolution(oBitmap, dpix, dpiy)
              mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
              mainLoadedIMGdetails.Width := imgW
              mainLoadedIMGdetails.Height := imgH
              mainLoadedIMGdetails.Frames := Gdip_GetBitmapFramesCount(oBitmap) - 1
              mainLoadedIMGdetails.PixelFormat := Gdip_GetImagePixelFormat(oBitmap, 2)
              trGdip_DisposeImage(oBitmap, 1)
           } Else r := LoadFileWithWIA(imgPath, 1, 1)
        }

        If (r=1)
        {
           If (returnObj=1)
           {
              obju := []
              obju.w := mainLoadedIMGdetails.Width
              obju.h := mainLoadedIMGdetails.Height
              obju.pixFmt := mainLoadedIMGdetails.PixelFormat
              obju.frames := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames +1 : 1
              obju.ratio := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              obju.mgpx := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              obju.dpi := mainLoadedIMGdetails.dpi
           } Else If isFilter
           {
              bckpResultedFilesList[imgIndex, 9] := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
              bckpResultedFilesList[imgIndex, 13] := mainLoadedIMGdetails.Width
              bckpResultedFilesList[imgIndex, 14] := mainLoadedIMGdetails.Height
              bckpResultedFilesList[imgIndex, 15] := mainLoadedIMGdetails.PixelFormat
              bckpResultedFilesList[imgIndex, 16] := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              bckpResultedFilesList[imgIndex, 17] := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              bckpResultedFilesList[imgIndex, 22] := mainLoadedIMGdetails.dpi
           } Else
           {
              resultedFilesList[imgIndex, 9] := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
              resultedFilesList[imgIndex, 13] := mainLoadedIMGdetails.Width
              resultedFilesList[imgIndex, 14] := mainLoadedIMGdetails.Height
              resultedFilesList[imgIndex, 15] := mainLoadedIMGdetails.PixelFormat
              resultedFilesList[imgIndex, 16] := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              resultedFilesList[imgIndex, 17] := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              resultedFilesList[imgIndex, 22] := mainLoadedIMGdetails.dpi
           }
        } Else obju := r := 0

        ; If (returnObj!=1)
        ; {
           fileInfos := GetFileAttributesEx(imgPath)
           If (isFilter && returnObj!=1)
           {
              bckpResultedFilesList[imgIndex, 6] := fileInfos.size
              bckpResultedFilesList[imgIndex, 7] := fileInfos.wTime
              bckpResultedFilesList[imgIndex, 8] := fileInfos.cTime
           } Else If (returnObj!=1)
           {
              resultedFilesList[imgIndex, 6] := fileInfos.size
              resultedFilesList[imgIndex, 7] := fileInfos.wTime
              resultedFilesList[imgIndex, 8] := fileInfos.cTime
           }
        ; }
        ; thumbBMP := LoadBitmapFromFileu(imgPath, 1)
     } Else If StrLen(thumbBMP)>2
     {
        fileInfos := ""
        Gdip_GetImageDimensions(thumbBMP, imgW, imgH)
        Gdip_BitmapGetDPIResolution(thumbBMP, dpix, dpiy)
        If (returnObj=1)
        {
           obju := []
           obju.pixFmt := Gdip_GetImagePixelFormat(thumbBMP, 2)
           obju.dpi := Round((dpix + dpiy)/2)
           Gdip_GetImageDimensions(thumbBMP, imgW, imgH)
           obju.frames := Gdip_GetBitmapFramesCount(thumbBMP) - 1
           obju.w := imgW
           obju.h := imgH
           obju.mgpx := Round((imgW * imgH)/1000000, 2)
           obju.ratio := Round(imgW/imgH, 2)
        } Else If isFilter
        {
           bckpResultedFilesList[imgIndex, 9] := Gdip_GetBitmapFramesCount(thumbBMP)
           bckpResultedFilesList[imgIndex, 13] := imgW
           bckpResultedFilesList[imgIndex, 14] := imgH
           bckpResultedFilesList[imgIndex, 15] := Gdip_GetImagePixelFormat(thumbBMP, 2)
           bckpResultedFilesList[imgIndex, 16] := Round(imgW/imgH, 2)
           bckpResultedFilesList[imgIndex, 17] := Round((imgW * imgH)/1000000, 2)
           bckpResultedFilesList[imgIndex, 22] := Round((dpix + dpiy)/2)
        } Else
        {
           resultedFilesList[imgIndex, 9] := Gdip_GetBitmapFramesCount(thumbBMP)
           resultedFilesList[imgIndex, 13] := imgW
           resultedFilesList[imgIndex, 14] := imgH
           resultedFilesList[imgIndex, 15] := Gdip_GetImagePixelFormat(thumbBMP, 2)
           resultedFilesList[imgIndex, 16] := Round(imgW/imgH, 2)
           resultedFilesList[imgIndex, 17] := Round((imgW * imgH)/1000000, 2)
           resultedFilesList[imgIndex, 22] := Round((dpix + dpiy)/2)
        } 

        r := wasGiven := 1
     }

     If !wasGiven
        trGdip_DisposeImage(thumbBMP, 1)

     If (returnObj=1)
        Return [obju, fileInfos]

     Return r
}

QPV_listThumbnailsGridMode() {
    setImageLoading()
    trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xFF" WindowBgrColor)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    zBru := Gdip_BrushCreateSolid("0x66994433")
    rowIndex := 0
    columnIndex := -1
    prevMSGdisplay := A_TickCount
    If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    If (SLDtypeLoaded=3 && thumbsListViewMode=3)
       activeSQLdb.Exec("BEGIN TRANSACTION;")

    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := resultedFilesList[thisFileIndex, 1]
        imgPath := StrReplace(imgPath, "||")

        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        ; Gdip_FillRectangle(2NDglPG, pBrushWinBGR, DestPosX, DestPosY, thumbsW, thumbsH)
        If (StrLen(imgPath)>2 && thumbsListViewMode<=1)
        {
           zPlitPath(imgPath, 1, fileNamu, folderu)
           entireString := fileNamu "`n" folderu "\"
           If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(2NDglPG, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=2)
        {
           zPlitPath(imgPath, 1, fileNamu, folderu)
           ofileSizu := Round(QPV_FileGetSizeTime(imgPath, "S", thisFileIndex) / 1024) ; kilobytes
           fileSizu := (ofileSizu>1023) ? Round(ofileSizu/1024, 1) " MB" : ofileSizu " KB"
           FileDateM := QPV_FileGetSizeTime(imgPath, "M", thisFileIndex)
           FileDateC := QPV_FileGetSizeTime(imgPath, "C", thisFileIndex)
           Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
           Try FormatTime, FileDateC, % FileDateC, dd/MM/yyyy, HH:mm
           fileMsg := FileExist(imgPath) ? FileDateC " | " FileDateM " | " fileSizu : "Error gathering data..."
           entireString := mgpx fileNamu "`n" folderu "\`n" fileMsg
           If (ofileSizu<2 && !InStr(fileMsg, "error"))
           {
              Gdip_FillRectangle(2NDglPG, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           } Else If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(2NDglPG, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=3)
        {
           zPlitPath(imgPath, 1, fileNamu, folderu)
           If FileExist(imgPath)
           {
              If !resultedFilesList[thisFileIndex, 9]
              {
                 If !retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12], 1)
                    GetCachableImgFileDetails(imgPath, thisFileIndex)

                 If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
                    updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
              }

              Width := resultedFilesList[thisFileIndex, 13]
              Height := resultedFilesList[thisFileIndex, 14]
              CountFrames := (resultedFilesList[thisFileIndex, 9]>1) ? " | " resultedFilesList[thisFileIndex, 9] " frames" : ""
              mgpx := resultedFilesList[thisFileIndex, 17] " MPx | "
              ofileSizu := Round(QPV_FileGetSizeTime(imgPath, "S", thisFileIndex) / 1024) ; kilobytes
              fileSizu := (ofileSizu>1023) ? Round(ofileSizu/1024, 1) " MB" : ofileSizu " KB"
              fileMsg := groupDigits(Width) " x " groupDigits(Height) " | " resultedFilesList[thisFileIndex, 9] CountFrames " | " fileSizu
           } Else fileMsg := "Error gathering data..."

           entireString := mgpx fileNamu "`n" folderu "\`n" fileMsg
           If ((Width<2 || Height<2 || ofileSizu<2) && !InStr(fileMsg, "error"))
           {
              Gdip_FillRectangle(2NDglPG, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           } Else If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(2NDglPG, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        }

        If StrLen(entireString)>2
        {
           infoBoxBMP2 := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.25, thumbsW, thumbsH, OSDtextColor, WindowBGRcolor, 1, 0)
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP2, DestPosX, DestPosY)
           infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
           entireString := ""
        }

        If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1)
        {
           If retrieveSeenImageDBentry(imgPath, thisFileIndex)
              Gdip_DrawRectangle(2NDglPG, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (A_TickCount - prevMSGdisplay > 450)
        {
           prevMSGdisplay := A_TickCount
           r2 := LrydWinUpdt(hGDIthumbsWin, 2NDglHDC)
        } Else If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }
    }

    If (SLDtypeLoaded=3 && thumbsListViewMode=3)
       activeSQLdb.Exec("COMMIT TRANSACTION;")

    Gdip_DeleteBrush(zBru)
    r2 := LrydWinUpdt(hGDIthumbsWin, 2NDglHDC)
    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    prevFullThumbsUpdate := A_TickCount
    SetTimer, ResetImgLoadStatus, -15
    prevFullThumbsUpdate := A_TickCount
}

mainGdipWinThumbsGrid(mustDestroyBrushes:=0, mustShowNames:=0) {
    Critical, on
    Static pBrush1, pBrush2, pBrush3, pBrush4, pBrush5
         , brushesCreated, prevIndexu

    If (mustDestroyBrushes=1 && brushesCreated=1)
    {
       Gdip_DeleteBrush(pBrush1)
       Gdip_DeleteBrush(pBrush2)
       Gdip_DeleteBrush(pBrush3)
       Gdip_DeleteBrush(pBrush4)
       Gdip_DeleteBrush(pBrush5)
       brushesCreated := 0
       Return
    } Else If (mustDestroyBrushes=1)
       Return

    If (brushesCreated!=1)
    {
       pBrush1 := Gdip_BrushCreateSolid("0x88999999")
       pBrush2 := Gdip_BrushCreateSolid("0x55999999")
       pBrush3 := Gdip_BrushCreateSolid("0x400188FF")
       pBrush4 := Gdip_BrushCreateSolid("0x55404040")
       pBrush5 := Gdip_BrushCreateSolid("0x66334433")
       brushesCreated := 1
    }

    If StrLen(hitTestSelectionPath)>1
    {
       Gdip_DeletePath(hitTestSelectionPath)
       hitTestSelectionPath := ""
    }

    selectorWidth := imgHUDbaseUnit//6
    If (selectorWidth>min(thumbsW, thumbsH)*0.3)
       selectorWidth := Round(min(thumbsW, thumbsH)*0.3)

    Gdip_SetPenWidth(pPen6, selectorWidth)
    Gdip_SetPenWidth(pPen1d, selectorWidth//2)
    Gdip_SetPenWidth(pPen5, selectorWidth//2)
    ; hitTestSelectionPath := Gdip_CreatePath()
    trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    rowIndex := 0
    columnIndex := -1
    If (startIndex=prevIndexu)
       prevIndexu := ""

    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := resultedFilesList[thisFileIndex, 1]
        imgPathSelected := resultedFilesList[thisFileIndex, 2]
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        If (mustShowNames=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
           If StrLen(imgPath)<4
              Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (mustShowNames=1 && thisFileIndex=startIndex && StrLen(imgPath)>5)
        {
           mustDrawBoxNow := 1
        } Else If (mustShowNames=2 && StrLen(imgPath)>5)
        {
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX + 1, DestPosY + 1, thumbsW - 2, thumbsH - 2)
        } Else If (StrLen(imgPath)>5 && !mustShowNames && thumbnailsListMode!=1)
        {
           If !FileRexists(imgPath)
           {
              infoBoxBMP2 := drawTextInBox("! " thisFileIndex, OSDFontName, OSDfntSize//1.5, thumbsW, thumbsH, OSDtextColor, OSDbgrColor, 0, 0)
              trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP2, DestPosX, DestPosY)
              infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
           }
        }

        If (!mustShowNames && StrLen(ImgPath)>5)
        {
           If !FileRexists(imgPath)
              Gdip_FillRectangle(2NDglPG, pBrush4, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (resultedFilesList[thisFileIndex, 3]=1)
           Gdip_DrawRectangle(2NDglPG, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)
        If (resultedFilesList[thisFileIndex, 5]=1)
           Gdip_DrawRectangle(2NDglPG, pPen1d, DestPosX, DestPosY, thumbsW, thumbsH)

        If (thisFileIndex=currentFileIndex)
        {
           ; Gdip_FillRectangle(2NDglPG, pBrush1, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_DrawRectangle(2NDglPG, pPen6, DestPosX, DestPosY, thumbsW, thumbsH)
           If (noTooltipMSGs=0 || mustShowNames=1)
           {
              ; Gdip_AddPathRectangle(hitTestSelectionPath, DestPosX, DestPosY, thumbsW, thumbsH)
              zPlitPath(imgPath, mustDrawBoxNow, fileNamu, folderu)
              If FileExist(imgPath)
              {
                 QPV_FileGetSizeTime(imgPath, "R", thisFileIndex)
                 fileSizu := Round(resultedFilesList[thisFileIndex, 6]/1024)
                 fileSizu := (fileSizu>1023) ? Round(fileSizu/1024, 1) " MB" : fileSizu " KB"
                 FileDateM := resultedFilesList[thisFileIndex, 7]
                 Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
                 fileMsg := fileSizu " | " FileDateM
              } Else fileMsg := "File not found or access denied"

              delim := (multilineStatusBar=1 || mustShowNames=1) ? "`n" : " | "
              theMsg := groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) " | " fileNamu " | " fileMsg delim folderu "\"
           }
        }

        If (imgPathSelected=1)
        {
           countSel++
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_FillRectangle(2NDglPG, pBrush3, DestPosX, DestPosY, thumbsW, thumbsH)
        }
        If (thisFileIndex=EntryMarkedMoveIndex)
           Gdip_FillRectangle(2NDglPG, pBrushC, DestPosX, DestPosY, thumbsW, thumbsH)
    }

    If (countSel>markedSelectFile && countSel>1 && markedSelectFile>1)
       SetTimer, dummyRecountSelectedFiles, -100

    If (mustDrawBoxNow=1 || mustShowNames=1)
    {
       knobSize := imgHUDbaseUnit//3.5
       Gdip_FillRectangle(2NDglPG, pBrushE, 0, 0, mainWidth, knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, Round(mainWidth*(currentFileIndex/maxFilesIndex)), knobSize//2)
    }

    If StrLen(filesFilter)>1
       theMsg := "[F] " theMsg

    prevIndexu := startIndex
    If markedSelectFile
    {
       Gdip_FillRectangle(2NDglPG, pBrush1, 0, 0, mainWidth, imgHUDbaseUnit//5)
       theMsg := markedSelectFile " selected | " theMsg
    }

    scrollYpos := startIndex/maxFilesIndex
    scrollYpos := Round(mainHeight*scrollYpos)
    thisFileIndex := currentFileIndex
    If (thisFileIndex>maxFilesIndex - maxItemsPage)
       thisFileIndex := maxFilesIndex - maxItemsPage

    scrollHeight := (maxItemsPage/maxFilesIndex)*100
    scrollHeight := Ceil((mainHeight/100)*scrollHeight)
    If (scrollHeight<imgHUDbaseUnit//4.5)
       scrollHeight := imgHUDbaseUnit//4.5

    scrollYpos := clampInRange(scrollYpos, 1, mainHeight - imgHUDbaseUnit//4.5)
    If ((mustShowNames=1 || noTooltipMSGs=0) && StrLen(theMsg)>1)
    {
       bgrTXT := (resultedFilesList[currentFileIndex, 2]=1) ? 103388 : OSDbgrColor
       If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
       {
          theMSG := "DUPE ID: " resultedFilesList[currentFileIndex, 23] " | " theMSG
          mpxu := " | " Round(resultedFilesList[currentFileIndex, 17], 2) " MPx"
          theMSG := StrReplace(theMSG, " MB |", " MB" mpxu " |")
          theMSG := StrReplace(theMSG, " KB |", " KB" mpxu " |")
       }

       infoBoxBMP := drawTextInBox(theMsg, OSDFontName, Round(OSDfntSize*0.9), mainWidth, mainHeight//3, OSDtextColor, bgrTXT, 1)
       Gdip_GetImageDimensions(infoBoxBMP, ThumbsStatusBarW, ThumbsStatusBarH)
       ThumbsStatusBarW := clampInRange(ThumbsStatusBarW, 1, mainWidth - imgHUDbaseUnit//3.3)
       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, -1, mainHeight - ThumbsStatusBarH)
       theMSG2 := theMSG
       If (markSearchMatches=1 && userSearchString && modus!="all")
       {
          If coreSearchIndex(getIDimage(currentFileIndex), thisSearchString, userSearchWhat)
          {
             Gdip_FillRectangle(2NDglPG, pBrushD, -1, mainHeight - ThumbsStatusBarH, OSDfntSize//2.5+1, ThumbsStatusBarH)
             theMSG2 .=  " | Matched search: " thisSearchString 
          }
       }

       If (resultedFilesList[currentFileIndex, 3]=1)
       {
          Gdip_DrawRectangle(2NDglPG, pPen5, -1, mainHeight - ThumbsStatusBarH, ThumbsStatusBarW, ThumbsStatusBarH)
          theMSG2 .=  " | Image already seen"
       }

       If (resultedFilesList[currentFileIndex, 5]=1)
       {
          Gdip_DrawRectangle(2NDglPG, pPen1d, -1, mainHeight - ThumbsStatusBarH, ThumbsStatusBarW, ThumbsStatusBarH)
          theMSG2 .=  " | Added to favourites"
       }

       If (bgrTXT!=OSDbgrColor)
          theMSG2 .=  " | File selected"

       If StrLen(filesFilter)>1
          theMSG2 .=  " | Files list filtered"

       interfaceThread.ahkPostFunction("UpdateUiStatusBar", theMSG2, ThumbsStatusBarH, 0, maxItemsPage)
       trGdip_DisposeImage(infoBoxBMP, 1)

       If (showInfoBoxHUD>0 && mustShowNames!=1)
          drawinfoBox(mainWidth, mainHeight)

       If (showHUDnavIMG=1 && thumbnailsListMode=1 && mustShowNames!=1)
          VPnavBoxWrapper(mainWidth, mainHeight - ThumbsStatusBarH)
    }

    lineThickns := imgHUDbaseUnit//3.25
    If (scrollHeight<mainHeight)
    {
       Gdip_FillRectangle(2NDglPG, pBrushE, mainWidth - lineThickns, 0, lineThickns, mainHeight)
       ; Gdip_AddPathRectangle(hitTestSelectionPath, mainWidth - lineThickns, 0, lineThickns, mainHeight)
       Gdip_FillRectangle(2NDglPG, pBrushD, mainWidth - lineThickns + 5, scrollYpos, lineThickns, scrollHeight)
    }

    SetTimer, ResetImgLoadStatus, -25
    r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    If (toolTipGuiCreated=2)
    {
       clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
       toolTipGuiCreated := 0
    }
}

dummyRecountSelectedFiles() {
   getSelectedFiles(0, 1)
}

EraseThumbsCache(dummy:=0, remCacheOldDays:=0) {
   startZeit := A_TickCount
   showTOOLtip("Emptying thumbnails cache, please wait")
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   countTFilez := countFilez := 0
   Loop, Files, %thumbsCacheFolder%\*.*
   {
      If !(A_LoopFileExt="tiff" || A_LoopFileExt="png" || A_LoopFileExt="jpg")
         Continue

      changeMcursor()
      timeNow := %A_Now%
      EnvSub, timeNow, %A_LoopFileTimeCreated%, Days
      mustRem := (timeNow>remCacheOldDays && dummy="daysITis") ? 1 : 0
      countTFilez++
      If (mustRem=1 || dummy!="daysITis")
      {
         FileDelete, % A_LoopFileFullPath
         If !ErrorLevel
            countFilez++
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         showTOOLtip("Emptying thumbnails cache, please wait`n" countFilez " removed until now.")
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   If (dummy="daysITis")
   {
      moreInfo := " out of " countTFilez
      friendly := " older than " remCacheOldDays " days"
   }


   If (abandonAll=1)
      showTOOLtip("Operation aborted. Removed " countFilez " cached thumbnails until now")
   Else If (A_TickCount - startZeit>1500) || (dummy="daysITis")
      showTOOLtip("Finished removing " countFilez moreInfo " cached thumbnails" friendly)
   
   remCacheOldDays := 0
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createThumbsFolder() {
    If !FolderExist(thumbsCacheFolder)
    {
       FileCreateDir, %thumbsCacheFolder%
       If ErrorLevel
          Return "error"
    }
}

generateImgThumbCache(imgPath, newImgSize) {
    Critical, on
    r := createThumbsFolder()
    If (r="error")
       Return r

    MD5name := generateThumbName(imgPath)
    file2save := thumbsCacheFolder "\" MD5name ".jpg"
    thisImgFile := FileExist(file2save) ? file2save : imgPath
    whichLIB := (thisImgFile=file2save) ? 1 : 0
    changeMcursor()
    oBitmap := LoadBitmapFromFileu(thisImgFile, 0, whichLIB)
    If !oBitmap
       Return "error"

    Gdip_GetImageDimensions(oBitmap, imgW, imgH)
    calcIMGdimensions(imgW, imgH, newImgSize, newImgSize, ResizedW, ResizedH)
    If (isInRange(imgW, ResizedW - 15, ResizedW + 15) && isInRange(imgH, ResizedH - 15, ResizedH + 15))
    {
       cacheUsed := 1
       ResizedW -= 50
       ResizedH -= 50
    }
    changeMcursor()
    thisImgQuality := (userimgQuality=1) ? 3 : 5
    thumbBMP := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, ResizedW, ResizedH, 0, thisImgQuality, -1)
    trGdip_DisposeImage(oBitmap, 1)
    If (cacheUsed=1)
       Sleep, 1

    changeMcursor()
    r := Gdip_SaveBitmapToFile(thumbBMP, file2save)
    trGdip_DisposeImage(thumbBMP, 1)
}

setPriorityThread(level, handle:="A") {
  If (handle="A" || !handle)
     handle := DllCall("GetCurrentThread")
  Return DllCall("SetThreadPriority", "UPtr", handle, "Int", level)
}

ObjToString(obj) {
  if (!IsObject(obj))
    return obj
  str := "`n{"
  for key, value in obj
    str .= "`n" key ": " ObjToString(value) ","
  return str "`n}"
}

CustomObjToString(obj) {
  if (!IsObject(obj))
    return obj
;  str := "|&|"
  for key, value in obj
    str .= "?" key "|" CustomaObjToString(value)
  return str ; "|&|"
}

CustomaObjToString(obj) {
  if (!IsObject(obj))
    return obj
 ; str := "/&/"
  for key, value in obj
    str .= "<" ObjToString(value) "@"
  return str ; "/&/"
}

StrToObject(stringu) {
  newArrayu := []
  Loop, Parse, stringu, ?
  {
      If !A_LoopField
         Continue
      lineArrayu := StrSplit(A_LoopField, "|<")
      thisIndex := lineArrayu[1]
      preparedOther := StrReplace(lineArrayu[2], "@")
      otherLineArrayu := StrSplit(preparedOther, "<")
      ; MsgBox, % A_LoopField "`n" thisIndex "`n" preparedOther "`n" otherLineArrayu[1] "`n" lineArrayu[2] "`n" A_Index
      Loop, % otherLineArrayu.Count()
          newArrayu[thisIndex, A_Index] := otherLineArrayu[A_Index]
  }
  ; MsgBox, % CustomObjToString(newArrayu)
  Sleep, 50
  Return newArrayu
}

generateAllThumbsNow() {
   Static chunkSize := 1500
   If (thumbsDisplaying!=1 || maxFilesIndex<3 || !CurrentSLD)
      Return

   currentFileIndex := 1
   thumbsListViewMode := thumbnailsListMode := 0
   ; If (thumbnailsListMode!=1)
   ;    initAHKhThumbThreads()

   INIaction(1, "thumbnailsListMode", "General")
   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   loopTimes := Ceil(maxFilesIndex/chunkSize)
   startZeit := A_TickCount
   Loop, % loopTimes
   {
      currentFileIndex := (A_Index - 1) * chunkSize
      If !currentFileIndex
         currentFileIndex := 1

      r := QPV_ShowThumbnails("all", A_Index * chunkSize, startZeit)
      If r
         Break
   }
 
   currentFileIndex := 1
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(90)
   SoundBeep , 900, 100
   SetTimer, ResetImgLoadStatus, -25
   RemoveTooltip()
}

QPV_ShowThumbnails(modus:=0, allStarter:=0, allStartZeit:=0) {
    Critical, on

    prevFullThumbsUpdate := A_TickCount
    mainStartZeit := A_TickCount
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    If (modus="all")
    {
       maxItemsW := maxItemsH := allStarter//2 + 1
       maxItemsPage := allStarter + 1
       ; MsgBox, % maxItemsPage
    }

    If (thumbnailsListMode=1)
    {
       QPV_listThumbnailsGridMode()
       Return
    }

    setImageLoading()
    If (minimizeMemUsage!=1)
    {
       thumbsBitmap := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, "0xE200B")
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbsBitmap, 5, 1)
       If !G2
       {
          trGdip_DisposeImage(thumbsBitmap, 1)
          thumbsBitmap := ""
          G2 := glPG
       }
    } Else G2 := glPG

    hasUpdated := rowIndex := imgsListed := 0
    maxImgSize := maxZeit := columnIndex := -1
    fnOutputDebug("Begin show " maxItemsPage " thumbs from index " startIndex)
    setPriorityThread(-2)
    DestroyGIFuWin()
    createThumbsFolder()
    trGdip_GraphicsClear(A_ThisFunc, glPG, "0xFF" WindowBgrColor)
    If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, mainWidth + 5, mainHeight + 5)
    prevGUIupdate := A_TickCount
    thisImgQuality := (userimgQuality=1) ? 7 : 5
    imgsListArrayThumbs := []
    lastMsg := imgsMustPaint := imgsNotCached := 0
    doStartLongOpDance()
    Loop, % maxItemsW*maxItemsH*2
    {
        If (modus="all" && maxFilesIndex>100)
        {
           If (determineTerminateOperation()=1)
           {
              fnOutputDebug("ThumbsMode. User abandoned the operation during preparations phase of generate all thumbs.")
              abandonAll := 1
              hasUpdated := 0
              Break
           }
        }

        thisFileIndex := startIndex + A_Index - 1
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH || thisFileIndex>maxFilesIndex) || (modus="all" && thisFileIndex>allStarter)
        {
           ; If (thisFileIndex>maxFilesIndex)
           ;    SoundBeep , 300, 100
           Break
        }

        If (modus="all") && (A_TickCount - lastMsg > 450)
        {
           lastMsg := A_TickCount
           showTOOLtip("Preparing to generate all thumbnails: " thisFileIndex "/" maxFilesIndex, 0, 0, thisFileIndex / maxFilesIndex)
        }

        imgPath := StrReplace(getIDimage(thisFileIndex), "||")
        thisFileDead := (StrLen(imgPath)<5 || !FileRexists(imgPath)) ? 1 : 0
        DestPosX := thumbsW//2 + thumbsW*columnIndex
        DestPosY := thumbsH//2 + thumbsH*rowIndex
        memCached := wasThumbCached := 0
        MD5name := generateThumbName(imgPath, 1, 1)
        isForceRefresh := resultedFilesList[thisFileIndex, 4]
        If (thisFileDead=1)
        {
           imgsListArrayThumbs[thisFileIndex] := ["x", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else If StrLen(imgThumbsCacheIDsArray[MD5name])>0
        {
           memCached := 1
           imgsListArrayThumbs[thisFileIndex] := ["m", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else
        {
           wasThumbCached := (isForceRefresh=1) ? 0 : checkThumbExists(MD5name, imgPath, file2load)
           fnOutputDebug("Thumb = " thisFileIndex  " cached=" wasThumbCached " original file: " imgPath " thumb file: " file2load)
           If (wasThumbCached=1)
              imgsListArrayThumbs[thisFileIndex] := ["f", 0, imgPath, file2load, DestPosX, DestPosY, MD5name]
        }

        If (currentFileIndex=thisFileIndex)
        {
           sizeSquare := 36 + zoomLevel*15
           Gdip_FillRectangle(glPG, pBrushA, DestPosX - sizeSquare//2, DestPosY - sizeSquare//2, sizeSquare, sizeSquare)
        }

        imgsMustPaint++
        If (memCached=1 || wasThumbCached=1 || thisFileDead=1) && (isForceRefresh!=1)
           Continue

        imgsNotCached++
        ; Gdip_FillRectangle(glPG, pBrushE, DestPosX - 10, DestPosY - 10, 20, 20)
        file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
        If (isForceRefresh=1)
        {
           FileDelete, % file2save
           resultedFilesList[thisFileIndex, 4] := 0
        }

        thisW := imgPath ? "w" : "x"
        imgsListArrayThumbs[thisFileIndex] := [thisW, 0, imgPath, file2save, DestPosX, DestPosY, MD5name]
        ;    fnoutputdebug("thumbs prepare " imgPath "|" thisFileIndex "|" MD5name)
    }

   limitCores := realSystemCores + 1
   filesPerCore := imgsNotCached//limitCores
   If (filesPerCore<2 && limitCores>1)
   {
      systemCores := imgsNotCached//2
      filesPerCore := imgsNotCached//systemCores
   } Else systemCores := limitCores

   maxLimitReached := (minimizeMemUsage=1) && (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
   mustDoMultiCore := (allowMultiCoreMode=1 && maxLimitReached!=1 && systemCores>1 && filesPerCore>1 && multiCoreThumbsInitGood=1) ? 1 : 0
   fnOutputDebug("ThumbsMode. Init. doMultiCore:" mustDoMultiCore ", cores:" systemCores ", filesPerCore:" filesPerCore ", imgsNotCached:" imgsNotCached ", imgsMustPaint:" imgsMustPaint)
   mamUsage := GetProcessMemoryUsage(QPVpid)
   systemMemInfo := GlobalMemoryStatusEx()
   thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/Round(systemMemInfo.TotalPhys*0.9))*100, 1)
   fnOutputDebug("ThumbsMode. Memory usage: " thisMemoryLoad "%")
   If (thisMemoryLoad>70 || isWinXP=1)
   {
      fnOutputDebug("ThumbsMode. Memory usage above 70%. Multi-threaded thumbnails generation deactivated.")
      mustDoMultiCore := 0
   }

   ; how much time in miliseconds can an image take to load and not be cached
   timePerImg := 1550//imgsNotCached
   If (timePerImg<25 || modus="all")
      timePerImg := 25
   Else If (timePerImg>300)
      timePerImg := 300

   timePerImgMultiCore := (modus="all") ? 25 : timePerImg*2 + limitCores*2
   If (timePerImgMultiCore>350)
      timePerImgMultiCore := 350

   If (mustDoMultiCore=1)
   {
      fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. Cores: " limitCores)
      Loop, % limitCores
          thumbThread%A_Index%.ahkPostFunction("cleanMess", "c" A_Index)
      ; fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. DONE")
   } Else limitCores := 1

   thisFileIndex := MD5name := Bindex := hasUpdated := rowIndex := imgsListed := lastMsg := 0
   imgsHavePainted := thisNonCachedImg := coreIndex := threadIndex := memCached := lapsOccured := totalLoops := 0
   lowestGiven := maxIndexu := maxImgSize := maxZeit := columnIndex := -1
   prevCoreEventZeit := A_TickCount - 2
    ; MsgBox, % filesPerCore "--" imgsMustPaint "--" imgsNotCached "--" imgsListArrayThumbs.Length()
   interfaceThread.ahkassign("alterFilesIndex", 0)
   If (abandonAll!=1)
   {
      Loop
      {
          alterFilesIndex := interfaceThread.ahkgetvar.alterFilesIndex
          If (alterFilesIndex>1 && lapsOccured>3)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation by scrolling.")
             userScrolled := 1
             Break
          }

          totalLoops++
          If (determineTerminateOperation()=1)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation.")
             abandonAll := 1
             hasUpdated := 0
             Break
          }

          ; Sleep, 0
          Bindex++
          If (Bindex>imgsMustPaint)
          {
             lapsOccured++
             Bindex := 1
          }

          thisFileIndex := startIndex + Bindex - 1
          If (mustEndLoop=1)
          {
             fnOutputDebug("ThumbsMode. Must end loop = 1. laps " lapsOccured "  -- loops " totalLoops "  -- inner " innerLoops " ")
             hasUpdated := 0
             Break
          }

          If (imgsHavePainted>=imgsMustPaint)
             mustEndLoop := 1

          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          If (cacheType="d")
             Continue

          If (cacheType="x")
          {
             fnOutputDebug("ThumbsMode. Failed to generate. " thisFileIndex " .")
             imgsListArrayThumbs[thisFileIndex, 1] := "d"
             thumbsFailures++
             imgsHavePainted++
             Continue
          }

          If (modus="all") && (A_TickCount - lastMsg > 750)
          {
             allStuffPerc := (startIndex + imgsHavePainted) / maxFilesIndex
             etaTime := ETAinfos(startIndex + imgsHavePainted, maxFilesIndex, allStartZeit)
             If (mustDoMultiCore=1)
                etaTime .= "`nUsing multi-threaded processing"

             showTOOLtip("Generating all thumbnails at " thumbsSizeQuality "px: " etaTime, 0, 0, allStuffPerc)
             lastMsg := A_TickCount
          }

          innerLoops++
          If (cacheType="w" && mustDoMultiCore=1)
          {
             ; Sleep, -1
             thisCoreDoneLine := ""
             thisCoreDoneArr := ""
             whichCoreBusy := imgsListArrayThumbs[thisFileIndex, 2]
             mamUsage := GetProcessMemoryUsage(QPVpid)
             systemMemInfo := GlobalMemoryStatusEx()
             thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/Round(systemMemInfo.TotalPhys*0.9))*100, 1)
             If (A_TickCount - prevCoreEventZeit>69500 && innerLoops>2 && lapsOccured>2 && totalLoops>2)
             {
                fnOutputDebug("ThumbsMode. Wait time since last new core started ... exceeded.  " thisFileIndex " . Loop. Break. Now. :-) ")
                Break
             }

             If (whichCoreBusy>0)
             {
                hasThumbFailed := thumbThread%whichCoreBusy%.AHKgetvar.operationFailed
                thisCoreDoneLine := thumbThread%whichCoreBusy%.AHKgetvar.resultsList
                thisCoreDoneArr := StrSplit(thisCoreDoneLine, "|")
                waitDataCollect := thumbThread%whichCoreBusy%.AHKgetvar.waitDataCollect
                If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && thisCoreDoneArr[5]=Bindex && waitDataCollect=1)
                {
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "fim"
                   imgsListArrayThumbs[thisCoreDoneArr[3], 2] := thisPBitmap
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      fnOutputDebug("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "x"
                   }
                } Else If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && waitDataCollect=1)
                {
                   ; SoundBeep 
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisFileIndex := thisCoreDoneArr[3]
                   Bindex := thisCoreDoneArr[5]
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   imgsListArrayThumbs[thisFileIndex, 1] := "fim"
                   imgsListArrayThumbs[thisFileIndex, 2] := thisPBitmap
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      fnOutputDebug("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisFileIndex, 1] := "x"
                   }
                } Else Continue
             } Else
             {
                coreIndex++
                If (coreIndex>limitCores)
                   coreIndex := 1

                thisCoreDone := thumbThread%coreIndex%.AHKgetvar.operationDone
                waitDataCollect := thumbThread%coreIndex%.AHKgetvar.waitDataCollect
                hasThumbFailed := thumbThread%coreIndex%.AHKgetvar.operationFailed
                If (thisMemoryLoad<90 && thisCoreDone=1 && waitDataCollect<1 && hasThumbFailed=0)
                {
                   prevCoreEventZeit := A_TickCount
                   thumbThread%coreIndex%.ahkassign("operationDone", 0)
                   thumbThread%coreIndex%.ahkassign("waitDataCollect", 0)
                   thisPath := imgsListArrayThumbs[thisFileIndex, 3]
                   thisSavePath := imgsListArrayThumbs[thisFileIndex, 4]
                   thumbThread%coreIndex%.ahkPostFunction("MonoGenerateThumb", thisPath, thisSavePath, enableThumbsCaching, thumbsSizeQuality, timePerImgMultiCore, coreIndex, thisFileIndex, Bindex)
                   imgsListArrayThumbs[thisFileIndex, 2] := coreIndex
                   fnOutputDebug("ThumbsMode. Work assigned to thread. IMG #" thisFileIndex ". Core " coreindex " ")
                   Sleep, 1
                }
                Continue
             }
          }

          ; Sleep, 1
          changeMcursor()
          startZeit := A_TickCount
          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          fnOutputDebug("thumbs inner " thisCoreDoneLine " -- cT" cacheType " --cB" whichCoreBusy  " -- " reallyThreadsDone " -- loops infos " A_Index " -- " innerLoops " -- " lapsOccured " -- " totalLoops " -- " imgsHavePainted " -- " imgsMustPaint)
          fimCached := mustDisposeImgNow := 0
          wasCacheFile := thumbCachable := WasMemCached := hasNowMemCached := 0
          If (cacheType="w")
          {
             If (mustDoMultiCore=1)
                Continue

             ; mustDisposeImgNow := 1
             thumbCachable := 1
             imgsListArrayThumbs[thisFileIndex, 1] := "f"
             file2load := imgsListArrayThumbs[thisFileIndex, 3]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 1, 0, 0, 800, 800, 1)
             GetCachableImgFileDetails(file2load, thisFileIndex, oBitmap, 0, 0)
          } Else If (cacheType="m")
          {
             WasMemCached := 1
             MD5name := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := imgThumbsCacheArray[imgThumbsCacheIDsArray[MD5name], 1]
          } Else If (cacheType="f")
          {
             wasCacheFile := 1
             file2load := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 1, 0, 0, 800, 800, 1)
          } Else If (cacheType="fim")
          {
             fimCached := 1
             oBitmap := imgsListArrayThumbs[thisFileIndex, 2]
             If !oBitmap
             {
                ; mustDisposeImgNow := 1
                cacheType := "f"
                wasCacheFile := 1
                fimCached := 0
                file2load := imgsListArrayThumbs[thisFileIndex, 4]
                fnOutputDebug("missing thumb cached with a FIM thread " thisFileIndex ". Trying to load file... " file2load)

                If !FileRexists(file2load)
                {
                   wasCacheFile := fimCached := 0
                   thumbCachable := 1
                   file2load := imgsListArrayThumbs[thisFileIndex, 3]
                }
                oBitmap := LoadBitmapFromFileu(file2load, 0, 1, 0, 0, 800, 800, 1)
             }
          }

          extendedLoops++
          imgsListArrayThumbs[thisFileIndex, 1] := "d"
          imgPath := imgsListArrayThumbs[thisFileIndex, 3]
          MD5name := imgsListArrayThumbs[thisFileIndex, 7]
          file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
          Gdip_GetImageDimensions(oBitmap, imgW, imgH)

          If (!oBitmap || !FileExist(imgPath) || !imgW || !imgH)
          {
             If (WasMemCached=1)
             {
                wasThumbCached := checkThumbExists(MD5name, imgPath, file2load)
                imgsListArrayThumbs[thisFileIndex, 1] := FileExist(file2load) ? "fim" : "w"
                imgsListArrayThumbs[thisFileIndex, 2] := 0
                imgsListArrayThumbs[thisFileIndex, 4] := file2load
             } Else imgsHavePainted++

             fnOutputDebug("broken thumb: mem" WasMemCached " -- w" imgW "-- h" imgH "-- obj bmp id" oBitmap)
             Continue
          } Else imgsHavePainted++

          If (thumbCachable=1)
          {
             fnOutputDebug("must resize GDI object thumbCachable=1. " oBitmap)
             zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, thumbsW, thumbsH, 1, thisImgQuality, -1)
             If zBitmap
             {
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. " oBitmap)
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. DONE")
                oBitmap := zBitmap
             }
          } Else If (WasMemCached!=1 && modus!="all")
          {
             fnOutputDebug("must clone GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
             zBitmap := cloneGDItoMem(A_ThisFunc, oBitmap, imgW, imgH)
             If (fimCached!=1)
             {
                fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. DONE")
             }
             If zBitmap
                oBitmap := zBitmap
          }

          thisZeit := A_TickCount - startZeit
          fnOutputDebug("MEM cached thumbs infos: " memCached " -- " hasMemThumbsCached " -- " imgThumbsCacheIDsArray[MD5name] " = " file2save)
          Gdip_GetImageDimensions(oBitmap, newW, newH)
          If (!newW || !newH)
          {
             fnOutputDebug("ThumbsMode. Faulty GDI thumbnail. File Index: " thisFileIndex ". GDI bmp: " oBitmap ".")
             oBitmap := trGdip_DisposeImage(oBitmap, 1)
             ; fnOutputDebug("ThumbsMode. Faulty GDI thumbnail object disposed.")
             Continue
          }

          If (WasMemCached!=1 && minimizeMemUsage!=1 && modus!="all")
          {
             hasNowMemCached := 1
             hasMemThumbsCached++ 
             fnOutputDebug("ThumbsMode. Memory cached GDI thumb to be disposed: " imgThumbsCacheArray[hasMemThumbsCached, 1] )
             trGdip_DisposeImage(imgThumbsCacheArray[hasMemThumbsCached, 1], 1)
             ; fnOutputDebug("ThumbsMode. A memory cached GDI thumb to be disposed... DONE")
             imgThumbsCacheIDsArray[imgThumbsCacheArray[hasMemThumbsCached, 2]] := ""
             imgThumbsCacheArray[hasMemThumbsCached] := [oBitmap, MD5name]
             imgThumbsCacheIDsArray[MD5name] := hasMemThumbsCached
             If (hasMemThumbsCached>maxMemThumbsCache)
                hasMemThumbsCached := 0
          }

          calcIMGdimensions(newW, newH, thumbsW, thumbsH, fW, fH)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
          DestPosX -= (imageAligned!=5) ? thumbsW//2 : fW//2
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
          DestPosY -= (imageAligned!=5) ? thumbsH//2 : fH//2
          If (fimCached!=1 && thumbCachable=1 && thisZeit>timePerImg && file2save!=file2load && enableThumbsCaching=1 && WasMemCached!=1)
          && ((newW<imgW//2) || (newH<imgH//2))
          {
             fnOutputDebug("Saving thumb for: " file2load " -- " file2save) 
             zr := Gdip_SaveBitmapToFile(oBitmap, file2save, 94)
             If zr
                fnOutputDebug("ThumbsMode. failed to save thumbnail to file: " file2save)
          }

          If (WasMemCached=1 || hasNowMemCached=1)
          {
             zBitmap := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
             oBitmap := zBitmap
          }

          If (bwDithering=1 && imgFxMode=4) || (modus="all")
          {
             nullu := ""
          } Else If (usrColorDepth>1)
          {
             fnOutputDebug("ThumbsMode. Changing thumb color depth... " oBitmap)
             E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
          }

          If (modus!="all")
          {
             ; fnOutputDebug("ThumbsMode. (maybe) flipping thumb... " oBitmap)
             flipBitmapAccordingToViewPort(oBitmap)
             ; changeMcursor()
             hasUpdated := 0
             fnOutputDebug("ThumbsMode. Drawing image thumb: " oBitmap)
             r1 := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, DestPosX, DestPosY, fW - 1, fH - 1)
          }

          fnOutputDebug("ThumbsMode. Disposing GDI thumb after drawing: " oBitmap)
          oBitmap := trGdip_DisposeImage(oBitmap, 1)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
          If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1 && modus!="all")
          {
             If retrieveSeenImageDBentry(imgPath, thisFileIndex)
             {
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
             }
          }

          If (markSearchMatches=1 && userSearchString && modus!="all")
          {
             If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                Gdip_FillRectangle(G2, pBrushD, DestPosX - thumbsW//2, DestPosY - thumbsH//2, Ceil(thumbsW*0.05), thumbsH - 8)
          }

          If ((A_TickCount - prevGUIupdate>350) && modus!="all")
          {
             fnOutputDebug("ThumbsMode. Redraw the whole window.")
             If (minimizeMemUsage!=1 && thumbsBitmap)
                r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)
             r2 := LrydWinUpdt(hGDIthumbsWin, glHDC)
             prevGUIupdate := A_TickCount
             If (minimizeMemUsage!=1)
                hasUpdated := 1
          }
      }
   }

    If (alterFilesIndex>1 && mustEndLoop!=1 && lapsOccured>3 && modus!="all")
    {
       mustReloadThumbsList := 1
       ; mainGdipWinThumbsGrid()
       SetTimer, ForceRefreshNowThumbsList, -350
       ; Return
    } Else If (mustDoMultiCore=1 && mustEndLoop=1 && abandonAll!=1 && modus!="all")
    {
       fnOutputDebug("ThumbsMode after. Clean GDIs mess. Cores: " limitCores)
       Loop, % limitCores
           thumbThread%A_Index%.ahkPostFunction("cleanMess", "c" A_Index)
       ; fnOutputDebug("Thumbnails generator after. Clean GDIs mess. DONE.")
    }

    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    setPriorityThread(0)
    If (modus!="all" && (minimizeMemUsage=1 || !thumbsBitmap))
    {
       r2 := LrydWinUpdt(hGDIthumbsWin, glHDC)
    } Else If (modus!="all")
    {
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(thumbsBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If StrLen(zBitmap)>2
          {
             trGdip_DisposeImage(thumbsBitmap, 1)
             thumbsBitmap := zBitmap
          }
          E := Gdip_BitmapSetColorDepth(thumbsBitmap, "BW", 1)
       }

       If !isWinXP
          decideGDIPimageFX(matrix, imageAttribs, pEffect)

       fnOutputDebug("ThumbsMode end. Redraw the whole window.")
       If (pEffect || imageAttribs)
          r1 := trGdip_DrawImageFX(A_ThisFunc, glPG, thumbsBitmap, 0, 0, 0, 0, mainWidth, mainHeight, matrix, pEffect, imageAttribs)
       Else If (hasUpdated=0)
          r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)

       r2 := LrydWinUpdt(hGDIthumbsWin, glHDC)
    }

    If (minimizeMemUsage!=1 && thumbsBitmap)
       Gdip_DeleteGraphics(G2)

    trGdip_DisposeImage(thumbsBitmap, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeImageAttributes(imageAttribs)

    ; ToolTip, %imgW% -- %imgH% == %newW% -- %newH%
    prevFullThumbsUpdate := A_TickCount
    If (!userScrolled && !abandonAll && alterFilesIndex!=1)
    {
       mustReloadThumbsList := 0
       prevFullIndexThumbsUpdate := startPageIndex
    }

    If (abandonAll=1)
       lastLongOperationAbort := A_TickCount

    executingCanceableOperation := 0
    If (modus!="all")
       SetTimer, ResetImgLoadStatus, -25

    prevFullThumbsUpdate := A_TickCount
    addJournalEntry(maxItemsPage " thumbnails listed in " SecToHHMMSS((A_TickCount - mainStartZeit)/1000) ".")
    ; ToolTip, % lapsOccured "|"  totalLoops " | " innerLoops " | " extendedLoops " | " imgsNotCached "`nZeit: " A_TickCount - mainStartZeit , , , 2
    r := (r1!=0 || !r2 || abandonAll=1) ? 0 : 1
    If (modus="all")
       Return abandonAll
    Return r
}

cloneGDItoMem(funcu, pBitmap, W:=0, H:=0) {
    If !pBitmap
    {
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: no bitmap given")
       Return
    }

    If (!W || !H)
       Gdip_GetImageDimensions(pBitmap, W, H)

    thisImgQuality := (userimgQuality=1) ? 3 : 5
    newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, W, H, "0xE200B")
    If newBitmap
    {
       G := trGdip_GraphicsFromImage(A_ThisFunc "() invoked by " funcu, newBitmap, thisImgQuality)
       If G
          E := trGdip_DrawImage(A_ThisFunc "() invoked by " funcu, G, pBitmap, 0, 0, W, H)

       If (E="fail" || !G)
       {
          newBitmap := trGdip_DisposeImage(newBitmap, 1)
          addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create GDI+ graphics object")
       }

       Gdip_DeleteGraphics(G)
    } Else addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create bitmap")
    Return newBitmap
}

calcIMGcoord(usePrevious, mainWidth, mainHeight, newW, newH, ByRef DestPosX, ByRef DestPosY) {
    Static orderu := {1:7, 2:8, 3:9, 4:4, 5:5, 6:6, 7:1, 8:2, 9:3}
         , prevW := 1, prevH := 1, prevZoom := 0

    imgDecLX := LX := mainWidth - newW
    imgDecLY := LY := mainHeight - newH
    ; vpCenterX := 1, vpCenterY := 1
    CX := Round((mainWidth/2 - newW/2))
    CY := Round((mainHeight/2 - newH/2))

    modus := orderu[imageAligned]
    If (thumbsDisplaying=1)
       modus := 5

    If (modus=1)
    {
       DestPosX := 0
       DestPosY := LY
    } Else If (modus=2)
    {
       DestPosX := CX
       DestPosY := LY
    } Else If (modus=3)
    {
       DestPosX := LX
       DestPosY := LY
    } Else If (modus=4)
    {
       DestPosX := 0
       DestPosY := CY
    } Else If (modus=5)
    {
       DestPosX := CX
       DestPosY := CY
    } Else If (modus=6)
    {
       DestPosX := LX
       DestPosY := CY
    } Else If (modus=7)
    {
       DestPosX := DestPosY := 0
    } Else If (modus=8)
    {
       DestPosX := CX
       DestPosY := 0
    } Else If (modus=9)
    {
       DestPosX := LX
       DestPosY := 0
    } Else DestPosX := DestPosY := 0

    If (IMGlargerViewPort!=1)
    {
       IMGdecalageY := IMGdecalageY := 1
    } Else If (IMGresizingMode=4 && thumbsDisplaying!=1)
    {
       If (prevZoom!=zoomLevel && prevZoom!=0)
       {
          scaleu := newH/prevH
          IMGdecalageX := Round(IMGdecalageX*scaleu)
          IMGdecalageY := Round(IMGdecalageY*scaleu)
       } 

       factoru := (imageAligned=5) ? 2 : 1
       If (IMGdecalageX<LX//factoru) && (newW>mainWidth)
          IMGdecalageX := LX//factoru
       If (IMGdecalageY<LY//factoru) && (newH>mainHeight)
          IMGdecalageY := LY//factoru

       If (newW-5>mainWidth)
          DestPosX := DestPosX + IMGdecalageX
       Else
          IMGdecalageX := 0

       If (newH-5>mainHeight)
          DestPosY := DestPosY + IMGdecalageY
       Else
          IMGdecalageY := 0

       If (DestPosX>0) && (newW>mainWidth)
       {
          DestPosX := 0
          IMGdecalageX := (imageAligned=5) ? - LX//2 : 0
       }

       If (DestPosY>0) && (newH>mainHeight)
       {
          DestPosY := 0
          IMGdecalageY := (imageAligned=5) ? - LY//2 : 0
       }
    }

    prevW := newW
    prevH := newH
    prevZoom := zoomLevel
}

saveMainWinPos() {
   WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
   mainWinPos := winX "|" winY
   IniAction(1, "mainWinPos", "General")
}

writeMainWindowPos() {
   Static prevInfos
   If determineLClickstate()
   {
      SetTimer, writeMainWindowPos, -300
      Return
   }

   thisWinHwnd := (thumbsDisplaying=1) ? hGDIthumbsWin : hGDIwin
   WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
   WinGetPos,,, winWidth, winHeight, ahk_id %thisWinHwnd%
   WinGetPos,,, win2Width, win2Height, ahk_id %PVhwnd%
   If (winX && winY && winWidth && winHeight)
   {
      mainWinPos := winX "|" winY
      mainWinSize := winWidth "|" winHeight
      WinGet, Stylu, Style, ahk_id %PVhwnd%
      mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
      ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
      thisInfos := win2Width "z" win2Height "z" mainWinSize "z" mainWinPos "z" mainWinMaximized
      If (prevInfos!=thisInfos)
      {
         prevInfos := thisInfos
         IniAction(1, "mainWinPos", "General")
         IniAction(1, "mainWinSize", "General")
         IniAction(1, "mainWinMaximized", "General")
         SetTimer, writeMainWindowPos, -300
      }
   }
}

GDIupdaterResize(eventu:=0) {
   If (A_TickCount - scriptStartTime<450)
      Return

   If (drawingShapeNow=1)
      stopDrawingShape()
   If (toolTipGuiCreated=1)
      RemoveTooltip()
   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   If (eventu=2)
   {
      WinGet, Stylu, Style, ahk_id %PVhwnd%
      mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
      IniAction(1, "mainWinMaximized", "General")
      ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
   } Else If (eventu!=1)
      SetTimer, writeMainWindowPos, -350

   SetTimer, dummyTimerReloadThisPicture, Off
   SetTimer, dummyTimerDelayiedImageDisplay, Off
   DestroyGIFuWin()
   resetSlideshowTimer(0)
   imgPath := getIDimage(currentFileIndex)
   If StrLen(UserMemBMP)>2
      thisClippyIMG := 1

   If (!imgPath || !maxFilesIndex || PrevGuiSizeEvent=1 || !CurrentSLD) && (thisClippyIMG!=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      If (A_OSVersion="WIN_7" || isWinXP=1)
         GDIwindowsPosCorrections()

      ForceRefreshNowThumbsList()
      If (A_TickCount - lastWinDrag<350)
         Return

      If (thumbsDisplaying=1) && (!maxFilesIndex || !CurrentSLD)
         ToggleVisibilityWindow("hide", hGDIthumbsWin)
      Else
         FadeMainWindow()

      Return
   }

   If (maxFilesIndex>0 && PrevGuiSizeEvent!=1 && thumbsDisplaying!=1) && (A_TickCount - scriptStartTime>500) || (thisClippyIMG=1)
   {
      addJournalEntry("Resize window event - image view mode. ")
      delayu := (A_TickCount - lastWinDrag<450) ? 450 : 15
      filterDelayiedImageDisplay()
      ; dummyTimerDelayiedImageDisplay(delayu)
      dummyTimerReloadThisPicture(750)
      ForceRefreshNowThumbsList()
   } Else If (thumbsDisplaying=1 && maxFilesIndex>1)
   {
      addJournalEntry("Resize window event - thumbs mode.")
      recalculateThumbsSizes()
      ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      ; WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight% , ahk_id %hGDIthumbsWin%
      delayu := (A_TickCount - lastWinDrag<450) ? 550 : 325
      SetTimer, RefreshThumbsList, % -delayu
   }

   If (A_OSVersion="WIN_7" || isWinXP=1)
      GDIwindowsPosCorrections()
}

ToggleViewModeTouch() {
   zoomLevel := IMGdecalageY := IMGdecalageX := 1
   If (IMGresizingMode=1)
   {
      IMGresizingMode := 3
      ToggleImageSizingMode()
   } Else
   {
      IMGresizingMode := 0
      ToggleImageSizingMode()
   }
}

JEE_ClientToScreen(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472

  VarSetCapacity(POINT, 8)
  NumPut(vPosX, &POINT, 0, "Int")
  NumPut(vPosY, &POINT, 4, "Int")
  DllCall("user32\ClientToScreen", "Ptr", hWnd, "Ptr", &POINT)
  vPosX2 := NumGet(&POINT, 0, "Int")
  vPosY2 := NumGet(&POINT, 4, "Int")
}


ReloadDynamicFolderz(fileNamu) {
    showTOOLtip("Refreshing files list, please wait")
    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    listu := coreLoadDynaFolders(fileNamu)
    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue
       Else
          r := GetFilesList(line "\*")
       If (r="abandoned")
          Break
    }
}

coreLoadDynaFolders(fileNamu) {
    FileRead, tehFileVar, %fileNamu%
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(DF[0-9].*\=[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
          listu .= SubStr(line, InStr(line, "=")+1) "`n"
    }
 
    DynamicFoldersList := StrReplace(DynamicFoldersList, "|hexists|")
    listu .= "`n" Trimmer(DynamicFoldersList) "`n"
    changeMcursor()
    Sort, listu, UD`n
    DynamicFoldersList := listu
    Return listu
}

RegenerateEntireList() {
    If (AnyWindowOpen>0)
       BtnCloseWindow()

    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
    {
       retrieveFavesAsList()
       Return
    } Else If InStr(CurrentSLD, "\viewed-images-history-")
       Return

    If askAboutFileSave(" and the files list will be reloaded")
       Return

    thisIndex := currentFileIndex
    newStaticFoldersListCache := []
    startOperation := A_TickCount
    showTOOLtip("Refreshing files list, please wait")
    listu := getDynamicFoldersList()
    If StrLen(listu)<4
    {
       showTOOLtip("WARNING: No list of dynamic folders found")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    mustOpenStartFolder := ""
    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    renewCurrentFilesList()
    mustGenerateStaticFolders := (SLDtypeLoaded=3) ? 0 : 1
    Sort, listu, UD`n
    If (SLDtypeLoaded=3)
    {
       ; activeSQLdb.Exec("UPDATE images SET isDeleted=1;")
       ; activeSQLdb.Exec("DELETE FROM images;")
       recreateDynaFoldersSQLdbList(listu)
       saveSlideSettingsInDB()
       getMaxRowIDsqlDB()
    }

    countFolders := ST_Count(listu, "`n") + 1
    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       isPipe := InStr(line, "|") ? 1 : 0
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue

       If (SLDtypeLoaded=3)
       {
          thisR := SQLescapeStr(fileTest, 1)
          thisR := (isPipe=1) ? thisR : thisR "%"
          SQLstr := "UPDATE images SET isDeleted=1 WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          activeSQLdb.Exec(SQLstr)
       }

       r := GetFilesList(line "\*", A_Index / countFolders)
       If (SLDtypeLoaded=3)
          SQLdeleteEntriesMarked()

       If (r="abandoned")
          Break
    }

    ; If (r="abandoned" && SLDtypeLoaded!=3)
    ; {
    ;    resetMainWin2Welcome()
    ;    showTOOLtip("Operation aborted. The files list is now empty.")
    ;    SoundBeep, 300, 100
    ;    SetTimer, RemoveTooltip, % -msgDisplayTime
    ; } Else
    ; {
       thisFolder := StrReplace(CurrentSLD, "|")
       If (SLDtypeLoaded=3 && r!="abandoned")
          SQLdbGenerateStaticFolders()
       Else If (SLDtypeLoaded=1 && FolderExist(thisFolder))
          watchFolderDetails := getFolderDetails(thisFolder)

       GenerateRandyList()
       If (r="abandoned" && SLDtypeLoaded!=3)
       {
          showDelayedTooltip("Operation aborted - regenerate files list. The files list is now incomplete.")
          SoundBeep, 300, 100
       } Else SoundBeep, 900, 100

       currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
       If (maxFilesIndex<1)
       {
          friendly := (SLDtypeLoaded=1 && FolderExist(thisFolder)) ? "No image files found in the folder:`n" thisFolder "\`n`n" : "Error refreshing files list... found nothing.`n`n"
          FadeMainWindow()
          msgBoxWrapper(appTitle ": WARNING", friendly "No indexed files found, please open a file or folder.", 0, 0, "info")
          resetMainWin2Welcome()
       } Else dummyTimerDelayiedImageDisplay(50)
       ; RandomPicture()
    ; }
    etaTime := "Elapsed time to regenerate files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
    addJournalEntry(etaTime)
}

throwSQLqueryDBerror(funcu) {
   SetTimer, ResetImgLoadStatus, -150
   showDelayedTooltip("ERROR: " funcu "() failed to query or commit changes the SQL database`n" activeSQLdb.ErrorMsg)
   SoundBeep, 300, 100
   ; SetTimer, RemoveTooltip, % -msgDisplayTime
}

getMaxRowIDsqlDB() {
  SQL := "SELECT max(imgidu) FROM images;"
  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "() " activeSQLdb.ErrorMsg)
     Return
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If IsNumber(Rowu[1])
         sqlDBrowID := Rowu[1] + 1 ; Rowu[2] Rowu[3]
  }

  RecordSet.Free()
  Return sqlDBrowID
}

sldbDataBaseOpen(fileNamu) {
  activeSQLdb.CloseDB()
  activeSQLdb := new SQLiteDB
  If !activeSQLdb.OpenDB(fileNamu)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return -1
  }

  startOperation := A_TickCount
  If (MustLoadSLDprefs=1)
  {
     IniSLDBreadAll() ; read slideshow settings
  } Else
  {
     IniSLDBreadAll("prevFilesSortMode")
     IniSLDBreadAll("reverseOrderOnSort")
  }

  RecordSet := ""
  SLDcacheFilesList := 1
  sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
  reorder := StrLen(prevFilesSortMode)>3 ? " ORDER BY " prevFilesSortMode sortMode ";" : " ORDER BY imgidu;"
 
  SQL := "SELECT imgidu, fullPath FROM images" reorder
  startOperation := A_TickCount
  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return -1
  }

  resultedFilesList := []
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[2]
      {
         maxFilesIndex++
         resultedFilesList[maxFilesIndex, 1] := Rowu[2]
         resultedFilesList[maxFilesIndex, 12] := Rowu[1]
      }
  }

  RecordSet.Free()
  getMaxRowIDsqlDB()

  SQL := "SELECT imgfolder FROM dynamicfolders;"
  DynamicFoldersList := ""
  activeSQLdb.GetTable(SQL, RecordSet)
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[1]
         DynamicFoldersList .= Rowu[1] "`n"
  }

  RecordSet.Free()
  etaTime := "Elapsed time to open SQL database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
  addJournalEntry(etaTime)
  If (A_TickCount - startOperation>7000) && (maxFilesIndex>2)
     SoundBeep , 900, 100

  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}

crapBIGcrap() {
   ; collectSQLFileInfosNow(thisNOTnullCol, 0, 1, 0)
   ; If InStr(theseCols, "pixelzHash")
   ;    generateSQLimagesExtraHash()

   showTOOLtip("Identifying image duplicates, please wait")
   ; SQLstr := "SELECT imgidu, fullPath, a.imgmegapix, a.fsize, a.innerpixelz||a.outerpixelz, b.groupID FROM images AS a`n"
   ; SQLstr .= " JOIN (SELECT substr(pixelzHash, 4, 32) AS pixelzHash, ROWID AS groupID`n"
   ; SQLstr .= " FROM images WHERE pixelzHash IS NOT NULL`n"
   ; SQLstr .= " GROUP BY substr(pixelzHash, 4, 32) HAVING count(*)>1) AS b`n"
   ; SQLstr .= " ON (substr(a.pixelzHash, 4, 32) = b.pixelzHash)"
   ; SQLstr .= " ORDER BY b.groupID;"

   SQLstr := "SELECT imgidu, fullPath, imgmegapix, fsize, entireHush`n"
   SQLstr .= " FROM images WHERE pixelzHash IS NOT NULL`n"
   SQLstr .= " ORDER BY imgidu LIMIT 10201;"

   startOperation := A_TickCount
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      Return -1
   }

   If (RecordSet.RowCount<2)
   {
      showTOOLtip("Found no image duplicates")
      addJournalEntry("SQL query used:`n" SQLstr)
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If !SortCriterion
         SetTimer, PanelFindDupes, -250
      Return
   }

   doStartLongOpDance()
   showTOOLtip("Found " groupDigits(RecordSet.RowCount) " duplicate images`nGenerating files, please wait")
   groupies := []
   currIDs := []
   Roza := []
   hashesListArray := new hashtable()
   prevMSGdisplay := A_TickCount
   Loop, % RecordSet.RowCount
   {
      Roxa := RecordSet.Rows[A_Index]
      ; Roza[A_Index] := [Roxa[1], Roxa[2], Roxa[3], Roxa[4], "0x" ConvertBase(2, 16, reorderStoredHash(Roxa[5], Roxa[6]))]
      Roza[A_Index] := [Roxa[1], Roxa[2], Roxa[3], Roxa[4]]
      hashesList[A_Index] := Roxa[5]
      ; Roza[A_Index] := [Roxa[1], Roxa[2], Roxa[3], Roxa[4], Roxa[5]]
   }

   oneLap := RecordSet.RowCount
   totalLoops := Round((RecordSet.RowCount * RecordSet.RowCount)*0.49686)
   totalu := Round((RecordSet.RowCount * RecordSet.RowCount)*0.5)
   mainIndex := secondIndex := 1
   newTempList := []
   VarSetCapacity(bigArray, 8*elements)
   Loop, % elements
   {
      NumPut(mainArray[A_Index], bigArray,8*(A_Index - 1), "uint64")
   }
   DllCall("DllFile\Function", "Ptr", &bigArray, "Ptr*", resultsArray)


   Loop, % totalu
   {
      secondIndex++
      If (secondIndex>oneLap)
      {
         mainIndex++
         If (mainIndex>oneLap)
            Break
         Else
            secondIndex := mainIndex + 1

         ; cu := StrSplit(Roza[mainIndex, 5])
      }
      If (secondIndex=mainIndex) ; || IsObject(newTempList[Roza[secondIndex, 1]])
      {
         skippedFiles++
         Continue
      }

      ; If (determineTerminateOperation()=1)
      ; {
      ;    abandonAll := 1
      ;    Break
      ; }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(A_Index, totalLoops, startOperation)
            showTOOLtip("looping... " groupDigits(mainIndex) "..." groupDigits(foundDupes) "..." newTempList.Count()  "..." skippedFiles "`n" etaTime)
            prevMSGdisplay := A_TickCount
         }

            If (HammingDistanceNew2020dec(hashesListArray[mainIndex], hashesListArray[secondIndex])<2)
            {
               ; HammingDistanceNew2020dec(Roza[mainIndex, 5], Roza[secondIndex, 5], 0)

               ; ToolTip, %  Roza[mainIndex, 5] "`n" Roza[secondIndex, 5], , , 2
               ; Sleep, , 200
               foundDupes++
               ; newTempList[Roza[secondIndex, 1]] := Roza
            }

   }





/*

   method 1

   Loop, % totalu
   {
      secondIndex++
      If (secondIndex>oneLap)
      {
         mainIndex++
         If (mainIndex>oneLap)
            Break
         Else
            secondIndex := mainIndex + 1

         ; cu := StrSplit(Roza[mainIndex, 5])
      }
      If (secondIndex=mainIndex) || IsObject(newTempList[Roza[secondIndex, 1]])
      {
         skippedFiles++
         Continue
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(A_Index, totalLoops, startOperation)
            showTOOLtip("looping... " groupDigits(mainIndex) "..." groupDigits(foundDupes) "..." newTempList.Count()  "..." skippedFiles "`n" etaTime)
            prevMSGdisplay := A_TickCount
         }

            If (HammingDistanceNew2020dec(Roza[mainIndex, 5], Roza[secondIndex, 5])<2)
            {
               ; HammingDistanceNew2020dec(Roza[mainIndex, 5], Roza[secondIndex, 5], 0)

               ; ToolTip, %  Roza[mainIndex, 5] "`n" Roza[secondIndex, 5], , , 2
               ; Sleep, , 200
               foundDupes++
               newTempList[Roza[secondIndex, 1]] := Roza

               ; If (groupies[Rowu[6]]!=1)
               ; {
               ;    resultedFilesList[maxFilesIndex, 1] := Rowu[2]
               ;    resultedFilesList[maxFilesIndex, 12] := Rowu[1]
               ;    resultedFilesList[maxFilesIndex, 17] := Rowu[3]
               ;    resultedFilesList[maxFilesIndex, 6] := Rowu[4]
               ;    resultedFilesList[maxFilesIndex, 23] := Rowu[6]
               ; } Else
               ; {
               ;    resultedFilesList[maxFilesIndex, 1] := Row[2]
               ;    resultedFilesList[maxFilesIndex, 12] := Row[1]
               ;    resultedFilesList[maxFilesIndex, 17] := Row[3]
               ;    resultedFilesList[maxFilesIndex, 6] := Row[4]
               ;    resultedFilesList[maxFilesIndex, 23] := Rowu[6]
               ; }
               ; groupies[Rowu[6]] := 1
            }

   }

*/

/*

   method 0

   totalLoops := RecordSet.RowCount
   Loop, % RecordSet.RowCount
   {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      ; Rowu := RecordSet.Rows[A_Index]

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(A_Index, totalLoops, startOperation)
            showTOOLtip("looping... " groupDigits(A_Index) "`n" etaTime)
            prevMSGdisplay := A_TickCount
         }

         Loop, % RecordSet.RowCount
         {
            ; Row := RecordSet.Rows[A_Index]
            If (currIDs[Roza[A_Index, 1]]=1)
            {
            ;    ; thisu++
            ;    ; ToolTip, % thisu "=" , , , 2
               Continue
            }
            If (HammingDistance3(Rowu[5], Row[5])<2)
            {
               maxFilesIndex++
               If (groupies[Rowu[6]]!=1)
               {
                  resultedFilesList[maxFilesIndex, 1] := Rowu[2]
                  resultedFilesList[maxFilesIndex, 12] := Rowu[1]
                  resultedFilesList[maxFilesIndex, 17] := Rowu[3]
                  resultedFilesList[maxFilesIndex, 6] := Rowu[4]
                  resultedFilesList[maxFilesIndex, 23] := Rowu[6]
               } Else
               {
                  resultedFilesList[maxFilesIndex, 1] := Row[2]
                  resultedFilesList[maxFilesIndex, 12] := Row[1]
                  resultedFilesList[maxFilesIndex, 17] := Row[3]
                  resultedFilesList[maxFilesIndex, 6] := Row[4]
                  resultedFilesList[maxFilesIndex, 23] := Rowu[6]
               }
               groupies[Rowu[6]] := 1
            }
         }
         currIDs[Roza[A_Index, 1]] := 1
      ; }
   }
*/

   RecordSet.Free()
   ; userFilterDoString := 0
   ; currentFileIndex := userFilterProperty := 1
   ; filesFilter := "SQL:query:" StrReplace(SubStr(SQLstr, Round(InStr(SQLstr, "JOIN (")), InStr(SQLstr, " ORDER BY") - InStr(SQLstr, "JOIN (")), "`n", A_Space)
   ; ToolTip, % filesFilter , , , 2
   etaTime := "Elapsed time to identify possible image duplicates: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   showDelayedTooltip("Found " groupDigits(groupies.Count()) " groups of duplicates`nTotal images: " groupDigits(maxFilesIndex))
   ; SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -100
   dummyTimerDelayiedImageDisplay(90)
   ; RandomPicture()
}

retrieveDupesByProperties(theseCols, fsCmp, SortCriterion:=0) {
   Static prevMode, notFloatsRegEX := "i)(fcreated|fmodified|fsize|imgfile|innerpixelz|outerpixelz|imgwidth|imgheight|imgframes|imgdpi|imgpixfmt|pixelzHash)"

   If SortCriterion
      mode := prevMode

   prevMode := theseCols
   If RegExMatch(theseCols, "i)(innerpixelz|outerpixelz|pixelzHash)")
      thisNOTnullCol := "innerpixelz"
   Else If RegExMatch(theseCols, "i)(imgmedian|imgavg|imghpeak|imghlow|imghmode|imghminu|imghrange|imghrms)")
      thisNOTnullCol := "imgmedian"
   Else If RegExMatch(theseCols, "i)(imgmegapix|imgdpi|imgwidth|imgframes|imgpixfmt|imgheight|imgwhratio)")
      thisNOTnullCol := "imgwidth"
   Else If RegExMatch(theseCols, "i)(fcreated|fmodified|fsize)")
      thisNOTnullCol := "fsize"
   Else
      thisNOTnullCol := "imgfile"
   ; ToolTip, % theseCols "`n" thisNOTnullCol , , , 2
   collectSQLFileInfosNow(thisNOTnullCol, 0, 1, 0)
   If InStr(theseCols, "pixelzHash")
      generateSQLimagesExtraHash()

   showTOOLtip("Identifying image duplicates, please wait")
   innerTrimL := hashInnerTrimLeft + 1
   innerTrimR := 36 - hashInnerTrimRight - hashInnerTrimLeft
   outerTrimL := hashOuterTrimLeft + 1
   outerTrimR := 28 - hashOuterTrimRight - hashOuterTrimLeft
   simpleTrimL := (hashSimpleTrimLeft=0) ? 1 : hashSimpleTrimLeft + 4
   simpleTrimR := 36 - hashSimpleTrimRight - hashSimpleTrimLeft
   mustDoSubStr := 0
   If ((innerTrimL!=1 || innerTrimR!=36) && InStr(theseCols, "innerp"))
   || ((outerTrimL!=1 || outerTrimR!=28) && InStr(theseCols, "outerp"))
   || ((simpleTrimL!=1 || simpleTrimR!=36)  && InStr(theseCols, "pixelzH"))
      mustDoSubStr := 1

   orderCol := "a.imgmegapix,a.fsize"
   ONlist := "ON ("
   Loop, Parse, % theseCols, CSV
   {
      If (InStr(A_LoopField, "inner") && mustDoSubStr=1)
         ONlist .= " AND substr(a.innerpixelz," innerTrimL "," innerTrimR ") = b.innerpixelz"
      Else If (InStr(A_LoopField, "outer") && mustDoSubStr=1)
         ONlist .= " AND substr(a.outerpixelz," outerTrimL "," outerTrimR ") = b.outerpixelz"
      Else If (InStr(A_LoopField, "hash") && mustDoSubStr=1)
         ONlist .= " AND substr(a.pixelzHash," simpleTrimL "," simpleTrimR ") = b.pixelzHash"
      Else If A_LoopField
         ONlist .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " AND Round(a." A_LoopField "," findDupesPrecision ") = b." A_LoopField : " AND a." A_LoopField " = b." A_LoopField
   }

   Loop, Parse, % theseCols, CSV
   {
      If !A_LoopField
         Continue

      If (InStr(A_LoopField, "pixelz") && mustDoSubStr=1)
      {
         If InStr(A_LoopField, "inner")
         {
            newCols .= " substr(innerpixelz," innerTrimL "," innerTrimR "),"
            selectuCols .= " substr(innerpixelz," innerTrimL "," innerTrimR ") AS innerpixelz,"
         } Else If InStr(A_LoopField, "outer")
         {
            newCols .= " substr(outerpixelz," outerTrimL "," outerTrimR "),"
            selectuCols .= " substr(outerpixelz," outerTrimL "," outerTrimR ") AS outerpixelz,"
         } Else If InStr(A_LoopField, "hash")
         {
            newCols .= " substr(pixelzHash," simpleTrimL "," simpleTrimR "),"
            selectuCols .= " substr(pixelzHash," simpleTrimL "," simpleTrimR ") AS pixelzHash,"
         }
      } Else
      {
         newCols .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " Round(" A_LoopField "," findDupesPrecision ")," : A_LoopField ","
         selectuCols .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " Round(" A_LoopField "," findDupesPrecision ") AS " A_LoopField "," : A_LoopField ","
      }
   }

   theseCols := Trimmer(newCols, ",")
   selectuCols := Trimmer(selectuCols, ",")
   SQLstr := "SELECT imgidu, fullPath, a.imgmegapix, a.fsize, b.groupID FROM images AS a`n"
   SQLstr .= " JOIN (SELECT " selectuCols ", ROWID AS groupID`n"
   SQLstr .= " FROM images WHERE " thisNOTnullCol " IS NOT NULL`n"
   SQLstr .= " GROUP BY " theseCols " HAVING count(*)>1) AS b`n"
   SQLstr .= StrReplace(ONlist, "ON ( AND ", "ON (") ") "
   SQLstr .= StrLen(SortCriterion)>1 ? "ORDER BY a." SortCriterion ";" : "ORDER BY b.groupID," orderCol ";"

   startOperation := A_TickCount
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      Return -1
   }

   addJournalEntry("SQL query used to identify dupes:`n" SQLstr)
   If (RecordSet.RowCount<2)
   {
      showTOOLtip("Found no image duplicates")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If !SortCriterion
         SetTimer, PanelFindDupes, -250
      Return
   }

   showTOOLtip("Found " groupDigits(RecordSet.RowCount) " duplicate images`nGenerating files, please wait")
   If !filesFilter
      bckpMaxFilesIndex := maxFilesIndex   
   renewCurrentFilesList()
   groupies := []
   Loop, % RecordSet.RowCount
   {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[2]
      {
         maxFilesIndex++
         resultedFilesList[maxFilesIndex, 1] := Rowu[2]
         resultedFilesList[maxFilesIndex, 12] := Rowu[1]
         resultedFilesList[maxFilesIndex, 17] := Rowu[3]
         resultedFilesList[maxFilesIndex, 6] := Rowu[4]
         resultedFilesList[maxFilesIndex, 23] := Rowu[5]
         groupies[Rowu[5]] := 1
      }
   }

   RecordSet.Free()
   userFilterDoString := 0
   currentFileIndex := userFilterProperty := 1
   filesFilter := "SQL:query:" StrReplace(SubStr(SQLstr, Round(InStr(SQLstr, "JOIN (")), InStr(SQLstr, " ORDER BY") - InStr(SQLstr, "JOIN (")), "`n", A_Space)
   ; ToolTip, % filesFilter , , , 2
   etaTime := "Elapsed time to identify possible image duplicates: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   showDelayedTooltip("Found " groupDigits(groupies.Count()) " groups of duplicates`nTotal images: " groupDigits(maxFilesIndex))
   ; SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -100
   dummyTimerDelayiedImageDisplay(90)
   ; RandomPicture()
}

autoSelectDupesInGroups(mode, givenRegEx:=0) {
   ; dropFilesSelection(1)
   theArray := []
   ; ToolTip, % mode "==" givenRegEx , , , 2
   Loop, % maxFilesIndex
   {
      If (grpID := resultedFilesList[A_Index, 23])
      {
         countPerGroup%grpID%++
         fs := resultedFilesList[A_Index, 6]
         mgpx := Round(resultedFilesList[A_Index, 17], 3)
         If (fs>theArray[grpID, 1, 1])
            theArray[grpID, 1] := [fs, A_Index]
         If (fs<theArray[grpID, 3, 1] || !theArray[grpID, 3, 1])
            theArray[grpID, 3] := [fs, A_Index]

         If (mgpx>theArray[grpID, 2, 1])
            theArray[grpID, 2] := [mgpx, A_Index]
         If (mgpx<theArray[grpID, 4, 1] || !theArray[grpID, 4, 1])
            theArray[grpID, 4] := [mgpx, A_Index]
      }
   }

   indexu := 0
   rescanIDs := []
   Loop, % maxFilesIndex
   {
      grpID := resultedFilesList[A_Index, 23]
      If (mode=1)
      {
         If (grpID && countPerGroup%grpID%>1)
         {
            mgpxMax := theArray[grpID, 2, 1]
            mgpxMin := theArray[grpID, 4, 1]
            ; Sleep, 100
            ; ToolTip, % mgpxMin "==" mgpxMax , , , 2
            If (mgpxMin=mgpxMax)
            {
               fsMax := Round(theArray[grpID, 1, 1]/1024, 1)
               fsMin := Round(theArray[grpID, 3, 1]/1024, 1)
               If (fsMin=fsMax && givenRegEx)
               {
                  imgPath := resultedFilesList[A_Index, 1]
                  r := coreSearchIndex(imgPath, givenRegEx, 2)
                  resultedFilesList[A_Index, 2] := r ? 0 : 1
                  If !rescanIDs[grpID, 1]
                  {
                     indexu++
                     rescanIDs[grpID, 1] := r ? 0 : 1
                  }

                  If (rescanIDs[grpID, 2]!=0)
                     rescanIDs[grpID, 2] := r ? 0 : 1
               } Else
               {
                  thisIndex := theArray[grpID, 1, 2] ; max file size
                  resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
               }
            } Else
            {
               thisIndex := theArray[grpID, 2, 2] ; max res
               resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
            }
         } Else resultedFilesList[A_Index, 2] := 0
      } Else
      {
         If (grpID && countPerGroup%grpID%>1)
         {
            thisIndex := (mode=2) ? theArray[grpID, 1, 2] : theArray[grpID, 2, 2]
            resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
         } Else resultedFilesList[A_Index, 2] := 0
      }
   }

   If (indexu>0 && mode=1 && givenRegEx)
   {
      ; ensure that all or none are selected within a group after regex
      Loop, % maxFilesIndex
      {
         grpID := resultedFilesList[A_Index, 23]
         If (grpID && countPerGroup%grpID%>1)
         {
            If (rescanIDs[grpID, 1]=0)
            {
               rescanIDs[grpID, 1] := 1
               resultedFilesList[A_Index, 2] := 1
            }

            If (rescanIDs[grpID, 2]=1)
            {
               rescanIDs[grpID, 2] := 0
               resultedFilesList[A_Index, 2] := 0
            }
         }
      }
   }
   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)

}

sldGenerateFilesList(readThisFile, doFilesCheck, mustRemQuotes, doOptionals:=1) {
    startZeit := A_TickCount
    FileRead, tehFileVar, %readThisFile%
    If (mustRemQuotes=1)
    {
       tehFileVar := StrReplace(tehFileVar, """-")
       tehFileVar := StrReplace(tehFileVar, """")
    }

    doStartLongOpDance()
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If InStr(line, "|")
       {
          RecursiveFlag := "|"
          line := StrReplace(line, "|")
       } Else RecursiveFlag := ""

       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       ; changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          If (doFilesCheck=1)
          {
             If !FileRexists(line)
                Continue
          }

          maxFilesIndex++
          resultedFilesList[maxFilesIndex] := [line]
       } Else If RegExMatch(line, "i)^(.\:\\.)") ; RegExMatch(line, "i)^(.\:\\.).*(\\)$")
       {
          line := Trimmer(line, "\")
          If FolderExist(line)
          {
             DynamicFoldersList .= "`n" RecursiveFlag line "`n"
             GetFilesList(RecursiveFlag line "\*")
          }
       }
    }

    etaTime := "Elapsed time to open TXT files list: " SecToHHMMSS(Round((A_TickCount - startZeit)/1000, 3)) ". Files: " maxFilesIndex
    addJournalEntry(etaTime)
    If (A_TickCount - startZeit>7000) && (maxFilesIndex>2 && abandonAll!=1)
       SoundBeep, 900, 100

    executingCanceableOperation := 0
    SetTimer, ResetImgLoadStatus, -50
    If (doOptionals=1)
    {
       If (abandonAll=1)
          showDelayedTooltip("Operation aborted. The files list is now empty.")
       Else If (maxFilesIndex<1)
          showDelayedTooltip("Found no files or folders in the SLD`nThe files list is now empty.")

       If (abandonAll=1 || maxFilesIndex<1)
       {
          lastLongOperationAbort := A_TickCount
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SoundBeep, 300, 100
          Return "abandoned"
       }
    }
}

filterCoreString(stringu, behave, thisFilter, doExactFolderMatch:=0) {
  If (doExactFolderMatch=1)
  {
     zPlitPath(stringu, 1, OutFileName, OutDir)
     r := RegExMatch(OutDir "\", "i)^(" thisFilter "\\)$")
  } Else r := RegExMatch(stringu, "i)(" thisFilter ")")
  z := r ? 1 : 0
  Return (behave=2) ? !z : z
}

GetFilesList(strDir, progressInfo:=0) {
  showTOOLtip("Loading files from`n" strDir "`n", 0, 0, progressInfo)
  If InStr(strDir, "|")
  {
     doRecursive := ""
     strDir := StrReplace(strDir, "|")
  } Else doRecursive := "R"

  addedNow := 0
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  prevDisplay := A_TickCount
  If (SLDtypeLoaded=3)
     activeSQLdb.Exec("BEGIN TRANSACTION;")

  doStartLongOpDance()
  Loop, Files, %strDir%, %doRecursive%
  {
      fullPath := Trimmer(A_LoopFileFullPath)
      If (RegExMatch(fullPath, RegExFilesPattern) && A_LoopFileSize>120)
      {
         If (SLDtypeLoaded=3) ; SQLite database 
            erru := addSQLdbEntry(A_LoopFileName, A_LoopFileDir, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated)

         If !erru
         {
            addedNow++
            maxFilesIndex++
            If (A_PtrSize=8 && minimizeMemUsage!=1)
               resultedFilesList[maxFilesIndex] := [fullPath,,,,, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated]
            Else
               resultedFilesList[maxFilesIndex] := [fullPath]

            If (SLDtypeLoaded=3)
               resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
         }
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         showTOOLtip("Loading files from`n" strDir "`nFound " groupDigits(addedNow) " files...`nTotal indexed files: " groupDigits(maxFilesIndex), 0, 0, progressInfo)
         prevMSGdisplay := A_TickCount
      }

      changeMcursor()
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
  }

  If (SLDtypeLoaded=3)
  {
     If !activeSQLdb.Exec("COMMIT TRANSACTION;")
        throwSQLqueryDBerror(A_ThisFunc)
  }

  currentFilesListModified := 1
  executingCanceableOperation := 0
  SetTimer, ResetImgLoadStatus, -50
  If (abandonAll=1)
  {
     showTOOLtip("Files list loading aborted")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "abandoned"
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return loadedFirst
}

getIDimage(imgID) {
    r := resultedFilesList[imgID, 1]
    Return r
}

IDshowImage(imgID, opentehFile:=0) {
    Static prevIMGid, prevImgPath, lastInvoked := 1
    imgPath := getIDimage(imgID)
    If StrLen(imgPath)<4
    {
       addJournalEntry("Index entry error: incorrect file path:`n" imgPath " [ " imgID " ]")
       If (A_TickCount - lastInvoked>1050)
          SoundBeep, 300, 90
       lastInvoked := A_TickCount
       Return 0
    }

    isPipe := InStr(imgPath, "||")
    imgPath := StrReplace(imgPath, "||")
    If (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath) || StrLen(UserMemBMP)>2 || thumbsDisplaying=1)
       ignoreFileCheck := 1

    If (ignoreFileCheck!=1 && skipDeadFiles=1)
    {
       If (!FileRexists(imgPath) && opentehFile!=250 && imgPath!=prevImgPath)
       {
          If (autoRemDeadEntry=1 && imgID=currentFileIndex)
             remCurrentEntry(0, 1)
          Return 0
       }
    }

    If (AnyWindowOpen!=10 && resetImageViewOnChange=1 && thumbsDisplaying!=1)
    {
       newIMGid := generateThumbName(imgPath, 1)
       If (prevIMGid!=newIMGid)
       {
          prevIMGid := newIMGid
          usrColorDepth := imgFxMode := 1
          vpIMGrotation := FlipImgH := FlipImgV := 0
       }
    }

    prevImgPath := (opentehFile=0 || opentehFile=2) ? imgPath : 0
    If (opentehFile=2)
       ShowTheImage(imgPath, 2)  ; prevent down-scaled display
    Else If (opentehFile=3)
       ShowTheImage(imgPath, 2, 1)  ; force image reload
    Else
       ShowTheImage(imgPath)
    Return 1
}

PreventKeyPressBeep() {
   IfEqual,A_Gui,1,Return 0 ; prevent keystrokes for GUI 1 only
}

doSuspendu(act) {
  If (act=1)
     Suspend, On
  Else
     Suspend, Off
}

trimArray(arr) {
; Hash O(n) - function by errorseven from:
; https://stackoverflow.com/questions/46432447/how-do-i-remove-duplicates-from-an-autohotkey-array
    hash := {}
    newArr := []
    thisCounter := 0
    For k, v in arr
    {
        z := "z" StringToASC(v)
        If (hash[z]!=1)
        {
           thisCounter++
           hash[z] := 1
           newArr[thisCounter] := v
        }
    }
    Return newArr
}

ReverseListNow() {
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (askAboutFileSave(" and the files list will be reversed") || maxFilesIndex<3)
       Return

    showTOOLtip("Reversing files list order")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := reverseArray(resultedFilesList)
    If StrLen(filesFilter)>1
       filteredMap2mainList := reverseArray(filteredMap2mainList)

    currentFilesListModified := 1
    ForceRefreshNowThumbsList()
    CurrentSLD := backCurrentSLD
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

RandomizeListNow() {
    If StrLen(filesFilter)>1
    {
       msgResult := msgBoxWrapper(appTitle ": Randomize files list", "You currently have a files list filter applied. To randomize the list, it will be deactivated.", 4, 0, "question")
       If InStr(msgResult, "yes")
       {
          markedSelectFile := 0
          showTOOLtip("Deactivating the files list filter, please wait")
          remFilesListFilter("simple")
          Sleep, 10
          RemoveTooltip()
       } Else Return
    }

    If askAboutFileSave(" and the files list will be randomized")
       Return

    showTOOLtip("Randomizing files list order")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := Random_ShuffleArray(resultedFilesList)
    CurrentSLD := backCurrentSLD
    currentFilesListModified := 1
    ForceRefreshNowThumbsList()
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

Random_ShuffleArray(Array) {
; function from "Facade Functional Programming Suite"
; by Shambles, from https://github.com/Shambles-Dev/AutoHotkey-Facade
; modified by Marius Șucan
; This is the Fisher–Yates shuffle algorithm.

    Result := Array.Clone()
    maxArray := Array.Count()
    Loop, % maxArray - 1
    {
        Random, J, % A_Index, % maxArray
        Temp            := Result[A_Index]
        Result[A_Index] := Result[J]
        Result[J]       := Temp
    }

    Return Result
}

reverseArray(a) {
; function inspired by RHCP from https://autohotkey.com/board/topic/97722-some-array-functions/

    aStorage := []
    maxIndexu := a.Count()
    Loop, % maxIndexu
        aStorage[A_Index] := a[maxIndexu - A_Index + 1]

    Return aStorage
}

coreResizeIMG(imgPath, newW, newH, file2save, goFX, toClippy, rotateAngle, soloMode:=1, imgW:=0, imgH:=0, batchMode:=0) {
    Static rr := "error"
    If (soloMode=1)
    {
       oBitmap := LoadBitmapFromFileu(imgPath)
       If StrLen(oBitmap)>2
       {
          Gdip_GetImageDimensions(oBitmap, imgW, imgH)
          rawFmt := Gdip_GetImageRawFormat(oBitmap)
          If (rawFmt="JPEG")
             RotateBMP2exifOrientation(oBitmap)

          If (!newW || !newH)
             mustDoRotateCoord := 1

          If !newW
             newW := imgW
          If !newH
             newH := imgH
          If (rotateAngle>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1 && mustDoRotateCoord=1)
             Gdip_GetRotatedDimensions(newW, newH, rotateAngle, newW, newH)
       } Else Return rr
    } Else oBitmap := soloMode

    If !oBitmap
       Return rr

    If (ResizeApplyEffects=1 || goFX=1)
    {
       mustDoBw := (bwDithering=1 && imgFxMode=4) ? 1 : 0
       If (imgFxMode=3 && toClippy!=1)
          AdaptiveImgLight(oBitmap, imgPath, 1, 1)

       decideGDIPimageFX(matrix, imageAttribs, pEffect)
    }

    ; to-do - if pargb - always??
    oPixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    If (toClippy=1)
       oPixFmt := (currIMGdetails.HasAlpha=1) ? "32-PARGB" : "24-RGB"

    brushRequired := !InStr(oPixFmt, "argb") ? 1 : 0
    pixFmt := (must24bits=1) ? "0x21808" : "0x26200A"     ; 24-RGB  //  32-ARGB
    thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
    If (editingSelectionNow=1 && ResizeCropAfterRotation=1 && ResizeWithCrop=1 && rotateAngle>0)
    {
       oBitmap := coreRotateBMP(oBitmap, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired)
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
    }

    If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1 && soloMode=1)
       calcRelativeSelCoords(oBitmap, imgW, imgH)

    If (editingSelectionNow=1 && (goFX=1 || ResizeWithCrop=1))
    {
       calcImgSelection2bmp(0, imgW, imgH, newW, newH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       imgSelW := Round(imgW), imgSelH := Round(imgH)
       imgSelPx := 0, imgSelPy := 0

       zImgSelW := Round(newW), zImgSelH := Round(newH)
       zImgSelPx := 0, zImgSelPy := 0
    }

    thumbBMP := trGdip_CreateBitmap(A_ThisFunc, zImgSelW, zImgSelH, pixFmt)
    If warnUserFatalBitmapError(thumbBMP, A_ThisFunc)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return rr
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbBMP, thisImgQuality, 4, 2)
    If !G2
    {
       trGdip_DisposeImage(oBitmap, 1)
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return rr
    }

    If (brushRequired=1) || (!RegExMatch(file2save, saveAlphaTypesRegEX) && toClippy!=1)
       trGdip_GraphicsClear(A_ThisFunc, G2, "0xFf" WindowBgrColor)
       ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, imgW + 4, imgH + 4)

    If (goFX=1 || ResizeApplyEffects=1)
    {
       setMainCanvasTransform(zImgSelW, zImgSelH, G2)
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(oBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If zBitmap
          {
             trGdip_DisposeImage(oBitmap, 1)
             oBitmap := zBitmap
          }

          E := Gdip_BitmapSetColorDepth(oBitmap, "BW", 1)
       } Else If (usrColorDepth>1)
          E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
 
       If pEffect
          Gdip_BitmapApplyEffect(oBitmap, pEffect)
    }

    changeMcursor()
    E := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, 0, 0, zImgSelW, zImgSelH, imgSelPx, imgSelPy, imgSelW, imgSelH,, 2, imageAttribs)
    trGdip_DisposeImage(oBitmap, 1)
    If (E="fail")
    {
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DeleteGraphics(G2)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return rr
    }

    Sleep, 0
    If (editingSelectionNow=1 && ResizeCropAfterRotation=0 && ResizeWithCrop=1 && rotateAngle>0) || (rotateAngle>0 && editingSelectionNow!=1) || (rotateAngle>0 && ResizeWithCrop!=1)
       thumbBMP := coreRotateBMP(thumbBMP, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired)

    If (toClippy!=1 && FileExist(file2save))
       Try FileSetAttrib, -R, %file2save%

    Sleep, 0
    changeMcursor()
    If StrLen(thumbBMP)>3
    {
       If (toClippy=1)
       {
          hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, thumbBMP)
          r := hBitmap ? Gdip_SetBitmapToClipboard(thumbBMP, hBitmap) : addJournalEntry("get_last_err")
       } Else
          r := Gdip_SaveBitmapToFile(thumbBMP, file2save, userJpegQuality)

       If (toClippy!=1) && (r=-2 || r=-1)
          r := SaveFIMfile(file2save, thumbBMP)
    } Else r := "err"

    Gdip_DeleteGraphics(G2)
    Gdip_DisposeImageAttributes(imageAttribs)
    Gdip_DisposeEffect(pEffect)
    trGdip_DisposeImage(thumbBMP, 1)
    Return r
}

coreRotateBMP(whichBitmap, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired) {
    Static imgOrientOpt := {"i000":0, "i100":1, "i200":2, "i300":3, "i010":4, "i110":5, "i210":6, "i310":7, "i001":6, "i101":7, "i201":4, "i301":5, "i011":2, "i111":3, "i211":0, "i311":1}

    confirmSimpleRotation := (rotateAngle=0 || rotateAngle=90 || rotateAngle=180 || rotateAngle=270) ? 1 : 0
    If (confirmSimpleRotation=1)
    {
       imgFoperation := (rotateAngle=90) ? 1 : 0
       imgFoperation := (rotateAngle=180) ? 2 : imgFoperation
       imgFoperation := (rotateAngle=270) ? 3 : imgFoperation
       ; If (goFX=1 || ResizeApplyEffects=1)
       ;    imgFoperation := imgOrientOpt["i" imgFoperation FlipImgH FlipImgV]
       If (imgFoperation>0)
          Gdip_ImageRotateFlip(whichBitmap, imgFoperation)
       thumbBMP := whichBitmap
    } Else
    {
       whichBrush := (brushRequired=1) ? pBrushWinBGR : ""
       zBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, rotateAngle, whichBrush, thisImgQuality, pixFmt)
       If StrLen(zBitmap)>2
       {
          trGdip_DisposeImage(whichBitmap, 1)
          thumbBMP := zBitmap
       } Else thumbBMP := zBitmap
       ; If (goFX=1 || ResizeApplyEffects=1) && (ResizeCropAfterRotation=1)
       ;    flipBitmapAccordingToViewPort(thumbBMP, 1)
    }
    Return thumbBMP
}

flipBitmapAccordingToViewPort(whichBitmap, ignoreThis:=0) {
   imgOp := (FlipImgH=1) ? 4 : 0
   imgOp := (FlipImgV=1) ? 6 : imgOp
   imgOp := (FlipImgV=1 && FlipImgH=1) || (vpIMGrotation=180 && ignoreThis=0) ? 2 : imgOp
   If (imgOp>0 && whichBitmap)
      Gdip_ImageRotateFlip(whichBitmap, imgOp)
   Return whichBitmap
}

calcImgSelection2bmp(boundLess, imgW, imgH, newW, newH, ByRef imgSelPx, ByRef imgSelPy, ByRef imgSelW, ByRef imgSelH, ByRef zImgSelPx, ByRef zImgSelPy, ByRef zImgSelW, ByRef zImgSelH, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, usePrevious:=0, givenRotation:=0, givenCoords:=0) {
   If (usePrevious=1)
   {
      nImgSelX1 := min(prevImgSelX1, prevImgSelX2)
      nImgSelY1 := min(prevImgSelY1, prevImgSelY2)
      nImgSelX2 := max(prevImgSelX1, prevImgSelX2)
      nImgSelY2 := max(prevImgSelY1, prevImgSelY2)
   } Else
   {
      nImgSelX1 := min(imgSelX1, imgSelX2)
      nImgSelY1 := min(imgSelY1, imgSelY2)
      nImgSelX2 := max(imgSelX1, imgSelX2)
      nImgSelY2 := max(imgSelY1, imgSelY2)
   }

   If InStr(givenCoords, "|")
   {
      givenCoordsObj := StrSplit(givenCoords, "|")
      nImgSelX1 := min(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY1 := min(givenCoordsObj[2], givenCoordsObj[4])
      nImgSelX2 := max(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY2 := max(givenCoordsObj[2], givenCoordsObj[4])
   }

   If (boundLess=-1)
   {
      initialboundLess := boundLess
      boundLess := (A_PtrSize=4) ? 0 : 1
   }

   If (boundLess!=1)
   {
      If (nImgSelX1<0)
         nImgSelX1 := 0
      If (nImgSelY1<0)
         nImgSelY1 := 0

      If (nImgSelX2>imgW)
         nImgSelX2 := imgW
      If (nImgSelY2>imgH)
         nImgSelY2 := imgH
   }

   imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
   imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
   imgSelPx := min(nImgSelX1, nImgSelX2)
   imgSelPy := min(nImgSelY1, nImgSelY2)
   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(imgSelW, imgSelH, givenRotation, rimgSelW, rimgSelH)
      imgSelPx := imgSelPx - (rimgSelW - imgSelW)//2
      imgSelPy := imgSelPy - (rimgSelH - imgSelH)//2
      imgSelW := rimgSelW
      imgSelH := rimgSelH
      If (imgSelPx<1)
         imgSelPx := 0
      If (imgSelPy<1)
         imgSelPy := 0
      If (imgSelPx + imgSelW>imgW)
         imgSelW := imgW - imgSelPx
      If (imgSelPy + imgSelH>imgH)
         imgSelH := imgH - imgSelPy
   }

   If (imgSelW<2)
   {
      imgSelW := 2
      imgSelPx := (imgSelPx>=2) ? imgSelPx - 2 : 0
      nImgSelX2 := imgSelPx + imgSelW
   }

   If (imgSelH<2)
   {
      imgSelH := 2
      imgSelPy := (imgSelPy>=2) ? imgSelPy - 2 : 0
      nImgSelY2 := imgSelPy + imgSelH
   }

   nImgSelX1 := imgSelPx
   nImgSelY1 := imgSelPy

   zLv := newH/imgH
   zLh := newW/imgW
   zImgSelX1 := Floor(nImgSelX1*zLh)
   zImgSelY1 := Floor(nImgSelY1*zLv)
   zImgSelX2 := Floor(nImgSelX2*zLh)
   zImgSelY2 := Floor(nImgSelY2*zLv)
   If (boundLess!=1)
   {
      If (zImgSelX2>newW)
         zImgSelX2 := newW
      If (zImgSelY2>newH)
         zImgSelY2 := newH
   }

   zImgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   zImgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
   zImgSelPx := min(zImgSelX1, zImgSelX2)
   zImgSelPy := min(zImgSelY1, zImgSelY2)

   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(zimgSelW, zimgSelH, givenRotation, zrimgSelW, zrimgSelH)
      zimgSelPx := zimgSelPx - (zrimgSelW - zimgSelW)//2
      zimgSelPy := zimgSelPy - (zrimgSelH - zimgSelH)//2
      zimgSelW := zrimgSelW
      zimgSelH := zrimgSelH
      If (zimgSelPx<1)
         zimgSelPx := 0
      If (zimgSelPy<1)
         zimgSelPy := 0
      If (zimgSelPx + zimgSelW>newW)
         zimgSelW := newW - zimgSelPx
      If (zimgSelPy + zimgSelH>newH)
         zimgSelH := newH - zimgSelPy
   }

   If (zImgSelW<2)
   {
      zImgSelW := 2
      zImgSelPx := (zImgSelPx>=2) ? zImgSelPx - 2 : 0
   }

   If (zImgSelH<2)
   {
      zImgSelH := 2
      zImgSelPy := (zImgSelPy>=2) ? zImgSelPy - 2 : 0
   }

   If (initialboundLess=-1 && boundLess=0)
   {
      capSelectionRelativeCoords()
      imgSelX1 := X1, imgSelY1 := Y1
      imgSelX2 := X2, imgSelY2 := Y2
      SetTimer, dummyRefreshImgSelectionWindow, -100
   }
}

ResizePanelHelpBoxInfo() {
    msgBoxWrapper(appTitle ": HELP", "In «Advanced mode» there is limited support for color depths other than 24 and 32 bits. All images will be converted to 24 bits per pixel. If the alpha channel is present, the resulted file will be in 32 bits, if the format allows. When saving images in formats that do not support an alpha channel, the window background color is used.`n`nUse «Simple mode» to better preserve color depths or work with images larger than 530 MPx or than 32500 px [if the given file format allows it]. This mode supports 1-, 8-, 24-, 32-, 16- (UINT16), 48- (RGB16), 64- (RGBA16), 32- (FLOAT), 96- (RGBF) and 128- (RGBAF) bits images. High-dynamic range formats supported: .EXR, .HDR, .JXR, .HDP, .PFM and .TIFF.`n`nPlease also note, while there is full support for multi-frames/paged images [for GIFs and TIFFs only] in the viewport... on file (re)save or format conversion, only the first frame will be preserved.", -1, 0, 0)
}

OpenGitHub() {
  Static thisURL := "https://github.com/marius-sucan/Quick-Picto-Viewer"
  Try Run, % thisURL
  Catch wasError
        Sleep, 1

  If wasError
     msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the URL:`n" %thisURL%, 0, 0, "error")
}

drawViewportHelpMap() {
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    If (editingSelectionNow=1)
    {
       SetTimer, RemoveTooltip, Off
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xEE121212")
       thisThick := imgHUDbaseUnit//9
       Penuha := Gdip_CreatePen("0xEE445544", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x15EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x20778877)
       dotsSize := SelDotsSize
       thisW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
       thisH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
       thisX := min(selDotX, selDotAx) + dotsSize//2
       thisY := min(selDotY, selDotAy) + dotsSize//2

       Gdip_FillRectangle(2NDglPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisX, thisY, thisW, thisH)
       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfntSize*0.77)
       thisStylu := " x" thisX " y" thisY
       ERR := Gdip_TextToGraphics(2NDglPG, "Image selected area", thisFntSize thisStylu , "Arial", thisW, thisH)
       thisFntSize := "Bold cFFeeEEee s" Round(OSDfntSize*0.77)
       thisStylu := " x" OSDfntSize*2 " y" OSDfntSize*2
       ERR := Gdip_TextToGraphics(2NDglPG, "Current selection type: " DefineVPselAreaMode() ".`n `nDouble click on its edges to open a menu option.`n `nDouble click outside to drop the selection.`n `nCtrl + Wheel Up/Down to zoom in/out anywhere.", thisFntSize thisStylu , "Arial", mainWidth - OSDfntSize*2, mainHeight - OSDfntSize*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)
       r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
       toolTipGuiCreated := 2
    } Else If (TouchScreenMode=1)
    {
       SetTimer, RemoveTooltip, Off
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xEE121212")
       thisThick := imgHUDbaseUnit//10
       Penuha := Gdip_CreatePen("0x99334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x15EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x20778877)

       calculateTouchMargins(thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(2NDglPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(2NDglPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(2NDglPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_SetClipRect(2NDglPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(2NDglPG)
       Gdip_DrawRectangle(2NDglPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfntSize*0.77)
       thisStylu := " x" thisX " y" thisY
       ERR := Gdip_TextToGraphics(2NDglPG, "Image panning area.`n`nDouble click in this area to change how the image is adapted to the viewport.`n`nShift + Left-click to create a new selection area.`n`nOne-finger swipe gestures allowed when nothing to pan - outside this rectangle they are always allowed.`n`nCtrl + Wheel Up/Down to zoom in/out anywhere", thisFntSize thisStylu , "Arial", thisW, thisH)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfntSize*0.9)
       thisStylu := " x" thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom in", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x" thisX " y" thisY + thisH
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom out", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x1 y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Previous`nimage", thisFntSize thisStylu, "Arial", thisX, mainHeight)
       thisStylu := " x" thisW + thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Next`nimage", thisFntSize thisStylu, "Arial", thisX, mainHeight)
       r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
       toolTipGuiCreated := 2
    }
}

ShowContextualHelp() {
   If (drawingShapeNow=1)
   {
      msgu := "Current context: drawing a freeform shape.`nTo abandon, press Escape or Right-Click."
   } Else
   {
      If (AnyWindowOpen=24 || AnyWindowOpen=31)
         BtnHelpTransform()
      WinGetTitle, OutputVar , ahk_id %hSetWinGui%
      If (imgEditPanelOpened=1)
         moreInfo := "`nLive image editing tool"

      OutputVar := StrReplace(OutputVar, ": " appTitle)
      msgu := "Current tool: " OutputVar moreInfo
   }

   showTOOLtip(msgu)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

AboutWindow() {
    Global LViewOthers, listViewFilteru
    If (AnyWindowOpen || drawingShapeNow=1)
    {
       ShowContextualHelp()
       Return
    }

    thisBtnHeight := createSettingsGUI(1, A_ThisFunc)
    Gui, Add, Button, x1 y1 h1 w1 Default gBtnCloseWindow, Close
    Gui, -DPIScale
    Gui, Font, s19 Bold, Arial, -wrap
    Gui, Add, Picture, x+10 y+10 w150 Section h-1 +0x3 gOpenGitHub, qpv-icon.ico
    Gui, Add, Text, x+20 y15, %appTitle% v%appVersion%
    Gui, Font, s10 Bold, Arial, -wrap
    Gui, Add, Link, y+5 wp, Developed by <a href="http://marius.sucan.ro/">Marius Șucan</a>.
    Gui, Font
    Gui, Add, Link, y+10 wp, Based on the prototype image viewer by <a href="http://sites.google.com/site/littlescripting/">SBC</a> from October 2010 published on <a href="https://autohotkey.com/board/topic/58226-ahk-picture-viewer/">AHK forums</a>.
    lstWid := 450
    btnWid := 100
    txtWid := 440
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 250
       btnWid := btnWid + 50
       txtWid := txtWid + 190
       Gui, Font, s%LargeUIfontValue%
    }

    drawViewportHelpMap()
    IniAction(1, "appVersion", "General")
    If wasInitFIMlib
       thisVersion := " v" FreeImage_GetVersion()

    compiled := (A_IsCompiled=1) ? "Compiled. " : "Uncompiled. "
    compiled .= (A_PtrSize=8) ? "x64. " : "x32. "
    Gui, +DPIScale
    Gui, Add, Tab3, xs, General|Keyboard shortcuts|Command line|
    Gui, Tab, 1 ; general
    Gui, Font, Bold
    Gui, Add, Text, x+15 y+15 w%txtWid%, Current version: v%appVersion% from %vReleaseDate%. Internal AHK-H version: %A_AhkVersion%. %compiled%OS: %A_OSVersion%.
    Gui, Font, Normal
    Gui, Add, Text, y+10 w%txtWid%, Dedicated to people with really large image collections and slideshow needs :-).
    Gui, Add, Text, y+10 w%txtWid%, This application contains code from various entities. You can find more details in the source code.
    Gui, Add, Text, y+10 w%txtWid%, QPV uses GDI+ [Windows APIs] to display images and FreeImage%thisVersion% to load exotic file formats. FreeImage is licensed under the GNU General Public License, v2.0 (GPLv2) or v3.0 (GPLv3), and the FreeImage Public License (FIPL)

    Gui, Add, Link, y+10 w%txtWid%, To keep the development going, <a href="https://www.paypal.me/MariusSucan/10">please donate</a> or <a href="mailto:marius.sucan@gmail.com?subject=%appTitle% v%appVersion%">send me feedback</a>.
    Gui, Add, Link, y+10 w%txtWid%, New and previous versions are available on <a href="https://github.com/marius-sucan/Quick-Picto-Viewer">GitHub</a>.

    Gui, Tab, 2 ; keyboard 
    Gui, Add, ListView, x+15 y+15 w%lstWid% r10 Grid vLViewOthers, Keys|Action|Context|Opens
    Gui, Add, Combobox, xp y+10 wp gfilterListViewKbdsAbout +hwndhEditField vlistViewFilteru, \Files list|\Image view|\Image selection area|\Live editing|\Folder tree|\Freeform drawing|\Anywhere|\Panel|\Menu

    cmdHelp := "QPV can be invoked with command line arguments. Examples:`n`n1. Open a folder:`nqpv.exe ""fd=C:\example folder\tempus""`n`nAdd a pipe ""|"" after equal ""="" to NOT have images loaded recursively."
    cmdHelp .= "`n`n2. Call an internal function:`nqpv.exe call_ToggleThumbsMode() ""fd=C:\folder\tempus""`n`nThis will index all the images in the given folder and switch to thumbnails mode.`n`nOnly functions that need no parameters can be invoked. If multiple call_ are used, only the last valid one will be considered."
    cmdHelp .= "`n`nTo learn what functions you can call, check the Journal window in QPV. It names functions when opening panels or when errors occur. You can also enable debug mode, to gather more intel, or study the source code."
    cmdHelp .= "`n`n3. Specify user settings:`n`nqpv.exe set_IMGresizingMode=3 set_vpIMGrotation=45 ""C:\folder\this-image.png""`n"
    cmdHelp .= "`nYou can find available user settings in the quick-picto-viewer.ini file or by right-clicking on controls in the panels.`n`nYou can pass up to 950 arguments`n`nPass /qpv-debug argument to have QPV send debug information to a Win32 Debug Viewer.`n`nIf one .SLD file or one folder is passed as argument, any other image file passed as argument is ignored."

    Gui, Tab, 3 ; 
    Gui, Add, Edit, x+15 y+15 w%lstWid% r13 ReadOnly, %cmdHelp%

    Gui, Tab
    Gui, Add, Button, xs y+5 h%thisBtnHeight% w105 Default gBtnCloseWindow, &Close
    Gui, Add, Button, x+5 hp wp gPanelJournalWindow, &Journal
    If !A_IsAdmin
       Gui, Add, Button, x+5 hp gRunAdminMode, &Run in admin mode
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "About " appTitle " v" appVersion)
    PopulateAboutKbdShortcutsList()
}

PopulateAboutKbdShortcutsList(listFilter:=0) {
    EM_SETCUEBANNER(hEditField, "Filter keyboard shortcuts list", 0)
    startOperation := A_TickCount
    setImageLoading()
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    startZeit := A_TickCount
 
    FileRead, fileData, % mainCompiledPath "\help-keyboard-shortcuts.txt"
    startOperation := A_TickCount
    Loop, Parse, fileData, `n, `r
    {
        If (StrLen(A_LoopField)<5) || (listFilter && !InStr(A_LoopField, listFilter))
           Continue

        countThese++
        lineArru := StrSplit(A_LoopField, "|")
        LV_Add(A_Index, lineArru[1], lineArru[2], lineArru[3], lineArru[4])
    }

    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

filterListViewKbdsAbout() {
   GuiControlGet, listViewFilteru
   If (SubStr(listViewFilteru, 1, 1)="\" && StrLen(listViewFilteru)>3) 
      listViewFilteru := StrReplace(listViewFilteru, "\", "|")

   PopulateAboutKbdShortcutsList(listViewFilteru)
}

BtnChangeSatPlus() {
  ChangeSaturation(1)
}

BtnChangeSatMin() {
  ChangeSaturation(-1)
}

BtnChangeLumPlus() {
  ChangeLumos(1)
}

BtnChangeLumMin() {
  ChangeLumos(-1)
}

BtnChangeGammPlus() {
  ChangeGammos(1)
}

BtnChangeGammMin() {
  ChangeGammos(-1)
}

PanelsCheckFileExists() {
   If (currentFileIndex=0)
      Return 0

   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, fileNamu, folderu)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 0
   } Else Return 1
}

PanelResolutionSorting() {
   If AnyWindowOpen
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(20, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Choose resolution sort mode: " appTitle, "Each file will be read to identify the image resolution, in pixels.`n`nThis operation can take a lot of time with many files.", "&Sort list|&Histogram|&Cancel", 1, "image-file", "&Reverse order", 0, "Resolution (MPx)`f`fImage width`fImage height`fAspect ratio (W/H)`fImage DPI`fPages / frames", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "sort")
   {
      reverseOrderOnSort := msgResult.check
      IniAction(1, "reverseOrderOnSort", "General")
      ActSortImageProperties(msgResult.list)
   } Else If InStr(msgResult.btn, "histogram")
      PanelHistogramSorting()
}

PanelHistogramSorting() {
   Static hasAskedSort := 0
   If AnyWindowOpen
      Return

   If warnXPhistoSort()
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(45, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Choose image histogram sort mode: " appTitle, "Each image file will be read to extract its histogram data.`n`nThis operation can take a lot of time with many files.", "&Sort list|&Resolution|&Cancel", 1, "image-file", "&Reverse order", 0, "Average`f`fMedian`fPeak range`fMinimum range`f`Range`fMode`fMinimum`fRoot-mean square", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "sort")
   {
      good2go := 0
      If !hasAskedSort
      {
         msgResultu := msgBoxWrapper(appTitle ": Sort list", "Each file will be read to determine its histogram main points.`n`nAre you sure you want to sort the list in this mode? It can take a lot of time...", 4, 0, "question")
         If InStr(msgResultu, "yes")
            hasAskedSort := 1
      } Else good2go := 1
      If (good2go!=1 && hasAskedSort=0)
         Return

      reverseOrderOnSort := msgResult.check
      IniAction(1, "reverseOrderOnSort", "General")
      ActSortHistogram(msgResult.list)
   } Else If InStr(msgResult.btn, "resolution")
      PanelResolutionSorting()
}

PanelFindDupes() {
    Global userFindDupesSelectAllDummy := 0
    userFindDupesSelectAllDummy := 0
    Static hasOpened
    If !hasOpened
    {
       Global UIcheckimgfile := 0, UIcheckfcreated := 0, UIcheckfmodified := 0, UIcheckfsize := 0, UIcheckkbfsize := 0, UIcheckimgpixfmt := 0, UIcheckimgwidth := 0, UIcheckimgheight := 0, UIcheckimgmegapix := 0, UIcheckimgwhratio := 0, UIcheckimgframes := 0, UIcheckimghpeak := 0, UIcheckimghlow := 0
            , UIcheckimghrange := 0, UIcheckimgavg := 0, UIcheckimgmedian := 0, UIcheckimghrms := 0, UIcheckimghmode := 0, UIcheckimghminu := 0
       hasOpened := 1
    }

    If (maxFilesIndex<3 && !filesFilter)
    {
       showTOOLtip("WARNING: Insufficient indexed files to activate the list view mode")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (SLDtypeLoaded!=3)
    {
       msgResult := msgBoxWrapper(appTitle ": Confirmation", "The files list is currently not saved as a SQLite database. Would you like to save it in the specified format?", "&Yes|&Remove duplicate entries|&Cancel", 2, "question")
       If (msgResult="Yes")
          PanelSaveSlideShowu()
       Else If InStr(msgResult, "remove")
          cleanDeadFilesList("noFilesCheck")
       Return
    }

    thisBtnHeight := createSettingsGUI(49, A_ThisFunc, 1)
    btnWid := 100
    txtWid := 350
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 175
       Gui, Font, s%LargeUIfontValue%
    }

    col := (PrefsLargeFonts=1) ? 285 : 190
    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, General|Image fingerprints
    Gui, Tab, 1 ; general
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gBTNchangeDupesPreset AltSubmit Choose%userFindDupePresets% vuserFindDupePresets, Image content fingerprint (dHash 8x8)|Image histogram data|Image resolution and file size|Image histogram, resolution and file size|Identical file names|Identical file names and file sizes|Custom mode
    Gui, Add, Checkbox, xs y+7 w%col% -wrap gUIfindDupesChecksu Checked%UIcheckimgfile% vUIcheckimgfile, File name and its extension
    Gui, Add, Checkbox, x+7 gBTNselectAllFindDupesProperties Checked%userFindDupesSelectAllDummy% vuserFindDupesSelectAllDummy, &Select all
    Gui, Add, Text, x+3 vbtnFldr, Precision:
    Gui, Add, Edit, x+2 w50 number -multi limit1 veditF5, % findDupesPrecision
    Gui, Add, UpDown, vfindDupesPrecision Range1-5, % findDupesPrecision
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckfcreated% vUIcheckfcreated, Date created
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckfmodified% vUIcheckfmodified, Date modified
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckfsize% vUIcheckfsize, Size (bytes)
    Gui, Add, Checkbox, X+7 gUIfindDupesChecksu Checked%UIcheckkbfsize% vUIcheckkbfsize, Size (kilobytes)
    Gui, Add, Checkbox, xs y+17 w%col% gUIfindDupesChecksu Checked%UIcheckimgpixfmt% vUIcheckimgpixfmt, Image pixel format
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgframes% vUIcheckimgframes, Frames / pages
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgwidth% vUIcheckimgwidth, Width
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgheight% vUIcheckimgheight, Height
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgmegapix% vUIcheckimgmegapix, Megapixels
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgwhratio% vUIcheckimgwhratio, Aspect ratio (W/H)
    Gui, Add, Checkbox, xs y+17 w%col% gUIfindDupesChecksu Checked%UIcheckimghpeak% vUIcheckimghpeak, Histogram maximum (range)
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghlow% vUIcheckimghlow, Histogram minimum (range)
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimghrange% vUIcheckimghrange, Histogram total range
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgavg% vUIcheckimgavg, Histogram average
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgmedian% vUIcheckimgmedian, Histogram median
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghrms% vUIcheckimghrms, Histogram root-mean square
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimghmode% vUIcheckimghmode, Histogram mode
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghminu% vUIcheckimghminu, Histogram minimum

    fingWid := (PrefsLargeFonts=1) ? 170 : 100
    fingEdt := (PrefsLargeFonts=1) ? 70 : 50
    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 w%txtWid% Section vbtnFldr6, Image fingerprints are image 8x8 distance hashes. Below you can configure what sections of the image hashes to compare. The blue dots in the preview area highlight the areas of the images that will be compared. The less the 8x8 grid is complete, the more false-positives may be identified.
    Gui, -DPIScale
    Gui, Add, Text, xp y+15 Section w122 h122 +0x1000 +0xE +hwndhCropCornersPic, Image hashing preview
    Gui, +DPIScale
    Gui, Add, Checkbox, x+10 yp w%fingWid% Section gBTNchangeDupesPreset Checked%UIcheckinnerpixelz% vUIcheckinnerpixelz, Inner area
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF11, % hashInnerTrimLeft
    Gui, Add, UpDown, vhashInnerTrimLeft gBTNchangeDupesPreset Range0-9, % hashInnerTrimLeft
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF6, % hashInnerTrimRight
    Gui, Add, UpDown, vhashInnerTrimRight gBTNchangeDupesPreset Range0-9, % hashInnerTrimRight
    Gui, Add, Checkbox, xs y+7 w%fingWid% gBTNchangeDupesPreset Checked%UIcheckouterpixelz% vUIcheckouterpixelz, Borders
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF7, % hashOuterTrimLeft
    Gui, Add, UpDown, vhashOuterTrimLeft gBTNchangeDupesPreset Range0-9, % hashOuterTrimLeft
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF8, % hashOuterTrimRight
    Gui, Add, UpDown, vhashOuterTrimRight gBTNchangeDupesPreset Range0-9, % hashOuterTrimRight
    Gui, Add, Checkbox, xs y+7 w%fingWid% gBTNchangeDupesPreset Checked%UIcheckpixelzHash% vUIcheckpixelzHash, Simplified
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF9, % hashSimpleTrimLeft
    Gui, Add, UpDown, vhashSimpleTrimLeft gBTNchangeDupesPreset Range0-9, % hashSimpleTrimLeft
    Gui, Add, Edit, x+5 w%fingEdt% gBTNchangeDupesPreset number -multi limit1 veditF10, % hashSimpleTrimRight
    Gui, Add, UpDown, vhashSimpleTrimRight gBTNchangeDupesPreset Range0-9, % hashSimpleTrimRight

    Gui, Tab
    Gui, Add, Button, xm+15 y+20 h%thisBtnHeight% w%btnWid% Default gBTNfindDupesNow, &Find duplicates
    If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
       Gui, Add, Button, x+5 hp wp gBTNautoselectDupes, &Auto-select dupes
    Else
       Gui, Add, Button, x+5 hp wp gBtnCollectHistoInfos, Collect files &data
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNhelpFindDupes, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Find image duplicates: " appTitle)
    SetTimer, BTNchangeDupesPreset, -300
}

UIimageHashPreview() {
    Static uiboxSize := 122, dotu := 12
    GuiControlGet, UIcheckpixelzHash
    GuiControlGet, UIcheckinnerpixelz
    GuiControlGet, UIcheckouterpixelz
    GuiControlGet, hashInnerTrimLeft
    GuiControlGet, hashInnerTrimRight
    GuiControlGet, hashOuterTrimLeft
    GuiControlGet, hashOuterTrimRight
    GuiControlGet, hashSimpleTrimLeft
    GuiControlGet, hashSimpleTrimRight
    GuiControlGet, userFindDupePresets

    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, "0xE200B")
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    innerTrimL := hashInnerTrimLeft + 1
    innerTrimR := 36 - hashInnerTrimRight - hashInnerTrimLeft
    outerTrimL := hashOuterTrimLeft + 1
    outerTrimR := 28 - hashOuterTrimRight - hashOuterTrimLeft
    simpleTrimL := hashSimpleTrimLeft*2 + 1
    simpleTrimR := 64 - hashSimpleTrimRight*2 - hashSimpleTrimLeft*2
    opacityBr := (hashSimpleTrimLeft>0) ? "0x77" : "0xAA"

    red := Gdip_BrushCreateSolid(opacityBr "22FFAA")
    Gdip_GetImageDimensions(cornersBMP, imgW, imgH)
    If (UIcheckpixelzHash=1 || UIcheckinnerpixelz=1 || UIcheckouterpixelz=1) && (userFindDupePresets=7)
    {
       Gdip_FillRectangle(G, pBrushZ, 0, 0, imgW, imgH)
    } Else
    {
       Gdip_FillRectangle(G, pBrushA, 0, 0, imgW, imgH)
       Gdip_FillRectangle(G, pBrushA, 0, 0, imgW, imgH)
    }

    Loop, 8
    {
       If (userFindDupePresets!=7)
          Continue

       pY := A_Index - 1
       Loop, 8
       {
          pX := A_Index - 1
          allLoops++
          If (pY=0 || pY=7 || pX=0 || pX=7)
          {
             outLoops++
             If (isInRange(outLoops, outerTrimL, outerTrimR + outerTrimL - 1) && UIcheckouterpixelz=1)
                Gdip_FillRectangle(G, pBrushD, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)
   
             If (isInRange(outLoops, 1, 28 - hashSimpleTrimRight*2) && UIcheckpixelzHash=1)
                Gdip_FillEllipse(G, red, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)
          } Else
          {
             inLoops++
             If (isInRange(inLoops, innerTrimL, innerTrimR + innerTrimL - 1) && UIcheckinnerpixelz=1)
                Gdip_FillRectangle(G, pBrushD, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)

             If (!isInRange(inLoops, 0, simpleTrimL - 3) && UIcheckpixelzHash=1)
                Gdip_FillEllipse(G, red, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)
          }
       }
    }

    Gdip_DeleteBrush(red)
    Gdip_DeleteGraphics(G)
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)
    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    UIfindDupesChecksu()
    ; BTNchangeDupesPreset()
    Return er
}

BTNautoselectDupes() {
   BtnCloseWindow()
   PanelAutoSelectDupes()
}

UIfindDupesChecksu() {
   GuiControl, SettingsGUIA:, userFindDupesSelectAllDummy, 0
}

BTNchangeDupesPreset() {
   If (AnyWindowOpen=49)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, userFindDupePresets
   actu := (userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   actu2 := (userFindDupePresets=5 || userFindDupePresets=6) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, SettingsGUIA:, userFindDupesSelectAllDummy, 0
   GuiControl, % actu, userFindDupesSelectAllDummy
   GuiControl, % actu, btnFldr6
   GuiControl, % actu2, findDupesPrecision
   GuiControl, % actu2, editF5
   GuiControl, % actu2, btnFldr
   UIfindDupesCheckboxes(actu)
}

BTNselectAllFindDupesProperties() {
   GuiControlGet, userFindDupesSelectAllDummy
   UIfindDupesCheckboxes("SettingsGUIA:", userFindDupesSelectAllDummy)
}

UIfindDupesCheckboxes(hactu, v:="") {
   If (AnyWindowOpen=49)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControl, % hactu, UIcheckimgfile, %v%
   GuiControl, % hactu, UIcheckfcreated, %v%
   GuiControl, % hactu, UIcheckfmodified, %v%
   GuiControl, % hactu, UIcheckfsize, %v%
   GuiControl, % hactu, UIcheckkbfsize, %v%
   GuiControl, % hactu, UIcheckimgpixfmt, %v%
   GuiControl, % hactu, UIcheckimgwidth, %v%
   GuiControl, % hactu, UIcheckimgheight, %v%
   GuiControl, % hactu, UIcheckimgmegapix, %v%
   GuiControl, % hactu, UIcheckimgwhratio, %v%
   GuiControl, % hactu, UIcheckimgframes, %v%
   GuiControl, % hactu, UIcheckimghpeak, %v%
   GuiControl, % hactu, UIcheckimghlow, %v%
   GuiControl, % hactu, UIcheckimghrange, %v%
   GuiControl, % hactu, UIcheckimgavg, %v%
   GuiControl, % hactu, UIcheckimgmedian, %v%
   GuiControl, % hactu, UIcheckimghrms, %v%
   GuiControl, % hactu, UIcheckimghmode, %v%
   GuiControl, % hactu, UIcheckimghminu, %v%
   GuiControl, % hactu, UIcheckinnerpixelz, %v%
   GuiControl, % hactu, UIcheckouterpixelz, %v%
   GuiControl, % hactu, UIcheckpixelzHash, %v%

   GuiControlGet, UIcheckpixelzHash
   GuiControlGet, UIcheckinnerpixelz
   GuiControlGet, UIcheckouterpixelz
   GuiControlGet, userFindDupePresets
   actu := (UIcheckinnerpixelz=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, hashInnerTrimLeft
   GuiControl, % actu, hashInnerTrimRight
   GuiControl, % actu, editF11
   GuiControl, % actu, editF6
   actu := (UIcheckouterpixelz=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, hashOuterTrimLeft
   GuiControl, % actu, hashOuterTrimRight
   GuiControl, % actu, editF7
   GuiControl, % actu, editF8
   actu := (UIcheckpixelzHash=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, hashSimpleTrimLeft
   GuiControl, % actu, hashSimpleTrimRight
   GuiControl, % actu, editF9
   GuiControl, % actu, editF10
   If InStr(hactu, "able")
      UIimageHashPreview()
}

BTNfindDupesNow() {
   columnus := ""
   Gui, SettingsGUIA: Default
   GuiControlGet, findDupesPrecision
   GuiControlGet, hashInnerTrimLeft
   GuiControlGet, hashInnerTrimRight
   GuiControlGet, hashOuterTrimLeft
   GuiControlGet, hashOuterTrimRight
   GuiControlGet, hashSimpleTrimLeft
   GuiControlGet, hashSimpleTrimRight

   If GuiCtrlGet("UIcheckimgfile")
      columnus .= "imgfile,"

   If GuiCtrlGet("UIcheckfcreated")
      columnus .= "fcreated,"

   If GuiCtrlGet("UIcheckfmodified")
      columnus .= "fmodified,"

   If GuiCtrlGet("UIcheckfsize")
   {
      columnus .= "fsize,"
   } Else 
   {
      If GuiCtrlGet("UIcheckkbfsize")
         columnus .= "kbfsize,"
   }

   If GuiCtrlGet("UIcheckimgpixfmt")
      columnus .= "imgpixfmt,"

   If GuiCtrlGet("UIcheckimgwidth")
      columnus .= "imgwidth,"

   If GuiCtrlGet("UIcheckimgheight")
      columnus .= "imgheight,"

   If GuiCtrlGet("UIcheckimgmegapix")
      columnus .= "imgmegapix,"

   If GuiCtrlGet("UIcheckimgwhratio")
      columnus .= "imgwhratio,"

   If GuiCtrlGet("UIcheckimgframes")
      columnus .= "imgframes,"

   If GuiCtrlGet("UIcheckimghpeak")
      columnus .= "imghpeak,"

   If GuiCtrlGet("UIcheckimghlow")
      columnus .= "imghlow,"

   If GuiCtrlGet("UIcheckimghrange")
      columnus .= "imghrange,"

   If GuiCtrlGet("UIcheckimgavg")
      columnus .= "imgavg,"

   If GuiCtrlGet("UIcheckimgmedian")
      columnus .= "imgmedian,"

   If GuiCtrlGet("UIcheckimghrms")
      columnus .= "imghrms,"

   If GuiCtrlGet("UIcheckimghmode")
      columnus .= "imghmode,"

   If GuiCtrlGet("UIcheckimghminu")
      columnus .= "imghminu,"

   If GuiCtrlGet("UIcheckinnerpixelz")
      columnus .= "innerpixelz,"

   If GuiCtrlGet("UIcheckouterpixelz")
      columnus .= "outerpixelz,"

   If GuiCtrlGet("UIcheckpixelzHash")
      columnus .= "pixelzHash,"

   GuiControlGet, userFindDupePresets
   If (userFindDupePresets=1)
   {
      hashInnerTrimLeft := 1
      hashInnerTrimRight := 1
      hashOuterTrimLeft := 1
      hashOuterTrimRight := 1
      columnus := "innerpixelz,outerpixelz,imgframes,imgwhratio"
   } Else If (userFindDupePresets=2)
      columnus := "imgavg,imghpeak,imgmedian,imghlow,imghrange,imghmode,imgframes,imgwhratio"
   Else If (userFindDupePresets=3)
      columnus := "fsize,imgmegapix,imgwhratio,imgframes"
   Else If (userFindDupePresets=4)
      columnus := "kbfsize,imgframes,imgmegapix,imgwhratio,imgavg,imghpeak,imgmedian,imghlow"
   Else If (userFindDupePresets=5)
      columnus := "imgfile,imgframes"
   Else If (userFindDupePresets=6)
      columnus := "fsize,imgfile,imgframes"

   ; Gui, SettingsGUIA: Submit, NoHide
   ; ToolTip, % userFindDupePresets "==" columnus , , , 2
   columnus := Trimmer(columnus, ",")
   If !columnus
   {
      showTOOLtip("WARNING: No properties selected by which to identify duplicates.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   retrieveDupesByProperties(columnus, 0)
}

BTNhelpFindDupes() {
    msgBoxWrapper(appTitle ": HELP", "This panel offers you the possibility to identify duplicated images based on the collected file, image properties, fingerprints and histogram data points.`n`nPlease choose based on what criteria to identify possible image duplicates. The more properties you select the stricter the criteria for identifying image duplicates will be.`n`nThis functionality relies on collected data, please ensure you allow " appTitle " to scan the files.", -1, 0, 0)
}

GuiCtrlGet(varu) {
   GuiControlGet, %varu%
   x := %varu%
   Return x
}

PanelPurgeCachedSQLdata() {
   If (AnyWindowOpen=49)
   {
      reOpenIT := 1
      BtnCloseWindow()
   }

   If (AnyWindowOpen || SLDtypeLoaded!=3)
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(46, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Purge cached data: " appTitle, "Please choose what kind of cached data to erase from the files list database.", "&Purge|C&ancel", 1, "trash", 0, 0, "File details`f`fImage properties`fImage histograms`fAll`fAll (selected files only)", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "purge")
   {
      extraFilter := extractSQLqueryFromFilter()
      If extraFilter
         msgInfos := "`n`nThe purge will occur only for the files matching the current files list filter. To purge all the cached data, deactivate current filter."
 
      msgResultu := msgBoxWrapper(appTitle ": Purge cached data", "Please confirm you want to purge selected cached data from the database.`n`nThis data is used for sorting the files list much faster, identify image duplicates or to generate files list statistics." msgInfos, 4, 0, "question")
      If !InStr(msgResultu, "yes")
         Return

      If (msgResult.list=1)
         corePurgeCachedSQLdata("attributes")
      Else If (msgResult.list=2)
         corePurgeCachedSQLdata("resolution")
      Else If (msgResult.list=3)
         corePurgeCachedSQLdata("histogram")
      Else If (msgResult.list=4)
         corePurgeCachedSQLdata("all")
      Else If (msgResult.list=5)
         PurgeCachedDataSelectedFiles()
   }

   If (reOpenIT=1)
      PanelWrapperFilesStats()
}

corePurgeCachedSQLdata(mode) {
   setImageLoading()
   extraFilter := extractSQLqueryFromFilter()
   wherePart := extraFilter ? extraFilter " AND " : "WHERE"
   friendly := extraFilter ? "`nCurrent files list filter:`n" extraFilter : ""
   showTOOLtip("Purging cached data from the database, please wait" friendly)
   If (mode="attributes" || mode="all")
      SQLstr .= "UPDATE images SET fsize = NULL, fmodified = NULL, fcreated = NULL " wherePart " fsize IS NOT NULL; "
   If (mode="resolution" || mode="all")
      SQLstr .= "UPDATE images SET imgdpi = NULL, imgwidth = NULL, imgheight = NULL, imgframes = NULL, imgpixfmt = NULL " wherePart " imgwidth IS NOT NULL; "
   If (mode="histogram" || mode="all")
      SQLstr .= "UPDATE images SET imgavg = NULL, imgmedian = NULL, imghpeak = NULL, imghlow = NULL, imghminu = NULL, imghmode = NULL, imghrms = NULL, imghrange = NULL, pixelzHash = NULL, outerpixelz = NULL, innerpixelz = NULL " wherePart " imgavg IS NOT NULL;"

   If !activeSQLdb.Exec(SQLStr)
   {
      showTOOLtip("Failed to purge the cached data from the database:`n" activeSQLdb.ErrorMsg)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep 300, 100
   } Else SoundBeep 900, 100

   SetTimer, RemoveTooltip, -350
   SetTimer, ResetImgLoadStatus, -250
}

PurgeCachedDataSelectedFiles() {
   getSelectedFiles(0, 1)
   If !markedSelectFile
   {
      showTOOLtip("WARNING: No files are currently selected to perform given operation")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   If markedSelectFile
   {
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countTFiles++
         r := selectivePurgeCachedSQLdata(resultedFilesList[A_Index,12])
         If r
            failedFiles++
         Else
            countFiles++

         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(countTFiles, markedSelectFile, startOperation)
            If failedFiles
               etaTime .= "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

            showTOOLtip("Purging cached data for selected image files, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }
      }
   }

   If failedFiles
      someErrors := "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

   If (abandonAll=1)
   {
      showTOOLtip("Operation abandoned. Files processed: " groupDigits(countFiles) " out of " groupDigits(markedSelectFile) someErrors)
      SoundBeep, 300, 100
   } Else
   {
      showTOOLtip("Finished purging cached data for the selected files: " groupDigits(markedSelectFile) someErrors)
      SoundBeep, 900, 100
   }
  
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -150
}

selectivePurgeCachedSQLdata(dbIndex, batchMode:=0) {
   SQLstr := "UPDATE images SET innerpixelz = NULL, outerpixelz = NULL, pixelzHash = NULL, imgavg = NULL, imgmedian = NULL, imghmode = NULL, imghrms = NULL, imghminu = NULL, imghrange = NULL, imghpeak = NULL, imghlow = NULL, imgwidth = NULL, imgheight = NULL, imgframes = NULL, imgpixfmt = NULL, imgdpi = NULL, fsize = NULL, fmodified = NULL, fcreated = NULL WHERE imgidu=" dbIndex ";"
   If !activeSQLdb.Exec(SQLStr)
   {
      If (batchMode=1)
         Return "fail"
      Else
         addJournalEntry("Failed to purge the cached data in the database for given index: " dbIndex "`n" activeSQLdb.ErrorMsg)
   }
}

PanelJpegPerformOperation() {
    Global mainBtnACT

    If !PanelsCheckFileExists()
       Return

    filesElected := getSelectedFiles(0, 1)
    If (vpIMGrotation>0)
    {
       FlipImgV := FlipImgH := vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    } Else If (FlipImgH=1 || FlipImgV=1)
    {
       FlipImgV := FlipImgH := 0
       dummyTimerDelayiedImageDisplay(50)
    } 

    thisBtnHeight := createSettingsGUI(12, A_ThisFunc)
    btnWid := 110
    txtWid := slideWid := 280

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 100
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    If (editingSelectionNow!=1)
       jpegDoCrop := 0

    Gui, Add, Text, x15 y15 Section, Please choose a JPEG lossless operation...
    Gui, Add, DropDownList, y+10 Section w%txtWid% AltSubmit Choose%jpegDesiredOperation% vjpegDesiredOperation, None|Flip Horizontally|Flip Vertically|Transpose|Transverse|Rotate 90°|Rotate 180°|Rotate -90° [270°]
    Gui, Add, Checkbox, y+10 Checked%jpegDoCrop% vjpegDoCrop, Crop image(s) to selected area (irreversible)
    If (filesElected>1)
       Gui, Add, Text, y+20, %filesElected% files are selected.
    If (editingSelectionNow!=1)
       GuiControl, Disable, jpegDoCrop

    If (filesElected<2)
    {
       If (thumbsDisplaying!=1)
       {
          Gui, Add, Button, xs y+10 h%thisBtnHeight% w%btnWid% gBTNautoCropRealtime, &Auto-crop selection
          Gui, Add, Button, x+5 hp w%btnWid% gPanelImgAutoCrop, &Configure auto-crop
       }
       Gui, Add, Button, xs+0 y+25 h%thisBtnHeight% w35 gPreviousPicture, <<
       Gui, Add, Button, x+5 hp wp gNextPicture, >>
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnPerformJpegOp vmainBtnACT, &Perform operation
    } Else Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gBtnPerformJpegOp, &Perform operation
 
    Gui, Add, Button, x+5 hp w80 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "JPEG lossless operations: " appTitle)
}

BtnPerformJpegOp(dummy:=0) {
    Static lastInvoked := 1
    If (dummy!="extern")
    {
       Gui, SettingsGUIA: Default
       GuiControlGet, jpegDesiredOperation
       GuiControlGet, jpegDoCrop
       GuiControlGet, mainBtnACT
    }

    If (A_TickCount - lastInvoked < 150) || (jpegDesiredOperation=1 && jpegDoCrop=0)
    {
       showTOOLtip("WARNING: No operations selected to perform")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    initFIMGmodule()
    If !wasInitFIMlib
    {
       msgBoxWrapper(appTitle ": ERROR", "Unable to initialize the FreeImage library module.`n`nThis functionality is currently unavailable.", 0, 0, "error")
       Return
    }

    lastInvoked := A_TickCount
    ForceRefreshNowThumbsList()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       batchJpegLLoperations()
       Return
    } Else If (currIMGdetails.HasAlpha!=1)
    {
       destroyGDIfileCache()
       r := coreJpegLossLessAction(imgPath, jpegDesiredOperation, jpegDoCrop)
    }

    If (dummy!="extern")
    {
       GuiControl, SettingsGUIA: Disable, mainBtnACT
       SetTimer, reactivateMainBtnACT, -800
    }

    If r
    {
       resultedFilesList[currentFileIndex, 4] := 1
       FlipImgV := FlipImgH := vpIMGrotation := 0
       If (SLDtypeLoaded=3)
          selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])
       showTOOLtip("JPEG operation completed succesfully")
       RefreshImageFile()
    } Else
    {
       SoundBeep, 300, 100
       If (dummy!="extern")
          msgBoxWrapper(appTitle ": ERROR", "The JPEG operation has failed. The file might not be a JPEG as the file extension suggests.", 0, 0, "error")
       Else
          showTOOLtip("ERROR: The JPEG operation has failed. The file might not be a JPEG as the file extension suggests.")
    }

    lastInvoked := A_TickCount
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

reactivatemainBtnACT() {
    If (AnyWindowOpen=12 || AnyWindowOpen=18 || AnyWindowOpen=17)
    {
       If (imageLoading=1)
          SetTimer, reactivatemainBtnACT, -600
       Else
          GuiControl, SettingsGUIA: Enable, mainBtnACT
    }
}

batchJpegLLoperations() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && jpegDoCrop=1) || (filesElected>150)
   {
      msgInfos := (jpegDoCrop=1) ? "`n`nThe crop operation IS irreversible!" : ""
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to perform the JPEG transformations on the selected files? There are currently " filesElected " selected files. " msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
 
   BtnCloseWindow()
   Sleep, 25
   showTOOLtip("Performing JPEG lossless operations on " filesElected " files, please wait")
   prevMSGdisplay := A_TickCount
   failedFiles := countFilez := countTFilez := 0

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>3) ? 1 : 0
   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresJpegLL(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("File format conversion: failed to initialize multi-threaded processing")

   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   CurrentSLD := ""
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      If (InStr(file2rem, "||") || !file2rem)
         Continue
 
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFor " groupDigits(failedFiles) " files, the operations failed"
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip("Performing JPEG lossless operations, please wait" etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      If !RegExMatch(file2rem, "i)(.\.(jpeg|jpg|jpe))$")
      {
         skippedFiles++
         Continue
      }

      r := coreJpegLossLessAction(file2rem, jpegDesiredOperation, jpegDoCrop)
      If r
      {
         resultedFilesList[thisFileIndex, 4] := 1
         countFilez++
      } Else failedFiles++
   }

   CurrentSLD := backCurrentSLD
   If (failedFiles>0)
      someErrors := "`nFor " groupDigits(failedFiles) " files, the operations failed"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip(countFilez " out of " groupDigits(countTFilez) " selected JPEG files were processed" someErrors)

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return
}

coreJpegLossLessAction(imgPath, jpegOperation, mustCrop) {
    FileGetTime, originalMtime, % imgPath, M
    FileGetTime, originalCtime, % imgPath, C
    FileSetAttrib, -R, %imgPath%
    Sleep, 1
    changeMcursor()
    If (mustCrop=1 && editingSelectionNow=1) || (mustCrop=1 && hasInitSpecialMode=1)
    {
       r1 := GetImgFileDimension(imgPath, imgW, imgH)
       If (relativeImgSelCoords=1)
          calcRelativeSelCoords("--", imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       x1 := Round(X1), y1 := Round(Y1)
       x2 := Round(X2), y2 := Round(Y2)
       changeMcursor()
       r := FreeImage_JPEGTransformCombined(imgPath, imgPath, jpegOperation - 1, X1, Y1, X2, Y2)
    } Else
    {
       Sleep, -1
       r := FreeImage_JPEGTransform(imgPath, imgPath, jpegOperation - 1)
    }

    If originalMtime
    {
       Sleep, 0
       FileSetTime, % originalMtime, % imgPath, M
       FileSetTime, % originalCtime, % imgPath, C
    }
    Return r
}

toggleImgEditPanelWindow(dummy:="") {
   Static Width := 0, Height := 0, lastInvoked := A_TickCount
   If (AnyWindowOpen!=10 && imgEditPanelOpened!=1 && dummy!="forced") || (A_TickCount - lastInvoked<350)
      Return

   ; WinGetPos, , , nWidth, nHeight, ahk_id %hSetWinGui%
   thisHeight := imgHUDbaseUnit//4 + 2
   thisWidth := imgHUDbaseUnit//2 + 2
   ; If (Width<nWidth-5) || (Height<nHeigh-5)
   ;    panelWinCollapsed := 1

   If (panelWinCollapsed=0)
   {
      Gui, SettingsGUIA: Show, NoActivate w%thisWidth% h%thisHeight%
      Gui, SettingsGUIA: -SysMenu
      WinActivate, ahk_id %PVhwnd%
      WinSet, Transparent, 190, ahk_id %hSetWinGui%
      WinSet, Style, -0xC00000, ahk_id %hSetWinGui%
      ; WinGetPos, , , Width, Height, ahk_id %hSetWinGui%
      ; WinSet, Disable,, ahk_id %hSetWinGui%
      panelWinCollapsed := 1
   } Else 
   {
      WinSet, Transparent, 255, ahk_id %hSetWinGui%
      WinSet, Style, +0xC00000, ahk_id %hSetWinGui%
      Gui, SettingsGUIA: Show, AutoSize
      Gui, SettingsGUIA: +SysMenu
      ; WinSet, Enable,, ahk_id %hSetWinGui%
      panelWinCollapsed := 0
   }
   lastInvoked := A_TickCount
   interfaceThread.ahkassign("panelWinCollapsed", panelWinCollapsed)
}

PanelColorsAdjusterWindow() {
    Global sliderBright, sliderContrst, sliderSatu, realTimePreview, CustomZoomCB, infoImgZoom, infolummyAdjust
         , infoBright, infoContrst, infoSatu, BtnLumPlus, BtnLumMin, BtnFlipH, infoZatAdjust, UIvpImgAlignCenter
         , BtnGammPlus, BtnGammMin, BtnSatPlus, BtnSatMin, ResizeModeDL, BtnFlipV, infohueAdjust
         , infoRGBchnls, RGBcbList := "-3.0|-2.0|-1.5|-1.0|-0.9|-0.8|-0.7|-0.6|-0.5|-0.4|-0.3|-0.2|-0.1|0.0|0.1|0.2|0.3|0.4|0.5|0.6|0.7|0.8|0.9|1.0|1.5|2.0|3.0"
         , infoRealGammos, infoThreshold, UIimgThreshold, UIrealGammos, infoImgRotation, UIdoubleZoom

    If (thumbsDisplaying=1 || StrLen(gdiBitmap)<4 || openingPanelNow=1)
       Return

    ; If (editingSelectionNow=1)
    ;    toggleImgSelection()
    openingPanelNow := 1
    setImageLoading()
    showTOOLtip("Opening colors adjustments panel, please wait")
    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(10, A_ThisFunc)
    ForceNoColorMatrix := 0
    If (usrColorDepth=0)
       usrColorDepth := 1

    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 180
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       slide2Wid := slide2Wid + 65
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    thisZL := Round(zoomLevel*100) "%"
    UIdoubleZoom := (zoomLevel>4.99) ? 1 : 0
    UIimgThreshold := imgThreshold*100
    UIrealGammos := (realGammos<=1.001) ? realGammos*200 : ((realGammos+5)*100)/3
    UIvpImgAlignCenter := (imageAligned=5) ? 1 : 0
    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, Color matrix|More adjustments|Other options
    Gui, Tab, 1 ; general
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%imgFxMode% vimgFxMode, Original image colors|Personalized colors|Auto-adjusted colors|Grayscale|Red channel|Green channel|Blue channel|Alpha channel|Inverted colors|Sepia
    Gui, Add, DropDownList, xs y+5 w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%autoAdjustMode% vAutoAdjustMode, Adaptive mixed mode|Increase brightness|Increase contrast
    Gui, Add, ComboBox, x+1 w90 gColorPanelTriggerImageUpdate vusrAdaptiveThreshold, -2000|-100|-50|-2|1|2|50|1000|2000|%usrAdaptiveThreshold%||
    Gui, Add, Checkbox, xs y+2 w%txtWid% gColorPanelTriggerImageUpdate Checked%doSatAdjusts% vdoSatAdjusts, Auto-adjust image saturation level
    Gui, Add, Checkbox, x+5 w90 gColorPanelTriggerImageUpdate Checked%bwDithering% vbwDithering, B/W
    Gui, Add, Text, xs y+8 w%txtWid% gBtnResetBrightness vinfoBright, Brightness: ----
    Gui, Add, Slider, y+5 AltSubmit ToolTip NoTicks w%slideWid% gColorPanelTriggerImageUpdate vsliderBright Range-100-100, 1
    Gui, Add, Button, x+1 hp w45 gBtnChangeLumPlus vBtnLumPlus, +
    Gui, Add, Button, x+1 hp wp gBtnChangeLumMin vBtnLumMin, -
    Gui, Add, Text, xs y+2 w%txtWid% gBtnResetContrast vinfoContrst, Contrast: ----
    Gui, Add, Slider, y+1 AltSubmit ToolTip NoTicks w%slideWid% gColorPanelTriggerImageUpdate vsliderContrst Range-100-100, 1
    Gui, Add, Button, x+1 hp w45 gBtnChangeGammPlus vBtnGammPlus, -
    Gui, Add, Button, x+1 hp wp gBtnChangeGammMin vBtnGammMin, +
    Gui, Add, Text, xs y+2 w%txtWid% gBtnResetSaturation vinfoSatu, Saturation: ----
    Gui, Add, Slider, y+5 AltSubmit ToolTip NoTicks w%slideWid% gColorPanelTriggerImageUpdate vsliderSatu Range-100-100, 1
    Gui, Add, Button, x+1 hp w45 gBtnChangeSatPlus vBtnSatPlus, +
    Gui, Add, Button, x+1 hp w45 gBtnChangeSatMin vBtnSatMin, -
    Gui, Add, Text, xs y+2 w%slide2Wid% gBtnResetRealGamma vinfoRealGammos, Gamma: ----
    Gui, Add, Text, x+5 w%slide2Wid% gBtnResetThreshold vinfoThreshold, Threshold: ----
    Gui, Add, Slider, xs y+2 AltSubmit NoTicks ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vUIrealGammos Range1-500, % UIrealGammos
    Gui, Add, Slider, x+5 AltSubmit NoTicks ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vUIimgThreshold Range0-100, % UIimgThreshold
    ; Gui, Add, Checkbox, xs y+15 gColorPanelTriggerImageUpdate Checked%realTimePreview% vrealTimePreview, Update image in real time
    Gui, Add, Text, xs y+8 gBtnResetCHNdec vinfoRGBchnls, RGBA channels balance:
    Gui, Add, ComboBox, x+5 w65 gColorPanelTriggerImageUpdate vchnRdecalage, %RGBcbList%|%chnRdecalage%||
    Gui, Add, ComboBox, x+5 wp gColorPanelTriggerImageUpdate vchnGdecalage, %RGBcbList%|%chnGdecalage%||
    Gui, Add, ComboBox, x+5 wp gColorPanelTriggerImageUpdate vchnBdecalage, %RGBcbList%|%chnBdecalage%||
    Gui, Add, ComboBox, x+5 wp gColorPanelTriggerImageUpdate vIntensityAlphaChannel, 0|0.25|0.5|0.75|1|2|5|10|20|30|%IntensityAlphaChannel%||

    slide3wid := slide2wid - 42
    Gui, Tab, 2 ; more
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%specialColorFXmode% vspecialColorFXmode, None|Blur|Sharpen|Brightness / Contrast|Hue / Saturation / Lightness|Levels adjust|Color tint|Colors balance|Color curve per channel
    Gui, Add, DropDownList, xs y+2 w%slide3Wid% gColorPanelTriggerImageUpdate AltSubmit Choose%uiColorCurveFXmode% vuiColorCurveFXmode, Brightness (density)|Contrast|Highlights|Shadows|Mid-tones|White saturation|Black saturation
    Gui, Add, DropDownList, x+2 wp gColorPanelTriggerImageUpdate AltSubmit Choose%uiColorCurveFXchannel% vuiColorCurveFXchannel, Red|Green|Blue|Apply on all channels

    Gui, Add, Text, xs y+10 w%slideWid% gBtnResetHue vinfohueAdjust, Hue: ----
    Gui, Add, Slider, xs y+2 wp AltSubmit ToolTip gColorPanelTriggerImageUpdate vhueAdjust Range-300-300, % hueAdjust
    Gui, Add, Text, xs y+10 wp gBtnResetVibrance vinfoZatAdjust, Vibrance: ----
    Gui, Add, Slider, xs y+2 wp AltSubmit ToolTip gColorPanelTriggerImageUpdate vzatAdjust Range-300-300, % zatAdjust
    Gui, Add, Text, xs y+10 wp gBtnResetLummy vinfolummyAdjust, Lightness: ----
    Gui, Add, Slider, xs y+2 wp AltSubmit ToolTip gColorPanelTriggerImageUpdate vlummyAdjust Range-300-300, % lummyAdjust

    Gui, Tab, 3 ; others
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%IMGresizingMode% vIMGresizingMode, Adapt all images into view|Adapt only large images into view|Original resolution (100`%)|Custom zoom level|Stretched to window size
    Gui, Add, Checkbox, x+5 gColorPanelTriggerImageUpdate Checked%UIvpImgAlignCenter% vUIvpImgAlignCenter, Centered
    Gui, Add, DropDownList, xs y+5 w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%usrColorDepth% vusrColorDepth, Simulate color depth|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]
    Gui, Add, Checkbox, x+5 gColorPanelTriggerImageUpdate Checked%ColorDepthDithering% vColorDepthDithering, Dithering
    Gui, Add, Text, xs y+10 w%slide2Wid% gBtnResetRotation vinfoImgRotation, Image rotation: ----
    Gui, Add, Checkbox, x+5 gColorPanelTriggerImageUpdate Checked%UIdoubleZoom% vUIdoubleZoom, 2x
    Gui, Add, Text, x+1 w%slide2Wid% gBtnResetZoom vinfoImgZoom, Image zoom: ----
    Gui, Add, Slider, xs y+10 ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vvpIMGrotation Range0-360, % Round(vpIMGrotation)
    Gui, Add, Slider, x+5 ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vCustomZoomCB Range1-500, % thisZL
    Gui, Add, Text, xs y+10 h%thisBtnHeight% +0x200, Flip viewport:
    Gui, Add, Checkbox, x+10 +0x1000 hp gColorPanelTriggerImageUpdate Checked%FlipImgV% vFlipImgV, vertically
    Gui, Add, Checkbox, x+5 +0x1000 hp gColorPanelTriggerImageUpdate Checked%FlipImgH% vFlipImgH, horizontally
    Gui, Add, Text, xs y+10, Display histogram:
    Gui, Add, DropDownList, x+10 w%btnWid% gColorPanelTriggerImageUpdate AltSubmit Choose%showHistogram% vshowHistogram, None|Luminance|Red|Green|Blue|All mixed
    Gui, Add, DropDownList, x+6 w%btnWid% gColorPanelTriggerImageUpdate AltSubmit Choose%histogramMode% vhistogramMode, Lows|Balanced|Peaks
    Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%userimgQuality% vuserimgQuality, High quality image resampling
    Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%usrTextureBGR% vusrTextureBGR, Auto-generated ambiental textured viewport background
    Gui, Add, Checkbox, xs y+10 gToggleAutoResetImageView Checked%resetImageViewOnChange% vresetImageViewOnChange, Deactivate and reset image adjustments on image file change
    ; Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%showHistogram% vshowHistogram, Display the image luminance histogram
    Gui, Add, Text, xs y+10, TIP: right click on the viewport for more options.

    Gui, Tab
    Gui, Add, Button, xs-10 y+15 h%thisBtnHeight% w35 gBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gBtnNextImg, >>
    Gui, Add, Button, x+5 hp wp gtoggleImgEditPanelWindow, ▲
    ; Gui, Add, Button, x+5 hp w%btnWid% gCopyImage2clip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid% gBtnSaveIMGadjustPanel, &Save or copy
    Gui, Add, Button, x+5 hp wp-25 gBtnResetImageView, &Reset all
    ; Gui, Add, Button, x+5 hp w80 Default gBtnCloseWindow, C&lose
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Adjust viewport image view: " appTitle, winPos)
    Sleep, 1
    updatePanelColorsInfo()
    updatePanelColorSliderz()
    SetTimer, resetOpeningPanel, -300
    SetTimer, RemoveTooltip, -100
    SetTimer, ResetImgLoadStatus, -50
}

resetOpeningPanel() {
    openingPanelNow := 0
}

BtnResetBrightness() {
  lumosAdjust := lumosGrayAdjust := 1
  GuiControl, SettingsGUIA:, infoBright, Brightness: 1.000
  GuiControl, SettingsGUIA:, sliderBright, 1
  INIaction(1, "lumosAdjust", "General")
  INIaction(1, "lumosGrayAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetContrast() {
  GammosAdjust := GammosGrayAdjust := 0
  GuiControl, SettingsGUIA:, infoContrst, Contrast: 0.000
  GuiControl, SettingsGUIA:, sliderContrst, 0
  INIaction(1, "GammosAdjust", "General")
  INIaction(1, "GammosGrayAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetSaturation() {
  satAdjust := 1
  GuiControl, SettingsGUIA:, infoSatu, Saturation: 1.000
  GuiControl, SettingsGUIA:, sliderSatu, 0
  INIaction(1, "satAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetVibrance() {
  zatAdjust := 0
  GuiControl, SettingsGUIA:, infoZatAdjust, 0
  GuiControl, SettingsGUIA:, zatAdjust, 0
  INIaction(1, "zatAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetLummy() {
  lummyAdjust := 0
  GuiControl, SettingsGUIA:, infoLummyAdjust, 0
  GuiControl, SettingsGUIA:, lummyAdjust, 0
  INIaction(1, "lummyAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetHue() {
  thisValue := (specialColorFXmode=6) ? 100 : 0
  hueAdjust := thisValue
  GuiControl, SettingsGUIA:, infohueAdjust, % thisValue
  GuiControl, SettingsGUIA:, hueAdjust, % thisValue
  INIaction(1, "hueAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetRealGamma() {
  realGammos := 1
  GuiControl, SettingsGUIA:, infoRealGammos, Gamma: 1.000 
  GuiControl, SettingsGUIA:, UIrealGammos, 200
  INIaction(1, "realGammos", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetThreshold() {
  imgThreshold := 0
  GuiControl, SettingsGUIA:, infoThreshold, Threshold: 0
  GuiControl, SettingsGUIA:, UIimgThreshold, 0
  INIaction(1, "imgThreshold", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetCHNdec() {
  chnRdecalage := chnGdecalage := chnBdecalage := 0.0
  IntensityAlphaChannel := 1
  GuiControl, SettingsGUIA: Choose, chnRdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnGdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnBdecalage, 14
  GuiControl, SettingsGUIA: Choose, IntensityAlphaChannel, 5
  INIaction(1, "chnRdecalage", "General")
  INIaction(1, "chnGdecalage", "General")
  INIaction(1, "chnBdecalage", "General")
  INIaction(1, "IntensityAlphaChannel", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetZoom() {
  zoomLevel := 1
  GuiControl, SettingsGUIA:, UIdoubleZoom, 0
  GuiControl, SettingsGUIA:, infoImgZoom, Image zoom: 100 `%
  GuiControl, SettingsGUIA:, CustomZoomCB, 100
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetRotation() {
  If (vpIMGrotation=0)
     Return

  vpIMGrotation := 0
  GuiControl, SettingsGUIA:, vpIMGrotation, 0
  GuiControl, SettingsGUIA:, infoImgRotation, Image rotation: 0°
  GuiControl, SettingsGUIA: Enable, usrTextureBGR
  INIaction(1, "vpIMGrotation", "General")
  RefreshImageFile()
}

BtnSaveIMGadjustPanel() {
   ForceNoColorMatrix := 0
   CloseWindow()
   dummyTimerDelayiedImageDisplay(50)
   PanelSaveImg()
}

BtnNextImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  NextPicture()
  If (imgFxMode=3)
  {
     updatePanelColorsInfo()
     updatePanelColorSliderz()
  }
}

BtnPrevImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  PreviousPicture()
  If (imgFxMode=3)
  {
     updatePanelColorsInfo()
     updatePanelColorSliderz()
  }
}

updatePanelColorSliderz() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 100)
   {
      SetTimer, % A_ThisFunc, -110
      Return
   }

   If (AnyWindowOpen=10)
      Gui, SettingsGUIA: Default
   Else
      Return

   ; GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   If (imgFxMode=1 || imgFxMode=2 || imgFxMode=3)
   {
      infoSliderBright := (lumosAdjust>1) ? Floor((lumosAdjust - 1)/14*100) : - Floor((1 - lumosAdjust)*100)
      infoSliderContrst := (GammosAdjust<0) ? Floor(Abs(GammosAdjust)/15*100) : - Floor((Abs(GammosAdjust))*100)
      infoSliderSatu := (satAdjust>1) ? Floor((satAdjust - 1)/2*100) : - Floor((1 - satAdjust)*100)
      UIrealGammos := (realGammos<=1.001) ? realGammos*200 : ((realGammos+5)*100)/3
      GuiControl, SettingsGUIA:, sliderSatu, % infoSliderSatu 
      GuiControl, SettingsGUIA:, sliderBright, % infoSliderBright
      GuiControl, SettingsGUIA:, sliderContrst, % infoSliderContrst
      GuiControl, SettingsGUIA:, UIrealGammos, % UIrealGammos
   } Else If (imgFxMode=4)
   {
      infoSliderBright := (lumosGrayAdjust>1) ? Floor((lumosGrayAdjust - 1)/14*100) :  - Floor((1 - lumosGrayAdjust)*100)
      infoSliderContrst := (GammosGrayAdjust<0) ? Floor(Abs(GammosGrayAdjust)/15*100) : - Floor((Abs(GammosGrayAdjust))*100)
      GuiControl, SettingsGUIA:, sliderBright, % infoSliderBright
      GuiControl, SettingsGUIA:, sliderContrst, % infoSliderContrst
      GuiControl, SettingsGUIA:, sliderSatu, 0
   }

   GuiControl, SettingsGUIA:, UIvpImgAlignCenter, % (imageAligned=5) ? 1 : 0
   lastInvoked := A_TickCount
}

updatePanelColorsInfo() {
   Static colorzFXinfoz := 0, colorzFXminz := 0, colorzFXmaxz := 0
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 100)
   {
      SetTimer, % A_ThisFunc, -110
      Return
   }

   If (AnyWindowOpen=10)
      Gui, SettingsGUIA: Default
   Else
      Return

   If !IsObject(colorzFXinfoz)
   {
      colorzFXinfoz := []
      colorzFXinfoz[1] := ["-", "-", "-"]
      colorzFXinfoz[2] := ["Blur radius", "-", "-"]
      colorzFXinfoz[3] := ["Sharpen radius", "Sharpen amount", "-"]
      colorzFXinfoz[4] := ["Brightness", "Contrast", "-"]
      colorzFXinfoz[5] := ["Hue", "Saturation", "Lightness"]
      colorzFXinfoz[6] := ["Highlights", "Midtones", "Shadows"]
      colorzFXinfoz[7] := ["Hue", "Amount", "-"]
      colorzFXinfoz[8] := ["Cyan / Red", "Magenta / Green", "Yellow / Blue"]
      colorzFXinfoz[9] := ["-", "-", "Amount"]
      colorzFXminz := []
      colorzFXminz[1] := [-300, -300, -300]
      colorzFXminz[2] := [0, -300, -300]
      colorzFXminz[3] := [0, 0, -300]
      colorzFXminz[4] := [-255, -100, -300]
      colorzFXminz[5] := [-180, -100, -100]
      colorzFXminz[6] := [0, -100, 0]
      colorzFXminz[7] := [-180, 0, -300]
      colorzFXminz[8] := [-100, -100, -100]
      colorzFXminz[9] := [-300, -300, -100]
      colorzFXmaxz := []
      colorzFXmaxz[1] := [300, 300, 300]
      colorzFXmaxz[2] := [255, 300, 300]
      colorzFXmaxz[3] := [255, 100, 300]
      colorzFXmaxz[4] := [255, 100, 300]
      colorzFXmaxz[5] := [180, 100, 100]
      colorzFXmaxz[6] := [100, 100, 100]
      colorzFXmaxz[7] := [180, 100, 300]
      colorzFXmaxz[8] := [100, 100, 100]
      colorzFXmaxz[9] := [300, 300, 100]
   }

   GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   GuiControlGet, imgFxMode, SettingsGUIA:, imgFxMode
   GuiControlGet, IMGresizingMode, SettingsGUIA:, IMGresizingMode
   GuiControlGet, bwDithering, SettingsGUIA:, bwDithering
   thisMinA := colorzFXminz[specialColorFXmode, 1]
   thisMinB := colorzFXminz[specialColorFXmode, 2]
   thisMinC := colorzFXminz[specialColorFXmode, 3]
   thisMaxA := colorzFXmaxz[specialColorFXmode, 1]
   thisMaxB := colorzFXmaxz[specialColorFXmode, 2]
   thisMaxC := colorzFXmaxz[specialColorFXmode, 3]
   If (specialColorFXmode=9 && uiColorCurveFXmode=1)
   {
      thisMaxC := 255
      thisMinC := -255
   } Else If (specialColorFXmode=9 && uiColorCurveFXmode>=6)
   {
      thisMaxC := 255
      thisMinC := 0
   }

   GuiControl, SettingsGUIA: +Range%thisMinA%-%thisMaxA%, hueAdjust
   GuiControl, SettingsGUIA: +Range%thisMinB%-%thisMaxB%, zatAdjust
   GuiControl, SettingsGUIA: +Range%thisMinC%-%thisMaxC%, lummyAdjust

   infolumosAdjust := (imgFxMode=4) ? Round(lumosGrayAdjust, 3) : Round(lumosAdjust, 3)
   infoGammosAdjust := (imgFxMode=4) ? Round(GammosGrayAdjust, 3) : Round(GammosAdjust, 3)
   infoSatAdjust := Round(satAdjust, 3)
   infoZoom := Round(zoomLevel*100)
   GuiControl, SettingsGUIA:, infoBright, % "Brightness: " infolumosAdjust
   GuiControl, SettingsGUIA:, infoContrst, % "Contrast: " infoGammosAdjust
   GuiControl, SettingsGUIA:, infoSatu, % "Saturation: " infoSatAdjust
   GuiControl, SettingsGUIA:, infoRealGammos, % "Gamma: " realGammos
   GuiControl, SettingsGUIA:, infoThreshold, % "Threshold: " imgThreshold
   GuiControl, SettingsGUIA:, infoImgZoom, % "Image zoom: " infoZoom " %"
   GuiControl, SettingsGUIA:, infoImgRotation, % "Image rotation: " vpIMGrotation "° "

   GuiControl, SettingsGUIA:, infohueAdjust, % colorzFXinfoz[specialColorFXmode, 1] ": " hueAdjust
   GuiControl, SettingsGUIA:, infoZatAdjust, % colorzFXinfoz[specialColorFXmode, 2] ": " zatAdjust
   GuiControl, SettingsGUIA:, infoLummyAdjust, % colorzFXinfoz[specialColorFXmode, 3] ": " lummyAdjust

   If (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270)
      GuiControl, SettingsGUIA: Enable, usrTextureBGR
   Else
      GuiControl, SettingsGUIA: Disable, usrTextureBGR

   If (usrColorDepth>1)
      GuiControl, SettingsGUIA: Enable, ColorDepthDithering
   Else
      GuiControl, SettingsGUIA: Disable, ColorDepthDithering

   act := (IMGresizingMode=4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, CustomZoomCB
   GuiControl, % act, UIdoubleZoom
   GuiControl, % act, infoImgZoom

   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   act := (imgFxMode=2) || (imgFxMode=4 && o_bwDithering=0) || (imgFxMode=9) || (imgFxMode=10) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, infoRealGammos
   GuiControl, % act, UIrealGammos

   If (IMGresizingMode=5)
      GuiControl, SettingsGUIA: Disable, usrTextureBGR
   Else
      GuiControl, SettingsGUIA: Enable, usrTextureBGR

   If (IMGresizingMode=5)
      GuiControl, SettingsGUIA: Disable, UIvpImgAlignCenter
   Else
      GuiControl, SettingsGUIA: Enable, UIvpImgAlignCenter

   If (imgFxMode=2)
   {
      GuiControl, SettingsGUIA: Enable, sliderSatu
      GuiControl, SettingsGUIA: Enable, sliderBright
      GuiControl, SettingsGUIA: Enable, sliderContrst
      GuiControl, SettingsGUIA: Enable, BtnLumPlus
      GuiControl, SettingsGUIA: Enable, BtnLumMin
      GuiControl, SettingsGUIA: Enable, BtnGammPlus
      GuiControl, SettingsGUIA: Enable, BtnGammMin
      GuiControl, SettingsGUIA: Enable, BtnSatPlus
      GuiControl, SettingsGUIA: Enable, BtnSatMin
      GuiControl, SettingsGUIA: Enable, infoBright
      GuiControl, SettingsGUIA: Enable, infoContrst
      GuiControl, SettingsGUIA: Enable, infoSatu
   } Else If (imgFxMode=4 && o_bwDithering=0)
   {
      GuiControl, SettingsGUIA: Enable, infoBright
      GuiControl, SettingsGUIA: Enable, infoContrst
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Enable, sliderBright
      GuiControl, SettingsGUIA: Enable, sliderContrst
      GuiControl, SettingsGUIA: Disable, sliderSatu
      GuiControl, SettingsGUIA: Enable, BtnLumPlus
      GuiControl, SettingsGUIA: Enable, BtnLumMin
      GuiControl, SettingsGUIA: Enable, BtnGammPlus
      GuiControl, SettingsGUIA: Enable, BtnGammMin
      GuiControl, SettingsGUIA: Disable, BtnSatPlus
      GuiControl, SettingsGUIA: Disable, BtnSatMin
   } Else
   {
      GuiControl, SettingsGUIA: Disable, infoBright
      GuiControl, SettingsGUIA: Disable, infoContrst
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Disable, BtnLumPlus
      GuiControl, SettingsGUIA: Disable, BtnLumMin
      GuiControl, SettingsGUIA: Disable, BtnGammPlus
      GuiControl, SettingsGUIA: Disable, BtnGammMin
      GuiControl, SettingsGUIA: Disable, BtnSatPlus
      GuiControl, SettingsGUIA: Disable, BtnSatMin
      GuiControl, SettingsGUIA: Disable, sliderSatu
      GuiControl, SettingsGUIA: Disable, sliderBright
      GuiControl, SettingsGUIA: Disable, sliderContrst
   }

   If (imgFxMode=4)
      GuiControl, SettingsGUIA: Enable, bwDithering
   Else
      GuiControl, SettingsGUIA: Disable, bwDithering

   act := (imgFxMode=2 || imgFxMode=3 || imgFxMode=4 || imgFxMode=9 || imgFxMode=10) && (o_bwDithering=0) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, zatAdjust
   GuiControl, % act, infoZatAdjust
   GuiControl, % act, hueAdjust
   GuiControl, % act, infohueAdjust
   GuiControl, % act, lummyAdjust
   GuiControl, % act, infoLummyAdjust
   GuiControl, % act, specialColorFXmode
   GuiControl, % act, UIimgThreshold
   GuiControl, % act, infoThreshold
   GuiControl, % act, IntensityAlphaChannel
   canEnableThese := InStr(act, "enable") ? 1 : 0

   act := (specialColorFXmode=9 && canEnableThese=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, uiColorCurveFXmode
   GuiControl, % act, uiColorCurveFXchannel

   act := (imgFxMode=2 || imgFxMode=3) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, infoRGBchnls
   GuiControl, % act, chnRdecalage
   GuiControl, % act, chnGdecalage
   GuiControl, % act, chnBdecalage

   act := (imgFxMode=3) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, autoAdjustMode
   GuiControl, % act, usrAdaptiveThreshold
   GuiControl, % act, doSatAdjusts

   If (colorzFXinfoz[specialColorFXmode, 1]="-")
   {
      GuiControl, SettingsGUIA: Disable, infohueAdjust
      GuiControl, SettingsGUIA: Disable, hueAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infohueAdjust
      GuiControl, SettingsGUIA: Enable, hueAdjust
   }

   If (colorzFXinfoz[specialColorFXmode, 2]="-")
   {
      GuiControl, SettingsGUIA: Disable, infoZatAdjust
      GuiControl, SettingsGUIA: Disable, zatAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infoZatAdjust
      GuiControl, SettingsGUIA: Enable, zatAdjust
   }

   If (colorzFXinfoz[specialColorFXmode, 3]="-")
   {
      GuiControl, SettingsGUIA: Disable, infoLummyAdjust
      GuiControl, SettingsGUIA: Disable, lummyAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infoLummyAdjust
      GuiControl, SettingsGUIA: Enable, lummyAdjust
   }

   lastInvoked := A_TickCount
}

btnResetImageView() {
  ; GuiControlGet, realTimePreview
   If (AnyWindowOpen=10)
      Gui, SettingsGUIA: Default
   Else
      Return

  ForceNoColorMatrix := 0
  GuiControl, SettingsGUIA: Choose, imgFxMode, 1
  GuiControl, SettingsGUIA: Choose, usrColorDepth, 1
  GuiControl, SettingsGUIA: Choose, usrAdaptiveThreshold, 5
  GuiControl, SettingsGUIA: Choose, chnRdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnGdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnBdecalage, 14
  GuiControl, SettingsGUIA: Choose, IntensityAlphaChannel, 5
  GuiControl, SettingsGUIA: Choose, IMGresizingMode, 1
  GuiControl, SettingsGUIA: Choose, specialColorFXmode, 1
  GuiControl, SettingsGUIA:, bwDithering, 0
  ColorDepthDithering := usrColorDepth := IMGresizingMode := imgFxMode := satAdjust := lumosAdjust := lumosGrayAdjust := specialColorFXmode := IntensityAlphaChannel := 1
  vpIMGrotation := zatAdjust := hueAdjust := GammosAdjust := GammosGrayAdjust := 0
  chnRdecalage := chnGdecalage := chnBdecalage := 0.0
  updatePanelColorsInfo()
  UIrealGammos := 200
  realGammos := usrAdaptiveThreshold := infoBright := infoSatu := 1
  bwDithering := infoContrst := sliderSatu := sliderBright := sliderContrst := 0
  FlipImgV := FlipImgH := usrTextureBGR := vpIMGrotation := UIimgThreshold := imgThreshold := 0

  GuiControl, SettingsGUIA:, infoBright, Brightness: 1.009
  GuiControl, SettingsGUIA:, infoContrst, Contrast: 0.000
  GuiControl, SettingsGUIA:, infoSatu, Saturation: 1.000
  GuiControl, SettingsGUIA:, infoThreshold, Threshold: 0.00
  GuiControl, SettingsGUIA:, infoRealGammos, Gamma: 1.00
  GuiControl, SettingsGUIA:, hueAdjust, 0
  GuiControl, SettingsGUIA:, zatAdjust, 0
  GuiControl, SettingsGUIA:, UIrealGammos, 200
  GuiControl, SettingsGUIA:, UIimgThreshold, 0
  GuiControl, SettingsGUIA:, sliderSatu, 0
  GuiControl, SettingsGUIA:, sliderBright, 0
  GuiControl, SettingsGUIA:, sliderContrst, 0
  GuiControl, SettingsGUIA:, vpIMGrotation, 0
  GuiControl, SettingsGUIA:, usrTextureBGR, 0
  GuiControl, SettingsGUIA:, FlipImgV, 0
  GuiControl, SettingsGUIA:, FlipImgH, 0
  GuiControl, SettingsGUIA:, ColorDepthDithering, 1
  interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
  defineColorDepth()
  SetTimer, WriteSettingsColorAdjustments, -90
  dummyTimerDelayiedImageDisplay(50)
}

ColorPanelTriggerImageUpdate(dummy:=0) {
   Critical, On
   If (AnyWindowOpen=10)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, imgFxMode
   GuiControlGet, usrAdaptiveThreshold
   GuiControlGet, doSatAdjusts
   GuiControlGet, autoAdjustMode
   GuiControlGet, showHistogram
   GuiControlGet, sliderBright
   GuiControlGet, sliderContrst
   GuiControlGet, sliderSatu
   GuiControlGet, bwDithering
   GuiControlGet, UIvpImgAlignCenter
   GuiControlGet, FlipImgV
   GuiControlGet, FlipImgH
   GuiControlGet, CustomZoomCB
   GuiControlGet, chnRdecalage
   GuiControlGet, chnGdecalage
   GuiControlGet, chnBdecalage
   GuiControlGet, IntensityAlphaChannel
   GuiControlGet, zatAdjust
   GuiControlGet, hueAdjust
   GuiControlGet, lummyAdjust
   GuiControlGet, uiColorCurveFXchannel
   GuiControlGet, uiColorCurveFXmode
   GuiControlGet, specialColorFXmode
   GuiControlGet, UIimgThreshold
   GuiControlGet, UIrealGammos
   GuiControlGet, userimgQuality
   GuiControlGet, vpIMGrotation
   GuiControlGet, UIdoubleZoom
   GuiControlGet, usrTextureBGR
   GuiControlGet, usrColorDepth
   GuiControlGet, ColorDepthDithering
   GuiControlGet, histogramMode

   ; GuiControlGet, realTimePreview
   If (dummy!="ignore-zoom")
   {
      GuiControlGet, IMGresizingMode, SettingsGUIA:, IMGresizingMode
      imageAligned := (UIvpImgAlignCenter=1) ? 5 : 1
      zoomLevel := (UIdoubleZoom=1) ? (2*CustomZoomCB)/100 + 2 : CustomZoomCB/100
   }

   defineColorDepth()
   ForceNoColorMatrix := 0
   If (vpIMGrotation=1 || vpIMGrotation>358)
      vpIMGrotation := 0

   imgThreshold := Round(UIimgThreshold/100, 3)
   If (imgFxMode!=3 && imgFxMode!=1)
      realGammos := (UIrealGammos>200) ? Round((UIrealGammos*3 - 500)/100, 3) : Round(UIrealGammos/200, 3)

   If (imgFxMode=2)
   {
      lumosAdjust := (sliderBright>0) ? 0.14*sliderBright + 1 : 0.01*Abs(sliderBright + 100)
      GammosAdjust := (sliderContrst>0) ? -0.14*sliderContrst : 0.01*Abs(sliderContrst)
      satAdjust := (sliderSatu>0) ? 0.02*sliderSatu + 1 : 0.01*Abs(sliderSatu + 100)
   } Else If (imgFxMode=4)
   {
      lumosGrayAdjust := (sliderBright>0) ? 0.14*sliderBright + 1 : 0.01*Abs(sliderBright + 100)
      GammosGrayAdjust := (sliderContrst>0) ? -0.14*sliderContrst : 0.01*Abs(sliderContrst)
   }

   If (imgFxMode=3)
   {
      imgPath := getIDimage(currentFileIndex)
      AdaptiveImgLight(useGdiBitmap(), imgPath, 1, 1)
      updatePanelColorSliderz()
   }

   If (imgFxMode!=4)
   {
      GuiControl, SettingsGUIA:, bwDithering, 0
      bwDithering := 0
   }

   If (prevvpIMGrotation!=vpIMGrotation)
   {
      mustReloadIMG := 1
      prevvpIMGrotation := vpIMGrotation
   }

   updatePanelColorsInfo()
   filterDelayiedImageDisplay()
   SetTimer, WriteSettingsColorAdjustments, -150
}

PanelFileFormatConverter() {
    Global btnFldr, IDbtnConvert, editF5
    filesElected := getSelectedFiles(0, 1)
    thisBtnHeight := createSettingsGUI(15, A_ThisFunc)
    btnWid := 110
    txtWid := 280
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    initFIMGmodule()
    ReadSettingsFormatConvert()
    Gui, Add, Text, x15 y15 Section, Destination format:
    Gui, Add, DropDownList, x+10 w85 gTglDesiredSaveFormat AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, .BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM
    Gui, Add, Text, xs y+10, On file name conflicts
    Gui, Add, DropDownList, x+5 w150 AltSubmit gTglOverwriteFiles Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    Gui, Add, Checkbox, xs y+10 gTglKeepOriginals Checked%OnConvertKeepOriginals% vOnConvertKeepOriginals, &Keep original file[s]
    Gui, Add, Checkbox, y+7 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder:
    Gui, Add, Edit, xp+10 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    If (filesElected>1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, Files selected to convert: %filesElected%.
       Gui, Font, Normal
    } 

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Add, Button, xs y+15 h%thisBtnHeight% w90 gBTNconvertNow Default vIDbtnConvert, &Convert
    Gui, Add, Button, x+5 hp wp gBTNconvertHelp, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file format conversion: " appTitle)
}

BTNconvertHelp() {
    msgBoxWrapper(appTitle ": HELP", "File format conversion relies primarly on the FreeImage library.`n`nOn conversion, images will be converted to 24 bits or 32 bits.`n`nFailures can occur if the images are very large (above 250 MPx) and the destination format does not allow such large images, if there is insufficient system memory or... if file access is denied when attempting to write files.`n`nQuality option applies for JPG, JP2, J2K, JXR and WEBP file formats.", -1, 0, 0)
}

TglKeepOriginals() {
    GuiControlGet, OnConvertKeepOriginals
    INIaction(1, "OnConvertKeepOriginals", "General")
}

TglOverwriteFiles() {
    GuiControlGet, userActionConflictingFile
    INIaction(1, "userActionConflictingFile", "General")
}

TglDesiredSaveFormat() {
    GuiControlGet, userDesireWriteFMT
    INIaction(1, "userDesireWriteFMT", "General")
}

BTNconvertNow() {
   If (AnyWindowOpen=15)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, ResizeDestFolder
   GuiControlGet, OnConvertKeepOriginals
   GuiControlGet, userActionConflictingFile
   GuiControlGet, userDesireWriteFMT
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality

   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   If (!RegExMatch(rDesireWriteFMT, "i)(bmp|png|tiff|tif|gif|jpg|jpeg)$") && wasInitFIMlib!=1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "The ." rDesireWriteFMT " format is currently unsupported. The FreeImage library failed to properly initialize.", 0, 0, "error")
      Return
   }

   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "ResizeDestFolder", "General")
   INIaction(1, "OnConvertKeepOriginals", "General")
   INIaction(1, "PreserveDateTimeOnSave", "General")
   INIaction(1, "userActionConflictingFile", "General")
   INIaction(1, "userDesireWriteFMT", "General")
   If (markedSelectFile>1)
   {
      CloseWindow()
      batchConvert2format()
   } Else convert2format()
}

PanelAdjustImageCanvasSize() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight
         , userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter

    If (thumbsDisplaying=1 || AnyWindowOpen)
       Return

    thisBtnHeight := createSettingsGUI(28, A_ThisFunc)
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "ResizeKeepAratio", "General", 1)
    INIaction(0, "ResizeInPercentage", "General", 1)
    INIaction(0, "adjustCanvasCentered", "General", 1)
    INIaction(0, "adjustCanvasMode", "General", 1)
    INIaction(0, "adjustCanvasNoBgr", "General", 1)
    INIaction(0, "FillAreaColor", "General", 3)
    INIaction(0, "FillAreaOpacity", "General", 2, 1, 255)

    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    r1 := Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    If r1
    {
       CloseWindow()
       SoundBeep, 300, 100
       showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    Gui, Add, Text, x15 y15 Section, Original image size: %oImgW% x %oImgH% pixels.
    Gui, Add, Edit, x15 y15 w1 r1 limit7 -multi -wrap, -
    Gui, Add, Text, xs y+10, Set new canvas dimensions (W x H):
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit7 -multi number -wrap gEditResizeWidth vuserEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 limit7 -multi number -wrap gEditResizeHeight vuserEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, Use `% percentages
    Gui, Add, Checkbox, xs+15 y+5 hp gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp Checked%adjustCanvasCentered% vadjustCanvasCentered, Centered image

    Gui, Add, Text, xs y+15, Resulted dimensions and background color:
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled -wrap vResultEditWidth, % oImgW
    Gui, Add, Edit, x+5 wp r1 Disabled -wrap vResultEditHeight, % oImgH
    Gui, Add, ListView, x+5 wp hp %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, ComboBox, x+5 wp vFillAreaOpacity, 25|50|75|100|150|200|255|%FillAreaOpacity%||
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P

    Gui, Add, Checkbox, xs y+10 hp Checked%adjustCanvasNoBgr% vadjustCanvasNoBgr gupdateUIadjustCanvasPanel, Transparent background 
    Gui, Add, Checkbox, xs y+10 Section hp Checked%adjustCanvasMode% vadjustCanvasMode gupdateUIadjustCanvasPanel, Add margins to current image dimensions:
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled +0x0800, -
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddTop, 0
    Gui, Add, Edit, x+5 wp r1 Disabled +0x0800, -

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddLeft, 0
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddCenter, 0
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddRight, 0

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled +0x0800, -
    Gui, Add, Edit, x+5 w%editWid% r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddBottom, 0
    Gui, Add, Edit, x+5 wp r1 Disabled +0x0800, -

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% gBTNadjustCanvasAction Default, &Adjust canvas
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Adjust image canvas size: " appTitle)
    updateUIadjustCanvasPanel()
}

EditCanvasMargins() {
   If (AnyWindowOpen=28)
      Gui, SettingsGUIA: Default
   Else
      Return

   GuiControlGet, userAddTop
   GuiControlGet, userAddBottom
   GuiControlGet, userAddCenter
   GuiControlGet, userAddLeft
   GuiControlGet, userAddRight
   If (!userAddTop || userAddTop<0)
      userAddTop := 0
   If (!userAddBottom || userAddBottom<0)
      userAddBottom := 0
   If (!userAddCenter || userAddCenter<0)
      userAddCenter := 0
   If (!userAddLeft || userAddLeft<0)
      userAddLeft := 0
   If (!userAddRight || userAddRight<0)
      userAddRight := 0

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   thisWidth := oImgW + userAddLeft + userAddRight + userAddCenter
   thisHeight := oImgH + userAddTop + userAddBottom + userAddCenter
   GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
   GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
}

updateUIadjustCanvasPanel() {
    If (AnyWindowOpen=28)
       Gui, SettingsGUIA: Default
    Else
       Return

    GuiControlGet, adjustCanvasNoBgr
    GuiControlGet, adjustCanvasMode

    If (adjustCanvasMode=1)
    {
       EditCanvasMargins()
       GuiControl, SettingsGUIA: Disable, ResizeKeepAratio
       GuiControl, SettingsGUIA: Disable, ResizeInPercentage
       GuiControl, SettingsGUIA: Disable, adjustCanvasCentered
       GuiControl, SettingsGUIA: Disable, userEditHeight
       GuiControl, SettingsGUIA: Disable, userEditWidth
       GuiControl, SettingsGUIA: Enable, userAddCenter
       GuiControl, SettingsGUIA: Enable, userAddTop
       GuiControl, SettingsGUIA: Enable, userAddBottom
       GuiControl, SettingsGUIA: Enable, userAddLeft
       GuiControl, SettingsGUIA: Enable, userAddRight
    } Else
    {
       EditResizeWidth()
       GuiControl, SettingsGUIA: Disable, userAddCenter
       GuiControl, SettingsGUIA: Disable, userAddTop
       GuiControl, SettingsGUIA: Disable, userAddBottom
       GuiControl, SettingsGUIA: Disable, userAddLeft
       GuiControl, SettingsGUIA: Disable, userAddRight
       GuiControl, SettingsGUIA: Enable, ResizeKeepAratio
       GuiControl, SettingsGUIA: Enable, ResizeInPercentage
       GuiControl, SettingsGUIA: Enable, adjustCanvasCentered
       GuiControl, SettingsGUIA: Enable, userEditHeight
       GuiControl, SettingsGUIA: Enable, userEditWidth
    }

    If (adjustCanvasNoBgr=1)
    {
       GuiControl, SettingsGUIA: Disable, FillAreaColor
       GuiControl, SettingsGUIA: Disable, FillAreaOpacity
    } Else
    {
       GuiControl, SettingsGUIA: Enable, FillAreaColor
       GuiControl, SettingsGUIA: Enable, FillAreaOpacity
    }

    INIaction(1, "adjustCanvasMode", "General")
    INIaction(1, "adjustCanvasNoBgr", "General")
}

BTNadjustCanvasAction() {
    Gui, SettingsGUIA: Default
    GuiControlGet, adjustCanvasCentered
    GuiControlGet, adjustCanvasNoBgr
    GuiControlGet, adjustCanvasMode
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, FillAreaOpacity
    GuiControlGet, userAddTop
    GuiControlGet, userAddBottom
    GuiControlGet, userAddCenter
    GuiControlGet, userAddLeft
    GuiControlGet, userAddRight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResultEditWidth

    If (!userAddTop || userAddTop<0)
       userAddTop := 0
    If (!userAddBottom || userAddBottom<0)
       userAddBottom := 0
    If (!userAddCenter || userAddCenter<0)
       userAddCenter := 0
    If (!userAddLeft || userAddLeft<0)
       userAddLeft := 0
    If (!userAddRight || userAddRight<0)
       userAddRight := 0

    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    If (ResultEditWidth=oImgW && ResultEditHeight=oImgH)
    {
       showTOOLtip("WARNING: The new dimension is equal with the initial one")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    If (ResultEditWidth*ResultEditHeight>maxGDIbmpSize) || (ResultEditWidth>32500) || (ResultEditHeight>32500)
    {
       showTOOLtip("ERROR: The document dimensions exceed the maximum limits")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    INIaction(1, "ResizeKeepAratio", "General")
    INIaction(1, "ResizeInPercentage", "General")
    INIaction(1, "adjustCanvasMode", "General")
    INIaction(1, "adjustCanvasCentered", "General")
    INIaction(1, "adjustCanvasNoBgr", "General")
    INIaction(1, "FillAreaColor", "General")
    FillAreaOpacity := Trimmer(FillAreaOpacity)
    FillAreaOpacity := StrReplace(FillAreaOpacity, "%")
    FillAreaOpacity := StrReplace(FillAreaOpacity, A_Space)
    If !isNumber(FillAreaOpacity)
       FillAreaOpacity := 255

    clampInRange(FillAreaOpacity, 5, 255)
    INIaction(1, "FillAreaOpacity", "General")
  
    CloseWindow()
    ToggleEditImgSelection("show-edit")
    ChangeImageCanvasSize(ResultEditWidth, ResultEditHeight, userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter, 0)
}

PanelResizeImageWindow() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight, btnFldr, editF5

    ToolTip, Please wait...
    filesElected := getSelectedFiles(0, 1)
    multipleFilesMode := (filesElected>1) ? 1 : 0
    If (multipleFilesMode=0 && !PanelsCheckFileExists())
    {
       ToolTip
       Return
    }

    thisBtnHeight := createSettingsGUI(4, A_ThisFunc)
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsImageProcessing()
    img2resizePath := getIDimage(currentFileIndex)
    If (multipleFilesMode=0)
    {
       zPlitPath(img2resizePath, 0, fileNamu, folderu)
       r1 := GetImgFileDimension(img2resizePath, oImgW, oImgH)
       FileGetSize, fileSizu, % img2resizePath, K
       If !r1
       {
          BtnCloseWindow()
          showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
          SoundBeep, 300, 100
          img2resizePath := ""
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    } Else
    {
       oImgW := ResolutionWidth
       oImgH := ResolutionHeight
    }

    initFIMGmodule()
    If (editingSelectionNow!=1)
       ResizeWithCrop := 0

    If (resetImageViewOnChange=1)
       ResizeApplyEffects := 0

    Gui, Add, Tab3, , General|File(s) destination
    Gui, Tab, 1
    If (multipleFilesMode=1)
    {
       Gui, Add, Text, x+15 y+15 Section, Resize image to (W x H)
    } Else
    {
       Gui, Add, Text, x+15 y+15 Section, Original image dimensions:
       Gui, Add, Text, xs+15 y+5, %oImgW% x %oImgH% pixels. %fileSizu% kilobytes.
       Gui, Add, Text, xs y+10, Resize image to (W x H)
    }

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeWidth vuserEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeHeight vuserEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 wp+30 hp +0x1000 gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `% perc.
    If (multipleFilesMode!=1)
       Gui, Add, Text, xs y+15, Result (W x H) in pixels
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled -wrap vResultEditWidth, % (multipleFilesMode=1) ? "--" : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 Disabled -wrap vResultEditHeight, % (multipleFilesMode=1) ? "--" : oImgH
    thisRotation := (vpIMGrotation=0) ? ResizeRotationUser : vpIMGrotation
    otherRotation := (vpIMGrotation=thisRotation) ? ResizeRotationUser : vpIMGrotation
    Gui, Add, ComboBox, x+5 wp+30 gTglRszRotation vResizeRotationUser, Rotate: 0°|45°|90°|135°|180°|225°|270°|315°|%thisRotation%°||%otherRotation%°
    Gui, Add, Checkbox, xs y+10 hp +0x1000 gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp +0x1000 gTglRszQualityHigh Checked%ResizeQualityHigh% vResizeQualityHigh, High quality resampling
    Gui, Add, Checkbox, xs y+10 gTglRszCropping Checked%ResizeWithCrop% vResizeWithCrop, Crop image(s) to the viewport selection
    Gui, Add, Checkbox, xp+10 y+10 gTglRszCropping Checked%ResizeCropAfterRotation% vResizeCropAfterRotation, Perform image crop after image rotation (as in the viewport)
    Gui, Add, Checkbox, xs y+10 gTglRszApplyEffects Checked%ResizeApplyEffects% vResizeApplyEffects, Apply color adjustments and image mirroring`nactivated in the main window

    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15, If no destination folder is chosen,`nthe original files may be overwritten.
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the following folder
    Gui, Add, Edit, xp+15 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs y+7 , On file name conflicts
    Gui, Add, DropDownList, x+5 w150 gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    If (multipleFilesMode=1)
    {
       Gui, Add, DropDownList, xs y+10 w%txtWid% gTglRszUnsprtFrmt AltSubmit Choose%userUnsprtWriteFMT% vuserUnsprtWriteFMT, Skip files in unsupported write formats|Try to preserve file formats, convert unsupported to...|Convert all the files to...
       Gui, Add, DropDownList, xs y+5 w85 AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, .BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM
       Gui, Add, Button, x+5 hp w85 gResizePanelHelpBoxInfo, Help
    }

    If (resetImageViewOnChange=1)
       GuiControl, Disable, ResizeApplyEffects

    If (editingSelectionNow!=1)
    {
       GuiControl, Disable, ResizeWithCrop
       GuiControl, Disable, ResizeCropAfterRotation
    }

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Tab
    If (multipleFilesMode=1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs-15 y+10, %filesElected% files are selected for processing.`nMulti-threaded processing not yet implemented.
       Gui, Font, Normal
       Gui, Add, Button, xp y+10 h%thisBtnHeight% w%btnWid% Default gBTNsaveResizedIMG, &Process images
       Gui, Add, Button, x+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       If (userUnsprtWriteFMT=1)
          GuiControl, SettingsGUIA: Disable, userDesireWriteFMT
    } Else
    {
       Gui, Add, Button, xs-15 y+20 h%thisBtnHeight% w%btnWid% gBtnCopy2ClipResizedIMG, &Copy to clipboard
       Gui, Add, Button, x+5 hp wp Default gBTNsaveResizedIMG, &Save image as...
       Gui, Add, Button, xs-15 y+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       Gui, Add, Button, x+5 hp w85 gResizePanelHelpBoxInfo, Help
    }
    ToolTip
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / rotate / crop image(s): " appTitle)
}

BtnInvokePanelSimpleResizeRotate() {
   BtnCloseWindow()
   Sleep, 25
   PanelSimpleResizeRotate("forced")
}

BTNchangeResizeDestFolder() {
   If (AnyWindowOpen=4)
      EditResizeWidth()

   SelectImg := openFoldersDialogWrapper("S2", ResizeDestFolder)
   OutDir := Trimmer(SelectImg)
   If !FolderExist(OutDir)
   {
      WinActivate, ahk_id %hSetWinGui%
      Return
   } Else
   {
      GuiControl, SettingsGUIA:, ResizeDestFolder, % OutDir
      ResizeDestFolder := OutDir
      INIaction(1, "ResizeDestFolder", "General")
   }
}

setForceRefreshThumbsFilesIndex(onlySelected) {
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1 && onlySelected=1)
         Continue

      resultedFilesList[A_Index, 4] := 1
   }
   ForceRefreshNowThumbsList()
}

batchIMGresizer(desiredW, desiredH, isPercntg, dontAsk:=0) {
   cleanResizeUserOptionsVars()
   If (!desiredH || !desiredW
   || desiredW<1 || desiredH<1)
   || ((desiredW<5 || desiredH<5) && (isPercntg!=1))
   {
      showTOOLtip("WARNING: Incorrect dimensions given")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   filesElected := getSelectedFiles(0, 1)
   If (dontAsk!="yes")
   {
      If (filesElected>100)
      {
         overwriteWarning := (ResizeUseDestDir!=1) ? "`n`nWARNING: All the original files will be overwritten!" : "`n`nThe files will be saved in " ResizeDestFolder "\"
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to process multiple images in one go. There are " filesElected " selected files for this operation. " overwriteWarning, 4, 0, "question")
         If (msgResult!="Yes")
            Return
      } Else Return
   }

   BtnCloseWindow()
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   startOperation := A_TickCount
   CurrentSLD := ""
   thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
   If (ResizeKeepAratio=1 && isPercntg=1)
      desiredW := desiredH

   showTOOLtip("Processing " filesElected " images, please wait")
   prevMSGdisplay := A_TickCount
   countTFilez := countFilez := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   failedFiles := countFilez := skippedFiles := 0
   destroyGDIfileCache()
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      countTFilez++
      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (!FileExist(imgPath) || !imgPath) || (!RegExMatch(imgPath, saveTypesRegEX) && userUnsprtWriteFMT=1)
      {
         skippedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to process " groupDigits(failedFiles) " files"
         If (skippedFiles>0)
            etaTime .= "`n" groupDigits(skippedFiles) "files were skipped"

         showTOOLtip("Processing images, please wait" etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      fOutDir := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      If (userUnsprtWriteFMT=3)
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else If (userUnsprtWriteFMT=2 && !RegExMatch(imgPath, saveTypesRegEX))
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else
         destImgPath := fOutDir "\" OutFileName

      If (userUnsprtWriteFMT!=1 || ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionConflictingFile, performOverwrite)
      }

      If !destImgPath
      {
         skippedFiles++
         Continue
      }

      oBitmap := LoadBitmapFromFileu(imgPath)
      If StrLen(oBitmap)<3
      {
         failedFiles++
         Continue
      }

      Gdip_GetImageDimensions(oBitmap, imgW, imgH)
      If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
         Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

      If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      z := calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, ResizeKeepAratio, newW, newH)
      If (z=-1 || z=1)
      {
         failedFiles++
         trGdip_DisposeImage(oBitmap, 1)
         Continue
      }

      r := coreResizeIMG(imgPath, newW, newH, destImgPath, 0, 0, ResizeRotationUser, oBitmap, imgW, imgH, 0)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If (failedFiles>0)
      someErrors := "`nFailed to process " groupDigits(failedFiles) " files"
   If (skippedFiles>0)
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   If (editingSelectionNow=1 && relativeImgSelCoords=1)
      calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip("Finished processing " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

WriteSettingsResizePanel() {
  INIaction(1, "userActionConflictingFile", "General")
  INIaction(1, "ResizeApplyEffects", "General")
  INIaction(1, "ResizeCropAfterRotation", "General")
  INIaction(1, "ResizeInPercentage", "General")
  INIaction(1, "ResizeKeepAratio", "General")
  INIaction(1, "ResizeRotationUser", "General")
  INIaction(1, "ResizeQualityHigh", "General")
  INIaction(1, "ResizeWithCrop", "General")
  INIaction(1, "ResizeDestFolder", "General")
  INIaction(1, "ResizeUseDestDir", "General")
}

WriteSettingsResizeSimplePanel() {
  INIaction(1, "userActionConflictingFile", "General")
  INIaction(1, "SimpleOperationsFlipV", "General")
  INIaction(1, "SimpleOperationsFlipH", "General")
  INIaction(1, "SimpleOperationsDoCrop", "General")
  INIaction(1, "SimpleOperationsRotateAngle", "General")
  INIaction(1, "SimpleOperationsScaleXimgFactor", "General")
  INIaction(1, "SimpleOperationsScaleYimgFactor", "General")
  INIaction(1, "ResizeMustPerform", "General")
  INIaction(1, "ResizeQualityHigh", "General")
  INIaction(1, "ResizeDestFolder", "General")
  INIaction(1, "ResizeUseDestDir", "General")
}

calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, isKeepRatio, ByRef newW, ByRef newH) {
   r := 0
   If (isPercntg=1)
   {
      newW := Round((imgW/100)*desiredW)
      newH := Round((imgH/100)*desiredH)
      If (newW<10 && newH<10)
         r := -1
   } Else If (isKeepRatio=1)
   {
      calcIMGdimensions(imgW, imgH, desiredW, desiredH, newW, newH)
      If (newW<10 && newH<10)
         r := -1
   } Else
   {
      newW := desiredW
      newH := desiredH
   }

   If (newW*newH>536848912) || (newW>32100) || (newH>32100)
      r := 1
   Return r
}

filesListApplyColors() {
    Static prevFXmode := "n"

    o_imgFxMode := imgFxMode
    If (imgFxMode>1)
       prevFXmode := imgFxMode
    Else If (prevFXmode!="n")
       imgFxMode := prevFXmode

    If (imgFxMode=1)
    {
       showTOOLtip("No viewport color adjustments to be applied on image`n`nPress F to cycle through mode")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && imgFxMode>1)
   {
      If (filesElected>200)
      {
         msgResult := msgBoxWrapper(appTitle ": Apply colors", "All the images in supported writing formats will be processed accordingly to the color adjustments of the viewport. The original files will be overwritten. Do you want to continue?", 4, 0, "question")
         If !InStr(msgResult, "yes")
            Return
      }

      ResizeMustPerform := ResizeUseDestDir := 0
      ResizeInPercentage := ResizeApplyEffects := 1
      userActionConflictingFile := userUnsprtWriteFMT := 1
      ResizeWithCrop := ResizeRotationUser := simpleOpRotationAngle := 0
      ResultEditWidth := ResultEditHeight := 100
      WriteSettingsResizePanel()
      batchIMGresizer(100, 100, ResizeInPercentage, "yes")
   } Else
   {
      imgPath := resultedFilesList[currentFileIndex, 1]
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      If !RegExMatch(imgPath, saveTypesRegEX)
      {
         showTOOLtip("ERROR: Image file is in an unsupported write format")
         SoundBeep, 300, 100
      } Else
      {
         destroyGDIfileCache()
         ResizeMustPerform := ResizeUseDestDir := 0
         ResizeInPercentage := ResizeApplyEffects := 1
         userActionConflictingFile := userUnsprtWriteFMT := 1
         ResizeWithCrop := ResizeRotationUser := simpleOpRotationAngle := 0
         ResultEditWidth := ResultEditHeight := 100
         ; WriteSettingsResizePanel()
         GetImgFileDimension(imgPath, imgW, imgH, 0)
         r := coreResizeIMG(imgPath, imgW, imgH, imgPath, 1, 0, 0, 1, imgW, imgH)
         If r
         {
            SoundBeep, 300, 100
            showTOOLtip("ERROR: Unable to save imagel file - unknown error:`n" OutFileName "`n" OutDir "\")
         } Else
         {
            resultedFilesList[currentFileIndex, 4] := 1
            If (SLDtypeLoaded=3)
               selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

            showTOOLtip("Viewport colour effects applied on the image:`n" OutFileName "`n" OutDir "\")
         }
      }
   }

   imgFxMode := 1
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
}

filesListFlipHimage() {
   coreQuickImageFilesListActions(2)
}

filesListFlipVimage() {
   coreQuickImageFilesListActions(3)
}

filesListFlipRotatePlus() {
   coreQuickImageFilesListActions(6)
}

filesListFlipRotateMinus() {
   coreQuickImageFilesListActions(8)
}

coreQuickImageFilesListActions(actu) {
   initFIMGmodule()
   countNotJpegs := firstu := 0
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1)
   {
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         imgPath := resultedFilesList[A_Index, 1]
         If (!RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && imgPath)
         {
            countNotJpegs++
            If !firstu
               firstu := A_Index
         }
         If (countNotJpegs>3)
            Break
      }
   }

   imgPath := resultedFilesList[currentFileIndex, 1]
   If (RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && countNotJpegs<2)
   {
      hasExec := 1
      jpegDesiredOperation := actu
      jpegDoCrop := 0
      BtnPerformJpegOp("extern")
   }

   If (countNotJpegs=1 && firstu)
   {
      hasExec := 0
      currentFileIndex := firstu
   }

   If (hasExec!=1)
   {
      ResizeMustPerform := 0 
      SimpleOperationsFlipV := (actu=3) ? 1 : 0
      SimpleOperationsFlipH := (actu=2) ? 1 : 0
      SimpleOperationsDoCrop := 0
      SimpleOperationsRotateAngle := 1
      If (actu=6)  ; 90 degrees rotation
         SimpleOperationsRotateAngle := 2
      Else If (actu=8) ; -90 degrees rotation 
         SimpleOperationsRotateAngle := 4

      SimpleOperationsScaleXimgFactor := 100
      SimpleOperationsScaleYimgFactor := 100
      ResizeQualityHigh := ResizeInPercentage := 1
      ResizeUseDestDir := 0
      cleanResizeUserOptionsVars()
      BtnPerformSimpleProcessing("no-prompt", "extern")
   }
}

BTNsaveResizedIMG() {
    Gui, SettingsGUIA: Default
    GuiControlGet, ResultEditWidth
    GuiControlGet, ResultEditHeight
    GuiControlGet, userEditWidth
    GuiControlGet, userEditHeight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResizeApplyEffects
    GuiControlGet, ResizeCropAfterRotation
    GuiControlGet, ResizeDestFolder
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, ResizeQualityHigh
    GuiControlGet, ResizeRotationUser
    GuiControlGet, ResizeUseDestDir
    GuiControlGet, ResizeWithCrop
    GuiControlGet, userActionConflictingFile
    GuiControlGet, userJpegQuality

    EditResizeWidth()
    cleanResizeUserOptionsVars()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       GuiControlGet, userDesireWriteFMT
       GuiControlGet, userUnsprtWriteFMT
       rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
       If (!RegExMatch(rDesireWriteFMT, "i)(bmp|png|tiff|tif|gif|jpg|jpeg)$") && wasInitFIMlib!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The ." rDesireWriteFMT " format is currently unsupported. The FreeImage library failed to properly initialize.", 0, 0, "error")
          Return
       }

       WriteSettingsResizePanel()
       If (ResizeUseDestDir=1)
          INIaction(1, "ResizeDestFolder", "General")

       batchIMGresizer(userEditWidth, userEditHeight, ResizeInPercentage)
       Return
    }

   If (!ResultEditHeight || !ResultEditWidth
   || ResultEditWidth<5 || ResultEditHeight<5)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
      Return
   }

   If (ResultEditWidth*ResultEditHeight>536848912) || (ResultEditWidth>32100) || (ResultEditHeight>32100)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceeds the limits of GDI+.`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
      Return
   }

   zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutFileNameNoExt, fileEXT)
   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileName : OutDir "\" OutFileNameNoExt
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   Loop, Parse, dialogSaveFptrn, |
   {
        If InStr(A_LoopField, "." fileEXT)
           defFMTindex := A_Index
   }

   file2save := openFileDialogWrapper("S", "PathMustExist", startPath, "Save processed image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)
   If file2save
   {
      zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      zPlitPath(file2save, 0, OutFileName, OutDir)
      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      GetImgFileDimension(img2resizePath, imgW, imgH, 0)
      If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
         Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

      z := calcNewImgDimensions(imgW, imgH, userEditWidth, userEditHeight, ResizeInPercentage, ResizeKeepAratio, newW, newH)
      If (z=-1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
         Return
      } Else If (z=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceed the limits of GDI+.`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
         Return
      }

      If FileExist(file2save)
      {
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      destroyGDIfileCache()
      SetTimer, WriteSettingsResizePanel, -90
      r := coreResizeIMG(img2resizePath, newW, newH, file2save, 0, 0, ResizeRotationUser, 1, imgW, imgH)
      If r
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Unable to save file... Unknown error.`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         Return
      }

      resultedFilesList[currentFileIndex, 4] := 1
      If (SLDtypeLoaded=3)
         selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

      SoundBeep, 900, 100
      showTOOLtip("Processed image saved`n" OutFileName "`n`n" OutDir "\")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BtnCopy2ClipResizedIMG() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResultEditWidth
   GuiControlGet, ResultEditHeight
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeQualityHigh
   GuiControlGet, ResizeApplyEffects
   GuiControlGet, ResizeRotationUser
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation

   EditResizeWidth()
   cleanResizeUserOptionsVars()

   GetImgFileDimension(img2resizePath, imgW, imgH, 0)
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
      Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

   z := calcNewImgDimensions(imgW, imgH, userEditWidth, userEditHeight, ResizeInPercentage, ResizeKeepAratio, newW, newH)
   If (z=-1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
      Return
   } Else If (z=1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceeds the limits of GDI+.`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
      Return
   }

   showTOOLtip("Processing image, please wait")
   r := coreResizeIMG(img2resizePath, newW, newH, "--", 0, 1, ResizeRotationUser, 1, imgW, imgH)
   SoundBeep, % r ? 300 : 900, 100
   ToolTip
   If !r
      showTOOLtip("Processed image copied to clipboard")
   Else 
      msgBoxWrapper(appTitle ": ERROR", "Unable to copy the processed image to the clipboard.`nError code: " r, 0, 0, "error")

   SetTimer, RemoveTooltip, % -msgDisplayTime//3
   SetTimer, ResetImgLoadStatus, -150
}

EditResizeWidth() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   GuiControlGet, ResizeRotationUser
   If (AnyWindowOpen!=28)
      GuiControlGet, ResizeRotationUser
   
   If (A_TickCount - lastEditRHChange < 200)
      Return

   If (AnyWindowOpen!=28)
      cleanResizeUserOptionsVars()
   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRWChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditHeight, % Round(userEditWidth)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditWidth<1 || !userEditWidth)
      userEditWidth := 1

   If (AnyWindowOpen=28)
   {
      whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   } Else GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

   Global lastEditRWChange := A_TickCount
   Sleep, 5
   If (ResizeKeepAratio=1)
   {
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      calcIMGdimensions(oImgW, oImgH, thisWidth, 90000*oImgH, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newH/oimgH)*100) : newH
      GuiControl, SettingsGUIA:, userEditHeight, % Round(newValue)

      Gdip_GetRotatedDimensions(newW, newH, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }
}

EditResizeHeight() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   If (AnyWindowOpen!=28)
      GuiControlGet, ResizeRotationUser

   If (A_TickCount - lastEditRWChange < 200)
      Return

   If (AnyWindowOpen!=28)
      cleanResizeUserOptionsVars()
   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRHChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditWidth, % Round(userEditHeight)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditHeight<1 || !userEditHeight)
      userEditHeight := 1

   If (AnyWindowOpen=28)
   {
      whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   } Else GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

   Global lastEditRHChange := A_TickCount
   Sleep, 5
   If (ResizeKeepAratio=1)
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      calcIMGdimensions(oImgW, oImgH, 90000*oImgW, thisHeight, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newW/oimgW)*100) : newW
      GuiControl, SettingsGUIA:, userEditWidth, % Round(newValue)
      Gdip_GetRotatedDimensions(newW, newH, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }
}

TglRszInPercentage() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
   If (AnyWindowOpen!=18)
   {
      filesElected := getSelectedFiles()
      If (filesElected>1)
      {
         oImgW := ResolutionWidth
         oImgH := ResolutionHeight
      } Else If (AnyWindowOpen=28)
      {
         whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
         Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
      } Else GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

      GuiControl, SettingsGUIA:, userEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
      GuiControl, SettingsGUIA:, userEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
      If (filesElected<2)
         EditResizeWidth()
   }

   INIaction(1, "ResizeInPercentage", "General")
}

TglRszKeepAratio() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, ResizeKeepAratio
   If (!markedSelectFile || ResizeKeepAratio=1 && ResizeInPercentage=1)
      EditResizeWidth()

   INIaction(1, "ResizeKeepAratio", "General")
}

TglRszUnsprtFrmt() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userUnsprtWriteFMT
   GuiControlGet, userDesireWriteFMT
   If (userUnsprtWriteFMT>1)
      GuiControl, SettingsGUIA: Enable, userDesireWriteFMT
   Else
      GuiControl, SettingsGUIA: Disable, userDesireWriteFMT
   INIaction(1, "userDesireWriteFMT", "General")
}

cleanResizeUserOptionsVars() {
    ResizeRotationUser := StrReplace(ResizeRotationUser, ":")
    ResizeRotationUser := StrReplace(ResizeRotationUser, "°")
    ResizeRotationUser := StrReplace(ResizeRotationUser, "rotate")
    ResizeRotationUser := Trimmer(ResizeRotationUser)

    If (SimpleOperationsRotateAngle=2)
       simpleOpRotationAngle := 90
    Else If (SimpleOperationsRotateAngle=3)
       simpleOpRotationAngle := 180
    Else If (SimpleOperationsRotateAngle=4)
       simpleOpRotationAngle := 270
    Else
       simpleOpRotationAngle := 0
}

TglRszRotation() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeRotationUser
   GuiControlGet, ResizeWithCrop
   cleanResizeUserOptionsVars()
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation

   EditResizeWidth()
   INIaction(1, "ResizeWithCrop", "General")
   INIaction(1, "ResizeRotationUser", "General")
}

TglRszCropping() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation
   EditResizeWidth()
   INIaction(1, "ResizeWithCrop", "General")
   INIaction(1, "ResizeCropAfterRotation", "General")
}

TglRszDestFoldr() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeUseDestDir
   If !ResizeUseDestDir
   {
      GuiControl, SettingsGUIA: Disable, btnFldr
      GuiControl, SettingsGUIA: Disable, ResizeDestFolder
   } Else
   {
      GuiControl, SettingsGUIA: Enable, btnFldr
      GuiControl, SettingsGUIA: Enable, ResizeDestFolder
   }
   INIaction(1, "ResizeUseDestDir", "General")
}

TglRszQualityHigh() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeQualityHigh
   INIaction(1, "ResizeQualityHigh", "General")
}

TglRszApplyEffects() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeApplyEffects
   INIaction(1, "ResizeApplyEffects", "General")
   If (ResizeApplyEffects=1)
   {
      infoMirroring := defineIMGmirroring()
      If (usrColorDepth>1)
         infoColorDepth := "`nSimulated color depth: " defineColorDepth()
      If (imgFxMode>1)
         infoColors := "`nColors display mode: " DefineFXmodes() " [" currIMGdetails.PixelFormat "]"
 
      entireString := infoMirroring infoColors infoColorDepth infoRenderOpaque
      entireString := (entireString) ?  "Effects currently activated: " entireString : "No effects currently activated."
      msgBoxWrapper(appTitle, entireString, 0, 0, "info")
   }
}

invokePanelStaticFoldersContextMenu() {
   Try Menu, PanelStaticMenu, Delete
   Sleep, 2

   Menu, PanelStaticMenu, Add, &Rescan folder, BTNupdateSelectedStaticFolder
   Menu, PanelStaticMenu, Add, &Erase indexed files, BTNremFilesStaticFolder
   Menu, PanelStaticMenu, Add, &Open folder in Explorer, BTNopenDynaFolder
   Menu, PanelStaticMenu, Add, &Copy folder path, BTNcopyStaticFolderPath
   Menu, PanelStaticMenu, Add, &Ignore date change, BTNignoreSelFolder
   Menu, PanelStaticMenu, Add, Rename inde&x entry, PanelRenameStaticFolder
   Menu, PanelStaticMenu, Add, &Filter list to selected folder, MenuFolderzFilterList
   Menu, PanelStaticMenu, Add,
   Menu, PanelStaticMenu, Add, &Copy entire list, BTNcopyAllStaticFolderPaths
   Menu, PanelStaticMenu, Add, &View list as a folders tree, BTNshowStaticFoldersInTreeView
   showThisMenu("PanelStaticMenu")
}

invokePanelDynaFoldersContextMenu() {
   Try Menu, PanelDynaMenu, Delete
   Sleep, 2

   Menu, PanelDynaMenu, Add, &Rescan folder, BTNrescanDynaFolder
   Menu, PanelDynaMenu, Add, &Remove from the list, RemDynaSelFolder
   Menu, PanelDynaMenu, Add, Rename inde&x entry, PanelRenameStaticFolder
   Menu, PanelDynaMenu, Add, &Open folder in Explorer, BTNopenDynaFolder
   Menu, PanelDynaMenu, Add, &Copy folder path, BTNcopyStaticFolderPath
   Menu, PanelDynaMenu, Add, &Toggle recursive folder scan, InvertRecurseDynaFolder
   Menu, PanelDynaMenu, Add, &Filter list to selected folder, MenuFolderzFilterList
   Menu, PanelDynaMenu, Add
   Menu, PanelDynaMenu, Add, &View list as a folders tree, BTNshowDynamicFoldersInTreeView
   showThisMenu("PanelDynaMenu")
}

PanelStaticFolderzManager() {
    Global LViewOthers, listViewFilteru
    If !(RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
       Return

    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    thisBtnHeight := createSettingsGUI(2, A_ThisFunc)
    btnWid := 115
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 95
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := (PrefsLargeFonts=1) ? 140 : 95
    btnWid3 := (PrefsLargeFonts=1) ? 95 : 55
    btnWid4 := (PrefsLargeFonts=1) ? 160 : 90
    CountFilesFolderzList := 0
    widthu := (SLDtypeLoaded=3) ? "w1" : ""
    Gui, Add, Text, x15 y15, This folders list was generated based on the indexed files.
    Gui, Add, ListView, xp y+10 w%lstWid% -multi AltSubmit gFolderzFilterListBTN r12 Grid vLViewOthers +hwndhLVmainu, #|Date|(?)|Folder path|Files
    Gui, Add, Edit, xs y+10 wp-50 -multi -wantTab gfilterListViewStaticFoldersList +hwndhEditField vlistViewFilteru,
    Gui, Add, Button, x+1 hp w50 gBTNhelpStaticFolderz, [ ? ]
    Gui, Add, Checkbox, xs y+10 gToggleRecursiveStaticRescan vRecursiveStaticRescan Checked%RecursiveStaticRescan%, &Perform recursive (in sub-folders) rescan

    Gui, Add, Button, xs+0 y+15 h%thisBtnHeight% w%btnWid2% gBTNupdateSelectedStaticFolder, &Rescan folder
    Gui, Add, Button, x+5 hp w%btnWid% gSQLdbGenerateStaticFolders , I&gnore all changes
    Gui, Add, Button, x+5 hp wp+40 gRegenerateEntireList, R&egenerate entire index
    Gui, Add, Button, x+5 hp w70 ginvokePanelStaticFoldersContextMenu, &More

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Cached folders list updater: " appTitle)
    Sleep, 25
    If (SLDtypeLoaded=3)
       PopulateStaticSQLfolderzList()
    Else
       PopulateStaticFolderzList()
}

BTNhelpStaticFolderz() {
   msgBoxWrapper(appTitle ": HELP", "Please select the folder you want updated.`nFolders marked with (*) are changed since the last scan, based on folder modified date.`n`nWhen you choose to «remove file entries» for a specific folder, the files indexed pertaining to the selected will be removed ONLY from the index/list, NOT from the disk.", -1, 0, 0)
}

EM_SETCUEBANNER(handle, string, option := true) {
; ===============================================================================================================================
; Message ..................:  EM_SETCUEBANNER
; Minimum supported client .:  Windows Vista
; Minimum supported server .:  Windows Server 2003
; Links ....................:  https://docs.microsoft.com/en-us/windows/win32/controls/em-setcuebanner
; Description ..............:  Sets the textual cue, or tip, that is displayed by the edit control to prompt the user for information.
; Options ..................:  True  -> if the cue banner should show even when the edit control has focus
;                              False -> if the cue banner disappears when the user clicks in the control
; ===============================================================================================================================
   static ECM_FIRST       := 0x1500 
        , EM_SETCUEBANNER := ECM_FIRST + 1
   if (DllCall("user32\SendMessage", "ptr", handle, "uint", EM_SETCUEBANNER, "int", option, "str", string, "int"))
      return true
   return false
}

PanelDynamicFolderzWindow(dummy:=0) {
    Static LViewDynas
    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    thisBtnHeight := createSettingsGUI(3, A_ThisFunc)
    btnWid := 120
    txtWid := 360
    lstWid := 535
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 175
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    Gui, Add, Text, x15 y15, This folders list is used to generate the files list index.
    Gui, Add, ListView, y+10 w%lstWid% gFolderzFilterListBTN -multi r12 Grid vLViewDynas +hwndhLVmainu, #|(?)|Folder path

    btnWid2 := (PrefsLargeFonts=1) ? 95 : 60
    btnWid3 := (PrefsLargeFonts=1) ? 120 : 90
    If (dummy="reopen")
    {
       Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w60 gPanelSaveSlideShowu, &Back
       Gui, Add, Button, x+5 hp wp gBTNaddNewFolder2list, &Add
    } Else
       Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w60 gBTNaddNewFolder2list, &Add
    Gui, Add, Button, x+5 hp w%btnWid2% gRemDynaSelFolder, &Remove
    Gui, Add, Button, x+5 hp wp+30 gRegenerateEntireList, R&escan all
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNcopyDynaFoldersList, &Copy list
    Gui, Add, Button, x+5 hp wp+5 gBTNpasteDynaFoldersList, &Paste list
    Gui, Add, Button, x+5 hp wp+5 ginvokePanelDynaFoldersContextMenu, &More
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Manage folders list: " appTitle)
    Sleep, 25
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")
    PopulateDynamicFolderzList()
}

ToggleCountFilesFoldersList() {
  GuiControlGet, CountFilesFolderzList
  If (AnyWindowOpen=3)
     PanelDynamicFolderzWindow()
  Else If (AnyWindowOpen=2)
     PanelStaticFolderzManager()
}

ToggleRecursiveStaticRescan() {
    GuiControlGet, RecursiveStaticRescan
}

BTNaddNewFolder2list() {
    BtnCloseWindow()
    Sleep, 10
    r := addNewFolder2list()
    Sleep, 10
    SetTimer, PanelDynamicFolderzWindow, -50
}

BTNignoreSelFolder(dummy:=0) {
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    If (dummy="update-all")
       RowNumber := 1

    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded!=3)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
    }

    If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
       Return
    }

    BtnCloseWindow()
    doAll := (dummy="update-all") ? 1 : 0
    updateCachedStaticFolders(folderu, 1, doAll)
    showTOOLtip("Folders list information updated")
    SetTimer, RemoveTooltip, % -msgDisplayTime
    Sleep, 50
    PanelStaticFolderzManager()
}

BTNcopyStaticFolderPath() {
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    colNum := (AnyWindowOpen=2) ? 4 : 3
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return
    
    Try Clipboard := folderu
    Catch wasError

    If wasError
    {
       showTOOLtip("Failed to copy path to clipboard:`n" folderu)
       SoundBeep , 300, 100
    } Else
       showTOOLtip("Folder path copied to clipboard:`n" folderu)

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNcopyAllStaticFolderPaths() {
    arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
    Loop, % countStaticFolders
          finalListu .= arrayList[A_Index, 1] "`n"

    Try Clipboard := finalListu
    Catch wasError

    If wasError
    {
       showTOOLtip("Failed to copy folder paths to clipboard")
       SoundBeep , 300, 100
    } Else
       showTOOLtip("Folder paths copied to clipboard")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNshowStaticFoldersInTreeView() {
    arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
    Loop, % countStaticFolders
          finalListu .= arrayList[A_Index, 1] "`n"

    BtnCloseWindow()
    ; PanelFoldersTree()
    FolderTreeRepopulate("given", finalListu)
}

BTNshowDynamicFoldersInTreeView() {
    foldersListu := getDynamicFoldersList()
    Loop, Parse, foldersListu, `n
    {
        fileTest := StrReplace(Trimmer(A_LoopField), "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= fileTest "`n"
    }
    If !newFoldersList
       Return

    BtnCloseWindow()
    ; PanelFoldersTree()
    FolderTreeRepopulate("given", newFoldersList)
}

BTNremFilesStaticFolder() {
    GuiControlGet, RecursiveStaticRescan
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (RecursiveStaticRescan=1)
       friendly := "(and its sub-folders)"

    recursive := (RecursiveStaticRescan=1) ? "" : "|"
    msgResult := msgBoxWrapper(appTitle ": Remove files associated to static folder", "Please confirm that you want to remove the files from the index/list pertaining to the static folder " friendly " selected:`n`n" folderu "\", 4, 0, "question")
    If (msgResult="yes")
    {
       BtnCloseWindow()
       Sleep, 10
       r := coreRemFilesStaticFolder(folderu, recursive)
       Sleep, 10
       If r
          PanelStaticFolderzManager()
    } Else Return
}

coreRemFilesStaticFolder(folderu, recursive) {
    remFilesFromList(recursive folderu)
    If (maxFilesIndex>0)
    {
       GenerateRandyList()
       SoundBeep, 900, 100
       RandomPicture()
       Return 1
    } Else
    {
       handleEmptyFilesList(CurrentSLD)
       Return 0
    }
}

BTNcopyDynaFoldersList() {
    foldersListu := getDynamicFoldersList()
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    ResetImgLoadStatus()
    If !newFoldersList
       Return

    Try Clipboard := newFoldersList
    Catch wasError

    If !wasError
    {
       showTOOLtip("Dynamic folders list copied to clipboard")
    } Else
    {
       showTOOLtip("Failed to copy to clipboard the dynamic folders list")
       SoundBeep , 300, 100
    }

    SetTimer, RemoveTooltip, % msgDisplayTime
}

BTNpasteDynaFoldersList() {
    BtnCloseWindow()
    Sleep, 50
    foldersListu := getDynamicFoldersList()
    foldersListu .= SubStr(Clipboard, 1, 50432)
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    mustOpenStartFolder := ""
    Sort, newFoldersList, UD`n
    DynamicFoldersList := newFoldersList
    If (SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    currentFilesListModified := 1
    Sleep, 50
    ResetImgLoadStatus()
    PanelDynamicFolderzWindow()
}

RemDynaSelFolder() {
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    BtnCloseWindow()
    Sleep, 50
    mustOpenStartFolder := ""
    foldersListu := getDynamicFoldersList()
    currentFilesListModified := 1
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)") || folderu=line)
           Continue

        newFoldersList .= line "`n"
    }

    DynamicFoldersList := newFoldersList
    If (SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    msgResult := msgBoxWrapper(appTitle ": Remove dynamic folder", "Would you like to remove the files from the index/list pertaining to the removed dynamic folder as well ?`n`n" folderu "\", 4, 0, "question")
    If (msgResult="yes")
    {
       remFilesFromList(folderu)
       If (maxFilesIndex>0)
       {
          GenerateRandyList()
          SoundBeep, 900, 100
          RandomPicture()
       } Else 
       {
          handleEmptyFilesList(CurrentSLD)
          Return
       }
    }

    Sleep, 50
    ResetImgLoadStatus()
    PanelDynamicFolderzWindow()
}

LV_EX_GetNextItem(HLV, nRow, lParam:=0x0001) {
; Description ..: Get the next item in the target ListView.
; Parameters ...: HLV  - External ListView hwnd
; ..............: nRow   - Row where to start the search for the next item (0-based index).
; ..............: lParam - Status of the searched item. Common statuses are:
; ..............:          LVNI_ALL         - 0x0000
; ..............:          LVNI_FOCUSED     - 0x0001
; ..............:          LVNI_SELECTED    - 0x0002
; ..............:          LVNI_CUT         - 0x0004
; ..............:          LVNI_DROPHILITED - 0x0008
; Info .........: LVM_GETNEXTITEM - http://msdn.microsoft.com/en-us/library/windows/desktop/bb761057%28v=vs.85%29.aspx
; Return .......: Item content as a string.

    ; LVM_GETNEXTITEM = LVM_FIRST (0x1000) + 12 = 0x100C.
    SendMessage, 0x100C, %nRow%, %lParam%,, % "ahk_id " HLV
    Return ErrorLevel
}

LV_EX_GetItemsCount(HLV, ByRef rows, ByRef cols) {
    ; LVM_GETITEMCOUNT = LVM_FIRST (0x1000) + 4 = 0x1004.
    SendMessage, 0x1004, 0, 0,, % "ahk_id " hlv
    rows := ErrorLevel

    ; LVM_GETHEADER = LVM_FIRST (0x1000) + 31 = 0x101F.
    SendMessage, 0x101F, 0, 0,, % "ahk_id " hlv
    hhdr := ErrorLevel

    ; HDM_GETITEMCOUNT = HDM_FIRST (0x1200) + 0 = 0x1200.
    SendMessage, 0x1200, 0, 0,, % "ahk_id " hhdr
    cols := ErrorLevel
}

LV_EX_LVITEM(ByRef LVITEM, Mask := 0, Row := 1, Col := 1) {
   Static LVITEMSize := 48 + (A_PtrSize * 3)
   VarSetCapacity(LVITEM, LVITEMSize, 0)
   NumPut(Mask, LVITEM, 0, "UInt"), NumPut(Row - 1, LVITEM, 4, "Int"), NumPut(Col - 1, LVITEM, 8, "Int")
}

LV_EX_GetSubItemText(HLV, Row, Column := 1, MaxChars := 1024) {
; function by «just me»
; found on https://github.com/AHK-just-me/

   ; LVM_GETITEMTEXT -> http://msdn.microsoft.com/en-us/library/bb761055(v=vs.85).aspx
   Static LVM_GETITEMTEXT := A_IsUnicode ? 0x1073 : 0x102D ; LVM_GETITEMTEXTW : LVM_GETITEMTEXTA
   Static OffText := 16 + A_PtrSize
   Static OffTextMax := OffText + A_PtrSize
   VarSetCapacity(ItemText, MaxChars << !!A_IsUnicode, 0)
   LV_EX_LVITEM(LVITEM, , Row, Column)
   NumPut(&ItemText, LVITEM, OffText, "Ptr")
   NumPut(MaxChars, LVITEM, OffTextMax, "Int")
   SendMessage, % LVM_GETITEMTEXT, % (Row - 1), % &LVITEM, , % "ahk_id " . HLV
   VarSetCapacity(ItemText, -1)
   Return ItemText
}

BTNopenDynaFolder() {
    whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
    Gui, SettingsGUIA: ListView, % whichLV
    colNum := (AnyWindowOpen=3) ? 3 : 4
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1) ; LV_GetNext(0, "F")
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    ; LV_GetText(folderu, RowNumber, colNum)
    ; ToolTip, % RowNumber "==" A_GuiEventInfo "`n" folderu , , , 2
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    folderu := StrReplace(folderu, "|")
    Try Run, "%folderu%"
    Catch wasError
          Sleep, 1

    If wasError
       msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu, 0, 0, "error")
}

FolderzFilterListBTN(dummy:=0) {
    whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
    Gui, SettingsGUIA: ListView, % whichLV
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    colNum := (AnyWindowOpen=3) ? 3 : 4
    indexu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum - 3)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    files := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum + 1)

    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If ((A_GuiEvent="Normal" || A_GuiEvent="K") && files="" && whichLV="LViewOthers")
    {
       countedFiles := 0
       ; startZeit := A_TickCount
       Loop, % maxFilesIndex
       {
          imgPath := resultedFilesList[A_Index, 1]
          If InStr(imgPath, folderu)
             zPlitPath(imgPath, 1, OutFileName, OutDir)
          Else
             OutDir := ""
          ; If QPV_InStr(imgPath, folderu)
          If (OutDir=folderu)
             countedFiles++
       }
       ; ToolTip, % A_TickCount - startZeit , , , 2
       newStaticFoldersListCache[indexu, 3] := countedFiles
       LV_Modify(RowNumber + 1, "Col" colNum+1, countedFiles)
       LV_ModifyCol(colNum + 1, "AutoHdr Left")
       Return
    }

    If (A_GuiEvent!="DoubleClick" && dummy!="menu-mode")
       Return

    ; doExactMatch := (AnyWindowOpen=3) ? 0 : 1
    BtnCloseWindow()
    folderu := Trimmer(StrReplace(folderu, "|"))
    If (AnyWindowOpen=3)
    {
       userFilterProperty := userFilterWhat := userFilterDoString := userFilterStringPos := 1
       userFilterStringIsNot := 0
       UsrEditFilter := folderu "\"
    } Else
    {
       userFilterProperty := userFilterDoString := 1
       userFilterWhat := 2
       userFilterStringPos := 3
       userFilterStringIsNot := 0
       UsrEditFilter := folderu
    }

    thisFilter := updateUIFiltersPanel("external")
    coreEnableFiltru(thisFilter)
}

MenuFolderzFilterList() {
   FolderzFilterListBTN("menu-mode")
}

InvertRecurseDynaFolder() {
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    BtnCloseWindow()
    Sleep, 25
    foldersListu := getDynamicFoldersList()
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || line="|hexists|" || !RegExMatch(fileTest, "i)^(.\:\\.)") || folderu=line)
           Continue

        newFoldersList .= line "`n"
    }

    isPipe := InStr(folderu, "|") ? 1 : 0
    folderu := StrReplace(folderu, "|")
    If (isPipe!=1)
       folderu := "|" folderu

    newFoldersList .= folderu "`n"
    Sort, newFoldersList, UD`n
    DynamicFoldersList := newFoldersList
    Sleep, 15
    PanelDynamicFolderzWindow()
    Sleep, 15
    showTOOLtip("You need to rescan folder for the effect to take place")
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNrescanDynaFolder() {
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    BtnCloseWindow()
    Sleep, 25
    ; msgbox, % folderu
    mustOpenStartFolder := ""
    showTOOLtip("Preparing files list, please wait.`n" folderu "\")
    ; If InStr(folderu, "|")
    ; {
    ;    fileTest := StrReplace(folderu, "|")
    ;    remFilesFromList(fileTest)
    ; }

    coreAddNewFolder(folderu, 1, 0, 0)
    SQLdeleteEntriesMarked()
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=2)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1 || InStr(folderu, "|"))
          good2go := "null"
    } Else good2go := "null"
    If (SLDtypeLoaded=3)
       good2go := 0

    If (mustGenerateStaticFolders=0 && good2go!="null" && RegExMatch(CurrentSLD, sldsPattern))
       updateCachedStaticFolders(folderu, 0)

    Sleep, 250
    PanelDynamicFolderzWindow()
}

updateCachedStaticFolders(mainFolderu, onlyMainFolder, updateAllDates:=0) {
   thisIndex := 0
   showTOOLtip("Updating static folders list")
   arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
   Loop, % countStaticFolders
         foldersListu .= "Fi" A_Index "=" arrayList[A_Index, 2] "*&*" arrayList[A_Index, 1] "`n"

   FileGetTime, dirDate, % mainFolderu, M
   newEntry := dirDate "*&*" mainFolderu "`n"

   If (onlyMainFolder!=1)
   {
      Loop, Files, %mainFolderu%\*, RD
      {
          FileGetTime, dirDate, %A_LoopFileFullPath%, M
          MoreNewFileFolders .= dirDate "*&*" A_LoopFileFullPath "`n"
          ; Tooltip, % MoreNewFileFolders
      }
   }

   Loop, Parse, foldersListu, `n
   {
       lineArru := StrSplit(A_LoopField, "*&*")
       folderu := lineArru[2], oldDateu := lineArru[1]
       If !FolderExist(folderu) || (folderu=mainFolderu) || InStr(MoreNewFileFolders, "*&*" folderu "`n")
          Continue

       oldDateu := SubStr(oldDateu, InStr(oldDateu, "=")+1)
       If (updateAllDates=1)
          FileGetTime, oldDateu, % folderu, M
       newFoldersList .= oldDateu "*&*" folderu "`n"
   }

   FinalStaticFoldersList := newFoldersList "`n" MoreNewFileFolders "`n" newEntry
   Sort, FinalStaticFoldersList, U D`n
   If (SLDtypeLoaded=3)
   {
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      activeSQLdb.Exec("DELETE FROM staticfolders;")
      Loop, Parse, FinalStaticFoldersList, `n
      {
          If StrLen(A_LoopField)>2
             lineArru := StrSplit(A_LoopField, "*&*")
          Else
             Continue

          folderu := lineArru[2]
          oldDateu := lineArru[1]
          addStaticFolderSQLdb(folderu, oldDateu, 0)
      }

      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)

      Return
   }

   thisIndex := 0
   newStaticFoldersListCache := []
   Loop, Parse, FinalStaticFoldersList, `n
   {
        If StrLen(A_LoopField)<5
           Continue

        thisIndex++
        lineArru := StrSplit(A_LoopField, "*&*")
        newStaticFoldersListCache[thisIndex] := [lineArru[2], lineArru[1]]
   }
}

remFilesFromList(SelectedDir, silentus:=0, forReal:=1) {
    If (silentus=0)
       showTOOLtip("Removing files from the list pertaining to`n" SelectedDir "\")

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    selectedFiles := markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    oldMaxy := maxFilesIndex
    isPipe := InStr(SelectedDir, "|") ? 1 : 0
    SelectedDir := StrReplace(SelectedDir, "|")
    newArrayu := []
    Loop, % maxFilesIndex + 1
    {
        r := getIDimage(A_Index)
        If (InStr(r, "||") || !r)
           Continue

        If !isPipe
        {
           If InStr(r, SelectedDir "\")
              Continue
        } Else If (isPipe=1)
        {
           rT := StrReplace(r, SelectedDir "\")
           If !InStr(rT, "\")
              Continue
        }

        countFiles++
        newArrayu[countFiles] := resultedFilesList[A_Index]
        If (resultedFilesList[A_Index, 2]=1)
           selectedFiles++
    }

    If (SLDtypeLoaded=3)
    {
       thisR := SQLescapeStr(SelectedDir, 1)
       thisR := (isPipe=1) ? thisR : thisR "%"
       If (forReal=1)
       {
          activeSQLdb.Exec("BEGIN TRANSACTION;")
          SQLstr := "DELETE FROM images WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          If !activeSQLdb.Exec(SQLStr)
          {
             stringA:= thisR
             activeSQLdb.EscapeStr(stringA)
             SQLstr := "DELETE FROM images WHERE imgfolder LIKE " stringA " ESCAPE '>';"
             activeSQLdb.Exec(SQLStr)
          }

          If !activeSQLdb.Exec("COMMIT TRANSACTION;")
             throwSQLqueryDBerror(A_ThisFunc)
       } Else
       {
          SQLstr := "UPDATE images SET isDeleted=1 WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          If !activeSQLdb.Exec(SQLstr)
             throwSQLqueryDBerror(A_ThisFunc)
       }
    }

    renewCurrentFilesList()
    maxFilesIndex := countFiles
    resultedFilesList := newArrayu.Clone()
    markedSelectFile := selectedFiles
    ForceRefreshNowThumbsList()
    filesRemoved := oldMaxy - maxFilesIndex
    If (SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    If (filesRemoved<1)
       filesRemoved := 0
    Else
       currentFilesListModified := 1

    CurrentSLD := backCurrentSLD
    If (silentus=0)
       showTOOLtip("Finished removing " filesRemoved " files from the list")

    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

PanelRenameStaticFolder() {
    ; Global newFileName, idFolder, remFilesFromFolder, doRemRecursively
    ; GuiControlGet, RecursiveStaticRescan
    winOpen := AnyWindowOpen
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    colNum := (AnyWindowOpen=2) ? 4 : 3 ; 2 = static panel ; 3 = dynamic panel
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded=2 && AnyWindowOpen=2)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
          Return
       }
   }

   Sleep, 15
   folderu := StrReplace(folderu, "|")
   msgResult := msgBoxWrapper("Rename static folder entry: " appTitle, "Please type the new folder path. The records in the index pertaining to this folder, will automatically be updated to reflect the change.", "&Rename folder entry|C&ancel", 1, "modify-entry", 0, 1, 0, "limit9050 w850", folderu)
   If InStr(msgResult.btn, "Rename")
   {
      remFilesFromFolder := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      newFileName := StrReplace(newFileName, "/", "\")
      newFileName := StrReplace(newFileName, "|")
      newFileName := Trimmer(newFileName, "\")
      newFileName := RegExReplace(newFileName, "\\{2,}", "\")
      If (!newFileName || newFileName=folderu)
         Return

      If (!RegExMatch(newFileName, "i)^(.\:\\.)") || !newFileName)
      {
         showTOOLtip("WARNING: Incorrect folder path provided")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If !FolderExist(newFileName)
      {
         showTOOLtip("WARNING: Inexistent folder path provided")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      BtnCloseWindow()
      ; If (remFilesFromFolder=1)
      ;    coreRemFilesStaticFolder(folderu, recursive)

      newName := newFileName
      If (winOpen=2)
      {
         showTOOLtip("Updating static folders list")
         If (SLDtypeLoaded=3)
         {
            Sleep, 25
         } Else
         {
            arrayList := LoadStaticFoldersCached(CurrentSLD, totalStaticFolders, 1)
            Loop, % totalStaticFolders
            {
               If (arrayList[A_Index, 1]=folderu)
                  arrayList[A_Index, 1] := newName
               Else
                  arrayList[A_Index, 1] := StrReplace(arrayList[A_Index, 1], folderu "\", newName "\")
            }

            newStaticFoldersListCache := []
            newStaticFoldersListCache := arrayList.Clone()
         }
      } Else
      {
         finalListu := ""
         foldersListu := getDynamicFoldersList()
         Loop, Parse, foldersListu,`n,`r
         {
            line := StrReplace(A_LoopField, "|")
            If (line=folderu)
               finalListu .= StrReplace(A_LoopField, folderu, newName) "`n"
            Else
               finalListu .= StrReplace(A_LoopField, folderu "\", newName "\") "`n"
         }

         DynamicFoldersList := finalListu
         If (SLDtypeLoaded=3)
            recreateDynaFoldersSQLdbList(finalListu)
      }

      currentFilesListModified := 1
      SearchAndReplaceThroughIndex(folderu "\", newName "\", 0, 1)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      ; MsgBox, % firstPart "`n" newName "`n" indexSelected
      If (winOpen=2)
         PanelStaticFolderzManager()
      Else
         PanelDynamicFolderzWindow()
    }
}

SearchAndReplaceThroughIndex(what, replacer, silentus:=0, folderMode:=0) {
    If (silentus=0)
       showTOOLtip("Performing search and replace in the files list index:`n" what "`n" replacer)

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    changeMcursor()
    selectedFiles := markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    newArrayu := []
    totalAffected := 0
    If (SLDtypeLoaded=3)
    {
       whatESC := SQLescapeStr(what)
       replacerESC := SQLescapeStr(replacer)
       ; activeSQLdb.EscapeStr(what)
       ; activeSQLdb.EscapeStr(replacer)
       activeSQLdb.Exec("BEGIN TRANSACTION;")
       If (folderMode=1)
          SQLstr := "UPDATE images SET imgfolder='" Trimmer(replacerESC, "\") "' WHERE imgfolder='" Trimmer(whatESC, "\") "';"

       If (activeSQLdb.Exec(SQLStr) || folderMode!=1)
       {
          If (folderMode=1)
             SQLstr := "SELECT imgidu, imgfolder FROM images WHERE imgfolder LIKE '" Trimmer(SQLescapeStr(what, 1), "\") "\%' ESCAPE '>';"
          Else
             SQLstr := "SELECT imgidu, imgfolder FROM images WHERE imgfolder LIKE '%" Trimmer(SQLescapeStr(what, 1)) "%' ESCAPE '>';"

          If !activeSQLdb.GetTable(SQLstr, RecordSet)
             errorOccured := activeSQLdb.ErrorMsg

          Loop, % RecordSet.RowCount
          {
              Row := RecordSet.Rows[A_Index]
              If Row[2]
              {
                 newFolderName := StrReplace(Row[2], what, replacer)
                 SQLstr := "UPDATE images SET imgfolder='" SQLescapeStr(newFolderName) "' WHERE imgidu='" Row[1] "';"
                 If !activeSQLdb.Exec(SQLstr)
                    failedFiles++
              }
          }
          RecordSet.Free()
       } Else errorOccured := activeSQLdb.ErrorMsg
       activeSQLdb.Exec("COMMIT TRANSACTION;")
    }

    If !errorOccured
    {
       Loop, % maxFilesIndex + 1
       {
           r := getIDimage(A_Index)
           If (InStr(r, "||") || !r)
              Continue

           countFiles++
           newArrayu[countFiles] := resultedFilesList[A_Index]
           newArrayu[countFiles, 1] := StrReplace(newArrayu[countFiles, 1], what, replacer, affected)
           totalAffected += affected
           If (resultedFilesList[A_Index, 2]=1)
              selectedFiles++
       }
    }

    ;  E:\Trash-100\meta\poze\soft\_older-selection\001 (6).jpg
    currentFilesListModified := 1
    renewCurrentFilesList()
    maxFilesIndex := countFiles
    resultedFilesList := newArrayu.Clone()
    markedSelectFile := selectedFiles
    ForceRefreshNowThumbsList()
    currentFileIndex := clampInRange(oldIndex, 1, maxFilesIndex)
    dummyTimerDelayiedImageDisplay(50)
    If (SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    If errorOccured
    {
       showTOOLtip("Failed to update the files list database`n" errorOccured)
       SoundBeep , 300, 100
    } Else
    {
       If failedFiles
          someErrors := "Failed to modify " groupDigits(failedFiles) " entries in the files list`n"
       showTOOLtip(someErrors "Finished updating the files list`n" groupDigits(totalAffected) " records were modified")
       SoundBeep , 900, 100
    }
    CurrentSLD := backCurrentSLD
    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -200
}

SearchAndReplaceSeenDB(what, replacer) {
    initSeenImagesListDB()
    If (sqlFailedInit=1)
    {
       showTOOLtip("Failed to initialize database of seen images")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    changeMcursor()
    showTOOLtip("Performing search and replace in the seen database list:`n" what "`n" replacer)
    whatESC := what
    replacerESC := replacer
    seenImagesDB.EscapeStr(whatESC)
    seenImagesDB.EscapeStr(replacerESC)
    seenImagesDB.Exec("BEGIN TRANSACTION;")
    SQLstr := "SELECT ROWID, imgfile FROM images WHERE imgfile LIKE '%" Trimmer(SQLescapeStr(what, 1)) "%' ESCAPE '>';"
    If !seenImagesDB.GetTable(SQLstr, RecordSet)
       errorOccured := seenImagesDB.ErrorMsg

    totalAffected := failedFiles := 0
    If !errorOccured
    {
       Loop, % RecordSet.RowCount
       {
           Row := RecordSet.Rows[A_Index]
           If Row[2]
           {
              newFolderName := StrReplace(Row[2], what, replacer)
              SQLstr := "UPDATE images SET imgfile='" SQLescapeStr(newFolderName) "' WHERE ROWID='" Row[1] "';"
              If !seenImagesDB.Exec(SQLstr)
                 failedFiles++
              Else
                 totalAffected++
           }
       }
       RecordSet.Free()
    }

    k := seenImagesDB.Exec("COMMIT TRANSACTION;")
    If (errorOccured || !k)
    {
       showTOOLtip("Failed to update the seen images database`n" errorOccured)
       SoundBeep , 300, 100
    } Else
    {
       If failedFiles
          someErrors := "Failed to modify " groupDigits(failedFiles) " entries in the seen images database`n"
       showTOOLtip(someErrors "Finished updating the seen images database`n" groupDigits(totalAffected) " records were modified")
       SoundBeep , 900, 100
    }

    CurrentSLD := backCurrentSLD
    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -200
}

BTNupdateSelectedStaticFolder() {
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded!=3)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
    }

    If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
       Return
    }

    If (RecursiveStaticRescan!=1)
       isRecursive := "|"

    BtnCloseWindow()
    Sleep, 5
    showTOOLtip("Preparing files list, please wait.`n" isRecursive folderu "\")
    coreAddNewFolder(isRecursive folderu, 0, 1, 0)
    SQLdeleteEntriesMarked()
    modus := isRecursive ? 1 : 0
    updateCachedStaticFolders(folderu, modus)
    Sleep, 5
    SetTimer, RemoveTooltip, % -msgDisplayTime
    PanelStaticFolderzManager()
}


filterListViewStaticFoldersList() {
   GuiControlGet, listViewFilteru
   If (imageLoading=1)
      Return

   If (SLDtypeLoaded=3)
      PopulateStaticSQLfolderzList(listViewFilteru)
   Else
      PopulateStaticFolderzList(listViewFilteru)
}

PopulateStaticSQLfolderzList(listFilter:=0) {
    If (mustGenerateStaticFolders=1 || SLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
       Return

    Tooltip, Gathering folders list - please wait
    EM_SETCUEBANNER(hEditField, "Gathering folders list - please wait", 0)
    startOperation := A_TickCount
    setImageLoading()
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    startZeit := A_TickCount

    LV_ModifyCol(5, "Integer")
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")

    RecordSet := ""
    SQL := "SELECT imgfolder, COUNT(*) FROM images GROUP BY imgfolder;"
    If !activeSQLdb.GetTable(SQL, RecordSet)
    {
       throwSQLqueryDBerror(A_ThisFunc)
       SetTimer, ResetImgLoadStatus, -200
       Return 0
    }

    arrayList := []
    fCountThese := countThese := 0
    Loop, % RecordSet.RowCount
    {
        Rowu := RecordSet.Rows[A_Index]
        ; If (Row[1] && Row[2])
        ; {
           fCountThese++
           arrayList[fCountThese] := [Rowu[1], Rowu[2]]
        ; }
    }

    RecordSet.Free()
    foldersDatesArray := []
    SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
    If !activeSQLdb.GetTable(SQL, RecordSet)
    {
       throwSQLqueryDBerror(A_ThisFunc)
       SetTimer, ResetImgLoadStatus, -200
       Return 0
    }

    Loop, % RecordSet.RowCount
    {
        Rowu := RecordSet.Rows[A_Index]
        foldersDatesArray[CalcStringHash(Rowu[1], 0x8003)] := [Rowu[2], Rowu[1]]
    }

    RecordSet.Free()
    doStartLongOpDance()
    startOperation := A_TickCount
    Loop, % fCountThese
    {
        folderu := Trimmer(arrayList[A_Index, 1])
        If (StrLen(folderu)<5) || (listFilter && !InStr(folderu, listFilter))
           Continue

        countThese++
        hashu := CalcStringHash(folderu, 0x8003)
        oldDateu := foldersDatesArray[hashu, 1]
        foldersDatesArray[hashu] := "done"
        FileGetTime, dirDate, % folderu, M
        statusu := (dirDate!=oldDateu) ? "(*)" : "_"
        dirDate := oldDateu
        FormatTime, dirDate, % dirDate, yyyy/MM/dd-HH:mm
        countFiles := arrayList[A_Index, 2]

        LV_Add(A_Index, A_Index, dirDate, statusu, folderu, countFiles)
        If (A_Index=5)
        {
           ; msgbox, % folderu "`n" countFiles
           Loop, 5
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }

    EM_SETCUEBANNER(hEditField, "Filter folders list", 0)
    executingCanceableOperation := 0
    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")

    LV_ModifyCol(3, "Sort")
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

PopulateStaticFolderzList(listFilter:=0) {
    If (mustGenerateStaticFolders=1 || SLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
       Return

    EM_SETCUEBANNER(hEditField, "Preparing folders list - please wait", 0)
    startOperation := A_TickCount
    setImageLoading()
    Tooltip, Preparing folders list - please wait.
    arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    startZeit := A_TickCount
    If (CountFilesFolderzList=1)
       dropFilesSelection(1)

    LV_ModifyCol(5, "Integer")
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")
    doStartLongOpDance()
    startOperation := A_TickCount
    thisIndex := foldersCount := 0

    Tooltip, Listing folders now - please wait...
    Loop, % countStaticFolders
    {
        thisIndex := A_Index
        folderu := arrayList[A_Index, 1]
        If (StrLen(folderu)<2) || (listFilter && !InStr(folderu, listFilter))
           Continue

        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           CountFilesFolderzList := 0
           Break
        }

        oldDateu := arrayList[A_Index, 2]
        FileGetTime, dirDateO, % folderu, M
        statusu := (dirDateO!=oldDateu) ? "(*)" : "_"
        dirDate := SubStr(dirDateO, 1, StrLen(dirDate)-2)
        FormatTime, dirDate, % dirDate, yyyy/MM/dd-HH:mm
        countFiles := arrayList[A_Index, 3] ; countedFilesArray[countThese] ; : "-"

        LV_Add(A_Index, thisIndex, dirDate, statusu, folderu, countFiles)
        If (A_Index=5)
        {
           Loop, 5
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }
    ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 

    EM_SETCUEBANNER(hEditField, "Filter folders list", 0)
    executingCanceableOperation := 0
    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")

    LV_ModifyCol(3, "Sort")
    SetTimer, ResetImgLoadStatus, -25
    If (CountFilesFolderzList=1)
    {
       SoundBeep, 900, 100
       CountFilesFolderzList := 0
       GuiControl, SettingsGUIA:, CountFilesFolderzList, 0
    }
    Tooltip
}

StrPutVar(string, ByRef var, encoding) {
    ; Ensure capacity.
    ; StrPut returns char count, but VarSetCapacity needs bytes.
    VarSetCapacity(var, StrPut(string, encoding) * ((encoding="utf-16"||encoding="cp1200") ? 2 : 1))
    ; Copy or convert the string.
    return StrPut(string, &var, encoding)
}

PopulateDynamicFolderzList() {
    listu := getDynamicFoldersList()
    Gui, SettingsGUIA: ListView, LViewDynas
    Loop, Parse, listu, `n
    {
        line := Trimmer(A_LoopField)
        If (StrLen(line)<3)
           Continue

        counteru++
        statusu := InStr(line, "|") ? "_" : "[R]"
        LV_Add(A_Index, counteru, statusu, line)
    }

    Loop, 3
        LV_ModifyCol(A_Index, "AutoHdr Left")

    ResetImgLoadStatus()
}

CloseWindow(forceIT:=0, cleanCaches:=1) {
    Critical, on
    If (toolTipGuiCreated=2)
       SetTimer, RemoveTooltip, -9500

    If (prevOpenedWindow[6]=1)
       ToggleImgQuality("highu")

    fnOutputDebug("Close window: " prevOpenedWindow[1] "---" prevOpenedWindow[2])
    isFakeWin := prevOpenedWindow[5]
    If (isFakeWin && AnyWindowOpen)
    {
       AnyWindowOpen := 0
       interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
       SetTimer, CloseMsgBox2Win, Delete
       SetTimer, WatchMsgBox2Win, Delete
       MsgBox2Result := "win_closed"
       MsgBox2InputHook.Stop()
       Gui, WinMsgBox: Destroy
       MsgBox2hwnd := ""
       Sleep, 25
       Return
    }

    If (forceIT!="yes")
    {
       If (A_TickCount - lastLongOperationAbort < 1000)
          Return
    }

    Sleep, 5
    If (imgEditPanelOpened!=1)
       ResetImgLoadStatus()

    If (AnyWindowOpen>0 && imgEditPanelOpened=1)
       Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%

    Global lastOtherWinClose := A_TickCount
    interfaceThread.ahkassign("AnyWindowOpen", 0)
    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    ForceNoColorMatrix := 0
    DestroyGIFuWin()
    Gui, SettingsGUIA: Destroy
    WinActivate, ahk_id %PVhwnd%
    interfaceThread.ahkassign("imgEditPanelOpened", 0)
    If globalhFIFimg
    {
       FreeImage_UnLoad(globalhFIFimg)
       globalhFIFimg := ""
    }

    If (imgEditPanelOpened=1)
    {
       If (AnyWindowOpen=23 && editingSelectionNow=1)
       {
          If (FillAreaShape<=2)
             EllipseSelectMode := 0
          Else If (FillAreaShape=3)
             EllipseSelectMode := 1
          Else If (FillAreaShape=7)
             EllipseSelectMode := 2
       }

       editingSelectionNow := prevOpenedWindow[4]
       TriggerMenuBarUpdate()
       livePreviewInsertTextinArea("kill")
       If (cleanCaches!=0)
       {
          corePasteInPlaceActNow("kill")
          coreFillSelectedArea("kill")
          livePreviewDesaturateArea("kill")
       }
       SetTimer, dummyRefreshImgSelectionWindow, -200
    }

    imgEditPanelOpened := AnyWindowOpen := 0
}

CreateOSDinfoLine(msg:=0, killWin:=0, forceDarker:=0, perc:=0) {
    ; Critical, On
    Static prevMsg, preventKill, lastInvoked := 1

    If (killWin=1 || StrLen(msg)<3)
    {
       If (A_TickCount - lastInvoked<msgDisplayTime + 900) && (preventKill=1)
       || (A_TickCount - lastInvoked<350) && (killWin=1 && slideShowRunning!=1)
       {
          SetTimer, RemoveTooltip, -400
          Return
       }

       toolTipGuiCreated := 0
       interfaceThread.ahkassign("toolTipGuiCreated", 0)
       clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
       preventKill := 0
       Return
    }

    If (A_TickCount - lastInvoked<95) && (forceDarker!=1)
    {
       SetTimer, dummyPrevShowToolTip, -200
       Return
    }
    If (A_TickCount - lastInvoked<msgDisplayTime - 300) && (preventKill=1 && prevMsg!=msg && runningLongOperation!=1)
       msgBoxWrapper(appTitle ": ERROR", prevMsg, 0, 0, "error")

    addJournalEntry("OSD: " msg)
    If (!CurrentSLD && currentFileIndex!=0) || (forceDarker=1)
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x66" WindowBgrColor, 1)
    Else
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)

    preventKill := 0
    If RegExMatch(msg, "i)^(error|failed)")
    {
       preventKill := 1
       uBrushA := Gdip_BrushCreateSolid("0xEEFF2200")
    } Else If RegExMatch(msg, "i)^(WARNING|operation aborted)")
       uBrushA := Gdip_BrushCreateSolid("0xEEFFDE21")

    knobSize := imgHUDbaseUnit//3.5
    posXu := uBrushA ? knobSize : 0
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    BoxBMP := drawTextInBox(msg, OSDFontName, OSDfntSize, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0)
    If !BoxBMP
    {
       Gdip_DeleteBrush(uBrushA)
       Return
    }

    Gdip_GetImageDimensions(BoxBMP, imgW, imgH)
    posYu := perc ? knobSize//2 : 0
    trGdip_DrawImage(A_ThisFunc, 2NDglPG, BoxBMP, posXu, posYu, imgW, imgH)
    If uBrushA
    {
       Gdip_FillRectangle(2NDglPG, uBrushA, 0, posYu, knobSize, imgH)
       Gdip_FillRectangle(2NDglPG, uBrushA, imgW + posXu, posYu, knobSize, imgH)
    }

    If perc
    {
       percW := Round(mainWidth*perc)
       Gdip_FillRectangle(2NDglPG, pBrushE, percW, 0, mainWidth - percW + 1, knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushB, 0, knobSize//2, mainWidth, 3)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, percW, knobSize//2)
    }

    r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
    trGdip_DisposeImage(BoxBMP, 1)
    Gdip_DeleteBrush(uBrushA)
    toolTipGuiCreated := 1
    prevMsg := msg
    If (prevMsg!=msg)
       lastInvoked := A_TickCount

    lastOSDtooltipInvoked := A_TickCount
    If (forceDarker!=1)
       interfaceThread.ahkassign("toolTipGuiCreated", 1)
}

BlackedCreator(thisOpacity, killWin:=0) {
    Critical, On
    Static lastInvoked := 1
    If (killWin=1)
    {
       Gui, BlackGuia: Destroy
       Return
    }

    If (A_TickCount - lastInvoked<250)
       Return

    lastInvoked := A_TickCount
    Gui, BlackGuia: Destroy
    Sleep, 5
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    Gui, BlackGuia: -DPIScale -Caption +Owner%PVhwnd% +ToolWindow +E0x80000 +E0x20 +hwndhGuiBlack
    Gui, BlackGuia: Color, c%OSDbgrColor%
    Gui, BlackGuia: Margin, 0, 0
    Gui, BlackGuia: Add, Text,+0x80 c%OSDtextColor% w%mainWidth% h%mainHeight% gRemoveTooltip, %msg%
    JEE_ClientToScreen(hPicOnGui1, 1, 1, GuiX, GuiY)
    WinSet, Transparent, %thisOpacity%, ahk_id %hGuiBlack%
    WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight%, ahk_id %hGuiBlack%
    ; GuiX := GuiY := 0
    Gui, BlackGuia: Show, NoActivate AutoSize x%GuiX% y%GuiY%, GuiBlackedWin
    ; SetParentID(PVhwnd, hGuiBlack)
}

DestroyGIFuWin() {
    If (slideShowRunning=1 || animGIFplaying=1)
       SetTimer, ResetImgLoadStatus, -15

    autoChangeDesiredFrame("stop")
}

; =================================================================================================
; Function......: GetModuleFileNameEx
; DLL...........: Kernel32.dll / Psapi.dll
; Library.......: Kernel32.lib / Psapi.lib
; U/ANSI........: GetModuleFileNameExW (Unicode) and GetModuleFileNameExA (ANSI)
; Author........: jNizM
; Modified......:
; Links.........: http://msdn.microsoft.com/en-us/library/windows/desktop/ms683198(v=vs.85).aspx
; =================================================================================================

GetModuleFileNameEx(PID) {
; found on: https://autohotkey.com/board/topic/109557-processid-a-scriptfullpath/

    hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x001F0FFF, "UInt", 0, "UInt", PID)
    If (ErrorLevel || hProcess = 0)
       Return
    Static lpFilename, nSize := 260, int := VarSetCapacity(lpFilename, nSize, 0)
    DllCall("Psapi.dll\GetModuleFileNameEx", "Ptr", hProcess, "Ptr", 0, "Str", lpFilename, "UInt", nSize)
    DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
    Return lpFilename
}

GetCurrentProcessId() {
    Return DllCall("Kernel32.dll\GetCurrentProcessId")
}

Fnt_GetListOfFonts() {
; function stripped down from Font Library 3.0 by jballi
; from https://autohotkey.com/boards/viewtopic.php?t=4379

    Static Dummy65612414
          ,HWND_DESKTOP := 0   ;-- Device constants
          ,LF_FACESIZE  := 32  ;-- In TCHARS - LOGFONT constants

    ;-- Initialize and populate LOGFONT structure
    Fnt_EnumFontFamExProc_List := ""
    p_CharSet := 1
    p_Flags := 0x800
    VarSetCapacity(LOGFONT,A_IsUnicode ? 92:60,0)
    NumPut(p_CharSet,LOGFONT,23,"UChar")                ;-- lfCharSet

    ;-- Enumerate fonts
    EFFEP := RegisterCallback("Fnt_EnumFontFamExProc","F")
    hDC := Gdi_GetDC(HWND_DESKTOP)
    DllCall("gdi32\EnumFontFamiliesExW"
       ,"Ptr", hDC                                      ;-- hdc
       ,"Ptr", &LOGFONT                                 ;-- lpLogfont
       ,"Ptr", EFFEP                                    ;-- lpEnumFontFamExProc
       ,"Ptr", p_Flags                                  ;-- lParam
       ,"UInt", 0)                                      ;-- dwFlags (must be 0)

    DllCall("user32\ReleaseDC","Ptr",HWND_DESKTOP,"Ptr",hDC)
    DllCall("GlobalFree", "Ptr", EFFEP)
    Return Fnt_EnumFontFamExProc_List
}

Fnt_EnumFontFamExProc(lpelfe,lpntme,FontType,p_Flags) {
    Fnt_EnumFontFamExProc_List := 0
    Static Dummy62479817
          ,LF_FACESIZE := 32     ;-- In TCHARS - LOGFONT constants

    l_FaceName := StrGet(lpelfe+28,LF_FACESIZE)
    FontList.Push(l_FaceName)    ;-- Append the font name to the list
    Return 1                     ;-- Continue enumeration
}

ST_Insert(insert,input,pos=1) {
  Length := StrLen(input)
  ((pos > 0) ? (pos2 := pos - 1) : (((pos = 0) ? (pos2 := StrLen(input),Length := 0) : (pos2 := pos))))
  output := SubStr(input, 1, pos2) . insert . SubStr(input, pos, Length)
  If (StrLen(output) > StrLen(input) + StrLen(insert))
     ((Abs(pos) <= StrLen(input)/2) ? (output := SubStr(output, 1, pos2 - 1) . SubStr(output, pos + 1, StrLen(input)))
     : (output := SubStr(output, 1, pos2 - StrLen(insert) - 2) . SubStr(output, pos - StrLen(insert), StrLen(input))))
  Return output
}

SetVolume(val:=100, r:="") {
; Function by Drugwash
  v := Round(val*655.35)
  vr := r="" ? v : Round(r*655.35)
  Try DllCall("winmm\waveOutSetVolume", "UInt", 0, "UInt", (v|vr<<16))
}

initCompiled(mode) {
   fullPath2exe := GetModuleFileNameEx(QPVpid)
   If (mode=1)
   {
      zPlitPath(fullPath2exe, 0, OutFileName, OutDir)
      mainCompiledExe := OutFileName
      mainCompiledPath := OutDir
      thumbsCacheFolder := OutDir "\thumbs-cache"
      mainSettingsFile := OutDir "\" mainSettingsFile
      mainRecentsFile := OutDir "\" mainRecentsFile
      mainFavesFile := OutDir "\" mainFavesFile
      miniFavesFile := OutDir "\" miniFavesFile
   } Else
   {
      mainCompiledPath := A_ScriptDir
      unCompiledExePath := Chr(34) fullPath2exe Chr(34) A_Space Chr(34) A_ScriptFullPath Chr(34)
   }
}

RunAdminMode() {
  If !A_IsAdmin
  {
      Try {
         If A_IsCompiled
            Run *RunAs "%fullPath2exe%" /restart
         Else
            Run *RunAs "%A_AhkPath%" /restart "%A_ScriptFullPath%"

         ExitApp
      }
  }
}

FileAssociate(Label,Ext,Cmd,Icon:="", batchMode:=0) {
  Static q := Chr(34)
  ; by Ħakito: https://autohotkey.com/boards/viewtopic.php?f=6&t=55638 
  ; modified by Marius Șucan to AHK v1.1
  ; Weeds out faulty extensions, which must start with a period, and contain more than 1 character
  IF (SubStr(Ext,1,1)!="." || StrLen(Ext)<=1)
     Return 0

  ; Weeds out faulty labels such as ".exe" which is an extension and not a label
  IF (SubStr(Label,1,1)=".")
     Return 0

  If Label
     RegRead, CheckLabel, HKEY_CLASSES_ROOT\%Label%, FriendlyTypeName

  ; Do not allow the modification of some important registry labels
  iF (Cmd!="" && CheckLabel)
     Return 0

  regFile := "Windows Registry Editor Version 5.00`n`n"
  ; Note that "HKEY_CLASSES_ROOT" actually writes to "HKEY_LOCAL_MACHINE\SOFTWARE\Classes"
  ; If the command is just a simple path, then convert it into a proper run command
  iF (SubStr(Cmd,2,2)=":\" && FileExist(Cmd))
     Cmd := q Cmd q A_Space q "%1" q
  Else
     Return 0

  Cmd := StrReplace(Cmd, "\", "\\")
  Cmd := StrReplace(Cmd, """", "\""")
  typeInfo := "`n""ContentType""=" q "image/" Ext q "`n""PerceivedType""=" q "image" q "`n"
  regFile .= "[HKEY_CLASSES_ROOT\" Ext "]`n@=" q Label q typeInfo
  regFile .= "`n[HKEY_CLASSES_ROOT\" Label "]`n@=" q Label q "`n"
  regFile .= "`n[HKEY_CLASSES_ROOT\" Label "\Shell\Open\Command]`n@=" q Cmd q "`n"

  regFile .= "`n[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\" Ext "]`n@=" q Label q typeInfo
  regFile .= "`n[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\" Label "]`n@=" q Label q "`n"
  regFile .= "`n[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\" Label "\Shell\Open\Command]`n@=" q Cmd q "`n"

  regFile .= "`n[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\" Ext "\UserChoice]`n""ProgId""=" q Label q "`n"
  regFile .= "`n[-HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\" Ext "\OpenWithProgids]`n"
  regFile .= "`n[-HKEY_CLASSES_ROOT\" Ext "\OpenWithProgids]`n`n"

  ; If Icon
  ;    regFile .= "`n[HKEY_CLASSES_ROOT\" QPVslideshow "\DefaultIcon]`n@=" Icon "`n`n"
  If !FolderExist(mainCompiledPath "\regFiles")
  {
     FileCreateDir, %mainCompiledPath%\regFiles
     If ErrorLevel
        Return 0

     Sleep, 1
  }

  iExt := StrReplace(Ext, ".")
  FileDelete, %mainCompiledPath%\regFiles\RegFormat%iExt%.reg
  Sleep, 1
  FileAppend, % regFile, %mainCompiledPath%\regFiles\RegFormat%iExt%.reg, UTF-16
  If ErrorLevel
     Return 0

  runTarget := "Reg Import " q mainCompiledPath "\regFiles\RegFormat" iExt ".reg" q "`n"
  If !InStr("|WIN_7|WIN_8|WIN_8.1|WIN_VISTA|WIN_2003|WIN_XP|WIN_2000|", "|" A_OSVersion "|")
     runTarget .= q mainCompiledPath "\SetUserFTA.exe" q A_Space Ext A_Space Label "`n"

  FileAppend, % runTarget, %mainCompiledPath%\regFiles\runThis.bat
  If ErrorLevel
     Return 0

  If (batchMode!=1)
  {
     Sleep, 1
     Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
     Sleep, 1
     FileDelete, %mainCompiledPath%\regFiles\RegFormat%iExt%.reg
     FileDelete, %mainCompiledPath%\regFiles\runThis.bat
  }

  Return 1
}


; ==================================================================================================================================
; function by «just me», source https://www.autohotkey.com/boards/viewtopic.php?t=18081
;
; Creates an 'open with' menu for the passed file.
; Parameters:
;     FilePath    -  Fully qualified path of a single file.
;     Recommended -  Show only recommended apps (True/False).
;                    Default: True
;     ShowMenu    -  Immediately show the menu (True/False).
;                    Default: False
;     MenuName    -  The name of the menu.
;                    Default: OpenWithMenu
;     Others      -  Name of the submenu holding not recommended apps (if Recommended has been set to False).
;                    Default: Others
; Return values:
;     On success the function returns the menu's name unless ShowMenu has been set to True.
;     If the menu couldn't be created, the function returns False.
; Remarks:
;     Requires AHK 1.1.23.07+ and Win Vista+!!!
;     The function registers itself as the menu handler.
; Credits:
;     Based on code by querty12 -> autohotkey.com/boards/viewtopic.php?p=86709#p86709.
;     I hadn't even heard anything about the related API functions before.
; MSDN:
;     SHAssocEnumHandlers -> msdn.microsoft.com/en-us/library/bb762109%28v=vs.85%29.aspx
;     SHCreateItemFromParsingName -> msdn.microsoft.com/en-us/library/bb762134%28v=vs.85%29.aspx
; ==================================================================================================================================
CreateOpenWithMenu(FilePath, Recommended := 1, ShowMenu := 0, MenuName := "OpenWithMenu", Others := "Others") {
   Static RecommendedHandlers := []
        , OtherHandlers := []
        , HandlerID := A_TickCount
        , HandlerFunc := 0
        , ThisMenuName := ""
        , ThisOthers := ""
   ; -------------------------------------------------------------------------------------------------------------------------------
   Static IID_IShellItem := 0, BHID_DataObject := 0, IID_IDataObject := 0
        , Init := VarSetCapacity(IID_IShellItem, 16, 0) . VarSetCapacity(BHID_DataObject, 16, 0)
          . VarSetCapacity(IID_IDataObject, 16, 0)
          . DllCall("Ole32.dll\IIDFromString", "WStr", "{43826d1e-e718-42ee-bc55-a1e261c37bfe}", "Ptr", &IID_IShellItem)
          . DllCall("Ole32.dll\IIDFromString", "WStr", "{B8C0BD9F-ED24-455c-83E6-D5390C4FE8C4}", "Ptr", &BHID_DataObject)
          . DllCall("Ole32.dll\IIDFromString", "WStr", "{0000010e-0000-0000-C000-000000000046}", "Ptr", &IID_IDataObject)
   ; -------------------------------------------------------------------------------------------------------------------------------
   ; Handler call
   If (Recommended = HandlerID) {
      AssocHandlers := A_ThisMenu = ThisMenuName ? RecommendedHandlers : OtherHandlers
      If (AssocHandler := AssocHandlers[A_ThisMenuItemPos]) && FileExist(FilePath) {
         AssocHandlerInvoke := NumGet(NumGet(AssocHandler + 0, "UPtr"), A_PtrSize * 8, "UPtr")
         If !DllCall("Shell32.dll\SHCreateItemFromParsingName", "WStr", FilePath, "Ptr", 0, "Ptr", &IID_IShellItem, "PtrP", Item) {
            BindToHandler := NumGet(NumGet(Item + 0, "UPtr"), A_PtrSize * 3, "UPtr")
            If !DllCall(BindToHandler, "Ptr", Item, "Ptr", 0, "Ptr", &BHID_DataObject, "Ptr", &IID_IDataObject, "PtrP", DataObj) {
               DllCall(AssocHandlerInvoke, "Ptr", AssocHandler, "Ptr", DataObj)
               ObjRelease(DataObj)
            }
            ObjRelease(Item)
         }
      }
      Try Menu, %ThisMenuName%, DeleteAll
      For Each, AssocHandler In RecommendedHandlers
         ObjRelease(AssocHandler)
      For Each, AssocHandler In OtherHandlers
         ObjRelease(AssocHandler)
      RecommendedHandlers := []
      OtherHandlers := []
      Return
   }
   ; -------------------------------------------------------------------------------------------------------------------------------
   ; User call
   If !FileExist(FilePath)
      Return 0

   ThisMenuName := MenuName
   ThisOthers := Others
   SplitPath, FilePath, , , Ext
   For Each, AssocHandler In RecommendedHandlers
      ObjRelease(AssocHandler)
   For Each, AssocHandler In OtherHandlers
      ObjRelease(AssocHandler)
   RecommendedHandlers:= []
   OtherHandlers:= []
   Try Menu, %ThisMenuName%, DeleteAll
   Try Menu, %ThisOthers%, DeleteAll
   ; Try to get the default association
   Size := VarSetCapacity(FriendlyName, 520, 0) // 2
   DllCall("Shlwapi.dll\AssocQueryString", "UInt", 0, "UInt", 4, "Str", "." . Ext, "Ptr", 0, "Str", FriendlyName, "UIntP", Size)
   HandlerID := A_TickCount
   HandlerFunc := Func(A_ThisFunc).Bind(FilePath, HandlerID)
   Filter := !!Recommended ; ASSOC_FILTER_NONE = 0, ASSOC_FILTER_RECOMMENDED = 1
   ; Enumerate the apps and build the menu
   If DllCall("Shell32.dll\SHAssocEnumHandlers", "WStr", "." . Ext, "UInt", Filter, "PtrP", EnumHandler)
      Return 0

   EnumHandlerNext := NumGet(NumGet(EnumHandler + 0, "UPtr"), A_PtrSize * 3, "UPtr")
   While (!DllCall(EnumHandlerNext, "Ptr", EnumHandler, "UInt", 1, "PtrP", AssocHandler, "UIntP", Fetched) && Fetched)
   {
      VTBL := NumGet(AssocHandler + 0, "UPtr")
      AssocHandlerGetUIName := NumGet(VTBL + 0, A_PtrSize * 4, "UPtr")
      AssocHandlerGetIconLocation := NumGet(VTBL + 0, A_PtrSize * 5, "UPtr")
      AssocHandlerIsRecommended := NumGet(VTBL + 0, A_PtrSize * 6, "UPtr")
      UIName := ""
      If !DllCall(AssocHandlerGetUIName, "Ptr", AssocHandler, "PtrP", StrPtr, "UInt")
      {
         UIName := StrGet(StrPtr, "UTF-16")
         DllCall("Ole32.dll\CoTaskMemFree", "Ptr", StrPtr)
      } Else UIName := AssocHandler

      If (UIName!="")
      {
         If !DllCall(AssocHandlerGetIconLocation, "Ptr", AssocHandler, "PtrP", StrPtr, "IntP", IconIndex := 0, "UInt")
         {
            IconPath := StrGet(StrPtr, "UTF-16")
            DllCall("Ole32.dll\CoTaskMemFree", "Ptr", StrPtr)
         }

         If (SubStr(IconPath, 1, 1) = "@")
         {
            VarSetCapacity(Resource, 4096, 0)
            If !DllCall("Shlwapi.dll\SHLoadIndirectString", "WStr", IconPath, "Ptr", &Resource, "UInt", 2048, "PtrP", 0)
               IconPath := StrGet(&Resource, "UTF-16")
         }
         ItemName := StrReplace(UIName, "&", "&&")
         If (Recommended || !DllCall(AssocHandlerIsRecommended, "Ptr", AssocHandler, "UInt"))
         {
            If (UIName=FriendlyName)
            {
               If RecommendedHandlers.Count()
               {
                  Menu, %ThisMenuName%, Insert, 1&, %ItemName%, % HandlerFunc
                  RecommendedHandlers.InsertAt(1, AssocHandler)
               } Else
               {
                  Menu, %ThisMenuName%, Add, %ItemName%, % HandlerFunc
                  RecommendedHandlers.Push(AssocHandler)
               }
         ;      Menu, %ThisMenuName%, Default, %ItemName%
            } Else
            {
               Menu, %ThisMenuName%, Add, %ItemName%, % HandlerFunc
               RecommendedHandlers.Push(AssocHandler)
            }
            Try Menu, %ThisMenuName%, Icon, %ItemName%, %IconPath%, %IconIndex%
         } Else
         {
            Menu, %ThisOthers%, Add, %ItemName%, % HandlerFunc
            OtherHandlers.Push(AssocHandler)
            Try Menu, %ThisOthers%, Icon, %ItemName%, %IconPath%, %IconIndex%
         }
      } Else ObjRelease(AssocHandler)
   }

   ObjRelease(EnumHandler)
   ; All done
   If !RecommendedHandlers.Count() && !OtherHandlers.Count()
      Return 0

   If OtherHandlers.Count()
      Menu, %ThisMenuName%, Add, %ThisOthers%, :%ThisOthers%

   If (ShowMenu=1)
      Menu, %ThisMenuName%, Show
   Else
      Return ThisMenuName
}

invokeSHopenWith() {
; function by zcooler
; source:  https://www.autohotkey.com/boards/viewtopic.php?t=17850

  ; msdn.microsoft.com/en-us/library/windows/desktop/bb762234(v=vs.85).aspx
  ; OAIF_ALLOW_REGISTRATION   0x00000001 - Enable the "always use this program" checkbox. If not passed, it will be disabled.
  ; OAIF_REGISTER_EXT         0x00000002 - Do the registration after the user hits the OK button.
  ; OAIF_EXEC                 0x00000004 - Execute file after registering.
  OAIF := {ALLOW_REGISTRATION: 0x00000001, REGISTER_EXT: 0x00000002, EXEC: 0x00000004}
  imgPath := getIDimage(currentFileIndex)
  VarSetCapacity(OPENASINFO, A_PtrSize * 3, 0)
  NumPut(&imgPath, OPENASINFO, 0, "Ptr")
  NumPut(0x04, OPENASINFO, A_PtrSize * 2, "UInt")
  DllCall("Shell32.dll\SHOpenWithDialog", "Ptr", 0, "Ptr", &OPENASINFO)
}

ReadSettingsAutoCropPanel() {
    IniAction(0, "AutoCropAdaptiveMode", "General", 1)
    IniAction(0, "ResizeDestFolder", "General", 5)
    IniAction(0, "ResizeUseDestDir", "General", 1)
    IniAction(0, "UIcropThreshold", "General", 2, 0, 99)
    IniAction(0, "userActionConflictingFile", "General", 2, 1, 3)
    IniAction(0, "userJpegQuality", "General", 2, 1, 100)
    IniAction(0, "usrAutoCropColorTolerance", "General", 2, 0, 255)
    IniAction(0, "usrAutoCropDeviation", "General", 2, -50, 50)
    IniAction(0, "usrAutoCropDeviationPixels", "General", 1)
    IniAction(0, "usrAutoCropDeviationSnap", "General", 1)
    IniAction(0, "usrAutoCropGenerateSelection", "General", 1)
}

PanelImgAutoCrop() {
    Global UIcropThreshold, btnFldr, infoCropTolerance, infoCropThreshold, infoCropDeviation, mainBtnACT, editF5
    If (thumbsDisplaying=1)
       ToggleThumbsMode()

    If (vpIMGrotation>0)
    {
       vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    }

    thisBtnHeight := createSettingsGUI(17, A_ThisFunc)
    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 220

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       slide2Wid := slide2Wid + 75
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsAutoCropPanel()
    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    filesElected := getSelectedFiles(0, 1)
    UIcropThreshold := Round(usrAutoCropImgThreshold * 100)
    if (StrLen(UserMemBMP)>2 && !markedSelectFile)
       usrAutoCropGenerateSelection := 1

    Gui, Add, Text, x15 y15 Section, Please adjust the following parameters for best results.
    Gui, Add, Text, xs y+8 w%slide2Wid% vinfoCropTolerance, Color variation tolerance: %usrAutoCropColorTolerance%
    Gui, Add, Text, x+1 yp, Image corners preview
    Gui, -DPIScale
    Gui, Add, Text, xp+1 y+1 w220 h220 +0xE gTglAutoCropBorderzSize +hwndhCropCornersPic, -
    Gui, +DPIScale
    Gui, Add, Slider, xs yp+1 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vusrAutoCropColorTolerance Range0-254, % usrAutoCropColorTolerance
    Gui, Add, Text, xs y+8 w%slide2Wid% vinfoCropThreshold, Image threshold: %UIcropThreshold%
    Gui, Add, Slider, xs y+5 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vUIcropThreshold Range0-99, % UIcropThreshold
    Gui, Add, Text, xs y+8 w%slide2Wid% gresetAutoCropDeviation vinfoCropDeviation, Margins deviation factor: %usrAutoCropDeviation%%measureUnit%
    Gui, Add, Slider, xs y+5 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vusrAutoCropDeviation Range-50-50, %usrAutoCropDeviation%

    Gui, Add, Checkbox, y+10 w%slide2Wid% gUpdateAutoCropParams Checked%usrAutoCropDeviationSnap% vusrAutoCropDeviationSnap, Snap to original image edges
    Gui, Add, Checkbox, x+1 gUpdateAutoCropParams Checked%usrAutoCropDeviationPixels% vusrAutoCropDeviationPixels, Deviation factor in pixels
    Gui, Add, Checkbox, xs y+10 w%slide2Wid% gUpdateAutoCropParams Checked%usrAutoCropGenerateSelection% vusrAutoCropGenerateSelection, Generate an image selection
    Gui, Add, Checkbox, x+1 gUpdateAutoCropParams Checked%AutoCropAdaptiveMode% vAutoCropAdaptiveMode, Adaptive color variations
 
    thisW := (filesElected>1) ? "" : "w1"
    thisH := (filesElected>1) ? "" : "h1"
    thisY := (filesElected>1) ? "+20" : "p-20"
    Gui, Add, Checkbox, xs y+10 gTglRszDestFoldr %thisW% %thisH% Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder: 
    Gui, Add, Edit, xp+10 y+5 wp %thisH% r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 %thisW% %thisH% gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs y+7 %thisW% %thisH%, On file name conflicts
    Gui, Add, DropDownList, x+5 w150 %thisW% %thisH% gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10 %thisW% %thisH%, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 %thisH% number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality

    if (StrLen(UserMemBMP)>2 && !markedSelectFile)
       GuiControl, Disable, usrAutoCropGenerateSelection

    If (filesElected>1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, Files selected to process: %filesElected%.`nMulti-threaded processing not yet implemented.`nFiles in unsupported write formats will be skipped.
       Gui, Font, Normal
    } 

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Add, Button, xs y%thisY% h%thisBtnHeight% w35 gBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gBtnNextImg, >>

    If (filesElected>1)
    {
       Gui, Add, Button, x+5 hp w%btnWid% Default gBTNautoCropRealtime vmainBtnACT, &Viewport preview
       Gui, Add, Button, x+5 hp w%btnWid% gBTNsaveAutoCroppedFile, &Process files...
       Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    } Else
    {
       Gui, Add, Button, x+5 hp w90 Default gBTNautoCropRealtime vmainBtnACT, &Apply
       Gui, Add, Button, x+5 hp w%btnWid% gBTNsaveAutoCroppedFile, &Save image
       Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&lose
    }

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Automatic image crop: " appTitle, winPos)
    Sleep, 1
    captureImgCorners(useGdiBitmap())
    ResetImgLoadStatus()
}

resetAutoCropDeviation() {
    GuiControl, SettingsGUIA:, usrAutoCropDeviation, 0
    UpdateAutoCropParams()
}

UpdateAutoCropParams() {
    GuiControlGet, UIcropThreshold
    GuiControlGet, usrAutoCropColorTolerance
    GuiControlGet, usrAutoCropGenerateSelection
    GuiControlGet, usrAutoCropDeviation
    GuiControlGet, usrAutoCropDeviationSnap
    GuiControlGet, usrAutoCropDeviationPixels
    GuiControlGet, AutoCropAdaptiveMode
    GuiControlGet, ResizeUseDestDir
    GuiControlGet, ResizeDestFolder
    GuiControlGet, userActionConflictingFile
    GuiControlGet, userJpegQuality

    usrAutoCropImgThreshold := UIcropThreshold/100
    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    GuiControl, SettingsGUIA:, infoCropTolerance, Color variation tolerance: %usrAutoCropColorTolerance%
    GuiControl, SettingsGUIA:, infoCropThreshold, Image threshold: %UIcropThreshold%
    GuiControl, SettingsGUIA:, infoCropDeviation, Margins deviation factor: %usrAutoCropDeviation%%measureUnit%
    SetTimer, WriteSettingsAutoCropPanel, -200
}

WriteSettingsAutoCropPanel() {
   INIaction(1, "ResizeUseDestDir", "General")
   INIaction(1, "ResizeDestFolder", "General")
   INIaction(1, "AutoCropAdaptiveMode", "General")
   INIaction(1, "usrAutoCropDeviationPixels", "General")
   INIaction(1, "usrAutoCropDeviationSnap", "General")
   INIaction(1, "usrAutoCropDeviation", "General")
   INIaction(1, "usrAutoCropGenerateSelection", "General")
   INIaction(1, "usrAutoCropColorTolerance", "General")
   INIaction(1, "UIcropThreshold", "General")
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "userActionConflictingFile", "General")
}

TglAutoCropBorderzSize() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 900) && (AutoCropBordersSize!=5)
       AutoCropBordersSize := 5
    Else
       AutoCropBordersSize := (AutoCropBordersSize=15) ? 30 : 15
    captureImgCorners(useGdiBitmap())
    lastInvoked := A_TickCount
}

captureImgCorners(whichBmp) {
   If !whichBmp
      Return

   cornersBMP2 := coreCaptureImgCorners(whichBmp)
   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP2)
   SetImage(hCropCornersPic, hBitmap)
   trGdip_DisposeImage(cornersBMP2, 1)
   Gdi_DeleteObject(hBitmap)
}

coreCaptureImgCorners(whichBmp, thisSize:=0, thisBoxSize:=0) {
    boxSize := (thisBoxSize=0) ? 220 : thisBoxSize
    realSize := (thisSize=0) ? AutoCropBordersSize : thisSize
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, boxSize, boxSize, "0xE200B")
    If !cornersBMP
       Return

    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBmp, imgW, imgH)
    If (editingSelectionNow=1)
    {
       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       X1 := Y1 := 0
       X2 := ImgSelW := imgW
       Y2 := ImgSelH := imgH
    }

    Loop, 3
    {
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, boxSize//2, boxSize//2, X1, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, 0, boxSize//2, boxSize//2, X2 - realSize, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, boxSize//2, boxSize//2, boxSize//2, X1, Y2 - realSize, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, boxSize//2, boxSize//2, boxSize//2, X2 - realSize, Y2 - realSize, realSize, realSize)
    }

    Static borderSize := 8
    Gdip_DeleteGraphics(G)
    cornersBMP2 := trGdip_CreateBitmap(A_ThisFunc, boxSize+borderSize, boxSize+borderSize, "0xE200B")
    If cornersBMP2
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP2, 3)
       If G2
       {
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, cornersBMP, borderSize//2, borderSize//2)
       }
    }

    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(cornersBMP, 1)
    Return cornersBMP2
}

AutoCropAction(zBitmap, varTolerance, threshold, silentMode:=0, forceNoSel:=0) {
   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 0", 0, 0, 0.001)

   aBitmap := trGdip_BitmapConvertGray(zBitmap)
   If !aBitmap
   {
      If (silentMode=0)
      {
         showTOOLtip("Failed to process image for auto-cropping")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   Gdip_GetImageDimensions(aBitmap, Width, Height)
   pBitmap := trGdip_ResizeBitmap(A_ThisFunc, aBitmap, Width//2, Height//2, 0)
   trGdip_DisposeImage(aBitmap, 1)
   If !pBitmap
   {
      If (silentMode=0)
      {
         showTOOLtip("Failed to process image for auto-cropping")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   ; pBitmap := aBitmap
   alphaUniform := Gdip_TestBitmapUniformity(pBitmap, 3, maxLevelIndex, maxLevelPixels)
   If (alphaUniform=1)
   {
      If (silentMode=0)
      {
         showTOOLtip("The image seems to be uniformly colored")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   selCoords := CoreAutoCropAlgo(pBitmap, varTolerance, threshold)
   trGdip_DisposeImage(pBitmap, 1)
   If (selCoords="error")
   {
      SoundBeep, 300, 100
      showTOOLtip("Auto-crop processing aborted by user")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   selCoords := StrSplit(selCoords, ",")
   X1 := selCoords[1], Y1 := selCoords[2]
   X2 := selCoords[3], Y2 := selCoords[4]

   If (silentMode=0)
   {
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, -500
   }

   If (usrAutoCropGenerateSelection=0 || forceNoSel=1)
   {
      newW := X2 - X1
      newH := Y2 - Y1
      kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, zBitmap, X1, Y1, newW, newH)
      return kBitmap
   } Else
   {
      vPselRotation := EllipseSelectMode := 0
      ImgSelX1 := X1, ImgSelY1 := Y1
      ImgSelX2 := X2, ImgSelY2 := Y2
      defineRelativeSelCoords(Width, Height)
   }
}

CoreAutoCropAlgo(pBitmap, varTolerance, threshold, silentMode:=0) {
   If !pBitmap
   {
      addJournalEntry(A_ThisFunc "(): no bitmap given for auto-cropping")
      Return "error"
   }

   interfaceThread.ahkassign("canCancelImageLoad", 1)
   Gdip_GetImageDimensions(pBitmap, Width, Height)
   maxThresholdHitsW := Round(Width*threshold) + 1
   If (maxThresholdHitsW>Width//2)
      maxThresholdHitsW := Width//2

   maxThresholdHitsH := Round(Height*threshold) + 1
   If (maxThresholdHitsH>Height//2)
      maxThresholdHitsH := Height//2

   If (threshold=0)
      maxThresholdHitsW := maxThresholdHitsH := 1

   c := Gdip_GetPixelColor(pBitmap, 1, 1, 2)
   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   If E1
      Return "error"

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 1 - Y1", 0, 0, 0.1)

   c := StrSplit(c, ",")
   prevR1 := firstR1 := c[1]
   x := y := ToleranceHits := abortImgLoad := 0
   Loop %Height%
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      y++
      vX := 0, vY := y - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vX := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Width%
      {
         pX := A_Index-1, pY := y - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
     ;  sleep, 10
      ;    ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsW " [" varTolerance "]" "`n" firstR1 ", " primeR1a ", " primeR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.2, R1 + varTolerance//1.2) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsW)
         {
            ToleranceHits++
         } Else
         {
            Y1 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If Y1
      {
         Y1 := y - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 2 - X1", 0, 0, 0.3)

   prevR1 := firstR1
   x := y := ToleranceHits := 0
   Loop %Width% 
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      x++
      vY := 0, vX := x - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vY := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Height%
      {
         pY := A_Index-1, pX := x - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsH "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsH)
         {
            ToleranceHits++
         } Else
         {
            X1 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If X1
      {
         X1 := x - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 3 - Y2", 0, 0, 0.5)

   Gdip_UnlockBits(pBitmap, BitmapData1)
   Gdip_ImageRotateFlip(pBitmap, 2)
   c := Gdip_GetPixelColor(pBitmap, 1, 1, 2)
   c := StrSplit(c, ",")
   prevR1 := firstR1 := c[1]
   x := y := ToleranceHits := 0
   E2 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   If E2
      Return "error"

   Loop %Height%
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      y++
      vX := 0, vY := y - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vX := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Width%
      {
         pX := A_Index-1, pY := y - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsW "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsW)
         {
            ToleranceHits++
         } Else
         {
            Y2 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If Y2
      {
         Y2 := Height - y - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 4 - X2", 0, 0, 0.8)
   prevR1 := firstR1
   x := y := ToleranceHits := 0
   Loop %Width% 
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      x++
      vY := 0, vX := x - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vY := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Height%
      {
         pY := A_Index-1, pX := x - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsH "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsH)
         {
            ToleranceHits++
         } Else
         {
            X2 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If X2
      {
         X2 := Width - x - 1
         Break
      }
   }

   deviationW := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Width/100)*usrAutoCropDeviation)
   deviationH := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Height/100)*usrAutoCropDeviation)
   If (usrAutoCropDeviationSnap=1 && X1>2) || (usrAutoCropDeviationSnap=0)
      X1 -= deviationW
   If (usrAutoCropDeviationSnap=1 && Y1>2) || (usrAutoCropDeviationSnap=0)
      Y1 -= deviationH
   If (usrAutoCropDeviationSnap=1 && X2<Width-3) || (usrAutoCropDeviationSnap=0)
      X2 += deviationW
   If (usrAutoCropDeviationSnap=1 && Y2<Height-3) || (usrAutoCropDeviationSnap=0)
      Y2 += deviationH

   ; ToolTip, % X1 "," Y1 "--" X2 "," Y2 "`n" maxThresholdHitsW "--" maxThresholdHitsH "--" firstR1, , , 2
   If (X1="" || X1>Width - 2)
      X1 := Width - 3
   If (Y1="" || Y1>Height - 2)
      Y1 := Height - 3
   If (X2="" || X2<3)
      X2 := 3
   If (Y2="" || Y2<3)
      Y2 := 3

   X2 := X2*2, Y2 := Y2*2
   X1 := X1*2, Y1 := Y1*2
   If (X2 < X1 - 2)
      X2 := X1 + 2
   If (Y2 < Y1 - 2)
      Y2 := Y1 + 2

   selCoords := x1 "," y1 "," x2 "," y2
   Gdip_UnlockBits(pBitmap, BitmapData1)
   If (abortImgLoad>1)
      selCoords := "error"

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nDONE", 0, 0, 0.99)
   interfaceThread.ahkassign("canCancelImageLoad", 0)
   Return selCoords
}

BTNsaveAutoCroppedFile() {
    UpdateAutoCropParams()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       batchAutoCropFiles()
       Return
    }

   BTNautoCropRealtime()
   BtnCloseWindow()
   PanelSaveImg()
}

coreAutoCropFileProcessing(imgPath, file2save, silentMode) {
    oBitmap := LoadBitmapFromFileu(imgPath)
    If !oBitmap
       Return -3

    Gdip_GetImageDimensions(oBitmap, oImgW, oImgH)
    pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    kBitmap := AutoCropAction(oBitmap, usrAutoCropColorTolerance, usrAutoCropImgThreshold, silentMode, 1)
    trGdip_DisposeImage(oBitmap, 1)
    If !kBitmap
       Return -1

    Gdip_GetImageDimensions(kBitmap, imgW, imgH)
    If (imgW>oImgW-1) && (imgH>oImgH-1)
       Return -2

    If InStr(pixFmt, "argb")
    {
       isUniform := Gdip_TestBitmapUniformity(kBitmap, 7, maxLevelIndex)
       If (isUniform=1 && (isInRange(maxLevelIndex, 0, 5) || isInRange(maxLevelIndex, 250, 255)))
          Gdip_BitmapSetColorDepth(kBitmap, 24)
    } Else Gdip_BitmapSetColorDepth(kBitmap, 24)

    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 1
    }

    r := Gdip_SaveBitmapToFile(kBitmap, file2save, 90)
    If (r=-2 || r=-1)
       r := SaveFIMfile(file2save, kBitmap)

    trGdip_DisposeImage(kBitmap, 1)
    Return r
}

batchAutoCropFiles() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to crop " filesElected " files? The auto-crop algorithm may take some time to finish going through all of them. Hold ESC to abandon it."
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"

      If (userActionConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."

      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   Sleep, 25
   showTOOLtip("Performing image auto-crop on " filesElected " files, please wait")
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   countFilez := countTFilez := skippedFiles := failedFiles := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (A_TickCount - prevMSGdisplay>3000)
      {
         If failedFiles
            someErrors := "`nErrors occured for " failedFiles "files..."
         If skippedFiles
            someErrors .= "`n" skippedFiles "files were skipped"

         showTOOLtip("Performing image auto-crop on " countTFilez "/" filesElected " files, please wait..." someErrors, 0, 0, (countTFilez + skippedFiles)/filesElected)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      If (!RegExMatch(imgPath, saveTypesRegEX) || StrLen(imgPath)<2)
      {
         skippedFiles++
         Continue
      }

      If (ResizeUseDestDir=1)
      {
         zPlitPath(imgPath, 0, OutFileName, OutDir)
         destImgPath := ResizeDestFolder "\" OutFileName
      } Else destImgPath := imgPath

      If (ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionConflictingFile, performOverwrite)
      }

      countTFilez++
      If !destImgPath
      {
         skippedFiles++
         Continue
      }

      changeMcursor()
      r := coreAutoCropFileProcessing(imgPath, destImgPath, 0)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If failedFiles
      someErrors := "`nErrors occured for " failedFiles "files..."
   If skippedFiles
      someErrors .= "`n" skippedFiles "files were skipped"
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countFilez " out of " filesElected " selected files were processed until now..." someErrors)
   Else
      showTOOLtip(countFilez " out of " countTFilez " selected images were automatically cropped" someErrors)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNautoCropRealtime() {
  Static wasAutoCropped := 0

  lockSelectionAspectRatio := 1
  defineSelectionAspectRatios()
  GuiControl, SettingsGUIA: Disable, mainBtnACT
  SetTimer, reactivateMainBtnACT, -350
  If (AnyWindowOpen=17)
     UpdateAutoCropParams()
  Else If (AnyWindowOpen=12)
     usrAutoCropGenerateSelection := 1

  If (usrAutoCropGenerateSelection=0)
  {
     editingSelectionNow := 0
     wasAutoCropped := performAutoCropNow := 1
     updateUIctrl()
     RefreshImageFile()
     MouseMoveResponder()
  } Else
  {
     resultu := getIDimage(currentFileIndex)
     If FileExist(resultu)
     {
        thumbBMP := LoadBitmapFromFileu(resultu)
        FlipImgV := FlipImgH := vpIMGrotation := performAutoCropNow := 0
        If thumbBMP
        {
           AutoCropAction(thumbBMP, usrAutoCropColorTolerance, usrAutoCropImgThreshold)
           trGdip_DisposeImage(thumbBMP, 1)
        }

        editingSelectionNow := performAutoCropNow := 1
        If (wasAutoCropped=0)
           dummyTimerDelayiedImageDisplay(50)
        Else
           RefreshImageFile()
     }
  }

  If (AnyWindowOpen=17)
  {
     captureImgCorners(useGdiBitmap())
  } Else If (editingSelectionNow=1 && AnyWindowOpen=12)
  {
     GuiControl, SettingsGUIA: Enable, jpegDoCrop
     GuiControl, SettingsGUIA: , jpegDoCrop, 1
  }
}

coreWIAsimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   Try wiaImg := WIA_LoadImage(imgPath)
   If !IsObject(wiaImg)
   {
      addJournalEntry("Failed to load and process image file using WIA`n" imgPath)
      Return 0
   }

   imgW := wiaImg.Width, imgH := wiaImg.Height
   If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
   {
      If (relativeImgSelCoords=1 && editingSelectionNow=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      wiaImg := WIA_CropImage(wiaImg, X1, Y1, X2, Y2)
   }

   If (rotateAngle!=0 && isNumber(rotateAngle))
      wiaImg := WIA_RotateImage(wiaImg, rotateAngle)

   If (SimpleOperationsFlipH=1)
      wiaImg := Wia_FlipImage(wiaImg, "Horizontal")
   If (SimpleOperationsFlipV=1)
      wiaImg := Wia_FlipImage(wiaImg, "Vertical")

   imgW := wiaImg.Width, imgH := wiaImg.Height
   thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
   thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
   changeMcursor()
   If (IsObject(wiaImg) && ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
      Try wiaImg := WIA_ScaleImage(wiaImg, thisW, thisH, 0)

    If (FileExist(file2save) && IsObject(wiaImg))
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    If IsObject(wiaImg)
       r := WIA_SaveImage(wiaImg, file2save)
    Else r := 0

    If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
    {
       r := 0
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

   wiaImg := ""
   Return !r
}

coreGdipSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
    Static imgOrientOpt := {"i000":0, "i100":1, "i200":2, "i300":3, "i010":4, "i110":5, "i210":6, "i310":7, "i001":6, "i101":7, "i201":4, "i301":5, "i011":2, "i111":3, "i211":0, "i311":1}
    oBitmap := trGdip_CreateBitmapFromFile(imgPath)
    If StrLen(oBitmap)>2
    {
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
       pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
       If (InStr(pixFmt, "CMYK") || InStr(pixFmt, "48-") || InStr(pixFmt, "64-"))
          ER := Gdip_BitmapConvertFormat(oBitmap, 0x26200A, 2, 1, 0, 0, 0, 0, 0)
    } Else mustOpenWithWia := 1

    capMaxGDIbmpSize32bits()
    If (imgW<1) || (imgH<1) || InStr(pixFmt, "0x") || ER || (imgW*imgH>maxGDIbmpSize - 10) || (imgW>32100) || (imgH>32100)
       mustOpenWithWia := 1

    If (mustOpenWithWia=1)
    {
       addJournalEntry("Failed to load and process image file using GDI+`n" imgPath)
       trGdip_DisposeImage(oBitmap, 1)
       r := coreWIAsimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
       Return r
    }

    If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
    {
       newPixFmt := InStr(pixFmt, "argb") ? "0x26200A" : "0x21808"   ; 32-bits // 24-bits
       If (relativeImgSelCoords=1 && editingSelectionNow=1)
          calcRelativeSelCoords(oBitmap, imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, oBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, newPixFmt)
       If zBitmap
       {
          trGdip_DisposeImage(oBitmap, 1)
          oBitmap := zBitmap
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    imgFoperation := (rotateAngle=90) ? 1 : 0
    imgFoperation := (rotateAngle=180) ? 2 : imgFoperation
    imgFoperation := (rotateAngle=270) ? 3 : imgFoperation
    imgFoperation := imgOrientOpt["i" imgFoperation SimpleOperationsFlipH SimpleOperationsFlipV]
    If (imgFoperation>0)
       flipErr := Gdip_ImageRotateFlip(oBitmap, imgFoperation)

    If flipErr
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    If (ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
    {
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
       newPixFmt := InStr(pixFmt, "argb") ? "0x26200A" : "0x21808"   ; 32-bits // 24-bits
       resizeFilter := (ResizeQualityHigh=1) ? 7 : 5
       thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
       thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
       changeMcursor()
       zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, thisW, thisH, 0, resizeFilter, newPixFmt)
       If zBitmap
       {
          trGdip_DisposeImage(oBitmap, 1)
          oBitmap := zBitmap
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    If StrLen(oBitmap)>2
    {
       tempFileExists := "r"
       If FileExist(file2save)
       {
          Try FileSetAttrib, -R, % file2save
          Sleep, 0
          FileMove, % file2save, % file2save "-tmp"
          If !ErrorLevel
             tempFileExists := 1
          Sleep, 0
       }

       r := Gdip_SaveBitmapToFile(oBitmap, file2save, 90)
       If (r=-2 || r=-1)
          r := SaveFIMfile(file2save, oBitmap)

       If (r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
       {
          FileDelete, % file2save
          Sleep, 0
          FileMove, % file2save "-tmp", % file2save
       } Else If (tempFileExists=1)
          FileDelete, % file2save "-tmp"

       trGdip_DisposeImage(oBitmap, 1)
    } Else r := 1

    Return r
}

coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
  maxLimitReached := 0 ; (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
  If (RegExMatch(imgPath, RegExFIMformPtrn) || (RegExMatch(imgPath, "i)(.\.(png|tiff|tif))$") && (maxLimitReached!=1 && wasInitFIMlib=1)))
     r := coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
  Else
     r := coreGdipSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
  Return r
}

coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
    Sleep, 0
    loadArgs := 0
    GFT := FreeImage_GetFileType(imgPath)
    If (GFT=34)
       loadArgs := (userHQraw=1) ? 0 : 5
    Else If (GFT=2)
       loadArgs := 8

    hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
    If !hFIFimgA
    {
       addJournalEntry("Failed to load and process image file using FreeImage library`n" imgPath)
       Return "err"
    }

    If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
    {
       FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
       If (relativeImgSelCoords=1 && editingSelectionNow=1)
          calcRelativeSelCoords("--", imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       x1 := Round(X1), y1 := Round(Y1)
       x2 := Round(X2), y2 := Round(Y2)
       changeMcursor()
       hFIFimgB := FreeImage_Copy(hFIFimgA, X1, Y1, X2, Y2)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    If (rotateAngle>0)
    {
       changeMcursor()
       hFIFimgB := FreeImage_Rotate(hFIFimgA, rotateAngle)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    If (SimpleOperationsFlipH=1)
       FreeImage_FlipHorizontal(hFIFimgA)
    If (SimpleOperationsFlipV=1)
       FreeImage_FlipVertical(hFIFimgA)

    If (ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
    {
       FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
       resizeFilter := (ResizeQualityHigh=1) ? 4 : 0
       thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
       thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
       changeMcursor()
       hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, resizeFilter)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    tempFileExists := "r"
    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    saveArg := 0
    If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
       saveArg := clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
    Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
       saveArg := clampInRange(Round(userJpegQuality), 1, 100)

    changeMcursor()
    r := FreeImage_Save(hFIFimgA, file2save, saveArg)

    FreeImage_UnLoad(hFIFimgA)
    If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
    {
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

    Return !r
}

PanelSimpleResizeRotate(modus:="") {
    Global mainBtnACT, btnFldr, editF5
    If !PanelsCheckFileExists()
       Return

    If (vpIMGrotation>0)
    {
       FlipImgV := FlipImgH := vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    } Else If (FlipImgH=1 || FlipImgV=1)
    {
       FlipImgV := FlipImgH := 0
       dummyTimerDelayiedImageDisplay(50)
    } 

    imgPath := getIDimage(currentFileIndex)
    filesElected := getSelectedFiles(0, 1)
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    If (!filesElected && !RegExMatch(imgPath, thisRegEX) && modus!="forced")
    {
       CloseWindow()
       Sleep, 5
       PanelResizeImageWindow()
       Return
    }

    thisBtnHeight := createSettingsGUI(18, A_ThisFunc)
    ReadSettingsImageProcessing()
    btnWid := 100
    txtWid := slideWid := 280
    If (editingSelectionNow!=1)
       SimpleOperationsDoCrop := 0

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }
    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    Gui, Add, Text, x15 y15 Section, Rotate / flip:
    Gui, Add, DropDownList, x+5 w100 AltSubmit Choose%SimpleOperationsRotateAngle% vSimpleOperationsRotateAngle, 0°|90°|180°|-90° [270°]
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipV% vSimpleOperationsFlipV, Vertical
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipH% vSimpleOperationsFlipH, Horizontal
    ; Gui, Add, ComboBox, x+5 w100 vSimpleOperationsScaleXimgFactor, 5 `%|10 `%|20 `%|50 `%|75 `%|100 `%|200 `%|500 `%|950 `%|%SimpleOperationsScaleXimgFactor%||
    ; Gui, Add, ComboBox, x+5 w100 vSimpleOperationsScaleYimgFactor, 5 `%|10 `%|20 `%|50 `%|75 `%|100 `%|200 `%|500 `%|950 `%|%SimpleOperationsScaleYimgFactor%||
    Gui, Add, Checkbox, xs y+10 gTglRszMustPerformResize Checked%ResizeMustPerform% vResizeMustPerform, Perform image resizing (W x H):
    Gui, Add, Edit, xs+15 y+5 w100 r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleXimgFactor, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 wp r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleYimgFactor, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 wp+30 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `% perc.
    Gui, Add, Checkbox, xs y+10 Checked%SimpleOperationsDoCrop% vSimpleOperationsDoCrop, Crop image(s) to selected area in viewport
    Gui, Add, Checkbox, xs y+10 Checked%ResizeQualityHigh% vResizeQualityHigh, High quality image resampling
    Gui, Add, Checkbox, xs y+15 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the specified destination folder:
    Gui, Add, Edit, xp+15 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs+15 y+7 , In destination folder, on file name conflicts
    Gui, Add, DropDownList, x+5 w140 gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite

    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    If (editingSelectionNow!=1)
       GuiControl, Disable, SimpleOperationsDoCrop

    If (filesElected>1)
    {
       msgFriendly := filesElected " files are selected for processing."
       Gui, Font, Bold
       Gui, Add, Text, xs y+20 w%txtWid%, % msgFriendly
       Gui, Font, Normal
       Gui, Add, Text, xs y+10 w%txtWid%, Files in unsupported write formats will be skipped.
    }

    If (filesElected<2)
    {
       Gui, Add, Button, xs+0 y+25 h%thisBtnHeight% w35 gPreviousPicture, <<
       Gui, Add, Button, x+5 hp wp gNextPicture, >>
       ; Gui, Add, Button, x+5 hp w%btnWid%  gBtnSaveNowSimpleProcessing , &Save image
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnSaveAsSimpleProcessing vmainBtnACT, &Save image as...
    } Else Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% wp Default gBtnPerformSimpleProcessing, &Perform operations on the files

    Gui, Add, Button, xs y+5 h%thisBtnHeight% w%btnWid% gBtnInvokePanelResizeImageWindow, &Advanced mode
    Gui, Add, Button, x+5 hp w80 gResizePanelHelpBoxInfo, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / crop / rotate image [simple mode]: " appTitle)
    ResetImgLoadStatus()
    SetTimer, TglRszMustPerformResize, -300
}

BtnInvokePanelResizeImageWindow() {
   BtnCloseWindow()
   Sleep, 10
   PanelResizeImageWindow()
}

BtnSaveAsSimpleProcessing() {
    BtnPerformSimpleProcessing()
}

BtnSaveNowSimpleProcessing() {
    BtnPerformSimpleProcessing("no-prompt")
}

TglRszMustPerformResize() {
    Gui, SettingsGUIA: Default
    GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform
    If (ResizeMustPerform!=1)
    {
       GuiControl, SettingsGUIA: Disable, SimpleOperationsScaleXimgFactor
       GuiControl, SettingsGUIA: Disable, SimpleOperationsScaleYimgFactor
       GuiControl, SettingsGUIA: Disable, ResizeInPercentage
    } Else
    {
       GuiControl, SettingsGUIA: Enable, SimpleOperationsScaleXimgFactor
       GuiControl, SettingsGUIA: Enable, SimpleOperationsScaleYimgFactor
       GuiControl, SettingsGUIA: Enable, ResizeInPercentage
    }
}

BtnPerformSimpleProcessing(dummy:=0, contextu:="") {
    If (contextu!="extern")
    {
       Gui, SettingsGUIA: Default
       GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform
       GuiControlGet, SimpleOperationsFlipV, SettingsGUIA:, SimpleOperationsFlipV
       GuiControlGet, SimpleOperationsFlipH, SettingsGUIA:, SimpleOperationsFlipH
       GuiControlGet, SimpleOperationsDoCrop, SettingsGUIA:, SimpleOperationsDoCrop
       GuiControlGet, SimpleOperationsRotateAngle, SettingsGUIA:, SimpleOperationsRotateAngle
       GuiControlGet, SimpleOperationsScaleXimgFactor, SettingsGUIA:, SimpleOperationsScaleXimgFactor
       GuiControlGet, SimpleOperationsScaleYimgFactor, SettingsGUIA:, SimpleOperationsScaleYimgFactor
       GuiControlGet, ResizeQualityHigh, SettingsGUIA:, ResizeQualityHigh
       GuiControlGet, ResizeDestFolder, SettingsGUIA:, ResizeDestFolder
       GuiControlGet, ResizeUseDestDir, SettingsGUIA:, ResizeUseDestDir
       GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
       GuiControlGet, userJpegQuality, SettingsGUIA:, userJpegQuality
       GuiControlGet, userActionConflictingFile, SettingsGUIA:, userActionConflictingFile

       userJpegQuality := clampInRange(userJpegQuality, 1, 100)
       INIaction(1, "userJpegQuality", "General")
       cleanResizeUserOptionsVars()
       If (ResizeMustPerform=0 && SimpleOperationsRotateAngle=1 && SimpleOperationsFlipV=0 && SimpleOperationsFlipH=0 && SimpleOperationsDoCrop=0)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": WARNING", "No image transformations selected or activated to perform.", 0, 0, "exclamation")
          Return
       }

       If ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
       || SimpleOperationsScaleXimgFactor<5 || SimpleOperationsScaleYimgFactor<5) && (ResizeMustPerform=1 && ResizeInPercentage=0))
       || ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
       || SimpleOperationsScaleXimgFactor<1 || SimpleOperationsScaleYimgFactor<1) && (ResizeMustPerform=1 && ResizeInPercentage=1))
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
          Return
       }
    }
 
    initFIMGmodule()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       If (contextu!="extern")
          WriteSettingsResizeSimplePanel()
       batchSimpleProcessing(simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    If (contextu!="extern")
    {
       Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
       oImgW := (ResizeInPercentage=1) ? Round(oImgW*(SimpleOperationsScaleXimgFactor/100)) : SimpleOperationsScaleXimgFactor
       oImgH := (ResizeInPercentage=1) ? Round(oImgH*(SimpleOperationsScaleYimgFactor/100)) : SimpleOperationsScaleYimgFactor
       newImgSize := oImgH*oImgW
       If ((newImgSize>536848912) || (oImgW>32100) || (oImgH>32100) && ResizeMustPerform=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": WARNING", "The resulting image dimensions are very large... the resizing might fail, depending on the file format.`n`nW x H: " oImgW " x " oImgH " pixels.", 0, 0, "Exclamation")
       }

       If (!filesElected && !RegExMatch(imgPath, thisRegEX))
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "This file format (." oExt ") cannot be processed in «Simple mode». Please use the «Advanced mode» which allows file format conversions.", 0, 0, "exclamation")
          Return
       }
    }

   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileName : imgPath
   If (dummy="no-prompt")
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save processed image as...", oExt " images (*." oExt ")")

   If file2save
   {
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." oExt

      If !RegExMatch(file2save, thisRegEX)
      {
         SoundBeep, 300, 100
         If (dummy="no-prompt")
         {
            If (contextu="extern")
            {
               showTOOLtip("ERROR: unsupported image file write format")
               SoundBeep , 300, 100
               SetTimer, RemoveTooltip, % -msgDisplayTime
            } Else msgBoxWrapper(appTitle ": ERROR", "Unsupported file write format. Please use one of the allowed image file formats: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         } Else msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      If (nExt!=oExt && StrLen(nExt)>0)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "You cannot change the image file format from ." oExt " to ." nExt ". If you want to do this, please use the «Advanced mode».", 0, 0, "exclamation")
         Return
      }

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         msgu := "The image file format is currently unsupported, because the FreeImage library failed to properly initialize."
         SoundBeep, 300, 100
         If (contextu="extern")
         {
            showTOOLtip("ERROR: " msgu "`n" OutFileName)
            SetTimer, RemoveTooltip, % -msgDisplayTime
         } Else msgBoxWrapper(appTitle ": ERROR", msgu "`n`n" OutFileName, 0, 0, "error")
         Return
      }

      If (FileExist(file2save) && dummy!="no-prompt" && contextu!="extern")
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      destroyGDIfileCache()
      If (contextu!="extern")
      {
         GuiControl, SettingsGUIA: Disable, mainBtnACT
         SetTimer, reactivateMainBtnACT, -950
      }

      showTOOLtip("Processing image, please wait")
      r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
      If r
      {
         SoundBeep, 300, 100
         If (contextu="extern")
            showTOOLtip("ERROR: Unable to save file, error code: " r "`n" OutFileName "`n" OutDir "\")
         Else
            msgBoxWrapper(appTitle ": ERROR", "Unable to save file, error code: " r ".`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      ForceRefreshNowThumbsList()
      resultedFilesList[currentFileIndex, 4] := 1
      If (SLDtypeLoaded=3)
         selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

      If (contextu!="extern")
      {
         SetTimer, WriteSettingsResizeSimplePanel, -90
         SoundBeep, 900, 100
      }

      showTOOLtip("Processed image saved`n" OutFileName)
      If (dummy="no-prompt")
         SetTimer, RefreshImageFile, -150

      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

batchSimpleProcessing(rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to process " filesElected " files?"
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      Else
         msgInfos .= "`n`nThe files will be will be OVERWRITTEN."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   backCurrentSLD := CurrentSLD
   setImageLoading()
   showTOOLtip("Processing " filesElected " images, please wait")

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>2) ? 1 : 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresSimpleImgProcessing(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("Image processing in batch: failed to initialize multi-threaded processing")

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
   countTFilez := failedFiles := filesConverted := skippedFiles := 0
   doStartLongOpDance()
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If !RegExMatch(imgPath, thisRegEX)
      {
         skippedFiles++
         Continue
      }

      countTFilez++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If failedFiles
            etaTime := "`nFailed to process " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`n" groupDigits(skippedFiles) " files were skipped"

         showTOOLtip("Processing image files, please wait" etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := StrReplace(imgPath, "||")
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutFileName

      If (ResizeUseDestDir=1)
      {
         If (FileExist(file2save) && !FolderExist(file2save))
            file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)
      }

      If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
      If r
         failedFiles++
      Else
         filesConverted++
   }

   If failedFiles
      someErrors := "`nFailed to process " groupDigits(failedFiles) " files"
   If skippedFiles
      someErrors .= "`n" groupDigits(skippedFiles) " files were skipped"

   executingCanceableOperation := 0
   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip("Finished processing " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

printLargeStrArray(whichArray, maxList, delim) {
  startZeit := A_TickCount
  trenchSize := 15000
  changeMcursor()
  If (maxList<trenchSize)
  {
     Loop, % maxList
     {
          rA := whichArray[A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu .= r delim
     }
     Return filesListu
  }

  doStartLongOpDance()
  splitParts := maxList//trenchSize
  Loop, % splitParts - 1
  {
      If (A_TickCount - startZeit>2500)
         executingCanceableOperation := A_TickCount

      changeMcursor()
      thisIndex := A_Index
      Loop, % trenchSize
      {
          rA := whichArray[trenchSize*(thisIndex-1) + A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu%thisIndex% .= r delim
      }

      If (determineTerminateOperation()=1) ; && (A_TickCount - startZeit>2500)
      {
         abandonAll := 1
         Break
      }
  }

  If (abandonAll=1)
  {
     SoundBeep, 300, 100
     lastLongOperationAbort := A_TickCount
     Return
  }

  Loop, % maxList - trenchSize*(splitParts - 1)
  {
      rA := whichArray[trenchSize*(splitParts - 1) + A_Index]
      r := rA[1]
      If (InStr(r, "||") || !r)
         Continue

      filesListu%splitParts% .= r delim
  }

  filesListu%splitParts% := Trimmer(filesListu%splitParts%)
  Loop, % splitParts
      result .= filesListu%A_Index%

  ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 
  Return result
}

GetRes(ByRef bin, lib, res, type) {
  If !A_IsCompiled
     Return 0

  hL := 0
  If lib
     hM := DllCall("kernel32\GetModuleHandleW", "Str", lib, "Ptr")

  If !lib
  {
     hM := 0  ; current module
  } Else If !hM
  {
     If (!hL := hM := DllCall("kernel32\LoadLibraryW", "Str", lib, "Ptr"))
        Return
  }

  dt := (type+0 != "") ? "UInt" : "Str"
  hR := DllCall("kernel32\FindResourceW"
      , "Ptr" , hM
      , "Str" , res
      , dt , type
      , "Ptr")

  If !hR
  {
     fnOutputDebug("GetRes() ERR " FormatMessage(A_ThisFunc "(" lib ", " res ", " type ", " l ")", A_LastError))
     Return
  }

  hD := DllCall("kernel32\LoadResource"
      , "Ptr" , hM
      , "Ptr" , hR
      , "Ptr")
  hB := DllCall("kernel32\LockResource"
      , "Ptr" , hD
      , "Ptr")
  sz := DllCall("kernel32\SizeofResource"
      , "Ptr" , hM
      , "Ptr" , hR
      , "UInt")
  If !sz
  {
     fnOutputDebug("Error: resource size 0 in  " A_ThisFunc " ( " lib " ,  " res " ,  " type " )")
     DllCall("kernel32\FreeResource", "Ptr" , hD)
     If hL
        DllCall("kernel32\FreeLibrary", "Ptr", hL)
     Return
  }

  VarSetCapacity(bin, 0), VarSetCapacity(bin, sz, 0)
  DllCall("ntdll\RtlMoveMemory", "Ptr", &bin, "Ptr", hB, "UInt", sz)
  DllCall("kernel32\FreeResource", "Ptr" , hD)

  If hL
     DllCall("kernel32\FreeLibrary", "Ptr", hL)

  Return sz
}

FormatMessage(ctx, msg, arg="") {
  Global
  Local txt, buf
  SetFormat, Integer, H
  msg+=0
  SetFormat, Integer, D
  frmMsg := DllCall("kernel32\FormatMessageW"
          , "UInt" , 0x1100 ; FORMAT_MESSAGE_FROM_SYSTEM/ALLOCATE_BUFFER
          , "Ptr"  , 0      ; lpSource
          , "UInt" , msg    ; dwMessageId
          , "UInt" , 0      ; dwLanguageId (0x0418=RO)
          , "PtrP" , buf    ; lpBuffer
          , "UInt" , 0      ; nSize
          , "Str"  , arg)   ; Arguments

  txt := StrGet(buf, "UTF-16")
  lF := DllCall("kernel32\LocalFree", "Ptr", buf)
  Result := "Error " msg " in " ctx ":`n" txt
  Return Result
}

calcHistoAvgFile(xBitmap, returnObj, isFilter, imgIndex, zEffect:=0, originalBMP:=0) {
    Static numEntries, TotalPixelz := 122500
    
    If StrLen(xBitmap)<2
       Return 0

    If !numEntries
    {
       z := DllCall("gdiplus\GdipBitmapGetHistogramSize", "UInt", 3, "UInt*", numEntries)
       numEntries := numEntries
    }

    ; brLvlArray := []
    VarSetCapacity(ch0, numEntries * 4, 0)
    R := DllCall("gdiplus\GdipBitmapGetHistogram", "Ptr", xBitmap, "UInt", 3, "UInt", numEntries, "Ptr", &ch0, "Ptr", 0, "Ptr", 0, "Ptr", 0)
    If R
    {
       fnOutputDebug(A_ThisFunc "() failed to retrieve histogram" )
       Return 0
    }

    medianValue := -1
    pixMinu := TotalPixelz
    modePointV := peakPointV := sumTotalBr := nrPixelz := thisSum := minBrLvlV := 0
    Loop, % numEntries
    {
        thisIndex := A_Index - 1
        nrPixelz := NumGet(&ch0+0, thisIndex * 4, "UInt")
        ; nrPixelz := brLvlArray[thisIndex]
        If (nrPixelz="")
           Continue

        If (nrPixelz>modePointV)
        {
           modePointV := nrPixelz
           modePointK := thisIndex
        }

        If (nrPixelz>0 && medianValue=-1)
        {
           thisSum += nrPixelz
           If (thisSum>TotalPixelz//2)
              medianValue := thisIndex
        }

        sumTotalBr += nrPixelz * A_Index
        If (nrPixelz>0)
        {
           peakPointK := thisIndex ; max range in histogram
           If !minBrLvlK
              minBrLvlK := thisIndex   ; min range in histogram
        }

        If (nrPixelz<pixMinu)
        {
           pixMinu := nrPixelz
           minPointK := thisIndex
        }
        pixRms += nrPixelz ** 2    ; root-mean square
    }
    ; pixContent := pixBorder := 1
    If (SLDtypeLoaded=3)
    {
       entireHash := ""
       zBitmap := Gdip_ResizeBitmap(originalBMP, 9, 8, 0, 7)

       If StrLen(zBitmap)>2
       {
          Gdip_BitmapApplyEffect(zBitmap, zEffect)
          E1 := Gdip_LockBits(zBitmap, 0, 0, 9, 8, Stride1, Scan01, BitmapData1)
          If !E1
          {
             Loop, 8
             {
                pY := A_Index - 1 ; y++
                Loop, 8
                {
                   pX := A_Index - 1 ; , pY := y - 1
                   R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
                   ; If (pX=7) ; it exceeds the width
                   ;    R2 := Gdip_RFromARGB(NumGet(Scan01+0, ((pX-3)*4)+(pY*Stride1), "UInt"))
                   ; Else
                      R2 := Gdip_RFromARGB(NumGet(Scan01+0, ((pX+1)*4)+(pY*Stride1), "UInt"))

                   If (pY=0 || pY=7 || pX=0 || pX=7)
                      pixBorder .= (R1<R2) ? 1 : 0
                   Else
                      pixContent .= (R1<R2) ? 1 : 0

                   entireHash .= (R1<R2) ? 1 : 0
                   ; pixContent .= Round(Gdip_RFromARGB(NumGet(Scan01+0, ((A_Index-1)*4)+((y - 1)*Stride1), "UInt"))*0.9)
                }
             }
             Gdip_UnlockBits(zBitmap, BitmapData1)
          } 
          Gdip_DisposeImage(zBitmap, 1)
       }
    }

    avgu := (sumTotalBr/TotalPixelz - 1)/2
    rmsu := Sqrt(pixRms / (peakPointK - minBrLvlK))
    entireAsh := ConvertBase(2, 16, entireHash)
    ; If InStr(entireAsh, "-")
    ;    entireAsh := StrReplace(entireAsh, "-", "9")

    If (returnObj=1)
    {
       r := []
       r.avg := Round((avgu + 1)/256, 5)
       r.median := Round((medianValue + 1)/256, 5)
       r.peak := Round((peakPointK + 1)/256, 5)
       r.low := Round((minBrLvlK + 1)/256, 5)
       r.rms := Round((rmsu + 1)/7000, 5)
       r.range := Round((peakPointK - minBrLvlK + 1)/256, 5)
       r.mode := Round((modePointK + 1)/256, 5)
       r.minu := Round((minPointK + 1)/256, 5)
       r.innerpixelz := pixContent
       r.outerpixelz := pixBorder
       r.entireH := entireAsh
       Return r
    } Else If isFilter
    {
       bckpResultedFilesList[imgIndex, 11] := 1
       bckpResultedFilesList[imgIndex, 18] := Round((avgu + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 19] := Round((medianValue + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 20] := Round((peakPointK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 21] := Round((minBrLvlK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 24] := Round((rmsu + 1)/7000, 5)
       bckpResultedFilesList[imgIndex, 25] := Round((peakPointK - minBrLvlK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 26] := Round((modePointK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 27] := Round((minPointK + 1)/256, 5)
       bckpResultedFilesList[imgIndex, 28] := pixContent
       bckpResultedFilesList[imgIndex, 29] := pixBorder
       bckpResultedFilesList[imgIndex, 30] := entireAsh
    } Else
    {
       resultedFilesList[imgIndex, 11] := 1
       resultedFilesList[imgIndex, 18] := Round((avgu + 1)/256, 5)
       resultedFilesList[imgIndex, 19] := Round((medianValue + 1)/256, 5)
       resultedFilesList[imgIndex, 20] := Round((peakPointK + 1)/256, 5)
       resultedFilesList[imgIndex, 21] := Round((minBrLvlK + 1)/256, 5)
       resultedFilesList[imgIndex, 24] := Round((rmsu + 1)/7000, 5)
       resultedFilesList[imgIndex, 25] := Round((peakPointK - minBrLvlK + 1)/256, 5)
       resultedFilesList[imgIndex, 26] := Round((modePointK + 1)/256, 5)
       resultedFilesList[imgIndex, 27] := Round((minPointK + 1)/256, 5)
       resultedFilesList[imgIndex, 28] := pixContent
       resultedFilesList[imgIndex, 29] := pixBorder
       resultedFilesList[imgIndex, 30] := entireAsh
    }

    ; ToolTip, % medianValue "=" r.avg "=" peakPointK "=" minBrLvlK , , , 2
    Return 1
}

GetCachableHistogramFile(imgPath, imgIndex, thumbBMP:=0, returnObj:=0, noFileInfos:=0, isFilter:=0, zEffect:=0) {
     If (!imgPath || !imgIndex)
     {
        fnOutputDebug(A_ThisFunc "() - wow error: " imgPath "-" imgIndex)
        Return
     }

     If !thumbBMP
     {
        wasGiven := 0
        thumbBMP := LoadBitmapFromFileu(imgPath, 1, 0, 0, 0, 350, 350, 0)
        If StrLen(thumbBMP)>2
        {
           If (returnObj=1)
           {
              imgInfosObju := []
              imgInfosObju.dpi := mainLoadedIMGdetails.dpi
              imgInfosObju.w := mainLoadedIMGdetails.Width
              imgInfosObju.h := mainLoadedIMGdetails.Height
              imgInfosObju.pixFmt := mainLoadedIMGdetails.PixelFormat
              imgInfosObju.frames := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
           } Else If isFilter
           {
              bckpResultedFilesList[imgIndex, 9] := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
              bckpResultedFilesList[imgIndex, 13] := mainLoadedIMGdetails.Width
              bckpResultedFilesList[imgIndex, 14] := mainLoadedIMGdetails.Height
              bckpResultedFilesList[imgIndex, 15] := mainLoadedIMGdetails.PixelFormat
              bckpResultedFilesList[imgIndex, 16] := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              bckpResultedFilesList[imgIndex, 17] := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              bckpResultedFilesList[imgIndex, 22] := mainLoadedIMGdetails.dpi
           } Else
           {
              resultedFilesList[imgIndex, 9] := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
              resultedFilesList[imgIndex, 13] := mainLoadedIMGdetails.Width
              resultedFilesList[imgIndex, 14] := mainLoadedIMGdetails.Height
              resultedFilesList[imgIndex, 15] := mainLoadedIMGdetails.PixelFormat
              resultedFilesList[imgIndex, 16] := Round(mainLoadedIMGdetails.Width/mainLoadedIMGdetails.Height, 2)
              resultedFilesList[imgIndex, 17] := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
              resultedFilesList[imgIndex, 22] := mainLoadedIMGdetails.dpi
           }

           If (mainLoadedIMGdetails.OpenedWith="GDI+")
              zBitmap := trGdip_ResizeBitmap(A_ThisFunc, thumbBMP, 350, 350, 0, 3, "0x21808")
           Else
              Gdip_BitmapConvertFormat(thumbBMP, "0x21808", 2, 1, 0, 0, 0, 0, 0)

           If zBitmap
           {
              ; trGdip_DisposeImage(thumbBMP, 1)
              originalBMP := thumbBMP
              thumbBMP := zBitmap
           }

           If zEffect
              Gdip_BitmapApplyEffect(thumbBMP, zEffect)
        } Else imgInfosObju := 0
     } Else imgInfosObju := wasGiven := 1 ; image object to be disposed by caller

     histoObj := calcHistoAvgFile(thumbBMP, returnObj, isFilter, imgIndex, zEffect, originalBMP)
     If !wasGiven
     {
        trGdip_DisposeImage(thumbBMP, 1)
        trGdip_DisposeImage(originalBMP, 1)
     }

     If (noFileInfos=0)
     {
        fileInfos := GetFileAttributesEx(imgPath)
        If (isFilter && returnObj!=1)
        {
           bckpResultedFilesList[imgIndex, 6] := fileInfos.size
           bckpResultedFilesList[imgIndex, 7] := fileInfos.wTime
           bckpResultedFilesList[imgIndex, 8] := fileInfos.cTime
        } Else (returnObj!=1)
        {
           resultedFilesList[imgIndex, 6] := fileInfos.size
           resultedFilesList[imgIndex, 7] := fileInfos.wTime
           resultedFilesList[imgIndex, 8] := fileInfos.cTime
        }
     }

     If (IsObject(histoObj) && returnObj=1)
        Return [histoObj, imgInfosObju, fileInfos]
     Else
        Return histoObj
        ; fnOutputDebug(A_ThisFunc "() - no cache: " imgPath)
     ; } Else fnOutputDebug(A_ThisFunc "() - failed to generate histogram: " imgIndex " = " imgPath)
}

SaveFIMfile(file2save, pBitmap) {
  initFIMGmodule()
  If !wasInitFIMlib
     Return 1

  hFIFimgA := ConvertPBITMAPtoFIM(pBitmap)
  If !hFIFimgA
  {
     SoundBeep , 300, 100
     message := "Failed to convert GDI+ image object to FreeImage object..."
     addJournalEntry(message)
     Return message 
  }

  If FileExist(file2save)
  {
     Try FileSetAttrib, -R, % file2save
     Sleep, 0
     FileMove, % file2save, % file2save "-tmp"
     If !ErrorLevel
        tempFileExists := 1

     Sleep, 0
  }

  saveArg := 0
  If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
     saveArg :=  clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
  Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
     saveArg :=  clampInRange(Round(userJpegQuality), 1, 100)

  If RegExMatch(file2save, "i)(.\.(gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|wbm|xpm))$")
  {
     hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")
     changeMcursor()
     r := FreeImage_Save(hFIFimgB, file2save, saveArg)
     FreeImage_UnLoad(hFIFimgB)
  } Else r := FreeImage_Save(hFIFimgA, file2save, saveArg)

  FreeImage_UnLoad(hFIFimgA)
  If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
  {
     r := 0
     FileDelete, % file2save
     Sleep, 0
     FileMove, % file2save "-tmp", % file2save
  } Else If (tempFileExists=1)
     FileDelete, % file2save "-tmp"

  Return !r
}

initFIMGmodule() {
  Static firstTimer := 1
  If (wasInitFIMlib!=1)
  {
     r := FreeImage_FoxInit(1) ; Load the FreeImage Dll
     wasInitFIMlib := (r && !InStr(r, "err")) ? 1 : 0
     If wasInitFIMlib
        addJournalEntry("FreeImage library initialized: v" FreeImage_GetVersion())
  }

  If InStr(r, "err - ")
  {
     alwaysOpenwithFIM := 0
     FIMfailed2init := 1
     If InStr(r, "err - 126")
        friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2013."
     Else If InStr(r, "err - 404")
        friendly := "`n`nThe FreeImage.dll file seems to be missing..."

     If (firstTimer=1 && hasInitSpecialMode!=1)
     {
        SoundBeep, 300, 100
        msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Some image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
     }
  } Else FIMfailed2init := 0

  firstTimer := 0
  Return r
}

GlobalMemoryStatusEx() {
; https://msdn.microsoft.com/en-us/library/aa366589(v=vs.85).aspx 
; by jNizM
; https://github.com/jNizM/MemoryInfo/blob/master/src/MemoryInfo.ahk
    static MSEX, init := NumPut(VarSetCapacity(MSEX, 64, 0), MSEX, "uint")
    if !(DllCall("GlobalMemoryStatusEx", "ptr", &MSEX))
       Return 0
       ;  throw Exception("Call to GlobalMemoryStatusEx failed: " A_LastError, -1)
    return { MemoryLoad: NumGet(MSEX, 4, "uint"), TotalPhys: NumGet(MSEX, 8, "uint64"), AvailPhys: NumGet(MSEX, 16, "uint64") }
}

GetProcessMemoryUsage(ProcessID) {
; by jNizM
; https://www.autohotkey.com/boards/viewtopic.php?t=62848
; modified by Marius Șucan

   static PMC_EX, size := NumPut(VarSetCapacity(PMC_EX, 8 + A_PtrSize * 9, 0), PMC_EX, "uint")

   if (hProcess := DllCall("OpenProcess", "uint", 0x1000, "int", 0, "uint", ProcessID))
   {
      if !(DllCall("GetProcessMemoryInfo", "ptr", hProcess, "ptr", &PMC_EX, "uint", size))
      {
         if !(DllCall("psapi\GetProcessMemoryInfo", "ptr", hProcess, "ptr", &PMC_EX, "uint", size))
            return (ErrorLevel := 2) & 0, DllCall("CloseHandle", "ptr", hProcess)
      }
      DllCall("CloseHandle", "ptr", hProcess)
      infos := []
      infos[0] := NumGet(PMC_EX, A_PtrSize, "uptr")   ; peak working set bytes
      infos[1] := NumGet(PMC_EX, 8 + A_PtrSize, "uptr")   ; working set bytes
      infos[8] := NumGet(PMC_EX, 8 + A_PtrSize*8, "uptr") ; private bytes
      Return infos
   }
   return (ErrorLevel := 1) & 0
}

LoadFimFile(imgPath, noBPPconv, noBMP:=0, forceW:=0, forceH:=0, keepAratio:=0) {
  Critical, on
  sTime := A_tickcount  
  initFIMGmodule()
  If !wasInitFIMlib
     Return

  loadArgs := (noBPPconv=1 || noBMP=1) ? -1 : 0   ; FIF_LOAD_NOPIXELS
  GFT := FreeImage_GetFileType(imgPath)
  If (GFT=34 && loadArgs=0)
     loadArgs := (userHQraw=1 && thumbsDisplaying=0) ? 0 : 5
  Else If (GFT=2 && loadArgs=0)
     loadArgs := 8

  changeMcursor()
  hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs) ; load image
  If !hFIFimgA
  {
     addJournalEntry("Failed to load image file using FreeImage library")
     Return
  }

  FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
  FreeImage_GetDPIresolution(hFIFimgA, dpiX, dpiY)
  If (forceW && forceH)
  {
     If (imgW>forceW || imgH>forceH)
     {
        If (keepAratio=1)
        {
           calcIMGdimensions(imgW, imgH, forceW, forceH, xForceW, xForceH)
           hFIFimgX := FreeImage_Rescale(hFIFimgA, xForceW, xForceH, 0)
        } Else
           hFIFimgX := FreeImage_Rescale(hFIFimgA, forceW, forceH, 0)
     }

     If hFIFimgX
     {
        FreeImage_UnLoad(hFIFimgA)
        hFIFimgA := hFIFimgX
     }
  }

  imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
  ColorsType := FreeImage_GetColorType(hFIFimgA)
  If (noBPPconv=0)
     alphaBitmap := FreeImage_GetChannel(hFIFimgA, 4)

  mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba")) || (imgBPP>64) ? 1 : 0
  toneMapped := ""
  If (mustApplyToneMapping=1 && noBPPconv=0 && noBMP=0)
  {
     setWindowTitle("Applying adaptive logarithmic tone mapping to display high color depth image")
     changeMcursor()
     hFIFimgB := FreeImage_ToneMapping(hFIFimgA, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
     toneMapped := " (TONE-MAPPED)"
  }

  fileType := FreeImage_GetFileType(imgPath, 1)
  If (fileType="raw" && userHQraw!=1)
     fileType .= " [LOW QUALITY]"

  imgType := FreeImage_GetImageType(hFIFimgA, 1)
  mainLoadedIMGdetails.File := imgPath
  mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
  mainLoadedIMGdetails.Width := imgW
  mainLoadedIMGdetails.Height := imgH
  mainLoadedIMGdetails.Frames := FreeImage_GetPageCount(hFIFimgA) - 1
  mainLoadedIMGdetails.HasAlpha := InStr(ColorsType, "rgba") ? 1 : 0
  mainLoadedIMGdetails.RawFormat := fileType " | " imgType
  mainLoadedIMGdetails.PixelFormat := imgBPP "-" ColorsType toneMapped
  mainLoadedIMGdetails.OpenedWith := "FreeImage library"
  mainLoadedIMGdetails.TooLargeGDI := 0
  If (noBMP=1)
  {
     FreeImage_UnLoad(hFIFimgA)
     Return 1
  }

  hFIFimgZ := hFIFimgB ? hFIFimgB : hFIFimgA
  hFIFimgC := hFIFimgZ ? hFIFimgZ : hFIFimgA
  FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)

  If (noBPPconv=0)
  {
     capMaxGDIbmpSize32bits()
     If (imgW*imgH>maxGDIbmpSize)
     {
        setWindowTitle("Rescaling image to fit the GDI+ maximum image dimensions limits")
        calcIMGdimensions(imgW, imgH, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), nImgW, nImgH)
        changeMcursor()
        hFIFimgKO := FreeImage_Rescale(hFIFimgC, nimgW, nimgH, 0)
     } Else If (imgW>32500 || imgH>32500)
     {
        setWindowTitle("Rescaling image to fit the GDI+ maximum image dimensions limits")
        calcIMGdimensions(imgW, imgH, 32500, 32500, nImgW, nImgH)
        changeMcursor()
        hFIFimgKO := FreeImage_Rescale(hFIFimgC, nimgW, nimgH, 0)
     }

     If StrLen(hFIFimgKO)>2
     {
        hFIFimgC := hFIFimgKO
        mainLoadedIMGdetails.TooLargeGDI := 1
        FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)
     }

     setWindowTitle("Converting FreeImage object to GDI+ image bitmap")
     imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgC), "-"))
     If (imgBPPc!=32)
        hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "32Bits")

     hFIFimgE := hFIFimgD ? hFIFimgD : hFIFimgC
     If alphaBitmap
     {
        hFIFimgXu := FreeImage_ConvertTo(alphaBitmap, "Greyscale")
        eRR := FreeImage_GetHistogram(hFIFimgXu, 5, histoArray)
        mustInvert := eRR
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && A_Index>2)
               mustInvert := 0
        }
        HasAlpha := 0
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && isInRange(A_Index, 3, 254))
               HasAlpha := 1
        }

        ; ToolTip, % lola " = " eRR " - " mustInvert  " / " HasAlpha , , , 2
        If (mustInvert=1)
        {
           FreeImage_Invert(hFIFimgXu)
           FreeImage_SetChannel(hFIFimgE, hFIFimgXu, 4)
        }

        mainLoadedIMGdetails.HasAlpha := HasAlpha
        FreeImage_UnLoad(hFIFimgXu)
        FreeImage_UnLoad(alphaBitmap)
     }
     ; FreeImage_PreMultiplyWithAlpha(hFIFimgE)
     pBitmap := ConvertFIMtoPBITMAP(hFIFimgE)
  } Else pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")

  ; Gdip_GetImageDimensions(pBitmap, imgW2, imgH2)
  imgIDs := hFIFimgA "|" hFIFimgB "|" hFIFimgC "|" hFIFimgKO "|" hFIFimgD "|" hFIFimgE "|" hFIFimgZ
  Sort, imgIDs, UD|
  Loop, Parse, imgIDs, |
  {
      If A_LoopField
         FreeImage_UnLoad(A_LoopField)
  }

  eTime := A_TickCount - sTime
  ; ToolTip, % imgW ", " imgW2,,,2
  ; Tooltip, % etime "; " noPixels "; " GFT
  ; Tooltip, %r1% -- %r2% -- %pBits% ms ---`n %pbitmap% -- %hbitmap% -- %hfifimg%
  ; ToolTip, % Gdip_GetImagePixelFormat(pBitmap, 2) , , , 2
  Return pBitmap
}

changeMcursor(whichCursor:=0) {
  Static lastInvoked := 1, prevCursor := "none"
  If ((drawingShapeNow=1 || slideShowRunning=1 || animGIFplaying=1 || (A_TickCount - zeitSillyPrevent<300) || hasInitSpecialMode=1) && imageLoading!=1)
     Return

  If (whichCursor)
  {
     prevCursor := whichCursor
     interfaceThread.ahkPostFunction("changeMcursor", whichCursor)
  } Else If (A_TickCount - lastInvoked > 500) ; && (imageLoading!=1)
  {
     interfaceThread.ahkPostFunction("changeMcursor", "busy")
     ; interfaceThread.ahkassign("imageLoading", 1)
     ; Try DllCall("user32\SetCursor", "Ptr", hCursBusy)
     lastInvoked := A_TickCount
  }
}

GetImgFileDimension(imgPath, ByRef W, ByRef H, fastWay:=1) {
   Static prevImgPath, prevW, prevH
   thisImgPath := generateThumbName(imgPath, 1) fastWay
   If (prevImgPath=thisImgPath && prevH>1 && prevW>1)
   {
      W := prevW
      H := prevH
      Return 1
   }

   prevImgPath := thisImgPath
   changeMcursor()
   pBitmap := LoadBitmapFromFileu(imgPath, fastWay)
   prevW := W := mainLoadedIMGdetails.Width
   prevH := H := mainLoadedIMGdetails.Height
   trGdip_DisposeImage(pBitmap, 1)

   changeMcursor("normal")
   r := (w>1 && h>1) ? 1 : 0
   Return r
}

isInRange(value, inputA, inputB) {
    If (value=inputA || value=inputB)
       Return 1

    Return (value>=min(inputA, inputB) && value<=max(inputA, inputB)) ? 1 : 0
}

ST_ReadLine(String, line, delim="`n", exclude="`r") {
   String := Trimmer(String, delim)
   StringReplace, String, String, %delim%, %delim%, UseErrorLevel
   TotalLcount := ErrorLevel + 1

   If (abs(line)>TotalLCount && (line!="L" || line!="R" || line!="M"))
      Return 0

   If (Line="R")
      Random, Rand, 1, %TotalLcount%
   Else If (line<=0)
      line := TotalLcount + line

   Loop, Parse, String, %delim%, %exclude%
   {
      out := (Line="R" && A_Index=Rand) ? A_LoopField
           : (Line="M" && A_Index=TotalLcount//2) ? A_LoopField
           : (Line="L" && A_Index=TotalLcount) ? A_LoopField
           : (A_Index=Line) ? A_LoopField : -1
      If (out!=-1) ; Something was found so stop searching.
         Break
   }
   Return out
}

triggerOwnDialogs() {
  If AnyWindowOpen
     Gui, SettingsGUIA: +OwnDialogs
  Else
     Gui, 1: +OwnDialogs
}

checkThumbExists(MD5name, imgPath, ByRef file2load) {
   file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
   If FileExist(file2save)
   {
      FileGetSize, fileSizu, % file2save
      If (fileSizu<3)
         Return 0

      file2load := file2save
      Return 1
   } Else If (thumbsSizeQuality>755)
   {
      file2load := imgPath
      Return 0
   } Else If (thumbsSizeQuality>=500)
   {
      file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : imgPath
   } Else If (thumbsSizeQuality>=245)
   {
      file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : imgPath
      }
   } Else If (thumbsSizeQuality>124)
   {
      file2test := thumbsCacheFolder "\245-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : 0
         If !file2load
         {
            file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
            file2load := FileExist(file2test) ? file2test : imgPath
         }
      }
   }
   FileGetSize, fileSizu, % file2load
   r := (imgPath=file2load || fileSizu<3) ? 0 : 1
   Return r
}

generateThumbName(imgPath, forceThis:=0, thumbsSizer:=0) {
   Static lastInvoked := 1, prevMD5name, prevImgPath := "null"

   If (A_TickCount - lastInvoked<50) && (imgPath=prevImgPath)
      Return prevMD5name

   If (enableThumbsCaching!=1 && forceThis=0)
      Return

   obju := GetFileAttributesEx(imgPath)
   MD5name := CalcStringHash(imgPath obj.size obju.wtime obju.ctime, 0x8003)
   ; If (thumbsSizer=1)
   ;    MD5name := thumbsSizeQuality "-" MD5name
   lastInvoked := A_TickCount
   prevMD5name := MD5name
   Return MD5name
}

CalcStringHash(string, algid, encoding = "UTF-8", byref hash = 0, byref hashlength = 0) {
; function by jNizM and Bentschi
; taken from https://github.com/jNizM/HashCalc
; this calculates the MD5 hash
; function under MIT License: https://raw.githubusercontent.com/jNizM/AHK_Network_Management/master/LICENSE

    chrlength := (encoding = "CP1200" || encoding = "UTF-16") ? 2 : 1
    length := (StrPut(string, encoding) - 1) * chrlength
    VarSetCapacity(data, length, 0)
    StrPut(string, &data, floor(length / chrlength), encoding)
    Result := CalcAddrHash(&data, length, algid, hash, hashlength)
    Return Result
}

CalcAddrHash(addr, length, algid, byref hash = 0, byref hashlength = 0) {
; function by jNizM and Bentschi
; taken from https://github.com/jNizM/HashCalc
; function under MIT License: https://raw.githubusercontent.com/jNizM/AHK_Network_Management/master/LICENSE

    Static h := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f"]
         , b := h.minIndex()
    hProv := hHash := o := ""
    CAC := DllCall("advapi32\CryptAcquireContext", "Ptr*", hProv, "Ptr", 0, "Ptr", 0, "UInt", 24, "UInt", 0xf0000000)
    If CAC
    {
       CCH := DllCall("advapi32\CryptCreateHash", "Ptr", hProv, "UInt", algid, "UInt", 0, "UInt", 0, "Ptr*", hHash)
       If CCH
       {
          CHD := DllCall("advapi32\CryptHashData", "Ptr", hHash, "Ptr", addr, "UInt", length, "UInt", 0)
          If CHD
          {
             CGP := DllCall("advapi32\CryptGetHashParam", "Ptr", hHash, "UInt", 2, "Ptr", 0, "UInt*", hashlength, "UInt", 0)
             If CGP
             {
                VarSetCapacity(hash, hashlength, 0)
                CGHP := DllCall("advapi32\CryptGetHashParam", "Ptr", hHash, "UInt", 2, "Ptr", &hash, "UInt*", hashlength, "UInt", 0)
                If CGHP
                {
                   Loop, %hashlength%
                   {
                      v := NumGet(hash, A_Index - 1, "UChar")
                      o .= h[(v >> 4) + b] h[(v & 0xf) + b]
                   }
                }
             }
          }
          CDH := DllCall("advapi32\CryptDestroyHash", "Ptr", hHash)
       }
       CRC := DllCall("advapi32\CryptReleaseContext", "Ptr", hProv, "UInt", 0)
    }
    Return o
}









HammingDistance(stringA, stringB) {
    ; If (StrLen(stringA) != StrLen(stringB))
    ;    Return -1

    countDiffs := 0
    Loop, % StrLen(stringA)
    {
       If (SubStr(stringA, A_Index, 1)!=SubStr(stringB, A_Index, 1))
          countDiffs++
    }
    Return countDiffs
}

HammingDistanceBugz(a,b) {
; by Bugz000
    loop % 17
      s.=(c:="0." substr(a,(A_index)*16-15,16))+(d:="0." substr(b,(A_index)*16-15,16))
    z:=strsplit(s,"1")
    return % z.count()-1
}


HammingDistance3(a,b) {
; by Bugz000
    Loop, Parse, a
    {
       If (A_loopfield!=SubStr(b, A_Index, 1))
          i++
    }
    return i
}

HammingDistanceNew2020dec(a,b, silent:=1) {
; by Bugz000
    ; i := 20
    ; x := a^b
    ; g := ConvertBase(10, 2, a^b)
    ; StrReplace(Haystack, SearchText [, ReplaceText, OutputVarCount, Limit := -1])
    ; StrReplace(ConvertBase(10, 2, a^b), 1, , OutputVarCount)
    ; If !silent
       ; ToolTip, % a "`n" b "`n" g "`n" x "`n" OutputVarCount  , , , 2
    return 5 ;  OutputVarCount ; ? OutputVarCount : 9
}

reorderStoredHashes(a, b) {
    outsideLoop := insideLoop := 0
    Loop, 8
    {
       pY := A_Index - 1 ; y++
       Loop, 8
       {
          pX := A_Index - 1 ; , pY := y - 1
          If (pY=0 || pY=7 || pX=0 || pX=7)
          {
             outsideLoop++
             newHash .= SubStr(b, outsideLoop, 1)
          } Else
          {
             insideLoop++
             newHash .= SubStr(a, insideLoop, 1)
          }
          ; pixContent .= Round(Gdip_RFromARGB(NumGet(Scan01+0, ((A_Index-1)*4)+((y - 1)*Stride1), "UInt"))*0.9)
       }
    }
    ; Clipboard := newHash
    ; ToolTip, % newHash , , , 2
    Return newHash
}

ConvertBase(InputBase, OutputBase, nptr){
    ; source https://www.autohotkey.com/boards/viewtopic.php?t=3925
    static u := A_IsUnicode ? "_wcstoui64" : "_strtoui64"
    static v := A_IsUnicode ? "_i64tow"    : "_i64toa"
    VarSetCapacity(s, 256, 0)
    value := DllCall("msvcrt.dll\" u, "Str", nptr, "UInt", 0, "UInt", InputBase, "CDECL Int64")
    DllCall("msvcrt.dll\" v, "Int64", value, "Str", s, "UInt", OutputBase, "CDECL")
    ; ToolTip, % s , , , 2
    return s
}


HammingDistanceRust(a, b) {
     r := DllCall("hamming_distance.dll\harming_distance_bytes", "astr", a, "astr", b)
     Return r
}

testAlgoSingle() {
   imgPath := getIDimage(currentFileIndex)
     hashA := Gdip_ImageDhash(imgPath)
 imgPath := getIDimage(currentFileIndex + 1)
     hashB := Gdip_ImageDhash(imgPath)
r1 := HammingDistanceRust(hashA, hashB)
r2 := HammingDistance(hashA, hashB)

MsgBox, % r1 "--" r2 "`n" hashA "`n" hashB

}


Gdip_ImageDhash(imgPath) {
   Width := 9*2, Height := 8*2
   oBitmap := LoadBitmapFromFileu(imgPath)
   If oBitmap
   {
      xBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, Width, Height, 0, 3)
      lBitmap := trGdip_BitmapConvertGray(xBitmap, 0, -20)
      trGdip_DisposeImage(oBitmap, 1)
   }

   E1 := Gdip_LockBits(lBitmap, 0, 0, Width, Height, Stride, Scan0, BitmapData)
   dHash := z := 0
   Loop %Height%
   {
      y++
      Loop % Width - 1
      {
         pX := A_Index - 1, pY := y - 1
         R1 := Gdip_RFromARGB(NumGet(Scan0+0, (pX*4)+(pY*Stride), "UInt"))
         R2 := Gdip_RFromARGB(NumGet(Scan0+0, ((pX+1)*4)+(pY*Stride), "UInt"))
         dHash .= (R1<R2) ? 1 : 0
      }
   }

   Gdip_UnlockBits(lBitmap, BitmapData)
   trGdip_DisposeImage(lBitmap, 1)
   trGdip_DisposeImage(xBitmap, 1)
   return dHash
}

testAlgo() {
  SoundBeep 
  thisCounter := 0
  startZeit := A_TickCount
  hashesListArray := []
  ; create hashes for images in the resultedFilesList Array
  Loop, % maxFilesIndex
  {
      imgPath := getIDimage(A_Index)
      If !FileRexists(imgPath)
         Continue

      thisCounter++
      newHash := (cachedHashes[imgPath]!="") ? cachedHashes[imgPath] : Gdip_ImageDhash(imgPath)
      cachedHashes[imgPath] := newHash
      ; hashesList .= newHash "`n"
      hashesListArray[thisCounter] := newHash
      hashesListIDsArray[newHash] := imgPath
  }

  thresholdu := 1   
  countAll := countThese := newFilesIndex := 0
  hashesList := Trimmer(hashesList)
  newFilesList := []
  distCombinationsA := []
  distCombinationsB := []
  distCombinations := []
  ; hashesListArray := []
  ; hashesListArray := StrSplit(hashesList, "`n")
  ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) "`n" hashesListArray.count()
  ; SoundBeep 

  DllPath := FreeImage_FoxGetDllPath("hamming_distance.dll")
  lalala := DllCall("LoadLibraryW", "WStr", DllPath, "UPtr")

  Loop, % hashesListArray.Count()
  {
      thisHash := hashesListArray[A_Index]
      If !thisHash
         Continue
      countAll++
      thisIndex := A_Index
      Loop, % thisIndex - 1
      {
          countThese++
    ;      distCombinations[A_Index] := hashesListArray[A_Index]
          hDistances := HammingDistanceRust(thisHash, hashesListArray[A_Index])
      }
  }

/*

  Loop, % hashesListArray.MaxIndex()
  {
    originalIndex := A_Index
    startPoint := StrSplit(hashesListArray[originalIndex], "|:|")
    startPointV := startPoint[1]


  Loop, % hashesListArray.MaxIndex() ; - originalIndex
  {
      thisThing := hashesListArray[originalIndex + A_Index - thresholdu]
      If !thisThing
         Continue

      thisIndex := StrSplit(thisThing, "|:|")
      If isInRange(thisIndex[1], startPointV - thresholdu, startPointV + thresholdu)
      {
         newFilesIndex++
         newFilesList[newFilesIndex] := thisIndex[2]
 ;        tooltip, % newFilesIndex "--" thisIndex[1] "--" thisIndex[2]
      }
  }
}

   newFilesList := trimArray(newFilesList)
   filteredMap2mainList := []
   resultedFilesList := newFilesList.Clone()
   maxFilesIndex := newFilesIndex
   newFilesList := []
   newMappingList := []
   GenerateRandyList()
   ForceRefreshNowThumbsList()
*/

SoundBeep 
  MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) "`n" countThese "--" countAll "`n" hashesListArray.count()


  dummyTimerReloadThisPicture(50)
  
 ; Clipboard := hashesList
}

OpenNewExternalCoreThread(thisIndex, args, thisList) {
   pidThread := 0
   Try FileDelete, %thumbsCacheFolder%\tempList%thisIndex%.txt
   Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
   Sleep, 0
   Try FileAppend, % thisList, %thumbsCacheFolder%\tempFilesList.txt, utf-16
   Catch wasErrorA
         Sleep, 1

   If wasErrorA
      Return 0

   Sleep, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, threadParams, %thisIndex%||%args%

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath%,,, pidThread
   Catch wasErrorB
       Sleep, 0

   If (wasErrorB || !pidThread)
   {
      Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
      Return 0
   } Else
   {
      WinWait, ahk_pid %pidThread%,,2
      WinGet, hwndThread, ID, ahk_pid %pidThread%
      Sleep, 10
      Loop, 500
      {
          RegRead, thisThreadStarted, %QPVregEntry%\multicore, ThreadRunning%thisIndex%
          If (thisThreadStarted=1 || thisThreadStarted=2 || thisThreadStarted=-1)
             Break
          Else
             Sleep, 15
      }

      allGood := (thisThreadStarted=1 || thisThreadStarted=2) ? 1 : 0
      If (allGood!=1)
      {
         Process, Close, % pidThread
         RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
         Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
         Return 0
      }
      Return pidThread
   }
}

initExternalCoreMode() {
  Critical, on
  hasInitSpecialMode := 1
  RegRead, mainThreadHwnd, %QPVregEntry%\multicore, mainThreadHwnd
  If !WinExist("ahk_id" mainThreadHwnd)
  {
     RegWrite, REG_SZ, %QPVregEntry%, Running, 0
     fatalError := 1
  }

  RegRead, threadParams, %QPVregEntry%\multicore, threadParams
  If !threadParams
     fatalError := 1

  args := StrSplit(threadParams, "||")
  coreThread := args[1]

  Try FileRead, filesList, %thumbsCacheFolder%\tempFilesList.txt
  If !filesList
     fatalError := 1

  If (fatalError=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, -1
     ForceExitNow()
     Return
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 1
  initFIMGmodule()
  RegRead, hGDIwin, %QPVregEntry%\multicore, mainWindowID
     ; MsgBox, % args[1] "--" args[3]
  If (args[2]="batch-jpegll")
     multiCoresJpegLL(args[1], args[3], filesList)
  Else If (args[2]="batch-simpleimgproc")
     multiCoresSimpleImgProcessing(args[1], args[3], filesList)
  Else If (args[2]="batch-fmtconv")
     multiCoresFormatConvert(args[1], filesList)

  ; msgbox, killaaaa
  ForceExitNow()
  Return
}



testResourcesMemoryLeaks() {
  Loop, 4500
  {
       pEffect3 := Gdip_CreateEffect(1, 20, 0, 0)
       Gdip_DisposeEffect(pEffect3)

       lolBrush := Gdip_BrushCreateSolid("0x77898898")
       Gdip_DeleteBrush(lolBrush)

       lolPen1 := Gdip_CreatePen("0xCCbbccbb", 5)
       Gdip_DeletePen(lolPen1)


       lolPath := Gdip_CreatePath()
       Gdip_AddPathEllipse(lolPath, 30, 30, 200, 200)
       Gdip_DeletePath(lolPath)

       ; lola := drawTextInBox("loWooWol", "Arial", 99, 1500, 1500, "ff0099", "EEff0099", 0)
       pBitmap := trGdip_CreateBitmap(A_ThisFunc, 900, 900, "0xE200B")
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4)
       txtOptions := "x30 y30 center cEEff0099 r4 s10 Bold" 
       dimensions := Gdip_TextToGraphics(G3, "loooool", txtOptions, "Arial", 400, 400, 0, 0, 2)
       Gdip_DeleteGraphics(G3)
       trGdip_DisposeImage(pBitmap)
       trGdip_DisposeImage(lola)
  }
  MsgBox, lololol
}

GetInstalledPrinters(Delimiter="|",Default=True) {
;  Run, rundll32    shimgvw.dll    ImageView_PrintTo /pt   xxx.png   "printer name"
;  Run, mspaint /pt [image filename]


  if (Default = True)
  {
    regread,defaultPrinter,HKCU,Software\Microsoft\Windows NT\CurrentVersion\Windows,device
    stringsplit,defaultName,defaultPrinter,`,
    defaultName := defaultName1
    printerlist =
    loop,HKCU,Software\Microsoft\Windows NT\CurrentVersion\devices
    {
      if (A_LoopRegName = defaultname)
      printerlist = %printerlist%%A_loopRegName%%Delimiter%%Delimiter%
      else printerlist = %printerlist%%A_loopRegName%%Delimiter%
    }
  }
  else
  {
    printerlist =
    loop,HKCU,Software\Microsoft\Windows NT\CurrentVersion\devices
    {
      printerlist = %printerlist%%A_loopRegName%%Delimiter%
    }
  }
  StringTrimRight, printerlist, printerlist, StrLen(Delimiter)
  return %printerlist%
}

PrinterGetMatchingBitmap(width, height, color:="0xffFFFFFF") {
  ; set background-color (default is white)
  pBitmap := trGdip_CreateBitmap(A_ThisFunc, width, height)
  If StrLen(pBitmap)<3
     Return

  G := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4, 2)
  If G
     trGdip_GraphicsClear(A_ThisFunc, G, color)

  Gdip_DeleteGraphics(G)
  return pBitmap
}

printImageNow(mainBMP, PrintOptions, previewMode) {
   If StrLen(mainBMP)<3
      Return

   pPrinterName := PrintOptions.pPrinterName
   adaptFit := PrintOptions.adaptFit
   userImgX := PrintOptions.userImgX
   userImgY := PrintOptions.userImgY
   userImgW := PrintOptions.userImgW
   userImgH := PrintOptions.userImgH
   colorsMode := PrintOptions.colorsMode
   imgOrient := PrintOptions.imgOrient
   copiez := PrintOptions.copiez
   flipuV := PrintOptions.flipuV
   flipuH := PrintOptions.flipuH
   applyFX := PrintOptions.applyFX

   ; pPrinterName := SGDIPrint_GetDefaultPrinter()
   ; hdcObj := SGDIPrint_GetHDCfromPrintDlg(PVhwnd)
   hdcObj := SGDIPrint_GetHDCfromPrinterName(pPrinterName, 1, Round(colorsMode + 1), copiez, PVhwnd)
   If (previewMode=1)
   {
      calcIMGdimensions(hdcObj.HDC_Width, hdcObj.HDC_Height, 248, 351, ResizedW, ResizedH)
   } Else
   {
      ResizedW := hdcObj.HDC_Width
      ResizedH := hdcObj.HDC_Height
   }

   ; - "print" to bitmap -
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, "0xE200B")
   If (previewMode!=1)
   {
      If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
         Return
   }

   gPrint := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4, 2)
   E := trGdip_GraphicsClear(A_ThisFunc, gPrint, "0xFFffFFff")
   If (!pBitmap || !gPrint || E="fail")
      Return

   If (applyFX=1)
      decideGDIPimageFX(matrix, imageAttribs, pEffect)

   Gdip_GetImageDimensions(pBitmap, pageW, pageH)
   imgPosX := Round(pageW*(userImgX/100))
   imgPosY := Round(pageH*(userImgY/100))
   imgNewW := Round(pageW*(userImgW/100))
   imgNewH := Round(pageH*(userImgH/100))
   If (adaptFit=1)
   {
      imgNewH := pageH
      imgNewW := pageW
      imgPosX := imgPosY := 0
   }

   ; mainBMP := useGdiBitmap()
   If isInRange(imgOrient, 1, 359)
   {
      If (previewMode=1)
         imgToPrint := trGdip_ResizeBitmap(A_ThisFunc, mainBMP, 600, 600, 1, 3, -1)
      whichBitmap := StrLen(imgToPrint)>3 ? imgToPrint : mainBMP
      newBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, imgOrient, 1)
      If StrLen(imgToPrint)>3
         imgToPrint := trGdip_DisposeImage(imgToPrint, 1)

      If StrLen(newBitmap)>3
      {
         hasRotated := 1
         imgToPrint := newBitmap
      }
   } 

   whichBitmap := (hasRotated=1) ? imgToPrint : mainBMP
   Gdip_GetImageDimensions(whichBitmap, realImgW, realImgH)
   calcIMGdimensions(realImgW, realImgH, imgNewW, imgNewH, imgNewW, imgNewH)
   ; Gdip_GetRotatedDimensions(imgNewW, imgNewH, imgOrient, rotImgW, rotImgH)
   newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgNewW, imgNewH, 1)
   If StrLen(imgToPrint)>3
      trGdip_DisposeImage(imgToPrint, 1)

   failedResize := 0
   If StrLen(newBitmap)>3
      imgToPrint := newBitmap
   Else failedResize := 1

   If pEffect
   {
      Gdip_BitmapApplyEffect(imgToPrint, pEffect)
      Gdip_DisposeEffect(pEffect)
   }

   If (colorsMode!=1)
   {
      newBitmap := trGdip_BitmapConvertGray(imgToPrint)
      If StrLen(newBitmap)>3
      {
         trGdip_DisposeImage(imgToPrint, 1)
         imgToPrint := newBitmap
      }
   }
   If (flipuV=1)
      Gdip_ImageRotateFlip(imgToPrint, 6)
   If (flipuH=1)
      Gdip_ImageRotateFlip(imgToPrint, 4)

   If (adaptFit=1)
   {
      Gdip_GetImageDimensions(imgToPrint, imgNewW, imgNewH)
      imgPosX := (pageW - imgNewW)//2
      imgPosY := (pageH - imgNewH)//2
   }

   r4 := trGdip_DrawImage(A_ThisFunc, gPrint, imgToPrint, imgPosX, imgPosY,,,,,,,,, imageAttribs)
   previewScale := ResizedW / hdcObj.HDC_Width
   If StrLen(PrintOptions.text)>0
   {
      If (TextInAreaFontBold=1)
         thisStylu .= "Bold "
      If (TextInAreaFontItalic=1)
         thisStylu .= "Italic "
      If (TextInAreaFontUline=1)
         thisStylu .= "Underline "

      If (TextInAreaAlign=1)
         thisTxtAlignu := "Left "
      Else If (TextInAreaAlign=2)
         thisTxtAlignu := "Center "
      Else If (TextInAreaAlign=3)
         thisTxtAlignu := "Right "

      If (TextInAreaValign=1)
         thisTxtvAlignu := "Top "
      Else If (TextInAreaValign=2)
         thisTxtvAlignu := "vCenter "
      Else If (TextInAreaValign=3)
         thisTxtvAlignu := "Bottom "
      ; SoundBeep 
      ERR := Gdip_TextToGraphics(gPrint, PrintOptions.text, thisTxtAlignu thisTxtvAlignu thisStylu " s" Round(PrintTxtSize*previewScale) " cFF" TextInAreaFontColor, TextInAreaFontName, pageW, pageH)
      ; ToolTip, % ERR " == "  PrintOptions.text "`n" thisTxtAlignu thisTxtvAlignu " s" TextInAreaFontSize " c" TextInAreaFontColor " == " TextInAreaFontName " == " pageW " == " pageH , , , 2
   }

   If (previewMode!=1 && r4!="fail" && failedResize!=1)
   {
      r := SGDIPrint_BeginDocument(hdcObj.HDC_ptr, appTitle " image file")
      If r
      {
         SGDIPrint_CopyBitmapToPrinterHDC(pBitmap, hdcObj.HDC_ptr, hdcObj.HDC_Width, hdcObj.HDC_Height)
         SGDIPrint_EndDocument(hdcObj.HDC_ptr) ; starts printing
      }
   } Else If (previewMode=1)
   {
      marginuX := hdcObj.HDC_PHYSICALOFFSETX/hdcObj.HDC_PHYSICALWIDTH
      marginuY := hdcObj.HDC_PHYSICALOFFSETY/hdcObj.HDC_PHYSICALHEIGHT
      marginuX := Ceil(ResizedW * marginuX)
      marginuY := Ceil(ResizedH * marginuY)
      newBitmap := SGDIPrint_GetMatchingBitmap(ResizedW + marginuX*2, ResizedH + marginuY*2)
      If newBitmap
      {
         gU := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
         If gU
         {
            r4 := trGdip_DrawImage(A_ThisFunc, gU, pBitmap, marginuX, marginuY)
            If (r4!="fail")
            {
               hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, newBitmap)
               SetImage(hCropCornersPic, hBitmap)
               Gdi_DeleteObject(hBitmap)
            }
            Gdip_DeleteGraphics(gU)
         }
         trGdip_DisposeImage(newBitmap, 1)
      }
      pageDPI := Round((hdcObj.hdc_xdpi + hdcObj.hdc_ydpi)/2)
      pageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi, 1)
      pageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi, 1)
      MMpageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi * 25.4)
      MMpageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi * 25.4)
      GuiControl, SettingsGUIA:, PrinterPageInfos, % "Page details:`n" pageWr " x " pageHr " in`n" MMpageWr " x " MMpageHr " mm`n" pageDPI " DPI"
   }

   Gdip_DeleteGraphics(gPrint)
   trGdip_DisposeImage(pBitmap, 1)
   Gdip_DisposeImageAttributes(imageAttribs)
   trGdip_DisposeImage(imgToPrint, 1)
}

AcquireWIAimage() {
    Static clippyCount
    If askAboutFileSave(" and the dialog to acquire an image from a WIA-ready device will open")
       Return

    setImageLoading()
    showTOOLtip("Acquiring image, please wait")
    terminateIMGediting()
    Try hbmp := WIA_AcquireImage()
    Catch errMsg
       Sleep, 1

    If StrLen(hbmp)<4
    {
       ResetImgLoadStatus()
       showTOOLtip("Failed to acquire image`n" errMsg.message)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    } Else SoundBeep , 900, 100

    If hbmp
    {
       Gdip_GetImageDimensions(hbmp, imgW, imgH)
       If (imgW<5 || imgH<5)
       {
          ResetImgLoadStatus()
          hbmp := trGdip_DisposeImage(hbmp, 1)
          showTOOLtip("Failed to acquire image`nPossibly malformed image.")
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    }

    UserMemBMP := hbmp
    clippyCount++
    If (!currentFileIndex || !CurrentSLD || !maxFilesIndex)
    {
       maxFilesIndex := currentFileIndex := 0
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\WIA-Acquired-" clippyCount ".img"
    }

    imgIndexEditing := currentFileIndex
    usrColorDepth := imgFxMode := 1
    currIMGdetails.HasAlpha := 0
    vpIMGrotation := FlipImgH := FlipImgV := 0
    dropFilesSelection(1)
    RemoveTooltip()
    Gdi_DeleteObject(hbmp)
    SetTimer, ResetImgLoadStatus, -50
    SetTimer, RefreshImageFile, -50
}














testWICwhatever() {
/*
   destroyGDIfileCache()
   imgPath := getIDimage(currentFileIndex)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

   IWICImagingFactory_Initialize(pWICimgFactory, 1)
   IWICImagingFactory_CreateDecoderFromFilename(pWICimgFactory, imgPath,,,, ppIDecoder)
   IWICImagingFactory_CreateBitmapScaler(pWICimgFactory, ppIBitmapScaler)
   IWICImagingFactory_CreateFormatConverter(pWICimgFactory, ppIFormatConverter)

   IWICBitmapDecoder_GetFrameCount(ppIDecoder, fCount)
   IWICBitmapDecoder_GetFrame(ppIDecoder, 0, ppIBitmapSourceFrame)
   IWICBitmapScaler_Initialize(ppIBitmapScaler, ppIBitmapSourceFrame, mainWidth, mainHeight)
   ; IWICFormatConverter_Initialize(ppIFormatConverter, ppIBitmapScaler, "GUID_WICPixelFormat32bppBGR", 0, NULL, 0.1, 0)
*/

   MsgBox, % pWICimgFactory "`n" ppIDecoder "`n" fcount "`n" ppIBitmapSourceFrame "`nBMPscale" ppIBitmapScaler "`nFmtConv" ppIFormatConverter "`n" 
}

xxtestwhatever() {

   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x2
ppIDecoder := "lodekl"
   destroyGDIfileCache()
   wzFileName := getIDimage(currentFileIndex)

   thisObj := ComObjCreate("{cacaf262-9370-4615-a13b-9f5539da4c0a}", "{ec5ec8a9-c395-4314-9c77-54d7a935ff70}")
      thisObj.ThrowHRerrors := 1

   ; hr := DllCall(NumGet(NumGet(thisObj+0)+14*A_PtrSize), "ptr", thisObj, "ptr*", ppIWICStream)
   ;    WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)


   ; hr := DllCall(NumGet(NumGet(thisObj+0)+15*A_PtrSize), "ptr", thisObj, "str", wzFileName, "uint", dwDesiredAccess)
   ; if hr or ErrorLevel
   ;    WIC_hr(hr, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)

/*
   hr := DllCall(vtable(thisObj, 3)
         ,"ptr", thisObj
         ,"str", wzFilename
         ,"ptr", NULL ; WIC_GUID(GUID,pguidVendor)
         ,"uint", dwDesiredAccess
         ,"uint", metadataOptions
         ,"ptr*", ppIDecoder)
      WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)
   MsgBox, % thisObj "`n" ppIDecoder "`n" vtable(thisObj, 3) ;  "`n" WIC_hr(HR, "init")
*/
}


gtestwhatever() {
; # dwDesiredAccess
; WIC_GENERIC_READ = 0x80000000
; WIC_GENERIC_WRITE = 0x40000000

; # WICBitmapCreateCacheOption
; WICBitmapNoCache = 0x0
; WICBitmapCacheOnDemand = 0x1
; WICBitmapCacheOnLoad = 0x2

; # WICDecodeOptions
; WICDecodeMetadataCacheOnDemand = 0x0
; WICDecodeMetadataCacheOnLoad = 0x1


   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x1

   destroyGDIfileCache()
   imgPath := getIDimage(currentFileIndex)
   DllCall("windowscodecs.dll\WICCreateImagingFactory_Proxy", "Uint", WinCodecSKDversion, "UPtr*", pWICimgFactory)

   HR := DllCall("windowscodecs.dll\IWICImagingFactory_CreateDecoderFromFilename_Proxy", "UPtr", pWICimgFactory, "Wstr", imgPath, "Ptr", GuidVendor, "Uint", dwDesiredAccess, "Uint", metadataOptions, "UPtr*", ppIDecoder)
   MsgBox, % pWICimgFactory "`n" ppIDecoder
}

SelectFolderEx(StartingFolder:="", DlgTitle:="", OwnerHwnd:=0, OkBtnLabel:="", comboList:="", desiredDefault:=1, comboLabel:="", CustomPlaces:="", pickFoldersOnly:=1, usrFilters:="", defIndexFilter:=1, FileMustExist:=1, defaultEditField:="") {
; ==================================================================================================================================
; Shows a dialog to select a folder.
; Depending on the OS version the function will use either the built-in FileSelectFolder command (XP and previous)
; or the Common Item Dialog (Vista and later).
;
; Parameter:
;     StartingFolder -  the full path of a folder which will be preselected.
;     DlgTitle       -  a text used as window title (Common Item Dialog) or as text displayed withing the dialog.
;     FileMustExist  -  [bool] to allow or not opening files that do not exist
;     ----------------  Common Item Dialog only:
;     OwnerHwnd      -  HWND of the Gui which owns the dialog. If you pass a valid HWND the dialog will become modal.
;     BtnLabel       -  a text to be used as caption for the apply button.
;     comboList      -  a string with possible drop-down options, separated by `n [new line]
;     desiredDefault -  the default selected drop-down row
;     comboLabel     -  the drop-down label to display
;     CustomPlaces   -  custom directories that will be displayed in the left pane of the dialog; missing directories will be omitted; a string separated by `n [newline]
;     pickFoldersOnly - boolean option [0, 1]
;     defaultEditField - the text to display in the edit field by default when the open dialog shows up
;
;  Return values:
;     On success the function returns an object with the full path of the selected/file folder
;     and combobox selected [if any]; otherwise it returns an empty string.
;
; MSDN:
;     Common Item Dialog -> msdn.microsoft.com/en-us/library/bb776913%28v=vs.85%29.aspx
;     IFileDialog        -> msdn.microsoft.com/en-us/library/bb775966%28v=vs.85%29.aspx
;     IShellItem         -> msdn.microsoft.com/en-us/library/bb761140%28v=vs.85%29.aspx
; ==================================================================================================================================
; Source https://www.autohotkey.com/boards/viewtopic.php?f=6&t=18939
; by «just me»
; modified by Marius Șucan on jeudi 7 mai 2020
; to allow ComboBox and CustomPlaces
;
; options flags
; FOS_OVERWRITEPROMPT  = 0x2,
; FOS_STRICTFILETYPES  = 0x4,
; FOS_NOCHANGEDIR  = 0x8,
; FOS_PICKFOLDERS  = 0x20,
; FOS_FORCEFILESYSTEM  = 0x40,
; FOS_ALLNONSTORAGEITEMS  = 0x80,
; FOS_NOVALIDATE  = 0x100,
; FOS_ALLOWMULTISELECT  = 0x200,
; FOS_PATHMUSTEXIST  = 0x800,
; FOS_FILEMUSTEXIST  = 0x1000,
; FOS_CREATEPROMPT  = 0x2000,
; FOS_SHAREAWARE  = 0x4000,
; FOS_NOREADONLYRETURN  = 0x8000,
; FOS_NOTESTFILECREATE  = 0x10000,
; FOS_HIDEMRUPLACES  = 0x20000,
; FOS_HIDEPINNEDPLACES  = 0x40000,
; FOS_NODEREFERENCELINKS  = 0x100000,
; FOS_OKBUTTONNEEDSINTERACTION  = 0x200000,
; FOS_DONTADDTORECENT  = 0x2000000,
; FOS_FORCESHOWHIDDEN  = 0x10000000,
; FOS_DEFAULTNOMINIMODE  = 0x20000000,
; FOS_FORCEPREVIEWPANEON  = 0x40000000,
; FOS_SUPPORTSTREAMABLEITEMS  = 0x80000000

; IFileDialog vtable offsets
; 0   QueryInterface
; 1   AddRef 
; 2   Release 
; 3   Show 
; 4   SetFileTypes 
; 5   SetFileTypeIndex 
; 6   GetFileTypeIndex 
; 7   Advise 
; 8   Unadvise 
; 9   SetOptions 
; 10  GetOptions 
; 11  SetDefaultFolder 
; 12  SetFolder 
; 13  GetFolder 
; 14  GetCurrentSelection 
; 15  SetFileName 
; 16  GetFileName 
; 17  SetTitle 
; 18  SetOkButtonLabel 
; 19  SetFileNameLabel 
; 20  GetResult 
; 21  AddPlace 
; 22  SetDefaultExtension 
; 23  Close 
; 24  SetClientGuid 
; 25  ClearClientData 
; 26  SetFilter


   Static OsVersion := DllCall("GetVersion", "UChar")
        , IID_IShellItem := 0
        , InitIID := VarSetCapacity(IID_IShellItem, 16, 0)
                  & DllCall("Ole32.dll\IIDFromString", "WStr", "{43826d1e-e718-42ee-bc55-a1e261c37bfe}", "Ptr", &IID_IShellItem)
        , ShowDialog := A_PtrSize * 3
        , SetFileTypes := A_PtrSize * 4
        , SetFileTypeIndex := A_PtrSize * 5
        , SetOptions := A_PtrSize * 9
        , SetFolder := A_PtrSize * 12
        , SetDefaultEdit := A_PtrSize * 15 ; SetFileName
        , SetWinTitle := A_PtrSize * 17
        , SetOkButtonLabel := A_PtrSize * 18
        , GetResult := A_PtrSize * 20
        , AddPlaces := A_PtrSize * 21
        , ComDlgObj := {COMDLG_FILTERSPEC: ""}

   SelectedFolder := ""
   OwnerHwnd := DllCall("IsWindow", "Ptr", OwnerHwnd, "UInt") ? OwnerHwnd : 0
   Try FileDialog := ComObjCreate("{DC1C5A9C-E88A-4dde-A5A1-60F82A20AEF7}", "{42f85136-db7e-439c-85f1-e4075d135fc8}")
   If !FileDialog
   {
      thisOption := (FileMustExist=1) ? 3 : 2
      FileSelectFolder, SelectedFolder, *%StartingFolder%, % thisOption, % DlgTitle
      Return SelectedFolder
   }

   VTBL := NumGet(FileDialog + 0, "UPtr") ; virtual table addresses
   dialogOptions := 0x8 | 0x800  ;  FOS_NOCHANGEDIR | FOS_PATHMUSTEXIST
   If (pickFoldersOnly=1)
      dialogOptions |= 0x20      ; FOS_PICKFOLDERS

   If (FileMustExist=1)
      dialogOptions |=  0x1000   ; FOS_FILEMUSTEXIST

   DllCall(NumGet(VTBL + SetOptions, "UPtr"), "Ptr", FileDialog, "UInt", dialogOptions, "UInt")
   If StartingFolder
   {
      If !DllCall("Shell32.dll\SHCreateItemFromParsingName", "WStr", StartingFolder, "Ptr", 0, "Ptr", &IID_IShellItem, "PtrP", FolderItem)
         DllCall(NumGet(VTBL + SetFolder, "UPtr"), "Ptr", FileDialog, "Ptr", FolderItem, "UInt")
   }

   If DlgTitle
      DllCall(NumGet(VTBL + SetWinTitle, "UPtr"), "Ptr", FileDialog, "WStr", DlgTitle, "UInt")
   If OkBtnLabel
      DllCall(NumGet(VTBL + SetOkButtonLabel, "UPtr"), "Ptr", FileDialog, "WStr", OkBtnLabel, "UInt")

   If (pickFoldersOnly!=1)
   {
       Filters := IsObject(usrFilters) ? usrFilters : {"All files": "*.*"}
       ObjSetCapacity(ComDlgObj, "COMDLG_FILTERSPEC", 2*Filters.Count() * A_PtrSize)
       for Description, FileTypes in Filters
       {
           ObjRawSet(ComDlgObj, "#" . A_Index, Trimmer(Description))
           , ObjRawSet(ComDlgObj, "@" . A_Index, Trimmer(StrReplace(FileTypes,"`n")))
           , NumPut(ObjGetAddress(ComDlgObj,"#" . A_Index)
           , ObjGetAddress(ComDlgObj,"COMDLG_FILTERSPEC") + A_PtrSize * 2*(A_Index-1))        ; COMDLG_FILTERSPEC.pszName
           , NumPut(ObjGetAddress(ComDlgObj,"@" . A_Index)
           , ObjGetAddress(ComDlgObj,"COMDLG_FILTERSPEC") + A_PtrSize * (2*(A_Index-1)+1))    ; COMDLG_FILTERSPEC.pszSpec
       }

       ; IFileDialog::SetFileName method 
       ; https://docs.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-ifiledialog-setfilename
       If defaultEditField
          DllCall(NumGet(VTBL + SetDefaultEdit), "UPtr", FileDialog, "WStr", defaultEditField)

       ; IFileDialog::SetFileTypes method
       ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775980(v=vs.85).aspx
       DllCall(NumGet(VTBL + SetFileTypes), "UPtr", FileDialog, "UInt", Filters.Count(), "UPtr", ObjGetAddress(ComDlgObj,"COMDLG_FILTERSPEC"))

       ; IFileDialog::SetFileTypeIndex method
       ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775978(v=vs.85).aspx
       If defIndexFilter
          DllCall(NumGet(VTBL + SetFileTypeIndex), "UPtr", FileDialog, "UInt", defIndexFilter)
   }

   If CustomPlaces
   {
      Loop, Parse, CustomPlaces, `n
      {
          Directory := Trim(A_LoopField, "`r `n `t`f`v`b")
          If FolderExist(Directory)
          {
             foo := 1
             DllCall("Shell32.dll\SHParseDisplayName", "UPtr", &Directory, "Ptr", 0, "UPtrP", PIDL, "UInt", 0, "UInt", 0)
             DllCall("Shell32.dll\SHCreateShellItem", "Ptr", 0, "Ptr", 0, "UPtr", PIDL, "UPtrP", IShellItem)
             ObjRawSet(ComDlgObj, IShellItem, PIDL)
             ; IFileDialog::AddPlace method
             ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775946(v=vs.85).aspx
             DllCall(NumGet(VTBL + AddPlaces), "UPtr", FileDialog, "UPtr", IShellItem, "UInt", foo)
          }
      }
   }

   If (comboList && comboLabel)
   {
      Try If ((FileDialogCustomize := ComObjQuery(FileDialog, "{e6fdd21a-163f-4975-9c8c-a69f1ba37034}")))
      {
         groupId := 616 ; arbitrarily chosen IDs
         comboboxId := 93270
         DllCall(NumGet(NumGet(FileDialogCustomize+0)+26*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", groupId, "WStr", comboLabel) ; IFileDialogCustomize::StartVisualGroup
         DllCall(NumGet(NumGet(FileDialogCustomize+0)+6*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId) ; IFileDialogCustomize::AddComboBox
         ; DllCall(NumGet(NumGet(FileDialogCustomize+0)+19*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt", itemOneId, "WStr", "Current folder") ; IFileDialogCustomize::AddControlItem
         
         entriesArray := []
         Loop, Parse, comboList,`n
         {
             elementu := Trim(A_LoopField, "`r `n `t`f`v`b")
             If elementu
             {
                Random, varA, 2, 900
                Random, varB, 2, 900
                thisID := varA varB
                If (A_Index=desiredDefault)
                   desiredIDdefault := thisID

                entriesArray[thisId] := elementu
                DllCall(NumGet(NumGet(FileDialogCustomize+0)+19*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt", thisID, "WStr", elementu)
             }
         }

         DllCall(NumGet(NumGet(FileDialogCustomize+0)+25*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt", desiredIDdefault) ; IFileDialogCustomize::SetSelectedControlItem
         DllCall(NumGet(NumGet(FileDialogCustomize+0)+27*A_PtrSize), "Ptr", FileDialogCustomize) ; IFileDialogCustomize::EndVisualGroup
      }

   }

   If !DllCall(NumGet(VTBL + ShowDialog, "UPtr"), "Ptr", FileDialog, "Ptr", OwnerHwnd, "UInt")
   {
      If !DllCall(NumGet(VTBL + GetResult, "UPtr"), "Ptr", FileDialog, "PtrP", ShellItem, "UInt")
      {
         GetDisplayName := NumGet(NumGet(ShellItem + 0, "UPtr"), A_PtrSize * 5, "UPtr")
         If !DllCall(GetDisplayName, "Ptr", ShellItem, "UInt", 0x80028000, "PtrP", StrPtr) ; SIGDN_DESKTOPABSOLUTEPARSING
         {
            SelectedFolder := StrGet(StrPtr, "UTF-16")
            DllCall("Ole32.dll\CoTaskMemFree", "Ptr", StrPtr)
         }

         ObjRelease(ShellItem)
         if (FileDialogCustomize && entriesArray.Count())
         {
            if (DllCall(NumGet(NumGet(FileDialogCustomize+0)+24*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt*", selectedItemId) == 0)
            { ; IFileDialogCustomize::GetSelectedControlItem
               if selectedItemId
                  thisComboSelected := entriesArray[selectedItemId]
            }   
         }
      }
   }
   If (FolderItem)
      ObjRelease(FolderItem)

   if (FileDialogCustomize)
      ObjRelease(FileDialogCustomize)

   ObjRelease(FileDialog)
   r := []
   r.SelectedDir := SelectedFolder
   r.SelectedCombo := thisComboSelected
   Return r
}

recentOpenedFolders() {
   If (allowRecordHistory=1)
   {
      historyList := readRecentEntries()
      historyList .= readRecentFileDesties()
      Loop, Parse, historyList, `n
      {
         If (A_Index>30)
            Break

         entryu := StrReplace(A_LoopField, "|")
         If (!entryu || RegExMatch(entryu, sldsPattern))
            Continue

         If FolderExist(entryu)
            entriesList .= entryu "`n"
      }
      Sort, entriesList, UD`n
   }
   Return Trimmer(entriesList)
}


;------------------------------
;
; Function: Dlg_OpenSaveFile
;
; Description:
;
;   Internal function used by <Dlg_OpenFile> and <Dlg_SaveFile> to create an
;   Open or Save dialog.
;
; Type:
;
;   Internal function.  Subject to change.  Do not call directly.
;
; Parameters:
;
;   p_Type - [Internal function only] Set to "O" or "Open" to create a Open
;       dialog.  Set to "S" or "Save" to create a Save dialog.
;
;   hOwner - A handle to the window that owns the dialog box.  This parameter
;       can be any valid window handle or it can be set to 0 or null if the
;       dialog box has no owner.  Note: A valid window handle must be specified
;       if the OFN_SHOWHELP flag is included (explicitly or implicitly).
;
;   p_Title - A string to be placed in the title bar of the dialog box.  If set
;       to null (the default), the system uses the default title (that is,
;       "Open" or "Save As").
;
;   p_Filter - One or more filter strings that determine which files are
;       displayed. [Optional] Each filter string is composed of two parts.
;       The first part describes the filter.  For example: "Text Files".  The
;       second part specifies the filter pattern and must be enclosed in
;       parenthesis.  For example "(*.txt)".  To specify multiple filter
;       patterns for a single display string, use a semicolon to separate the
;       patterns.  For example: "(*.txt;*.doc;*.bak)".  A pattern string can be
;       a combination of valid file name characters and the asterisk ("*")
;       wildcard character.  Do not include spaces in the pattern string.
;       Multiple filter strings are delimited by the "|" character.  For
;       example: "Text Files (*.txt)|Backup Files (*.bak)".
;
;   p_FilterIndex - 1-based filter index.  If set to null (the default), 1 is
;       used.  The index determines which filter string is pre-selected in the
;       "File Types" control.
;
;   p_Root - Root (startup) directory and/or default file name.  To specify a
;       root directory only, include the full path of the directory with a
;       trailing "\" character.  Ex: "C:\Program Files\".  To specify a startup
;       directory and a default file, include the full path of the default file.
;       Ex: "C:\My Stuff\My Program.html".  To specify a default file only,
;       include the file name without the path.  Ex: "My Program.html".  If a
;       default file name is included, the file name (sans the path) is shown in
;       the dialog's "File name:" edit field. If this parameter is set to null
;       (the default), the startup directory will be set using the OS default
;       for this dialog.  See the documentation for the OPENFILENAME structure
;       (lpstrInitialDir member) for more information.
;
;   p_DfltExt - Extension to append when none is given.  Ex: "txt".  The string
;       should not contain a period (".").  If this parameter is null (the
;       default) and the user fails to type an extension, no extension is
;       appended.
;
;   r_Flags - Flags used to initialize the dialog. [Optional, Input/Output] See
;       the *Flags* section for the details.
;
;   p_HelpHandler - Name of a developer-created function that is called when the
;       the user presses the Help button on the dialog. [Optional] See the *Help
;       Handler* section for the details.  Note: The OFN_SHOWHELP flag is
;       automatically added if this parameter contains a valid function name.
;
; Flags:
;
;   On input, the r_Flags parameter contains flags that are used to initialize
;   and/or determine the behavior of the dialog.  If set to 0 or null and
;   p_Type="O" (Open dialog), the OFN_FILEMUSTEXIST and OFN_HIDEREADONLY flags
;   are added automatically.  If r_Flag contains an interger value, the
;   parameter is assumed to contain bit flags.  See the function's static
;   variables for a list a valid bit flags.  Otherwise, text flags are assumed.
;   The following space-delimited text flags can be used.
;
;   AllowMultiSelect - Specifies that the File Name list box allows multiple
;       selections.
;
;   CreatePrompt - [Open dialog only] If the user specifies a file that does not
;       exist, this flag causes the dialog to prompt the user for permission to
;       create the file.
;
;   DontAddToRecent - Prevents the system from adding a link to the selected
;       file in the file system directory that contains the user's most recently
;       used documents.
;
;   Ex_NoPlacesBar - If specified, the places bar is not displayed.  If not
;       specified, Explorer-style dialog boxes include a places bar containing
;       icons for commonly-used folders, such as Favorites and Desktop.
;
;   FileMustExist - [Open dialog only (with implicit exceptions)] This flag
;       ensures that the user can only type names of existing files in the File
;       Name entry.  A message box is generated if an invalid file is entered.
;       Opinion: This flag should be specified in most circumstances.
;       IMPORTANT: If this flag is specified (explicitly or implicitly), the
;       PathMustExist flag is also used.  See the PathMustExist flag for the
;       rules that are enforced for both the Open and Save dialogs.
;
;   ForceShowHidden - Forces the showing of system and hidden files, thus
;       overriding the user setting to show or not show hidden files.  However,
;       a file that is marked both system and hidden is not shown.  Observation:
;       This flag does not work as expected on Windows XP (may also occur on
;       other (or all) versions of Windows).  When a directory that includes a
;       hidden file is first displayed (including the initial directory), hidden
;       files are not shown.  Clicking on the "Open" or "Save" button without
;       selecting a file will redisplay the list of files to include the hidden
;       file(s).
;
;   HideReadOnly - [Open dialog only] Hides the Read Only check box.  This flag
;       should be specified in most circumstances.
;
;   NoChangeDir - Restores the current directory to its original value if the
;       user changed the directory while searching for files.
;
;   NoDereferenceLinks - Directs the dialog box to return the path and file name
;       of the selected shortcut (.LNK) file.  If this value is not specified,
;       the dialog box returns the path and file name of the file referenced by
;       the shortcut.  Observation: For shortcuts to OS files, this works as
;       expected.  However, for other types of shortcuts, Ex: shortcuts to a web
;       site, the return value may not be what is expected.  Test thoroughly
;       before using.
;
;   NoReadOnlyReturn - [Save dialog only] Prevents the dialog from returning
;       names of existing files that have the read-only attribute.  If a
;       read-only file is selected, a message dialog is generated.  The dialog
;       will persist until the selection does not include a file with read-only
;       attribute.
;
;   NoTestFileCreate - By default, the dialog box creates a zero-length test
;       file to determine whether a new file can be created in the selected
;       directory.  Set this flag to prevent the creation of this test file.
;       This flag should be specified if the application saves the file on a
;       network drive with Create but no Modify privileges.
;
;   NoValidate - Specifies that the common dialog boxes allow invalid characters
;       in the returned file name.
;
;   OverwritePrompt - [Save dialog only] Causes the dialog to generate a message
;       box if the selected file already exists.  The user must confirm whether
;       to overwrite the file.
;
;   PathMustExist - Specifies that the user can type only existing paths in the
;       File Name entry.  A message box is generated if an invalid path is
;       entered.  Note: This flag is automatically added if the FileMustExist
;       flag is used.
;
;   ReadOnly - [Open dialog only] Causes the Read Only check box to be selected
;       initially when the dialog box is created.
;
;   ShowHelp - Causes the dialog to display the Help button.
;
;   On output, the r_Flag parameter may contain bit flags that inform the
;   developer of conditions of the dialog at the time the dialog was closed.
;   The following bit flags can be set.
;
;   OFN_READONLY (0x1) - [Open dialog only] This flag is set if the Read Only
;       check box was checked when the dialog was closed.
;
;   OFN_EXTENSIONDIFFERENT (0x400) - This flag is set if the p_DfltExt parameter
;       is not null and the user selected or typed a file name extension that
;       differs from the p_DfltExt parameter.  Exception: This flag is not set
;       if multiple files are selected.
;
; Returns:
;
;   Selected file name(s) or null if cancelled.  If more then one file is
;   selected, each file is delimited by a new line ("`n") character.
;
; Remarks:
;
;   If the user changes the directory while using the Open or Save dialog, the
;   script's working directory will also be changed.  If desired, use the
;   "NoChangeDir" flag (r_Flags parameter) to prevent this from occurring or use
;   the *SetWorkingDir* command to restore the working directory after calling
;   this function.
;
; Help Handler:
;
;   The "Help Handler" is an optional developer-created function that is called
;   when the user presses the Help button on the dialog.
;
;   The handler function must have at least 2 parameters.  Additional parameters
;   are allowed but must be optional (defined with a default value).  The
;   required parameters are defined/used as follows, and in the following order:
;
;       hDialog - The handle to the dialog window.
;
;       lpInitStructure - A pointer to the initialization structure for the
;           common dialog box. For this handler, the pointer is to a
;           OPENFILENAME structure.
;
;   It's up to the developer to determine what commands are performed in this
;   function but displaying some sort of help message/document is what is
;   expected.
;
;   To avoid interference with the operation of the dialog, the handler should
;   either 1) finish quickly or 2) any dialogs displayed via the handler should
;   be modal.  See the scripts included with this project for an example.
;
;-------------------------------------------------------------------------------
Dlg_OpenSaveFile(p_Type,hOwner:=0,p_Title:="",p_Filter:="",p_FilterIndex:="",p_Root:="",p_DfltExt:="",ByRef r_Flags:=0,p_HelpHandler:="") {
; function source: https://www.autohotkey.com/boards/viewtopic.php?f=6&t=462
; by jballi

    Static Dummy16963733
          ,s_strFileMaxSize:=32768
                ;-- This is the ANSI byte limit.  For consistency, this value
                ;   is also used to set the the maximum number characters that
                ;   used in Unicode.  Note: Only the first entry contains the
                ;   folder name so 32K characters can hold a very large number
                ;   of file names.

          ,HELPMSGSTRING:="commdlg_help"
                ;-- Registered message string for the Help button on common
                ;   dialogs

          ,OPENFILENAME
                ;-- Static OPENFILENAME structure.  Also used by the hook
                ;   callback and the help message.

          ;-- Open File Name flags
          ,OFN_ALLOWMULTISELECT    :=0x200
          ,OFN_CREATEPROMPT        :=0x2000
          ,OFN_DONTADDTORECENT     :=0x2000000
          ,OFN_ENABLEHOOK          :=0x20

          ,OFN_EXPLORER            :=0x80000
                ;-- This flag is set by default.  This function does not work
                ;   with the old-style dialog box.

          ,OFN_EXTENSIONDIFFERENT  :=0x400
                ;-- Output flag only.

          ,OFN_FILEMUSTEXIST       :=0x1000
          ,OFN_FORCESHOWHIDDEN     :=0x10000000
          ,OFN_HIDEREADONLY        :=0x4

          ,OFN_NOCHANGEDIR         :=0x8
          ,OFN_NODEREFERENCELINKS  :=0x100000

          ,OFN_NOREADONLYRETURN    :=0x8000
          ,OFN_NOTESTFILECREATE    :=0x10000
          ,OFN_NOVALIDATE          :=0x100
          ,OFN_OVERWRITEPROMPT     :=0x2
          ,OFN_PATHMUSTEXIST       :=0x800
          ,OFN_READONLY            :=0x1
          ,OFN_SHOWHELP            :=0x10

          ;-- Open File Name extended flags
          ,OFN_EX_NOPLACESBAR      :=0x1
                ;-- Note: This flag is only available as a text flag, i.e.
                ;   "NoPlacesBar".

          ;-- Misc.
          ,TCharSize:=A_IsUnicode ? 2:1

    ;[==============]
    ;[  Parameters  ]
    ;[==============]
    ;-- Type
    p_Type:=SubStr(p_Type,1,1)
    StringUpper p_Type,p_Type
        ;-- Convert to uppercase to simplify processing

    if p_Type not in O,S
        p_Type:="O"

    ;-- Filter
    if p_Filter is Space
        p_Filter:="All Files (*.*)"

    ;-- Flags
    l_Flags  :=OFN_EXPLORER
    l_FlagsEx:=0
    if not r_Flags  ;-- Zero, blank, or null
    {
        if (p_Type="O")  ;-- Open dialog only
            l_Flags|=OFN_FILEMUSTEXIST|OFN_HIDEREADONLY
    } else
    {
        ;-- Bit flags
        if r_Flags is Integer
        {
            l_Flags|=r_Flags
        } else
        {
            ;-- Convert text flags into bit flags
            Loop Parse,r_Flags,%A_Tab%%A_Space%,%A_Tab%%A_Space%
            {
                if A_LoopField is not Space
                {
                    if OFN_%A_LoopField% is Integer
                    {
                        if InStr(A_LoopField,"ex_")
                            l_FlagsEx|=OFN_%A_LoopField%
                        else
                            l_Flags|=OFN_%A_LoopField%
                    }
                }
            }
        }
    }

    if IsFunc(p_HelpHandler)
        l_Flags|=OFN_SHOWHELP

    ; if (p_Type="O") and (l_Flags & OFN_ALLOWMULTISELECT)
    ;     l_Flags|=OFN_ENABLEHOOK

    ;-- Create and, if needed, populate the buffer used to initialize the
    ;   File Name Edit control.  The dialog will also use this buffer to return
    ;   the file(s) selected.
    VarSetCapacity(strFile,s_strFileMaxSize*TCharSize,0)
    SplitPath p_Root,l_RootFileName,l_RootDir
    if l_RootFileName is not Space
    {
        DllCall("RtlMoveMemory"
            ,"Str",strFile
            ,"Str",l_RootFileName
            ,"UInt",(StrLen(l_RootFileName)+1)*TCharSize)
    }

    ;-- Convert p_Filter into the format required by the API
    VarSetCapacity(strFilter,StrLen(p_Filter)*(A_IsUnicode ? 5:3),0)
        ;-- Enough space for the full description _and_ file pattern(s) of all
        ;   filter strings (ANSI and Unicode) plus null characters between all
        ;   of the pieces and a double null at the end.

    l_Offset:=&strFilter
    Loop Parse,p_Filter,|
    {
        ;-- Break the filter string into 2 parts
        l_LoopField:=Trim(A_LoopField," `f`n`r`t`v")
            ;-- Assign and remove all leading/trailing white space

        l_Part1:=l_LoopField
            ;-- Part 1: The entire filter string which includes the description
            ;   and the file pattern(s) in parenthesis.  This is what is
            ;   displayed in  the "File Of Types" or the "Save As Type"
            ;   drop-down.

        l_Part2:=SubStr(l_LoopField,InStr(l_LoopField,"(")+1,-1)
            ;-- Part 2: File pattern(s) sans parenthesis.  The dialog uses this
            ;   to filter the files that are displayed.

        ;-- Calculate the length of the pieces
        l_lenPart1:=(StrLen(l_LoopField)+1)*TCharSize
            ;-- Size includes terminating null

        l_lenPart2:=(StrLen(l_Part2)+1)*TCharSize
            ;-- Size includes terminating null

        ;-- Copy the pieces to the filter string.  Each piece includes a
        ;   terminating null character.
        DllCall("RtlMoveMemory","Ptr",l_Offset,"Str",l_Part1,"UInt",l_lenPart1)
        DllCall("RtlMoveMemory","Ptr",l_Offset+l_lenPart1,"Str",l_Part2,"UInt",l_lenPart2)                          ;-- Length

        ;-- Calculate the offset of the next filter string
        l_Offset+=l_lenPart1+l_lenPart2
    }

    ;[==================]
    ;[  Pre-Processing  ]
    ;[==================]
    ;-- Create and populate the OPENFILENAME structure
    lStructSize:=VarSetCapacity(OPENFILENAME,(A_PtrSize=8) ? 152:88,0)
    NumPut(lStructSize,OPENFILENAME,0,"UInt")
        ;-- lStructSize
    NumPut(hOwner,OPENFILENAME,(A_PtrSize=8) ? 8:4,"Ptr")
        ;-- hwndOwner
    NumPut(&strFilter,OPENFILENAME,(A_PtrSize=8) ? 24:12,"Ptr")
        ;-- lpstrFilter
    NumPut(p_FilterIndex,OPENFILENAME,(A_PtrSize=8) ? 44:24,"UInt")
        ;-- nFilterIndex
    NumPut(&strFile,OPENFILENAME,(A_PtrSize=8) ? 48:28,"Ptr")
        ;-- lpstrFile
    NumPut(s_strFileMaxSize,OPENFILENAME,(A_PtrSize=8) ? 56:32,"UInt")
        ;-- nMaxFile
    NumPut(&l_RootDir,OPENFILENAME,(A_PtrSize=8) ? 80:44,"Ptr")
        ;-- lpstrInitialDir
    NumPut(&p_Title,OPENFILENAME,(A_PtrSize=8) ? 88:48,"Ptr")
        ;-- lpstrTitle
    NumPut(l_Flags,OPENFILENAME,(A_PtrSize=8) ? 96:52,"UInt")
        ;-- Flags
    NumPut(&p_DfltExt,OPENFILENAME,(A_PtrSize=8) ? 104:60,"Ptr")
        ;-- lpstrDefExt
    NumPut(l_FlagsEx,OPENFILENAME,(A_PtrSize=8) ? 148:84,"UInt")
        ;-- FlagsEx

    ;[===============]
    ;[  Show dialog  ]
    ;[===============]
    if (p_type="O")
        RC:=DllCall("comdlg32\GetOpenFileName" . (A_IsUnicode ? "W":"A"),"Ptr",&OPENFILENAME)
    else
        RC:=DllCall("comdlg32\GetSaveFileName" . (A_IsUnicode ? "W":"A"),"Ptr",&OPENFILENAME)

    ;[===================]
    ;[  Post-Processing  ]
    ;[===================]
    ;-- If needed, turn off monitoring of help message
    if l_HelpMsg
        OnMessage(l_HelpMsg,"")  ;-- Turn off monitoring

    ;-- Dialog canceled?
    if (RC=0)
        Return

    ;-- Rebuild r_Flags for output
    r_Flags  :=0
    l_Flags:=NumGet(OPENFILENAME,(A_PtrSize=8) ? 96:52,"UInt")
    n_FilterIndex := NumGet(OPENFILENAME,(A_PtrSize=8) ? 44:24,"UInt")
    ;-- Flags

    if p_DfltExt is not Space  ;-- Flag is ignored unless p_DfltExt contains a value
    {
        if l_Flags & OFN_EXTENSIONDIFFERENT
            r_Flags|=OFN_EXTENSIONDIFFERENT
    }

    if (p_Type="O")  ;-- i.e. flag is ignored if using the Save dialog
    {
        if l_Flags & OFN_ALLOWMULTISELECT
        {
            ; Hook was used to collect ReadOnly status.  Collect the ReadOnly
            ; status from the hook function.
            Sleep, 1
            ; if Dlg_OFNHookCallback("GetReadOnly","","","")
            ; r_Flags|=OFN_READONLY
        } else
        {
            ;-- Hook was NOT used to collect ReadOnly status.  Determine status from l_Flags
            if l_Flags & OFN_READONLY
                r_Flags|=OFN_READONLY
        }
    }

    ;-- Extract file(s) from the buffer
    l_FileList:=""
    l_Offset  :=&strFile
    Loop
    {
        ;-- Get next
        l_Next:=StrGet(l_Offset,-1)

        ;-- End of list?
        if not StrLen(l_Next)
        {
            ;-- If end-of-list occurs on the 2nd iteration, it means that only
            ;   one file was selected
            if (A_Index=2)
                l_FileList:=l_FileName
            Break
        }

        ;-- Assign to working variable
        l_FileName:=l_Next

        ;-- Update the offset for the next iteration
        l_Offset+=(StrLen(l_FileName)+1)*TCharSize

        ;-- If this is the first iteration, we have to wait until the next loop
        ;   before we can determine if this is a directory or file and if a
        ;   file, if it is the only file selected.
        if (A_Index=1)
        {
            l_Dir:=l_FileName
            ;-- Windows adds "\" character when in root of the drive but doesn't
            ;   add it otherwise.  Adjust if needed.
            if (StrLen(l_Dir)<>3)
                l_Dir.="\"

            ;-- Continue to next
            Continue
        }

        ;-- Add the file to the list
        l_FileList.=(StrLen(l_FileList) ? "`n":"") . l_Dir . l_FileName
    }
    ; ToolTip, % n_FilterIndex , , , 2
    ;-Return to sender
    Return l_FileList
}

SHGetKnownFolderPath(FOLDERID, KF_FLAG:=0) {                  ;   By SKAN on D356 @ tiny.cc/t-75602 
   ; FOLDERID_AccountPictures         := "{008ca0b1-55b4-4c56-b8a8-4de4b299d3be}" ; Windows  8
   ; FOLDERID_AddNewPrograms          := "{de61d971-5ebc-4f02-a3a9-6c82895e5c04}"  
   ; FOLDERID_AdminTools              := "{724EF170-A42D-4FEF-9F26-B60E846FBA4F}"  
   ; FOLDERID_AppDataDesktop          := "{B2C5E279-7ADD-439F-B28C-C41FE1BBF672}" ; Windows  10, version 1709
   ; FOLDERID_AppDataDocuments        := "{7BE16610-1F7F-44AC-BFF0-83E15F2FFCA1}" ; Windows  10, version 1709
   ; FOLDERID_AppDataFavorites        := "{7CFBEFBC-DE1F-45AA-B843-A542AC536CC9}" ; Windows  10, version 1709
   ; FOLDERID_AppDataProgramData      := "{559D40A3-A036-40FA-AF61-84CB430A4D34}" ; Windows  10, version 1709
   ; FOLDERID_ApplicationShortcuts    := "{A3918781-E5F2-4890-B3D9-A7E54332328C}" ; Windows  8
   ; FOLDERID_AppsFolder              := "{1e87508d-89c2-42f0-8a7e-645a0f50ca58}" ; Windows  8
   ; FOLDERID_AppUpdates              := "{a305ce99-f527-492b-8b1a-7e76fa98d6e4}"  
   ; FOLDERID_CameraRoll              := "{AB5FB87B-7CE2-4F83-915D-550846C9537B}" ; Windows  8.1
   ; FOLDERID_CDBurning               := "{9E52AB10-F80D-49DF-ACB8-4330F5687855}"  
   ; FOLDERID_ChangeRemovePrograms    := "{df7266ac-9274-4867-8d55-3bd661de872d}"  
   ; FOLDERID_CommonAdminTools        := "{D0384E7D-BAC3-4797-8F14-CBA229B392B5}"  
   ; FOLDERID_CommonOEMLinks          := "{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}"  
   ; FOLDERID_CommonPrograms          := "{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}"  
   ; FOLDERID_CommonStartMenu         := "{A4115719-D62E-491D-AA7C-E74B8BE3B067}"  
   ; FOLDERID_CommonStartup           := "{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}"  
   ; FOLDERID_CommonTemplates         := "{B94237E7-57AC-4347-9151-B08C6C32D1F7}"  
   ; FOLDERID_ComputerFolder          := "{0AC0837C-BBF8-452A-850D-79D08E667CA7}"  
   ; FOLDERID_ConflictFolder          := "{4bfefb45-347d-4006-a5be-ac0cb0567192}" ; Windows  Vista
   ; FOLDERID_ConnectionsFolder       := "{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}"  
   ; FOLDERID_Contacts                := "{56784854-C6CB-462b-8169-88E350ACB882}" ; Windows  Vista
   ; FOLDERID_ControlPanelFolder      := "{82A74AEB-AEB4-465C-A014-D097EE346D63}"  
   ; FOLDERID_Cookies                 := "{2B0F765D-C0E9-4171-908E-08A611B84FF6}"  
   ; FOLDERID_Desktop                 := "{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}"  
   ; FOLDERID_DeviceMetadataStore     := "{5CE4A5E9-E4EB-479D-B89F-130C02886155}" ; Windows  7
   ; FOLDERID_Documents               := "{FDD39AD0-238F-46AF-ADB4-6C85480369C7}"  
   ; FOLDERID_DocumentsLibrary        := "{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}" ; Windows  7
   ; FOLDERID_Downloads               := "{374DE290-123F-4565-9164-39C4925E467B}"  
   ; FOLDERID_Favorites               := "{1777F761-68AD-4D8A-87BD-30B759FA33DD}"  
   ; FOLDERID_Fonts                   := "{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}"  
   ; FOLDERID_Games                   := "{CAC52C1A-B53D-4edc-92D7-6B2E8AC19434}"  
   ; FOLDERID_GameTasks               := "{054FAE61-4DD8-4787-80B6-090220C4B700}" ; Windows  Vista
   ; FOLDERID_History                 := "{D9DC8A3B-B784-432E-A781-5A1130A75963}"  
   ; FOLDERID_HomeGroup               := "{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}" ; Windows  7
   ; FOLDERID_HomeGroupCurrentUser    := "{9B74B6A3-0DFD-4f11-9E78-5F7800F2E772}" ; Windows  8
   ; FOLDERID_ImplicitAppShortcuts    := "{BCB5256F-79F6-4CEE-B725-DC34E402FD46}" ; Windows  7
   ; FOLDERID_InternetCache           := "{352481E8-33BE-4251-BA85-6007CAEDCF9D}"  
   ; FOLDERID_InternetFolder          := "{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}"  
   ; FOLDERID_Libraries               := "{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}" ; Windows  7
   ; FOLDERID_Links                   := "{bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968}"  
   ; FOLDERID_LocalAppData            := "{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}"  
   ; FOLDERID_LocalAppDataLow         := "{A520A1A4-1780-4FF6-BD18-167343C5AF16}"  
   ; FOLDERID_LocalizedResourcesDir   := "{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}"  
   ; FOLDERID_Music                   := "{4BD8D571-6D19-48D3-BE97-422220080E43}"  
   ; FOLDERID_MusicLibrary            := "{2112AB0A-C86A-4FFE-A368-0DE96E47012E}" ; Windows  7
   ; FOLDERID_NetHood                 := "{C5ABBF53-E17F-4121-8900-86626FC2C973}"  
   ; FOLDERID_NetworkFolder           := "{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}"  
   ; FOLDERID_Objects3D               := "{31C0DD25-9439-4F12-BF41-7FF4EDA38722}" ; Windows  10, version 1703
   ; FOLDERID_OriginalImages          := "{2C36C0AA-5812-4b87-BFD0-4CD0DFB19B39}" ; Windows  Vista
   ; FOLDERID_PhotoAlbums             := "{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}" ; Windows  Vista
   ; FOLDERID_PicturesLibrary         := "{A990AE9F-A03B-4E80-94BC-9912D7504104}" ; Windows  7
   ; FOLDERID_Pictures                := "{33E28130-4E1E-4676-835A-98395C3BC3BB}"  
   ; FOLDERID_Playlists               := "{DE92C1C7-837F-4F69-A3BB-86E631204A23}"  
   ; FOLDERID_PrintersFolder          := "{76FC4E2D-D6AD-4519-A663-37BD56068185}"  
   ; FOLDERID_PrintHood               := "{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}"  
   ; FOLDERID_Profile                 := "{5E6C858F-0E22-4760-9AFE-EA3317B67173}"  
   ; FOLDERID_ProgramData             := "{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}"  
   ; FOLDERID_ProgramFiles            := "{905e63b6-c1bf-494e-b29c-65b732d3d21a}"  
   ; FOLDERID_ProgramFilesX64         := "{6D809377-6AF0-444b-8957-A3773F02200E}"  
   ; FOLDERID_ProgramFilesX86         := "{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}"  
   ; FOLDERID_ProgramFilesCommon      := "{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}"  
   ; FOLDERID_ProgramFilesCommonX64   := "{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}"  
   ; FOLDERID_ProgramFilesCommonX86   := "{DE974D24-D9C6-4D3E-BF91-F4455120B917}"  
   ; FOLDERID_Programs                := "{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}"  
   ; FOLDERID_Public                  := "{DFDF76A2-C82A-4D63-906A-5644AC457385}"  
   ; FOLDERID_PublicDesktop           := "{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}"  
   ; FOLDERID_PublicDocuments         := "{ED4824AF-DCE4-45A8-81E2-FC7965083634}"  
   ; FOLDERID_PublicDownloads         := "{3D644C9B-1FB8-4f30-9B45-F670235F79C0}" ; Windows  Vista
   ; FOLDERID_PublicGameTasks         := "{DEBF2536-E1A8-4c59-B6A2-414586476AEA}" ; Windows  Vista
   ; FOLDERID_PublicLibraries         := "{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}" ; Windows  7
   ; FOLDERID_PublicMusic             := "{3214FAB5-9757-4298-BB61-92A9DEAA44FF}"  
   ; FOLDERID_PublicPictures          := "{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}"  
   ; FOLDERID_PublicRingtones         := "{E555AB60-153B-4D17-9F04-A5FE99FC15EC}" ; Windows  7
   ; FOLDERID_PublicUserTiles         := "{0482af6c-08f1-4c34-8c90-e17ec98b1e17}" ; Windows  8
   ; FOLDERID_PublicVideos            := "{2400183A-6185-49FB-A2D8-4A392A602BA3}"  
   ; FOLDERID_QuickLaunch             := "{52a4f021-7b75-48a9-9f6b-4b87a210bc8f}"  
   ; FOLDERID_Recent                  := "{AE50C081-EBD2-438A-8655-8A092E34987A}"  
   ; FOLDERID_RecordedTV              := "{1A6FDBA2-F42D-4358-A798-B74D745926C5}" ; Windows  7
   ; FOLDERID_RecycleBinFolder        := "{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}"  
   ; FOLDERID_ResourceDir             := "{8AD10C31-2ADB-4296-A8F7-E4701232C972}"  
   ; FOLDERID_Ringtones               := "{C870044B-F49E-4126-A9C3-B52A1FF411E8}" ; Windows  7
   ; FOLDERID_RoamingAppData          := "{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}"  
   ; FOLDERID_RoamedTileImages        := "{AAA8D5A5-F1D6-4259-BAA8-78E7EF60835E}" ; Windows  8
   ; FOLDERID_RoamingTiles            := "{00BCFC5A-ED94-4e48-96A1-3F6217F21990}" ; Windows  8
   ; FOLDERID_SampleMusic             := "{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}"  
   ; FOLDERID_SamplePictures          := "{C4900540-2379-4C75-844B-64E6FAF8716B}"  
   ; FOLDERID_SamplePlaylists         := "{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}" ; Windows  Vista
   ; FOLDERID_SampleVideos            := "{859EAD94-2E85-48AD-A71A-0969CB56A6CD}"  
   ; FOLDERID_SavedGames              := "{4C5C32FF-BB9D-43b0-B5B4-2D72E54EAAA4}" ; Windows  Vista
   ; FOLDERID_SavedPictures           := "{3B193882-D3AD-4eab-965A-69829D1FB59F}"  
   ; FOLDERID_SavedPicturesLibrary    := "{E25B5812-BE88-4bd9-94B0-29233477B6C3}"  
   ; FOLDERID_SavedSearches           := "{7d1d3a04-debb-4115-95cf-2f29da2920da}"  
   ; FOLDERID_Screenshots             := "{b7bede81-df94-4682-a7d8-57a52620b86f}" ; Windows  8
   ; FOLDERID_SEARCH_CSC              := "{ee32e446-31ca-4aba-814f-a5ebd2fd6d5e}"  
   ; FOLDERID_SearchHistory           := "{0D4C3DB6-03A3-462F-A0E6-08924C41B5D4}" ; Windows  8.1
   ; FOLDERID_SearchHome              := "{190337d1-b8ca-4121-a639-6d472d16972a}"  
   ; FOLDERID_SEARCH_MAPI             := "{98ec0e18-2098-4d44-8644-66979315a281}"  
   ; FOLDERID_SearchTemplates         := "{7E636BFE-DFA9-4D5E-B456-D7B39851D8A9}" ; Windows  8.1
   ; FOLDERID_SendTo                  := "{8983036C-27C0-404B-8F08-102D10DCFD74}"  
   ; FOLDERID_SidebarDefaultParts     := "{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}"  
   ; FOLDERID_SidebarParts            := "{A75D362E-50FC-4fb7-AC2C-A8BEAA314493}"  
   ; FOLDERID_SkyDrive                := "{A52BBA46-E9E1-435f-B3D9-28DAA648C0F6}" ; Windows  8.1
   ; FOLDERID_SkyDriveCameraRoll      := "{767E6811-49CB-4273-87C2-20F355E1085B}" ; Windows  8.1
   ; FOLDERID_SkyDriveDocuments       := "{24D89E24-2F19-4534-9DDE-6A6671FBB8FE}" ; Windows  8.1
   ; FOLDERID_SkyDrivePictures        := "{339719B5-8C47-4894-94C2-D8F77ADD44A6}" ; Windows  8.1
   ; FOLDERID_StartMenu               := "{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}"  
   ; FOLDERID_Startup                 := "{B97D20BB-F46A-4C97-BA10-5E3608430854}"  
   ; FOLDERID_SyncManagerFolder       := "{43668BF8-C14E-49B2-97C9-747784D784B7}" ; Windows  Vista
   ; FOLDERID_SyncResultsFolder       := "{289a9a43-be44-4057-a41b-587a76d7e7f9}" ; Windows  Vista
   ; FOLDERID_SyncSetupFolder         := "{0F214138-B1D3-4a90-BBA9-27CBC0C5389A}" ; Windows  Vista
   ; FOLDERID_System                  := "{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}"  
   ; FOLDERID_SystemX86               := "{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}"  
   ; FOLDERID_Templates               := "{A63293E8-664E-48DB-A079-DF759E0509F7}"  
   ; FOLDERID_TreeProperties          := "{9E3995AB-1F9C-4F13-B827-48B24B6C7174}" ; Windows  7
   ; FOLDERID_UserProfiles            := "{0762D272-C50A-4BB0-A382-697DCD729B80}"  
   ; FOLDERID_UserProgramFiles        := "{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}" ; Windows  7
   ; FOLDERID_UserProgramFilesCommon  := "{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}" ; Windows  7
   ; FOLDERID_UsersFiles              := "{f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}"  
   ; FOLDERID_UsersLibraries          := "{A302545D-DEFF-464b-ABE8-61C8648D939B}" ; Windows  7
   ; FOLDERID_Videos                  := "{18989B1D-99B5-455B-841C-AB7C74E4DDFC}"  
   ; FOLDERID_VideosLibrary           := "{491E922F-5643-4AF4-A7EB-4E7A138D8174}" ; Windows  7
   ; FOLDERID_Windows                 := "{F38BF404-1D43-42F2-9305-67DE0B28FC23}"  
   ; function by Skan: https://www.autohotkey.com/boards/viewtopic.php?f=6&t=75602&sid=f29192e2e8a74e847f62a152afa55aa1
   Local CLSID, pPath:=""                                        ; Thanks teadrinker @ tiny.cc/p286094
   Return Format("{4:}", VarSetCapacity(CLSID, 16, 0)
        , DllCall("ole32\CLSIDFromString", "Str",FOLDERID, "Ptr",&CLSID)
        , DllCall("shell32\SHGetKnownFolderPath", "Ptr",&CLSID, "UInt",KF_FLAG, "Ptr",0, "PtrP",pPath)
        , StrGet(pPath, "utf-16")
        , DllCall("ole32\CoTaskMemFree", "Ptr",pPath))

}

processFlags(n, b:=32, d:="`n", f:="") {
; by SKAN @ tiny.cc/t-75877
; https://www.autohotkey.com/boards/viewtopic.php?f=6&t=75877

   Loop %b%
   {
       f .= Format( n & 1 ? "0x{1:x}{2:}"  : ""
                  , n & 1 ? 2**(A_Index-1) : 0, d, n >>= 1)
   }
   Return RTrim(f, d) 
}

testArkive() {
 
lola := Gdip_GetImageFlags(gdiBitmap)
MsgBox, % lola "`n" processFlags(lola, 128)

    ;     loop, files, E:\Sucan twins\_small-apps\AutoHotkey\other scripts\flipeador-Library-AutoHotkey-master\Library-AutoHotkey-master\graphics\Gdiplus\*, R
;     {
;           If (A_LoopFileExt="ahk")
;           {
;              FileRead, filecontent, % A_LoopFileLongPath
;              concat .= filecontent "`n`n"
;           }
; }
;           FileAppend, % concat, % mainCompiledPath "\mergedFiles.ahk"
;     SoundBeep 
}



Class IDesktopWallpaper 
{
; class created by Flipeador
; source https://github.com/flipeador/Library-AutoHotkey/blob/master/device/IDesktopWallpaper.ahk

    ; ===================================================================================================================
    ; CONSTRUCTOR
    ; ===================================================================================================================
    __New() {
        this.IDesktopWallpaper := ComObjCreate("{C2CF3110-460E-4fc1-B9D0-8A1C0C9CC4BD}", "{B92B56A9-8B55-4E14-9A89-0199BBB6F93B}")

        For Each, Method in ["SetWallpaper","GetWallpaper","GetMonitorDevicePathAt","GetMonitorDevicePathCount","GetMonitorRECT","SetBackgroundColor","GetBackgroundColor","SetPosition","GetPosition","SetSlideshow", "GetSlideshow","SetSlideshowOptions","GetSlideshowOptions","AdvanceSlideshow","GetStatus","Enable"]
            ObjRawSet(this, "p" . Method, NumGet(NumGet(this.IDesktopWallpaper), (2 + A_Index) * A_PtrSize))
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775771(v=vs.85).aspx

    ; ===================================================================================================================
    ; DESTRUCTOR
    ; ===================================================================================================================
    __Delete() {
        Return ObjRelease(this.IDesktopWallpaper)
    }

    ; ===================================================================================================================
    ; PRIVATE METHODS
    ; ===================================================================================================================
    _R(R, pBuffer, ByRef Var := "", Error := "") {
        If (R == 0)
        {
            If (IsByRef(Var))
                Var := StrGet(pBuffer, "UTF-16")
            DllCall("Kernel32.dll\GlobalFree", "UPtr", pBuffer, "UPtr")
        }
        Else If (IsByRef(Var))
            Var := Error
        Return R
    }

    ; ===================================================================================================================
    ; PUBLIC METHODS
    ; ===================================================================================================================
    /*
        Establece el fondo de escritorio.
        Parámetros:
            MonitorID: El identificador del monitor. Este valor se puede obtener a través de GetMonitorDevicePathAt. Establezca este valor en NULL para establecer la imagen en todos los monitores.
            Wallpaper: La ruta completa del archivo de imagen de fondo de pantalla.
    */
    SetWallpaper(MonitorID, Wallpaper) {
        Return DllCall(this.pSetWallpaper, "UPtr", this.IDesktopWallpaper, "Ptr", MonitorID, "UPtr", &Wallpaper, "UInt")
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706962(v=vs.85).aspx

    /*
        Recupera el identificador de uno de los monitores del sistema.
        Parámetros:
            MonitorIndex: El número del monitor. LLame a GetMonitorDevicePathCount para determinar el número total de monitores.
            MonitorID   : Recibe el identificador del monitor.
    */
    GetMonitorDevicePathAt(MonitorIndex, ByRef MonitorID) {
        Return this._R(DllCall(this.pGetMonitorDevicePathAt, "UPtr", this.IDesktopWallpaper, "UInt", MonitorIndex, "UPtrP", pBuffer, "UInt"), pBuffer, MonitorID)
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706950(v=vs.85).aspx

    /*
        Recupera la cantidad de monitores que están asociados con el sistema.
        Parámetros:
            Count: Recibe la cantidad de monitores.
    */
    GetMonitorDevicePathCount(ByRef Count) {
        Return DllCall(this.pGetMonitorDevicePathCount, "UPtr", this.IDesktopWallpaper, "UIntP", Count, "UInt")
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706951(v=vs.85).aspx

} ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706946(v=vs.85).aspx




testeGDIspeed() {
   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(2)
   pa := A_TickCount - startZeit

   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(10)

   pb := A_TickCount - startZeit
   MsgBox, % pa "`n" pb
}

isFileLocked(imgPath) {
   If !FileRexists(imgPath)
      Return -1

   myFile := fileOpen(imgPath, "a")
   If IsObject(myFile)
   {
      myFile.Close()
      Return 0
   } Else Return 1
}

trGdip_CreateBitmap(funcu, Width, Height, PixelFormat:=0, Stride:=0, Scan0:=0) {
    PixelFormat := (PixelFormat="0xE200B") ? coreDesiredPixFmt : PixelFormat
    r := Gdip_CreateBitmap(Width, Height, PixelFormat, Stride, Scan0)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() called by " funcu "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0))

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Else
       addJournalEntry(A_ThisFunc "() called by " funcu "() using w" Width " - h" Height " - pixFmt" PixelFormat " failed: " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateBitmapFromFile(sFile, useICM:=0) {
    r := Gdip_CreateBitmapFromFileSimplified(sFile, useICM)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() error: " Gdip_ErrorHandler(gdipLastError, 0) "`nFile to load:" sFile)

    Return r
}

trGdip_CreateBitmapFromHBITMAP(hBitmap, hPalette:=0) {
    r := Gdip_CreateBitmapFromHBITMAP(hBitmap, hPalette)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0))

    ; If (r && coreDesiredPixFmt="0xE200B")
    ; {
    ;    z := Gdip_CloneBmpPargbArea(A_ThisFunc, r)
    ;    If z
    ;    {
    ;       ; SoundBeep 
    ;       trGdip_DisposeImage(r, 1)
    ;       r := z
    ;    }
    ; }
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, hBitmap = " hBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateHBITMAPFromBitmap(funcu, pBitmap, bgr:=0) {
    r := Gdip_CreateHBITMAPFromBitmap(pBitmap, bgr)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If !r
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateARGBBitmapFromHBITMAP(hBitmap) {
    r := Gdip_CreateARGBBitmapFromHBITMAP(hBitmap)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed to create pBitmap from hBitmap = " hBitmap)

    Return r
}

trGdip_BitmapConvertGray(pBitmap, hue:=0, vibrance:=-40, brightness:=1, contrast:=0, KeepPixelFormat:=0) {
    r := Gdip_BitmapConvertGray(pBitmap, hue, vibrance, brightness, contrast, KeepPixelFormat)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "(): failed, pBitmap = " pBitmap)
    Return r
}

trGdip_CloneBitmapArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:="0xE200B", KeepPixelFormat:=0) {
    r := Gdip_CloneBitmapArea(pBitmap, x, y, w, h, PixelFormat, KeepPixelFormat)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CloneBitmap(funcu, pBitmap) {
    r := Gdip_CloneBitmap(pBitmap)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_BlurBitmap(pBitmap, BlurAmount, usePARGB:=0, quality:=7) {
    If !pBitmap
       addJournalEntry("WARNING: no bitmap given to blur")

    r := Gdip_BlurBitmap(pBitmap, BlurAmount, usePARGB, quality)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, pBitmap = " pBitmap)
    Return r
}

trGdip_RenderPixelsOpaque(pBitmap, pBrush:=0, alphaLevel:=0) {
    r := Gdip_RenderPixelsOpaque(pBitmap, pBrush, alphaLevel, coreDesiredPixFmt)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, pBitmap = " pBitmap)
    Return r
}

trGdip_RetrieveBitmapChannel(pBitmap, channel) {
    r := Gdip_RetrieveBitmapChannel(pBitmap, channel, coreDesiredPixFmt)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Return r
}

trGdip_ResizeBitmap(funcu, pBitmap, givenW, givenH, KeepRatio, InterpolationMode:="", KeepPixelFormat:=0, checkTooLarge:=0) {
    thisPixFmt := (KeepPixelFormat=-1) ? coreDesiredPixFmt : KeepPixelFormat
    r := Gdip_ResizeBitmap(pBitmap, givenW, givenH, KeepRatio, InterpolationMode, thisPixFmt, checkTooLarge)
    If StrLen(r)<3
    {
       baseMsg := "Unable to resize internal bitmap to given size: W" givenW " - H" givenH " for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error. "
       generalInternalErrorMsgBox(gdipLastError, baseMsg)
       Return
    } Else createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Return r
}

trGdip_RotateBitmapAtCenter(funcu, pBitmap, Angle, pBrush:=0, InterpolationMode:=7, PixelFormat:=0) {
    If !Angle
    {
       newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc "() initially invoked by " funcu "()", pBitmap)
       Return newBitmap
    }

    thisPixFmt := (PixelFormat=-1) ? coreDesiredPixFmt : PixelFormat
    r := Gdip_RotateBitmapAtCenter(pBitmap, Angle, pBrush, InterpolationMode, thisPixFmt)
    If StrLen(r)<3
    {
       baseMsg := "Unable to rotate internal bitmap to given angle: " angle "° for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error."
       generalInternalErrorMsgBox(gdipLastError, baseMsg)
       Return
    } Else createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Return r
}

trGdip_DisposeImage(pBitmap, noErr:=1) {
    ; If (createdGDIobjsArray["x" pBitmap, 3]=1 && createdGDIobjsArray["x" pBitmap, 2]="bmp")
       r := Gdip_DisposeImage(pBitmap, 1)

    If pBitmap
       createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 0, 0]
    Return r
}

gdipObjectsStats(killAll:=0, filteru:=0) {
   For Key, Value in createdGDIobjsArray
   {
      If (value[2]="bmp")
      {
         totalBMPs++
         If (value[3]=1)
         {
            If (killAll=1)
            {
               If (!InStr(value[4], filteru) && filteru)
                  Continue

               If !filteru
                  fnOutputDebug("Possible memory leak: " value[4])
               trGdip_DisposeImage(value[1], 1)
            }
            UnremovedBMPs++
         }
      }
   }

   If (killAll=1 && !filteru)
   {
      imgThumbsCacheArray := []
      imgThumbsCacheIDsArray := []
      imgsListArrayThumbs := []
   }

   If (killAll!=1)
      msgbox, % totalBMPs " // " UnremovedBMPs
}

testMemCrash() {
   Global sillyArray := []
   imgPath := "E:\Sucan twins\photos test\SLDs\really-all-images-cached-mega-test.sld"
   SoundBeep 
   FileRead, OutputVar, % imgPath
   Loop, Parse, OutputVar, `n,`r
   {
      If A_LoopField
      {
         loopsOccured++
         ; If (loopsOccured<510100)
            sillyArray[A_Index] := [A_LoopField, "z" A_LoopField] ; "|=|" A_LoopField "||" SubStr(A_LoopField, 4) A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4)
         ; Else If (loopsOccured<990100)
         ;    sillyArrayC[A_Index] := A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4) A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4)
         ; Else
         ;    sillyArrayB[A_Index] := A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4) A_LoopField "==" SubStr(A_LoopField, 4) "|=|" A_LoopField "||" SubStr(A_LoopField, 4)
         ; sillyArray[A_loopField] := A_LoopField "-" SubStr(A_LoopField, 4) "=====" A_LoopField "|||" SubStr(A_LoopField, 4)
         ; sillyArray[A_Index] := A_LoopField "-" SubStr(A_LoopField, 2) "==" A_LoopField "|" SubStr(A_LoopField, 2)
      }
   }
   ToolTip, % loopsOccured , , , 2
   SoundBeep 
}
