; Script details:
;   Name:     Quick Picto Viewer
;   Platform: Windows 7 or later, preferred is Windows 10.
;   Author:   Marius Șucan - https://marius.sucan.ro/
;   GitHub:   https://github.com/marius-sucan/Quick-Picto-Viewer
;   Requires: AHK-H v1.1.33.01+.
;   Code overview: https://raw.githubusercontent.com/marius-sucan/Quick-Picto-Viewer/master/general-code-overview.txt
;
; Quick Picto Viewer can run on Windows 7 and even on XP, but various features
; might not work. To this end, you may have to copy all the DLL files found
; in the .\optional-DLL-files-x64\ folder to the same folder where the QPV
; binary is. If you are running it uncompiled, you must place them in the
; folder where the AutoHotkey binary resides. The required DLLs for x64
; are bundled since version 5.7.5 in the ZIP package and can also be found
; in the Github repository.
;
; The following DLLs are already located in the main Quick Picto Viewer folder:
; FreeImage.dll
; msvcr100.dll
; sqlite3.dll
; ucrtbase.dll
; vcomp140.dll
; vcruntime140.dll
;
; QPV main functionalities:
; Display images, edit images, organize and create slideshows using GDI+ 
; and the FreeImage library.
; 85 supported image formats: jpeg, jpg, bmp, png, gif, tif,
; hdr, exr, webp, raw and many more...
;
; Original Licence: GPL. Please reffer to this page for more information. http://www.gnu.org/licenses/gpl.html
; Current licence: I do not know, I do not care. Licences are for obedient entities.
;
;@Ahk2Exe-AddResource Lib\module-interface.ahk
;@Ahk2Exe-AddResource Lib\module-fim-thumbs.ahk
;@Ahk2Exe-SetName Quick Picto Viewer
;@Ahk2Exe-SetProductName Quick Picto Viewer
;@Ahk2Exe-SetDescription Quick Picto Viewer
;@Ahk2Exe-UpdateManifest 0, Quick Picto Viewer
;@Ahk2Exe-SetOrigFilename Quick-Picto-Viewer.exe
;@Ahk2Exe-SetVersion 6.0.00
;@Ahk2Exe-SetProductVersion 6.0.00
;@Ahk2Exe-SetCopyright Marius Şucan (2019-2024)
;@Ahk2Exe-SetCompanyName https://marius.sucan.ro
;@Ahk2Exe-SetMainIcon qpv-icon.ico
;___________ Auto Execute Section ____

#Requires AutoHotkey v1.1.33.01+
#NoEnv
#NoTrayIcon
#MaxHotkeysPerInterval, 950
#HotkeyInterval, 50
#MaxThreads, 255
#MaxThreadsPerHotkey, 1
#MaxThreadsBuffer, Off
#MaxMem, 9924
#IfTimeout, 35
#SingleInstance, off
#UseHook, Off
DetectHiddenWindows, On
CoordMode, Mouse, Screen
CoordMode, ToolTip, Screen
CoordMode, Menu, Screen
SetWorkingDir, %A_ScriptDir%
#Include %A_ScriptDir%\Lib\Gdip_All.ahk           ; graphics display interface plus v1.1, extended compilation editon
#Include %A_ScriptDir%\Lib\Gdi.ahk                ; graphics display interface written by Marius Șucan
#Include %A_ScriptDir%\Lib\SGdiPrint.ahk
#Include %A_ScriptDir%\Lib\freeimage-wrapper.ahk  ; used to load exotic file formats, written by Marius Șucan
#Include %A_ScriptDir%\Lib\MCI.ahk                ; media controller interface [ used for audio annotations/files associated with images ], by Fincs
#Include %A_ScriptDir%\Lib\wia.ahk                ; windows image acquisition ; used for acquiring images from scanners 
#Include %A_ScriptDir%\Lib\Font_library3.ahk      ; Fnt_library 3.0 by jballi; used for message boxes, to size them
#Include %A_ScriptDir%\Lib\Class_SQLiteDB.ahk     ; used for slideshow databases and maintaining a list of viewed images [if activated], by just-me
#Include %A_ScriptDir%\Lib\Class_CtlColors.ahk    ; used for dark mode, by just-me
#Include %A_ScriptDir%\Lib\Class_ImageButton.ahk  ; used for dark mode and custom buttons, by just-me, v1.7
#Include %A_ScriptDir%\Lib\msgbox2.ahk
#Include %A_ScriptDir%\Lib\tvh.ahk                ; Functions for TreeView controls, by just-me
#Include %A_ScriptDir%\Lib\LV_EX.ahk              ; Functions for list views, by just-me
#Include %A_ScriptDir%\Lib\shell-stuff.ahk
#Include %A_ScriptDir%\Lib\iDesktopWallpaper.ahk  ; functions to set the windows wallpaper on windows 8 and above
#Include %A_ScriptDir%\Lib\hashtable.ahk          ; super-fast and capable arrays, by Helgef
#Include %A_ScriptDir%\Lib\cli-interface.ahk      ; command line interface
#Include %A_ScriptDir%\Lib\file-get-prop-lib.ahk  ; used to get file properties on Alt+Enter [ File Information panel ]
#Include %A_ScriptDir%\Lib\Class_screenQPVimage.ahk
; #Include %A_ScriptDir%\Lib\json.ahk

SetWinDelay, 1
SetBatchLines, -1

Global PVhwnd := 1, hGDIwin := 1, hGDIthumbsWin := 1, pPen4 := "", pPen5 := "", pPen6 := "", unCompiledExePath := "", pBrushZ := ""
   , glPG := "", glOBM := "", glHbitmap := "", glHDC := "", pPen1 := "", pPen1d, pPen2 := "", pPen3 := "", pPen8 := ""
   , pBrushHatch := "", pBrushWinBGR := "", pBrushA := "", pBrushB := "", pBrushC := "", pBrushD := "", currentPixFmt := ""
   , pBrushE := "", pBrushHatchLow, hGuiTip := 1, hSetWinGui := 1, undoSelLevelsArray := [], QPVerrJournal := []
   , prevFullThumbsUpdate := 1, winGDIcreated := 0, ThumbsWinGDIcreated := 0, currentFilesListModified := 0
   , hPicOnGui1 := "", scriptStartTime := A_TickCount, lastEditRHChange :=1, doubleBlurPreviewArea := 0
   , newStaticFoldersListCache := [], lastEditRWChange := 1, QPVjournal := [], pPen7 := "", hQPVtoolbar
   , mainCompiledPath := "", wasInitFIMlib := 0, hGDIselectWin, allowNextSlide := 1, LVitemsPerPage := 5100
   , filteredMap2mainList := [], thumbsCacheFolder := A_ScriptDir "\thumbs-cache", hSNDsong, lastZeitOpenWin := 1
   , resultedFilesList := [], currentFileIndex := "", maxFilesIndex := 0, gdiBitmapIDentire := 0
   , appTitle := "Quick Picto Viewer", FirstRun := 1, hSNDmediaFile := "", mouseToolTipWinCreated := 0
   , bckpResultedFilesList := [], bckpMaxFilesIndex := 0, DynamicFoldersList := "", lastPointerUseZeit := 1
   , animGIFplaying := 0, startPageIndex := 0, RandyIMGids := [], IMGdecalageY := 1, IMGdecalageX := 1
   , RandyIMGnow := 0, GDIPToken := "", gdiBitmapSmall := "", hSNDmedia := "", imgIndexEditing := 0
   , AprevGdiBitmap := "", BprevGdiBitmap := "", msgDisplayTime := 3000, gdiBitmapIDcall := ""
   , slideShowRunning := 0, CurrentSLD := "", markedSelectFile := 0, IMGlargerViewPort := 0, thisPanelTab := 1
   , ResolutionWidth := "", ResolutionHeight := "", prevStartIndex := 1, mustReloadThumbsList := 0
   , gdiBitmap := "", mainSettingsFile := "quick-picto-viewer.ini", mainRecentsFile := "quick-picto-viewer-recents.ini"
   , mustOpenStartFolder := "", mainFavesFile := "quick-picto-viewer-favourites.ini", miniFavesFile := "quick-picto-viewer-minifaves.ini"
   , RegExAllFilesPattern := "ico|dib|dng|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif|webp"
   , RegExFilesPattern := "i)^(.\:\\).*(\.(" RegExAllFilesPattern "))$", folderFavesFile := "quick-picto-viewer-folder-faves.ini"
   , RegExFIMformPtrn := "i)(.\\*\.(DNG|DDS|EXR|HDR|JBG|JNG|JP2|JXR|JIF|TIFF|TIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f))$"
   , RegExWICfmtPtrn := "i)(.\\*\.(place-holder|webp|bmp|tiff|tif|png|jpg|jpeg))$", customKbdFile := "quick-picto-viewer-custom-kbd.ini"
   , saveTypesRegEX := "i)(.\.(bmp|j2k|j2c|jp2|jxr|wdp|hdp|png|tga|tif|tiff|webp|gif|ico|jng|jif|jpg|jpe|jpeg|ppm|xpm))$"
   , saveTypesFriendly := ".BMP, .GIF, .HDP, .J2K, .JNG, .JP2, .JPG, .JXR, .PNG, .PPM, .TGA, .TIF, .WDP, .WEBP, .ICO or .XPM"
   , saveAlphaTypesRegEX := "i)(.\.(j2k|j2c|jp2|jxr|wdp|hdp|ico|png|tga|tif|tiff|webp))$", userJpegQuality := 90
   , openFptrn1 := "*.png;*.bmp;*.gif;*.jpg;*.tif;*.tga;*.webp;*.jpeg", prevLoadedImageIndex := 0, mainExecPath
   , openFptrn2 := "*.dds;*.emf;*.exr;*.g3;*.hdp;*.j2c;*.j2k;*.jbg;*.jif;*.jng;*.jp2;*.jxr;*.koa;*.lbm;*.mng;*.pbm;*.pcd;*.pct;*.pcx;*.pfm;*.pgm;*.pic;*.ppm;*.psd;*.ras;*.sgi;*.wap;*.wbm;*.wbmp;*.wdp;*.wmf;*.xbm;*.xpm"
   , openFptrn3 := "*.3fr;*.arw;*.bay;*.bmq;*.cap;*.cine;*.cr2;*.crw;*.cs1;*.dc2;*.dcr;*.drf;*.dsc;*.erf;*.fff;*.hdr;*.ia;*.iiq;*.k25;*.kc2;*.kdc;*.mdc;*.mef;*.mos;*.mrw;*.nef;*.nrw;*.orf;*.pef;*.ptx;*.pxn;*.qtk;*.raf;*.raw;*.rdc;*.rw2;*.rwz;*.sr2;*.srf;*.x3f"
   , openFptrn4 := "*.tiff;*.targa;*.jpe;*.dib;*.pict;*.rle", openFptrnWIC := "", forceLiveAlphaPreviewMode := 0
   , dialogSaveFptrn := "HD Photo (*.hdp;*.jxr)|Network Graphics JPEG (*.jng)|JPEG Common (*.jpg;*.jpeg)|JPEG 2000 (*.jp2)|JPEG 2000 codestream (*.j2k)|JPEG-XR (*.jxr)|Non-animated Compuserve GIF (*.gif)|Portable Network Graphics (*.png)|Portable PixelMap (*.ppm)|Tagged Image File Format (*.tif;*.tiff)|TrueVision Targa (*.tga)|Windows Photo (*.wdp;*.jxr)|Google WebP (*.webp)|Windows Bitmap (*.bmp)|X-PixMap (*.xpm)|Icon (*.ico)"
   , dialogSaveIndexes := {1:"hdp", 2:"jng", 3:"jpg", 4:"jp2", 5:"j2k", 6:"jxr", 7:"gif", 8:"png", 9:"ppm", 10:"tif", 11:"tga", 12:"wdp", 13:"webp", 14:"bmp", 15:"xpm", 16:"ico"}
   , userPossibleWriteFMTs := ".BMP|.GIF|.HDP|.J2K|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM"
   , saveimgformatslist := {1:"bmp", 2:"gif", 3:"hdp", 4:"j2k", 5:"jng", 6:"jp2", 7:"jpg", 8:"jxr", 9:"png", 10:"ppm", 11:"tga", 12:"tif", 13:"wdp", 14:"webp", 15:"xpm"}
   , LargeUIfontValue := 14, AnyWindowOpen := 0, toolTipGuiCreated := 0, panelWinCollapsed :=0, brushAclrAlpha := "ffFFff"
   , PrefsLargeFonts := 0, OSDbgrColor := "252525", OSDtextColor := "FEFDFC", initialCustomShapeCoords := ""
   , PasteFntSize := 35, OSDfontSize := 23, OSDFontName := "Arial", prevOpenFolderPath := "", brushBclrAlpha := "010101"
   , mustGenerateStaticFolders := 1, lastWinDrag := 1, img2resizePath := "", colorPickerModeNow := 0
   , prevFileMovePath := "", lastGIFdestroy := 1, prevAnimGIFwas := "", prevFilesSortMode, bruAchClrAlpha := ""
   , thumbsW := 300, thumbsH := 300, thumbsDisplaying := 0, userSeenSessionImagesArray := new hashtable()
   , othumbsW := 300, othumbsH := 300, VPselRotation := 0, hEditMenuSearch := "", prevOmniBoxFolder := ""
   , CountFilesFolderzList := 0, imgSelLargerViewPort := 0, dynamicLiveObjVisible := 1, colorPickerMustEnd := 0
   , UsrMustInvertFilter := 0, userActionConflictingFile := 1, LastWasFastDisplay := 0, hEditA := 0
   , prevFileSavePath := "", imgHUDbaseUnit := Round(OSDfontSize*2.5), lastLongOperationAbort := 1
   , lastOtherWinClose := 1, UsrCopyMoveOperation := 2, editingSelectionNow := 0, EntryMarkedMoveIndex := 0
   , ForceNoColorMatrix := 0, prevFastDisplay := 1, hSNDmediaDuration, lastMenuBarUpdated := 1
   , imgSelX1 := 0, imgSelY1 := 0, imgSelX2 := -1, imgSelY2 := -1, adjustNowSel := 0, hasHamDistCached := 0
   , prevImgSelX1 := 0, prevImgSelY1 := 0, prevImgSelX2 := -1, prevImgSelY2 := -1, prevSelDotX := "", prevSelDotY := "", prevSelDotAx := "", prevSelDotAy := ""
   , selDotX := "", selDotY := "", selDotAx := "", selDotAy := "", selDotBx := "", selDotBy := "", selDotCx := "", selDotCy := "", selDotDx := "", selDotDy := ""
   , prcSelX1 := 0, prcSelX2 := 0.5, prcSelY1 := 0, prcSelY2 := 0.5, pBrushF := "", lastWasLowQuality := 0
   , SelDotsSize := imgHUDbaseUnit//4, ViewPortBMPcache := "", startZeitIMGload := 0, cachedAllSessionsSeen := new hashtable()
   , imageLoading := 0, PrevGuiSizeEvent := 0, imgSelOutViewPort := 0, prevLastImg := [], userUIshapeCavity := 0
   , imgEditPanelOpened := 0, jpegDesiredOperation := 1, copyMoveDoLastOption := 4, alphaMaskCoffsetY := 0
   , rDesireWriteFMT := "jpg", FIMfailed2init := 0, prevDestPosX := "", prevDestPosY := "", hGuiBtn
   , CCLVO := " gInvokeStandardDialogColorPicker -E0x200 +Border -Hdr -Multi +ReadOnly Report AltSubmit ", FontList := []
   , totalFramesIndex := 0, pVwinTitle := "", AprevImgCall := "", BprevImgCall := "", prevSetWinPosX := "", prevSetWinPosY := ""
   , coreIMGzeitLoad := 0, desiredFrameIndex := 0, prevDrawingMode := 0, sqlFailedInit := 0, currentImgModified := 0
   , currIMGdetails := [], AbackupIMGdetails := [], BbackupIMGdetails := [], mainLoadedIMGdetails := [], lastSelPrinterName := ""
   , diffIMGdecX := 0, diffIMGdecY := 0, oldZoomLevel := 0, fullPath2exe := "", hasMemThumbsCached := 0
   , scrollBarHy := 0, scrollBarVx := 0, HistogramBMP := "", internalColorDepth := 0, printerDevModeOptions := ""
   , drawModeBzeit := 1, drawModeAzeit := 1, drawModeCzeit := 1, prevColorAdjustZeit := 1, AutoCropBordersSize := 15
   , GDIfadeVPcache := "", executingCanceableOperation := 1, hCropCornersPic, UserMemBMP := "", userSearchString := ""
   , systemCores := 1, realSystemCores := 1, hasInitSpecialMode := 0, CountGIFframes := 0, prevSlideShowStop := 1
   , prevTryThumbsUpdate := 1, thumbsSizeQuality := 245, prevFullIndexThumbsUpdate := -1, userClipBMPpaste
   , UserNewWidth := 0, UserNewHeight := 0, UserNewDPI := 0, viewportStampBMP := "", tinyPrevAreaCoordY := 1
   , ThumbsStatusBarH := 0, activeSQLdb := "", SLDtypeLoaded := 0, sldsPattern := "i)(.\.(sld|sldb))$"
   , imgThumbsCacheIDsArray := [], imgThumbsCacheArray := [], viewportIDstampBMP := 0, qpvMainDll, sqlDBrowID := 1
   , prevVPselRotation, prevrotateSelBoundsKeepRatio, prevEllipseSelectMode, currentSelUndoLevel := 1, liveDrawingBrushTool := 0
   , seenImagesDB := "", mustRecordSeenImgs := 0, hEditField := "", gdiBMPvPsize := "", maxGDIbmpSize := 536847521
   , GDIcacheSRCfileA := "", idGDIcacheSRCfileA := "", GDIcacheSRCfileB := "", idGDIcacheSRCfileB := "", prevOpenedWindow := []
   , startLongOperation := 1, simpleOpRotationAngle := 1, UserTextArea := "", hKbdGuia, GDIPbrushHatch := ""
   , runningLongOperation := 0, hasReachedMaxUndoLevels := 0, GIFframesPlayied := 0, allImagesWereSeen := 0
   , 2NDglHbitmap := "", 2NDglHDC := "", 2NDglOBM := "", 2NDglPG := "", mainThreadHwnd := "", imgDecLX := "", imgDecLY := ""
   , undoLevelsArray := [], currentUndoLevel := 0, maxUndoLevels := 50, undoLevelsRecorded := 0, hGDIinfosWin := ""
   , zeitSillyPrevent := 1, PrintPosX, PrintPosY, PrintPosW, PrintPosH, tinyPrevAreaCoordX := 1, UsrEditFileDestination := ""
   , hLVmainu := 0, tempBtnVisible := "null", tempBtnGuiBtnArray := [], userMultiCoresLimit := 100
   , drawingShapeNow := 0, customShapePoints := [], prevResizedVPimgW := "", prevResizedVPimgH := "", PenuDrawLive := ""
   , customShapePropPoints := [], drawingVectorLiveMode := 0, cardinalCurveCustomShape := 0, openingPanelNow := 0
   , closedLineCustomShape := 1, tensionCurveCustomShape := 0.5, userDefinedSelCoords := 0, thisSearchString := ""
   , SelectionCoordsType := 1, alphaMaskRefBMP := 1, infoBoxGdiCached := "", watchFolderDetails := "", isNowFakeWinOpen := 0
   , FilteruMinRange, FilteruMaxRange, userFilterSizeProperty := 1, qpvCanvasHasInit := 0, coreDesiredPixFmt := "0xE200B"
   , FilteruDateMinRange, FilteruDateMaxRange, InternalFilterString, userFilterProperty := 1, userFindDupePresets := 1
   , HUDobjNavBoxu := [], HUDobjHistoBoxu := [], globalhFIFimg := 0, userAddedFavesCount := 0, bckpCurrentFileIndex := 0
   , maxFavesEntries := 987654, gdipLastError := 0, hasDrawnImageMap := 0, hasDrawnHistoMap := 0, lastZeitFileSelect := 1
   , isWinXP := (A_OSVersion="WIN_XP" || A_OSVersion="WIN_2003" || A_OSVersion="WIN_2000") ? 1 : 0
   , QPVpid := GetCurrentProcessId(), preventUndoLevels := 0, maxMemUndoLevels := 979394, delayiedHUDmsg := "", hamLowLim := 0, hamUppLim := 0
   , delayiedHUDperc := 0, delayedfunc2exec := 0, lastOSDtooltipInvoked := 1, lastTimeToggleThumbs := 1, dupesStringFilter := ""
   , CurrentPanelTab := 0, debugModa := !A_IsCompiled, createdGDIobjsArray := [], countGDIobjects := 0
   , oldCustomShapePoints := [], TVlistFolders, hfdTreeWinGui, folderTreeWinOpen := 0, VPstampBMPx := 0, VPstampBMPy := 0
   , reviewSelectedIndexes := [], toBeExcludedIndexes := [], fimMultiPage := 0, fimMultiBMP := 0, staticListViewFilteru
   , listViewReviewFilteru := "", IMGentirelylargerThanVP := 0, mustPreventMenus := 0, hQuickMenuSearchWin := 0
   , VisibleQuickMenuSearchWin := 0, userQuickMenusEdit := "", preventHUDelements := 0, OSDwinFadedBrushBGR := 0
   , gdiAmbientalTexBrush := "", GDIbrushWinBGR := "", GDIbrushHatch := "", vpImgPanningNow := 0, viewportDynamicOBJcoords := []
   , mustCaptureCloneBrush := 0, hCropCornersPic2, globalWinStates := [], userAlphaMaskBmpPainted := "", lastPaintEventID := 1
   , prevImgEditZeit := 1, hudBTNfuncu, hudBTNtypeFuncu, hudBTNheightFuncu, hudBTNwidthFuncu, TouchToolbarGUIcreated := 0
   , tlbrIconzList := [], ToolBarBtnWidth := 45, UserToolbarY := 60, UserToolbarX := 200, prevFolderSortMode := 0
   , ToolbarWinW := 0, ToolbarWinH := 0, isToolbarKBDnav := 0, lastZeitIMGsaved := [], lastZeitUndoRecorded := 0
   , CustomShapeSymmetry := 0, CustomShapeLockedSymmetry := 0, viewportQPVimage := new screenQPVimage
   , vpSymmetryPointXdp := 0, vpSymmetryPointYdp := 0, userSeenSessionImagesIndex := 0, FloodFillSelectionAdj := 0
   , createdQuickMenuSearchWin := 0, lastUserRclickVPx := 0, lastUserRclickVPy := 0, vpFreeformShapeOffset := []
   , customShapeHasSelectedPoints := 0, currentVectorUndoLevel := 1, undoVectorShapesLevelsArray := []
   , hGradientAlphaMSKpreview, hGradientFillpreview, userMonitorImgPos, uiSlidersArray := [], navKeysCounter := 0
   , mseUppLim := 0, mseLowLim := 0, userHamDistStringStringPos := 1, userHamDistStringFilterWhat := 1
   , thisBMPdummy := 0, dummyGu := 9, whileLoopExec := 0, WICmoduleHasInit := 0, dupesDCTcoeffsInit := 0
   , resultsDupesArray := [], hTVlistFolders := "", SearchedStringz := "", dupesPixelData := []
   , dupesHashesData := [], dbVersion := 0, dbExpectedVersion := 2, userPrevAlphaMaskBmpPainted := ""
   , clrGradientOffX := 0, clrGradientOffY := 0, userAllowClrGradientRecenter := 0, TabsPerWindow := []
   , darkWindowColor := 0x202020, darkControlColor := 0xEDedED, allowWICloader := 1, allowFIMloader := 1
   , monitorBgrColor := darkWindowColor, lastSlidersPainted := [], userCustomKeysDefined := []
   , simulateMenusMode := 0, lastLVquickSearchSortCol := [], soloSliderWinVisible := 0, backupGdiBMP := 0
   , lastFastImgChangeHUDzeit := 1, forceProtectLoadedImg := 0, lastTippyWin := 0

Global previnnerSelectionCavityX := 0, previnnerSelectionCavityY := 0, prevNameSavedVectorShape := ""
   , postVectorWinOpen := 0, isWelcomeScreenu := 0, prevVectorShapeSymmetryMode := [], AllowDarkModeForWindow := ""
   , iduStaticFoldersListCache := 0, lastFilterEditSearch := "", additionalLVrows := 1, uLVr := 12, hSliderWidget
   , omniBoxMode := 0, hLVquickSearchMenus := "", hotkate, vk_hwnd, lastInfoBoxBMP := [], lastSymmetryCoords := []
   , userFriendlyPrevImgSelAction, keywordsListArray := new hashtable(), keywrdLVfilter, wasVPfxBefore := 0
   , lastLclickX, lastLclickY, lastTlbrClicked := 0, uiLVoffset := 0, repositionedWindow := 0, hCollapseWidget := 0
   , selDotMaX, selDotMaY, selDotMbX, selDotMbY, selDotMcX, selDotMcY, selDotMdX, selDotMdY, OnExtractConflictOverwrite := 4
   , lastInfoBoxZeitToggle := 1, prevHistoBoxString := "", menuHotkeys, whichMainDLL := "qpvmain.dll", lastMenuZeit := 1
   , userExtractFramesFmt := 3, maxMultiPagesAllowed := 2048, maxMemLimitMultiPage := 2198765648, alphaMaskCoffsetX := 0
   , userImgClrMtrxBrightness, userImgClrMtrxContrast, userImgClrMtrxSaturation, userImgVPthreshold, userImgVPgammaLevel
   , cmdExifTool := "", tabzDarkModus := 0, maxRecentOpenedFolders := 15, UIuserToneMapParamA := 74, UIuserToneMapParamB := 200
   , userImgChannelRlvl, userImgChannelGlvl, userImgChannelBlvl, userImgChannelAlvl, combosDarkModus := ""
   , sillySeparator :=  "▪", menuCustomNames := new hashtable(), clrGradientCoffX := 0, clrGradientCoffY := 0
   , userBlendModesList := "Darken*|Multiply*|Linear burn*|Color burn|Lighten*|Screen*|Linear dodge* [Add]|Hard light|Soft light|Overlay|Hard mix*|Linear light|Color dodge|Vivid light|Average*|Divide|Exclusion*|Difference*|Substract|Luminosity|Ghosting|Inverted difference*|Background clipper*"
   , hasDrawnAnnoBox := 0, fileActsHistoryArray := new hashtable(), oldSelectionArea := [], prevPasteInPlaceVPcoords := []
   , freeHandPoints := [], customShapeCountPoints := 0, brushZeitung := 0, prevAlphaMaskCoordsPreview := []
   , QPVregEntry := "HKEY_CURRENT_USER\SOFTWARE\Quick Picto Viewer", verType := ""
   , appVersion := "6.0.00", vReleaseDate := "2024/06/05" ; yyyy-mm-dd

 ; User settings
   , askDeleteFiles := 1, enableThumbsCaching := 1, OnConvertKeepOriginals := 1
   , thumbsAratio := 3, thumbsZoomLevel := 1, zatAdjust := 0, lummyAdjust := 0, doSlidesTransitions := 0
   , specialColorFXmode := 1, uiColorCurveFXmode := 2, uiColorCurveFXchannel := 4, FloodFillTolerance := 0
   , WindowBgrColor := "141414", slideShowDelay := 3000, userMultiDelChoice := 2, ambiTexBrushSize := 150
   , IMGresizingMode := 1, SlideHowMode := 1, TouchScreenMode := 1, screenSaverMode := 0, userSearchPos := 1
   , lumosAdjust := 1, GammosAdjust := 0, userimgQuality := 0, imgFxMode := 1, FlipImgH := 0, FlipImgV := 0
   , filesFilter := "", isAlwaysOnTop := 0, IntensityAlphaChannel := 1, zoomLevel := 1, SimpleOperationsScaleXImgFactor := "100 %"
   , skipDeadFiles := 0, userHQraw  := 0, isTitleBarVisible := 1, lumosGrayAdjust := 0, imageAligned := 5
   , MustLoadSLDprefs := 0, animGIFsSupport := 1, move2recycler := 1, deleteFileActAfter := 1
   , SLDcacheFilesList := 1, autoRemDeadEntry := 0, ResizeWithCrop := 1, ResizeMustPerform := 1
   , easySlideStoppage := 1, ResizeInPercentage := 0, autoPlaySlidesAudio := 0, ResizeApplyEffects := 1
   , ResizeKeepAratio := 1, ResizeQualityHigh := 1, ResizeRotationUser := 0, satAdjust := 1
   , ResizeDestFolder, ResizeUseDestDir := 0, chnRdecalage := 0.0, chnGdecalage := 0.0
   , chnBdecalage := 0.0, alwaysOpenwithFIM := 0, bwDithering := 0, showHistogram := 0,  FloodFillModus := 0
   , userUnsprtWriteFMT := 1, userDesireWriteFMT := 9, hueAdjust := 0, syncSlideShow2Audios := 0
   , DisplayTimeUser := 3, OSDfontBolded := 1, OSDfontItalica := 0, showInfoBoxHUD := 0, usrAutoCropDeviation := 0
   , usrTextureBGR := 0, realGammos := 1, imgThreshold := 0, relativeImgSelCoords := 1, hCurrTab := ""
   , vpIMGrotation := 0, usrTextAlign := "Left", autoPlaySNDs := 0, usrAutoCropDeviationSnap := 1
   , ResizeCropAfterRotation := 1, usrColorDepth := 1, ColorDepthDithering := 1, mediaSNDvolume := 80
   , borderAroundImage := 0, usrAutoCropColorTolerance := 5, userActionAdvImgProcConflictingFile := 4
   , SimpleOperationsDoCrop := 0, SimpleOperationsRotateAngle := 1, SimpleOperationsScaleYImgFactor := "100 %"
   , SimpleOperationsNoPromptOnSave := 0, SimpleOperationsFlipV := 0, SimpleOperationsFlipH := 0
   , usrAutoCropDeviationPixels := 0, multilineStatusBar := 0, AutoCropAdaptiveMode := 1, allowGIFsPlayEntirely := 0
   , allowMultiCoreMode := 0, minimizeMemUsage := 0, GIFspeedDelay := 35, userImgAdjustAltBright := 1
   , maxMemThumbsCache := 300, resetImageViewOnChange := 0, FillAreaRemBGR := 0, blurAreaPixelizeMethod := 1
   , EraseAreaFader := 0, EraseAreaOpacity := 190, blurAreaOpacity := 250, blurAreaAmount := 10
   , FillAreaOpacity := 250, FillAreaColor := OSDbgrColor, FillAreaShape := 1, FillAreaInverted := 0
   , PasteInPlaceAlignment := 3, PasteInPlaceOpacity := 255, PasteInPlaceAdaptMode := 1, PasteInPlaceQuality := 1
   , PasteInPlaceOrientation := 4, showImgAnnotations := 0, blurAreaSoftEdges := 1, BlurAreaInverted := 0
   , PasteInPlaceBlurAmount := 0, PasteInPlaceCropSel := 1, PasteInPlaceCropAngular := 0, globalMenuOptions := 0

Global PasteInPlaceGamma := 0, PasteInPlaceSaturation := 0, PasteInPlaceHue := 0, PasteInPlaceLight := 0
   , EllipseSelectMode := 0, thumbsListViewMode := 1, userimgGammaCorrect := 0, FillAreaGradientAngle := 0
   , adjustCanvasCentered := 1, adjustCanvasMode := 1, adjustCanvasDoBgr := 1, LimitSelectBoundsImg := 1, FillAreaDoContour := 0
   , DrawLineAreaColor := "ff3366", DrawLineAreaDashStyle := 1, DrawLineAreaContourAlign := 1, DrawLineAreaKeepBounds := 1
   , DrawLineAreaContourThickness := 20, DrawLineAreaOpacity := 255, DrawLineAreaBorderTop := 1, DrawLineAreaBorderBottom := 0
   , DrawLineAreaBorderLeft := 1, DrawLineAreaBorderRight := 0, DrawLineAreaBorderCenter := 1, DrawLineAreaBorderArcA := 0
   , DrawLineAreaBorderArcC := 0, DrawLineAreaBorderArcD := 1, DrawLineAreaCapsStyle := 1, DrawLineAreaDoubles := 0
   , PasteInPlaceEraseInitial := 1, doImgEditLivePreview := 1, DrawLineAreaBorderArcB := 0, EraseAreaInvert := 0
   , PasteInPlaceToolMode := 0, NewDocUseColor := 1, PredefinedDocsSizes := 1, NewImageReverseDimensions := 0, FillAreaGlassy := 1
   , FillAreaColorMode := 1, FillAreaColorReversed := 0, FillArea2ndColor := "FF2211", FillArea2ndOpacity := 200
   , FillAreaGradientPosA := 5, FillAreaGradientPosB := 100, FillAreaGradientScale := 100, FillAreaGradientWrapped := 5
   , TextInAreaFontName := "Arial", TextInAreaFontSize := 15, TextInAreaBorderSize := 5, GammosGrayAdjust := 0
   , TextInAreaFontBold := 0, TextInAreaFontItalic := 0, TextInAreaFontUline := 0, TextInAreaAlign := 1, TextInAreaBgrUnified := 0
   , TextInAreaFontColor := "eeFFaa", TextInAreaFontOpacity := 250, TextInAreaRoundBoxBgr := 1, TextInAreaValign := 1
   , TextInAreaBgrColor := "229933", TextInAreaBgrOpacity := 100, TextInAreaOnlyBorder := 0, TextInAreaBlurAmount := 0
   , TextInAreaBorderOut := 1, TextInAreaBorderColor := "334400", TextInAreaBorderOpacity := 200, TextInAreaCharSpacing := 0
   , TextInAreaUsrMarginz := 0, TextInAreaBlurBorderAmount := 0, TextInAreaDoBlurs := 0
   , TextInAreaFontLineSpacing := 0, TextInAreaCutOutMode := 0, TextInAreaBgrEntire := 0, TextInAreaFontStrike := 0
   , showMainMenuBar := 1, markSearchMatches := 1, showSelectionGrid := 0, blurAreaTwice := 0, TextInAreaFlipV := 0
   , allowRecordHistory := 1, TextInAreaPaintBgr := 1, rotateSelBoundsKeepRatio := 1, TextInAreaFlipH := 0
   , highlightAlreadySeenImages := 1, useCachedSLDdata := 1, PreserveDateTimeOnSave := 0, PrintAdaptToFit := 1
   , PrintDimensionsXYWH := "0|0|50|50", PrintColorMode := 0, PrintImgAngleOrientation := 0, PrintUseViewportColors := 1
   , FillAreaClosedPath := 1, FillAreaCustomShape := "", alphaMaskingMode := 1, userImgAdjustInvertArea := 0
   , alphaMaskClrAintensity := 0, alphaMaskClrBintensity := 255, closeEditPanelOnApply := 1, FillAreaCurveTension := 2
   , alphaMaskOffsetX := 0, alphaMaskOffsetY := 0, alphaMaskReplaceMode := 0, alphaMaskBMPchannel := 5
   , blurAreaMode := 1, FillAreaBlendMode := 1, PasteInPlaceApplyColorFX := 0, blurAreaPixelizeAmount := 0
   , dynamicThumbsColumns := 0, thumbsColumns := 8, TextInAreaAutoWrap := 1, histogramMode := 2, cmrRAWtoneMapParamB := 0
   , showHUDnavIMG := 0, HUDnavBoxSize := 75, PrintTxtSize := 300, cmrRAWtoneMapAlgo := 1, cmrRAWtoneMapParamA := 1.85
   , mainWinPos := 0, mainWinMaximized := 2, mainWinSize := 0, UserExternalApp := "", UserExternalEditApp := ""
   , lockSelectionAspectRatio := 1, desiredSelAspectRatio := 0, adjustingSelDotNow := 0, cycleFavesOpenIMG := 0
   , slidesFXrandomize := 0, IDedgesCenterAmount := 1, IDedgesXuAmount := 2, IDedgesYuAmount := 1, IDedgesInvert := 0
   , IDedgesEmphasis := 0, IDedgesContrast := 0, IDedgesBlendMode := 0, IDedgesOpacity := 255, IDedgesAfterBlur := 1
   , IDedgesEmbossLvl := 1, UserAddNoiseIntensity := 35, UserAddNoiseGrays := 0, reverseOrderOnSort := 0
   , userSearchWhat := 1, OnSortdoFilesCheck := 0, QuickFileActFolder1 := "", QuickFileActFolder2 := ""
   , QuickFileActFolder3 := "", QuickFileActFolder4 := "", QuickFileActFolder5 := "", QuickFileActAfter1 := 1
   , QuickFileActAfter2 := 1, QuickFileActAfter3 := 1, QuickFileActAfter4 := 1, QuickFileActAfter5 := 1
   , QuickFileActAfter6 := 1, QuickFileActFolder6 := "", userFilterWhat := 1, userFilterStringPos := 1
   , userFilterStringIsNot := 0, userFilterDoString := 1, UsrEditFilter, QuickFileActConflict := 4
   , preventDBentryRemoval := 0, findDupesPrecision := 5, DesaturateAreaAmount := 255, PrintPaperOrient := 1
   , DesaturateAreaHue := 0, DesatureAreaAlternate := 0, skipSeenImageSlides := 0, blurAreaSoftLevel := 1
   , BlurAreaBlendMode := 1, PasteInPlaceBlurEdgesSoft := 0, preventDeleteMatchingSearch := 0
   , protectedFolderPath := "", preventDeleteFromProtectedPath := 0, preventDeleteFromProtectedSubPaths := 0
   , excludePreviousDupesFromList := 0, userFindDupesHamDistLvl := 1, userFindDupesFilterHamDist := 1
   , userFilterInvertThis := 0, UserHamDistStringFilter := "", UserHamDistCacheFilterMonoGroups := 1
   , UserHamDistStringInvert := 0, lockZoomLevel := 0, showViewPortGrid := 0, vpGridColor := "998899"
   , vpGridAlpha := 150, vpGridThickness := 1, vpGridSize := 35, vpGridStepu := 4, vpGridFixedSize := 0
   , PasteInPlaceAutoExpandIMG := 0, SlidesMusicSong := "", PrintStrechedSize := 0, brushToolSize := 50
   , BrushToolAopacity := 200, BrushToolBopacity := 120, BrushToolAcolor := "ff9900", BrushToolBcolor := "3399FF"
   , BrushToolSoftness := 60, BrushToolWetness := 0, BrushToolDryingRate := 0, BrushToolType := 1
   , BrushToolUseSecondaryColor := 0, BrushToolAspectRatio := 0, BrushToolAngle := 0, BrushToolOutsideSelection := 1
   , BrushToolBlurStrength := 0, brushToolStepping := 0, BrushToolDoubleSize := 0, BrushToolOverDraw := 1
   , BrushToolDynamicCloner := 0, BrushToolEraserRestore := 0, BrushToolRandomSize := 0, BrushToolRandomSoftness := 0
   , BrushToolRandomAspectRatio := 0, BrushToolRandomAngle := 0, BrushToolRandomPosX := 0, BrushToolRandomPosY := 0
   , BrushToolRandomHue := 0, BrushToolRandomSat := 0, BrushToolRandomLight := 0, BrushToolRandomDark := 0 
   , BrushToolTexture := 1, BrushToolAutoAngle := 1, ShowAdvToolbar := 1, ToolbarOpacity := 255, findFlippedDupes := 0
   , BrushToolSymmetryX := 0, BrushToolSymmetryY := 0, BrushToolSymmetryPointX := 0.5, BrushToolSymmetryPointY := 0.5
   , BrushToolApplyColorFX := 0, PasteInPlaceBlendMode := 1, PasteInPlaceGlassy := 1, ToolbarScaleFactor := 1
   , ToolbarBgrColor := "212121", TLBRverticalAlign := 1, TLBRtwoColumns := 1, FillAreaApplyColorFX := 0
   , UserGIFsDelayu := 30, FloodFillCartoonMode := 0, FloodFillDynamicOpacity := 0, FloodFillAltToler := 1
   , FloodFillEightWays := 0, maxVectorUndoLevels := 30, showNewVectorPointPreview := 1, hamDistInterpolation := 0
   , allowUserQuickFileActions := 0, userAllowsGradientRecentering := 0, TextInAreaCaseTransform := 1
   , customZoomAdaptMode := 0, allowFreeIMGpanning := 0, lockToolbar2Win := 1, showFilesListMap := 0
   , showFolderTreeDetails := 0, userSaveBitsDepth := 1, uiUseDarkMode := 0, uiPreferedFileStats := 1
   , hamDistLBorderCrop := 0, hamDistRBorderCrop := 0, userpHashMode := 0, graylevelCompressor := 1
   , findInvertedDupes := 0, PerformMSDonDupes := 0, userFindDupesMSElvl := 50, FloodFillColor := "aa0099"
   , dupesApplyBlur := 0, BreakDupesGroups := 0, fadeOtherDupeGroups := 1
   , keepUserPaintAlphaMask := 0, alphaMaskColorReversed := 0, alphaMaskGradientScale := 100
   , alphaMaskGradientPosA := 0, alphaMaskGradientPosB := 100, alphaMaskGradientWrapped := 5
   , FillBehindClrOpacity  := 200, FillBehindOpacity := 255, FillBehindColor := "ff4400", allowCustomKeys := 0
   , alphaMaskGradientAngle := 0, DesaturateAreaChannel := 1, FloodFillClrOpacity := 255
   , FloodFillOpacity := 205, FloodFillBlendMode := 1, TextInAreaBlendMode := 1, BlurAreaAlphaMask := 0
   , UserAddNoiseBlurAmount := 0, UserAddNoisePixelizeAmount := 2, FillBehindInvert := 0
   , alphaMaskPreviewOpacity := 255, FloodFillUseAlpha := 0, EraseAreaUseAlpha := 0, bezierSplineCustomShape := 0
   , innerSelectionCavityX := 0, innerSelectionCavityY := 0, ResizeEnforceCanvas := 0
   , ResizeFillCanvasMode := 1, ShowToolTipsToolbar := 1, userPrivateMode := 0, thresholdKeywords := 1
   , minKeywordLength := 2, LangKeywordsFilter := 0, mergeKeywordRows := 1, limitSearchReplaceSelected := 0
   , autoReflectVectorAnchors := 0, shearImgX := 0, shearImgY := 0, UserSymmetricaMode := 1
   , uiZoomBlurAreaXamount := 15, zoomBlurMode := 1, DesaturateAreaLevels := 1, DesaturateAreaDither := 0
   , BlurAreaHue := 0, BlurAreaSaturation := 0, BlurAreaLight := 0, BlurAreaGamma := 0
   , userCombineGIFframeDelay := 100, userCombineFramesFmt := 2, UserCombinePDFpageSize := 1
   , combinePDFpageLandscape := 0, combinePDFpageHighQuality := 0, usePrevSaveFolder := 0
   , userCombineSubFrames := 0, blurAreaYamount := 10, blurAreaEqualXY := 1, UserAddNoiseMode := 1
   , UserAddNoiseDetails := 10, slidesRandoMode := 1, convertOnAutoCrop := 0, AutoCropStrongAdaptiveMode := 0
   , usrAutoCropErrThreshold := 5, onConflictMultiRenameAct := 4, userActionAutoCropConflictingFile := 4
   , userCopyMoveStructuredConflictMode := 4, SeenIMGprivateFolder := "", FillAreaRectRoundness := 45
   , FillAreaEllipseSection := 850, FillAreaEllipsePie := 1, DrawLineAreaGridX := 6, DrawLineAreaGridY := 6
   , DrawLineAreaSpiralLength := 350, DrawLineAreaRaysLimit := 9, DrawLineAreaSpiralCenterMode := 1
   , DrawLineAreaCenterCut := 0, blurAreaCircular := 0, ImageSharpenAmount := 25, ImageSharpenRadius := 10
   , ImageSharpenMode := 1, userAutoColorAdjustMode := 1, userAutoColorAdjustAll := 0, userAutoColorIntensity := 255
   , UserSymmetricaCenteringMode := 0, UserSymmetricaSrcFlipX := 0, UserSymmetricaSrcFlipY := 0
   , UserSymmetricaSrcAlign := 1, UserSymmetricaSrcRotated := 0, UserSymmetricaScaleX := 200
   , UserSymmetricaScaleY := 200, UserSymmetricaSelAligned := 1, UserSymmetricaSelOffX := 0
   , UserSymmetricaSelOffY := 0, UserSymmetricaUseAlpha := 0, UserSymmetricaInvertArea := 0
   , DrawLineAreaAtomizedGrid := 1, DrawLineAreaEqualGrid := 1, DrawLineAreaAltRays := 0
   , DrawLineAreaGridCenter := 2, DrawLineAreaCropShape := 1, OutlierFillColor := "eeFFaa"
   , OutlierFillOpacity := 200, alphaMaskBMPbright := 0, alphaMaskBMPcontrast := 0, FillAreaWelcomePattern := 1
   , toolbarViewerMode := 1, userCustomizedToolbar := 0, userThumbsToolbarList, userImgViewToolbarList
   , thumbsModeItemHighlight := 1, convertFormatUseMultiThreads := 0, convertFormatAutoSkip := 1
   , SimpleOperationsMultiThreaded := 0, FillAreaBlurAmount := 0, BrushToolBlendMode := 1
   , BlendModesFlipped := 0, allowToneMappingImg := 1, userThumbsSheetWidth := 300, userThumbsSheetHeight := 300
   , userThumbsSheetColumns := 10, userThumbsSheetSpacing := 50, userThumbsSheetFrame := 100
   , userThumbsSheetBgrColor := "FFffFF", userThumbsSheetShowLabel := 0, userThumbsSheetHideExt := 1
   , userThumbsSheetBgrShade := 2, userCombineDepthDithering := 1, imgColorsFXopacity := 255
   , userUndoDeleteNonIdenticalCopy := 0, userUndoMustDoOverwrite := 4, userUndoRecoverOverwritten := 1
   , UserUndoMultiDesiredOperation := 1, UserAddNoiseTransparent := 1, userImgAdjustSat := 0
   , userImgAdjustBright := 0, userImgAdjustContra := 0, userImgAdjustHue := 0, userImgAdjustGamma := 300
   , userImgAdjustOffR := 0, userImgAdjustOffG := 0, userImgAdjustOffB := 0, userImgAdjustOffA := 0
   , userImgAdjustInvertColors := 0, userImgAdjustAltContra := 0, userImgAdjustTintDeg := 0
   , userImgAdjustTintAmount := 0, userImgAdjustShadows := 0, userImgAdjustHighs := 0
   , userImgAdjustAltHiLows := 0, userImgAdjustBlackPoint := 0, userImgAdjustWhitePoint := 65535
   , userImgAdjustAltSat := 1, userImgAdjustAltTint := 0, DesaturateAreaBright := 0, DesaturateAreaContra := 0
   , DesaturateAreaInvert := 0, userImgAdjustThreR := -1, userImgAdjustThreG := -1, userImgAdjustThreB := -1
   , userImgAdjustThreA := -1, userImgAdjustLinkThresholds := 1, userImgAdjustSeeThrough := 1
   , userImgAdjustHiPrecision := 0, userImgAdjustNoClamp := 0, userImgAdjustConvertDepth := 0
   , UserSymmetricaBlendMode := 1, UserSymmetricaOpacity := 255, userImgAdjustNoisePoints := 0
   , blurAreaApplyFX := 0, FillAreaDoBehind := 0, PasteInPlaceRevealOriginal := 0, PasteInPlaceCropDo := 0
   , PasteInPlaceCropAdaptImg := 1, PasteInPlaceOrientFlipX := 0, PasteInPlaceOrientFlipY := 0
   , freeHandSelectionMode := 0, DrawLineAreaBorderConnector := 1, DrawLineAreaSnapLine := 0
   , DrawLineAreaBlendMode := 1, BlendModesPreserveAlpha := 0, FillAreaCutGlass := 0
   , userImgChannelAlphaAdd := 0, forceSlowLivePreviewMode := 0, showContextualStatusBar := 1
   , vectorToolModus := 1, TextInAreaVerticalia := 0, DrawLineAreaThickScale := 100

EnvGet, realSystemCores, NUMBER_OF_PROCESSORS
addJournalEntry("Application started: PID " QPVpid ".`nCPU cores identified: " realSystemCores ".")

If (realSystemCores>8)
   realSystemCores := 8

RegRead, InitCheckReg, %QPVregEntry%, Running
RegRead, InitTimeReg, %QPVregEntry%, LastStartTime
If (Abs(A_TickCount - InitTimeReg)<600 && IsNumber(InitTimeReg) && InitCheckReg=1 && InitTimeReg>1)
{
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}


OnExit, doCleanup
initCompiled(A_IsCompiled)
If !A_IsCompiled
   Try Menu, Tray, Icon, %mainExecPath%\qpv-icon.ico
thisGDIPversion := Gdip_LibrarySubVersion()
GDIPToken := Gdip_Startup()
If (!GDIPToken || thisGDIPversion<1.92)
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+...`n`nThe program will now exit.`n`nRequired GDI+ library wrapper: v1.92 - extended compilation edition.
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}

; RegRead, initArgu, %QPVregEntry%, initArgu
If (InitCheckReg=2)
{
   initExternalCoreMode()
   Return
}

RegWrite, REG_SZ, %QPVregEntry%, Running, 1
RegWrite, REG_SZ, %QPVregEntry%, LastStartTime, % A_TickCount
IniRead, FirstRun, % mainSettingsFile, General, FirstRun, @
If (FirstRun!=0)
{
   realSystemCores := systemCores := 2
   writeMainSettingsApp()
   FirstRun := 0
   IniWrite, % FirstRun, % mainSettingsFile, General, FirstRun
} Else readMainSettingsApp(0)

OnMessage(0x201, "WM_LBUTTONdown")
OnMessage(0x202, "WM_LBUTTONup")
OnMessage(0x200, "WM_MOUSEMOVE")
OnMessage(0x203, "OnLButtonDblClk")
OnMessage(0x20A, "adjustWheelNumbersEditFields") ; WM_MOUSEWHEEL
OnMessage(0x20E, "adjustWheelNumbersEditFields") ; WM_MOUSEWHEEL
; Loop, 9
;     OnMessage(255+A_Index, "PreventKeyPressBeep")   ; 0x100 to 0x108
OnMessage(0x100, "WM_KEYDOWN")
OnMessage(0x104, "WM_KEYDOWN")

Global interfaceThread
If !A_IsCompiled
   interfaceThread := ahkthread("#Include *i Lib\module-interface.ahk")
Else If (sz := GetRes(data, 0, "MODULE-INTERFACE.AHK", 10))
   interfaceThread := ahkThread(StrGet(&data, sz, "utf-8"))

; the interface is a separate thread to allow users 
; enjoy a more responsive user interface when the main thread
; is busy processing
externObj := WindowBgrColor "$" isAlwaysOnTop "$" mainCompiledPath "$" isTitleBarVisible "$" TouchScreenMode "$.$" mainWinPos "$" mainWinSize "$" mainWinMaximized "$" IMGresizingMode
externObj .= "$" OSDbgrColor "$" OSDtextColor "$" OSDfontSize "$" PrefsLargeFonts "$" OSDFontName "$" OSDfontBolded
initGUI := interfaceThread.ahkFunction("BuildGUI", externObj)
fnOutputDebug("extern UI HWNDs: " initGUI)
If !InStr(initGUI, "|")
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize the interface. The application will now exit...
   hasInitSpecialMode := 1
   ForceExitNow()
   Return
} Else
{
   handleUIhwnd(initGui)
   externObj := ""
}

createGDIPcanvas()
InitGDIpStuff()

Global multiCoreThumbsInitGood := "n", thumbThread1,thumbThread2,thumbThread3,thumbThread4
,thumbThread5,thumbThread6,thumbThread7,thumbThread8,thumbThread9,thumbThread10

If (A_PtrSize=4)
{
   allowMultiCoreMode := 0
   minimizeMemUsage := 1
   maxUndoLevels := 2
   coreDesiredPixFmt := "0x21808"
}

; OnMessage(0x205, "WM_RBUTTONUP")
TriggerMenuBarUpdate()
addJournalEntry("Finished initialization of " appTitle " v" appVersion ".")
If (qpvCanvasHasInit=1)
   doWelcomeNow := initializeAppWithGivenArguments()

; MsgBox, % A_TickCount - scriptStartTime
If (doWelcomeNow=1 && qpvCanvasHasInit=1)
{
   drawWelcomeImg()
   interfaceThread.ahkPostFunction("uiAccessWelcomeView")
}

If (A_Is64bitOS=1 && A_PtrSize!=8)
   SetTimer, giveWarningX64, -500

If (uiUseDarkMode=1)
{
   setMenusTheme(uiUseDarkMode)
   setDarkWinAttribs(PVhwnd, uiUseDarkMode)
}

SetTimer, createGUItoolbar, -100
; initQPVmainDLL()
; createDummyTestGui()
Return

;_____________________________________ Hotkeys _________________
; the hotkeys are registered since v5.4.5 in
; interfaceThread / module-interface.ahk

identifyThisWin() {
  Static prevR, lastInvoked := 1
  If (A_TickCount - lastInvoked < 50)
     Return prevR

  Az := WinActive("A")
  prevR := (Az=PVhwnd || Az=hGDIwin || Az=hGDIthumbsWin || Az=hGDIinfosWin || Az=hGDIselectWin) ? 1 : 0
  lastInvoked := A_TickCount
  Return prevR
}

HKifs(q:=0, whichWin:=-1) {
   whichBitmap := (validBMP(useGdiBitmap()) && resultedFilesList[currentFileIndex, 1]) ? 1 : 0
   If (q="imgEditSolo")
      r := (!AnyWindowOpen && openingPanelNow!=1 && !CurrentSLD && whichBitmap=1 && thumbsDisplaying!=1) ? 1 : 0
   Else If (q="imgsLoaded")
      r := (!AnyWindowOpen && openingPanelNow!=1 && CurrentSLD && maxFilesIndex>0) ? 1 : 0
   Else If (q="liveEdit")
      r := (AnyWindowOpen && openingPanelNow!=1 && imgEditPanelOpened=1 && whichBitmap=1 && thumbsDisplaying!=1) ? 1 : 0
   Else If (q="general")
      r := (!AnyWindowOpen && imgEditPanelOpened!=1) ? 1 : 0

   If (drawingShapeNow=1 || whileLoopExec=1 || whichWin=AnyWindowOpen)
      r := 0

   Return r
}

constructKbdKey(vk_shift, vk_ctrl, vk_alt, vk_code) {
   Static vkList := {8:"BACKSPACE", 9:"TAB", C:"NUMPADCLEAR", D:"ENTER", 14:"CAPSLOCK", 1B:"ESCAPE", 20:"SPACE", 21:"PGUP", 22:"PGDN", 23:"END", 24:"HOME", 25:"LEFT", 26:"UP", 27:"RIGHT", 28:"DOWN", 2D:"INSERT", 2E:"DELETE", 5B:"SCROLLLOCK", 5D:"APPSKEY", 60:"NUMPAD0", 61:"NUMPAD1", 62:"NUMPAD2", 63:"NUMPAD3", 64:"NUMPAD4", 65:"NUMPAD5", 66:"NUMPAD6", 67:"NUMPAD7", 68:"NUMPAD8", 69:"NUMPAD9"
                   , 6A:"NUMPADMULT", 6B:"NUMPADADD", 6D:"NUMPADSUB", 6E:"NUMPADDOT", 6F:"NUMPADDIV", 70:"F1", 71:"F2", 72:"F3", 73:"F4", 74:"F5", 75:"F6", 76:"F7", 77:"F8", 78:"F9", 79:"F10", 7A:"F11", 7B:"F12", 90:"NUMLOCK", AD:"VOLUME_MUTE", AE:"VOLUME_DOWN", AF:"VOLUME_UP", B0:"MEDIA_NEXT", B1:"MEDIA_PREV", B2:"MEDIA_STOP", B3:"MEDIA_PLAY_PAUSE", FF:"PAUSE", 1:"LBUTTON", 2:"RBUTTON"
                   , 3:"BREAK", 4:"MBUTTON", 5:"XBUTTON1", 6:"XBUTTON2", 10:"SHIFT", 11:"CONTROL", 12:"ALT", 13:"PAUSE", 15:"KANA/HANGUL", 17:"JUNJA", 18:"IME_FINAL", 19:"HANJA/KANJI", 16:"IME_ON", 1A:"IME_OFF", 1C:"IME_CONVERT", 1D:"IME_NON_CONVERT", E5:"IME_PROCESSKEY", 1E:"IME_ACCEPT", 1F:"IME_MODECHANGE", 2F:"HELP", 29:"SELECT", 2A:"PRINT", 2B:"EXECUTE", 2C:"PRINT_SCREEN", 5F:"SLEEP"
                   , 7C:"F13", 7D:"F14", 7E:"F15", 7F:"F16", 80:"F17", 81:"F18", 82:"F19", 83:"F20", 84:"F21", 85:"F22", 86:"F23", 87:"F24", A6:"BROWSER_BACK", A7:"BROWSER_FORWARD", A8:"BROWSER_REFRESH", A9:"BROWSER_STOP", AA:"BROWSER_SEARCH", AB:"BROWSER_FAVORITES", AC:"BROWSER_HOME", B4:"LAUNCH_MAIL", B5:"LAUNCH_MEDIA_SELECT", B6:"LAUNCH_APP1", B7:"LAUNCH_APP2", F6:"ATTN", F7:"CrSEL"
                   , F8:"ExSEL", F9:"ERASE_EOF", FA:"PLAY", FB:"ZOOM", FD:"PA1", A0:"LSHIFT", A1:"RSHIFT", A2:"LCTRL", A3:"RCTRL", A4:"LALT", A5:"RALT", 5B:"LWIN", 5C:"RWIN", BF:"SLASH", DC:"BSLASH", C0:"TILDA", DE:"QUOTES"}
        , vkExtraList := {30:"00.1", 31:"1", 32:"2", 33:"3", 34:"4", 35:"5", 36:"6", 37:"7", 38:"8", 39:"9", 41:"A", 42:"B", 43:"C", 44:"D", 45:"E", 46:"F", 47:"G", 48:"H", 49:"I", 4A:"J", 4B:"K", 4C:"L", 4D:"M", 4E:"N", 4F:"O", 50:"P", 51:"Q", 52:"R", 53:"S", 54:"T", 55:"U", 56:"V", 57:"W", 58:"X", 59:"Y", 5A:"Z", BB:"EQUAL", BC:"COMMA", BD:"MINUS", BE:"PERIOD", BA:"COLON", DB:"LBRACKET", DD:"RBRACKET"}
        ; DF:"OEM_8", E2:"OEM_102", E1:"OEM_9", E3:"OEM_11", E4:"OEM_12", E6:"OEM_13", FE:"OEM_CLEAR", 92:"OEM_14", 93:"OEM_15", 94:"OEM_16", 95:"OEM_17", 96:"OEM_18"}
   ; vk list based on https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes

   newkate := ""
   If vk_shift
      newkate .= "+"
   If vk_ctrl
      newkate .= "^"
   If vk_alt
      newkate .= "!"

   If (vkExtraList[vk_code]!="")
      newkate .= vkExtraList[vk_code]
   Else
      newkate .= vkList[vk_code] ? vkList[vk_code] : "vk" vk_code

   Return newkate
}

PreProcessKbdKey() {
   Static lastInvoked := 1, counter := 0, prevKey

   Awin := WinActive("A")
   If (A_TickCount - lastOtherWinClose<300) || (Awin=PVhwnd) || (Awin!=vk_hwnd)
   {
      lastInvoked := 1, counter := 0, prevKey := 0
      Return
   }

   ; ToolTip, % hotkate , , , 2
   If (A_TickCount - lastInvoked>250)
      counter := 0

   ; addJournalEntry(A_ThisFunc "(): " thisWin "|" hotkate)
   If (A_TickCount - lastInvoked>30) && (whileLoopExec=0 && runningLongOperation=0)
   {
      lastInvoked := A_TickCount
      abusive := (counter>25) ? 1 : 0
      thisHwnd := identifyParentWind() ? "parentu" : Awin
      KeyboardResponder(hotkate, thisHwnd, abusive, "n")
      If (hotkate=prevKey)
         counter++
      Else 
         counter := 0

      prevKey := hotkate
   } Else If (hotkate=prevKey)
      counter++
   Else 
      counter := 0
}

decideBlockKbdKeys(Az, givenKey) {
   Critical, on
   blockKey := 0
   If AnyWindowOpen
      GuiControlGet, OutputVname, SettingsGUIA: FocusV

   If (Az=hQPVtoolbar) ; && (isVarEqualTo(givenKey, "home", "end", "BackSpace", "tab", "+tab", "+enter", "+space", "up", "down", "enter", "space", "escape", "AppsKey", "f1", "h") || (isInRange(givenKey, 0, 9) && isNumber(givenKey)  )  )  )
   {
      blockKey := 1
   } Else If (givenKey="^a" && Az=hSetWinGui && (AnyWindowOpen=2 || AnyWindowOpen=60))
   {
      GuiControlGet, OutputVar, SettingsGUIA: Focus
      If InStr(OutputVar, "ListView")
         blockKey := 1
   } Else If (Az=hQuickMenuSearchWin && VisibleQuickMenuSearchWin=1 && givenKey!="Tab")
   {
      GuiControlGet, OutputVar, QuickMenuSearchGUIA: Focus
      If (InStr(OutputVar, "edit") && (givenKey="Up" || givenKey="Down"))
      || (isVarEqualTo(givenKey, "^Up", "!Up", "!Left", "!BackSpace", "^x", "^c") && omniBoxMode=1)
         blockKey := 1
         GuiControlGet, OutputVname, SettingsGUIA: FocusV
   } Else If (Az=hSetWinGui && InStr(OutputVname, "customSliders") && isVarEqualTo(givenKey, "Left", "Right", "PgUp", "PgDn", "Home", "End", "BackSpace", "Delete"))
   {
      blockKey := 1
   } Else If (Az=hSetWinGui && isVarEqualTo(givenKey, "Up", "Down"))
   {
      GuiControlGet, hVar, SettingsGUIA: hwnd, % OutputVname
      WinGetClass, pClass, ahk_id %hVar%
      isOkay := (SubStr(OutputVname, 1, 5)!="editF" && StrLen(OutputVname)>1 && !InStr(pClass, "_updown") && !InStr(pClass, "ComboBox")) ? 1 : 0
      If isOkay
      {
         GuiControlGet, OutputVar, SettingsGUIA: Focus
         GuiControlGet, OutputVal, SettingsGUIA:, % OutputVname
         GuiControlGet, OutputEnable, SettingsGUIA: Enabled, % OutputVname
         If (isNumber(OutputVal) && InStr(OutputVar, "edit") && OutputEnable=1)
            blockKey := 1
      }
   } Else If (givenKey="^F4")
   {
      If (imgEditPanelOpened=1 || AnyWindowOpen>0) && (Az=hSetWinGui) && (A_TickCount - lastOtherWinClose>150)
         BtnCloseWindow()
   } Else If (givenKey="AppsKey") || (givenKey="Enter" && (A_TickCount - lastOtherWinClose>300))
   {
      If (imgEditPanelOpened=1 || AnyWindowOpen>0) && (Az=hSetWinGui)
         blockKey := externalinvokedSettingsContextMenu(givenKey, 1)
   }
   Return blockKey
}

MsgBoxConflictKeysResponder(keyu) {
    Static listu := {"o":"overwrite", "a":"auto-rename", "s":"skip file", "c":"cancel"}
    pp := constructKbdKey(0, 0, 0, keyu)
    SetTimer, highlightActiveArrowsCtrl, -50, 200
    If (pp="Escape")
    {
       KillMsgbox2Win()
    } Else If (pp="Space" || pp="Enter")
    {
       Gui, WinMsgBox: Default
       GuiControlGet, btnFocused, WinMsgBox: FocusV
       GuiControlGet, hwnd, hwnd, %btnFocused%
       ControlGetText, btnText, , ahk_id %hwnd%
       WinGetClass, classu, ahk_id %hwnd%
       ; ToolTip, % A_GuiControl "|" btnFocused "|" btnText "|" hwnd "|" pp "|" classu , , , 3
       If (btnText=btnFocused && A_GuiControl=btnFocused && InStr(classu, "button") && !InStr(btnFocused, "checkbox"))
       {
          MsgBox2Result := btnFocused && btnText ? btnText : "close"
          MsgBox2InputHook.Stop()
       }
    } Else If isVarEqualTo(pp,"o", "a", "s", "c")
    {
       MsgBox2Result := listu[pp]
       MsgBox2InputHook.Stop()
    }
}

WM_KEYDOWN(wParam, lParam, msg, ctrlHwnd) {
    vk_code := Format("{1:x}", wParam)
    Awin := WinActive("A")

    If (MsgBox2hwnd=Awin && MsgBox2Result="wait-ask")
    {
       MsgBoxConflictKeysResponder(vk_code)
       Return
    }


    If (whileLoopExec=1 || runningLongOperation=1) && (vk_code!="1B") 
    || (A_TickCount - lastOtherWinClose<300) || (Awin=PVhwnd)
       Return 

    vk_shift := DllCall("GetKeyState","Int", 0x10, "short") >> 16
    vk_ctrl := DllCall("GetKeyState","Int", 0x11, "short") >> 16
    vk_alt := (msg=260) ? -1 : DllCall("GetKeyState","Int", 0x12, "short") >> 16
    hotkate := constructKbdKey(vk_shift, vk_ctrl, vk_alt, vk_code)
    vk_hwnd := Awin

    If (vk_code!=10 && vk_code!=11 && vk_code!=12)
    {
       SetTimer, PreProcessKbdKey, -25
       If decideBlockKbdKeys(Awin, hotkate)
          Return 0
    }

    ; TulTip(0, "|   ", wParam, vk_shift, vk_ctrl, vk_alt, msg, "main thread", lParam>>16 & 0xffff)
}

deactivateTlbrKbdMode(m:=0) {
   isToolbarKBDnav := 0
   interfaceThread.ahkassign("isToolbarKBDnav", isToolbarKBDnav)
   If (m=1)
      WinActivate, ahk_id %PVhwnd%
}

KeyboardResponder(givenKey, thisWin, abusive, externCounter) {
   ; SoundBeep 
   If isNumber(externCounter)
      navKeysCounter := externCounter

   Az := WinActive("A")
   If (Az!=hQPVtoolbar)
      deactivateTlbrKbdMode()
   ; addJournalEntry(A_ThisFunc "(): " az "=" thisWin "|" givenKey)
   If (VisibleQuickMenuSearchWin=1 && !isVarEqualTo(Az, hQuickMenuSearchWin, hKbdGuia, hSetWinGui) && omniBoxMode=0)
   {
      lastTimeToggleThumbs := A_TickCount 
      closeQuickSearch()
      Return
   } Else If (imgEditPanelOpened=1 && panelWinCollapsed=1 && Az=hSetWinGui)
   {
      If (mustCaptureCloneBrush!=1 && colorPickerModeNow!=1 || givenKey="Escape")
         toggleImgEditPanelWindow()
      Return
   } Else If (imgEditPanelOpened=1 && panelWinCollapsed=1 && Az=hCollapseWidget)
   {
      If (givenKey="F11")
         toggleImgEditPanelWindow()
      Else If (givenKey="F12")
         ActToggleLivePreview()
      Else If (givenKey="COLON")
         PanelQuickSearchMenuOptions()
      Else If isVarEqualTo(givenKey, "HOME", "END", "PGUP", "PGDN", "BACKSPACE", "DELETE", "UP", "DOWN", "TAB", "SLASH", "BSLASH", "INSERT", "T", "A", "F", "EQUAL", "MINUS", "COMMA", "PERIOD", "LBRACKET", "RBRACKET", "QUOTES", "TILDA", "APPSKEY")
      {
         v := OSDfontSize//2
         WinActivate, ahk_id %PVhwnd%
         mouseCreateOSDinfoLine("The main window has keyboard focus now", v)
      }
      Return
   }

   If (thisWin="parentu")
   {
      If ((givenKey="AppsKey" || givenKey="Enter") && (A_TickCount - lastOtherWinClose>300) && (imgEditPanelOpened=1 || AnyWindowOpen>0) && Az=hSetWinGui)
      {
         externalinvokedSettingsContextMenu(givenKey)
      } Else If (givenKey="^a" && Az=hSetWinGui && (AnyWindowOpen=2 || AnyWindowOpen=60))
      {
         GuiControlGet, OutputVar, SettingsGUIA: Focus
         If InStr(OutputVar, "ListView")
            BTNreviewLVselAll()
      } Else If (Az=hQuickMenuSearchWin && VisibleQuickMenuSearchWin=1 && givenKey!="Tab")
      {
         GuiControlGet, OutputVar, QuickMenuSearchGUIA: Focus
         If (InStr(OutputVar, "edit") && (givenKey="Up" || givenKey="Down"))
         {
            changeOptionQuickSearch(givenKey)
            SetTimer, highlightActiveArrowsCtrl, -50
         } Else If (InStr(OutputVar, "edit") && (givenKey="home" || givenKey="end"))
         {
            Static lastSilly := 1
            lastSilly := !lastSilly
            If lastSilly
               highlightActiveCtrl()
            Else
               highlightActiveArrowsCtrl()
         } Else If (InStr(OutputVar, "edit") && omniBoxMode=1)
         {
            If (givenKey="F2")
               omniBoxFolderRename()
            Else If (givenKey="F3")
               omniBoxFolderImport()
            Else If (givenKey="F5")
               SetTimer, PopulateQuickMenuSearch, -150
            Else If (givenKey="F7")
               omniBoxFolderCreateNew()
            Else If (givenKey="F8")
               omniBoxFolderDelete()
            Else If (givenKey="F12")
               omniBoxFolderProperties()
         } Else If (InStr(OutputVar, "edit") && givenKey="F1")
         {
            btnHelpQuickSearchMenus()
         } Else If (InStr(OutputVar, "edit") && givenKey="F2")
         {
            PanelDefineKbdShortcut()
         } Else If (InStr(OutputVar, "edit") && givenKey="F8")
         {
            closeQuickSearch()
            SetTimer, openPreviousPanel, -200
         }

         If (isVarEqualTo(givenKey, "^Up", "!Up", "!Left", "!BackSpace") && omniBoxMode=1)
         {
            GoQuickSearchAction(0, "yes", "!OmniNavigateUpFolder")
            highlightActiveArrowsCtrl()
         }
   
         If (omniBoxMode=1 && givenKey="^x")
            omniBoxFolderCutCopy("cut")
         Else If (omniBoxMode=1 && givenKey="^c")
            omniBoxFolderCutCopy("copy")
      } Else If (givenKey="Tab" || givenKey="+Tab")
      {
         GuiUpdateFocusedSliders("keys")
         SetTimer, highlightActiveCtrl, -50
      } Else If (isVarEqualTo(givenKey, "Up", "Down", "Left", "Right", "PgUp", "PgDn", "Home", "End", "BackSpace", "Delete"))
      {
         GuiUpdateFocusedSliders("keys")
         pp := (Az=hSetWinGui) ? "SettingsGUIA" : "SoloSliderWidgetGUIA"
         GuiControlGet, OutputVname, %pp%: FocusV
         If ((Az=hSetWinGui && AnyWindowOpen || Az=hSliderWidget && soloSliderWinVisible=1) && InStr(OutputVname, "customSliders"))
         {
            GuiControlGet, hVar, %pp%: hwnd, % OutputVname
            GuiSlidersResponder(hVar, "uiLabel", givenKey)
         } Else If (Az=hSetWinGui && (givenKey="Up" || givenKey="Down"))
         {
            GuiControlGet, hVar, SettingsGUIA: hwnd, % OutputVname
            WinGetClass, pClass, ahk_id %hVar%
            isOkay := (SubStr(OutputVname, 1, 5)!="editF" && StrLen(OutputVname)>1 && !InStr(pClass, "_updown") && !InStr(pClass, "ComboBox")) ? 1 : 0
            ; ToolTip, % isOkay "==" pClass , , , 2
            If isOkay
            {
               GuiControlGet, OutputVar, SettingsGUIA: Focus
               GuiControlGet, OutputVal, SettingsGUIA:, % OutputVname
               GuiControlGet, OutputEnable, SettingsGUIA: Enabled, % OutputVname
               If (isNumber(OutputVal) && InStr(OutputVar, "edit") && OutputEnable=1)
                  GuiControl, SettingsGUIA:, % OutputVname, % (givenKey="Up") ? OutputVal + 1 : OutputVal - 1
            }
         }
         If isVarEqualTo(givenKey, "Up", "Down", "Left", "Right")
            SetTimer, highlightActiveArrowsCtrl, -50
      } Else If (givenKey="^F4")
      {
         If (imgEditPanelOpened=1 || AnyWindowOpen>0) && (Az=hSetWinGui) && (A_TickCount - lastOtherWinClose>150)
            BtnCloseWindow()
      } Else If (givenKey="F8" || givenKey="F11")
      {
         If (imgEditPanelOpened=1 || AnyWindowOpen>0) && (Az=hSetWinGui)
            toggleImgEditPanelWindow()
      } Else If (givenKey="F12")
      {
         If (imgEditPanelOpened=1 && Az=hSetWinGui && isImgEditingNow()=1)
            SetTimer, ActToggleLivePreview, -150
      } Else If (givenKey="Space")
         highlightActiveCtrl(givenKey)
      Else If (givenKey="RButton")
         highlightActiveCtrl(givenKey)
   
      If (folderTreeWinOpen=1 && Az=hfdTreeWinGui && givenKey="^x")
         folderTreeCutCopyFolder("cut")
      Else If (folderTreeWinOpen=1 && Az=hfdTreeWinGui && givenKey="^c")
         folderTreeCutCopyFolder("copy")
   } Else If (thisWin=hQPVtoolbar && ShowAdvToolbar=1 && Az=thisWin)
   {
       If isVarEqualTo(givenKey, "+Tab", "Tab", "Escape", "AppsKey", "BackSpace")
       {
          If (givenKey="escape")
          {
             lastOtherWinClose := A_TickCount
             interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
          }

          deactivateTlbrKbdMode(1)
          displayNowToolbarHelp(3)
       } Else If (givenKey="h" || givenKey="F1")
       {
          displayNowToolbarHelp(1)
       } Else If (givenKey="COLON")
       {
          deactivateTlbrKbdMode(1)
          SetTimer, PanelQuickSearchMenuOptions, -50
      } Else If (givenKey="F8" || givenKey="F11")
      {
         deactivateTlbrKbdMode(1)
         If HKifs("liveEdit")
            SetTimer, toggleImgEditPanelWindow, -50
      } Else If (givenKey="F12")
      {
          If (imgEditPanelOpened=1 && isImgEditingNow()=1)
             SetTimer, ActToggleLivePreview, -150
       } Else If isVarEqualTo(givenKey, "Left", "Up", "Down", "Right")
       {
          KeyboardMoveMouseToolbar(givenKey)
       } Else If (givenKey="Home")
       {
          KeyboardMoveMouseToolbar(2)
       } Else If (givenKey="End")
       {
          KeyboardMoveMouseToolbar(tlbrIconzList["counter"])
       } Else If (givenKey="+Space" || givenKey="+Enter")
       {
          invokeKbdToolbarAct("right")
       } Else If (givenKey="Space" || givenKey="Enter")
       {
          invokeKbdToolbarAct("n")
       } Else If (isInRange(givenKey, 0, 9) && isNumber(givenKey))
       {
          v := givenKey ? givenKey : 10
          KeyboardMoveMouseToolbar(v)
       }
   } Else If (thisWin=PVhwnd && identifyThisWin()=1)
   {
       ; ToolTip, % givenKey "==" thisWin , , , 2
       If (ckbd := testCustomKBDcontexts(givenKey))
       {
          If isFunc(userCustomKeysDefined[ckbd, 1])
          {
             thisu := userCustomKeysDefined[ckbd, 1]
             If testFuncIsInMenus(thisu) ; prevent execution of functions that are no available in the current context
                %thisu%()
          }
       } Else If (allowLoop := processDefaultKbdCombos(givenKey, thisWin, abusive, Az, 0))
       {
          allowLoop := (allowLoop=-1) ? 0 : allowLoop - 1
       } Else If (InStr(menuHotkeys, givenKey "|") && showMainMenuBar=1 && InStr(givenKey, "!") && StrLen(givenKey)=2)
       {
          n := 0
          Loop, Parse, menuHotkeys, |
          {
             If (A_LoopField=givenKey)
             {
                n := A_Index - 1
                Break
             }
          }
          If n
             interfaceThread.ahkPostFunction("invokeGivenMenuBarPopup", n)
       }
   }

   If (abusive=1 && allowLoop=1)
   {
      KeyboardResponder(givenKey, thisWin, 0, "n")
   } Else If (totalFramesIndex>2 && CountGIFframes>2)
   {
      animGIFplaying := interfaceThread.ahkgetvar.animGIFplaying
      If (animGIFplaying=-1)
      {
         imgPath := getIDimage(currentFileIndex)
         animGIFplaying := 1
         interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
         ; setGIFframesDelay()
         autoChangeDesiredFrame("start", imgPath)
         SetTimer, autoChangeDesiredFrame, % GIFspeedDelay + UserGIFsDelayu
      }
   }
} ; // KeyboardResponder()

processDefaultKbdCombos(givenKey, thisWin, abusive, Az, simulacrum) {
    func2Call := []
    allowLoop := 0
    If (givenKey="^o")
    {
        If HKifs("general")
           func2Call := ["OpenDialogFiles"]
    } Else If (givenKey="o")
    {
        imgPath := getIDimage(currentFileIndex)
        If (isImgEditingNow()=1 && drawingShapeNow=1)
           func2Call := ["toggleOpenClosedLineEditorCustomShape"]
        Else If HKifs("imgsLoaded")
           func2Call := ["OpenThisFileMenu"]
        Else If ((HKifs("general") && (!CurrentSLD || !validBMP(gdiBitmap))) && !FileRexists(imgPath))
           func2Call := ["OpenDialogFiles"]
    } Else If (givenKey="w")
    {
        ; w - to-do
        If (isImgEditingNow()=1 && drawingShapeNow=1)
           func2Call := ["focusVectorEndPoint"]
        Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1 && thumbsDisplaying!=1)
           func2Call := ["flipSelectionWH"]
        Else If (thumbsDisplaying=1 && maxFilesIndex>10 && CurrentSLD && !z)
           func2Call := ["invokeFilesListMapNow"]

        ; testCreateMask()
    } Else If (givenKey="+^n")
    {
        If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
           func2Call := ["OpenNewQPVinstance"]
    } Else If (givenKey="^n")
    {
        If HKifs("general")
           func2Call := ["PanelNewImage"]
    } Else If (givenKey="+tilda")
    {
        If HKifs("general")
           func2Call := ["PanelJournalWindow"]
    } Else If (givenKey="F12")
    {
        If HKifs("liveEdit")
           func2Call := ["ActToggleLivePreview"]
        Else If HKifs("general")
           func2Call := ["PanelPrefsWindow"]
    } Else If (givenKey="p")
    {
        If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["togglePreviewVectorNewPoint"]
        Else If (liveDrawingBrushTool=1 && isImgEditingNow()=1 && AnyWindowOpen=64)
          func2Call := ["toggleBrushDeformers"]
        Else If ((HKifs("imgEditSolo") || HKifs("liveEdit", 64) || HKifs("imgsLoaded")) && AnyWindowOpen!=31 && AnyWindowOpen!=24)
          func2Call := ["PanelBrushTool"]
    } Else If (givenKey="!p")
    {
        If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
           func2Call := ["MenuRealStartDrawingLines"]
    } Else If (givenKey="+p")
    {
        If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
           func2Call := ["MenuRealStartDrawingShapes"]
    } Else If (givenKey="^p")
    {
        If (imageLoading!=1 && (HKifs("imgEditSolo") || HKifs("imgsLoaded")))
           func2Call := ["PanelPrintImage"]
    } Else If (givenKey="COLON")
    {
        func2Call := ["PanelQuickSearchMenuOptions"]
    } Else If (givenKey="+COLON")
    {
        func2Call := ["invokeOmniBoxCurrentFile"]
    } Else If InStr(givenKey, "^Numpad")
    {
        func2Call := ["alignImgSelection", givenKey]
    } Else If (givenKey="^NumpadAdd" || givenKey="^equal")
    {
        func2Call := ["MenuChangeOSDZoomPlus"]
    } Else If (givenKey="^NumpadSub" || givenKey="^minus")
    {
        func2Call := ["MenuChangeOSDZoomMinus"]
    } Else If (givenKey="+o")
    {
        If HKifs("general")
           func2Call := ["OpenFolders"]
    } Else If (givenKey="^F10" || givenKey="+F10" || givenKey="+!F10")
    {
        func2Call := ["toggleAppToolbar"]
    } Else If (givenKey="!F10" || givenKey="F10") && (drawingShapeNow!=1)
    {
        func2Call := ["ToggleMenuBaru"]
    } Else If (givenKey="^AppsKey" || givenKey="+AppsKey") && (drawingShapeNow!=1)
    {
        func2Call := ["BuildSecondMenu", "tlbr"]
    } Else If (givenKey="#AppsKey" || givenKey="!AppsKey" || givenKey="AppsKey" || givenKey="RButton")
    {
        func2Call := ["InitGuiContextMenu", givenKey]
    } Else If (givenKey="Insert")
    {
        If (HKifs("general") && imageLoading!=1)
           func2Call := ["addNewFile2list"]
    } Else If (givenKey="^v")
    {
        If (HKifs("general") && imageLoading!=1)
           func2Call := (thumbsDisplaying=1) ? ["MenuPasteHDropFiles"] : ["PasteClipboardIMG"]
    } Else If (givenKey="Escape")
    {
        func2Call := ["dummy"]
    } Else If (givenKey="+Escape")
    {
        func2Call := ["restartAppu"]
    } Else If (givenKey="F1")
    {
        func2Call := ["showQuickHelp"]
    } Else If (givenKey="F9")
    {
       If (HKifs("imgsLoaded") && folderTreeWinOpen=1)
          func2Call := ["FolderTreeFindActiveFile"]
    } Else If (givenKey="^F4")
    {
       If (drawingShapeNow=1)
          func2Call := ["stopDrawingShape"]
       Else If AnyWindowOpen
          func2Call := ["CloseWindow"]
       Else If (thumbsDisplaying=1)
          func2Call := ["MenuReturnIMGedit"]
       Else
          func2Call := ["closeDocuments"]
    } Else If (givenKey="d")
    {
        If (HKifs("liveEdit") && liveDrawingBrushTool=1)
           func2Call := ["ResetColorsToBW"]
        Else If (HKifs("liveEdit") && AnyWindowOpen!=10)
           func2Call := ["toggleLiveEditObject"]
    } Else If (givenKey="l")
    {
        If ((HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1 || showViewPortGrid=1) && thumbsDisplaying!=1)
           func2Call := ["toggleLimitSelection"]
        Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
           func2Call := ["toggleListViewModeThumbs"]
    } Else If (givenKey="+^v")
    {
        If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
           func2Call := ["PanelPasteInPlace"]
    } Else If (givenKey="^d")
    {
        If (isImgEditingNow()=1 && drawingShapeNow=1)
           func2Call := ["MenuSelNoVectorPoints"]
        Else If (HKifs("imgsLoaded") && ((thumbsDisplaying=1) || (editingSelectionNow!=1 && markedSelectFile)))
           func2Call := ["dropFilesSelection"]
        Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
           func2Call := ["resetImgSelection"]
    } Else If (givenKey="^c")
    {
        If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
           func2Call := ["MenuExplorerCopyFiles"]
        Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
           func2Call := ["CopyImage2clip"]
    } Else If (givenKey="^x")
    {
        If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
           func2Call := ["MenuExplorerCutFiles"]
        Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
           func2Call := ["CutSelectedArea"]
    } Else If (givenKey="^z")
    {
        allowLoop := 1
        If (isImgEditingNow()=1 && drawingShapeNow=1)
           func2Call := ["ImgVectorUndoAct"]
        Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
           func2Call := ["ImgUndoAction"]
    } Else If (givenKey="z")
    {
        If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || (isImgEditingNow()=1 && drawingShapeNow=1))
          func2Call := ["ToggleImgNavBox"]
    } Else If (givenKey="^y")
    {
       allowLoop := 1
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["ImgVectorRedoAct"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["ImgRedoAction"]
    } Else If (givenKey="+^z")
    {
       allowLoop := 1
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["doUndoFileActsChronos"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["ImgSelUndoAct"]
    } Else If (givenKey="+^y")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["ImgSelRedoAct"]
    } Else If (givenKey="^!z")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuUndoImgJumpy"]
    } Else If (givenKey="^!y")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuRedoImgJumpy"]
    } Else If (givenKey="e")
    {
       If (isVarEqualTo(AnyWindowOpen, 64, 66, 12, 10) && imgEditPanelOpened=1) ; Brush, Fill and Jpeg Crop
          func2Call := ["ToggleEditImgSelection", "key"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["QuickSelectFilesSameFolder"]
       Else If (HKifs("liveEdit") && AnyWindowOpen!=10)
          func2Call := ["livePreviewsImageEditing", 1]
       Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          func2Call := ["ToggleEditImgSelection", "key"]
    } Else If (givenKey="+e")
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1 && currentFileIndex>0 && maxFilesIndex>2)
          func2Call := ["activateFilesListFilterBasedOnFolder", currentFileIndex]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuCycleSelectionShapes"]
    } Else If (givenKey="!e")
    {
       isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
       If (HKifs("imgEditSolo") || HKifs("imgsLoaded") || HKifs("liveEdit") && !isTransPanel)
          func2Call := ["PanelIMGselProperties"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["OpenQPVfileFolder"]
    } Else If (givenKey="^s")
    {
       If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          func2Call := ["PanelSaveImg"]
    } Else If (givenKey="^l")
    {
       isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
       If (HKifs("imgEditSolo") || (HKifs("liveEdit", 65) && !isTransPanel) || HKifs("imgsLoaded"))
          func2Call := ["tlbrDrawShapesContour"]
    } Else If (givenKey="+l")
    {
       If (HKifs("imgsLoaded") && (thumbsDisplaying=1))
          func2Call := ["CalculateSelectedFilesSizes"]
       Else If (HKifs("liveEdit") && EllipseSelectMode=2 && editingSelectionNow=1 && isVarEqualTo(AnyWindowOpen, 74, 68, 66, 65, 64, 55, 25, 23, 10))
          func2Call := ["MenuResumeDrawingShapes"]
       Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded")) && (thumbsDisplaying!=1)
       {
          If (editingSelectionNow!=1 || EllipseSelectMode!=2)
             func2Call := ["MenuStartDrawingSelectionArea"]
          Else
             func2Call := ["MenuResumeDrawingShapes"]
       }
    } Else If (givenKey="!BackSpace")
    {
       isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
       If (HKifs("imgEditSolo") || (HKifs("liveEdit") && !isTransPanel) || HKifs("imgsLoaded"))
          func2Call := ["tlbrFillShape"]
    } Else If (givenKey="!y")
    {
       isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
       If (HKifs("imgEditSolo") || (HKifs("liveEdit") && !isTransPanel) || HKifs("imgsLoaded"))
         func2Call := ["PanelImgAutoCrop"]
    } Else If (givenKey="y")
    {
       If ((liveDrawingBrushTool=1 || drawingShapeNow=1) && isImgEditingNow()=1)
          func2Call := ["toggleBrushSymmetryModes"]
    } Else If (givenKey="+y")
    {
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["BtnSetBrushSymmetryCoords"]
    } Else If (givenKey="i")
    {
       If (drawingShapeNow=1 && isImgEditingNow()=1)
          func2Call := ["ToggleContextStatusBar"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || (AnyWindowOpen>1 && isImgEditingNow()))
          func2Call := ["ToggleInfoBoxu"]
    } Else If (givenKey="LBRACKET")
    {
       allowLoop := 1 
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["MenuDecBrushSize"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow()=1)
          func2Call := ["MenuChangeDecBright"]
    } Else If (givenKey="RBRACKET")
    {
       allowLoop := 1 
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["MenuIncBrushSize"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow()=1)
          func2Call := ["MenuChangeIncBright"]
    } Else If (givenKey="+LBRACKET")
    {
       allowLoop := 1 
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["MenuDecBrushSoftness"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuChangeDecContrast"]
    } Else If (givenKey="+RBRACKET")
    {
       allowLoop := 1 
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["MenuIncBrushSoftness"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuChangeIncContrast"]
    } Else If (givenKey="^LBRACKET")
    {
       allowLoop := 1 
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["MenuDecBrushAngle"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuChangeDecSaturat"]
    } Else If (givenKey="^RBRACKET")
    {
       allowLoop := 1 
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["MenuIncBrushAngle"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuChangeIncSaturat"]
    } Else If (givenKey="!LBRACKET")
    {
       allowLoop := 1 
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["MenuDecBrushAspectRatio"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuChangeIncGamma"]
    } Else If (givenKey="!RBRACKET")
    {
       allowLoop := 1 
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["MenuIncBrushAspectRatio"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuChangeDecGamma"]
    } Else If (givenKey="BSLASH")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["ResetImageView"]
       Else If (HKifs("liveEdit") && (AnyWindowOpen=10 || AnyWindowOpen=74))
          func2Call := ["BtnToggleNoColorsFX"]
       Else If ((HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && vpIMGrotation!=0)
          func2Call := ["MenuResetVProtation"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["ResetImageView"]
    } Else If (givenKey="^BSLASH")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["HardResetImageView"]
       Else If (HKifs("liveEdit") && AnyWindowOpen=10)
          func2Call := ["btnResetImageView"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["HardResetImageView"]
    } Else If (givenKey="+BSLASH")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
       {
          func2Call := ["toggleColorAdjustments"]
       } Else If HKifs("liveEdit")
       {
          If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
             func2Call := ["resetSelectionAreaCavity"]
          Else
             func2Call := ["resetSelectionRotation"]
       } Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
       {
          If (innerSelectionCavityX>0 && innerSelectionCavityY>0 && editingSelectionNow=1)
             func2Call := ["resetSelectionAreaCavity"]
          Else If (editingSelectionNow=1 && VPselRotation>0)
             func2Call := ["resetSelectionRotation"]
          Else
             func2Call := ["toggleColorAdjustments"]
       }
    } Else If (givenKey="SLASH" || givenKey="NumpadDiv") ; /
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow()) && (thumbsDisplaying!=1)
          func2Call := ["MenuSetImageAdaptAll"]
    } Else If (givenKey="NumpadMult" || givenKey="^SLASH") ; Ctrl+/
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow()) && (thumbsDisplaying!=1)
          func2Call := ["toggleCustomZLmodes"]
    } Else If (givenKey="!BSLASH")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuResetSelAreaCavityRotation"]
    } Else If (givenKey="+NumpadAdd" || givenKey="+equal")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuIncSelAreaSize"]
    } Else If (givenKey="+NumpadSub" || givenKey="+minus")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuDecSelAreaSize"]
    } Else If (givenKey="!minus")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
          func2Call := ["MenuDecVPgridSize"]
    } Else If (givenKey="!equal")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
          func2Call := ["MenuIncVPgridSize"]
    } Else If (givenKey="NumpadAdd" || givenKey="equal")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
          func2Call := ["MenuChangeImgZoomPlus"]
    } Else If (givenKey="NumpadSub" || givenKey="minus")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
          func2Call := ["MenuChangeImgZoomMinus"]
    } Else If (givenKey="g")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["toggleViewPortGridu"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["ToggleImgHistogram", 1]
    } Else If (givenKey="+g")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["ToggleImgHistogram", -1]
    } Else If (givenKey="!g")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["ToggleHistogramMode"]
    } Else If (givenKey="^r")
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["PanelSimpleResizeRotate"]
       Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          func2Call := ["PanelEditorImgResize"]
    } Else If (givenKey="!r")
    {
       If (HKifs("imgEditSolo") || HKifs("imgsLoaded")) && (!AnyWindowOpen)
          func2Call := ["ResizeIMGviewportSelection"]
    } Else If (givenKey="r")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1 && bezierSplineCustomShape=1)
          func2Call := ["toggleAutoReflectAnchors"]
       Else If (HKifs("liveEdit") && (liveDrawingBrushTool=1 || AnyWindowOpen=64))
          func2Call := ["toggleBrushTypeEraser"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile)
          func2Call := ["PanelReviewSelectedFiles"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["makeSquareSelection"]
    } Else If (givenKey="+r")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuSelRotation"]
    } Else If (givenKey="+^r")
    {
       If ((HKifs("imgEditSolo") || HKifs("imgsLoaded")) && !AnyWindowOpen)
          func2Call := ["MenuRotateEditImagePlus"]
    } Else If (givenKey="^t")
    {
       If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          func2Call := ["PanelTransformSelectedArea"]
    } Else If (givenKey="+t")
    {
       isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
       If (HKifs("imgEditSolo") || (HKifs("liveEdit", 32) && !isTransPanel) || HKifs("imgsLoaded"))
          func2Call := ["PanelInsertTextArea"]
    } Else If (givenKey="+i")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["MenuSelInvertVectorPoints"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile>1)
          func2Call := ["invertFilesSelection"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["InvertSelectedArea"]
    } Else If (givenKey="^g")
    {
       isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
       If (HKifs("imgEditSolo") || (HKifs("liveEdit", 55) && !isTransPanel) || HKifs("imgsLoaded"))
          func2Call := ["PanelDesatureSelectedArea"]
    } Else If (givenKey="+b")
    {
       If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          func2Call := ["PanelBlurSelectedArea"]
    } Else If (givenKey="b")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["MenuToggleBezierMode"]
       Else If (HKifs("liveEdit") && (liveDrawingBrushTool=1 || AnyWindowOpen=64))
          func2Call := ["toggleBrushTypes"]
       Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          func2Call := ["KbdToggleImgFavourites"]
    } Else If (givenKey="^h")
    {
       If (HKifs("imgsLoaded") && maxFilesIndex>1)
          func2Call := ["PanelSearchAndReplaceIndex"]
    } Else If (givenKey="h")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["VPflipImgH"]
    } Else If (givenKey="v")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["VPflipImgV"]
    } Else If (givenKey="+h")
    {
       If (HKifs("liveEdit") && isNowAlphaPainting()=1)
          func2Call := ["FlipHalphaMask"]
       Else If (HKifs("liveEdit") && (AnyWindowOpen=31 || AnyWindowOpen=24))
          func2Call := ["FlipHtransformedIMGpanel"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["filesListFlipHimage"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
       {
          If (editingSelectionNow=1 && EllipseSelectMode=2 && AnyWindowOpen)
             func2Call := ["MenuSelectionFlipH"]
          Else
             func2Call := ["FlipSelectedAreaH"]
       }
    } Else If (givenKey="+v")
    {
       If (HKifs("liveEdit") && isNowAlphaPainting()=1)
          func2Call := ["FlipValphaMask"]
       Else If (HKifs("liveEdit") && (AnyWindowOpen=31 || AnyWindowOpen=24))
          func2Call := ["FlipVtransformedIMGpanel"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["filesListFlipVimage"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
       {
          If (editingSelectionNow=1 && EllipseSelectMode=2 && AnyWindowOpen)
             func2Call := ["MenuSelectionFlipV"]
          Else
             func2Call := ["FlipSelectedAreaV"]
       }
    } Else If (givenKey="u")
    {
       If (HKifs("liveEdit") && (AnyWindowOpen=31 || AnyWindowOpen=24))
          func2Call := ["togglePasteInPlaceColorsFX"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying=1 && thumbsListViewMode=1)
          func2Call := ["PanelSetThumbColumnOptions"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["PanelAdjustColorsSimpleWindow"]
    } Else If (givenKey="+u")
    {
       isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["filesListApplyColors"]
       Else If (HKifs("imgEditSolo") || (HKifs("liveEdit") && !isTransPanel) || HKifs("imgsLoaded"))
          func2Call := ["PanelColorsAdjusterWindow"]
    } Else If (givenKey="+^u")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["ApplyVPcolorAdjustSelectedArea"]
    } Else If (givenKey="f")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
          func2Call := ["ToggleImgFX", 1]
    } Else If (givenKey="+f")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || drawingShapeNow=1 && isImgEditingNow())
          func2Call := ["ToggleImgFX", -1]
    } Else If (givenKey="+q")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (liveDrawingBrushTool!=1)
          func2Call := ["ToggleImgColorDepth", -1]
    } Else If (givenKey="q")
    {
       isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
       If (HKifs("liveEdit") && (liveDrawingBrushTool=1 || AnyWindowOpen=64) && !isTransPanel)
          func2Call := ["toggleBrushTypeFX"]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["ToggleImgColorDepth", 1]
       Else If (isImgEditingNow() && drawingShapeNow=1)
          func2Call := ["MenuCycleVectToolMode"]
    } Else If (givenKey="Delete")
    {
       isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["MenuRemSelVectorPoints"]
       Else If ((HKifs("imgEditSolo") || HKifs("liveEdit", 25) || HKifs("imgsLoaded")) && thumbsDisplaying!=1 && editingSelectionNow=1 && !isTransPanel)
          func2Call := ["PanelEraseSelectedArea"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying!=1)
          func2Call := ["DeleteActivePicture"]
       Else If HKifs("imgsLoaded")
          func2Call := ["DeletePicture"]
    } Else If (givenKey="!Delete")
    {
       If (HKifs("imgsLoaded") && maxFilesIndex>1 && currentFileIndex>0)
          func2Call := ["singleInListEntriesRemover"]
    } Else If (givenKey="+Delete")
    {
       If HKifs("imgsLoaded")
          func2Call := ["DeleteActiveImgFileAndEntry"]
    } Else If (givenKey="^Delete")
    {
       If HKifs("imgsLoaded")
          func2Call := ["DeleteActivePicture"]
    } Else If (givenKey="a")
    {
       If HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || (AnyWindowOpen>1) || (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["ToggleIMGalign"]
    } Else If (givenKey="+a")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["toggleImgSelectionAspectRatio"]
    } Else If (givenKey="+^a")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["toggleImgSelectLockedRatio"]
    } Else If (givenKey="!a")
    {
       If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
          func2Call := ["PanelAdjustImageCanvasSize"]
    } Else If (givenKey="^a")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["tlbrSelAllVectorPoints"]
       Else If HKifs("liveEdit")
          func2Call := ["selectEntireImage"]
       Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
       {
          If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
             func2Call := ["selectAllFiles"]
          Else
             func2Call := ["selectEntireImage"]
       }
    } Else If (givenKey="+9")
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
       {
          func2Call := ["filesListFlipRotateMinus"]
       } Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1)
       {
          allowLoop := 1
          func2Call := ["MenuSelDecRotation"]
       }
    } Else If (givenKey="8")
    {
       allowLoop := 1
       If (HKifs("liveEdit") && liveDrawingBrushTool=1)
          func2Call := ["changeBrushOpacity", givenKey, 1]
    } Else If (givenKey="9")
    {
       allowLoop := 1
       If (HKifs("liveEdit") && liveDrawingBrushTool=1)
          func2Call := ["changeBrushOpacity", givenKey, 1]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuDecVProtation"]
    } Else If (givenKey="!9")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["changeLittleImgRotationInVP", -1]
    } Else If (givenKey="+00.1")
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
       {
          func2Call := ["filesListFlipRotatePlus"]
       } Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (editingSelectionNow=1)
       {
          allowLoop := 1
          func2Call := ["MenuSelIncRotation"]
       }
    } Else If (givenKey="00.1")
    {
       allowLoop := 1
       If (HKifs("liveEdit") && liveDrawingBrushTool=1)
          func2Call := ["changeBrushOpacity", givenKey, 1]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["MenuIncVProtation"]
    } Else If (givenKey="!00.1")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["changeLittleImgRotationInVP", 1]
    } Else If (givenKey="Up" || givenKey="+Up")
    {
       okayu := (thumbsDisplaying=1 || undoLevelsRecorded<2 || currentImgModified!=1) ? 1 : 0
       If ((isImgEditingNow()=1 && drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
          func2Call := ["PanIMGonScreen", "U", givenKey]
       Else If (HKifs("imgsLoaded") && okayu=1)
          func2Call := ["ThumbsNavigator", "Upu", givenKey]
    } Else If (givenKey="Down" || givenKey="+Down")
    {
       okayu := (thumbsDisplaying=1 || undoLevelsRecorded<2 || currentImgModified!=1) ? 1 : 0
       If ((isImgEditingNow()=1 && drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
          func2Call := ["PanIMGonScreen", "D", givenKey]
       Else If (HKifs("imgsLoaded") && okayu=1)
          func2Call := ["ThumbsNavigator", "Down", givenKey]
    } Else If (givenKey="^WheelUp")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["VPchangeZoom", 1, "WheelUp"]
    } Else If (givenKey="^WheelDown")
    {
       allowLoop := 1
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["VPchangeZoom", -1, "WheelDown"]
    } Else If (givenKey="!Left")
    {
       allowLoop := 1
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["arrowKeysAdjustPrevPointPath", -1, 1]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["arrowKeysAdjustSelectionArea", -1, 1]
    } Else If (givenKey="!Right")
    {
       allowLoop := 1
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["arrowKeysAdjustPrevPointPath", 1, 1]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["arrowKeysAdjustSelectionArea", 1, 1]
    } Else If (givenKey="!Up")
    {
       allowLoop := 1
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["arrowKeysAdjustPrevPointPath", -2, 1]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["arrowKeysAdjustSelectionArea", -2, 1]
    } Else If (givenKey="!Down")
    {
       allowLoop := 1
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["arrowKeysAdjustPrevPointPath", 2, 1]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["arrowKeysAdjustSelectionArea", 2, 1]
    } Else If (givenKey="+!Left")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["arrowKeysAdjustPrevPointPath", -1, 2]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["arrowKeysAdjustSelectionArea", -1, 2]
    } Else If (givenKey="+!Right")
    {
       allowLoop := 1
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["arrowKeysAdjustPrevPointPath", 1, 2]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["arrowKeysAdjustSelectionArea", 1, 2]
    } Else If (givenKey="+!Up")
    {
       allowLoop := 1
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["arrowKeysAdjustPrevPointPath", -2, 2]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["arrowKeysAdjustSelectionArea", -2, 2]
    } Else If (givenKey="+!Down")
    {
       allowLoop := 1
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["arrowKeysAdjustPrevPointPath", 2, 2]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          func2Call := ["arrowKeysAdjustSelectionArea", 2, 2]
    } Else If (givenKey="F8")
    {
       If HKifs("general")
          func2Call := ["openPreviousPanel"]
    } Else If (givenKey="Space")
    {
       If (HKifs("imgsLoaded") && drawingShapeNow!=1)
       {
          If ((thumbsDisplaying=1 || markedSelectFile) && slideShowRunning!=1)
             func2Call := ["markThisFileNow"]
          Else If (slideShowRunning=1)
             func2Call := ["dummyInfoToggleSlideShowu", "stop"]
          Else If (A_TickCount - lastOtherWinClose>350) && (A_TickCount - prevSlideShowStop>950) ; && (drawingShapeNow!=1)
             func2Call := ["MenuGoPlaySlidesNow"]
       } Else if (!CurrentSLD && !maxFilesIndex && !validBMP(UserMemBMP))
          func2Call := ["toggleScreenSaverMode"]
    } Else If (givenKey="+n")
    {
       If HKifs("imgsLoaded")
          func2Call := ["PanelEditImgCaption"]
    } Else If (givenKey="n")
    {
       If (HKifs("liveEdit") && (isAlphaMaskWindow()=1 || isAlphaMaskPartialWin()=1))
          func2Call := ["toggleInvertAlphaMask"]
       Else If HKifs("imgsLoaded")
          func2Call := ["ToggleImgCaptions"]
    } Else If (SubStr(givenKey, 1, 1)="^" && isInRange(SubStr(givenKey, 2, 1), 0, 8))
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
       {
          If (givenKey="^1")
             func2Call := ["ActSortName"]
          Else If (givenKey="^2")
             func2Call := ["ActSortPath"]
          Else If (givenKey="^3")
             func2Call := ["ActSortFileName"]
          Else If (givenKey="^4")
             func2Call := ["ActSortSize"]
          Else If (givenKey="^5")
             func2Call := ["ActSortModified"]
          Else If (givenKey="^6")
             func2Call := ["ActSortCreated"]
          Else If (givenKey="^7")
             func2Call := ["PanelResolutionSorting"]
          Else If (givenKey="^8")
             func2Call := ["PanelHistogramSorting"]
          Else If (givenKey="^00.1")
             func2Call := ["ReverseListNow"]
       }
    } Else If (givenKey="j")
    {
       If (liveDrawingBrushTool=1 || AnyWindowOpen=64) && HKifs("liveEdit")
          func2Call := ["toggleBrushTypeCloner"]
       Else If HKifs("imgsLoaded")
          func2Call := ["PanelJump2index"]
    } Else If (givenKey="+Insert")
    {
       If HKifs("imgsLoaded")
          func2Call := ["addNewFolder2list"]
    } Else If (givenKey="Tab")
    {
        func2Call := ["mainWinTabResponse"]
    } Else If (givenKey="+Tab")
    {
       If (ShowAdvToolbar=1 && hQPVtoolbar)
          func2Call := ["focusToolbarNavKeys"]
    } Else If (givenKey="^Tab")
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1 && markedSelectFile>1)
          func2Call := ["filterToFilesSelection"]
    } Else If (givenKey="F11")
    {
       If HKifs("liveEdit")
          func2Call := ["toggleImgEditPanelWindow"]
       Else If !AnyWindowOpen
          func2Call := ["ToggleFullScreenMode"]
    } Else If (givenKey="+Enter")
    {
       If HKifs("liveEdit")
          func2Call := ["applyIMGeditKeepWin"]
       Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded")) && (!AnyWindowOpen)
          func2Call := ["CropImageInViewPortToSelection"]
    } Else If (givenKey="^Enter")
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["OpenWithNewQPVinstance"]
       Else If HKifs("imgsLoaded")
          func2Call := ["SoloNewQPVinstance"]
    } Else If (givenKey="Enter")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["stopDrawingShape"]
       Else If HKifs("liveEdit")
          func2Call := ["applyIMGeditFunction"]
       Else If (HKifs("imgsLoaded") && (A_TickCount - lastOtherWinClose>250))
          func2Call := ["ToggleThumbsMode"]
    } Else If (givenKey="!Enter")
    {
       If HKifs("imgsLoaded")
          func2Call := ["PanelImageInfos"]
    } Else If (givenKey="c")
    {
       If HKifs("liveEdit")
          func2Call := ["changeBrushColorPicker"]
       Else If HKifs("imgsLoaded")
          func2Call := ["InvokeCopyFiles"]
    } Else If (givenKey="^u")
    {
       If HKifs("imgsLoaded")
          func2Call := ["PanelStaticFolderzManager"]
    } Else If (givenKey="!u")
    {
        If !AnyWindowOpen
           func2Call := ["PanelDynamicFolderzWindow"]
    } Else If (givenKey="^k")
    {
       If (HKifs("liveEdit") && (AnyWindowOpen=64 || AnyWindowOpen=66 || isAlphaMaskWindow()=1))
          func2Call := ["toggleAlphaPaintingMode"]
       Else If HKifs("imgsLoaded")
          func2Call := ["PanelFileFormatConverter"]
    } Else If (givenKey="k")
    {
       If (HKifs("imgsLoaded") || HKifs("liveEdit") || HKifs("imgEditSolo"))
          func2Call := ["PanelFloodFillTool"]
    } Else If (givenKey="+k")
    {
       If (imgEditPanelOpened=1 && liveDrawingBrushTool=1 || AnyWindowOpen=64 || AnyWindowOpen=66)
          func2Call := ["toggleBrushDrawInOutModes"]
    } Else If (givenKey="+j")
    {
       If (HKifs("imgsLoaded") && !AnyWindowOpen)
       {
          If (RegExMatch(getIDimage(currentFileIndex), "i)(.\.(jpg|jpeg))$") || markedSelectFile)
             func2Call := ["PanelJpegPerformOperation"]
       }
    } Else If (givenKey="+c")
    {
       If (HKifs("liveEdit") && (AnyWindowOpen=31 || AnyWindowOpen=24))
          func2Call := ["togglePasteInPlaceCropShapes"]
       Else If HKifs("imgsLoaded")
          func2Call := ["CopyImagePath"]
    } Else If (givenKey="^e")
    {
       If HKifs("imgsLoaded")
          func2Call := ["OpenThisFileFolder"]
    } Else If (givenKey="^f")
    {
       If HKifs("imgsLoaded")
          func2Call := ["PanelEnableFilesFilter"]
    } Else If (givenKey="s")
    {
       If (drawingShapeNow=1 && isImgEditingNow())
          func2Call := ["toggleVectorSelectMmde"]
       Else If (HKifs("liveEdit"))
       {
          If (AnyWindowOpen=31 || AnyWindowOpen=24)
             func2Call := ["togglePasteInPlaceAdaptModes"]
          Else If (AnyWindowOpen=64 && BrushToolType=3 && liveDrawingBrushTool=1)
             func2Call := ["BtnSetClonerBrushSource"]
          Else If (AnyWindowOpen=23 && FillAreaColorMode=6)
             func2Call := ["BtnSetTextureSource"]
       } Else If HKifs("imgsLoaded")
       {
          If (thumbsDisplaying=1)
             func2Call := ["keepSelectedDupeInGroup"]
          Else
             func2Call := ["ToggleSlideshowModes"]
       }
    } Else If (givenKey="+s")
    {
       If (HKifs("liveEdit") && liveDrawingBrushTool=1)
          func2Call := ["toggleBrushDoubleSize"]
       Else If (HKifs("imgsLoaded") && mustRecordSeenImgs=1 && thumbsDisplaying=1)
          func2Call := ["ToggleSeenIMGstatus"]
    } Else If (givenKey="+^s")
    {
       If HKifs("imgsLoaded")
          func2Call := ["PanelSaveSlideShowu"]
    } Else If (givenKey="T")
    {
       If (liveDrawingBrushTool=1 && isImgEditingNow()=1)
          func2Call := ["toggleBrushAirMode"]
       Else If (isImgEditingNow()=1 && drawingShapeNow=1)
          func2Call := ["togglePathCurveTension"]
       Else If (HKifs("imgsLoaded") || HKifs("liveEdit"))
          func2Call := ["ToggleImageSizingMode"]
    } Else If (givenKey="+Space")
    {
       If HKifs("imgsLoaded")
       {
          If (thumbsDisplaying=1)
             func2Call := ["dropFilesSelection"]
          Else If (slideShowRunning=1)
             func2Call := ["dummyInfoToggleSlideShowu", "stop"]
          Else If (A_TickCount - prevSlideShowStop>950)
             func2Call := ["MenuGoPlaySlidesNow"]
       }
    } Else If (givenKey="^Space")
    {
       If HKifs("imgsLoaded")
       {
          If (slideShowRunning=1)
             func2Call := ["dummyInfoToggleSlideShowu", "stop"]
          Else If StrLen(filesFilter)>1
             func2Call := ["MenuRemFilesListFilter"]
       }
    } Else If (givenKey="BackSpace")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
         func2Call := ["reduceCustomShapeLength"]
       Else If (HKifs("liveEdit") && (AnyWindowOpen=31 || AnyWindowOpen=24))
         func2Call := ["toggleErasePasteInPlace"]
       Else If HKifs("imgsLoaded")
         func2Call := ["PrevRandyPicture", "key"]
    } Else If (givenKey="+BackSpace")
    {
       If HKifs("imgsLoaded")
          func2Call := ["RandomPicture", "key"]
    } Else If (givenKey="^Backspace")
    {
       If HKifs("imgsLoaded")
          func2Call := ["jumpPreviousImage"]
    } Else If (givenKey="!period")
    {
       allowLoop := 1
       If (HKifs("imgsLoaded") && animGIFsSupport=1)
          func2Call := ["MenuIncGIFspeed"]
    } Else If (givenKey="+period")
    {
       allowLoop := 1
       If (liveDrawingBrushTool=1)
          func2Call := ["MenuIncBrushWetness"]
       Else
          func2Call := ["MenuSetVolumeUp"]
    } Else If (givenKey="^period")
    {
       func2Call := ["MenuIncSelAreaCavity"]
    } Else If (givenKey="^comma")
    {
       func2Call := ["MenuDecSelAreaCavity"]
    } Else If (givenKey="period")
    {
       allowLoop := 1
       If (liveDrawingBrushTool=1)
          func2Call := ["MenuDecBrushOpacity"]
       Else If HKifs("imgsLoaded")
          func2Call := ["IncreaseSlideSpeed"]
    } Else If (givenKey="comma")
    {
       allowLoop := 1
       If (liveDrawingBrushTool=1)
          func2Call := ["MenuIncBrushOpacity"]
       Else If HKifs("imgsLoaded")
          func2Call := ["DecreaseSlideSpeed"]
    } Else If (givenKey="!comma")
    {
       allowLoop := 1
       If (HKifs("imgsLoaded") && animGIFsSupport=1)
          func2Call := ["MenuDecGIFspeed"]
    } Else If (givenKey="+comma")
    {
       allowLoop := 1
       If (liveDrawingBrushTool=1)
          func2Call := ["MenuDecBrushWetness"]
       Else
          func2Call := ["MenuSetVolumeDown"]
    } Else If (givenKey="+SLASH") ; Shift+/
    {
       If HKifs("imgsLoaded")
          func2Call := ["PanelDefineEntireSlideshowLength"]
    } Else If (givenKey="F5")
    {
       If HKifs("imgsLoaded") || (liveDrawingBrushTool=1 && AnyWindowOpen=64)
          func2Call := ["RefreshImageFileAction"]
    } Else If (givenKey="!F5")
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["DeepRefreshThumbsNow"]
    } Else If (givenKey="+F5")
    {
       If HKifs("imgsLoaded")
          func2Call := ["RefreshFilesList"]
    } Else If (givenKey="^F5")
    {
       If HKifs("imgsLoaded")
          func2Call := ["invertCurrentFolderRecursiveness"]
    } Else If (givenKey="F2")
    {
       If HKifs("imgsLoaded")
          func2Call := ["PanelRenameThisFile"]
    } Else If (givenKey="+F2")
    {
       If HKifs("imgsLoaded")
          func2Call := ["SingularRenameFile"]
    } Else If (givenKey="^F2")
    {
       If HKifs("imgsLoaded")
          func2Call := ["PanelUpdateThisFileIndex"]
    } Else If (givenKey="m")
    {
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && ((editingSelectionNow=1 || AnyWindowOpen=66) && thumbsDisplaying!=1 && AnyWindowOpen!=70)
          func2Call := ["ViewAlphaMaskNow"]
       Else If HKifs("imgsLoaded")
          func2Call := ["PanelMoveCopyFiles"]
    } Else If (givenKey="x")
    {
       If HKifs("liveEdit")
       {
          func2Call := ["ToggleBrushColors"]
       } Else If HKifs("imgsLoaded")
       {
          If (animGIFplaying=1)
             func2Call := ["DestroyGIFuWin"]
          Else If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0)
             func2Call := ["moveMarkedEntryNow", currentFileIndex]
          Else
             func2Call := ["PlayAudioFileAssociatedNow"]
       }
    } Else If (givenKey="+x")
    {
       If HKifs("imgsLoaded")
       {
          If (animGIFplaying=1)
             func2Call := ["DestroyGIFuWin"]
          Else If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0 && markedSelectFile>1)
             func2Call := ["regroupSelectedFiles"]
          Else If (thumbsDisplaying=1 && maxFilesIndex>1 && currentFileIndex>0)
             func2Call := ["moveMarkedEntryNow", currentFileIndex, "move"]
          Else
             func2Call := ["StopMediaPlaying"]
       }
    } Else If ((isInRange(givenKey, 1, 7) && isNumber(givenKey))
           || (SubStr(givenKey, 1, 1)="+" && isInRange(SubStr(givenKey, 2, 1), 1, 7)))
    {
       If (HKifs("liveEdit") && liveDrawingBrushTool=1)
       {
          allowLoop := 1
          func2Call := ["changeBrushOpacity", givenKey, 1]
       } Else If (HKifs("imgsLoaded") && !InStr(givenKey, "8"))
          func2Call := ["triggerQuickFileAction", givenKey]
    } Else If (givenKey="^Left")
    {
       If HKifs("imgsLoaded")
          func2Call := ["navSelectedFiles", -1]
    } Else If (givenKey="^Right")
    {
       If HKifs("imgsLoaded")
          func2Call := ["navSelectedFiles", 1]
    } Else If (givenKey="F3")
    {
       If HKifs("imgsLoaded")
          func2Call := ["MenuSearchNextIndex"]
    } Else If (givenKey="+F3")
    {
       If HKifs("imgsLoaded")
          func2Call := ["MenuSearchPrevIndex"]
    } Else If (givenKey="^F3")
    {
       If HKifs("imgsLoaded")
          func2Call := ["PanelSearchIndex"]
    } Else If (givenKey="F4")
    {
       If !AnyWindowOpen
          func2Call := ["PanelFoldersTree"]
    } Else If (givenKey="+F4")
    {
       If HKifs("imgsLoaded")
          func2Call := ["invokeFoldersListerMenu"]
    } Else If (givenKey="WheelUp")
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["ThumbsNavigator", "Upu", givenKey]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || isImgEditingNow()=1 && drawingShapeNow=1) && (IMGresizingMode=4 && thumbsDisplaying!=1)
          func2Call := ["VPchangeZoom", 1, "WheelUp"]
       Else If (HKifs("imgsLoaded"))
          func2Call := ["PreviousPicture", "key-" givenKey]
    } Else If (givenKey="WheelDown")
    {
       If (HKifs("imgsLoaded") && thumbsDisplaying=1)
          func2Call := ["ThumbsNavigator", "Down", givenKey]
       Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded") || isImgEditingNow()=1 && drawingShapeNow=1) && (IMGresizingMode=4 && thumbsDisplaying!=1)
          func2Call := ["VPchangeZoom", -1, "WheelDown"]
       Else If (HKifs("imgsLoaded"))
          func2Call := ["NextPicture", "key-" givenKey]
    } Else If (givenKey="Right" || givenKey="+Right")
    {
       If HKifs("imgsLoaded")
       {
          If ((IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
          {
             func2Call := ["PanIMGonScreen", "R", givenKey]
          } Else
          {
             okayu := (thumbsDisplaying=1 || undoLevelsRecorded<2 || currentImgModified!=1) ? 1 : 0
             func2Call := ["resetSlideshowTimer"]
             If (thumbsDisplaying=1)
                func2Call := ["ThumbsNavigator", "Right", givenKey]
             Else If (okayu=1)
                func2Call := ["NextPicture", "key-" givenKey]
         }
       } Else If ((isImgEditingNow()=1 && drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
         func2Call := ["PanIMGonScreen", "R", givenKey]
    } Else If (givenKey="Left" || givenKey="+Left")
    {
       If HKifs("imgsLoaded")
       {
          If ((IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
          {
             func2Call := ["PanIMGonScreen", "L", givenKey]
          } Else
          {
             okayu := (thumbsDisplaying=1 || undoLevelsRecorded<2 || currentImgModified!=1) ? 1 : 0
             func2Call := ["resetSlideshowTimer"]
             If (thumbsDisplaying=1)
                func2Call := ["ThumbsNavigator", "Left", givenKey]
             Else If (okayu=1)
                func2Call := ["PreviousPicture", "key-" givenKey]
         }
       } Else If ((isImgEditingNow()=1 && drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && thumbsDisplaying=0)
         func2Call := ["PanIMGonScreen", "L", givenKey]
    } Else If (givenKey="PgDn")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
       {
          allowLoop := 1
          func2Call := ["adjustCustomShapePositionLive", -1]
       } Else If (HKifs("liveEdit") && editingSelectionNow=1)
       {
          allowLoop := 1
          func2Call := ["MenuSelAreaMoveLeft"]
       } Else If HKifs("imgsLoaded")
       {
          func2Call := ["resetSlideshowTimer"]
          If (thumbsDisplaying=1)
          {
             allowLoop := 1
             func2Call := ["ThumbsNavigator", "PgDn", givenKey]
          } Else func2Call := ["NextPicture"]
       }
    } Else If (givenKey="PgUp")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
       {
          allowLoop := 1
          func2Call := ["adjustCustomShapePositionLive", 1]
       } Else If (HKifs("liveEdit") && editingSelectionNow=1)
       {
          allowLoop := 1
          func2Call := ["MenuSelAreaMoveRight"]
       } Else If HKifs("imgsLoaded")
       {
          func2Call := ["resetSlideshowTimer"]
          If (thumbsDisplaying=1)
          {
             allowLoop := 1
             func2Call := ["ThumbsNavigator", "PgUp", givenKey]
          } Else func2Call := ["PreviousPicture"]
       }
    } Else If (givenKey="+PgDn")
    {
       If HKifs("imgsLoaded")
       {
          func2Call := ["resetSlideshowTimer"]
          If (thumbsDisplaying=1)
          {
             allowLoop := 1
             func2Call := ["ThumbsNavigator", "PgDn", givenKey]
          } Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
             func2Call := ["MenuNextDesiredFrame"]
       }
    } Else If (givenKey="+PgUp")
    {
       If HKifs("imgsLoaded")
       {
          func2Call := ["resetSlideshowTimer"]
          If (thumbsDisplaying=1)
          {
             allowLoop := 1
             func2Call := ["ThumbsNavigator", "PgUp", givenKey]
          } Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
             func2Call := ["MenuPrevDesiredFrame"]
       }
    } Else If (givenKey="^PgUp")
    {
       allowLoop := 1
       If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
          func2Call := ["FileExploreUpDownLevel", -1]
    } Else If (givenKey="^PgDn")
    {
       allowLoop := 1
       If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
          func2Call := ["FileExploreUpDownLevel", 1]
    } Else If (givenKey="!PgUp")
    {
       allowLoop := 1
       If ((HKifs("imgEditSolo") || HKifs("imgsLoaded")) && editingSelectionNow=1 && thumbsDisplaying!=1)
          func2Call := ["MenuSelAreaMoveRight"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
          func2Call := ["FileExploreSiblingsNav", -1]
    } Else If (givenKey="!PgDn")
    {
       allowLoop := 1
       If ((HKifs("imgEditSolo") || HKifs("imgsLoaded")) && editingSelectionNow=1 && thumbsDisplaying!=1)
          func2Call := ["MenuSelAreaMoveLeft"]
       Else If (HKifs("imgsLoaded") && thumbsDisplaying=1 && SLDtypeLoaded=1)
          func2Call := ["FileExploreSiblingsNav", 1]
    } Else If (givenKey="^Home")
    {
       If HKifs("imgsLoaded")
          func2Call := ["jumpToFilesSelBorder", -1]
    } Else If (givenKey="^End")
    {
       If HKifs("imgsLoaded")
          func2Call := ["jumpToFilesSelBorder", 1]
    } Else If (givenKey="!End")
    {
       If ((HKifs("imgEditSolo") || HKifs("imgsLoaded")) && editingSelectionNow=1 && thumbsDisplaying!=1)
          func2Call := ["MenuSelAreaMoveDown"]
    } Else If (givenKey="!Home")
    {
       If ((HKifs("imgEditSolo") || HKifs("imgsLoaded")) && editingSelectionNow=1 && thumbsDisplaying!=1)
          func2Call := ["MenuSelAreaMoveUp"]
    } Else If (givenKey="Home" || givenKey="+Home")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
       {
          allowLoop := 1
          func2Call := ["adjustCustomShapePositionLive", 2]
       } Else If (HKifs("liveEdit") && editingSelectionNow=1)
       {
          allowLoop := 1
          func2Call := ["MenuSelAreaMoveUp"]
       } Else If HKifs("imgsLoaded")
       {
          If (thumbsDisplaying=1)
          {
             allowLoop := 1
             func2Call := ["ThumbsNavigator", "Home", givenKey]
          } Else func2Call := ["FirstPicture"]
       }
    } Else If (givenKey="End" || givenKey="+End")
    {
       If (isImgEditingNow()=1 && drawingShapeNow=1)
       {
          allowLoop := 1
          func2Call := ["adjustCustomShapePositionLive", -2]
       } Else If (HKifs("liveEdit") && editingSelectionNow=1)
       {
          allowLoop := 1
          func2Call := ["MenuSelAreaMoveDown"]
       } Else If HKifs("imgsLoaded")
       {
          If (thumbsDisplaying=1)
          {
             allowLoop := 1
             func2Call := ["ThumbsNavigator", "End", givenKey]
          } Else func2Call := ["LastPicture"]
      }
    }

    If (simulacrum=1)
       Return func2Call

    c := defineKBDcontexts(0) "." func2Call[1]
    If (SubStr(userCustomKeysDefined[c, 1], 1, 1)="?")
       func2Call := ""

    If IsFunc(func2Call[1])
    {
       fn := func2Call[1]
       If (func2Call.Count()=1)
          %fn%()
       Else If (func2Call.Count()=2)
          %fn%(func2Call[2])
       Else If (func2Call.Count()=3)
          %fn%(func2Call[2], func2Call[3])
       Else If (func2Call.Count()=4)
          %fn%(func2Call[2], func2Call[3], func2Call[4])
       Else
          r := 1
    } Else If (Strlen(func2Call[1])>1)
       r := func2Call[1]
    Else
       Return 0

    If (r=1)
       simpleMsgBoxWrapper(appTitle ": ERROR", "An error occured calling " fn "() for " givenKey ". Too many parameters.")
    Else If r
       simpleMsgBoxWrapper(appTitle ": ERROR", "An error occured calling " r "() function for " givenKey ".")

    Return r ? -1 : allowLoop + 1
} ; // processDefaultKbdCombos

;____________ Functions __________________

initQPVmainDLL(modus:=0) {
   Static attempts := 0

   If (qpvMainDll || attempts>2)
      Return

   If (wasInitFIMlib!=1 && FIMfailed2init!=1)
      initFIMGmodule()

   attempts++
   DllPath := FreeImage_FoxGetDllPath(whichMainDLL, mainExecPath)
   ; addJournalEntry("INIT main QPV initial DllPath: " DllPath)
   If !DllPath
   {
      addJournalEntry("ERROR: Failed to find qpvMain.dll. Various features in QPV will not work.")
      Return
   }

   Static srcDll := "e:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\qpv-main\x64\Release\qpvmain.dll"
   If (A_PtrSize=8 && InStr(A_ScriptDir, "sucan twins") && !A_IsCompiled && FileExist(srcDll))
      DllPath := srcDll

   qpvMainDll := DllCall("LoadLibraryW", "WStr", DllPath, "UPtr")
   addJournalEntry("INIT main QPV dll: " A_LastError "==" qpvMainDll "==" DllPath)
   If !qpvMainDll
   {
      addJournalEntry("ERROR: Failed to initialize qpvMain.dll. Various features in QPV will not work.")
      Return
   }

   If (modus!=1)
      disableWindowPenServices(PVhwnd)

   dupesDCTcoeffsInit := DllCall(whichMainDLL "\calculateDCTcoeffs", "int", 32)
   If !dupesDCTcoeffsInit
      addJournalEntry("ERROR: Failed to initialize DCT coefficients required for identifying image duplicates. This feature will not work.")

   WICmoduleHasInit := DllCall(whichMainDLL "\initWICnow", "int", debugModa, "int", 0)
   ; MsgBox, % r "=" WICmoduleHasInit
   If WICmoduleHasInit
   {
      CLSIDlist := ""
      extensionsList := ""
      Loop, Reg, HKEY_CLASSES_ROOT\CLSID\{7ED96837-96F0-4812-B211-F13C24117ED3}\Instance, KVR
      {
         If (InStr(A_LoopRegName, "{") && InStr(A_LoopRegName, "}") && ST_Count(A_LoopRegName, "-")>2)
            CLSIDlist .= A_LoopRegName "`n"
      }

      Sort, CLSIDlist, UD`n
      Loop, Parse, CLSIDlist, `n
      {
         If !A_LoopField
            Continue

         Loop, Reg, HKEY_CLASSES_ROOT\CLSID\%A_loopField%, KV
         {
            RegRead, value
            If InStr(A_LoopRegName, "FileExtension")
               extensionsList .= Trimmer(value) ","
         }
      }

      extensionsList := StrReplace(extensionsList, ",", "|")
      extensionsList := StrReplace(extensionsList, ".", "|")
      extensionsList := StrReplace(extensionsList, "||", "|")
      Sort, extensionsList, UD|
      extensionsList := Trimmer(extensionsList, "|")
      RegExWICfmtPtrn := StrReplace(RegExWICfmtPtrn, "place-holder", extensionsList)
      RegExAllFilesPattern := StrReplace(RegExAllFilesPattern, "|dib|", "|" extensionsList "|")
      Sort, RegExAllFilesPattern, UD|
      extensionsList := Trimmer(RegExAllFilesPattern, "|")
      RegExFilesPattern := "i)^(.\:\\).*(\.(" RegExAllFilesPattern "))$"
      ; interfaceThread.ahkassign("RegExFilesPattern", RegExFilesPattern)
      allFormats := "*.jpeg;*.ico;" openFptrn3 openFptrn1 openFptrn2 openFptrn4 ";"
      Loop, Parse, extensionsList, |
      {
         If !InStr(allFormats, "*." A_LoopField ";")
            openFptrnWIC .= "*." A_LoopField ";"
      }
      openFptrnWIC := Trimmer(openFptrnWIC, ";")
      fnOutputDebug("WIC init formats: " openFptrnWIC)
   } Else addJournalEntry("ERROR: Failed to initialize WIC module. Some image formats may not be supported.")

   ; interfaceThread.ahkassign("RegExFilesPattern", RegExFilesPattern)
   RegWrite, REG_SZ, %QPVregEntry%, RegExFilesPattern, % RegExFilesPattern
   ; MsgBox, % WICmoduleHasInit "==" CLSIDlist "`n" extensionsList
   ; ToolTip, % WICmoduleHasInit " | " A_LastError "==" qpvMainDll "`n" DllPath , , , 2
}

initializeAppWithGivenArguments() {
   thisCounter := folderOpened := sldOpened := doWelcomeNow := 0
   disCount := A_Args.Count()
   Loop, % disCount
   {
      If (A_Index>=950)
      {
         doWelcomeNow := 1
         Break
      } Else If (RegExMatch(A_Args[A_Index], sldsPattern) && RegExMatch(A_Args[A_Index], "i)^(.\:\\..*)") && !sldOpened)
      {
         If FileExist(A_Args[A_Index])
            sldOpened := A_Args[A_Index]
      } Else If (RegExMatch(A_Args[A_Index], "i)^(fd\=\|?.\:\\..*)") && !folderOpened)
      {
         paramSet := SubStr(A_Args[A_Index], 4)
         If FolderExist(StrReplace(paramSet, "|"))
            folderOpened := paramSet
      } Else If (RegExMatch(A_Args[A_Index], RegExFilesPattern) && !folderOpened && !sldOpened)
      {
         filesListu .= A_Args[A_Index] "`n"
         thisCounter++
      } Else If RegExMatch(A_Args[A_Index], "i)^(.?qpv-debug)")
      {
         debugModa := 1
      } Else If RegExMatch(A_Args[A_Index], "i)^(set\_..*\=..*)")
      {
         paramSet := SubStr(A_Args[A_Index], 5, InStr(A_Args[A_Index], "=") - 5)
         paramSetValue := SubStr(A_Args[A_Index], InStr(A_Args[A_Index], "=") + 1)
         If (paramSet && paramSetValue!="")
            %paramSet% := paramSetValue
      } Else If RegExMatch(A_Args[A_Index], "i)^(call\_..*\(\))")
      {
         func2exec := SubStr(A_Args[A_Index], 6, InStr(A_Args[A_Index], "(") - 6)
         If (IsFunc(func2exec)=1 && StrLen(func2exec)>2)
            delayedfunc2exec := func2exec
      }
   }
   ; ToolTip, % "l=" disCount , , , 2
   If sldOpened
   {
      OpenSLD(sldOpened)
   } Else If folderOpened
   {
      If InStr(folderOpened, "|")
         tryOpenGivenFolder(folderOpened, 0)
      Else
         OpenFolders(folderOpened)
   } Else If (thisCounter=1 && !sldOpened && !folderOpened)
      OpenArgFile(Trimmer(filesListu))
   Else If (thisCounter>1 && !sldOpened && !folderOpened)
      GuiDroppedFiles(filesListu, nona, none, thisCounter, 0)
   Else Return 1

   If delayedfunc2exec
      SetTimer, runDelayedfunc2exec, -950

   Return doWelcomeNow
}

runDelayedfunc2exec() {
   If IsFunc(delayedfunc2exec)
      %delayedfunc2exec%()
   Else If delayedfunc2exec
      addJournalEntry("ERROR: The function passed as argument does not seem to exist: " delayedfunc2exec)
}

OpenSLD(fileNamu, dontStartSlide:=0) {
  mustOpenStartFolder := ""
  If !FileExist(fileNamu)
  {
     showTOOLtip("ERROR: Failed to load files list")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  PopulateIndexFilesStatsInfos("kill")
  If (SLDtypeLoaded=3)
  {
     SLDtypeLoaded := 0
     activeSQLdb.CloseDB()
  }

  mustRemQuotes := 1
  setImageLoading()
  renewCurrentFilesList()
  newStaticFoldersListCache := []
  DynamicFoldersList := CurrentSLD := filesFilter := ""
  zPlitPath(fileNamu, 0, OutFileName, OutDir, extname)
  pfn := (userPrivateMode=1) ? "******." extname : OutFileName
  fdr := (userPrivateMode=1) ? "*:\******\***" : OutDir
  showTOOLtip("Loading slideshow, please wait`n" pfn "`n" fdr "\")
  setWindowTitle("Loading slideshow, please wait", 1)
  If RegExMatch(fileNamu, "i)(.\.sldb)$")
  {
     r := OpenSLDBdataBase(fileNamu)
     If (maxFilesIndex>0 && r!=-1)
     {
        SLDcacheFilesList := 1
        mustGenerateStaticFolders := 0
        GenerateRandyList()
        SetTimer, ResetImgLoadStatus, -50
        CurrentSLD := fileNamu
        RecentFilesManager(CurrentSLD)
        SLDtypeLoaded := 3
        prevOpenFolderPath := OutDir
        INIaction(1, "prevOpenFolderPath", "General")
        RandomPicture()
        InfoToggleSlideShowu()
     } Else resetMainWin2Welcome()
     SetTimer, createGUItoolbar, -100
     SetTimer, TriggerMenuBarUpdate, -90
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  SlidesMusicSong := ""
  FileReadLine, firstLine, % fileNamu, 1
  If InStr(firstLine, "[General]") 
  {
     mustRemQuotes := 0
     IniRead, SlidesMusicSong, % fileNamu, General, SlidesMusicSong, @
     ; If FileExist(SlidesMusicSong)
        IniRead, autoPlaySlidesAudio, % fileNamu, General, autoPlaySlidesAudio, @

     IniRead, testStaticFolderz, % fileNamu, Folders, Fi1, @
     IniRead, tstSLDcacheFilesList, % fileNamu, General, SLDcacheFilesList, @
     IniRead, testDynaFolderz, % fileNamu, DynamicFolderz, DF1, @
     If StrLen(testDynaFolderz)>4
        DynamicFoldersList := "|hexists|"
       ; DynamicFoldersList := coreLoadDynaFolders(fileNamu)

     If (tstSLDcacheFilesList=1 || tstSLDcacheFilesList=0)
        SLDcacheFilesList := tstSLDcacheFilesList
  }

  mustGenerateStaticFolders := (InStr(firstLine, "[General]") && StrLen(testStaticFolderz)>8) ? 0 : 1
  If (tstSLDcacheFilesList=0)
     mustGenerateStaticFolders := 0

  If (SLDcacheFilesList=1 && InStr(firstLine, "[General]")) || !InStr(firstLine, "[General]")
     res := sldGenerateFilesList(fileNamu, 0, mustRemQuotes)

  currentFilesListModified := 0
  interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
  prevOpenFolderPath := OutDir
  INIaction(1, "prevOpenFolderPath", "General")
  If (res="abandoned")
  {
     closeDocuments()
     showDelayedTooltip("Files list operation aborted by user")
     SoundBeep , 300, 100
     Return
  }

  If InStr(firstLine, "[General]") 
  {
     If (maxFilesIndex<3 && DynamicFoldersList="|hexists|")
        ReloadDynamicFolderz(fileNamu)

     If (MustLoadSLDprefs=1)
        readSlideSettings(fileNamu, 0)
  }

  GenerateRandyList()
  CurrentSLD := fileNamu
  SLDtypeLoaded := 2
  currentFileIndex := 1
  currentFilesListModified := 0
  RecentFilesManager(CurrentSLD)
  SetTimer, createGUItoolbar, -100
  SetTimer, TriggerMenuBarUpdate, -90
  If (dontStartSlide=1)
  {
     SetTimer, RemoveTooltip, % -msgDisplayTime
     ResetImgLoadStatus()
     Return
  }

  ResetImgLoadStatus()
  If (maxFilesIndex>2)
  {
     RandomPicture()
     InfoToggleSlideShowu()
  } Else If (maxFilesIndex>0)
  {
     currentFileIndex := 1
     IDshowImage(1)
  } Else resetMainWin2Welcome()

  SetTimer, RemoveTooltip, % -msgDisplayTime
}

endCaptureCloneBrush() {
   mustCaptureCloneBrush := 0
   interfaceThread.ahkassign("mustCaptureCloneBrush", mustCaptureCloneBrush)
   SetTimer, createGUItoolbar, -150
}

resetMainWin2Welcome() {
     Critical, on
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
     { 
        seenImagesDB.Exec("COMMIT TRANSACTION;")
        Sleep, -1
        seenImagesDB.Exec("BEGIN TRANSACTION;")
     }

     If (ShowAdvToolbar!=1)
        trackImageListButtons("kill")

     desiredFrameIndex := SLDtypeLoaded := 0
     hasDrawnImageMap := hasDrawnHistoMap := editingSelectionNow := thumbsDisplaying := 0
     userAllowClrGradientRecenter := userAllowsGradientRecentering := 0
     recordUndoLevelHugeImagesNow("kill", 0, 0, 0)
     endCaptureCloneBrush()
     renewCurrentFilesList()
     activeSQLdb.CloseDB()
     newStaticFoldersListCache := []
     bckpResultedFilesList := []
     filteredMap2mainList := []
     toBeExcludedIndexes := []
     resultsDupesArray := []
     dupesHashesData := []
     dupesPixelData := []
     RandyIMGids := []
     calcScreenLimits()
     resetImgSelection("forced")
     updateUIctrl()
     SlidesMusicSong := DynamicFoldersList := CurrentSLD := ""
     filesFilter := EntryMarkedMoveIndex := mustOpenStartFolder := ""
     createGDIPcanvas()
     ToggleVisibilityWindow("show", hGDIwin)
     interfaceThread.ahkassign("thumbsDisplaying", 0)
     interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
     Gdip_GraphicsClear(glPG, "0x00" WindowBgrColor)
     doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC, 1)
     doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC, 1)
     doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, glHDC, 1)
     doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, glHDC, 1)
     ToggleVisibilityWindow("hide", hGDIthumbsWin)
     gdiBitmapIDcall := viewportIDstampBMP := AprevImgCall := BprevImgCall := ""
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     killQPVscreenImgSection()
     getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
     corePasteInPlaceActNow("kill")
     livePreviewInsertTextinArea("kill")
     coreFillSelectedArea("kill")
     livePreviewFillBehindArea("kill")
     coreCreateVPnavBox("kill")
     LoadCachableBitmapFromFile("kill")
     createGradientBrushBitmap("kill", 0, 0, 0, 0)
     createClonedBrushBitmap("kill", 0, 0, 0, 0)
     viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
     gdipObjectsStats()
     ForceRefreshNowThumbsList()
     prevOpenedWindow := ""
     SetTimer, createGUItoolbar, -100
     drawWelcomeImg()
     interfaceThread.ahkPostFunction("uiAccessWelcomeView")
     SetTimer, TriggerMenuBarUpdate, -90
     SetTimer, ResetImgLoadStatus, -50
     If (lockToolbar2Win=1 && ShowAdvToolbar=1)
        SetTimer, tlbrResetPosition, -100
}

activateFilesListFilterBasedOnFolder(thisIndex) {
   If askAboutFileSave(" and the files list will be filtered to the current image containing folder")
      Return

   r := getIDimage(thisIndex)
   zPlitPath(r, 0, OutFileName, OutDir)
   userFilterProperty := userFilterDoString := 1
   userFilterWhat := 2
   userFilterStringPos := 3
   userFilterInvertThis := userFilterStringIsNot := 0
   UsrEditFilter := OutDir
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   showDelayedTooltip("Files list filtered to current image file path:`n" OutDir "\", 0, 325)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(100)
}

mainWinTabResponse() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked>200)
   {
      If HKifs("liveEdit")
         toggleImgEditPanelWindow()
      Else If HKifs("imgsLoaded")
         markThisFileNow()
      lastInvoked := A_TickCount
   }
}

GenerateRandyList() {
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   RandyIMGids := []
   RandyIMGnow := -1
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
}

coreGenerateRandomList() {
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   RandyIMGids := []
   If (slidesRandoMode=1 || maxFilesIndex<100 || !slidesRandoMode)
   {
      Loop, % maxFilesIndex
          RandyIMGids[A_Index] := A_Index
      RandyIMGids := Random_ShuffleArray(RandyIMGids)
   } Else If (slidesRandoMode>1)
   {
      ; SoundBeep 
      x := []
      Loop, % maxFilesIndex//4
          x[A_Index] := A_Index
      a := Random_ShuffleArray(x.Clone())
      ; b := Random_ShuffleArray(x.Clone())
      ; c := Random_ShuffleArray(x.Clone())
      Loop, % maxFilesIndex - (maxFilesIndex//4) * 3
          x[A_Index] := A_Index
      d := Random_ShuffleArray(x)

      f := []
      Loop, % (maxFilesIndex//4) * 2
          f[A_Index] := A_Index

      ; Loop, % maxFilesIndex//4
      ;     f[A_Index + maxFilesIndex//4] := c[A_Index] + maxFilesIndex//4

      f := Random_ShuffleArray(f)
      Loop, % maxFilesIndex//4
          RandyIMGids[A_Index] := (slidesRandoMode=2) ? a[A_Index] : d[A_Index] + (maxFilesIndex//4)*3
      Loop, % (maxFilesIndex//4) * 2
          RandyIMGids[A_Index + maxFilesIndex//4] := f[A_Index] + maxFilesIndex//4
      Loop, % maxFilesIndex - (maxFilesIndex//4) * 3
          RandyIMGids[A_Index + (maxFilesIndex//4)*3] := (slidesRandoMode=2) ? d[A_Index] + (maxFilesIndex//4)*3 : a[A_Index]
      
      Loop, % maxFilesIndex//2
      {
         Random, f, 1, 20
         If (f=2)
         {
            t := RandyIMGids[A_Index]
            RandyIMGids[A_Index] := RandyIMGids[maxFilesIndex - A_Index]
            RandyIMGids[maxFilesIndex - A_Index] := t
         }
      }
      ; k := printArrayStr(RandyIMGids)
      ; addJournalEntry(k)
      ; ToolTip, %  RandyIMGids.Count()  , , , 2
   }
   RandyIMGnow := 1
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
}

OpenThisFilePropFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    resultu := StrReplace(getIDimage(currentFileIndex), "||")
    If resultu
    {
       zPlitPath(resultu, 0, fileNamu, folderu)
       invokeStandardFolderProperties(folderu)
    }
}

OpenThisFileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    resultu := StrReplace(getIDimage(currentFileIndex), "||")
    If resultu
    {
       zPlitPath(resultu, 0, fileNamu, folderu)
       Try Run, "%folderu%"
       Catch wasError
       {
          If !AnyWindowOpen
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu "\", 0, 0, "error")
       }
    }
}

OpenQPVfileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
    If !FolderExist(folderu)
    {
       showTOOLtip("ERROR: Folder not found or access denied`n" folderu "\")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If askAboutFileSave(" and the containing folder of the selected image will be opened")
       Return

    If askAboutSlidesListSave()
       Return

    If imgPath
    {
       renewCurrentFilesList()
       mustOpenStartFolder := folderu
       currentFileIndex := 1
       resultedFilesList[1, 1] := imgPath
       currentFileIndex := doOpenStartFolder()
       dummyTimerDelayiedImageDisplay(50)
    }
}

setImageWallpaper(monitorIndex, imgPath, setPos) {
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If !RegExMatch(imgPath, "i)(.\.(bmp|jpg|jpeg|png|tif))$")
   {
      showTOOLtip("Converting Image file format for desktop wallpaper into JPEG")
      file2save := mainCompiledPath "\wallpaper-" OutNameNoExt ".jpg"
      r := coreConvertImgFormat(imgPath, file2save)
      ResetImgLoadStatus()
      If !r
      {
         imgPath := file2save
      } Else
      {
         showTOOLtip("ERROR: An undefined error occured during image file conversion. The desktop wallpaper was not changed.`n" fileNamu "`n" folderu "\")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   If (A_OSVersion="WIN_7" || isWinXP)
   {
      ; DllCall("SetSysColors", "Int", 1, "Int*", 1, "UInt*", "0x" rgb2bgr(monitorBgrColor))
      r := DllCall("SystemParametersInfo", "UInt", 0x14, "UInt", 0, "WStr", imgPath, "UInt", 1) ; SPI_SETDESKWALLPAPER = 0x14
      thisPath := r ? imgPath : 0
      counter := 1
   } Else
   {
      dw := new IDesktopWallpaper
      dw.GetMonitorDevicePathAt(monitorIndex, MonitorID)
      dw.SetWallpaper(MonitorID, imgPath)
      dw.SetPosition(setPos)
      dw.SetBackgroundColor("0x" rgb2bgr(monitorBgrColor))
      dw.GetMonitorDevicePathCount(counter)
      Sleep, 1000
      dw.GetWallpaper(MonitorID, thisPath)
      dw := ""
      dw := Delete IDesktopWallpaper
   }

   If (thisPath!=imgPath)
   {
      showTOOLtip("Failed to set image as a desktop wallpaper")
      SoundBeep 300, 100
   } Else showTOOLtip("Image file is now set as desktop wallpaper`n" fileNamu "`n" folderu "\")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return counter - 1
}

OpenThisFileMenu() {
  If (slideShowRunning=1)
     ToggleSlideShowu()

  DestroyGIFuWin()
  imgPath := StrReplace(getIDimage(currentFileIndex), "||")
  InvokeOpenWithMenu(imgPath)
}

TestQPVisAssociated() {
  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, Ext)
  labelu := "QPVimg." Ext
  RegRead, regEntryA, HKEY_CLASSES_ROOT\.%Ext%
  If (regEntryA=labelu)
     testA := 1

  RegRead, regEntryB, HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.%Ext%\UserChoice, ProgId
  If (regEntryB=labelu)
     testB := 1
  
  isAssociated := (testA=1 && testB=1) ? 1 : 0
  Return isAssociated
}

SoloNewQPVinstance() {
   OpenWithNewQPVinstance("single")
}

OpenWithNewQPVinstance(modus:=0, givenList:=0, givenCount:=0) {
   filesElected := getSelectedFiles(0, 1)
   markedSelectFile := filesElected
   If (givenList && givenCount && isNumber(givenCount))
      filesElected := givenCount

   ; ToolTip, % givenCount "--" modus "--" filesElected "--" givenList , , , 2
   If (filesElected>25 && modus!="single")
   {
      msgBoxWrapper(appTitle ": WARNING", "You are not allowed to spawn in one go more than 25 instances of " appTitle ".", 0, 0, "error")
      Return
   }

   If (filesElected>5 && modus!="single")
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " groupDigits(filesElected) " files. Please confirm you want to spawn so many new instances of " appTitle ".", 4, 0, "question")
      If (msgResult="Yes")
         allGood := 1
   } Else allGood := 1

   If (givenList && givenCount>0 && isNumber(givenCount) && modus!="single" && allGood=1)
   {
      Loop, Parse, givenList, `n
      {
         imgPath := Trimmer(A_LoopField)
         If StrLen(imgPath)>4
         {
            Sleep, (A_Index>1) ? 700 : 300
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (markedSelectFile && filesElected>1 && modus!="single" && allGood=1)
   {
      thisIndex := 0
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
            Continue

         thisIndex++
         imgPath := resultedFilesList[A_Index, 1]
         If StrLen(imgPath)>4
         {
            Sleep, (thisIndex>1) ? 700 : 300
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (!markedSelectFile || modus="single")
   {
      imgPath := getIDimage(currentFileIndex)
      OpenNewQPVinstance(imgPath)
   }
}

OpenNewQPVinstance(imgPath:="") {
   imgPath := StrReplace(imgPath, "||")
   If FolderExist(imgPath)
      imgPath := "fd=" imgPath
   Else If !FileRexists(imgPath)
      imgPath := ""

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening a new instance of " appTitle ".", 0, 0, "error")
}

OpenWithDefaultApp() {
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    If !FileRexists(imgPath)
       informUserFileMissing()
    Sleep, 25
    If imgPath
    {
       Try Run, "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the default application.", 0, 0, "error")
    }
}

OpenFileProperties() {
    imgPath := StrReplace(getIDimage(currentFileIndex), "||")
    If !FileRexists(imgPath)
       informUserFileMissing()

    Sleep, 25
    If imgPath
    {
       Try Run, Properties "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the system file properties.", 0, 0, "error")
    }
}

InvokeOpenWithMenu(imgPath) {
    Try Menu, OpenWithMenu, Delete
    Global lastWinDrag := 1
    Global lastOtherWinClose := 1
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    CurrentSLD := Trimmer(StrReplace(CurrentSLD, "|"))
    CreateOpenWithMenu(imgPath)
    Menu, OpenWithMenu, Add,
    If (AnyWindowOpen!=60)
    {
       IniAction(0, "UserExternalApp", "General", 6)
       pathu := "&X. " PathCompact(UserExternalApp, 28)
       If StrLen(Trimmer(UserExternalApp))<6
          pathu := "NONE CHOSEN"

       IniAction(0, "UserExternalEditApp", "General", 6)
       pathu2 := "&Y. " PathCompact(UserExternalEditApp, 28)
       If StrLen(Trimmer(UserExternalEditApp))<6
          pathu2 := "NONE CHOSEN"

       If !markedSelectFile
          Menu, OpenWithMenu, Add, &0. Open file(s) in a new QPV instance, SoloNewQPVinstance
       Menu, OpenWithMenu, Add, &1. Open with default application, OpenWithDefaultApp
       Menu, OpenWithMenu, Add, &2. System «Open with» dialog, MenuInvokeSHopenWith
       Menu, OpenWithMenu, Add, &4. Explore containing folder`tCtrl+E, OpenThisFileFolder
       If (CurrentSLD!=OutDir)
          Menu, OpenWithMenu, Add, &5. Open containing folder in QPV`tAlt+E, OpenQPVfileFolder
       Menu, OpenWithMenu, Add,
       Menu, OpenWithMenu, Add, &Choose external application, browseExternalApp
       Menu, OpenWithMenu, Add, %pathu%, OpenImgWithUserExternApp
       Menu, OpenWithMenu, Add, &Choose external editor application, browseExternalEditApp
       Menu, OpenWithMenu, Add, %pathu2%, OpenImgWithUserEditExternApp
       If (!pathu || pathu="none chosen")
          Menu, OpenWithMenu, Disable, %pathu%
       If (!pathu2 || pathu2="none chosen")
          Menu, OpenWithMenu, Disable, %pathu2%
       Menu, OpenWithMenu, Add,
    }

    Menu, OpenWithMenu, Add, &Cancel, dummy
    showThisMenu("OpenWithMenu", 1)
}

browseExternalApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalApp := imgPath
      IniAction(1, "UserExternalApp", "General")
      OpenImgWithUserExternApp()
   }
}

browseExternalEditApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalEditApp := imgPath
      IniAction(1, "UserExternalEditApp", "General")
      OpenImgWithUserEditExternApp()
   }
}

OpenImgWithUserEditExternApp() {
   destroyGDIfileCache()
   OpenImgWithUserExternApp("editor")
}

OpenImgWithUserExternApp(modus:=0) {
   ; IniAction(0, "UserExternalApp", "General", 6)
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   thisAPPpath := (modus="editor") ? UserExternalEditApp : UserExternalApp
   If !FileExist(thisAPPpath)
   {
      zPlitPath(thisAPPpath, 0, fileNamu, folderu, OutNameNoExt)
      showTOOLtip("ERROR: The file of the external application does not seem to exist anymore`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   Try Run, %thisAPPpath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the external application.", 0, 0, "error")
}

incDecSlidesSpeed(direction) {
   If (direction=1)
      IncreaseSlideSpeed()
   Else
      DecreaseSlideSpeed()
}

resetSlideshowTimer(ignoreEasyStop:=0) {
   If (slideShowRunning!=1)
      Return

   If (easySlideStoppage=1 && slideShowRunning=1 && ignoreEasyStop=0)
      ToggleSlideShowu("stop", 0)
   Else If (slideShowRunning=1)
      ToggleSlideShowu("start", 1)
}

showSlideShowInfosNow(showProgress) {
   friendly := (slideShowRunning=1) ? "RUNNING" : "STOPPED"
   delayu := DefineSlidesRate()
   etaTime := "Estimated time: " EstimateSlideShowLength()
   proggy := (showProgress=1) ? slideShowDelay/59125 : 0
   showTOOLtip("Slideshow speed: " delayu "`nTotal files: " groupDigits(maxFilesIndex) "`n" etaTime "`nSlideshow: " friendly, "incDecSlidesSpeed", 2, proggy)
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

IncreaseSlideSpeed() {
   If isInRange(slideShowDelay, 900, 1100)
   {
      slideShowDelay := 1500
   } Else If isInRange(slideShowDelay, 1450, 1950)
   {
      slideShowDelay := 2000
   } Else If (slideShowDelay<1150)
   {
      slideShowDelay += 300
   } Else
   {
      slideShowDelay += 1000
      If (slideShowDelay>59000)
         slideShowDelay := 59000
   }

   resetSlideshowTimer(1)
   showSlideShowInfosNow(1)
   INIaction(1, "slideShowDelay", "General")
   Sleep, 5
}

DecreaseSlideSpeed() {
   If isInRange(slideShowDelay, 1900, 2100)
   {
      slideShowDelay := 1500
   } Else If isInRange(slideShowDelay, 1450, 1550)
   {
      slideShowDelay := 1000
   } Else If (slideShowDelay<1001)
   {
      slideShowDelay -= 300
      If (slideShowDelay<200)
         slideShowDelay := 100
   } Else
   {
      slideShowDelay -= 1000
   }

   resetSlideshowTimer(1)
   showSlideShowInfosNow(1)
   INIaction(1, "slideShowDelay", "General")
   Sleep, 5
}

fileSizeFriendly(bytez) {
  totalSize := Round(bytez/1024, 2)
  If (totalSize>1023)
  {
     totalSize := Round(totalSize/1024, 1)
     If (totalSize>1023.9)
        totalSize := Round(totalSize/1024, 1) " GB"
     Else totalSize := totalSize " MB"

  } Else totalSize := Round(totalSize) " KB"

  Return totalSize
}

copyMoveStructuredFolders(srcDir, finalDest) {
   Static lastInvoked := 1
   filesElected := getSelectedFiles(0, 1)
   If (srcDir=finalDest || !srcDir || !finalDest || filesElected<2)
      Return

   If (filesElected>150) ; ((A_TickCount - lastInvoked > 29500) && dummy!="quick-actu")
   {
      wording := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to " wording " the selected files.`n`nSelected " groupDigits(filesElected) " files`nDestination: " finalDest "\", 4, 0, "question")
      If (msgResult!="Yes")
         Return 0
   }

   BtnCloseWindow()
   lastInvoked := A_TickCount
   friendly := (UsrCopyMoveOperation=2) ? "Moving " : "Copying "
   showTOOLtip(friendly groupDigits(filesElected) " files to`n" finalDest "\`nPlease wait")
   destroyGDIfileCache()
   Sleep, 25
   askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   countTFilez := filezMoved := failedFiles := skippedFiles := 0
   forceConflictOption := userCopyMoveStructuredConflictMode
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   prevuDir := ""
   startZeit := A_Now
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   setWhileLoopExec(1)
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      changeMcursor()
      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      countTFilez++
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If !InStr(file2rem, srcDir "\")
      {
         skippedFiles++
         Continue
      }

      originalMtime := ""
      FileGetTime, originalMtime, % file2rem, M
      FileGetTime, originalCtime, % file2rem, C
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to perform action on " groupDigits(failedFiles) " files"
         If (skippedFiles>0)
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip(friendly "files and structure to`n" finalDest "\" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      file2save := StrReplace(file2rem, srcDir "\", finalDest "\")
      zPlitPath(file2save, 1, OldOutFileName, OutDir, OutFileNameNoExt, OutFileExt)
      If (prevuDir!=OutDir)
      {
         If !FolderExist(OutDir)
         {
            FileCreateDir, % OutDir
            If ErrorLevel
            {
               failedFiles++
               Continue
            } Else prevuDir := OutDir
         }
      }
      ; Tooltip, % file2rem "`n" file2save "`n" OutDir
      originalFileInfos := mustPerformOperation := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, forceConflictOption, performOverwrite)

      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }

      thisFileExists := FileRexists(file2save, 0)
      If (performOverwrite=1 && thisFileExists=1)
      {
         jso := GetFileAttributesEx(file2save)
         originalFileInfos := jso.size "|" jso.wtime "|" jso.ctime
         FileSetAttrib, -R, %file2save%
         Sleep, 2
         FileRecycle, %file2save%
         Sleep, 2
         mustPerformOperation := 1
      } Else If (thisFileExists=1)
      {
         skippedFiles++
         Continue
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (UsrCopyMoveOperation=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         updateDates := 1
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
            updateDates := 0
         }

         filezMoved++
         extraMarker := (thisFileExists=1 && performOverwrite=1) ? "*" : ""
         recordUndoFileActs(file2save, resultedFilesList[thisFileIndex, 1], extraMarker, UsrCopyMoveOperation, startZeit, originalFileInfos)
         ; zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
         If (UsrCopyMoveOperation=2)
         {
            resultedFilesList[thisFileIndex, 1] := file2save
            ; resultedFilesList[thisFileIndex, 2] := 1
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[thisFileIndex, 12])

            updateMainUnfilteredList(thisFileIndex, 1, file2save)
         }
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   setWhileLoopExec(0)
   CurrentSLD := backCurrentSLD
   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         someErrors .= "`nFailed to commit changes to the SQL database"
   }

   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " groupDigits(failedFiles) " files"
   If (skippedFiles>0)
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   watchFolderDetails := ""
   If (UsrCopyMoveOperation=2 && filezMoved>0)
      currentFilesListModified := 1

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (UsrCopyMoveOperation=2)
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   Return 0
}

CalculateSelectedFilesSizes() {
  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  getSelectedFiles(0, 1)
  If !markedSelectFile
  {
     showTOOLtip("WARNING: No files currently selected to calculate the total size for")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  showTOOLtip("Calculating total size for selected file entries, please wait")
  prevMSGdisplay := A_TickCount
  startOperation := A_TickCount
  doStartLongOpDance()
  maxCdate := maxMdate := maxSizeu := 0
  minCdate := minMdate := minSizeu := 99999999999999
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  Loop, % maxFilesIndex
  {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

     executingCanceableOperation := A_TickCount
     If (determineTerminateOperation()=1)
     {
        abandonAll := 1
        Break
     }

     If (A_TickCount - prevMSGdisplay>1000)
     {
        thisSize := fileSizeFriendly(totalSize)
        etaTime := ETAinfos(countFiles, markedSelectFile, startOperation)
        If failedFiles
           etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

        showTOOLtip("Calculating total files size`nTotal size: " thisSize etaTime, 0, 0, countFiles/markedSelectFile)
        prevMSGdisplay := A_TickCount
     }

     countFiles++
     fileInfos := GetFileAttributesEx(resultedFilesList[A_Index, 1])
     If !fileInfos.size
     {
        failedFiles++
        Continue
     }

     totalSize += fileInfos.size
     minSizeu := min(minSizeu, fileInfos.size)
     maxSizeu := max(maxSizeu, fileInfos.size)
     minMdate := min(minMdate, fileInfos.wtime)
     maxMdate := max(maxMdate, fileInfos.wtime)
     minCdate := min(minCdate, fileInfos.ctime)
     maxCdate := max(maxCdate, fileInfos.ctime)
  }
  ; ToolTip, % minCdate , , , 2
  totalSize := fileSizeFriendly(totalSize)
  minSizeu := fileSizeFriendly(minSizeu)
  maxSizeu := fileSizeFriendly(maxSizeu)
  CurrentSLD := backCurrentSLD
  Try FormatTime, minCdate, % minCdate, dd/MM/yyyy, HH:mm
  Try FormatTime, maxCdate, % maxCdate, dd/MM/yyyy, HH:mm
  Try FormatTime, minMdate, % minMdate, dd/MM/yyyy, HH:mm
  Try FormatTime, maxMdate, % maxMdate, dd/MM/yyyy, HH:mm
  If (abandonAll=1)
     someErrors := "Operation aborted by user`n"

  showTOOLtip(someErrors "Details for " groupDigits(countFiles) " selected files:`nTotal size: " totalSize "`nFile sizes range: " minSizeu " - " maxSizeu "`nDate modified: " minMdate " - " maxMdate "`nDate created: " minCdate " - " maxCdate)
  SetTimer, ResetImgLoadStatus, -200
  SetTimer, RemoveTooltip, % -msgDisplayTime * 2
}

CopyImageFileNames() {
   CopyImagePath("files")
}

CopyImageFolderPaths() {
   CopyImagePath("dirs")
}

CopyImagePath(modus:=0) {
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   getSelectedFiles(0, 1)
   If !markedSelectFile
   {
      imgPath := getIDimage(currentFileIndex)
      If (!imgPath || !currentFileIndex)
         Return
 
      imgPath := StrReplace(imgPath, "||")
      zPlitPath(imgPath, 0, fileNamu, folderu)
      If (modus="dirs")
         Try Clipboard := folderu
      Else If (modus="files")
         Try Clipboard := fileNamu
      Else
         Try Clipboard := imgPath
      Catch wasError
          Sleep, 1
 
      folderu := PathCompact(folderu, "a", 1, OSDfontSize)
      thisu := (modus="dirs") ? folderu "\" : fileNamu "`n" folderu "\"
      If (modus="files")
         thisu := fileNamu

      If (userPrivateMode=1)
         thisu := "****************"

      infoText := wasError ? "ERROR: Failed to copy to clipboard as text the active entry" : "The active entry was copied to clipboard as text"
      showTOOLtip(infoText "`n" thisu)
      If InStr(infoText, "error: failed")
         SoundBeep 300, 100 

      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   counter := 0
   listu := ""
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalSelected := markedSelectFile
   itemsList := new hashtable()
   Loop, % maxFilesIndex
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(counter, totalSelected, startOperation)
          showTOOLtip("Processing the list to copy selected index entries" etaTime, 0, 0, counter/totalSelected)
          prevMSGdisplay := A_TickCount
       }
       
       If !resultedFilesList[A_Index, 2]
          Continue ; if file not selected, skip

       imgPath := StrReplace(resultedFilesList[A_Index, 1], "||")
       If imgPath
       {
          If (modus="dirs")
             zPlitPath(imgPath, 1, OutFileName, imgPath)
          Else If (modus="files")
             zPlitPath(imgPath, 1, imgPath, OutDir)

          If (modus="dirs" || modus="files")
          {
             t := Format("{:L}", imgPath)
             If itemsList[t]
                Continue

             itemsList[t] := 1
          }

          counter++
          listu .= imgPath "`n"
       }
   }

    itemsList := ""
    If (!listu || abandonAll=1)
    {
       ResetImgLoadStatus()
       Return
    }
 
    friendly := (modus="dirs") ? "containing folders" : "complete paths"
    If (modus="files")
       friendly := "file names"

    Try Clipboard := listu
    Catch wasError
          Sleep, 1

    If wasError
    {
       showTOOLtip("Failed to copy to clipboard as text the " friendly)
       SoundBeep , 300, 100
    } Else showTOOLtip(groupDigits(counter) " selected " friendly " copied to clipboard as text")

    SetTimer, RemoveTooltip, % -msgDisplayTime
    ResetImgLoadStatus()
}

MenuExplorerCopyFiles() {
    CopyMoveFilesExplorer("copy")
}

MenuExplorerCutFiles() {
    destroyGDIfileCache()
    CopyMoveFilesExplorer("cut")
}

MenuExplorerCopyContainFolder() {
    CopyMoveFilesExplorer("copy", "folderu")
}

MenuExplorerCutContainFolder() {
    destroyGDIfileCache()
    CopyMoveFilesExplorer("cut", "folderu")
}

CopyMoveFilesExplorer(userOption:="copy", onWhat:=0) {
  userOption := (userOption="cut") ? "CUT" : "COPY"
  If (currentFileIndex=0)
     Return

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  friendly := (onWhat="folderu") ? "folder" : "file"
  showTOOLtip("Copying " friendly "(s) to clipboard")
  getSelectedFiles(0, 1)
  newFilesList := []
  countTFilez := 0
  If (markedSelectFile>1)
  {
     itemsList := new hashtable()
     Loop, % maxFilesIndex
     {
        If !resultedFilesList[A_Index, 2]
           Continue

        imgPath := StrReplace(resultedFilesList[A_Index, 1], "||")
        If StrLen(imgPath)<4
           Continue

        If (onWhat="folderu")
        {
           imgPath := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
           t := Format("{:L}", imgPath)
           If itemsList[t]
              Continue

           itemsList[t] := 1
        }

        countTFilez++
        newFilesList[countTFilez] := imgPath
     }

     If countTFilez
     {
        modus := (onWhat="folderu") ? 1 : 0
        dataHandle := ClipboardSetFiles(newFilesList, userOption, modus)
        Sleep, 5
        testClipType := IsClipboardFormatAvailable(15)
        infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to store the selected " friendly "s into the clipboard" : userOption " was applied on " groupDigits(countTFilez) A_Space friendly "s.`nThese can now be pasted in any file manager or in QPV."
        showTOOLtip(infoText)
        SoundBeep, % InStr(infoText, "error") ? 300 : 900, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     } Else markedSelectFile := 0
  }

  imgPath := Trimmer(StrReplace(getIDimage(currentFileIndex), "||"))
  If (!imgPath || !currentFileIndex)
     Return

  zPlitPath(imgPath, 0, fileNamu, folderu)
  If (onWhat="folderu")
     newFilesList[1] := folderu
  Else
     newFilesList[1] := imgPath

  modus := (onWhat="folderu") ? 1 : 0
  dataHandle := ClipboardSetFiles(newFilesList, userOption, modus)
  Sleep, 5
  Try testClipType := IsClipboardFormatAvailable(15)
  infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to set " friendly " to clipboard" : userOption " [Explorer] was applied on the " friendly " `n"
  showTOOLtip(infoText fileNamu "`n" folderu "\")
  SoundBeep, % InStr(infoText, "error") ? 300 : 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

throwErrorNoImageLoaded(noMSG:=0, stringent:=1) {
   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   stringent := (stringent=1) ? 0 : FileRexists(imgPath)
   If (!validBMP(whichBitmap) && !stringent || !imgPath)
   {
      If (noMSG=0)
      {
         showTOOLtip("WARNING: No image file is currently loaded")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime//2
      }
      Return "fail"
   }
}

CopyImage2clip() {
  If (thumbsDisplaying=1)
     Return "fail"

  If throwErrorNoImageLoaded()
     Return "fail"

  whichBitmap := useGdiBitmap()
  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  friendly := (editingSelectionNow=1) ? " selected area" : ""
  If (editingSelectionNow=1 && validBMP(whichBitmap))
  {
     If throwErrorSelectionOutsideBounds(whichBitmap)
        Return "fail"
  }

  setImageLoading()
  If (viewportQPVimage.imgHandle)
  {
     vpWinClientSize(mainWidth, mainHeight)
     FreeImage_GetImageDimensions(viewportQPVimage.imgHandle, imgW, imgH)
     If (editingSelectionNow=1)
     {
        calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
        additionalHUDelements(3, mainWidth, mainHeight)
     } Else
     {
        imgSelW := imgW, imgSelH := imgH
        imgSelPx := imgSelPy := 0
     }

     rw := imgSelW, rh := imgSelH
     capIMGdimensionsGDIPlimits(rw, rh)
     nmgpx := Round((rw * rh)/1000000, 1)
     zf := (imgSelW!=rw || imgSelH!=rh) ? "`nResizing image to" rw " x " rh " pixels`n" nmgpx " megapixels" : ""
     showTOOLtip("Copying image" friendly " to clipboard, please wait" zf)
     If (editingSelectionNow=1)
     {
        zBitmap := getSelectedImageArea(useGdiBitmap(), 1, 2, 0, rw, rh)
     } Else
     {
        zBitmap := viewportQPVimage.ImageGetResizedRect(imgSelPx, imgSelPy, ImgSelW, imgSelW, rw, rh, userimgQuality)
        zBitmap := applyVPeffectsOnBMP(zBitmap, 1)
        flipBitmapAccordingToViewPort(zBitmap)
     }

     If validBMP(zBitmap)
     {
        hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, zBitmap)
        r := hBitmap ? Gdip_SetBitmapToClipboard(zBitmap, hBitmap) : addJournalEntry("get_last_err")
        trGdip_DisposeImage(zBitmap, 1)
     } Else r := "fail"
  } Else If validBMP(whichBitmap)
  {
     showTOOLtip("Copying image" friendly " to clipboard, please wait")
     If (editingSelectionNow=1)
        zBitmap := getSelectedImageArea(whichBitmap, 1, 2, 0)
     Else
        zBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, whichBitmap)))

     If validBMP(zBitmap)
     {
        hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, zBitmap)
        ; Gdi_DeleteObject(hBitmap)
        r := hBitmap ? Gdip_SetBitmapToClipboard(zBitmap, hBitmap) : addJournalEntry("get_last_err")
        ; If (zBitmap!=whichBitmap)
           trGdip_DisposeImage(zBitmap, 1)
     } Else r := "fail"
  } Else r := "fail"

  SetTimer, ResetImgLoadStatus, -100
  If r
     showTOOLtip("Failed to copy the image to clipboard`nError code: " r)
  Else
     showTOOLtip("Image" friendly " copied to clipboard")

  SoundBeep, % r ? 300 : 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return r
}

UIbtnViewAlphaMaskNow() {
   ViewAlphaMaskNow("btn")
}

ViewAlphaMaskNow(modus:=0) {
   Static lastInvoked := 1
   If (thumbsDisplaying=1)
      Return

   If (!(isAlphaMaskWindow()=1 || isAlphaMaskPartialWin()=1) && imgEditPanelOpened=1 && AnyWindowOpen)
   {
      showTOOLtip("WARNING: The current tool does not support alpha masks")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (isNowAlphaPainting() && isAlphaMaskWindow() && AnyWindowOpen!=70)
   {
      forceLiveAlphaPreviewMode := !forceLiveAlphaPreviewMode
      corelivePreviewsImageEditing()
      Return
   }

   SetTimer, RemoveTooltip, Off
   isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
   If ((A_TickCount - lastInvoked<350) && modus!="btn" && isTransPanel=0)
   {
      SetTimer, dummyViewAlphaMaskNow, Off
      SetTimer, PanelSoloAlphaMasker, -200
      lastInvoked := A_TickCount
      Return
   }
   lastOSDtooltipInvoked := A_TickCount
   SetTimer, dummyViewAlphaMaskNow, -70
   lastInvoked := A_TickCount
}

ResizeAlphaMask2sel() {
   If !validBMP(userAlphaMaskBmpPainted)
   {
      showTOOLtip("WARNING: There is no user painted alpha mask available")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   If (imgSelW<5 || imgSelH<5 || !imgSelW || !imgSelH)
   {
      showTOOLtip("ERROR: Invalid selection area")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   z := downscaleHugeImagesForEditing()
   If (z<0 || z=1)
      Return

   alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, userAlphaMaskBmpPainted, imgSelW, imgSelH, 0, 7, -1)
   If validBMP(alphaMaskGray)
   {
      userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted, 1)
      userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
      userAlphaMaskBmpPainted := alphaMaskGray
      UItriggerBrushUpdate(1, 5)
      showTOOLtip("Alpha mask bitmap resized to:`n" groupDigits(imgSelW) " x " groupDigits(imgSelH) " (" Round(imgSelW/imgSelH, 2) ")")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      showTOOLtip("ERROR: Failed to resize the alpha mask bitmap")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

FlipHalphaMask() {
   coreFlipuAlphaMask(4)
}

FlipValphaMask() {
   coreFlipuAlphaMask(6)
}

coreFlipuAlphaMask(modus) {
   If !validBMP(userAlphaMaskBmpPainted)
   {
      showTOOLtip("WARNING: There is no user painted alpha mask available")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   Gdip_ImageRotateFlip(userAlphaMaskBmpPainted, modus)
   UItriggerBrushUpdate(1, 5)
   showTOOLtip("Alpha mask bitmap flipped")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyViewAlphaMaskNow() {
   If (thumbsDisplaying=1)
      Return

   infoMask := defineCurrentAlphaMask()
   If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
   {
      showDelayedTooltip("WARNING: No alpha mask has been defined")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   SetTimer, RemoveTooltip, Off
   lastOSDtooltipInvoked := A_TickCount
   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
   ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   vpWinClientSize(mainWidth, mainHeight)
   setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
   toolTipGuiCreated := 2
   If (AnyWindowOpen=66 && editingSelectionNow!=1)
   {
      restoreThis := 1
      opa := BrushToolOutsideSelection
      editingSelectionNow := BrushToolOutsideSelection := 1
   }

   SkeletDrawSelectionBox(1)
   Gdip_ResetWorldTransform(2NDglPG)
   If (restoreThis=1)
   {
      editingSelectionNow := 0
      BrushToolOutsideSelection := opa
   }
   lastOSDtooltipInvoked := A_TickCount
   toolTipGuiCreated := 2
}

RasterizeAlphaMaskNow(allowAsk:="yes") {
   CopyAlphaMask2clippy("rasterize", allowAsk)
}

CopyAlphaMask2clippy(modus:=0, allowAsk:=0) {
  If (thumbsDisplaying=1)
     Return

  If throwErrorNoImageLoaded()
     Return 

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  infoMask := defineCurrentAlphaMask()
  If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
  {
     showTOOLtip("WARNING: There is no defined alpha mask")
     SoundBeep 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  If InStr(infoMask, "user painted")
  {
     trGdip_GetImageDimensions(userAlphaMaskBmpPainted, vPimgSelW, vPimgSelH)
  } Else If InStr(infoMask, "main image")
  {
     trGdip_GetImageDimensions(useGdiBitmap(), vPimgSelW, vPimgSelH)
  } Else If InStr(infoMask, "transformed")
  {
     trGdip_GetImageDimensions(userClipBMPpaste, vPimgSelW, vPimgSelH)
  } Else
  {
     If (editingSelectionNow!=1)
     {
        ToggleEditImgSelection()
        If (modus="rasterize")
           SetTimer, RasterizeAlphaMaskNow, -250
        Else
           SetTimer, CopyAlphaMask2clippy, -250
        Return
     }

     vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
     vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
  }

  transformTool := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
  alphaMaskGray := generateAlphaMaskBitmap(0, 0, vPimgSelW, vPimgSelH, 0, 0, 0, 1, transformTool)
  If validBMP(alphaMaskGray)
  {
     pEffectGray := Gdip_CreateEffect(6, 0, -100, 0)
     pEffectInvert := Gdip_CreateEffect(7, 0, 0, 100)
     If (alphaMaskingMode=5 && alphaMaskBMPchannel!=5)
        Gdip_BitmapApplyEffect(alphaMaskGray, pEffectGray)
     If (alphaMaskColorReversed=1)
        Gdip_BitmapApplyEffect(alphaMaskGray, pEffectInvert)

     If (modus="rasterize")
     {
        userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
        userPrevAlphaMaskBmpPainted := userAlphaMaskBmpPainted
        r := 1
        If (validBMP(userAlphaMaskBmpPainted) && allowAsk!="no-ask")
           r := PanelOfferAlphaMaskMerger(userAlphaMaskBmpPainted, alphaMaskGray)
        Else
           userAlphaMaskBmpPainted := alphaMaskGray

        If (r=1)
        {
           alphaMaskingMode := 5
           keepUserPaintAlphaMask := alphaMaskBMPchannel := alphaMaskRefBMP := alphaMaskGradientScale := 1
           alphaMaskBMPcontrast := alphaMaskBMPbright := alphaMaskGradientAngle := alphaMaskReplaceMode := alphaMaskColorReversed := 0
           If (isAlphaMaskWindow()=1 && imgEditPanelOpened=1)
           {
              GuiUpdateSliders("alphaMaskBMPcontrast")
              GuiUpdateSliders("alphaMaskBMPbright")
              GuiUpdateSliders("alphaMaskGradientScale")
              GuiUpdateSliders("alphaMaskGradientAngle")
              GuiControl, SettingsGUIA:, alphaMaskColorReversed, 0
              GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 5
              GuiControl, SettingsGUIA: Choose, alphaMaskRefBMP, 1
              GuiControl, SettingsGUIA: Choose, alphaMaskBMPchannel, 1
              realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
              generateAlphaMaskBitmap("kill", 0)
              UItriggerBrushUpdate(1)
           }
        }
     } Else
     {
        hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, alphaMaskGray)
        r := (hBitmap!="") ? Gdip_SetBitmapToClipboard(alphaMaskGray, hBitmap) : addJournalEntry("get_last_err")
     }

     Gdip_DisposeEffect(pEffectGray)
     Gdip_DisposeEffect(pEffectInvert)
  } Else r := (modus="rasterize") ? "" : "unknown error"

  generateAlphaMaskBitmap("kill", 0)
  SetTimer, ResetImgLoadStatus, -100
  If (modus="rasterize")
  {
     If (r=2)
        showTOOLtip("The alpha mask was not changed. User abandoned the procedure.")
     Else If !r
        showTOOLtip("Failed to rasterize the alpha mask")
     Else
        showTOOLtip("Alpha mask rasterized as user painted bitmap`nOriginal mask type: " infoMask)
     SoundBeep, % !r ? 300 : 900, 100
  } Else
  {
     If r
        showTOOLtip("Failed to copy the alpha mask bitmap to clipboard`nError code: " r)
     Else
        showTOOLtip("Alpha mask copied to clipboard`nMask type: " infoMask)
     SoundBeep, % r ? 300 : 900, 100
  }

  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return r
}

PanelAskSliderValue(varName, varMin, varMax, curVal, defVal, nameu) {
   r := msgBoxWrapper("Set slider value: " appTitle, "Please input a new value for:`n" nameu "`n(" varName ")`n`nAllowed range: " varMin "; " varMax ".`nCurrent value is " curVal ".`nThe default is " defVal ".", "&OK|&Cancel", 1,, nullCheckBox, 0, "", "limit5", curVal, 1)
   l := Trimmer(r.edit)
   e := (!isNumber(l) || r.btn!="ok") ? curVal : clampInRange(Round(l), varMin, varMax)
   Return e
}

PanelOfferAlphaMaskMerger(oldBitmap, newBitmap) {
   Static blends := {1:0, 2:2, 3:3, 4:6, 5:7, 6:10, 7:16}

   widthu := (PrefsLargeFonts=1) ? 900 : 600
   msgResult := msgBoxWrapper("Merge alpha masks: " appTitle, "It seems you already have a user painted bitmap as alpha mask. Would you like to blend it with the new generated bitmap or just replace it?", "&Proceed|&Cancel", 1, "image", nullCheckBox, 0, "", "" ,, 1, widthu, "Replace bitmap (no blending)`f`fDarken (substractive)`fMultiply (substractive)`fLighten (additive)`fScreen (additive)`fOverlay (mixed)`fExclusion (mixed)", 2)
   If InStr(msgResult.btn, "proceed")
   {
      thisu := blends[msgResult.2ndlist]
      If !thisu
      {
         userAlphaMaskBmpPainted := newBitmap
         Return 1
      }

      trGdip_GetImageDimensions(newBitmap, w, h)
      trGdip_GetImageDimensions(oldBitmap, w2, h2)
      If (w2!=w || h2!=h) && (w && h && w2 && h2)
         zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oldBitmap, w, h, 0, 3)
      Else
         zBitmap := trGdip_CloneBitmap(A_ThisFunc, oldBitmap)

      ; fnOutputDebug(A_ThisFunc "() " w "=" w2 "||" h "=" h2 " |z=" zBitmap "|o=" oldBitmap "|n=" newBitmap)
      ; fnOutputDebug(A_ThisFunc "(): l=" thisu " | " msgResult.2ndlist)
      r := QPV_BlendBitmaps(zBitmap, newBitmap, thisu)
      if !r
      {
         addJournalEntry(A_ThisFunc "(): An error occured when blending the bitmaps.")
         SoundBeep , 300, 100
      }
      userAlphaMaskBmpPainted := zBitmap
      trGdip_DisposeImage(newBitmap, 1)
      Return 1
   } Else
   {
      userAlphaMaskBmpPainted := userPrevAlphaMaskBmpPainted
      userPrevAlphaMaskBmpPainted := ""
      Return 2
   }
}

SetImageAsAlphaMask(isGiven:=0, externBMP:=0) {
  wasGiven := (isGiven="yes-bitmap" && validBMP(externBMP)) ? 1 : 0
  If (thumbsDisplaying=1 && wasGiven=0)
     Return

  If throwErrorNoImageLoaded()
     Return 

  if (wasGiven=0)
  {
     If throwErrorSelectionOutsideBounds()
        Return
  }

  If throwWarningHugeImagesFeatureNotAvailable()
     Return

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  r := 1
  whichBitmap := (wasGiven=1) ? externBMP : useGdiBitmap()
  friendly := (editingSelectionNow=1 && wasGiven=0) ? " selected area " : ""
  setImageLoading()
  If validBMP(whichBitmap)
  {
     obju := []
     obju[1] := [VPselRotation, EllipseSelectMode, innerSelectionCavityX, innerSelectionCavityY]
     VPselRotation := EllipseSelectMode := innerSelectionCavityX := innerSelectionCavityY :=  0
     showTOOLtip("Processing image" friendly ", please wait")
     If (editingSelectionNow=1 && wasGiven!=1)
        zBitmap := getSelectedImageArea(whichBitmap, 0, 1, 0)
     Else If (wasGiven=1)
        zBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
     Else
        zBitmap := applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, whichBitmap))

     EllipseSelectMode := obju[1, 1]
     VPselRotation := obju[1, 2]
     innerSelectionCavityX := obju[1, 3]
     innerSelectionCavityY := obju[1, 4]
     If validBMP(zBitmap)
     {
        If (wasGiven=0)
        {
           trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
           isOutside := (imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH) ? 1 : 0
        }

        userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
        userPrevAlphaMaskBmpPainted := userAlphaMaskBmpPainted
        If (currIMGdetails.HasAlpha=1 || isOutside=1 || wasGiven=1)
        {
           ; eliminate transparency
           Gdip_BitmapConvertFormat(zBitmap, 0x21808, 2, 1, 0, 0, 0, 0, 0)
           Gdip_BitmapConvertFormat(zBitmap, 0xE200B, 2, 1, 0, 0, 0, 0, 0)
        }

        If validBMP(userAlphaMaskBmpPainted)
           z := PanelOfferAlphaMaskMerger(userAlphaMaskBmpPainted, zBitmap)
        Else
           userAlphaMaskBmpPainted := zBitmap

        r := 0
        If (z!=2)
           keepUserPaintAlphaMask := 1
     } Else r := "fail"
  } Else r := "fail"

  SetTimer, ResetImgLoadStatus, -100
  friendly := (editingSelectionNow=1 && wasGiven=0) ? "selected area " : ""
  If (z=2)
  {
     showTOOLtip("The alpha mask was not changed. User abandoned the procedure.")
  } Else If (r || !validBMP(userAlphaMaskBmpPainted))
  {
     showTOOLtip("Failed to set image " friendly "as alpha mask")
  } Else
  {
     alphaMaskRefBMP := alphaMaskGradientScale := 1
     alphaMaskingMode := alphaMaskBMPchannel := 5
     alphaMaskColorReversed := alphaMaskBMPbright := alphaMaskBMPcontrast := alphaMaskGradientAngle := alphaMaskReplaceMode := 0
     If (isAlphaMaskWindow()=1 && imgEditPanelOpened=1)
     {
        GuiUpdateSliders("alphaMaskBMPbright")
        GuiUpdateSliders("alphaMaskBMPcontrast")
        GuiUpdateSliders("alphaMaskGradientScale")
        GuiUpdateSliders("alphaMaskGradientAngle")
        GuiControl, SettingsGUIA:, alphaMaskReplaceMode, 0
        GuiControl, SettingsGUIA:, alphaMaskColorReversed, 0
        GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 5
        GuiControl, SettingsGUIA: Choose, alphaMaskRefBMP, 1
        GuiControl, SettingsGUIA: Choose, alphaMaskBMPchannel, 5
        UItriggerBrushUpdate(1)
        realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
        livePreviewsImageEditing()
     }

     generateAlphaMaskBitmap("kill", 0)
     trGdip_GetImageDimensions(userAlphaMaskBmpPainted, w, h)
     showTOOLtip("Image " friendly "is set as alpha mask`nDimensions: " groupDigits(w) " x " groupDigits(h) " (" Round(w/h, 2) ")")
  }

  SoundBeep, % r ? 300 : 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return r
}

invertCurrentFolderRecursiveness() {
   If (RegExMatch(CurrentSLD, sldsPattern) || !CurrentSLD)
      Return

   isPipe := InStr(CurrentSLD, "|") ? 1 : 0
   CurrentSLD := StrReplace(CurrentSLD, "|")
   DynamicFoldersList := StrReplace(DynamicFoldersList, "|")
   If (isPipe!=1)
   {
      CurrentSLD := "|" CurrentSLD
      DynamicFoldersList := "|" DynamicFoldersList
   }

   RefreshFilesList()
}

MenuRemFilesListFilter() {
   remFilesListFilter()
   ; SetTimer, RandomPicture, -150
   dummyTimerDelayiedImageDisplay(50)
}

remFilesListFilter(modus:=0) {
   If (modus="simple")
   {
      addJournalEntry("Removing files list filter:`n" filesFilter)
      prevFilter := filesFilter
      filesFilter := ""
      resultsDupesArray := []
      FilterFilesIndex(0, prevFilter)
      currentFileIndex := clampInRange(bckpCurrentFileIndex, 1, maxFilesIndex)
   } Else coreEnableFiltru("")
}

dummyTimerReloadThisPicture(timeru:=0) {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If (timeru>1)
     SetTimer, extraDummyReloadThisPicture, % -timeru, 950
}

extraDummyReloadThisPicture() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyReloadThisPicture, -15
     Return
  }
  ReloadThisPicture()
}

determineLClickState() {
   If (slideShowRunning=1)
      Return 0

   LbtnDwn := interfaceThread.ahkgetvar.LbtnDwn
   If (GetKeyState("LButton") || LbtnDwn=1)
      Return 1
   Else
      Return 0
}

ReloadThisPicture() {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If ((CurrentSLD && maxFilesIndex>0) || validBMP(UserMemBMP))
  {
     delayu := (A_TickCount - prevFastDisplay < 500) ? 90 : 550
     If (determineLClickState()=1 || GetKeyState("Space", "P"))
     {
        dummyTimerReloadThisPicture(delayu)
        Return
     }

     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing(1)
  }
}

coreReloadThisPicture() {
  If ((CurrentSLD && maxFilesIndex>0) || validBMP(UserMemBMP))
  {
     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing(1)
  }
}

FirstPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=1 && thumbsDisplaying!=1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := 1
   dummyTimerDelayiedImageDisplay(50)
}

LastPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=maxFilesIndex && thumbsDisplaying!=1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := maxFilesIndex
   dummyTimerDelayiedImageDisplay(50)
}

SettingsGUIAGuiClose:
SettingsGUIAGuiEscape:
   CloseWindow()
Return

OSDguiToolbarGuiClose:
   WinGetPos, X, Y, Width, Height, ahk_id %hQPVtoolbar%
   If (x && y)
   {
      UserToolbarX := x
      UserToolbarY := y
   }

   toggleAppToolbar()
Return

doCleanup:
   TrueCleanup()
Return

TrueCleanup() {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 900) || (hasInitSpecialMode=1)
      Return

   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
      seenImagesDB.Exec("COMMIT TRANSACTION;")

   activeSQLdb.CloseDB()
   seenImagesDB.CloseDB()
   If AnyWindowOpen
      BtnCloseWindow()

   Sleep, 10
   WinSet, Region, 0-0 w1 h1, ahk_id %PVhwnd%
   RegWrite, REG_SZ, %QPVregEntry%, Running, 0

   lastInvoked := A_TickCount
   If (slideShowRunning=1)
      DestroyGIFuWin()
   Sleep, 1
   If (wasInitFIMlib=1)
      FreeImage_FoxInit(0) ; Unload Dll

   tlbrSetImageIcon("kill", "kill", 0, 0)
   trackImageListButtons("kill")
   killQPVscreenImgSection()
   viewportQPVimage.DiscardImage()
   disposeCacheIMGs()
   destroyGDIfileCache()
   discardViewPortCaches()
   terminateIMGediting()
   userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted)
   userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted)
   Gdip_DeleteBrush(pBrushWinBGR)
   Gdip_DeleteBrush(pBrushHatch)
   Gdip_DeleteBrush(pBrushHatchLow)
   Gdip_DeleteBrush(pBrushA)
   Gdip_DeleteBrush(pBrushB)
   Gdip_DeleteBrush(pBrushC)
   Gdip_DeleteBrush(pBrushD)
   Gdip_DeleteBrush(pBrushE)
   Gdip_DeleteBrush(pBrushF)
   Gdip_DeleteBrush(pBrushZ)
   Gdip_DeleteBrush(OSDwinFadedBrushBGR)
   Gdi_DeleteObject(gdiAmbientalTexBrush)
   Gdi_DeleteObject(GDIbrushWinBGR)
   Gdip_DeletePen(pPen1d)
   Loop, 8
      Gdip_DeletePen(pPen%A_Index%)

   mainGdipWinThumbsGrid(1)
   destroyGDIPcanvas()
   Sleep, 1
   GDIPToken := Gdip_Shutdown(GDIPToken)
   lastInvoked := A_TickCount
   lastInvoked := A_TickCount
   fnOutputDebug("Proper exit. Main thread. PID=" QPVpid)
   ForceExitNow("yay")
}

ForceExitNow(modus:=0) {
   If GDIPToken
      Gdip_Shutdown(GDIPToken)  
   Sleep, 5
   If (modus!="yay")
      fnOutputDebug("Forced exit. Main thread. PID=" QPVpid)
   Process, Close, % QPVpid
   ExitApp
}

dummySetWindowTitle() {
    setWindowTitle("lol", 0, 1)
}

setWindowTitle(msg, forceThis:=0, useLast:=0) {
    Static prevSet, prevMsg, lastInvoked := 1
    If (A_TickCount - zeitSillyPrevent<200)
       Return

    msg := StrReplace(msg, "`n", " | ")
    If (userPrivateMode=1)
    {
       msg := RegExReplace(msg, "im)(\|.*\|)", "|")
       msg := RegExReplace(msg, "im)(\].*\|)", "|")
    }

    If (useLast!=1)
       addJournalEntry("WinTitle: " msg)

    infoSlideDelay := (slideShowRunning=1 && slideShowDelay<2950) ? 1 : 0
    thisMsg := (useLast=1 && StrLen(prevMsg)>3) ? prevMsg : msg
    If (useLast!=1)
       prevMsg := msg

    If (A_TickCount - lastInvoked<200) && (useLast!=1 && forceThis!=1)
    {
       SetTimer, dummySetWindowTitle, -350
       Return
    }

    If (prevSet!=thisMsg && runningLongOperation!=1 && infoSlideDelay=0 && animGIFplaying!=1 && hasInitSpecialMode!=1) || (forceThis=1)
    {
       prevSet := thisMsg
       WinSetTitle, ahk_id %PVhwnd%,, % verType thisMsg " | QPV"
       ; fnOutputDebug("WinTitle: " thisMsg)
       lastInvoked := A_TickCount
    }
}

TulTip(debugger, sep, params*) {
    str := ""
    For index,param in params
        str .= "[" A_Index "]" param . sep
    
    If debugger
       fnOutputDebug(debugger ": " str)
    Else
       ToolTip, % str , , , 2
}

fnOutputDebug(msg) {
   Static prevMsg

   If (debugModa=1)
   {
      If (prevMsg!=msg && slideShowRunning!=1 && slideShowDelay>300)
      {
         If (InStr(msg, "Thumb") && thumbsDisplaying=1)
            Return

         prevMsg := msg
         msg := StrReplace(msg, "User journal: wintitle:", "WinTitle:")
         msg := StrReplace(msg, "User journal: dialog box:", "Dialog box:")
         msg := StrReplace(msg, "User journal: osd:", "OSD:")
         msg := StrReplace(msg, "`n", "; ")
         OutputDebug, % "QPV: " Trim(msg)
      }
   }
}

MenuDummyToggleThumbsMode() {
   lastOtherWinClose := 5
   ToggleThumbsMode()
}

initAHKhThumbThreads() {
    Static multiCoreInit := 0

    If (multiCoreInit=1 || allowMultiCoreMode!=1 || minimizeMemUsage=1)
       Return

    addJournalEntry("Attempting to initialize " realSystemCores " threads for thumbnails generation")
    initFIMGmodule()
    If (FIMfailed2init=1)
    {
       addJournalEntry("Failed to initialize the auxiliary threads because FreeImage failed to initialize")
       multiCoreThumbsInitGood := 0
    } Else
    {
       ; SoundBeep 300, 100
       If A_IsCompiled
          r := GetRes(dataFile, 0, "MODULE-FIM-THUMBS.AHK", 10)

       Loop, % realSystemCores
       {
           If IsObject(thumbThread%A_Index%)
              Continue

           If !A_IsCompiled
              thumbThread%A_Index% := ahkthread("#Include *i Lib\module-fim-thumbs.ahk")
           Else If r
              thumbThread%A_Index% := ahkThread(StrGet(&dataFile, r, "utf-8"))

           Sleep, 1
       }

       Loop, % realSystemCores
       {
           goodInit += thumbThread%A_Index%.ahkFunction("initThisThread", GDIPToken "|" mainCompiledPath "|" imgQuality "|" A_Index "|" WICmoduleHasInit)
           Sleep, 1
       }

       multiCoreThumbsInitGood := (goodInit = realSystemCores) ? 1 : 0
       If (multiCoreThumbsInitGood=1)
          addJournalEntry("Succesfully initialized " goodInit " threads.")
       Else
          addJournalEntry("Failed to initialize the auxiliary threads (unknown cause).")
    }

    multiCoreInit := 1
}

getFolderDetails(pathu) {
   FileGetTime, fileMdate, % pathu, M
   FileGetTime, fileCdate, % pathu, C
   FileGetAttrib, fileAttribs, % pathu
   thisFolderDetails := "\" fileMdate "\" fileCdate "\" fileAttribs "\" pathu
   Return thisFolderDetails
}

ToggleThumbsMode() {
   Static lastInvoked := 1, prevIndexu
   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (soloSliderWinVisible=1)
      destroySoloSliderWidget()

   If (A_TickCount - lastInvoked<190) || (A_TickCount - lastOtherWinClose<190)
   {
      lastInvoked := A_TickCount
      Return
   }

   mouseTurnOFFtooltip()
   If (StrLen(mustOpenStartFolder)>3 && !ar)
   {
      currentFileIndex := doOpenStartFolder(didSomething)
      If !didSomething
         Return
   } Else If (thumbsDisplaying=1 && currentFileIndex!=imgIndexEditing)
   {
      ar := askAboutFileSave(" and another image will be loaded", 1, "yes")
      If ar
      {
         If (ar=1)
         {
            SetTimer, PanelSaveImg, -350
            currentFileIndex := imgIndexEditing
         } Else Return
      }
   }

   If (SLDtypeLoaded=1 && FolderExist(StrReplace(CurrentSLD, "|")) && watchFolderDetails && maxFilesIndex>1 && thumbsDisplaying!=1)
   {
      thisFolderDetails := getFolderDetails(StrReplace(CurrentSLD, "|"))
      IF (thisFolderDetails!=watchFolderDetails && !markedSelectFile)
      {
         msgResult := msgBoxWrapper(appTitle ": Folder changed", "The folder currently opened seems to have been changed. Would you like to reload it?", 4, 0, "question")
         If InStr(msgResult, "yes")
            RefreshFilesList()
      }
      watchFolderDetails := thisFolderDetails
   }

   lastInvoked := A_TickCount
   If (maxFilesIndex<1 && thumbsDisplaying!=1)
   {
      showTOOLtip("WARNING: Insufficient indexed files to activate the list view mode")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   currentFileIndex := clampInRange(currentFileIndex, 1, maxFilesIndex)
   interfaceThread.ahkassign("lastCloseInvoked", 0)
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   thisIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIselectWin)
   If (thumbsDisplaying=1)
   {
      lastTimeToggleThumbs := A_TickCount
      fnOutputDebug("Deactivating the thumbnails mode")
      If (thisIndexu!=prevIndexu)
         FadeMainWindow()

      thumbsDisplaying := 0
      Global lastOtherWinClose := A_TickCount
      ; fnOutputDebug("Showing hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("show", hGDIwin)
      uiPanelOpenCloseEvent()
      ; fnOutputDebug("Hiding hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("hide", hGDIthumbsWin)
      fnOutputDebug("Image view initialized")
      dummyTimerDelayiedImageDisplay(50)
      interfaceThread.ahkPostFunction("uiAccessUpdateUiStatusBar", 0, 0, "image")
      If hSNDmediaFile
         MCI_Resume(hSNDmedia)
      lastTimeToggleThumbs := A_TickCount
   } Else If (CurrentSLD && maxFilesIndex>0)
   {
      initQPVmainDLL()
      SetTimer, extraDummyReloadThisPicture, Off
      SetTimer, extraDummyDelayiedImageDisplay, Off
      lastTimeToggleThumbs := A_TickCount
      fnOutputDebug("Initializing thumbnails/list view mode")
      prevLoadedImageIndex := currentFileIndex
      If (prevIndexu!=thisIndexu && thumbsListViewMode=1)
         CreateOSDinfoLine("Generating thumbnails, please wait", 0, 1)

      prevIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
      If (thumbsListViewMode=1 && !isWinXP)
         initAHKhThumbThreads()

      ; If (getCaptionStyle(PVhwnd)=1)
      ;    ToggleTitleBaruNow()
      If hSNDmediaFile
         MCI_Pause(hSNDmedia)

      ; fnOutputDebug("Hiding hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("hide", hGDIwin)
      ; fnOutputDebug("Showing hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("show", hGDIthumbsWin)
      thumbsDisplaying := 1
      uiPanelOpenCloseEvent()
      ; fnOutputDebug("Recalculating thumbnail sizes")
      recalculateThumbsSizes()
      interfaceThread.ahkFunction("uiAccessUpdateUiStatusBar", 0, 0, "list", 0, OSDfontSize, maxFilesIndex)
      UpdateThumbsScreen()
      ; fnOutputDebug("hGDIinfosWin cleaned... " hGDIinfosWin "  -- G= " 2NDglPG "  -- hDC= " 2NDglHDC " ")
      clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
      RemoveTooltip()
      lastTimeToggleThumbs := A_TickCount
   }

   SetTimer, createGUItoolbar, -125
   SetTimer, TriggerMenuBarUpdate, -90
   If (ShowAdvToolbar=1)
      updateTlbrColorsSwatch()
   lastInvoked := A_TickCount
}

TriggerMenuBarUpdate(modus:=0) {
   If (showMainMenuBar!=1 && modus!="forced")
      Return

   modus := (validBMP(UserMemBMP) || (maxFilesIndex>0 && CurrentSLD)) ? modus : "welcome"
   If (drawingShapeNow=1)
      modus := "freeform"

   lastMenuBarUpdated := A_TickCount
   ; interfaceThread.ahkassign("thumbsDisplaying", thumbsDisplaying)
   interfaceThread.ahkPostFunction("UpdateMenuBar", modus)
   SetTimer, refreshEntireViewport, -450
}

refreshEntireViewport() {
   Static prevState := ""
   vpWinClientSize(mainWidth, mainHeight)
   thisState := "a" mainWidth "|" mainHeight "|" showMainMenuBar ToolbarWinW ToolbarWinH TLBRverticalAlign TLBRtwoColumns ToolbarScaleFactor
   If (thisState!=prevState)
   {
      createGDIPcanvas(mainWidth, mainHeight, 1)
      ForceRefreshNowThumbsList()
      recalculateThumbsSizes()
      dummyTimerDelayiedImageDisplay(15)
      prevState := thisState
   }
}

defineThumbsAratio() {
  friendly := (thumbsAratio=1) ? "Wide (1.81)" : "Tall (0.48)"
  If (thumbsAratio=3)
     friendly := "Square (1.00)"

  Return friendly
}

recalculateThumbsSizes() {
   Static theString := "WAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAW"
   , prevDimensions, columnsPossible, txtResH

   If (thumbsAratio=1)
   {
      othumbsW := 300
      othumbsH := 165
   } Else If (thumbsAratio=2)
   {
      othumbsW := 144
      othumbsH := 300
   } Else If (thumbsAratio=3)
   {
      othumbsW := 300
      othumbsH := 300
   }
 
   If (thumbsZoomLevel<0.35)
     thumbsZoomLevel := 0.35
   Else If (thumbsZoomLevel>3)
     thumbsZoomLevel := 3
 
   thumbsH := Round(othumbsH*thumbsZoomLevel)
   thumbsW := Round(othumbsW*thumbsZoomLevel)
   vpWinClientSize(mainWidth, mainHeight)
   If (thumbsH>mainHeight || thumbsW>mainWidth)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//2 - 16, mainHeight//2 - 16, ResizedW, ResizedH)
      If ResizedH
         thumbsH := ResizedH
      If ResizedW
         thumbsW := ResizedW
   }

   If (thumbsColumns>0 && dynamicThumbsColumns=0)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//thumbsColumns, mainHeight, ResizedW, ResizedH)
      z := Round(mainHeight/ResizedH)
      If z
         thumbsH := mainHeight//z
      If ResizedW
         thumbsW := ResizedW

      thumbsW := clampInRange(thumbsW, 80 + Round(OSDfontSize/9), 2048)
      thumbsH := clampInRange(thumbsH, 80 + Round(OSDfontSize/9), 2048)
   }

   If isInRange(max(thumbsW, thumbsH), 0, 150)
      thumbsSizeQuality := 125
   Else If isInRange(max(thumbsW, thumbsH), 151, 290)
      thumbsSizeQuality := 245
   Else If (max(thumbsW, thumbsH)>650)
      thumbsSizeQuality := 755
   Else
      thumbsSizeQuality := 500

   If (thumbsListViewMode>1)
   {
      theseDimensions := "a" mainWidth mainHeight OSDfontSize OSDFontName imgHUDbaseUnit thumbsListViewMode
      If (prevDimensions!=theseDimensions)
      {
         borderSize := imgHUDbaseUnit//5
         txtOptions := "x" borderSize " y" borderSize A_Space " Left cEE090909 r1 s" OSDfontSize//1.25
         thisString := theString "`n" theString
         If (thumbsListViewMode>2)
            thisString .= "`n" theString

         dimensions := Gdip_TextToGraphics(2NDglPG, thisString, txtOptions, OSDFontName, mainWidth, mainHeight, 1, 0)
         txtRes := StrSplit(dimensions, "|")
         txtResW := Ceil(txtRes[3]) + borderSize*2
         txtResH := Ceil(txtRes[4]) + borderSize*2.1
         columnsPossible := Round(mainWidth/txtResW)
         prevDimensions := theseDimensions
      }

      thumbsW := mainWidth//columnsPossible - 5
      thumbsH := Round(txtResH)
   }
}

ToggleThumbsAratio() {
  If (thumbsDisplaying!=1)
     Return

  If (thumbsListViewMode>1)
  {
     ToggleImgNavSizeBox()
     Return
  }

  thumbsAratio++
  If (thumbsAratio>3)
     thumbsAratio := 1

  recalculateThumbsSizes()
  showTOOLtip("Thumbnails intended aspect ratio: " defineThumbsAratio() "`nSize: " thumbsW " x " thumbsH " pixels (" Round(thumbsW/thumbsH, 2) ")" , A_ThisFunc, 1, thumbsAratio/3)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  INIaction(1, "thumbsAratio", "General")
  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(90)
}

ToggleTDupesGroupsFading() {
  If (thumbsDisplaying!=1)
     Return

  recalculateThumbsSizes()
  fadeOtherDupeGroups := !fadeOtherDupeGroups
  friendly := (fadeOtherDupeGroups=2) ? "ACTIVATED" : "DEACTIVATED" 
  showTOOLtip("Fade images not in the active group of duplicates:`n" friendly, A_ThisFunc, 1)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  INIaction(1, "fadeOtherDupeGroups", "General")
  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(90)
}

thumbsInfoYielder(ByRef maxItemsW, ByRef maxItemsH, ByRef maxItemsPage, ByRef maxPages, ByRef startIndex, ByRef mainWidth, ByRef mainHeight) {
   Static prevRealThumbsIndex := -1
   vpWinClientSize(mainWidth, mainHeight) ; global vars:
   maxItemsW := mainWidth//thumbsW               ;    prevStartIndex
   If (maxItemsW<4 && thumbsListViewMode=1)
      maxItemsW := mainWidth//Round(thumbsW*0.95)

   maxItemsH := mainHeight//thumbsH              ;    startPageIndex
   If (maxItemsH<7 && thumbsListViewMode=1)
      maxItemsH := mainHeight//Round(thumbsH*0.95)

   If (maxItemsW<2)                                   ;    currentFileIndex ---
      maxItemsW := 1
   If (maxItemsH<2)
      maxItemsH := 1
 
   maxItemsPage := maxItemsW*maxItemsH
   maxPages := Ceil(maxFilesIndex/maxItemsPage)
   If (maxItemsH=1 && maxItemsW>1)
   {
      hasReversed := 1
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   maxItemsLine := maxItemsW ; *maxItemsH
   maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
   If (maxItemsW=1)
   {
      startIndex := Floor(currentFileIndex/maxItemsLine) * maxItemsLine
      If (startIndex<2)
         startIndex := 1

      ; ToolTip, % startIndex  " -- " prevRealThumbsIndex " || " maxItemsW " -- " maxItemsH , , , 2
      If isInRange(startIndex, prevRealThumbsIndex + maxItemsPage*2, prevRealThumbsIndex - maxItemsPage)
      {
         If isInRange(startIndex, prevRealThumbsIndex, prevRealThumbsIndex + maxItemsPage - maxItemsW)
            startIndex := prevRealThumbsIndex
         Else
            startIndex := (startIndex<prevRealThumbsIndex) ? startIndex : startIndex - maxItemsPage + maxItemsW
      } Else startIndex := Floor(currentFileIndex/maxItemsPage) * maxItemsPage

      maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      prevRealThumbsIndex := startIndex
   } Else
   {
      If (prevRealThumbsIndex=-1)
         prevRealThumbsIndex := currentFileIndex - maxItemsPage//2

      minIndex := prevRealThumbsIndex
      minIndex := ((minIndex//maxItemsLine) * maxItemsLine) + 1
      If (prevRealThumbsIndex != minIndex)
         prevRealThumbsIndex := minIndex
      
      maxIndex := prevRealThumbsIndex + maxItemsPage - 1
      ; DebugMsg("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; DebugMsg("diff check: " Abs(currentFileIndex - minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex - maxIndex) " / " maxItemsLine)
      ; fnOutputDebug("min/max Index: " minIndex " / " maxIndex)
      ; fnOutputDebug("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; fnOutputDebug("diff check: " Abs(currentFileIndex - minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex - maxIndex) " / " maxItemsLine)
      If (Abs(currentFileIndex - minIndex) <= maxItemsLine) || (Abs(currentFileIndex - maxIndex) <= maxItemsLine) || (currentFileIndex>=minIndex && currentFileIndex<=maxIndex)
      { ; just scrolling
          If (currentFileIndex<minIndex)     ; scrolling up
          {
             startIndex := prevRealThumbsIndex-maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("1: startIndex: " startIndex)
          } Else If (currentFileIndex>maxIndex) ; scrolling down
          {
             startIndex := prevRealThumbsIndex+maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("2: startIndex: " startIndex)
          } Else  ; when changing img index but not changing pages
          {
             startIndex := prevRealThumbsIndex
             ; fnOutputDebug("3: startIndex: " startIndex)
          }
      } Else ; this is for a jump
      {
         thisIndexu := currentFileIndex/maxFilesIndex
         startIndex := Floor(maxTotalLines*thisIndexu)*maxItemsW
         ; startIndex := ((currentFileIndex//maxItemsLine) * maxItemsLine) + 1
         prevRealThumbsIndex := startIndex
         ; fnOutputDebug("4: startIndex: " startIndex)
      }

      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      ; maxuStartIndex := (maxFilesIndex>maxItemsPage) ? maxFilesIndex - maxItemsPage + 1 : maxFilesIndex - 1
      ; fnOutputDebug(startIndex  "s -- " prevRealThumbsIndex "p -- " maxuStartIndex " || " maxItemsW "w -- h" maxItemsH)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      If (startIndex>1 && maxFilesIndex<maxItemsPage)
         startIndex := 1

      prevRealThumbsIndex := clampInRange(prevRealThumbsIndex, 1, maxuStartIndex)
   }

   If (hasReversed=1)
   {
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   ; DebugMsg("basics:`r`nmaxItemsPage: " maxItemsPage "`r`nmaxItemsLine: " maxItemsLine "`r`nmin: " minIndex "`r`nmax: " maxIndex "`r`ncurrentFileIndex : " currentFileIndex "`r`n")
   Return "a" startIndex maxItemsW maxItemsH maxItemsPage
}

DeepRefreshThumbsNow() {
   If (thumbsDisplaying!=1 || maxFilesIndex<3)
      Return

   If (markedSelectFile>1)
      setForceRefreshThumbsFilesIndex(1)
   Else
      setForceRefreshThumbsFilesIndex(0)

   dummyTimerDelayiedImageDisplay(50)
}

RefreshThumbsList() {
   mustReloadThumbsList := 1
   dummyTimerDelayiedImageDisplay(50)
}

ForceRefreshNowThumbsList() {
   ; mustReloadThumbsList := 1
   prevStartIndex := -1 ; this will trigger a refresh of the painted thumbnails in the window
   ; dummyTimerDelayiedImageDisplay(50)
}

determineNavKeysDown() {
   If GetKeyState("Up", "P")
      Return 1
   Else If GetKeyState("Down", "P")
      Return 1
   Else If GetKeyState("PgUp", "P")
      Return 1
   Else If GetKeyState("PgDn", "P")
      Return 1
   Else Return 0
}

UpdateThumbsScreen(forceReload:=0, forceFastMode:=0) {
   Critical, on
   Static lastInvoked := 1, prevMW, prevMH, prevNavKeysu := 0
   If (thumbsDisplaying!=1)
      Return

   SetTimer, dummyTimerDelayiedImageDisplay, Off
   SetTimer, dummyTimerReloadThisPicture, Off
   Gdip_ResetClip(glPG)
   startPageIndex := thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
   ; ToolTip, % mainWidth , , , 2
   createGDIPcanvas(mainWidth, mainHeight)
   If (prevMW!=mainWidth || prevMH!=mainHeight)
      recalculateThumbsSizes()

   Gdip_ResetWorldTransform(glPG)
   IMGlargerViewPort := IMGentirelylargerThanVP := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   moda := modus := 0
   skippedKeys := navKeysCounter - prevNavKeysu
   ; ToolTip, % navKeysCounter "|" prevNavKeysu "|" skippedKeys , , , 2
   If (skippedKeys>6 || (A_TickCount - lastInvoked<350) || forceFastMode=1)
   {
      If (forceFastMode!=1)
      {
         lastInvoked := A_TickCount
         prevFullThumbsUpdate := A_TickCount
         prevTryThumbsUpdate := A_TickCount
      }
      SetTimer, RefreshThumbsList, -650
      modus := moda := 1
   } Else If (skippedKeys=0 && (A_TickCount - prevTryThumbsUpdate<230)) && (mustReloadThumbsList!=1 && startPageIndex!=prevFullIndexThumbsUpdate)
   {
      modus := (thumbsListViewMode>1) ? 2 : 1
      moda := (thumbsListViewMode>2) ? 1 : 0
      ; If (startPageIndex!=prevFullIndexThumbsUpdate)
      prevFullThumbsUpdate := A_TickCount
      If determineNavKeysDown()
      {
         prevTryThumbsUpdate := A_TickCount
         SetTimer, RefreshThumbsList, -650
      } Else
         SetTimer, RefreshThumbsList, -300
   }

   If (thumbsListViewMode>1 && (modus>0 || skippedKeys>2))
      QPV_listThumbnailsGridMode(moda, glPG, glHDC, hGDIthumbsWin)
 
   If (modus=0 && skippedKeys<6 && (prevStartIndex!=startPageIndex || mustReloadThumbsList=1 || forceReload=1))
   {
      r := QPV_ShowThumbnails()
      If r
         prevFullIndexThumbsUpdate := startPageIndex
      
      mustReloadThumbsList := 0
   } ; Else r := 1

   mainGdipWinThumbsGrid(0, modus)
   prevStartIndex := startPageIndex
   ; prevRealThumbsIndex := startIndex
   ; lastInvoked := A_TickCount
   prevNavKeysu := navKeysCounter
}

GDIwindowsPosCorrections(whichHwnd:="") {
    Static lastInvoked := 1
    If (A_OSVersion="WIN_7" || isWinXP=1) && (A_TickCount - lastInvoked>100) || (isWinXP=1 && editingSelectionNow=1)
    {
       JEE_ClientToScreen(hPicOnGui1, 0, 0, mainX, mainY)
       If whichHwnd
       {
          WinMove, ahk_id %whichHwnd%,, %mainX%, %mainY%
       } Else
       {
          WinMove, ahk_id %hGDIwin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIthumbsWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIselectWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIinfosWin%,, %mainX%, %mainY%
       }
       lastInvoked := A_TickCount
    } Else If (A_OSVersion="WIN_7" || isWinXP=1)
       SetTimer, GDIwindowsPosCorrections, -50
}

panIMGonScrollBar(doX, doY) {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   vpWinClientSize(mainWidth, mainHeight)
   If (allowFreeIMGpanning=1)
   {
      simplePanIMGonClick("scroll", doX, doY)
      Return
   }
   
   oDx := IMGdecalageX
   oDy := IMGdecalageY
   trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
   thisIndex := 0
   prevState := "a"
   imgPath := getIDimage(currentFileIndex)
   GetMouseCoord2wind(PVhwnd, roX, roY)
   scH := Round(mainHeight * (mainHeight / prevResizedVPimgH) / 2)
   scW := Round(mainWidth * (mainWidth / prevResizedVPimgW) / 2)
   oX := doX , oY := doY
   setWhileLoopExec(1)
   While, (determineLClickState()=1)
   {
      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX -= scW, mY -= scH
      prcW := nprcW := mX/mainWidth
      prcH := nprcH := mY/mainHeight
      If (FlipImgH=1)
         prcW := nprcW := 1 - prcW
      If (FlipImgV=1)
         prcH := nprcH := 1 - prcH

      decX := Round((imgW*nprcW) * zoomLevel)
      decY := Round((imgH*nprcH) * zoomLevel)
      If (FlipImgH=0)
         decX := -decX

      If (FlipImgV=0)
         decY := -decY

      If (doX=1)
      {
         newDecX := (FlipImgH=1) ? -decX : decX
         IMGdecalageX := (A_Index=1) ? (newDecX + oDx)//2 : newDecX
         diffIMGdecX := mX - oX + 2
      } Else
      {
         newDecY := (FlipImgV=1) ? -decY : decY
         IMGdecalageY := (A_Index=1) ? (newDecY + oDy)//2 : newDecY
         diffIMGdecY := mY - oY + 2
      }

      ; ToolTip, % diffIMGdecX "|" diffIMGdecY "`n" DestPosX "|" DestPosY "`n" prevDestPosX "|" prevDestPosY , , , 2
      thisState := "a" IMGdecalageX IMGdecalageY diffIMGdecX diffIMGdecY imgPath currentFileIndex
      If (prevState!=thisState)
      {
         thisIndex++
         prevState := thisState
         dummyResizeImageGDIwin()
      }
      If (thisIndex<4)
        Sleep, 70
   }

   setWhileLoopExec(0)
   vpImgPanningNow := 0
   diffIMGdecX := diffIMGdecY := 0
   ; If (thisIndex>10) || (lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
}

invokeFilesListMapNow() {
   ToolTip, Please wait - generating list map
   listMap := generateFilesListMap("auto")
   ToolTip
   mainGdipWinThumbsGrid(0, 0, listMap[1])
   trGdip_DisposeImage(listMap[1])
   thisVal := listMap[2]
   If (thisVal=2)
      friendly := "SELECTED FILES"
   Else If (thisVal=3)
      friendly := "ALREADY SEEN IMAGES"
   Else If (thisVal=5)
      friendly := "ADDED TO FAVOURITES"
   Else
      friendly := "NONE"

   showDelayedTooltip("Files list map: " friendly)
}

MenuDrawFilesListMap() {
   SetTimer, RemoveTooltip, Off
   lastOSDtooltipInvoked := A_TickCount
   SetTimer, invokeFilesListMapNow, -150
}

ThumbsScrollbar() {
   If (maxFilesIndex<2)
      Return

   vpWinClientSize(mainWidth, mainHeight)
   prevFileIndex := currentFileIndex
   prevu := lastu := -2
   listMap := doMapNow := 0
   If (showFilesListMap=1 && isInRange(markedSelectFile, 2, maxFilesIndex - 2) && maxFilesIndex>10 && minimizeMemUsage!=1)
      doMapNow := 1

   GetMouseCoord2wind(PVhwnd, mX, mY)
   setWhileLoopExec(1)
   startZeit := A_TickCount
   knobSize := getScrollWidth()
   ScrollRegionH := mainHeight - knobSize*1.5 - 4
   offsetu := Round(knobSize*1.5 + 2)
   thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
   ; scrollHeight := getScrollThumbsHeight(ScrollRegionH, maxItemsPage) // 2
   While, (determineLClickState()=1 || A_Index<3)
   {
      If (A_TickCount - startZeit>550 && doMapNow=1)
      {
         doMapNow := 2
         ToolTip, Please wait - generating list map
         listMap := generateFilesListMap()
         ToolTip
      }

      zeitSillyPrevent := A_TickCount
      If (A_Index>2)
         GetMouseCoord2wind(PVhwnd, mX, mY)

      mY := clampInRange(mY + 0 - offsetu, 0, ScrollRegionH - offsetu)
      prcY := Round(mY/(ScrollRegionH - offsetu), 3)
      ; ToolTip, % mY "|" prcY , , , 2
      newIndex := clampInRange(Round(((maxFilesIndex/maxItemsH)*prcY)*maxItemsH), 1, maxFilesIndex)
      ; newIndex := clampInRange(Ceil((maxFilesIndex/100)*mYperc), 1, maxFilesIndex)
      ; mapOffset := - clampInRange(mY * 2, 0, mainHeight*2 - 1)
      If (lastu!=newIndex)
      {
         lastu := newIndex
         currentFileIndex := newIndex
         thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
         modus := (thumbsListViewMode>1) ? 2 : 1
         moda := (thumbsListViewMode>2) ? 1 : 0
         If (startIndex!=prevu)
         {
            prevu := startIndex
            If (thumbsListViewMode>1)
               QPV_listThumbnailsGridMode(moda, glPG, glHDC, hGDIthumbsWin)
            Else
               filterDelayiedImageDisplay()
         }
         mainGdipWinThumbsGrid(0, modus, listMap[1], "scroll", listMap[3])
      }
   }

   setWhileLoopExec(0)
   trGdip_DisposeImage(listMap[1])
   If (GetKeyState("Shift", "P"))
   {
      keyu := (currentFileIndex>prevFileIndex) ? "Down" : "Home"
      thumbsSelector(keyu, "+Shift", prevFileIndex)
   }
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(250)
}

setWhileLoopExec(val) {
   whileLoopExec := val
   interfaceThread.ahkassign("whileLoopExec", val)
}

simplePanIMGonClick(modus:=0, doX:=1, doY:=1, bX:=0, bY:=0) {
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   vpWinClientSize(mainWidth, mainHeight)
   If (modus="scroll")
      JEE_ClientToScreen(hGDIwin, lastLclickX, lastLclickY, oX, oY)
   Else
      GetPhysicalCursorPos(oX, oY)
   ; ToolTip, % modus "=l" , , , 2
   oDx := IMGdecalageX, oDy := IMGdecalageY
   minTopCornerX := (allowFreeIMGpanning=1) ? mainWidth : 0
   minTopCornerY := (allowFreeIMGpanning=1) ? mainHeight : 0
   lastInvoked := A_TickCount
   normalModeZeit := thisZeit := 1
   vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
   prevMX := oX, prevMY := oY
   prevState := thisIndex := 0
   thisZL := (zoomLevel>8) ? 8 : 0.8 + zoomLevel
   ; ToolTip, % "l=" thisZL , , , 2
   setWhileLoopExec(1)
   If (modus="scroll")
      wrapResizeImageGDIwin()

   imgW := prevResizedVPimgW
   imgH := prevResizedVPimgH
   vrSizeX := imgW + mainWidth*2
   vrSizeY := imgH + mainHeight*2
   While, (determineLClickState()=1)
   {
      If (allowFreeIMGpanning=1 && modus="scroll")
         GetMouseCoord2wind(PVhwnd, mX, mY)
      Else
         GetPhysicalCursorPos(mX, mY)

      moX := (FlipImgH=1) ? mainWidth - mX : mX
      moY := (FlipImgV=1) ? mainHeight - mY : mY
      calculateScrollBars(prevResizedVPimgW, prevResizedVPimgH, prevDestPosX, prevDestPosY, mainWidth, mainHeight, knobW, knobH, knobX, knobY)
      scrolly := (doX=1) ? isInRange(moX, knobX, knobX + knobW) : isInRange(moY, knobY, knobY + knobH)
      thisState := mX "=" mY "=" prevResizedVPimgW "=" prevResizedVPimgH
      If ((thisState!=prevState && allowFreeIMGpanning=1 && modus="scroll") && (A_TickCount - lastInvoked>30))
      {
         prevState := thisState
         prcX := moX/mainWidth
         prcY := moY/mainHeight
         If (doX=1)
            IMGdecalageX := Round(weighTwoValues(mainWidth*2, mainWidth, prcX) - vrSizeX*prcX)
         If (doY=1)
            IMGdecalageY := Round(weighTwoValues(mainHeight*2, mainHeight, prcY) - vrSizeY*prcY)

         diffIMGdecX := diffIMGdecY := 1
         dummyResizeImageGDIwin()
         Sleep, -1
         thisIndex := !thisIndex
         lastInvoked := A_TickCount
         ; ToolTip, % prcY "|" IMGdecalageY "|" vrSizeY "|" imgH , , , 2
      } Else If (allowFreeIMGpanning=1 && modus="scroll")
      {
         Sleep, -1
      } Else
      {
         If (scrolly=1)
            normalModeZeit := A_TickCount

         diffIMGdecX := Dx := Ceil((mX - oX)*thisZL)
         diffIMGdecY := Dy := Ceil((mY - oY)*thisZL)
         If (modus="navBox")
         {
            Dx := -3*Dx * (zoomLevel//2 + 1)
            Dy := -3*Dy * (zoomLevel//2 + 1)
         } Else If (modus="scroll")
         {
            Dx := -1*Dx
            Dy := -1*Dy
         }

         If (doX=1)
            IMGdecalageX := (FlipImgH=1) ? oDx - Dx : oDx + Dx
         If (doY=1)
            IMGdecalageY := (FlipImgV=1) ? oDy - Dy : oDy + Dy

         ; ToolTip, % Dx "|" Dy , , , 2
         limitPanningDist(oDx, oDy, minTopCornerX, minTopCornerY)
         If (!isDotInRect(mX, mY, prevMX - 5, prevMX + 5, prevMY - 5, prevMY + 5) && (A_TickCount - thisZeit>15))
         {
            thisIndex++
            zeitSillyPrevent := A_TickCount
            dummyResizeImageGDIwin()
            prevMX := mX
            prevMY := mY
            thisZeit := A_TickCount
         }
      }
   }

   setWhileLoopExec(0)
   If (bX && bY)
      doSetCursorPos(bX, bY)

   vpImgPanningNow := diffIMGdecX := diffIMGdecY := 0
   ; If (thisIndex>10 || lastWasLowQuality=1 || allowFreeIMGpanning=1 || modus="scroll")
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
}

limitPanningDist(ByRef oDx, ByRef oDy, minTopCornerX, minTopCornerY) {
   If (oDx>=minTopCornerX)
      oDx := minTopCornerX
   Else If (oDx<imgDecLX)
      oDx := imgDecLX

   If (oDy>=minTopCornerY)
      oDy := minTopCornerY
   Else If (oDy<imgDecLY)
      oDy := imgDecLY
}

winSwipeAction(thisCtrlClicked, mainParam) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   didSomething := 1
   infoImgEditingMode := (editingSelectionNow=1 || imgEditPanelOpened=1) ? 1 : 0
   infoPannable := ((IMGlargerViewPort=1 || allowFreeIMGpanning=1) && thumbsDisplaying!=1 && IMGresizingMode=4) ? 1 : 0
   If (infoPannable=1 && InStr(thisCtrlClicked, "|PicOnGUI2b|"))
   || (infoPannable=1 && (InStr(thisCtrlClicked, "|PicOnGUI3|") || InStr(thisCtrlClicked, "|PicOnGUI1|")) && infoImgEditingMode=1)
   {
      SetTimer, simplePanIMGonClick, -5
      Return 0
   }

   startZeit := A_TickCount
   ; GetPhysicalCursorPos(oX, oY)
   JEE_ClientToScreen(hGDIwin, lastLclickX, lastLclickY, oX, oY)
   SelDotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
   dotSize := Round(SelDotsSize*2.5)
   lowerLimitRatio := (IMGresizingMode=4) ? 0.4 : 0.4
   GetPhysicalCursorPos(mX, mY)
   vpWinClientSize(mainWidth, mainHeight)
   setWhileLoopExec(1)
   While, (determineLClickState()=1 || A_Index<2)
   {
      GetPhysicalCursorPos(mX, mY)
      diffx := snapToValues(Abs(mX - oX), 1, mainWidth, 10, 0)
      diffy := snapToValues(Abs(mY - oY), 1, mainHeight, 10, 0)
      dirX := (mX - oX) < 0 ? -1 : 1
      dirY := (mY - oY) < 0 ? -1 : 1
      ratioDiffs := diffx/diffy
      If (diffx>45 || diffy>45) && (ratioDiffs<lowerLimitRatio || ratioDiffs>3)
      {
         Sleep, 1
         zeitSillyPrevent := A_TickCount
         swipeAct := (ratioDiffs<lowerLimitRatio) ? 1 : 2
         If (ratioDiffs="")
            swipeAct := 0
      } Else swipeAct := 0 ;  Tooltip
      ; Sleep, 5
      ; ToolTip, % swipeAct " - " thisCtrlClicked " - " ratioDiffs "`n" diffx "==" diffy "`n" dirX "==" dirY

      stepFactor := 1
      doNextSlide := doPrevSlide := doZoomChange := doFrameChange := 0
      If (!swipeAct && isDotInRect(mX, mY, oX - dotSize, oX + dotSize, oY - dotSize, oY + dotSize))
      {
         zeitSillyPrevent := 1
         If InStr(thisCtrlClicked, "|PicOnGUI3|")
         {
            If (infoImgEditingMode!=1)
               doNextSlide := 1
         } Else If InStr(thisCtrlClicked, "|PicOnGUI1|" )
         {
            If (infoImgEditingMode!=1)
               doPrevSlide := 1
         } Else If InStr(thisCtrlClicked, "|PicOnGUI2a|")
         {
            doZoomChange := 1
         } Else If InStr(thisCtrlClicked, "|PicOnGUI2c|")
         {
            doZoomChange := -1
         }
      } Else If (swipeAct=1)
      {
         stepFactor := (diffy/mainHeight)*10 + 1.25
         ; ToolTip, % stepFactor " = " dirY , , , 2
         doZoomChange := dirY
         ;  VPchangeZoom(dirY, 0, stepFactor)
      } Else If (swipeAct=2 && infoImgEditingMode!=1)
      {
         If (dirX=1)
            doNextSlide := 1
         Else If (dirX=-1)
            doPrevSlide := 1
      }

      If ((doNextSlide || doPrevSlide) && totalFramesIndex>1)
      {
         JEE_ScreenToClient(hGDIwin, mX, mY, pX, pY)
         If (pY>mainHeight*0.7)
         {
            doFrameChange := (doNextSlide=1) ? 1 : -1
            doNextSlide := doPrevSlide := 0
         }
      }

      If (A_TickCount - startZeit>350 && InStr(mainParam, "pen-") && !swipeAct)
         doNextSlide := doPrevSlide := doZoomChange := doFrameChange := 0

      If doFrameChange
      {
         friendly := (doFrameChange=1) ? "Next" : "Previous"
         showTOOLtip(friendly " frame", 0, "swipe-mode")
      } Else If (doNextSlide || doPrevSlide)
      {
         friendly := (doNextSlide=1) ? "Next" : "Previous"
         showTOOLtip(friendly " slide", 0, "swipe-mode")
      } Else If doZoomChange
      {
         friendly := (doZoomChange=1) ? "in" : "out"
         zl := decideNewVPzoomLevel(zoomLevel, 0, doZoomChange, stepFactor)
         showTOOLtip("Zoom " friendly ": " Round(zl*100) "%", 0, "swipe-mode")
      } Else 
      {
         toolTipGuiCreated := 0
         interfaceThread.ahkassign("toolTipGuiCreated", 0)
         clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
      }
   }

   setWhileLoopExec(0)
   lastSwipeZeitGesture := A_TickCount
   If (doFrameChange || doNextSlide || doPrevSlide || doZoomChange)
      interfaceThread.ahkassign("lastSwipeZeitGesture", lastSwipeZeitGesture)

   didSomething := 1
   If doFrameChange
      changeDesiredFrame(doFrameChange)
   Else If doNextSlide
      GoNextSlide()
   Else If doPrevSlide
      GoPrevSlide()
   Else If doZoomChange
      VPchangeZoom(doZoomChange, 0, stepFactor)
   Else 
      didSomething := 0

   lastSwipeZeitGesture := A_TickCount
   If didSomething
      interfaceThread.ahkassign("lastSwipeZeitGesture", lastSwipeZeitGesture)
   Else
      zeitSillyPrevent := 1

   Return didSomething
}

GetMouseCoord2wind(hwnd, ByRef nX, ByRef nY) {
    ; CoordMode, Mouse, Screen
    MouseGetPos, oX, oY
    If (hwnd=PVhwnd && ShowAdvToolbar=1 && lockToolbar2Win=1)
       JEE_ScreenToClient(hGDIwin, oX, oY, nX, nY)
    Else
       JEE_ScreenToClient(hwnd, oX, oY, nX, nY)
}

doLayeredWinUpdate(funcu, hwnd, HDCu, opacity:=255) {
  If (debugModa=2)
  {
     ; If (hwnd=hGDIselectWin)
     ;    opacity := 120

     If (hwnd=hGDIwin)
        nameHwnd := "hGDIwin"
     Else If (hwnd=hGDIthumbsWin)
        nameHwnd := "hGDIthumbsWin"
     Else If (hwnd=hGDIselectwin)
        nameHwnd := "hGDIselectwin"
     Else If (hwnd=hGDIinfosWin)
        nameHwnd := "hGDIinfosWin"
     Else
        nameHwnd := "unknownWin"

     If (HDCu=2NDglHDC)
        nameDCu := "2NDglHDC"
     Else If (HDCu=glHDC)
        nameDCu := "glHDC"
     Else
        nameDCu := "unknownHDC"

     fnOutputDebug(A_ThisFunc "(): " funcu " = " nameHwnd " = " nameDCu)
  }

  vpWinClientSize(mainWidth, mainHeight)
  xPos := 0, yPos := 0
  If (A_OSVersion="WIN_7" || isWinXP=1)
  {
     JEE_ClientToScreen(hPicOnGui1, 0, 0, xPos, yPos)
  } Else If (ShowAdvToolbar=1 && lockToolbar2Win=1)
  {
     hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
     If (hasTrans=1)
        xPos += ToolbarWinW
     If (hasTrans=2)
        yPos += ToolbarWinH
  }

  rr := UpdateLayeredWindow(hwnd, HDCu, xPos, yPos, mainWidth, mainHeight, opacity)
  If !rr
     addJournalEntry(A_ThisFunc "(): ERROR. Failed to update window: " hwnd ". Device context: " HDCu ". Invoked by: " funcu)

  Return rr
}

vpWinClientSize(ByRef w, ByRef h, hwnd:=0, mode:=0) {
  Static lastInvoked := 1, pW, pH, pa

  If !hwnd
     hwnd := PVhwnd

  If ((A_TickCount - lastInvoked<70) && pW && pH && pa=hwnd)
  {
     w := pW, h := pH
     Return
  }

  p := GetWinClientSize(w, h, hwnd, mode)
  If (ShowAdvToolbar=1)
     hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
  If (hasTrans=1)
     w -= ToolbarWinW
  If (hasTrans=2)
     h -= ToolbarWinH

  pW := w, pH := h, pa := hwnd
  lastInvoked := A_TickCount
  Return p
}

BtnSetBrushSymmetryCoords() {
   If (BrushToolType>5)
   {
      showTOOLtip("WARNING: Symmetry painting not available for the current brush type")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (AnyWindowOpen!=64 || !isImgEditingNow())
      Return

   BrushToolSymmetryX .= "c"
   liveDrawingBrushTool := 1
   showTOOLtip("Please click inside the image area to set the symmetry axis")
   ; SetTimer, RemoveTooltip, % -msgDisplayTime//2
   mustCaptureCloneBrush := 1
   interfaceThread.ahkPostFunction("setMenuBarState", "Disable", "PVmenu")
   interfaceThread.ahkassign("mustCaptureCloneBrush", mustCaptureCloneBrush)
   createGUItoolbar()
   If (panelWinCollapsed=0)
      toggleImgEditPanelWindow()
   dummyTimerDelayiedImageDisplay(50)
}

setNewBrushSymmetryPoints() {
   whichBitmap := useGdiBitmap()
   vpWinClientSize(mainWidth, mainHeight)
   trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
   thisZeit := kX := kY := 0
   BrushToolSymmetryX := SubStr(BrushToolSymmetryX, 1, 1)
   setWhileLoopExec(1)
   While, (determineLClickState()=1)
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
      ; tinyPrevAreaCoordX := kX, tinyPrevAreaCoordY := kY
      showTOOLtip("Symmetry point coordinates set to`n" kX " / " kY)
      BrushToolSymmetryPointX := Round(kX/imgW, 5)
      BrushToolSymmetryPointY := Round(kY/imgH, 5)
      If (A_TickCount - thisZeit>90)
      {
         dummyRefreshImgSelectionWindow()
         thisZeit := A_TickCount
      }
   }

   If (BrushToolSymmetryX=0 && BrushToolSymmetryY=0)
   {
      BrushToolSymmetryX := 1
      GuiControl, SettingsGUIA:, BrushToolSymmetryX, 1
   }

   setWhileLoopExec(0)
   endCaptureCloneBrush()
   If (panelWinCollapsed=1)
      toggleImgEditPanelWindow()

   SoundBeep , 900, 100
   dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

drawInactiveSelArea() {
   If identifyThisWin()
   {
      lastZeitFileSelect := A_TickCount//2
      dummyRefreshImgSelectionWindow()
      Return
   }

   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
   ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   vpWinClientSize(mainWidth, mainHeight)
   setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
   SkeletDrawSelectionBox()
   Gdip_ResetWorldTransform(2NDglPG)
}

MouseMoveResponder(actu:=0) {
  Static prevState := "C", prevMouseCoords := [], lastInvoked := 1, prevDotu := -1
  If (actu="rem")
  {
     prevDotu := prevState := "-"
     prevMouseCoords := []
     clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
     Return
  }

  If (toolTipGuiCreated=2)
  {
     SetTimer, RemoveTooltip, % -msgDisplayTime*4
     Return
  }

  If (A_TickCount - lastOSDtooltipInvoked<625)
  {
     SetTimer, MouseMoveResponder, -350
     Return
  }

  brushingMode := (liveDrawingBrushTool=1 && AnyWindowOpen=64) || (FloodFillSelectionAdj!=1 && AnyWindowOpen=66) ? 1 : 0
  If (editingSelectionNow=1 && thumbsDisplaying=0 && actu="krill" && drawingShapeNow!=1 && (A_TickCount - lastMenuZeit>250))
  {
     If identifyThisWin()
        SetTimer, dummyRefreshImgSelectionWindow, -150
     Else If (AnyWindowOpen!=12)
        SetTimer, drawInactiveSelArea, -150
  } Else If (drawingShapeNow=1)
  {
     ; Sleep, -1
     ; dummyRefreshImgSelectionWindow()
     SetTimer, dummyRefreshImgSelectionWindow, -2
  } Else If (liveDrawingBrushTool=1 && AnyWindowOpen && AnyWindowOpen!=66)
  {
     brushSize := (BrushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
     thisSize := (AnyWindowOpen=64) ? brushSize * zoomLevel : brushSize * viewportDynamicOBJcoords.zl
     Gdip_ResetClip(2NDglPG)
     vpWinClientSize(mainWidth, mainHeight)
     Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
     If (GetKeyState("CapsLock", "T") || mustCaptureCloneBrush=1 || whileLoopExec=1)
     {
        doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
        Return
     }

     setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
     If (thisSize>10)
     {
        ; Gdip_SetClipRect(2NDglPG, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, 0)
        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight, 0)
        If (BrushToolOutsideSelection>1 && AnyWindowOpen=64 && editingSelectionNow=1)
        {
           trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
           ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, imgW, imgH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
           ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
           modus := (BrushToolOutsideSelection=3) ? 4 : 1
           Gdip_SetClipPath(2NDglPG, ImgSelPath, modus)
        }

        GetMouseCoord2wind(PVhwnd, mX, mY)
        If ((A_TickCount - lastInvoked > 90) && BrushToolAutoAngle=1)
        {
           If (prevMouseCoords[1] && prevMouseCoords[2]
           && !isDotInRect(mX, mY, prevMouseCoords[1] - 10, prevMouseCoords[1] + 10, prevMouseCoords[2] - 10, prevMouseCoords[2] + 10))
           {
              newAngle := MouseDeltaAngle180(prevMouseCoords[1], prevMouseCoords[2], mX, mY)
              If (newAngle<0)
                 newAngle := 360 - Abs(newAngle)/2
              If (prevMouseCoords[3]<90 && newAngle>270)
                 prevMouseCoords[3] := 360 + prevMouseCoords[3]/2
              If (prevMouseCoords[3]!="")
                 newAngle := (newAngle + prevMouseCoords[3] + prevMouseCoords[3])/3
              If (newAngle>360)
                 newAngle -= 360

              prevMouseCoords[3] := newAngle
           }

           prevMouseCoords[1] := mX, prevMouseCoords[2] := mY
           lastInvoked := A_TickCount
           If (newAngle && !determineLClickState())
              BrushToolAngle := Round(newAngle) - 180
        }
 
        mX := (FlipImgH=1) ? mainWidth - mX : mX
        mY := (FlipImgV=1) ? mainHeight - mY : mY
        tmpPath := createBrushShapePath(thisSize, mX, mY, BrushToolAspectRatio, BrushToolAngle + 180)
        Gdip_SetPenWidth(pPen1d, SelDotsSize/3 + 1)
        Gdip_SetPenWidth(pPen2, SelDotsSize/5 + 1)

        Gdip_ResetWorldTransform(2NDglPG)
        If (showHUDnavIMG=1)
           Gdip_SetClipRect(2NDglPG, HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[5], HUDobjNavBoxu[6], 4)

        If (showHistogram>1)
           Gdip_SetClipRect(2NDglPG, HUDobjHistoBoxu[3], HUDobjHistoBoxu[4], HUDobjHistoBoxu[1], HUDobjHistoBoxu[2], 4)

        knobSize := getScrollWidth()
        If (scrollBarHy>1)
           Gdip_SetClipRect(2NDglPG, 0, mainHeight - knobSize, mainWidth, knobSize, 4)

        If (scrollBarVx>1)
           Gdip_SetClipRect(2NDglPG, mainWidth - knobSize, 0, knobSize, mainHeight, 4)

        setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
        Gdip_DrawPath(2NDglPG, pPen2, tmpPath)
        Gdip_DrawPath(2NDglPG, pPen1d, tmpPath)
        Gdip_DeletePath(tmpPath)
        ; ToolTip, % BrushToolAngle " == " newAngle , , , 2

        brushSofty := (100 - BrushToolSoftness)/100
        brushSize := (brushSize*brushSofty)*zoomLevel
        If (BrushToolType!=1 && isInRange(BrushToolSoftness, 2, 98) && brushSize>9)
        {
           tmpPath2 := createBrushShapePath(brushSize, mX, mY, BrushToolAspectRatio, BrushToolAngle + 180)
           ; Gdip_DrawPath(2NDglPG, pPen2, tmpPath2)
           Gdip_DrawPath(2NDglPG, pPen1d, tmpPath2)
           Gdip_DeletePath(tmpPath2)
        }

        Gdip_ResetClip(2NDglPG)
        If ImgSelPath
           Gdip_DeletePath(ImgSelPath)
     }
     Gdip_ResetWorldTransform(2NDglPG)
     doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
  } Else If (editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1 && drawingShapeNow!=1 && brushingMode!=1)
  {
     ; ToolTip, % SelDotsSize , , , 2
     vpWinClientSize(mainWidth, mainHeight)
     GetMouseCoord2wind(PVhwnd, mX, mY)
     dotActiveObj := determineSelAreaClickRect(mX, mY, SelDotsSize, mainWidth, mainHeight, 1)
     If isFreeHandModus(dotActiveObj.n)
        dotActiveObj.n := 0
     Else If !identifyThisWin()
        dotActiveObj.n := 0

     Gdip_SetPenWidth(pPen7, SelDotsSize)
     If (dotActiveObj.n=9)
        thisState := "A"
     Else If (dotActiveObj.n=0)
        thisState := "C"
     Else
        thisState := "B"

     If (thisState="B" && dotActiveObj.n!=prevDotu) ; && prevState!=thisState)
     {
        SetTimer, dummyAutoClearSelectionHighlight, Off
        prevDotu := dotActiveObj.n
        ; changeMcursor("finger")
        prevState := thisState
        Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
        Gdip_SetPenWidth(pPen1d, SelDotsSize/2)
        getVPselSize(imgSelW, imgSelH, 0, 0)
        tooBig := (imgSelW>mainWidth*1.5 && imgSelH>mainHeight*1.5 || imgSelW>mainWidth*2.5 || imgSelH>mainHeight*2.5) ? 1 : 0
        thisPen := (tooBig=1 || imgSelLargerViewPort=1) ? pPen1 : pPen1d
        If (dotActiveObj.n=9)
        {
           thisu := clampValuesToWindow(dotActiveObj.gx + SelDotsSize/2, dotActiveObj.gy + SelDotsSize/2, dotActiveObj.w, dotActiveObj.h, mainWidth, mainHeight)
           Gdip_DrawRectangle(2NDglPG, thisPen, thisu.X, thisu.Y, thisu.W, thisu.H)
        } Else
        {
           If InStr(dotActiveObj.line, "|")
           {
              Gdip_DrawLines(2NDglPG, thisPen, dotActiveObj.line)
              Gdip_FillEllipse(2NDglPG, pBrushC, dotActiveObj.cx2 - SelDotsSize, dotActiveObj.cy2 - SelDotsSize, SelDotsSize*2, SelDotsSize*2)
           } Else
           {
              thisu := clampValuesToWindow(dotActiveObj.gx + SelDotsSize/2, dotActiveObj.gy + SelDotsSize/2, dotActiveObj.w, dotActiveObj.h, mainWidth, mainHeight)
              Gdip_DrawLine(2NDglPG, thisPen, dotActiveObj.line, dotActiveObj.cy1, dotActiveObj.cx2, dotActiveObj.cy2)
           }
        }
        doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
     } Else If (thisState="A" && prevState!=thisState)
     {
        ; changeMcursor("move")
        prevState := "A"
        prevDotu := dotActiveObj.n
        Gdip_SetPenWidth(pPen1d, SelDotsSize/2)
        Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
        selX := dotActiveObj.gx + SelDotsSize/2
        selY := dotActiveObj.gy + SelDotsSize/2
        selW := dotActiveObj.w
        selH := dotActiveObj.h
        ; ToolTip, % selX "=" selY "`n" selW "=" selH , , , 2
        Gdip_FillEllipse(2NDglPG, pBrushD, selX + selW/2 - SelDotsSize/3, selY + selH/2 - SelDotsSize/3, SelDotsSize*0.7, SelDotsSize*0.7)
        thisu := clampValuesToWindow(selX, selY, selW, selH, mainWidth, mainHeight)
        Gdip_FillRectangle(2NDglPG, pBrushF, thisu.X, thisu.Y, thisu.W, thisu.H)
        Gdip_DrawRectangle(2NDglPG, pPen1d, thisu.X, thisu.Y, thisu.W, thisu.H)
        doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
        SetTimer, dummyAutoClearSelectionHighlight, -150
     } Else If (thisState="C" && prevState!=thisState)
     {
        SetTimer, dummyAutoClearSelectionHighlight, Off
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevDotu := dotActiveObj.n
        prevState := "C"
     }
  } Else
  {
     prevDotu := dotActiveObj.n
     If (prevState!="C")
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
     prevState := "C"
  }
}

dummyAutoClearSelectionHighlight() {
  MouseGetPos, , , OutputVarWin
  ; ToolTip, % OutputVarWin "===" PVhwnd , , , 2
  If (OutputVarWin!=PVhwnd)
     MouseMoveResponder("rem")
  Else If (editingSelectionNow=1)
     SetTimer, dummyAutoClearSelectionHighlight, -150
}

applyIMGeditKeepWin() {
   o := closeEditPanelOnApply
   closeEditPanelOnApply := 0
   GuiControl, SettingsGUIA:, closeEditPanelOnApply, 0
   applyIMGeditFunction()
   Sleep, 2
   CreateTempGuiButton("Undo action,,ImgUndoAction||Reopen panel,,openPreviousPanel", 0, msgDisplayTime//1.5 + 500)
   closeEditPanelOnApply := o
   GuiControl, SettingsGUIA:, closeEditPanelOnApply, % o
}

applyIMGeditFunction() {
    ; recordSelUndoLevelNow()
    GuiControl, SettingsGUIA: Disable, btnLiveApplyTool
    If isNowAlphaPainting()
    {
       toggleAlphaPaintingMode()
       GuiControl, SettingsGUIA: Enable, btnLiveApplyTool
       Return
    }
    If (viewportQPVimage.imgHandle)
       imgFxMode := 1

    If (AnyWindowOpen=24 || AnyWindowOpen=31)
       BtnPasteInSelectedArea()
    Else If (AnyWindowOpen=30)
       BtnDrawLinesSelectedArea()
    Else If (AnyWindowOpen=32)
       BtnInsertTextSelectedArea()
    Else If (AnyWindowOpen=23)
       BtnFillSelectedArea()
    Else If (AnyWindowOpen=25)
       BtnEraseSelectedArea()
    Else If (AnyWindowOpen=68)
       BtnFillBehindSelectedArea()
    Else If (AnyWindowOpen=55)
       BtnGraySelectedArea()
    Else If (AnyWindowOpen=65)
       BtnDrawShapeSelectedArea()
    Else If (AnyWindowOpen=74)
       BtnAdjustColorsImgSelectedArea()
    Else If (AnyWindowOpen=81)
       BtnSymmetrySelectedArea()
    Else If (AnyWindowOpen=89)
       BtnAdjustColorsSimpleImgSelArea()
    Else
       BtnCloseWindow()

    SetTimer, RemoveTooltip, -300
    If AnyWindowOpen
       GuiControl, SettingsGUIA: Enable, btnLiveApplyTool
}

livePreviewPasteInPlace() {
   If (forceLiveAlphaPreviewMode=1 && liveDrawingBrushTool=1)
      livePreviewAlphaMasking("live")
   Else
      corePasteInPlaceActNow(0, 0)
}

livePreviewFillSelectedArea() {
   If (viewportQPVimage.imgHandle)
      livePreviewHugeImageFillSelArea()
   Else If (forceLiveAlphaPreviewMode=1 && liveDrawingBrushTool=1)
      livePreviewAlphaMasking("live")
   Else
      coreFillSelectedArea(1, -1, liveDrawingBrushTool)
}

dummyLivePreviewsDelayer() {
   livePreviewsImageEditing(0, A_ThisFunc)
}

livePreviewsImageEditing(modus:=0, doTimer:=0, hwnd:=0, eventu:=0) {
   ; function meant to filter out repeated calls
   Static prev := -1
   WinGetClass, WinClass, ahk_id %hwnd%
   If (StrLen(doTimer)>2 && InStr(WinClass, "_trackbar"))
   {
      okay := (prev=5 && eventu=4) ? 0 : 1
      ; fnOutputDebug("slider:" hwnd " = " eventu "=" okay)
      If (eventu!="normal" && okay=1)
         SetTimer, dummyLivePreviewsDelayer, -25
      prev := eventu
   } Else
   {
      ; fnOutputDebug("weeeeeeeeeeeeeee: " doTimer)
      corelivePreviewsImageEditing(modus)
   }
}

corelivePreviewsImageEditing(modus:=0) {
   Critical, on
   If (imgEditPanelOpened!=1 || thumbsDisplaying=1)
      Return

   If (toolTipGuiCreated=2 && WinActive("A")!=PVhwnd)
      RemoveTooltip()

   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
   vpWinClientSize(mainWidth, mainHeight)
   createGDIPcanvas(mainWidth, mainHeight)
   If (modus!="live-selection")
      setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)

   If ((imgSelX2="C" || imgSelY2="C" || imgSelX2=-1 || imgSelY2=-1) && editingSelectionNow=1 && modus="coords")
   {
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      createDefaultSizedSelectionArea(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgW, imgH, mainWidth, mainHeight)
      ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, imgW, imgH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   }

   If (vpImgPanningNow!=1)
   {
      If (dynamicLiveObjVisible=0)
         toggleLiveEditObject()

      okayu := (A_TickCount - prevImgEditZeit>350) ? 1 : 0
      If (AnyWindowOpen=24 || AnyWindowOpen=31)
         livePreviewPasteInPlace()
      Else If (AnyWindowOpen=23 && (okayu=1 || liveDrawingBrushTool=1))
         livePreviewFillSelectedArea()
      Else If (AnyWindowOpen=25 && okayu=1)
         livePreviewEraseArea()
      Else If (AnyWindowOpen=30 && okayu=1)
         coreDrawLinesStuffTool("parametric")
      Else If (AnyWindowOpen=32 && (okayu=1 || liveDrawingBrushTool=1))
         livePreviewInsertTextinArea(0, liveDrawingBrushTool)
      Else If (AnyWindowOpen=55 && okayu=1)
         livePreviewDesaturateArea()
      Else If (AnyWindowOpen=65 && okayu=1)
         coreDrawLinesStuffTool("shapes")
      Else If (AnyWindowOpen=68 && okayu=1)
         livePreviewFillBehindArea()
      Else If (AnyWindowOpen=70 && (okayu=1 || liveDrawingBrushTool=1))
         livePreviewAlphaMasking("live")
      Else If (AnyWindowOpen=74)
         livePreviewAdjustColorsArea()
      Else If (AnyWindowOpen=81 && okayu=1)
         livePreviewSymmetricaImgArea()
      Else If (AnyWindowOpen=89 && okayu=1)
         livePreviewSimpleColorsAdjustImage()
   }

   fnOutputDebug("redraw: " A_ThisFunc)
   If (showViewPortGrid=1 && imgEditPanelOpened=1)
      drawVPgridsNow(mainWidth, mainHeight, 2NDglPG)

   If (editingSelectionNow=1 && doImgEditLivePreview!=1)
      drawImgSelectionOnWindow("active", "-", "-", "-", mainWidth, mainHeight, prevResizedVPimgW, prevResizedVPimgH, prevDestPosX, prevDestPosY)

   If (modus!="live-selection")
      Gdip_ResetWorldTransform(2NDglPG)

   If (scrollBarHy>0)
   {
      Gdip_SetClipRect(2NDglPG, 0, mainHeight - scrollBarHy, mainWidth, scrollBarHy)
      Gdip_GraphicsClear(2NDglPG)
   }

   If (scrollBarVx>0)
   {
      Gdip_SetClipRect(2NDglPG, mainWidth - scrollBarVx, 0, scrollBarVx, mainHeight)
      Gdip_GraphicsClear(2NDglPG)
   }

   r := doLayeredWinUpdate(A_ThisFunc, hGDIwin, 2NDglHDC)
   If (scrollBarHy>0 || scrollBarVx>0)
      Gdip_ResetClip(2NDglPG)
   Return r
}

isVPselLarger(mainWidth:=0, mainHeight:=0) {
   If (!mainWidth || !mainHeight)
      vpWinClientSize(mainWidth, mainHeight)

   nImgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := min(imgSelY1, imgSelY2)
   nImgSelX2 := max(imgSelX1, imgSelX2)
   nImgSelY2 := max(imgSelY1, imgSelY2)

   zImgSelX1 := prevDestPosX + Round(nImgSelX1*zoomLevel)
   zImgSelY1 := prevDestPosY + Round(nImgSelY1*zoomLevel)
   zImgSelX2 := prevDestPosX + Round(nImgSelX2*zoomLevel)
   zImgSelY2 := prevDestPosY + Round(nImgSelY2*zoomLevel)

   vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
   vPimgSelX := min(zImgSelX1, zImgSelX2) + dotsSize//2
   vPimgSelY := min(zImgSelY1, zImgSelY2) + dotsSize//2

   larger := (vPimgSelH>mainHeight*2 || vPimgSelW>mainWidth*2) ? 1 : 0
   If !larger
      larger := (vPimgSelX<-10 && vPimgSelY<-10) && ((vPimgSelX + vPimgSelW>mainWidth + 10) || (vPimgSelW>mainWidth + 10)) && ((vPimgSelY + vPimgSelH>mainHeight + 10) || (vPimgSelH>mainHeight + 10)) ? 1 : 0
   Return larger
}

clampValuesToWindow(imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight) {
     thisu := []
     thisErr := imgHUDbaseUnit//9
     thisu.X := clampInRange(imgSelPx, -thisErr, mainWidth + thisErr*2)
     thisu.Y := clampInRange(imgSelPy, -thisErr, mainHeight + thisErr*2)
     thisu.WX := clampInRange(imgSelPx + imgSelW, -thisErr, mainWidth + thisErr*2)
     thisu.HY := clampInRange(imgSelPy + imgSelH, -thisErr, mainHeight + thisErr*2)
     thisu.W := thisu.WX - thisu.X
     thisu.H := thisu.HY - thisu.Y
     ; TulTip(A_ThisFunc, "|", thisX, thisY, thisW, thisH)
     Return thisu
}

VPcreateSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, angleu, isAngleu, mainWidth, mainHeight, allowSimple, forceAdvanced:=0) {
     Static prevState := 0, prevPath := 0
     If (imgSelPx="kill")
     {
        prevState := ""
        If (prevPath)
           Gdip_DeletePath(prevPath)
        Return
     } Else If (imgSelPx="prevID")
     {
        Return prevState
     }

     tooBig := ((imgSelW>mainWidth*1.5 && imgSelH>mainHeight*1.5 || imgSelW>mainWidth*2.5 || imgSelH>mainHeight*2.5) && EllipseSelectMode=2 && customShapeCountPoints>2100) ? 1 : 0
     advancedShape := (  (vpImgPanningNow || forceAdvanced=1 || doImgEditLivePreview!=1 || allowSimple=0 && doImgEditLivePreview=1) && isVarEqualTo(AnyWindowOpen, 23, 65, 68)  ) ? 1 : 0
     simpleRect := ((advancedShape=1 && FillAreaShape=1 || EllipseSelectMode=0 && advancedShape=0) && angleu=0 && innerSelectionCavityX=0 && innerSelectionCavityY=0 || isSelEntireOutside(mainWidth, mainHeight)) ? 1 : 0
     selOptionalInTool := (AnyWindowOpen=66 || AnyWindowOpen=64) ? 1 : 0
     ; simpleRect := (tooBig=1 || EllipseSelectMode=0 && angleu=0 && innerSelectionCavityX=0 && innerSelectionCavityY=0 || imgSelOutViewPort=1 || isSelEntireOutside(mainWidth, mainHeight)) ? 1 : 0
     ; fnOutputDebug(A_ThisFunc "(): tooBig=" tooBig "| simpleRect=" simpleRect "| EllipseSelectMode=" EllipseSelectMode "| customShapeCountPoints=" customShapeCountPoints)
     If (simpleRect=1 || advancedShape!=1 && AnyWindowOpen && doImgEditLivePreview=1 && allowSimple=1 && selOptionalInTool=0)
     {
        thisu := clampValuesToWindow(imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight)
        ImgSelPath := Gdip_CreatePath()
        Gdip_AddPathRectangle(ImgSelPath, thisu.X, thisu.Y, thisu.W, thisu.H)
        ; fnOutputDebug("lool=" simpleRect "|" advancedShape "|" allowSimple)
        Return ImgSelPath
     }

     thisState := "a" imgSelW imgSelH angleu isAngleu EllipseSelectMode VPselRotation innerSelectionCavityX innerSelectionCavityY customShapePoints bezierSplineCustomShape FillAreaCurveTension doImgEditLivePreview AnyWindowOpen advancedShape FillAreaShape rotateSelBoundsKeepRatio closedLineCustomShape FillAreaRectRoundness FillAreaEllipsePie FillAreaEllipseSection
     If (thisState=prevState && prevPath)
     {
        ImgSelPath := Gdip_ClonePath(prevPath)
        Gdip_TranslatePath(ImgSelPath, imgSelPx, imgSelPy)
        ; fnOutputDebug("cached=" simpleRect "|" advancedShape "|" allowSimple)
        Return ImgSelPath
     }

     ; fnOutputDebug("no cache=" simpleRect "|" advancedShape "|" allowSimple)
     If prevPath
        Gdip_DeletePath(prevPath)

     startZeit := A_TickCount
     If (advancedShape=1)
        ImgSelPath := coreCreateFillAreaShape(0, 0, imgSelW, imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio, 2)
     Else
        ImgSelPath := createImgSelPath(0, 0, imgSelW, imgSelH, EllipseSelectMode, angleu, rotateSelBoundsKeepRatio, 0, 2, isAngleu, innerSelectionCavityX, innerSelectionCavityY)
     ; ToolTip, % "a=" A_TickCount - startZeit , , , 2
     prevState := thisState
     prevPath := Gdip_ClonePath(ImgSelPath)
     Gdip_TranslatePath(ImgSelPath, imgSelPx, imgSelPy)
     Return ImgSelPath
}

SkeletDrawSelectionBox(paintAlphaMask:=0) {
   dotsSize := SelDotsSize
   vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
   vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
   vPimgSelX := min(selDotX, selDotAx) + dotsSize//2
   vPimgSelY := min(selDotY, selDotAy) + dotsSize//2

   vpWinClientSize(mainWidth, mainHeight)
   tooBig := (vPimgSelW>mainWidth*1.5 && vPimgSelH>mainHeight*1.5 || vPimgSelW>mainWidth*2.5 || vPimgSelH>mainHeight*2.5) ? 1 : 0
   simpleRect := (imgSelLargerViewPort=1 || imgSelOutViewPort=1 || isSelEntireOutside(mainWidth, mainHeight) || tooBig=1) ? 1 : 0
   If (VPselRotation!=0)
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)

   If (imgEditPanelOpened=1)
   {
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)
      Gdip_FillEllipse(2NDglPG, pBrushA, SelDotDx + 5, SelDotDy + 5, dotsSize, dotsSize)
   }

   thisThick := dotsSize//5 + 1
   Gdip_SetPenWidth(pPen4, thisThick)
   Gdip_SetPenWidth(pPen1d, thisThick)
   decideLiveSelectionBasedOnWindow(angleu, isAngleu)
   advancedShape := (  (vpImgPanningNow || doImgEditLivePreview!=1) && isVarEqualTo(AnyWindowOpen, 23, 65, 68)  ) ? 1 : 0
   If (paintAlphaMask=1 || advancedShape!=1 && AnyWindowOpen && doImgEditLivePreview=1)
   {
      ImgSelPath := Gdip_CreatePath()
      thisu := clampValuesToWindow(vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH, mainWidth, mainHeight)
      Gdip_AddPathRectangle(ImgSelPath, thisu.X, thisu.Y, thisu.W, thisu.H)
      If (imgSelLargerViewPort=1)
         Gdip_DrawRectangle(2NDglPG, pPen1d, mainWidth*0.15, mainHeight*0.15, mainWidth - mainWidth*0.3, mainHeight - mainHeight*0.3)
   } Else 
   {
      ImgSelPath := VPcreateSelPath(vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH, angleu, isAngleu, mainWidth, mainHeight, 1)
   }

   zPen := Gdip_CreatePen("0x88456345", imgHUDbaseUnit//16)
   thisu := clampValuesToWindow(vPimgSelX + thisThick//3, vPimgSelY + thisThick//3, vPimgSelW, vPimgSelH, mainWidth, mainHeight)
   Gdip_DrawRectangle(2NDglPG, pPen4, thisu.X, thisu.Y, thisu.W, thisu.H)
   Gdip_DrawPath(2NDglPG, zPen, ImgSelPath)
   thisu := clampValuesToWindow(vPimgSelX + thisThick//2, vPimgSelY + thisThick//2, vPimgSelW, vPimgSelH, mainWidth, mainHeight)
   Gdip_DrawRectangle(2NDglPG, pPen4, thisu.X, thisu.Y, thisu.W, thisu.H)
   Gdip_DeletePen(zPen)
   If (paintAlphaMask=1 && AnyWindowOpen!=70)
   {
      livePreviewAlphaMasking()
      generateAlphaMaskBitmap("kill", 0)
   }

   If (showInfoBoxHUD>0 && editingSelectionNow=1)
      drawinfoBox(mainWidth, mainHeight, 0, 2NDglPG)

   thisWin := (paintAlphaMask=1) ? hGDIinfosWin : hGDIselectWin
   r := doLayeredWinUpdate(A_ThisFunc, thisWin, 2NDglHDC)
   Gdip_DeletePath(ImgSelPath)
   Return r
}

defineCurrentAlphaMask() {
   If (viewportQPVimage.imgHandle)
      return "none"

   az := validBMP(userClipBMPpaste) ? "(referenced bitmap)" : "(inexistent reference)"
   bc := validBMP(useGdiBitmap()) ? "(referenced bitmap)" : "(inexistent reference)"
   cz := validBMP(userAlphaMaskBmpPainted) ? "(effects may apply)" : "(inexistent reference)"
   If (alphaMaskingMode=6)
      friendly := "custom shape (generated)"
   Else If (alphaMaskingMode=2)
      friendly := "linear gradient (generated)"
   Else If (alphaMaskingMode=3)
      friendly := "radial gradient (generated)"
   Else If (alphaMaskingMode=4)
      friendly := "box gradient (generated)"
   Else If (alphaMaskingMode=5 && alphaMaskRefBMP=1)
      friendly := "user painted bitmap " cz
   Else If (alphaMaskingMode=5 && alphaMaskRefBMP=2)
      friendly := "main image " bc
   Else If (alphaMaskingMode=5 && alphaMaskRefBMP=3)
      friendly := "transformed image object " az
   Else
      friendly := "none"

   Return friendly
}

selectFileLongTap() {
   If (thumbsDisplaying=1 && determineLClickState()=1 && (A_TickCount - lastOtherWinClose>350) && (A_TickCount - lastTimeToggleThumbs>350))
      markThisFileNow(currentFileIndex)
}

isDotInRect(mX, mY, x1, x2, y1, y2, modus:=0) {
   If (modus=1)
      Return (isInRange(mX, y1 - x1, y1 + x2) && isInRange(mY, y2 - x1, y2 + x2)) ? 1 : 0
   Else
      Return (isInRange(mX, x1, x2) && isInRange(mY, y1, y2)) ? 1 : 0
}

determineSelAreaClickRect(mX, mY, dotsSize, mainWidth, mainHeight, doFlips) {
; selection area points/rects that the user can click on, their IDs
; selection points highlighted with brackets
; [1]---5---[11]---5---[3]
;  |                    |
;  |                    |
;  7    9          9    8
;  |                    |
;  |                    |
; [14]      [10]      [12]
;  |                    |
;  |                    |
;  7    9          9    8
;  |                    |
;  |                    |
; [4]---6---[13]---6---[2]
; 
   If (showHUDnavIMG=1 && hasDrawnImageMap=1 && IMGlargerViewPort=1
   && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
      Return

   If ((IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1) && thumbsDisplaying!=1)
   {
      ; handle clicks on the H/V scrollbars for images larger than the viewport
      knobSize := getScrollWidth()
      If (scrollBarHy>1 && mY>(mainHeight - knobSize))
      || (scrollBarVx>1 && mX>(mainWidth - knobSize))
         Return
   }

   nSelDotX  := selDotX,    nSelDotY  := selDotY    ; [1]
   nSelDotAx := selDotAx,   nSelDotAy := selDotAy   ; [2]
   nSelDotBx := selDotBx,   nSelDotBy := selDotBy   ; [3]
   nSelDotCx := selDotCx,   nSelDotCy := selDotCy   ; [4]
   nSelDotDx := selDotDx,   nSelDotDy := selDotDy   ; [10]
   nSelDotMaX := selDotMaX, nSelDotMaY := selDotMaY ; [11]
   nSelDotMbX := selDotMbX, nSelDotMbY := selDotMbY ; [12]
   nSelDotMcX := selDotMcX, nSelDotMcY := selDotMcY ; [13]
   nSelDotMdX := selDotMdX, nSelDotMdY := selDotMdY ; [14]
   dotActive := 0

   If (FlipImgH=1 && doFlips=1)
   {
      nSelDotX := mainWidth - selDotX - dotsSize
      nSelDotAx := mainWidth - selDotAx - dotsSize
      nSelDotBx := mainWidth - selDotBx - dotsSize
      nSelDotCx := mainWidth - selDotCx - dotsSize
      nSelDotDx := mainWidth - selDotDx - dotsSize
      nSelDotMaX := mainWidth - selDotMaX - dotsSize
      nSelDotMbX := mainWidth - selDotMbX - dotsSize
      nSelDotMcX := mainWidth - selDotMcX - dotsSize
      nSelDotMdX := mainWidth - selDotMdX - dotsSize
   }

   If (FlipImgV=1 && doFlips=1)
   {
      nSelDotY := mainHeight - selDotY - dotsSize
      nSelDotAy := mainHeight - selDotAy - dotsSize
      nSelDotBy := mainHeight - selDotBy - dotsSize
      nSelDotCy := mainHeight - selDotCy - dotsSize
      nSelDotDy := mainHeight - selDotDy - dotsSize
      nSelDotMaY := mainHeight - selDotMaY - dotsSize
      nSelDotMbY := mainHeight - selDotMbY - dotsSize
      nSelDotMcY := mainHeight - selDotMcY - dotsSize
      nSelDotMdY := mainHeight - selDotMdY - dotsSize
   }

   d := dotsSize//2
   transformTool := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
   If isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotX, nSelDotY, 1)
   {
      ; top-left corner
      line := nSelDotBx + d "," nSelDotBy + d "|"
      line .= nSelDotX + d "," nSelDotY + d "|"
      line .= nSelDotCx + d "," nSelDotCy + d
      cX1 := nSelDotX
      cY1 := nSelDotY
      cX2 := nSelDotX + d
      cY2 := nSelDotY + d
      dotActive := 1
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotAx, nSelDotAy, 1)
   {
      ; bottom-right corner
      line := nSelDotBx + d "," nSelDotBy + d "|"
      line .= nSelDotAx + d "," nSelDotAy + d "|"
      line .= nSelDotCx + d "," nSelDotCy + d
      cX1 := nSelDotAx
      cY1 := nSelDotAy
      cX2 := nSelDotAx + d
      cY2 := nSelDotAy + d
      dotActive := 2
      DotPosX := imgSelX2
      DotPosY := imgSelY2
   } Else If isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotCx, nSelDotCy, 1)
   {
      ; bottom-left corner
      line := nSelDotX + d "," nSelDotY + d "|"
      line .= nSelDotCx + d "," nSelDotCy + d "|"
      line .= nSelDotAx + d "," nSelDotAy + d
      cX1 := nSelDotCx
      cY1 := nSelDotCy
      cX2 := nSelDotCx + d
      cY2 := nSelDotCy + d
      dotActive := 4
      DotPosX := imgSelX1
      DotPosY := imgSelY2
   } Else If isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotBx, nSelDotBy, 1)
   {
      ; top-right corner
      line := nSelDotX + d "," nSelDotY + d "|"
      line .= nSelDotBx + d "," nSelDotBy + d "|"
      line .= nSelDotAx + d "," nSelDotAy + d 
      cX1 := nSelDotBx
      cY1 := nSelDotBy
      cX2 := nSelDotBx + d
      cY2 := nSelDotBy + d
      dotActive := 3
      DotPosX := imgSelX2
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotDx, nSelDotDx + dotsSize, nSelDotDy, nSelDotDy + dotsSize)
   {
      ; click the center dot of the selection area
      cX1 := nSelDotDx
      cY1 := nSelDotDy
      cX2 := nSelDotDx + d
      cY2 := nSelDotDy + d
      dotActive := 10
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If (transformTool=1 && isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotMaX, nSelDotMaY, 1))
   {
      ; mid-top edge
      cX1 := nSelDotMaX
      cY1 := nSelDotMaY
      cX2 := nSelDotMaX + d
      cY2 := nSelDotMaY + d
      dotActive := 11
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If (transformTool=1 && isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotMbX, nSelDotMbY, 1))
   {
      ; mid-right edge
      cX1 := nSelDotMbX
      cY1 := nSelDotMbY
      cX2 := nSelDotMbX + d
      cY2 := nSelDotMbY + d
      dotActive := 12
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If (transformTool=1 && isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotMcX, nSelDotMcY, 1))
   {
      ; mid-bottom edge
      cX1 := nSelDotMcX
      cY1 := nSelDotMcY
      cX2 := nSelDotMcX + d
      cY2 := nSelDotMcY + d
      dotActive := 13
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If (transformTool=1 && isDotInRect(mX, mY, dotsSize, dotsSize, nSelDotMdX, nSelDotMdY, 1))
   {
      ; mid-left edge
      cX1 := nSelDotMdX
      cY1 := nSelDotMdY
      cX2 := nSelDotMdX + d
      cY2 := nSelDotMdY + d
      dotActive := 14
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotX, nSelDotBx, nSelDotY, nSelDotY + dotsSize)
   {
      ; top edge
      cX1 := nSelDotX
      cX2 := nSelDotBx
      cY1 := nSelDotY + d
      cY2 := nSelDotY + d
      dotActive := 5
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotCx, nSelDotBx, nSelDotCy, nSelDotCy + dotsSize)
   {
      ; bottom edge
      cX1 := nSelDotCx
      cX2 := nSelDotBx
      cY1 := nSelDotCy + d
      cY2 := nSelDotCy + d
      dotActive := 6
      DotPosX := imgSelX1
      DotPosY := imgSelY2
   } Else If isDotInRect(mX, mY, nSelDotX, nSelDotX + dotsSize, nSelDotY, nSelDotCy)
   {
      ; left edge
      cX1 := nSelDotX + d
      cX2 := nSelDotX + d
      cY1 := nSelDotY
      cY2 := nSelDotCy
      dotActive := 7
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotBx, nSelDotBx + dotsSize, nSelDotAy, nSelDotBy + dotsSize)
   {
      ; right edge
      cX1 := nSelDotBx + d
      cX2 := nSelDotBx + d
      cY1 := nSelDotAy
      cY2 := nSelDotBy
      dotActive := 8
      DotPosX := imgSelX2
      DotPosY := imgSelY1
   } Else If isDotInRect(mX, mY, nSelDotX, nSelDotBx, nSelDotBy, nSelDotAy)
   {
      ; click anywhere within the selection
      cX1 := nSelDotX
      cX2 := nSelDotBx
      cY1 := nSelDotBy
      cY2 := nSelDotAy
      dotActive := 9
      DotPosX := imgSelX1
      DotPosY := imgSelY1
   }
   ; z := nSelDotX "=" nSelDotY "`n" nSelDotAx "=" nSelDotAy "`n" nSelDotBx "=" nSelDotBy
   ; ToolTip, % "d=" y "=l=" dotActive "`n" z "`n" mX "=" mY , , , 2
   obju := []
   obju.n := dotActive
   obju.x := DotPosX
   obju.y := DotPosY
   obju.w := max(cx2, cx1) - min(cx2, cx1)
   obju.h := max(cy2, cy1) - min(cy2, cy1)
   obju.gX := (FlipImgH=1 && doFlips=1) ? cX1 - obju.w : cX1
   obju.gY := (FlipImgV=1 && doFlips=1) ? cY1 - obju.h : cY1
   obju.cX1 := cX1
   obju.cX2 := cX2
   obju.cY1 := cY1
   obju.cY2 := cY2
   obju.line := line ? line : cX1
   ; fnOutputDebug("dot=" dotActive "|" mX "\" mY)

   Return obju
}

createVectorMenuToolModes() {
   Try Menu, pvVectModes, Delete 
   kMenu("pvVectModes", "Add", "Cycle tool modes`tQ", "MenuCycleVectToolMode")
   Menu, pvVectModes, Add
   kMenu("pvVectModes", "Add/Uncheck", "Mixed", "MenuSetVectToolModeMixed")
   kMenu("pvVectModes", "Add/Uncheck", "Add", "MenuSetVectToolModeAdd")
   kMenu("pvVectModes", "Add/Uncheck", "Remove", "MenuSetVectToolModeRemove")
   kMenu("pvVectModes", "Add/Uncheck", "Select", "MenuSetVectToolModeSelect")
   kMenu("pvVectModes", "Add/Uncheck", "Adjust", "MenuSetVectToolModeAdjust")
   If (vectorToolModus=1)
      kMenu("pvVectModes", "Check", "Mixed")
   Else If (vectorToolModus=2)
      kMenu("pvVectModes", "Check", "Add")
   Else If (vectorToolModus=3)
      kMenu("pvVectModes", "Check", "Remove")
   Else If (vectorToolModus=4)
      kMenu("pvVectModes", "Check", "Select")
   Else If (vectorToolModus=5)
      kMenu("pvVectModes", "Check", "Adjust")
}

MenuCycleVectToolMode() {
   vectorToolModus := clampInRange(vectorToolModus + 1, 1, 5, 1)
   showTOOLtip("Vector tool mode: " Format("{:U}", defineVectToolMode()), A_ThisFunc, 2, (vectorToolModus + 0.05 - 1) / 4.1)
   If (ShowAdvToolbar=1)
      decideIconBTNvectToolModes()
   SetTimer, dummyForcedRefreshImgSelectionWindow, -100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

defineVectToolMode() {
   Static pp := {1:"Mixed", 2:"Add", 3:"Remove", 4:"Select", 5:"Adjust"}
   Return pp[vectorToolModus]
}

MenuSetVectToolModeMixed() {
   vectorToolModus := 5
   MenuCycleVectToolMode()
}

MenuSetVectToolModeAdd() {
   vectorToolModus := 1
   MenuCycleVectToolMode()
}

MenuSetVectToolModeRemove() {
   vectorToolModus := 2
   MenuCycleVectToolMode()
}

MenuSetVectToolModeSelect() {
   vectorToolModus := 3
   MenuCycleVectToolMode()
}

toggleVectorSelectMmde() {
   vectorToolModus := (vectorToolModus=4) ? 4 : 3
   MenuCycleVectToolMode()
}

MenuSetVectToolModeAdjust() {
   vectorToolModus := 4
   MenuCycleVectToolMode()
}

createContextMenuCustomShapeDrawing(mX, mY, dontAddPoint, indexu, bK, givenCoords:=0) {
   deleteMenus()
   If (dontAddPoint!=1)
   {
      kMenu("PVnav", "Add", "&Done / apply changes`tEnter", "stopDrawingShape")
      kMenu("PVnav", "Add", "&Cancel / exit pen tool`tEscape", "MenuCancelDrawingShape")
      kMenu("PVnav", "AddSeparator", 0)
   }

   If (indexu)
   {
      fr := (bK!=1 && bezierSplineCustomShape=1) ? "P'" : "P"
      getVPcoordsVectorPoint(indexu, mX, mY)
      kMenu("PVnav", "Add", fr "[" indexu "] = X: " Round(mX) " Y: " Round(mY), "dummy")
      kMenu("PVnav", "Disable", fr "[" indexu "] = X: " Round(mX) " Y: " Round(mY), "dummy")
   } Else
   {
      keyu := (vectorToolModus=1) ? "`tAlt+Click" : ""
      If (dontAddPoint!=1)
         kMenu("PVnav", "Add", "Add new point on edge" keyu, "MenuAddUnorderedVectorPoint")
      kMenu("PVnav", "Add", "X: " mX " Y: " mY, "dummy")
      kMenu("PVnav", "Disable", "X: " mX " Y: " mY, "dummy")
   }

   infoLine := Format("{:U}", defineVectorPathType())
   If (customShapeHasSelectedPoints!=1 && dontAddPoint!=1)
   {
      kMenu("PVnav", "Add", "Vector mode: " infoLine, "dummy")
      kMenu("PVnav", "Disable", "Vector mode: " infoLine, "dummy")
      kMenu("PVnav", "AddSeparator", 0)
   }

   undos := undoVectorShapesLevelsArray.Count()
   If (currentVectorUndoLevel>1 || undos>1)
   {
      kMenu("PVnav", "Add", "&Undo`tCtrl+Z", "ImgVectorUndoAct")
      kMenu("PVnav", "Add", "&Redo`tCtrl+Y", "ImgVectorRedoAct")
      kMenu("PVnav", "AddSeparator", 0)
   }

   If (dontAddPoint=1)
   {
      If (bezierSplineCustomShape=1)
      {
         kMenu("PVnav", "Add/Uncheck", "Symmetrical anchors`tR", "toggleAutoReflectAnchors")
         If (autoReflectVectorAnchors=1)
            kMenu("PVnav", "Check", "Symmetrical anchors`tR")
         kMenu("PVnav", "AddSeparator", 0)
      }

      keyu := (vectorToolModus<3) ? "`tDbl-Click" : ""
      canDoSymmetry := isNowSymmetricVectorShape()
      symPoint := prevVectorShapeSymmetryMode[1, 1]
      If (indexu=symPoint && canDoSymmetry)
         kMenu("PVnav", "Add", "Discard as symmetry reference`tY", "MenuSetVectorPathNoSymmetryMode")
      Else If (bk=1)
         kMenu("PVnav", "Add", "&Divide point" keyu, "MenuSplitVectorPoint")

      keyu := (vectorToolModus<3 || vectorToolModus=5) ? "`tAlt+Click" : ""
      If (bk=1 && bezierSplineCustomShape=1)
      {
         kMenu("PVnav", "Add", "E&xpand anchors" keyu, "MenuExpandVectorPointAnchors")
         kMenu("PVnav", "Add", "&Collapse anchors", "MenuCollapseVectorPoint")
      } 

      keyu := (vectorToolModus<3) ? "`tCtrl+Click" : ""
      If (bk!=1 && bezierSplineCustomShape=1)
         kMenu("PVnav", "Add", "&Reflect anchor", "MenuReflectAnchorVectorPoint")
      labelu := (bk=1 && bezierSplineCustomShape=1 || bezierSplineCustomShape!=1) ? "&Remove point" : "Collapse &anchor"
      kMenu("PVnav", "Add", labelu keyu, "MenuRemVectorPoint")
      keyu := (vectorToolModus=1 || vectorToolModus=5) ? "`tShift+Click" : ""
      kMenu("PVnav", "Add", "S&elect point" keyu, "MenuSelVectorPoint")
      If !isNowSymmetricVectorShape()
      {
         If (bezierSplineCustomShape!=1)
            kMenu("PVnav", "Add", "Paste points here", "MenuPasteVectorPoints")

         If (indexu!=1)
            kMenu("PVnav", "Add", "Set as sta&rt point", "MenuSetStartVectorPoint")
      }
   }

   kMenu("PVnav", "AddSeparator", 0)
   kMenu("PVnav", "Add", "Select all points`tCtrl+A", "tlbrSelAllVectorPoints")
   If (customShapeHasSelectedPoints=1)
   {
      If (bezierSplineCustomShape!=1)
         kMenu("PVnav", "Add", "Cop&y points", "MenuCopyVectorPoints")

      kMenu("PVnav", "Add", "Deselect points`tCtrl+D", "MenuSelNoVectorPoints")
      kMenu("PVnav", "Add", "In&vert points selection`tShift+I", "MenuSelInvertVectorPoints")
      kMenu("PVnav", "Add", "&Delete selected points`tDelete", "MenuRemSelVectorPoints")
      If (dontAddPoint=1)
      {
         kMenu("PVnav", "Add", "&Align points on X", "MenuAlignXvectorPoints")
         kMenu("PVnav", "Add", "Align points on Y", "MenuAlignYvectorPoints")
      }

      If (bezierSplineCustomShape=1 && customShapePoints.Count()>3)
      {
         kMenu("PVnav", "Add", "&Collapse anchors for selected points", "MenuCollapseSelectedAnchorPoints")
         kMenu("PVnav", "Add", "&Expand anchors for selected points", "MenuExpandSelectedAnchorPoints")
      }
   }

   If (dontAddPoint!=1)
   {
      kMenu("PVnav", "AddSeparator", 0)
      kMenu("PVnav", "Add", "&Remove end point`tBackspace", "reduceCustomShapeLength")
      kMenu("PVnav", "Add", "C&ycle symmetry modes`tY", "toggleBrushSymmetryModes")
      ; kMenu("PVnav", "Add", "Make the shape symmetrical", "MenuCreateShapeSymmetricalVectorShape")
      createMenuSelectShapeTension()
      kMenu("PVnav", "Add", "&Path type / smoothness", ":PVshapeTension")
      If (vectorToolModus<3)
      {
         kMenu("PVnav", "Add/Uncheck", "&Preview new point`tP", "togglePreviewVectorNewPoint")
         If (showNewVectorPointPreview=1)
            kMenu("PVnav", "Check", "&Preview new point`tP")
      }

      If (bezierSplineCustomShape=1)
      {
         kMenu("PVnav", "Add/Uncheck", "Symmetrical anchors`tR", "toggleAutoReflectAnchors")
         If (autoReflectVectorAnchors=1)
            kMenu("PVnav", "Check", "Symmetrical anchors`tR")
      }

      kMenu("PVnav", "Add/Uncheck", "&Open ended path`tO", "toggleOpenClosedLineEditorCustomShape", "opened closed vector")
      If (closedLineCustomShape=0)
         kMenu("PVnav", "Check", "&Open ended path`tO")

      createVectorMenuToolModes()
      kMenu("PVnav", "AddSeparator", 0)
      kMenu("PVnav", "Add", "Tool modes", ":pvVectModes")
      If (mustPreventMenus=1 || showMainMenuBar!=1)
      {
         createMenuInterfaceOptions()
         InvokeMenuBarVectorView(0, "extern")
         kMenu("PVnav", "Add", "Interface", ":PvUIprefs")
         kMenu("PVnav", "Add", "Vie&wport", ":pvMenuBarView")
      } Else
      {
         kMenu("PVnav", "Add/Uncheck", "Show viewport &grid`tG", "toggleViewPortGridu")
         If (showViewPortGrid=1)
            kMenu("PVnav", "Check", "Show viewport &grid`tG")

         kMenu("PVnav", "Add/UnCheck", "&Show toolbar`tShift+F10", "toggleAppToolbar")
         If (ShowAdvToolbar=1)
            kMenu("PVnav", "Check", "&Show toolbar`tShift+F10")
      }
   }

   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVnav") : givenCoords
   showThisMenu("PVnav")
}

MenuSplitVectorPoint() {
  lastOtherWinClose := 1
  vpWinClientSize(mainWidth, mainHeight)
  PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "splitPoint", 0, 0)
}

MenuAlignXvectorPoints() {
  lastOtherWinClose := 1
  vpWinClientSize(mainWidth, mainHeight)
  PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "align-x", 0, 0)
}

MenuAlignYvectorPoints() {
  lastOtherWinClose := 1
  vpWinClientSize(mainWidth, mainHeight)
  PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "align-y", 0, 0)
}

MenuRemVectorPoint() {
  lastOtherWinClose := 1
  vpWinClientSize(mainWidth, mainHeight)
  PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "remClick", 0, 0)
}

MenuSelAllVectorPoints() {
   Loop, % customShapePropPoints.Count()
       customShapePropPoints[A_Index, 1] := 1

   customShapeHasSelectedPoints := 1
   ; lastZeitFileSelect := A_TickCount
   showTOOLtip("Selected all " groupDigits(customShapePoints.Count()) " path points")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, dummyForcedRefreshImgSelectionWindow, -25
}

MenuSelNoVectorPoints() {
   Loop, % customShapePropPoints.Count()
       customShapePropPoints[A_Index, 1] := 0

   customShapeHasSelectedPoints := 0
   ; lastZeitFileSelect := A_TickCount
   showTOOLtip("Deselected all " groupDigits(customShapePoints.Count()) " path points")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, dummyForcedRefreshImgSelectionWindow, -25
}

MenuSetVectorShapeSymmetryXPoint() {
   configVectorShapeSymmetryPoint("x", 0, 0)
}

MenuSetVectorShapeSymmetryYPoint() {
   configVectorShapeSymmetryPoint("y", 0, 0)
}

configVectorShapeSymmetryPoint(modus, silentu, givenIndex, noChecks:=0, allowReinit:=1) {
   If (bezierSplineCustomShape=1)
      autoDeactivateClosedBezier()

   totalLoops := customShapePoints.Count()
   If (totalLoops<3)
      Return

   lastOtherWinClose := 1
   vpWinClientSize(mainWidth, mainHeight)
   If givenIndex
      thisIndex := givenIndex
   Else
      thisIndex := PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "setStart", 0, 1)

   getVPcoordsVectorPoint(thisIndex, gX, gY)
   If (bezierSplineCustomShape=1)
   {
      ignorePoints := []
      listuArray := getPointsSameCoordsVectorPath(totalLoops, k, thisIndex, gX, gY)
      Loop, % listuArray.Count()
      {
         p := listuArray[A_Index, 1]
         ignorePoints[p] := 1
      }
   }

   ; ToolTip, % totalLoops "=" modus "=" silentu "=" givenIndex , , , 2
   mIndex := 0
   uneven := (totalLoops//2 != totalLoops/2) ? 1 : 0
   leftSideXH := rightSideXH := 0
   topSideYV := bottomSideYV := 0
   ppz := totalLoops//2 + 1
   If (ppz=thisIndex && uneven=1)
      noChecks := 1

   ; ToolTip, % ppz "|" thisIndex "|" noChecks "|" uneven , , , 2
   If (noChecks!=1)
   {
      Loop, % totalLoops
      {
          ; If (uneven=1 && thisIndex=A_Index) || (ignorePoints[A_Index]=1 && bezierSplineCustomShape=1)
          ;    Continue

          k := (bezierSplineCustomShape=1) ? clampInRange(k + 1, 1, 3, 1) : 1
          If (k=1)
          {
             mIndex++
             If (mindex=thisIndex)
                Continue

             If (modus="x")
             {
                If (mIndex<thisIndex)
                   leftSideXH++
                Else
                   rightSideXH++
             } Else
             {
                If (mIndex<thisIndex)
                   topSideYV++
                Else
                   bottomSideYV++
             }
          }
      }

      getVPcoordsVectorPoint(1, fxu, fyu)
      getVPcoordsVectorPoint(totalLoops, exu, eyu)
      If (modus="x")
      {
         If (fxu<gX && exu<gX) || (fxu>gX && exu>gX)
            errMsgNow := "ERROR: The start point and the end point are on the same side of the designated symmetry point.`nPlease choose another point from the path."
      } Else
      {
         If (fyu<gY && eyu<gY) || (fyu>gY && eyu>gY)
            errMsgNow := "ERROR: The start point and the end point are on the same side of the designated symmetry point.`nPlease choose another point from the path."
      }

      ; fnOutputDebug(A_ThisFunc "(" modus "," silentu ", " givenIndex "): " thisIndex " | " kX "=" kY " || " fX "=" fY)
      If (modus="x" && !errMsgNow)
      {
         If (leftSideXH!=rightSideXH)
            errMsgNow := "ERROR: The number of points do not correspond.`nLeft side: " leftSideXH "`nRight side: " rightSideXH "`nPlease choose another point."
      } Else If !errMsgNow
      {
         If (topSideYV!=bottomSideYV)
            errMsgNow := "ERROR: The number of points do not correspond.`nTop side: " topSideYV "`nBottom side: " bottomSideYV "`nPlease choose another point."
      }
   }

   If (silentu!=1 && errMsgNow)
   {
      showTOOLtip(errMsgNow)
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime*2
      Return
   } Else If errMsgNow
   {
      addJournalEntry(A_ThisFunc "(): " errMsgNow)
      Return
   }

   If customShapeHasSelectedPoints
   {
      ; must deselect points to avoid some edge cases
      Loop, % customShapePropPoints.Count()
          customShapePropPoints[A_Index, 1] := 0
   }

   thisu := (modus="x") ? 1 : 2
   CustomShapeSymmetry := CustomShapeLockedSymmetry := thisu
   coreSetVPsymmetryPoint(thisIndex, allowReinit)
   ; vpFreeformShapeOffset := []
   SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuSetVectorPathNoSymmetryMode() {
   CustomShapeSymmetry := CustomShapeLockedSymmetry := vpSymmetryPointXdp := vpSymmetryPointYdp := 0
   prevVectorShapeSymmetryMode := []
   SetTimer, dummyRefreshImgSelectionWindow, -10
}

coreSetVPsymmetryPoint(thisIndex, allowReinit:=1) {
   getVPcoordsVectorPoint(thisIndex, vpSymmetryPointXdp, vpSymmetryPointYdp)
   prevVectorShapeSymmetryMode[1] := [thisIndex, CustomShapeSymmetry]
}

MenuExpandSelectedAnchorPoints() {
    k := 0
    totalCount := customShapePoints.Count()
    canDoSymmetry := isNowSymmetricVectorShape()
    Loop, % totalCount
    {
        thisIndex := A_Index
        selu := customShapePropPoints[thisIndex, 1]
        c := customShapePoints[thisIndex]
        k := clampInRange(k + 1, 1, 3, 1)
        If (c[1]="" || c[2]="" || selu!=1 || lol[thisIndex]=1 || k!=1)
           Continue

        oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
        rr := expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, c[1], c[2])
    }
    If (rr=1)
       recordVectorUndoLevels()

    ; lastZeitFileSelect := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuCollapseSelectedAnchorPoints() {
    k := 0
    totalCount := customShapePoints.Count()
    canDoSymmetry := isNowSymmetricVectorShape()
    lol := []
    Loop, % totalCount
    {
        thisIndex := A_Index
        selu := customShapePropPoints[thisIndex, 1]
        c := customShapePoints[thisIndex]
        k := clampInRange(k + 1, 1, 3, 1)
        If (c[1]="" || c[2]="" || selu!=1 || lol[thisIndex]=1)
           Continue

        oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
        collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
        lol[thisIndex] := 1
        If (k!=1)
        {
           ; collapse anchors on «delete»
           customShapePropPoints[thisIndex, 1] := 0
           If (oppoIndex!=thisIndex && canDoSymmetry=1)
           {
              lol[oppoIndex] := 1
              customShapePropPoints[oppoIndex, 1] := 0
           }
        } Else
        {
           A := B := 0
           collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
           getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
           If A
           {
              lol[a] := 1
              customShapePropPoints[A, 1] := 1
           }

           If B
           {
              lol[b] := 1
              customShapePropPoints[B, 1] := 1
           }

           If (oppoIndex!=thisIndex && canDoSymmetry=1 && a!=thisIndex && b!=thisIndex && a!=oppoIndex && b!=oppoIndex)
           {
              za := totalCount - a + 1
              zb .= totalCount - b + 1
              If (a!=za && za!=zb && a)
              {
                 customShapePropPoints[za, 1] := 1
                 lol[za] := 1
              }

              If (b!=zb && za!=zb && b)
              {
                 customShapePropPoints[zb, 1] := 1
                 lol[zb] := 1
              }
           }
        }
    }

    customShapeHasSelectedPoints := 0
    Loop, % totalCount
    {
        If customShapePropPoints[A_Index, 1]
        {
           customShapeHasSelectedPoints := 1
           Break
        }
    }
    recordVectorUndoLevels()
    ; lastZeitFileSelect := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuReflectAnchorVectorPoint() {
  lastOtherWinClose := 1
  vpWinClientSize(mainWidth, mainHeight)
  ; lastZeitFileSelect := A_TickCount
  PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "reflectAnchor", 0, 0, 0)
  SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuRemSelVectorPoints() {
    If (bezierSplineCustomShape=1)
    {
       lol := []
       zpp := k := hasFoundDot := 0
       totalCount := customShapePoints.Count()
       canDoSymmetry := isNowSymmetricVectorShape()
       symPoint := prevVectorShapeSymmetryMode[1, 1]
       Loop, % totalCount
       {
           thisIndex := A_Index
           selu := customShapePropPoints[thisIndex, 1]
           c := customShapePoints[thisIndex]
           k := clampInRange(k + 1, 1, 3, 1)
           If (c[1]="" || c[2]="" || selu!=1 || lol[thisIndex]=1)
              Continue

           oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
           If (symPoint=thisIndex && canDoSymmetry)
              zpp := 1

           If (k!=1)
           {
              ; collapse anchors on «delete»
              collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
              customShapePropPoints[thisIndex, 1] := 0
              lol[thisIndex] := 1
              If (oppoIndex!=thisIndex && canDoSymmetry=1)
              {
                 lol[oppoIndex] := 1
                 customShapePropPoints[oppoIndex, 1] := 0
              }
           } Else
           {
              ; select anchors of selected main/key points and below, they all get removed
              A := B := 0
              hasFoundDot := 1
              getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
              If A
              {
                 lol[a] := 1
                 customShapePropPoints[A, 1] := 1
              }

              If B
              {
                 lol[b] := 1
                 customShapePropPoints[B, 1] := 1
              }

              If (oppoIndex!=thisIndex && canDoSymmetry=1 && a!=thisIndex && b!=thisIndex && a!=oppoIndex && b!=oppoIndex)
              {
                 za := totalCount - a + 1
                 zb .= totalCount - b + 1
                 If (a!=za && za!=zb && a)
                 {
                    customShapePropPoints[za, 1] := 1
                    lol[za] := 1
                 }
 
                 If (b!=zb && za!=zb && b)
                 {
                    customShapePropPoints[zb, 1] := 1
                    lol[zb] := 1
                 }
              }
           }
       }

       If !hasFoundDot
       {
          ; if no main/key points were selected, collapsing anchors is sufficient
          recordVectorUndoLevels()
          lastZeitFileSelect := A_TickCount
          customShapeHasSelectedPoints := 0
          SetTimer, dummyRefreshImgSelectionWindow, -10
          Return
       }
    }

    newArrayu := []
    newuArrayu := []
    thisIndex := thePoint := 0
    If isNowSymmetricVectorShape()
    {
       hasSymmetry := 1
       thePoint := prevVectorShapeSymmetryMode[1, 1]
       symPoint := thePoint
    }

    zpp := 0
    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       selu := customShapePropPoints[A_Index, 1]
       If (hasSymmetry=1 && selu=1 && symPoint=A_Index)
          zpp := 1

       If (c[1]="" || c[2]="" || selu=1)
       {
          If (A_Index<symPoint && symPoint && hasSymmetry=1)
             thePoint--

          Continue
       }

       thisIndex++
       newuArrayu[thisIndex] := customShapePropPoints[A_Index]
       newArrayu[thisIndex] := c
    }

    If (hasSymmetry=1 && symPoint)
       prevVectorShapeSymmetryMode[1, 1] := thePoint

    If (zpp=1)
    {
       prevVectorShapeSymmetryMode := []
       CustomShapeLockedSymmetry := CustomShapeSymmetry := vpSymmetryPointXdp := vpSymmetryPointYdp := 0
    }
    ; nz := prevVectorShapeSymmetryMode[1, 1]
    ; ToolTip, % initial "=l=" thePoint "=" nz , , , 2
    customShapePoints := newArrayu.Clone()
    customShapePropPoints := newuArrayu.Clone()
    customShapeHasSelectedPoints := 0
    recordVectorUndoLevels()
    lastZeitFileSelect := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuPasteVectorPoints() {
   vpWinClientSize(mainWidth, mainHeight)
   thisIndex := PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "setStart", 0, 1)
   MenuCopyVectorPoints("paste", thisIndex)
}

MenuCopyVectorPoints(modus:=0, givenIndex:=0) {
    Static clipVectorPoints := []

    thisIndex := 0
    pzx := (SelDotsSize * 2) / prevResizedVPimgW
    pzy := (SelDotsSize * 2) / prevResizedVPimgH
    If (modus="paste")
    {
       If (!isNumber(givenIndex) || clipVectorPoints.Count()<3)
          Return

       Loop, % customShapePropPoints.Count()
             customShapePropPoints[A_Index, 1] := 0

       recordVectorUndoLevels()
       If (vectorToolModus=3 || vectorToolModus=4)
          vectorToolModus := 5

       Loop, % clipVectorPoints.Count()
       {
          c := clipVectorPoints[A_Index].Clone()
          c[1] += pzx
          c[2] += pzy
          thisIndex++
          customShapePoints.InsertAt(givenIndex, c)
          customShapePropPoints.InsertAt(givenIndex, [1, 0])
       }

       CustomShapeLockedSymmetry := CustomShapeSymmetry := vpSymmetryPointXdp := vpSymmetryPointYdp := 0
       prevVectorShapeSymmetryMode := []
       customShapeHasSelectedPoints := 1
       recordVectorUndoLevels()
       showTOOLtip(groupDigits(thisIndex) " points were pasted at P[" givenIndex "]")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       lastZeitFileSelect := A_TickCount
       SetTimer, dummyRefreshImgSelectionWindow, -10
       Return
    }

    nVpoints := []
    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       selu := customShapePropPoints[A_Index, 1]
       If (c[1] && c[2] && selu=1)
       {
          thisIndex++
          nVpoints[thisIndex] := c
          nVcoords[thisIndex] := customShapePropPoints[A_Index]
       }
    }

    If (nVpoints.Count()>2)
    {
       clipVectorPoints := nVpoints.Clone()
       showTOOLtip(groupDigits(thisIndex) " points were copied to private clipboard")
    } Else
    {
       showTOOLtip("WARNING: At least 3 points need to be selected to copy to clipboard")
       SoundBeep 300, 100
    }

    ; lastZeitFileSelect := A_TickCount
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuSelInvertVectorPoints() {
   thisCounter := 0
   customShapeHasSelectedPoints := 1
   Loop, % customShapePropPoints.Count()
   {
       customShapePropPoints[A_Index, 1] := !customShapePropPoints[A_Index, 1]
       If customShapePropPoints[A_Index, 1]
       {
          thisCounter++
          customShapeHasSelectedPoints := 1
       }
   }

   ; lastZeitFileSelect := A_TickCount
   customShapeHasSelectedPoints := thisCounter ? 1 : 0
   SetTimer, dummyForcedRefreshImgSelectionWindow, -25
   showTOOLtip("Points selection inverted`nTotal: " groupDigits(customShapePoints.Count()) "`nSelected: " groupDigits(thisCounter))
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

MenuSelVectorPoint() {
  lastOtherWinClose := 1
  vpWinClientSize(mainWidth, mainHeight)
  customShapeHasSelectedPoints := 1
  ; lastZeitFileSelect := A_TickCount
  PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "selClick", 0, 1)
  SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuConvertShapeToPoly() {
   ; blends := {1:0.1, 2:0.2, 3:0.3, 4:0,4}
   totalCount := customShapePoints.Count()
   If (totalCount<3)
      Return

   widthu := (PrefsLargeFonts=1) ? 600 : 300
   msgResult := msgBoxWrapper("Convert curved shape to polygonal: " appTitle, "Please select the level of detail for the resulted polygonal shape.", "&Convert shape|&Cancel", 1, "image", nullCheckBox, 0, "90`%`f80`%`f`f70`%`f60`%`f50`%`f40`%`f30`%`f20`%`f10`%","",,, widthu)
   If InStr(msgResult.btn, "convert")
   {
      thisLevel := msgResult.list / 10
      PointsListArray := []
      Loop, % totalCount
      {
          getVPcoordsVectorPoint(A_Index, xu, yu)
          PointsListArray[A_Index*2 - 1] := xu
          PointsListArray[A_Index*2] := yu
      }

      thisPath := Gdip_CreatePath()
      createPathVectorCustomShape(thisPath, PointsListArray, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, 0, 1, 0)
      r1 := Gdip_FlattenPath(thisPath, thisLevel)
      PointsCount := Gdip_GetPathPointsCount(thisPath)
      If (PointsCount>200100)
      {
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The initial vector path has " totalCount " points. After converting it to a polygonal path, the path has " PointsCount ". Please note, " appTitle " was not developed to efficiently handle so many points in a vector path. It is likely that you will be noticing significant performance regressions. Please confirm you want to continue with the resulted polygonal path.", 4, 0, "question")
         If (msgResult!="Yes")
         {
            PointsF := ""
            PointsListArray := ""
            Gdip_DeletePath(thisPath)
            Return
         }
      }

      VarSetCapacity(PointsF, 8 * (PointsCount + 1), 0)
      r2 := DllCall("gdiplus\GdipGetPathPoints", "UPtr", thisPath, "UPtr", &PointsF, "int*", PointsCount)
      If (r1!=0 || r1!=0 || PointsCount<totalCount)
      {
         showTOOLtip("ERROR: Failed to convert curved shape to polygonal.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         PointsF := ""
         Gdip_DeletePath(thisPath)
         PointsListArray := ""
         Return
      }

      customShapeHasSelectedPoints := 0
      customShapePoints := []
      customShapePropPoints := []
      Loop, % PointsCount
      {
          x := NumGet(&PointsF, 8*(A_Index-1), "float")
          y := NumGet(&PointsF, (8*(A_Index-1))+4, "float")
          ; getVectorCoordsFromVPpoint(x, y, nX, nY)
          customShapePoints[A_Index] := [(x - prevDestPosX)/prevResizedVPimgW, (y - prevDestPosY)/prevResizedVPimgH]
          customShapePropPoints[A_Index] := [0, 0]
      }

      customShapeCountPoints := PointsCount
      FillAreaCurveTension := 1
      bezierSplineCustomShape := 0
      decideCustomShapeStyle()
      PointsF := ""
      PointsListArray := ""
      Gdip_DeletePath(thisPath)
      showTOOLtip("Curved vector shape converted to polygonal shape:`nInitial number of points: " groupDigits(totalCount) "`nAfter conversion: " groupDigits(PointsCount))
      recordVectorUndoLevels()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, dummyRefreshImgSelectionWindow, -50
   }
}

MenuAddUnorderedVectorPoint(zzx:=0, zzy:=0, mo:=0) {
   lastOtherWinClose := 1
   startZeit := A_TickCount
   vpWinClientSize(mainWidth, mainHeight)
   mX := lastUserRclickVPx, mY := lastUserRclickVPy

   gmX := (FlipImgH=1) ? mainWidth - mX : mX
   gmY := (FlipImgV=1) ? mainHeight - mY : mY
   If (mo="given")
   {
      gmX := zzx,    gmY := zzy
   }

   Gdip_SetPenWidth(pPen8, Gdip_GetPenWidth(PenuDrawLive) + 4)
   sl := Gdip_GetPenWidth(PenuDrawLive) + 4
   If (sl<4)
      sl := 4

   totalCount := customShapePoints.Count()
   If (FillAreaCurveTension>1)
      foundStuff := coreAddUnorderedVectorPointCurveMode(gmx, gmy, sl)
   Else
      foundStuff := coreAddUnorderedVectorPointPolyMode(gmx, gmy, sl)

   foundDot := foundStuff[1]
   foundOtherDot := foundStuff[2]
   canDoSymmetry := isNowSymmetricVectorShape()
   zzz := min(foundDot, foundOtherDot) + 1
   If (max(foundDot, foundOtherDot)>=totalCount && FillAreaCurveTension=1)
      zzz := totalCount + 1

   If (foundDot=(totalCount - 1) && FillAreaCurveTension=1)
      zzz := totalCount

   If foundDot
   {
      k := 0
      lastK1 := 0
      rr := "yes"
      If (bezierSplineCustomShape=1)
      {
         Loop, % zzz
         {
             k := clampInRange(k + 1, 1, 3, 1)
             If (k=1)
                lastK1 := A_Index
         }

         If (lastK1=zzz && k=1)
         {
            k := 2
            zzz++
         }
      }
      ; ToolTip, % "k=" k "|" lastK1 "|" zzz , , , 2
      lastZeitFileSelect := A_TickCount
      If (k=3 && bezierSplineCustomShape=1 || bezierSplineCustomShape!=1)
         pushAtGivenVectorPoint(zzz, gmX, gmY)
      Else If (k=1 && bezierSplineCustomShape=1 && zzz!=1)
         pushAtGivenVectorPoint(zzz - 1, gmX, gmY)
      Else If (k=2 && bezierSplineCustomShape=1)
         pushAtGivenVectorPoint(zzz + 1, gmX, gmY)

      ; pushAtGivenVectorPoint(zzz, gmX, gmY)
      symPoint := totalCount//2 + 1
      oppoIndex := (canDoSymmetry=1) ? totalCount - zzz + 1 : 0
      If (oppoIndex!=zzz && canDoSymmetry=1 && oppoIndex>0)
      {
         calculateSymmetricVectorPoint(gmX, gmY, nX, nY)
         If (zzz < oppoIndex)
            oppoIndex++

         If (bezierSplineCustomShape=1 && zzz>symPoint)
            oppoIndex -= 1
         Else
            oppoIndex++

         If (k=3 && bezierSplineCustomShape=1 || bezierSplineCustomShape!=1)
            pushed := pushAtGivenVectorPoint(oppoIndex, nX, nY)
         Else If (k=1 && bezierSplineCustomShape=1 && zzz!=1)
            pushed := pushAtGivenVectorPoint(oppoIndex - 1, nX, nY)
         Else If (k=2 && bezierSplineCustomShape=1)
            pushed := pushAtGivenVectorPoint(oppoIndex + 1, nX, nY)

         prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] + pushed
      }

      symPoint := totalCount//2 + 1
      If canDoSymmetry
         coreSetVPsymmetryPoint(symPoint)
      recordVectorUndoLevels()
   } Else
      rr := "no"
      ; splitPointGivenInPath(1, totalCount, foundDot, oppoIndex, canDoSymmetry, gmX, gmY)

   ; ToolTip, % totalCount " | dot=" foundDot "/" foundOtherDot "|" zzz "|" A_TickCount - startZeit , , , 2
   fnOutputDebug(A_ThisFunc "(): "  A_TickCount - startZeit " ms ")
   ; ToolTip, % A_TickCount - startZeit " ms loops=" hasFoundDot "| dot=" foundDot "/" foundOtherDot " | o=" outline " rects=" drects " kTotals=" kTotals , , , 2
   doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   SetTimer, dummyRefreshImgSelectionWindow, -25
   SetTimer, clearHGDIinfosWin, -255
   Return rr
}

clearHGDIinfosWin() {
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
}

coreAddUnorderedVectorPointCurveMode(gmx, gmy, sl) {
   totalCount := customShapePoints.Count()
   If (totalCount<3)
      Return

   decideCustomShapeStyle()
   vpWinClientSize(mainWidth, mainHeight)
   PointsListArray := []
   Loop, % totalCount
   {
       getVPcoordsVectorPoint(A_Index, xu, yu)
       xu := Round(xu),    yu := Round(yu)
       apz := "a" xu "|" yu
       PointsListArray[A_Index*2 - 1] := xu
       PointsListArray[A_Index*2] := yu
   }

   thisPath := Gdip_CreatePath()
   createPathVectorCustomShape(thisPath, PointsListArray, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, 0, 1, 0)
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, gmx + 5, gmy + 5)
   If validBMP(pBitmap)
   {
      zg := Gdip_GraphicsFromImage(pBitmap)
      Gdip_GraphicsClear(zg, "0xFF000000")
      fnOutputDebug(pBitmap "|" zg)
      Gdip_DrawPath(zg, pPen8, thisPath)
      ; Gdip_DrawImageFast(2NDglPG, pBitmap)
      clr := Gdip_GetPixelColor(pBitmap, gmx, gmy, 2)
      ; fnOutputDebug("clr=" clr[2])
      ; doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
      Gdip_DeleteGraphics(zg)
      trGdip_DisposeImage(pBitmap)
   }

   outline := (clr[2]>1) ? 1 : 0 ; this is too slow >>> Gdip_IsOutlineVisiblePathPoint(2NDglPG, thisPath, pPen8, gmX, gmY)
   If (outline=1)
   {
      If (closedLineCustomShape=1)
      {
         PointsListArray[(totalCount + 1)*2 - 1] := PointsListArray[1]
         PointsListArray[(totalCount + 1)*2] := PointsListArray[2]
      }

      prevPointsCount := CreatePointsF(prevPointsF, PointsListArray)
      startZeit := A_TickCount
      Gdip_FlattenPath(thisPath, 0.2)
      PointsCount := Gdip_GetPathPointsCount(thisPath)
      VarSetCapacity(PointsF, 8 * (PointsCount + 1), 0)
      ; fnOutputDebug(A_ThisFunc ": " outline "|" PointsCount "|" totalCount "|" prevPointsCount )
      finalIndex := lastIndex := hasFound := outline := 0
      zaa := zbb := firstu := lastu := -1

      gdipLastError := DllCall("gdiplus\GdipGetPathPoints", "UPtr", thisPath, "UPtr", &PointsF, "int*", PointsCount)
      zz := DllCall(whichMainDLL "\traverseCurvedPath", "UPtr", &prevPointsF, "Int", prevPointsCount - 1, "UPtr", &PointsF, "Int", PointsCount - 1, "Int", gmx, "Int", gmy, "int", sl, "UPtr", pPen8, "int*", zaa, "int*", zbb, "int*", firstu, "int*", lastu)
      If (zz=2)
         hasFound := 1
      If (!zz)
         addJournalEntry(A_ThisFunc "(): Failed to execute traverseCurvedPath() from the main DLL.")
      Else
         fnOutputDebug("zeitung=" A_TickCount - startZeit " ms ||" zaa "|" zbb "||" firstu "|" lastu)
   }

   Gdip_DeletePath(thisPath)
   PointsListArray := []
   Gdip_GraphicsClear(2NDglPG)
   thisIndex := 0
   If (hasFound)
   {
      diffu := abs(lastu - firstu)
      Loop, % diffu
      {
          ti := firstu + A_Index - 1
          If (ti>=PointsCount || ti<1)
             Continue

          ax := NumGet(&PointsF, 8 * (ti - 1), "float")
          ay := NumGet(&PointsF, (8 * (ti - 1)) + 4, "float")
          thisIndex++
          ; fnOutputDebug(ax "|" ay)

          PointsListArray[thisIndex*2 - 1] := ax
          PointsListArray[thisIndex*2] := ay
      }

      thisPath := Gdip_CreatePath()
      Gdip_AddPathLines(thisPath, PointsListArray)
      setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
      Gdip_DrawPath(2NDglPG, pPen8, thisPath)
      doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
      Gdip_ResetWorldTransform(2NDglPG)
      Gdip_DeletePath(thisPath)
   }

   PointsF := ""
   prevPointsF := ""
   foundDots := []
   If (hasFound)
      foundDots := [zaa, zbb]
   Return foundDots
}

coreAddUnorderedVectorPointPolyMode(gmx, gmy, sl) {
   totalCount := customShapePoints.Count()
   If (totalCount<3)
      Return

   foundDots := []
   aIndex := bIndex := 0
   z := (FillAreaClosedPath=1) ? totalCount + 1 : totalCount
   PointsListArray := []
   Loop, % totalCount + 1
   {
       aIndex++
       If (aIndex>totalCount)
          aIndex := 1
       getVPcoordsVectorPoint(aIndex, ax, ay)
       PointsListArray[aIndex] := [ax, ay]
   }

   aIndex := 0
   bIndex := 1
   Loop, % z
   {
       aIndex++
       ax := PointsListArray[aIndex, 1]
       ay := PointsListArray[aIndex, 2]

       bIndex++
       bx := PointsListArray[bIndex, 1]
       by := PointsListArray[bIndex, 2]

       min_dist(ax, bx, sl)
       min_dist(ay, by, sl)
       inn := isDotInRect(gmx, gmy, ax, bx, ay, by)
       If inn
       {
          pPath := Gdip_CreatePath()
          ax := PointsListArray[aIndex, 1],          ay := PointsListArray[aIndex, 2]
          bx := PointsListArray[bIndex, 1],          by := PointsListArray[bIndex, 2]
          DllCall("gdiplus\GdipAddPathLine", "UPtr", pPath, "float", ax, "float", ay, "float", bx, "float", by)
          outline := Gdip_IsOutlineVisiblePathPoint(0, pPath, pPen8, gmX, gmY)
          If (outline=1)
          {
             ; Gdip_GraphicsClear(2NDglPG)
             Gdip_DrawPath(2NDglPG, pPen8, pPath)
             doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
             Gdip_DeletePath(pPath)
             foundDots := [aIndex, bIndex]
             Break
          }
          Gdip_DeletePath(pPath)
       }
   }
   Return foundDots
}

min_dist(ByRef va, ByRef vb, distu) {
   d := abs(va - vb)
   If (d>=distu)
      Return

   dp := distu - d
   k := (dp//2 = dp/2) ? 0 : 1
   If (va<vb)
   {
      va -= dp//2
      vb += dp//2 + k
   } Else
   {
      va += dp//2 + k
      vb -= dp//2
   }
   ;  fnOutputDebug(A_ThisFunc ": after = " va "|" vb "|d=" abs(va - vb))
}

MenuCollapseVectorPoint() {
  lastOtherWinClose := 1
  vpWinClientSize(mainWidth, mainHeight)
  lastZeitFileSelect := A_TickCount
  PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "collapseClick", 0, 0, 0)
  SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuExpandVectorPointAnchors() {
  lastOtherWinClose := 1
  vpWinClientSize(mainWidth, mainHeight)
  ; lastZeitFileSelect := A_TickCount
  PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "expandClick", 0, 0, 0)
  SetTimer, dummyForcedRefreshImgSelectionWindow, -10
}

MenuSetStartVectorPoint(given:=0, isGiven:=0) {
  wasGiven := (given>0 && isGiven="yes") ? 1 : 0
  If (isNowSymmetricVectorShape() && wasGiven=0)
  {
     showTOOLtip("WARNING: The symmetry mode is currently activated. `nIt is not allowed to change the start point of the path.")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  totalLoops := customShapePropPoints.Count()
  If (totalLoops<3)
     Return

  lastOtherWinClose := 1
  vpWinClientSize(mainWidth, mainHeight)
  If (wasGiven=1)
     newStartPoint := given
  Else
     newStartPoint := PerformVectorShapeActions(lastUserRclickVPx, lastUserRclickVPy, mainWidth, mainHeight, "setStart", 0, 1)

  If (newStartPoint=1)
     Return

  newStartCoords := []
  Loop, % totalLoops - newStartPoint
      newStartCoords[A_Index] := customShapePropPoints[A_Index + newStartPoint - 1]
  Loop, % newStartPoint - 1
      newStartCoords[A_Index + totalLoops - newStartPoint] := customShapePropPoints[A_Index]
  newStartCoords.InsertAt(1 + totalLoops - newStartPoint, customShapePropPoints[totalLoops])

  newArrayu := []
  totalLoops := customShapePoints.Count()
  Loop, % totalLoops - newStartPoint
      newArrayu[A_Index] := customShapePoints[A_Index + newStartPoint - 1]
  Loop, % newStartPoint - 1
      newArrayu[A_Index + totalLoops - newStartPoint] := customShapePoints[A_Index]
  newArrayu.InsertAt(1 + totalLoops - newStartPoint, customShapePoints[totalLoops])

  ; r := totalLoops - newStartPoint
  ; d := newStartPoint - 1
  ; e := 1 + totalLoops - newStartPoint
  ; f := d + totalLoops - newStartPoint
  ; newu := newArrayu.Count()
  ; ToolTip, % totalLoops "==" newu "|" r "|" d "|" e "|" f , , , 2
  customShapePropPoints := newStartCoords.Clone()
  customShapePoints := newArrayu.Clone()
  recordVectorUndoLevels()
  lastZeitFileSelect := A_TickCount
  SetTimer, dummyRefreshImgSelectionWindow, -10
}

MenuToggleBezierMode() {
   bezierSplineCustomShape := !bezierSplineCustomShape
   FillAreaCurveTension := (bezierSplineCustomShape=1) ? 5 : 3
   If (drawingShapeNow!=1 && bezierSplineCustomShape=1)
      closedLineCustomShape := 0

   friendly := (bezierSplineCustomShape=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Bézier path mode: " friendly, A_ThisFunc, 1)
   performBezierActivePathAutoFixNow()
   decideCustomShapeStyle()
   RegAction(1, "FillAreaCurveTension")
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()

   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(100)
}

performBezierActivePathAutoFixNow() {
   PointsCount := customShapePoints.Count()
   If (bezierSplineCustomShape=1 && PointsCount>0)
   {
      r := mod(PointsCount, 3)
      ; ToolTip, % "r=" r, , , 2
      c := customShapePoints[PointsCount]
      d := customShapePropPoints[PointsCount]
      loops := (r=2) ? 2 : 1
      If (r=1)
         loops := 0

      Loop, % loops
      {
         customShapePoints.Push(c.Clone())
         customShapePropPoints.Push(d.Clone())
      }
      ; ToolTip, % "l=" loops , , , 2
   }
}

PerformVectorShapeActions(mX, mY, mainWidth, mainHeight, mainParam, ctrlState, shiftState, altState:=0) {
; the following array is used when editing the vector shape to hold details about viewport conditions when user added/modified points:
   ; customShapePropPoints[A_Index] := [prevDestPosX, prevDestPosY, isSelected, prevResizedVPimgW, prevResizedVPimgH]

; the main array is:
   ; customShapePoints[A_Index] := [x, y]
   ; it holds the actual coords of the points, the data is held in pixels units when user edits the shape; when not, the values are relative to a rect bound box [0 to 1]

   Critical, on
   Static lastIndex
   If ((mainParam="setStart") || (A_TickCount - lastOtherWinClose<250))
      Return lastIndex

   ; fnOutputDebug(A_ThisFunc "(): " lastIndex " | " mX "=" mY " || " mainParam)
   If (mainParam="rClick")
   {
      lastUserRclickVPx := mX
      lastUserRclickVPy := mY
   }

   If !IsObject(customShapePoints)
      customShapePoints := []

   gmX := (FlipImgH=1) ? mainWidth - mX : mX
   gmY := (FlipImgV=1) ? mainHeight - mY : mY
   selu := oppoIndex := doSpecialAct := dontAddPoint := dotRemoved := 0
   hasFoundDot := k := thisIndex := 0
   totalCount := customShapePoints.Count()
   canDoSymmetry := isNowSymmetricVectorShape()
   sl := SelDotsSize//2 + 1
   If (totalCount<3)
   {
      vectorToolModus := 1
      If (ShowAdvToolbar=1)
         decideIconBTNvectToolModes()
   }

   ; determine user clicked point from the entire path
   vectorVisiblePoints := drawLiveCreateCustomShape("getPoints", 0, 0)
   thisObjIndex := drawVisibleVectorPoints(gmX, gmY, mX, mY, "clicky", totalCount, 0, mainWidth, mainHeight, vectorVisiblePoints, "")
   thisIndex := thisObjIndex[1]
   oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
   selu := customShapePropPoints[thisIndex, 1]
   k := (bezierSplineCustomShape=1) ? thisObjIndex[4] : 1
   getVPcoordsVectorPoint(thisIndex, xu, yu)
   If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
   {
      hasFoundDot := 1
      If (k!=1 && bezierSplineCustomShape=1)
      {
         ; if an anchor point was clicked, determine if other points in the proximity share the same coordinates
         ; if they do, then consider the associated key point as the point that was clicked...
         ; this prevents users from clicking on anchors when they click on «key» points
         nextK := getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
         getVPcoordsVectorPoint(thisIndex, refX, refY)
         getVPcoordsVectorPoint(A, refAx, refAy)
         getVPcoordsVectorPoint(B, refBx, refBy)
         getVPcoordsVectorPoint(nextK, refKx, refKy)
         If ( isDotInRect(refX, refY, sl, sl, refAx, refAy, 1)
         || isDotInRect(refX, refY, sl, sl, refBx, refBy, 1)
         || isDotInRect(refX, refY, sl, sl, refKx, refKy, 1) )
         {
            thisIndex := (k=3) ? nextK : nextK - 3
            oppoIndex := (canDoSymmetry=1) ? totalCount - thisIndex + 1 : -1
            getVPcoordsVectorPoint(thisIndex, xu, yu)
            k := 1
            If !selu
               selu := customShapePropPoints[thisIndex, 1]
         }
      }
      dontAddPoint := 1
   }
   ; ToolTip, % "l=" mainParam , , , 2
   If hasFoundDot
   {
      ; perform action[s] on thisIndex point from customShapePoints
      If (mainParam="DoubleClick" && totalCount>2 && shiftState=0 && ctrlState=0 && vectorToolModus!=3)
      {
         dontAddPoint := 1
         If (vectorToolModus=4)
            selectGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, mainParam, gmX, gmY)
         Else If (k!=1 && bezierSplineCustomShape=1)
            collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
         Else If ((k=1 && altState=0 && bezierSplineCustomShape=1 || bezierSplineCustomShape!=1) && vectorToolModus!=5)
            splitPointGivenInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
         Else If (altState=1 && bezierSplineCustomShape=1 && k=1)
         {
            doSpecialAct := dontAddPoint := 1
            rrz := expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
            If !rrz
            {
               doSpecialAct := dontAddPoint := 1
               collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
            }
            rrz := (rrz=1) ? "" : "no" 
         }
      } Else If (shiftState=1 && !isVarEqualTo(vectorToolModus,2,3) || mainParam="selClick" || vectorToolModus=4 && mainParam="normal" && ctrlState=0)
      {
         dontAddPoint := 1
         ; lastZeitFileSelect := A_TickCount
         If (vectorToolModus=4 && shiftState=1 && mainParam="normal")
         {
            selectGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, mainParam, gmX, gmY)
            selectPathPointsInRect(gmX, gmY, shiftState, ctrlState)
         } Else
            selectGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, mainParam, gmX, gmY)
         rrz := "no"
      } Else If (mainParam="collapseClick")
      {
         doSpecialAct := dontAddPoint := 1
         collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
      } Else If (mainParam="splitPoint")
      {
         dontAddPoint := 1
         splitPointGivenInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
      } Else If (mainParam="align-x" || mainParam="align-y")
      {
         dontAddPoint := 1
         rrz := alignPointsWithPointInPath(mainParam, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
         rrz := (rrz=1) ? "" : "no" 
      } Else If (mainParam="reflectAnchor")
      {
         doSpecialAct := dontAddPoint := 1
         reflectGivenAnchorInPath(k, totalCount, thisIndex, canDoSymmetry)
      } Else If (mainParam="expandClick") || (altState=1 && mainParam="DoubleClick" && bezierSplineCustomShape=1 && k=1)
      {
         doSpecialAct := dontAddPoint := 1
         rrz := expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
         rrz := (rrz=1) ? "" : "no" 
      } Else If (ctrlState=1 && vectorToolModus<5 || mainParam="remClick" || vectorToolModus=3 && mainParam="normal")
      {
         dotRemoved := 1
         If (vectorToolModus=4 && ctrlState=1 && mainParam="normal")
            selectPathPointsInRect(gmX, gmY, shiftState, ctrlState)
         Else
            removeGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
      } Else If (mainParam!="remClick" && mainParam!="rClick" && ctrlState=0 && shiftState=0)
      {
         If (customShapeHasSelectedPoints=1 && selu=1)
         {
            ; drag/move selected points
            moveSelectedPointsInVectorPath(gmX, gmY, altState)
            dontAddPoint := doSpecialAct := 1
         } Else
         { 
            dontAddPoint := 1
            mustRem := moveOnePointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY, altState)
            rrz := (mustRem=1) ? "" : "no" 
         }
      }
   } Else
   {
      If (ctrlState=1 || altState=1)
         rrz := "no"
     
      If (vectorToolModus=4)
      {
         If (!shiftState && mainParam="DoubleClick")
            MenuSelNoVectorPoints()
         Else If ((shiftState=1 || ctrlState=1) && mainParam="Normal")
            selectPathPointsInRect(gmX, gmY, shiftState, ctrlState)
         rrz := "no"
      }
      thisIndex := 0
   }

   If (dontAddPoint && thisIndex)
      lastIndex := thisIndex

   If (mustRem=1)
      RemoveTooltip()

   If (mainParam="rClick" && dotRemoved!=1)
   {
      createContextMenuCustomShapeDrawing(mX, mY, dontAddPoint, thisIndex, k)
      Return lastIndex
   }

   If (customShapeHasSelectedPoints=1 && doSpecialAct!=1 && dotRemoved!=1 && dontAddPoint!=1 && !InStr(mainParam, "pen-") && ctrlState=0 && altState=0 && vectorToolModus=5)
   {
      dontAddPoint := 1
      If (mainParam="DoubleClick" && customShapeHasSelectedPoints=1)
      {
         SetTimer, MenuSelNoVectorPoints, -50
      } Else
      {
         zpr := rescaleSelectedVectorPoints(shiftState)
         rrz := (zpr=0) ? "no" : ""
      }
   }

   ; If (FlipImgH=1 || FlipImgV=1)
      ; vpWinClientSize(mainWidth, mainHeight)
   If (doSpecialAct!=1 && dotRemoved!=1 && dontAddPoint!=1 && mainParam!="DoubleClick" && !InStr(mainParam, "pen-") && ctrlState=0 && altState=0 && (vectorToolModus<3 || vectorToolModus=4))
   {
      If (vectorToolModus=2)
      {
         If (MenuAddUnorderedVectorPoint(gmX, gmY, "given")="yes")
            Return
      } Else If (vectorToolModus=4)
      {
         selectPathPointsInRect(gmX, gmY, shiftState, ctrlState)
         Return
      }
      ; actually add new point[s] to path, if nothing else happened before ^_^ 
      lastSnap := drawVisibleVectorPoints("snap", 0, 0, 0, 0, 0, 0, 0, 0, ppz, "")
      If (lastSnap[1]!="" && lastSnap[2]!="" && shiftState=1)
      {
         gmX := lastSnap[1],   gmY := lastSnap[2]
      }

      hasSymmetry := calculateSymmetricVectorPoint(gmX, gmY, nX, nY)
      If hasSymmetry
      {
         doFlippuX := (gmX<vpSymmetryPointXdp && CustomShapeSymmetry=1) ? 1 : 0
         doFlippuY := (gmY<vpSymmetryPointYdp && CustomShapeSymmetry=2) ? 1 : 0
         ; ToolTip, % doFlippuX "|" doFlippuY , , , 2
         If (doFlippuX || doFlippuY)
         {
            swapVars(gmX, nX)
            swapVars(gmY, nY)
         }
         pushAtGivenVectorPoint(1, nX, nY)
      } Else If (customShapePoints.Count()>2)
         CustomShapeSymmetry := CustomShapeLockedSymmetry := 0

      thisIndex := pushEndNewVectorPoint(gmX, gmY)
      If (customShapePoints.Count()=3 && CustomShapeSymmetry)
         prevVectorShapeSymmetryMode[1, 1] := 2 
      ; klp := prevVectorShapeSymmetryMode[1, 1]
      ; ToolTip, % "klp =" klp , , , 2
      If (bezierSplineCustomShape=1 && thisIndex>2)
      {
         fn := Func("adjustAnchorPointsCustomShape").Bind(thisIndex + 1)
         SetTimer, % fn, -20
      } Else If (hasSymmetry!=1 && shiftState=0 && bezierSplineCustomShape=0)
         SetTimer, addFluidPointsCustomShape, -200
   } Else If (mainParam!="remClick" && mainParam!="rClick" && ctrlState=0 && altState=1 && shiftState=0 && !hasFoundDot && vectorToolModus<3)
   {
      rrz := "no"
      MenuAddUnorderedVectorPoint(gmX, gmY, "given")
   }

   If (rrz!="no")
      recordVectorUndoLevels()

   SetTimer, dummyRefreshImgSelectionWindow, -5
} ; // PerformVectorShapeActions()

autoDeactivateClosedBezier() {
   r := testIsEditorBezierPathClosed()
   If (r=1)
   {
      closedLineCustomShape := 0
      reduceCustomShapeLength()
      If (testIsEditorBezierPathClosed()=1)
         reduceCustomShapeLength()

      RegAction(1, "closedLineCustomShape")
      If (drawingShapeNow=1)
         showQuickActionButtonsDrawingShape()
   }
}

pushEndNewVectorPoint(ogmX, ogmY, noCloseTest:=0, zz:=0) {
   If (bezierSplineCustomShape=1 && noCloseTest=0)
      autoDeactivateClosedBezier()

   zr := 1
   handleOpenCloseBezier("kill")
   getVectorCoordsFromVPpoint(ogmX, ogmY, gmX, gmY)
   customShapePoints.Push([gmX, gmY])
   customShapePropPoints.Push([0, 0])
   prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] + 1
   thisIndex := customShapePoints.MaxIndex()
   If (bezierSplineCustomShape=1)
   {
      zr := 2
      customShapePoints.Push([gmX, gmY])
      customShapePropPoints.Push([0, 0])
      prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] + 1
      If (thisIndex>4)
      {
         zr := 3
         customShapePoints.Push([gmX, gmY])
         customShapePropPoints.Push([0, 0])
         prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] + 1
      }
   }

   If (isNowSymmetricVectorShape() && bezierSplineCustomShape=1)
   {
      lastZeitFileSelect := A_TickCount
   } Else If (zz!=1)
   {
      vpWinClientSize(mainWidth, mainHeight)
      drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-new-end", zr)
      If (bezierSplineCustomShape=1)
         drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", customShapePoints.Count() - 1)
   }
   Return thisIndex
}

pushAtGivenVectorPoint(givenIndex, ogmX, ogmY) {
   pushed := 1
   If (givenIndex<4 || givenIndex>(customShapePoints.Count() - 3))
      handleOpenCloseBezier("kill")

   getVectorCoordsFromVPpoint(ogmX, ogmY, gmX, gmY)
   customShapePoints.InsertAt(givenIndex, [gmX, gmY])
   customShapePropPoints.InsertAt(givenIndex, [0, 0])
   thisIndex := customShapePoints.MaxIndex()
   If (bezierSplineCustomShape=1)
   {
      customShapePoints.InsertAt(givenIndex, [gmX, gmY])
      customShapePropPoints.InsertAt(givenIndex, [0, 0])
      pushed++
      If (thisIndex>4)
      {
         pushed++
         customShapePoints.InsertAt(givenIndex, [gmX, gmY])
         customShapePropPoints.InsertAt(givenIndex, [0, 0])
      }
   }
   Return pushed
}

alignPointsWithPointInPath(modus, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY) {
   k := (bezierSplineCustomShape=1) ? 0 : 1
   getVPcoordsVectorPoint(thisIndex, xa, ya)
   calculateSymmetricVectorPoint(xa, ya, pnX, pnY)
   getVectorCoordsFromVPpoint(pnX, pnY, nX, nY)
   p := customShapePoints[thisIndex]
   pzx := p[1],    pzy := p[2]
   totalCount := customShapePoints.Count()
   ; ToolTip, % thisIndex "|" modus , , , 2
   hasLooped := 0
   setWhileLoopExec(1)
   Loop, % totalCount
   {
           If (customShapePropPoints[A_Index, 1]!=1)
              Continue

           hasLooped := 1
           If (modus="align-x")
              customShapePoints[A_Index] := [pzx, customShapePoints[A_Index, 2]]
           Else
              customShapePoints[A_Index] := [customShapePoints[A_Index, 1], pzy]

           oppoIndex := (canDoSymmetry=1) ? totalCount - A_Index + 1 : 0
           If (oppoIndex && canDoSymmetry && thisIndex!=oppoIndex && oppoIndex!=symPoint)
           {
              If (modus="align-x")
                 customShapePoints[oppoIndex] := [nX, customShapePoints[oppoIndex, 2]]
              Else
                 customShapePoints[oppoIndex] := [customShapePoints[oppoIndex, 1], nY]
           }
   }

   setWhileLoopExec(0)
   If canDoSymmetry
      coreSetVPsymmetryPoint(symPoint)

   lastZeitFileSelect := A_TickCount
   Return hasLooped
}

splitPointGivenInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY) {
   If (bezierSplineCustomShape=1)
   {
      endsConnected := areEndsConnectedBezierPath(thisIndex, totalCount)
      If endsConnected
      {
         SoundBeep ,300, 100
         handleOpenCloseBezier("kill")
         expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
         expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY, "no")
         closedLineCustomShape := 0
         lastZeitFileSelect := A_TickCount
         RegAction(1, "closedLineCustomShape")
         If (drawingShapeNow=1)
            showQuickActionButtonsDrawingShape()
         Return
      }
   }

   If (isNowSymmetricVectorShape() && thisIndex=prevVectorShapeSymmetryMode[1, 1])
   {
      showTOOLtip("WARNING: The designated symmetry point cannot be divided.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (thisIndex<4 || thisIndex>(customShapePoints.Count() - 3))
      handleOpenCloseBezier("kill")
   Random, slx, % SelDotsSize//2 + 1, SelDotsSize*4
   Random, sly, % SelDotsSize//2 + 1, SelDotsSize*4
   Random, r1, -1, 1
   Random, r2, -1, 1
   slx := (r1<0) ? -1*slx : slx
   sly := (r2<0) ? -1*sly : sly
   totalCount := customShapePoints.Count()
   symPoint := totalCount//2 + 1
   If canDoSymmetry
      thisIndex += 3

   If (k=3 && bezierSplineCustomShape=1 || bezierSplineCustomShape!=1)
      pushAtGivenVectorPoint(thisIndex, gmX - slx, gmY - sly)
   Else If (k=1 && bezierSplineCustomShape=1 && thisIndex!=1)
      pushAtGivenVectorPoint(thisIndex - 1, gmX - slx, gmY - sly)
   Else If (k=2 && bezierSplineCustomShape=1)
      pushAtGivenVectorPoint(thisIndex + 1, gmX - slx, gmY - sly)

   If (oppoIndex!=thisIndex && canDoSymmetry=1)
   {
      calculateSymmetricVectorPoint(gmX - slx, gmY - sly, nX, nY)
      If (thisIndex < oppoIndex)
         oppoIndex++

      If (bezierSplineCustomShape=1)
         oppoIndex += 1
      Else
         oppoIndex++

      If (k=3 && bezierSplineCustomShape=1 || bezierSplineCustomShape!=1)
         pushed := pushAtGivenVectorPoint(oppoIndex, nX, nY)
      Else If (k=1 && bezierSplineCustomShape=1 && thisIndex!=1)
         pushed := pushAtGivenVectorPoint(oppoIndex - 1, nX, nY)
      Else If (k=2 && bezierSplineCustomShape=1)
         pushed := pushAtGivenVectorPoint(oppoIndex + 1, nX, nY)

      If (bezierSplineCustomShape=1)
      {
         thisIndex -= 2
         Loop, 8
         {
            thisIndex++
            getVPcoordsVectorPoint(thisIndex, px, py)
            calculateSymmetricVectorPoint(px, py, zx, zy)
            getVectorCoordsFromVPpoint(zx, zy, zx, zy)
            pp := customShapePoints.Count() - thisIndex + 1
            customShapePoints[pp] := [zx, zy]
            ; ToolTip, % pp "|" thisIndex + 5 , , , 2
         }
      }
      prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] + pushed
   } Else If (CustomShapeLockedSymmetry && oppoIndex=-1)
   {
      prevVectorShapeSymmetryMode[1, 2] := 0
      CustomShapeLockedSymmetry := 0
   }

   symPoint := customShapePoints.Count()//2 + 1
   If isNowSymmetricVectorShape()
      coreSetVPsymmetryPoint(symPoint)

   lastZeitFileSelect := A_TickCount
   drawLiveCreateCustomShape("kill", 0, 0)
   dummyRefreshImgSelectionWindow()
}

areEndsConnectedBezierPath(thisIndex, totalCount, m:=0) {
   Return ((thisIndex<3 || thisIndex>totalCount - 2) && testIsEditorBezierPathClosed(m)=1) ? 1 : 0
}

expandGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY, dummy:=0) {
   If (thisIndex<4 || thisIndex>(customShapePoints.Count() - 3))
      handleOpenCloseBezier("kill")

   endsConnected := areEndsConnectedBezierPath(thisIndex, totalCount)
   nextK := getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
   auxiliaryPoints := getPointsSameCoordsVectorPath(totalCount, k, thisIndex, gmX, gmY)
   If (auxiliaryPoints.Count()<1 && endsConnected=1 || !endsConnected || dummy="no")
      auxiliaryPoints2 := getPointsSameCoordsVectorPath(totalCount, 1, nextK, customShapePoints[nextK, 1], customShapePoints[nextK, 2])

   initial := auxiliaryPoints.Count()
   Loop, % auxiliaryPoints2.Count()
      auxiliaryPoints.Push(auxiliaryPoints2[A_Index])

   hasFoundDot := 0
   Loop, % auxiliaryPoints.Count()
   {
      If (auxiliaryPoints[A_Index, 1]=thisIndex)
         Continue

      isOkay := (auxiliaryPoints[A_Index, 1]=A || auxiliaryPoints[A_Index, 1]=B) ? 1 : 0
      If !isOkay
         Continue

      hasFoundDot := 1
   }

   hasLooped := 0
   Loop, % auxiliaryPoints.Count()
   {
      If (auxiliaryPoints[A_Index, 1]=thisIndex)
         Continue

      isOkay := (auxiliaryPoints[A_Index, 1]=A || auxiliaryPoints[A_Index, 1]=B) ? 1 : 0
      If ((!isOkay && hasFoundDot=1) || (hasFoundDot=0 && A_Index>initial))
         Continue

      Random, slx, % SelDotsSize + 1, SelDotsSize*4
      Random, sly, % SelDotsSize + 1, SelDotsSize*4
      Random, r1, -1, 1
      Random, r2, -1, 1
      hasLooped := 1
      slx := (r1<0) ? -1*slx : slx
      sly := (r2<0) ? -1*sly : sly
      getVectorCoordsFromVPpoint(gmX + slx, gmY + sly, nX, nY)
      customShapePoints[auxiliaryPoints[A_Index, 1]] := [nX, nY]
      If (oppoIndex!=thisIndex && canDoSymmetry=1)
      {
         calculateSymmetricVectorPoint(gmX + slx, gmY + sly, nX, nY)
         getVectorCoordsFromVPpoint(nX, nY, nX, nY)
         customShapePoints[auxiliaryPoints[A_Index, 2]] := [nX, nY]
      }
   }
   If (k=1 && bezierSplineCustomShape=1 && thisIndex>1 && hasLooped=1)
      reflectGivenAnchorInPath(3, totalCount, thisIndex - 1, canDoSymmetry)

   If hasLooped
   {
      vpWinClientSize(mainWidth, mainHeight)
      drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", thisIndex)
      SetTimer, dummyRefreshImgSelectionWindow, -50
   }

   Return hasLooped
}

reflectGivenAnchorInPath(k, totalCount, thisIndex, canDoSymmetry, forceIT:=0, doRedraw:=1) {
   ; this assumes drawingShapeNow = 1
   If (k!=1 && isInRange(thisIndex, 2, totalCount - 1))
   {
      If (thisIndex=2 || thisIndex=(totalCount - 1))
      {
         r := testIsEditorBezierPathClosed()
         If (r!=1)
            Return
      }

      whichIndex := (k=2) ? thisIndex - 1 : thisIndex + 1
      If (whichIndex=prevVectorShapeSymmetryMode[1, 1] && canDoSymmetry && forceIT!=1)
         Return

      vpWinClientSize(mainWidth, mainHeight)
      ; whichIndex = key point , to which the anchors belong to
      getVPcoordsVectorPoint(whichIndex, xA, yA)

      ; thisIndex = anchor to be reflected
      getVPcoordsVectorPoint(thisIndex, xB, yB)
      w := max(xA, xB) - min(xA, xB)
      h := max(yA, yB) - min(yA, yB)
      gmX := (xA<xB) ? xA - w : xA + w
      gmY := (yA<yB) ? yA - h : yA + h

      ; indexu = «destination» anchor for the reflected whichIndex anchor
      indexu := (k=2) ? thisIndex - 2 : thisIndex + 2
      If (r=1)
         indexu := (k=2) ? totalCount - 1 : 2

      getVectorCoordsFromVPpoint(gmX, gmY, zzX, zzY)
      customShapePoints[indexu] := [zzX, zzY]
      getVectorCoordsFromVPpoint(xB, yB, zzX, zzY)
      customShapePoints[thisIndex] := [zzX, zzY]
      If (doRedraw=1)
      {
         drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", indexu - 2)
         If (r=1)
            drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", 1)
      }
      ; ToolTip, % k "A[" whichIndex "]=" cA[1] "|" cA[2] "`nB[" thisIndex "]=" cB[1] "|" cB[2] "`nC[" indexu "]" gmX "|" gmY  , , , 2
      If (oppoIndex!=thisIndex && canDoSymmetry=1 && !r)
      {
         oppoIndex := totalCount - indexu + 1
         calculateSymmetricVectorPoint(gmX, gmY, nX, nY)
         getVectorCoordsFromVPpoint(nX, nY, nX, nY)
         customShapePoints[oppoIndex] := [nX, nY]
         If (doRedraw=1)
            drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", oppoIndex)

         oppoIndex := totalCount - thisIndex + 1
         calculateSymmetricVectorPoint(xB, yB, gX, gY)
         getVectorCoordsFromVPpoint(gX, gY, gX, gY)
         customShapePoints[oppoIndex] := [gX, gY]
         If (doRedraw=1)
            drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", oppoIndex)
      }
   }
}

reflectGivenAnchorInAltPath(ByRef PointsList, thisIndex, indexu, whichIndex) {
   ; this assumes drawingShapeNow = 0
   ; whichIndex = key point , to which the anchors belong to
   xA := PointsList[whichIndex*2 - 1], yA := PointsList[whichIndex*2]

   ; thisIndex = anchor to be reflected
   xB := PointsList[thisIndex*2 - 1], yB := PointsList[thisIndex*2]

   w := max(xA, xB) - min(xA, xB)
   h := max(yA, yB) - min(yA, yB)
   gmX := (xA<xB) ? xA - w : xA + w
   gmY := (yA<yB) ? yA - h : yA + h

   ; indexu = «destination» anchor for the reflected whichIndex anchor
   PointsList[indexu*2 - 1] := gmX
   PointsList[indexu*2] := gmY
   ; ToolTip, % k "A[" whichIndex "]=" xA "|" yA "`nB[" thisIndex "]=" xB "|" yB "`nC[" indexu "]=" gmX "|" gmY  , , , 2
}

getVectorCoordsFromVPpoint(px, py, ByRef X, ByRef Y) {
   x := (px - prevDestPosX)/prevResizedVPimgW
   y := (py - prevDestPosY)/prevResizedVPimgH
}

getVPcoordsVectorPoint(whichIndex, ByRef X, ByRef Y) {
   x := customShapePoints[whichIndex, 1]*prevResizedVPimgW + prevDestPosX
   y := customShapePoints[whichIndex, 2]*prevResizedVPimgH + prevDestPosY
}

collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry) {
   If (thisIndex<4 || thisIndex>(customShapePoints.Count() - 3))
      handleOpenCloseBezier("kill")

   If (k=2)
   {
      c := customShapePoints[thisIndex - 1]
      customShapePoints[thisIndex] := [c[1], c[2]]
      If (oppoIndex!=thisIndex && canDoSymmetry=1)
      {
         c := customShapePoints[totalCount - (thisIndex - 1) + 1]
         customShapePoints[oppoIndex] := [c[1], c[2]]
      }
   } Else If (k=3)
   {
      c := customShapePoints[thisIndex + 1]
      customShapePoints[thisIndex] := [c[1], c[2]]
      If (oppoIndex!=thisIndex && canDoSymmetry=1)
      {
         c := customShapePoints[totalCount - (thisIndex + 1) + 1]
         customShapePoints[oppoIndex] := [c[1], c[2]]
      }
   } Else If (k=1)
   {
      endsConnected := ((thisIndex=1 || thisIndex=totalCount) && testIsEditorBezierPathClosed()=1) ? 1 : 0
      If endsConnected
      {
         c := customShapePoints[1]
         customShapePoints[2] := [c[1], c[2]]
         customShapePoints[totalCount - 1] := [c[1], c[2]]
      } Else
      {
         c := customShapePoints[thisIndex]
         If (thisIndex + 1<=totalCount)
            customShapePoints[thisIndex + 1] := [c[1], c[2]]

         If (thisIndex - 1>=1)
            customShapePoints[thisIndex - 1] := [c[1], c[2]]
      }

      oppoIndex := totalCount - thisIndex + 1
      If (oppoIndex!=thisIndex && canDoSymmetry=1 && !endsConnected)
      {
         c := customShapePoints[oppoIndex]
         If (oppoIndex + 1 <= totalCount)
            customShapePoints[oppoIndex + 1] := [c[1], c[2]]

         If (oppoIndex - 1>=1)
            customShapePoints[oppoIndex - 1] := [c[1], c[2]]
      }
   }

   vpWinClientSize(mainWidth, mainHeight)
   drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", thisIndex)
   SetTimer, dummyRefreshImgSelectionWindow, -50
}

rescaleSelectedVectorPoints(shiftState) {
   ttlz := customShapePoints.Count()
   If (ttlz<4 && bezierSplineCustomShape=1 || ttlz<2)
      Return

   handleOpenCloseBezier("kill")
   thisState := prevState := 0
   GetMouseCoord2wind(PVhwnd, omX, omY)
   newArrayu := customShapePoints.Clone()
   setWhileLoopExec(1)
   minX := minY := 8823893348934389
   maxX := maxY := -8823893348934389
   lockedAR := 1
   If shiftState
      lockedAR := 0

   PP := 0
   startOperation := A_TickCount
   ToolTip, Please wait A... rescale selected points , , , 2
   Loop, % ttlz
   {
      c := newArrayu[A_Index]
      If (c[1]="" || c[2]="" || customShapePropPoints[A_Index, 1]!=1)
         Continue

      pp++
      minX := min(minX, c[1])
      minY := min(minY, c[2])
      maxX := max(maxX, c[1])
      maxY := max(maxY, c[2])
   }
 
   If !pp
   {
      ToolTip, , , , 2
      Return
   }

   avgX := (minX + maxX)/2
   avgY := (minY + maxY)/2
   ominX := minX,  ominY := minY
   minX := minY := 8823893348934389
   maxX := maxY := -8823893348934389
   ToolTip, Please wait B... rescale selected points , , , 2
   Loop, % ttlz
   {
      c := newArrayu[A_Index]
      If (c[1]="" || c[2]="" || customShapePropPoints[A_Index, 1]!=1)
         Continue

      xu := c[1] - (avgX + ominX)
      yu := c[2] - (avgY + ominY)
      newArrayu[A_Index] := [xu, yu]
      minX := min(minX, xu)
      minY := min(minY, yu)
      maxX := max(maxX, xu)
      maxY := max(maxY, yu)
   }

   avgX := (minX + maxX)/2
   avgY := (minY + maxY)/2
   hasLooped := 0
   ToolTip, , , , 2
   canDoSymmetry := isNowSymmetricVectorShape()
   symPoint := canDoSymmetry ? ( customShapePoints.Count() ) // 2 + 1 : -1
   While, (determineLClickState()=1)
   {
      If (A_TickCount - startOperation<125)
         Continue

      If (A_TickCount - startOperation<1025)
      {
         If GetKeyState("Shift", "P")
            lockedAR := 0
      }

      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      gmX := omX/mX
      gmY := omY/mY
      hasLooped := 1
      If (lockedAR=1)
         gmX := gmY := max(gmX, gmY)

      thisState := "a" gmX "=" gmY
      If (thisState!=prevState)
      {
         prevState := thisState
         Loop, % customShapePoints.Count()
         {
            If (pp[A_Index]=1 || symPoint=A_Index)
               Continue

            c := newArrayu[A_Index]
            selu := customShapePropPoints[A_Index, 1]
            If (c[1]="" || c[2]="" || selu!=1)
               Continue

            diffX := avgX * gmX + minX
            diffY := avgY * gmY + minY
            xu := c[1] * gmX - diffX
            yu := c[2] * gmY - diffY
            customShapePoints[A_Index] := [xu, yu]
            If canDoSymmetry
            {
               oppoIndex := ttlz - A_Index + 1
               If (oppoIndex && oppoIndex!=A_Index && pp[A_Index]!=1)
               {
                  getVPcoordsVectorPoint(A_Index, fzX, fzY)
                  calculateSymmetricVectorPoint(fzX, fzY, nX, nY)
                  getVectorCoordsFromVPpoint(nX, nY, nX, nY)
                  customShapePoints[oppoIndex] := [nX, nY]
                  pp[oppoIndex] := 1
               }
            }

         }
         lastZeitFileSelect := A_TickCount
         showTOOLtip("Scale selected points:`nX=" Round(gmX, 3) ", Y=" Round(gmY, 3))
         dummyRefreshImgSelectionWindow()
      }
      Sleep, 5
   }

   If canDoSymmetry
      coreSetVPsymmetryPoint(symPoint)

   setWhileLoopExec(0)
   RemoveTooltip()
   newArrayu := []
   Return hasLooped
}

moveOnePointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY, altState) {
   soX := soY := doX := doY := poX := poY := hasLooped := mustRem := 0
   vpWinClientSize(mainWidth, mainHeight)
   If (k=1 || bezierSplineCustomShape!=1) ; reference point for snapping at angles
      getVPcoordsVectorPoint(thisIndex, refX, refY)
   Else If (k=2)
      getVPcoordsVectorPoint(thisIndex - 1, refX, refY)
   Else
      getVPcoordsVectorPoint(thisIndex + 1, refX, refY)

   If (thisIndex<4 || thisIndex>(customShapePoints.Count() - 3))
      handleOpenCloseBezier("kill")

   setWhileLoopExec(1)
   startOperation := A_TickCount
   symPoint := ( customShapePoints.Count() ) // 2 + 1
   getAssociatedBezierPoints(k, totalCount, thisIndex, Az, Bz)
   canDoSymmetry := isNowSymmetricVectorShape()
   thisReflctAnchr := ((symPoint=Az || symPoint=Bz) && canDoSymmetry) ? 0 : autoReflectVectorAnchors
   ; ToolTip, % thisReflctAnchr "|" prevVectorShapeSymmetryMode[1,1] "|" symPoint , , , 2
   While, (determineLClickState()=1 || altState="forced" && A_Index<3)
   {
        If (A_TickCount - startOperation<250 && altState!="forced")
           Continue

        If (hasLooped=0)
        {
           hasLooped := 1
           If (k=1 && thisReflctAnchr=1 && bezierSplineCustomShape=1)
              endsConnected := areEndsConnectedBezierPath(thisIndex, totalCount, 1)

           getVPcoordsVectorPoint(thisIndex, soX, soY)
           If (endsConnected=1)
           {
              getVPcoordsVectorPoint(2, poX, poY)
              getVPcoordsVectorPoint(totalCount - 1, doX, doY)
           } Else
           {
              getVPcoordsVectorPoint(thisIndex + 1, poX, poY)
              getVPcoordsVectorPoint(thisIndex - 1, doX, doY)
           }

           If (bezierSplineCustomShape=1)
              auxiliaryPoints := getPointsSameCoordsVectorPath(totalCount, k, thisIndex, gmX, gmY)
        }

        zeitSillyPrevent := A_TickCount
        If (altState!="forced")
        {
           GetMouseCoord2wind(PVhwnd, mX, mY)
           gmX := (FlipImgH=1) ? mainWidth - mX : mX
           gmY := (FlipImgV=1) ? mainHeight - mY : mY
           If GetKeyState("Shift", "P")
           {
              snapPointsAtAngles(gmX, gmY, refX, refY, gmX, gmY)
              gmX := Round(gmX),  gmY := Round(gmY)
           }
        }

        diffX := gmX - soX, diffY := gmY - soY
        If (k=1 && thisReflctAnchr=1 && bezierSplineCustomShape=1)
        {
           ; drag anchors as well 
           getVectorCoordsFromVPpoint(poX + diffX, poY + diffY, pzX, pzY)
           getVectorCoordsFromVPpoint(doX + diffX, doY + diffY, dzX, dzY)
           If (endsConnected=1)
           {
              customShapePoints[2] := [pzX, pzY]
              customShapePoints[totalCount - 1] := [dzX, dzY]
           } Else
           {
              If (thisIndex + 1 <= totalCount)
                 customShapePoints[thisIndex + 1] := [pzX, pzY]

              If (thisIndex - 1 >= 1)
                 customShapePoints[thisIndex - 1] := [dzX, dzY]

              thisu := (thisIndex + 1 <= totalCount) ? thisIndex + 1 : thisIndex - 1
              tK := (thisIndex + 1 <= totalCount) ? 2 : 3
              If ((thisu<totalCount || thisu>1) && canDoSymmetry
              && thisu!=2 && thisu!=(totalCount - 1))
                 reflectGivenAnchorInPath(tK, totalCount, thisu, canDoSymmetry, 0, 0)
           }
        }

        mustRem := 1
        getVectorCoordsFromVPpoint(gmX, gmY, zgX, zgY)
        customShapePoints[thisIndex] := [zgX, zgY]
        If (bezierSplineCustomShape=1)
        {
           Loop, % auxiliaryPoints.Count()
               customShapePoints[auxiliaryPoints[A_Index, 1]] := [zgX, zgY]
        }

        If (oppoIndex!=thisIndex && canDoSymmetry=1 && altState=0)
        {
           calculateSymmetricVectorPoint(gmX, gmY, nzX, nzY)
           getVectorCoordsFromVPpoint(nzX, nzY, nX, nY)
           customShapePoints[oppoIndex] := [nX, nY]
           Loop, % auxiliaryPoints.Count()
               customShapePoints[auxiliaryPoints[A_Index, 2]] := [nX, nY]

           ; customShapePropPoints[oppoIndex] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]
           If (thisIndex=1)
           {
              getVPcoordsVectorPoint(2, pzX, pzY)
              calculateSymmetricVectorPoint(pzX, pzY, pzX, pzY)
              getVectorCoordsFromVPpoint(pzX, pzY, pzX, pzY)
              customShapePoints[totalCount - 1] := [pzX, pzY]
           } Else If (thisIndex=totalCount)
           {
              getVPcoordsVectorPoint(totalCount - 1, pzX, pzY)
              calculateSymmetricVectorPoint(pzX, pzY, pzX, pzY)
              getVectorCoordsFromVPpoint(pzX, pzY, pzX, pzY)
              customShapePoints[2] := [pzX, pzY]
           }
        }
        If (thisReflctAnchr=1 && k!=1 && bezierSplineCustomShape=1)
           reflectGivenAnchorInPath(k, totalCount, thisIndex, canDoSymmetry, 0, 0)

        thisState := "a" gmX gmY mX mY
        If (thisState!=prevState)
        {
           If (oppoIndex!=thisIndex && canDoSymmetry=1)
              otheru := ", " oppoIndex

           prevState := thisState
           fr := (k!=1 && bezierSplineCustomShape=1) ? "P'" : "P"
           showTOOLtip(fr "[" thisIndex otheru "] = (" gmX ", " gmY ")")
           drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", thisIndex)
           ; dummyRefreshImgSelectionWindow()
        }
        Sleep, 2
   }

   zpp := (isNowSymmetricVectorShape() && thisIndex=(totalCount//2 + 1)) ? 1 : 0
   If (!hasLooped && altState=1 && bezierSplineCustomShape=0 && !zpp)
   {
      mustRem := 1
      splitPointGivenInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY)
   } Else If (zpp=1)
      coreSetVPsymmetryPoint(thisIndex)

   MouseMove, 2, 0, 2, R
   MouseMove, -2, 0, 2, R
   setWhileLoopExec(0)
   SetTimer, dummyForcedRefreshImgSelectionWindow, -50
   Return mustRem
}

selectPathPointsInRect(gmX, gmY, shiftState, ctrlState) {
   nmX := nmY := tx := ty := mw := mh := hasLooped := 0
   vpWinClientSize(mainWidth, mainHeight)
   setWhileLoopExec(1)
   startOperation := A_TickCount
   hasLooped := 0
   ; ToolTip, % thisReflctAnchr "|" prevVectorShapeSymmetryMode[1,1] "|" symPoint , , , 2
   While, (determineLClickState()=1)
   {
        If (A_TickCount - startOperation<150)
           Continue

        hasLooped := 1
        zeitSillyPrevent := A_TickCount
        GetMouseCoord2wind(PVhwnd, mX, mY)
        nmX := (FlipImgH=1) ? mainWidth - mX : mX
        nmY := (FlipImgV=1) ? mainHeight - mY : mY
        thisState := "a" gmX gmY nmX nmY
        If (thisState!=prevState)
        {
           mw := abs(gmX - nmX), mh := abs(gmY - nmY)
           tx := min(gmX, nmX)
           ty := min(gmY, nmY)
           ; ToolTip, % mw "|" mh , , , 2
           prevState := thisState
           drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "sel-rect", [tX, tY, mw, mh])
           ; dummyRefreshImgSelectionWindow()
        }
        Sleep, 2
   }

   m := ctrlState ? 0 : 1
   If hasLooped
   {
      PointsListArray := drawLiveCreateCustomShape("getAllPoints", 0, 0)
      Loop, % customShapePoints.Count()
      {
           xu := PointsListArray[A_Index*2 - 1]
           yu := PointsListArray[A_Index*2]
           If isDotInRect(xu, yu, gmx, nmx, gmy, nmy)
              customShapePropPoints[A_Index, 1] := m
      }
      MouseMove, 2, 0, 2, R
      MouseMove, -2, 0, 2, R
   }

   setWhileLoopExec(0)
   drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", 1)
   SetTimer, dummyForcedRefreshImgSelectionWindow, -50
   Return hasLooped
}

removeGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, gmX, gmY) {
   If (thisIndex<4 || thisIndex>(customShapePoints.Count() - 3))
      handleOpenCloseBezier("kill")

   If (k!=1 && bezierSplineCustomShape=1)
   {
      collapseGivenAnchorInPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry)
      Return
   }

   listu := thisIndex "|"
   zpp := (isNowSymmetricVectorShape() && thisIndex=prevVectorShapeSymmetryMode[1, 1]) ? 1 : 0
   If (bezierSplineCustomShape=1 && k=1 && thisIndex=1)
   {
      a := 3, b := 2
      listu .= "2|3|"
   } Else If (bezierSplineCustomShape=1 && k=1 && thisIndex=totalCount)
   {
      a := totalCount - 1, b := totalCount - 2
      listu .= a "|" b "|"
   } Else If (bezierSplineCustomShape=1 && k=1)
   {
      ; identify associated points to be deleted - the anchors
      nextK := getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
      If a
         listu .= a "|"
      If b
         listu .= b "|"
      ; ToolTip, % "nextK=" nextK, , , 2
      nextKcoords := customShapePoints[nextK]
   }

   If (oppoIndex!=thisIndex && canDoSymmetry=1 && a!=thisIndex && b!=thisIndex && a!=oppoIndex && b!=oppoIndex)
   {
      listu .= oppoIndex "|"
      If (bezierSplineCustomShape=1)
      {
         za := totalCount - a + 1
         zb := totalCount - b + 1
         If za
            listu .= za "|"
         If zb
            listu .= zb "|"
      }
   }


   lista := Trim(listu, "|")
   Sort, lista, R U N D|
   ; ToolTip, % listu "`n" lista , , , 2
   ; ToolTip, % anchorPa "=" anchorPb "=" anchorPc , , , 2
   Loop, Parse, lista, |
   {
      If !A_LoopField
         Continue

      customShapePoints.RemoveAt(A_LoopField)
      customShapePropPoints.RemoveAt(A_LoopField)
      If (A_LoopField < prevVectorShapeSymmetryMode[1, 1])
         prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] - 1
   }

   If (bezierSplineCustomShape=1)
   {
      auxiliaryPoints := getPointsSameCoordsVectorPath(totalCount, k, thisIndex, gmX, gmY)
      Loop, % auxiliaryPoints.Count()
      {
         If auxiliaryPoints[A_Index, 1]
            customShapePoints[auxiliaryPoints[A_Index, 1]] := [nextKcoords[1], nextKcoords[2]]
      }
   }

   ; ToolTip, % "l=" CustomShapeLockedSymmetry "=" thisIndex "=" oppoIndex , , , 2
   If (oppoIndex!=thisIndex && canDoSymmetry=1)
   {
      Sleep, 0
   } Else If (CustomShapeLockedSymmetry && oppoIndex=-1)
   {
      prevVectorShapeSymmetryMode[1, 2] := 0
      CustomShapeLockedSymmetry := 0
   }
 
   If (zpp=1)
   {
      CustomShapeLockedSymmetry := CustomShapeSymmetry := vpSymmetryPointXdp := vpSymmetryPointYdp := 0
      prevVectorShapeSymmetryMode := []
   }
}

getPointsSameCoordsVectorPath(totalCount, k, givenIndex, gmX, gmY) {
   newArrayu := []
   getAssociatedBezierPoints(k, totalCount, givenIndex, A, B)
   If A
   {
      oppoIndex := totalCount - A + 1
      getVPcoordsVectorPoint(A, xu, yu)
      If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
         newArrayu.Push([A, oppoIndex])
   }

   If B
   {
      oppoIndex := totalCount - B + 1
      getVPcoordsVectorPoint(B, xu, yu)
      If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
         newArrayu.Push([B, oppoIndex])
   }

   If ((givenIndex<3 || givenIndex>totalCount - 3) && bezierSplineCustomShape=1 && testIsEditorBezierPathClosed(1)=1)
   {
      If (givenIndex<3)
      {
         A := totalCount, B := totalCount - 1
         If A
         {
            oppoIndex := totalCount - A + 1
            getVPcoordsVectorPoint(A, xu, yu)
            If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
               newArrayu.Push([A, oppoIndex])
         }

         If B
         {
            oppoIndex := totalCount - B + 1
            getVPcoordsVectorPoint(B, xu, yu)
            If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
               newArrayu.Push([B, oppoIndex])
         }
      } Else
      {
         A := 1,          B := 2
         If A
         {
            oppoIndex := totalCount - A + 1
            getVPcoordsVectorPoint(A, xu, yu)
            If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
               newArrayu.Push([A, oppoIndex])
         }

         If B
         {
            oppoIndex := totalCount - B + 1
            getVPcoordsVectorPoint(B, xu, yu)
            If isDotInRect(gmX, gmY, SelDotsSize, SelDotsSize, xu, yu, 1)
               newArrayu.Push([B, oppoIndex])
         }
      }
   }
   Return newArrayu
}

moveSelectedPointsInVectorPath(gmX, gmY, altState) {
   ttlz := customShapePoints.Count()
   If (ttlz<4 && bezierSplineCustomShape=1 || ttlz<2)
      Return

   handleOpenCloseBezier("kill")
   thisState := prevState := 0
   GetMouseCoord2wind(PVhwnd, omX, omY)
   newArrayu := customShapePoints.Clone()
   setWhileLoopExec(1)
   startOperation := A_TickCount
   listPoints := []
   showTOOLtip("Move selected points:`n---, ---")
   pp := new hashtable()
   canDoSymmetry := altState ? 0 : isNowSymmetricVectorShape()
   symPoint := canDoSymmetry ? ( customShapePoints.Count() ) // 2 + 1 : -1
   Loop, % ttlz
   {
      c := newArrayu[A_Index]
      If (c[1]="" || c[2]="" || customShapePropPoints[A_Index, 1]!=1)
         Continue

      If (pp[A_Index]!=1 && A_Index!=symPoint)
         listPoints[A_Index] := 1

      If canDoSymmetry
      {
         oppoIndex := ttlz - A_Index + 1
         If (oppoIndex && pp[A_Index]!=1)
            pp[oppoIndex] := 1
      }
   }

   pp := ""
   vpImgPanningNow := 1
   startOperation := A_TickCount
   zx := (FlipImgV=1) ? -1 : 1
   zy := (FlipImgH=1) ? -1 : 1
   While, (determineLClickState()=1)
   {
      If (A_TickCount - startOperation<150)
         Continue

      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      gmX := omX - mX
      gmY := omY - mY
      thisState := "a" gmX "=" gmY
      If (thisState!=prevState)
      {
         prevState := thisState
         For Key, Value in listPoints
         {
            c := newArrayu[Key]
            If (c[1]="" || c[2]="" || customShapePropPoints[Key, 1]!=1)
               Continue

            customShapePoints[Key] := [c[1] - gmX/prevResizedVPimgW * zx, c[2] - gmY/prevResizedVPimgH * zy]
            If canDoSymmetry
            {
               oppoIndex := ttlz - Key + 1
               If (oppoIndex && oppoIndex!=key)
               {
                  getVPcoordsVectorPoint(Key, gX, gY)
                  calculateSymmetricVectorPoint(gX, gY, nX, nY)
                  getVectorCoordsFromVPpoint(nX, nY, nX, nY)
                  customShapePoints[oppoIndex] := [nX, nY]
               }
            }
         }

         showTOOLtip("Move selected points:`nX=" -1*gmX ", Y=" -1*gmY)
         lastZeitFileSelect := A_TickCount
         dummyRefreshImgSelectionWindow()
      }
      Sleep, 2
   }

   vpImgPanningNow := 0
   If isNowSymmetricVectorShape()
      coreSetVPsymmetryPoint(symPoint)

   setWhileLoopExec(0)
   RemoveTooltip()
   newArrayu := []
}

selectGivenPointInVectorPath(k, totalCount, thisIndex, oppoIndex, canDoSymmetry, mainParam, gmX, gmY) {
    Static lastAmount := 0, lastInvoked := 1, lastIndexu := -1
    actu := !customShapePropPoints[thisIndex, 1]
    listu := thisIndex "|"
    If (bezierSplineCustomShape=1 && (mainParam="selclickAnchors" || mainParam="DoubleClick"))
    {
       If (bezierSplineCustomShape=1)
          endsConnected := ((thisIndex<=2 || thisIndex>=(totalCount - 1)) && testIsEditorBezierPathClosed()=1) ? 1 : 0

       If (endsConnected=1)
          listu .= "1|2|" totalCount "|" totalCount - 1 "|"

       getAssociatedBezierPoints(k, totalCount, thisIndex, A, B)
       If a
          listu .= a "|"
       If b
          listu .= b "|"
    }

    ; ToolTip, % " k = " k , , , 2
    If (bezierSplineCustomShape=1) ; || mainParam="DoubleClick")
       auxiliaryPoints := getPointsSameCoordsVectorPath(totalCount, k, thisIndex, gmX, gmY)

    If (oppoIndex!=thisIndex && canDoSymmetry=1 && a!=thisIndex && b!=thisIndex && a!=oppoIndex && b!=oppoIndex)
    {
       listu .= oppoIndex "|"
       If (bezierSplineCustomShape=1)
       {
          za := totalCount - a + 1
          zb .= totalCount - b + 1
          If (a!=za && za!=zb && a)
             listu .= za "|"
          If (b!=zb && za!=zb && b)
             listu .= zb "|"
          Loop, % auxiliaryPoints.Count()
             listu .= auxiliaryPoints[A_Index, 2] "|"
       }
    }

    Loop, % auxiliaryPoints.Count()
       listu .= auxiliaryPoints[A_Index, 1] "|"

   lista := Trim(listu, "|")
   ; ToolTip, % lista , , , 2
   newArrayu := StrSplit(lista, "|")
   If (bezierSplineCustomShape=1 && (mainParam="selclickAnchors" || mainParam="DoubleClick"))
   {
      If (newArrayu[2]!=thisIndex && newArrayu[2])
         actu := !customShapePropPoints[newArrayu[2], 1]
      Else If (newArrayu[3]!=thisIndex && newArrayu[3])
         actu := !customShapePropPoints[newArrayu[3], 1]
   }

   If (lastAmount!=newArrayu.Count() && mainParam="DoubleClick")
      actu := (lastIndexu=thisIndex && (A_TickCount - lastInvoked<550)) ? 0 : 1

   Loop, % newArrayu.Count()
   {
      If !newArrayu[A_Index]
         Continue

      customShapePropPoints[newArrayu[A_Index], 1] := actu
   }

   lastAmount := newArrayu.Count()
   If (newArrayu.Count()>2)
   {
      fr := actu ? "" : "de"
      showTOOLtip(newArrayu.Count() " points were now " fr "selected")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
 
   dummyForcedRefreshImgSelectionWindow()
   If (mainParam="DoubleClick" && actu=1)
   {
      lastInvoked := A_TickCount
      lastIndexu := thisIndex
   }
}

getAssociatedBezierPoints(k, totalCount, thisIndex, ByRef A, ByRef B) {
    If (k=1)
    {
       If (thisIndex<totalCount)
          a := thisIndex + 1
       If (thisIndex>1)
          b := thisIndex - 1
       Return thisIndex + 3
    } Else If (k=2)
    {
       a := thisIndex - 1
       If (thisIndex - 2>1)
          b := thisIndex - 2
       Return thisIndex + 2
    } Else If (k=3)
    {
       a := thisIndex + 1
       If (thisIndex + 2<totalCount)
          b := thisIndex + 2
       Return thisIndex + 1
    }
}

calculateSymmetricVectorPoint(gmX, gmY, ByRef mX, ByRef mY) {
   hasSymmetry := 0
   If (CustomShapeSymmetry=1 && vpSymmetryPointXdp)
   {
       vpSymX := vpSymmetryPointXdp
       gmXa := (gmX<vpSymX) ? vpSymX*2 - gmX : vpSymX - (gmX - vpSymX)
       mX := gmXa
       mY := gmY
       hasSymmetry := 1
   } Else If (CustomShapeSymmetry=2 && vpSymmetryPointYdp)
   {
       vpSymY := vpSymmetryPointYdp
       gmYa := vpSymY - (gmY - vpSymY)
       mX := gmX
       mY := gmYa
       hasSymmetry := 1
   }

   ; fnOutputDebug(A_ThisFunc "(): " gmX "=" gmY " | " mX "=" mY " | " vpSymX "=" vpSymY)
   Return hasSymmetry
}

isNowSymmetricVectorShape() {
   hasSymmetry := 0
   If (CustomShapeSymmetry=1 && vpSymmetryPointXdp)
      hasSymmetry := 1
   Else If (CustomShapeSymmetry=2 && vpSymmetryPointYdp)
      hasSymmetry := 1

   Return hasSymmetry
}

thumbsListClickResponder(mX, mY, mainWidth, mainHeight, mainParam, ctrlState, shiftState, altState) {
   Static lastInvoked := 1, doNotAskAgain := 0
   If (A_TickCount - lastInvoked<50)
      Return "none"

   lastInvoked := A_TickCount
   knobSize := getScrollWidth()
   scrollXpos := mainWidth - knobSize
   statusBarYpos := Round(mainHeight - ThumbsStatusBarH)
   If (mX>scrollXpos)
   {
      pt := A_TickCount
      If (mY<knobSize*1.5)
      {
         While, determineLClickState()
         {
            kz := (A_TickCount - pt > 2500) ? 1 : 0
            ThumbsNavigator("Upu", "Up")
            UpdateThumbsScreen(0, kz)
            Sleep, % (kz=1) ? 50 : 150
            If (A_Index>500)
               Break
         }
      } Else If (mY>mainHeight - knobSize*1.5)
      {
         While, determineLClickState()
         {
            kz := (A_TickCount - pt > 2500) ? 1 : 0
            ThumbsNavigator("Down", "Down")
            UpdateThumbsScreen(0, kz)
            Sleep, % (kz=1) ? 50 : 150
            If (A_Index>500)
               Break
         }
      } Else If (markedSelectFile>1 && maxFilesIndex>4 && altState=1 && mainParam="normal")
      {
         mYperc := ((mY - 15)/mainHeight)*100
         newIndex := clampInRange(Ceil((maxFilesIndex/100)*mYperc), 1, maxFilesIndex)
         currentFileIndex := newIndex
         regroupSelectedFiles()
         Return "none"
      } Else If (mainParam!="rclick")
         SetTimer, ThumbsScrollbar, -25
      Return "scrollbar"
   } Else If (mY>statusBarYpos)
   {
      If (markedSelectFile>1 && maxFilesIndex>4 && altState=1 && mainParam="normal")
         filterToFilesSelection()
      Else If (mainParam="rclick")
         Return "statusBar"
      Else If !InStr(mainParam, "pen-")
         ToggleMultiLineStatus()
      Return
   }

   If InStr(mainParam, "pen-")
      Return

   oIndex := currentFileIndex
   thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
   rowIndex := 0, columnIndex := -1
   Loop, % maxItemsPage*2
   {
      columnIndex++
      If (columnIndex>=maxItemsW)
      {
         rowIndex++
         columnIndex := 0
      }
      DestPosX := thumbsW*columnIndex + thumbsW
      DestPosY := thumbsH*rowIndex + thumbsH
      If (DestPosX>mX && DestPosY>mY)
      {
         newIndex := startIndex + A_Index - 1
         Break
      }
   }

   If newIndex
   {
      If (mainParam="rClick")
      {
         ; currentFileIndex := newIndex
         ; mainGdipWinThumbsGrid()
         If (newIndex=oIndex)
            Return "FsoloMenu"
         Else
            Return
      }

      startClick := A_TickCount
      longTapDelay := markedSelectFile ? 350 : 750
      newIndex := clampInRange(newIndex, 1, maxFilesIndex)
      If (ctrlState=1)
      {
         markThisFileNow(newIndex)
      } Else If (altState=1 && (omniBoxMode=1 && VisibleQuickMenuSearchWin=1 || folderTreeWinOpen=1))
      {
         If (omniBoxMode=1 && VisibleQuickMenuSearchWin=1)
         {
            Gui, QuickMenuSearchGUIA: Default
            GuiControlGet, userQuickMenusEdit
            edithu := Trimmer(userQuickMenusEdit)
            edithu := Trimmer(StrReplace(edithu, "\\", "\"), "\")
         }

         func2exec := r := info := ""
         prevMSGdisplay := 1
         currentFileIndex := newIndex
         UpdateThumbsScreen()
         While, determineLClickState()
         {
            ; drag and drop
            If (GetKeyState("Escape", "P"))
            {
               func2exec := r := info := ""
               Global lastOtherWinClose := A_TickCount
               interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
               Break
            }

            info := defineWindowUnderMouse()
            If InStr(info, "tooltip")
            {
               showOSDinfoLineNow(500)
               Continue
            } Else If (InStr(info, "main") && markedSelectFile>1)
            {
               GetMouseCoord2wind(PVhwnd, nX, nY)
               If (nY > statusBarYpos)
                  friendly := "`nFilter the files list to selected items"
               Else If (nX > scrollXpos - 50)
                  friendly := "`nRegroup selected files at this scrollbar location"
               Else
                  friendly := "`nNo action associated to this pointer location"
            
               nc := nY
               thisFolder := r := dc := ""
               r := friendly
            } Else If InStr(info, "tree")
            {
               thisFolder := r := dc := nc := ""
               LV_Modify(initialRow, "select")
               friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
               GetMouseCoord2wind(hTVlistFolders, nX, nY)
               nc := TVH_HitTest(hTVlistFolders, cr, nX, nY)
               If nc
               {
                  Gui, fdTreeGuia: Default
                  Gui, fdTreeGuia: TreeView, TVlistFolders
                  TV_GetText(thisFolder, nc)
                  TV_Modify(nc)
               }
               friendly .= "`nDestination: ." thisFolder "\"
               r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
               friendly .= A_Space r
            } Else If InStr(info, "omnibox list")
            {
               thisFolder := r := dc := nc := ""
               GetMouseCoord2wind(hLVquickSearchMenus, nX, nY)
               dc := LV_EX_ItemHitTest(hLVquickSearchMenus, kp, nX, nY)
               thisFolder := OmniBoxGetSelectedFolder(dc, "yes", edithu)
               LV_Modify(dc, "select")
               restu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
               friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
               r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
               friendly2 := "`nDestination: ." restu "\ " r
               friendly .= thisFolder ? friendly2 : "`nNo folder is currently underneath."
               ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
            } Else 
            {
               func2exec := r := dc := nc := ""
               friendly := "`nNo action associated to this pointer location"
            }

            If (A_TickCount - prevMSGdisplay>100)
            {
               externToolTiput(info friendly)
               prevMSGdisplay := A_TickCount
            }
         } ; while end

         If (InStr(info, "main") && r)
         {
            If InStr(r, "filter")
            {
               func2exec := "filterToFilesSelection"
            } Else If InStr(r, "regroup")
            {
               mYperc := ((nc - 15)/mainHeight)*100
               newIndex := clampInRange(Ceil((maxFilesIndex/100)*mYperc), 1, maxFilesIndex)
               currentFileIndex := newIndex
               func2exec := "regroupSelectedFiles"
            }
         } Else If (InStr(info, "omnibox") && dc && thisFolder)
         {
            externTooltiput("-hide-")
            dest := OmniBoxGetSelectedFolder(dc, "yes", edithu)
            rDest := SubStr(dest, InStr(dest, "\", 0, -1) + 1)
            If (doNotAskAgain=0 && InStr(dest, ":\") && r)
            {
               msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action from the main window into the omnibox: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: selected files`nDestination: .\" rDest "\", "&Yes|&No", 2, "question", "Do not ask again in this application session")
               If !InStr(msgResult.btn, "Yes")
               {
                  SetTimer, PopulateQuickMenuSearch, -200
                  Return 1
               } Else doNotaskAgain := msgResult.check
            }

            If (InStr(r, "_") && InStr(dest, ":\"))
            {
               externTooltiput("Please wait - performing action")
               If InStr(r, "copy")
                  func2exec := "omniBoxFolderCopyFiles"
               Else If InStr(r, "move")
                  func2exec := "omniBoxFolderMoveFiles"
            }
            externTooltiput("-hide-")
         } Else If (InStr(info, "tree") && r && nc)
         {
            externTooltiput("-hide-")
            dest := folderTreeGetSelectedPath(nc)
            If (doNotAskAgain=0 && InStr(dest, ":\") && r)
            {
               msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action from the main window into the folders tree panel: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: selected files`nDestination: ." dest "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
               If !InStr(msgResult.btn, "Yes")
               {
                  SetTimer, folderTreeInfoStatusLineUpdater, -125
                  Return 1
               } Else doNotaskAgain := msgResult.check
            }

            externTooltiput("Please wait - performing folder action")
            If (InStr(r, "_") && InStr(dest, ":\"))
            {
               If InStr(r, "copy")
                  func2exec := "FolderTreeMenuCopyFiles"
               Else If InStr(r, "move")
                  func2exec := "FolderTreeMenuMoveFiles"
            }
         }

         externTooltiput("-hide-")
         If func2exec
            SetTimer, % func2exec, -500
      } Else If (altState=1)
      {
         moveMarkedEntryNow(newIndex)
      } Else If (shiftState=1)
      {
         clickAct := "S"
      } Else
      {
         While, (determineLClickState()=1 && (A_TickCount - startClick<longTapDelay+150))
         {
            Sleep, 1
         }

         If (A_TickCount - startClick<longTapDelay) && (newIndex=currentFileIndex)
         {
            ToggleThumbsMode()
            Return
         } Else If (A_TickCount - startClick>longTapDelay)
            markThisFileNow(newIndex)
      }

      If (clickAct="S")
      {
         keyu := (newIndex>currentFileIndex) ? "Down" : "Upu"
         prevFileIndex := currentFileIndex
         currentFileIndex := newIndex
         thumbsSelector(keyu, "+Shift", prevFileIndex)
      } Else currentFileIndex := newIndex

      dummyTimerDelayiedImageDisplay(25)
   }

   lastInvoked := A_TickCount
}

isFreeHandModus(dotu) {
   linez := (AnyWindowOpen=30 && (DrawLineAreaBorderCenter<4 || DrawLineAreaBorderCenter=7)) ? 1 : 0
   r := (dotu!=1 && dotu!=2 && dotu!=10 && freeHandSelectionMode=1 && imgEditPanelOpened=1 && (isVarEqualTo(AnyWindowOpen, 23, 65, 68) || linez=1)) ? 1 : 0
   Return r
}

endFreeHandModus(rImgW, rImgH) {
; unused; meant to track where the click-down ended
   MouseGetPos, mX, mY
   MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
   freeHandPoints[3] := kX,       freeHandPoints[4] := kY
   imgSelX1 := freeHandPoints[1], imgSelY1 := freeHandPoints[2]
   imgSelX2 := freeHandPoints[3], imgSelY2 := freeHandPoints[4]
   nImgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := min(imgSelY1, imgSelY2)
   nImgSelX2 := max(imgSelX1, imgSelX2)
   nImgSelY2 := max(imgSelY1, imgSelY2)
   ImgSelX1 := nImgSelX1,    ImgSelY1 := nImgSelY1
   ImgSelX2 := nImgSelX2,    ImgSelY2 := nImgSelY2
   defineRelativeSelCoords(rImgW, rImgH)
}

defineFreeHandFrame(mX, mY, mXo, mYo) {
   Static cadruH := {1:2,2:1,3:4,4:3}
        , cadruV := {1:3,2:4,3:1,4:2}

   If (mX="flip")
   {
      cadru := mYo
      If (mY=1)
         cadru := cadruH[cadru]
      If (mXo=1)
         cadru := cadruV[cadru]

      Return cadru
   }

   If (mX<mXo && mY<mYo)
      cadru := 1
   Else If (mX>=mXo && mY<mYo)
      cadru := 2
   Else If (mX<mXo && mY>=mYo)
      cadru := 3
   Else If (mX>=mXo && mY>=mYo)
      cadru := 4

   Return cadru
}

initFreeHandClickResponse(mX, mY, imgW, imgH, mainWidth, mainHeight) {
   amX := (FlipImgH=1) ? mainWidth - mX : mX
   amY := (FlipImgV=1) ? mainHeight - mY : mY
   MouseCoords2Image(amX, amY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
   freeHandPoints := [kX, kY, kX, kY]
   imgSelX1 := kX, imgSelY1 := kY
   imgSelX2 := kX + 1, imgSelY2 := kY + 1
   defineRelativeSelCoords(imgW, imgH)
   ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, imgW, imgH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   dotActiveObj := determineSelAreaClickRect(mX, mY, SelDotsSize*2, mainWidth, mainHeight, 1)
   Return dotActiveObj
}

scaleVector(x1, y1, x2, y2, scaleFactor) {
    vx := x2 - x1
    vy := y2 - y1
    scaled_vx := scaleFactor * vx
    scaled_vy := scaleFactor * vy
    new_x := x1 + scaled_vx
    new_y := y1 + scaled_vy
    return [new_x, new_y]
}

UIcalculateNewAngleOnMouseCoords(mXo, mYo, mX, mY, startValue, snap) {
    newRotation := MouseDeltaAngle360(mXo, mYo, mX, mY)
    If (newRotation<0)
       newRotation += 360

    newValue := startValue + newRotation
    If (newValue>360)
       newValue -= 360

    newValue := snapToValues(newValue, 90, 180, snap, 0)
    newValue := snapToValues(newValue, 270, 360, snap, 0)
    newValue := snapToValues(newValue, 0, 360, snap, 0)
    newValue := clampInRange(newValue, 0, 360)
    If (newValue>=360)
       newValue := 0
    ; ToolTip, % weight " | " newRotation " -- " startValue " |" newValue  , , , 2
    Return newValue
}

WinClickAction(winEventu:=0, thisCtrlClicked:=0, mX:=0, mY:=0) {
   Critical, on
   Static thisZeit := 1, anotherZeit := 1, lastInvoked := 1, lastInvokedSwipe := 1
   If (isToolbarKBDnav=1)
   {
      deactivateTlbrKbdMode()
      Return
   }

   lastLclickX := mX,  lastLclickY := mY
   If (VisibleQuickMenuSearchWin=1 && omniBoxMode=0)
   {
      lastTimeToggleThumbs := A_TickCount 
      closeQuickSearch()
      Return "none"
   }

   displayingImageNow := (thumbsDisplaying!=1 && useGdiBitmap()) ? 1 : 0
   If isVarEqualTo(AnyWindowOpen, 1, 33, 39, 59, 48, 61)
   {
      If ((prevOpenedWindow[1, 1]=-1) || (A_TickCount - lastZeitOpenWin<400))
         Return

      ; auto-close windows
      lastTimeToggleThumbs := A_TickCount 
      BtnCloseWindow()
      Return
   } Else If ((InStr(winEventu, "normal") || InStr(winEventu, "DoubleClick")) && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && displayingImageNow=1 && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1) && thumbsDisplaying!=1)
   {
      ; handle clicks on the H/V scrollbars for images larger than the viewport
      knobSize := getScrollWidth()
      vpWinClientSize(mainWidth, mainHeight)
      If (scrollBarHy>1 && mY>(mainHeight - knobSize))
      {
         RemoveTooltip()
         fn := Func("panIMGonScrollBar").Bind(1,0)
         SetTimer, % fn, -25
         Return
      } Else If (scrollBarVx>1 && mX>(mainWidth - knobSize))
      {
         RemoveTooltip()
         fn := Func("panIMGonScrollBar").Bind(0,1)
         SetTimer, % fn, -25
         Return
      }
   }
 
   If (IsFunc(hudBTNfuncu) && hudBTNfuncu && hudBTNheightFuncu && mY<hudBTNheightFuncu && mX<hudBTNwidthFuncu && hudBTNtypeFuncu=1)
   {
      lastTimeToggleThumbs := A_TickCount 
      hudBTNtypeFuncu := 0
      %hudBTNfuncu%()
      Return
   } Else If (AnyWindowOpen=64 && liveDrawingBrushTool=1`&& mustCaptureCloneBrush=1)
   {
      If StrLen(BrushToolSymmetryX)>1
      {
         setNewBrushSymmetryPoints()
      } Else
      {
         tinyPrevAreaCoordX := tinyPrevAreaCoordY := "C"
         createClonedBrushBitmap(mX, mY, 0, 0, 0)
      }
      lastTimeToggleThumbs := A_TickCount 
      Return
   } Else If (AnyWindowOpen=23 && FillAreaColorMode=6 && mustCaptureCloneBrush=1 || AnyWindowOpen=81 && GetKeyState("Ctrl", "P") && hUserSymmetricaCenteringMode=0)
   {
      vpWinClientSize(mainWidth, mainHeight)
      setWhileLoopExec(1)
      While, (determineLClickState()=1)
      {
         GetMouseCoord2wind(PVhwnd, mX, mY)
         mX := (FlipImgH=1) ? mainWidth - mX : mX
         mY := (FlipImgV=1) ? mainHeight - mY : mY
         MouseCoords2Image(mX, mY, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
         tinyPrevAreaCoordX := kX, tinyPrevAreaCoordY := kY
         showTOOLtip("Texture source set to`n" kX " / " kY)
         If (A_TickCount - thisZeit>90)
         {
            dummyRefreshImgSelectionWindow()
            thisZeit := A_TickCount
         }
      }

      setWhileLoopExec(0)
      endCaptureCloneBrush()

      SoundBeep , 900, 100
      dummyRefreshImgSelectionWindow()
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      If (AnyWindowOpen=81)
         SetTimer, updateUIsymmetricaPanel, -150
      Else If (panelWinCollapsed=1)
         toggleImgEditPanelWindow()
      lastTimeToggleThumbs := A_TickCount 
      Return
   } Else If (AnyWindowOpen=81 && UserSymmetricaCenteringMode=1)
   {
      vpWinClientSize(mainWidth, mainHeight)
      dotActiveObj := determineSelAreaClickRect(mX, mY, SelDotsSize, mainWidth, mainHeight, 1)
      If (dotActiveObj.n=0 || dotActiveObj.n=9)
      {
         RemoveTooltip()
         setWhileLoopExec(1)
         While, (determineLClickState()=1)
         {
            GetMouseCoord2wind(PVhwnd, mX, mY)
            mX := (FlipImgH=1) ? mainWidth - mX : mX
            mY := (FlipImgV=1) ? mainHeight - mY : mY
            MouseCoords2Image(mX, mY, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
            tinyPrevAreaCoordX := kX, tinyPrevAreaCoordY := kY
            If (A_TickCount - thisZeit>90)
            {
               dummyRefreshImgSelectionWindow()
               thisZeit := A_TickCount
            }
         }
         showTOOLtip("Symmetry point set to`n" kX " / " kY)
         setWhileLoopExec(0)
         dummyRefreshImgSelectionWindow()
         SetTimer, RemoveTooltip, % -msgDisplayTime//2
         Return
      }
   } Else If isVarEqualTo(AnyWindowOpen, 69, 43, 44, 26, 78, 79)
   {
      ; respond to clicks in viewport for panels with region based previews
      setWhileLoopExec(1)
      While, (determineLClickState()=1)
      {
         updateTinyPreviewArea(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, 1)
         dummyRefreshImgSelectionWindow()
      }
      setWhileLoopExec(0)
      lastTimeToggleThumbs := A_TickCount 
      Return
   }

   ; ToolTip, % winEventu " -- " thisCtrlClicked,,,2
   If (A_TickCount - lastLongOperationAbort < 550) || (A_TickCount - lastTimeToggleThumbs < 450) || (A_TickCount - executingCanceableOperation < 550)
   || (A_TickCount - lastWinDrag < 250) 
      Return "none"

   If (imgEditPanelOpened!=1 && AnyWindowOpen)
   {
      ; handle clicks in the viewport when a panel unrelated to image editing  is open
      SoundPlay, *-1
      WinActivate, ahk_id %hSetWinGui%
      Return
   }

   If (imageLoading=1 && thumbsDisplaying=1)
      Return "none"

   If (toolTipGuiCreated=1)
      RemoveTooltip()

   ;  ToolTip, % HUDobjHistoBoxu[3] "==" HUDobjHistoBoxu[1] "==" mX "`n" HUDobjHistoBoxu[4] "==" HUDobjHistoBoxu[2] "==" mY , , , 2
   If (showHUDnavIMG=1 && hasDrawnImageMap=1 && InStr(thisCtrlClicked, "|ImgNavBox|"))
   {
      If (winEventu="DoubleClick")
      {
         ToggleImgNavSizeBox()
         Return
      } Else If (thumbsDisplaying!=1 && IMGlargerViewPort=1)
      {
         SetTimer, ImageNavBoxClickResponder, -25
         Return
      }
   } Else If (showHistogram>1 && hasDrawnHistoMap=1 && thumbsDisplaying!=1 && InStr(thisCtrlClicked, "|ImgHistoBox|") && drawingShapeNow!=1 && !isDotInSelRect(mX, mY))
   {
      If (winEventu="DoubleClick")
      {
         invokeHistoMenu()
      } Else
      {
         If (showHistogram=6)
            showHistogram := 1

         ToggleImgHistogram(1)
      }
      Return
   } Else If (showImgAnnotations=1 && hasDrawnAnnoBox=1 && !AnyWindowOpen && InStr(thisCtrlClicked, "|ImgAnnoBox|") && !isDotInSelRect(mX, mY) && drawingShapeNow!=1)
   {
      If (winEventu="DoubleClick")
         ToggleImgCaptions()
      Else
         PanelEditImgCaption()
      Return
   }

   ctrlState := GetKeyState("Ctrl", "P") ? 1 : 0
   shiftState := GetKeyState("Shift", "P") ? 1 : 0
   altState := GetKeyState("Alt", "P") ? 1 : 0
   vpWinClientSize(mainWidth, mainHeight)
   If (winEventu="DoubleClick" && thumbsDisplaying!=1 && drawingShapeNow!=1 && editingSelectionNow=1 && adjustNowSel=0)
   {
      pmY := (FlipImgV=1) ? mainHeight - mY : mY
      pmX := (FlipImgH=1) ? mainWidth - mX : mX
      If (imgSelLargerViewPort=1 || (pku := isDotInSelRect(pmX, pmY)))
      {
         If (pku=1 && imgSelLargerViewPort!=1 && EllipseSelectMode=2 && (ctrlState=1 || shiftState=1))
            MenuResumeDrawingShapes()
         Else If (imgEditPanelOpened=1 && !liveDrawingBrushTool)
            BuildImgLiveEditMenu()
         Else If !liveDrawingBrushTool
            invokeSelectionAreaMenu("DoubleClick")
         Return
      }
   }

   If (thumbsDisplaying=1 && maxFilesIndex>0 && winEventu!="DoubleClick")
   {
      ; handle clicks on thumbnails and the vertical scrollbar
      ; ToolTip, % mX "," mY "|" mainWidth "," mainHeight , , , 2
      r := thumbsListClickResponder(mX, mY, mainWidth, mainHeight, winEventu, ctrlState, shiftState, altState)
      Return r
   }

   spaceState := GetKeyState("Space", "P") ? 1 : 0
   If (isAlphaMaskWindow()=1 && spaceState!=1 && imgEditPanelOpened=1 && liveDrawingBrushTool=1)
   {
      ; respond to clicks when drawing with the brush tools
      SetTimer, ActDrawAlphaMaskBrushNow, -5
      Return
   } Else If (AnyWindowOpen=64 && spaceState!=1 && imgEditPanelOpened=1 && liveDrawingBrushTool=1)
   {
      ; respond to clicks when drawing with the brush tools
      SetTimer, ActPaintBrushNow, -5
      Return
   } Else If (AnyWindowOpen=66 && spaceState!=1 && imgEditPanelOpened=1 && FloodFillSelectionAdj=0)
   {
      ActFloodFillNow()
      Return
   } Else If (drawingShapeNow=1 && spaceState!=1)
   {
      ; respond to clicks when drawing freeform polygonal shapes
      PerformVectorShapeActions(mX, mY, mainWidth, mainHeight, winEventu, ctrlState, shiftState, altState)
      Return
   }

   If ((editingSelectionNow!=1) || (imgSelOutViewPort=1 && editingSelectionNow=1) || (imgSelLargerViewPort=1 && editingSelectionNow=1))
   && (displayingImageNow=1 && getCaptionStyle(PVhwnd)!=1 && InStr(winEventu,"normal") && shiftState=1)
   {
      ; activate selection on single click + shift
      pmY := (FlipImgV=1) ? mainHeight - mY : mY
      pmX := (FlipImgH=1) ? mainWidth - mX : mX
      MouseCoords2Image(pmX - 200, pmY - 200, LimitSelectBoundsImg, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
      MouseCoords2Image(pmX + 200, pmY + 200, LimitSelectBoundsImg, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
      trGdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
      defineRelativeSelCoords(rImgW, rImgH)
      ToggleEditImgSelection("show-edit")
      dummyTimerDelayiedImageDisplay(50)
      Return
   }

   If (InStr(winEventu, "normal") && editingSelectionNow=1 && spaceState!=1 && displayingImageNow=1)
   {
      ; handle clicks on the image selection rectangle in the viewport
      yayFreeMode := 0
      dotsSize := SelDotsSize
      zL := (zoomLevel>1) ? zoomLevel : 1/zoomLevel
      If !IsObject(dotActiveObj)
         dotActiveObj := determineSelAreaClickRect(mX, mY, dotsSize, mainWidth, mainHeight, 1)

      trGdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
      If isFreeHandModus(dotActiveObj.n)
      {
         dotActiveObj := initFreeHandClickResponse(mX, mY, rImgW, rImgH, mainWidth, mainHeight)
         yayFreeMode := 1
      }

      DotPosX := dotActiveObj.x
      DotPosY := dotActiveObj.y
      dotActive := dotActiveObj.n
      If (dotActive=10)       ; click the center dot of the selection area
         anotherZeit := A_TickCount

      If (dotActive && imgSelOutViewPort=1)
      {
         dotActive := 9 ;       ; anywhere within the selection [makes the entire selection draggable]
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      }
 
      If (InStr(winEventu, "pen-") && (dotActive=9 || !dotActive))
         Return
 
      ; ToolTip, % "l=" dotActive , , , 2
      SetTimer, dummyRefreshImgSelectionWindow, Off
      oVPselRotation := VPselRotation
      tDotPosX := DotPosX
      tDotPosY := DotPosY

      SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
      MouseCoords2Image(prevDestPosX + SelDotsSize + 1, prevDestPosY + SelDotsSize + 1, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, snapSizeX, snapSizeY)
      ; snapSizeX := (xKx>rImgW*0.3) ? Ceil(rImgW*0.005) + 1 : xKx
      ; snapSizeY := (xKy>rImgH*0.3) ? Ceil(rImgH*0.005) + 1 : xKy
      ; ToolTip, % xKx "=" xKy "`n" snapSizeX "=" snapSizeY , , , 2
      nImgSelX1 := tImgSelX1 := imgSelX1
      nImgSelY1 := tImgSelY1 := imgSelY1
      nImgSelX2 := tImgSelX2 := imgSelX2
      nImgSelY2 := tImgSelY2 := imgSelY2
      timgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      timgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      tavg := (timgSelW + timgSelH)//2
      timgSelX2 := tImgSelX1 + tavg
      timgSelY2 := tImgSelY1 + tavg
      otimgSelX2 := nImgSelX2
      otimgSelY2 := nImgSelY2
      timgSelRatio := timgSelW/timgSelH
      thisZeit := zX := zY := adjustNowSel := 1
      o_imageLoading := imageLoading
      If dotActive
      {
         If (lockSelectionAspectRatio>1 && desiredSelAspectRatio && altState!=1 && isInRange(dotActive, 1, 8) && ctrlState!=1)
            shiftState := 1

         drawImgSelectionOnWindow("init", 0, 0, 0, mainWidth, mainHeight)
         If isInRange(dotActive, 1, 8)
            adjustingSelDotNow := dotActive
      }

      newPosZeit := A_TickCount
      oldPosZeit := A_TickCount
      o_alphaMaskOffsetX := alphaMaskOffsetX,   o_alphaMaskOffsetY := alphaMaskOffsetY
      o_clrGradientOffX := clrGradientOffX,     o_clrGradientOffY := clrGradientOffY
      o_shearImgX := shearImgX,                 o_shearImgY := shearImgY
      o_innerSelectionCavityX := innerSelectionCavityX
      o_innerSelectionCavityY := innerSelectionCavityY
      adjustSkewImg := adjustGradientOffset := adjustSelCavity := 0
      parametricWin := (dotActive=9 && AnyWindowOpen=30 && isVarEqualTo(DrawLineAreaBorderCenter, 4, 5, 6) && ctrlState!=1 && shiftState!=1 && userAllowsGradientRecentering=1) ? 1 : 0
      selLim := (viewportQPVimage.imgHandle) ? 9876543210 : 199000
      If (isInRange(dotActive, 11, 14) && ctrlState!=1 && shiftState!=1 && (AnyWindowOpen=31 || AnyWindowOpen=24) && !viewportQPVimage.imgHandle)
      {
         adjustSkewImg := 1
      } Else If (dotActive=9 && AnyWindowOpen=23 && ctrlState!=1 && shiftState!=1 && userAllowClrGradientRecenter=1)
      {
         If isInRange(FillAreaColorMode, 2, 4)
            adjustGradientOffset := 2
      } Else If (dotActive=9 && ctrlState=1)
      {
         adjustSelCavity := 1
      } Else If (dotActive=9 && isAlphaMaskWindow()=1 && ctrlState!=1 && shiftState!=1 && userAllowsGradientRecentering=1) || (parametricWin=1)
      {
         If (alphaMaskingMode>1 && alphaMaskingMode!=5 || parametricWin=1)
            adjustGradientOffset := 1
      }

      setWhileLoopExec(0)
      ; JEE_ClientToScreen(hPicOnGui1, mX, mY, mXo, mYo)
      MouseGetPos, mXo, mYo
      Critical, off
      While, (determineLClickState()=1 && o_imageLoading!=1 && dotActive)
      {
          MouseGetPos, mX, mY
          If yayFreeMode
          {
             ; MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
             ; freeHandPoints[3] := kX,     freeHandPoints[4] := kY
             freeHandPoints[5] := defineFreeHandFrame(mX, mY, mXo, mYo)
             freeHandPoints[6] := MouseDeltaAngle180(mXo, mYo, mX, mY)
          }

          skipLoop := isDotInRect(mX, mY, zX - 3, zX + 3, zY - 3, zY + 3) ? 1 : 0
          If (A_TickCount - newPosZeit>750) ; || (mX=oX && mY=oY)
          {
             newPosZeit := A_TickCount
             zX := mX, zY := mY
             If (skipLoop=1)
                Continue
          } Else If (skipLoop=1)
             Continue

          Sleep, 1
          zeitSillyPrevent := A_TickCount
          changePosX := (zoomLevel>1) ? Round((mX - mXo)/zL) : Round((mX - mXo)*zL)
          changePosY := (zoomLevel>1) ? Round((mY - mYo)/zL) : Round((mY - mYo)*zL)
          scPosX := mX - mXo
          scPosY := mY - mYo
          If (dotActive=10)
          {
             ; center dot - selection rotation
             VPselRotation := UIcalculateNewAngleOnMouseCoords(mXo, mYo, mX, mY, oVPselRotation, 5)
          } Else If (dotActive=9 && ctrlState=1 && adjustSelCavity=1)
          {
             coords := 10
             movX := scPosX/(mainWidth*0.5)
             movY := scPosY/(mainHeight*0.5)
             If (FlipImgH=1 && FlipImgV=1 || FlipImgH=0 && FlipImgV=0)
                movX := movY := (movX + movY)/2
             innerSelectionCavityX := clampInRange(o_innerSelectionCavityX + movX , 0, 0.99)
             innerSelectionCavityY := clampInRange(o_innerSelectionCavityY + movY , 0, 0.99)
          } Else If (adjustSkewImg=1)
          {
             coords := 10
             movX := (FlipImgH=1) ? - scPosX/(mainWidth*0.5) : scPosX/(mainWidth*0.5)
             movY := (FlipImgV=1) ? - scPosY/(mainHeight*0.5) : scPosY/(mainHeight*0.5)
             If (dotActive=11)
                shearImgX := snapToValues(clampInRange(o_shearImgX - movX*2, -9.9, 9.9), -9 0, 0, 0.05, 0)
             Else If (dotActive=13)
                shearImgX := snapToValues(clampInRange(o_shearImgX + movX*2, -9.9, 9.9), -9 0, 0, 0.05, 0)
             Else If (dotActive=12)
                shearImgY := snapToValues(clampInRange(o_shearImgY + movY*2, -9.9, 9.9), -9 0, 0, 0.05, 0)
             Else If (dotActive=14)
                shearImgY := snapToValues(clampInRange(o_shearImgY - movY*2, -9.9, 9.9), -9 0, 0, 0.05, 0)
          } Else If (dotActive=9 && adjustGradientOffset>0)
          {
             ; click anywhere within selection 
             coords := 10
             movX := (FlipImgH=1) ? - scPosX/(mainWidth*0.5) : scPosX/(mainWidth*0.5)
             movY := (FlipImgV=1) ? - scPosY/(mainHeight*0.5) : scPosY/(mainHeight*0.5)
             If (adjustGradientOffset=1)
             {
                alphaMaskOffsetX := clampInRange(o_alphaMaskOffsetX + movX, -0.9, 0.9)
                alphaMaskOffsetY := clampInRange(o_alphaMaskOffsetY + movY, -0.9, 0.9)
                If (altState=1)
                   alphaMaskOffsetX := alphaMaskOffsetY := o_alphaMaskOffsetX := o_alphaMaskOffsetY := 0
             } Else If (adjustGradientOffset=2)
             {
                clrGradientOffX := clampInRange(o_clrGradientOffX + movX, -0.9, 0.9)
                clrGradientOffY := clampInRange(o_clrGradientOffY + movY, -0.9, 0.9)
                If (altState=1)
                   clrGradientOffX := clrGradientOffY := o_clrGradientOffX := o_clrGradientOffY := 0
             }
          }

          If (shiftState=1 && dotActive=9 && adjustGradientOffset=0)
          {
             ; drag selection
             snapAxisX := dotActiveObj.cx1 + SelDotsSize//2
             snapAxisY := dotActiveObj.cy1 + SelDotsSize//2
             changePosX := snapToValues(changePosX, 0, rImgW//2, snapSizeX, 0)
             changePosY := snapToValues(changePosY, 0, rImgW//2, snapSizeX, 0)
             maxPos := max(Abs(changePosX), Abs(changePosY))
             If (maxPos=Abs(changePosX))
                changePosY := 0
             Else If (maxPos=Abs(changePosY))
                changePosX := 0
          } Else If (adjustGradientOffset=0 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; changePosX := Round(changePosX*timgSelRatio)
             If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -selLim, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, selLim)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -selLim, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, selLim)
             } Else If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -selLim, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, selLim)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -selLim, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, selLim)
             } Else If (dotActive=3)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -selLim, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, selLim)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -timgSelH + 2, selLim) : clampInRange(changePosY, -selLim, timgSelH - 2)
             } Else If (dotActive=4)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -selLim, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, selLim)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -timgSelH + 2, selLim) : clampInRange(changePosY, -selLim, timgSelH - 2)
             }
          }
 
          newSelDotX := (FlipImgH=1) ? tDotPosX - changePosX : tDotPosX + changePosX
          newSelDotY := (FlipImgV=1) ? tDotPosY - changePosY : tDotPosY + changePosY
          If (showSelectionGrid=1 && shiftState!=1 && lockSelectionAspectRatio<2)
          {
             newSelDotX := snapToValues(newSelDotX, 0, rImgW//2, snapSizeX, 0)
             newSelDotY := snapToValues(newSelDotY, 0, rImgH//2, snapSizeY, 0)
          }

          If (shiftState!=1 && lockSelectionAspectRatio<2)
          {
             newSelDotX := snapToValues(newSelDotX, 0, rImgW, snapSizeX, 0)
             newSelDotY := snapToValues(newSelDotY, 0, rImgH, snapSizeY, 0)
          }

          If (dotActive=1)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=2)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=3)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=4)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=5)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=6)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=7)
          {
             coords := 2
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=8)
          {
             coords := 2
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=9 && adjustGradientOffset=0 && adjustSelCavity=0)
          {
             coords := 10
             imgSelX1 := (FlipImgH=1) ? nImgSelX1 - changePosX : nImgSelX1 + changePosX
             imgSelY1 := (FlipImgV=1) ? nImgSelY1 - changePosY : nImgSelY1 + changePosY
             imgSelX2 := (FlipImgH=1) ? nImgSelX2 - changePosX : nImgSelX2 + changePosX
             imgSelY2 := (FlipImgV=1) ? nImgSelY2 - changePosY : nImgSelY2 + changePosY
          }

          If (nImgSelX1>nImgSelX2 || nImgSelY1>nImgSelY2) && (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY2
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY1
          } Else If (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY1
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY2
          }

          If (imgSelX1=imgSelX2)
             imgSelX2 += 2
          If (imgSelY1=imgSelY2)
             imgSelY2 += 2

          imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
          imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          If (adjustGradientOffset=0 && altState=1 && (dotActive=1 || dotActive=2 || dotActive=9))
          {
             ; rectangular selection mode
             avg := (imgSelW+imgSelH)//2
             If (dotActive=9)
             {
                cAvg := (changePosX+changePosY)//2
                imgSelX2 := timgSelX2 + cAvg
                imgSelY2 := timgSelY2 + cAvg
                imgSelX1 := timgSelX1 - cAvg
                imgSelY1 := timgSelY1 - cAvg
             } Else If (dotActive=2)
             {
                imgSelX2 := imgSelX1 + avg
                imgSelY2 := imgSelY1 + avg
             } Else
             {
                imgSelX1 := imgSelX2 - avg
                imgSelY1 := imgSelY2 - avg

             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          } Else If (adjustGradientOffset=0 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; keep aspect ratio mode
             cAvg := (changePosX+changePosY)//2
             diffu := (timgSelRatio>1) ? min(timgSelW, timgSelH) : max(timgSelW, timgSelH)
             If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                imgSelX2 := clampInRange(timgSelX1 + Round((diffu + cAvg)*timgSelRatio), timgSelX1 + 5, selLim)
                imgSelY2 := clampInRange(timgSelY1 + (diffu + cAvg), timgSelY1 + 5, selLim)
                If (dotActive=6)
                   ImgSelY1 := nImgSelY1
                Else If (dotActive=8)
                   ImgSelX1 := nImgSelX1
             } Else If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                cAvg := -cAvg
                imgSelX1 := clampInRange(otimgSelX2 - Round((diffu + cAvg)*timgSelRatio), -selLim, otimgSelX2 + 5)
                imgSelY1 := clampInRange(otimgSelY2 - (diffu + cAvg), -selLim, otimgSelY2 + 5)
             } Else If (dotActive=3)
             {
                cAvg := -cAvg
                imgSelX2 := timgSelX1 + Round((diffu+cAvg)*timgSelRatio)
                imgSelY1 := otimgSelY2 - diffu - cAvg
             } Else If (dotActive=4)
             {
                ; cAvg := -cAvg
                imgSelY2 := timgSelY1 + diffu + cAvg
                imgSelX1 := otimgSelX2 - Round((diffu+cAvg)*timgSelRatio)
             }

             ; TulTip(0, "=", changePosX, changePosX, tDotPosX, tDotPosY, imgSelW, imgSelH, imgSelX1, "lol " imgSelY1, nImgSelX1, nImgSelY1, newSelDotX, newSelDotY, dotActive)
             If (LimitSelectBoundsImg=1)
             {
                imgSelX1 := clampInRange(imgSelX1, 0, rImgW)
                imgSelY1 := clampInRange(imgSelY1, 0, rImgH)
                imgSelX2 := clampInRange(imgSelX2, 0, rImgW)
                imgSelY2 := clampInRange(imgSelY2, 0, rImgH)
             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          }

          ; ToolTip, % cAvg "=" dotActive "|" changePosX "|" changePosY "|" timgSelW "|" timgSelH , , , 2
          If (A_TickCount - thisZeit>25)
          {
             If (isInRange(dotActive, 1, 4) && minimizeMemUsage!=1 && !viewportQPVimage.imgHandle)
             {
                ARGBdec := Gdip_GetPixel(gdiBitmap, newSelDotX, newSelDotY)
                Gdip_FromARGB(ARGBdec, cA, cR, cG, cB)
                pixelColor := cR ", " cG ", " cB ", " cA
                addMsg := "`n `nCorner coordinates`nX / Y: " Round(newSelDotX) ", " Round(newSelDotY) "`nColor: " pixelColor
             }

             theRatio := (lockSelectionAspectRatio>1) ? "`nLocked aspect ratio: " Round(desiredSelAspectRatio, 2) : " (" Round(imgSelW/imgSelH, 2) ")"
             ; If (imgEditPanelOpened=1)
                theRatio .= "`nRotation: " Round(VPselRotation, 1) "° "

             mpx := "| " Round(imgSelW * imgSelH/1000000, 1) " MPx"
             theMsg := "X / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) "`nW / H: " Round(imgSelW) ", " Round(imgSelH) theRatio mpx addMsg
             If (adjustGradientOffset=1 && parametricWin=1)
                theMsg := "Object center offset`nX / Y: " Round(alphaMaskOffsetX * 100, 1) "%, " Round(alphaMaskOffsetY * 100, 1) "%"
             Else If (adjustGradientOffset=1)
                theMsg := "Alpha mask gradient center offset`nX / Y: " Round(alphaMaskOffsetX * 100, 1) "%, " Round(alphaMaskOffsetY * 100, 1) "%`nGradient angle: " Round(alphaMaskGradientAngle, 1) "°"
             Else If (adjustSkewImg=1)
                theMsg := "Skew image object`nX / Y: " Round(shearImgX * 10, 1) "%, " Round(shearImgY * 10, 1) "%"
             Else If (adjustGradientOffset=2)
                theMsg := "Color gradient center offset`nX / Y: " Round(clrGradientOffX * 100, 1) "%, " Round(clrGradientOffY * 100, 1) "%`nGradient angle: " Round(FillAreaGradientAngle, 1) "°"
             Else If (adjustSelCavity=1)
                theMsg := "Selection exclusion area`nX / Y:" Round(innerSelectionCavityX*100, 1) "%, " Round(innerSelectionCavityY*100, 1) "%"

             ; ToolTip, % theMsg, % mainX + 10, % mainY + 10
             drawImgSelectionOnWindow("live", theMsg, ARGBdec, dotActive, mainWidth, mainHeight, 0, 0, 0, 0, snapAxisX, snapAxisY)
             thisZeit := A_TickCount
          }
      }

      Critical, on
      setWhileLoopExec(0)
      adjustingSelDotNow := adjustNowSel := 0
      If dotActive
      {
         ; If yayFreeMode
         ;    endFreeHandModus(rImgW, rImgH)
         drawImgSelectionOnWindow("end")
         SetTimer, dummyRefreshImgSelectionWindow, -100
      }

      ToolTip
      If (dotActive && imgEditPanelOpened=1)
         anotherZeit := A_TickCount

      If (dotActive=9 && isInRange(Abs(changePosY), 0, 2) && isInRange(Abs(changePosX), 0, 2))
      {
         If (A_TickCount - anotherZeit<300) && (imgEditPanelOpened!=1)
            thisZeit := dotActive := ctrlState := 0
         anotherZeit := A_TickCount
      }

      If (dotActive || (A_TickCount - thisZeit<150)) && (ctrlState=0)
         Return
   }

   If (winEventu="DoubleClick" && thumbsDisplaying!=1 && displayingImageNow=1 && spaceState!=1) && (A_TickCount - lastInvokedSwipe>500) && (A_TickCount - anotherZeit>600)
   {
      ; handle double clicks in the viewport when an image is being displayed
      If (editingSelectionNow=1 && imgEditPanelOpened!=1)
      {
         lastInvoked := A_TickCount
         ToggleEditImgSelection()
         Return
      }

      lastInvoked := A_TickCount
      If (slideShowRunning=1)
         InfoToggleSlideShowu()
      Else If (InStr(thisCtrlClicked, "|PicOnGUI2b|") && TouchScreenMode=1 || TouchScreenMode!=1)
         ToggleImgSizeViewModes()
   } Else If ((displayingImageNow=1 || mustOpenStartFolder) && winEventu!="DoubleClick") && (A_TickCount - thisZeit>950)
   ; } Else If ((maxFilesIndex>1 || mustOpenStartFolder) && CurrentSLD && winEventu!="DoubleClick") && (A_TickCount - thisZeit>950)
   {
      ; handle single clicks in the viewport when multiple files are loaded
      didSomething := 0
      If (TouchScreenMode=0 || spaceState=1) && ((IMGlargerViewPort=1 || allowFreeIMGpanning=1 || spaceState=1) && IMGresizingMode=4 && thumbsDisplaying!=1)
         SetTimer, simplePanIMGonClick, -15
      Else If (TouchScreenMode=1 && drawingShapeNow!=1)
         didSomething := winSwipeAction(thisCtrlClicked, winEventu)
      Else didSomething := 0

      lastInvoked := A_TickCount
      If didSomething
         lastInvokedSwipe := A_TickCount
   } Else If (!CurrentSLD || maxFilesIndex<1) && (A_TickCount - thisZeit>450)
   {
      ; when no image is loaded, on click, open files dialog
      lastInvoked := A_TickCount
      If validBMP(UserMemBMP)
         Return

      SetTimer, drawWelcomeImg, Off
      Sleep, 5
      If (A_TickCount - lastWinDrag>300)
         OpenDialogFiles()
   }
   lastInvoked := A_TickCount
} ; // WinClickAction()

ToggleImageSizingMode(modus:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50)
       Return

    If (thumbsDisplaying=1)
    {
       ToggleThumbsAratio()
       Return
    }

    If blockBrokenIMGrefresh()
       Return

    o_friendly := DefineImgSizing(0)
    lastInvoked := A_TickCount
    resetSlideshowTimer()
    If (modus="cus-w")
    {
       IMGdecalageX := IMGdecalageY := 1
       lockZoomLevel := 0
       IMGresizingMode := 4
       customZoomAdaptMode := 1
    } Else If (modus="cus-h")
    {
       IMGdecalageX := IMGdecalageY := 1
       lockZoomLevel := 0
       customZoomAdaptMode := 2
       IMGresizingMode := 4
    } Else If (modus="cus-tom")
    {
       IMGdecalageX := IMGdecalageY := zoomLevel := 1
       IMGresizingMode := 4
       customZoomAdaptMode := 0
    } Else If (imgEditPanelOpened=1 || drawingShapeNow=1 && editingSelectionNow=1 || modus="flip-flop")
    {
       IMGresizingMode := (IMGresizingMode=1) ? 4 : 1
       If (IMGresizingMode=4)
          zoomLevel := 1
    } Else 
    {
       IMGdecalageX := IMGdecalageX := 1
       IMGresizingMode := clampInRange(IMGresizingMode + 1, 1, 5, 1)
       If (IMGresizingMode=3)
       {
          zoomLevel := 1
          IMGresizingMode := 4
       }

       If (IMGresizingMode=5 && editingSelectionNow=1)
          ToggleEditImgSelection()
    }

    If (IMGresizingMode=4)
       moreInfos := "`nImages can be panned in this mode."

    friendly := DefineImgSizing(0)
    If InStr(modus, "cus-")
       showTOOLtip("Adapt to window mode:`n" friendly moreInfos, "toggleCustomZLmodes", 1, (customZoomAdaptMode + 1.01)/3.02)
    Else If (modus="z")
       showTOOLtip("Adapt to window mode:`n" friendly moreInfos, 0, 0, 0)
    Else
       showTOOLtip("Adapt to window mode:`n" friendly moreInfos, A_ThisFunc, 1, (IMGresizingMode - 0.99)/4)

    If (IMGresizingMode=4 && (o_friendly!=friendly2 || InStr(modus, "cus-")))
    {
       IMGdecalageX := IMGdecalageY := 1
       PrintPosX := "X"
       ; SoundBeep 300, 200
    }

    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "zoomLevel", "General")
    INIaction(1, "lockZoomLevel", "General")
    uiPanelOpenCloseEvent()
    SetTimer, RemoveTooltip, % -msgDisplayTime
    If (drawingShapeNow=1)
    {
       dummyResizeImageGDIwin()
       If (drawingShapeNow=1 && isNowSymmetricVectorShape())
          SetTimer, updateVectorSymmetryPoint, -100
       Else
          SetTimer, dummyForcedRefreshImgSelectionWindow, -100
       Return
    }

    SetTimer, coreReloadThisPicture, -50
    ; dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, uiIMGresizingMode, % IMGresizingMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

DefineImgSizing(modus:=1) {
   zl := (modus=1) ? " (" defineZoomLevel() "%)" : ""
   friendly := (IMGresizingMode=1) ? "ADAPT ALL INTO VIEW" zl : "ADAPT ONLY LARGE IMAGES"
   If (IMGresizingMode=3)
      friendly := "NONE (FIXED TO ORIGINAL SIZE)"
   Else If (IMGresizingMode=5)
      friendly := "STRETCHED TO WINDOW"
   Else If (IMGresizingMode=4)
   {
      friendly := "CUSTOM ZOOM" zl
      If (customZoomAdaptMode>0)
         friendly := (customZoomAdaptMode=1) ? "ADAPT TO WINDOW WIDTH" zl : "ADAPT TO WINDOW HEIGHT" zl
   }

   Return friendly
}

VPimgFXrandomizer() {
    Static lastFX, FXmodes := {1:1, 2:2, 3:3, 4:4, 5:10}
    Random, OutputVar, 1, 5
    imgFxMode := FXmodes[OutputVar]
    If (imgFxMode=lastFX && lastFX=10)
    {
       Random, OutputVar, 1, 5
       imgFxMode := FXmodes[OutputVar]
    }

    Random, OutputVar, 1, 200
    satAdjust := OutputVar/100

    Random, OutputVar, 0.1, 0.9
    bwDithering := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 0.1, 0.9
    usrTextureBGR := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 0.1, 0.9
    FlipImgH := SubStr(Round(OutputVar), 1, 1)

    Random, OutputVar, 1, 7
    If (OutputVar=2)
       OutputVar := 1

    usrColorDepth := OutputVar
}

dummyInfoToggleSlideShowu(actu:=0) {
  Static lastInvoked := 1
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()

  GIFframesPlayied := 0
  r := ToggleSlideShowu(actu)
  If (r="lulz")
     Return

  If (slideShowRunning!=1 || actu="stop")
  {
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     ; userSeenSlideImages := (userSeenSlideImages>maxFilesIndex - 1) ? maxFilesIndex : userSeenSlideImages
     showTOOLtip("Slideshow: STOPPED`nImages seen in this session: " groupDigits(userSeenSlideImages))
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  } Else ;  If (A_TickCount - lastInvoked > 450)
  {
     delayu := DefineSlidesRate()
     friendly := DefineSlideShowType()
     etaTime := "`nEstimated time: " EstimateSlideShowLength()
     If (slidesFXrandomize=1)
        etaTime .= "`nViewport colour effects are randomized for each image."

     If (skipSeenImageSlides=1)
        etaTime .= "`nAlready seen images will be skipped."

     showTOOLtip("Started " friendly " slideshow`nSpeed: " delayu "`nTotal files: " groupDigits(maxFilesIndex) etaTime)
     SetTimer, RemoveTooltip, % -msgDisplayTime, 900
     If (slideShowDelay < 900)
     {
        Sleep, 550
        RemoveTooltip()
     } Else SetTimer, RemoveTooltip, % -msgDisplayTime, 900
  } ; Else  SetTimer, dummyInfoToggleSlideShowu, Off
}

InfoToggleSlideShowu() {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 350) && (slideShowRunning!=1) || (maxFilesIndex<3 && StrLen(mustOpenStartFolder)<4)
   {
     lastInvoked := A_TickCount
     Return
   }

   lastInvoked := A_TickCount
   If !(IMGlargerViewPort=1 && IMGresizingMode=4)
      SetTimer, dummyInfoToggleSlideShowu, -80
   Return
}

preventScreenOff() {
  ; if the user is idle ;-)
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 10500) || (slideShowRunning!=1)
     Return

  lastInvoked := A_TickCount
  If (!GetKeyState("Space", "P") && slideShowRunning=1 && WinActive("A")=PVhwnd)
  {
     MouseMove, 2, 0, 2, R
     MouseMove, -2, 0, 2, R
     ; SendEvent, {Up}
  }
  ; z := DllCall("user32\SetCursor", "Ptr", hCursBusy)
  ; ToolTip, % "L=" z , , , 2
}

ToggleSlideShowu(actu:=0, resetMode:=0) {
  If (maxFilesIndex<3 && slideShowRunning!=1)
  {
     showTOOLtip("WARNING: Insufficient indexed files to start a slideshow")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "lulz"
  }

  If askAboutFileSave(" and the slideshow will begin")
     Return "lulz"
  Else
     terminateIMGediting()

  If (RandyIMGnow=-1 || !RandyIMGids.Count()) && (SlideHowMode=1)
     coreGenerateRandomList()

  interfaceThread.ahkFunction("initSlidesModes", animGIFplaying, allowNextSlide, maxFilesIndex, slidesFXrandomize)
  If (slideShowRunning=1 || actu="stop") && (actu!="start")
  {
     If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
     {
        WinSet, Region,, ahk_id %hQPVtoolbar%
        Loop, % tlbrIconzList["counter"]
        {
            h := tlbrIconzList[A_Index, 1]
            WinSet, Transparent, 255, ahk_id %h%
        }
     }

     If (StrLen(SlidesMusicSong)>3 && hSNDsong && resetMode!=1)
        StopMediaPlaying(1)

     slideShowRunning := 0
     ; ResetImgLoadStatus()
     ; SetTimer, theSlideShowCore, Off
     prevSlideShowStop := A_TickCount
     interfaceThread.ahkFunction("slideshowsHandler", 0, "stop", SlideHowMode)
     SetTimer, ResetImgLoadStatus, -150
  } Else If (thumbsDisplaying!=1 || actu="start")
  {
     If (A_TickCount - prevSlideShowStop<500) && (actu!="start")
        Return

     If (editingSelectionNow=1)
        ToggleEditImgSelection()

     If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1 && slideShowRunning!=1)
     {
        SetWindowRegion(hQPVtoolbar, 1, 1, 1, 1)
        ; DelayiedImageDisplay()
        ; dummyResizeImageGDIwin()
     }

     Static lastInvoked := 1
     If ((A_TickCount - lastInvoked>100) && TouchToolbarGUIcreated=1 && ShowAdvToolbar=1 && lockToolbar2Win=1)
     {
        createGDIPcanvas()
        lastInvoked := A_TickCount
     }

     imageLoading := 0
     interfaceThread.ahkassign("imageLoading", imageLoading)
     changeMcursor("normal-extra")
     SetTimer, ResetImgLoadStatus, Off
     If (StrLen(SlidesMusicSong)>3 && autoPlaySlidesAudio=1 && resetMode!=1)
        startSlidesMusicNow()

     slideShowRunning := 1
     interfaceThread.ahkassign("allowNextSlide", 1)
     If (hSNDmediaFile && hSNDmediaDuration && hSNDmedia)
        milisec := MCI_Length(hSNDmedia) 

     thisSlideSpeed := (milisec>slideShowDelay) ? milisec : slideShowDelay
     msgu := "Slideshow is running. Direction: " DefineSlideShowType() ". Speed: " DefineSlidesRate() "."
     If (slidesFXrandomize=1)
        msgu .= "`nViewport colour effects are randomized for each image."

     If (skipSeenImageSlides=1)
        msgu .= "`nAlready seen images will be skipped."

     msgu .= "`nPress Escape or click to stop the slideshow."
     interfaceThread.ahkFunction("slideshowsHandler", thisSlideSpeed, "start", SlideHowMode, msgu)
     ; SetTimer, theSlideShowCore, % thisSlideSpeed
  }
  Return
}

GoNextSlide() {
  Sleep, 15
  resetSlideshowTimer()
  If (SlideHowMode=1 && !GetKeyState("Ctrl", "P"))
     RandomPicture()
  Else
     NextPicture()
}

GoPrevSlide() {
  Sleep, 15
  resetSlideshowTimer()
  If (SlideHowMode=1 && !GetKeyState("Ctrl", "P"))
     PrevRandyPicture()
  Else
     PreviousPicture()
}

coreSecToHHMMSS(Seco, ByRef Hrs, ByRef Min, ByRef Sec) {
  OldFormat := A_FormatFloat
  SetFormat, Float, 2.00
  Hrs := Seco//3600/1
  Min := Mod(Seco//60, 60)/1
  SetFormat, Float, %OldFormat%
  Sec := Round(Mod(Seco, 60), 2)
}

SecToHHMMSS(Seco) {
  coreSecToHHMMSS(Seco, Hrs, Min, Sec)
  If (hrs>26)
     dayz := Round(hrs/24, 2)

  If (dayz>=1.1)
  {
     If (dayz>32)
        Return "about " Round(dayz/30.5, 2) " months"
     r := dayz " days"
  } Else  r := (Hrs ? Hrs "h " : "") Min "m " Sec "s"

  If (!min && !hrs)
  {
     r := StrReplace(r, "0m ")
     r := Trimmer(r, "0")
  }

  r := StrReplace(r, ".00s", "s")
  If (min || hrs)
     r := RegExReplace(r, "\...s", "s")
  r := StrReplace(r, " 0s")
  r := StrReplace(r, "  ", A_Space)
  r := Trimmer(r)

  Return r
}

MenuSlideshowModeNext() {
   SlideHowMode := 2
   ToggleSlideshowModes()
}

MenuSlideshowModePrev() {
   SlideHowMode := 1
   ToggleSlideshowModes()
}

MenuSlideshowModeRando() {
   slidesRandoMode := 1
   SlideHowMode := 0
   GenerateRandyList()
   ToggleSlideshowModes()
}

MenuSlideshowModeRandyFirst() {
   SlideHowMode := 0
   slidesRandoMode := 2
   GenerateRandyList()
   ToggleSlideshowModes()
}

MenuSlideshowModeRandySecond() {
   SlideHowMode := 0
   slidesRandoMode := 3
   GenerateRandyList()
   ToggleSlideshowModes()
}

DefineSlideShowType() {
   friendly := (SlideHowMode=1) ? "RANDOM" : "BACKWARD"
   If (SlideHowMode=3)
      friendly := "FORWARD"

   If (SlideHowMode=1 && slidesRandoMode=2)
      friendly .= " (1st half bias)"
   Else If (SlideHowMode=1 && slidesRandoMode=3)
      friendly .= " (2nd half bias)"

   Return friendly
}

ToggleSlideshowModes() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50) ; || (thumbsDisplaying=1)
      Return

   lastInvoked := A_TickCount
   SlideHowMode++
   If (SlideHowMode>3)
      SlideHowMode := 1

   resetSlideshowTimer(1)
   friendly := DefineSlideShowType() "`nCurrently "
   friendly .= (slideShowRunning=1) ? "running" : "stopped"
   showTOOLtip("Slideshow direction: " friendly, A_ThisFunc, 1, SlideHowMode/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "SlideHowMode", "General")
   RegAction(1, "slidesRandoMode")
}

DefineVPselAreaMode() {
   If (EllipseSelectMode=2)
      friendly := (bezierSplineCustomShape=1) ?  "FREEFORM BÉZIER" : "FREEFORM - T" FillAreaCurveTension
   Else If (EllipseSelectMode=1)
      friendly := "ELLIPTICAL"
   Else
      friendly := "RECTANGULAR"

   If ((AnyWindowOpen=23 || AnyWindowOpen=65) && EllipseSelectMode=0)
   {
      Gui, SettingsGUIA: Default
      GuiControlGet, hwnd, hwnd, FillAreaShape
      ControlGetText, info,, ahk_id %hwnd%
      info := Format("{:U}", info)
      Return info
   }
   Return friendly
}

DefineFXmodes() {
   Static FXmodesLabels := {1:"ORIGINAL", 2:"PERSONALIZED", 3:"AUTO-ADJUSTED", 4:"GRAYSCALE", 5:"RED CHANNEL", 6:"GREEN CHANNEL", 7:"BLUE CHANNEL", 8:"ALPHA CHANNEL", 9:"INVERTED COLORS", 10:"SEPIA"}

   If FXmodesLabels.HasKey(imgFxMode)
      friendly := FXmodesLabels[imgFxMode]
   Else
      friendly := "Colors FX: " imgFxMode

   If (bwDithering=1 && imgFxMode=4)
      friendly := "BLACK/WHITE DITHERED"

   If (imgFxMode=1 && isInRange(usrColorDepth, 2, 10))
      friendly := "ALTERED COLOR DEPTH"

   Return friendly
}

ToggleImgColorDepth(dir:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 && thumbsListViewMode>1)
       Return

   If blockBrokenIMGrefresh(1)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer()
   If (imgFxMode=4 && bwDithering=1)
   {
      imgFxMode := 1
      Return
   }

   good2go := (imgFxMode=1 || imgFxMode=2 || imgFxMode=3 || imgFxMode=8) ? 1 : 0
   If (good2go!=1)
      imgFxMode := 1

   If (dir=1)
      usrColorDepth++
   Else
      usrColorDepth--

   usrColorDepth := clampInRange(usrColorDepth, 1, 9, 1)
   ForceRefreshNowThumbsList()
   infoColorDepth := (usrColorDepth>1) ? defineColorDepth() : "NONE"
   showTOOLtip("Image color depth simulated:`n" infoColorDepth, A_ThisFunc, 2, (usrColorDepth - 0.999)/8)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "usrColorDepth", "General")
   INIaction(1, "imgFxMode", "General")
   SetTimer, RefreshImageFile, -50
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, usrColorDepth, % usrColorDepth
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineColorDepth() {
   Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:16}

   internalColorDepth := bitsOptions[usrColorDepth]
   r := internalColorDepth " bits [" 2**internalColorDepth " colors]"
   If (r<1)
      r := currIMGdetails.PixelFormat
   Else If (ColorDepthDithering=1)
      r .= " | DITHERED"

   If !r
      r := "NONE"
   Return r
}

ToggleImgFX(dir:=0) {
   Static lastInvoked := 1, moreFX := {1:"None", 2:"Brightness / Contrast", 3:"Hue / Saturation / Lightness", 4:"Levels adjust [High / Mid / Low]", 5:"Color tint [Hue / Amount]", 6:"Colors balance", 7:"Color curve per channel"}
        , curvesFX := {1:"Brightness (density)", 2:"Contrast", 3:"Highlights", 4:"Shadows", 5:"Midtones", 6:"White saturation", 7:"Black saturation"}
        , curvesChannels := {1:"Red", 2:"Green", 3:"Blue", 4:"All"}

   If (A_TickCount - lastInvoked < 50) ; || (thumbsDisplaying=1 && showHUDnavIMG!=1)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer()
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=1)
      imgFxMode++
   Else
      imgFxMode--

   prevColorAdjustZeit := A_TickCount
   If (imgFxMode=3)
   {
      If (dir=1)
         imgFxMode++
      Else
         imgFxMode--
   }

   If (thumbsDisplaying=1 && imgFxMode=8)
   {
      If (dir=1)
         imgFxMode++
      Else
         imgFxMode--
   }

   ; ToolTip, % " l = " imgFxMode , , , 2
   imgFxMode := clampInRange(imgFxMode, 1, 10, 1)
   friendly := DefineFXmodes()
   If (imgFxMode=4)
      friendly .= "`nBrightness: " Round(lumosGrayAdjust, 3) "`nContrast: " Round(GammosGrayAdjust, 3)
   Else If (imgFxMode=2)
      friendly .= "`nBrightness: " Round(lumosAdjust, 3) "`nContrast: " Round(GammosAdjust, 3) "`nSaturation: " Round(satAdjust*100) "%"

   If isVarEqualTo(imgFxMode, 2, 4, 9)
      friendly .= "`nGamma: " Round(realGammos, 3)
   
   If (isVarEqualTo(imgFxMode, 2, 3, 9, 10) || (imgFxMode=4 && !bwDithering)) && (IntensityAlphaChannel!=1)
      friendly .= "`nAlpha channel: ALTERED"

   If (specialColorFXmode>1 && isVarEqualTo(imgFxMode, 2, 3, 4, 9))
   {
      friendly .= "`n" moreFX[specialColorFXmode]
      If (specialColorFXmode=7)
         friendly .= " [" curvesFX[uiColorCurveFXmode] "]: "  Round(lummyAdjust) " - " curvesChannels[uiColorCurveFXchannel]
      Else
         friendly .= ":`n" Round(hueAdjust) " / " Round(zatAdjust) " / " Round(lummyAdjust)
   }

   bonus := (usrColorDepth>1 && imgFxMode=1) ? 0.5 : 0
   If (usrColorDepth>1 && imgFxMode=1)
      friendly .= "`nSimulated color depth: " defineColorDepth()

   If (imgFxMode=4 || imgFxMode=3 || imgFxMode=2)
      friendly .= "`n `nPress U to adjust colors display options."

   showTOOLtip("Image colors: " friendly, A_ThisFunc, 2, (imgFxMode - 0.999 + bonus)/9)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()

   INIaction(1, "imgFxMode", "General")
   If (o_bwDithering=0)
      o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0

   If (o_bwDithering=1 && thumbsDisplaying!=1)
      RefreshImageFile()
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, imgFxMode, % imgFxMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineImgAlign() {
   modes := {1:"Top-left corner", 2:"Top-center", 3:"Top-right corner", 4:"Left-center", 5:"Center", 6:"Right-center", 7:"Bottom-left corner", 8:"Bottom-center", 9:"Bottom-right corner"}
   ; thisAlign := (IMGresizingMode=4) ? 5 : imageAligned
   r := modes[imageAligned]
   StringUpper, r, r
   Return r
}

ToggleIMGalign() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (!validBMP(useGdiBitmap()) && thumbsDisplaying!=1)
      Return

   resetSlideshowTimer(1)
   imageAligned := (imageAligned=5) ? 1 : 5
   showTOOLtip("Image alignment: " defineImgAlign(), A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "imageAligned", "General")
   IMGdecalageX := IMGdecalageY := 1
   If (IMGresizingMode=4)
      PrintPosX := "X"

   dummyTimerReloadThisPicture(50)
   If (drawingShapeNow=1)
   {
      If isNowSymmetricVectorShape()
         coreSetVPsymmetryPoint(( customShapePoints.Count() ) // 2 + 1)
      SetTimer, dummyForcedRefreshImgSelectionWindow, -100
      Return
   }

   uiPanelOpenCloseEvent()
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   } Else If (thumbsDisplaying=1)
   {
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(50)
   }
}

MenuToggleColorAdjustments() {
   toggleColorAdjustments()
}

toggleColorAdjustments(modus:=0) {
   Static lastInvoked := 1, prevImgAlphaChn := 1, prevFXmode := 1
   If (modus="backup")
   {
      IntensityAlphaChannel := (ForceNoColorMatrix=1) ? 1 : prevImgAlphaChn
      imgFxMode := (ForceNoColorMatrix=1) ? 1 : prevFXmode
      Return
   }

   If (A_TickCount - lastInvoked < 50)
      Return

  lastInvoked := A_TickCount
  If (imgFxMode!=1 && thumbsDisplaying!=1)
  {
     prevColorAdjustZeit := A_TickCount
     resetSlideshowTimer()
     If (!ForceNoColorMatrix && modus!="backup")
     {
        prevFXmode := imgFxMode
        prevImgAlphaChn := IntensityAlphaChannel
     }

     ForceNoColorMatrix := !ForceNoColorMatrix
     If (modus=0)
        AnyWindowOpen := (ForceNoColorMatrix=1) ? 10 : 0
     IntensityAlphaChannel := (ForceNoColorMatrix=1) ? 1 : prevImgAlphaChn
     imgFxMode := (ForceNoColorMatrix=1) ? 1 : prevFXmode
     dummyTimerDelayiedImageDisplay(50)
     If (modus=0)
     {
        AnyWindowOpen := 10
        SetTimer, resetClrMatrix, -1950
     }
  }
}

resetClrMatrix() {
   resetSlideshowTimer()
   AnyWindowOpen := ForceNoColorMatrix := 0
   toggleColorAdjustments("backup")
   dummyTimerDelayiedImageDisplay(50)

}

ResetImageView() {
   Critical, on
   If throwErrorNoImageLoaded()
      Return

   VPchangeLumos(2)
}

HardResetImageView() {
   Critical, on
   DestroyTempBtnGui("now")
   If (!validBMP(useGdiBitmap()) && !CurrentSLD)
      Return

   VPchangeLumos(2, "k")
   If (AnyWindowOpen=40 && thumbsDisplaying=1)
      updateUIthumbsView()
}

coreResetIMGview(dummy:=0) {
  Critical, on
  If (imgFxMode=4 && lumosGrayAdjust=1 && GammosGrayAdjust=0)
     mustResetFxMode := 1

  If (dummy="k")
  {
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0
     imgThreshold := bwDithering := hueAdjust := zatAdjust := lummyAdjust := 0
     IntensityAlphaChannel := specialColorFXmode := 1
  }

  If (imgFxMode=4)
  {
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
  } Else If (imgFxMode=2)
  {
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || dummy="k")
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0

  realGammos := 1
  If (imgFxMode=1 || dummy="k")
  {
     zoomLevel := 1
     FlipImgH := FlipImgV := 0
     If (thumbsDisplaying!=1)
       vpIMGrotation := 0
  }

  If (dummy="k")
  {
     ; bwDithering := 0
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
     vpIMGrotation := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || imgFxMode>4 || mustResetFxMode=1)
     imgFxMode := 1

  If (thumbsDisplaying=1)
  {
     thumbsZoomLevel := 1
     thumbsColumns := 7
     recalculateThumbsSizes()
     ; thumbsH := othumbsH + 1
     ; thumbsW := othumbsW + 1
     ForceRefreshNowThumbsList()
  }

  interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
  If (dummy="k")
     usrColorDepth := internalColorDepth := 1

  SetTimer, WriteSettingsColorAdjustments, -100
}

VPchangeLumos(dir, dummy:=0) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer()
   If (imgFxMode!=2 && imgFxMode!=4 && dir!=2)
      imgFxMode := 2

   showHardReset := 0
   If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
      showHardReset := 1

   prevColorAdjustZeit := A_TickCount
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=2)
   {
      coreResetIMGview(dummy)
   } Else If (imgFxMode=4)
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosGrayAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosGrayAdjust += stepu
      Else
         lumosGrayAdjust -= stepu

      lumosGrayAdjust := clampInRange(lumosGrayAdjust, 0.001, 25)
   } Else
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosAdjust += stepu
      Else
         lumosAdjust -= stepu

      lumosAdjust := clampInRange(lumosAdjust, 0.001, 25)
   }

   value2show := (imgFxMode=4) ? Round(lumosGrayAdjust, 3) : Round(lumosAdjust, 3)
   If (dir=2)
   {
      If (imgFxMode=4)
         addMsg := DefineFXmodes()
      If (imgFxMode=1 && usrColorDepth>1)
         addMsg .= "`nImage color depth: ALTERED [ " defineColorDepth() " ]"
      If (vpIMGrotation>0)
         addMsg .= "`nImage rotated: " vpIMGrotation "° degrees."

      addMsg .= defineIMGmirroring()
      If (dummy!="k" && showHardReset=1)
      {
         addMore := "`nReset all adjustments to defaults with Ctrl + \"
         CreateTempGuiButton("Reset all adjustments,,HardResetImageView", 0, msgDisplayTime//1.5 + 100)
      }
      showTOOLtip("Image display: UNALTERED " addMsg addMore)
   } Else showTOOLtip("Image brightness: " value2show, A_ThisFunc, 2, value2show / 25)

   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues && dir!=2)
      Return

   If (dir!=2)
      SetTimer, dummySaveLumGammosSettings, -70

   prevValues := newValues
   If (o_bwDithering=1) ; && (thumbsDisplaying!=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If ((AnyWindowOpen=10 || AnyWindowOpen=74) && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

WriteSettingsColorAdjustments() {
    INIaction(1, "bwDithering", "General")
    INIaction(1, "chnBdecalage", "General")
    INIaction(1, "chnGdecalage", "General")
    INIaction(1, "chnRdecalage", "General")
    INIaction(1, "ColorDepthDithering", "General")
    INIaction(1, "FlipImgH", "General")
    INIaction(1, "FlipImgV", "General")
    INIaction(1, "GammosAdjust", "General")
    INIaction(1, "GammosGrayAdjust", "General")
    INIaction(1, "histogramMode", "General")
    INIaction(1, "hueAdjust", "General")
    INIaction(1, "imgFxMode", "General")
    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "imgThreshold", "General")
    INIaction(1, "IntensityAlphaChannel", "General")
    INIaction(1, "lummyAdjust", "General")
    INIaction(1, "lumosAdjust", "General")
    INIaction(1, "lumosGrayAdjust", "General")
    INIaction(1, "realGammos", "General")
    INIaction(1, "satAdjust", "General")
    INIaction(1, "showHistogram", "General")
    INIaction(1, "specialColorFXmode", "General")
    INIaction(1, "uiColorCurveFXchannel", "General")
    INIaction(1, "uiColorCurveFXmode", "General")
    INIaction(1, "userimgQuality", "General")
    INIaction(1, "usrColorDepth", "General")
    INIaction(1, "usrTextureBGR", "General")
    INIaction(1, "vpIMGrotation", "General")
    INIaction(1, "zatAdjust", "General")
    INIaction(1, "zoomLevel", "General")
}

defineIMGmirroring() {
    If (FlipImgH=1 || FlipImgV=1)
    {
       infoMirroring := "`nImage mirroring: "
       If (FlipImgV=1 && FlipImgH=0)
          infoMirroring :=  infoMirroring "VERTICAL"
       Else If (FlipImgV=0 && FlipImgH=1)
          infoMirroring := infoMirroring "HORIZONTAL"
       Else If (FlipImgV=1 && FlipImgH=1)
          infoMirroring := infoMirroring "VERTICAL, HORIZONTAL"
    }
    Return infoMirroring
}

defineFilesListType() {
    If (SLDtypeLoaded=1)
    {
       infou := !InStr(CurrentSLD, "|") ? "FOLDER RECURSIVELY" : "FOLDER"
    } Else If (SLDtypeLoaded=2)
    {
       infou := "PLAIN-TEXT | cached list"
       If (currentFilesListModified=1)
          infou .= " | unsaved changes"
    } Else If (SLDtypeLoaded=3)
       infou := "SQLITE DATABASE | cached list"
       
    Return infou
}

ChangeThumbsZoom(dir) {
   If (thumbsListViewMode>1)
   {
      changeOSDfontSize(dir)
      Return
   }

   If (dynamicThumbsColumns=1)
   {
      If (dir=1)
         thumbsZoomLevel += 0.1
      Else
         thumbsZoomLevel -= 0.1
   } Else
   {
      If (dir=1)
         thumbsColumns += 1
      Else
         thumbsColumns -= 1
   }

   thumbsZoomLevel := clampInRange(thumbsZoomLevel, 0.35, 3)
   thumbsColumns := clampInRange(thumbsColumns, 2, 100)
   ForceRefreshNowThumbsList()
   recalculateThumbsSizes()
   If (thumbsListViewMode=1)
      ForceRefreshNowThumbsList()

   INIaction(1, "thumbsZoomLevel", "General")
   INIaction(1, "thumbsColumns", "General")
   ; INIaction(1, "dynamicThumbsColumns", "General")
   If (dynamicThumbsColumns=1)
      showTOOLtip("Thumbnails zoom level: " Round(thumbsZoomLevel*100) "%`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", A_ThisFunc, 2, thumbsZoomLevel/3)
   Else
      showTOOLtip("Thumbnails columns: " thumbsColumns "`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", A_ThisFunc, 2, thumbsColumns/100)

   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(100)
}

decideNewVPzoomLevel(zl, key, dir, stepFactor) {
   If (zl<=0.1 && dir!=1)
      changeFactor := 0.01
   Else If (zl<0.1 && dir=1)
      changeFactor := 0.01
   Else
      changeFactor := 0.05

   If (zl>5)
      changeFactor := 0.50
   Else If (zl>1)
      changeFactor := 0.15
   Else If (zl<0.01)
      changeFactor := 0.005

   If InStr(key, "wheel")
      changeFactor *= 2

   If (dir=1)
      zl += changeFactor * stepFactor
   Else
      zl -= changeFactor * stepFactor

   If isInRange(zl, 0.1, 0.12)
      zl := 0.1
   Else If isInRange(zl, 0.99, 1.01)
      zl := 1
   Else If isInRange(zl, 1.98, 2.02)
      zl := 2
   Else If isInRange(zl, 9.90, 10.10)
      zl := 10

   trGdip_GetImageDimensions(useGdiBitmap(), W, H)
   mpx := Round((W * H)/1000000, 1)
   zl := (mpx>1000) ? clampInRange(zl, 0.005, 15) : clampInRange(zl, 0.005, 20)
   If (mpx>4500 && zl > 10)
      zl := 10

   Return zl 
}

blockBrokenIMGrefresh(allowThumbs:=0) {
   If (allowThumbs=1 && thumbsDisplaying=1)
      Return 0

   If !isImgEditingNow()
   {
      showTOOLtip("ERROR: No image currently loaded or it failed to load.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }
   Return 0
}

dummyForcedRefreshImgSelectionWindow() {
   dummyRefreshImgSelectionWindow("forced")
}

VPchangeZoom(dir, key:=0, stepFactor:=1, forceUpdate:=0) {
   Static prevValues, lastInvoked := 1, lastInvoked2 := 1, prevNavKeysu := 0
   If InStr(key, "wheel")
   {
      MouseGetPos, , , OutputVarWin
      If (OutputVarWin!=PVhwnd)
         Return
   }

   resetSlideshowTimer()
   If (thumbsDisplaying=1)
   {
      ChangeThumbsZoom(dir)
      Return
   }

   If blockBrokenIMGrefresh()
      Return

   oldZoomLevel := zoomLevel
   zoomLevel := decideNewVPzoomLevel(zoomLevel, key, dir, stepFactor)
   o_IMGresizingMode := IMGresizingMode
   IMGresizingMode := 4
   customZoomAdaptMode := 0
   ; If (allowFreeIMGpanning=1 && imageAligned=5 && IMGresizingMode=4)
   ;    PrintPosX := (o_IMGresizingMode=IMGresizingMode) ? "W" : "C"

   If (o_IMGresizingMode!=IMGresizingMode)
      uiPanelOpenCloseEvent()

   dummyDisplayZoomImgInfo()
   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")

   imgPath := getIDimage(currentFileIndex)
   skippedKeys := navKeysCounter - prevNavKeysu
   If (A_TickCount - lastInvoked2>450)
      prevNavKeysu := navKeysCounter

   ; ToolTip, % "s=" skippedKeys , , , 2
   If (skippedKeys>4 && drawingShapeNow!=1)
   {
      dummyTimerDelayiedImageDisplay(500)
      If (drawingShapeNow=1 && isNowSymmetricVectorShape())
         SetTimer, updateVectorSymmetryPoint, -650
      lastInvoked2 := A_TickCount
      Return
   }

   newValues := "a" zoomLevel thumbsZoomLevel IMGresizingMode imageAligned imgPath gdiBitmap UserMemBMP currentFileIndex vpIMGrotation
   If (prevValues=newValues && hasThisChangedYo!=1)
      Return

   prevValues := newValues
   Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
   lastInvoked := A_TickCount
   If (forceUpdate=1)
      dummyResizeImageGDIwin()
   Else 
      SetTimer, dummyResizeImageGDIwin, -50
   If (drawingShapeNow=1 && isNowSymmetricVectorShape())
      SetTimer, updateVectorSymmetryPoint, -100
}

updateVectorSymmetryPoint() {
   coreSetVPsymmetryPoint(( customShapePoints.Count() ) // 2 + 1)
   dummyForcedRefreshImgSelectionWindow()
}

dummyResizeImageGDIwin() {
   If (currIMGdetails.Width && currIMGdetails.Height)
   {
      startZeitIMGload := A_TickCount
      imgPath := StrReplace(getIDimage(currentFileIndex), "||")
      r := ResizeImageGDIwin(imgPath, 0, 0)
      Return r
   }
}

dummyDisplayZoomImgInfo() {
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, uiIMGresizingMode, % IMGresizingMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }

   showTOOLtip("Zoom level: " defineZoomLevel() "%" friendly, 0, 0, zoomLevel/20)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ; SetTimer, ResetImgLoadStatus, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

VPchangeGammos(dir) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer()
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (imgFxMode!=2 && imgFxMode!=4)
      imgFxMode := 2

   value2Adjust := (imgFxMode=4) ? GammosGrayAdjust : GammosAdjust
   value2AdjustB := (imgFxMode=4) ? lumosGrayAdjust : lumosAdjust
   stepu := (A_tickcount - lastInvoked<300) && (value2Adjust<-2) ? 0.06 : 0.03
   If (dir=1)
   {
      value2Adjust += stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB -= stepu
   } Else
   {
      value2Adjust -= stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB += stepu
   }

   value2Adjust := clampInRange(value2Adjust, -25, 1)
   value2AdjustB := clampInRange(value2AdjustB, 0.001, 25)
   If (imgFxMode=4)
   {
      GammosGrayAdjust := value2Adjust
      lumosGrayAdjust := value2AdjustB
   } Else
   {
      GammosAdjust := value2Adjust
      lumosAdjust := value2AdjustB
   }

   prevColorAdjustZeit := A_TickCount
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image contrast: " Round(value2Adjust, 3), A_ThisFunc, 2, Abs(value2Adjust - 1)/26)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues)
      Return

   SetTimer, dummySaveLumGammosSettings, -70
   prevValues := newValues
   If (o_bwDithering=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If ((AnyWindowOpen=10 || AnyWindowOpen=74) && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

dummySaveLumGammosSettings() {
   INIaction(1, "GammosAdjust", "General")
   INIaction(1, "GammosGrayAdjust", "General")
   INIaction(1, "lumosAdjust", "General")
   INIaction(1, "lumosGrayAdjust", "General")
   INIaction(1, "imgFxMode", "General")
   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")
}

VPchangeSaturation(dir) {
   Static prevValues
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer()
   If (imgFxMode=4)
      satAdjust := 0

   imgFxMode := 2
   prevColorAdjustZeit := A_TickCount
   value2Adjust := satAdjust
   If (dir=1)
      value2Adjust += 0.05
   Else
      value2Adjust -= 0.05

   value2Adjust := clampInRange(value2Adjust, 0, 3)
   satAdjust := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image saturation: " Round(value2Adjust*100) "%", A_ThisFunc, 2, value2Adjust/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" satAdjust imgFxMode currentFileIndex
   If (prevValues=newValues)
      Return

   INIaction(1, "satAdjust", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)
   If ((AnyWindowOpen=10 || AnyWindowOpen=74) && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

VPchangeRealGamma(dir) {
   Static prevValues
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      Return

   resetSlideshowTimer()
   prevColorAdjustZeit := A_TickCount
   imgFxMode := 2
   value2Adjust := realGammos
   If (value2Adjust>2)
      stepu := 0.2
   Else If (value2Adjust<0.1)
      stepu := 0.01
   Else
      stepu := 0.05

   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   value2Adjust := clampInRange(value2Adjust, 0.01, 10)
   realGammos := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image gamma: " Round(value2Adjust*100) "%", A_ThisFunc, 2, value2Adjust/8)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" realGammos imgFxMode
   If (prevValues=newValues)
      Return

   INIaction(1, "realGammos", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)

   If ((AnyWindowOpen=10 || AnyWindowOpen=74) && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

ChangeSoundVolume(dir) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (thumbsDisplaying=1)
      Return

   resetSlideshowTimer(1)
   value2Adjust := mediaSNDvolume
   If (dir=1)
      value2Adjust += 5
   Else
      value2Adjust -= 5

   value2Adjust := clampInRange(value2Adjust, 1, 100)
   If (hSNDmedia && hSNDmediaFile)
   {
      zPlitPath(hSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      milisec := MCI_Length(hSNDmedia)
      hSNDmediaDuration := MCI_ToHHMMSS(milisec)
      infoMedia := "`nAudio annotation playing:`n" OutFileName " ( " hSNDmediaDuration " )"
   }

   If (hSNDsong && StrLen(SlidesMusicSong)>3)
   {
      zPlitPath(SlidesMusicSong, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      milisec := MCI_Length(hSNDsong)
      lenghtu := MCI_ToHHMMSS(milisec)
      infoMedia .= "`nBackground slideshow music playing:`n" OutFileName " ( " lenghtu " )"
   }

   If !infoMedia
      infoMedia := "`nNo audio is playing through QPV"

   mediaSNDvolume := value2Adjust
   INIaction(1, "mediaSNDvolume", "General")
   SetVolume(mediaSNDvolume)
   showTOOLtip("Audio volume: " value2Adjust "%" infoMedia, A_ThisFunc, 2, value2Adjust/100)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

changeGIFsDelayu(dir) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   If (thumbsDisplaying=1 || !isImgEditingNow() || animGIFsSupport!=1)
      Return

   factoru := (A_TickCount - lastInvoked<350) ? 150 : 15
   resetSlideshowTimer(1)
   value2Adjust := UserGIFsDelayu
   If (dir=1)
      value2Adjust += factoru
   Else
      value2Adjust -= factoru

   value2Adjust := clampInRange(value2Adjust, -9500, 9500, 1)
   UserGIFsDelayu := value2Adjust
   SetTimer, postPonedWriteGifSpeed, -150
   ; setGIFframesDelay()
   showTOOLtip("GIFs playback delay: " value2Adjust " ms", A_ThisFunc, 2, (value2Adjust+9500)/19000)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
}

postPonedWriteGifSpeed() {
   INIaction(1, "UserGIFsDelayu", "General")
}

VPchangeSelRotation(dir, stepu:=1) {
   If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
      Return

   value2Adjust := VPselRotation
   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   value2Adjust := clampInRange(value2Adjust, 0, 360 - 1, 1)
   VPselRotation := value2Adjust
   vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
   ; SetTimer, dummyRefreshImgSelectionWindow, -50
   dummyRefreshImgSelectionWindow()
   userFriendlyPrevImgSelAction := (dir=1) ? "SELECTION ROTATION +" stepu "°" : "SELECTION ROTATION -" stepu "°"
   dummyShowSelCoordsInfos()
   vpImgPanningNow := 0
   delayu := (imgEditPanelOpened=1 && AnyWindowOpen) ? 400 : 150
   dummyTimerDelayiedImageDisplay(delayu)
}

isImgSizeTooLarge(imgW, imgH, typu:="gdip", extraLimit:=1) {
   If (typu="gdip")
      r := (Round((imgW * imgH)/1000000, 1) > 536.7) || (max(imgW, imgH)>199000) ? 1 : 0
   Else If (typu="webp")
      r := (Round((imgW * imgH)/1000000, 1) > 267.2) || (imgW>16350 || imgH>16350) ? 1 : 0 ; max. 267 mgpx
   ; Else If (typu="png")
   ;    r := (Round((imgW * imgH)/1000000, 1) > 486) ? 1 : 0
   Else If (typu="fim")
      r := (Round((imgW * imgH)/1000000, 1) > 9850) ? 1 : 0
   Else If (typu="ico")
      r := (imgW>256 || imgH>256) ? 1 : 0 ; max. 267 mgpx
   Else If isVarEqualTo(typu, "jng", "jpg", "jpeg", "jfif", "gif", "tga")
      r := (imgW>65530 || imgH>65530) || (Round((imgW * imgH)/1000000, 1) > 4294) ? 1 : 0
   Else If isVarEqualTo(typu, "jp2", "j2k")
      r := (imgW>32760 || imgH>32760) || (Round((imgW * imgH)/1000000, 1) > 1073) ? 1 : 0

   ; (23160*23160)/1000000 = 536.7 mgpx 32 bits limit [RGBA]
   ; (26745*26745)/1000000 = 715.3 mgpx 24 bits limit [RGB]
   If (!r && extraLimit=1)
      r := (Round((imgW * imgH)/1000000, 1) > 715.3) ? 1 : 0
   Return r
}

changeLittleImgRotationInVP(dir) {
   changeImgRotationInVP(dir, 1)
}

changeImgRotationInVP(dir, stepu:=5, doReset:=0) {
   If (thumbsDisplaying=1)
      Return

   If blockBrokenIMGrefresh()
      Return

   whichBitmap := useGdiBitmap()
   If validBMP(whichBitmap)
   {
      trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
      Gdip_GetRotatedDimensions(imgW, imgH, 45, ResizedW, ResizedH)
      If (isImgSizeTooLarge(ResizedW, ResizedH) && vpIMGrotation=0)
      {
         vpIMGrotation := 0
         If (viewportQPVimage.imgHandle)
            showTOOLtip("WARNING: The image cannot be rotated in the viewport.`nTo rotate the image itself go to Image > Transform menu`nand select Rotate by 90°.")
         Else
            showTOOLtip("ERROR: The image dimensions exceed the maximum limits.`nThe image cannot be rotated in the viewport.")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   } Else Return

   resetSlideshowTimer()
   value2Adjust := vpIMGrotation
   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   If (doReset=1)
      value2Adjust := 0
   Else
      value2Adjust := clampInRange(value2Adjust, 0, 360 - stepu, 1)

   vpIMGrotation := value2Adjust
   SetTimer, RefreshImageFile, -750
   dummyChangeVProtation()
}

dummyChangeVProtation() {
   showTOOLtip("Image rotation: " vpIMGrotation "° ", "changeImgRotationInVP", 2, vpIMGrotation/360)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "vpIMGrotation", "General")
   GdipCleanMain(4)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, vpIMGrotation, % vpIMGrotation
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

MenuNextDesiredFrame() {
    changeDesiredFrame(1)
}

MenuPrevDesiredFrame() {
    changeDesiredFrame(-1)
}

changeDesiredFrame(dir:=1) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 || !totalFramesIndex)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If askAboutFileSave(" and the current image frame will be changed")
      Return

   DestroyGIFuWin()
   resetSlideshowTimer()
   value2Adjust := desiredFrameIndex
   If (dir=1)
      value2Adjust++
   Else
      value2Adjust--

   If (dir=-1 && value2Adjust<0)
      value2Adjust := totalFramesIndex

   value2Adjust := clampInRange(value2Adjust, 0, totalFramesIndex, 1)
   desiredFrameIndex := value2Adjust
   If (A_TickCount - lastInvoked > 350) || (dir=-1 || drawModeCzeit>450)
   {
      infoShowCurrentFrameIndex()
      lastInvoked := A_TickCount
   } Else SetTimer, infoShowCurrentFrameIndex, -400

   newValues := "a" value2Adjust currentFileIndex totalFramesIndex
   If (prevValues!=newValues)
   {
      ; ToolTip, % drawModeCzeit "==" drawModeAzeit "==" drawModeBzeit , , , 2
      If (drawModeAzeit>450)
         SetTimer, RefreshImageFile, -450
      Else
         SetTimer, RefreshImageFile, % (dir=-1) ? -95 : -5
      prevValues := newValues
   }
}

DestroyGIFuWin() {
    Critical, on
    If (mustPreventMenus=1 || simulateMenusMode=1)
       Return

    If (slideShowRunning=1 || animGIFplaying=1)
       SetTimer, ResetImgLoadStatus, -15

    interfaceThread.ahkassign("animGIFplaying", 0)
    SetTimer, autoChangeDesiredFrame, Off
    autoChangeDesiredFrame("stop")
}

restartGIFplayback() {
   If (CountGIFframes>1 && !AnyWindowOpen && animGIFsSupport=1, totalFramesIndex>1 && thumbsDisplaying!=1)
   {
      autoChangeDesiredFrame("stop", 0)
      Sleep, 5
      ; setGIFframesDelay()
      autoChangeDesiredFrame("start", getIDimage(currentFileIndex))
      SetTimer, autoChangeDesiredFrame, % GIFspeedDelay + UserGIFsDelayu
   }
}

autoChangeDesiredFrame(act:=0, imgPath:=0) {
   Critical, on
   Static prevImgPath, lastInvoked := 1, lastFrameChange := 1
   If (thumbsDisplaying=1 || act="stop" || AnyWindowOpen || animGIFsSupport!=1 || !maxFilesIndex || !CurrentSLD)
   {
      If (animGIFplaying=1)
      {
         SetTimer, autoChangeDesiredFrame, Off
         SetTimer, ResetImgLoadStatus, -50
         prevAnimGIFwas := prevImgPath
         prevImgPath := ""
         Global lastGIFdestroy := A_TickCount
         lastFrameChange := A_TickCount
         animGIFplaying := 0
         ; lastInvoked := A_TickCount
         interfaceThread.ahkassign("animGIFplaying", 0)
         ResetImgLoadStatus()
         ; dummyTimerDelayiedImageDisplay(50)
      }
      Return
   }

   If (prevImgPath!=imgPath && StrLen(imgPath)>2)
      lastInvoked := A_TickCount

   If (act="start" && imgPath && prevImgPath!=imgPath)
   {
      SetTimer, ResetImgLoadStatus, -15
      lastFrameChange := A_TickCount
      prevImgPath := imgPath
      allowNextSlide := 0
      animGIFplaying := 1
      interfaceThread.ahkassign("animGIFplaying", 1)
      interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
      Return
   } Else
   {
      Sleep, -1
      animGIFplaying := interfaceThread.ahkgetvar.animGIFplaying
      ; mustHalt := interfaceThread.ahkgetvar.mustProcessKeys
      If (animGIFplaying<=0)
      {
         SetTimer, ResetImgLoadStatus, -10
         SetTimer, autoChangeDesiredFrame, Off
         animGIFplaying := 0
         allowNextSlide := 1
         interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
         prevImgPath := ""
         If (animGIFplaying=0)
         {
            interfaceThread.ahkassign("animGIFplaying", 0)
            prevAnimGIFwas := prevImgPath
            lastFrameChange := A_TickCount
            Global lastGIFdestroy := A_TickCount
         }
         Return
      }
   }

   allowNextSlide := 0
   desiredFrameIndex++
   GIFframesPlayied++
   If (allowGIFsPlayEntirely=1 && GIFframesPlayied>totalFramesIndex-1) || (totalFramesIndex<3) || (allowGIFsPlayEntirely!=1)
      allowNextSlide := 1
   ; ToolTip, % allowGIFsPlayEntirely "--" allowNextSlide , , , 2
   prevAnimGIFwas := ""
   desiredFrameIndex := clampInRange(desiredFrameIndex, 0, totalFramesIndex, 1)
   totalZeit := A_TickCount - startZeitIMGload
   delayu := GIFspeedDelay + UserGIFsDelayu
   thisFrameDelay := (totalZeit>25 && totalFramesIndex>20) ? delayu//2 : delayu
   If (totalZeit>70 && totalFramesIndex>15) || (totalZeit>25 && totalFramesIndex>180)
      thisFrameDelay := 10
   If (thisFrameDelay<12 && totalZeit<40 && totalFramesIndex<14)
      thisFrameDelay := 11
   If (totalZeit>100 && totalFramesIndex>95)
      thisFrameDelay := 1

   If (thumbsDisplaying=1 || liveDrawingBrushTool=1 && imgEditPanelOpened=1 || drawingShapeNow=1)
      allowNextSlide := 0

   If (slideShowRunning=1 && (A_TickCount - lastInvoked>slideShowDelay + 1) && allowNextSlide=1)
   {
      ; allowNextSlide := 0
      lastInvoked := A_TickCount
      prevImgPath := ""
      interfaceThread.ahkPostFunction("theSlideShowCore", "force")
      ; theSlideShowCore()
      invokeExternalSlideshowHandler()
   } Else If (A_TickCount - lastFrameChange > thisFrameDelay)
   {
      lastFrameChange := A_TickCount
      SetTimer, RefreshImageFile, -1
   }
   interfaceThread.ahkPostFunction("infosSlideShow", slideShowRunning, SlideHowMode, animGIFplaying, allowNextSlide, runningLongOperation)
   ; interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
}

infoShowCurrentFrameIndex() {
    showTOOLtip("Image frame index: " desiredFrameIndex " / " totalFramesIndex, "changeDesiredFrame", 2, desiredFrameIndex/totalFramesIndex)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}


VPflipImgV() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   If blockBrokenIMGrefresh(1)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer()
   ForceRefreshNowThumbsList()
   FlipImgV := !FlipImgV
   friendly := (FlipImgV=1) ? "ON" : "off"
   showTOOLtip("Vertical mirroring: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgV", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgV, % FlipImgV
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

setMainCanvasTransform(W, H, G:=0, forceH:=0, forceV:=0) {
    If (thumbsDisplaying=1)
       Return

    If !G
       G := glPG

    If (FlipImgH=1 && forceH=0) || (forceH=1)
    {
       Gdip_ScaleWorldTransform(G, -1, 1)
       Gdip_TranslateWorldTransform(G, -W, 0)
    }

    If (FlipImgV=1 && forceV=0) || (forceV=1)
    {
       Gdip_ScaleWorldTransform(G, 1, -1)
       Gdip_TranslateWorldTransform(G, 0, -H)
    }
}

VPflipImgH() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   If blockBrokenIMGrefresh(1)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer()
   ForceRefreshNowThumbsList()
   FlipImgH := !FlipImgH
   friendly := (FlipImgH=1) ? "ON" : "off"
   showTOOLtip("Horizontal mirroring: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgH", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgH, % FlipImgH
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

doOpenStartFolder(ByRef didSomething:=0) {
   didSomething := 0
   If StrLen(mustOpenStartFolder)>3
   {
      ForceRefreshNowThumbsList()
      startIndex := currentFileIndex ? currentFileIndex : 1
      imgPath := getIDimage(currentFileIndex)
      If !FileRexists(imgPath)
      {
         If askAboutFileSave(" and files found in " mustOpenStartFolder "\ will be indexed.")
            Return currentFileIndex
      }
 
      didSomething := "yes"
      SLDtypeLoaded := 1
      forceProtectLoadedImg := 1
      coreOpenFolder("|" mustOpenStartFolder, 0)
      If FileRexists(imgPath)
      {
         startIndex := detectFileID(imgPath)
      } Else
      {
         startIndex := clampInRange(startIndex, 1, maxFilesIndex)
         discardSRCfileCaches()
         destroyGDIfileCache()
         discardViewPortCaches()
         disposeCacheIMGs()
         terminateIMGediting()
      }

      forceProtectLoadedImg := 0
      dummyTimerReloadThisPicture(150)
      SetTimer, TriggerMenuBarUpdate, -90
      SetTimer, createGUItoolbar, -110
   } Else
   {
      startIndex := currentFileIndex ? currentFileIndex : 1
   }
   Return startIndex
}

coreNextPrevImage(direction, startIndex, randomMode) {
   Static countSeen, prevStatus
   If (thumbsDisplaying!=1 && maxFilesIndex>1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return currentFileIndex
   }

   If StrLen(mustOpenStartFolder)>3
   {
      startIndex := doOpenStartFolder()
      currentFileIndex := startIndex
      ; Return currentFileIndex
   }

   thisState := "a" maxFilesIndex CurrentSLD SLDtypeLoaded
   If (thisState!=prevStatus || countSeen>maxFilesIndex)
      countSeen := 0

   prevStatus := thisState
   If (startIndex>=maxFilesIndex && direction=1 && thumbsDisplaying=1 && randomMode!=1)
      Return maxFilesIndex
   Else If (startIndex<2 && direction=-1 && thumbsDisplaying=1 && randomMode!=1)
      Return 1

   startZeit := A_TickCount
   If (startIndex=1 && direction=-1)
      startIndex := maxFilesIndex + 1
   Else If (startIndex=maxFilesIndex && direction=1)
      startIndex := 0

   ; canResetSeen := 0
   delayu := (slideShowDelay>3500) ? Round(slideShowDelay*0.25) : Round(slideShowDelay*0.5)
   Loop, % maxFilesIndex + 1
   {
        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        If (thisIndex>maxFilesIndex)
           thisIndex -= maxFilesIndex
        Else If (thisIndex<1)
           thisIndex := startIndex + Abs(thisIndex)

        newIndex := thisIndex
        If (randomMode=1)
        {
           z := RandyIMGids[thisIndex]
           r := getIDimage(z)
        } Else r := getIDimage(thisIndex)
        If !r
           Continue

        If (A_TickCount - startZeit>delayu)
           Break

        r := StrReplace(r, "||")
        If (mustRecordSeenImgs=1 && skipSeenImageSlides=1 && slideShowRunning=1 && allImagesWereSeen!=1)
        {
           If retrieveSeenImageDBentry(r, thisIndex)
           {
              countSeen++
              Continue
           }
        }

        ignoreFileCheck := (InStr(AprevImgCall, r) || InStr(BprevImgCall, r)) ? 1 : 0
        If (skipDeadFiles=1 && thumbsDisplaying!=1 && ignoreFileCheck!=1)
        {
           If !FileRexists(r)
              Continue
           Else
              Break
        } Else Break
   }

   ; ToolTip, % thisIndex "==" countSeen "==" delayu , , , 2
   If newIndex
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)

   If (countSeen>=maxFilesIndex - 1) || (!newIndex) ; || (allImagesWereSeen=1)
   {
      allImagesWereSeen := 1
      newIndex := (direction=-1) ? startIndex - 1 : startIndex + 1
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)
   }

   If (randomMode=1)
   {
      RandyIMGnow := newIndex
      newIndex := RandyIMGids[RandyIMGnow]
      if (newIndex>maxFilesIndex)
      {
         Random, thisIndex, 1, % maxFilesIndex
         RandyIMGids[RandyIMGnow] := thisIndex
         newIndex := thisIndex
      }
   }

   startIndex := clampInRange(startIndex, 1, maxFilesIndex, 1)
   ; msgbox, % A_ThisFunc "=" startIndex "|" newIndex
   If (!newIndex && startIndex)
      Return startIndex

   Return newIndex
}

PreviousPicture(dummy:=0, selForbidden:=0) {
   If (validBMP(UserMemBMP) && (editingSelectionNow=1 || thumbsDisplaying!=1 && currentImgModified=1) && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && thumbsDisplaying!=1 && slideShowRunning!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(-1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Left", "+Left", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

NextPicture(dummy:=0, selForbidden:=0) {
   If (validBMP(UserMemBMP) && (editingSelectionNow=1 || thumbsDisplaying!=1 && currentImgModified=1) && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && slideShowRunning!=1 && thumbsDisplaying!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Right", "+Right", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

drawInPlaceTextInBox(Gu, theString, txtOptions) {
   Return TextuToGraphics(Gu, theString, txtOptions, txtOptions.fontu, "draw2", 0, mainObju)
}

drawTextInBox(theString, fntName, theFntSize, maxW, maxH, txtColor, bgrColor, NoWrap, flippable:=0, thisTextAlign:=0, BGRopacity:="0xDD", borderu:=0) {
    startZeit := A_TickCount
    ; pBr0 := Gdip_BrushCreateSolid(bgrColor)
    If (OSDfontBolded=1)
       txtStyle .= " Bold"
    If (OSDfontItalica=1 && NoWrap=0)
       txtStyle .= " Italic"

    If !thisTextAlign
       thisTextAlign := (flippable=1 && FlipImgH=1) ? "Right" : "Left"
    Else
       thisTextAlign := Trimmer(thisTextAlign)

    borderSize := (NoWrap=1) ? Floor(theFntSize*1.2) : Floor(theFntSize*1.5)
    borderSize := borderu ? borderu : borderSize//3
    txtOptions := []
    txtOptions.x := borderSize
    txtOptions.y := borderSize
    txtOptions.w := maxW - borderSize*2
    txtOptions.h := maxH - borderSize*2
    txtOptions.Styles := txtStyle
    txtOptions.Align := thisTextAlign
    txtOptions.Color := "0xEE" txtColor
    txtOptions.Size := theFntSize
    mainObju := TextuToGraphics(G, "initing", txtOptions, fntName, "begin", 0, 0, NoWrap)
    ; ToolTip, % mainObju.hfnt "`n" mainObju.hStrFmt "`n" mainObju.hBrush , , , 2

    dims := TextuToGraphics(2NDglPG, theString, nul, fntName, "measure", 0, mainObju)
    dimsFw := clampInRange(dims.w + borderSize*2, 5, maxW)
    dimsFh := clampInRange(dims.h + borderSize*2, 5, maxH)

    clipBMPa := trGdip_CreateBitmap(A_ThisFunc, dimsFw, dimsFh, coreDesiredPixFmt)
    If validBMP(clipBMPa)
       G := trGdip_GraphicsFromImage(A_ThisFunc, clipBMPa, 5, 1)

    If (!G || !validBMP(clipBMPa))
    {
       trGdip_DisposeImage(clipBMPa, 1)
       Return
    }

    fontQuality := (theFntSize>90) ? 2 : 3
    If (theFntSize<20)
       fontQuality := 4

    Gdip_SetTextRenderingHint(G, fontQuality)
    trGdip_GraphicsClear(A_ThisFunc, G, BGRopacity bgrColor)
    ; Gdip_FillRectangle(G, pBr0, -2, -2, dimsFw + 3, dimsFh + 3)
    _E := TextuToGraphics(G, theString, txtOptions, fntName, "draw", 0, mainObju)
    ; ToolTip, % dims.w "--" dims.h "--" _E , , , 2
    If (flippable=1)
       flipBitmapAccordingToViewPort(clipBMPa, 1)

    Gdip_DeleteGraphics(G)
    ; fnOutputDebug("draw text in box: " A_TickCount - startZeit " ms")
    Return clipBMPa
}

TextuToGraphics(pGraphics, Text, OptionsObj, Font:="Arial", initMode:=0, Unit:=0, inObj:=0, NoWrap:=0) {
   Static Styles := "Regular|Bold|Italic|BoldItalic|Underline|Strikeout"
        , Alignments := "Near|Left|Centre|Center|Far|Right"
        , prevfontFam, hFontFamily, prevFontu, hFont, prevColor, pBrushu
        , prevFmtStyle, hStringFormat

   If (initMode="begin")
   {
      xpos := OptionsObj.x,  ypos := OptionsObj.y
      Width := OptionsObj.w, Height := OptionsObj.h
      Size := OptionsObj.Size

      If (prevfontFam!=Font || !hFontFamily)
      {
         If hFontFamily
         {
            Gdip_DeleteFontFamily(hFontFamily)
            hFontFamily := ""
         }

         prevfontFam := Font
         hFontFamily := Gdip_FontFamilyCreate(Font)
         If !hFontFamily
            hFontFamily := Gdip_FontFamilyCreateGeneric(1)
      }

      thisFontu := "a" hFontFamily Font OptionsObj.Styles Size Unit
      If (thisFontu!=prevFontu || !hFont)
      {
         If hFont
         {
            Gdip_DeleteFont(hFont)
            hFont := ""
         }

         Styleu := 0
         For eachStyle, valStyle in StrSplit(Styles, "|")
         {
            If RegExMatch(OptionsObj.Styles, "\b" valStyle)
               Styleu |= (valStyle != "StrikeOut") ? (A_Index - 1) : 8
         }

         ; ToolTip, % options "`n" size " == " colour , , , 2
         hFont := Gdip_FontCreate(hFontFamily, Size, Styleu, Unit)
         If hFont
            prevFontu := thisFontu
      }

      thisFmtStyle := "a" NoWrap OptionsObj.Align
      If (thisFmtStyle!=prevFmtStyle || !hStringFormat)
      {
         If hStringFormat
         {
            Gdip_DeleteStringFormat(hStringFormat)
            hStringFormat := ""
         }

         FormatStyle := (NoWrap=1) ? 0x4000 | 0x1000 : 0x4000
         hStringFormat := Gdip_StringFormatCreate(FormatStyle)
         If !hStringFormat
            hStringFormat := Gdip_StringFormatGetGeneric(1)

         If hStringFormat
         {
            Align := 0
            prevFmtStyle := thisFmtStyle
            For eachAlignment, valAlignment in StrSplit(Alignments, "|")
            {
               If RegExMatch(OptionsObj.Align, "\b" valAlignment)
                  Align |= A_Index//2.1   ; 0|0|1|1|2|2
            }

            Gdip_SetStringFormatAlign(hStringFormat, Align)
            If InStr(OptionsObj.Styles, "autotrim")
               Gdip_SetStringFormatTrimming(hStringFormat, 3)
         }
      }

      If (OptionsObj.Color!=prevColor || !pBrushu)
      {
         pBrushu := Gdip_BrushCreateSolid(OptionsObj.Color)
         If pBrushu
            prevColor := OptionsObj.Color
      }

      If !(hFontFamily && hFont && hStringFormat && pBrushu)
      {
         E := !pGraphics ? -2 : !hFontFamily ? -3 : !hFont ? -4 : !hStringFormat ? -5 : !pBrushu ? -6 : 0
         If pBrushu
         {
            Gdip_DeleteBrush(pBrushu)
            pBrushu := ""
         }

         If hStringFormat
         {
            Gdip_DeleteStringFormat(hStringFormat)
            hStringFormat := ""
         }

         If hFont
         {
            Gdip_DeleteFont(hFont)
            hFont := ""
         }

         If hFontFamily
         {
            Gdip_DeleteFontFamily(hFontFamily)
            hFontFamily := ""
         }
         return E
      }


      obju := []
      obju.x := xpos,  obju.y := ypos
      obju.w := width, obju.h := height
      ; ToolTip, % hfont "`n" hStringFormat "`n" pBrush , , , 2
      Return obju
   }

   If (initMode="measure")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ; TOOLTIP, % inObj.x "--" inObj.y "--" inObj.w "--" inObj.h , , , 2
      ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
      val := StrSplit(ReturnRC, "|")
      measure := []
      measure.x := Floor(val[1]), measure.y := Floor(val[2])
      measure.w := Ceil(val[3]), measure.h := Ceil(val[4])
      Return measure
   }

   If (initMode="draw")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
      ReturnRCtest := StrSplit(ReturnRC, "|")
      testX := Floor(ReturnRCtest[1]) - 2
      If (testX>xpos) ; error correction for different text alignments
      {
         nxpos := Floor(inObj.x - (testX - inObj.x))
         CreateRectF(RC, nxpos, inObj.y, inObj.w, inObj.h)
         ; ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
         ; MsgBox, % nxpos "--" xpos "--" ypos "`n" width "--" height "`n" ReturnRC
      }

      _E := Gdip_DrawString(pGraphics, Text, hFont, hStringFormat, pBrushu, RC)
      Return _E
   } Else if (initMode="draw2")
   {
      CreateRectF(RC, OptionsObj.x, OptionsObj.y, OptionsObj.w, OptionsObj.h)
      ; Gdip_SetClipRect(pGraphics, OptionsObj.x, OptionsObj.y, OptionsObj.w, OptionsObj.h)
      _E := Gdip_DrawString(pGraphics, Text, hFont, hStringFormat, pBrushu, RC)
      Return _E
   }

   return _E ? _E : ReturnRC
}

HardWrapTextFontBased(TextToWrap, hFont, maxW, maxH, lineHeight, vAlign, scaleuPreview) {
   ; Critical, on
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
        , maxCharsInWidth := 2048

   If (StrLen(TextToWrap)<=2)
      Return TextToWrap

   TextToWrap := Trimmer(TextToWrap)
   If (maxW<5)
   {
      kk := ""
      pp := StrSplit(TextToWrap)
      Loop, % pp.Count()
         kk .= pp[A_Index] "`n" 

      Return kk
   }

   cH := 0
   thisIndex := thisH := linez := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   hDC := Gdi_GetDC()
   old_hFont := Gdi_SelectObject(hDC, hFont)
   ; maxLinez := Ceil(maxH/lineHeight) + 1
   thisCharSpacing := (TextInAreaCharSpacing>0) ? TextInAreaCharSpacing : 0
   Loop, Parse, TextToWrap
   {
       If ((cH>maxH + lineHeight) && vAlign!=3)
          Break

       thisIndex++
       thisLineu .= A_LoopField
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
       {
          linez++
          thisLineu := ""
          cH += lineHeight
          thisIndex := hasMatchedRegEx := 0
          Continue
       }

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
          whereHasMatchedinLine := thisIndex
       }

       ; thisObj := Gdi_TruncateStringToFitWidth(hFont, A_Space thisLineu A_Space, maxW - TextInAreaCharSpacing * (StrLen(thisLineu) + 1))
       E := Gdi_GetTextExtentExPoint(hDC, A_Space thisLineu A_Space, maxW - thisCharSpacing * (StrLen(thisLineu) + 1), fitLength, w, h)
       ; fnOutputDebug(A_ThisFunc "(): " ww " x " hh " || " w " x " h)
       ; ToolTip, % thisObj.fitLength "==" thisObj.width "==" thisObj.height "==" thisObj.stringLength "`n" thisLineu, , , 2
       stringLength := StrLen(thisLineu) + 1
       If (hasMatchedRegEx=1 && (stringLength>fitLength || stringLength>maxCharsInWidth) && !isImgSizeTooLarge(w, h))
       {
          linez++
          offsetu++
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          hasMatchedRegEx := 0
          If (thisLineu=A_Space)
             thisLineu := ""
          thisLineu := SubStr(thisLineu, whereHasMatchedinLine)
          thisIndex := StrLen(thisLineu)
       } Else If (stringLength>fitLength || stringLength>maxCharsInWidth)
       {
          linez++
          thisLineu := ""
          newLinez .= "`n"
          cH += lineHeight
          thisIndex := hasMatchedRegEx := 0
       }
   }
   ; ToolTip, % maxW "|" newLinez , , , 2
   w := Gdi_SelectObject(hDC, old_hFont)
   g := Gdi_ReleaseDC(hDC, 0)
   ; ToolTip, % w "|" g "." foundPos "==" startPos, , , 2
   return newLinez
}

SimpleHardWrapText(TextToWrap, LengthLim) {
; function no longer used
; superseded by HardWrapTextFontBased()
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
   LengthLim := Round(LengthLim)
   if (LengthLim<2)
      return TextToWrap
   if (StrLen(TextToWrap) <= LengthLim + 1)
      return TextToWrap

   thisIndex := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   
   Loop, Parse, TextToWrap
   {
       thisIndex++
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
          thisIndex := hasMatchedRegEx := 0

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
       }

       If (thisIndex=LengthLim && hasMatchedRegEx=1)
       {
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          offsetu++
          thisIndex := hasMatchedRegEx := 0
       } Else If (thisIndex=LengthLim)
       {
          newLinez .= "`n"
          thisIndex := hasMatchedRegEx := 0
       }
   }

   ; ToolTip, % foundPos "==" startPos, , , 2
   return newLinez
}

Gdi_DrawTextInBox(theString, hFont, txtColor, bgrColor, marginSize:=0, scaleuPreview:=1, doFlipH:=0, doFlipV:=0, chrSpace:=0, lnAngle:=0, onlyBorder:=0, borderOut:=0, outlineSize:=0) {
    startZeit := A_TickCount
    thisCharSpacing := Round(chrSpace / scaleuPreview)
    Gdi_MeasureString(hFont, theString, 1, oW, oH)
    ; Fnt_GetMultilineStringSizeDT(hFont, theString, 1, 0, oW, oH)
    reAdjustWtxtspacing := (Abs(thisCharSpacing)//2) * StrLen(theString)
    reAdjustWtxtspacing := clampInRange(reAdjustWtxtspacing, 1, oW - 5)
    If (thisCharSpacing<0)
       oW := oW - reAdjustWtxtspacing
    Else
       oW := oW + thisCharSpacing * StrLen(theString)

    ; ToolTip, % oW "==" oH "==" reAdjustWtxtspacing , , , 2
    Gdip_GetRotatedDimensions(oW, oH, lnAngle/10, rWidth, rHeight)
    scaleu := Abs(lnAngle/900)
    scaleu2 := Abs((lnAngle*scaleu)/900)
    r_Width := rWidth + marginSize*2
    r_Height := rHeight + marginSize*2
    offsetY := (lnAngle<0) ? r_Width//2 - rWidth//2 : r_Height//2 - rHeight//2 + clampInRange(Floor(rHeight*(scaleu*1.9)), - rHeight*5, rHeight)
    offsetX := (lnAngle<0) ? r_Height//2 - rHeight//2 + Floor(rWidth*scaleu2)  : r_Width//2 - rWidth//2
    If (offsetY<(rHeight - oH + marginSize) && lnAngle>0)
       offsetY := Abs(rHeight - oH + marginSize)

    If (offsetX<marginSize)
       offsetX := marginSize

    If (onlyBorder!=1 || borderOut=1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDc, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), "0x" rgb2bgr(bgrColor))
       pBitmap := trGdip_CreateBitmapFromHBITMAP(A_ThisFunc, hbm)
       Gdi_SelectObject(hDc, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hdc)
    }

    If (outlineSize>0 && borderOut>1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDC, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextOutline(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), Round(outlineSize / scaleuPreview))
       If (borderOut=3)
          Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x000000")
       pBitmap2 := trGdip_CreateBitmapFromHBITMAP(A_ThisFunc, hbm)
       Gdi_SelectObject(hDC, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hDC)
    }

    If (validBMP(pBitmap) && doFlipH=1)
       Gdip_ImageRotateFlip(pBitmap, 4)

    If (validBMP(pBitmap2) && doFlipH=1)
       Gdip_ImageRotateFlip(pBitmap2, 4)

    If (validBMP(pBitmap) && doFlipV=1)
       Gdip_ImageRotateFlip(pBitmap, 6)

    If (validBMP(pBitmap2) && doFlipV=1)
       Gdip_ImageRotateFlip(pBitmap2, 6)

    ; trGdip_GetImageDimensions(pBitmap, imgW, imgH)
     ; ToolTip, % r_width "=" r_height "`n" hbm "==" hdc "==" obm "`n" imgW "==" imgH, , , 2
    ; fnOutputDebug("draw text in box with GDI: " A_TickCount - startZeit " ms")
    Return [pBitmap, pBitmap2]
}

applyTextTransform(theString, caseTransform) {
    Static leetSpeakDict := {"A":"4", "B":"8", "C":"¢", "D":"Ð", "E":"3", "F":"F", "G":"6", "H":"#", "I":"1", "J":"J", "K":"K", "L":"£", "M":"M", "N":"Π", "O":"0", "P":"P", "Q":"Q", "R":"Я", "S":"5", "T":"7", "U":"µ", "V":"W", "W":"V", "X":"χ", "Y":"¥", "Z":"2", "1":"I", "2":"Z", "3":"E", "4":"A", "5":"S", "6":"G", "7":"T", "8":"B", "9":"9", "0":"O", "?":"¿", "!":"¡"}
    If (caseTransform=2)
       StringUpper, theString, % theString
    Else If (caseTransform=3)
       StringLower, theString, % theString
    Else If (caseTransform=4)
       StringUpper, theString, % theString, T
    Else If (caseTransform=5)
    {
       For Key, Value in leetSpeakDict
          theString := StrReplace(theString, key, value)
    }
    Return theString
}

BTNapplyCaseTransfm() {
   Gui, SettingsGUIA: Default
   GuiControlGet, UserTextArea
   GuiControlGet, TextInAreaCaseTransform
   theString := applyTextTransform(UserTextArea, TextInAreaCaseTransform)
   GuiControl, SettingsGUIA:, UserTextArea, % theString
   TextInAreaCaseTransform := 1
   GuiControl, SettingsGUIA: Choose, TextInAreaCaseTransform, 1
}

coreInsertTextInAreaBox(theString, maxW, maxH, previewMode, cropYa:=0, cropYb:=0, allowCrop:=0) {
    Static OBJ_FONT := 6, testString := "This is going to be a test"
    Static cachedRawTXTbmps := []
    If (theString=0 && maxW="kill")
    {
       Loop, % cachedRawTXTbmps.Count()
       {
          trGdip_DisposeImage(cachedRawTXTbmps[A_Index, 1])
          trGdip_DisposeImage(cachedRawTXTbmps[A_Index, 2])
       }
       cachedRawTXTbmps := []
       Return
    }

    startZeit := A_TickCount
    theString := applyTextTransform(theString, TextInAreaCaseTransform)
    If StrLen(theString)<1
       Return "fail"

    txtColor := makeRGBAcolor(TextInAreaFontColor, TextInAreaFontOpacity)
    bgrColor := makeRGBAcolor(TextInAreaBgrColor, TextInAreaBgrOpacity)
    borderColor := makeRGBAcolor(TextInAreaBorderColor, TextInAreaBorderOpacity)

    fntQuality := (previewMode=1) ? 1 : 4
    fntWeight := (TextInAreaFontBold=1) ? 800 : 400
    thisFactor := (zoomLevel<1) ? 1 - zoomLevel*2 + 1.25 : zoomLevel/2
    thisFactor += TextInAreaFontSize/80
    If (TextInAreaFontSize<14)
       thisFactor := 1
    Else If (zoomLevel>4)
       thisFactor := (TextInAreaFontSize>30 && previewMode=1) ? 2 : 1
    Else
       thisFactor := clampInRange(thisFactor, 1.3, 13)
    ; ToolTip, % "z=" thisFactor "|" zoomLevel , , , 2

    thisLineAngle := 0
    hFont := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    If (Gdi_GetObjectType(hFont)!="FONT")
       Return "fail"

    hFontPreview := (thisFactor=1) ? Gdi_CloneFont(hFont) : Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize//thisFactor, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    thisBlurAmount := (TextInAreaDoBlurs=1) ? max(TextInAreaBlurAmount, TextInAreaBlurBorderAmount) // 2 : 0
    obs := borderSize := (TextInAreaBorderOut>1) ? TextInAreaBorderSize//2 + thisBlurAmount : thisBlurAmount
    If (TextInAreaUsrMarginz>1)
       obs := borderSize := TextInAreaUsrMarginz 
    Gdi_MeasureString(hFont, testString, 1, testWa, testHa)
    Gdi_MeasureString(hFontPreview, testString, 1, testWb, testHb)
    ; ToolTip, % "l=" testWa "|" testWb , , , 2
    scaleuPreview := (previewMode=1 && thisFactor!=1) ? testWa/testWb : 1
    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1)
       lnSpace := (previewMode=1) ? Round(TextInAreaFontLineSpacing / scaleuPreview) : TextInAreaFontLineSpacing
    Else
       lnSpace := (previewMode=1) ? Round((TextInAreaFontLineSpacing - borderSize*2) / scaleuPreview) : TextInAreaFontLineSpacing - borderSize * 2
    theString := StrReplace(theString, "`n`n", "`n┘")
    thisLnHeight := (previewMode=1) ? testHb + lnSpace : testHa + lnSpace
    If (thisLnHeight<1)
       thisLnHeight := 1
    ; ToolTip, % lnSpace "|" thisLnHeight , , , 2
    If (TextInAreaAutoWrap=1)
       theString := Trimmer(HardWrapTextFontBased(theString, hFont, maxW - borderSize * 2, maxH + 2, thisLnHeight, TextInAreaValign, scaleuPreview))
    Else
       theString := Trimmer(theString)
       ; theString := Trimmer(HardWrapTextFontBased(theString, hFont, 42600 - borderSize * 2, 42600, thisLnHeight, TextInAreaValign, scaleuPreview))

    textArray := StrSplit(theString, "`n")
    totalLinez := textArray.Count()
    maxW := Round(maxW / scaleuPreview)
    maxH := Round(maxH / scaleuPreview)
    If (totalLinez=1 && TextInAreaValign=2)
    {
       oneLiner := 1
       omH := maxH
       maxH := (previewMode=1) ? Round((testHa + borderSize*2) / scaleuPreview) : testHa + borderSize*2
    }
    ; ToolTip, % maxH "|" testHa "|" borderSize , , , 2
    cropYa := Round(cropYa / scaleuPreview)
    cropYb := Round(cropYb / scaleuPreview)
    If (previewMode=1)
       borderSize := Round(borderSize/scaleuPreview)
    ; p := capIMGdimensionsFormatlimits("gdip", 0, maxW, maxH)
    scaleuBlrPreview := (previewMode=1) ? (borderSize*4 + testWb + testHb)/(obs*4 + testWa + testHa) : 1
    If (isImgSizeTooLarge(maxW, maxH) && previewMode=1)
    {
       addJournalEntry(A_ThisFunc "(). ERROR. Cannot generate text preview. Bitmap too large: " maxW " x " maxH)
       Gdi_DeleteObject(hFont)
       Gdi_DeleteObject(hFontPreview)
       Return "fail"
    }

    ; ToolTip, % thisFactor "==" scaleuPreview "|" maxW "|" maxH , , , 2
    ; ToolTip, % testWa "==" testHa "`n" testWb "==" testHb "`n" testWa/testWb , , , 2
    mainBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, coreDesiredPixFmt)
    If warnUserFatalBitmapError(mainBMP, A_ThisFunc)
    {
       Gdi_DeleteObject(hFont)
       Gdi_DeleteObject(hFontPreview)
       Return "fail"
    }

    thisBlur := Round(TextInAreaBlurAmount * scaleuBlrPreview)
    doEffect := (thisBlur>0 && TextInAreaDoBlurs=1 && !isWinXP) ? 1 : 0
    ; ToolTip, % thisBlur "`n" scaleuBlrPreview "`n" scaleuPreview , , , 2
    thisBorderBlur := Round(TextInAreaBlurBorderAmount * scaleuBlrPreview)
    zBrush := Gdip_BrushCreateSolid(bgrColor)
    thisQuality := (previewMode=1) ? 5 : 7
    G := trGdip_GraphicsFromImage(A_ThisFunc, mainBMP, thisQuality)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G, 2)

    doConturDraw := (TextInAreaBorderSize>0 && TextInAreaBorderOut>1) ? 1 : 0
    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
    {
       If (doConturDraw=1 && TextInAreaOnlyBorder=0)
       {
          contoursBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, coreDesiredPixFmt)
          Gz := trGdip_GraphicsFromImage(A_ThisFunc, contoursBMP, thisQuality)
       }
       o_txtColor := txtColor
       txtColor := "0xFFffFFff"
       trGdip_GraphicsClear(A_ThisFunc, G, "0xFF000000")
    }

    thisY := (TextInAreaValign=3) ? maxH : 0
    prevY := thisX := maxedW := maxedH := skippedLines := 0
    minedX := maxW, minedY := maxH

    rescaleWidthCharSpacing := (TextInAreaCharSpacing<0) ? (100 - Abs(TextInAreaCharSpacing))/90 : 1
    allowOpti := (previewMode!=1 || VPselRotation!=0 || TextInAreaValign=2) ? 0 : 1
    thisHFont := (previewMode=1) ? hFontPreview : hFont
    threads := (previewMode=1) ? realSystemCores : 0
    prevImgH := imgH := (previewMode=1) ? testHb : testHa
    prevImgW := imgW := (previewMode=1) ? testWb : testWa
    Loop, % totalLinez
    {
       thisuString := (TextInAreaValign=3) ? textArray[totalLinez - A_Index + 1] : textArray[A_Index]
       If !Trimmer(thisuString)
          Continue

       wasCachedLine := 0
       thisuString := StrReplace(thisuString, "┘", " `n")
       pzYa := (TextInAreaValign=3) ? thisY : thisY + prevImgH
       pzYb := (TextInAreaValign=3) ? thisY - prevImgH : thisY
       lineVisible := (((pzYa<=cropYa) || pzYb>=cropYb) && allowOpti=1 && allowCrop=1 && A_Index>1) ? 0 : 1
       thisTXTid := "a" thisuString borderSize scaleuPreview TextInAreaFlipH TextInAreaFlipV TextInAreaCharSpacing TextInAreaOnlyBorder TextInAreaBorderOut TextInAreaBorderSize "||" TextInAreaFontName TextInAreaFontSize fntWeight TextInAreaFontItalic TextInAreaFontStrike TextInAreaFontUline fntQuality thisLineAngle TextInAreaCaseTransform TextInAreaValign
       thisPartialTXTid := "a" thisuString borderSize scaleuPreview TextInAreaCharSpacing TextInAreaBorderSize "||" TextInAreaFontSize fntWeight thisLineAngle TextInAreaValign
       If ((cachedRawTXTbmps[A_Index, 3]=thisTXTid && lineVisible=1 || cachedRawTXTbmps[A_Index, 4]=thisPartialTXTid && lineVisible=0) && previewMode=1)
       {
          aa := validBMP(cachedRawTXTbmps[A_Index, 1]) ? trGdip_CloneBitmap(A_ThisFunc, cachedRawTXTbmps[A_Index, 1]) : 0
          bb := validBMP(cachedRawTXTbmps[A_Index, 2]) ? trGdip_CloneBitmap(A_ThisFunc, cachedRawTXTbmps[A_Index, 2]) : 0
          objBMPs := [aa, bb]
          wasCachedLine := (validBMP(aa) || validBMP(bb)) ? 1 : 0
          fnOutputDebug(lineVisible "= visible | cached txt line=" A_Index "|" totalLinez)
          If !wasCachedLine
             fnOutputDebug(lineVisible "= visible | incorrect cached txt line=" A_Index)
       }

       If !wasCachedLine
       {
          cachedRawTXTbmps[A_Index, 1] := trGdip_DisposeImage(cachedRawTXTbmps[A_Index, 1])
          cachedRawTXTbmps[A_Index, 2] := trGdip_DisposeImage(cachedRawTXTbmps[A_Index, 2])
          srr := (lineVisible=1) ? thisuString : SubStr(thisuString, 1, 2)
          fnOutputDebug("render txt line=" A_Index " / " totalLinez " | visible= " lineVisible)
          objBMPs := Gdi_DrawTextInBox(srr, thisHFont, "FFffFF", "000000", borderSize, scaleuPreview, TextInAreaFlipH, TextInAreaFlipV, TextInAreaCharSpacing, 0, TextInAreaOnlyBorder, TextInAreaBorderOut, TextInAreaBorderSize)
          If (previewMode=1)
          {
             thisPartialTXTid := "a" srr borderSize scaleuPreview TextInAreaCharSpacing TextInAreaBorderSize "||" TextInAreaFontSize fntWeight thisLineAngle TextInAreaValign
             thisTXTid := "a" srr borderSize scaleuPreview TextInAreaFlipH TextInAreaFlipV TextInAreaCharSpacing TextInAreaOnlyBorder TextInAreaBorderOut TextInAreaBorderSize "||" TextInAreaFontName TextInAreaFontSize fntWeight TextInAreaFontItalic TextInAreaFontStrike TextInAreaFontUline fntQuality thisLineAngle TextInAreaCaseTransform TextInAreaValign
             aa := validBMP(objBMPs[1]) ? trGdip_CloneBitmap(A_ThisFunc, objBMPs[1]) : 0
             bb := validBMP(objBMPs[2]) ? trGdip_CloneBitmap(A_ThisFunc, objBMPs[2]) : 0
             cachedRawTXTbmps[A_Index] := [aa, bb, thisTXTid, thisPartialTXTid]
          }
       }

       If validBMP(objBMPs[1])
          trGdip_GetImageDimensions(objBMPs[1], imgW, imgH)
       Else
          trGdip_GetImageDimensions(objBMPs[2], imgW, imgH)

       pBitmap := (doConturDraw=1 && TextInAreaOnlyBorder=1 && validBMP(objBMPs[2])) ? objBMPs[2] : objBMPs[1]
       If (doConturDraw=1 && validBMP(objBMPs[1]) && TextInAreaOnlyBorder=1 && pBitmap!=objBMPs[1])
          trGdip_DisposeImage(objBMPs[1])

       thisBMP := pBitmap
       pBitmapContours := objBMPs[2]
       If (imgW>maxW && validBMP(thisBMP))
       {
          thisBMP := resizeBitmapToGivenRef(thisBMP, 0, maxW, imgH, 3, 1)
          trGdip_GetImageDimensions(thisBMP, imgW, imgH)
          If validBMP(pBitmapContours)
             pBitmapContours := resizeBitmapToGivenRef(pBitmapContours, 0, maxW, imgH, 3, 1)
       }

       If !validBMP(thisBMP)
       {
          fnOutputDebug(A_ThisFunc "(): an error occured rendering txt line=" A_Index)
          imgW := prevImgW, imgH := prevImgH
          ; trGdip_DisposeImage(pBitmapContours)
          ; addJournalEntry(A_ThisFunc "(): ERROR. No valid bitmap generated for text line = " A_Index)
          ; Continue
       } Else If (lineVisible=1)
       {
          If (doEffect && (TextInAreaBgrUnified!=1 || TextInAreaPaintBgr!=1))
             QPV_BoxBlurBitmap(thisBMP, thisBlur, thisBlur, 0)
          Gdip_BitmapConvertFormat(thisBMP, 0xE200B, 2, 1, 0, 0, 0, 0, 0)
          ; fnOutputDebug(Gdip_GetImagePixelFormat(pBitmap, 3))
          If (TextInAreaCutOutMode=1 && TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1)
          {
             QPV_SetColorAlphaChannel(thisBMP, bgrColor, 1)
          } Else
          {
             thisColor := (TextInAreaOnlyBorder=1 && TextInAreaBorderOut>1) ? borderColor : txtColor
             If (TextInAreaOnlyBorder=1 && TextInAreaBorderOut>1 && TextInAreaBgrUnified=1 && TextInAreaPaintBgr=1)
                thisColor := txtColor
   
             QPV_SetColorAlphaChannel(thisBMP, thisColor, 0)
          }
       }

       forceW := (imgW>=maxW) ? maxW : imgW
       thisXbonus := (imgW>maxW) ? imgW - maxW : 0
       If (rescaleWidthCharSpacing<1)
       {
          phorceW := Round(forceW*rescaleWidthCharSpacing)
          forceW -= (forceW - phorceW)//2.5
       }

       If (TextInAreaAlign=2)
          thisX := Round(maxW/2 - imgW/2 + thisXbonus/2)
       Else If (TextInAreaAlign=3)
          thisX := maxW - imgW + thisXbonus

       If (TextInAreaValign=3)
       {
          thisY := thisY - imgH - lnSpace
          If (thisY>prevY)
             thisY := maxH - imgH
       }

       isOkay := (thisuString=" `n" && TextInAreaPaintBgr=1 && TextInAreaBgrEntire=0 && TextInAreaBgrUnified=0) ? 0 : 1
       If (TextInAreaBgrUnified!=1 && TextInAreaPaintBgr=1 && lineVisible=1 && validBMP(thisBMP))
       {
          If (TextInAreaCutOutMode!=1 && isOkay=1)
             Gdip_FillRectangle(G, zBrush, thisX, thisY, imgW, imgH)

          If (TextInAreaBgrEntire=1)
          {
             Gdip_SetClipRect(G, 0, thisY, maxW, imgH)
             Gdip_SetClipRect(G, thisX, thisY, imgW, imgH, 4)
             Gdip_FillRectangle(G, zBrush, 0, thisY, maxW, imgH)
             Gdip_ResetClip(G)
          }
       }

       maxedW := max(forceW, maxedW)
       maxedH := max(thisY + imgH, maxedH)
       minedX := min(thisX, minedX)
       minedY := min(thisY, minedY)
       If (isOkay && lineVisible=1 && validBMP(thisBMP))
          drawFail := trGdip_DrawImage(A_ThisFunc, G, thisBMP, thisX, thisY, forceW, imgH)

       If (doConturDraw=1 && TextInAreaOnlyBorder!=1 && validBMP(pBitmapContours) && lineVisible=1)
       {
          Gdip_BitmapConvertFormat(pBitmapContours, 0xE200B, 2, 1, 0, 0, 0, 0, 0)
          If (thisBorderBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
             QPV_BoxBlurBitmap(pBitmapContours, thisBorderBlur, thisBorderBlur, 0)

          QPV_SetColorAlphaChannel(pBitmapContours, borderColor, 0)
          Guu := (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1) ? Gz : G
          trGdip_DrawImage(A_ThisFunc, Guu, pBitmapContours, thisX, thisY, forceW, imgH)
          pBitmapContours := trGdip_DisposeImage(pBitmapContours, 1)
       }

       If (TextInAreaValign!=3)
       {
          thisY := thisY + imgH + lnSpace
          If (thisY<prevY)
             thisY := prevY + 2
       }

       ; fnOutputDebug("line #/Y:" A_Index "|" thisY "|" maxH "|" thisuString)
       thisBMP := trGdip_DisposeImage(thisBMP, 1)
       If validBMP(pBitmapContours)
          pBitmapContours := trGdip_DisposeImage(pBitmapContours, 1)

       prevY := thisY
       If (drawFail="fail")
       {
          fattalErr := 1
          Break
       }

       ; fnOutputDebug("thisY=" thisY "|| " (cropH + cropY)*scaleuPreview "||" maxH)
       prevImgW := imgW,       prevImgH := imgH
       If (thisY>maxH && TextInAreaValign!=3 || (thisY + imgH)<0 && TextInAreaValign=3)
       {
          fnOutputDebug("text outside selection boundaries: " thisY "||" maxH)
          Break
       }
    }

    If (fattalErr=1)
       warnUserFatalBitmapError("no-gdip", A_ThisFunc)

    Gdi_DeleteObject(hFont)
    Gdi_DeleteObject(hFontPreview)
    minedX := clampInRange(minedX, 0, maxW)
    minedY := clampInRange(minedY, 0, maxH)
    maxedW := clampInRange(maxedW, 1, maxW)
    maxedH := clampInRange(maxedH, 1, maxH)
    If (TextInAreaValign=3)
       maxedH := clampInRange(maxedH - minedY, 1, maxH)

    If (oneLiner=1 && omH<maxH)
    {
       minedY := (maxH - omH)/2
       maxedH := clampInRange(maxedH - (maxH - omH), omH, maxedH)
    }

    If (Gz || contoursBMP)
       Gdip_DeleteGraphics(Gz)

    newBMP := "-"
    Gdip_DeleteGraphics(G)
    ; ToolTip, % maxedW "==" maxedH " = " minedX "==" minedY , , , 2
    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
    {
       newBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, coreDesiredPixFmt)
       warnUserFatalBitmapError(newBMP, A_ThisFunc)
    }

    If validBMP(newBMP)
    {
       If (TextInAreaBgrOpacity>4)
       {
          thisColoru := MixARGB(bgrColor, "0xFF" TextInAreaFontColor, TextInAreaFontOpacity/255)
       } Else If (TextInAreaBgrOpacity>3)
       {
          thisColorA := MixARGB(bgrColor, "0xFF" TextInAreaFontColor, TextInAreaFontOpacity/255)
          thisColoru := MixARGB(o_txtColor, thisColorA, 0.75)
       } Else If (TextInAreaBgrOpacity>2)
       {
          thisColorA := MixARGB(bgrColor, "0xFF" TextInAreaFontColor, TextInAreaFontOpacity/255)
          thisColoru := MixARGB(o_txtColor, thisColorA, 0.5)
       } Else If (TextInAreaBgrOpacity>1)
       {
          thisColorA := MixARGB(bgrColor, "0xFF" TextInAreaFontColor, TextInAreaFontOpacity/255)
          thisColoru := MixARGB(o_txtColor, thisColorA, 0.25)
       } Else
          thisColoru := o_txtColor

       o_txtColor := (TextInAreaCutOutMode=1) ? "0x00" TextInAreaBgrColor : thisColoru
       If (doConturDraw=1 && TextInAreaOnlyBorder=1)
          o_txtColor := (TextInAreaCutOutMode=1) ? "0x00" TextInAreaBgrColor : borderColor

       If doEffect
          QPV_BoxBlurBitmap(mainBMP, thisBlur, thisBlur, 0)

       QPV_ColorizeGrayImage(mainBMP, o_txtColor, bgrColor, userimgGammaCorrect)
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBMP)
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G3, 2)

       If (TextInAreaRoundBoxBgr=1)
       {
          oor := FillAreaRectRoundness
          FillAreaRectRoundness := 33
          kPath := coreCreateFillAreaShape(minedX, minedY, maxedW, maxedH, 2, 0, 0, 2, 0)
          FillAreaRectRoundness := oor
          Gdip_SetClipPath(G3, kPath)
          Gdip_DeletePath(kPath)
       } Else
       {
          Gdip_SetClipRect(G3, minedX, minedY, maxedW, maxedH)
          ; trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
       }

       trGdip_DrawImage(A_ThisFunc, G3, mainBMP, 0, 0)
       If validBMP(contoursBMP)
          trGdip_DrawImage(A_ThisFunc, G3, contoursBMP, 0, 0)
       Gdip_ResetClip(G3)
       ; QPV_SetBitmapAsAlphaChannel(newBMP, mainBMP, TextInAreaCutOutMode)
       trGdip_DisposeImage(mainBMP, 1)
       Gdip_DeleteGraphics(G3)
       mainBMP := newBMP
    }

    Gdip_DeleteBrush(zBrush)
    trGdip_DisposeImage(contoursBMP)
    obju := [mainBMP, minedX, minedY, maxedW, maxedH, scaleuPreview, skippedLines]
    fnOutputDebug(A_ThisFunc "(): text rendered in: " A_TickCount - startZeit)
    Return obju
} ; // coreInsertTextInAreaBox()

coreInsertTextHugeImages(theString, maxW, maxH) {
    Static OBJ_FONT := 6, testString := "This is going to be a test"
    startZeit := A_TickCount
    theString := applyTextTransform(theString, TextInAreaCaseTransform)
    txtColor := makeRGBAcolor(TextInAreaFontColor, TextInAreaFontOpacity)
    bgrColor := makeRGBAcolor(TextInAreaBgrColor, TextInAreaBgrOpacity)
    borderColor := makeRGBAcolor(TextInAreaBorderColor, TextInAreaBorderOpacity)
    fntQuality := 4
    thisLineAngle := 0
    thisFactor := scaleuPreview := scaleuBlrPreview := 1
    fntWeight := (TextInAreaFontBold=1) ? 800 : 400
    hFont := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    If (Gdi_GetObjectType(hFont)!="FONT")
       Return "fail"

    thisBlurAmount := (TextInAreaDoBlurs=1) ? max(TextInAreaBlurAmount, TextInAreaBlurBorderAmount) // 2 : 0
    obs := borderSize := (TextInAreaBorderOut>1) ? TextInAreaBorderSize//2 + thisBlurAmount : thisBlurAmount
    If (TextInAreaUsrMarginz>1)
       obs := borderSize := TextInAreaUsrMarginz 
    Gdi_MeasureString(hFont, testString, 1, testWa, testHa)
    lnSpace := (TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1) ? TextInAreaFontLineSpacing : TextInAreaFontLineSpacing - borderSize*2
    theString := StrReplace(theString, "`n`n", "`n┘")
    thisLnHeight := testHa + lnSpace
    If (thisLnHeight<1)
       thisLnHeight := 1

    If (TextInAreaAutoWrap=1)
       theString := Trimmer(HardWrapTextFontBased(theString, hFont, maxW - borderSize * 2, maxH + 2, thisLnHeight, TextInAreaValign, scaleuPreview))
    Else
       theString := Trimmer(theString)

    textArray := StrSplit(theString, "`n")
    totalLinez := textArray.Count()
    maxW := Round(maxW)
    maxH := Round(maxH)
    If (totalLinez=1 && TextInAreaValign=2)
    {
       oneLiner := 1
       omH := maxH
    }

    ; ToolTip, % thisFactor "==" scaleuPreview "|" maxW "|" maxH , , , 2
    ; ToolTip, % testWa "==" testHa "`n" testWb "==" testHb "`n" testWa/testWb , , , 2
    thisBlur := Round(TextInAreaBlurAmount * scaleuBlrPreview)
    doEffect := (thisBlur>0 && TextInAreaDoBlurs=1 && !isWinXP) ? 1 : 0
    ; ToolTip, % thisBlur "`n" scaleuBlrPreview "`n" scaleuPreview , , , 2
    thisBorderBlur := Round(TextInAreaBlurBorderAmount * scaleuBlrPreview)
    prevY := thisY := (TextInAreaValign=3) ? maxH : 0
    rendered := thisX := maxedW := maxedH := 0
    minedX := maxW, minedY := maxH
    doConturDraw := (TextInAreaBorderSize>0 && TextInAreaBorderOut>1) ? 1 : 0
    rescaleWidthCharSpacing := (TextInAreaCharSpacing<0) ? (100 - Abs(TextInAreaCharSpacing))/90 : 1
    thisHFont := hFont
    cachedRawTXTbmps := []
    showTOOLtip("Applying insert text, please wait...`nRendering text lines")
    Loop, % totalLinez
    {
       thisuString := (TextInAreaValign=3) ? textArray[totalLinez - A_Index + 1] : textArray[A_Index]
       If !Trimmer(thisuString)
          Continue

       thisuString := StrReplace(thisuString, "┘", " `n")
       ; fnOutputDebug("render txt line=" A_Index)
       objBMPs := Gdi_DrawTextInBox(thisuString, thisHFont, "FFffFF", "000000", borderSize, scaleuPreview, TextInAreaFlipH, TextInAreaFlipV, TextInAreaCharSpacing, 0, TextInAreaOnlyBorder, TextInAreaBorderOut, TextInAreaBorderSize)
       thisBMP := objBMPs[1]
       pBitmapContours := objBMPs[2]
       If validBMP(thisBMP)
          trGdip_GetImageDimensions(thisBMP, imgW, imgH)
       Else
          trGdip_GetImageDimensions(pBitmapContours, imgW, imgH)

       If (!validBMP(thisBMP) && !validBMP(pBitmapContours))
       {
          fnOutputDebug(A_ThisFunc "(): an error occured rendering txt line=" A_Index)
       } Else
       {
          If (imgW>maxW)
          {
             thisBMP := resizeBitmapToGivenRef(thisBMP, 0, maxW, imgH, 3, 1)
             pBitmapContours := resizeBitmapToGivenRef(pBitmapContours, 0, maxW, imgH, 3, 1)
             If validBMP(thisBMP)
                trGdip_GetImageDimensions(thisBMP, imgW, imgH)
             Else
                trGdip_GetImageDimensions(pBitmapContours, imgW, imgH)
          }

          If validBMP(pBitmapContours)
          {
             If (thisBorderBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
                QPV_BoxBlurBitmap(thisBMP, thisBorderBlur, thisBorderBlur, 0)

             Gdip_ImageRotateFlip(pBitmapContours, 6)
             Gdip_BitmapSetColorDepth(pBitmapContours, 32)
          }

          If validBMP(thisBMP)
          {
             If doEffect
                QPV_BoxBlurBitmap(thisBMP, thisBlur, thisBlur, 0)

             Gdip_ImageRotateFlip(thisBMP, 6)
             Gdip_BitmapSetColorDepth(thisBMP, 32)
          }
       }

       forceW := (imgW>maxW) ? maxW : imgW
       thisXbonus := (imgW>maxW) ? imgW - maxW : 0
       If (rescaleWidthCharSpacing<1)
       {
          phorceW := Round(forceW*rescaleWidthCharSpacing)
          forceW -= (forceW - phorceW)//2.5
       }

       If (TextInAreaAlign=2)
          thisX := Round(maxW/2 - imgW/2 + thisXbonus/2)
       Else If (TextInAreaAlign=3)
          thisX := maxW - imgW + thisXbonus

       If (TextInAreaValign=3)
       {
          thisY := thisY - imgH - lnSpace
          If (thisY>prevY)
             thisY := maxH - imgH 
       }

       maxedW := max(forceW, maxedW)
       maxedH := max(thisY + imgH, maxedH)
       minedX := min(thisX, minedX)
       minedY := min(thisY, minedY)
       If (validBMP(thisBMP) || validBMP(pBitmapContours))
       {
          rendered++
          cachedRawTXTbmps[rendered] := [thisBMP, pBitmapContours, thisX, thisY, imgW, imgH]
       }

       If (TextInAreaValign!=3)
       {
          thisY := thisY + imgH + lnSpace
          If (thisY<prevY)
             thisY := prevY + 2
       }

       ; fnOutputDebug("line #/Y:" A_Index "|" thisY "|" maxH "|" thisuString)
       prevY := thisY
       If (drawFail="fail")
       {
          fattalErr := 1
          Break
       }

       ; fnOutputDebug("thisY=" thisY "|| " (cropH + cropY)*scaleuPreview "||" maxH)
       If (thisY>maxH && TextInAreaValign!=3 || thisY<0 && TextInAreaValign=3)
       {
          fnOutputDebug("text outside selection boundaries: " thisY "||" maxH)
          Break
       }
    }

    minedX := clampInRange(minedX, 0, maxW)
    minedY := clampInRange(minedY, 0, maxH)
    maxedW := clampInRange(maxedW, 1, maxW)
    maxedH := clampInRange(maxedH, 1, maxH)
    hha := maxedH
    nmaxH := testHa + borderSize*2
    If (TextInAreaValign=3)
    {
       maxedH := clampInRange(maxedH - minedY, 1, maxH)
       maxedH -= Round(lnSpace)
       hha := maxedH
       maxedH := clampInRange(maxedH, 1, maxH)
    } Else If (oneLiner=1 && omH<nmaxH)
    {
       oneLiner := 2
       minedY := (nmaxH - omH)//2
    }

    hFIFimgA := FreeImage_Allocate(maxedW, maxedH, 32)
    FreeImage_GetImageDimensions(hFIFimgA, mImgW, mImgH)
    bpp := FreeImage_GetBPP(hFIFimgA)
    pBitsAll := FreeImage_GetBits(hFIFimgA)
    Stride := FreeImage_GetStride(hFIFimgA)

    showTOOLtip("Applying insert text, please wait...`nColouring text lines")
    Loop, % rendered
    {
       If fattalErr
          Break

       thisBMP := cachedRawTXTbmps[A_Index, 1]
       pBitmapContours := cachedRawTXTbmps[A_Index, 2]
       imgW := mw := cachedRawTXTbmps[A_Index, 5]
       imgH := mh := cachedRawTXTbmps[A_Index, 6]
       thisX := cachedRawTXTbmps[A_Index, 3] - minedX
       thisY := cachedRawTXTbmps[A_Index, 4] - minedY - abs(maxedH - hha)
       cachedRawTXTbmps[A_Index, 3] := thisX
       cachedRawTXTbmps[A_Index, 4] := thisY
       ; fnOutputDebug(A_ThisFunc " loop rendered " A_Index "|" mw "|" mh "|" thisX "|" thisY)
       If validBMP(thisBMP)
       {
          If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
             Sleep, -1
          Else If (TextInAreaCutOutMode=1 && TextInAreaPaintBgr=1)
             QPV_ColorizeGrayImage(thisBMP, "0x00" TextInAreaBgrColor, bgrColor, 0)
          Else
             QPV_ColorizeGrayImage(thisBMP, "0xFF" TextInAreaFontColor, "0x00" TextInAreaFontColor, 0)
       }

       If (validBMP(thisBMP) || validBMP(pBitmapContours))
       {
          If (TextInAreaPaintBgr=1 && TextInAreaCutOutMode!=1 && TextInAreaBgrUnified!=1)
             r := DllCall(whichMainDLL "\DrawBitmapInPlace", "UPtr", pBitsAll, "Int", mImgW, "Int", mImgH, "int", Stride, "int", bpp, "int", 255, "int", userimgGammaCorrect, "int", 0, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha, "UPtr", 0, "int", bgrColor, "int", 32, "int", thisX, "int", thisY, "int", mw, "int", mh)

          If validBMP(thisBMP)
          {
             EZ := 1
             If !(TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1 && TextInAreaCutOutMode=1 && TextInAreaOnlyBorder=1 && TextInAreaBorderOut>1)
                EZ := Gdip_LockBits(thisBMP, 0, 0, mw, mh, mStride, mScan, mData, 1)

             If !EZ
             {
                bmpOpacity := (TextInAreaCutOutMode=1 && TextInAreaPaintBgr=1 || TextInAreaBgrUnified=1) ? 255 : TextInAreaFontOpacity
                thisBlendMode := (TextInAreaBgrUnified=1) ? 5 : 0
                r := DllCall(whichMainDLL "\DrawBitmapInPlace", "UPtr", pBitsAll, "Int", mImgW, "Int", mImgH, "int", Stride, "int", bpp, "int", bmpOpacity, "int", userimgGammaCorrect, "int", thisBlendMode, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha, "UPtr", mScan, "int", mStride, "int", 32, "int", thisX, "int", thisY, "int", mw, "int", mh)
                ; fnOutputDebug(A_Index " rendered thisBMP")
                Gdip_UnlockBits(thisBMP, mData)
             }
             thisBMP := trGdip_DisposeImage(thisBMP)
          }

          thisBMP := pBitmapContours
          If (validBMP(thisBMP) && TextInAreaBgrUnified!=1)
          {
             If (TextInAreaCutOutMode=1 && TextInAreaOnlyBorder=1 && TextInAreaBorderOut>1 && TextInAreaPaintBgr=1 && TextInAreaBgrUnified=0)
                QPV_ColorizeGrayImage(thisBMP, "0x00" TextInAreaBgrColor, "0xFF" TextInAreaBgrColor, 0)
             Else If !(TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
                QPV_ColorizeGrayImage(thisBMP, "0xFF" TextInAreaBorderColor, "0x00" TextInAreaBorderColor, 0)

             EZ := Gdip_LockBits(thisBMP, 0, 0, mw, mh, mStride, mScan, mData, 1)
             If !EZ
             {
                bmpOpacity := (TextInAreaBgrUnified=1) ? 255 : TextInAreaBorderOpacity
                thisBlendMode := (TextInAreaBgrUnified=1) ? 5 : 0
                r := DllCall(whichMainDLL "\DrawBitmapInPlace", "UPtr", pBitsAll, "Int", mImgW, "Int", mImgH, "int", Stride, "int", bpp, "int", bmpOpacity, "int", userimgGammaCorrect, "int", thisBlendMode, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha, "UPtr", mScan, "int", mStride, "int", 32, "int", thisX, "int", thisY, "int", mw, "int", mh)
                ; fnOutputDebug(A_Index " rendered contour bitmap")
                Gdip_UnlockBits(thisBMP, mData)
                thisBMP := trGdip_DisposeImage(thisBMP)
             }
          }
       }
    }

    modusContour := (TextInAreaCutOutMode=1 && TextInAreaOnlyBorder=1 || TextInAreaCutOutMode=0) ? 1 : 0
    If (TextInAreaCutOutMode=1 && TextInAreaOnlyBorder=1 && TextInAreaBgrUnified=1 && TextInAreaPaintBgr=1 && TextInAreaBorderOut>1)
       modusContour := 0
    Else If (TextInAreaCutOutMode=1 && TextInAreaOnlyBorder=0 && TextInAreaBgrUnified=1 && TextInAreaPaintBgr=1 && TextInAreaBorderOut>1)
       modusContour := 1

    showTOOLtip("Applying insert text, please wait...`nPost-processing text line bitmaps")
    If (TextInAreaBgrUnified=1 && TextInAreaPaintBgr=1 && fattalErr!=1)
    {
       r := DllCall(whichMainDLL "\FillImageHoles", "UPtr", pBitsAll, "Int", mImgW, "Int", mImgH, "int", "0xFF000000")
       If (TextInAreaBgrUnified=1 && TextInAreaPaintBgr=1 && modusContour=0 && TextInAreaBorderOut>1)
       {
          fnOutputDebug("pre-unified processing with borders")
          Loop, % rendered
          {
             ; render the pBitmapContours bitmaps
             thisBMP := cachedRawTXTbmps[A_Index, 2]
             If validBMP(thisBMP)
             {
                thisX := cachedRawTXTbmps[A_Index, 3],    thisY := cachedRawTXTbmps[A_Index, 4]
                Gdip_GetImageDimensions(thisBMP, mw, mh)
                EZ := Gdip_LockBits(thisBMP, 0, 0, mw, mh, mStride, mScan, mData, 1)
                If !EZ
                {
                   r := DllCall(whichMainDLL "\DrawBitmapInPlace", "UPtr", pBitsAll, "Int", mImgW, "Int", mImgH, "int", Stride, "int", bpp, "int", 255, "int", userimgGammaCorrect, "int", 5, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha, "UPtr", mScan, "int", mStride, "int", 32, "int", thisX, "int", thisY, "int", mw, "int", mh)
                   Gdip_UnlockBits(thisBMP, mData)
                   thisBMP := trGdip_DisposeImage(thisBMP)
                }
             }
          }
       }

       If (TextInAreaCutOutMode=1)
       {
          r := DllCall(whichMainDLL "\ColorizeGrayImage", "UPtr", pBitsAll, "int", mImgW, "int", mImgH, "int", Stride, "int", 32, "int", 0, "int", "0x00" TextInAreaBgrColor, "int", bgrColor)
       } Else
       {
          If (TextInAreaBgrOpacity>4)
          {
             thisColoru := MixARGB(bgrColor, "0xFF" TextInAreaFontColor, TextInAreaFontOpacity/255)
          } Else If (TextInAreaBgrOpacity>3)
          {
             thisColorA := MixARGB(bgrColor, "0xFF" TextInAreaFontColor, TextInAreaFontOpacity/255)
             thisColoru := MixARGB(txtColor, thisColorA, 0.75)
          } Else If (TextInAreaBgrOpacity>2)
          {
             thisColorA := MixARGB(bgrColor, "0xFF" TextInAreaFontColor, TextInAreaFontOpacity/255)
             thisColoru := MixARGB(txtColor, thisColorA, 0.5)
          } Else If (TextInAreaBgrOpacity>1)
          {
             thisColorA := MixARGB(bgrColor, "0xFF" TextInAreaFontColor, TextInAreaFontOpacity/255)
             thisColoru := MixARGB(txtColor, thisColorA, 0.25)
          } Else
             thisColoru := txtColor

          ntxtColor := (TextInAreaCutOutMode=1) ? "0x00" TextInAreaBgrColor : thisColoru
          r := DllCall(whichMainDLL "\ColorizeGrayImage", "UPtr", pBitsAll, "int", mImgW, "int", mImgH, "int", Stride, "int", 32, "int", userimgGammaCorrect, "int", ntxtColor, "int", bgrColor)
       }
    }

    If (TextInAreaBgrUnified=1 && TextInAreaPaintBgr=1 && modusContour=1 && TextInAreaBorderOut>1 && fattalErr!=1)
    {
       fnOutputDebug("post-unified processing with borders")
       Loop, % rendered
       {
          ; render the pBitmapContours bitmaps
          thisBMP := cachedRawTXTbmps[A_Index, 2]
          If validBMP(thisBMP)
          {
             thisX := cachedRawTXTbmps[A_Index, 3],    thisY := cachedRawTXTbmps[A_Index, 4]
             QPV_ColorizeGrayImage(thisBMP, "0xFF" TextInAreaBorderColor, "0x00" TextInAreaBorderColor, 0)
             Gdip_GetImageDimensions(thisBMP, mw, mh)
             EZ := Gdip_LockBits(thisBMP, 0, 0, mw, mh, mStride, mScan, mData, 1)
             If !EZ
             {
                r := DllCall(whichMainDLL "\DrawBitmapInPlace", "UPtr", pBitsAll, "Int", mImgW, "Int", mImgH, "int", Stride, "int", bpp, "int", TextInAreaBorderOpacity, "int", userimgGammaCorrect, "int", 0, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha, "UPtr", mScan, "int", mStride, "int", 32, "int", thisX, "int", thisY, "int", mw, "int", mh)
                Gdip_UnlockBits(thisBMP, mData)
                thisBMP := trGdip_DisposeImage(thisBMP)
             }
          }
       }
    }

    Gdi_DeleteObject(hFont)
    If (fattalErr=1)
       Return

    If (TextInAreaValign=3)
       minedY += lnSpace
    Else If (oneLiner=2)
       minedY -= (nmaxH - omH)//2

    cachedRawTXTbmps := []
    cachedRawTXTbmps := [hFIFimgA, minedX, minedY, maxedW, maxedH, rendered, lnSpace]
    fnOutputDebug(A_ThisFunc "(): text rendered in: " A_TickCount - startZeit)
    Return cachedRawTXTbmps
} ; // coreInsertTextHugeImages()

drawHistogram(dataArray, graphFocus, Scale, fgrColor, bgrColor, borderSize, infoBoxBMP) {
    Static graphHeight := 300 ; graph height
    stylu := (showHistogram=6) ? 3 : 2
    plotBMP := BarChart(dataArray, lol, Round(296*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:0, BarHeight:" Scale*1.5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,TextSize:0,AutoCalculateHeight:1, BarColorDirection:" stylu ", BarPeaksColor:eeFFffFF, BgrStyle:3, BarBorderColor:0, MaxPercentValue:" graphFocus ", BarColorA:" fgrColor ", ChartBackColorA:dd" bgrColor)
    recordGdipBitmaps(plotBMP, A_ThisFunc "<-BarChart")
    If !validBMP(plotBMP)
    {
       addJournalEntry(A_ThisFunc "(): invalid bitmap to process")
       Return
    }

    Gdip_ImageRotateFlip(plotBMP, 5)
    Gdip_ImageRotateFlip(plotBMP, 6)
    trGdip_GetImageDimensions(plotBMP, imgW, imgH)
    If validBMP(infoBoxBMP)
       trGdip_GetImageDimensions(infoBoxBMP, imgW2, imgH2)

    clipBMP := trGdip_CreateBitmap(A_ThisFunc, imgW + borderSize * 2, imgH + Round(imgH2) + Round(borderSize*1.25), coreDesiredPixFmt)
    If !validBMP(clipBMP)
    {
       trGdip_DisposeImage(plotBMP, 1)
       Return
    }

    G3 := Gdip_GraphicsFromImage(clipBMP)
    If G3
    {
       trGdip_GetImageDimensions(clipBMP, maxW, maxH)
       lineThickns := Round(borderSize/15)
       Gdip_SetPenWidth(pPen1d, lineThickns)
       Gdip_GraphicsClear(G3, "0xEE" bgrColor)
       ; Gdip_FillRectangle(G3, pBr0, -2, -2, maxW + borderSize*2+12, maxH + borderSize*3)
       ; Gdip_FillRectangle(G3, pBrushE, borderSize/2, borderSize/2, imgW + borderSize, imgH + borderSize)
       Gdip_DrawRectangle(G3, pPen1d, borderSize/2 - lineThickns, borderSize/2 - lineThickns, imgW + lineThickns*2 + borderSize, imgH + lineThickns*2 + borderSize//2)
       HUDobjHistoBoxu[5] := imgW + lineThickns*2 + borderSize
       HUDobjHistoBoxu[6] := imgH + lineThickns*2 + borderSize
       tzGdip_DrawImage(G3, plotBMP, borderSize, borderSize)
       If validBMP(infoBoxBMP)
          tzGdip_DrawImage(G3, infoBoxBMP, borderSize//5, imgH + lineThickns*2 + borderSize)
       ; infoBoxBMP is disposed by the caller
       Gdip_DeleteGraphics(G3)
    }

    trGdip_DisposeImage(plotBMP, 1)
    ; ToolTip, % clipBMPa  "`n" clipBMP , , , 2
    ; tooltip, % maxYlimit ", " LengthX " || "  maxW "," maxH  ;  `n" PointsList
    Return clipBMP
}

performAutoExpandCanvas(imgW, imgH) {
    nImgSelX1 := imgSelX1, nImgSelY1 := imgSelY1
    nimgSelX2 := imgSelX2, nimgSelY2 := imgSelY2
    If (imgSelX1>=0)
       imgSelX1 := 0
    Else
       zImgSelX1 := Abs(imgSelX1)

    If (imgSelY1>0)
       imgSelY1 := 0
    Else
       zImgSelY1 := Abs(imgSelY1)

    If (imgSelX2<imgW)
       imgSelX2 := imgW
    If (imgSelY2<imgH)
       imgSelY2 := imgH

    obju := []
    obju[1] := [EllipseSelectMode, VPselRotation, innerSelectionCavityX, innerSelectionCavityY]
    VPselRotation := EllipseSelectMode := innerSelectionCavityX := innerSelectionCavityY :=  0
    defineRelativeSelCoords(imgW, imgH)
    CropImageInViewPortToSelection("simplex")
    prevImgSelX1 += Round(zimgSelX1)
    prevImgSelY1 += Round(zimgSelY1)
    prevImgSelX2 += Round(zimgSelX1)
    prevImgSelY2 += Round(zimgSelY1)
    VPstampBMPx += Round(zimgSelX1)
    VPstampBMPy += Round(zimgSelY1)
    imgSelX1 := nimgSelX1 + Round(zimgSelX1)
    imgSelY1 := nimgSelY1 + Round(zimgSelY1)
    imgSelX2 := nimgSelX2 + Round(zimgSelX1)
    imgSelY2 := nimgSelY2 + Round(zimgSelY1)
    EllipseSelectMode := obju[1, 1]
    VPselRotation := obju[1, 2]
    innerSelectionCavityX := obju[1, 3]
    innerSelectionCavityY := obju[1, 4]
    editingSelectionNow := 1
    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    defineRelativeSelCoords(imgW, imgH)
    Return 1
}

testAllowOutsidePasteInPlace(imgW, imgH, oImgW, oImgH) {
    allowOutside := 0 
    imgSelW := Round( ( max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2) ) )
    imgSelH := Round( ( max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2) ) )
    imgSelPx := imgSelX1, imgSelPy := imgSelY1
    capped := (viewportQPVimage.imgHandle) ? 0 : 1
    If ((PasteInPlaceOrientation=2 || PasteInPlaceOrientation=4) && (PasteInPlaceAdaptMode=1 || PasteInPlaceAdaptMode=3) )
       flipVars(oImgW, oImgH)

    If (VPselRotation>0 && prevPasteInPlaceVPcoords[5]=1 && !viewportQPVimage.imgHandle)
    {
       If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
          Gdip_GetRotatedEllipseDimensions(oImgW, oImgH, VPselRotation, oImgW, oImgH)
       Else
          Gdip_GetRotatedDimensions(oImgW, oImgH, VPselRotation, oImgW, oImgH)
    }

    PasteInPlaceCalcObjSize(0, prevPasteInPlaceVPcoords[5], oImgW, oImgH, imgSelW, imgSelH, VPselRotation, capped, ResizedW, ResizedH)
    PasteInPlaceCalcObjCoords(imgSelW, imgSelH, ResizedW, ResizedH, imgSelPx, imgSelPy)
    xa := imgSelPx, ya := imgSelPy
    xb := imgSelPx + ResizedW, yb := imgSelPy + ResizedH
    If ((xa<0 || ya<0 || xb>imgW || yb>imgH) && PasteInPlaceAutoExpandIMG=1 && imgW && imgH)
       allowOutside := 1

    ; ToolTip, % oImgW "|" oImgH "`n" ResizedW "|" ResizedH , , , 2
    ; TulTip(A_ThisFunc, "|", xa, ya, xb, yb, prevPasteInPlaceVPcoords[1], prevPasteInPlaceVPcoords[2], prevPasteInPlaceVPcoords[3], prevPasteInPlaceVPcoords[4])
    Return [allowOutside, xa, ya, xb, yb]
}

PasteInPlaceSelectedArea() {
    trGdip_GetImageDimensions(userClipBMPpaste, rzW, rzH)
    whichBitmap := useGdiBitmap()
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    allowOutside := testAllowOutsidePasteInPlace(imgW, imgH, rzW, rzH)
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 1, allowOutside[1])
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       corePasteInPlaceActNow("kill")
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    If (allowOutside[1]=1)
    {
       xa := imgSelX1, ya := imgSelY1
       xb := imgSelX2, yb := imgSelY2
       zW := Round( ( max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2) ) )
       zH := Round( ( max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2) ) )
       imgSelX1 := allowOutside[2], imgSelY1 := allowOutside[3]
       imgSelX2 := allowOutside[4], imgSelY2 := allowOutside[5]
       zX := (imgSelX1<0) ? abs(imgSelX1) : 0,  zY := (imgSelY1<0) ? abs(imgSelY1) : 0
       defineRelativeSelCoords(imgW, imgH)
       hasRanExpand := performAutoExpandCanvas(imgW, imgH)
       imgSelX1 := xa + zX, imgSelY1 := ya + zY
       imgSelX2 := xb + zX, imgSelY2 := yb + zY
       defineRelativeSelCoords(imgW, imgH)
    }

    startZeit := A_TickCount
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    newBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    If validBMP(newBitmap)
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, thisImgQuality, 4,, compositingQuality)

    If !G2
    {
       If validBMP(newBitmap)
          showTOOLtip("Failed to perform paste in place. Unable to create GDI+ graphics object.")
       Else
          showTOOLtip("Failed to perform paste in place. Unable to allocate new bitmap.")

       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       trGdip_DisposeImage(newBitmap, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       backupGdiBMP := trGdip_DisposeImage(backupGdiBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    ; setImageLoading()
    r1 := corePasteInPlaceActNow(G2, newBitmap)
    If (PasteInPlaceEraseInitial=1)
       currIMGdetails.HasAlpha := 1

    Gdip_DeleteGraphics(G2)
    corePasteInPlaceActNow("kill")
    If (r1!="fail" && validBMP(newBitmap))
    {
       wrapRecordUndoLevelNow(newBitmap)
    } Else
    {
       showTOOLtip("Failed to perform paste in place")
       SoundBeep 300, 100
       trGdip_DisposeImage(newBitmap)
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }

    SetTimer, ResetImgLoadStatus, -100
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "(): transformations ended. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    dummyTimerDelayiedImageDisplay(50)
    If (hasRanExpand=1)
    {
       totalSelUndos := Round(undoSelLevelsArray.Count())
       currentSelUndoLevel := clampInRange(totalSelUndos, 1, totalSelUndos)
       restorePreviousSelections(currentSelUndoLevel)
       SetTimer, dummyRefreshImgSelectionWindow, -125
    }
}

determineSizeRotateSkew(whichBitmap, Angle, shearX, shearY, ellipseModus, revealOriginal) {
   If IsObject(whichBitmap)
   {
      imgW := whichBitmap[1]
      imgH := whichBitmap[2]
   } Else
      trGdip_GetImageDimensions(whichBitmap, imgW, imgH)

   getVPselSize(zW, zH, 1, 0)
   calcIMGdimensions(zW, zH, imgW, imgH, newW, newH)
   pPath := Gdip_CreatePath()
   If (ellipseModus=1)
      Gdip_AddPathEllipse(pPath, 0, 0, imgW, imgH)
   Else
      Gdip_AddPathRectangle(pPath, 0, 0, imgW, imgH)

   pMatrix := Gdip_CreateMatrix()
   Gdip_ShearMatrix(pMatrix, shearX, shearY)
   Gdip_RotateMatrix(pMatrix, Angle)
   Gdip_TransformPath(pPath, pMatrix)

   If (ellipseModus=1 && revealOriginal=0)
      pb := getAccuratePathBounds(pPath, 2)
   Else
      pb := Gdip_GetPathWorldBounds(pPath)
   ; ToolTip, % pb.w "|" pb.h "`n" imgW "|" imgH , , , 2

   transX  := -(pb.x),   transY := -(pb.y)
   pb.imgW := imgW,      pb.imgH := imgH
   pb.nw   := newW,      pb.nh   := newH
   pb.obj  := pMatrix
   Gdip_TranslateMatrix(pMatrix, transX, transY, 1)
   ; Gdip_SetWorldTransform(2NDglPG, pMatrix)
   ; tzGdip_DrawImage(2NDglPG, whichBitmap, 0, 0, imgW, imgH, , , , , 0.7)
   ; ToolTip, % "l=" a , , , 2
   Gdip_DeletePath(pPath)
   Return pb
}

RotateAndSkewBitmap(whichBitmap, Angle, shearX, shearY, ellipseModus, InterpolationMode, revealOriginal) {
    If !validBMP(whichBitmap)
    {
       addJournalEntry(A_ThisFunc "(). ERROR. Invalid bitmap. Function likely invoked by realtimePasteInPlaceRotator()")
       Return
    }

    If (!Angle && !shearX && !shearY)
       Return trGdip_CloneBitmap(A_ThisFunc, whichBitmap)

    pb := determineSizeRotateSkew(whichBitmap, Angle, shearX, shearY, ellipseModus, revealOriginal)
    If isImgSizeTooLarge(pb.w, pb.h)
    {
       addJournalEntry(A_ThisFunc "(). ERROR. The bitmap resolution is too big. It exceeds the GDI+ limits.")
       Return
    }

    newBitmap := trGdip_CreateBitmap(A_ThisFunc, pb.w, pb.h, "0xE200B")
    If validBMP(newBitmap)
       G := Gdip_GraphicsFromImage(newBitmap, InterpolationMode, 4)

    If (!validBMP(newBitmap) || !G)
    {
       addJournalEntry(A_ThisFunc "(): ERROR. Failed to process image G=" G " or newBitmap= " newBitmap " missing.")
       trGdip_DisposeImage(newBitmap, 1)
       Gdip_DeleteGraphics(G)
       Return
    }

    Gdip_SetWorldTransform(G, pb.obj)
    r := tzGdip_DrawImage(G, whichBitmap, 0, 0, pb.imgW, pb.imgH)
    If r
    {
       trGdip_DisposeImage(newBitmap, 1)
       newBitmap := ""
    }

    Gdip_DeleteGraphics(G)
    Gdip_DeleteMatrix(pb.obj)
    Return newBitmap
}

realtimePasteInPlaceRotator(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState, hasRotated
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    opacityExtra := (PasteInPlaceOpacity>255 && !viewportQPVimage.imgHandle) ? PasteInPlaceOpacity - 255 : 0
    thisState := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation VPselRotation prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex PasteInPlaceBlurEdgesSoft previnnerSelectionCavityX previnnerSelectionCavityY shearImgX shearImgY PasteInPlaceRevealOriginal PasteInPlaceOrientFlipX PasteInPlaceOrientFlipY opacityExtra
    If (thisState=prevState && validBMP(prevBMPu))
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return hasRotated
    }

    hasRotated := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    If (!validBMP(userClipBMPpaste) || !validBMP(viewportStampBMP))
    {
       addJournalEntry("An error occured in " A_ThisFunc "(). userClipBMPpaste and/or viewportStampBMP are invalid bitmaps.")
       Return "fail"
    }

    clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
    If !validBMP(clipBMP)
       Return 0

    trGdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    trGdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := JimgW/vpImgW
    ellipseModus := (prevEllipseSelectMode=1 && PasteInPlaceToolMode=1) ? 1 : 0
    trGdip_GetImageDimensions(clipBMP, eImgW, eImgH)

    If (PasteInPlaceOrientation>1)
       ER := Gdip_ImageRotateFlip(clipBMP, PasteInPlaceOrientation - 1)

    If (PasteInPlaceOrientFlipX=1 && PasteInPlaceOrientFlipY=1)
       ER := Gdip_ImageRotateFlip(clipBMP, 2)
    Else If (PasteInPlaceOrientFlipX=1)
       ER := Gdip_ImageRotateFlip(clipBMP, 4)
    Else If (PasteInPlaceOrientFlipY=1)
       ER := Gdip_ImageRotateFlip(clipBMP, 6)

    If ((VPselRotation>0 || shearImgX!=0 || shearImgY!=0) && !ER && !viewportQPVimage.imgHandle)
    {
       setWindowTitle("Rotating image at " Round(VPselRotation, 1) "°")
       xBitmap := RotateAndSkewBitmap(clipBMP, VPselRotation, shearImgX, shearImgY, ellipseModus, thisImgQuality, PasteInPlaceRevealOriginal)
       If validBMP(xBitmap)
       {
          hasRotated := 1
          clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
    }

    If (prevEllipseSelectMode>0 && PasteInPlaceToolMode=1 && hasRotated=1 && PasteInPlaceRevealOriginal=0)
    {
       trGdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       pb := determineSizeRotateSkew([eImgW, eImgH], VPselRotation, shearImgX, shearImgY, ellipseModus, PasteInPlaceRevealOriginal)
       gFx := pB.w/rimgW
       gFy := pB.h/rimgH
       zwImgW := Round(rImgW * gFx)
       zwImgH := Round(rImgH * gFy)
       dX := (rImgW - zwImgW)//2
       dY := (rImgH - zwImgH)//2
       xBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP, dX, dY, zwImgW, zwImgH, 0, 0, 1)
       Gdip_DeleteMatrix(pb.obj)
       If validBMP(xBitmap)
       {
          clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
       ; ToolTip, % gFx " --- " gFy "`n" zwImgW " --- " zwImgH "`n" rImgW " --- " rImgH "`n" dX " --- " dY "`n" clipBMP , , , 2
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    Return hasRotated
}

realtimePasteInPlaceBlurrator(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState

    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    opacityExtra := (PasteInPlaceOpacity>255 && !viewportQPVimage.imgHandle) ? PasteInPlaceOpacity - 255 : 0
    thisState := "a" userClipBMPpaste PasteInPlaceBlurEdgesSoft viewportStampBMP previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex PasteInPlaceAdaptMode previnnerSelectionCavityX previnnerSelectionCavityY PasteInPlaceRevealOriginal opacityExtra
    If (thisState=prevState && validBMP(prevBMPu))
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return
    }

    If (!validBMP(userClipBMPpaste) || !validBMP(viewportStampBMP))
    {
       addJournalEntry("An error occured in " A_ThisFunc "(). userClipBMPpaste and/or viewportStampBMP are invalid bitmaps.")
       Return "fail"
    }

    fnOutputDebug("redraw: " A_ThisFunc)
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    clipBMP := trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    If !validBMP(clipBMP)
       Return "fail"

    trGdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    trGdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := (vpImgW + vpImgH) / (JimgW + JimgH)
    thisAmount := (previewMode=1) ? Round(PasteInPlaceBlurAmount * fScale) : PasteInPlaceBlurAmount
    If (thisAmount>1 && !viewportQPVimage.imgHandle)
    {
       If (previewMode!=1)
       {
          setWindowTitle("Applying blur filter on image")
          QPV_PrepareAlphaChannelBlur(clipBMP, 1, 1)
       }

       ; ToolTip, % thisAmount "=" fScale  , , , 2
       QPV_BoxBlurBitmap(clipBMP, thisAmount, thisAmount, 0)
    }

    If (PasteInPlaceToolMode=1 && PasteInPlaceRevealOriginal=0) ; && (prevVPselRotation>0 || prevEllipseSelectMode>0))
    {
       ; when used with the transform tool
       eimgW := max(prevImgSelX1, prevImgSelX2) - min(prevImgSelX1, prevImgSelX2)
       eimgH := max(prevImgSelY1, prevImgSelY2) - min(prevImgSelY1, prevImgSelY2)
       decX := prevImgSelX1 - VPstampBMPx
       decY := prevImgSelY1 - VPstampBMPy
       If (previewMode=1)
       {
          trGdip_GetImageDimensions(clipBMP, wImgW, wImgH)
          trGdip_GetImageDimensions(userClipBMPpaste, gImgW, gImgH)
          scaleu := gImgW/wImgW
          eimgW := Round(eimgW/scaleu)
          eimgH := Round(eimgH/scaleu)
          decX := Round(decX/scaleu)
          decY := Round(decY/scaleu)
       }
       If (viewportQPVimage.imgHandle)
          trGdip_GetImageDimensions(clipBMP, eImgW, eImgH)

       pPath := createImgSelPath(0, 0, eImgW, eImgH, prevEllipseSelectMode, prevVPselRotation, prevrotateSelBoundsKeepRatio, 0, 1, 1, previnnerSelectionCavityX, previnnerSelectionCavityY)
       If pPath
       {
          thisAmount := (PasteInPlaceBlurEdgesSoft=1) ? thisAmount//4 + 4 : 0
          carvePathFromBitmap(clipBMP, pPath, -decX, -decY, 0, 2, thisAmount, 0, PasteInPlaceBlurEdgesSoft, 1)
          Gdip_DeletePath(pPath)
       }
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    Return
}

realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlphaBMP, rImgW, rImgH, thisImgQuality:=0) {
    Static prevBMPu, prevState
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisBMP := userAlphaBMP
    thisState := "a" previewMode alphaMaskRefBMP getIDimage(currentFileIndex) currentFileIndex alphaMaskGradientAngle lastPaintEventID VPselRotation rImgW rImgH brushZeitung
    If (thisState=prevState && validBMP(prevBMPu))
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       trGdip_DisposeImage(thisBMP, 1)
       Return newBitmap
    }

    fnOutputDebug("redraw: " A_ThisFunc)
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    thisImgQuality := (PasteInPlaceQuality=1 && previewMode!=1) ? 7 : 5
    If (alphaMaskGradientAngle!=0 && isNumber(alphaMaskGradientAngle) && validBMP(thisBMP))
    {
       changeMcursor()
       thisMono := (alphaMaskColorReversed!=1) ? "0xFF000000" : "0xFFFFFFFF"
       thisMonoBrush := Gdip_BrushCreateSolid(thisMono)
       pra := (alphaMaskGradientAngle>0) ? alphaMaskGradientAngle : 360 + alphaMaskGradientAngle
       xMaskBmp := trGdip_RotateBitmapAtCenter(A_ThisFunc, thisBMP, pra, thisMonoBrush, thisImgQuality)
       If validBMP(xMaskBmp)
       {
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := xMaskBmp
       } Else ER := "fail"
       Gdip_DeleteBrush(thisMonoBrush)
    } Else If !validBMP(thisBMP)
       ER := "fail"

    If ER
    {
       trGdip_DisposeImage(thisBMP, 1)
       Return
    }

    trGdip_GetImageDimensions(thisBMP, zImgW, zImgH)
    If (zImgW!=rImgW || zImgH!=rImgH)
       alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, thisBMP, rImgW, rImgH, 0, thisImgQuality, -1)
    Else
       alphaMaskGray := trGdip_CloneBitmap(A_ThisFunc, thisBMP)

    trGdip_DisposeImage(thisBMP, 1)
    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : alphaMaskGray
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? alphaMaskGray : trGdip_CloneBitmap(A_ThisFunc, alphaMaskGray)
    Return newBitmap
}

useGdiBitmap(doConvertPARG:=0) {
   If validBMP(gdiBitmap)
   {
      If (doConvertPARG="yes")
         thisPixFmt := Gdip_GetImagePixelFormat(gdiBitmap, 1)
      If (!isVarEqualTo(thisPixFmt, "0xE200B", "0x26200A") && thisPixFmt)
      {
          newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, gdiBitmap)
          If validBMP(newBitmap)
          {
             trGdip_DisposeImage(gdiBitmap, 1)
             gdiBitmap := newBitmap
          }
      }
      Return gdiBitmap
   } Else If validBMP(UserMemBMP)
   {
      If (doConvertPARG="yes")
         thisPixFmt := Gdip_GetImagePixelFormat(UserMemBMP, 1)
      If (!isVarEqualTo(thisPixFmt, "0xE200B", "0x26200A") && thisPixFmt)
      {
          newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, UserMemBMP)
          If validBMP(newBitmap)
          {
             trGdip_DisposeImage(UserMemBMP, 1)
             UserMemBMP := newBitmap
          }
      }
      Return UserMemBMP
   }
}

LoadCachableBitmapFromFile(imgPath) {
   Static prevBMPu, prevState
   If (imgPath="kill")
   {
      prevState := 0
      prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
      Return
   }

   thisState := "a" generateThumbName(imgPath, 1) "=-=b"
   If (thisState=prevState && validBMP(prevBMPu) && FileRexists(imgPath))
   {
      newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
      Return newBitmap
   }

   fnOutputDebug("redraw: " A_ThisFunc)
   prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
   pBitmap := LoadBitmapFromFileu(imgPath)
   If validBMP(pBitmap)
   {
      zBitmap := cloneGDItoMem(A_ThisFunc, pBitmap)
      If validBMP(zBitmap)
      {
         trGdip_DisposeImage(pBitmap, 1)
         pBitmap := zBitmap
      }
   } Else
   {
      addJournalEntry(A_ThisFunc "() failed: unable to load image file")
      Return
   }

   prevBMPu := (minimizeMemUsage=1) ? 0 : pBitmap
   prevState := (pBitmap && minimizeMemUsage!=1) ? thisState : 0
   If validBMP(pBitmap)
      newBitmap := (minimizeMemUsage=1) ? pBitmap : trGdip_CloneBitmap(A_ThisFunc, pBitmap)
   Return newBitmap
}

QPV_SetBitmapAsAlphaChannel(pBitmap, pBitmapMask, invertAlphaMask:=0, replaceSourceAlphaChannel:=0, whichChannel:=1) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  trGdip_GetImageDimensions(pBitmapMask, w2, h2)
  If (!validBMP(pBitmap) || !validBMP(pBitmapMask))
  {
     addJournalEntry(A_ThisFunc "(): ERROR. Invalid bitmaps provided.")
     Return 0
  }

  isOkay := (w2=w && h2=h) ? 1 : 0 
  If (!w || !h || !w2 || !h2 || !isOkay)
  {
     addJournalEntry(A_ThisFunc "(): ERROR. Bitmaps dimensions mismatched." w2 "/" h2 " | " w "/" h)
     Return 0
  } ; Else
     ; addJournalEntry(A_ThisFunc "(): Bitmaps dimensions. " w2 "/" h2 " | " w "/" h)

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  E2 := Gdip_LockBits(pBitmapMask, 0, 0, w, h, mStride, mScan, mData, 1)
  If (!E1 && !E2)
     r := DllCall(whichMainDLL "\SetBitmapAsAlphaChannel", "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", stride, "int", 32, "Int", invertAlphaMask, "Int", replaceSourceAlphaChannel, "Int", whichChannel)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmapMask, mData)
  ; fnOutputDebug(a_thisfunc "() = " A_TickCount - thisStartZeit)
  return r
}

QPV_SetColorAlphaChannel(pBitmap, newColor, invertAlphaMask) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !validBMP(pBitmap))
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If !E1
     r := DllCall(whichMainDLL "\SetColorAlphaChannel", "UPtr", iScan, "Int", w, "Int", h, "Int", newColor, "Int", invertAlphaMask, "Int")

  If !E1
     Gdip_UnlockBits(pBitmap, iData)

  return r
}

QPV_FloodFill(pBitmap, x, y, newColor, fillOpacity) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !validBMP(pBitmap) || !isInRange(x, 0, w) || !isInRange(y, 0, h))
     Return 0

  Gdip_FromARGB(newColor, A, R, G, B)
  newColor := Gdip_ToARGB(A, R, G, B)
  If (FloodFillTolerance<3)
     FloodFillCartoonMode := 0

  ; oldColor := Gdip_GetPixel(pBitmap, x, y)
  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, Stride, iScan, iData, 3)
  tolerance := (FloodFillAltToler=1) ? Ceil(FloodFillTolerance*0.7) + 1 : FloodFillTolerance
  If !E1
     r := DllCall(whichMainDLL "\FloodFillWrapper", "UPtr", iScan, "Int", FloodFillModus, "Int", w, "Int", h, "Int", x, "Int", y, "Int", newColor, "int", tolerance, "int", fillOpacity, "int", FloodFillDynamicOpacity, "int", FloodFillBlendMode - 1, "int", FloodFillCartoonMode, "int", FloodFillAltToler, "int", FloodFillEightWays, "int", userimgGammaCorrect, "int", BlendModesFlipped, "int", Stride, "int", 32, "int", 0, "int", 0)
  ; ToolTip, % A_PtrSize "=" A_LastError "==" r "=" func2exec "=" SecToHHMMSS(Round(zeitOperation/1000, 3)) , , , 2

  If !E1
     Gdip_UnlockBits(pBitmap, iData)

  zeitOperation := A_TickCount - thisStartZeit
  return r
}

QPV_ConvertToGrayscale(pBitmap, modus, intensity, previewMode) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !validBMP(pBitmap))
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If !E1
  {
     If (previewMode=1)
        QPV_PrepareHugeImgSelectionArea(0, 0, w, h, w, h, EllipseSelectMode, VPselRotation, 1, invertArea)
     Else
        QPV_PrepareHugeImgSelectionArea(0, 0, w, h, w, h, -1, 0, 0, 0)
     r := DllCall(whichMainDLL "\ConvertToGrayScale", "UPtr", iScan, "Int", w, "Int", h, "int", modus, "int", intensity, "int", stride, "int", 32, "UPtr", 0, "int", 0)
     Gdip_UnlockBits(pBitmap, iData)
  }

  zeitOperation := A_TickCount - thisStartZeit
  return r
}

QPV_AdjustImageColors(pBitmap, thisOpacity, InvertColors, AltSat, Sat, AltBright, Bright, AltContra, Contra, AltHiLows, Shadows, Highs, Hue, TintDeg, TintAmount, AltTint, Gamma, OffR, OffG, OffB, OffA, ThreR, ThreG, ThreB, ThreA, SeeThrough, InvertArea, NoClamp, WhitePoint, BlackPoint, NoisePoints, previewMode) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !validBMP(pBitmap))
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If !E1
  {
     If (previewMode=1)
        QPV_PrepareHugeImgSelectionArea(0, 0, w, h, w, h, EllipseSelectMode, VPselRotation, 1, invertArea)
     Else If (previewMode!=-1)
        QPV_PrepareHugeImgSelectionArea(0, 0, w, h, w, h, -1, 0, 0, 0)

     this := (userImgAdjustHiPrecision=1) ? "Precise" : ""
     r := DllCall(whichMainDLL "\AdjustImageColors" this, "UPtr", iScan, "Int", w, "Int", h, "int", stride, "int", 32, "int", thisOpacity, "int", InvertColors, "int", AltSat, "int", Sat, "int", AltBright, "int", Bright, "int", AltContra, "int", Contra, "int", AltHiLows, "int", Shadows, "int", Highs, "int", Hue, "int", TintDeg, "int", TintAmount, "int", AltTint, "int", Gamma, "int", OffR, "int", OffG, "int", OffB, "int", OffA, "int", ThreR, "int", ThreG, "int", ThreB, "int", ThreA, "int", SeeThrough, "int", userimgGammaCorrect, "int", NoClamp, "int", WhitePoint, "int", BlackPoint, "int", NoisePoints, "UPtr", 0, "int", 0)
     Gdip_UnlockBits(pBitmap, iData)
  }

  ; ToolTip, % A_PtrSize "=" A_LastError "==" r "=" func2exec "=" SecToHHMMSS(Round(zeitOperation/1000, 3)) , , , 2
  zeitOperation := A_TickCount - thisStartZeit
  return r
}

livePreviewPrepareSelectionArea(objSel, invertArea, shapeMode) {
   oImgW := objSel.nw,   oImgH := objSel.nh
   tw := objSel.sw - objSel.nw 
   th := objSel.sh - objSel.nh 
   tx := objSel.sx - objSel.dx
   ty := objSel.sy - objSel.dy
   px := (prevDestPosX<0) ? 0 : - prevDestPosX
   py := (prevDestPosY<0) ? 0 : - prevDestPosY
   txb := oImgW + tw
   tyb := oImgH + th
   zx := (tX<0) ? abs(tX) : 0
   zy := (tY<0) ? abs(tY) : 0
   bzx := clampInRange(zx + objSel.mainW, 0, txb)
   bzy := clampInRange(zy + objSel.mainH, 0, tyb)
   ppo := [zx, zy, bzx, bzy, 1]
   If (invertArea=1)
   {
      tx := objSel.sx + px
      ty := objSel.sy + py
      txb := objSel.sw + objSel.sx + px
      tyb := objSel.sh + objSel.sy + py
   }

   ; ToolTip, % tx "|" ty "`n" zx "|" zy "`n" bzx "|" bzy "`n" txb "|" tyb , , , 2
   ; ToolTip, % oImgW "|" oImgH "`n" imgSelW "|" imgSelH "`n" mainWidth "|" mainHeight , , , 2
   If (viewportQPVimage.imgHandle && invertArea=1)
      QPV_PrepareHugeImgSelectionArea(tx, ty, txb, tyb, objSel.sw, objSel.sh, shapeMode, VPselRotation, 1, invertArea, "a", "a", ppo)
   Else If (viewportQPVimage.imgHandle)
      QPV_PrepareHugeImgSelectionArea(tx, ty, txb, tyb, txb, tyb, shapeMode, VPselRotation, 1, 0, "a", "a", ppo)
   Else 
      QPV_PrepareHugeImgSelectionArea(0, 0, oImgW, oImgH, oImgW, oImgH, -1, 0, 0, 0)
}

QPV_PrepareHugeImgSelectionArea(x1, y1, x2, y2, w, h, mode, rotation, doFlip, invertArea, cavityX:="a", cavityY:="a", ppo:=0) {
   ; mode is EllipseSelectMode [the shape]
   Static pi := 3.141592653
   , lastState := 0

   If (editingSelectionNow!=1)
   {
      lastState :=""
      r := DllCall(whichMainDLL "\prepareSelectionArea", "int", x1, "int", y1, "int", x2, "int", y2, "int", w, "int", h,  "float", 1, "float", 1, "float", 0, "int", 0, "int", 0, "float", 0, "int", 0)
      Return
   }

   If (mode=3 && FillAreaShape=1 || mode=4 && PasteInPlaceCropSel=1)
      mode := 0
   Else If (mode=3 && FillAreaShape=3 || mode=4 && PasteInPlaceCropSel=3)
      mode := 1

   startZeit := A_TickCount
   PointsCount := PointsF := useCache := 0
   If ((mode=0 || mode=1) && rotation!=0)
   {
      lastState :=""
      If (mode=1)
      {
         pPath := createImgSelPath(0, 0, w, h, 1, rotation, rotateSelBoundsKeepRatio, 0, 2, 0, 0, 0, 0)
         ba := getAccuratePathBounds(pPath, 1, 21)
         ra := (w>h) ? ba.h / h : ba.w / w
         rw := w * ra
         rh := h * ra
         x1 := x1 + (w - rw)//2
         y1 := y1 + (h - rh)//2
         x2 := x1 + Round(rw)
         y2 := y1 + Round(rh)
         w := Round(rw)
         h := Round(rh)
         Gdip_GetRotatedEllipseDimensions(w, h, rotation, rw, rh)
         rw := Round(rw)
         rh := Round(rh)
         ; ToolTip, % rw "|" rh "`n" ba.w "|" ba.h "`n" ra , , , 2
         Gdip_DeletePath(pPath)
      } Else If (rotateSelBoundsKeepRatio=0 && mode=0)
      {
         Gdip_GetRotatedDimensions(w, h, rotation, rw, rh)
      } Else
      {
         ; my maths is simply.... sublime [sarcasm]
         If isInRange(rotation, 0, 44.99) ; << this should be the first hint ^_^ 
         {
            rotation := 180 + mod(rotation, 45)
         } Else If (isInRange(rotation, 135, 180) || isInRange(rotation, 315, 360))
         {
            If (rotation>=359.98 || isInRange(rotation, 179.98, 180.01))
            {
               rotation := 0
            } Else
            {
               doFlip := !doFlip
               rotation := 225 - mod(rotation, 45)
            }
         }

         TAngle := (rotation)*(pi/180)
         cTAngle := Cos(TAngle)
         sTAngle := Sin(TAngle)
         If isInRange(rotation, 180, 225)
         {
            rw := (w * sTAngle) + (h * cTAngle)
            rh := (w * cTAngle) + (h * sTangle)
         } Else
         {
            rw := Abs(w * cTAngle) + Abs(h * sTAngle)
            rh := Abs(w * sTAngle) + Abs(h * cTangle)
         }
      }

      If (rotateSelBoundsKeepRatio=1)
      {
         If (mode=0)
         {
            xf := max(rw, rh)/min(w,h)
            yf := max(rw, rh)/min(w,h)
            If isVarEqualTo(round(rotation, 2), 0, 180, 360)
               xf := yf := 1
         } else
         {
            xf := (rw/w > 1) ? rw/w : w/rw
            yf := (rh/h > 1) ? rh/h : h/rh
            xf := max(xf, yf)
            yf := max(xf, yf)
         }
      } Else
      {
         xf := rw/w
         yf := rh/h
      }
   } Else If (mode>=2)
   {
      rzu := DllCall(whichMainDLL "\testFilledPolygonCache", "int", 0)
      selID := VPcreateSelPath("prevID", 0, 0, 0, 0, 0, 0, 0, 0)
      zpklo := IsObject(ppo) ? "a" ppo[1] ppo[2] ppo[3] ppo[4] : "a"
      thisState := "a" selID x1 y1 x2 y2 w h mode rotation doFlip invertArea cavityX cavityY zpklo currentFileIndex getIDimage(currentFileIndex) AnyWindowOpen
      If ((thisState!=lastState || rzu!=1) && mode!=5)
      {
         trGdip_GetImageDimensions(useGdiBitmap(), zkw, zkh)
         sfs := (Round((zkw * zkh)/1000000, 1) > 5500) ? 0.5 : 0.7
         zsf := ((w>zkw*sfs || h>zkh*sfs) && ppo[5]=1 && (bezierSplineCustomShape=1 || FillAreaCurveTension>1)) ? 1 : 0
         mw := (zsf=1) ? zkw*sfs : w
         mh := (zsf=1) ? zkh*sfs : h
         If (mode=4)
            pPath := coreCreateFillAreaShape(0, 0, mw, mh, PasteInPlaceCropSel, rotation, rotateSelBoundsKeepRatio, 2, 0)
         Else If (mode=3)
            pPath := coreCreateFillAreaShape(0, 0, mw, mh, FillAreaShape, rotation, rotateSelBoundsKeepRatio, 2, 0)
         Else
            pPath := createImgSelPath(0, 0, mw, mh, 2, rotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY, 0)

         If (pPath="" || pPath=0)
         {
            addJournalEntry("ERROR: failed to generate vector path object with GDI+ in " A_ThisFunc "().")
            Return 0
         }

         if (doFlip!=1)
         {
            pMatrix := Gdip_CreateMatrix()
            Gdip_ScaleMatrix(pMatrix, 1, -1)
            Gdip_TranslateMatrix(pMatrix, 0, -mh)
            E := Gdip_TransformPath(pPath, pMatrix)
            Gdip_DeleteMatrix(pMatrix)
         }

         kkz := (mode=4 && PasteInPlaceCropSel=2 || mode=3 && FillAreaShape=2) ? 1 : 0
         If (bezierSplineCustomShape=1 || FillAreaCurveTension>1 || kkz=1)
            Gdip_FlattenPath(pPath, 0.1)

         If (zsf=1)
         {
            pMatrix := Gdip_CreateMatrix()
            Gdip_ScaleMatrix(pMatrix, w/mw, h/mh)
            Gdip_TransformPath(pPath, pMatrix)
            Gdip_DeleteMatrix(pMatrix)
         }

         PointsCount := Gdip_GetPathPointsCount(pPath)
         VarSetCapacity(PointsF, 8 * (PointsCount + 1), 0)
         gdipLastError := DllCall("gdiplus\GdipGetPathPoints", "UPtr", pPath, "UPtr", &PointsF, "int*", PointsCount)
         lastState := thisState
         useCache := 0
      } Else useCache := 1
      
      xf := yf := 1
      mode := 2
   } Else 
   {
      xf := yf := 1
   }

   cavityX := (cavityX="a") ? innerSelectionCavityX : cavityX
   cavityY := (cavityY="a") ? innerSelectionCavityY : cavityY
   If (cavityX=0 && cavityY=0 || mode>=2)
      exclusion := 0
   Else
      exclusion := 0.995 - ( 1 -  (cavityX + cavityY)/2 ) / 2

   If IsObject(ppo)
   {
      ppx1 := ppo[1], ppy1 := ppo[2]
      ppx2 := ppo[3], ppy2 := ppo[4]
      ppofYa := ppofYb := 0
   } else if (ppo=1 && mode=2)
   {
      trGdip_GetImageDimensions(useGdiBitmap(), zkw, zkh)
      ppx1 := (imgSelX1<0) ? abs(x1) : 0
      ppy1 := (imgSelY1<0) ? abs(imgSelY1) : 0
      ppx2 := (imgSelX2>zkw) ? zkw - imgSelX1 - ppx1 : imgSelX2 - imgSelX1
      ppy2 := (imgSelY2>zkh) ? zkh - imgSelY1 - ppy1 : imgSelY2 - imgSelY1
      If (imgSelX1<0 && imgSelX2>zkw)
         ppx2 += abs(x1)

      ppofYa := (imgSelY1<0) ? abs(imgSelY1) - 1 : 0
      ppofYb := (imgSelY2>zkh) ? imgSelY2 - zkh : 0
      y1 += ppofYb
      If (imgSelY1<0 && imgSelY2>zkh)
      {
         y1 += abs(imgSelY1)
         ppofYb += abs(imgSelY1)
         ppy1 := 0
      }
   } else
   {
      ppofYa := ppofYb := ppx1 := ppy1 := 0
      ppx2 := w
      ppy2 := h
   }

   ; fnOutputDebug(ppo " mode=" mode "; useCache=" useCache " | angle=" rotation " doFlip=" doFlip)
   ; fnOutputDebug("xxxcoords = " x1 "|" y1 "|" x2 "|" y2 "||" xf "|" yf)
   ; fnOutputDebug("selcoords = " imgSelX1 "|" imgSelY1 "|" imgSelX2 "|" imgSelY2)
   ; fnOutputDebug("pppcoords = " ppx1 "|" ppy1 "|" ppx2 "|" ppy2 "||" ppx2 - ppx1 "//" ppy2 - ppy1 " | Z | " ppofYa "|" ppofYb)
   ; ToolTip, % Round(innerSelectionCavityX, 2) "|" Round(innerSelectionCavityY, 2) "|" Round(exclusion, 2) , , , 2
   ; ToolTip, % round(w/h, 2) "|" round(mod(rotation, 45), 2) "°|" w "|" h "`n"  rw "|" rh "`n" Round(xf, 2) "|" Round(yf, 2) , , , 2
   ; ToolTip, % round(xf, 2) "|" round(yf, 2) "|"  round(rotation, 2) "|" Round(exclusion, 2) , , , 2
   r := DllCall(whichMainDLL "\prepareSelectionArea", "int", x1, "int", y1, "int", x2, "int", y2, "int", w, "int", h, "float", xf, "float", yf, "float", rotation, "int", mode, "int", doFlip, "float", exclusion, "int", invertArea, "UPtr", &PointsF, "int", PointsCount, "int", ppx1, "int", ppy1, "int", ppx2, "int", ppy2, "int", useCache, "int", ppofYa, "int", ppofYb)
   If (r!=1)
      addJournalEntry("ERROR: " A_ThisFunc "() failed via DLL: prepareSelectionArea()")

   PointsF := ""
   If (pPath!="")
      Gdip_DeletePath(pPath)
   ; ToolTip, % PointsCount "|" A_TickCount - startZeit , , , 2
   Return r
}

resizeBitmapToGivenRef(pBitmap, refBMP, nW:=0, nH:=0, thisImgQuality:=5, keepRatio:=0) {
    If validBMP(pBitmap)
       trGdip_GetImageDimensions(pBitmap, tW, tH)
    If (validBMP(refBMP) && refBMP)
       trGdip_GetImageDimensions(refBMP, nW, nH)

    If ((tW!=nW || tH!=nH) && tW && tH && nW && nH && validBMP(pBitmap))
    {
       ; fnOutputDebug("o_bgr resizing")
       tempBMP := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, nW, nH, keepRatio, thisImgQuality, 0, 0)
       If validBMP(tempBMP)
       {
          trGdip_DisposeImage(pBitmap, 1)
          pBitmap := tempBMP
       }
    }
    Return pBitmap
}

QPV_MergeBitmapsWithMask(initialBitmap, newBitmap, alphaBitmap, invert, maskOpacity:=0, invertOpacity:=0, previewMode:=0, whichChannel:=0) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(newBitmap, w, h)
  trGdip_GetImageDimensions(initialBitmap, w2, h2)
  ; ToolTip, % w "|" h "`n" w2 "|" h2 , , , 2
  If (!validBMP(newBitmap) || !validBMP(initialBitmap))
  {
     addJournalEntry(A_ThisFunc "(): ERROR. Invalid bitmaps provided.")
     Return 0
  }

  isOkay := (w2=w && h2=h) ? 1 : 0 
  If validBMP(alphaBitmap)
  {
     trGdip_GetImageDimensions(alphaBitmap, w3, h3)
     tisOkay := (w3=w && h3=h) ? 1 : 0 
  } Else tisOkay := 1

  If (!w || !h || !w2 || !h2 || !isOkay || !tisOkay)
  {
     addJournalEntry(A_ThisFunc "(): ERROR. Bitmaps dimensions mismatched. " w3 "/" h3 " | " w2 "/" h2 " | " w "/" h)
     Return 0
  } ; Else
     ; addJournalEntry(A_ThisFunc "(): Bitmaps dimensions. " w3 "/" h3 " | " w2 "/" h2 " | " w "/" h)

  E1 := Gdip_LockBits(initialBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  E2 := Gdip_LockBits(newBitmap, 0, 0, w, h, nstride, nScan, nData, 1)
  If validBMP(alphaBitmap)
  {
     E3 := Gdip_LockBits(alphaBitmap, 0, 0, w, h, mstride, mScan, mData, 1)
     If E3
     {
        alphaBitmap := trGdip_DisposeImage(alphaBitmap)
        alphaBitmap := 0
     }
  } Else alphaBitmap := 0

  If (!E1 && !E2)
     r := DllCall(whichMainDLL "\MergeBitmapsWithMask", "UPtr", iScan, "UPtr", nScan, "UPtr", mScan, "int", invert, "Int", w, "Int", h, "int", maskOpacity, "int", invertOpacity, "int", stride, "int", 32, "int", userimgGammaCorrect, "int", whichChannel)

  ; ToolTip, % A_PtrSize "=" A_LastError "==" r "=" func2exec "=" SecToHHMMSS(Round(zeitOperation/1000, 3)) , , , 2
  If !E1
     Gdip_UnlockBits(initialBitmap, iData)
  If !E2
     Gdip_UnlockBits(newBitmap, nData)
  If (!E3 && validBMP(alphaBitmap))
     Gdip_UnlockBits(alphaBitmap, mData)

  zeitOperation := A_TickCount - thisStartZeit
  return r
}

QPV_ColorizeGrayImage(pBitmap, thisColorA, thisColorB, linearu) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  ; ToolTip, % w "|" h "`n" w2 "|" h2 , , , 2
  If (!w || !h || !validBMP(pBitmap))
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, nScan, nData, 3)
  If !E1
  {
     r := DllCall(whichMainDLL "\ColorizeGrayImage", "UPtr", nScan, "int", w, "int", h, "int", stride, "int", 32, "int", linearu, "int", thisColorA, "int", thisColorB)
     Gdip_UnlockBits(pBitmap, nData)
  }
  ; ToolTip, % r "|" E1 "|" thisColorA "|" thisColorB , , , 2
  zeitOperation := A_TickCount - thisStartZeit
  return r
}

QPV_EraserBrush(pBitmap, pBitmapMask, invertAlphaMask, replaceMode, levelAlpha, offsetX, offsetY, clonescu) {
  ; thisStartZeit := A_TickCount
  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  trGdip_GetImageDimensions(pBitmapMask, w2, h2)
  If (!validBMP(pBitmap) || !validBMP(pBitmapMask))
     Return 0

  w3 := (offsetX<0) ? w2 - Abs(offsetX) : w2
  h3 := (offsetY<0) ? h2 - Abs(offsetY) : h2
  offX := (offsetX<0) ? Abs(offsetX) : 0
  offY := (offsetY<0) ? Abs(offsetY) : 0
  offsetX := (offsetX<0) ? 0 : offsetX
  offsetY := (offsetY<0) ? 0 : offsetY
  If (offsetX + w3>=w)
     w3 -= (offsetX + w3 - w)
  If (offsetY + h2>=h)
     h3 -= (offsetY + h3 - h)

  initQPVmainDLL()
  If (w3<1 || h3<1 || !qpvMainDll)
     Return 0

  E1 := Gdip_LockBits(pBitmap, offsetX, offsetY, w3, h3, strideA, iScan, iData)
  E2 := Gdip_LockBits(pBitmapMask, offX, offY, w3, h3, strideB, mScan, mData, 1)
  If clonescu
     E3 := Gdip_LockBits(clonescu, offsetX, offsetY, w3, h3, strideC, cScan, cData)

  If (!E1 && !E2)
  {
     useClone := (!E3 && clonescu) ? 1 : 0
     r := DllCall(whichMainDLL "\EraserBrush", "UPtr", iScan, "UPtr", mScan, "Int", w3, "Int", h3, "Int", invertAlphaMask, "Int", replaceMode, "Int", levelAlpha, "UPtr", cScan, "int", useClone)
     ; ToolTip, % r "=" ErrorLevel "=" A_LastError "`n" klop "`n" klopa "`n" kloxa "`n" "=" iScan "=" mScan "=" w2 "=" h2 "=" invertAlphaMask "=" replaceMode "=" levelAlpha "=" countClicks , , , 2
   }

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmapMask, mData)
  If (!E3 && clonescu)
     Gdip_UnlockBits(clonescu, cData)
  ; ToolTip, % "qpv_" r "=" e1 "=" e "`n" offsetX "=" offsetY "`n" w2 "=" h2, , , 2
  return r
}

QPV_ColourBrush(pBitmap, pBitmapMask, invertAlphaMask, newColor, replaceMode, levelAlpha, blendMode, offsetX, offsetY, clonescu, ByRef opacityBMPmap, overDraw, flipLayers) {
  ; thisStartZeit := A_TickCount
  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  trGdip_GetImageDimensions(opacityBMPmap, wa, ha)
  trGdip_GetImageDimensions(pBitmapMask, w2, h2)
  If (!validBMP(pBitmap) || !validBMP(pBitmapMask) || !validBMP(opacityBMPmap))
     Return 0

  w3 := (offsetX<0) ? w2 - Abs(offsetX) : w2
  h3 := (offsetY<0) ? h2 - Abs(offsetY) : h2
  offX := (offsetX<0) ? Abs(offsetX) : 0
  offY := (offsetY<0) ? Abs(offsetY) : 0
  offsetX := (offsetX<0) ? 0 : offsetX
  offsetY := (offsetY<0) ? 0 : offsetY
  If (offsetX + w3>=w)
     w3 -= (offsetX + w3 - w)
  If (offsetY + h2>=h)
     h3 -= (offsetY + h3 - h)

  initQPVmainDLL()
  If (w3<1 || h3<1 || !qpvMainDll)
     Return 0

  E1 := Gdip_LockBits(pBitmap, offsetX, offsetY, w3, h3, strideA, iScan, iData)
  E2 := Gdip_LockBits(pBitmapMask, offX, offY, w3, h3, strideB, mScan, mData, 1)
  E4 := Gdip_LockBits(opacityBMPmap, offsetX, offsetY, w3, h3, strideD, kScan, kData, 3)
  ; ToolTip, % opacityBMPmap "===" wa "/" ha "`n" w "/" h , , , 2

  If validBMP(clonescu)
     E3 := Gdip_LockBits(clonescu, offsetX, offsetY, w3, h3, strideC, cScan, cData)

  If (!E1 && !E2)
  {
     Gdip_FromARGB(newColor, A, R, G, B)
     newColor := Gdip_ToARGB(A, R, G, B)
     useClone := (!E3 && clonescu) ? 1 : 0
     ; ToolTip, % levelAlpha "|" blendMode "`n" offsetX "|" offsetY "`n" rImgW "|" rImgH , , , 2
     r := DllCall(whichMainDLL "\ColourBrush", "UPtr", kScan, "UPtr", iScan, "UPtr", mScan, "int", newColor, "Int", w3, "Int", h3, "Int", invertAlphaMask, "Int", replaceMode, "Int", levelAlpha, "int", blendMode, "UPtr", cScan, "int", useClone, "int", overDraw, "int", userimgGammaCorrect, "int", w, "int", h, "int", offsetX, "int", offsetY, "int", flipLayers)
     ; ToolTip, % r "=" ErrorLevel "=" A_LastError "`n" klop "`n" klopa "`n" kloxa "`n" "=" iScan "=" mScan "=" w2 "=" h2 "=" invertAlphaMask "=" replaceMode "=" levelAlpha "=" countClicks , , , 2
  }

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmapMask, mData)
  If !E4
     Gdip_UnlockBits(opacityBMPmap, kData)
  If (!E3 && validBMP(clonescu))
     Gdip_UnlockBits(clonescu, cData)
  ; ToolTip, % "qpv_" r "=" e1 "=" e "`n" offsetX "=" offsetY "`n" w2 "=" h2, , , 2
  return r
}

QPV_PrepareAlphaChannelBlur(pBitmap, givenLevel, fillMissingOnly) {
; this function fills / replaces black pixels [and opacity 0] with surrounding colors
; this helps mitigate the dark hallows that emerge when applying blur on images with areas that are fully transparent 
; the function can also be used to specify an opacity/alpha level of the image

  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV .dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !validBMP(pBitmap))
  {
     addJournalEntry(A_ThisFunc "(): failed - possibly malformed pBitmap given: " pBitmap)
     Return 0
  }

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If !E1
  {
     r := DllCall(whichMainDLL "\PrepareAlphaChannelBlur", "UPtr", iScan, "Int", w, "Int", h, "Int", givenLevel, "Int", fillMissingOnly, "Int", threads)
     Gdip_UnlockBits(pBitmap, iData)
  } Else 
     addJournalEntry(A_ThisFunc "(): failed - unable to lock the bitmap bits")

  ; ToolTip, % "qpv_alpha " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_AlterAlphaChannel(pBitmap, givenLevel, replaceAll) {
  ; thisStartZeit := A_TickCount
  If (givenLevel=0 && replaceAll=0)
     Return 1

  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV .dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !validBMP(pBitmap))
  {
     addJournalEntry(A_ThisFunc "(): failed - possibly malformed pBitmap given: " pBitmap)
     Return 0
  }

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If !E1
  {
     r := DllCall(whichMainDLL "\AlterBitmapAlphaChannel", "UPtr", iScan, "Int", w, "Int", h, "int", stride, "int", 32, "Int", givenLevel, "int", replaceAll)
     Gdip_UnlockBits(pBitmap, iData)
  } Else 
     addJournalEntry(A_ThisFunc "(): failed - unable to lock the bitmap bits")

  ; ToolTip, % "qpv_alpha " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_FillBitmapHoles(pBitmap, newColor) {
  ; thisStartZeit := A_TickCount
  initQPVmainDLL()
  If isWinXP
     Return

  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h || !validBMP(pBitmap))
  {
     addJournalEntry(A_ThisFunc "(): failed - possibly malformed pBitmap given: " pBitmap)
     Return 0
  }

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If !E1
     r := DllCall(whichMainDLL "\FillImageHoles", "UPtr", iScan, "Int", w, "Int", h, "UInt", newColor)
  ; fnOutputDebug(A_ThisFunc ": " func2exec "=r" r "=e" E1 "|" A_LastError)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  return r
}

QPV_BlendBitmaps(pBitmap, pBitmap2Blend, blendMode, protectAlpha:=0, flipLayers:=0, gamma:=0, faderMode:=0) {
  initQPVmainDLL()
  If (!qpvMainDll || isWinXP=1)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return
  }

  thisStartZeit := A_TickCount
  trGdip_GetImageDimensions(pBitmap, w, h)
  trGdip_GetImageDimensions(pBitmap2Blend, w2, h2)
  ; fnOutputDebug(A_ThisFunc "() " w "=" w2 "||" h "=" h2)
  If (w2!=w || h2!=h || !validBMP(pBitmap) || !validBMP(pBitmap2Blend) || !w ||)
  {
     addJournalEntry(A_ThisFunc "(): failed to apply blending modes; incorrect bitmaps provided")
     Return 0
  }

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  E2 := Gdip_LockBits(pBitmap2Blend, 0, 0, w, h, stride, mScan, mData, 1)
  If (!E1 && !E2)
     r := DllCall(whichMainDLL "\BlendBitmaps", "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", stride, "Int", 32, "Int", blendMode, "int", flipLayers, "int", faderMode, "int", protectAlpha, "int", gamma)

  ; fnOutputDebug(A_ThisFunc "() " A_LastError " r=" r "=" func2exec "=" A_TickCount - thisStartZeit "|" blendMode)
  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmap2Blend, mData)
  return r
}

QPV_ResizeBitmap(pBitmap, newW, newH, interpolation:=1, bond:=2) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return
  }

  If !validBMP(pBitmap)
  {
     addJournalEntry(A_ThisFunc "(): invalid bitmap to process")
     Return
  }

  trGdip_GetImageDimensions(pBitmap, w, h)
  If (w<1 || h<1)
     Return 0

  r := DllCall(whichMainDLL "\cImgResizeBitmap", "UPtr", pBitmap, "Int", w, "Int", h, "int", newW, "int", newH, "Int", interpolation, "int", bond, "UPtr")
  If StrLen(r)>2
  {
     recordGdipBitmaps(r, A_ThisFunc)
     Return r
  }

  Return 0
}

test_cImgLoadBitmap() {
; unsused - it does not work
   imgPath := resultedFilesList[currentFileIndex, 1]
   If (!imgPath || !FileExist(imgPath))
      Return

   GetWinClientSize(w, h, PVhwnd, 0)
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   pBitmap := QPV_cImgLoadBitmap(imgPath, w, h)
   If pBitmap
   {
      tzGdip_DrawImageFast(2NDglPG, pBitmap)
      doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
      trGdip_DisposeImage(pBitmap)
   }
}

QPV_cImgLoadBitmap(imgPath, w, h, interpolation:=1, bond:=2) {
; unsused - it does not work

  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return
  }

  r := DllCall(whichMainDLL "\cImgLoadBitmap", "AStr", imgPath, "Int", w, "Int", h, "Int", interpolation, "int", bond, "UPtr")
  If StrLen(r)>2
  {
     recordGdipBitmaps(r, A_ThisFunc)
     Return r
  }

  Return 0
}

QPV_CreateBitmapNoise(W, H, intensity, doGray, threads, fillBgr) {
  initQPVmainDLL()
  If (!qpvMainDll || isWinXP=1)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return
  }

  thisStartZeit := A_TickCount
  If (!w || !h)
     Return 0

  pBitmap := trGdip_CreateBitmap(A_ThisFunc, W, H, "0x26200A")
  If !validBMP(pBitmap)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If !E1
  {
     r := DllCall(whichMainDLL "\GenerateRandomNoise", "UPtr", iScan, "Int", w, "Int", h, "Int", intensity, "Int", doGray, "Int", threads, "Int", fillBgr)
     Gdip_UnlockBits(pBitmap, iData)
  }

  ; ToolTip, % E1 "==" r " == " pBitmap "==" W "x" H, , , 2
  ; ToolTip, % "r=" r " ; qpv == " A_TickCount - thisStartZeit, , , 2
  return pBitmap
}

QPV_CreatePlasmaBMP(W, H, intensity, details, scaleu, doGray, blurX, blurY, doBlur, fillBgr) {
  initQPVmainDLL()
  If (!qpvMainDll || isWinXP=1)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return
  }

  thisStartZeit := A_TickCount
  If (!w || !h)
     Return 0

  pBitmap := DllCall(whichMainDLL "\GenerateCIMGnoiseBitmap", "Int", w, "Int", h, "Int", intensity, "Int", details, "Int", scaleu, "int", blurX, "int", blurY, "int", doBlur, "UPtr")
  If StrLen(pBitmap)>2
     recordGdipBitmaps(pBitmap, A_ThisFunc)

  If (validBMP(pBitmap) && fillBgr=1)
     Gdip_BitmapSetColorDepth(pBitmap, 24)

  If (validBMP(pBitmap) && doGray=1)
  {
     pEffectGray := Gdip_CreateEffect(6, 0, -100, 0)
     Gdip_BitmapApplyEffect(pBitmap, pEffectGray)
     Gdip_DisposeEffect(pEffectGray)
  }
  ; ToolTip, % "r=" r " ; qpv == " A_TickCount - thisStartZeit, , , 2
  return pBitmap
}

generateAlphaMaskBitmap(clipBMP, previewMode, offX:=0, offY:=0, offW:=0, offH:=0, sizeIDu:=0, doGrayScale:=0, transformTool:=0) {
    Static prevBMPu, prevState
    If (clipBMP="last")
    {
       If !validBMP(prevBMPu)
          Return

       Return trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
    } Else If (clipBMP="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       backupGdiBMP := trGdip_DisposeImage(backupGdiBMP, 1)
       realtimePasteInPlaceAlphaMaskRotator("kill", 0, 0, 0)
       Return
    }

    If IsObject(offX)
    {
       selObj := offX.Clone()
       offX := 0
    }

    If (offX>2 && offY>2 && !offW && !offH)
    {
       rImgW := offX
       rImgH := offY
       offX := offY := 0
    } Else trGdip_GetImageDimensions(clipBMP, rImgW, rImgH)
    ; fnOutputDebug(A_ThisFunc "(): " offX "=" offY "|" offW "=" offH  "|" rImgW "=" rImgH)

    If IsObject(selObj)
    {
       rImgW := selObj.zw
       rImgH := selObj.zh
       offX := offY := 0
    }

    If (!offW || !offH)
    {
       offX := offY := 0
       offW := rImgW
       offH := rImgH
    }

    If (alphaMaskRefBMP=1)
       thisAlphaFile := userAlphaMaskBmpPainted
    Else If (alphaMaskRefBMP=2)
       thisAlphaFile := (previewMode!=1 && validBMP(backupGdiBMP)) ? backupGdiBMP : useGdiBitmap()
    Else If (alphaMaskRefBMP=3 && transformTool=1)
       thisAlphaFile := (previewMode=1) ? viewportStampBMP : userClipBMPpaste

    ; fnOutputDebug(A_ThisFunc "(): refBMP=" alphaMaskRefBMP " | transformTool=" transformTool " | " thisAlphaFile)
    sizeIDu := sizeIDu ? sizeIDu : "a" rImgW rImgH
    externBMP := (alphaMaskingMode=5 && validBMP(thisAlphaFile)) ? 1 : 0
    pa := "a"
    If (externBMP=1)
    {
       trGdip_GetImageDimensions(externBMP, oW, oH)
       pa := "a" oW oH
    }

    thisState := "a" externBMP previewMode thisAlphaFile VPselRotation sizeIDu getAlphaMaskIDu() pa brushZeitung
    If (thisState=prevState && validBMP(prevBMPu))
    {
       ; fnOutputDebug("cached alpha mask bitmap used")
       Return prevBMPu
    }

    prevState := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    fnOutputDebug("redraw: " A_ThisFunc)
    allGood := 0
    ; ToolTip, % paintedImage "/" externBMP "l" alphaMaskingMode "|" thisAlphaFile "|c=" clipBMP "|f=" alphaMaskRefBMP, , , 2
    If (externBMP!=1)
    {
       alphaMaskGray := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
       If warnUserFatalBitmapError(alphaMaskGray, A_ThisFunc)
          Return
    }

    If (externBMP=1)
    {
       userAlpha := trGdip_CloneBitmap(A_ThisFunc, thisAlphaFile)
       trGdip_GetImageDimensions(userAlpha, testImgW, testImgH)
       msize := (testImgW + testImgH)//2
       threads := (previewMode=1) ? realSystemCores : 0
       If (validBMP(userAlpha) && testImgW>1 && testImgH>1)
       {
          If (!rImgW || !rImgH)
             trGdip_GetImageDimensions(userAlpha, rImgW, rImgH)

          brLvl := alphaMaskBMPbright
          contrLvl := alphaMaskBMPcontrast
          thisImgQuality := (PasteInPlaceQuality=1 && previewMode!=1) ? 7 : 5
          alphaMaskGray := realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlpha, rImgW, rImgH, thisImgQuality)
          rsize := (rImgW + rimgH)//2
          If !validBMP(alphaMaskGray)
          {
             addJournalEntry(A_ThisFunc "(): failed to rotate alpha mask")
             Return
          }

          If (AnyWindowOpen=70 && previewMode=1 || doGrayScale=1)
             QPV_ConvertToGrayscale(alphaMaskGray, alphaMaskBMPchannel, 100, 0)
          Else If (alphaMaskBMPchannel=5 || doGrayScale=1)
             QPV_ConvertToGrayscale(alphaMaskGray, alphaMaskBMPchannel, 100, 0)

          ; trGdip_GetImageDimensions(alphaMaskGray, zImgW, zImgH)
          ; ToolTip, % testImgW "=" testImgH "`n" rImgW "=" rimgH "`n" zImgW "=" zimgH "`n" thisAlphaFile "--" userAlpha , , , 2
          If (brLvl!=0 || contrLvl!=0)
          {
             pEffect := Gdip_CreateEffect(5, brLvl, contrLvl)
             Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
             Gdip_DisposeEffect(pEffect)
          }

          thisAlphaBlur := Round((alphaMaskGradientScale - 1)/302 * 255)
          If (previewMode=1)
             thisAlphaBlur := Round(thisAlphaBlur * (rsize / msize))

          If (thisAlphaBlur>1)
             QPV_BoxBlurBitmap(alphaMaskGray, thisAlphaBlur, thisAlphaBlur, 0)

          allGood := 1
          ; ToolTip, % clipBMP "--" alphaMaskGray "--" userAlpha "=" brLvl "=" contrLvl , , , 2
       } Else 
       {
          trGdip_DisposeImage(userAlpha, 1)
          addJournalEntry(A_ThisFunc ": failed to retrieve alpha mask image.")
       }
    } Else If (alphaMaskingMode=6 && customShapePoints.Count()>1)
    {
       pEffect := Gdip_CreateEffect(1, alphaMaskClrAintensity, 0)
       alphaPath := Gdip_CreatePath()
       fAgScal := (alphaMaskGradientScale + 2)/100
       tempArray := StrSplit(initialCustomShapeCoords, "|")
       calcIMGdimensions(tempArray[3], tempArray[4], rImgW, rImgH, rW, rH)
       tRimgW := (tempArray[3]>1) ? Round(rW*fAgScal) : Round(rImgW*fAgScal)
       tRimgH := (tempArray[4]>1) ? Round(rH*fAgScal) : Round(rImgH*fAgScal)
       offX := rImgW - tRimgW + Round((rImgW*alphaMaskOffsetX)*(fAgScal+1))
       offY := rImgH - tRimgH + Round((rImgH*alphaMaskOffsetY)*(fAgScal+1))
       doDeduping := (alphaMaskClrBintensity>250) ? 0 : 1
       PointsList := convertCustomShape2givenArea(customShapePoints, 1 + offX//2, 1 + offY//2, tRimgW - 2, tRimgH - 2, 1, doDeduping)
       tensionLvl := Round(alphaMaskClrBintensity/255, 2)
       If (alphaMaskClrBintensity>250 && alphaPath)
          Gdip_AddPathBeziers(alphaPath, PointsList)
       Else If (alphaMaskClrBintensity<15 && alphaPath)
          Gdip_AddPathPolygon(alphaPath, PointsList)
       Else If alphaPath
          Gdip_AddPathClosedCurve(alphaPath, PointsList, tensionLvl)

       pra := (alphaMaskGradientAngle>0) ? alphaMaskGradientAngle : 360 + alphaMaskGradientAngle
       If (alphaMaskGradientAngle!=0 && IsNumber(alphaMaskGradientAngle) && alphaPath)
          trGdip_RotatePathAtCenter(alphaPath, pra, 1, 0, 1, 1)

       G4 := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray, 7, 4)
       trGdip_GraphicsClear(A_ThisFunc, G4, "0xFF000000")
       If G4
       {
          BrushB := Gdip_BrushCreateSolid("0xFFFFFFFF")
          Gdip_SetClipRect(G4, 0, 0, rImgW, rImgH)
          Gdip_FillPath(G4, BrushB, alphaPath)
          Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
          Gdip_DeleteBrush(BrushB)
          allGood := 1
       }

       Gdip_DisposeEffect(pEffect)
       Gdip_DeletePath(alphaPath)
       ; Gdip_DeleteBrush(BrushA)
       Gdip_DeleteGraphics(G4)
    } Else If isInRange(alphaMaskingMode, 2, 4)
    {
       thisColorA := Gdip_ToARGB("0xFF", alphaMaskClrAintensity, alphaMaskClrAintensity, alphaMaskClrAintensity)
       thisColorB := Gdip_ToARGB("0xFF", alphaMaskClrBintensity, alphaMaskClrBintensity, alphaMaskClrBintensity)
       ; ToolTip, % thisColorA "`n" thisColorB, , , 2
       brImgSelW := rImgW*(alphaMaskGradientScale/100)
       brImgSelH := rImgH*(alphaMaskGradientScale/100)
       gradientWrapMode := alphaMaskGradientWrapped - 1
       pra := (alphaMaskGradientAngle>0) ? alphaMaskGradientAngle : 360 + alphaMaskGradientAngle
       If (alphaMaskingMode=2)
       {
          brimgSelPx := 0 - (brImgSelW - rImgW)//2
          brimgSelPy := 0 - (brImgSelH - rImgH)//2
          gradBrush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + Round(brImgSelW*alphaMaskOffsetX), brimgSelPy + Round(brImgSelH*alphaMaskOffsetY), brimgSelW, brimgSelH, thisColorA, thisColorB, 1, clampInRange(gradientWrapMode, 0, 3, 1))
          If gradBrush
          {
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, [alphaMaskGradientPosA/200, alphaMaskGradientPosB/200], [thisColorA, thisColorB])
             Gdip_RotateLinearGrBrushAtCenter(gradBrush, Mod(Round(pra + VPselRotation), 360), 1)
          }
       } Else If (alphaMaskingMode=3 || alphaMaskingMode=4)
       {
          cX := Round(rImgW * (0.5 + alphaMaskOffsetX + alphaMaskCoffsetX * alphaMaskGradientScale/100))
          cY := Round(rImgH * (0.5 + alphaMaskOffsetY + alphaMaskCoffsetY * alphaMaskGradientScale/100))
          brimgSelPx := Round(rImgW/2 * (1 + 2 * alphaMaskOffsetX) - brImgSelW/2)
          brimgSelPy := Round(rImgH/2 * (1 + 2 * alphaMaskOffsetY) - brImgSelH/2)
          cX := clampInRange(cX, brimgSelPx, brimgSelPx + brImgSelW)
          cY := clampInRange(cY, brimgSelPy, brimgSelPy + brImgSelH)
          grpPath := Gdip_CreatePath()
          If (alphaMaskingMode=3 && grpPath)
             Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
          Else If grpPath
             Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

          If grpPath
             gradBrush := Gdip_PathGradientCreateFromPath(grpPath)

          If gradBrush
          {
             Gdip_PathGradientSetCenterPoint(gradBrush, cX, cY)
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, [alphaMaskGradientPosA/200, alphaMaskGradientPosB/200], [thisColorA, thisColorB])
             Gdip_RotatePathGradientAtCenter(gradBrush, Mod(Round(pra + VPselRotation), 360), 1)
             Gdip_PathGradientSetWrapMode(gradBrush, gradientWrapMode)
          }

          Gdip_DeletePath(grpPath)
       }

       Ga := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray)
       If Ga
       {
          trGdip_GraphicsClear(A_ThisFunc, Ga, thisColorB)
          Gdip_SetClipRect(Ga, offX, offY, offW, offH)
          ; ToolTip, % offX "=" offY "|" offW "=" offH  "|" rImgW "=" rImgH , , , 2
          Gdip_FillRectangle(Ga, gradBrush, 0, 0, rImgW, rImgH)
          Gdip_DeleteGraphics(Ga)
          allGood := 1
       }

       Gdip_DeletePath(pPath)
       Gdip_DeleteBrush(gradBrush)
    }

    If (allGood=1)
    {
       prevState := (minimizeMemUsage=0 && previewMode=1) ? thisState : 0
       prevBMPu := (minimizeMemUsage=0 && previewMode=1) ? alphaMaskGray : 0
       Return alphaMaskGray
    } Else prevState := 0

    trGdip_DisposeImage(alphaMaskGray, 1)
} ; // generateAlphaMaskBitmap()

realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, givenID, ByRef newBitmap, offX:=0, offY:=0, offW:=0, offH:=0, transformTool:=0, initialBitmap:=0, maskOpacity:=0) {
    Static prevBMPu, prevState
    If (previewMode="kill")
    {
       prevState := 0
       realtimePasteInPlaceAlphaMaskRotator("kill", 0, 0, 0)
       generateAlphaMaskBitmap("kill", 0)
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    doMerger := validBMP(initialBitmap) ? 1 : 0
    If (coreDesiredPixFmt="0x21808" && doMerger=0)
       Return

    newBitmap := ""
    pa := "a"
    trGdip_GetImageDimensions(clipBMP, oImgW, oImgH)
    If (doMerger=1)
    {
       trGdip_GetImageDimensions(initialBitmap, oW, oH)
       pa := "a" oW oH
    }

    thisState := "a" givenID oImgW oImgH maskOpacity doMerger pa brushZeitung
    If (thisState=prevState && validBMP(prevBMPu))
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       If !validBMP(newBitmap)
          addJournalEntry("An error occured in " A_ThisFunc "(). Invalid cached bitmap cloned.")

       Return
    }

    prevState := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    newBitmap := (doMerger=1) ? trGdip_CloneBitmap(A_ThisFunc, initialBitmap) : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    If !validBMP(newBitmap)
    {
       addJournalEntry("An error occured in " A_ThisFunc "(). Invalid bitmap to process. doMerger=" doMerger)
       Return
    }

    ; paintedImage := (InStr(alphaMaskRefBMP, "user-painted") && alphaMaskingMode=5) ? 1 : 0
    alphaMaskGray := generateAlphaMaskBitmap(newBitmap, previewMode, offX, offY, offW, offH, 0, 0, transformTool)
    If !validBMP(alphaMaskGray)
    {
       addJournalEntry(A_ThisFunc "(). ERROR. Alpha mask bitmap was not succesfully created.")
       Return
    }

    If IsObject(offX)
    {
       ; ToolTip, % "cropping" , , , 2
       vpWinClientSize(mainWidth, mainHeight)
       thisu := ((offX.sw != offX.dh || offX.sh != offX.dh) && offX.invertArea=0) ? 1 : 0
       If ((!isSelEntirelyWithinIMGbounds() || !isSelEntireVisible(mainWidth, mainHeight)) && offX.invertArea=0 || offX.invertArea=1 || offX.forceRect=1 || thisu=1)
       {
          thisAlphaBitmap := getRectFromBitmap(alphaMaskGray, offX, 1)
          If validBMP(thisAlphaBitmap)
             alphaMaskGray := thisAlphaBitmap
       }
    }

    If (doMerger=1)
       r := QPV_MergeBitmapsWithMask(newBitmap, clipBMP, alphaMaskGray, alphaMaskColorReversed, maskOpacity, 0, previewMode)
    Else
       r := QPV_SetBitmapAsAlphaChannel(newBitmap, alphaMaskGray, alphaMaskColorReversed, alphaMaskReplaceMode, alphaMaskBMPchannel)

    If !r
       addJournalEntry(A_ThisFunc "(): Failed to apply alpha mask to bitmap")

    ; fnOutputDebug(A_ThisFunc "(): transformTool=" transformTool " | merger=" doMerger  " | preview=" previewMode)
    trGdip_DisposeImage(thisAlphaBitmap, 1)
    If (previewMode!=1)
    {
       trGdip_DisposeImage(alphaMaskGray, 1)
       SetTimer, ResetImgLoadStatus, -100
    }

    fnOutputDebug("redraw: " A_ThisFunc)
    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : trGdip_CloneBitmap(A_ThisFunc, newBitmap)
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    Return
}

applyPersonalizedColorsBMP(clipBMP, doBlur, blurStrength, applyColorFX) {
    canApplyFX := (PasteInPlaceHue!=0 || PasteInPlaceSaturation!=0) ? 1 : 0
    If (!isWinXP && canApplyFX=1 && applyColorFX=1)
    {
       If (BrushToolRandomHue>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomHue
          gR := Randomizer(-gR, gR, 2, 10)
          H := clampInRange(PasteInPlaceHue + gR, -180, 180)
       } Else H := PasteInPlaceHue
 
       If (BrushToolRandomSat>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomSat
          gR := Randomizer(-gR, gR, 2, 11)
          S := clampInRange(PasteInPlaceSaturation + gR, -100, 100)
       } Else S := PasteInPlaceSaturation

       zEffect := Gdip_CreateEffect(6, H, S, 0)
       Gdip_BitmapApplyEffect(clipBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    canApplyFX := (PasteInPlaceLight!=0 || PasteInPlaceGamma!=0) ? 1 : 0
    If (!isWinXP && canApplyFX=1 && applyColorFX=1)
    {
       If (BrushToolRandomLight>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomLight
          gR := Randomizer(-gR, gR, 8, 8)
          L := clampInRange(PasteInPlaceLight + gR, -255, 255)
          ; ToolTip, % gR "===" gRz "`n" startToolColor "`n" o_startToolColor , , , 2
       } Else L := PasteInPlaceLight

       If (BrushToolRandomDark>0 && liveDrawingBrushTool=1 && AnyWindowOpen=64)
       {
          gR := BrushToolRandomDark
          gR := Randomizer(-gR, gR, 8, 9)
          D := clampInRange(PasteInPlaceGamma + gR, -100, 100)
       } Else D := PasteInPlaceGamma

       zEffect := Gdip_CreateEffect(5, L, D)
       Gdip_BitmapApplyEffect(clipBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (blurStrength>2 && doBlur=1)
    {
       ; QPV_BoxBlurBitmap(clipBMP, blurStrength, blurStrength, 0)
       pEffect := Gdip_CreateEffect(1, blurStrength, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, clipBMP, blurStrength, pEffect, 0)
       Gdip_DisposeEffect(pEffect)
    }
}

getPrevAlphaMaskCoords(ByRef imgSelPx, ByRef imgSelPy, ByRef ResizedW, ByRef ResizedH, vPimgSelW, vPimgSelH, vPimgSelX, vPimgSelY) {
   ; imgSelW := Round( max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2) )
   ; imgSelH := Round( max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2) )
   imgSelPx := Round(vpImgSelX + vpImgSelW * prevAlphaMaskCoordsPreview[1])
   imgSelPy := Round(vpImgSelY + vpImgSelH * prevAlphaMaskCoordsPreview[2])
   imgSelPax := Round(vpImgSelX + vpImgSelW * prevAlphaMaskCoordsPreview[3])
   imgSelPay := Round(vpImgSelY + vpImgSelH * prevAlphaMaskCoordsPreview[4])
   ResizedW := imgSelPax - imgSelPx
   ResizedH := imgSelPay - imgSelPy
   ; ToolTip, % imgSelPx "|" imgSelPy "||" imgSelPax "|" imgSelPay "||" ResizedW "|" ResizedH , , , 2
}

recordPrevAlphaMaskCoords(imgSelPx, imgSelPy, ResizedW, ResizedH) {
   ImageCoords2Window(imgSelX1, imgSelY1, prevDestPosX, prevDestPosY, 1, outX, outY)
   getVPselSize(imgSelW, imgSelH, 0, 0)
   xx := (imgSelPx - outX) / imgSelW
   yy := (imgSelPy - outY) / imgSelH
   x := (imgSelPx + ResizedW - outX) / imgSelW
   y := (imgSelPy + ResizedH - outY) / imgSelH
   prevAlphaMaskCoordsPreview := [xx, yy, x, y]
   ; ToolTip, % xx "|" yy "|" x "|" y , , , 2
   ; prevAlphaMaskCoordsPreview := [imgSelPx, imgSelPy, ResizedW, ResizedH]
}

corePasteInPlaceActNow(G2:=0, whichBitmap:=0, brushingMode:=0) {
    Critical, on
    Static prevImgCall, prevClipBMP, eImgW, eImgH, hasRotated, thisHasRan
         , lastInvoked := 1, blr := {0:0, 1:0, 2:15, 3:50, 4:120, 5:180, 6:254}

    If (G2="kill" && thisHasRan=1)
    {
       ; fnOutputDebug("remove transform tool caches")
       thisHasRan := 0
       LoadCachableBitmapFromFile("kill")
       realtimePasteInPlaceRotator("kill", 2, lol)
       realtimePasteInPlaceBlurrator("kill", 2, lol)
       realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
       getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       backupGdiBMP := trGdip_DisposeImage(backupGdiBMP, 1)
       userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
       If (keepUserPaintAlphaMask!=1)
          userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted, 1)
       viewportIDstampBMP := ""
       Return
    }

    If ((doImgEditLivePreview!=1 && !G2) || (G2="kill") || testSelectOutsideImgEntirely(useGdiBitmap()) && PasteInPlaceAutoExpandIMG=0 && !G2)
       Return

    If (G2)
    {
       If (PasteInPlaceEraseInitial=1)
          PasteInPlaceEraseArea(G2, previewMode)

       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       If (validBMP(userClipBMPpaste) && PasteInPlaceBlurAmount>1 && PasteInPlaceToolMode=0)
          QPV_PrepareAlphaChannelBlur(userClipBMPpaste, 1, 1)

       If validBMP(userClipBMPpaste)
          clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)

       If !validBMP(clipBMP)
       {
          addJournalEntry(A_ThisFunc "(): invalid bitmap to process: clipBMP.")
          Return "fail"
       }

       If (PasteInPlaceToolMode!=1)
          flipBitmapAccordingToViewPort(clipBMP, 1)

       trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
       previewMode := 0
    } Else
    {
       ; If (A_TickCount - lastInvoked < 60)
       ;    Return
       lastInvoked := A_TickCount
       G2 := 2NDglPG
       thisImgQuality := 5
       previewMode := 1
       brushingMode := isNowAlphaPainting()
       Gdip_ResetClip(G2)
       ; trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
       vpWinClientSize(mainWidth, mainHeight)
       trGdip_GetImageDimensions(useGdiBitmap(), thisW, thisH)
       objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, thisW, thisH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
       If (PasteInPlaceAdaptMode=3)
       {
          imgSelPx := objSel.oSelX,     imgSelPy := objSel.oSelY
          imgSelW  := objSel.oSelW,     imgSelH  := objSel.oSelH
       }

       opacityExtra := (PasteInPlaceOpacity>255) ? PasteInPlaceOpacity - 255 : 0 
       If (viewportQPVimage.imgHandle)
          opacityExtra := (oldSelectionArea[10]=32 && PasteInPlaceOpacity>255) ? clampInRange(PasteInPlaceOpacity - 255, 0, 255)*256 : 0 

       thisImgCall := "a" getIDimage(currentFileIndex) currentFileIndex viewportStampBMP viewportIDstampBMP PasteInPlaceOrientation VPselRotation PasteInPlaceBlurAmount PasteInPlaceLight PasteInPlaceHue PasteInPlaceSaturation PasteInPlaceGamma PasteInPlaceApplyColorFX PasteInPlaceBlendMode PasteInPlaceBlurEdgesSoft brushingMode shearImgX shearImgY getAlphaMaskIDu(0) PasteInPlaceRevealOriginal userImgAdjustInvertColors userImgAdjustAltSat userImgAdjustAltBright opacityExtra PasteInPlaceOrientFlipX PasteInPlaceOrientFlipY
       If (prevImgCall=thisImgCall && validBMP(prevClipBMP))
       {
          hasCached := 1
          clipBMP := prevClipBMP
       } Else
       {
          prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
          clipBMP := trGdip_CloneBitmap(A_ThisFunc, viewportStampBMP)
       }
    }
 
    thisHasRan := 1
    If (hasCached!=1)
    {
       fnOutputDebug("redraw: " A_ThisFunc)
       opacityExtra := (PasteInPlaceOpacity>255 && !viewportQPVimage.imgHandle) ? PasteInPlaceOpacity - 255 : 0
       If !(viewportQPVimage.imgHandle)
          QPV_AlterAlphaChannel(clipBMP, opacityExtra, 0)

       If (PasteInPlaceBlurAmount>0) || (PasteInPlaceToolMode=1 && (prevVPselRotation>0 || prevEllipseSelectMode>0 || previnnerSelectionCavityX>0 && previnnerSelectionCavityY>0))
       {
          realtimePasteInPlaceBlurrator(previewMode, clipBMP, newBitmap)
          If validBMP(newBitmap)
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       If (PasteInPlaceOrientation>1 || VPselRotation>0 || shearImgX!=0 || shearImgY!=0 || PasteInPlaceOrientFlipX=1 || PasteInPlaceOrientFlipY=1)
       {
          hasRotated := realtimePasteInPlaceRotator(previewMode, clipBMP, newBitmap)
          If validBMP(newBitmap)
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       } Else hasRotated := 0

       If (alphaMaskingMode>1 && brushingMode!=1 && !viewportQPVimage.imgHandle && PasteInPlaceBlendMode=1)
       {
          thisStartZeit := A_TickCount
          thisIDu := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation VPselRotation getAlphaMaskIDu() opacityExtra
          realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, thisIDu, newBitmap, 0, 0, 0, 0, 1)
          fnOutputDebug("before=" A_TickCount - thisStartZeit)
          If validBMP(newBitmap)
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       opacityExtra := (PasteInPlaceOpacity>255 && oldSelectionArea[10]=32) ? clampInRange(PasteInPlaceOpacity - 255, 0, 255)*256 : 0
       If (viewportQPVimage.imgHandle && (PasteInPlaceApplyColorFX=1 || opacityExtra>0) && previewMode=1)
       {
          If (PasteInPlaceApplyColorFX!=1)
             opacityExtra := (PasteInPlaceOpacity>255) ? PasteInPlaceOpacity - 255 : 0

          trGdip_GetImageDimensions(clipBMP, tw, th)
          QPV_PrepareHugeImgSelectionArea(0, 0, tW, tH, tW, tH, 0, 0, 0, 0, 0, 0)
          If (PasteInPlaceApplyColorFX=1)
             QPV_AdjustImageColors(clipBMP, 255, userImgAdjustInvertColors, userImgAdjustAltSat, Round(PasteInPlaceSaturation*655.35), userImgAdjustAltBright, Round(PasteInPlaceLight*257), 0, Round(PasteInPlaceGamma*655.30), 0, 0, 0, PasteInPlaceHue, 0, 0, 0, 300, 0, 0, 0, opacityExtra, -1, -1, -1, -1, 0, 0, 0, 65535, 0, 0, -1)
          Else If (opacityExtra!=0)
             QPV_AlterAlphaChannel(clipBMP, opacityExtra, 0)
             ; QPV_AlterAlphaChannel(clipBMP, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 300, 0, 0, 0, opacityExtra, -1, -1, -1, -1, 0, 0, 0, 65535, 0, 0, -1)
       } Else
          applyPersonalizedColorsBMP(clipBMP, 0, 0, PasteInPlaceApplyColorFX)
    }

    capped := (viewportQPVimage.imgHandle) ? 0 : 1
    trGdip_GetImageDimensions(clipBMP, oImgW, oImgH)
    PasteInPlaceCalcObjSize(previewMode, hasRotated, oImgW, oImgH, imgSelW, imgSelH, VPselRotation, capped, ResizedW, ResizedH)
    vPobju := testSelectionLargerThanViewport()
    Gdip_ResetClip(G2)
    If (previewMode=1)
       Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 0)

    mustClip := 0
    praz := (PasteInPlaceCropAngular>0) ? PasteInPlaceCropAngular : 360 + PasteInPlaceCropAngular
    ; ToolTip, % praz "|" VPselRotation "|" praz + VPselRotation , , , 2
    If (PasteInPlaceCropDo=1 && PasteInPlaceCropAdaptImg=0 && !viewportQPVimage.imgHandle)
    {
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, PasteInPlaceCropSel, VPselRotation + praz, rotateSelBoundsKeepRatio)
       mustClip := 1
    }

    PasteInPlaceCalcObjCoords(imgSelW, imgSelH, ResizedW, ResizedH, imgSelPx, imgSelPy)
    VPmpx := Round((ResizedW * ResizedH)/1000000, 3)
    MAINmpx := Round((mainWidth * mainHeight)/1000000, 3) + 2
    allowPreviewThis := (previewMode!=1 || VPmpx<MAINmpx || forceSlowLivePreviewMode=1) ? 1 : 0
    If (VPmpx>530 && previewMode=1)
       allowPreviewThis := 0

    If (brushingMode=1 && previewMode=1)
    {
       trGdip_GetImageDimensions(userAlphaMaskBmpPainted, zImgW, zImgH)
       viewportDynamicOBJcoords.x := imgSelPx, viewportDynamicOBJcoords.y := imgSelPy
       viewportDynamicOBJcoords.w := ResizedW, viewportDynamicOBJcoords.h := ResizedH
       viewportDynamicOBJcoords.zl := (ResizedW/zImgW + ResizedH/zImgH)/2 + 0.0001
       ; ToolTip, % zImgW "|" zImgH , , , 2
    }

    recordPrevAlphaMaskCoords(imgSelPx, imgSelPy, ResizedW, ResizedH)
    prevPasteInPlaceVPcoords := [imgSelPx, imgSelPy, ResizedW, ResizedH, hasRotated]
    If (brushingMode=1 && previewMode=1 && (allowPreviewThis!=1 || forceLiveAlphaPreviewMode=1))
    {
       prevImgCall := thisImgCall
       prevClipBMP := clipBMP
       Gdip_DeletePath(pPath)
       Return livePreviewAlphaMasking("live")
    }

    mustEraseAreaAfter := (BlendModesPreserveAlpha=1 && PasteInPlaceBlendMode>1) ? 1 : 0
    If (PasteInPlaceEraseInitial=1 && previewMode=1 && mustEraseAreaAfter=0)
       PasteInPlaceEraseArea(G2, previewMode)

    If (allowPreviewThis=1 && mustClip=1)
       Gdip_SetClipPath(G2, pPath, 1)

    If ((PasteInPlaceBlendMode>1 && allowPreviewThis=1) || (userimgGammaCorrect=1 && previewMode=1 && PasteInPlaceEraseInitial=0 && allowPreviewThis=1))
    {
       If (currIMGdetails.HasAlpha=1 && previewMode=1 && PasteInPlaceBlendMode>1 && !viewportQPVimage.imgHandle)
          o_bgrBMP := getImgOriginalSelectedAreaEdit(2, imgSelPx, imgSelPy, ResizedW, ResizedH, mainWidth, mainHeight, 1)
       Else If (previewMode=1)
          o_bgrBMP := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, ResizedW, ResizedH, 0, ResizedW, ResizedH)
       Else
          o_bgrBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, ResizedW, ResizedH, 0, 0, 1)
    }

    thisImgQuality := (userimgQuality=1 && previewMode!=1) ? 3 : 5
    If (PasteInPlaceBlendMode>1 && allowPreviewThis=1)
    {
       clipBMP := resizeBitmapToGivenRef(clipBMP, 0, ResizedW, ResizedH, thisImgQuality)
       o_bgrBMP := resizeBitmapToGivenRef(o_bgrBMP, 0, ResizedW, ResizedH, thisImgQuality)
       BlurAmount := (testSelectOutsideImgEntirely(useGdiBitmap()) || viewportQPVimage.imgHandle) ? 0 : blr[PasteInPlaceGlassy]
       If (previewMode=1)
       {
          MouseCoords2Image(imgSelPx, imgSelPy, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX1, kY1)
          MouseCoords2Image(imgSelPx + ResizedW, imgSelPy + ResizedH, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX2, kY2)
          kimgSelW := max(kX1, kX2) - min(kX1, kX2)
          kimgSelH := max(kY1, kY2) - min(kY1, kY2)
          msize := (kimgSelW + kimgSelH)//2
          rsize := (ResizedW + ResizedH)//2
          BlurAmount := Round(BlurAmount * (rsize / msize))
          If (zoomLevel>2 && !isSelEntireVisible(mainWidth, mainHeight) || imgSelLargerViewPort=1)
             BlurAmount := 0
       }

       thisFXstate := "a" whichBitmap getVPselIDs("saiz-vpos") previewMode BlurAmount "a" imgSelPx imgSelPy imgSelW imgSelH currentFileIndex getIDimage(currentFileIndex) oImgW oImgH currentUndoLevel currentSelUndoLevel FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevResizedVPimgW prevResizedVPimgH PasteInPlaceAdaptMode undoLevelsRecorded UserMemBMP ViewPortBMPcache getIDvpFX()
       ; bgrBMP := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, ResizedW, ResizedH, BlurAmount)
       If (validBMP(o_bgrBMP) && BlurAmount>1)
          bgrBMP := applyVPeffectsAdvOnBMP(o_bgrBMP, previewMode, thisFXstate, 0, 0, BlurAmount, 0)
       Else If validBMP(o_bgrBMP)
          bgrBMP := trGdip_CloneBitmap(A_ThisFunc, o_bgrBMP)

       If validBMP(bgrBMP)
       {
          ; fnOutputDebug("blend mode calculations")
          If (previewMode!=1)
             setWindowTitle("Applying blending mode")
          thisStartZeit := A_TickCount
          factoru := (previewMode=1) ? 2 : 3
          delayu := (previewMode=1) ? -1 : 2
          zr := QPV_BlendBitmaps(bgrBMP, clipBMP, PasteInPlaceBlendMode - 1, BlendModesPreserveAlpha, BlendModesFlipped)
       }
    }

    ; trGdip_GetImageDimensions(clipBMP, gimgW, gimgH)
    ; trGdip_GetImageDimensions(bgrBMP, wgimgW, wgimgH)
    ; fnOutputDebug("[" clipBMP "] " gImgW "==" gImgH " | [" bgrBMP "] "  wgImgW "==" wgImgH " | [" o_bgrBMP "] " dgImgW "==" dgImgH " | [target] " ResizedW "==" ResizedH)
    hasMasked := 0
    thisBMP := (validBMP(bgrBMP) && PasteInPlaceBlendMode>1) ? bgrBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    If (alphaMaskingMode>1 && !viewportQPVimage.imgHandle && (PasteInPlaceBlendMode>1 || brushingMode=1 && previewMode=1))
    {
       thisStartZeit := A_TickCount
       If (PasteInPlaceBlendMode=1)
          thisBMP := resizeBitmapToGivenRef(thisBMP, 0, ResizedW, ResizedH, thisImgQuality)

       thisIDu := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation VPselRotation getAlphaMaskIDu() opacityExtra thisImgCall thisFXstate BlendModesPreserveAlpha BlendModesFlipped userimgGammaCorrect brushZeitung
       realtimePasteInPlaceAlphaMasker(previewMode, thisBMP, thisIDu, newBitmap, 0, 0, 0, 0, 1, o_bgrBMP)
       fnOutputDebug(brushZeitung " after|" A_TickCount - thisStartZeit)
       If validBMP(newBitmap)
       {
          hasMasked := 1
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := newBitmap
       }
    }

    If (PasteInPlaceCropDo=1 && PasteInPlaceCropAdaptImg=1)
    {
       allowCavity := (viewportQPVimage.imgHandle && !(PasteInPlaceCropSel=1 || PasteInPlaceCropSel=3)) ? 0 : 1
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, ResizedW, ResizedH, PasteInPlaceCropSel, VPselRotation + praz, rotateSelBoundsKeepRatio, 2, allowCavity)
       If (allowPreviewThis=1)
          Gdip_SetClipPath(G2, pPath, 1)
    }

    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 2)

    hasPainted := 0
    If (allowPreviewThis=1 && previewMode=1)
    {
       If (validBMP(o_bgrBMP) && currIMGdetails.HasAlpha=1)
       {
          Gdip_FillRectangle(G2, GDIPbrushHatch, imgSelPx, imgSelPy, ResizedW, ResizedH)
          thisBMP := resizeBitmapToGivenRef(thisBMP, 0, ResizedW, ResizedH, thisImgQuality)
          o_bgrBMP := resizeBitmapToGivenRef(o_bgrBMP, 0, ResizedW, ResizedH, thisImgQuality)
          ; trGdip_GetImageDimensions(o_bgrBMP, kw, kh)
          ; trGdip_GetImageDimensions(thisBMP, mw, mh)
          thisOpacity := (PasteInPlaceOpacity>255) ? 0 : 255 - PasteInPlaceOpacity
          ; r1 := QPV_MergeBitmapsWithMask(thisBMP, o_bgrBMP, 0, 0, thisOpacity)
          ; ToolTip, % "hmm="  "|" kw "|" kh "`n" mw "|" mh "`n" ResizedW "|" ResizedH , , , 2
          r1 := trGdip_DrawImage(A_ThisFunc, G2, o_bgrBMP, imgSelPx, imgSelPy)
          thisOpacity := (PasteInPlaceOpacity>255) ? 1 : PasteInPlaceOpacity/255
          r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy,,,,,,, thisOpacity)
          trGdip_DisposeImage(thisBMP)
          hasPainted := 1
       } Else If validBMP(o_bgrBMP)
          trGdip_DrawImage(A_ThisFunc, G2, o_bgrBMP, imgSelPx, imgSelPy, ResizedW, ResizedH)
    }

    setWindowTitle("Scaling image to selection area")
    thisOpacity := (PasteInPlaceOpacity>255) ? (PasteInPlaceOpacity - 245)/10 : PasteInPlaceOpacity/255
    If (viewportQPVimage.imgHandle && previewMode=1 && PasteInPlaceOpacity>255 || !viewportQPVimage.imgHandle && PasteInPlaceOpacity>255)
       thisOpacity := 1

    If (validBMP(thisBMP) && G2 && allowPreviewThis=1 && hasPainted=0)
    {
       ; ToolTip, % validBMP(o_bgrBMP) " | " hasPainted  " opacity=" thisOpacity , , , 2
       r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, ResizedW, ResizedH, , , , , thisOpacity)
    } Else If (allowPreviewThis!=1 && previewMode=1)
    {
       If (PasteInPlaceEraseInitial=1 && mustEraseAreaAfter=1)
          PasteInPlaceEraseArea(G2, previewMode)
       black := makeRGBAcolor("998877", 128)
       blackBrush := Gdip_BrushCreateSolid(black)
       If (pPath && PasteInPlaceCropDo=1)
          Gdip_FillPath(G2, blackBrush, pPath)
       Else
          Gdip_FillRectangle(G2, blackBrush, imgSelPx, imgSelPy, ResizedW, ResizedH)

       Gdip_DeleteBrush(blackBrush)
    }

    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)

    Gdip_ResetClip(G2)
    trGdip_DisposeImage(bgrBMP, 1)
    trGdip_DisposeImage(o_bgrBMP, 1)
    ; If hasMasked
       trGdip_DisposeImage(thisBMP, 1)
    If (PasteInPlaceEraseInitial=1 && allowPreviewThis=1 && previewMode=1 && mustEraseAreaAfter=1)
       PasteInPlaceEraseArea(G2, previewMode)

    setWindowTitle(pVwinTitle, 1)
    If (previewMode=1)
    {
       If (PasteInPlaceCropDo=1 && pPath)
       {
          Gdip_SetPenWidth(pPen1d, imgHUDbaseUnit//11)
          whichPen := (allowPreviewThis=1) ? pPen1d : pPen4
          Gdip_DrawPath(G2, whichPen, pPath)
       }

       lastInvoked := A_TickCount
       prevImgCall := thisImgCall
       prevClipBMP := clipBMP
       ; trGdip_DisposeImage(clipBMP, 1)
    } Else
    {
       trGdip_DisposeImage(clipBMP, 1)
       ; userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       ; viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    }

    Gdip_DeletePath(pPath)
} ; // corePasteInPlaceActNow()

PasteInPlaceCalcObjCoords(imgSelW, imgSelH, ResizedW, ResizedH, ByRef imgSelPx, ByRef imgSelPy) {
    If (PasteInPlaceAlignment=2)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
    } Else If (PasteInPlaceAlignment=3)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)//2
       imgSelPy := imgSelPy + (imgSelH - ResizedH)//2
    } Else If (PasteInPlaceAlignment=4)
    {
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    } Else If (PasteInPlaceAlignment=5)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    }

    imgSelPx := Round(imgSelPx)
    imgSelPy := Round(imgSelPy)
}

PasteInPlaceCalcObjSize(previewMode, hasRotated, oImgW, oImgH, imgSelW, imgSelH, anglu, capped, ByRef ResizedW, ByRef ResizedH) {
    calcIMGdimensions(oImgW, oImgH, imgSelW, imgSelH, ResizedW, ResizedH)
    If (previewMode=1)
    {
       trGdip_GetImageDimensions(userClipBMPpaste, qImgW, qImgH)
       If (anglu>0 && hasRotated=1 && !viewportQPVimage.imgHandle)
       {
          If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
             Gdip_GetRotatedEllipseDimensions(qImgW, qImgH, anglu, qImgW, qImgH)
          Else
             Gdip_GetRotatedDimensions(qImgW, qImgH, anglu, qImgW, qImgH)
       }
    }

    If (PasteInPlaceAdaptMode=3)
    {
       ResizedW := oImgW
       ResizedH := oImgH
       If (previewMode=1)
       {
          If (viewportQPVimage.imgHandle)
          {
             ResizedW := oldSelectionArea[12]
             ResizedH := oldSelectionArea[13]
             If (PasteInPlaceOrientation=2 || PasteInPlaceOrientation=4)
                flipVars(ResizedW, ResizedH)
          } Else ; If (PasteInPlaceAdaptMode=3)
          {
             ; fnOutputDebug("hello9")
             trGdip_GetImageDimensions(userClipBMPpaste, ResizedW, ResizedH)
             If (PasteInPlaceOrientation=2 || PasteInPlaceOrientation=4)
                flipVars(ResizedW, ResizedH)

             If (anglu>0 && hasRotated=1)
             {
                If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
                   Gdip_GetRotatedEllipseDimensions(ResizedW, ResizedH, anglu, ResizedW, ResizedH)
                Else
                   Gdip_GetRotatedDimensions(ResizedW, ResizedH, anglu, ResizedW, ResizedH)
             }
          }
          ResizedW := ResizedW * zoomLevel
          ResizedH := ResizedH * zoomLevel
       }
    } Else If (PasteInPlaceAdaptMode=2)
    {
       ResizedW := imgSelW
       ResizedH := imgSelH
    }
    ; ToolTip, % ResizedW "|" ResizedH , , , 2
    ResizedW := Round(ResizedW), ResizedH := Round(ResizedH)
    keepRatio := (PasteInPlaceAdaptMode=2) ? 0 : 1
    If (capped=1)
       capIMGdimensionsFormatlimits("gdip", keepRatio, ResizedW, ResizedH)
}

capIMGdimensionsGDIPlimits(ByRef ResizedW, ByRef ResizedH) {
    p := capIMGdimensionsFormatlimits("gdip", 1, ResizedW, ResizedH)
    ; If (p!=1)
    ;    msgbox, % ResizedW "|" ResizedH 
    Return p
}

capIMGdimensionsFormatlimits(typu, keepRatio, ByRef ResizedW, ByRef ResizedH) {
    mpxLimit := thisLimit := 0
    If (typu="gdip")
    {
       thisLimit := 199000
       mpxLimit := 536.7
    } Else If (typu="qpv-live")
    {
       vpWinClientSize(mainWidth, mainHeight)
       thisLimit := Floor(max(mainWidth, mainHeight) * 1.15)
       mpxLimit := Floor(thisLimit**1.15)
    } Else If (typu="webp")
    {
       thisLimit := 16350
       mpxLimit := 267.2
    } Else If (typu="ico")
    {
       thisLimit := 256
       mpxLimit := 1
    } Else If (typu="fim")
    {
       thisLimit := 600500
       mpxLimit := 9850
    } Else If isVarEqualTo(typu, "jp2", "j2k")
    {
       thisLimit := 32760
       mpxLimit := 1073
    } Else If isVarEqualTo(typu, "jng", "jpeg", "gif", "targa", "tga")
    {
       thisLimit := 65530
       mpxLimit := 4294
    } Else Return

    ow := ResizedW, oh := ResizedH
    If (keepRatio=1 && thisLimit>1)
    {
       If (max(ResizedW, ResizedH)>thisLimit)
       {
          z := thisLimit/max(ResizedW, ResizedH)
          ResizedW := Floor(ResizedW * z)
          ResizedH := Floor(ResizedH * z)
       }
    } Else If (thisLimit>1)
    {
       ResizedW := (ResizedW>thisLimit) ? thisLimit : ResizedW
       ResizedH := (ResizedH>thisLimit) ? thisLimit : ResizedH
    }

    mpx := Round((ResizedW * ResizedH)/1000000, 1)
    If (mpx>mpxLimit)
    {
       g := 1
       rw := rh := 0
       Loop
       {
          g -= 0.001
          rw := Floor(ResizedW * g)
          rh := Floor(ResizedH * g)
          mpx := Round((rw * rh)/1000000, 1)
          If (mpx<mpxLimit)
             Break
       }
       ResizedW := rw
       ResizedH := rh
    }

    p := ((ResizedW + ResizedH)/2) / ((ow + oh)/2)
    Return p
}

getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, imgSelW, imgSelH, BlurAmount:=0, fimgW:=0, fimgH:=0, allowFX:=1) {
    Static prevBMPu, prevBlurredBMP, prevState, prevFXid
    If (previewMode="kill")
    {
       prevState := prevFXid := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
       Return
    }

    If (previewMode=1)
    {
       vpWinClientSize(mainWidth, mainHeight)
       thisImgTempQuality := (userimgQuality=1) ? 3 : 5
       If (viewportQPVimage.imgHandle)
       {
          obj := retrieveQPVscreenImgSection("last", 0, 0, 0, 0, 0)
          pBitmap := obj[1]
          If !validBMP(pBitmap)
             Return

          trGdip_GetImageDimensions(pBitmap, imgW, imgH)
          pBitmap := resizeBitmapToGivenRef(pBitmap, 0, obj[4], obj[5], thisImgQuality)
          ; fnOutputDebug(A_ThisFunc ": "  obj[4] "|" obj[5] "`n" imgW "|" imgH)
          thisu := max(fImgW, fImgH)
          calcIMGdimensions(imgW, imgH, thisu, thisu, ResizedW, ResizedH)
          If !isVPselLarger(mainWidth, mainHeight)
          {
             zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, pBitmap, imgSelPx - obj[2], imgSelPy - obj[3], imgSelW, imgSelH, 0, 0, 1)
          } Else
          {
             thisX := (obj[2]>0) ? imgSelPx - obj[2] : imgSelPx
             thisY := (obj[3]>0) ? imgSelPy - obj[3] : imgSelPy
             zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, pBitmap, thisX, thisY, imgSelW, imgSelH, 0, 0, 1)
          }
             ; zBitmap := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, fImgW, fImgH, 0, 5)
          trGdip_DisposeImage(pBitmap, 1)
          If (allowFX=1)
             zBitmap := applyVPeffectsOnBMP(zBitmap)
          Return zBitmap
       }

       trGdip_GetImageDimensions(useGdiBitmap(), aimgW, aimgH)
       If (allowFX=1)
          thisFXid := decideGDIPimageFX(matrix, imageAttribs, pEffect)
       Else
          thisFXid := "a"
       ; ToolTip, % thisFXid "`n" matrix , , , 2
       thisFXid .= (BlurAmount>1) ? "." BlurAmount zoomLevel : "."
       thisFXid .= "Z" FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevResizedVPimgW prevResizedVPimgH PasteInPlaceAdaptMode fImgW fImgH aimgW aimgH
       ; zPx := (selDotX<0 && selDotAx>mainWidth) ? 0 : imgSelPx
       ; zPy := (selDotY<0 && selDotAy>mainHeight) ? 0 : imgSelPy
       thisState := "a" imgSelPx imgSelPy imgSelW imgSelH fImgW fImgH currentFileIndex getIDimage(currentFileIndex) oImgW oImgH currentUndoLevel currentSelUndoLevel FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevResizedVPimgW prevResizedVPimgH PasteInPlaceAdaptMode undoLevelsRecorded UserMemBMP ViewPortBMPcache aimgW aimgH
       ; ToolTip, % thisState , , , 2
       If (thisFXid=prevFXid && thisState=prevState && validBMP(prevBMPu))
       {
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeImageAttributes(imageAttribs)
          newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
          Return newBitmap
       }

       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       If (thisFXid!=prevFXid || !validBMP(prevBlurredBMP))
       {
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
          If validBMP(ViewPortBMPcache)
          {
             prevBlurredBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          } Else
          {
             Gdip_DisposeEffect(pEffect)
             Gdip_DisposeImageAttributes(imageAttribs)
             prevFXid := prevState := ""
             Return
          }

          If validBMP(prevBlurredBMP)
          {
             If (pEffect && allowFX=1)
             {
                Gdip_BitmapApplyEffect(prevBlurredBMP, pEffect)
                Gdip_DisposeEffect(pEffect)
             }

             If (imageAttribs && allowFX=1)
             {
                G2 := trGdip_GraphicsFromImage(A_ThisFunc, prevBlurredBMP, 3)
                If G2
                   r1 := trGdip_DrawImage(A_ThisFunc, G2, prevBlurredBMP,,,,,,,,,,, imageAttribs)
                Gdip_DeleteGraphics(G2)
                Gdip_DisposeImageAttributes(imageAttribs)
             }

             If (BlurAmount>1)
             {
                BlurAmount := Round(BlurAmount*zoomLevel)
                QPV_BoxBlurBitmap(prevBlurredBMP, BlurAmount, BlurAmount, 0)
             }
             prevFXid := thisFXid
          } Else
          {
             Gdip_DisposeImageAttributes(imageAttribs)
             Gdip_DisposeEffect(pEffect)
             prevFXid := prevState := ""
             Return
          }
       } Else
       {
          Gdip_DisposeImageAttributes(imageAttribs)
          Gdip_DisposeEffect(pEffect)
       }

       thisBMP := prevBlurredBMP
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1)
       If validBMP(prevBlurredBMP)
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)

       ; ToolTip, % zBitmap "==" imgSelPx "==" imgSelPy "`n" imgSelW "--" imgSelH , , , 2
       ; ToolTip, % w "=" h "`n" fImgW "=" fImgH "`n" imgSelW "=" imgSelH , , , 2
       If validBMP(zBitmap)
       {
          trGdip_GetImageDimensions(zBitmap, w, h)
          If ((fImgW!=w || fImgH!=h) && fImgW>1 && fImgH>1)
             tempBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, fImgW, fImgH, 0, thisImgQuality, 0, 0)
          Else If ((oImgW!=imgSelW || oImgH!=imgSelH) && (!fImgW || !fImgH))
             tempBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, oImgW, oImgH, 0, thisImgQuality, 0, 0)

          If validBMP(tempBMP)
          {
             trGdip_DisposeImage(zBitmap, 1)
             zBitmap := tempBMP
          }
       }

       fnOutputDebug("redraw: " A_ThisFunc)
       ; SoundBeep 400,90
       prevState := (minimizeMemUsage=1) ? 0 : thisState
       prevBMPu := (minimizeMemUsage=1) ? 0 : trGdip_CloneBitmap(A_ThisFunc, zBitmap)
       Return zBitmap
    }

    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : useGdiBitmap()
    If (imgFxMode>1)
       whichBitmap := useGdiBitmap()

    If !validBMP(whichBitmap)
    {
       SoundBeep , 300, 100
       addJournalEntry(A_ThisFunc "(): ERROR. No bitmap to process.")
       Return
    }

    trGdip_GetImageDimensions(whichBitmap, aimgW, aimgH)
    MouseCoords2Image(imgSelPx, imgSelPy, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX1, imgY1)
    MouseCoords2Image(imgSelPx + imgSelW, imgSelPy + imgSelH, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX2, imgY2)

    ; givenCoords := imgSelPx//zoomLevel "|" imgSelPy//zoomLevel "|" Round((imgSelPx + imgSelW)/zoomLevel) "|" Round((imgSelPy + imgSelH)/zoomLevel)
    givenCoords := imgX1 "|" imgY1 "|" imgX2 "|" imgY2 
    calcImgSelection2bmp(1, aimgW, aimgH, Round(aimgW*zoomLevel), Round(aimgH*zoomLevel), dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0)
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, oImgW, oImgH, coreDesiredPixFmt)
    If warnUserFatalBitmapError(newBitmap, A_ThisFunc)
       Return

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1)
    If !validBMP(zBitmap)
    {
       trGdip_DisposeImage(newBitmap, 1)
       Return
    }

    BlurAmount := Round(BlurAmount)
    If (BlurAmount>1)
       QPV_PrepareAlphaChannelBlur(zBitmap, 2, 1)

    If pEffect
       Gdip_BitmapApplyEffect(zBitmap, pEffect)

    Gdip_DisposeEffect(pEffect)
    trGdip_GetImageDimensions(zBitmap, gimgW, gimgH)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 3)
    If !G2
    {
       trGdip_DisposeImage(newBitmap, 1)
       trGdip_DisposeImage(zBitmap, 1)
       Return
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0, oImgW, oImgH, 0, 0, gimgW, gimgH,,, imageAttribs)
    trGdip_DisposeImage(zBitmap, 1)
    Gdip_DisposeImageAttributes(imageAttribs)
    Gdip_DeleteGraphics(G2)

    If (BlurAmount>1 && G2)
       QPV_BoxBlurBitmap(newBitmap, BlurAmount, BlurAmount, 0)

    prevState := 0
    Return newBitmap
}

destroyGDIfileCache(remAll:=1, makeBackup:=0) {
    If (remAll=0)
    {
       imgPath := StrReplace(getIDimage(currentFileIndex), "||")
       MD5name := generateThumbName(imgPath, 1)
       If InStr(gdiBitmapIDcall, "a1" MD5name imgPath)
       {
          If (makeBackup=1)
          {
             mainCall := SubStr(gdiBitmapIDcall, 3)
             gdiBitmapIDcall := "a0" . mainCall
             gdiBitmap := cloneGDItoMem(A_ThisFunc, gdiBitmap)
             gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
             gdiBitmap := xBitmap
             gdiBitmapIDentire := gdiBitmapIDcall xBitmap
          } Else gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
       }

       If InStr(BprevImgCall, "1" MD5name imgPath)
       {
          BprevImgCall := ""
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       }

       If InStr(AprevImgCall, "1" MD5name imgPath)
       {
          AprevImgCall := ""
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       }

       If (!AprevImgCall && mainCall && makeBackup=1)
       {
          AprevImgCall := gdiBitmapIDcall
          AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       } Else If (!BprevImgCall && mainCall && makeBackup=1)
       {
          BprevImgCall := gdiBitmapIDcall
          BprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       }

       If InStr(idGDIcacheSRCfileA, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileA := ""
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       }

       If InStr(idGDIcacheSRCfileB, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileB := ""
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       }
    } Else
    {
       If (SubStr(idGDIcacheSRCfileA, 1, 1)=1)
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       If (SubStr(idGDIcacheSRCfileB, 1, 1)=1)
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       If (SubStr(BprevImgCall, 1, 1)=1)
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       If (SubStr(AprevImgCall, 1, 1)=1)
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       If (SubStr(gdiBitmapIDcall, 1, 1)=1)
          gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)

       idGDIcacheSRCfileA := idGDIcacheSRCfileB := ""
       BprevImgCall := AprevImgCall := ""
       GDIcacheSRCfileA := GDIcacheSRCfileB := gdiBitmapIDcall := ""
    }
}

discardSRCfileCaches() {
    prevMD5nameA := prevMD5nameB := ""
    GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
    GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
    idGDIcacheSRCfileA := idGDIcacheSRCfileB := ""
    GDIcacheSRCfileA := GDIcacheSRCfileB := 
}

discardViewPortCaches() {
    ; GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
    ; GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
    AprevImgCall := BprevImgCall := ""
    BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
    AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
}

disposeCacheIMGs(dummy:=0) {
    gdiBitmapIDcall := ""
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
    If (dummy!="soft")
       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)

    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
    infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
}

MenuReturnIMGedit() {
   If (validBMP(UserMemBMP) && imgIndexEditing>0)
      currentFileIndex := imgIndexEditing
   Else If (prevLastImg[1, 1])
      currentFileIndex := clampInRange(prevLastImg[1, 1], 1, maxFilesIndex)

   MenuDummyToggleThumbsMode()
}

recordSelUndoLevelNow() {
   selectionCoords := Round(imgSelX1) "|" Round(imgSelY1) "|" Round(imgSelX2) "|" Round(imgSelY2) "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" VPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid "|" innerSelectionCavityX "|" innerSelectionCavityY "|" FillAreaRectRoundness "|" FillAreaEllipseSection
   totalSelUndos := Round(undoSelLevelsArray.Count())
   currentSelUndoLevel := clampInRange(currentSelUndoLevel, 0, totalSelUndos)
   newArray := []
   Loop, % currentSelUndoLevel
       newArray[A_Index] := undoSelLevelsArray[A_Index]
   
   totalSelUndos := Round(newArray.Count())
   If (newArray[totalSelUndos]!=selectionCoords)
   {
      newArray[totalSelUndos + 1] := selectionCoords
      currentSelUndoLevel := totalSelUndos + 1
      totalSelUndos++
   }

   undoSelLevelsArray := []
   undoSelLevelsArray := newArray.Clone()
   newArray := []
   ; ToolTip, % currentSelUndoLevel  " = l" , , , 2
}

wrapRecordUndoLevelNow(newBitmap, allowRecord:=1) {
   If (viewportQPVimage.imgHandle || !validBMP(newBitmap))
      Return
   
   gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
   gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
   GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)

   currentImgModified := 1
   imgIndexEditing := currentFileIndex
   If (preventUndoLevels=1 && allowRecord=0)
   {
      If (newBitmap!=UserMemBMP)
         UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
      If (newBitmap!=gdiBitmap)
         gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
      gdiBitmap := newBitmap
      UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, newBitmap)
      Return
   }

   recordUndoLevelNow("init", 0)
   If (newBitmap!=UserMemBMP)
      UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   If (newBitmap!=gdiBitmap)
      gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)

   UserMemBMP := newBitmap
   gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, newBitmap)
   If (UserMemBMP=gdiBitmap)
      addJournalEntry(A_ThisFunc "(): ERROR. Illegal inequality. UserMemBMP=gdiBitmap" )

   recordUndoLevelNow(0, newBitmap)
}

recordUndoLevelNow(actionu, recordedBitmap, dX:=0, dY:=0, forceAlpha:="x") {
   Static prevAct, lastInvoked := 1
   If (preventUndoLevels=1 || viewportQPVimage.imgHandle)
      Return

   whichBitmap := useGdiBitmap()
   thisAct := actionu recordedBitmap whichBitmap minimizeMemUsage currentFileIndex getIDimage(currentFileIndex)
   if (prevAct=thisAct)
   {
      ; SoundBeep, 900, 900
      addJournalEntry(A_ThisFunc "(" actionu "): ERROR: already recorded undo state")
      Return
   }

   HasAlpha := (forceAlpha!="x") ? forceAlpha : currIMGdetails.HasAlpha
   selectionCoords := Round(imgSelX1) "|" Round(imgSelY1) "|" Round(imgSelX2) "|" Round(imgSelY2) "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" VPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid "|" innerSelectionCavityX "|" innerSelectionCavityY "|" FillAreaRectRoundness "|" FillAreaEllipseSection
   If (actionu="init" && minimizeMemUsage=1)
   {
      setImageLoading()
      trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
      thisBMP := trGdip_CloneBitmap(A_ThisFunc "(init)", whichBitmap)
      If validBMP(thisBMP)
      {
         prevAct := thisAct
         currentUndoLevel := 1
         If (undoLevelsRecorded=0)
            undoLevelsRecorded := 1
         undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
      } Else
      {
         addJournalEntry(A_ThisFunc "(" actionu "): failed to record undo level; minimizeMemUsage=1")
         Return
      }
      lastInvoked := A_TickCount
      Return
   }

   If (!validBMP(undoLevelsArray[1, 1]) && minimizeMemUsage!=1)
   {
      thisBMP := trGdip_CloneBitmap(A_ThisFunc "(auto-init)", whichBitmap)
      If validBMP(thisBMP)
      {
         prevAct := thisAct
         recordSelUndoLevelNow()
         undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
         currentUndoLevel := 1
         If (undoLevelsRecorded=0)
            undoLevelsRecorded := 1
      } Else
         addJournalEntry(A_ThisFunc "(" actionu "): failed to record undo level (auto-init)")

      If (actionu="init")
         Return
   }

   prevAct := 0
   HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
   If !validBMP(recordedBitmap)
   {
      If recordedBitmap
         addJournalEntry(A_ThisFunc "(): failed to record undo level: invalid bitmap to be recorded ID=" recordedBitmap)
      Return
   }

   If (A_PtrSize=8 && undoLevelsRecorded>2)
   {
      memInfos := getMemUsage()
      thisMemoryLoad := isWinXP ? 99 : memInfos.appPrcMem
      If (thisMemoryLoad<85 && memInfos.prcSys<85 && hasReachedMaxUndoLevels=0)
         maxUndoLevels := 100
      Else
         maxUndoLevels := hasReachedMaxUndoLevels := undoLevelsRecorded
   }

   ; currentSelUndoLevel := totalSelUndos := Round(undoSelLevelsArray.Count() + 1)
   ; undoSelLevelsArray[totalSelUndos] := selectionCoords
   recordSelUndoLevelNow()
   imgIndexEditing := currentFileIndex
   ; ToolTip, % currentSelUndoLevel " = p" , , , 2
   If (minimizeMemUsage=1)
   {
      currentUndoLevel := 2
      undoLevelsRecorded := 2
      trGdip_DisposeImage(undoLevelsArray[2, 1], 1)
      bmpu := trGdip_CloneBitmap(A_ThisFunc "(L2)", recordedBitmap)
      undoLevelsArray[currentUndoLevel] := [bmpu, dX, dY, currentSelUndoLevel, HasAlpha]
   } Else
   {
      If (currentUndoLevel>=maxUndoLevels)
      {
         trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
         undoLevelsArray.RemoveAt(1)
         bmpu := trGdip_CloneBitmap(A_ThisFunc "(Lmax)", recordedBitmap)
         undoLevelsArray[currentUndoLevel] := [bmpu, dX, dY, currentSelUndoLevel, HasAlpha]
      } Else
      {
         currentUndoLevel++
         undoLevelsRecorded++
         If (undoLevelsRecorded>currentUndoLevel)
            undoLevelsRecorded := currentUndoLevel

         bmpu := trGdip_CloneBitmap(A_ThisFunc "(Lx" currentUndoLevel ")", recordedBitmap)
         undoLevelsArray[currentUndoLevel] := [bmpu, dX, dY, currentSelUndoLevel, HasAlpha]
         Loop, % maxUndoLevels + 1 - currentUndoLevel
         {
             trGdip_DisposeImage(undoLevelsArray[currentUndoLevel + A_Index, 1], 1)
             undoLevelsArray[currentUndoLevel + A_Index, 1] := ""
         }
      }
   }

   currentImgModified := 1
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, TriggerMenuBarUpdate, -50
   If (A_TickCount - lastInvoked>950) && (liveDrawingBrushTool=0 && AnyWindowOpen!=66)
      SoundBeep , 900, 100
}

terminateIMGediting(modus:=0) {
   lastZeitIMGsaved := []
   allowThis := (modus="forced" && (undoLevelsRecorded>0 || validBMP(UserMemBMP))) ? 0 : 1
   If (allowThis=1)
   {
      If (!validBMP(UserMemBMP) && undoLevelsRecorded>0 && currentFileIndex!=imgIndexEditing && minimizeMemUsage=1)
      {
         UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
         userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
         viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
         viewportIDstampBMP := ""
         Loop, 3
         {
             trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
             undoLevelsArray[A_Index, 1] := ""
         }

         gdipObjectsStats("recordUndoLevelNow")
         currentImgModified := 0
         undoSelLevelsArray := []
         currentSelUndoLevel := 1
         undoVectorShapesLevelsArray := []
         currentVectorUndoLevel := 1
         customShapeHasSelectedPoints := 0
         currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
         interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
         interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
         SetTimer, TriggerMenuBarUpdate, -50
         Return
      }

      If (!validBMP(UserMemBMP) && undoLevelsRecorded<1) || (currentFileIndex=imgIndexEditing && undoLevelsRecorded>1 && currentImgModified=2)
         Return
   }

   currentImgModified := 0
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
   viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
   viewportIDstampBMP := ""
   imgIndexEditing := 0
   Loop, 200
   {
       trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
       undoLevelsArray[A_Index, 1] := ""
   }

   gdipObjectsStats("recordUndoLevelNow")
   fnOutputDebug(A_ThisFunc "(): undo/redo levels purged")
   currentSelUndoLevel := 1
   undoSelLevelsArray := []
   currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   SetTimer, TriggerMenuBarUpdate, -50
   maxUndoLevels := (A_PtrSize=8) ? 100 : 2
}

isAlphaMaskPartialWin(m:=0) {
   k := (m=1) ? prevOpenedWindow[1] : AnyWindowOpen
   Return isVarEqualTo(k, 81, 66, 55, 25)
}

isAlphaMaskWindow(m:=0) {
   k := (m=1) ? prevOpenedWindow[1] : AnyWindowOpen
   Return isVarEqualTo(k, 23, 24, 31, 32, 70, 74, 89)
}

isNowAlphaPainting() {
   Return (isAlphaMaskWindow()=1 && liveDrawingBrushTool=1 && isImgEditingNow()=1) ? 1 : 0
}

performUndoAlphaPainting() {
   If validBMP(userPrevAlphaMaskBmpPainted)
   {
      z := userAlphaMaskBmpPainted
      userAlphaMaskBmpPainted := userPrevAlphaMaskBmpPainted
      userPrevAlphaMaskBmpPainted := z
      realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
      SetTimer, livePreviewsImageEditing, -100
   }
}

ImgUndoAction(dummy:=0) {
   Critical, on
   If (viewportQPVimage.imgHandle && thumbsDisplaying!=1 && imageLoading!=1)
   {
      undoRedoHugeImagesAct()
      Return
   }

   If (isNowAlphaPainting()=1)
   {
      performUndoAlphaPainting()
      Return
   } Else If (imageLoading=1)
   {
      Sleep, 1
      Return
   } Else If (!validBMP(UserMemBMP) || thumbsDisplaying=1)
   {
      fileUndoAction(currentFileIndex)
      Return
   }

   If !validBMP(undoLevelsArray[currentUndoLevel - 1, 1])
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not being recorded (user option)`n" : ""
      showTOOLtip(friendly "Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel - howFar, 1, undoLevelsRecorded)
   coreChangeImgUndoLevel(currentUndoLevel)
   dummyTimerDelayiedImageDisplay(325)
   showTOOLtip("Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

coreChangeImgUndoLevel(levelu) {
   pBitmap := undoLevelsArray[levelu, 1]
   If (pBitmap!=UserMemBMP)
      UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   If (pBitmap!=gdiBitmap)
      gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)

   UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, pBitmap)
   gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, pBitmap)
   currIMGdetails.HasAlpha := undoLevelsArray[levelu, 5]
   vpIMGrotation := 0
   imgFxMode := usrColorDepth := 1
   defineColorDepth()
   INIaction(1, "usrColorDepth", "General")
   INIaction(1, "vpIMGrotation", "General")
   INIaction(1, "imgFxMode", "General")
   ; restorePreviousSelections(undoLevelsArray[currentUndoLevel, 4])
}

ImgSelUndoAct(dummy:=0) {
   Critical, on
   isOkay := (validBMP(UserMemBMP) || viewportQPVimage.imgHandle && viewportQPVimage.actions>0) ? 1 : 0
   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (isOkay!=1 || totalSelUndos<1 || thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
      Return

   If (StrLen(undoSelLevelsArray[currentSelUndoLevel - 1])<3 && totalSelUndos!=1 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   ; currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel - howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", A_ThisFunc, 1, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgSelRedoAct(dummy:=0) {
   Critical, on
   totalSelUndos := Round(undoSelLevelsArray.Count())
   isOkay := (validBMP(UserMemBMP) || viewportQPVimage.imgHandle && viewportQPVimage.actions>0) ? 1 : 0
   If (isOkay!=1 || totalSelUndos<1 || thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
      Return

   If (StrLen(undoSelLevelsArray[currentSelUndoLevel + 1])<3 && totalSelUndos!=1 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   ; currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel + howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", A_ThisFunc, 1, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgVectorRedoAct() {
   Critical, on
   If (drawingShapeNow!=1)
      Return

   totalUndos := Round(undoVectorShapesLevelsArray.Count())
   If !IsObject(undoVectorShapesLevelsArray[currentVectorUndoLevel + 1])
   {
      showTOOLtip("Shape redo [ " currentVectorUndoLevel " / " totalUndos " ]", 0, 0, currentVectorUndoLevel/totalUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentVectorUndoLevel := clampInRange(currentVectorUndoLevel + 1, 1, totalUndos)
   restoreGivenVectorUndoLevel(currentVectorUndoLevel)
   showTOOLtip("Shape redo [ " currentVectorUndoLevel " / " totalUndos " ]", A_ThisFunc, 1, currentVectorUndoLevel/totalUndos)
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, -25
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgVectorUndoAct() {
   Critical, on
   If (drawingShapeNow!=1)
      Return

   totalUndos := Round(undoVectorShapesLevelsArray.Count())
   If !IsObject(undoVectorShapesLevelsArray[currentVectorUndoLevel - 1])
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not being recorded (user option)`n" : ""
      showTOOLtip(friendly "Shape undo [ " currentVectorUndoLevel " / " totalUndos " ]", 0, 0, currentVectorUndoLevel/totalUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentVectorUndoLevel := clampInRange(currentVectorUndoLevel - 1, 1, totalUndos)
   restoreGivenVectorUndoLevel(currentVectorUndoLevel)
   showTOOLtip("Shape undo [ " currentVectorUndoLevel " / " totalUndos " ]", A_ThisFunc, 1, currentVectorUndoLevel/totalUndos)
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, -25
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

recordVectorUndoLevels() {
   If (preventUndoLevels=1)
      Return

   bonus := 0
   mainArray := customShapePoints.Clone()
   VPstuffArray := customShapePropPoints.Clone()
   undos := undoVectorShapesLevelsArray.Count()
   If (currentVectorUndoLevel<undos && undos>0)
   {
      bonus := 2
      Loop, % maxVectorUndoLevels
      {
         undos--
         undoVectorShapesLevelsArray.Pop()
         If (undos<currentVectorUndoLevel + 1)
            Break
      }
   }

   currentVectorUndoLevel := undoVectorShapesLevelsArray.Count()
   If (currentVectorUndoLevel>maxVectorUndoLevels)
      undoVectorShapesLevelsArray.RemoveAt(1)

   newArrayu := [mainArray, VPstuffArray, CustomShapeSymmetry, CustomShapeLockedSymmetry, customShapeHasSelectedPoints,  bezierSplineCustomShape, FillAreaCurveTension, closedLineCustomShape]
   undoVectorShapesLevelsArray.Push(newArrayu)
   currentVectorUndoLevel := undoVectorShapesLevelsArray.Count()
   ; ToolTip, % "l=" currentVectorUndoLevel , , , 2
}

restoreGivenVectorUndoLevel(levelu) {
   If !IsObject(undoVectorShapesLevelsArray[levelu])
      Return

   lastZeitFileSelect := A_TickCount
   a := undoVectorShapesLevelsArray[levelu, 1]
   b := undoVectorShapesLevelsArray[levelu, 2]
   customShapePoints := a.Clone()
   customShapePropPoints := b.Clone()
   CustomShapeSymmetry := undoVectorShapesLevelsArray[levelu, 3]
   CustomShapeLockedSymmetry := undoVectorShapesLevelsArray[levelu, 4]
   customShapeHasSelectedPoints := undoVectorShapesLevelsArray[levelu, 5]
   bezierSplineCustomShape := undoVectorShapesLevelsArray[levelu, 6]
   FillAreaCurveTension := undoVectorShapesLevelsArray[levelu, 7]
   closedLineCustomShape := undoVectorShapesLevelsArray[levelu, 8]
   prevVectorShapeSymmetryMode[1, 1] := ( customShapePoints.Count() ) // 2 + 1
   If CustomShapeSymmetry
      coreSetVPsymmetryPoint(( customShapePoints.Count() ) // 2 + 1)
   dummyTimerDelayiedImageDisplay(100)
}

restorePreviousSelections(thisLevel) {
   selectionCoords := undoSelLevelsArray[thisLevel]
   If !selectionCoords
      Return

   selectionPrefsArray := StrSplit(selectionCoords, "|")
   imgSelX1 := selectionPrefsArray[1], imgSelY1 := selectionPrefsArray[2]
   imgSelX2 := selectionPrefsArray[3], imgSelY2 := selectionPrefsArray[4]
   prcSelX1 := selectionPrefsArray[5], prcSelY1 := selectionPrefsArray[6]
   prcSelX2 := selectionPrefsArray[7], prcSelY2 := selectionPrefsArray[8]
   VPselRotation := selectionPrefsArray[9]
   rotateSelBoundsKeepRatio := selectionPrefsArray[10]
   EllipseSelectMode := selectionPrefsArray[11]
   LimitSelectBoundsImg := selectionPrefsArray[12]
   showSelectionGrid := selectionPrefsArray[13]
   innerSelectionCavityX := selectionPrefsArray[14]
   innerSelectionCavityY := selectionPrefsArray[15]
   FillAreaRectRoundness := selectionPrefsArray[16]
   FillAreaEllipseSection := selectionPrefsArray[17]
   currentSelUndoLevel := thisLevel
   ; currentImgModified := 1
}

ImgRedoAction(dummy:=0) {
   Critical, on
   If (viewportQPVimage.imgHandle && thumbsDisplaying!=1 && imageLoading!=1)
   {
      undoRedoHugeImagesAct()
      Return
   }

   If (!validBMP(UserMemBMP) || thumbsDisplaying=1 || imageLoading=1)
      Return

   If (isNowAlphaPainting()=1)
   {
      performUndoAlphaPainting()
      Return
   } Else If !validBMP(undoLevelsArray[currentUndoLevel + 1, 1])
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not being recorded (user option)`n" : ""
      showTOOLtip(friendly "Redo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel + howFar, 1, undoLevelsRecorded)
   coreChangeImgUndoLevel(currentUndoLevel)
   dummyTimerDelayiedImageDisplay(325)
   showTOOLtip("Redo [ "  currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ToggleCorePixFmt() {
   friendly := (A_PtrSize=4 && A_is64BitOS) ? "`n`nPlease use the 64-bits edition of this application to enjoy a better experience for image editing and image viewing." : ""
   friendly .= "`n`nUpon application restart, the 32-bits RGBA mode will no longer be activated."
   coreDesiredPixFmt := (coreDesiredPixFmt="0x21808") ? "0xE200B" : "0x21808"
   If (A_PtrSize=4 && coreDesiredPixFmt="0xE200B")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now activated. " appTitle " will now have an increased memory usage. The maximum amount of usable memory on your system is 2 GB." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=4 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. " appTitle " will use less memory, but various image editing options are disabled." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=8 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. Please note, various image editing options are disabled in 24-bits RGB mode, including proper alpha channel support.`n`nUpon application restart, the 32-bits RGBA mode will be reactivated. This option is only meant help reduce memory usage for old systems.", 0, 0, "exclamation")

   RefreshImageFileAction()
}

alertReduceColorDepth() {
   If (validBMP(UserMemBMP) || viewportQPVimage.imgHandle)
      Return

   pixFmt := currIMGdetails.PixelFormat " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      r := msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel.", "&OK|&Activate 32-RGBA", 1, "exclamation")
   
   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit is at an unsupported color depth for editing: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost.", 0, 0, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", 0, 0, "exclamation")

   If InStr(r, "activate")
   {
      coreDesiredPixFmt := "0x26200A"
      If !undoLevelsRecorded
         RefreshImageFileAction()
   }

   If (currIMGdetails.TooLargeGDI=1 && !validBMP(UserMemBMP))
   {
      infoRes := "`nOriginal resolution: " groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " groupDigits(imgW) " x " groupDigits(imgH) " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will edit it now at an automatically downscaled resolution:" newRes, 0, 0, "exclamation")
   }
}

alertReduceSaveColorDepth() {
   msgResult := "continue"
   If !InStr(msgResult, "continue")
      Return 1

   pixFmt := currIMGdetails.PixelFormat  " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel before editing or saving the image.", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave is originally at an unsupported color depth: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost. ", "&Continue|C&ancel", 1, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (currIMGdetails.TooLargeGDI=1 && !validBMP(UserMemBMP))
   {
      infoRes := "`nOriginal resolution: " currIMGdetails.Width " x " currIMGdetails.Height " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " imgW " x " imgH " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will be saving an automatically downscaled resolution:" newRes, "&Continue|C&ancel", 1, "exclamation")
   }
   If !InStr(msgResult, "continue")
      Return 1
}

downscaleHugeImagesForEditing() {
    If !(viewportQPVimage.imgHandle)
       Return 0

   trGdip_GetImageDimensions(useGdiBitmap(), w, h)
   mgpx := Round((w * h)/1000000, 1)
   capIMGdimensionsGDIPlimits(w, h)
   nmgpx := Round((w * h)/1000000, 1)
   If (mgpx>536.7)
   {
      msgResult := msgBoxWrapper(appTitle ": WARNING", "The image currently opened has " mgpx " megapixels. The image editing tool you intend to use does not work with images above 536 MPx. Do you want to down-scale the image?`n`nThe image will be down-scaled to:`n" w " x " h " pixels`n" nmgpx " megapixels.", "&Yes|&No", 1, "exclamation")
      If (msgResult!="yes")
         Return -1
   }

   setImageLoading()
   showTOOLtip("Please wait, resizing image to`n" w " x " h " pixels`n" nmgpx " megapixels")
   Sleep, 1
   trGdip_GetImageDimensions(useGdiBitmap(), rw, rh)
   thisBitmap := viewportQPVimage.ImageGetResizedRect(0, 0, rw, rh, w, h, userimgQuality)
   changeMcursor("normal")
   If validBMP(thisBitmap)
   {
      gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
      gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
      HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
      GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
      infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
      viewportQPVimage.DiscardImage()
      retrieveQPVscreenImgSection("kill", 0, 0, 0, 0, 0)
      trGdip_DisposeImage(useGdiBitmap())
      gdiBitmap := thisBitmap
      currIMGdetails.TooLargeGDI := 0
      calcRelativeSelCoords(thisBitmap, w, h)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   } Else
   {
      msgBoxWrapper(appTitle ": ERROR", "An internal error occured making the image available for editing. The application will malfunction.", 0, 0, "error")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return -2
   }
}

mergeViewPortEffectsImgEditing(funcu:=0, recordUndoAfter:=1, allowOutside:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If (downscaleHugeImagesForEditing()<0)
       Return 1

    funcuInfo := funcu ? "`n" funcu "()" : ""
    mergeViewPortRotationImgEditing()
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (!validBMP(whichBitmap) || thumbsDisplaying=1)
    {
       addJournalEntry(A_ThisFunc "() error - invoked by " funcu "() operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return 1
    }

    userPrivateMode := 0
    If (editingSelectionNow=1)
    {
       If testSelectOutsideImgEntirely(whichBitmap)
       {
          If (allowOutside!=1)
          {
             SoundBeep, 300, 100
             showDelayedTooltip("WARNING: Invalid image selection area. It seems to be too small or entirely outside the image boundaries." funcuInfo, 0, 450)
             Return 1
          }
       }
    }

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If isImgSizeTooLarge(imgW, imgH)
    {
       SoundBeep, 300, 100
       showDelayedTooltip("ERROR: Image editing is disabled`nThe document size is too large" funcuInfo, 0, 450)
       Return 1
    }

    alertReduceColorDepth()
    ; mustOpenStartFolder := ""
    imgIndexEditing := currentFileIndex
    currentImgModified := 1
    setImageLoading()
    showTOOLtip("Processing image, please wait" funcuInfo)
    ; If markedSelectFile
    ;    dropFilesSelection()

    discardViewPortCaches()
    ; msgbox % UserMemBMP "---" gdiBitmap

    If (AnyWindowOpen!=74 && AnyWindowOpen!=10)
       decideGDIPimageFX(matrix, imageAttribs, pEffect)

    If (pEffect || imageAttribs)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
       newBitmap := applyVPeffectsOnBMP(newBitmap)

       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       If (imgFxMode>1 && alphaMaskingMode=5 && alphaMaskRefBMP=2 && (isAlphaMaskWindow(1) || isAlphaMaskPartialWin(1)))
       {
          backupGdiBMP := trGdip_DisposeImage(backupGdiBMP, 1)
          backupGdiBMP := trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap())
       }
   
       If validBMP(newBitmap)
       {
          wrapRecordUndoLevelNow(newBitmap, recordUndoAfter)
          disposeCacheIMGs("soft")
       } Else 
       {
          addJournalEntry(A_ThisFunc "(): Failed to apply viewport color effects on the image.")
          trGdip_DisposeImage(newBitmap)
       }

       imgFxMode := usrColorDepth := 1
       vpIMGrotation := 0 ; FlipImgH := FlipImgV := 0
       defineColorDepth()
       INIaction(1, "usrColorDepth", "General")
       INIaction(1, "vpIMGrotation", "General")
       INIaction(1, "imgFxMode", "General")
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

CutSelectedArea() {
   If (thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   r := CopyImage2clip()
   If r
      Return

   Sleep, 350
   EraseAreaFader := 0
   EraseSelectedArea()
}

ApplyVPcolorAdjustSelectedArea(modus:=0) {
    Static prevFXmode := "n"
    If (thumbsDisplaying=1)
    {
       If (imgFxMode>1)
          prevFXmode := imgFxMode
       Return
    }

    If (AnyWindowOpen=74)
    {
       applyIMGeditFunction()
       Return
    }

    startOperation := A_TickCount
    If InStr(modus, "outside")
       modus := "outside"
    Else If (editingSelectionNow!=1)
       selectEntireImage()

    mergeViewPortRotationImgEditing()
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    stopNow := (editingSelectionNow=1 && validBMP(whichBitmap)) ? 0 : 1
    If (stopNow=1)
    {
       prevFXmode := imgFxMode
       Return 
    }

    If (throwErrorSelectionOutsideBounds(whichBitmap) || testEntireImgSelected() && modus="ouside")
    {
       prevFXmode := imgFxMode
       Return 
    }

    o_imgFxMode := imgFxMode
    If (imgFxMode>1)
       prevFXmode := imgFxMode
    Else If (prevFXmode!="n")
       imgFxMode := prevFXmode

    If (imgFxMode=1)
    {
       showTOOLtip("No viewport color adjustments to be applied on image`n`nPress F to cycle through modes`nor press U to open color adjustments panel")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (!validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       imgFxMode := o_imgFxMode
       Return
    }

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(-1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    newBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 7, 4)
    If !G2
    {
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area")
       imgFxMode := o_imgFxMode
       trGdip_DisposeImage(newBitmap)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    If !pPath
    {
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area`nUnable to create selection path")
       trGdip_DisposeImage(newBitmap)
       Gdip_DeleteGraphics(G2)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    thisMode := (modus="outside") ? 4 : 0
    Gdip_SetClipPath(G2, pPath, thisMode)
    setImageLoading()
    zBitmap := trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap())
    zBitmap := applyVPeffectsOnBMP(zBitmap)
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    okay := validBMP(zBitmap)
    trGdip_DisposeImage(zBitmap)
    etaTime := "Elapsed time to apply viewport color effects: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) 
    addJournalEntry(etaTime)
    If (r0!="fail" && r1!="fail" && G2 && validBMP(newBitmap) && okay=1)
    {
       wrapRecordUndoLevelNow(newBitmap)
       If (AnyWindowOpen!=10)
       {
          imgFxMode := 1
          INIaction(1, "imgFxMode", "General")
       }
    } Else
    {
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area`nError messages feel so desaturated...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       trGdip_DisposeImage(newBitmap)
    }

    dummyTimerDelayiedImageDisplay(50)
    SetTimer, ResetImgLoadStatus, -150
    Return r1
}

AdjustColorsLegacySelectedArea(prevFXmode:=0) {
    Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:16}
    thisBitsDepth := bitsOptions[DesaturateAreaLevels]
    startOperation := A_TickCount
    stopNow := (editingSelectionNow=1 && validBMP(useGdiBitmap())) ? 0 : 1
    If (stopNow=1)
       Return 

    If (prevFXmode<2 || !isNumber(prevFXmode))
    {
       showTOOLtip("No color adjustments to be applied on image`n`nPress U to open the color adjustments panel")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    mergeViewPortRotationImgEditing()
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (!validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    o_imgFxMode := imgFxMode
    imgFxMode := 1
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    calcImgSelection2bmp(-1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    newBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 7, 4, compositingQuality)
    If !G2
    {
       showTOOLtip("Failed to apply the color adjustments to the image selected area")
       trGdip_DisposeImage(newBitmap)
       imgFxMode := o_imgFxMode
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    If !pPath
    {
       showTOOLtip("Failed to apply the color adjustments to the image selected area`nUnable to create selection path")
       trGdip_DisposeImage(newBitmap)
       Gdip_DeleteGraphics(G2)
       imgFxMode := o_imgFxMode
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h
    If (EraseAreaInvert=1)
    {
       imgSelPx := 0,     imgSelPy := 0
       imgSelW  := imgW,  imgSelH  := imgH
    }

    setImageLoading()
    imgFxMode := prevFXmode
    thisOpacity := imgColorsFXopacity/255
    allowAlphaMasking := decideAlphaMaskingFeaseable(1)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, newBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    xBitmap := trGdip_CloneBitmap(A_ThisFunc, zBitmap)

    thisMode := (EraseAreaInvert=1) ? 4 : 0
    Gdip_SetClipPath(G2, pPath, thisMode)
    If (imgColorsFXopacity>253 && allowAlphaMasking!=1)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    If (thisBitsDepth>1 && DesaturateAreaLevels>1 && imgFxMode>1)
    {
       E := Gdip_BitmapSetColorDepth(zBitmap, thisBitsDepth, DesaturateAreaDither)
       Gdip_BitmapSetColorDepth(zBitmap, 32)
    }

    zBitmap := applyVPeffectsOnBMP(zBitmap)
    If (userImgChannelAlphaAdd>0)
       QPV_AlterAlphaChannel(zBitmap, userImgChannelAlphaAdd, 0)
    If (allowAlphaMasking=1)
    {
       realtimePasteInPlaceAlphaMasker(0, zBitmap, "lol", nowBitmap, 0, 0, 0, 0, 0, xBitmap, 255 - imgColorsFXopacity)
       If validBMP(nowBitmap)
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := nowBitmap
       }
    } Else
       QPV_MergeBitmapsWithMask(zBitmap, xBitmap, 0, 0, 255 - imgColorsFXopacity)


    r0 := trGdip_GraphicsClear(funcu, G2)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, imgSelPx, imgSelPy) ; ,,,,,,, thisOpacity)
    Gdip_ResetClip(G2)
    Gdip_DeleteGraphics(G2)
    Gdip_DeletePath(pPath)
    okay := validBMP(zBitmap)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(xBitmap, 1)
    etaTime := "Elapsed time to apply viewport color effects: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) 
    addJournalEntry(etaTime)
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    If (r0!="fail" && r1!="fail" && G2 && validBMP(newBitmap) && okay=1)
    {
       wrapRecordUndoLevelNow(newBitmap)
    } Else
    {
       showTOOLtip("Failed to apply the color adjustments to the image selected area`nIt is all so blue in my coding...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       trGdip_DisposeImage(newBitmap)
    }

    wasVPfxBefore := 0
    imgFxMode := o_imgFxMode
    dummyTimerDelayiedImageDisplay(50)
    SetTimer, ResetImgLoadStatus, -150
    Return r1
}

AdjustColorsSimpleSelectedArea() {
    startOperation := A_TickCount
    stopNow := (editingSelectionNow=1 && validBMP(useGdiBitmap())) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       imgFxMode := o_imgFxMode
       Return
    }

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    calcImgSelection2bmp(-1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    newBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 7, 4, compositingQuality)
    If !G2
    {
       showTOOLtip("Failed to apply the color adjustments to the image selected area")
       trGdip_DisposeImage(newBitmap)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    If !pPath
    {
       showTOOLtip("Failed to apply the color adjustments to the image selected area`nUnable to create selection path")
       trGdip_DisposeImage(newBitmap)
       Gdip_DeleteGraphics(G2)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h
    If (EraseAreaInvert=1)
    {
       imgSelPx := 0,     imgSelPy := 0
       imgSelW  := imgW,  imgSelH  := imgH
    }

    imgFxMode := prevFXmode
    thisOpacity := imgColorsFXopacity/255
    allowAlphaMasking := decideAlphaMaskingFeaseable(1)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, newBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    xBitmap := trGdip_CloneBitmap(A_ThisFunc, zBitmap)

    thisMode := (EraseAreaInvert=1) ? 4 : 0
    Gdip_SetClipPath(G2, pPath, thisMode)
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    threB := (userImgAdjustLinkThresholds=1) ? userImgAdjustThreR : userImgAdjustThreB
    threG := (userImgAdjustLinkThresholds=1) ? userImgAdjustThreR : userImgAdjustThreG
    QPV_AdjustImageColors(zBitmap, imgColorsFXopacity, userImgAdjustInvertColors, userImgAdjustAltSat, userImgAdjustSat, userImgAdjustAltBright, userImgAdjustBright, userImgAdjustAltContra, userImgAdjustContra, userImgAdjustAltHiLows, userImgAdjustShadows, userImgAdjustHighs, userImgAdjustHue, userImgAdjustTintDeg, userImgAdjustTintAmount, userImgAdjustAltTint, userImgAdjustGamma, userImgAdjustOffR, userImgAdjustOffG, userImgAdjustOffB, userImgAdjustOffA, userImgAdjustThreR, ThreG, ThreB, userImgAdjustThreA, userImgAdjustSeeThrough, userImgAdjustInvertArea, userImgAdjustNoClamp, userImgAdjustWhitePoint, userImgAdjustBlackPoint, userImgAdjustNoisePoints, 0)

    If (allowAlphaMasking=1)
    {
       realtimePasteInPlaceAlphaMasker(0, zBitmap, "lol", nowBitmap, 0, 0, 0, 0, 0, xBitmap, 0)
       If validBMP(nowBitmap)
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := nowBitmap
       }
    } Else
       QPV_MergeBitmapsWithMask(zBitmap, xBitmap, 0, 0, 0)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, imgSelPx, imgSelPy) ; ,,,,,,, thisOpacity)
    Gdip_ResetClip(G2)
    Gdip_DeleteGraphics(G2)
    Gdip_DeletePath(pPath)
    okay := validBMP(zBitmap)
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    etaTime := "Elapsed time to apply viewport color effects: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) 
    addJournalEntry(etaTime)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(xBitmap, 1)
    If (r0!="fail" && r1!="fail" && G2 && validBMP(newBitmap) && okay=1)
    {
       wrapRecordUndoLevelNow(newBitmap)
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       showTOOLtip("Failed to apply the color adjustments to the image selected area`nIt is so vividly painful...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       trGdip_DisposeImage(newBitmap)
    }

    SetTimer, ResetImgLoadStatus, -100
    Return r1
}

InsertTextSelectedArea() {
    allowOutside := 0
    whichBitmap := useGdiBitmap()
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If ((imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH) && PasteInPlaceAutoExpandIMG=1 && validBMP(whichBitmap) && imgW && imgH)
       allowOutside := 1

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 1, allowOutside)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    startOperation := A_TickCount
    If (allowOutside=1)
       hasRanExpand := performAutoExpandCanvas(imgW, imgH)



    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    metaBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    If validBMP(metaBitmap)
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, metaBitmap, 7, 4,, compositingQuality)
 
    If !G2
    {
       If validBMP(metaBitmap)
          showTOOLtip("Failed to insert text in the selected area.`nUnable to create GDI+ graphics object.")
       Else
          showTOOLtip("Failed to insert text in the selected area.`nUnable to allocate new bitmap.")
       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(metaBitmap)
       Return
    }

    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    o_imgSelPx := imgSelPx, o_imgSelPy := imgSelPy
    o_imgSelW := imgSelW, o_imgSelH := imgSelH
    bgrColor := makeRGBAcolor(TextInAreaBgrColor, TextInAreaBgrOpacity)
    zBrush := Gdip_BrushCreateSolid(bgrColor)
    obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 0)
    If validBMP(obju[1])
    {
       textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
       trGdip_DisposeImage(obju[1], 1)
    }
 
    zz := 0
    coreDesiredPixFmt := o_coreFmt
    trGdip_GetImageDimensions(textBoxu, nImgW, nImgH)
    thisRotation := (TextInAreaVerticalia=1) ? VPselRotation + 90 : VPselRotation
    Gdip_GetRotatedDimensions(nImgW, nImgH, thisRotation, rrImgW, rrImgH)
    mpx := Round((rrImgW * rrImgH)/1000000, 1)
    If (thisRotation>0)
    {
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, thisRotation, "-", 7, 0, 1)
       If (validBMP(xBitmap) || (xBitmap="ok"))
       {
          pkpl := (xbitmap="ok") ? textBoxu : xBitmap
          trGdip_GetImageDimensions(pkpl, kW, kH)
          zz := (kW>imgSelW || kH>imgSelH) ? 1 : 0
          bW := (kW>imgSelW) ? imgSelW : max(kW, kH)
          bH := (kH>imgSelH) ? imgSelH : max(kW, kH)
          bW := (bW>imgSelW) ? imgSelW : bW
          bH := (bH>imgSelH) ? imgSelH : bH
          calcIMGdimensions(kW, kH, bW, bH, zbw, zbh)
          If (xBitmap!="ok")
          {
             trGdip_DisposeImage(textBoxu, 1)
             textBoxu := xBitmap
          }
       } Else
          addJournalEntry(A_ThisFunc "(). ERROR. Unable to rotate the text bitmap. It exceeds 536 megapixels or another error occured.")
    }

    trGdip_GetImageDimensions(textBoxu, nImgW, nImgH)
    zImgW := (zz=1) ? zbw : nImgW
    zImgH := (zz=1) ? zbh : nImgH
    If (TextInAreaAlign=3)
       imgSelPx := imgSelPx + imgSelW - zImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx + Round(imgSelW/2 - zImgW/2)

    If (TextInAreaValign=3)
       imgSelPy := imgSelPy + imgSelH - zImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + Round(imgSelH/2 - zImgH/2)

    tX := imgSelPx,    tY := imgSelPy
    tW := zImgW,       tH := zImgH
    ; fnOutputDebug(A_ThisFunc "(): " tX "," tY "," wX "," hY "," tW "," tH)
    If (TextInAreaBlendMode>1 || alphaMaskingMode>1)
    {
       If (TextInAreaBlendMode>1)
          bgrBMPu := Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, tX, tY, tW, tH, 0, 0, 1)

       newBitmap := trGdip_CreateBitmap(A_ThisFunc, tW, tH)
       Gr := Gdip_GraphicsFromImage(newBitmap)
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(Gr, 2)

       r1 := trGdip_DrawImage(A_ThisFunc, Gr, textBoxu, imgSelPx - tX, imgSelPy - tY, zimgW, zimgH)
       Gdip_DeleteGraphics(Gr)
       If (TextInAreaBlendMode>1)
          zr := QPV_BlendBitmaps(bgrBMPu, newBitmap, TextInAreaBlendMode - 1, 0, BlendModesFlipped)

       If (alphaMaskingMode>1)
       {
          thisIDu := "a" previewMode
          fBitmap := (TextInAreaBlendMode>1) ? bgrBMPu : newBitmap
          realtimePasteInPlaceAlphaMasker(0, fBitmap, thisIDu, maskedBitmap)
       }

       gBitmap := validBMP(maskedBitmap) ? maskedBitmap : bgrBMPu
       r2 := trGdip_DrawImage(A_ThisFunc, G2, gBitmap, tX, tY)
       ; fnOutputDebug(A_ThisFunc "(): " r1 "=" r2 "=" zr)
       trGdip_DisposeImage(newBitmap, 1)
       trGdip_DisposeImage(bgrBMPu, 1)
       trGdip_DisposeImage(maskedBitmap, 1)
    } Else
    {
       r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, zimgW, zimgH)
    }

    livePreviewInsertTextinArea("kill")
    trGdip_DisposeImage(textBoxu, 1)
    Gdip_DeleteGraphics(G2)
    Gdip_DeleteBrush(zBrush)
    zeitOperation := A_TickCount - startOperation
    If (r1!="fail" && validBMP(metaBitmap))
    {
       wrapRecordUndoLevelNow(metaBitmap)
    } Else
    {
       trGdip_DisposeImage(metaBitmap)
       showTOOLtip("Failed to draw the text on the image")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }

    SetTimer, ResetImgLoadStatus, -100
    dummyTimerDelayiedImageDisplay(50)
    etaTime := SecToHHMMSS(Round(zeitOperation/1000, 3))
    addJournalEntry("Text drawn on image in: " etaTime)
    If (hasRanExpand=1)
    {
       totalSelUndos := Round(undoSelLevelsArray.Count())
       currentSelUndoLevel := clampInRange(totalSelUndos, 1, totalSelUndos)
       restorePreviousSelections(currentSelUndoLevel)
       SetTimer, dummyRefreshImgSelectionWindow, -125
    }
}

livePreviewInsertTextinArea(actionu:=0, brushingMode:=0) {
    Critical, on
    Static lastInvoked := 1, prevBMPu, prevState, scaleuPreview := 1, skippedLines := 0
    If (actionu="kill")
    {
       coreInsertTextInAreaBox(0, "kill", 0, 1, 0, 0)
       realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       prevState := 0
       Return
    } Else If (actionu="soft-kill")
    {
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       prevState := 0
       Return
    } 

    If (doImgEditLivePreview!=1 && brushingMode=0 || !AnyWindowOpen || testSelectOutsideImgEntirely(useGdiBitmap()) && PasteInPlaceAutoExpandIMG=0 && forceLiveAlphaPreviewMode=0 || imgSelOutViewPort=1)
       Return

    If (forceLiveAlphaPreviewMode=1 && liveDrawingBrushTool=1)
    {
       livePreviewAlphaMasking("live")
       Return
    }

    ; setImageLoading()
    G2 := 2NDglPG
    previewMode := 1
    Gdip_ResetClip(G2)
    ; trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
    vpWinClientSize(mainWidth, mainHeight)
    trGdip_GetImageDimensions(useGdiBitmap(), thisW, thisH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    thisPos := (skippedLines>0) ? "a" prevDestPosY zoomLevel : 0
    thisState := "a" UserTextArea TextInAreaAlign TextInAreaValign TextInAreaDoBlurs TextInAreaBlurAmount TextInAreaBlurBorderAmount TextInAreaUsrMarginz TextInAreaBgrColor TextInAreaBgrEntire TextInAreaBgrUnified TextInAreaCutOutMode TextInAreaBgrOpacity TextInAreaBorderSize TextInAreaBorderOut TextInAreaBorderColor TextInAreaBorderOpacity TextInAreaFontBold TextInAreaFontColor TextInAreaFontItalic TextInAreaFontName TextInAreaFontLineSpacing TextInAreaFontOpacity TextInAreaFontSize TextInAreaFontStrike TextInAreaFontUline TextInAreaOnlyBorder TextInAreaPaintBgr TextInAreaRoundBoxBgr imgSelW imgSelH mainWidth mainHeight TextInAreaCharSpacing TextInAreaAutoWrap TextInAreaCaseTransform TextInAreaFlipH TextInAreaFlipV userimgGammaCorrect thisW thisH thisPos
    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    If (((A_TickCount - lastInvoked < 50) || (thisState=prevState)) && validBMP(prevBMPu))
    {
       textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       If (thisState!=prevState)
          mustGoTimer := 1
    } Else
    {
       ; ToolTip, % mainHeight "|" imgSelPy "|" imgSelH , , , 2
       MouseCoords2Image(1, 1, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kYa)
       MouseCoords2Image(mainWidth + 2, mainHeight + 2, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kYb)
       kYa := (TextInAreaValign=13) ? thisH - kYa - imgSelY1 : kYa - imgSelY1
       kYb := (TextInAreaValign=13) ? thisH - kYb - imgSelY1 : kYb - imgSelY1
       obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 1, kYa, kYb, 1)
       ; obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 1, kYa, kYb, 1)
       If validBMP(obju[1])
       {
          prevState := thisState
          trGdip_DisposeImage(prevBMPu, 1)
          textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
          trGdip_DisposeImage(obju[1], 1)
          scaleuPreview := obju[6]
          skippedLines := obju[7]
          prevBMPu := textBoxu
          textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       } Else Return
    }

    startZeit := A_TickCount
    coreDesiredPixFmt := o_coreFmt
    Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight)
    trGdip_GetImageDimensions(useGdiBitmap(), thisW, thisH)
    objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, thisW, thisH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
    trGdip_GetImageDimensions(textBoxu, onImgW, onImgH)
    thisRotation := (TextInAreaVerticalia=1) ? VPselRotation + 90 : VPselRotation
    If (viewportQPVimage.imgHandle)
       thisRotation := (TextInAreaVerticalia=1) ? 90 : 0

    Gdip_GetRotatedDimensions(onImgW, onImgH, thisRotation, rrImgW, rrImgH)
    mpx := Round((rrImgW * rrImgH)/1000000, 1)
    If (thisRotation>0)
    {
       zz := 1
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, thisRotation, "-", 5, 0, 1)
       pkpl := (xbitmap="ok") ? textBoxu : xBitmap
       trGdip_GetImageDimensions(pkpl, kW, kH)
       ppw := Round((max(kW, kH) * zoomLevel) * scaleuPreview)
       bW := (kW>imgSelW) ? imgSelW : ppw
       bH := (kH>imgSelH) ? imgSelH : ppw
       bW := (bW>imgSelW) ? imgSelW : bW
       bH := (bH>imgSelH) ? imgSelH : bH
       calcIMGdimensions(kW, kH, bW, bH, zbw, zbh)
       If validBMP(xBitmap)
       {
          trGdip_DisposeImage(textBoxu, 1)
          textBoxu := xBitmap
       }
    } Else zz := 0

    trGdip_GetImageDimensions(textBoxu, nImgW, nImgH)
    zImgW := (zz=1) ? Round(zbw) : Round((nImgW * zoomLevel) * scaleuPreview)
    zImgH := (zz=1) ? Round(zbh) : Round((nImgH * zoomLevel) * scaleuPreview)
    ; ToolTip, % "on=" onImgW "|" onImgH "|" zz "`nk==" kW "|" kH "`nsel" imgSelW "|" imgSelH "`nNim" nImgW "|" nImgH  "`nZim" zImgW "|" zImgH  , , , 2

    If (TextInAreaAlign=3)
       imgSelPx := imgSelPx := imgSelPx + imgSelW - zImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx := imgSelPx + Round(imgSelW/2 - zImgW/2)

    If (TextInAreaValign=3)
       imgSelPy := imgSelPy + imgSelH - zImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + Round(imgSelH/2 - zImgH/2)

    tX := imgSelPx,    tY := imgSelPy
    tW := zImgW,       tH := zImgH
    objSel.sw := tW,   objSel.sh := tH
    objSel.sx := tX,   objSel.sy := tY
    recordPrevAlphaMaskCoords(tX, tY, zImgW, zImgH)
    If (userimgGammaCorrect=1 || TextInAreaBlendMode>1 || alphaMaskingMode>1)
    {
       If (TextInAreaBlendMode>1 || alphaMaskingMode>1)
       {
          otx := tX, oty := tY
          otw := tW, oth := tH
          getClampedVPselToWindow(0, mainWidth, mainHeight, thisW, thisH, tX, tY, tW, tH)
          ptx := tX - otx, pty := tY - oty
          ptw := tW - otw, pth := tH - oth
          objSel.dw := tW,   objSel.dh := tH
          objSel.dx := tX,   objSel.dy := tY
       }

       bgrBMPu := getImgSelectedAreaEditMode(1, tX, tY, tW, tH, tW, tH, 0, tW, tH)
       ; ToolTip, % tw "|" tH , , , 2
    }

    objSel.invertArea := 0
    objSel.nw := tW,   objSel.nh := tH
    If (validBMP(bgrBMPu) && userimgGammaCorrect=1)
    {
       trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, tX, tY, tW, tH)
       Gdip_SetCompositingQuality(G2, 2)
    }

    bgrColor := makeRGBAcolor(TextInAreaBgrColor, TextInAreaBgrOpacity)
    zBrush := Gdip_BrushCreateSolid(bgrColor)
    If (TextInAreaBlendMode>1 || alphaMaskingMode>1)
    {
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, tW, tH)
       Gr := Gdip_GraphicsFromImage(newBitmap)
       If (TextInAreaBlendMode=1)
          r1 := trGdip_DrawImage(A_ThisFunc, Gr, bgrBMPu)

       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(Gr, 2)

       r1 := trGdip_DrawImage(A_ThisFunc, Gr, textBoxu, imgSelPx - tX, imgSelPy - tY, zimgW, zimgH, 0, 0, nimgW, nimgH)
       Gdip_DeleteGraphics(Gr)
       If (TextInAreaBlendMode>1)
          zr := QPV_BlendBitmaps(bgrBMPu, newBitmap, TextInAreaBlendMode - 1, 0, BlendModesFlipped)

       fBitmap := (TextInAreaBlendMode>1) ? bgrBMPu : newBitmap
       If (alphaMaskingMode>1 && brushingMode=1 && validBMP(fBitmap))
       {
          trGdip_GetImageDimensions(userAlphaMaskBmpPainted, zImgW, zImgH)
          viewportDynamicOBJcoords.x := objSel.sx,  viewportDynamicOBJcoords.y := objSel.sy
          viewportDynamicOBJcoords.w := objSel.sw,  viewportDynamicOBJcoords.h := objSel.sH
          viewportDynamicOBJcoords.zl := (objSel.sw/zImgW + objSel.sh/zImgH)/2 + 0.0001
          wBitmap := getRectFromBitmap(userAlphaMaskBmpPainted, objSel, 1)
          alphaMaskGray := validBMP(wBitmap) ? wBitmap : userAlphaMaskBmpPainted
          QPV_SetBitmapAsAlphaChannel(fBitmap, alphaMaskGray, alphaMaskColorReversed, alphaMaskReplaceMode, alphaMaskBMPchannel)
          If validBMP(wBitmap)
             trGdip_DisposeImage(wBitmap, 1)
       } Else If (alphaMaskingMode>1)
       {
          getVPselSize(zW, zH, 1, 0)
          objSel.zw := zw,        objSel.zh := zh
          ; objSel.forceRect := (VPselRotation>0) ? 1 : 0
          ppk := (TextInAreaBlendMode>1) ? "a" imgSelX1 imgSelY1 : 0
          thisIDu := "a" previewMode VPselRotation zoomLevel imgFxMode ForceNoColorMatrix FlipImgH FlipImgV getIDvpFX() tinyPrevAreaCoordX tinyPrevAreaCoordY getVPselIDs("saiz-vpos") FillAreaApplyColorFX PasteInPlaceHue PasteInPlaceSaturation PasteInPlaceLight PasteInPlaceGamma clrGradientOffX clrGradientOffY TextInAreaFlipV TextInAreaFlipV TextInAreaAlign TextInAreaCharSpacing TextInAreaBlendMode TextInAreaValign TextInAreaBlurAmount TextInAreaBlurBorderAmount TextInAreaUsrMarginz TextInAreaBgrColor TextInAreaBgrEntire TextInAreaBgrUnified TextInAreaCutOutMode TextInAreaBgrOpacity TextInAreaBorderSize TextInAreaBorderOut TextInAreaBorderColor TextInAreaBorderOpacity TextInAreaFontBold TextInAreaFontColor TextInAreaFontItalic TextInAreaFontName
          thisIDu .= "b" TextInAreaFontLineSpacing TextInAreaFontOpacity TextInAreaFontSize TextInAreaFontStrike TextInAreaFontUline TextInAreaOnlyBorder TextInAreaPaintBgr TextInAreaRoundBoxBgr TextInAreaAutoWrap TextInAreaCaseTransform userimgGammaCorrect undoLevelsRecorded currentUndoLevel useGdiBitmap() getAlphaMaskIDu() ppk
          realtimePasteInPlaceAlphaMasker(previewMode, fBitmap, thisIDu, maskedBitmap, objSel)
       }

       gBitmap := validBMP(maskedBitmap) ? maskedBitmap : bgrBMPu
       If (alphaMaskingMode>1 && brushingMode=1)
          gBitmap := fBitmap
       r2 := trGdip_DrawImage(A_ThisFunc, G2, gBitmap, tX, tY)
       trGdip_GetImageDimensions(gBitmap, oImgW, oImgH)
       ; ToolTip, % tw "|" th "||" oImgW "|" oImgH , , , 2
       trGdip_DisposeImage(newBitmap, 1)
       If (gBitmap=maskedBitmap && brushingMode=0 && alphaMaskingMode>1)
          trGdip_DisposeImage(maskedBitmap, 1)
    } Else
    {
       r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, zimgW, zimgH, 0, 0, nimgW, nimgH)
    }

    trGdip_DisposeImage(textBoxu, 1)
    bgrBMPu := trGdip_DisposeImage(bgrBMPu, 1)
    Gdip_DeleteBrush(zBrush)
    Gdip_ResetClip(G2)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)

    If (mustGoTimer=1 && brushingMode=0)
       SetTimer, livePreviewsImageEditing, -100

    lastInvoked := A_TickCount
}

FillSelectedArea() {
    If (FillAreaInverted=1)
       PasteInPlaceAutoExpandIMG := 0

    If (!testAllowSelInvert() && FillAreaInverted=1)
    {
       btn := !AnyWindowOpen ? "|&Reopen panel" : ""
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK" btn, 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelFillSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    allowOutside := 0
    whichBitmap := useGdiBitmap()
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If ((imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH) && PasteInPlaceAutoExpandIMG=1 && validBMP(whichBitmap) && imgW && imgH)
       allowOutside := 1

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 1, allowOutside)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    startZeit := A_TickCount
    If (allowOutside=1)
    {
       xa := imgSelX1, ya := imgSelY1
       xb := imgSelX2, yb := imgSelY2
       zW := Round( ( max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2) ) )
       zH := Round( ( max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2) ) )
       pPath := coreCreateFillAreaShape(0, 0, zW, zH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio, 2, 0)
       bounds := getAccuratePathBounds(pPath, 1)
       imgSelX1 += bounds.x
       imgSelY1 += bounds.y
       imgSelX2 := imgSelX1 + bounds.w
       imgSelY2 := imgSelY1 + bounds.h
       zX := (imgSelX1<0) ? abs(imgSelX1) : 0,  zY := (imgSelY1<0) ? abs(imgSelY1) : 0
       defineRelativeSelCoords(imgW, imgH)
       hasRanExpand := performAutoExpandCanvas(imgW, imgH)
       imgSelX1 := xa + zX, imgSelY1 := ya + zY
       imgSelX2 := xb + zX, imgSelY2 := yb + zY
       defineRelativeSelCoords(imgW, imgH)
       Gdip_DeletePath(pPath)
    }

    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)
    If !validBMP(newBitmap)
    {
       showTOOLtip("Failed to fill selected area. Unable to allocate new bitmap.")
       SoundBeep 300, 100
       ResetImgLoadStatus()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    r := coreFillSelectedArea("no", newBitmap)
    If (r="fail" || !validBMP(newBitmap))
    {
       showTOOLtip("Failed to fill selected area")
       SoundBeep 300, 100
       ResetImgLoadStatus()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return "fail"
    }

    If (FillAreaRemBGR=1)
       currIMGdetails.HasAlpha := 1

    coreFillSelectedArea("kill", 0)
    wrapRecordUndoLevelNow(newBitmap)
    zeitOperation := A_TickCount - startZeit
    addJournalEntry("Fill selected area operation. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    dummyTimerDelayiedImageDisplay(50)
    If (hasRanExpand=1)
    {
       totalSelUndos := Round(undoSelLevelsArray.Count())
       currentSelUndoLevel := clampInRange(totalSelUndos, 1, totalSelUndos)
       restorePreviousSelections(currentSelUndoLevel)
       dummyRefreshImgSelectionWindow()
       ; ToolTip, % totalSelUndos "=" currentSelUndoLevel , , , 2
    }

    If (FillAreaDoContour=1)
    {
       fn := Func("DrawLinesInSelectedArea").Bind(2)
       SetTimer, % fn, -100
    }
}

dummyInnerCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, shape, pPath) {
    If (shape=1) ; rect
    {
       Gdip_AddPathRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (shape=2) ; rounded rect
    {
       radius := clampInRange(min(imgSelW, imgSelH)*(FillAreaRectRoundness/200) + 1, 2, min(imgSelW, imgSelH)*0.9)
       ; radius := Round(((imgSelW + imgSelH)//2)*0.1) + 1
       Gdip_AddPathRoundedRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, radius)
    } Else If (shape=3) ; ellipse
    {
       If (FillAreaEllipseSection<847 && FillAreaEllipsePie=1)
          createPiePath(imgSelPx, imgSelPy, imgSelW, imgSelH, 0, pPath)
       Else
          Gdip_AddPathEllipse(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (shape=4) ; triangle
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, [cX1, cY1, cX2, cY2, cX3, cY3])
    } Else If (shape=5) ; right triangle
    {
       cX1 := imgSelPx
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, [cX1, cY1, cX2, cY2, cX3, cY3])
    } Else If (shape=6) ; rhombus
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH//2
       cX3 := imgSelPx + imgSelW//2
       cY3 := imgSelPy + imgSelH
       cX4 := imgSelPx + imgSelW
       cY4 := imgSelPy + imgSelH//2
       Gdip_AddPathPolygon(pPath, [cX1, cY1, cX2, cY2, cX3, cY3, cX4, cY4])
    } Else If (shape=7)
    {
       PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx + 1, imgSelPy + 1, imgSelW, imgSelH, 1, !bezierSplineCustomShape)
       createPathVectorCustomShape(pPath, PointsList, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, 0)
    }
}

coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, shape, angleu:=0, keepBounds:=0, allowSelectionCenter:=2, allowCavity:=1) {
    If (shape=7)
       Return createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, 2, angleu, keepBounds, 0, allowSelectionCenter, 1, innerSelectionCavityX, innerSelectionCavityY)

    pPath := Gdip_CreatePath()
    dummyInnerCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, shape, pPath)
    If (innerSelectionCavityX>0 && innerSelectionCavityY>0 && allowCavity=1)
    {
       clonedPath := Gdip_ClonePath(pPath)
       Gdip_ScalePathAtCenter(clonedPath, innerSelectionCavityX, innerSelectionCavityY)
       Gdip_AddPathToPath(pPath, clonedPath, 0)
       Gdip_DeletePath(clonedPath)
    }

    If (angleu && pPath)
    {
       If (shape=3 && FillAreaEllipseSection<847 && FillAreaEllipsePie=1)
       {
          ; ToolTip, % "l=" keepBounds "|" angleu , , , 2
          sPath := Gdip_CreatePath()
          Gdip_AddPathEllipse(sPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
          trGdip_RotatePathAtCenter(sPath, angleu, 1, 1, keepBounds, 1, pPath)
          Gdip_DeletePath(sPath)
       } Else
          trGdip_RotatePathAtCenter(pPath, angleu, 1, 1, keepBounds, 1)
    }

    If ((shape=7 || shape=5 || shape=4) && pPath && allowSelectionCenter>=1)
       centerPath2bounds(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0)
 
    Return pPath
}

trGdip_RotatePathAtCenter(pPath, Angle, MatrixOrder:=1, withinBounds:=0, withinBkeepRatio:=1, highAccuracy:=0, destinationPath:=0) {
; modified by Marius Șucan - added withinBounds option
; and highAccuracy option

  If (highAccuracy=1)
     Rect := getAccuratePathBounds(pPath)
  Else
     Rect := Gdip_GetPathWorldBounds(pPath)

  cX := Rect.x + (Rect.w / 2)
  cY := Rect.y + (Rect.h / 2)
  pMatrix := Gdip_CreateMatrix()
  Gdip_TranslateMatrix(pMatrix, -cX , -cY)
  Gdip_RotateMatrix(pMatrix, Angle, MatrixOrder)
  Gdip_TranslateMatrix(pMatrix, cX, cY, MatrixOrder)
  pathu := destinationPath ? destinationPath : pPath
  E := Gdip_TransformPath(pathu, pMatrix)
  If destinationPath
     E := Gdip_TransformPath(pPath, pMatrix)
  Gdip_DeleteMatrix(pMatrix)

  If (withinBounds=1 && !E && Angle!=0)
  {
     If (highAccuracy=1)
        nRect := getAccuratePathBounds(pPath)
     Else
        nRect := Gdip_GetPathWorldBounds(pPath)

     ncX := nRect.x + (nRect.w / 2)
     ncY := nRect.y + (nRect.h / 2)
     pMatrix := Gdip_CreateMatrix()
     Gdip_TranslateMatrix(pMatrix, -ncX , -ncY)
     sX := Rect.w / nRect.w
     sY := Rect.h / nRect.h
     If (withinBkeepRatio=1)
     {
        sX := min(sX, sY)
        sY := min(sX, sY)
     }
     Gdip_ScaleMatrix(pMatrix, sX, sY, MatrixOrder)
     Gdip_TranslateMatrix(pMatrix, ncX, ncY, MatrixOrder)
     If (sX!=0 && sY!=0)
        E := Gdip_TransformPath(pathu, pMatrix)
     Gdip_DeleteMatrix(pMatrix)
  }

  Return E
}

testSelectionLargerThanViewport() {
    vpWinClientSize(mainWidth, mainHeight)
    obju := []
    obju.mainWidth := mainWidth
    obju.mainHeight := mainHeight
    vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx) + SelDotsSize//2
    vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy) + SelDotsSize//2
    VPmpx := Round((vPimgSelW * vPimgSelH)/1000000, 3)
    MAINmpx := Round((mainWidth * mainHeight)/1000000, 3) + 0.01
    obju.isLarger := (MAINmpx<VPmpx) ? 1 : 0
    Return obju
}

testSelectionLargerThanGiven(imgW, imgH) {
    nImgSelX1 := min(imgSelX1, imgSelX2)
    nImgSelY1 := min(imgSelY1, imgSelY2)
    nimgSelX2 := max(imgSelX1, imgSelX2)
    nimgSelY2 := max(imgSelY1, imgSelY2)
    If (nImgSelX1<0 || nImgSelY1<0 || nImgSelX2>imgW || nImgSelY2>imgH)
       Return 1
    Return 0
}

testEntireImgSelected(imgW:=0, imgH:=0, precise:=0) {
    If (!imgW || !imgH)
       trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)

    nImgSelX1 := min(imgSelX1, imgSelX2)
    nImgSelY1 := min(imgSelY1, imgSelY2)
    nimgSelX2 := max(imgSelX1, imgSelX2)
    nimgSelY2 := max(imgSelY1, imgSelY2)
    If (precise=1 && nImgSelX1=0 && nImgSelY1=0 && nImgSelX2=imgW && nImgSelY2=imgH)
       Return 1
    Else If (precise=0 && nImgSelX1<2 && nImgSelY1<2 && (nImgSelX2>=imgW - 1) && (nImgSelY2>=imgH - 1))
       Return 1
    Return 0
}

tzGdip_DrawImageFast(pGraphics, pBitmap, X:=0, Y:=0) {
   If !validBMP(pBitmap)
      Return -1

   If pGraphics
      i := Gdip_GetInterpolationMode(pGraphics)

   If (i=5 && pBitmap)
   {
      Gdip_GetImageDimensions(pBitmap, w, h)
      If (max(w, h)>32750 && w && h)
      {
         z := 1
         Gdip_SetInterpolationMode(pGraphics, 7)
      }
   }

   r := Gdip_DrawImageFast(pGraphics, pBitmap, X, Y)
   If (z=1)
      Gdip_SetInterpolationMode(pGraphics, 5)
   Return r
}

tzGdip_DrawImage(pGraphics, pBitmap, dx:="", dy:="", dw:="", dh:="", sx:="", sy:="", sw:="", sh:="", Matrix:=1, Unit:=2, ImageAttr:=0) {
   If !validBMP(pBitmap)
   {
      addJournalEntry(A_ThisFunc "(): error - invalid bitmap to draw.")
      Return -1
   }

   If pGraphics
      i := Gdip_GetInterpolationMode(pGraphics)

   If (i=5 && pBitmap)
   {
      Gdip_GetImageDimensions(pBitmap, w, h)
      If (max(w, h)>32750 && w && h)
      {
         z := 1
         Gdip_SetInterpolationMode(pGraphics, 7)
      }
   }

   r := Gdip_DrawImage(pGraphics, pBitmap, dx, dy, dw, dh, sx, sy, sw, sh, Matrix, Unit, ImageAttr)
   If (z=1)
      Gdip_SetInterpolationMode(pGraphics, 5)
   Return r
}

trGdip_DrawImage(funcu, pGraphics, pBitmap, dx:="", dy:="", dw:="", dh:="", sx:="", sy:="", sw:="", sh:="", Matrix:=1, Unit:=2, ImageAttr:=0) {
  If (!pGraphics)
  {
     addJournalEntry(A_ThisFunc "(). Internal error. Function called by " funcu "() using pG=" pGraphics)
     Return "fail"
  }

  If !validBMP(pBitmap)
  {
     addJournalEntry(A_ThisFunc "(). Internal error - invalid bitmap. Function called by " funcu "() with pBMP=" pBitmap)
     Return "fail"
  }

  r := tzGdip_DrawImage(pGraphics, pBitmap, dx, dy, dw, dh, sx, sy, sw, sh, Matrix, Unit, ImageAttr)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to draw the processed image in the internal graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics " and pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(r, baseMsg)
     Return "fail"
  }
}

trGdip_GraphicsFromImage(funcu, pBitmap, InterpolationMode:="", SmoothingMode:="", PageUnit:="", CompositingQuality:="") {
  If !validBMP(pBitmap)
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() for pBitmap = " pBitmap)
     Return
  }

  r := Gdip_GraphicsFromImage(pBitmap, InterpolationMode, SmoothingMode, PageUnit, CompositingQuality)
  If (!r || gdipLastError)
  {
     baseMsg := "Unable to create virtual graphics object required for processing the image... Error occured in " A_ThisFunc "() invoked by " funcu "() for pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(gdipLastError, baseMsg)
     Return
  } Else Return r
}

trGdip_DrawImageFX(funcu, pGraphics, pBitmap, dX:="", dY:="", sX:="", sY:="", sW:="", sH:="", matrix:="", pEffect:="", ImageAttr:=0, hMatrix:=0, Unit:=2) {
   If (!pGraphics || !validBMP(pBitmap))
   {
      addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() using " pGraphics ", " pBitmap)
      Return "fail"
   }

   If pGraphics
      i := Gdip_GetInterpolationMode(pGraphics)

   If (i=5 && validBMP(pBitmap))
   {
      Gdip_GetImageDimensions(pBitmap, w, h)
      If (max(w, h)>32750 && w && h)
      {
         z := 1
         Gdip_SetInterpolationMode(pGraphics, 7)
      }
   }
 
   r := Gdip_DrawImageFX(pGraphics, pBitmap, dX, dY, sX, sY, sW, sH, matrix, pEffect, ImageAttr, hMatrix, Unit)
   If (r=1 && A_LastError=8)
      r := 3

   If (z=1)
      Gdip_SetInterpolationMode(pGraphics, 5)

   If r
   {
      baseMsg := "Unable to modify the image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "(). "
      generalInternalErrorMsgBox(r, baseMsg)
      Return "fail"
   }
}

trGdip_GraphicsClear(funcu, pGraphics, coloru:=0x00ffFFff, silentMode:=0) {
  If !pGraphics
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() on graphics = " pGraphics ". ")
     Return "fail"
  }

  r := Gdip_GraphicsClear(pGraphics, coloru)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to apply operations on image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics ". "
     generalInternalErrorMsgBox(r, baseMsg, silentMode)
     Return "fail"
  }
}

QPV_SaveImageFile(funcu, pBitmap, file2save, jpegQuality, depthLevel:=1) {
   Static dephtus := {1:32, 2:24, 3:16, 4:8, 5:0}

   If (dephtus[depthLevel]>1 && depthLevel!=1)
   {
      pf := Gdip_GetImagePixelFormat(pBitmap, 2)
      allow := (pf="24-RGB" && depthLevel=2) || (pf="32-ARGB" && depthLevel=1) || (pf="32-PARGB" && depthLevel=1) ? 0 : 1
      If (allow=1)
         Gdip_BitmapSetColorDepth(pBitmap, dephtus[depthLevel], 1)
   }

   If ((depthLevel=1 || depthLevel=2) && RegExMatch(file2save, "i)(.\.(jpeg|jpg|jpe|jng|ppm|xpm))$"))
   {
      pf := Gdip_GetImagePixelFormat(pBitmap, 2)
      If (pf!="24-RGB")
         Gdip_BitmapSetColorDepth(pBitmap, 24, 1)
   }

   ; fnOutputDebug(A_ThisFunc "|" pf "|" allow "|" depthLevel)
   r := Gdip_SaveBitmapToFile(pBitmap, file2save, jpegQuality)
   If (r=-5)
      r := Gdip_ErrorHandler(gdipLastError, 0)
   Else If r
      r .= " / " A_LastError

   If r
   {
      pf := Gdip_GetImagePixelFormat(pBitmap, 2)
      zg := (pf="24-RGB") ? 24 : 32
      addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with GDI+: " file2save "`nError code: " r)
      zr := SaveFIMfile(file2save, pBitmap, dephtus[depthLevel], fileEXT, zg)
      If (!zr && wasInitFIMlib=1)
         r := zr
      Else If (wasInitFIMlib=1)
         addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with FreeImage: " file2save "`nError code: " zr)
   }
   Return r
}

warnUserFatalBitmapError(pBitmap, funcu) {
    If (!validBMP(pBitmap) || pBitmap="err" || pBitmap="fail")
    {
       r := (pBitmap="no-gdip") ? 0 : gdipLastError
       baseMsg := "Unable to create internal bitmap to apply operations on image... Error occured in Gdip_CreateBitmap() invoked by " funcu  "(). "
       generalInternalErrorMsgBox(r, baseMsg)
       Return "fail"
    }
}

getAlphaMaskIDu(moar:=1) {
   bonusOptions := (moar=1) ? "a" lastPaintEventID lastPaintEventID userAlphaMaskBmpPainted userPrevAlphaMaskBmpPainted : 0
   Return "a" alphaMaskBMPbright alphaMaskBMPchannel alphaMaskBMPcontrast alphaMaskClrAintensity alphaMaskClrBintensity alphaMaskCoffsetX alphaMaskCoffsetY alphaMaskColorReversed alphaMaskGradientAngle alphaMaskGradientPosA alphaMaskGradientPosB alphaMaskGradientScale alphaMaskGradientWrapped alphaMaskingMode alphaMaskOffsetX alphaMaskOffsetY alphaMaskRefBMP alphaMaskReplaceMode liveDrawingBrushTool bonusOptions
}

getVPselIDs(what) {
   kImgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   kImgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   If InStr(what, "csize")
      vpWinClientSize(mainWidth, mainHeight)

   MouseCoords2Image(1, 1, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, nimgSelX1, nimgSelY1)
   MouseCoords2Image(mainWidth, mainHeight, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, nimgSelX2, nimgSelY2)
   MouseCoords2Image(1, 1, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, zimgSelX1, zimgSelY1)
   MouseCoords2Image(mainWidth, mainHeight, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, zimgSelX2, zimgSelY2)
   koffX := (imgSelX1 < nimgSelX1) ? imgSelX1 : 0
   koffY := (imgSelY1 < nimgSelY1) ? imgSelY1 : 0
   zW := (ImgSelX2 < zImgSelX2) ? ImgSelX2 : kImgSelW
   zH := (ImgSelY2 < zImgSelY2) ? ImgSelY2 : kImgSelH
   If InStr(what, "saiz")
      r .= "a" kImgSelW kImgSelH
   If InStr(what, "vpos") ; clamped
      r .= "a" koffX koffY
   If InStr(what, "xy") ; clamped
      r .= "a" imgSelX1 imgSelY1
   If InStr(what, "vsize") ; clamped
      r .= "a" zW zH "|"
   Return r
}

isSelEntireVisible(mw:=0, mh:=0) {
   If (!mw || !mh)
      vpWinClientSize(mw, mh)

   nImgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := min(imgSelY1, imgSelY2)
   nImgSelX2 := max(imgSelX1, imgSelX2)
   nImgSelY2 := max(imgSelY1, imgSelY2)

   zImgSelX1 := prevDestPosX + Round(nImgSelX1*zoomLevel)
   zImgSelY1 := prevDestPosY + Round(nImgSelY1*zoomLevel)
   zImgSelX2 := prevDestPosX + Round(nImgSelX2*zoomLevel)
   zImgSelY2 := prevDestPosY + Round(nImgSelY2*zoomLevel)

   r := (zImgSelX1<=mw && zImgSelY1<=mh && zImgSelX1>=0 && zImgSelY1>=0 && zImgSelX2<=mw && zImgSelY2<=mh && zImgSelX2>=0 && zImgSelY2>=0) ? 1 : 0
   Return r
}

isSelEntirelyWithinIMGbounds() {
   trGdip_GetImageDimensions(useGdiBitmap(), w, h)
   r := (imgSelX1<0 || imgSelY1<0 || imgSelX2>w || imgSelY2>h) ? 0 : 1
   Return r
}

isSelEntireOutside(mw:=0, mh:=0) {
   If (!mw || !mh)
      vpWinClientSize(mw, mh)

   nImgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := min(imgSelY1, imgSelY2)
   nImgSelX2 := max(imgSelX1, imgSelX2)
   nImgSelY2 := max(imgSelY1, imgSelY2)

   zImgSelX1 := prevDestPosX + Round(nImgSelX1*zoomLevel)
   zImgSelY1 := prevDestPosY + Round(nImgSelY1*zoomLevel)
   zImgSelX2 := prevDestPosX + Round(nImgSelX2*zoomLevel)
   zImgSelY2 := prevDestPosY + Round(nImgSelY2*zoomLevel)
   vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)

   a := isDotInRect(zImgSelX1, zImgSelY1, 0, mw, 0, mh)
   b := isDotInRect(zImgSelX2, zImgSelY2, 0, mw, 0, mh)
   c := isDotInRect(zImgSelX1, zImgSelY1 + vPimgSelH, 0, mw, 0, mh)
   d := isDotInRect(zImgSelX1 + vPimgSelW, zImgSelY1, 0, mw, 0, mh)
   e := isDotInRect(zImgSelX1 + vPimgSelW//2, zImgSelY1 + vPimgSelH//2, 0, mw, 0, mh)
   If (a || b || c || d || e)
      Return 0

   a := isDotInRect(0, 0, zImgSelX1, zImgSelX2, zImgSelY1, zImgSelY2)
   b := isDotInRect(mw, mh, zImgSelX1, zImgSelX2, zImgSelY1, zImgSelY2)
   c := isDotInRect(mw//2, mh//2, zImgSelX1, zImgSelX2, zImgSelY1, zImgSelY2)
   If (a || b || c)
      Return 0

   Return 1
}

isTriangleEntirelyOutsideVP(x1, y1, x2, y2, x3, y3, mw, mh) {
   maxuX := max(x1,x2,x3) 
   maxuY := max(y1,y2,y3)
   minuX := min(x1,x2,x3) 
   minuY := min(y1,y2,y3)
   If (maxuX<0 || minuX>mw || maxuY<0 || minuY>mh)
      Return 1
   Return 0
}

isLineOutsideVP(x1, y1, x2, y2, mw, mh) {
   maxuX := max(x1,x2) 
   maxuY := max(y1,y2)
   minuX := min(x1,x2) 
   minuY := min(y1,y2)
   If (maxuX<0 || minuX>mw || maxuY<0 || minuY>mh)
      Return 1
   Return 0
}

getVPselSize(ByRef zW, ByRef zH, capped, invertArea) {
   If (invertArea=1)
   {
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      zW := Round( imgW * zoomLevel )
      zH := Round( imgH * zoomLevel )
   } Else
   {
      zW := Round( ( max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2) ) * zoomLevel )
      zH := Round( ( max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2) ) * zoomLevel )
   }
   If (capped=1)
      capIMGdimensionsFormatlimits("qpv-live", 1, zW, zH)
}

livePreviewHugeImageFillSelArea() {
   Critical, on
   Gdip_ResetClip(2NDglPG)
   If (doImgEditLivePreview!=1 || testSelectOutsideImgEntirely(useGdiBitmap()) || FillAreaInverted=0 && imgSelOutViewPort=1)
      Return

   ozeit := A_TickCount
   vpWinClientSize(mainWidth, mainHeight)
   trGdip_GetImageDimensions(useGdiBitmap(), thisW, thisH)
   objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, thisW, thisH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   ; pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)
   pPath := VPcreateSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, VPselRotation, 1, mainWidth, mainHeight, 0)
   If (FillAreaInverted=1)
   {
      invertPath := Gdip_ClonePath(pPath)
      tx := (imgSelPx > prevDestPosX) ? prevDestPosX : max(imgSelPx, prevDestPosX)
      ty := (imgSelPy > prevDestPosY) ? prevDestPosY : max(imgSelPy, prevDestPosY)
      twx := ((imgSelPx + imgSelW) > (prevDestPosX + prevResizedVPimgW)) ? prevDestPosX + prevResizedVPimgW : max(imgSelPx + imgSelW, prevDestPosX + prevResizedVPimgW)
      twy := ((imgSelPy + imgSelH) > (prevDestPosY + prevResizedVPimgH)) ? prevDestPosY + prevResizedVPimgH : max(imgSelPy + imgSelH, prevDestPosY + prevResizedVPimgH)
      Gdip_AddPathRectangle(invertPath, tx, ty, twx - tx, twy - ty)
      getClampedVPimgBounds(imgSelPx, imgSelPy, kX, kY, imgSelW, imgSelH)
   } Else
      getClampedVPselToWindow(1, mainWidth, mainHeight, thisW, thisH, imgSelPx, imgSelPy, imgSelW, imgSelH)

   If (imgSelOutViewPort!=1 || FillAreaInverted=1)
      zBitmap := getImgSelectedAreaEditMode(1, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0, imgSelW, imgSelH)

   If validBMP(zBitmap)
   {
      trGdip_GetImageDimensions(zBitmap, imgW, imgH)
      objSel.dw := imgSelW,    objSel.dh := imgSelH
      objSel.dx := imgSelPx,   objSel.dy := imgSelPy
      objSel.nw := imgW,       objSel.nh := imgH
      objSel.invertArea := FillAreaInverted
      ; fnOutputDebug(A_ThisFunc ": " zW "|" zH "`n" imgSelW "|" imgSelH "`n" o_imgSelW "|" o_imgSelH "`n" imgW "|" imgH)
      EZ := Gdip_LockBits(zBitmap, 0, 0, imgW, imgH, Stride, iScan, iData)
      If EZ
      {
         trGdip_DisposeImage(zBitmap)
         Gdip_DeletePath(pPath)
         addJournalEntry(A_ThisFunc "(): Failed to generate live preview. Unable to lock the bitmap bits.")
         Return
      }

      If isInRange(FillAreaColorMode, 2, 4) ; && FillAreaInverted=0 && !isImgSizeTooLarge(zW, zH))
      {
         gBpp := 32
         getVPselSize(zW, zH, 1, FillAreaInverted)
         gradientsBMP := drawFillSelGradient(zW, zH, 1, 0, 0, zW, zH, userimgGammaCorrect)
         If (validBMP(gradientsBMP) && (imgSelOutViewPort!=1 || FillAreaInverted=1))
         {
            Gdip_ImageRotateFlip(gradientsBMP, 6)
            wBitmap := getRectFromBitmap(gradientsBMP, objSel, 1)
            If validBMP(wBitmap)
            {
               trGdip_DisposeImage(gradientsBMP)
               gradientsBMP := wBitmap
            }
         }

         If validBMP(gradientsBMP)
         {
            trGdip_GetImageDimensions(gradientsBMP, zW, zH)
            imgW := min(zW, imgW),   imgH := min(zH, imgH)
            ; ToolTip, % zw "|" zh "`n" imgW "|" imgH , , , 2
            EZ := Gdip_LockBits(gradientsBMP, 0, 0, imgW, imgH, gStride, gScan, gData)
            If EZ
            {
               ; trGdip_DisposeImage(gradientsBMP)
               trGdip_GetImageDimensions(zBitmap, azW, azH)
               trGdip_DisposeImage(zBitmap)
               Gdip_DeletePath(pPath)
               addJournalEntry(A_ThisFunc "(): Failed to lock the bits of the gradient bitmap in live preview. " imgW "/" imgH " | " zW "/" zH " | " azW "/" azH)
               gradientsBMP := ""
               Return
            }
         } Else
            addJournalEntry(A_ThisFunc "(): Failed to generate the gradient bitmap for live preview.")
      }

      newColor := "0xFF" FillAreaColor
      thisOpacity := (FillAreaColorMode!=1) ? 255 : FillAreaOpacity
      eraser := (FillAreaRemBGR=1 && FillAreaDoBehind=0) ? -1 : 0
      bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
      whichPath := (FillAreaInverted=1) ? invertPath : pPath
      If (FillAreaRemBGR=1 && FillAreaDoBehind=0)
      {
         blackBrush := Gdip_BrushCreateSolid("0xFF000000")
         thisBrush := (currIMGdetails.HasAlpha=1 || bpp=32) ? pBrushHatchLow : blackBrush
         Gdip_FillPath(2NDglPG, thisBrush, whichPath)
         Gdip_DeleteBrush(blackBrush)
      }

      livePreviewPrepareSelectionArea(objSel, FillAreaInverted, 3)
      thisBehind := (FillAreaDoBehind=1 && bpp=32) ? 1 : 0
      r := DllCall(whichMainDLL "\FillSelectArea", "UPtr", iScan, "Int", imgW, "Int", imgH, "int", Stride, "int", 32, "int", newColor, "int", thisOpacity, "int", eraser, "int", userimgGammaCorrect, "int", FillAreaBlendMode - 1, "int", BlendModesFlipped, "UPtr", 0, "int", 0, "UPtr", gScan, "int", gStride, "int", gBpp, "int", thisBehind, "int", 0, "int", FillAreaCutGlass, "int", imgW, "int", imgH)
      ; ToolTip, % r "|" imgW "|" imgH , , , 2
      Gdip_UnlockBits(zBitmap, iData)
      If validBMP(gradientsBMP)
      {
         Gdip_UnlockBits(gradientsBMP, gData)
         trGdip_DisposeImage(gradientsBMP)
      }

      If ((currIMGdetails.HasAlpha=1 || bpp=32) && !thisBrush)
         Gdip_FillRectangle(2NDglPG, pBrushHatchLow, imgSelPx, imgSelPy, imgW, imgH)

      userImgAdjustHiPrecision := 1
      userImgAdjustNoClamp := (PasteInPlaceLight>1 && PasteInPlaceGamma<1) ? 1 : 0 
      thisOpacity := (FillAreaColorMode=1) ? FillAreaOpacity : 255
      If (FillAreaApplyColorFX=1 && FillAreaBlendMode>1 && thisBehind!=1)
         QPV_AdjustImageColors(zBitmap, thisOpacity, userImgAdjustInvertColors, userImgAdjustAltSat, Round(PasteInPlaceSaturation*655.35), userImgAdjustAltBright, Round(PasteInPlaceLight*257), 0, Round(PasteInPlaceGamma*655.30), 0, 0, 0, PasteInPlaceHue, 0, 0, 0, 300, 0, 0, 0, 0, -1, -1, -1, -1, 0, FillAreaInverted, 0, 65535, 0, 0, -1)

      r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, zBitmap, imgSelPx, imgSelPy)
      ; r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, zBitmap, imgSelPx, imgSelPy)
      Gdip_ResetClip(2NDglPG)
      trGdip_DisposeImage(zBitmap, 1)

   } Else
      addJournalEntry(A_ThisFunc "(): Failed to capture viewport bitmap required for the live preview.")

   Gdip_DeletePath(pPath)
   If (FillAreaInverted=1)
      Gdip_DeletePath(invertPath)

   fnOutputDebug("step END: " A_TickCount - ozeit)
}

coreFillSelectedArea(previewMode, whichBitmap:=0, brushingMode:=0) {
   Critical, on
   Static prevW, prevH, prevState, prevVPid
        , blr := {0:0, 1:0, 2:15, 3:50, 4:120, 5:180, 6:254}

   If (previewMode="kill")
   {
      LoadCachableBitmapFromFile("kill")
      realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
      drawFillSelGradient("kill", 0, 0, 0, 0, 0, 0)
      getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
      applyVPeffectsAdvOnBMP("kill")
      coredrawWelcomeImg("kill", 0, 0, 0, 0, 0, 0, 0, 0)
      userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
      If (keepUserPaintAlphaMask!=1)
         userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted, 1)
      Return
   }

   previewMode := (previewMode="no") ? 0 : 1
   If (previewMode=0)
   {
      G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap)
      If !G2
      {
         addJournalEntry("Failed to create the GDI+ graphics object.")
         Return "fail"
      }
   } Else
   {
      G2 := 2NDglPG
      whichBitmap := useGdiBitmap()
      If (doImgEditLivePreview!=1 || !validBMP(whichBitmap) || testSelectOutsideImgEntirely(useGdiBitmap()) && PasteInPlaceAutoExpandIMG=0 || FillAreaInverted=0 && imgSelOutViewPort=1 && PasteInPlaceAutoExpandIMG=0)
         Return
   }

   ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   trGdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   vpWinClientSize(mainWidth, mainHeight)
   If (previewMode=1)
      objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, oImgW, oImgH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   Else
      calcImgSelection2bmp(!LimitSelectBoundsImg, oimgW, oimgH, oimgW, oimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)

   thisVPid := "a" oImgW oImgH currentFileIndex IMGlargerViewPort imgSelLargerViewPort IMGdecalageX IMGdecalageY zoomLevel prevResizedVPimgW prevResizedVPimgH prevDestPosX prevDestPosY imageAligned
   pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio, 1)
   tx := (imgSelPx > prevDestPosX) ? prevDestPosX : max(imgSelPx, prevDestPosX)
   ty := (imgSelPy > prevDestPosY) ? prevDestPosY : max(imgSelPy, prevDestPosY)
   twx := ((imgSelPx + imgSelW) > (prevDestPosX + prevResizedVPimgW)) ? prevDestPosX + prevResizedVPimgW : max(imgSelPx + imgSelW, prevDestPosX + prevResizedVPimgW)
   twy := ((imgSelPy + imgSelH) > (prevDestPosY + prevResizedVPimgH)) ? prevDestPosY + prevResizedVPimgH : max(imgSelPy + imgSelH, prevDestPosY + prevResizedVPimgH)
   invertPath := Gdip_ClonePath(pPath)
   Gdip_AddPathRectangle(invertPath, tx, ty, twx - tx, twy - ty)
   whichPath := (FillAreaInverted=1) ? invertPath : pPath
   If (FillAreaInverted=1)
   {
      imgSelPx := imgSelPy := 0
      imgSelW  := oimgW,      imgSelH := oimgH
      prevVPid := ""
   }
   ; ToolTip, % imgSelW "=" imgSelH "`n" zImgSelW "=" zImgSelH "`n" qImgSelW "=" qImgSelH  , , , 2
   offX := offY := 0
   offW := imgSelW,   offH := imgSelH
   thisBlendMode := (FillAreaBlendMode=1 && FillAreaCutGlass=1 && FillAreaGlassy>1) ? 24 : FillAreaBlendMode 
   thisObjBlurAmount := (previewMode=1) ? (Round(abs(FillAreaBlurAmount) * zoomLevel)) : abs(FillAreaBlurAmount)
   If (FillAreaRemBGR=1 || zoomLevel>2 && previewMode=1 && !isSelEntireVisible(mainWidth, mainHeight) || imgSelLargerViewPort=1 && previewMode=1)
      thisObjBlurAmount := 0

   ainvertus := (FillAreaBlurAmount>1) ? 1 : 0
   If (FillAreaInverted=1)
      ainvertus := !ainvertus

   bgrRM := (FillAreaRemBGR=1) ? 1 : 0
   If (FillAreaRemBGR=1 && FillAreaInverted=1 && ainvertus=1)
      bgrRM := 0

   If (previewMode=1)
   {
      offX := offY := offW := offH := 0
      If (FillAreaInverted=1)
         getClampedVPimgBounds(imgSelPx, imgSelPy, kX, kY, imgSelW, imgSelH)
      Else
         getClampedVPselToWindow(!PasteInPlaceAutoExpandIMG, mainWidth, mainHeight, oImgW, oImgH, imgSelPx, imgSelPy, imgSelW, imgSelH)

      getVPselSize(zW, zH, 1, FillAreaInverted)
      objSel.dw := imgSelW,    objSel.dh := imgSelH
      objSel.dx := imgSelPx,   objSel.dy := imgSelPy
      objSel.nw := imgSelW,    objSel.nh := imgSelH
      objSel.zw := zW,         objSel.zh := zH
      objSel.invertArea := FillAreaInverted
      linearu := userimgGammaCorrect       ; (thisBlendMode>1 && thisBlendMode!=24) ? 0 : userimgGammaCorrect
      thisBrush := (FillAreaRemBGR=1 && thisObjBlurAmount>0) ? GDIPbrushHatch : 0
      gradientsBMP := drawFillSelGradient(zW, zH, 1, 0, 0, zW, zH, linearu, 0, 0, thisBrush)
      If (thisObjBlurAmount>0 && validBMP(gradientsBMP) && FillAreaRemBGR!=1)
      {
         fzx := zw/oImgW,              fzy := zh/oImgH
         ; ToolTip, % fzx "|" fzy "`n" zzw "|" zzh "`n" zzw "|" zzh , , , 2
         zzxa := imgSelX1*fzx,         zzya := imgSelY1*fzy
         zzxb := imgSelX2*fzx,         zzyb := imgSelY2*fzy
         zzw  := Round(zzxb - zzxa),   zzh  := Round(zzyb - zzya)
         If (FillAreaInverted=1)
            zPath := coreCreateFillAreaShape(zzxa, zzya, zzw, zzh, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)
         Else
            zPath := coreCreateFillAreaShape(0, 0, zw, zh, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)

         croppedOBJblurBMP := carvePathFromBitmap(gradientsBMP, zPath, 0, 0, 0, 2, thisObjBlurAmount, 0, !FillAreaInverted, ainvertus, 0)
         If validBMP(croppedOBJblurBMP)
            croppedOBJblurBMP := trGdip_DisposeImage(croppedOBJblurBMP)
         Gdip_DeletePath(zPath)
      }

      If (validBMP(gradientsBMP) && (imgSelOutViewPort!=1 || FillAreaInverted=1))
      {
         wBitmap := getRectFromBitmap(gradientsBMP, objSel, 1)
         If validBMP(wBitmap)
         {
            gradientsBMP := trGdip_DisposeImage(gradientsBMP)
            gradientsBMP := wBitmap
         } Else addJournalEntry(A_ThisFunc "(): failed to get rect from gradients bitmap")
      }
   } Else
   {
      gradientsBMP := drawFillSelGradient(imgSelW, imgSelH, previewMode, offX, offY, offW, offH, userimgGammaCorrect)
   }

   trGdip_GetImageDimensions(gradientsBMP, imgSelW, imgSelH)
   ; ToolTip, % imgSelW "|" imgSelH "`n" zW "|" zH , , , 2
   If (!validBMP(gradientsBMP) || !imgSelW || !imgSelH)
   {
      If (previewMode=0)
         Gdip_DeleteGraphics(G2)
      If pPath
         Gdip_DeletePath(pPath)
      If invertPath
         Gdip_DeletePath(invertPath)

      If (previewMode=1)
      {
         addJournalEntry("Failed to create gradient bitmap: drawFillSelGradient(). No live preview possible.")
      } Else
      {
         showTOOLtip("Failed to create gradient bitmap: drawFillSelGradient(). Tool cannot be applied.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
      Return "fail"
   }

   If (FillAreaApplyColorFX=1 && FillAreaColorMode>4)
      applyPersonalizedColorsBMP(gradientsBMP, 0, 0, FillAreaApplyColorFX)

   If (thisObjBlurAmount>0 && previewMode=0 && FillAreaRemBGR!=1)
   {
      croppedOBJblurBMP := carvePathFromBitmap(gradientsBMP, pPath, imgSelPx, imgSelPy, 0, 2, thisObjBlurAmount, 0, !FillAreaInverted, ainvertus, 1)
      If (validBMP(croppedOBJblurBMP) && FillAreaRemBGR=1)
      {
         bruW := Gdip_BrushCreateSolid("0xffFFffFF")
         bruD := Gdip_BrushCreateSolid("0xff000000")
         If (FillAreaInverted=1)
         {
            If (FillAreaBlurAmount<0)
            {
               hG := Gdip_GraphicsFromImage(croppedOBJblurBMP)
               Gdip_FillPath(hG, bruW, pPath)
               Gdip_DeleteGraphics(hG)
            }
            QPV_SetBitmapAsAlphaChannel(whichBitmap, croppedOBJblurBMP, !ainvertus)
         } Else
         {
            krpBmp := trGdip_CreateBitmap(A_ThisFunc, oImgW, oImgH)
            hG := Gdip_GraphicsFromImage(krpBmp)
            Gdip_GraphicsClear(hG, "0xFFffFFff")
            Gdip_DrawImageFast(hG, croppedOBJblurBMP, imgSelPx, imgSelPy)
            If (FillAreaBlurAmount<0)
               Gdip_FillPath(hG, bruD, pPath)

            Gdip_DeleteGraphics(hG)
            QPV_SetBitmapAsAlphaChannel(whichBitmap, krpBmp, !ainvertus)
            krpBmp := trGdip_DisposeImage(krpBmp)
         }

         Gdip_DeleteBrush(bruW)
         Gdip_DeleteBrush(bruD)
         currIMGdetails.HasAlpha := 1
         bgrRM := 2
      }
      If validBMP(croppedOBJblurBMP)
         croppedOBJblurBMP := trGdip_DisposeImage(croppedOBJblurBMP)
   }

   Gdip_ResetClip(G2)
   ; modus := (FillAreaInverted=1) ? 4 : 0
   ; If (imgSelOutViewPort!=1 || previewMode!=1)
      ; Gdip_SetClipPath(G2, pPath, modus)

   opacityLevels := (FillAreaColorMode=1 && FillAreaOpacity<254) || (FillAreaColorMode>1 && (FillAreaOpacity<254 || FillArea2ndOpacity<254)) ? 1 : 0
   If (FillAreaCutGlass=1 && (FillAreaColorMode=1 && FillAreaOpacity<2) || (FillAreaColorMode>1 && (FillAreaOpacity<2 || FillArea2ndOpacity<2)))
      opacityLevels := 0
   Else If (FillAreaCutGlass=0 && thisObjBlurAmount!=0)
      opacityLevels := 1

   BlurAmount := blr[FillAreaGlassy]
   kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   msize := (kImgSelW + kImgSelH)//2
   rsize := (ImgSelW + ImgSelH)//2
   If (previewMode=1)
      BlurAmount := (Round(BlurAmount * (rsize / msize)))

   If (FillAreaRemBGR=1)
   {
      If (bgrRM!=2 && previewMode=0)
         Gdip_GraphicsClear(G2)
      Else If (previewMode=1)
         Gdip_FillPath(G2, GDIPbrushHatch, whichPath)
      ; ToolTip, % previewMode "=" pPath "=" g2 "`n" imgSelPx "=" imgSelPy "=" imgSelW "=" imgSelH "=" FillAreaShape "=" VPselRotation "=" rotateSelBoundsKeepRatio , , , 2
   } Else If (FillAreaGlassy>1 && FillAreaRemBGR=0 && opacityLevels=1 && BlurAmount>1 || thisBlendMode>1)
   {
      thisQuality := (previewMode=1) ? 5 : 3
      canBlur := (previewMode=1 && doImgEditLivePreview=1 || previewMode=0) ? 1 : 0
      ; MsgBox, % "a" canBlur "=" mustRemBackground "=" FillAreaGlassy "=" opacityLevels
      If (canBlur=1 && !testSelectOutsideImgEntirely(whichBitmap))
      {
         partu := (FillAreaInverted=1) ? "a" : getVPselIDs("saiz-vpos-xy") VPselRotation EllipseSelectMode imgSelW imgSelH
         If (currIMGdetails.HasAlpha=1 && previewMode=1 && thisBlendMode>1)
            bgrBMPu := getImgOriginalSelectedAreaEdit(2, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, 1)
         Else
            bgrBMPu := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0, imgSelW, imgSelH)

         trGdip_GetImageDimensions(bgrBMPu, zImgW, zImgH)
         sizeu := (imgSelW=zImgW && imgSelH=zImgH) ? 1 : 0
         doFX := ((FillAreaGlassy>1 && opacityLevels=1 || thisBlendMode>1) && BlurAmount>1) ? 1 : 0
         thisFXstate := "a" whichBitmap partu previewMode BlurAmount currentFileIndex getIDimage(currentFileIndex) oImgW oImgH currentUndoLevel undoLevelsRecorded currentSelUndoLevel FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevResizedVPimgW prevResizedVPimgH PasteInPlaceAdaptMode UserMemBMP ViewPortBMPcache getIDvpFX()
         If (validBMP(bgrBMPu) && (doFX=1 || sizeu!=1))
            glassBitmap := applyVPeffectsAdvOnBMP(bgrBMPu, previewMode, thisFXstate, imgSelW, imgSelH, BlurAmount, 0)
         Else If validBMP(bgrBMPu)
            glassBitmap := trGdip_CloneBitmap(A_ThisFunc, bgrBMPu)

         ; ToolTip, % sizeu "=" doFX "=" glassBitmap , , , 2
         If (thisBlendMode>1)
         {
            o_glass := trGdip_CloneBitmap(A_ThisFunc, glassBitmap)
            thisAlphaMode := (FillAreaGlassy=1) ? FillAreaCutGlass : !FillAreaCutGlass
            thisu := (FillAreaGlassy>1) ? 1 : 0
            QPV_BlendBitmaps(glassBitmap, gradientsBMP, thisBlendMode - 1, thisAlphaMode, BlendModesFlipped, 0, thisu)
         }

         If (FillAreaApplyColorFX=1 && FillAreaColorMode<5)
            applyPersonalizedColorsBMP(glassBitmap, 0, 0, FillAreaApplyColorFX)

         If (thisBlendMode=1)
         {
            G5 := Gdip_GraphicsFromImage(glassBitmap)
            If (userimgGammaCorrect=1)
               Gdip_SetCompositingQuality(G5, 2)

            tzGdip_DrawImage(G5, gradientsBMP)
            Gdip_DeleteGraphics(G5)
         } Else If (FillAreaGlassy>1 && FillAreaRemBGR=0 && (FillAreaOpacity<254 || FillArea2ndOpacity<254))
         {
            thisOpacity := (FillAreaColorMode>4) ? FillAreaOpacity/255 : 1
            zBitmap := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH)
            If validBMP(zBitmap)
            {
               G5 := Gdip_GraphicsFromImage(zBitmap)
               If (userimgGammaCorrect=1)
                  Gdip_SetCompositingQuality(G5, 2)

               tzGdip_DrawImage(G5, o_glass, 0, 0, imgSelW, imgSelH, , , , , thisOpacity/2)
               tzGdip_DrawImage(G5, glassBitmap, 0, 0, imgSelW, imgSelH)
               Gdip_DeleteGraphics(G5)
               glassBitmap := trGdip_DisposeImage(glassBitmap, 1)
               glassBitmap := zBitmap
            }
         }

         If (thisObjBlurAmount>0 && FillAreaRemBGR!=1 && FillAreaInverted=0)
         {
            tiu := (FillAreaBlurAmount>0 && (FillAreaCutGlass=1 || thisBlendMode>1 || FillAreaGlassy>1)) ? 1 : 0
            ; zPath := coreCreateFillAreaShape(0, 0, zImgW, zImgH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)
            croppedOBJblurBMP := carvePathFromBitmap(glassBitmap, pPath, imgSelPx, imgSelPy, 0, 2, thisObjBlurAmount, 0, !FillAreaInverted, tiu, 0)
            If validBMP(croppedOBJblurBMP)
               croppedOBJblurBMP := trGdip_DisposeImage(croppedOBJblurBMP)
            ; Gdip_DeletePath(zPath)
         }

         If validBMP(o_glass)
            o_glass := trGdip_DisposeImage(o_glass, 1)
         gradientsBMP := trGdip_DisposeImage(gradientsBMP, 1)
      }
   }

   If (userimgGammaCorrect=1 && previewMode=1 && thisBlendMode=1)
   {
      If (!validBMP(bgrBMPu) && FillAreaRemBGR=0)
         bgrBMPu := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0, imgSelW, imgSelH)

      If validBMP(bgrBMPu)
      {
         Gdip_ResetClip(G2)
         trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH)
         ; Gdip_SetClipPath(G2, pPath, modus)
      }
   }

   If (userimgGammaCorrect=1 && thisBlendMode=1)
      Gdip_SetCompositingQuality(G2, 2)

   If validBMP(bgrBMPu)
      bgrBMPu := trGdip_DisposeImage(bgrBMPu, 1)

   fBitmapA := validBMP(glassBitmap) ? glassBitmap : gradientsBMP
   If (thisObjBlurAmount>0 && FillAreaRemBGR!=1 && FillAreaInverted=1 && (FillAreaGlassy>1 || FillAreaBlendMode>1))
   {
      trGdip_GetImageDimensions(fBitmapA, zImgW, zImgH)
      tiu := (FillAreaBlurAmount<0) ? 1 : 0
      croppedOBJblurBMP := carvePathFromBitmap(fBitmapA, pPath, imgSelPx, imgSelPy, 0, 2, thisObjBlurAmount, 0, !FillAreaInverted, tiu, 0)
      If validBMP(croppedOBJblurBMP)
         croppedOBJblurBMP := trGdip_DisposeImage(croppedOBJblurBMP)
   } 

   If (FillAreaInverted=1 && thisObjBlurAmount<0 && FillAreaRemBGR!=1)
      liveCarvePathBitmap(pPath, fBitmapA, imgSelPx, imgSelPy, 1)
   Else If (FillAreaInverted=0 && thisObjBlurAmount<0 && FillAreaRemBGR!=1)
      liveCarvePathBitmap(pPath, fBitmapA, imgSelPx, imgSelPy, 0)
   Else If (thisObjBlurAmount=0 || FillAreaRemBGR=1)
      liveCarvePathBitmap(pPath, fBitmapA, imgSelPx, imgSelPy, FillAreaInverted)

   ; fnOutputDebug("crp=" validBMP(croppedOBJblurBMP) "=" croppedOBJblurBMP "|fba=" validBMP(fBitmapA) "=" fBitmapA "|gla=" validBMP(glassBitmap) "=" glassBitmap "|grd=" gradientsBMP "=" validBMP(gradientsBMP))
   If (alphaMaskingMode>1 && brushingMode=1)
   {
      trGdip_GetImageDimensions(userAlphaMaskBmpPainted, zImgW, zImgH)
      viewportDynamicOBJcoords.x := objSel.sx,  viewportDynamicOBJcoords.y := objSel.sy
      viewportDynamicOBJcoords.w := objSel.sw,  viewportDynamicOBJcoords.h := objSel.sH
      viewportDynamicOBJcoords.zl := (objSel.sw/zImgW + objSel.sh/zImgH)/2 + 0.0001
      trGdip_GetImageDimensions(fBitmapA, oImgW, oImgH)
      objSel.nw := oImgW,      objSel.nh := oImgH
      wBitmap := getRectFromBitmap(userAlphaMaskBmpPainted, objSel, 1)
      alphaMaskGray := validBMP(wBitmap) ? wBitmap : userAlphaMaskBmpPainted
      QPV_SetBitmapAsAlphaChannel(fBitmapA, alphaMaskGray, alphaMaskColorReversed, alphaMaskReplaceMode, alphaMaskBMPchannel)
      If validBMP(wBitmap)
         trGdip_DisposeImage(wBitmap, 1)
   } Else If (alphaMaskingMode>1)
   {
      moreStuff := (FillAreaGlassy>1 || thisBlendMode>1) ? "a" imgSelPx imgSelPy : ""
      partu := (FillAreaInverted=1) ? "a" : getVPselIDs("saiz-vpos-xy") VPselRotation EllipseSelectMode imgSelW imgSelH
      thisIDu := "a" previewMode FillAreaRemBGR FillAreaInverted userimgGammaCorrect FillAreaGlassy thisBlendMode FillAreaColor FillAreaColorMode FillArea2ndColor FillAreaOpacity FillArea2ndOpacity FillAreaGradientWrapped FillAreaGradientAngle FillAreaGradientPosB FillAreaGradientPosA FillAreaColorReversed FillAreaGradientScale VPselRotation zoomLevel imgFxMode ForceNoColorMatrix FlipImgH FlipImgV getIDvpFX() tinyPrevAreaCoordX tinyPrevAreaCoordY BlendModesFlipped partu moreStuff FillAreaApplyColorFX PasteInPlaceHue PasteInPlaceSaturation PasteInPlaceLight PasteInPlaceGamma clrGradientOffX clrGradientOffY undoLevelsRecorded currentUndoLevel useGdiBitmap() getAlphaMaskIDu() prevDestPosX prevDestPosY thisObjBlurAmount userUIshapeCavity innerSelectionCavityX innerSelectionCavityY FillAreaShape
      If (previewMode=1)
         realtimePasteInPlaceAlphaMasker(previewMode, fBitmapA, thisIDu, newBitmap, objSel, 0, 0, 0)
      Else
         realtimePasteInPlaceAlphaMasker(previewMode, fBitmapA, thisIDu, newBitmap, 0, 0, offW, offH)

      If validBMP(newBitmap)
      {
         fBitmapA := trGdip_DisposeImage(fBitmapA, 1)
         fBitmapA := newBitmap
      }
   }

   thisOpacity := (FillAreaColorMode>4) ? FillAreaOpacity/255 : 1
   If (FillAreaInverted=1 && thisObjBlurAmount>1 && FillAreaBlurAmount>0)
      Gdip_ResetClip(G2)

   ; ToolTip, % "g2=" g2 " bmp="  fBitmapA " g=" gradientsBMP " o=" thisOpacity " p=" pPath , , , 2
   ; fnOutputDebug("crp=" validBMP(croppedOBJblurBMP) "=" croppedOBJblurBMP "|fba=" validBMP(fBitmapA) "=" fBitmapA "|gla=" validBMP(glassBitmap) "=" glassBitmap "|grd=" gradientsBMP "=" validBMP(gradientsBMP))
   rz := trGdip_DrawImage(A_ThisFunc, G2, fBitmapA, imgSelPx, imgSelPy, imgSelW, imgSelH, , , , , thisOpacity)
   If (userimgGammaCorrect=1)
      Gdip_SetCompositingQuality(G2, 1)

   If (previewMode!=1)
      Gdip_DeleteGraphics(G2)

   Gdip_ResetClip(G2)
   trGdip_DisposeImage(fBitmapA, 1)
   Gdip_DeletePath(pPath)
   Gdip_DeletePath(invertPath)
   If validBMP(glassBitmap)
      trGdip_DisposeImage(glassBitmap, 1)
   If (FillAreaDoContour=1 && previewMode=1)
      coreDrawLinesStuffTool("shapes")
   Return rz
}

weighTwoValues(A, B, w) {
    return A*w + B*(1-w)
}

flipVars(ByRef a, ByRef b) {
   tempus := a,   a := b,   b := tempus
}

swapVars(ByRef a, ByRef b) {
   tempus := a,   a := b,   b := tempus
}

makeRGBAcolor(clr, opacity) {
    Return Format("{1:#x}", opacity) clr
}

drawFillSelGradient(imgSelW, imgSelH, previewMode, offX, offY, offW, offH, linearu:=1, zX:=0, zY:=0, bgrBrush:=0) {
    Static prevBMPu, prevState
    If (imgSelW="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisu := (FillAreaInverted=1) ? 0 : "a" getVPselIDs("saiz-vpos") VPselRotation
    thisState := "a" previewMode thisu FillAreaInverted userimgGammaCorrect FillAreaColor FillAreaColorMode FillArea2ndColor FillAreaOpacity FillArea2ndOpacity FillAreaGradientWrapped FillAreaGradientAngle FillAreaGradientPosB FillAreaGradientPosA FillAreaColorReversed FillAreaGradientScale tinyPrevAreaCoordX tinyPrevAreaCoordY clrGradientOffX clrGradientOffY prevDestPosX prevDestPosY zoomLevel FillAreaWelcomePattern clrGradientCoffX clrGradientCoffY linearu bgrBrush
    ; ToolTip, % thisState , , , 2
    If (thisState=prevState && validBMP(prevBMPu))
       Return trGdip_CloneBitmap(A_ThisFunc, prevBMPu)

    ; ToolTip, % offX "=" offY "=" offW "=" offH "=" imgselW "=" imgSelH , , , 2
    prevState := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH)
    If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
       Return

    fnOutputDebug("redraw: " A_ThisFunc)
    ; prepare the brush colors
    thisColorA := makeRGBAcolor(FillAreaColor, FillAreaOpacity)
    thisColorB := makeRGBAcolor(FillArea2ndColor, FillArea2ndOpacity)
    thisClrA := FillAreaColor
    thisClrB := FillArea2ndColor
    If (FillAreaColorReversed=1 && isInRange(FillAreaColorMode, 2, 4))
    {
       flipVars(thisColorA, thisColorB)
       flipVars(thisClrA, thisClrB)
    }

    imgSelPx := imgSelPy := 0
    imgSelPx := imgSelPx + zX
    imgSelPy := imgSelPy + zY
    angelu := (FillAreaGradientAngle>0) ? FillAreaGradientAngle : 360 + FillAreaGradientAngle
    If (FillAreaColorMode=1)
    {
       ; solid color
       Brush := Gdip_BrushCreateSolid(thisColorA)
    } Else If (FillAreaColorMode=2)
    {
       ; linear gradient
       brImgSelW := Round(ImgSelW*(FillAreaGradientScale/100))
       brImgSelH := Round(ImgSelH*(FillAreaGradientScale/100))
       brimgSelPx := imgSelPx - (brImgSelW - imgSelW)//2
       brimgSelPy := imgSelPy - (brImgSelH - imgSelH)//2
       cX := Round(brImgSelW * clrGradientOffX)
       cY := Round(brImgSelH * clrGradientOffY)
       Brush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + cX, brimgSelPy + cY, brimgSelW, brimgSelH, thisColorA, thisColorB, 1, clampInRange(FillAreaGradientWrapped - 1, 0, 3, 1))
       ; ToolTip, % brush "|" brImgSelW "|" brImgSelH "|" brimgSelPx "|" brimgSelPy "|" cX "|" cY "|" ImgSelW "|" ImgSelH "|" imgSelPx "|" imgSelPy "|" FillAreaGradientScale "|" clrGradientOffX "|" clrGradientOffY  , , , 2
       Gdip_RotateLinearGrBrushAtCenter(Brush, Mod(Round(angelu + VPselRotation), 360), 1)
       Gdip_SetLinearGrBrushGammaCorrection(Brush, linearu)
       Gdip_SetLinearGrBrushPresetBlend(Brush, [FillAreaGradientPosA/200, FillAreaGradientPosB/200], [thisColorA, thisColorB])
    } Else If (FillAreaColorMode=3 || FillAreaColorMode=4)
    {
       ; radial or box gradient
       cX := Round(imgSelW * (0.5 + clrGradientOffX + clrGradientCoffX * FillAreaGradientScale/100))
       cY := Round(imgSelH * (0.5 + clrGradientOffY + clrGradientCoffY * FillAreaGradientScale/100))
       brImgSelW := Round(ImgSelW*(FillAreaGradientScale/100))
       brImgSelH := Round(ImgSelH*(FillAreaGradientScale/100))
       brimgSelPx := Round(imgSelPx + imgSelW/2 * (1 + 2 * clrGradientOffX) - brImgSelW/2)
       brimgSelPy := Round(imgSelPy + imgSelH/2 * (1 + 2 * clrGradientOffY) - brImgSelH/2)
       cX := clampInRange(cX, brimgSelPx, brimgSelPx + brImgSelW)
       cY := clampInRange(cY, brimgSelPy, brimgSelPy + brImgSelH)
       whichFunc := (FillAreaColorMode=3) ? "Ellipse" : "Rectangle"
       grpPath := Gdip_CreatePath()
       Gdip_AddPath%whichFunc%(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
       Brush := Gdip_PathGradientCreateFromPath(grpPath)
       thisColorY := makeRGBAcolor("ffFFff", 255)
       thisColorX := makeRGBAcolor("000000", 255)
       Gdip_PathGradientSetCenterPoint(Brush, cX, cY)
       ; Gdip_SetLinearGrBrushGammaCorrection(Brush, linearu)
       Gdip_SetLinearGrBrushPresetBlend(Brush, [FillAreaGradientPosA/200, FillAreaGradientPosB/200], [thisColorY, thisColorX])
       Gdip_RotatePathGradientAtCenter(Brush, Mod(Round(angelu + VPselRotation), 360), 1)
       Gdip_PathGradientSetWrapMode(Brush, FillAreaGradientWrapped - 1)
       Gdip_DeletePath(grpPath)
       Brush2 := Gdip_BrushCreateSolid(thisColorX)
    } Else If (FillAreaColorMode=5)
    {
       ; welcome screens patterns
       iterations := FillAreaGradientScale
       modelu := FillAreaWelcomePattern - 1        ; pattern style
       moduz := FillAreaGradientPosA           ; style deviation
       sweepRand := FillAreaGradientPosB
       Brush := Gdip_BrushCreateSolid(thisColorB)
       w := (previewMode=1) ? imgSelW // 2 : imgSelW
       h := (previewMode=1) ? imgSelH // 2 : imgSelH
       zBitmap := coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, w, h, 5, 5, 0, previewMode, !previewMode)
       ; Gdip_DeleteBrush(bruA)
    } Else If (FillAreaColorMode=6)
    {
       ; texture mode
       If (!isNumber(tinyPrevAreaCoordX) || !isNumber(tinyPrevAreaCoordY))
          tinyPrevAreaCoordX := tinyPrevAreaCoordY := 2

       trGdip_GetImageDimensions(useGdiBitmap(), kklimgW, kklimgH)
       maxSizeX := kklimgW - tinyPrevAreaCoordX - 2
       maxSizeY := kklimgH - tinyPrevAreaCoordY - 2
       texSizeX := clampInRange(4 * FillAreaGradientPosA, 5, maxSizeX)
       texSizeY := texSizeX + Round(texSizeX * (FillAreaGradientPosB/250))
       texSizeY := clampInRange(texSizeY, 5, maxSizeY)
       texScaleX := texScaleY := (imgSelW/kklimgW) * (FillAreaGradientScale / 100)
       Brush := Gdip_CreateTextureBrush(useGdiBitmap(), clampInRange(FillAreaGradientWrapped - 1, 0, 3), tinyPrevAreaCoordX, tinyPrevAreaCoordY, texSizeX, texSizeY,, texScaleX, texScaleY, angelu , 0)
       ; ToolTip, % "l=" Round(texScaleX, 3) , , , 2
    }

    If StrLen(Brush)<2
    {
       trGdip_DisposeImage(pBitmap)
       Return
    }

    G2 := Gdip_GraphicsFromImage(pBitmap)
    Gdip_SetClipRect(G2, offX, offY, offW, offH)
    If ((FillAreaColorMode=3 || FillAreaColorMode=4) && Brush2)
    {
       Gdip_FillRectangle(G2, Brush2, 0, 0, imgSelW, imgSelH)
       Gdip_DeleteBrush(Brush2)
       ; ToolTip, % "yay" , , , 2
    }

    Gdip_FillRectangle(G2, Brush, 0, 0, imgSelW, imgSelH)
    If validBMP(zBitmap)
    {
       If (linearu=1)
          Gdip_SetCompositingQuality(G2, 2)
       trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0, imgSelW, imgSelH)
       trGdip_DisposeImage(zBitmap, 1)
    }

    Gdip_DeleteGraphics(G2)
    Gdip_DeleteBrush(Brush)
    If ((FillAreaColorMode=3 || FillAreaColorMode=4) && Brush2)
       QPV_ColorizeGrayImage(pBitmap, thisColorA, thisColorB, linearu)

    If (bgrBrush && (FillAreaColor<254 || FillArea2ndColor<254))
    {
       bgrStuff := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH)
       If validBMP(bgrStuff)
       {
          ; ToolTip, % bgrBrush "|" bgrStuff , , , 2
          zG := Gdip_GraphicsFromImage(bgrStuff)
          Gdip_FillRectangle(zG, bgrBrush, 0, 0, imgSelW, imgSelH)
          Gdip_DrawImageFast(zG, pBitmap)
          Gdip_DeleteGraphics(zG)
          trGdip_DisposeImage(pBitmap)
          pBitmap := bgrStuff
       }
    }

    prevState := (minimizeMemUsage=0) ? thisState : 0
    prevBMPu := (minimizeMemUsage=0) ? trGdip_CloneBitmap(A_ThisFunc, pBitmap) : 0
    Return pBitmap
}

carvePathFromBitmap(ByRef pBitmap, pPath, cX, cY, modus, safeWay:=0, blurLevel:=0, doBorder:=1, doDecalage:=1, invertus:=0, giveAlpha:=0) {
    If (safeWay=2)
    {
       trGdip_GetImageDimensions(pBitmap, imgW, imgH)
       If (imgW && imgH)
          newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")

       If !validBMP(newBitmap)
          Return

       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
       r2 := trGdip_GraphicsClear(A_ThisFunc, G3, "0xFFFFFFFF")

       zPath := Gdip_ClonePath(pPath)
       pMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(pMatrix, -cX , -cY)
       ; Gdip_TranslateMatrix(pMatrix, blurLevel , blurLevel)
       E := Gdip_TransformPath(zPath, pMatrix)

       BrushB := Gdip_BrushCreateSolid("0xFF000000")
       Gdip_FillPath(G3, BrushB, zPath)
       If (doDecalage=1)
       {
          kBitmap := trGdip_CloneBitmap(A_ThisFunc, newBitmap)
          r2 := trGdip_GraphicsClear(A_ThisFunc, G3, "0xFFffFFff")
          tzGdip_DrawImage(G3, kBitmap, blurLevel, blurLevel, imgW - blurLevel*2, imgH - blurLevel*2)
          trGdip_DisposeImage(kBitmap, 1)
       } Else If (doBorder=1)
       {
          Gdip_SetClipRect(G3, blurLevel, blurLevel, imgW - blurLevel*2, imgH - blurLevel*2, 4)
          Gdip_GraphicsClear(G3, "0xFFffFFff")
       }

       Gdip_DeleteGraphics(G3)
       If (blurLevel>1)
       {
          thisAmount := clampInRange(blurLevel, 1, 255)
          QPV_BoxBlurBitmap(newBitmap, thisAmount, thisAmount, 0)
          If (blurLevel>257)
          {
             thisAmount := clampInRange(blurLevel - 255, 1, 255)
             QPV_BoxBlurBitmap(newBitmap, thisAmount, thisAmount, 0)
          }

          If (doBorder=2 && doDecalage!=1 && blurLevel>2)
          {
             G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
             Gdip_FillPath(G3, BrushB, zPath)
             Gdip_DeleteGraphics(G3)
          }
       }

       r0 := QPV_SetBitmapAsAlphaChannel(pBitmap, newBitmap, invertus)
       Gdip_DeletePath(zPath)
       Gdip_DeleteBrush(BrushB)
       Gdip_DeleteMatrix(pMatrix)
       If (giveAlpha=1)
          Return newBitmap

       trGdip_DisposeImage(newBitmap, 1)
       ; ToolTip, % newBitmap "==" G3 "==" BrushB "`n" r2 "==" r3 "==" r0 , , , 2
       Return
    } Else safeWay := 0

    If (safeWay=1)
    {
       trGdip_GetImageDimensions(pBitmap, imgW, imgH)
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0x26200A")
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
    } Else
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)

    If (G3 && (validBMP(newBitmap) || safeWay!=1))
    {
       ; trGdip_GetImageDimensions(pBitmap, qImgW, qImgH)
       zPath := Gdip_ClonePath(pPath)
       pMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(pMatrix, -cX , -cY)
       E := Gdip_TransformPath(zPath, pMatrix)
       If (safeWay=1)
       {
          Gdip_SetCompositingQuality(G3, 4)
          Gdip_SetCompositingMode(G3, 1)
          Gdip_SetPixelOffsetMode(G3, 4)
          thinBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, pBitmap,,,,, "0x26200A")
          pEffect := Gdip_CreateEffect(5, -25, 0, 0)
          Gdip_BitmapApplyEffect(thinBMP, pEffect)

          QPV_PrepareAlphaChannelBlur(thinBMP, 1, 0)
          trGdip_DrawImage(A_ThisFunc, G3, thinBMP) ; ,,,,,,,,,10)
          modus := (modus=4) ? 0 : 4
       }

       Gdip_SetClipPath(G3, zPath, modus)
       If (safeWay!=1)
          r1 := trGdip_GraphicsClear(A_ThisFunc, G3)

       r2 := trGdip_DrawImage(A_ThisFunc, G3, pBitmap)
       Gdip_DeletePath(zPath)
       Gdip_DeleteMatrix(pMatrix)
       Gdip_DeleteGraphics(G3)
       If (safeWay=1)
       {
          trGdip_DisposeImage(thinBMP, 1)
          If !r2
          {
             trGdip_DisposeImage(pBitmap, 1)
             pBitmap := newBitmap
          } Else Return "Fail"
       }
    }

    If (!G3 || r1="fail")
       Return "fail"
}

GraySelectedArea() {
   EraseOrInvertOrGraySelectedArea("desaturate", A_ThisFunc)
}

InvertSelectedArea() {
   If (viewportQPVimage.imgHandle)
      HugeImagesFlipHVinvert("i")
   Else
      EraseOrInvertOrGraySelectedArea("invert", A_ThisFunc)
}

EraseSelectedArea() {
   EraseOrInvertOrGraySelectedArea("erase", A_ThisFunc)
}

FlipSelectedAreaH() {
   If (viewportQPVimage.imgHandle)
      HugeImagesFlipHVinvert("h")
   Else
      EraseOrInvertOrGraySelectedArea("flip-h", A_ThisFunc)
}

FlipSelectedAreaV() {
   If (viewportQPVimage.imgHandle)
      HugeImagesFlipHVinvert("v")
   Else
      EraseOrInvertOrGraySelectedArea("flip-v", A_ThisFunc)
}

FillBehindSelectedArea() {
   EraseOrInvertOrGraySelectedArea("behind", A_ThisFunc)
}

EraseOrInvertOrGraySelectedArea(actionu, funcu) {
    Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8}

    ha := currIMGdetails.HasAlpha
    If (editingSelectionNow!=1 && thumbsDisplaying!=1 && actionu!="erase")
       selectEntireImage("r")

    stopNow := (editingSelectionNow=1 && validBMP(gdiBitmap)) ? 0 : 1
    If (stopNow=1)
       Return 

    thisu := (actionu="behind") ? FillBehindInvert : EraseAreaInvert
    If (!testAllowSelInvert() && thisu=1 && isVarEqualTo(actionu, "behind", "erase", "desaturate"))
    {
       If (action="erase")
          fn := "PanelEraseSelectedArea"
       Else If (action="behind")
          fn := "PanelFillBehindBgrImage"
       Else If (action="desaturate")
          fn := "PanelDesatureSelectedArea"
       btn := !AnyWindowOpen ? "|&Reopen panel" : ""
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK" btn, 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, % fn, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    If isVarEqualTo(actionu, "invert", "behind", "desaturate")
       stopNow := mergeViewPortEffectsImgEditing(funcu)
    Else
       mergeViewPortRotationImgEditing()

    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    metaBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    trGdip_GetImageDimensions(metaBitmap, imgW, imgH)
    calcImgSelection2bmp(!LimitSelectBoundsImg, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    infoFriendly := InStr(actionu, "flip-") ? actionu : actionu " the colours in"
    G2 := trGdip_GraphicsFromImage(funcu, metaBitmap, 7, 4)
    If !G2
    {
       showTOOLtip("Failed to " infoFriendly " the selected area")
       SoundBeep , 300, 100
       trGdip_DisposeImage(metaBitmap)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    zBitmap := useGdiBitmap()
    If (actionu="behind")
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)
    Else
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)

    If (pPath="")
    {
       showTOOLtip("Failed to " infoFriendly " the selected area`nUnable to create selection path")
       trGdip_DisposeImage(metaBitmap)
       Gdip_DeleteGraphics(G2)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    ; ToolTip, % imgSelPx "|" imgSelPy "`n" imgSelW "|" imgSelH "`n" imgW "|" imgH , , , 2
    modus := (EraseAreaInvert=1 && (actionu="desaturate" || actionu="erase")) ? 4 : 0
    If (actionu!="behind")
    {
       Gdip_SetClipPath(G2, pPath, modus)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    }

    If (actionu="erase")
    {
       clrMatrix := (EraseAreaFader=1) ? 1 - (EraseAreaOpacity / 255) : 0
    } Else If (actionu="behind")
    {
       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G2, 2)

       thisOpacity := FillBehindOpacity/255
       clrMatrix := (FillBehindOpacity!=255) ? thisOpacity : 1
       If (clrMatrix<1)
          ha := 1

       thisColorA := makeRGBAcolor(FillBehindColor, FillBehindClrOpacity)
       thisBrush := Gdip_BrushCreateSolid(thisColorA)
       If (FillBehindInvert=1)
       {
          Gdip_ResetClip(G2)
          Gdip_SetClipPath(G2, pPath, 4)
          If (FillBehindOpacity>1)
             r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

          Gdip_FillRectangle(G2, thisBrush, 0, 0, imgW, imgH)
       } Else
       {
          Gdip_ResetClip(G2)
          If (FillBehindOpacity>1)
             Gdip_SetClipPath(G2, pPath, 0)

          r0 := trGdip_GraphicsClear(A_ThisFunc, G2, 0)
          Gdip_FillPath(G2, thisBrush, pPath)
       }

       Gdip_DeleteBrush(thisBrush)
    } Else If (actionu="invert")
    {
       clrMatrix := GenerateColorMatrix(6, 1, 0, 1)
    } Else If (actionu="desaturate")
    {
       thisBitsDepth := bitsOptions[DesaturateAreaLevels]
    } Else If InStr(actionu, "flip")
    {
       clrMatrix := 1
       thisW := imgSelW + imgSelPx*2
       thisH := imgSelH + imgSelPy*2
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
       If (actionu="flip-h")
       {
          Gdip_ScaleWorldTransform(G2, -1, 1)
          Gdip_TranslateWorldTransform(G2, -thisW, 0)
       } Else If (actionu="flip-v")
       {
          Gdip_ScaleWorldTransform(G2, 1, -1)
          Gdip_TranslateWorldTransform(G2, 0, -thisH)
       }
    }

    allowAlphaMasking := decideAlphaMaskingFeaseable(EraseAreaUseAlpha)
    If (actionu="desaturate")
    {
       gBitmap := (EraseAreaInvert=1) ? trGdip_CloneBitmap(funcu, zBitmap) : Gdip_CloneBmpPargbArea(funcu, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)
       If (allowAlphaMasking=1)
          xBitmap := trGdip_CloneBitmap(funcu, gBitmap)

       If (thisBitsDepth>1)
       {
          Gdip_BitmapSetColorDepth(gBitmap, thisBitsDepth, DesaturateAreaDither)
          Gdip_BitmapSetColorDepth(gBitmap, 32)
       }

       QPV_AdjustImageColors(gBitmap, DesaturateAreaAmount, DesaturateAreaInvert, DesaturateAreaChannel - 1, -65535, 1, DesaturateAreaBright, 0, DesaturateAreaContra, 0, 0, 0, DesaturateAreaHue, 0, 0, 0, 300, 0, 0, 0, 0, -1, -1, -1, -1, 1, 0, 0, 65535, 0, 0, 0)
       If (allowAlphaMasking=1)
       {
          realtimePasteInPlaceAlphaMasker(0, gBitmap, "lol", newBitmap, 0, 0, 0, 0, 0, xBitmap)
          If validBMP(newBitmap)
          {
             trGdip_DisposeImage(gBitmap, 1)
             gBitmap := newBitmap
          }
          trGdip_DisposeImage(xBitmap, 1)
       }
   
       Gdip_ResetClip(G2)
       modusa := (EraseAreaInvert=1) ? 4 : 0
       Gdip_SetClipPath(G2, pPath, modusa)
       ; r0 := trGdip_GraphicsClear(funcu, G2)
       If (EraseAreaInvert=1)
          r2 := trGdip_DrawImage(funcu, G2, gBitmap)
       Else
          r2 := trGdip_DrawImage(funcu, G2, gBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)

       Gdip_ResetClip(G2)
       trGdip_DisposeImage(gBitmap, 1)
       done := 1
    } Else If (allowAlphaMasking=1 && actionu="erase")
    {
       If (editingSelectionNow=1 && EraseAreaInvert=0)
          gBitmap := Gdip_CloneBmpPargbArea(funcu, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

       fBitmap := validBMP(gBitmap) ? gBitmap : zBitmap
       kBitmap := validBMP(clipBMP) ? clipBMP : fBitmap
       realtimePasteInPlaceAlphaMasker(0, kBitmap, "lol", newBitmap, 0, 0, 0, 0)
       If validBMP(clipBMP)
          trGdip_DisposeImage(clipBMP)

       If validBMP(newBitmap)
       {
          clrMatrix := (EraseAreaFader=1) ? 1 - (EraseAreaOpacity / 255) : 1
          If validBMP(gBitmap)
          {
             wBitmap := Gdip_CloneBmpPargbArea(funcu, zBitmap)
             G3 := trGdip_GraphicsFromImage(funcu, wBitmap)
             Gdip_SetClipRect(G3, imgSelPx, imgSelPy, imgSelW, imgSelH)
             r0 := trGdip_GraphicsClear(funcu, G3)
             Gdip_ResetClip(G3)
             r2 := trGdip_DrawImage(funcu, G3, newBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
             Gdip_DeleteGraphics(G3)
             ; ToolTip, % imgSelPx "," imgSelPy "," imgSelW "," imgSelH , , , 2
             r1 := dummyDrawImage(pEffect, clrMatrix, wBitmap, G2, funcu)
             trGdip_DisposeImage(wBitmap)
          } Else
          {
             r1 := dummyDrawImage(pEffect, clrMatrix, newBitmap, G2, funcu)
          }
          trGdip_DisposeImage(newBitmap)
          done := 1
       }
       trGdip_DisposeImage(gBitmap, 1)
    }

    If !done
       r1 := dummyDrawImage(pEffect, clrMatrix, zBitmap, G2, funcu)
    
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    Gdip_DeletePath(pPath)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeleteGraphics(G2)
    If (r0!="fail" && r1!="fail" && G2 && validBMP(metaBitmap))
    {
       If (ha=1)
          currIMGdetails.HasAlpha := ha
     
       isInside := (imgSelX1>=0 && imgSelY1>=0 && imgSelX2<=imgW && imgSelY2<=imgH) ? 1 : 0
       If (actionu="erase") || (InStr(actionu, "flip") && isInside=0)
          currIMGdetails.HasAlpha := 1

       wrapRecordUndoLevelNow(metaBitmap)
    } Else
    {
       showTOOLtip("Failed to " infoFriendly " the selected area")
       SoundBeep , 300, 100
       trGdip_DisposeImage(metaBitmap)
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    SetTimer, ResetImgLoadStatus, -250
    dummyTimerDelayiedImageDisplay(50)
} ; // EraseOrInvertOrGraySelectedArea()

QPV_rect2polar(pBitmap) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  trGdip_GetImageDimensions(pBitmap, ow, oh)
  kBitmap := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, ow*2, oh*2, 0, 5, -1, 1)
  If !validBMP(kBitmap)
     pBitmap := trGdip_CloneBitmap(A_ThisFunc, pBitmap)
  Else
     pBitmap := kBitmap

  If !validBMP(pBitmap)
     Return

  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h)
     Return

  newBitmap := trGdip_CreateBitmap(A_ThisFunc, w, h)
  If !validBMP(newBitmap)
     Return

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 1)
  E2 := Gdip_LockBits(newBitmap, 0, 0, w, h, stride, mScan, mData, 1)

  orbScale := 1
  cx := w/2 , cy := h/2
  If (!E1 && !E2)
     r := DllCall(whichMainDLL "\rect2polarIMG", "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "double", cx, "double", cy, "double", orbScale, "int")

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(newBitmap, mData)

  If (r>2)
  {
     pk := min(w, h)/2
     px := Round(cx - pk)
     py := Round(cy - pk)
     pw := ph := Round(pk*2)
     nnBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, newBitmap, px, py, pw, ph, 0, 0, 1, 0)
     ; ToolTip, % pw "==" nnBMP "===" orbScale , , , 2
     Gdip_ImageRotateFlip(nnBMP, 4)
  }

  trGdip_DisposeImage(newBitmap)
  trGdip_DisposeImage(pBitmap)
  Return nnBMP
}

QPV_DissolveBitmap(pBitmap, rx, ry) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  If !validBMP(pBitmap)
     Return

  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h)
     Return

  newBitmap := trGdip_CreateBitmap(A_ThisFunc, w, h)
  If !validBMP(newBitmap)
     Return

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 1)
  E2 := Gdip_LockBits(newBitmap, 0, 0, w, h, stride, mScan, mData, 1)
  If (!E1 && !E2)
     r := DllCall(whichMainDLL "\dissolveBitmap", "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "int", Round(rx + 2), "int", Round(ry + 2), "int")

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(newBitmap, mData)

  Return newBitmap
}

QPV_SymmetricaBitmap(pBitmap, rx, ry) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  If !validBMP(pBitmap)
     Return

  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h)
     Return

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 1)
  If (!E1 && !E2)
     r := DllCall(whichMainDLL "\symmetricaBitmap", "UPtr", iScan, "Int", w, "Int", h, "int", rx, "int", ry, "int")

  If !E1
     Gdip_UnlockBits(pBitmap, iData)

  ; ToolTip, % "r=" r "_" pBitmap "_" w "|" h , , , 2
  Return r
}

QPV_autoContrastBitmap(pBitmap, typeu, whichBitmap:=0, entireImg:=0) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  If !validBMP(pBitmap)
     Return

  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h)
     Return

  startZeit := A_TickCount
  If (validBMP(whichBitmap) && entireImg=1)
     mini := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, w//6, h//6, 1, 7)
  Else
     mini := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, w//6, h//6, 1, 7)

  If !validBMP(mini)
     Return

  trGdip_GetImageDimensions(mini, mw, mh)
  xCrop := mw//14,   yCrop := mh//14
  wCrop := mw - xCrop*2 + 1
  hCrop := mh - yCrop*2 + 1
  cropBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, mini, xCrop, yCrop, wCrop, hCrop)
  trGdip_DisposeImage(mini, 1)
  if (typeu!=2 && validBMP(cropBMP))
     QPV_ConvertToGrayscale(cropBMP, 5, 100, 0)

  trGdip_GetImageDimensions(cropBMP, mw, mh)
  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If (validBMP(cropBMP) && !E1)
     E3 := Gdip_LockBits(cropBMP, 0, 0, mw, mh, strideMini, amScan, amData, 1)
  Else
     E3 := -1

  QPV_PrepareHugeImgSelectionArea(0, 0, w, h, w, h, 0, 0, 1, 0)
  If (!E1 && !E3)
     r := DllCall(whichMainDLL "\autoContrastBitmap", "UPtr", iScan, "UPtr", amScan, "Int", w, "Int", h, "int", mw, "int", mh, "int", typeu, "int", userAutoColorIntensity, "int", userimgGammaCorrect, "int", Stride, "int", strideMini, "int", 32, "UPtr", 0, "int", 0)

  ; ToolTip, % "l== " r "; e1=" E1 "; e3=" E3 "==" mini , , , 2
  fnOutputDebug(A_ThisFunc "(): " A_TickCount - startZeit)
  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E3
     Gdip_UnlockBits(cropBMP, amData)
  trGdip_DisposeImage(cropBMP)
  Return r
}

SharpenSelectedArea() {
    If (editingSelectionNow!=1 && thumbsDisplaying!=1)
       selectEntireImage("r")

    stopNow := (editingSelectionNow=1 && validBMP(useGdiBitmap())) ? 0 : 1
    If (stopNow=1)
       Return 

    If (!testAllowSelInvert() && BlurAreaInverted=1)
    {
       btn := !AnyWindowOpen ? "|&Reopen panel" : ""
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK" btn, 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelSharpenImage, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!LimitSelectBoundsImg, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    metaBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    G2 := trGdip_GraphicsFromImage(funcu, metaBitmap, 7, 4)
    If !G2
    {
       If validBMP(metaBitmap)
          showTOOLtip("Failed to apply filter: sharpen.`nUnable to create GDI+ graphics object.")
       Else
          showTOOLtip("Failed to apply filter: sharpen.`nUnable to allocate new bitmap.")
       SoundBeep 300, 100
       trGdip_DisposeImage(metaBitmap)
       SetTimer, ResetImgLoadStatus, -100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    If !pPath
    {
       showTOOLtip("Failed to sharpen the selected area`nUnable to create selection path")
       SoundBeep , 300, 100
       trGdip_DisposeImage(metaBitmap)
       Gdip_DeleteGraphics(G2)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    modus := (BlurAreaInverted=1) ? 4 : 0
    If (BlurAreaInverted=1)
       zBitmap := trGdip_CloneBitmap(A_ThisFunc, metaBitmap)
    Else
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1)

    Gdip_SetClipPath(G2, pPath, modus)
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    If (ImageSharpenMode=3)
    {
       gk := trGdip_CloneBitmap(A_ThisFunc, zBitmap)
       gb := trGdip_CloneBitmap(A_ThisFunc, zBitmap)
       r0 := coreDetectEdgesSelectedArea(gk, 3)
       QPV_SharpenBitmap(gb, ImageSharpenAmount, ImageSharpenRadius, ImageSharpenMode)
       rr := QPV_SetBitmapAsAlphaChannel(gb, r0)
       ; ToolTip, % "rr=" rr , , , 2
       Gp := Gdip_GraphicsFromImage(zBitmap)
       tzGdip_DrawImageFast(Gp, gb, 0, 0)
       Gdip_DeleteGraphics(Gp)
       trGdip_DisposeImage(gk)
       trGdip_DisposeImage(r0)
       trGdip_DisposeImage(gb)
    } Else
       QPV_SharpenBitmap(zBitmap, ImageSharpenAmount, ImageSharpenRadius, ImageSharpenMode)

    If (BlurAreaInverted=1)
       r1 := tzGdip_DrawImage(G2, zBitmap)
    Else
       r1 := tzGdip_DrawImage(G2, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)

    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(zBitmap, 1)
    If (r1!="fail" && G2 && validBMP(metaBitmap))
    {
       wrapRecordUndoLevelNow(metaBitmap)
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       showTOOLtip("Failed to apply filter: sharpen.`nI aint so sharp to know why...")
       trGdip_DisposeImage(metaBitmap)
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    SetTimer, ResetImgLoadStatus, -250
}

SymmetrySelectedArea() {
    If (editingSelectionNow!=1 && thumbsDisplaying!=1)
       selectEntireImage("r")

    stopNow := (editingSelectionNow=1 && validBMP(useGdiBitmap())) ? 0 : 1
    If (stopNow=1)
       Return 

    If (!testAllowSelInvert && BlurAreaInverted=1)
    {
       btn := !AnyWindowOpen ? "|&Reopen panel" : ""
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK" btn, 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelSymmetricaImage, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    startZeit := A_TickCount
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!LimitSelectBoundsImg, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    metaBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    If validBMP(metaBitmap)
       G2 := trGdip_GraphicsFromImage(funcu, metaBitmap, 7, 4)

    If !G2
    {
       pfu := !validBMP(metaBitmap) ? "Failed to allocate the new bitmap." : "Failed to create the GDI+ graphics object."
       showTOOLtip("Failed to process the selected area: symmetry tool.`n" pfu)
       trGdip_DisposeImage(metaBitmap)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    If !pPath
    {
       showTOOLtip("Failed to process the selected area: symmetry tool`nUnable to create selection path")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Gdip_DeleteGraphics(G2)
       trGdip_DisposeImage(metaBitmap)
       Return
    }

    modus := (UserSymmetricaInvertArea=1) ? 4 : 0
    Gdip_SetClipPath(G2, pPath, modus)
    zBitmap := coreSymmetricaImageGenerator(trGdip_CloneBitmap(A_ThisFunc, metaBitmap))
    If !validBMP(zBitmap)
    {
       showTOOLtip("Failed to process the selected area: symmetry tool`nCoreSymmetricaImageGenerator() failed poetically.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Gdip_DeleteGraphics(G2)
       Gdip_DeletePath(pPath)
       trGdip_DisposeImage(metaBitmap)
       Return
    }

    trGdip_GetImageDimensions(zBitmap, zw, zh)
    trGdip_GetImageDimensions(metaBitmap, mw, mh)
    nx := Round(zw * (min(ImgSelX1, ImgSelX2)/mw))
    ny := Round(zh * (min(ImgSelY1, ImgSelY2)/mh))
    nw := Round(zw * (max(ImgSelX1, ImgSelX2)/mw)) - nx
    nh := Round(zh * (max(ImgSelY1, ImgSelY2)/mh)) - ny
 
    nmX := clampInRange(zw - nw, 1, zw)
    nmY := clampInRange(zh - nh, 1, zh)
    offX := Round(nmX * (UserSymmetricaSelOffX/200)) 
    offY := Round(nmY * (UserSymmetricaSelOffY/200))
    bx := (UserSymmetricaSelAligned=1 && UserSymmetricaInvertArea=0) ? offX : nx
    by := (UserSymmetricaSelAligned=1 && UserSymmetricaInvertArea=0) ? offY : ny
    If (UserSymmetricaInvertArea!=1)
    {
       kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, zBitmap, bx, by, nw, nh, 0, 0, 1)
       If validBMP(kBitmap)
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := kBitmap
       }
       ; fnOutputDebug(nx "==" ny "|" nw "==" nh)
    }
 
    hasApplied := 0
    applyBlurColorsFX(zBitmap)
    If (UserSymmetricaBlendMode>1)
    {
       bgrBMP := (UserSymmetricaInvertArea=1) ? trGdip_CloneBitmap(A_ThisFunc, metaBitmap) : Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, nx, ny, nw, nh, 0, 0, 1)
       zr := QPV_BlendBitmaps(bgrBMP, zBitmap, UserSymmetricaBlendMode - 1, BlendModesPreserveAlpha, BlendModesFlipped)
       If zr
       {
          hasApplied := 1
          trGdip_DisposeImage(zBitmap)
          zBitmap := bgrBMP
       } Else
          trGdip_DisposeImage(bgrBMP)
    }
 
    allowAlphaMasking := decideAlphaMaskingFeaseable(UserSymmetricaUseAlpha)
    If (allowAlphaMasking=1 && validBMP(zBitmap))
    {
       thisIDu := "ap" alphaMaskColorReversed alphaMaskingMode userAlphaMaskBmpPainted VPselRotation EllipseSelectMode imgSelPx imgSelPy imgSelW imgSelH UserSymmetricaInvertArea currentUndoLevel undoLevelsRecorded useGdiBitmap()
       realtimePasteInPlaceAlphaMasker(1, zBitmap, thisIDu, newBitmap, 0, 0, 0, 0)
       If validBMP(newBitmap)
       {
          hasApplied := 1
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := newBitmap
       }
    }
 
    thisOpacity := UserSymmetricaOpacity/255
    px := (UserSymmetricaInvertArea=1) ? 0 : imgSelPx
    py := (UserSymmetricaInvertArea=1) ? 0 : imgSelPy
    If (!hasApplied && thisOpacity>0.98)
       Gdip_GraphicsClear(G2)
 
    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, px, py,,,,,,, thisOpacity)
    ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
    trGdip_DisposeImage(zBitmap, 1)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    If (r1!="fail" && G2 && validBMP(metaBitmap))
    {
       wrapRecordUndoLevelNow(metaBitmap)
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       showTOOLtip("Failed to apply tool: symmetry generator.`nAn unexpected asymmetry occured.")
       trGdip_DisposeImage(metaBitmap)
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    SetTimer, ResetImgLoadStatus, -100
    fnOutputDebug(A_ThisFunc "(): " A_TickCount - startZeit)
}

doRectPolarTransformSelectedArea() {
    PolarRectSelectedArea(A_ThisFunc, 1)
}

doPolarRectTransformSelectedArea() {
    PolarRectSelectedArea(A_ThisFunc, 2)
}

PolarRectSelectedArea(funcu, actionu, extraMod:=0, entireImg:=0) {
    If (editingSelectionNow!=1 && thumbsDisplaying!=1)
       selectEntireImage("r")

    stopNow := (editingSelectionNow=1 && validBMP(useGdiBitmap())) ? 0 : 1
    If (stopNow=1)
       Return

    stopNow := mergeViewPortEffectsImgEditing(funcu)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    startZeit := A_TickCount
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!LimitSelectBoundsImg, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    newBitmap := trGdip_CloneBitmap(A_ThisFunc "<-" funcu, whichBitmap)
    G2 := trGdip_GraphicsFromImage(funcu, newBitmap, 7, 4)
    If !G2
    {
       showTOOLtip("Failed to process the selected area:`n" funcu "()")
       trGdip_DisposeImage(newBitmap)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY, 0)
    If !pPath
    {
       showTOOLtip("Failed to process the selected area`nUnable to create selection path`n" funcu "()")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Gdip_DeleteGraphics(G2)
       trGdip_DisposeImage(newBitmap)
       Return
    }

    setImageLoading()
    if (actionu=3 && entireImg=1)
       mainBMP := trGdip_CloneBitmap(funcu, newBitmap)

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, newBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1)
    Gdip_SetClipPath(G2, pPath)
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    If (actionu=1)
       gBitmap := QPV_rect2polar(zBitmap)
    Else If (actionu=2)
       gBitmap := QPV_polar2rect(zBitmap)
    Else If (actionu=3)
    {
        gBitmap := trGdip_CloneBitmap(A_ThisFunc, zBitmap)
        QPV_autoContrastBitmap(gBitmap, extraMod, mainBMP, entireImg)
        allowAlphaMasking := decideAlphaMaskingFeaseable(1)
        If (allowAlphaMasking=1 && EraseAreaUseAlpha=1 && validBMP(gBitmap))
        {
           alphaMaskGray := generateAlphaMaskBitmap(gBitmap, 0, 0, 0, 0, 0, 0, 0, 0)
           QPV_MergeBitmapsWithMask(gBitmap, zBitmap, alphaMaskGray, alphaMaskColorReversed)
           trGdip_DisposeImage(alphaMaskGray)
        }
        trGdip_DisposeImage(mainBMP)
    }

    trGdip_DisposeImage(zBitmap, 1)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, gBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(gBitmap, 1)
    If (r1!="fail" && G2)
    {
       wrapRecordUndoLevelNow(newBitmap)
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       showTOOLtip("Failed to process the image selected area`n" funcu "()")
       SoundBeep , 300, 100
       trGdip_DisposeImage(newBitmap)
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    SetTimer, ResetImgLoadStatus, -250
    ; fnOutputDebug(A_ThisFunc "(" actionu "," extraMod "): " A_TickCount - startZeit)
}

QPV_polar2rect(oBitmap) {
  Static modus := 0
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 
  }

  trGdip_GetImageDimensions(pBitmap, ow, oh)
  ; kBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, ow*2, oh*2, 0, 5, -1, 1)
  If !validBMP(kBitmap)
     pBitmap := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
  Else
     pBitmap := kBitmap

  If !validBMP(pBitmap)
  {
     addJournalEntry(A_ThisFunc "(): ERROR. Invalid bitmap")
     Return
  }

  ; Gdip_ImageRotateFlip(pBitmap, 3)
  trGdip_GetImageDimensions(pBitmap, w, h)
  If (!w || !h)
  {
     addJournalEntry(A_ThisFunc "(): ERROR. Invalid image dimensions. W=" w " | H=" h)
     Return
  }

  cx := w/2 , cy := h/2
  pk := min(w, h)/2
  px := Round(cx - pk)
  py := Round(cy - pk)
  pw := ph := Round(pk*2)

  GP := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
  If !GP
  {
     addJournalEntry(A_ThisFunc "(): ERROR. Unable to process the image. GDI+ graphics object was not created.")
     trGdip_DisposeImage(pBitmap, 1)
     Return
  }

  tzGdip_DrawImage(GP, oBitmap, px, py, pw, ph)
  Gdip_DeleteGraphics(GP)
  startZeit := A_TickCount
  newBitmap := trGdip_CreateBitmap(A_ThisFunc, w, h)
  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 1)
  E2 := Gdip_LockBits(newBitmap, 0, 0, w, h, stride, mScan, mData, 1)

  Static orbScale := 1
  If (!E1 && !E2)
     r := DllCall(whichMainDLL "\polar2rectIMG", "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "double", cx, "double", cy, "double", orbScale, "Int")
  Else
     addJournalEntry(A_ThisFunc "(): ERROR. Unable to process the image. Failed to lock the bitmap bits.")

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(newBitmap, mData)

  Gdip_ImageRotateFlip(newBitmap, 4)
  trGdip_DisposeImage(pBitmap)
  ; fnOutputDebug(A_TickCount - startZeit)
  Return newBitmap
}

dummyDrawImage(pEffect, clrMatrix, zBitmap, G2, funcu) {
   If !pEffect
      r1 := trGdip_DrawImage(funcu, G2, zBitmap, 0, 0,,,,,,, clrMatrix)
   Else
      r1 := trGdip_DrawImageFX(funcu, G2, zBitmap,,,,,,, clrMatrix, pEffect)
   Return r1
}

recordUndoLevelHugeImagesNow(imgSelPx, imgSelPy, imgSelW, imgSelH, invertArea:=0, doAsk:=1) {
   Static lastu := [], hFIFimgA
   If (imgSelPx="get-bmp")
   {
      Return lastu
   } Else If (imgSelPx="soft-kill")
   {
      lastu := []
      hFIFimgA := ""
      Return
   }

   If hFIFimgA
   {
      FreeImage_UnLoad(hFIFimgA)
      hFIFimgA := ""
      lastu := []
   }

   If (imgSelPx="kill" || preventUndoLevels=1)
      Return

   recordSelUndoLevelNow()
   bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
   If (viewportQPVimage.LoadedWith!="FIM" || !isVarEqualTo(bpp, 24, 32))
   {
      addJournalEntry("ERROR. Unable to record undo level. Image not loaded into memory as a FreeImage bitmap.")
      Return
   }

   If !isVarEqualTo(bpp, 24, 32)
   {
      addJournalEntry("ERROR. Unable to record undo level. Image is not a 24- or 32-bits bitmap.")
      Return
   }

   FreeImage_GetImageDimensions(viewportQPVimage.imgHandle, imgW, imgH)
   If (imgSelPx="entire-vp" || invertArea=1)
   {
      If (memoryUsageWarning(imgW, imgH, bpp, 2, 0, 0)=1 && doAsk=0)
         Return

      If memoryUsageWarning(imgW, imgH, bpp, 2)
         Return 2

      showTOOLtip("Recording undo level...", "nully")
      calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
      hFIFimgA := FreeImage_Copy(viewportQPVimage.imgHandle, 0, 0, imgW, imgH)
      If !hFIFimgA
         addJournalEntry("Failed to duplicate the main bitmap. Unable to record undo level.")
      If (invertArea=1)
         lastu := [hFIFimgA, "invertArea", imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, innerSelectionCavityX, innerSelectionCavityY]
      Else
         lastu := [hFIFimgA, "entire-vp", 0, 0, imgW, imgH, EllipseSelectMode, VPselRotation, innerSelectionCavityX, innerSelectionCavityY]
      ; ToolTip, % imgSelPx "|" invertArea , , , 2
      showTOOLtip("nully")
      Return hFIFimgA ? 1 : 0
   }

   flastu := !isNumber(imgSelPx) ? imgSelPx : "img-crop"
   If (flastu="img-crop")
   {
      If (memoryUsageWarning(imgSelW, imgSelH, bpp, 3, 0, 0)=1 && doAsk=0)
         Return

      If memoryUsageWarning(imgSelW, imgSelH, bpp, 3)
         Return 2

      showTOOLtip("Recording undo level...", "nully")
      y1 := imgH - imgSelH - imgSelPy
      hFIFimgA := FreeImage_Crop(viewportQPVimage.imgHandle, imgSelPx, y1, imgSelW, imgSelH)
      If !hFIFimgA
         addJournalEntry("Failed to extract subsection of the main bitmap. Unable to record undo level.")
      lastu := [hFIFimgA, flastu, imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, innerSelectionCavityX, innerSelectionCavityY]
      showTOOLtip("nully")
   } Else
   {
      ; undoable actions that do not rely on a bitmap, because they are bidirectional actions, eg. flip, invert
      calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
      If (editingSelectionNow=1)
         lastu := [0, flastu, imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, innerSelectionCavityX, innerSelectionCavityY]
      Else
         lastu := [0, flastu, 0, 0, imgW, imgH, EllipseSelectMode, VPselRotation, innerSelectionCavityX, innerSelectionCavityY]
   }

   Return hFIFimgA ? 1 : 0
}

undoRedoHugeImagesAct() {
   If (preventUndoLevels=1)
   {
      showTOOLtip("WARNING: Undo levels are not being recorded (user option).`nOne undo level is allowed with images over 536 mgpx.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
 
   setImageLoading()
   prevVPselRotation := VPselRotation
   prevrotateSelBoundsKeepRatio := rotateSelBoundsKeepRatio
   prevEllipseSelectMode := EllipseSelectMode
   previnnerSelectionCavityX := innerSelectionCavityX
   previnnerSelectionCavityY := innerSelectionCavityY
   prevImgSelX1 := imgSelX1, prevImgSelX2 := imgSelX2
   prevImgSelY1 := imgSelY1, prevImgSelY2 := imgSelY2

   obju := recordUndoLevelHugeImagesNow("get-bmp", 0, 0, 0)
   If isVarEqualTo(obju[2], "i", "h", "v")
   {
      EllipseSelectMode := obju[7],      VPselRotation := obju[8]
      innerSelectionCavityX := obju[9],  innerSelectionCavityY := obju[10]
      imgSelX1 := obju[3],            imgSelY1 := obju[4]
      imgSelX2 := imgSelX1 + obju[5], imgSelY2 := imgSelY1 + obju[6]
      FreeImage_GetImageDimensions(viewportQPVimage.imgHandle, imgW, imgH)
      defineRelativeSelCoords(imgW, imgH)
      HugeImagesFlipHVinvert(obju[2])
   } Else If ((obju[2]="img-crop" || obju[2]="invertArea") && obju[1])
   {
      inv := (obju[2]="invertArea") ? 1 : 0
      hFIFimgA := obju[1]
      hFIFimgX := viewportQPVimage.imgHandle
      bpp := FreeImage_GetBPP(hFIFimgX)
      Abpp := FreeImage_GetBPP(hFIFimgA)
      If (bpp!=Abpp)
      {
         showTOOLtip("WARNING: The recorded undo level has a different color depth than the viewport bitmap.`nImpossible to perform undo.")
         addJournalEntry("Error: undo level has a different color depth than the viewport bitmap: " Abpp " // " bpp)
         SoundBeep 300, 100
         ResetImgLoadStatus()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      EllipseSelectMode := obju[7],      VPselRotation := obju[8]
      innerSelectionCavityX := obju[9],  innerSelectionCavityY := obju[10]
      imgSelX1 := obju[3],            imgSelY1 := obju[4]
      imgSelX2 := imgSelX1 + obju[5], imgSelY2 := imgSelY1 + obju[6]
      FreeImage_GetImageDimensions(hFIFimgX, imgW, imgH)
      FreeImage_GetImageDimensions(hFIFimgA, mW, mH)
      defineRelativeSelCoords(imgW, imgH)
      if (inv!=1)
      {
         imgSelY1 := imgH - imgSelY1
         imgSelY2 := imgSelY1 - obju[6]
         flipVars(imgSelY1, imgSelY2)
      }

      X1 := (inv=1) ? 0    : obju[3],         Y1 := (inv=1) ? 0    : obju[4]
      X2 := (inv=1) ? imgW : X1 + obju[5],    Y2 := (inv=1) ? imgH : Y1 + obju[6]

      pBitsAll := FreeImage_GetBits(hFIFimgX)
      pBitsMini := FreeImage_GetBits(hFIFimgA)
      Stride := FreeImage_GetStride(hFIFimgX)
      mStride := FreeImage_GetStride(hFIFimgA)
      showTOOLtip("Performing the undo action")
      startZeit := A_TickCount
      r := DllCall(whichMainDLL "\UndoAiderSwapPixelRegions", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", Stride, "UPtr", pBitsMini, "int", mStride, "int", bpp, "int", X1, "int", Y1, "int", X2, "int", Y2)
      ; ToolTip, % A_TickCount - startZeit , , , 2
      If !r
      {
         showTOOLtip("Failed to perform the undo action")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      } Else
      {
         SoundBeep 900, 100
         currentImgModified := 1
         imgIndexEditing := currentFileIndex
         killQPVscreenImgSection()
         dummyTimerDelayiedImageDisplay(250)
         SetTimer, RemoveTooltip, -500
      }
   } Else If (obju[2]="entire-vp")
   {
      hFIFimgA := obju[1]
      If !hFIFimgA
      {
         showTOOLtip("WARNING: No recorded undo bitmap")
         SoundBeep 300, 100
         ResetImgLoadStatus()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      tFrames := frameu := 1
      imgPath := viewportQPVimage.ImgFile
      viewportQPVimage.DiscardImage()
      killQPVscreenImgSection()
      Sleep, 1
      viewportQPVimage.LoadImage(imgPath, frameu, 0, 1, [hFIFimgA, tFrames], 1)
      SoundBeep 900, 100
      RemoveTooltip()
      currentImgModified := 1
      imgIndexEditing := currentFileIndex
      If (editingSelectionNow=1)
      {
         VPselRotation := EllipseSelectMode := innerSelectionCavityX := innerSelectionCavityY := 0
         selectEntireImage("r")
      }
      recordUndoLevelHugeImagesNow("soft-kill", 0, 0, 0)
      dummyTimerDelayiedImageDisplay(500)
   } Else
   {
      showTOOLtip("No undoable action was recorded")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }

   SetTimer, ResetImgLoadStatus, -150
   VPselRotation := prevVPselRotation
   rotateSelBoundsKeepRatio := prevrotateSelBoundsKeepRatio
   EllipseSelectMode := prevEllipseSelectMode
   innerSelectionCavityX := previnnerSelectionCavityX
   innerSelectionCavityY := previnnerSelectionCavityY
   imgSelX1 := prevImgSelX1,   imgSelX2 := prevImgSelX2
   imgSelY1 := prevImgSelY1,   imgSelY2 := prevImgSelY2
   FreeImage_GetImageDimensions(viewportQPVimage.imgHandle, imgW, imgH)
   defineRelativeSelCoords(imgW, imgH)
   dummyRefreshImgSelectionWindow()
}

HugeImagesFlipHVinvert(modus) {
   If warnHugeImageNotFIM()
      Return

   If (editingSelectionNow=1)
   {
      If throwErrorSelectionOutsideBounds()
         Return
   }

   If (modus="i")
   {
      bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
      ; isOkay := (EllipseSelectMode>0 || VPselRotation!=0 || innerSelectionCavityX!=0 || innerSelectionCavityY!=0)
      If (bpp=24 || bpp=32)
      {
         HugeImagesApplyGenericFilters("invert colors")
         Return
      }

      If warnIncorrectColorDepthHugeImage(bpp, 1)
         Return
   }

   setImageLoading()
   f := (editingSelectionNow=1) ? "selected area " : "image "
   z := (modus="h") ? "horizontally" : "vertically"
   If (modus="i")
      showTOOLtip("Processing: invert " f "`nPlease wait...")
   Else
      showTOOLtip("Processing: flip " f z "`nPlease wait...")

   If (editingSelectionNow=1)
   {
      VPselRotation := EllipseSelectMode := 0
      vpWinClientSize(mainWidth, mainHeight)
      FreeImage_GetImageDimensions(viewportQPVimage.imgHandle, imgW, imgH)
      calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
      additionalHUDelements(3, mainWidth, mainHeight)
      hFIFimgA := FreeImage_CreateView(viewportQPVimage.imgHandle, Round(x1), Round(y1), Round(x2), Round(y2))
      If hFIFimgA
      {
         recordUndoLevelHugeImagesNow(modus, 0, 0, 0, 0, 0)
         If (modus="i")
            r := FreeImage_Invert(hFIFimgA)
         Else If (modus="h")
            r := FreeImage_FlipHorizontal(hFIFimgA)
         Else If (modus="v")
            r := FreeImage_FlipVertical(hFIFimgA)
         FreeImage_UnLoad(hFIFimgA)
         ; ToolTip, % x1 "|" y1 "`n" x2 "|" y2 "`n" imgSelW "|" imgSelH , , , 2
      }
   } Else
   {
      recordUndoLevelHugeImagesNow(modus, 0, 0, 0, 0, 0)
      If (modus="i")
         r := FreeImage_Invert(viewportQPVimage.imgHandle)
      Else If (modus="h")
         r := FreeImage_FlipHorizontal(viewportQPVimage.imgHandle)
      Else If (modus="v")
         r := FreeImage_FlipVertical(viewportQPVimage.imgHandle)
   }

   If (r=1)
   {
      SoundBeep 900, 100
      currentImgModified := 1
      imgIndexEditing := currentFileIndex
      killQPVscreenImgSection()
      viewportQPVimage.actions := Round(viewportQPVimage.actions + 1)
      dummyTimerDelayiedImageDisplay(250)
      SetTimer, RemoveTooltip, -500
   } Else
   {
      showTOOLtip("Failed to process the image...")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
   SetTimer, ResetImgLoadStatus, -250
}

getMemUsage() {
   obj := []
   sys := SysProcInfo_GetSystemMemoryStatus()
   sysu := GlobalMemoryStatusEx()
   appu := GetProcessMemoryUsage(QPVpid)
   obj.prcSys := Round(sys.CommitTotal / sys.CommitLimit * 100, 1)
   obj.appMem := max(appu.WorkingSetSize, appu.PrivateUsage)
   ; ToolTip, % fileSizeFriendly(appu.WorkingSetSize) "`n" fileSizeFriendly(appu.PrivateUsage) "`n" fileSizeFriendly(appu.OtherUsage), , , 2
   obj.appPrcMem := Round(obj.appMem / sysu.TotalPhys * 100, 1)
   obj.appMem := fileSizeFriendly(obj.appMem)
   obj.sysMem := fileSizeFriendly(sysu.TotalPhys)
   Return obj
}

memoryUsageWarning(givenW:=0, givenH:=0, bitsDepth:=0, opener:=0, bonusBuffer:=0, doAsk:=1) {
   isAll := (givenW && givenH && bitsDepth) ? 1 : 0
   If (viewportQPVimage.imgHandle && isAll=0)
   {
      FreeImage_GetImageDimensions(viewportQPVimage.imgHandle, kW, kH)
      oimgBPP := FreeImage_GetBPP(viewportQPVimage.imgHandle)
   }

   If (givenW)
      kW := givenW
   If (givenH)
      kH := givenH

   sys := SysProcInfo_GetSystemMemoryStatus()
   prcSys := Round(sys.CommitTotal / sys.CommitLimit * 100, 1)
   mamUsage := GetProcessMemoryUsage(QPVpid)
   systemMemInfo := GlobalMemoryStatusEx()
   imgBPP := Trimmer(StrReplace(oimgBPP, "-"))
   imgBPP := isNumber(imgBPP) ? imgBPP : 32
   If bitsDepth
      imgBPP := bitsDepth

   Stride := (imgBPP * kW) / 8
   bufferSize := Stride * kH
   thisMemoryLoad := Round(((max(mamUsage[1], mamUsage[8]) + 0)/systemMemInfo.TotalPhys)*100, 1)
   projectedMemoryLoad := Round(((max(mamUsage[1], mamUsage[8]) + bufferSize + bonusBuffer)/systemMemInfo.TotalPhys)*100, 1)
   diffu := projectedMemoryLoad - thisMemoryLoad
   If ((projectedMemoryLoad>95 || prcSys>90) && opener=2)
      Return 1
   Else If ((projectedMemoryLoad>105 || prcSys>99) && opener=3)
      Return 1
   Else If (projectedMemoryLoad>90 || prcSys>85 && diffu>5)
   {
      If (doAsk=0)
         Return 1

      If (opener=1)
      {
         msgResult := msgBoxWrapper(appTitle ": WARNING", "You are currently opening a very large image. QPV already uses " thisMemoryLoad "% from the available system memory. It is projected to peak at around " projectedMemoryLoad "% or more. This may lead to a substantial decrease in system performance and potential system crashes. Current system memory load is at " prcSys " %.`n`nDo you want to load the image entirely into the memory? If you choose to load it partially, the viewport zoom and pan functionalities will be very slow. All image editing functions will be disabled as well.", "&Load it entirely into memory|&Load it partially", 1, "exclamation")
         If !InStr(msgResult, "entirely")
            Return 1
      } Else
      {
         msgResult := msgBoxWrapper(appTitle ": WARNING", "You currently have opened a very large image and are trying to edit it. QPV already uses " thisMemoryLoad "% from the available system memory. It is projected to peak at around " projectedMemoryLoad "% or more. This may lead to a substantial decrease in system performance and potential system crashes. No undo levels will be recorded. Current system memory load is at " prcSys " %.`n`nDo you want to continue?", "&Continue|C&ancel", 1, "exclamation")
         If !InStr(msgResult, "Continue")
            Return 1
      }
   }

   Return 0
}

warnHugeImageNotFIM() {
   If (viewportQPVimage.LoadedWith!="FIM")
   {
      showTOOLtip("ERROR: The image seems to not be loaded through the FreeImage library.`nThe image cannot be processed.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }   
}

convertImageIntoHugeImage(newW, newH, quality) {
   Critical, on
   whichBitmap := useGdiBitmap()
   If !validBMP(whichBitmap)
   {
      showTOOLtip("ERROR: The image visible in the viewport seems to be lost.`nUnable to transfer it to FreeImage.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }   

   trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
   bitsDepth := (currIMGdetails.HasAlpha=1) ? 32 : 24
   If memoryUsageWarning(imgW, imgH, bitsDepth)
      Return

   hFIFimgA := ConvertPBITMAPtoFIM(whichBitmap, !currIMGdetails.HasAlpha)
   If !hFIFimgA
   {
      showTOOLtip("ERROR: Unable to convert the GDI+ image to a FreeImage object.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   terminateIMGediting()
   If validBMP(gdiBitmap)
      gdiBitmap := trGdip_DisposeImage(gdiBitmap)

   gdiBitmap := trGdip_CreateBitmap(A_ThisFunc, 200, 200)
   whichBitmap := useGdiBitmap()
   If validBMP(whichBitmap)
      Gdip_BitmapSetColorDepth(whichBitmap, "BW")

   imgPath := StrReplace(getIDimage(currentFileIndex), "||")
   viewportQPVimage.DiscardImage()
   killQPVscreenImgSection()
   currentImgModified := 1
   imgIndexEditing := currentFileIndex
   r := viewportQPVimage.LoadImage(imgPath, 1, 0, 1, [hFIFimgA, 1], 1)
   If r
   {
      HugeImagesCropResizeRotate(newW, newH, "resize", 0, 0, 0, 0, quality, 0)
   } Else
   {
      showTOOLtip("ERROR: Unable to convert the GDI+ image to a FreeImage object.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      FreeImage_UnLoad(hFIFimgA)
      dummyTimerDelayiedImageDisplay(250)
   }
}

HugeImagesConvertClrDepth(modus) {
   If warnHugeImageNotFIM()
      Return

   hFIFimgX := viewportQPVimage.imgHandle
   oimgBPP := FreeImage_GetBPP(hFIFimgX)
   imgBPP := Trimmer(StrReplace(oimgBPP, "-"))
   FreeImage_GetImageDimensions(hFIFimgX, kW, kH)
   depth := isVarEqualTo(modus, 8, 16, "gray", "bw") ? 24 : modus
   lzp := (modus="gray" || modus="BW") ? 8 : modus
   Stride := (lzp * kW) / 8 ; (bitsDepth=32) ? imgW * 4 : imgW * 3
   bufferSize := Stride * kH
   If (oimgBPP=lzp && !isVarEqualTo(modus, "gray", "bw", 8))
   {
      showTOOLtip("The image already has the selected color depth: " modus "-bits.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      ResetImgLoadStatus()
      Return
   }

   If memoryUsageWarning(kw, kh, depth, 0, bufferSize)
      Return

   setImageLoading()
   showTOOLtip("Converting image color depth, please wait...")
   discarded := 0
   If ((imgBPP!=24 && imgBPP!=32 && modus=8)
   || (imgBPP>32 && isVarEqualTo(modus, 8, 16, "bw", "gray")))
   {
      hFIFimgZ := FreeImage_ConvertTo(hFIFimgX, "24Bits")
      thisu := hFIFimgZ ? hFIFimgZ : hFIFimgX
      If hFIFimgZ
      {
         discarded := 1
         viewportQPVimage.DiscardImage()
      }
   } Else thisu := hFIFimgX

   If (modus=32)
      hFIFimgA := FreeImage_ConvertTo(hFIFimgX, "32Bits")
   Else If (modus=24)
      hFIFimgA := FreeImage_ConvertTo(hFIFimgX, "24Bits")
   Else If (modus=16)
      hFIFimgA := FreeImage_ConvertTo(thisu, "16Bits")
   Else If (modus="bw")
      hFIFimgA := FreeImage_Dither(thisu)
   Else If (modus="gray")
      hFIFimgA := FreeImage_ConvertToGreyscale(thisu)
   Else If (modus=8)
      hFIFimgA := FreeImage_ColorQuantize(thisu, 0)

   If (hFIFimgZ && hFIFimgA)
   {
      FreeImage_UnLoad(hFIFimgZ)
   } Else If hFIFimgZ
   {
      modus := 24
      hFIFimgA := hFIFimgZ
   }

   If hFIFimgA
   {
      showTOOLtip("Succesfully converted the color depth to " modus "-bit")
      oimgBPP := FreeImage_GetBPP(hFIFimgA)
      imgPath := viewportQPVimage.ImgFile
      ColorsType := FreeImage_GetColorType(hFIFimgA)
      imgType := FreeImage_GetImageType(hFIFimgA, 1)
      fileType := FreeImage_GetFileType(imgPath, 1)
      actions := Round(viewportQPVimage.actions)

      tFrames := frameu := 1
      viewportQPVimage.DiscardImage()
      killQPVscreenImgSection()
      Sleep, 1
      viewportQPVimage.LoadImage(imgPath, frameu, 0, 1, [hFIFimgA, tFrames], 1)
      SoundBeep 900, 100
      currIMGdetails.HasAlpha := InStr(ColorsType, "rgba") ? 1 : 0
      currIMGdetails.RawFormat := fileType " | " imgType
      currIMGdetails.PixelFormat := StrReplace(oimgBPP, "-", "+") "-" ColorsType
      viewportQPVimage.HasAlpha := InStr(ColorsType, "rgba") ? 1 : 0
      viewportQPVimage.RawFormat := fileType " | " imgType
      viewportQPVimage.PixelFormat := StrReplace(oimgBPP, "-", "+") "-" ColorsType
      viewportQPVimage.clrinfo := oimgBPP "-bit " ColorsType
      viewportQPVimage.actions := actions
      RemoveTooltip()
      recordUndoLevelHugeImagesNow("kill", 0, 0, 0)
      dummyTimerDelayiedImageDisplay(500)
   } Else
   {
      showTOOLtip("Failed to convert the color depth at " modus "-bit")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
   SetTimer, ResetImgLoadStatus, -200
}

warnIncorrectColorDepthHugeImage(bpp, qpvMode){
   If (qpvMode=1)
   {
      If (bpp!=24 && bpp!=32)
      {
         showTOOLtip("WARNING: This tool can be applied only on 24- or 32-bits images.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return 1
      }
   } Else
   {
      If (bpp>64)
      {
         showTOOLtip("WARNING: This tool can be applied only on images with`na color depths equal to or lower than 64-bits.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return 1
      }
   }
}

HugeImagesApplyAutoColors() {
      If warnHugeImageNotFIM()
         Return

      If (editingSelectionNow=1)
      {
         If throwErrorSelectionOutsideBounds()
            Return "out-bounds"
      }

      hFIFimgX := viewportQPVimage.imgHandle
      bpp := FreeImage_GetBPP(hFIFimgX)
      If warnIncorrectColorDepthHugeImage(bpp, 1)
         Return

      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      mw := imgW//6,    mh := imgH//6
      If memoryUsageWarning(imgW//5, imgH//5, bpp)
         Return

      showTOOLtip("Applying auto-adjust image colors, please wait...")
      setImageLoading()
      obju := InitHugeImgSelPath(0, imgW, imgH)
      If validBMP(obju.alphaMaskGray)
      {
         EZ := Gdip_LockBits(obju.alphaMaskGray, 0, 0, obju.imgZelW, obju.imgZelH, mStride, mScan, mData, 3, "0x21808")
         If EZ
         {
            trGdip_DisposeImage(obju.alphaMaskGray)
            obju.alphaMaskGray := ""
         }
      }

      pBitsAll := FreeImage_GetBits(hFIFimgX)
      Stride := FreeImage_GetStride(hFIFimgX)
      hFIFimgA := FreeImage_Rescale(hFIFimgX, mw, mh, 0)
      If (userAutoColorAdjustAll=0 && editingSelectionNow=1 && testAllowSelInvert())
      {
         calcImgSelection2bmp(0, mw, mh, mw, mh, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, zX1, zY1, zX2, zY2, 0, 0, "a")
         hFIFimgD := FreeImage_Copy(hFIFimgA, zx1, zy1, zx2, zy2)
         ; fnOutputDebug(A_ThisFunc "(area): " mw "|" mh "//" zx1 "|" zy1 "//" zx2 "|" zy2)
         If hFIFimgD
         {
            FreeImage_GetImageDimensions(hFIFimgD, mw, mh)
            FreeImage_UnLoad(hFIFimgA)
            hFIFimgA := hFIFimgD
            ; fnOutputDebug(A_ThisFunc "(area after): " mw "|" mh)
         }
      }

      pBitsMini := FreeImage_GetBits(hFIFimgA)
      strideMini := FreeImage_GetStride(hFIFimgA)
      recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, 0, 0)
      QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.ImgSelW, obju.ImgSelH, EllipseSelectMode, VPselRotation, 0, 0, "a", "a", 1)
      If (userAutoColorAdjustMode=3)
      {
         r := DllCall(whichMainDLL "\autoContrastBitmap", "UPtr", pBitsAll, "UPtr", pBitsMini, "Int", imgW, "Int", imgH, "int", mw, "int", mh, "int", 1, "int", userAutoColorIntensity, "int", userimgGammaCorrect, "int", Stride, "int", strideMini, "int", bpp, "UPtr", mScan, "int", mStride)
         If r
            r := DllCall(whichMainDLL "\autoContrastBitmap", "UPtr", pBitsAll, "UPtr", pBitsMini, "Int", imgW, "Int", imgH, "int", mw, "int", mh, "int", 2, "int", userAutoColorIntensity, "int", userimgGammaCorrect, "int", Stride, "int", strideMini, "int", bpp, "UPtr", mScan, "int", mStride)
      } Else
         r := DllCall(whichMainDLL "\autoContrastBitmap", "UPtr", pBitsAll, "UPtr", pBitsMini, "Int", imgW, "Int", imgH, "int", mw, "int", mh, "int", userAutoColorAdjustMode, "int", userAutoColorIntensity, "int", userimgGammaCorrect, "int", Stride, "int", strideMini, "int", bpp, "UPtr", mScan, "int", mStride)

      FreeImage_UnLoad(hFIFimgA)
      DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
      If (editingSelectionNow=1 && validBMP(obju.alphaMaskGray))
      {
         trGdip_DisposeImage(obju.alphaMaskGray)
         Gdip_UnlockBits(obju.alphaMaskGray, mData)
      }

      If r 
      {
         killQPVscreenImgSection()
         currentImgModified := 1
         imgIndexEditing := currentFileIndex
         viewportQPVimage.actions := Round(viewportQPVimage.actions + 1)
         dummyTimerDelayiedImageDisplay(500)
         SoundBeep, 900, 100
         RemoveTooltip()
      } Else
      {
         recordUndoLevelHugeImagesNow("kill", 0, 0, 0)
         showTOOLtip("ERROR: Failed to auto-adjust the image colors")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
      ResetImgLoadStatus()
}

HugeImagesApplyInsertText() {
      If warnHugeImageNotFIM()
         Return

      If (editingSelectionNow=1)
      {
         If throwErrorSelectionOutsideBounds()
            Return "out-bounds"
      }

      hFIFimgX := viewportQPVimage.imgHandle
      bpp := FreeImage_GetBPP(hFIFimgX)
      If warnIncorrectColorDepthHugeImage(bpp, 1)
         Return

      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      showTOOLtip("Applying insert text, please wait...")
      setImageLoading()
      ; obju := InitHugeImgSelPath(0, imgW, imgH)
      pBitsAll := FreeImage_GetBits(hFIFimgX)
      Stride := FreeImage_GetStride(hFIFimgX)
      imgSelH := max(imgSelY2, imgSelY1) - min(imgSelY2, imgSelY1)
      imgSelW := max(imgSelX2, imgSelX1) - min(imgSelX2, imgSelX1)
      tobju := coreInsertTextHugeImages(UserTextArea, ImgSelW, ImgSelH)
      If IsObject(tobju)
      {
         hFIFimgA   := tobju[1]
         minedX     := tobju[2],    minedY := tobju[3]
         mW         := tobju[4],    mH := tobju[5]
         If (TextInAreaVerticalia=1)
            hFIFimgW := FreeImage_Rotate(hFIFimgA, -90)

         If hFIFimgW
         {
            FreeImage_UnLoad(hFIFimgA)
            hFIFimgA := hFIFimgW
            FreeImage_GetImageDimensions(hFIFimgA, nImgW, nImgH)
            If (nImgW>imgSelW || nImgH>imgSelH)
            {
               calcIMGdimensions(nImgW, nImgH, imgSelW, imgSelH, zbw, zbh)
               hFIFimgW := FreeImage_Rescale(hFIFimgA, zbw, zbh)
               If hFIFimgW
               {
                  FreeImage_UnLoad(hFIFimgA)
                  hFIFimgA := hFIFimgW
               }
            }
         } Else If (TextInAreaVerticalia=1)
            addJournalEntry(A_ThisFunc "(): ERROR. Failed to rotate text bitmap to 90 degrees.")

         ; fnOutputDebug("0: " imgSelX1 "|" imgSelY1 "|" imgSelX2 "|" imgSelY2 "||" imgSelW "|" imgSelH)
         ; fnOutputDebug("A: " minedX "|" minedY "|" mw "|" mH)
         FreeImage_GetImageDimensions(hFIFimgA, nImgW, nImgH)
         o_imgSelX1 := imgSelX1,    o_imgSelY1 := imgSelY1
         o_imgSelX2 := imgSelX2,    o_imgSelY2 := imgSelY2
         imgSelPx := imgSelX1 := imgSelX1 ; + minedX
         imgSelPy := imgSelY1 := imgSelY1 ; + minedY
         If (TextInAreaAlign=3)
            imgSelPx := imgSelPx + imgSelW - nImgW
         Else If (TextInAreaAlign=2)
            imgSelPx := imgSelPx + Round(imgSelW/2 - nImgW/2)
     
         ; fnOutputDebug("B: " imgSelPx "|" imgSelPy "|" nImgW "|" nImgH "|||" mW "|" mH)
         If (TextInAreaValign=3)
            imgSelPy := clampInRange(imgSelY2 - nImgH, imgSelY1, imgSelY2)
         Else If (TextInAreaValign=2)
            imgSelPy := imgSelPy + Round(imgSelH/2 - nImgH/2)

         failure := 0
         imgSelX1 := imgSelPx
         imgSelY1 := imgSelPy
         imgSelX2 := imgSelPx + nImgW
         imgSelY2 := imgSelPy + nImgH
         If testSelectOutsideImgEntirely(useGdiBitmap())
            failure++

         If (imgSelY2>imgH && failure=0)
         {
            hFIFimgZ := FreeImage_Copy(hFIFimgA, 0, 0, nImgW, nImgH - (imgSelY2 - imgH))
            If hFIFimgZ
            {
               FreeImage_UnLoad(hFIFimgA)
               hFIFimgA := hFIFimgZ
               FreeImage_GetImageDimensions(hFIFimgA, nImgW, nImgH)
            } else failure++
         }

         If (imgSelX1<0 && failure=0)
         {
            hFIFimgZ := FreeImage_Copy(hFIFimgA, abs(imgSelX1), 0, nImgW, nImgH)
            If hFIFimgZ
            {
               FreeImage_UnLoad(hFIFimgA)
               hFIFimgA := hFIFimgZ
               FreeImage_GetImageDimensions(hFIFimgA, nImgW, nImgH)
            } else failure++
         }

         If (failure=0)
         {
            defineRelativeSelCoords(imgW, imgH)
            ; fnOutputDebug("C: " imgSelPx "|" imgSelPy "|" imgSelX2 "|" imgSelY2)
            pBits := FreeImage_GetBits(hFIFimgA)
            mStride := FreeImage_GetStride(hFIFimgA)
            mBpp := FreeImage_GetBPP(hFIFimgA)
            ; fnOutputDebug("D: " pBits "|" mStride "|" mBpp "|" hFIFimgA "|" nImgW "|" nImgH)
            ; r := DllCall(whichMainDLL "\DrawBitmapInPlace", "UPtr", pBits, "Int", nImgW, "Int", nImgH, "int", mStride, "int", mbpp, "int", 255, "int", userimgGammaCorrect, "int", 0, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha, "UPtr", 0, "int", "0xFF0011ff", "int", 32, "int", 1, "int", 1, "int", nImgW, "int", nImgH)
            obju := InitHugeImgSelPath(0, imgW, imgH)
            recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, 0, 0)
            orr := FillAreaShape
            FillAreaShape := 2
            FillAreaRectRoundness := 33
            VPselRotation := innerSelectionCavityX := innerSelectionCavityY := 0
            ; r := DllCall(whichMainDLL "\DrawBitmapInPlace", "UPtr", pBitsAll, "Int", ImgW, "Int", ImgH, "int", Stride, "int", bpp, "int", 255, "int", userimgGammaCorrect, "int", 0, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha, "UPtr", 0, "int", "0xFFee2200", "int", 32, "int", imgSelPx, "int", imgSelPy, "int", nImgW, "int", 10)
            ; r := DllCall(whichMainDLL "\DrawBitmapInPlace", "UPtr", pBitsAll, "Int", ImgW, "Int", ImgH, "int", Stride, "int", bpp, "int", 255, "int", userimgGammaCorrect, "int", 0, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha, "UPtr", 0, "int", "0xFFee2200", "int", 32, "int", imgSelPx, "int", imgSelPy + nImgH - 10, "int", nImgW, "int", 10)
            shapeu := (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1 && TextInAreaRoundBoxBgr=1) ? 3 : 0
            QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.ImgSelW, obju.ImgSelH, shapeu, 0, 0, 0, 0, 0, 1)
            showTOOLtip("Applying insert text, please wait...`nFinalizing")
            r := DllCall(whichMainDLL "\FillSelectArea", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", 0, "int", 255, "int", 0, "int", userimgGammaCorrect, "int", TextInAreaBlendMode - 1, "int", BlendModesFlipped, "UPtr", 0, "int", 0, "UPtr", pBits, "int", mStride, "int", mBpp, "int", 0, "int", 0, "int", BlendModesPreserveAlpha, "int", nImgW, "int", nImgH)
            FillAreaShape := orr
            ; fnOutputDebug(r "E: " obju.x1 "|" obju.y1 "|" obju.x2 - 1 "|" obju.y2 - 1 "|" obju.ImgSelW "|" obju.ImgSelH "|" obju.bImgSelW "|" obju.bImgSelH)
         } Else
         {
            showTOOLtip("WARNING: The text seems to be entirely out of the image boundaries. Nothing to draw.")
            SoundBeep 300, 100
            SetTimer, RemoveTooltip, % -msgDisplayTime
            ResetImgLoadStatus()
         }

         FreeImage_UnLoad(hFIFimgA)
         imgSelX1 := o_imgSelX1,    imgSelY1 := o_imgSelY1
         imgSelX2 := o_imgSelX2,    imgSelY2 := o_imgSelY2
         defineRelativeSelCoords(imgW, imgH)
      }

      DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
      If failure
         Return

      If r 
      {
         killQPVscreenImgSection()
         currentImgModified := 1
         imgIndexEditing := currentFileIndex
         viewportQPVimage.actions := Round(viewportQPVimage.actions + 1)
         dummyTimerDelayiedImageDisplay(500)
         SoundBeep, 900, 100
         RemoveTooltip()
      } Else
      {
         recordUndoLevelHugeImagesNow("kill", 0, 0, 0)
         showTOOLtip("ERROR: Failed to draw the text on the image")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
      ResetImgLoadStatus()
}

processGdipPathForDLL(pPath, tk, o_imgSelH, subdivide, ByRef PointsCount, ByRef PointsF) {
   pMatrix := Gdip_CreateMatrix()
   Gdip_ScaleMatrix(pMatrix, 1, -1)
   Gdip_TranslateMatrix(pMatrix, 0, -o_imgSelH - tk*2)
   E := Gdip_TransformPath(pPath, pMatrix)
   Gdip_DeleteMatrix(pMatrix)
   If (subdivide=1)
      Gdip_FlattenPath(pPath, 0.1)

   PointsCount := Gdip_GetPathPointsCount(pPath)
   VarSetCapacity(PointsF, 8 * (PointsCount + 1), 0)
   rr := DllCall("gdiplus\GdipGetPathPoints", "UPtr", pPath, "UPtr", &PointsF, "int*", PointsCount)
   Return rr
}

HugeImagesDrawLineShapes() {
      If warnHugeImageNotFIM()
         Return

      If (editingSelectionNow=1)
      {
         If throwErrorSelectionOutsideBounds()
            Return "out-bounds"
      }

      hFIFimgX := viewportQPVimage.imgHandle
      bpp := FreeImage_GetBPP(hFIFimgX)
      If warnIncorrectColorDepthHugeImage(bpp, 1)
         Return

      startOperation := A_TickCount
      showTOOLtip("Preparing to draw lines, please wait...")
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      setImageLoading()
      ; obju := InitHugeImgSelPath(0, imgW, imgH)
      pBitsAll := FreeImage_GetBits(hFIFimgX)
      Stride := FreeImage_GetStride(hFIFimgX)
      o_imgSelH := max(imgSelY2, imgSelY1) - min(imgSelY2, imgSelY1)
      o_imgSelW := max(imgSelX2, imgSelX1) - min(imgSelX2, imgSelX1)
      maxLength := min(o_imgSelW, o_imgSelH)//2
      thisThick := (DrawLineAreaContourThickness > maxLength/1.05) ? maxLength/1.05 : DrawLineAreaContourThickness
      thisThick := thisThick * (DrawLineAreaThickScale / 100)
      thisThick := Round(thisThick * 0.49)
      tk := thisThick + 4
      o_imgSelX1 := imgSelX1,    o_imgSelY1 := imgSelY1
      o_imgSelX2 := imgSelX2,    o_imgSelY2 := imgSelY2
      imgSelX1 := imgSelX1 - tk,    imgSelY1 := imgSelY1 - tk
      imgSelX2 := imgSelX2 + tk,    imgSelY2 := imgSelY2 + tk

      imgSelH := max(imgSelY2, imgSelY1) - min(imgSelY2, imgSelY1)
      imgSelW := max(imgSelX2, imgSelX1) - min(imgSelX2, imgSelX1)
      showTOOLtip("Drawing lines, please wait...`nStep 1/3")

      defineRelativeSelCoords(imgW, imgH)
      obju := InitHugeImgSelPath(0, imgW, imgH)
      zrr := recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH)
      If (zrr=2)
      {
         showTOOLtip("Draw lines: operation abandoned by user.")
         DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
         imgSelX1 := o_imgSelX1,      imgSelY1 := o_imgSelY1
         imgSelX2 := o_imgSelX2,      imgSelY2 := o_imgSelY2
         defineRelativeSelCoords(imgW, imgH)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         ResetImgLoadStatus()
         Return
      }

      Sleep, 50
      QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.ImgSelW, obju.ImgSelH, 5, 0, 0, 0, 0, 0, 1)
      rzq := DllCall(whichMainDLL "\prepareDrawLinesMask", "int", thisThick, "int", DrawLineAreaCapsStyle)
      rza := DllCall(whichMainDLL "\prepareDrawLinesCapsGridMask", "int", thisThick, "int", DrawLineAreaCapsStyle)
      If (rza=1 && rzq=1)
      {
         otherThick := Round(thisThick*0.34)
         diffThick := (imgSelY1<0) ? imgSelY1 : 0
         If (imgSelY2>imgH)
            diffThick := diffThick + (imgSelY2 - imgH)
         If (imgSelY2>imgH && imgSelY1<0)
            diffThick := thisThick + (imgSelY2 - thisThick - imgH)

         doClone := (innerSelectionCavityX>0 && innerSelectionCavityY>0 && FillAreaShape<7) ? 1 : 0
         pPath := coreCreateFillAreaShape(tk, tk, o_imgSelW, o_imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio, 2, 0)
         If pPath
         {
            If (doClone=1)
               clonedPath := Gdip_ClonePath(pPath)

            subdivide := (((bezierSplineCustomShape=1 || FillAreaCurveTension>1) && FillAreaShape=7) || FillAreaShape=2 || FillAreaShape=3) ? 1 : 0
            processGdipPathForDLL(pPath, tk, o_imgSelH, subdivide, PointsCount, PointsF)
            showTOOLtip("Drawing lines, please wait...`nStep 2/3")
            closed := (FillAreaShape=7) ? FillAreaClosedPath : 1
            rzb := DllCall(whichMainDLL "\drawLineAllSegmentsMask", "UPtr", &PointsF, "int", PointsCount, "int", thisThick, "int", closed, "int", DrawLineAreaCapsStyle, "int", 0, "int", 0)
            If (rzb=1 && DrawLineAreaDoubles=1)
            {
               DllCall(whichMainDLL "\prepareDrawLinesCapsGridMask", "int", otherThick, "int", DrawLineAreaCapsStyle)
               rzb := DllCall(whichMainDLL "\drawLineAllSegmentsMask", "UPtr", &PointsF, "int", PointsCount, "int", thisThick, "int", closed, "int", DrawLineAreaCapsStyle, "int", 1, "int", diffThick)
               DllCall(whichMainDLL "\prepareDrawLinesCapsGridMask", "int", thisThick, "int", DrawLineAreaCapsStyle)
            }

            Gdip_DeletePath(pPath)
            If (doClone=1 && rzb=1)
            {
               Gdip_ScalePathAtCenter(clonedPath, innerSelectionCavityX, innerSelectionCavityY)
               processGdipPathForDLL(clonedPath, tk, o_imgSelH, subdivide, PointsCount, PointsF)
               rzb := DllCall(whichMainDLL "\drawLineAllSegmentsMask", "UPtr", &PointsF, "int", PointsCount, "int", thisThick, "int", closed, "int", DrawLineAreaCapsStyle)
               If (rzb=1 && DrawLineAreaDoubles=1)
               {
                  DllCall(whichMainDLL "\prepareDrawLinesCapsGridMask", "int", otherThick, "int", DrawLineAreaCapsStyle)
                  rzb := DllCall(whichMainDLL "\drawLineAllSegmentsMask", "UPtr", &PointsF, "int", PointsCount, "int", thisThick, "int", closed, "int", DrawLineAreaCapsStyle, "int", 1, "int", diffThick)
               }
               Gdip_DeletePath(clonedPath)
            }
         }
         PointsF := ""
      }

      showTOOLtip("Drawing lines, please wait...`nStep 3/3")
      If (rzb=1)
         rzc := DllCall(whichMainDLL "\FillSelectArea", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", "0xff" DrawLineAreaColor, "int", DrawLineAreaOpacity, "int", 0, "int", userimgGammaCorrect, "int", DrawLineAreaBlendMode - 1, "int", BlendModesFlipped, "UPtr", 0, "int", 0, "UPtr", 0, "int", 0, "int", 0, "int", doBehind, "int", 0, "int", BlendModesPreserveAlpha)

      DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
      r := (rzc=1) ? 1 : 0
      fnOutputDebug("Draw lines finished in: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)))
      imgSelX1 := o_imgSelX1,      imgSelY1 := o_imgSelY1
      imgSelX2 := o_imgSelX2,      imgSelY2 := o_imgSelY2
      defineRelativeSelCoords(imgW, imgH)
      If r 
      {
         killQPVscreenImgSection()
         currentImgModified := 1
         imgIndexEditing := currentFileIndex
         viewportQPVimage.actions := Round(viewportQPVimage.actions + 1)
         dummyTimerDelayiedImageDisplay(500)
         SoundBeep, 900, 100
         RemoveTooltip()
      } Else
      {
         recordUndoLevelHugeImagesNow("kill", 0, 0, 0)
         If (rza!=1)
            showTOOLtip("ERROR: Failed to draw the text on the image.`nLines mask prepration failed.")
         Else If (rzb!=1)
            showTOOLtip("ERROR: Failed to draw the text on the image.`nAn error occurred drawing the line segments.")
         Else If (rzc!=1)
            showTOOLtip("ERROR: Failed to draw the text on the image.`nAn error occurred utilizing the lines mask to alter the main bitmap.")
         Else
            showTOOLtip("ERROR: Failed to draw the text on the image. Unknown cause[s].")

         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
      ResetImgLoadStatus()
}

terminatePasteInPlace() {
   corePasteInPlaceActNow("kill")
   coreFillSelectedArea("kill")
   FreeImage_UnLoad(oldSelectionArea[11])
   oldSelectionArea := []
}

HugeImagesApplyPasteInPlace() {
; to-do; to do; possible optimization: if PasteInPlaceCropDo=1 and / or PasteInPlaceEraseInitial=1 and / or PasteInPlaceApplyColorFX=1
; and PasteInPlaceCropSel=7 [vector polygonal shape] is used, do not recreate the clip mask by reinvoking 
; QPV_PrepareHugeImgSelectionArea() in-between operations; keep the cache
      If warnHugeImageNotFIM()
      {
         terminatePasteInPlace()
         Return
      }

      If throwErrorSelectionOutsideBounds()
      {
         terminatePasteInPlace()
         Return
      }

      bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
      If warnIncorrectColorDepthHugeImage(bpp, 1)
      {
         terminatePasteInPlace()
         Return
      }

      If (PasteInPlaceCropDo!=1)
      {
         EllipseSelectMode := VPselRotation := PasteInPlaceCropAngular := innerSelectionCavityX := innerSelectionCavityY := 0
         PasteInPlaceCropSel := 1
      }

      friendly := (PasteInPlaceToolMode=1) ? "transform selected area" : "paste in place"
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      vpWinClientSize(mainWidth, mainHeight)
      showTOOLtip("Applying " friendly ", please wait...")
      prevVPselRotation := VPselRotation
      prevrotateSelBoundsKeepRatio := rotateSelBoundsKeepRatio
      prevEllipseSelectMode := EllipseSelectMode
      previnnerSelectionCavityX := innerSelectionCavityX
      previnnerSelectionCavityY := innerSelectionCavityY

      x1 := clampInRange(prevImgSelX1, 0, imgW - 1)
      y1 := clampInRange(prevImgSelY1, 0, imgH - 1)
      x2 := clampInRange(prevImgSelX2, prevImgSelX1 + 1, imgW)
      y2 := clampInRange(prevImgSelY2, prevImgSelY1 + 1, imgH)
      w := x2 - x1
      h := y2 - y1
      kw := kh := 0
      If (PasteInPlaceToolMode!=1 && oldSelectionArea[11])
         FreeImage_GetImageDimensions(oldSelectionArea[11],  kw, kh)

      thisQuality := (PasteInPlaceQuality=1) ? 3 : 0
      allowOutside := testAllowOutsidePasteInPlace(imgW, imgH, oldSelectionArea[12], oldSelectionArea[13])
      xa := allowOutside[2], ya := allowOutside[3]
      xb := allowOutside[4], yb := allowOutside[5]
      dw := xb - xa,         dh := yb - ya
      Stride := (bpp * max(dW, w, kw)) / 8
      bufferSize := (PasteInPlaceOrientation>1) ? Stride * max(dH, h, kh) : 1
      If memoryUsageWarning(max(dw, w), max(dh, h), bpp, 0, bufferSize)
      {
         terminatePasteInPlace()
         Return
      }

      setImageLoading()
      If (PasteInPlaceToolMode!=1)
         FreeImage_GetImageDimensions(oldSelectionArea[11], w, h)

      dmpx := Round((dw * dh)/1000000, 3)
      smpx := Round((w * h)/1000000, 3)
      applyCLRfxAfter := (dmpx<smpx) ? 1 : 0
      If (PasteInPlaceApplyColorFX=1 && applyCLRfxAfter=0 && PasteInPlaceToolMode=0 && oldSelectionArea[11])
         HugeImagesApplyCLRfxPasteInPlace(oldSelectionArea[11], friendly)
      Else
         applyCLRfxAfter := 1

      deg := (PasteInPlaceOrientation=2) ? 270 : 180
      If (PasteInPlaceOrientation=4)
         deg := 90

      If (PasteInPlaceOrientation>1 && deg>0)
      {
         showTOOLtip("Applying " friendly ", please wait...`nRotating the image at " deg "°", 1)
         If (PasteInPlaceToolMode=1)
            thisImg := FreeImage_CreateView(viewportQPVimage.imgHandle, x1, y1, x2, y2)
         Else
            thisImg := oldSelectionArea[11]

         hFIFimgD := FreeImage_Rotate(thisImg, deg)
         If hFIFimgD
         {
            FreeImage_UnLoad(thisImg)
            If (PasteInPlaceToolMode!=1)
               oldSelectionArea[11] := hFIFimgD
         } Else
         {
            If (PasteInPlaceToolMode=1)
               FreeImage_UnLoad(thisImg)
            addJournalEntry(A_ThisFunc "(): Failed to rotate bitmap with FreeImage")
         }
      }

      showTOOLtip("Applying " friendly ", please wait...`nRescaling image object", 1)
      If (PasteInPlaceToolMode=1)
      {
         If (hFIFimgD && PasteInPlaceOrientation>1)
         {
            hFIFimgA := FreeImage_Rescale(hFIFimgD, dw, dh, thisQuality)
            FreeImage_UnLoad(hFIFimgD)
         } Else
            hFIFimgA := FreeImage_RescaleRect(viewportQPVimage.imgHandle, dw, dh, x1, y1, w, h, thisQuality)
      } Else
      {
         If oldSelectionArea[11]
         {
            hFIFimgA := FreeImage_Rescale(oldSelectionArea[11], dw, dh, thisQuality)
            FreeImage_UnLoad(oldSelectionArea[11])
         }
         oldSelectionArea[11] := ""
      }

      If !hFIFimgA
      {
         terminatePasteInPlace()
         ResetImgLoadStatus()
         showTOOLtip("ERROR: Failed to " friendly ":`nUnable to rescale image object.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If (PasteInPlaceApplyColorFX=1 && applyCLRfxAfter=1)
         r := HugeImagesApplyCLRfxPasteInPlace(hFIFimgA, friendly)
      Else
         r := 1

      If (PasteInPlaceOrientFlipY=1)
         FreeImage_FlipVertical(hFIFimgA)
      If (PasteInPlaceOrientFlipX=1)
         FreeImage_FlipHorizontal(hFIFimgA)

      If (PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1 && r)
      {
         EraseAreaInvert := EraseAreaFader := 0
         VPselRotation := oldSelectionArea[6]
         EllipseSelectMode := oldSelectionArea[5]
         rotateSelBoundsKeepRatio := oldSelectionArea[7]
         innerSelectionCavityX := oldSelectionArea[8]
         innerSelectionCavityY := oldSelectionArea[9]
         imgSelX1 := oldSelectionArea[1],            imgSelX2 := oldSelectionArea[3]
         imgSelY1 := oldSelectionArea[2],            imgSelY2 := oldSelectionArea[4]
         defineRelativeSelCoords(imgW, imgH)
         r := HugeImagesApplyGenericFilters("erase initially selected area", 0, 0, 0)
         DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
      }

      rotateSelBoundsKeepRatio := prevrotateSelBoundsKeepRatio
      innerSelectionCavityX    := previnnerSelectionCavityX
      innerSelectionCavityY    := previnnerSelectionCavityY
      imgSelX1 := xa,          imgSelY1 := ya
      imgSelX2 := xb,          imgSelY2 := yb
      defineRelativeSelCoords(imgW, imgH)
      If (PasteInPlaceCropSel=3)
         EllipseSelectMode := 1
      Else If (PasteInPlaceCropSel=7)
         EllipseSelectMode := 2
      Else 
         EllipseSelectMode := 0

      VPselRotation := (PasteInPlaceCropAngular>0) ? PasteInPlaceCropAngular : PasteInPlaceCropAngular + 360
      VPselRotation += prevVPselRotation
      If (VPselRotation=360)
         VPselRotation := 0

      r := HugeImagesApplyGenericFilters(friendly, 1, hFIFimgA, 0)
      terminatePasteInPlace()
      If (r!=1)
         FreeImage_UnLoad(hFIFimgA)

      If (!(PasteInPlaceCropSel=1 || PasteInPlaceCropSel=3) && PasteInPlaceCropDo=1)
         innerSelectionCavityX := innerSelectionCavityY := 0

      DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
}

HugeImagesApplyCLRfxPasteInPlace(hFIFimgA, friendly) {
   showTOOLtip("Applying " friendly ", please wait...`nPerforming color adjustments", 1)
   userImgAdjustNoClamp := (PasteInPlaceLight>1 && PasteInPlaceGamma<1) ? 1 : 0 
   pBitsAll := FreeImage_GetBits(hFIFimgA)
   Stride := FreeImage_GetStride(hFIFimgA)
   bpp := FreeImage_GetBPP(hFIFimgA)
   FreeImage_GetImageDimensions(hFIFimgA, tW, tH)
   QPV_PrepareHugeImgSelectionArea(0, 0, tW, tH, tW, tH, -1, 0, 0, 0, 0, 0)
   r := DllCall(whichMainDLL "\AdjustImageColorsPrecise", "UPtr", pBitsAll, "Int", tW, "Int", tH, "int", Stride, "int", bpp, "int", 255, "int", userImgAdjustInvertColors, "int", userImgAdjustAltSat, "int", Round(PasteInPlaceSaturation*655.35), "int", userImgAdjustAltBright, "int", Round(PasteInPlaceLight*257), "int", 0, "int", Round(PasteInPlaceGamma*655.30), "int", 0, "int", 0, "int", 0, "int", PasteInPlaceHue, "int", 0, "int", 0, "int", 0, "int", 300, "int", 0, "int", 0, "int", 0, "int", 0, "int", -1, "int", -1, "int", -1, "int", -1, "int", 0, "int", userimgGammaCorrect, "int", userImgAdjustNoClamp, "int", 65535, "int", 0, "int", 0, "UPtr", 0, "int", 1)
   Return r
}

HugeImagesApplyGenericFilters(modus, allowRecord:=1, hFIFimgExtern:=0, warnMem:=1) {
      If warnHugeImageNotFIM()
         Return

      If (editingSelectionNow=1)
      {
         If throwErrorSelectionOutsideBounds()
            Return
      }

      hFIFimgX := viewportQPVimage.imgHandle
      bpp := FreeImage_GetBPP(hFIFimgX)
      If warnIncorrectColorDepthHugeImage(bpp, 1)
         Return

      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      showTOOLtip("Applying " modus ", please wait...")
      setImageLoading()
      startOperation := A_TickCount
      thisRotation := (PasteInPlaceCropAngular>0) ? PasteInPlaceCropAngular : PasteInPlaceCropAngular + 360
      advancedMode := (InStr(modus, "fill") && !InStr(modus, "flood") || InStr(modus, "transform") || InStr(modus, "paste in place")) ? 1 : 0
      If (InStr(modus, "transform") || InStr(modus, "paste in place"))
         obju := InitHugeImgSelPath(1, imgW, imgH, PasteInPlaceCropSel, thisRotation + VPselRotation, rotateSelBoundsKeepRatio)
      Else If (InStr(modus, "fill") && !InStr(modus, "flood"))
         obju := InitHugeImgSelPath(1, imgW, imgH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)
      Else
         obju := InitHugeImgSelPath(0, imgW, imgH)

      If validBMP(obju.alphaMaskGray)
      {
         EZ := Gdip_LockBits(obju.alphaMaskGray, 0, 0, obju.imgZelW, obju.imgZelH, mStride, mScan, mData, 3, "0x21808")
         If EZ
         {
            trGdip_DisposeImage(obju.alphaMaskGray)
            obju.alphaMaskGray := ""
         }
      }

      gBpp := 32
      pBitsAll := FreeImage_GetBits(hFIFimgX)
      Stride := FreeImage_GetStride(hFIFimgX)
      If advancedMode
      {
         nBmpW := nBmpH := 0
         fillTool := InStr(modus, "fill") ? 1 : 0
         transformTool := (InStr(modus, "transform") || InStr(modus, "paste in place")) ? 1 : 0

         If (isInRange(FillAreaColorMode, 2, 4) && fillTool=1 && obju.imgZelW && obju.imgZelH) ; && FillAreaInverted=0 && !isImgSizeTooLarge(zW, zH))
         {
            showTOOLtip("Applying " modus "`nGenerating gradient bitmap, please wait", 1)
            zW := (FillAreaInverted=1) ? imgW : max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
            zH := (FillAreaInverted=1) ? imgH : max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
            mustUnlock := mustResize := 0
            If (max(zW, zH)>14500)
            {
               mustResize := 1
               calcIMGdimensions(zW, zH, 14500, 14500, ResizedW, ResizedH)
               ; fnOutputDebug(A_ThisFunc " small gradient bitmap")
            } Else
            {
               ResizedW := (FillAreaInverted=1) ? imgW : obju.imgSelW
               ResizedH := (FillAreaInverted=1) ? imgH : obju.imgSelH
               fnOutputDebug(A_ThisFunc " gradient bitmap size matches selection area dimensions: " ResizedW " | " ResizedH)
            }

            Strode := (32 * obju.ImgZelW) / 8
            bonusBuffer := (ResizedW=obju.imgZelW && ResizedH=obju.imgZelH) ? 0 : Strode * obju.ImgZelH
            If (FillAreaInverted=1)
               bonusBuffer := ((32 * imgW) / 8) * imgH

            If memoryUsageWarning(ResizedW, ResizedH, 32, 0, bonusBuffer)
            {
               DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
               If validBMP(obju.alphaMaskGray)
               {
                  Gdip_UnlockBits(obju.alphaMaskGray, mData)
                  trGdip_DisposeImage(obju.alphaMaskGray)
               }
               Return
            }

            gradientsBMP := drawFillSelGradient(ResizedW, ResizedH, 0, 0, 0, ResizedW, ResizedH, userimgGammaCorrect)
            azX := (imgSelX1<0) ? abs(ImgSelX1) : 0
            azY := (imgSelY1<0) ? abs(ImgSelY1) : 0
            sazY := (ImgSelY2>imgH) ? imgSelY2 - imgH : 0
            szW := (ImgSelX2>imgW) ? imgSelX2 - imgW : 0
            szH := (ImgSelY2>imgH) ? imgSelY2 - imgH : 0
            If ((szW || szH || azX || azY) && validBMP(gradientsBMP) && FillAreaInverted=0)
            {
               ; crop top/left out of bounds
               xf := ResizedW/zW,                 yf := ResizedH/zH
               zX := Floor(azX*xf),               zY := Floor(azY*yf)
               szX := Ceil(azX*xf) + 1,           szY := Ceil(azY*yf) + 1
               szW := Ceil(szW*xf) + 1,           szH := Ceil(szH*yf) + 1
               rw := clampInRange(ResizedW - szX - szW, 2, ResizedW)
               rh := clampInRange(ResizedH - szY - szH, 2, ResizedH)
               pZy := (imgSelY1<0) ? 0 : Floor(sazY*yf)
               If (imgSelY1<0 && imgSelY2>imgH)
                  pZy += abs(Round(imgSelY2 - imgH)*yf)
               ; ToolTip, % "l=" pZy  , , , 2
               ; Gux := Gdip_GraphicsFromImage(gradientsBMP)
               ; Gdip_DrawRectangle(Gux, pPen7, zX, pZy, rw, rh)
               ; Gdip_DeleteGraphics(Gux)
               kBitmap := trGdip_CloneBitmapArea(A_ThisFunc, gradientsBMP, zX, Round(pZy), rw, rh)
               ; fnOutputDebug(A_ThisFunc ": " zX "|" zY "||" szX "|" szY " | crop top/left bounds from gradient rw, rh=" rw "|" rh)
               If validBMP(kBitmap)
               {
                  trGdip_DisposeImage(gradientsBMP, 1)
                  gradientsBMP := kBitmap
                  ; fnOutputDebug(A_ThisFunc ": cropped top/left bounds from gradient YAY")
               }
            }

            If validBMP(gradientsBMP)
            {
               If (mustResize=1)
               {
                  ; fnOutputDebug(A_ThisFunc ": convert small gradient bitmap to FreeImage")
                  showTOOLtip("Applying " modus "`nRescaling gradient bitmap, please wait", 1)
                  Gdip_ImageRotateFlip(gradientsBMP, 6)
                  hFIFimgGradient := ConvertPBITMAPtoFIM(gradientsBMP)
                  gradientsBMP := trGdip_DisposeImage(gradientsBMP)
                  If hFIFimgGradient
                  {
                     ; fnOutputDebug(A_ThisFunc ": resizing gradient with FreeImage: " obju.imgZelW " | " obju.imgZelH)
                     If (FillAreaInverted=1)
                        hFIFimgRealGradient := FreeImage_Rescale(hFIFimgGradient, imgW, imgH, 3)
                     Else
                        hFIFimgRealGradient := FreeImage_Rescale(hFIFimgGradient, obju.imgZelW, obju.imgZelH, 3)

                     gScan := FreeImage_GetBits(hFIFimgRealGradient)
                     gStride := FreeImage_GetStride(hFIFimgRealGradient)
                     gBpp := FreeImage_GetBPP(hFIFimgRealGradient)
                     FreeImage_GetImageDimensions(hFIFimgRealGradient, nBmpW, nBmpH)
                     ; fnOutputDebug(A_ThisFunc ": freeimage resized gradient " nBmpW "||" nBmpH)
                     FreeImage_UnLoad(hFIFimgGradient)
                  }
               } Else
               {
                  trGdip_GetImageDimensions(gradientsBMP, nBmpW, nBmpH)
                  ; fnOutputDebug(A_ThisFunc ": locking gradient bits with gdi+ " ResizedW "||" ResizedH)
                  EZ := Gdip_LockBits(gradientsBMP, 0, 0, nBmpW, nBmpH, gStride, gScan, gData)
                  gBpp := 32
                  mustUnlock := 1
               }

               If (EZ || !hFIFimgGradient && mustResize=1)
               {
                  If gradientsBMP
                     trGdip_DisposeImage(gradientsBMP)
                  addJournalEntry(A_ThisFunc "(): Failed to lock the bits of the gradient bitmap.")
                  gradientsBMP := ""
               }
            } Else
               addJournalEntry(A_ThisFunc "(): Failed to generate the gradient bitmap.")
         } Else If (transformTool=1)
         {
            FreeImage_GetImageDimensions(hFIFimgExtern, tw, th)
            zxa := (imgSelX1<0) ? abs(ImgSelX1) : 0
            zya := (imgSelY1<0) ? abs(ImgSelY1) : 0
            zxb := (ImgSelX2>imgW) ? tw - (imgSelX2 - imgW) : tw
            zyb := (ImgSelY2>imgH) ? th - (imgSelY2 - imgH) : th
            ; wz := zxb - zxa,    hz := zyb - zya
            If (zxa || zya || zxb!=tw || zyb!=th)
            {
               ; crop top/left out of bounds
               hFIFimgZB := FreeImage_Copy(hFIFimgExtern, zxa, zya, zxb, zyb)
               FreeImage_UnLoad(hFIFimgExtern)
               hFIFimgExtern := hFIFimgZB
            }

            gScan := FreeImage_GetBits(hFIFimgExtern)
            gStride := FreeImage_GetStride(hFIFimgExtern)
            gBpp := FreeImage_GetBPP(hFIFimgExtern)
            FreeImage_GetImageDimensions(hFIFimgExtern, nBmpW, nBmpH)
            ; TulTip(A_ThisFunc, "|", zxa, zya, wz, hz, obju.imgZelW, obju.imgZelH)
         }

         If (imgSelY1<0 && FillAreaInverted=1 && fillTool=1)
         {
            ; I do not know why i have to do this adjustment for the fill tool only; too lazy to dig to understand it
            obju.Y1 -= abs(imgselY1)
            obju.Y2 -= abs(imgselY1)
         }

         newColor := "0xFF" FillAreaColor
         thisOpacity := (transformTool=1) ? clampInRange(PasteInPlaceOpacity, 0, 255) : FillAreaOpacity
         If (fillTool=1 && FillAreaColorMode>1)
            thisOpacity := 255
         opacityExtra := (transformTool=1 && PasteInPlaceOpacity>255) ? clampInRange(PasteInPlaceOpacity - 255, 0, 255) : 0 
         eraser := (!InStr(modus, "behind") && FillAreaRemBGR=1 && fillTool=1) ? -1 : 0
         blending := (fillTool=1) ? FillAreaBlendMode - 1 : PasteInPlaceBlendMode - 1
         doBehind := (fillTool=1) ? FillAreaDoBehind : 0
         thisInvert := (fillTool=1) ? FillAreaInverted : 0
         shapeu := (fillTool=1) ? 3 : EllipseSelectMode
         ; ToolTip, % thisOpacity "|" transformTool "|" opacityExtra , , , 2
         ; thisRotation := (PasteInPlaceCropAngular>0) ? PasteInPlaceCropAngular : PasteInPlaceCropAngular + 360
         thisRotation := VPselRotation ; (transformTool=1 && PasteInPlaceCropDo=1) ? thisRotation + VPselRotation : VPselRotation
         If (transformTool=1 && PasteInPlaceCropDo=1)
            shapeu := 4
         ; fnOutputDebug(A_ThisFunc ": " stride "|" pBitsAll "|" imgW "|" imgH "|" thisInvert "|" blending "|" eraser "|" doBehind "|" thisOpacity "|" newColor "|" gBpp "|" VPselRotation "|" EllipseSelectMode "`n" obju.imgZelW "|" obju.imgZelH "`n" tw "|" th "|" gStride)
         ; TulTip(1, " | ", obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.imgSelW, obju.imgSelH, EllipseSelectMode, VPselRotation, 0, thisInvert)
         ; t := validBMP(obju.alphaMaskGray)
         ; fnOutputDebug(thisRotation "|" A_ThisFunc ": " obju.x1 "|" obju.y1 "|" obju.x2 "|" obju.y2 "|" obju.imgSelW "|" obju.imgSelH)
         showTOOLtip("Applying " modus "`nProcessing main bitmap, please wait", 1)
         recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, thisInvert, 0)
         QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.imgSelW, obju.imgSelH, shapeu, thisRotation, 0, thisInvert, "a", "a", 1)
         thisKeepAlpha := (transformTool=1) ? BlendModesPreserveAlpha : FillAreaCutGlass
         r := DllCall(whichMainDLL "\FillSelectArea", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", newColor, "int", thisOpacity, "int", eraser, "int", userimgGammaCorrect, "int", blending, "int", BlendModesFlipped, "UPtr", mScan, "int", mStride, "UPtr", gScan, "int", gStride, "int", gBpp, "int", doBehind, "int", opacityExtra, "int", thisKeepAlpha, "int", nBmpW, "int", nBmpH)
         If hFIFimgRealGradient
            FreeImage_UnLoad(hFIFimgRealGradient)
         If (hFIFimgExtern && r=1)
            FreeImage_UnLoad(hFIFimgExtern)
   
         userImgAdjustNoClamp := (PasteInPlaceLight>1 && PasteInPlaceGamma<1) ? 1 : 0 
         thisOpacity := (FillAreaColorMode=1) ? FillAreaOpacity : max(FillAreaOpacity, FillArea2ndOpacity)
         If (FillAreaApplyColorFX=1 && FillAreaBlendMode>1 && r && fillTool=1)
         {
            showTOOLtip("Applying " modus "`nPerforming color adjustments, please wait", 1)
            rz := DllCall(whichMainDLL "\AdjustImageColorsPrecise", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", thisOpacity, "int", userImgAdjustInvertColors, "int", userImgAdjustAltSat, "int", Round(PasteInPlaceSaturation*655.35), "int", userImgAdjustAltBright, "int", Round(PasteInPlaceLight*257), "int", 0, "int", Round(PasteInPlaceGamma*655.30), "int", 0, "int", 0, "int", 0, "int", PasteInPlaceHue, "int", 0, "int", 0, "int", 0, "int", 300, "int", 0, "int", 0, "int", 0, "int", 0, "int", -1, "int", -1, "int", -1, "int", -1, "int", 0, "int", userimgGammaCorrect, "int", userImgAdjustNoClamp, "int", 65535, "int", 0, "int", 0, "UPtr", mScan, "int", mStride)
         }

         If (mustUnlock=1 && !EZ)
         {
            Gdip_UnlockBits(gradientsBMP, gData)
            trGdip_DisposeImage(gradientsBMP)
         }

         If (fillTool=1 && !AnyWindowOpen)
         {
            coreFillSelectedArea("kill")
            drawFillSelGradient("kill", 0, 0, 0, 0, 0, 0)
            getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
            DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
         }

         If (bpp=32 && FillAreaRemBGR=1)
            currIMGdetails.HasAlpha := 1
      } Else If InStr(modus, "erase")
      {
         If (allowRecord=1)
         {
            zrr := recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, EraseAreaInvert)
            If (zrr=2)
            {
               showTOOLtip("Erase area: operation abandoned by user.")
               DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
               ResetImgLoadStatus()
               SetTimer, RemoveTooltip, % -msgDisplayTime
               Return
            }
         }

         newColor := "0x00010101"
         If (bpp=32)
            currIMGdetails.HasAlpha := 1
         thisOpacity := (EraseAreaFader=1) ? EraseAreaOpacity : 255
         QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.imgSelW, obju.imgSelH, EllipseSelectMode, VPselRotation, 0, EraseAreaInvert, "a", "a", 1)
         r := DllCall(whichMainDLL "\FillSelectArea", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", newColor, "int", thisOpacity, "int", 1, "int", 0, "int", 0, "int", 0, "UPtr", mScan, "int", mStride, "UPtr", 0, "int", 0, "int", 24, "int", 0, "int", 0, "int", 0)
         If InStr(modus, "initially")
         {
            If r
               viewportQPVimage.actions := Round(viewportQPVimage.actions + 1)
            Return
         }
      } Else If InStr(modus, "pixelize")
      {
         thisImgW := (BlurAreaInverted=1) ? Ceil(ImgW/blurAreaPixelizeAmount) : Ceil(obju.bImgSelW/blurAreaPixelizeAmount)
         thisImgH := (BlurAreaInverted=1) ? Ceil(ImgH/blurAreaPixelizeAmount) : Ceil(obju.bImgSelH/blurAreaPixelizeAmount)
         If memoryUsageWarning(thisImgW, thisImgH, bpp)
         {
            showTOOLtip("Pixelize area: operation abandoned by user.")
            DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
            ResetImgLoadStatus()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }

         showTOOLtip("Applying " modus "`nPhase 1/3...", 1)
         If (BlurAreaInverted=1)
            hFIFimgZ := FreeImage_Rescale(hFIFimgX, thisImgW, thisImgH, blurAreaPixelizeMethod - 1)
         Else
            hFIFimgZ := FreeImage_RescaleRect(hFIFimgX, thisImgW, thisImgH, obju.bImgSelPx, obju.bImgSelPy, obju.bImgSelW, obju.bImgSelH, blurAreaPixelizeMethod - 1)

         If hFIFimgZ
         {
            FreeImage_GetImageDimensions(hFIFimgZ, thisImgW, thisImgH)
            pBitsMini := FreeImage_GetBits(hFIFimgZ)
            strideMini := FreeImage_GetStride(hFIFimgZ)
            If (BlurAreaBlendMode>1 && blurAreaApplyFX=1)
            {
               userImgAdjustHiPrecision := 1
               userImgAdjustNoClamp := (PasteInPlaceLight>1 && PasteInPlaceGamma<1) ? 1 : 0 
               this := (userImgAdjustHiPrecision=1) ? "Precise" : ""
               showTOOLtip("Applying " modus "`nPhase 2/3...", 1)
               QPV_PrepareHugeImgSelectionArea(0, 0, thisImgW, thisImgH, thisImgW, thisImgH, 0, 0, 0, 0, "a", "a", 1)
               r := DllCall(whichMainDLL "\AdjustImageColors" this, "UPtr", pBitsMini, "Int", thisImgW, "Int", thisImgH, "int", strideMini, "int", bpp, "int", blurAreaOpacity, "int", userImgAdjustInvertColors, "int", userImgAdjustAltSat, "int", Round(BlurAreaSaturation*655.35), "int", userImgAdjustAltBright, "int", Round(BlurAreaLight*257), "int", 0, "int", Round(BlurAreaGamma*655.30), "int", 0, "int", 0, "int", 0, "int", BlurAreaHue, "int", 0, "int", 0, "int", 0, "int", 300, "int", 0, "int", 0, "int", 0, "int", 0, "int", -1, "int", -1, "int", -1, "int", -1, "int", 0, "int", userimgGammaCorrect, "int", userImgAdjustNoClamp, "int", 65535, "int", 0, "int", 0, "UPtr", 0, "int", 0)
            }

            recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, BlurAreaInverted, 0)
            QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.imgSelW, obju.imgSelH, EllipseSelectMode, VPselRotation, 0, BlurAreaInverted, "a", "a", 1)
            showTOOLtip("Applying " modus "`nPhase 3/3...", 1)
            r := DllCall(whichMainDLL "\PixelateHugeBitmap", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", blurAreaOpacity, "int", BlurAreaBlendMode - 1, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha, "int", userimgGammaCorrect, "UPtr", pBitsMini, "int", strideMini, "int", thisImgW, "int", thisImgH, "UPtr", mScan, "int", mStride)
            FreeImage_UnLoad(hFIFimgZ)
         } Else
         {
            addJournalEntry("Failed to rescale selected rect and to pixelize")
            r := 0
         }
      } Else If InStr(modus, "invert")
      {
         zrr := recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, 0)
         If (zrr=2)
         {
            showTOOLtip("Invert area: operation abandoned by user.")
            DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
            ResetImgLoadStatus()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }

         QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.imgSelW, obju.imgSelH, EllipseSelectMode, VPselRotation, 0, 0, "a", "a", 1)
         r := DllCall(whichMainDLL "\AdjustImageColors", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", 255, "int", 1, "int", 0, "int", 0, "int", 1, "int", 0, "int", 0, "int", 0, "int", 0, "int", 0, "int", 0, "int", 0, "int", 0, "int", 0, "int", 0, "int", 300, "int", 0, "int", 0, "int", 0, "int", 0, "int", -1, "int", -1, "int", -1, "int", -1, "int", 1, "int", 0, "int", 0, "int", 65535, "int", 0, "int", 0, "UPtr", mScan, "int", mStride)
      } Else If InStr(modus, "flood")
      {
         zrr := recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, 0)
         If (zrr=2)
         {
            showTOOLtip("Flood fill: operation abandoned by user.")
            DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
            ResetImgLoadStatus()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }

         newColor := "0x" Format("{:X}", FloodFillClrOpacity) FloodFillColor
         Gdip_FromARGB(newColor, A, R, G, B)
         newColor := Gdip_ToARGB(A, R, G, B)
         If (FloodFillTolerance<3)
            FloodFillCartoonMode := 0

         x := hFIFimgExtern[1], y := imgH - hFIFimgExtern[2]
         tolerance := (FloodFillAltToler=1) ? Ceil(FloodFillTolerance*0.7) + 1 : FloodFillTolerance
         QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.imgSelW, obju.imgSelH, EllipseSelectMode, VPselRotation, 0, 0, "a", "a", 1)
         use := (BrushToolOutsideSelection>1 && editingSelectionNow=1) ? 1 : 0
         inverter := (BrushToolOutsideSelection=3) ? 1 : 0
         r := DllCall(whichMainDLL "\FloodFillWrapper", "UPtr", pBitsAll, "Int", FloodFillModus, "Int", imgW, "Int", imgH, "Int", x, "Int", y, "Int", newColor, "int", tolerance, "int", FloodFillOpacity, "int", FloodFillDynamicOpacity, "int", FloodFillBlendMode - 1, "int", FloodFillCartoonMode, "int", FloodFillAltToler, "int", FloodFillEightWays, "int", userimgGammaCorrect, "int", BlendModesFlipped, "int", Stride, "int", bpp, "int", use, "int", inverter)
      } Else If InStr(modus, "noise")
      {
         If (UserAddNoisePixelizeAmount>0)
         {
            thisImgW := (BlurAreaInverted=1) ? Ceil(ImgW/UserAddNoisePixelizeAmount) : Ceil(obju.bImgSelW/UserAddNoisePixelizeAmount)
            thisImgH := (BlurAreaInverted=1) ? Ceil(ImgH/UserAddNoisePixelizeAmount) : Ceil(obju.bImgSelH/UserAddNoisePixelizeAmount)
            If memoryUsageWarning(thisImgW, thisImgH, bpp)
            {
               DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
               Return
            }

            hFIFimgZ := FreeImage_Allocate(thisImgW, thisImgH, 24)
            FreeImage_GetImageDimensions(hFIFimgZ, thisImgW, thisImgH)
            pBitsMini := FreeImage_GetBits(hFIFimgZ)
            strideMini := FreeImage_GetStride(hFIFimgZ)
            recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, 0, 0)
         } Else
         {
            zrr := recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH)
            If (zrr=2)
            {
               showTOOLtip("Add noise in selected area:`nOperation abandoned by user.")
               DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
               ResetImgLoadStatus()
               SetTimer, RemoveTooltip, % -msgDisplayTime
               Return
            }
         }

         ; fnOutputDebug(imgSelX1 "|" imgSelY1 "||" imgSelX2 "|" imgSelY2 "||" thisSelW "|" thisSelH)
         QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.imgSelW, obju.imgSelH, EllipseSelectMode, VPselRotation, 0, 0, "a", "a", 1)
         r := DllCall(whichMainDLL "\GenerateRandomNoiseOnBitmap", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", 100 - UserAddNoiseIntensity, "int", IDedgesOpacity, "int", IDedgesEmphasis, "int", UserAddNoiseGrays, "int", UserAddNoisePixelizeAmount, "UPtr", pBitsMini, "int", strideMini, "int", thisImgW, "int", thisImgH, "int", IDedgesBlendMode - 1, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha)
         If (UserAddNoisePixelizeAmount>0)
            FreeImage_UnLoad(hFIFimgZ)
      } Else If InStr(modus, "color")
      {
         this := (userImgAdjustHiPrecision=1) ? "Precise" : ""
         zrr := recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, userImgAdjustInvertArea)
         If (zrr=2)
         {
            showTOOLtip("Adjust image colors: operation abandoned by user.")
            DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
            ResetImgLoadStatus()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
 
         QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.imgSelW, obju.imgSelH, EllipseSelectMode, VPselRotation, 0, userImgAdjustInvertArea, "a", "a", 1)
         r := DllCall(whichMainDLL "\AdjustImageColors" this, "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", imgColorsFXopacity, "int", userImgAdjustInvertColors, "int", userImgAdjustAltSat, "int", userImgAdjustSat, "int", userImgAdjustAltBright, "int", userImgAdjustBright, "int", userImgAdjustAltContra, "int", userImgAdjustContra, "int", userImgAdjustAltHiLows, "int", userImgAdjustShadows, "int", userImgAdjustHighs, "int", userImgAdjustHue, "int", userImgAdjustTintDeg, "int", userImgAdjustTintAmount, "int", userImgAdjustAltTint, "int", userImgAdjustGamma, "int", userImgAdjustOffR, "int", userImgAdjustOffG, "int", userImgAdjustOffB, "int", userImgAdjustOffA, "int", userImgAdjustThreR, "int", userImgAdjustThreG, "int", userImgAdjustThreB, "int", userImgAdjustThreA, "int", userImgAdjustSeeThrough, "int", userimgGammaCorrect, "int", userImgAdjustNoClamp, "int", userImgAdjustWhitePoint, "int", userImgAdjustBlackPoint, "int", userImgAdjustNoisePoints, "UPtr", mScan, "int", mStride)
      } Else ; grayscale mode
      {
         this := (userImgAdjustHiPrecision=1) ? "Precise" : ""
         zrr := recordUndoLevelHugeImagesNow(obju.bX1, obju.bY1, obju.bImgSelW, obju.bImgSelH, EraseAreaInvert)
         If (zrr=2)
         {
            showTOOLtip("Adjust image colors: operation abandoned by user.")
            DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
            ResetImgLoadStatus()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }

         QPV_PrepareHugeImgSelectionArea(obju.x1, obju.y1, obju.x2 - 1, obju.y2 - 1, obju.imgSelW, obju.imgSelH, EllipseSelectMode, VPselRotation, 0, EraseAreaInvert, "a", "a", 1)
         r := DllCall(whichMainDLL "\AdjustImageColors" this, "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", DesaturateAreaAmount, "int", DesaturateAreaInvert, "int", DesaturateAreaChannel - 1, "int", -65535, "int", 1, "int", DesaturateAreaBright, "int", 0, "int", DesaturateAreaContra, "int", 0, "int", 0, "int", 0, "int", DesaturateAreaHue, "int", 0, "int", 0, "int", 0, "int", 300, "int", 0, "int", 0, "int", 0, "int", 0, "int", -1, "int", -1, "int", -1, "int", -1, "int", 1, "int", userimgGammaCorrect, "int", 0, "int", 65535, "int", 0, "int", 0, "UPtr", mScan, "int", mStride)
         ; r := DllCall(whichMainDLL "\ConvertToGrayScale", "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", DesaturateAreaChannel, "int", DesaturateAreaAmount, "int", stride, "int", bpp, "UPtr", mScan, "int", mStride)
      }

      If (editingSelectionNow=1 && validBMP(obju.alphaMaskGray))
      {
         Gdip_UnlockBits(obju.alphaMaskGray, mData)
         trGdip_DisposeImage(obju.alphaMaskGray)
      }

      DllCall(whichMainDLL "\discardFilledPolygonCache", "int", 0)
      etaTime := "Elapsed time to apply: " modus ": " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) 
      addJournalEntry(etaTime)
      If r 
      {
         killQPVscreenImgSection()
         currentImgModified := 1
         imgIndexEditing := currentFileIndex
         viewportQPVimage.actions := Round(viewportQPVimage.actions + 1)
         dummyTimerDelayiedImageDisplay(500)
         SoundBeep, 900, 100
         RemoveTooltip()
      } Else
      {
         recordUndoLevelHugeImagesNow("kill", 0, 0, 0)
         showTOOLtip("ERROR: Failed to apply the " modus " on the image")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }

      ResetImgLoadStatus()
      Return r
} ; // HugeImagesApplyGenericFilters()

HugeImagesCropResizeRotate(w, h, modus, x:=0, y:=0, zw:=0, zh:=0, givenQuality:=0, allowUndo:=1) {
   If warnHugeImageNotFIM()
      Return

   xx := (modus="resize") ? Ceil(w*1.5) : zw
   yy := (modus="resize") ? Ceil(h*1.5) : zh
   If (modus="crop")
      xx := yy := 0

   If memoryUsageWarning(xx, yy)
      Return

   setImageLoading()
   w := Round(w),   h := Round(h)
   ; fnOutputDebug(A_ThisFunc "(" modus "): " w "|" h "||" x "|" y "||" viewportQPVimage.imgHandle)
   FreeImage_GetImageDimensions(viewportQPVimage.imgHandle, kW, kH)
   mgpx := Round((kw * kh)/1000000, 1)
   ; fnOutputDebug(A_ThisFunc "(" modus "): " kw "|" kh)
   If (modus="resize")
   {
      nmgpx := Round((w * h)/1000000, 1)
      showTOOLtip("Resizing image to`n" w " x " h " pixels`n" nmgpx " megapixels`nPlease wait...")
      hq := (givenQuality=1) ? 3 : 0
      hFIFimgA := FreeImage_Rescale(viewportQPVimage.imgHandle, w, h, hq)
   } Else If (modus="crop")
   {
      nmgpx := Round((zw * zh)/1000000, 1)
      showTOOLtip("Cropping image to`n" zw " x " zh " pixels`n" nmgpx " megapixels`nPlease wait...")
      hFIFimgA := FreeImage_Copy(viewportQPVimage.imgHandle, x, y, w, h)
   } Else If InStr(modus, "rotate")
   {
      nmgpx := mgpx
      deg := (modus="rotate90") ? 90 : -90
      showTOOLtip("Rotating image to " deg "°`nPlease wait...")
      hFIFimgA := FreeImage_Rotate(viewportQPVimage.imgHandle, deg)
   }

   If hFIFimgA
   {
      If (allowUndo=1)
         recordUndoLevelHugeImagesNow("entire-vp", 0, 0, 0, 0, 0)

      ; ToolTip, % "zr=" zr , , , 2
      diffu := max(nmgpx, mgpx) - min(nmgpx, mgpx)
      If (diffu>70)
         PrintPosX := "X"

      tFrames := frameu := 1
      imgPath := viewportQPVimage.ImgFile
      actions := Round(viewportQPVimage.actions + 1)
      viewportQPVimage.DiscardImage()
      killQPVscreenImgSection()
      Sleep, 1
      viewportQPVimage.LoadImage(imgPath, frameu, 0, 1, [hFIFimgA, tFrames], 1)
      If (modus="resize" || modus="rotate90")
      {
         oimgBPP := FreeImage_GetBPP(hFIFimgA)
         ColorsType := FreeImage_GetColorType(hFIFimgA)
         imgType := FreeImage_GetImageType(hFIFimgA, 1)
         fileType := FreeImage_GetFileType(imgPath, 1)

         currIMGdetails.HasAlpha := InStr(ColorsType, "rgba") ? 1 : 0
         currIMGdetails.RawFormat := fileType " | " imgType
         currIMGdetails.PixelFormat := StrReplace(oimgBPP, "-", "+") "-" ColorsType
         viewportQPVimage.HasAlpha := InStr(ColorsType, "rgba") ? 1 : 0
         viewportQPVimage.RawFormat := fileType " | " imgType
         viewportQPVimage.PixelFormat := StrReplace(oimgBPP, "-", "+") "-" ColorsType
         viewportQPVimage.clrinfo := oimgBPP "-bit " ColorsType
      }

      SoundBeep 900, 100
      RemoveTooltip()
      currentImgModified := 1
      imgIndexEditing := currentFileIndex
      viewportQPVimage.actions := actions
      If (editingSelectionNow=1)
      {
         VPselRotation := EllipseSelectMode := innerSelectionCavityX := innerSelectionCavityY := 0
         selectEntireImage("r")
      }
      dummyTimerDelayiedImageDisplay(500)
   } Else
   {
      If (modus="resize")
         showTOOLtip("Failed to resize image to`n" w " x " h " pixels`n" nmgpx " megapixels")
      Else If (modus="crop")
         showTOOLtip("Failed to crop image to`n" zw " x " zh " pixels`n" nmgpx " megapixels")
      Else If InStr(modus, "rotate")
         showTOOLtip("Failed to rotate image to " deg "°")

      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
   SetTimer, ResetImgLoadStatus, -200
}

ResizeIMGviewportSelection() {
    mergeViewPortRotationImgEditing()
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    stopNow := (editingSelectionNow=1 && validBMP(whichBitmap)) ? 0 : 1
    If (stopNow=1)
       Return 

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    mgpx := Round((imgW * imgH)/1000000, 1)
    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    If !(viewportQPVimage.imgHandle)
       capIMGdimensionsGDIPlimits(imgSelW, imgSelH)
    If (imgSelW=imgW && imgSelH=imgH)
       Return

    If (throwErrorSelectionOutsideBounds(whichBitmap) || testEntireImgSelected(0, 0, 1))
       Return

    If (viewportQPVimage.imgHandle)
    {
       HugeImagesCropResizeRotate(imgSelW, imgSelH, "resize", 0, 0, 0, 0, userimgQuality)
       Return
    }

    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    thisQuality := (userimgQuality=1) ? 7 : 5
    pargbPixFmt := (coreDesiredPixFmt="0xE200B") ? -1 : 0
    nmgpx := Round((imgSelW * imgSelH)/1000000, 1)
    showTOOLtip("Please wait, resizing image to`n" imgSelW " x " imgSelH " pixels`n" nmgpx " megapixels")
    newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgSelW, imgSelH, 0, thisQuality, pargbPixFmt)
    If !validBMP(newBitmap)
    {
       showTOOLtip("Failed to resize image to`n" imgSelW " x " imgSelH " pixels`n" nmgpx " megapixels")
       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -150
       Return "fail"
    }

    diffu := max(nmgpx, mgpx) - min(nmgpx, mgpx)
    If (diffu>50)
       PrintPosX := "X"

    wrapRecordUndoLevelNow(newBitmap)
    VPselRotation := EllipseSelectMode := vpIMGrotation := 0
    INIaction(1, "vpIMGrotation", "General")
    selectEntireImage()
    updateUIctrl()
    MouseMoveResponder()
    dummyTimerDelayiedImageDisplay(50)
    SetTimer, ResetImgLoadStatus, -150
    SetTimer, dummyInfoImgResizeVP, -125
}

PerformAutoCropViewportMode() {
    stopNow := (editingSelectionNow=1 && validBMP(useGdiBitmap())) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1)
       Return

    newBitmap := AutoCropAction(whichBitmap, usrAutoCropColorTolerance, usrAutoCropErrThreshold/100, 0, 0)
    If !validBMP(newBitmap)
    {
       addJournalEntry(A_ThisFunc "(): ERROR. Failed to perform auto-crop for image.")
       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -150
       Return "fail"
    }

    wrapRecordUndoLevelNow(newBitmap)
    ResetImgLoadStatus()
    editingSelectionNow := vpIMGrotation := 0
    updateUIctrl()
    MouseMoveResponder()
    dummyTimerDelayiedImageDisplay(50)
    SetTimer, ResetImgLoadStatus, -150
    SetTimer, dummyInfoImgResizeVP, -125
}

dummyInfoImgResizeVP() {
   trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW * imgH)/1000000, 2)
   showTOOLtip("Image resized to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px | " Round(imgW/imgH, 2) " | " mpx " MPx" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

DrawLinesInSelectedArea(modus) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    allowOutside := 0
    whichBitmap := useGdiBitmap()
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    tk := (DrawLineAreaContourAlign=1 || PasteInPlaceAutoExpandIMG!=1) ? 0 : DrawLineAreaContourThickness
    o_imgSelX1 := imgSelX1,    o_imgSelY1 := imgSelY1
    o_imgSelX2 := imgSelX2,    o_imgSelY2 := imgSelY2
    imgSelX1 := imgSelX1 - tk//2,    imgSelY1 := imgSelY1 - tk//2
    imgSelX2 := imgSelX2 + tk//2,    imgSelY2 := imgSelY2 + tk//2
    offX := (imgSelX1<0) ? abs(imgSelX1) : 0
    offY := (imgSelY1<0) ? abs(imgSelY1) : 0
    If ((imgSelX1<0 || imgSelY1<0 || imgSelX2>imgW || imgSelY2>imgH) && PasteInPlaceAutoExpandIMG=1 && validBMP(whichBitmap) && imgW && imgH)
       allowOutside := 1

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 1, allowOutside)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    startZeit := A_TickCount
    If (allowOutside=1)
       hasRanExpand := performAutoExpandCanvas(imgW, imgH)

    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    trGdip_GetImageDimensions(whichBitmap, rw, rh)
    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    If (DrawLineAreaBlendMode>1)
       newBitmap := trGdip_CreateBitmap(A_ThisFunc, rw, rh)
    Else
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)

    If validBMP(newBitmap)
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 7, 4,, compositingQuality)

    If !G2
    {
       If validBMP(newBitmap)
          showTOOLtip("Failed to draw lines in the selected area.`nUnable to create GDI+ graphics object.")
       Else
          showTOOLtip("Failed to draw lines in the selected area.`nUnable to allocate new bitmap.")
       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       trGdip_DisposeImage(newBitmap)
       Return
    }

    If (hasRanExpand=1)
    {
       imgSelX1 := o_imgSelX1 + offX
       imgSelY1 := o_imgSelY1 + offY
       imgSelX2 := o_imgSelX2 + offX
       imgSelY2 := o_imgSelY2 + offY
       defineRelativeSelCoords(imgW, imgH)
    }

    If (modus=1)
       rz := coreDrawLinesStuffTool("parametric", G2, newBitmap)
    Else
       rz := coreDrawLinesStuffTool("shapes", G2, newBitmap)

    Gdip_DeleteGraphics(G2)
    If (DrawLineAreaBlendMode>1 && rz!=-1)
       r := QPV_BlendBitmaps(newBitmap, whichBitmap, DrawLineAreaBlendMode, BlendModesPreserveAlpha, BlendModesFlipped, 2)

    If (rz!=-1)
       wrapRecordUndoLevelNow(newBitmap)
    Else
       trGdip_DisposeImage(newBitmap)

    zeitOperation := A_TickCount - startZeit
    addJournalEntry("Draw lines operation. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    dummyTimerDelayiedImageDisplay(50)
    SetTimer, ResetImgLoadStatus, -100
    If (hasRanExpand=1)
    {
       totalSelUndos := Round(undoSelLevelsArray.Count())
       currentSelUndoLevel := clampInRange(totalSelUndos, 1, totalSelUndos)
       restorePreviousSelections(currentSelUndoLevel)
       dummyRefreshImgSelectionWindow()
       ; ToolTip, % totalSelUndos "=" currentSelUndoLevel , , , 2
    }
}

coreDrawParametricLinesTool(G2, previewMode, thisThick, imgSelPx, imgSelPy, imgSelW, imgSelH) {
    dR := (DrawLineAreaContourAlign=3) ? thisThick//2 : 0
    If (DrawLineAreaContourAlign=1)
       dR := -thisThick//2

    x1 := imgSelPx,              y1 := imgSelPy
    x2 := imgSelPx + imgSelW,    y2 := imgSelPy + imgSelH
    imgSelPx -= dR
    imgSelPy -= dR
    imgSelW += dR*2
    imgSelH += dR*2
    x1 -= dR
    y1 -= dR
    x2 += dR
    y2 += dR

    pPathArcs := Gdip_CreatePath()
    pPathBrders := Gdip_CreatePath()
    If (DrawLineAreaBorderCenter=1)
    {
       ; margins / borders and arcs
       bly2 := (DrawLineAreaBorderConnector=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcC=1) ? y2 - imgSelH//2 : y2
       bly1 := (DrawLineAreaBorderConnector=1 && DrawLineAreaBorderArcA=1 && DrawLineAreaBorderArcC=0) ? y1 + imgSelH//2 : y1
       bky2 := (DrawLineAreaBorderConnector=1 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcD=1) ? y2 - imgSelH//2 : y2
       bky1 := (DrawLineAreaBorderConnector=1 && DrawLineAreaBorderArcB=1 && DrawLineAreaBorderArcD=0) ? y1 + imgSelH//2 : y1
       blx2 := (DrawLineAreaBorderConnector=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=1) ? x2 - imgSelW//2 : x2
       blx1 := (DrawLineAreaBorderConnector=1 && DrawLineAreaBorderArcA=1 && DrawLineAreaBorderArcB=0) ? x1 + imgSelW//2 : x1
       bkx2 := (DrawLineAreaBorderConnector=1 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=1) ? x2 - imgSelW//2 : x2
       bkx1 := (DrawLineAreaBorderConnector=1 && DrawLineAreaBorderArcC=1 && DrawLineAreaBorderArcD=0) ? x1 + imgSelW//2 : x1
       If (DrawLineAreaBorderArcA=1)
          Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 180, 90)

       Gdip_StartPathFigure(pPathArcs)
       If (DrawLineAreaBorderArcB=1)
          Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 270, 90)

       Gdip_StartPathFigure(pPathArcs)
       If (DrawLineAreaBorderArcC=1)
          Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 90, 90)

       Gdip_StartPathFigure(pPathArcs)
       If (DrawLineAreaBorderArcD=1)
          Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 0, 90)

       whichPath := pPathArcs ; pPathBrders
       Gdip_StartPathFigure(whichPath)
       If (DrawLineAreaBorderTop=1)
          Gdip_AddPathLine(whichPath, blx1, y1, blx2, y1)

       Gdip_StartPathFigure(whichPath)
       If (DrawLineAreaBorderBottom=1)
          Gdip_AddPathLine(whichPath, bkx1, y2, bkx2, y2)

       Gdip_StartPathFigure(whichPath)
       If (DrawLineAreaBorderLeft=1)
          Gdip_AddPathLine(whichPath, x1, bly1, x1, bly2)

       Gdip_StartPathFigure(whichPath)
       If (DrawLineAreaBorderRight=1)
          Gdip_AddPathLine(whichPath, x2, bky1, x2, bky2)
    }

    If (DrawLineAreaBorderCenter=2)
    {
       ; mid-lines
       If (DrawLineAreaBorderTop=1)
       {
          Gdip_StartPathFigure(pPathBrders)
          Gdip_AddPathLine(pPathBrders, x1, y1 + imgSelH//2, x2, y1 + imgSelH//2)
       }

       If (DrawLineAreaBorderLeft=1)
       {
          Gdip_StartPathFigure(pPathBrders)
          Gdip_AddPathLine(pPathBrders, x1 + imgSelW//2, y1, x1 + imgSelW//2, y2)
       }
    }

    If (DrawLineAreaBorderCenter=3)
    {
       ; diagonals
       frame := defineFreeHandFrame("flip", FlipImgH, FlipImgV, freeHandPoints[5])
       ; deg := MouseDeltaAngle360(x1, y1, x2, y2)
       zSelW := ( max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2) ) * zoomLevel
       zSelH := ( max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2) ) * zoomLevel
       tt :=  (DrawLineAreaContourThickness<15) ?  DrawLineAreaContourThickness : DrawLineAreaContourThickness*zoomLevel
       If (DrawLineAreaContourAlign=2 && DrawLineAreaContourThickness>30)
          tt := tt/2

       tt := (tt<24) ? tt * 1.5 : tt * 0.9
       If (tt<5)
          tt := 5

       If (zSelW<tt && zSelH>tt)
          snapping := "h"
       Else If (zSelH<tt && zSelW>tt)
          snapping := "v"

       Gdip_StartPathFigure(pPathBrders)
       ; ToolTip, % thisThick "|" snapping "=" frame " deg=" deg , , , 2
       If (freeHandSelectionMode=1 && DrawLineAreaSnapLine=1 && snapping="v" && (frame=1 || frame=2))
          Gdip_AddPathLine(pPathBrders, x1, y2, x2, y2)
       Else If (freeHandSelectionMode=1 && DrawLineAreaSnapLine=1 && snapping="v" && (frame=3 || frame=4))
          Gdip_AddPathLine(pPathBrders, x1, y1, x2, y1)
       Else If (freeHandSelectionMode=1 && DrawLineAreaSnapLine=1 && snapping="h" && (frame=1 || frame=3))
          Gdip_AddPathLine(pPathBrders, x2, y1, x2, y2)
       Else If (freeHandSelectionMode=1 && DrawLineAreaSnapLine=1 && snapping="h" && (frame=2 || frame=4))
          Gdip_AddPathLine(pPathBrders, x1, y1, x1, y2)
       Else If (freeHandSelectionMode=1 && (frame=1 || frame=4))
          Gdip_AddPathLine(pPathBrders, x1, y1, x2, y2)
       Else If (freeHandSelectionMode=1 && (frame=2 || frame=3))
          Gdip_AddPathLine(pPathBrders, x1, y2, x2, y1)
       Else
       {
          If (DrawLineAreaBorderTop=1)
             Gdip_AddPathLine(pPathBrders, x1, y2, x2, y1)

          Gdip_StartPathFigure(pPathBrders)
          If (DrawLineAreaBorderLeft=1)
             Gdip_AddPathLine(pPathBrders, x1, y1, x2, y2)
       }
    }

    rz := Gdip_GetPathPointsCount(pPathBrders) + Gdip_GetPathPointsCount(pPathArcs) 
    If (DrawLineAreaBorderCenter<2 && !rz && previewMode=0)
    {
       showTOOLtip("WARNING: No lines configured to draw.`nIs this what they call a draw?")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Gdip_DeletePath(pPathBrders)
       Gdip_DeletePath(pPathArcs)
       Return -1
    }

    thisColor := makeRGBAcolor(DrawLineAreaColor,DrawLineAreaOpacity)
    thisPen := Gdip_CreatePen(thisColor, thisThick)
    Gdip_SetPenDashStyle(thisPen, DrawLineAreaDashStyle - 1)
    If (DrawLineAreaCapsStyle=1)
       Gdip_SetPenLineCaps(thisPen, 2, 2, 2)

    Static compoundArray := "0.0|0.33|0.67|1.0"
    If (DrawLineAreaDoubles=1)
       Gdip_SetPenCompoundArray(thisPen, compoundArray)

    If (DrawLineAreaCropShape>1 && isInRange(DrawLineAreaBorderCenter, 4, 6))
    {
       zPath := Gdip_CreatePath()
       If (DrawLineAreaCropShape=3)
          Gdip_AddPathEllipse(zPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
       Else
          Gdip_AddPathRectangle(zPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
       trGdip_RotatePathAtCenter(zPath, VPselRotation, 1, 1, DrawLineAreaKeepBounds, 1)
       Gdip_SetClipPath(G2, zPath)
       Gdip_DeletePath(zPath)
    }

    applyLimits := (Gdip_GetPathPointsCount(pPathBrders))>2 ? 1 : 0
    trGdip_RotatePathAtCenter(pPathBrders, VPselRotation, 1, applyLimits, DrawLineAreaKeepBounds, 1)
    trGdip_RotatePathAtCenter(pPathArcs, VPselRotation, 1, 1, DrawLineAreaKeepBounds, 1)
    Gdip_DrawPath(G2, thisPen, pPathBrders)
    Gdip_DrawPath(G2, thisPen, pPathArcs)
    Gdip_DeletePath(pPathBrders)
    Gdip_DeletePath(pPathArcs)
    If (DrawLineAreaBorderCenter=4)
    {
       ; rays
       rw := imgSelW ,  rh := imgSelH
       arw := rw + Round(rw * (DrawLineAreaAltRays/200))
       arh := rh + Round(rh * (DrawLineAreaAltRays/200))
       cX := imgSelPx + rW/2
       cY := imgSelPy + rH/2
       PointsList := []
       midPointsList := []
       pk := 0

       Loop, % DrawLineAreaGridX
       {
          If (DrawLineAreaRaysLimit>1)
          {
             If !isInRange(A_Index, DrawLineAreaRaysLimit, DrawLineAreaGridX - DrawLineAreaRaysLimit)
                Continue
          }

          pk := !pk
          getRelativePointCoordsCircle((1130 / DrawLineAreaGridX) * (A_Index - 1) - 281, zx, zy)
          mw := (pk=1) ? rw : arw
          mh := (pk=1) ? rh : arh
          bzx := cX + (zx*mW)/2
          bzy := cY + (zy*mH)/2
          PointsList.Push(bzx),  PointsList.Push(bzy)
          zx := cX + (zx*(mW/2))/2
          zy := cY + (zy*(mH/2))/2
          midPointsList.Push(zx),  midPointsList.Push(zy)
       }

       kPath := Gdip_CreatePath(0, PointsList)
       If (DrawLineAreaGridX>2)
          trGdip_RotatePathAtCenter(kPath, VPselRotation, 1, 1, DrawLineAreaKeepBounds, 1)

       newPoints := Gdip_GetPathPoints(kPath, 1)
       t := 0,  fx := imgSelW * alphaMaskOffsetX, fy := imgSelH * alphaMaskOffsetY
       ppr := (DrawLineAreaCenterCut>105) ? (DrawLineAreaCenterCut - 225)/350 : DrawLineAreaCenterCut/350
       Loop, % newPoints.Count() + 1
       {
          pPath := Gdip_CreatePath()
          t++
          zx := newPoints[t]
          mx := midPointsList[t]
          t++
          zy := newPoints[t]
          my := midPointsList[t]
          If (zx="" || mx="")
             Continue

          If (DrawLineAreaCenterCut>105)
          {
             abx := mX + fx/1.5,       aby := mY + fy/1.5
             bbx := weighTwoValues(zx, abx, ppr)
             bby := weighTwoValues(zy, aby, ppr)
             Gdip_AddPathLine(pPath, bbx, bby, zx, zy)
          } Else
          {
             abx := cX + fx,       aby := cY + fy
             bbx := weighTwoValues(zx, abx, ppr)
             bby := weighTwoValues(zy, aby, ppr)
             Gdip_AddPathCurve(pPath, [bbx, bby, mX + fx/1.5, mY + fy/1.5, zx, zy], 0.9)
          }
          Gdip_DrawPath(G2, thisPen, pPath)
          Gdip_DeletePath(pPath)
       }
       Gdip_DeletePath(kPath)

    } Else If (DrawLineAreaBorderCenter=5)
    {
       ; grid
       pPath := Gdip_CreatePath()
       If (DrawLineAreaAtomizedGrid=1)
       {
          Gdip_AddPathRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
          Rect := Gdip_GetPathWorldBounds(pPath)
 
          pMatrix := Gdip_CreateMatrix()
          cX := Rect.x + (Rect.w / 2),   cY := Rect.y + (Rect.h / 2)
          Gdip_TranslateMatrix(pMatrix, -cX , -cY)
          Gdip_RotateMatrix(pMatrix, VPselRotation, 1)
          Gdip_TranslateMatrix(pMatrix, cX, cY, 1)
          Gdip_TransformPath(pPath, pMatrix)

          nRect := Gdip_GetPathWorldBounds(pPath)
          ncX := nRect.x + (nRect.w / 2)
          ncY := nRect.y + (nRect.h / 2)
          zpMatrix := Gdip_CreateMatrix()
          Gdip_TranslateMatrix(zpMatrix, -ncX , -ncY)
          sX := Rect.w / nRect.w
          sY := Rect.h / nRect.h
          If (DrawLineAreaKeepBounds=1)
          {
             sX := min(sX, sY)
             sY := min(sX, sY)
          }
          Gdip_ScaleMatrix(zpMatrix, sX, sY, 1)
          Gdip_TranslateMatrix(zpMatrix, ncX, ncY, 1)
       }

       zxs := (imgSelW + thisThick)/DrawLineAreaGridX
       zx := -zxs + imgSelPx
       fx := imgSelW * alphaMaskOffsetX, fy := imgSelH * alphaMaskOffsetY
       If (DrawLineAreaGridCenter=1)
         fx := fy := (fx+fy)/2
       pa := DrawLineAreaGridX/2
       Loop, % DrawLineAreaGridX
       {
          zx += zxs
          If (zx - imgSelPx>imgSelW || DrawLineAreaGridCenter=4 && A_Index>1)
             Break

          If (DrawLineAreaGridCenter=1)
          {
             pfx := (A_Index>pa) ? weighTwoValues(fx, 0, (A_Index - pa)/pa) : - weighTwoValues(fx, 0, 1 - A_Index/pa)
             pfy := 0
          } Else If (DrawLineAreaGridCenter=3)
          {
             pfx := fx
             pfy := fy
          } Else
          {
             pfx := (A_Index>pa) ? weighTwoValues(fx, 0, 1 - (A_Index - pa)/pa) : weighTwoValues(fx, 0, A_Index/pa)
             pfy := (A_Index>pa) ? weighTwoValues(fy, 0, 1 - (A_Index - pa)/pa) : weighTwoValues(fy, 0, A_Index/pa)
          }

          If (DrawLineAreaAtomizedGrid=1)
          {
             gPath := Gdip_CreatePath()
             ; Gdip_AddPathLine(gPath, zx, imgSelPy, zx, imgSelPy + imgSelH)
             Gdip_AddPathCurve(gPath, [zx, imgSelPy, zx + pfx, imgSelPy + imgSelH/2 + pfy, zx, imgSelPy + imgSelH], 1)
             Gdip_TransformPath(gPath, pMatrix)
             Gdip_TransformPath(gPath, zpMatrix)
             Gdip_DrawPath(G2, thisPen, gPath)
             Gdip_DeletePath(gPath)
          } Else
          {
             Gdip_StartPathFigure(pPath)
             ; Gdip_AddPathLine(pPath, zx, imgSelPy, zx, imgSelPy + imgSelH)
             Gdip_AddPathCurve(pPath, [zx, imgSelPy, zx + pfx, imgSelPy + imgSelH/2 + pfy, zx, imgSelPy + imgSelH], 1)
          }
       }

       If (DrawLineAreaAtomizedGrid!=1)
       {
          Gdip_StartPathFigure(pPath)
          Gdip_AddPathLine(pPath, imgSelPx + imgSelW, imgSelPy, imgSelPx + imgSelW, imgSelPy + imgSelH)
       } Else
       {
          gPath := Gdip_CreatePath()
          Gdip_AddPathLine(gPath, imgSelPx + imgSelW, imgSelPy, imgSelPx + imgSelW, imgSelPy + imgSelH)
          Gdip_TransformPath(gPath, pMatrix)
          Gdip_TransformPath(gPath, zpMatrix)
          Gdip_DrawPath(G2, thisPen, gPath)
          Gdip_DeletePath(gPath)
       }

       gridy := (DrawLineAreaEqualGrid=1) ? DrawLineAreaGridX : DrawLineAreaGridY
       zys := (imgSelH + thisThick)/gridy
       zy := -zys + imgSelPy
       pa := gridy/2
       Loop, % gridy
       {
          zy += zys
          If (zy - imgSelPy>imgSelH || DrawLineAreaGridCenter=3 && A_Index>1)
             Break

          if (DrawLineAreaGridCenter=1)
          {
             pfx := 0
             pfy := (A_Index>pa) ? weighTwoValues(fy, 0, (A_Index - pa)/pa) : - weighTwoValues(fy, 0, 1 - A_Index/pa)
          } Else If (DrawLineAreaGridCenter=4)
          {
             pfx := fx
             pfy := fy
          } Else
          {
             pfx := (A_Index>pa) ? weighTwoValues(fx, 0, 1 - (A_Index - pa)/pa) : weighTwoValues(fx, 0, A_Index/pa)
             pfy := (A_Index>pa) ? weighTwoValues(fy, 0, 1 - (A_Index - pa)/pa) : weighTwoValues(fy, 0, A_Index/pa)
          }

          If (DrawLineAreaAtomizedGrid=1)
          {
             gPath := Gdip_CreatePath()
             ; Gdip_AddPathLine(gPath, imgSelPx, zy, imgSelPx + imgSelW, zy)
             Gdip_AddPathCurve(gPath, [imgSelPx, zy, imgSelPx + imgSelW/2 + pfx, zy + pfy, imgSelPx + imgSelW, zy], 1)
             Gdip_TransformPath(gPath, pMatrix)
             Gdip_TransformPath(gPath, zpMatrix)
             Gdip_DrawPath(G2, thisPen, gPath)
             Gdip_DeletePath(gPath)
          } Else
          {
             Gdip_StartPathFigure(pPath)
             Gdip_AddPathCurve(pPath, [imgSelPx, zy, imgSelPx + imgSelW/2 + pfx, zy + pfy, imgSelPx + imgSelW, zy], 1)
             ; Gdip_AddPathLine(pPath, imgSelPx, zy, imgSelPx + imgSelW, zy)
          }
       }

       if (DrawLineAreaAtomizedGrid!=1)
       {
          Gdip_StartPathFigure(pPath)
          Gdip_AddPathLine(pPath, imgSelPx, imgSelPy + imgSelH, imgSelPx + imgSelW, imgSelPy + imgSelH)
          trGdip_RotatePathAtCenter(pPath, VPselRotation, 1, 1, DrawLineAreaKeepBounds, 1)
          Gdip_DrawPath(G2, thisPen, pPath)
       } Else
       {
          gPath := Gdip_CreatePath()
          Gdip_AddPathLine(gPath, imgSelPx, imgSelPy + imgSelH, imgSelPx + imgSelW, imgSelPy + imgSelH)
          Gdip_TransformPath(gPath, pMatrix)
          Gdip_TransformPath(gPath, zpMatrix)
          Gdip_DrawPath(G2, thisPen, gPath)
          Gdip_DeletePath(gPath)
          Gdip_DeleteMatrix(pMatrix)
          Gdip_DeleteMatrix(zpMatrix)
       }

       Gdip_DeletePath(pPath)
    } Else If (DrawLineAreaBorderCenter=6 && DrawLineAreaSpiralLength>1)
    {
       ; spiral
       If (DrawLineAreaSpiralCenterMode=1 || DrawLineAreaSpiralCenterMode=2)
       {
          rp := (DrawLineAreaSpiralCenterMode=2) ? 350 : 50
          fx := imgSelW * (alphaMaskOffsetX/rp), fy := imgSelH * (alphaMaskOffsetY/rp)
          rw := imgSelW - fx*2,     rh := imgSelH - fy*2
       } Else
       {
          fx := imgSelW * alphaMaskOffsetX, fy := imgSelH * alphaMaskOffsetY
          rw := imgSelW,     rh := imgSelH
       }

       cX := imgSelPx + imgSelW/2
       cY := imgSelPy + imgSelH/2
       PointsList := []
       ; PointsList.Push(cX),  PointsList.Push(cY)
       angle := -272
       rw := imgSelW,     rh := imgSelH
       spx := imgSelPx,   spy := imgSelPy
       zfx := imgSelW/(DrawLineAreaSpiralLength + 2)
       zfy := imgSelH/(DrawLineAreaSpiralLength + 2)
       ppr := 1 - Round(DrawLineAreaCenterCut/400, 1)
       Loop, % DrawLineAreaSpiralLength
       {
          If (A_Index/DrawLineAreaSpiralLength>ppr)
             Break

          angle += 3

          If (angle>848)
             angle := -272

          rw -= zfx
          rh -= zfy
          If (DrawLineAreaSpiralCenterMode=2)
          {
             spx += zfx/2 + fx/2
             spy += zfy/2 + fy/2
          } Else
          {
             spx += zfx/2
             spy += zfy/2
          }

          cX := spx + rw/2
          cY := spy + rh/2
          getRelativePointCoordsCircle(angle, zx, zy)
          If (DrawLineAreaSpiralCenterMode=2)
          {
             zx := cX + (zx*rw)/2
             zy := cY + (zy*rh)/2
          } Else If (DrawLineAreaSpiralCenterMode=1)
          {
             zx := cX + ((zx + fx)*rw)/2
             zy := cY + ((zy + fy)*rh)/2
          } Else
          {
             zx := cX + (zx*(rw + fx))/2
             zy := cY + (zy*(rh + fy))/2
          }

          PointsList.Push(zx),  PointsList.Push(zy)
          lastu := !lastu
       }

       pPath := Gdip_CreatePath()
       Gdip_AddPathCurve(pPath, PointsList)
       trGdip_RotatePathAtCenter(pPath, VPselRotation, 1, 1, DrawLineAreaKeepBounds, 1)
       Gdip_DrawPath(G2, thisPen, pPath)
       Gdip_DeletePath(pPath)
    }
    Gdip_DeletePen(thisPen)
} ; // coreDrawParametricLinesTool()


createDrawLinesPen(thisThick) {
    Static compoundArray := "0.0|0.33|0.67|1.0"
    If (thisThick<2)
       thisThick := 1

    thisColor := makeRGBAcolor(DrawLineAreaColor, DrawLineAreaOpacity)
    thisPen := Gdip_CreatePen(thisColor, thisThick)
    Gdip_SetPenUnit(thisPen, 2)
    Gdip_SetPenDashStyle(thisPen, DrawLineAreaDashStyle - 1)
    If (DrawLineAreaCapsStyle=1)
       Gdip_SetPenLineCaps(thisPen, 2, 2, 2)
    Else
       Gdip_SetPenLineCaps(thisPen, 1, 1, 1)

    If (DrawLineAreaDoubles=1)
       Gdip_SetPenCompoundArray(thisPen, compoundArray)

    Return thisPen
}

coreDrawLinesStuffTool(modus, G2:=0, whichBitmap:=0) {
    If (G2)
    {
       previewMode := 0
       trGdip_GetImageDimensions(whichBitmap, oimgW, oimgH)
       calcImgSelection2bmp(!LimitSelectBoundsImg, oimgW, oimgH, oimgW, oimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       maxLength := min(imgSelW, imgSelH)//2
       thisThick := (DrawLineAreaContourThickness > maxLength//1.05) ? maxLength//1.05 : DrawLineAreaContourThickness
       If (modus!="shapes" && (DrawLineAreaBorderCenter=2 || DrawLineAreaBorderCenter=3))
          thisThick := DrawLineAreaContourThickness

       If (userimgGammaCorrect=1)
          Gdip_SetCompositingQuality(G2, 2)
    } Else
    {
       G2 := 2NDglPG ; preview mode
       If (doImgEditLivePreview!=1 || testSelectOutsideImgEntirely(useGdiBitmap()) && PasteInPlaceAutoExpandIMG!=1)
          Return

       ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
       previewMode := 1
       vpWinClientSize(mainWidth, mainHeight)
       trGdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
       calcImgSelection2bmp(!LimitSelectBoundsImg, qimgW, qimgH, qimgW, qimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       maxLength := min(imgSelW, imgSelH)//2
       thisThick := (DrawLineAreaContourThickness > maxLength//1.05) ? maxLength//1.05 : DrawLineAreaContourThickness
       If (modus!="shapes" && (DrawLineAreaBorderCenter=2 || DrawLineAreaBorderCenter=3))
          thisThick := DrawLineAreaContourThickness
       If (viewportQPVimage.imgHandle)
          thisThick := thisThick * (DrawLineAreaThickScale / 100)

       thisThick := thisThick*zoomLevel
       ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, qImgW, qImgH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
       tk := (DrawLineAreaContourAlign=2) ? thisThick//2 : thisThick
       If (DrawLineAreaContourAlign=1)
          tk := 0

       o_imgSelPx := imgSelPx,        o_imgSelPy := imgSelPy
       o_imgSelW  := imgSelW,         o_imgSelH  := imgSelH
       getClampedVPselToWindow(1, mainWidth, mainHeight, qimgW, qimgH, imgSelPx, imgSelPy, imgSelW, imgSelH)
       dw := (o_imgSelW>mainWidth) ? imgSelW : Round(imgSelW + tk * 2)
       dh := (o_imgSelH>mainHeight) ? imgSelH : Round(imgSelH + tk * 2)
       If (dw<3)
          dw := 3
       If (dh<3)
          dh := 3

       tkx := (o_imgSelW>mainWidth) ? 0 : tk
       tky := (o_imgSelH>mainHeight) ? 0 : tk
       bx := by := 0
       If (DrawLineAreaBlendMode>1 && !testSelectOutsideImgEntirely(useGdiBitmap()))
       {
          previewMode := 2
          xBitmap := trGdip_CreateBitmap(A_ThisFunc, dw, dh, "0x26200A")
          If (currIMGdetails.HasAlpha=1 && !viewportQPVimage.imgHandle)
             bgrBMPu := getImgOriginalSelectedAreaEdit(0, imgSelPx - tkx, imgSelPy - tky, dw, dh, mainWidth, mainHeight, 1)
          Else
             bgrBMPu := getImgSelectedAreaEditMode(1, imgSelPx - tkx, imgSelPy - tky, dw, dh, dw, dh, 0, dw, dh)

          G2 := Gdip_GraphicsFromImage(xBitmap, 5, 1, 2, 1)
          Gdip_SetPixelOffsetMode(G2, 1)
          bx := (prevDestPosX>=o_imgSelPx && prevDestPosX>=0) ? prevDestPosX - o_imgSelPx : 0
          by := (prevDestPosY>=o_imgSelPy && prevDestPosY>=0) ? prevDestPosY - o_imgSelPy : 0
          bx := (o_imgSelPx<=0 && prevDestPosX<=0) ? abs(o_imgSelPx) : bx
          by := (o_imgSelPy<=0 && prevDestPosY<=0) ? abs(o_imgSelPy) : by
          imgSelPx := tkx - bx
          imgSelPy := tky - by
       } Else If (userimgGammaCorrect=1 && AnyWindowOpen!=23)
       {
          bgrBMPu := getImgSelectedAreaEditMode(1, imgSelPx - tkx, imgSelPy - tky, dw, dh, dw, dh, 0, dw, dh)
          trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx - tkx, imgSelPy - tky, dw, dh)
          Gdip_SetCompositingQuality(G2, 2)
          imgSelPx := o_imgSelPx,        imgSelPy := o_imgSelPy
       } Else
       {
          imgSelPx := o_imgSelPx,        imgSelPy := o_imgSelPy
       }

       imgSelW  := o_imgSelW,         imgSelH  := o_imgSelH
    }

    Gdip_ResetClip(G2)
    If (previewMode>0)
       Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 0)

    If (modus="shapes")
       rz := coreDrawShapesLinesTool(G2, previewMode, thisThick, imgSelPx, imgSelPy, imgSelW, imgSelH)
    Else
       rz := coreDrawParametricLinesTool(G2, previewMode, thisThick, imgSelPx, imgSelPy, imgSelW, imgSelH)

    Gdip_ResetClip(G2)
    If (userimgGammaCorrect=1)
       Gdip_SetCompositingQuality(G2, 1)

    If (previewMode=2)
    {
       Gdip_DeleteGraphics(G2)
       Gdip_ResetClip(2NDglPG)
       QPV_BlendBitmaps(bgrBMPu, xBitmap, DrawLineAreaBlendMode - 1, BlendModesPreserveAlpha, BlendModesFlipped)
       If (currIMGdetails.HasAlpha=1)
          Gdip_FillRectangle(2NDglPG, GDIPbrushHatch, o_imgSelPx - tkx + bx, o_imgSelPy - tky + by, dw, dh)
       trGdip_DrawImage(A_ThisFunc, 2NDglPG, bgrBMPu, o_imgSelPx - tkx + bx, o_imgSelPy - tky + by, dw, dh)
       trGdip_DisposeImage(xBitmap)
    }

    If validBMP(bgrBMPu)
       trGdip_DisposeImage(bgrBMPu)
    Return rz
}

coreDrawShapesLinesTool(G2, previewMode, thisThick, imgSelPx, imgSelPy, imgSelW, imgSelH) {
    thisPen := createDrawLinesPen(thisThick)
    pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)
    modus := (DrawLineAreaContourAlign=1) ? 0 : 4
    If (DrawLineAreaContourAlign!=2)
       Gdip_SetClipPath(G2, pPath, modus)

    If (FillAreaEllipseSection<848 && FillAreaShape=3 && FillAreaEllipsePie=0)
    {
       nPath := createPiePath(imgSelPx, imgSelPy, imgSelW, imgSelH, thisThick*2)
       Gdip_SetClipPath(G2, nPath, 4)
       Gdip_DeletePath(nPath)
    }

    If (previewMode>0)
    {
       vpWinClientSize(mainWidth, mainHeight)
       Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)
    }

    Gdip_DrawPath(G2, thisPen, pPath)
    Gdip_ResetClip(G2)
    Gdip_DeletePath(pPath)
    Gdip_DeletePen(thisPen)
}


createPiePath(imgSelPx, imgSelPy, imgSelW, imgSelH, err:=0, pPath:=0) {
    nPath := pPath ? pPath : Gdip_CreatePath()
    cX2 := imgSelPx + imgSelW/2
    cY2 := imgSelPy + imgSelH/2
    PointsList := []
    ; PointsList.Push(cX1),  PointsList.Push(cY1)
    PointsList.Push(cX2),  PointsList.Push(cY2)
    Loop, % 848 - FillAreaEllipseSection
    {
       getRelativePointCoordsCircle(848 - A_Index, zx, zy)
       zx := cX2 + (zx*(imgSelW + err))/2
       zy := cY2 + (zy*(imgSelH + err))/2
       PointsList.Push(zx),  PointsList.Push(zy)
    }

    Gdip_AddPathPolygon(nPath, PointsList)
    ; Gdip_FillPath(G2, pBrushD, nPath)
    ; Gdip_DeletePath(nPath)
    PointsList := ""
    Return nPath
}

getRelativePointCoordsCircle(angle, ByRef zx, ByRef zy) {
   zx := cos(angle/180),   zy := sin(angle/180)
}

ChangeImageCanvasSize(userW, userH, userAddT, userAddB, userAddL, userAddR, userAddC) {
    mergeViewPortRotationImgEditing()
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (!validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If (adjustCanvasMode=1)
    {
       newW := userAddL + userAddR + userAddC + imgW
       newH := userAddT + userAddB + userAddC + imgH
       If isImgSizeTooLarge(newW, newH)
       {
          Loop
          {
             userAddL := clampInRange(userAddL - 1, 0, userAddL)
             userAddR := clampInRange(userAddR - 1, 0, userAddR)
             userAddC := clampInRange(userAddC - 1, 0, userAddC)
             userAddT := clampInRange(userAddT - 1, 0, userAddT)
             userAddB := clampInRange(userAddB - 1, 0, userAddB)
             newW := userAddL + userAddR + userAddC + imgW
             newH := userAddT + userAddB + userAddC + imgH
             If !isImgSizeTooLarge(newW, newH)
                Break
          }
       }
       imgSelPx := Round(userAddL + (userAddC + 1)/2)
       imgSelPy := Round(userAddT + (userAddC + 1)/2)
    } Else
    {
       newW := userW
       newH := userH
       If isImgSizeTooLarge(newW, newH)
          capIMGdimensionsGDIPlimits(newW, newH)
       imgSelPx := (adjustCanvasCentered=1) ? newW//2 - imgW//2 : 0
       imgSelPy := (adjustCanvasCentered=1) ? newH//2 - imgH//2 : 0
       ; ToolTip, % newW "|" imgW "|" imgSelPx "|" adjustCanvasCentered , , , 2
    }

    xBitmap := trGdip_CreateBitmap(A_ThisFunc, newW, newH, coreDesiredPixFmt)
    If warnUserFatalBitmapError(xBitmap, A_ThisFunc)
    {
       showTOOLtip("Failed to adjust the canvas size of the image")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return "fail"
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap, 7, 4)
    If !G2
    {
       showTOOLtip("Failed to adjust the canvas size of the image")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       trGdip_DisposeImage(xBitmap)
       Return "fail"
    }

    currIMGdetails.HasAlpha := 1
    If (adjustCanvasDoBgr=1)
    {
       thisColor := makeRGBAcolor(OutlierFillColor, OutlierFillOpacity)
       Gdip_SetClipRect(G2, imgSelPx, imgSelPy, imgW, imgH, 4)
       r0 := Gdip_GraphicsClear(G2, thisColor)
       If r0
          addJournalEntry(A_ThisFunc "(): failed to set background color through trGdip_GraphicsClear()")

       Gdip_ResetClip(G2)
    }
    ; MsgBox, % newW "--" newH "--" imgSelPx "--" imgSelPy
    r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, imgSelPx, imgSelPy)
    Gdip_DeleteGraphics(G2)
    If (r1!="fail" && validBMP(xBitmap))
    {
       imgSelX1 := imgSelPx,           imgSelY1 := imgSelPy
       imgSelX2 := imgSelPx + imgW,    imgSelY2 := imgSelPy + imgH
       defineRelativeSelCoords(newW, newH)
       wrapRecordUndoLevelNow(xBitmap)
    } Else
    {
       showTOOLtip("Failed to adjust the canvas size of the image")
       trGdip_DisposeImage(xBitmap, 1)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    dummyTimerDelayiedImageDisplay(50)
    SetTimer, ResetImgLoadStatus, -250
}

ApplySpecialFixedBlur(funcu, zBitmap, radius, pEffect, previewMode:=0) {
    Static offsets := {20:18, 19:16, 18:14, 17:12, 16:10, 15:8, 14:6, 13:4, 12:2, 11:1, 10:2, 9:2, 8:2, 7:2, 6:2, 5:2, 4:2, 3:2, 2:1, 1:1, 0:2}
    If (!pEffect || !validBMP(zBitmap))
    {
       addJournalEntry("Internal error: " A_ThisFunc "() has failed: " pEffect " | " zBitmap ". Caller: " funcu "()")
       Return
    }

    radius := clampInRange(radius, 1, 509)
    nr := clampInRange(radius - 255, 0, 255)
    If (nr>2 && radius>255 && !InStr(funcu, "ApplySpecialFixedBlur"))
    {
       zA := Gdip_CreateEffect(1, 255, 0, 0)
       Gdip_BitmapApplyEffect(zBitmap, zA)
       Gdip_DisposeEffect(zA)

       zB := Gdip_CreateEffect(1, radius - 255, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, zBitmap, nr, zB, previewMode)
       Gdip_DisposeEffect(zB)
       Return
    } Else If (radius>20 || previewMode=1)
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Return
    }

    If offsets[radius]
       radius += offsets[radius]

    zA := Gdip_CreateEffect(1, radius//2, 0, 0)
    zB := Gdip_CreateEffect(1, radius//2, 0, 0)
    Gdip_ImageRotateFlip(zBitmap, 1)
    Gdip_BitmapApplyEffect(zBitmap, zA)
    Gdip_ImageRotateFlip(zBitmap, 3)
    Gdip_BitmapApplyEffect(zBitmap, zB)
    Gdip_DisposeEffect(zA)
    Gdip_DisposeEffect(zB)
}

applyBlurColorsFX(zBitmap) {
    If (blurAreaApplyFX!=1)
       Return

    If (BlurAreaHue!=0 || BlurAreaSaturation!=0)
    {
       zEffect := Gdip_CreateEffect(6, BlurAreaHue, BlurAreaSaturation, 0)
       Gdip_BitmapApplyEffect(zBitmap, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (BlurAreaLight!=0 || BlurAreaGamma!=0)
    {
       zEffect := Gdip_CreateEffect(5, BlurAreaLight, BlurAreaGamma)
       Gdip_BitmapApplyEffect(zBitmap, zEffect)
       Gdip_DisposeEffect(zEffect)
    }
}

BlurSelectedArea(modus:="") {
    If (!testAllowSelInvert() && BlurAreaInverted=1)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If (InStr(msgResult, "reopen") && modus="pixelize")
          SetTimer, PanelPixelizeSelectedArea, -300
       Else If InStr(msgResult, "reopen")
          SetTimer, PanelBlurSelectedArea, -300
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    allowAlphaMasking := decideAlphaMaskingFeaseable(BlurAreaAlphaMask)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    o_blurAreaYamount := blurAreaYamount
    o_blurAreaAmount := blurAreaAmount
    If (blurAreaEqualXY=1 && modus!="pixelize")
    {
       o_blurAreaYamount := blurAreaAmount
       If (blurAreaMode=2 && blurAreaTwice!=1)
          o_blurAreaYamount := o_blurAreaAmount := Round(blurAreaAmount*0.5)
    }

    If (blurAreaTwice=1 && blurAreaMode>1 && modus!="pixelize")
    {
       o_blurAreaYamount *= 2
       o_blurAreaAmount *= 2
    }

    If (modus="pixelize")
       o_blurAreaYamount := o_blurAreaAmount := 0

    testu := (blurAreaMode=1 || blurAreaMode>1 && blurAreaEqualXY=1) ? o_blurAreaAmount : max(o_blurAreaAmount, o_blurAreaYamount)
    If (testu<2 && modus!="pixelize")
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "You have set the blur amount to zero. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelBlurSelectedArea, -300
       SetTimer, ResetImgLoadStatus, -100
       Return
    } Else If (blurAreaPixelizeAmount<2 && modus="pixelize")
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "You have set pixelize amount to zero. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelPixelizeSelectedArea, -300
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    metaBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, metaBitmap, 7, 4)
    If !G2
    {
       If validBMP(metaBitmap)
          showTOOLtip("Failed to blur the selected area.`nUnable to create GDI+ graphics object.")
       Else
          showTOOLtip("Failed to blur the selected area.`nUnable to allocate new bitmap.")
       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(metaBitmap)
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY, 0)
    pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h
    If (blurAreaSoftEdges!=1 && pPath || modus="pixelize")
    {
       nodus := (BlurAreaInverted=1) ? 4 : 0
       If (BlurAreaInverted=1 && pPath)
          Gdip_SetClipPath(G2, pPath, 4)
       Else If (pPath!="")
          Gdip_SetClipPath(G2, pPath, nodus)
    }

    If (BlurAreaInverted=1)
    {
       imgSelPx := imgSelPy := 0
       imgSelW := imgW
       imgSelH := imgH
    }

    thisOpacity := blurAreaOpacity/255
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    If (modus="pixelize")
       isUni := Gdip_TestBitmapUniformity(zBitmap, 7, maxLevelIndex, nimo, avgLevelAlpha)

    ; ToolTip, % "l=" isUni " | " maxLevelIndex , , , 2
    ; ToolTip, % blurAreaPixelizeAmount "==" blurAreaPixelizeMethod "==" modus , , , 2
    QPV_PrepareAlphaChannelBlur(zBitmap, 1, 1)
    If (blurAreaPixelizeAmount>1 && blurAreaPixelizeMethod>1 && modus="pixelize")
    {
       thisAmount := blurAreaPixelizeAmount
       thisImgW := (blurAreaPixelizeAmount>1) ? Ceil(imgSelW/blurAreaPixelizeAmount) : imgSelW
       thisImgH := (blurAreaPixelizeAmount>1) ? Ceil(imgSelH/blurAreaPixelizeAmount) : imgSelH
       setWindowTitle("PIXELIZING IMAGE, please wait", 1)
       thisPixiQuality := (blurAreaPixelizeMethod=2) ? 5 : 7
       pixiBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, thisImgW, thisImgH, 0, thisPixiQuality)
       If validBMP(pixiBMP)
          newBitmap := trGdip_ResizeBitmap(A_ThisFunc, pixiBMP, imgSelW, imgSelH, 0, 5)

       If (validBMP(newBitmap) && validBMP(pixiBMP))
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := newBitmap
       }
       trGdip_DisposeImage(pixiBMP, 1)
    } Else If (blurAreaPixelizeAmount>1 && modus="pixelize")
    {
       setWindowTitle("PIXELIZING IMAGE, please wait", 1)
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH, coreDesiredPixFmt)
       If warnUserFatalBitmapError(pixiBMP, A_ThisFunc)
       {
          SetTimer, ResetImgLoadStatus, -100
          trGdip_DisposeImage(zBitmap, 1)
          Gdip_DeletePath(pPath)
          Gdip_DeleteGraphics(G2)
          Return "fail"
       }

       thisStartZeit := A_TickCount
       QPV_PixelateBitmap(zBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, min(imgSelW, imgSelH)))
       ; ToolTip, % A_TickCount - thisStartZeit , , , 2
       trGdip_DisposeImage(zBitmap, 1)
       zBitmap := pixiBMP
    }

    thisBlurMode := blurAreaMode
    pEffect := Gdip_CreateEffect(1, o_blurAreaAmount, 0, 0)
    If (blurAreaTwice=1 && blurAreaMode=1 && modus!="pixelize")
    {
       setWindowTitle("EXTRA-BLURRING IMAGE, please wait", 1)
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, imgSelW//2, imgSelH//2, 1, 3, -1)
       If validBMP(xBitmap)
       {
          trGdip_DisposeImage(zBitmap, 1)
          dhMatrix := Gdip_CreateMatrix()
          Gdip_ScaleMatrix(dhMatrix, 2, 2, 1)
          Gdip_TranslateMatrix(dhMatrix, imgSelPx, imgSelPy, 1)
          If (thisBlurMode=8)
          {
             zxBitmap := QPV_DissolveBitmap(xBitmap, o_blurAreaAmount*1.5, o_blurAreaYamount*1.5)
             If validBMP(zxBitmap)
             {
                trGdip_DisposeImage(xBitmap)
                xBitmap := zxBitmap
             }
          } Else If (thisBlurMode>=3)
             QPV_BoxBlurBitmap(xBitmap, o_blurAreaAmount, o_blurAreaYamount, thisBlurMode - 2, 0, blurAreaCircular)
          Else If (thisBlurMode=2)
             QPV_BoxBlurBitmap(xBitmap, o_blurAreaAmount, o_blurAreaYamount, 0, 1)
          Else If (thisBlurMode=1)
             ApplySpecialFixedBlur(A_ThisFunc, xBitmap, o_blurAreaAmount, pEffect)

          ; trGdip_DisposeImage(zBitmap, 1)
          zBitmap := trGdip_ResizeBitmap(A_ThisFunc, xBitmap, imgSelW, imgSelH, 1, 3, -1)
          trGdip_DisposeImage(xBitmap, 1)
       }
    }

    If (max(o_blurAreaAmount, o_blurAreaYamount)<2 || modus="pixelize")
       thisBlurMode := 0
    Else
       setWindowTitle("BLURRING IMAGE, please wait", 1)

    If (thisBlurMode=8)
    {
       zzBitmap := QPV_DissolveBitmap(zBitmap, o_blurAreaAmount*1.5, o_blurAreaYamount*1.5)
       If validBMP(zzBitmap)
       {
          trGdip_DisposeImage(zBitmap)
          zBitmap := zzBitmap
       }
    } Else If (thisBlurMode>=3) ; box blur
       QPV_BoxBlurBitmap(zBitmap, o_blurAreaAmount, o_blurAreaYamount, thisBlurMode - 2, 0, blurAreaCircular)
    Else If (thisBlurMode=2)  ; alternate mode
       QPV_BoxBlurBitmap(zBitmap, o_blurAreaAmount, o_blurAreaYamount, 0)
    Else If (thisBlurMode=1) ; high quality
       ApplySpecialFixedBlur(A_ThisFunc, zBitmap, o_blurAreaAmount, pEffect)
    Else If (modus="pixelize" && blurAreaAmount>2)
       QPV_BoxBlurBitmap(zBitmap, Round(blurAreaAmount*0.5), Round(blurAreaAmount*0.5), 0)

    If (isUni && modus="pixelize")
       QPV_PrepareAlphaChannelBlur(zBitmap, avgLevelAlpha, 0)

    If (BlurAreaBlendMode>1 || allowAlphaMasking=1)
       bgrBMPu := Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

    If (blurAreaOpacity>252 && blurAreaSoftEdges!=1)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    If (blurAreaSoftEdges=1 && modus!="pixelize")
    {
       setWindowTitle("APPLYING SOFT EDGES MASK, please wait", 1)
       thisAmount := (o_blurAreaAmount + o_blurAreaYamount)/2
       thisAmount := (blurAreaSoftLevel>3) ? Round(thisAmount*(blurAreaSoftLevel - 1)) : Round(thisAmount*(blurAreaSoftLevel/3))
       carvePathFromBitmap(zBitmap, pPath, imgSelPx, imgSelPy, 0, 2, thisAmount, 0, 1, !BlurAreaInverted)
    }

    If (BlurAreaBlendMode>1)
    {
       setWindowTitle("APPLYING BLENDING MODE, please wait", 1)
       If (allowAlphaMasking=1)
          ou := trGdip_CloneBitmap(A_ThisFunc, bgrBMPu)

       applyBlurColorsFX(zBitmap)
       rz := QPV_BlendBitmaps(bgrBMPu, zBitmap, BlurAreaBlendMode - 1, BlendModesPreserveAlpha, BlendModesFlipped)
       If (allowAlphaMasking=1)
          trGdip_DisposeImage(zBitmap)
       Else
          ou := zBitmap
       zBitmap := bgrBMPu
       bgrBMPu := ou
    }

    If (allowAlphaMasking=1 && validBMP(bgrBMPu))
    {
       realtimePasteInPlaceAlphaMasker(0, zBitmap, "lol", newBitmap, 0, 0, 0, 0)
       If validBMP(newBitmap)
       {
          r2 := trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH)
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := newBitmap
       }
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    Gdip_DeleteMatrix(dhMatrix)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    If (r1!="fail" && r0!="fail" && validBMP(metaBitmap))
    {
       wrapRecordUndoLevelNow(metaBitmap)
    } Else
    {
       showTOOLtip("Failed to blur the selected image area.`nPlease do not tell anyone")
       SoundBeep 300, 100
       trGdip_DisposeImage(metaBitmap)
    }

    SetTimer, ResetImgLoadStatus, -100
    dummyTimerDelayiedImageDisplay(50)
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

ZoomBlurSelectedArea() {
    If (!testAllowSelInvert() && BlurAreaInverted=1)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK|&Reopen panel", 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelZoomBlurSelectedArea, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    setImageLoading()
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    allowAlphaMasking := decideAlphaMaskingFeaseable(BlurAreaAlphaMask)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    metaBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    If validBMP(metaBitmap)
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, metaBitmap, 7, 4)

    If !G2
    {
       If validBMP(metaBitmap)
          showTOOLtip("Failed to apply filter: radial blur.`nUnable to create GDI+ graphics object.")
       Else
          showTOOLtip("Failed to apply filter: radial blur.`nUnable to allocate new bitmap.")
       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(metaBitmap)
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
    pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
    imgSelPx := pB.x,  imgSelPy := pB.y
    imgSelW  := pB.w,  imgSelH  := pB.h
    If pPath
    {
       modus := (BlurAreaInverted=1) ? 4 : 0
       Gdip_SetClipPath(G2, pPath, modus)
    }

    If (BlurAreaInverted=1)
    {
       imgSelPx := imgSelPy := 0
       imgSelW := imgW
       imgSelH := imgH
    }

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    If !validBMP(zBitmap)
    {
       showTOOLtip("Failed to apply filter: radial blur.`nUnable to allocate new bitmap.")
       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(metaBitmap)
       Gdip_DeleteGraphics(G2)
       Gdip_DeletePath(pPath)
       Return
    }

    QPV_PrepareAlphaChannelBlur(zBitmap, 1, 1)
    If (BlurAreaBlendMode>1 || allowAlphaMasking=1)
       bgrBMPu := Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

    If (blurAreaOpacity>252)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    setWindowTitle("APPLYING BLUR ON IMAGE, please wait", 1)
    thisOpacity := blurAreaOpacity/255
    gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    G3 := trGdip_GraphicsFromImage(A_ThisFunc, gBitmap, 1, 3)
    Gdip_SetClipRect(G3, 0, 0, imgSelW, imgSelH)
    thisO := 0.85
    dimgSelPx := imgSelPx, dimgSelPy := imgSelPy
    dimgSelW := imgSelW, dimgSelH := imgSelH

    prcX := (clampInRange(tinyPrevAreaCoordX, imgSelPx, imgSelW) - imgSelPx)/imgSelW
    prcY := (clampInRange(tinyPrevAreaCoordY, imgSelPy, imgSelH) - imgSelPy)/imgSelH
    zoomBlurAreaXamount := uiZoomBlurAreaXamount/10
    b := (zoomBlurAreaXamount*2)/1980
    b := b*((imgSelW + imgSelH)/2)
    thisBlurX := thisBlurY := clampInRange(Round(zoomBlurAreaXamount * 0.51), 1, 21)
    If (zoomBlurMode=2)
       thisBlurY := thisBlurY/5 + 1
    Else If (zoomBlurMode=3)
       thisBlurX := thisBlurX/5 + 1

    doStartLongOpDance()
    ; fnOutputDebug("zb=" b "|" thisBlurX "|" thisBlurY)
    If isInRange(zoomBlurMode, 1, 3)
    {
       Loop
       {
          thisO -= 0.1 ; thisOpacity - (A_Index - 1) * startOpacity
          If (thisO<0)
             Break

          showTOOLtip("Radial blur: step " A_Index ".0`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startZeit)/1000, 3)),, , (1 - thisO)/1)
          ; fnOutputDebug(thisBlurAmount "=" thisO)
          QPV_BoxBlurBitmap(zBitmap, thisBlurX, thisBlurY, 0)
          If (zoomBlurMode=1 || zoomBlurMode=2)
             dimgSelW += A_Index * b
          If (zoomBlurMode=1 || zoomBlurMode=3)
             dimgSelH += A_Index * b

          If (zoomBlurMode=1 || zoomBlurMode=2)
             dimgSelPx := 0 - (dimgSelW - imgSelW)*prcX
          If (zoomBlurMode=1 || zoomBlurMode=3)
             dimgSelPy := 0 - (dimgSelH - imgSelH)*prcY

          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }

          showTOOLtip("Radial blur: step " A_Index ".5`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startZeit)/1000, 3)),, , (1 - (thisO - 0.05))/1)
          r1 := trGdip_DrawImage(A_ThisFunc, G3, zBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH,,,,, thisO)
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := trGdip_CloneBitmap(A_ThisFunc, gBitmap)
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }

       }
    }

    Gdip_DeleteGraphics(G3)
    If (BlurAreaBlendMode>1 && abandonAll!=1)
    {
       setWindowTitle("APPLYING BLENDING MODE, please wait", 1)
       applyBlurColorsFX(gBitmap)
       If (allowAlphaMasking=1)
          ou := trGdip_CloneBitmap(A_ThisFunc, bgrBMPu)

       rz := QPV_BlendBitmaps(bgrBMPu, gBitmap, BlurAreaBlendMode - 1, 0, BlendModesFlipped)
       If (allowAlphaMasking=1)
          trGdip_DisposeImage(gBitmap)
       Else
          ou := gBitmap

       gBitmap := bgrBMPu
       bgrBMPu := ou
    }

    If (allowAlphaMasking=1 && validBMP(bgrBMPu) && abandonAll!=1)
    {
       realtimePasteInPlaceAlphaMasker(0, gBitmap, "lol", newBitmap, 0, 0, 0, 0)
       If validBMP(newBitmap)
       {
          r2 := trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu, imgSelPx, imgSelPy, imgSelW, imgSelH)
          trGdip_DisposeImage(gBitmap, 1)
          gBitmap := newBitmap
       }
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, gBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    If (r1!="fail" && r0!="fail" && validBMP(metaBitmap))
    {
       wrapRecordUndoLevelNow(metaBitmap)
    } Else
    {
       showTOOLtip("Failed to apply filter: radial blur. It is all a blur...")
       SoundBeep 300, 100
       trGdip_DisposeImage(metaBitmap)
    }

    SetTimer, ResetImgLoadStatus, -100
    dummyTimerDelayiedImageDisplay(50)
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

isDotInSelRect(mX, mY) {
   p := (!isDotInRect(mX, mY, SelDotX - SelDotsSize, SelDotBx + SelDotsSize*2, SelDotBy - SelDotsSize, SelDotAy + SelDotsSize*2) || editingSelectionNow!=1) ? 0 : 1
   Return p
}

detectEdgesSelectedArea() {
    If (!testAllowSelInvert() && BlurAreaInverted=1)
    {
       btn := !AnyWindowOpen ? "|&Reopen panel" : ""
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image is entirely selected, however you chose to invert the selection area. Therefore, nothing remains selected. Operation abandoned.", "&OK" btn, 1, "exclamation")
       If InStr(msgResult, "reopen")
          SetTimer, PanelDetectEdgesImage, -500
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    newBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    If validBMP(newBitmap)
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 7, 4)

    If !G2
    {
       If validBMP(newBitmap)
          showTOOLtip("Failed to apply filter: detect edges.`nUnable to create GDI+ graphics object.")
       Else
          showTOOLtip("Failed to apply filter: detect edges.`nUnable to allocate new bitmap.")
       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(newBitmap)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisCount := (isNumber(IDedgesEmbossLvl) && IDedgesBlendMode>1) ? clampInRange(IDedgesEmbossLvl, 1, 10) : 1
    Loop, % thisCount
    {
       setWindowTitle("DETECTING EDGES - iteration " A_Index "/" thisCount ", please wait", 1)
       rz := coreDetectEdgesSelectedArea(newBitmap, 0, G2)
       If rz
          Break
    }

    Gdip_DeleteGraphics(G2)
    If (rz!="fail" && validBMP(newBitmap))
    {
       wrapRecordUndoLevelNow(newBitmap)
    } Else
    {
       trGdip_DisposeImage(newBitmap)
       showTOOLtip("Failed to apply filter: detect edges")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }

    SetTimer, ResetImgLoadStatus, -100
    dummyTimerDelayiedImageDisplay(50)
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

coreDetectEdgesSelectedArea(whichBitmap, previewMode, Gu:=0) {
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (previewMode=3)
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
          Return

       imgSelPx := imgSelPy := 0
       imgSelW := imgW, imgSelH := imgH
    } Else If (previewMode!=1)
    {
       G2 := Gu
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY, 0)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelPx := pB.x,  imgSelPy := pB.y
       imgSelW  := pB.w,  imgSelH  := pB.h
       If (BlurAreaInverted=1)
       {
          imgSelPx := imgSelPy := 0
          imgSelW := imgW, imgSelH := imgH
       }
    } Else
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
       {
          SetTimer, ResetImgLoadStatus, -100
          Return "fail"
       }
       imgSelPx := imgSelPy := 0
       imgSelW := imgW, imgSelH := imgH
    }

    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    fBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    If (IDedgesBlendMode>1 && previewMode!=3)
       gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)

    If (IDedgesCenterAmount>1)
       QPV_BoxBlurBitmap(zBitmap, IDedgesCenterAmount, IDedgesCenterAmount, 0)

    Static pxs := {1:"-3", 2:"-2", 3:"-1", 4:"0", 5:"1", 6:"2", 7:"3"}

    G3 := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
    r0 := trGdip_DrawImage(A_ThisFunc, G3, zBitmap, pxs[IDedgesXuAmount], pxs[IDedgesYuAmount])
    QPV_BlendBitmaps(fBitmap, zBitmap, 18, 0) ; difference mode

    zEffect := Gdip_CreateEffect(6, 0, -100, 0)  ; desaturate image
    If zEffect
       Gdip_BitmapApplyEffect(fBitmap, zEffect)
    Gdip_DisposeEffect(zEffect)

    If (IDedgesEmphasis!=0 || IDedgesContrast!=0)
       wEffect := Gdip_CreateEffect(5, IDedgesEmphasis, IDedgesContrast, 0)

    If wEffect
       Gdip_BitmapApplyEffect(fBitmap, wEffect)

    Gdip_DisposeEffect(wEffect)
    If (IDedgesInvert=1)
    {
       zEffect := Gdip_CreateEffect(7, 0, 0, 100)
       If zEffect
          Gdip_BitmapApplyEffect(fBitmap, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    pr := (IDedgesAfterBlur=2) ? 1 : IDedgesAfterBlur*2
    If (IDedgesAfterBlur>1)
       QPV_BoxBlurBitmap(fBitmap, pr, pr, 0)

    If (IDedgesBlendMode>1 && validBMP(gBitmap))
    {
       QPV_BlendBitmaps(gBitmap, fBitmap, IDedgesBlendMode - 1, 0, BlendModesFlipped)
       If (previewMode!=1 && IDedgesOpacity>253)
          r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    }

    If (previewMode!=3)
    {
       thisOpacity := IDedgesOpacity/255
       thisBMP := (IDedgesBlendMode>1 && validBMP(gBitmap)) ? gBitmap : fBitmap
       If (previewMode!=1)
       {
          modus := (BlurAreaInverted=1) ? 4 : 0
          Gdip_SetClipPath(G2, pPath, modus)
       }

       r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
       trGdip_DisposeImage(fBitmap, 1)
       Gdip_ResetClip(G2)
    }

    Gdip_DeletePath(pPath)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    Gdip_DeleteGraphics(G3)
    If (previewMode=1)
       Gdip_DeleteGraphics(G2)
    er := r1 ? r1 : r0
    Return (previewMode=3) ? fBitmap : er
}

addNoiseSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       addJournalEntry(A_ThisFunc "() error - operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
    newBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    If validBMP(newBitmap)
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 7, 4,, compositingQuality)

    If !G2
    {
       If validBMP(newBitmap)
          showTOOLtip("Failed to apply filter: add noise.`nUnable to create GDI+ graphics object.")
       Else
          showTOOLtip("Failed to apply filter: add noise.`nUnable to allocate new bitmap.")
       SoundBeep 300, 100
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(newBitmap)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    setWindowTitle("GENERATING NOISE :-), please wait", 1)
    rz := coreAddNoiseSelectedArea(whichBitmap, 0, G2)
    Gdip_DeleteGraphics(G2)
    If (rz!="fail" && validBMP(newBitmap))
    {
       wrapRecordUndoLevelNow(newBitmap)
    } Else
    {
       trGdip_DisposeImage(newBitmap)
       showTOOLtip("Failed to apply filter: add noise. How noisy!")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }

    SetTimer, ResetImgLoadStatus, -100
    dummyTimerDelayiedImageDisplay(50)
    zeitOperation := A_TickCount - startZeit
    addJournalEntry(A_ThisFunc "() elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

coreAddNoiseSelectedArea(whichBitmap, previewMode, Gu:=0) {
    Critical, on

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (previewMode!=1)
    {
       G2 := Gu
       allowAlphaMasking := decideAlphaMaskingFeaseable(BlurAreaAlphaMask)
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY, 0)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelPx := pB.x,  imgSelPy := pB.y
       imgSelW  := pB.w,  imgSelH  := pB.h
    } Else
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
       {
          SetTimer, ResetImgLoadStatus, -100
          Return "fail"
       }
       imgSelPx := imgSelPy := 0
       imgSelW := imgW, imgSelH := imgH
    }

    extendedClone := testSelectionLargerThanGiven(imgW, imgH)
    plasmaScale := (doubleBlurPreviewArea=1 && previewMode=1) ? UserAddNoisePixelizeAmount//1.25 : UserAddNoisePixelizeAmount
    thisPixelize := (doubleBlurPreviewArea=1 && previewMode=1) ? UserAddNoisePixelizeAmount/2 : UserAddNoisePixelizeAmount
    If (UserAddNoiseMode!=2)
       thisPixelize := 0

    thisImgW := (thisPixelize>1 && UserAddNoiseMode!=3) ? Ceil(imgSelW/thisPixelize) : imgSelW
    thisImgH := (thisPixelize>1 && UserAddNoiseMode!=3) ? Ceil(imgSelH/thisPixelize) : imgSelH
    thisBlurAmount := (doubleBlurPreviewArea=1 && previewMode=1) ? UserAddNoiseBlurAmount//2 : UserAddNoiseBlurAmount
    thisBlurAmountY := (doubleBlurPreviewArea=1 && previewMode=1) ? blurAreaYamount//2 : blurAreaYamount
    If (UserAddNoiseMode=1) ; gaussian
    {
       noiseBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)
       noiseBMP := QPV_CreateGaussianNoiseBMP(noiseBMP, UserAddNoiseIntensity*3)
    } Else If (UserAddNoiseMode=2) ; weird noise
       noiseBMP := QPV_CreateBitmapNoise(thisImgW, thisImgH, UserAddNoiseIntensity, UserAddNoiseGrays, 1, !UserAddNoiseTransparent)
    Else ; plasma
       noiseBMP := QPV_CreatePlasmaBMP(thisImgW, thisImgH, UserAddNoiseIntensity, UserAddNoiseDetails, plasmaScale, UserAddNoiseGrays, thisBlurAmount, thisBlurAmountY, !blurAreaEqualXY, !UserAddNoiseTransparent)

    If !validBMP(noiseBMP)
    {
       If (pPath!="")
          Gdip_DeletePath(pPath)
       Return "error"
    }

    If (thisPixelize>1 && UserAddNoiseMode=2 && validBMP(noiseBMP))
       noiseBMP := resizeBitmapToGivenRef(noiseBMP, 0, imgSelW, imgSelH, 5)

    fBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
    If (thisBlurAmount>1 && blurAreaEqualXY=1 && UserAddNoiseMode>1)
    {
       pEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, noiseBMP, thisBlurAmount, pEffect)
       Gdip_DisposeEffect(pEffect)
    } Else If (blurAreaEqualXY=0 && max(thisBlurAmount, thisBlurAmountY)>1 && UserAddNoiseMode>1)
       QPV_BoxBlurBitmap(noiseBMP, thisBlurAmount, thisBlurAmountY, 1)

    If ((IDedgesEmphasis!=0 || IDedgesContrast!=0) && UserAddNoiseMode>1)
    {
       wEffect := Gdip_CreateEffect(5, IDedgesEmphasis, IDedgesContrast, 0)
       If wEffect
          Gdip_BitmapApplyEffect(noiseBMP, wEffect)
       Gdip_DisposeEffect(wEffect)
    }

    If (IDedgesInvert=1 && UserAddNoiseMode>1)
    {
       zEffect := Gdip_CreateEffect(7, 0, 0, 100)
       If zEffect
          Gdip_BitmapApplyEffect(noiseBMP, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    If (IDedgesBlendMode>1 && UserAddNoiseMode>1)
    {
       gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, extendedClone)
       If validBMP(gBitmap)
          QPV_BlendBitmaps(gBitmap, noiseBMP, IDedgesBlendMode - 1, 0, BlendModesFlipped)
    }

    ; r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    thisOpacity := IDedgesOpacity/255
    thisBMP := (IDedgesBlendMode>1 && validBMP(gBitmap)) ? gBitmap : noiseBMP
    If (previewMode!=1)
       carvePathFromBitmap(thisBMP, pPath, pB.x, pB.y, 4)

    If (allowAlphaMasking=1 && validBMP(fBitmap) && previewMode!=1)
    {
       realtimePasteInPlaceAlphaMasker(0, thisBMP, "lol", newBitmap, 0, 0, 0, 0)
       If validBMP(newBitmap)
       {
          r2 := trGdip_DrawImage(A_ThisFunc, G2, fBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := newBitmap
       }
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    ; fnOutputDebug(A_ThisFunc ": fbitmap=" fbitmap)
    trGdip_DisposeImage(fBitmap, 1)
    ; fnOutputDebug(A_ThisFunc ": gbitmap=" gbitmap)
    trGdip_DisposeImage(gBitmap, 1)
    ; fnOutputDebug(A_ThisFunc ": newbitmap=" newbitmap)
    trGdip_DisposeImage(newBitmap, 1)
    If (noiseBMP!=newBitmap)
       trGdip_DisposeImage(noiseBMP, 1)

    ; fnOutputDebug(A_ThisFunc ": noiseBMP=" noiseBMP)
    ; fnOutputDebug(A_ThisFunc ": alpha masker krill")
    realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
    Gdip_DeletePath(pPath)
    If (previewMode=1)
       Gdip_DeleteGraphics(G2)

    er := r1 ? r1 : r0
    Return er
}

livePreviewsPanelNoEffects() {
    er := livePreviewAddNoiser("none")
    Return er
 }

livePreviewIDedgesPanel() {
    er := livePreviewAddNoiser("edges")
    Return er
}

livePreviewAddNoiser(modus:=0) {
    WinGetPos, , , uiboxSizeW, uiboxSizeH, ahk_id %hCropCornersPic%
    imgBoxSizeW := (doubleBlurPreviewArea=1) ? uiboxSizeW*2 : uiboxSizeW
    imgBoxSizeH := (doubleBlurPreviewArea=1) ? uiboxSizeH*2 : uiboxSizeH
    whichBitmap := useGdiBitmap()
    If !validBMP(whichBitmap)
       Return

    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSizeW, uiboxSizeH, coreDesiredPixFmt)
    If !validBMP(cornersBMP)
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    cX := (uiboxSizeW<imgW) ? 0 : uiboxSizeW//2 - imgW//2
    cY := (uiboxSizeH<imgH) ? 0 : uiboxSizeH//2 - imgH//2
    imgBoxSizeW := min(imgW, imgBoxSizeW)
    imgBoxSizeH := min(imgH, imgBoxSizeH)
    uiBoxSizeW := min(imgW, uiBoxSizeW)
    uiBoxSizeH := min(imgH, uiBoxSizeH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSizeW//2, 0, imgW - imgBoxSizeW)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSizeH//2, 0, imgH - imgBoxSizeH)
    Gdip_GraphicsClear(G, "0xFF666666")
    If (viewportQPVimage.imgHandle)
    {
       thisBMP := viewportQPVimage.ImageGetResizedRect(thisPrevieCoordX, thisPrevieCoordY, imgBoxSizeW, imgBoxSizeH, imgBoxSizeW, imgBoxSizeH, userimgQuality)
       r1 := trGdip_DrawImage(A_ThisFunc, G, thisBMP, cX, cY, uiboxSizeW, uiboxSizeH)
       trGdip_DisposeImage(thisBMP)
    } Else
       r1 := trGdip_DrawImage(A_ThisFunc, G, whichBitmap, cX, cY, uiboxSizeW, uiboxSizeH, thisPrevieCoordX, thisPrevieCoordY, imgBoxSizeW, imgBoxSizeH)

    Gdip_DeleteGraphics(G)
    cornersBMP := applyVPeffectsOnBMP(cornersBMP)
    If (modus="sharpen" || CurrentPanelTab=1 && AnyWindowOpen=79 && modus!="none")
    {
       If (ImageSharpenMode=3)
       {
          gk := trGdip_CloneBitmap(A_ThisFunc, cornersBMP)
          gb := trGdip_CloneBitmap(A_ThisFunc, cornersBMP)
          r0 := coreDetectEdgesSelectedArea(gk, 3)
          QPV_SharpenBitmap(gb, ImageSharpenAmount, ImageSharpenRadius, ImageSharpenMode)
          rr := QPV_SetBitmapAsAlphaChannel(gb, r0)
          ; ToolTip, % "rr=" rr , , , 2
          Gp := Gdip_GraphicsFromImage(cornersBMP)
          tzGdip_DrawImageFast(Gp, gb, 0, 0)
          Gdip_DeleteGraphics(Gp)
          trGdip_DisposeImage(gk)
          trGdip_DisposeImage(r0)
          trGdip_DisposeImage(gb)
       } Else
          QPV_SharpenBitmap(cornersBMP, ImageSharpenAmount, ImageSharpenRadius, ImageSharpenMode)
    } Else If (modus="edges")
    {
       thisCount := (isNumber(IDedgesEmbossLvl) && IDedgesBlendMode>1) ? clampInRange(IDedgesEmbossLvl, 1, 10) : 1
       Loop, % thisCount
       {
          r0 := coreDetectEdgesSelectedArea(cornersBMP, 1)
          If r0
             Break
       }
    } Else If (modus="none")
    {
       Sleep, 0
    } Else
    {
       If (viewportQPVimage.imgHandle)
       {
          If (UserAddNoisePixelizeAmount>0)
          {
             thisImgW := Ceil(imgBoxSizeW/UserAddNoisePixelizeAmount)
             thisImgH := Ceil(imgBoxSizeH/UserAddNoisePixelizeAmount)
             hFIFimgZ := FreeImage_Allocate(thisImgW, thisImgH, 24)
             FreeImage_GetImageDimensions(hFIFimgZ, thisImgW, thisImgH)
             thisSelW := imgBoxSizeW
             thisSelH := imgBoxSizeH
             pBitsMini := FreeImage_GetBits(hFIFimgZ)
             strideMini := FreeImage_GetStride(hFIFimgZ)
             ; fnOutputDebug("i" thisImgW "|" thisImgH "s" thisSelW "|" thisSelH)
          }

          QPV_PrepareHugeImgSelectionArea(0, 0, imgBoxSizeW - 1, imgBoxSizeH - 1, imgBoxSizeW, imgBoxSizeH, 0, 0, 0, 0, 0, 0, 1)
          E1 := Gdip_LockBits(cornersBMP, 0, 0, imgBoxSizeW, imgBoxSizeH, stride, iScan, iData)
          r0 := DllCall(whichMainDLL "\GenerateRandomNoiseOnBitmap", "UPtr", iScan, "Int", imgBoxSizeW, "Int", imgBoxSizeH, "int", stride, "int", 32, "int", 100 - UserAddNoiseIntensity, "int", IDedgesOpacity, "int", IDedgesEmphasis, "int", UserAddNoiseGrays, "int", UserAddNoisePixelizeAmount, "UPtr", pBitsMini, "int", strideMini, "int", thisImgW, "int", thisImgH, "int", IDedgesBlendMode - 1, "int", BlendModesFlipped, "int", BlendModesPreserveAlpha)
          Gdip_UnlockBits(cornersBMP, iData)
          If (UserAddNoisePixelizeAmount>0)
             FreeImage_UnLoad(hFIFimgZ)
       } Else
          r0 := coreAddNoiseSelectedArea(cornersBMP, 1)
    }

    flipBitmapAccordingToViewPort(cornersBMP, 1)
    Gdip_SetPbitmapCtrl(hCropCornersPic, cornersBMP)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    Return er
}

QPV_BoxBlurBitmap(pBitmap, passesX, passesY:=0, modus:=1, forceCimg:=0, circular:=0, preview:=0) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  If !validBMP(pBitmap)
  {
     addJournalEntry(A_ThisFunc "(): invalid bitmap to process")
     Return
  }

  trGdip_GetImageDimensions(pBitmap, w, h)
  If (w<1 || h<1)
     Return 0

  If (modus=0 && forceCimg=0 && passesX=passesY && isInRange(passesX, 21, 255))
  {
     ; fnOutputDebug("large radius for blur=" passesX)
     zA := Gdip_CreateEffect(1, passesX, 0, 0)
     Gdip_BitmapApplyEffect(pBitmap, zA)
     Gdip_DisposeEffect(zA)
     Return 1
  } else If (modus=0 && forceCimg=0 && passesX=passesY)
     passesX := passesY := Round(passesX * 0.4) + 1

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, Stride, iScan, iData, 3)
  If !E1
  {
     r := DllCall(whichMainDLL "\cImgBlurBitmapFilters", "UPtr", iScan, "Int", w, "Int", h, "Int", passesX, "Int", passesY, "Int", modus, "Int", circular, "Int", preview, "int", Stride, "int", 32)
     Gdip_UnlockBits(pBitmap, iData)
  }

  Return r
}

QPV_SharpenBitmap(pBitmap, amount, radius, typeu) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return 0
  }

  If !validBMP(pBitmap)
  {
     addJournalEntry(A_ThisFunc "(): invalid bitmap to process")
     Return
  }

  trGdip_GetImageDimensions(pBitmap, w, h)
  If (w<1 || h<1)
     Return 0

  If (typeu>=2)
  {
     ; fnOutputDebug("large radius for blur=" passesX)
     zA := Gdip_CreateEffect(2, radius, amount)
     Gdip_BitmapApplyEffect(pBitmap, zA)
     Gdip_DisposeEffect(zA)
     Return 1
  }

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If !E1
  {
     r := DllCall(whichMainDLL "\cImgSharpenBitmap", "UPtr", iScan, "Int", w, "Int", h, "Int", round(amount**1.7), "int", stride, "int", 32)
     Gdip_UnlockBits(pBitmap, iData)
  }
  Return r
}

QPV_CreateGaussianNoiseBMP(pBitmap, intensity) {
  initQPVmainDLL()
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return
  }

  If !validBMP(pBitmap)
  {
     addJournalEntry(A_ThisFunc "(): invalid bitmap to process")
     Return
  }

  trGdip_GetImageDimensions(pBitmap, w, h)
  If (w<1 || h<1)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData, 3)
  If !E1
  {
     r := DllCall(whichMainDLL "\cImgAddGaussianNoiseOnBitmap", "UPtr", iScan, "int", w, "int", h, "Int", intensity, "int", Stride, "int", 32)
     Gdip_UnlockBits(pBitmap, iData)
  }

  Return pBitmap
}

QPV_PixelateBitmap(pBitmap, ByRef pBitmapOut, BlockSize) {
   initQPVmainDLL()
   If !qpvMainDll
   {
      addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
      Return
   }

   If (!validBMP(pBitmap) || !validBMP(pBitmapOut))
   {
      addJournalEntry(A_ThisFunc "(): invalid bitmaps (in/out) to process")
      Return
   }

   trGdip_GetImageDimensions(pBitmap, Width, Height)
   If (width<1 || height<1)
      Return 0

   If (Width!=Gdip_GetImageWidth(pBitmapOut) || Height!=Gdip_GetImageHeight(pBitmapOut))
      return -1

   If (BlockSize>Width || BlockSize>Height)
      return -2

   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1, 1)
   E2 := Gdip_LockBits(pBitmapOut, 0, 0, Width, Height, Stride2, Scan02, BitmapData2, 3)
   If (!E1 && !E2)
      r := DllCall(whichMainDLL "\PixelateBitmap", "UPtr", Scan01, "UPtr", Scan02, "int", Width, "int", Height, "int", Stride1, "int", BlockSize, "int", 32)

   If !E1
      Gdip_UnlockBits(pBitmap, BitmapData1)

   If !E2
      Gdip_UnlockBits(pBitmapOut, BitmapData2)
   return r
}

applyVPeffectsOnBMP(zBitmap, doClrDepths:=0, isAlpha:=0, isG:=0) {
    If (bwDithering=1 && imgFxMode=4 && doClrDepths=1)
    {
       If (isG=0 && currIMGdetails.HasAlpha=1 || isAlpha=1 && isG="y")
          Gdip_BitmapSetColorDepth(zBitmap, 24, 1)
  
       kBitmap := trGdip_BitmapConvertGray(A_ThisFunc, zBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
       If validBMP(kBitmap)
       {
          Gdip_BitmapSetColorDepth(kBitmap, "BW", 1)
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := kBitmap
       }
    } Else If (usrColorDepth>1 && doClrDepths=1)
    {
       If (isG=0 && currIMGdetails.HasAlpha=1 || isAlpha=1 && isG="y")
          Gdip_BitmapSetColorDepth(zBitmap, 24, 1)
       Gdip_BitmapSetColorDepth(zBitmap, internalColorDepth, ColorDepthDithering)
    }

    trGdip_GetImageDimensions(zBitmap, imgW, imgH)
    r := decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If pEffect
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If (imageAttribs && matrix && !InStr(r, "moreThanClrMatrix"))
    {
       pEffect := Gdip_CreateEffect(3, matrix, 0)
       If pEffect
       {
          Gdip_BitmapApplyEffect(zBitmap, pEffect)
          Gdip_DisposeEffect(pEffect)
       }
    } Else If imageAttribs
    {
       xBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
       If validBMP(xBitmap)
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap,,,,,,,,,,, imageAttribs)
          Gdip_DeleteGraphics(G2)
          If (r1!="fail" && G2)
          {
             trGdip_DisposeImage(zBitmap, 1)
             zBitmap := xBitmap
          } Else
             trGdip_DisposeImage(xBitmap, 1)
       }
    }
    Return zBitmap
}

applyVPeffectsAdvOnBMP(zBitmap, allowCache:=0, givenID:=0, gImgW:=0, gImgH:=0, BlurAmount:=0, applyVPfx:=1) {
    Static prevState, prevBMP
    If (zBitmap="kill")
    {
       prevState := 0
       prevBMP := trGdip_DisposeImage(prevBMP, 1)
       Return
    }

    trGdip_GetImageDimensions(zBitmap, imgW, imgH)
    If (applyVPfx=1)
       r := decideGDIPimageFX(matrix, imageAttribs, pEffect)
    Else
       r := 1

    thisState := "a" r gImgW gImgH imgW imgH givenID
    If (allowCache=1 && thisState=prevState && validBMP(prevBMP))
    {
       Gdip_DisposeImageAttributes(imageAttribs)
       Gdip_DisposeEffect(pEffect)
       Return trGdip_CloneBitmap(A_ThisFunc, prevBMP)
    }

    prevState := 0
    prevBMP := trGdip_DisposeImage(prevBMP, 1)
    If (imgW!=gImgW || imgH!=gImgH) && (gImgW>1 && gImgH>1)
       nBitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, gImgW, gImgH, 0, 3)
    Else
       nBitmap := trGdip_CloneBitmap(A_ThisFunc, zBitmap)

    If pEffect
    {
       Gdip_BitmapApplyEffect(nBitmap, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If (imageAttribs && matrix && !InStr(r, "moreThanClrMatrix"))
    {
       pEffect := Gdip_CreateEffect(3, matrix, 0)
       If pEffect
       {
          Gdip_BitmapApplyEffect(nBitmap, pEffect)
          Gdip_DisposeEffect(pEffect)
       }
    } Else If imageAttribs
    {
       xBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
       If validBMP(xBitmap)
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, nBitmap,,,,,,,,,,, imageAttribs)
          Gdip_DeleteGraphics(G2)
          If (r1!="fail" && G2)
          {
             trGdip_DisposeImage(nBitmap, 1)
             nBitmap := xBitmap
          } Else
             trGdip_DisposeImage(xBitmap, 1)
       }
    }

    ; fnOutputDebug("redraw: " A_ThisFunc " | " BlurAmount)
    startZeit := A_TickCount
    If (BlurAmount>1)
       QPV_BoxBlurBitmap(nBitmap, BlurAmount, BlurAmount, 0)

    ; fnOutputDebug(A_TickCount - startZeit)
    Gdip_DisposeImageAttributes(imageAttribs)
    prevState := (allowCache=1 && minimizeMemUsage=0) ? thisState : 0
    prevBMP := (allowCache=1 && minimizeMemUsage=0) ? trGdip_CloneBitmap(A_ThisFunc, nBitmap) : 0
    Return nBitmap
}

GetPathRelativeBounds(pPath, imgSelPx, imgSelPy) {
    pB := getAccuratePathBounds(pPath)
    pB.xa := Round(imgSelPx + pB.x)
    pB.ya := Round(imgSelPy + pB.y)
    pB.w := Round(pB.w)
    pB.h := Round(pB.h)
    Return pB
}

getSelectedImageArea(whichBitmap, doCarving, applyVPfx, fakeBGR, newW:=0, newH:=0) {
    If !validBMP(whichBitmap)
    {
       addJournalEntry(A_ThisFunc "(): failed; no bitmap given")
       Return
    }

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
    k := (viewportQPVimage.imgHandle) ? 1 : capIMGdimensionsGDIPlimits(imgSelW, imgSelH)
    pPath := createImgSelPath(0, 0, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY, 0)
    If pPath
    {
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       pBxa := pB.xa
       pBya := pB.ya
       pBw := Floor(pB.w * k)
       pBh := Floor(pB.h * k)
       If (viewportQPVimage.imgHandle)
       {
          pBxa := clampInRange(pBxa, 0, imgW - 1)
          pBya := clampInRange(pBya, 0, imgH - 1)
          pBxb := clampInRange(pBxa + pBw, pBxa + 1, imgW)
          pByb := clampInRange(pBya + pBh, pBya + 1, imgH)
          pBw := pBxb - pBxa
          pBh := pByb - pBya
          dummBMP := viewportQPVimage.ImageGetResizedRect(pBxa, pBya, pBw, pBh, newW, newH, userimgQuality)
       } Else
          dummBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, pBxa, pBya, pBw, pBh, 0, 0, 1, 0)
       ; ToolTip, % imgSelPx "===" imgSelPy "`n" pBw "===" pBh , , , 2
       ; extendedClone := !limitBounds ; (A_PtrSize=8) ? 1 : 0
       If validBMP(dummBMP)
       {
          If (applyVPfx>0)
             dummBMP := applyVPeffectsOnBMP(dummBMP)

          If (doCarving=1)
             carvePathFromBitmap(dummBMP, pPath, pB.x, pB.y, 4, fakeBGR)

          If (applyVPfx=2)
             flipBitmapAccordingToViewPort(dummBMP)
       } Else
       {
          addJournalEntry(A_ThisFunc "(): failed to clone bitmap: " whichBitmap)
          Gdip_DeletePath(pPath)
          Return
       }

       Gdip_DeletePath(pPath)
       Return dummBMP
    } Else addJournalEntry(A_ThisFunc "(): failed to create GDI+ object path")
}

MenuRotateEditImagePlus() {
   RotateEditedImage(90)
}

MenuRotateEditImageMinus() {
   RotateEditedImage(-90)
}

RotateEditedImage(modus:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    mergeViewPortRotationImgEditing()
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (!validBMP(whichBitmap) || thumbsDisplaying=1)
       Return

    If (viewportQPVimage.imgHandle)
    {
       HugeImagesCropResizeRotate(0, 0, "rotate" modus)
       Return
    }

    setImageLoading()
    dir := (modus=90) ? 1 : 3
    newBitmap := (preventUndoLevels=1) ? whichBitmap : trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
    r := Gdip_ImageRotateFlip(newBitmap, dir)
    If (validBMP(newBitmap) && !r)
    {
       wrapRecordUndoLevelNow(newBitmap)
       vpIMGrotation := 0
       SoundBeep 900, 100
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       showTOOLtip("Failed to rotate image")
       If (preventUndoLevels!=1)
          trGdip_DisposeImage(newBitmap, 1)
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    SetTimer, ResetImgLoadStatus, -125
}

CropImageInViewPortToSelection(modus:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    mergeViewPortRotationImgEditing()
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    If (!validBMP(whichBitmap) || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If (throwErrorSelectionOutsideBounds(whichBitmap) || testEntireImgSelected(0, 0, 1))
       Return

    If (viewportQPVimage.imgHandle)
    {
       trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
       imgSelX1 := Round(prcSelX1*imgW)
       imgSelY1 := Round(prcSelY1*imgH)
       imgSelX2 := Round(prcSelX2*imgW)
       imgSelY2 := Round(prcSelY2*imgH)
       nImgSelX1 := imgSelX1 := min(imgSelX1, imgSelX2)
       nImgSelY1 := imgSelY1 := min(imgSelY1, imgSelY2)
       nimgSelX2 := max(imgSelX1, imgSelX2)
       nimgSelY2 := max(imgSelY1, imgSelY2)
       ImgSelX1 := nImgSelX1,       ImgSelY1 := nImgSelY1
       ImgSelX2 := nimgSelX2,       ImgSelY2 := nimgSelY2
       vpWinClientSize(mainWidth, mainHeight)
       additionalHUDelements(3, mainWidth, mainHeight)
       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       If (imgSelW!=imgW || imgSelH!=imgH)
          HugeImagesCropResizeRotate(Round(x2), Round(y2), "crop", Round(x1), Round(y1), imgSelW, imgSelH)
       Return
    }

    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    mgpx := Round((imgW * imgH)/1000000, 1)
    calcImgSelection2bmp(1, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (modus!="simplex" && EllipseSelectMode=0 && isInRange(imgSelW, imgW - 2, imgW + 2) && isInRange(imgSelH, imgH - 2, imgH + 2) && !imgSelPx && !imgSelPy)
    {
       MouseMoveResponder()
       dummyTimerDelayiedImageDisplay(50)
       Return
    }

    newBitmap := getSelectedImageArea(whichBitmap, 1, 0, 0)
    If validBMP(newBitmap)
    {
       trGdip_GetImageDimensions(newBitmap, kw, kh)
       nmgpx := Round((kw * kh)/1000000, 1)
       diffu := max(nmgpx, mgpx) - min(nmgpx, mgpx)
       If (diffu>50)
          PrintPosX := "X"

       If (EllipseSelectMode>0 || VPselRotation>0 || X1<0 || Y1<0 || X2>imgW || Y2>ImgH) || (innerSelectionCavityX>0 && innerSelectionCavityY>0)
          currIMGdetails.HasAlpha := 1
      
       wrapRecordUndoLevelNow(newBitmap)
       If (modus!="simplex")
       {
          editingSelectionNow := vpIMGrotation := 0
          updateUIctrl()
          MouseMoveResponder()
          dummyTimerDelayiedImageDisplay(50)
          SetTimer, dummyInfoImgCropVP, -150
       }
    } Else
    {
       showTOOLtip("Failed to crop image to selected area")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    ResetImgLoadStatus()
}

dummyInfoImgCropVP() {
   trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW * imgH)/1000000, 2)
   showTOOLtip("Image canvas size set to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px | " Round(imgW/imgH, 2) " | " mpx " MPx" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

MenuPasteHDropFiles() {
   r := PasteHDropFiles(1)
   If !r
   {
      showTOOLtip("No image files identified in the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PasteHDropFiles(allowFilesPaste) {
   Try testClipTypeImgA := IsClipboardFormatAvailable(8)
   Try testClipTypeImgB := IsClipboardFormatAvailable(2)
   If (testClipTypeImgA=1 || testClipTypeImgB=1)
      Return

   Try testClipType := IsClipboardFormatAvailable(15)
   Try imgsListu := Clipboard
   If (testClipType!=1)
   {
      filesFound := 0
      Loop, Parse, imgsListu, `n,`r
      {
           If FileExist(Trimmer(A_LoopField))
              filesFound := 1
      } Until (A_Index>5)

      If (filesFound!=1)
      {
         ResetImgLoadStatus()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   If (testClipType=1 || filesFound=1) && (allowFilesPaste=0)
   {
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }

   countFiles := ST_Count(Trimmer(imgsListu), "`n")
   If (countFiles>0 && StrLen(imgsListu)>4)
   {
      showTOOLtip("Files identified in the clipboard")
      zpk := (maxFilesIndex>1) ? "Select newly inserted index entries" : ""
      msgResult := msgBoxWrapper(appTitle ": Paste files", "You have " countFiles " file entries stored in the clipboard by your file explorer or manager.`n`nWould you like to import the image files (if any) into the files list of " appTitle "?", 4, 0, "question", zpk)
   }

   If (InStr(msgResult.btn, "yes") || msgResult="yes")
   {
      initialIndex := maxFilesIndex
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir, msgResult.check)
      If (initialIndex!=maxFilesIndex)
      {
         currentFileIndex := maxFilesIndex - 1
         GenerateRandyList()
         dummyTimerDelayiedImageDisplay(50)
         ForceRefreshNowThumbsList()
         newFiles := max(initialIndex, maxFilesIndex) - min(initialIndex, maxFilesIndex)
         showTOOLtip("Finished adding " groupDigits(newFiles) " files to the current list from the clipboard")
      } Else showTOOLtip("No image files identified in the clipboard`nFiles list unchanged.")
   } Else RemoveTooltip()

   SetTimer, ResetImgLoadStatus, -100
   createGUItoolbar()
   SetTimer, TriggerMenuBarUpdate, -90
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return 1
}

rescaleFIMbmpGDIp(ByRef hFIFimgA, nw, nh) {
    If !hFIFimgA
       Return

    rescaled := 0
    thisQuality := (userimgQuality=1) ? 3 : 0
    FreeImage_GetImageDimensions(hFIFimgA, oImgW, oImgH)
    If (nw*1.25<oImgW || nh*1.25<oImgH)
    {
       rescaled := 1
       calcIMGdimensions(oImgW, oImgH, nw, nh, nw, nh)
       hFIFimgB := FreeImage_Rescale(hFIFimgA, nw, nh, thisQuality)
    } Else
       hFIFimgB := hFIFimgA

    If !hFIFimgB
    {
       FreeImage_UnLoad(hFIFimgA)
       hFIFimgA := ""
       Return
    }

    imgBPP := FreeImage_GetBPP(hFIFimgA)
    If (imgBPP!=32)
    {
       hFIFimgD := FreeImage_ConvertTo(hFIFimgB, "32Bits")
       If hFIFimgD
       {
          If (rescaled=1)
             FreeImage_UnLoad(hFIFimgB)

          hFIFimgB := hFIFimgD
          rescaled := 1
       }
    }

    If hFIFimgB
    {
       bpp := FreeImage_GetBPP(hFIFimgB)
       pBitmap := ConvertFIMtoPBITMAP(hFIFimgB)
       If (rescaled=1)
          FreeImage_UnLoad(hFIFimgB)

       If StrLen(pBitmap)>2
       {
          recordGdipBitmaps(pBitmap, A_ThisFunc)
          addJournalEntry(A_ThisFunc "(): YAY - rescaled FIM bitmap to screen. BPP = " bpp "|" rescaled)
       } Else
       {
          addJournalEntry(A_ThisFunc "(): Failed to convert to GDI+ the rescaled FIM bitmap to screen. BPP = " bpp "|" rescaled)
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := ""
       }
    } Else
    {
       addJournalEntry(A_ThisFunc "(): Failed to rescale FIM bitmap to screen.")
       FreeImage_UnLoad(hFIFimgA)
       hFIFimgA := ""
    }
    Return pBitmap
}

corePasteClipboardImg(modus, imgW, imgH, allowFilesPaste) {
    clipBMP := Gdip_CreateBitmapFromClipboard()
    If StrLen(clipBMP)>2
       recordGdipBitmaps(clipBMP, A_ThisFunc)

    If (isInRange(Abs(clipBMP), 1, 5) || !validBMP(clipBMP))
    {
       If PasteHDropFiles(allowFilesPaste)
          Return

       Try toPaste := Trimmer(Clipboard)
       If StrLen(toPaste)>2
       {
          textMode := 1
          toPaste := SubStr(toPaste, 1, 9500)
          clipBMP := drawTextInBox(toPaste, OSDFontName, PasteFntSize, imgW, imgH, OSDtextColor, OSDbgrColor, 0, 0, usrTextAlign, "0xFF")
          If (modus=1)
             showTOOLtip("Text clipboard content rendered as image`nOSD font and colors used")
          SetTimer, RemoveTooltip, % -msgDisplayTime
       } Else
       {
          Tooltip
          showTOOLtip("ERROR: Unable to retrieve image from clipboard")
          SetTimer, ResetImgLoadStatus, -25
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    }

    ; disposeCacheIMGs()
    If !validBMP(clipBMP)
       Return

    If (!InStr(Gdip_GetImagePixelFormat(clipBMP, 1), "0xE200") && coreDesiredPixFmt="0xE200B")
    {
       krpBmp := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
       If validBMP(krpBmp)
       {
          trGdip_DisposeImage(clipBMP, 1)
          clipBMP := krpBmp
       }
    }
    ; MsgBox, % Gdip_GetImagePixelFormat(clipBMP, 1)
    Return clipBMP
}

PasteClipboardIMG(modus:=0, clipBMP:=0) {
    Critical, on
    Static clippyCount := 0

    If (AnyWindowOpen>0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    ; If askAboutFileSave(" and the clipboard image or files entries are going to be pasted")
    ;    Return

    setImageLoading()
    changeMcursor()
    calcScreenLimits()
    imgPath := getIDimage(currentFileIndex)
    If (modus!="scanner")
    {
       showTOOLtip("Retrieving clipboard, please wait")
       If PasteHDropFiles(1)
       {
          ResetImgLoadStatus()
          SetTimer, RemoveTooltip, -500
          Return
       }

       clipBMP := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 1)
    }

    If !validBMP(clipBMP)
    {
       ResetImgLoadStatus()
       SetTimer, RemoveTooltip, -500
       Return
    }


    isImgOpen := 1
    If isImgEditingNow()
       isImgOpen := 2
    Else If (!currentFileIndex || !CurrentSLD || !maxFilesIndex || !imgPath)
       isImgOpen := 0

    If (viewportQPVimage.imgHandle)
    {
       If askAboutFileSave(" and the image from the clipboard will be pasted")
       {
          trGdip_DisposeImage(clipBMP)
          ResetImgLoadStatus()
          Return
       }

       discardSRCfileCaches()
       destroyGDIfileCache()
       discardViewPortCaches()
       disposeCacheIMGs()
       terminateIMGediting()
       isImgOpen := 1
    }

    clippyCount++
    If (editingSelectionNow=1)
       ToggleEditImgSelection()

    discardViewPortCaches()
    If (isImgOpen=0)
    {
       maxFilesIndex := currentFileIndex := 0
       labelu := (modus="scanner") ? "WIA-Acquired-" : "Clipboard-"
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\" labelu "-" clippyCount ".img"
    }

    zoomLevel := IMGresizingMode := 1
    If (modus!="scanner")
    {
       currIMGdetails.HasAlpha := 1
       isUniform := Gdip_TestBitmapUniformity(clipBMP, 7, maxLevelIndex)
       If (isUniform=1 && isInRange(maxLevelIndex, 252, 255))
          currIMGdetails.HasAlpha := 0
    } Else currIMGdetails.HasAlpha := 0

    ; ToolTip, % currIMGdetails.HasAlpha " = lol" , , , 2
    imgIndexEditing := currentFileIndex
    vpIMGrotation := FlipImgH := FlipImgV := 0
    currentImgModified := usrColorDepth := imgFxMode := 1
    INIaction(1, "FlipImgH", "General")
    INIaction(1, "FlipImgV", "General")
    INIaction(1, "usrColorDepth", "General")
    INIaction(1, "imgFxMode", "General")
    INIaction(1, "vpIMGrotation", "General")
    UserMemBMP := clipBMP
    If (isImgOpen=2)
       wrapRecordUndoLevelNow(clipBMP)
    Else 
       gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, clipBMP)

    defineColorDepth()
    dropFilesSelection(1)
    RemoveTooltip()
    dummyTimerDelayiedImageDisplay(5)
    SetTimer, createGUItoolbar, -100
    SetTimer, ResetImgLoadStatus, -55
    SetTimer, TriggerMenuBarUpdate, -95
}

thumbsSelector(keyu, aKey, prevFileIndex) {
  Static lastInvoked := 1

  ; ToolTip, % prevFileIndex "--" markedSelectFile 
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Upu" || keyu="Home") && prevFileIndex<=1)
  || (InStr(aKey, "+") && (keyu="Right" || keyu="Down" || keyu="End") && prevFileIndex>=maxFilesIndex)
     Return

  selA := resultedFilesList[currentFileIndex, 2]
  selB := resultedFilesList[prevFileIndex, 2]
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Right"))
  {
     testIndex := (keyu="Left") ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (keyu="Left") ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
        markedSelectFile++
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 1
     } Else If (selA=1 && selB=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 0
        markedSelectFile -= 2
     }

     markedSelectFile++
     lastZeitFileSelect := A_TickCount
  } Else If InStr(aKey, "+") ; && (keyu="Upu" || keyu="Down"))
  {
     direction := (keyu="Down" || keyu="PgDn" || keyu="End") ? 1 : 0
     testIndex := (direction!=1) ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (direction!=1) ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
        lastZeitFileSelect := A_TickCount
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 1)
        lastZeitFileSelect := A_TickCount
     } Else If (selA=1 && selB=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 0)
        resultedFilesList[currentFileIndex, 2] := 1
        lastZeitFileSelect := A_TickCount
        markedSelectFile++
     }
  }

  If (markedSelectFile=1 && InStr(aKey, "+"))
  {
     markedSelectFile := 0
     lastZeitFileSelect := A_TickCount
     resultedFilesList[currentFileIndex, 2] := 0
  }
}

generateNumberRangeString(pA, pB) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
        stringRange .= "," mA + A_Index - 1 "|"

    Return stringRange
}

selectFilesRange(pA, pB, sel) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
    {
        oSel := resultedFilesList[mA + A_Index - 1, 2]
        resultedFilesList[mA + A_Index - 1, 2] := sel
        If (sel=1 && oSel!=1)
           markedSelectFile++
        Else If (sel!=1 && oSel=1)
           markedSelectFile--
    }
    lastZeitFileSelect := A_TickCount
    Return rangeC
}


selectSeenFilesSession() {
    wasSelect := (markedSelectFile>2) ? 1 : 0
    Loop, % maxFilesIndex
    {
        imgPath := resultedFilesList[A_Index, 1]
        If userSeenSessionImagesArray[Format("{:L}", imgPath)]
           resultedFilesList[A_Index, 2] := 1
    }

    lastZeitFileSelect := A_TickCount
    getSelectedFiles(0, 1)
    dummyTimerReloadThisPicture(50)
    If (markedSelectFile>2 && wasSelect=0 && SLDtypeLoaded!=3 && !InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
    {
       msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " groupDigits(markedSelectFile) " files. Would you like to remove these index entries?", 4, 2, "question")
       If (msgResult="Yes")
          InListMultiEntriesRemover(0, "y")
    }
}

jumpSelectRangeGiven(pA, pB) {
   mB := max(pA, pB)
   mA := min(pA, pB)
   rangeC := mB - mA + 1
   changeMcursor()
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection. The given range is: " mA " - " mB, "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel" || InStr(msgResult, "win_close"))
      {
         SetTimer, RemoveTooltip, -250
         Return
      }
   }

   If (msgResult="replace" || !msgResult)
   {
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   Loop, % rangeC
      resultedFilesList[mA + A_Index - 1, 2] := (msgResult="add" || !msgResult) ? 1 : 0

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ResetImgLoadStatus()
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   Return rangeC
}

ThumbsNavigator(keyu, aKey) {
  resetSlideshowTimer()
  If (thumbsDisplaying!=1 && maxFilesIndex>1)
  {
     If askAboutFileSave(" and another image will be loaded")
        Return
  }

  prevFileIndex := currentFileIndex
  thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
  If (keyu="Down")
  {
     currentFileIndex := currentFileIndex + maxItemsW - 1
     NextPicture(0, 1)
  } Else If (keyu="Upu")
  {
     currentFileIndex := currentFileIndex - maxItemsW + 1
     PreviousPicture(0, 1)
  } Else If (keyu="PgUp")
  {
     currentFileIndex := currentFileIndex - maxItemsPage + 1
     PreviousPicture()
  } Else If (keyu="PgDn")
  {
     Loop, % maxItemsH
     {
        currentFileIndex := currentFileIndex + maxItemsW - 1
        NextPicture(0, 1)
        thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
     }
     ; currentFileIndex := currentFileIndex + maxItemsPage - 1
     ; NextPicture()
  } Else If (keyu="Left")
     PreviousPicture()
  Else If (keyu="Right")
     NextPicture()
  Else If (keyu="End")
     LastPicture()
  Else If (keyu="Home")
     FirstPicture()

  thumbsSelector(keyu, aKey, prevFileIndex)
  If (thumbsDisplaying!=1 && InStr(aKey, "+"))
     dummyTimerDelayiedImageDisplay(50)
}

PanIMGonScreen(direction, thisKey) {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (toolTipGuiCreated=2)
      RemoveTooltip()

   If (slideShowRunning=1)
      ToggleSlideShowu()

   vpWinClientSize(mainWidth, mainHeight)
   fastMode := (InStr(thisKey, "+") || InStr(thisKey, "-/")) ? 1 : 0
   If (fastMode=1)
      zL := clampInRange(zoomLevel, 0.8, 3.2)
   Else
      zL := clampInRange(zoomLevel, 0.7, 2.1)

   stepu := InStr(thisKey, "+") ? 0.35 * zL : 0.1 * zL
   stepu := Round(mainHeight*stepu + mainWidth*stepu)//2 + 1
   If (thisKey="-")
      stepu := stepu//2 + 1

   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY + stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX + stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX - stepu

   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      diffIMGdecY := stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      diffIMGdecY := - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      diffIMGdecX := stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      diffIMGdecX := - stepu

   If (thisKey!="-")
   {
      If (editingSelectionNow=1)
         MouseMoveResponder("rem")
      dummyTimerDelayiedImageDisplay(5)
   }

   Return 1
}

dummyTimerDelayiedImageDisplay(timeru:=0) {
  If (timeru>1)
     SetTimer, extraDummyDelayiedImageDisplay, % -timeru ; , 950
}

extraDummyDelayiedImageDisplay() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -15
     Return
  }
  DelayiedImageDisplay()
}

filterDelayiedImageDisplay() {
  Static lastInvoked := 1
  If (A_tickcount - lastInvoked < 60)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -50
     Return
  }
  lastInvoked := A_TickCount
  DelayiedImageDisplay()
  lastInvoked := A_TickCount
}

DelayiedImageDisplay() {
   If ((CurrentSLD && maxFilesIndex>0) || validBMP(UserMemBMP))
   {
      r := IDshowImage(currentFileIndex)
      If !r
         informUserFileMissing(1)
   }
}

DonateNow() {
   Try Run, https://www.paypal.me/MariusSucan/10
}

openSettingsDir() {
   Try Run, % mainCompiledPath
}

DeleteAllSettings() {
    SoundBeep, 300, 300
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete ALL personalized settings?`n`n" appTitle " will automatically restart if you choose to do so. This action is irreversible.", "&Restore defaults|&Cancel", 2, "exclamation")
    If (msgResult="restore defaults")
    {
       RegDelete, % QPVregEntry "\PanelOptions"
       FileSetAttrib, -R, % mainSettingsFile
       FileDelete, % mainSettingsFile
       terminateIMGediting()
       restartAppu()
    }
}

externalinvokedSettingsContextMenu(keyu:=0, simulated:=0) {
    Static listu := {3:1,2:1,60:1,3:1,2:1,48:1,59:1,60:1,39:1,71:1}
    hwndA := WinActive("ahk_id " hSetWinGui)
    hwndB := WinActive("ahk_id " MsgBox2hwnd)
    hwnd := ((hwndA=hSetWinGui || hwndB=MsgBox2hwnd) && AnyWindowOpen) ? 1 : 0
    If (hwnd!=1)
       Return 0

    If (AnyWindowOpen && MsgBox2hwnd=hwndB && hwndB && MsgBox2InputHook)
       GuiControlGet, OutputVar, WinMsgBox: Focus
    Else If AnyWindowOpen
       GuiControlGet, OutputVar, SettingsGUIA: Focus
    ; ToolTip, % OutputVar , , , 2
    If (!InStr(OutputVar, "listview") && keyu="enter")
       Return 0

    If (simulated=1 && listu[AnyWindowOpen]=1)
       Return 1

    If (AnyWindowOpen=3 && inStr(keyu, "appskey"))
       invokePanelDynaFoldersContextMenu()
    Else If (AnyWindowOpen=2 && inStr(keyu, "appskey"))
       invokePanelStaticFoldersContextMenu()
    Else If (AnyWindowOpen=60 && inStr(keyu, "appskey"))
       invokePanelReviewSelContextMenu()
    Else If ((AnyWindowOpen=3 || AnyWindowOpen=2) && inStr(keyu, "enter"))
       BtnPanelStaticJumpFirst()
    Else If ((AnyWindowOpen=48 || AnyWindowOpen=59) && inStr(keyu, "enter"))
       IndexStatsLVaction(0, "DoubleClick")
    Else If (AnyWindowOpen=60 && inStr(keyu, "enter"))
       uiLVreviewSelFilesResponder("menu-mode", "DoubleClick", 0)
    Else If (AnyWindowOpen=39 && inStr(keyu, "enter"))
       SeenStatsLVaction(hwnd, "DoubleClick")
    Else If (AnyWindowOpen=71 && inStr(keyu, "enter"))
       uiLVkeywordsListResponder(hwnd, "RightClick", "enter")
    Else If (AnyWindowOpen && inStr(keyu, "AppsKey"))
       invokePrefsPanelsContextMenu()
}

SettingsGUIAGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1

    If (GuiHwnd!=hSetWinGui)
       Return

    If (AnyWindowOpen=3 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelDynaFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen=2 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelStaticFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen=60 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelReviewSelContextMenu()
       Return
    } Else If (AnyWindowOpen && !InStr(A_GuiControl, "lview") && IsRightClick=1) 
    {
       If SettingsToolTips()
          Return
    }

    If (CtrlHwnd && IsRightClick=1) || ((A_TickCount - lastInvoked>250) && IsRightClick=0) ; || (mouseToolTipWinCreated=1)
    {
       lastInvoked := A_TickCount
       Return
    }

    lastInvoked := A_TickCount
    invokePrefsPanelsContextMenu()
    Return
}

MenuRestoreAnyContextDefaultKBD() {
   MenuRestoreDefaultKBD("all")
   k := defineKBDcontexts(2)
   showTOOLtip("Any custom key binding associated with the selected function was removed")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

MenuDisableKbdShortcut() {
    Gui, QuickMenuSearchGUIA: Default
    Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
    RowNumber := LV_GetFirstSelected(hLVquickSearchMenus)
    If !RowNumber
       RowNumber := LV_GetNext(0, "F")

    LV_GetText(menuName, RowNumber, 1)
    LV_GetText(oshortcut, RowNumber, 3)
    LV_GetText(menuLocation, RowNumber, 4)
    LV_GetText(funcu, RowNumber, 6)
    LV_GetText(kwds, RowNumber, 5)
    posu := InStr(kwds, sillySeparator)
    If (oshortcut="" && !posu)
    {
       showTOOLtip("WARNING: No keyboard shortcut is associated with the selected option:`n" menuName)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    c := defineKBDcontexts(0)
    shortcut := processHumanKkbdName(oshortcut)
    defaultHotKateRaw := posu ? SubStr(kwds, posu + 1) : shortcut
    txtLine := sillySeparator "?" funcu sillySeparator menuName sillySeparator menuLocation sillySeparator c sillySeparator defaultHotKateRaw
    cshortcut := c shortcut
    If ((SubStr(userCustomKeysDefined[cshortcut, 1], 1, 1)="?")
    || (SubStr(userCustomKeysDefined[c . defaultHotKateRaw, 1], 1, 1)="?" && defaultHotKateRaw && posu && shortcut=""))
    {
       showTOOLtip("WARNING: The keyboard shortcut is already disabled")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    } Else If (userCustomKeysDefined[cshortcut, 1]="?2")
    {
       pk := userCustomKeysDefined[cshortcut, 2]
       showTOOLtip("WARNING: This keyboard shortcut is already replaced with: " pk "`n" userCustomKeysDefined[pk, 2])
       SoundBeep , 300, 100
       Settimer, RemoveTooltip, % -msgDisplayTime
       Return
    } Else If (IsFunc(userCustomKeysDefined[cshortcut, 1]) && shortcut!="")
    {
       closeQuickSearch()
       oldShortcut := userCustomKeysDefined[cshortcut, 5]
       humanKbd := sillySeparator processKkbdNameToHuman(oldShortcut)
       newLine := (oldShortcut!="") ? oldShortcut txtLine humanKbd : ""
       defaultu := processDefaultKbdCombos(shortcut, PVhwnd, 0, PVhwnd, 1)
       If StrLen(defaultu[1])>2
          bonusLine := (oldShortcut!=shortcut) ? shortcut sillySeparator "?_generic" sillySeparator "ALL" sillySeparator "\ANYWHERE" sillySeparator c sillySeparator shortcut sillySeparator oshortcut : ""
   
       r := updateCustomUserKbds(newLine, userCustomKeysDefined[cshortcut, 7], 0, bonusLine)
       If !r
       {
          showTOOLtip("ERROR: Failed to update the custom keyboard settings file")
          SoundBeep 300, 100
          Settimer, RemoveTooltip, % -msgDisplayTime
       }
       Sleep, 5
       loadCustomUserKbds()
       PanelQuickSearchMenuOptions()
       Return
    }

    closeQuickSearch()
    If (shortcut!="")
    {
       humanKbd := sillySeparator processKkbdNameToHuman(shortcut)
       FileAppend, % shortcut txtLine humanKbd "`n", % customKbdFile, UTF-8
       Sleep, 5
       loadCustomUserKbds()
    }

    PanelQuickSearchMenuOptions()
}

MenuRestoreDefaultKBD(modus:=0) {
    Gui, QuickMenuSearchGUIA: Default
    Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
    RowNumber := LV_GetFirstSelected(hLVquickSearchMenus)
    If !RowNumber
       RowNumber := LV_GetNext(0, "F")

    LV_GetText(funcu, RowNumber, 6)
    LV_GetText(kwds, RowNumber, 5)
    LV_GetText(shortcut, RowNumber, 3)
    posu := InStr(kwds, sillySeparator)
    If (posu && shortcut="")
       HotKateRaw := SubStr(kwds, posu + 1)

    r := restoreDefaultCustomUserKbds(HotKateRaw, funcu, defineKBDcontexts(0), modus)
    If !r
    {
       showTOOLtip("ERROR: Failed to update the custom keyboard settings file")
       SoundBeep 300, 100
       Settimer, RemoveTooltip, % -msgDisplayTime
    }

    loadCustomUserKbds()
    Sleep, 5
    closeQuickSearch()
    PanelQuickSearchMenuOptions()
}

processHumanKkbdName(shortcut, ByRef obju:=0) {
    Static humanlistu := {0:"00.1","PageUp":"PGUP","PageDown":"PGDN","-":"MINUS","=":"EQUAL","[":"LBRACKET","]":"RBRACKET","\":"BSLASH","/":"SLASH",";":"COLON",",":"COMMA",".":"PERIOD","""":"QUOTES","Numpad+":"NumpadAdd","Numpad-":"NumpadSub","Numpad*":"NumpadMult","Numpad/":"NumpadDiv","Numpad.":"NumpadDot","Esc":"Escape","``":"TILDA"}
    obju := []
    shortcut := Trimmer(StrReplace(shortcut, A_Space))
    shortcut := StrReplace(shortcut, "numpad+", "NumpadAdd")
    If InStr(shortcut, "+")
       shortcut := StrReplace(shortcut, "+", "®")

    If InStr(shortcut, "shift®")
    {
       shortcut := StrReplace(shortcut, "shift®")
       nsh .= "+"
    }

    If InStr(shortcut, "ctrl®")
    {
       shortcut := StrReplace(shortcut, "ctrl®")
       nsh .=  "^"
    }

    If InStr(shortcut, "alt®")
    {
       shortcut := StrReplace(shortcut, "alt®")
       nsh .= "!"
    }
 
    shortcut := StrReplace(shortcut, "®")
    shortcut := StrReplace(shortcut, "NumpadAdd", "Numpad+")
    nraw := StrReplace(shortcut, "Page", "Page ")
    obju.r := StrReplace(nraw, "Numpad", "Numpad ")
    shortcut := humanlistu[shortcut] ? humanlistu[shortcut] : shortcut
    obju.p := nsh
    obju.s := shortcut
    Return nsh shortcut
}

processKkbdNameToHuman(shortcut) {
    Static humanlistu := {"00.1":"0","PGUP":"Page Up","PGDN":"Page Down","MINUS":"-","EQUAL":"=","LBRACKET":"[","RBRACKET":"]","BSLASH":"\","SLASH":"/","COLON":";","COMMA":",","PERIOD":".","QUOTES":"""","NumpadAdd":"Numpad +","NumpadSub":"Numpad -","NumpadMult":"Numpad *","NumpadDiv":"Numpad /","NumpadDot":"Numpad .","TILDA":"``"}
    p := ""
    If InStr(shortcut, "^")
    {
       shortcut := StrReplace(shortcut, "^")
       p .= "Ctrl+"
    }

    If InStr(shortcut, "!")
    {
       shortcut := StrReplace(shortcut, "!")
       p .=  "Alt+"
    }

    If InStr(shortcut, "+")
    {
       shortcut := StrReplace(shortcut, "+")
       p .= "Shift+"
    }

    shortcut := humanlistu[shortcut] ? humanlistu[shortcut] : shortcut
    Return p shortcut
}

BtnApplyNewKbdShortcut() {
    Static humanlistu := {0:"00.1","PageUp":"PGUP","PageDown":"PGDN","-":"MINUS","=":"EQUAL","[":"LBRACKET","]":"RBRACKET","\":"BSLASH","/":"SLASH",";":"COLON",",":"COMMA",".":"PERIOD","""":"QUOTES","Numpad+":"NumpadAdd","Numpad-":"NumpadSub","Numpad*":"NumpadMult","Numpad/":"NumpadDiv","Numpad.":"NumpadDot","Esc":"Escape","``":"TILDA"}

    Gui, customKbdGUIA: Default
    GuiControlGet, BtnModsCtrl
    GuiControlGet, BtnModsAlt
    GuiControlGet, BtnModsShift
    GuiControlGet, tehCustomKeysThing
    GuiControlGet, txtline2 ; menu item details
    GuiControlGet, txtline3 ; previous keyboard shortcut
    GuiControlGet, txtline4 ; default keyboard shortcut

    GuiControlGet, hwnd, hwnd, tehCustomKeysThing
    ControlGetText, info,, ahk_id %hwnd%
    If (info="(None)")
    {
       showTOOLtip("WARNING: No keyboard shortcut is defined.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    } Else If (info="escape" && (BtnModsShift=0 && BtnModsAlt=0 && BtnModsCtrl=0 || BtnModsShift=1 && BtnModsAlt=1 && BtnModsCtrl=1 || BtnModsShift=0 && BtnModsAlt=0 && BtnModsCtrl=1))
    {
       showTOOLtip("WARNING: Illegal shortcut defined.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    } Else If (isInRange(tehCustomKeysThing, 79, 89) && InStr(info, "numpad") && BtnModsShift=1)
    {
       showTOOLtip("WARNING: Numpad digits with Shift are not supported.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    CloseKbdDefinePanel()
    If (info="Esc")
       info := StrReplace(info, "Esc", "Escape")

    Sleep, 1
    If (BtnModsShift=1)
       nsh .= "+"
    If (BtnModsCtrl=1)
       nsh .= "^"
    If (BtnModsAlt=1)
       nsh .= "!"

    humanKbd := StrReplace(nsh, "+", "Shift+")
    humanKbd := StrReplace(humanKbd, "^", "Ctrl+")
    humanKbd := StrReplace(humanKbd, "!", "Alt+")
    humanKbd .= info
    info := StrReplace(info, A_Space)
    infok := (humanlistu[info]!="") ? humanlistu[info] : info

    c := defineKBDcontexts(0)
    shortcut := nsh infok
    cshortcut := c shortcut
    finalu := shortcut sillySeparator txtline2 sillySeparator txtLine4 sillySeparator humanKbd
    If Trimmer(txtLine3)
    {
       ; delete user previously defined key for the selected menu item
       reupdate := 1
       updateCustomUserKbds("`n", userCustomKeysDefined[c . txtline3, 7])
    }

    If (SubStr(userCustomKeysDefined[c . txtLine4, 1], 1, 1)="?")
    {
       ; if default keyboard is disabled, remove the binding
       reupdate := 1
       updateCustomUserKbds("`n", userCustomKeysDefined[c . txtline4, 7])
    }

    If (reupdate=1)
       loadCustomUserKbds()

    If (shortcut=txtLine4 && txtLine4!="")
    {
       ; avoid assigning the default keyboard shortcut as a custom one
       PanelQuickSearchMenuOptions()
       Return
    }

    ; fnOutputDebug(userCustomKeysDefined[cshortcut, 7] "===" finalu )
    If (SubStr(userCustomKeysDefined[cshortcut, 1], 1, 1)="?")
    {
       pk := StrSplit(finalu, sillySeparator)
       updateCustomUserKbds(finalu, userCustomKeysDefined[cshortcut, 7], 0, bonusLine)
       Sleep, 5
       loadCustomUserKbds()
       PanelQuickSearchMenuOptions()
       Return
    } Else If IsFunc(userCustomKeysDefined[cshortcut, 1])
    {
       ; ask about keyboard keys conflict ? nah, too lazy
       pk := StrSplit(finalu, sillySeparator)
       ; fnOutputDebug(pk[2] "|" userCustomKeysDefined["." pk[2], 3])
       If (SubStr(userCustomKeysDefined[c "." pk[2], 1], 1, 1)="?")
       {
          SoundBeep 900, 200
          pk[6] := userCustomKeysDefined[c "." pk[2], 5]
          bonusRem := userCustomKeysDefined[c "." pk[2], 7]
       } Else
       {
          pk[6] := txtLine4 ; the default
       }

       If (userCustomKeysDefined[cshortcut, 5]!="" && userCustomKeysDefined[cshortcut, 5]!=userCustomKeysDefined["." pk, 8])
       {
          humanKbd := sillySeparator processKkbdNameToHuman(userCustomKeysDefined[cshortcut, 5])
          bonusLine := userCustomKeysDefined[cshortcut, 5] sillySeparator "?" userCustomKeysDefined[cshortcut, 1] sillySeparator userCustomKeysDefined[cshortcut, 2] sillySeparator userCustomKeysDefined[cshortcut, 3] sillySeparator c sillySeparator userCustomKeysDefined[cshortcut, 5] humanKbd
       }

       lineRem := userCustomKeysDefined[cshortcut, 7]
       updateCustomUserKbds(pk, lineRem, bonusRem, bonusLine)
       Sleep, 5
       loadCustomUserKbds()
       PanelQuickSearchMenuOptions()
       Return
    }

    ; ToolTip, % finalu , , , 2
    FileAppend, % finalu "`n", % customKbdFile, UTF-8
    Sleep, 5
    loadCustomUserKbds()
    PanelQuickSearchMenuOptions()
}

BtnDisableKbdDefine() {
   CloseKbdDefinePanel()
   Sleep, 1
   MenuDisableKbdShortcut()
}

BtnRestoreKbdDefine() {
   CloseKbdDefinePanel()
   Sleep, 1
   MenuRestoreDefaultKBD()
}

BtnCloseKbdDefine() {
   CloseKbdDefinePanel()
   Sleep, 1
   PanelQuickSearchMenuOptions()
}

CloseKbdDefinePanel() {
    Global lastOtherWinClose := A_TickCount
    uiPanelOpenCloseEvent(1)

    WinSet, Enable,, ahk_id %PVhwnd%
    WinSet, Enable,, ahk_id %hQuickMenuSearchWin%
    If AnyWindowOpen
       WinSet, Enable,, ahk_id %hSetWinGui%

    Sleep, 1
    Gui, customKbdGUIA: Destroy
    hKbdGuia := ""
    If (ShowAdvToolbar=1 && hQPVtoolbar)
       WinSet, Enable,, ahk_id %hQPVtoolbar%
    If (folderTreeWinOpen=1 && hfdTreeWinGui)
       WinSet, Enable,, ahk_id %hfdTreeWinGui%

    Sleep, 1
}

defineKBDcontexts(humanMode) {
   Static lastInvoked := 1, lastState
   Static lp := {5:"Vector shape drawing", 4:"Paint brush tools", 3:"Live image editor tools", 2:"Image view / welcome screen", 1:"Files list/thumbnails mode", 100:"Unknown"}

   If (humanMode=2)
   {
      Return lp.Count()
   } Else If (humanMode=3)
   {
      lis := ""
      Loop, % lp.Count()
         lis .= lp[A_Index] "|"
      Return Trim(lis, "|")
   }

   If ((A_TickCount - lastInvoked < 100) && (humanMode=0))
      Return lastState

   pk := isImgEditingNow()
   isVectorMode := (pk=1 && drawingShapeNow=1 && editingSelectionNow=1 && EllipseSelectMode=2) ? 1 : 0
   isWelcomeScreenu := (pk=1 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
   isAlphaPainting := isNowAlphaPainting()
   paintModus := (isAlphaPainting=1 || liveDrawingBrushTool=1 && AnyWindowOpen=64 && imgEditPanelOpened=1 && pk=1) ? 1 : 0
   liveEdit := (pk=1 && imgEditPanelOpened=1 && AnyWindowOpen>0) ? 1 : 0
   ; isTransPanel := (liveEdit=1 && (AnyWindowOpen=31 || AnyWindowOpen=24)) ? 1 : 0
   isThumbs := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD) ? 1 : 0

   rz := 100
   If (isVectorMode=1)
      rz := 5
   Else If (isAlphaPainting=1 || paintModus=1)
      rz := 4
   Else If (liveEdit=1)
      rz := 3
   Else If (pk=1 || isWelcomeScreenu) ; image view
      rz := 2
   Else If (isThumbs=1)
      rz := 1

   lastState := rz
   lastInvoked := A_TickCount
   If (humanMode=1)
      Return lp[rz]
   Else
      Return rz
}

testCustomKBDcontexts(givenKey) {
   r := defineKBDcontexts(0)
   If StrLen(userCustomKeysDefined[r . givenKey, 1])>0
      Return r givenKey
}

DragCollapsedWidget() {
   GetPhysicalCursorPos(oX, oY)
   WinGetPos, winX, winY,,, ahk_id %hCollapseWidget%
   Dx := Dy := 0
   lastInvoked := A_TickCount
   ; ToolTip, % "l=" thisZL , , , 2
   setWhileLoopExec(1)
   While, (determineLClickState()=1)
   {
      GetPhysicalCursorPos(mX, mY)
      ; ToolTip, % mX "|" mY , , , 2
      Dx := mX - oX
      Dy := mY - oY
      WinMove, ahk_id %hCollapseWidget%, , % winX + Dx, % winY + Dy
      Sleep, -1
   }
   setWhileLoopExec(0)
   Sleep, 2
   WinActivate, ahk_id %PVhwnd%
}

collapseWidgetGUIAGuiClose:
   If (AnyWindowOpen && panelWinCollapsed=1)
      toggleImgEditPanelWindow()
Return

collapseWidgetGUIAGuiEscape:
   WinActivate, ahk_id %PVhwnd%
Return

CreateCollapsedPanelWidget(modus:=0) {
    Static lastState := -1
    If (modus="kill")
    {
       Gui, collapseWidgetGUIA: Destroy
       lastState := ""
       Return
    }

    thisState := "a" uiUseDarkMode ToolbarScaleFactor PrefsLargeFonts colorPickerModeNow mustCaptureCloneBrush
    If (thisState=lastState)
       Return

    Gui, collapseWidgetGUIA: Destroy
    Sleep, 2
    Gui, collapseWidgetGUIA: Default
    Gui, collapseWidgetGUIA: -DPIScale +Border -MaximizeBox -MinimizeBox -SysMenu +hwndhCollapseWidget +Owner%PVhwnd% -Caption
    Gui, collapseWidgetGUIA: Margin, 1, 1
    If (uiUseDarkMode=1)
    {
       Gui, Color, 303030,303030
       ; Gui, Color, % darkWindowColor, % darkWindowColor
       Gui, Font, c%darkControlColor%
       setDarkWinAttribs(hCollapseWidget)
    }

    ; WinSet, Transparent, 195, ahk_id %hCollapseWidget%
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    ToolBarBtnWidth := Round(OSDfontSize*1.5 * ToolbarScaleFactor)
    w := h := ToolBarBtnWidth
    ww := Round(15*ToolbarScaleFactor)
    pk := (uiUseDarkMode=1) ? "" : "-dark"
    pp := mainExecPath "\resources\toolbar\"
    ; w := (PrefsLargeFonts=1) ? 64 : 58
    Gui, Add, Picture, x1 y1 w%ww% h%h% +Border Center +0x200 gDragCollapsedWidget +hwndhTemp, % mainExecPath "\resources\toolbar\dragger.png"
    ToolTip2ctrl(hTemp, "Click and drag to reposition this widget")
    GuiAddButton("x+2 yp w" w " hp gtoggleImgEditPanelWindow", pp "triangle-down" pk ".png", "Show tool panel. F11", "Show panel for the current tool [F11]", "collapseWidgetGUIA")
    If (mustCaptureCloneBrush!=1 && colorPickerModeNow!=1)
    {
       GuiAddButton("x+2 yp wp hp gPanelQuickSearchMenuOptions", pp "loupe" pk ".png", "Quick search panel options. Semi-colon", "Quick search menu options [ `; ]", "collapseWidgetGUIA")
       GuiAddButton("x+2 yp wp hp gtoggleAppToolbar", pp "toolbar" pk ".png", "Toggle toolbar. Shift+F10", "Toggle toolbar [Shift+F10]", "collapseWidgetGUIA")
       GuiAddButton("x+2 yp wp hp gToggleMenuBaru", pp "menu" pk ".png", "Toggle menu bar. F10", "Toggle menu bar [F10]", "collapseWidgetGUIA")
       GuiAddButton("x+2 yp wp hp gBtnCloseWindow", pp "cancel-tool.png", "Cancel tool and close panel. Escape", "Close / cancel current tool [Esc]", "collapseWidgetGUIA")
    }
    lastState := thisState
}

PanelDefineKbdShortcut() {
    Static keyzList := "0|1|2|3|4|5|6|7|8|9|0|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|F1|F2|F3|F4|F5|F6|F7|F8|F9|F10|F11|F12|Tab|Space|Enter|Backspace|Delete|Insert|Home|End|Page up|Page down|Left|Right|Up |Down|-|=|[|]|\|/|;|,|.|""|Numpad +|Numpad -|Numpad *|Numpad /|Numpad .|Numpad 0|Numpad 1|Numpad 2|Numpad 3|Numpad 4|Numpad 5|Numpad 6|Numpad 7|Numpad 8|Numpad 9|Escape"
    Global BtnModsCtrl, BtnModsAlt, BtnModsShift, tehCustomKeysThing
    If (allowCustomKeys!=1)
    {
       msgResult := msgBoxWrapper(appTitle ": Confirmation", "To customize the selected keyboard shortcut, the option to allow custom user defined keyboard shortcuts must be activated. Would you like to activate it now?", 4, 0, "question")
       If (msgResult="Yes")
       {
          ToggleCustomKBDsMode()
          PanelQuickSearchMenuOptions()
          SetTimer, PanelDefineKbdShortcut, -100
          Return
       } Else Return
    }

    Gui, QuickMenuSearchGUIA: Default
    Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
    ; [func, menu-name, menu-location, kbd-human, context-id, original-default-kbd]
    RowNumber := LV_GetFirstSelected(hLVquickSearchMenus)
    If !RowNumber
       RowNumber := LV_GetNext(0, "F")

    LV_GetText(menuName, RowNumber, 1)
    LV_GetText(shortcut, RowNumber, 3)
    LV_GetText(menuLocation, RowNumber, 4)
    LV_GetText(kwds, RowNumber, 5)
    LV_GetText(funcu, RowNumber, 6)
    If (!funcu || !RowNumber)
       Return

    lastZeitOpenWin := A_TickCount
    thisBtnHeight := (PrefsLargeFonts=1) ? 34 : 24
    setLVrowsCount()
    mouseTurnOFFtooltip()
    ; closeQuickSearch()
    contextID := defineKBDcontexts(0)
    contextu := defineKBDcontexts(1)
    WinSet, Disable,, ahk_id %PVhwnd%
    If AnyWindowOpen
       WinSet, Disable,, ahk_id %hSetWinGui%
    If VisibleQuickMenuSearchWin
       WinSet, Disable,, ahk_id %hQuickMenuSearchWin%
    If (ShowAdvToolbar=1 && hQPVtoolbar)
       WinSet, Disable,, ahk_id %hQPVtoolbar%
    If (folderTreeWinOpen=1 && hfdTreeWinGui)
       WinSet, Disable,, ahk_id %hfdTreeWinGui%

    Gui, customKbdGUIA: Destroy
    Sleep, 110
    Gui, customKbdGUIA: Default
    Gui, customKbdGUIA: +Border -MaximizeBox -MinimizeBox +Owner%PVhwnd% +hwndhKbdGuia
    Gui, customKbdGUIA: Margin, 15, 15
    If (uiUseDarkMode=1)
    {
       Gui, Color, % darkWindowColor, % darkWindowColor
       Gui, Font, c%darkControlColor%
       setDarkWinAttribs(hKbdGui)
    }

    btnWid := 45
    lstWid := 105
    txtWid := 242
    If (PrefsLargeFonts=1)
    {
       btnWid +=30
       lstWid += 70
       txtWid += 157
       Gui, Font, s%LargeUIfontValue%
       Gui, Font, Bold Q4
    }
 
    If !menuLocation
       menuLocation := "QPVmenu"
 
    HotKateRaw := processHumanKkbdName(shortcut, obju)
    pp := isFunc(userCustomKeysDefined[contextID HotKateRaw, 1]) ? HotKateRaw : ""
    defaultHotKateRaw := (posu := InStr(kwds, sillySeparator)) ? SubStr(kwds, posu + 1) : HotKateRaw
    If (defaultHotKateRaw=pp && !posu)
       defaultHotKateRaw := ""

    combosDarkModus := (uiUseDarkMode=1) ? "-theme -border " : ""
    reused := "x+0 +0x1000 w" btnWid " hp "
    Gui, Add, Text, x15 y15 w%txtWid% Section, Please configure the shortcut for:
    GuiAddEdit("y+5 wp ReadOnly r1 -wrap -multi vtxtLine1", menuName " | " menuLocation, "Menu item selected", "customKbdGUIA")
    GuiAddEdit("y+1 w1 h1 ReadOnly -wrap -multi vtxtLine2", funcu sillySeparator menuName sillySeparator menuLocation sillySeparator contextID, 0, "customKbdGUIA")
    GuiAddEdit("x+1 wp hp ReadOnly -wrap -multi vtxtLine3", pp, 0, "customKbdGUIA") ; user defined key to be deleted if user applies
    GuiAddEdit("x+1 wp hp ReadOnly -wrap -multi vtxtLine4", defaultHotKateRaw, 0, "customKbdGUIA")

    modsC := InStr(HotKateRaw, "^") ? 1 : 0
    modsS := InStr(HotKateRaw, "+") ? 1 : 0
    modsA := InStr(HotKateRaw, "!") ? 1 : 0
    ComboChoice := (obju.r!="") ? obju.r : "(None)"
    GuiAddDropDownList("xs y+10 w" lstWid " AltSubmit vtehCustomKeysThing", ComboChoice "||" keyzList, "Key", "", "customKbdGUIA")
    Gui, Add, Checkbox, % reused " Checked" modsC " vBtnModsCtrl", Ctrl
    Gui, Add, Checkbox, % reused " Checked" modsA " vBtnModsAlt", Alt
    Gui, Add, Checkbox, % reused " Checked" modsS " vBtnModsShift", Shift
    Gui, Add, Text, xs y+10 w%txtWid% Section +TabStop gbtnHelpKbdContexts, The newly defined shortcut will apply only to:`n%contextu%
 
    Gui, Add, Button, xs y+15 w80 h%thisBtnHeight% Default gBtnApplyNewKbdShortcut, &Apply
    Gui, Add, Button, x+5 wp+5 hp gBtnRestoreKbdDefine, &Restore
    Gui, Add, Button, x+5 wp hp gBtnDisableKbdDefine, &Disable
    Gui, Add, Button, x+5 wp hp gBtnCloseKbdDefine, &Cancel
    GuiControl, Focus, tehCustomKeysThing
    repositionWindowCenter("customKbdGUIA", hKbdGuia, PVhwnd, "Set new keyboard shortcut: " appTitle)
}

GuiAddEdit(options, defaultu, labelu:="", guiu:="SettingsGUIA") {
    If labelu
    {
       posu := ""
       nopt := A_Space options
       Loop, Parse, % "xywh"
       {
          px := A_LoopField ? InStr(" " options, " " A_LoopField) : 0
          k := InStr(options, " ", 0, px + 1) - px
          If (px && k)
          {
             t := SubStr(options, px, k)
             posu .= t " "
             nopt := StrReplace(nopt, A_Space t A_Space, A_Space)
          }
          ; fnOutputDebug(A_LoopField "|" posu "|" px "|" k "|" t "|" nopt)
       }

       Gui, %guiu%: Add, Text, % posu " +BackgroundTrans +hide -wrap", % labelu
       Gui, %guiu%: Add, Edit, % " xp yp wp " nopt " +hwndhTemp", % defaultu
       EM_SETCUEBANNER(hTemp, labelu, 1)
       ToolTip2ctrl(hTemp, labelu)
    } Else
       Gui, %guiu%: Add, Edit, % options " +hwndhTemp", % defaultu

    Return hTemp
}

GuiAddDropDownList(options, listu, labelu:="", tipu:="", guiu:="SettingsGUIA") {
    If (labelu && !IsObject(labelu))
    {
       posu := ""
       nopt := A_Space options
       Loop, Parse, % "xywh"
       {
          px := A_LoopField ? InStr(" " options, " " A_LoopField) : 0
          k := InStr(options, " ", 0, px + 1) - px
          If (px && k)
          {
             t := SubStr(options, px, k)
             posu .= t " "
             nopt := StrReplace(nopt, A_Space t A_Space, A_Space)
          }
          ; fnOutputDebug(A_LoopField "|" posu "|" px "|" k "|" t "|" nopt)
       }

       Gui, %guiu%: Add, Text, % posu " +BackgroundTrans +hide +hwndhTmp -wrap", % labelu
       ; SetWindowRegion(hTmp, 1, 1, 1, 1, 0)
       Gui, %guiu%: Add, DropDownList, % combosDarkModus " xp yp wp " nopt " +hwndhTemp" , % listu
    } Else
    {
       Gui, %guiu%: Add, DropDownList, % combosDarkModus A_Space options " +hwndhTemp" , % listu
       If IsObject(labelu)
       {
          ; WinGetPos, , , w, h, ahk_id %hTemp%
          ; GetWinClientSize(w, h, hTemp, 2)
          z := GetWindowPlacement(labelu[1])
          If (labelu[2])
          {
             g := GetWindowPlacement(labelu[2])
             z.w := g.w
          }

          r := GetWindowPlacement(hTemp)
          SetWindowPlacement(labelu[1], z.x, z.y, z.w, r.h, 1)
          If (labelu[2] && labelu[3])
          {
             p := GetWindowPlacement(labelu[3])
             SetWindowPlacement(hTemp, p.x, r.y, r.w, r.h, 1)
          }

          ; GuiControl, %guiu%: MoveDraw, %tipu%, w%w% h%h%
          If labelu[3]
             labelu := labelu[3]
          Else
             labelu := tipu := ""
       }
    }

    tipu := tipu ? tipu : labelu
    If tipu
       ToolTip2ctrl(hTemp, tipu)
    Return hTemp
}

GuiAddListView(options, headeru, labelu, guiu:="SettingsGUIA") {
    posu := ""
    nopt := options
    Loop, Parse, % "xy"
    {
       px := A_LoopField ? InStr(" " options, " " A_LoopField) : 0
       k := InStr(options, " ", 0, px + 1) - px
       If (px && k)
       {
          t := SubStr(options, px, k)
          posu .= t " "
          nopt := StrReplace(nopt, t)
       }
    }

    Gui, %guiu%: Add, Text, % posu " w1 h1 +BackgroundTrans +hide -wrap", % labelu
    Gui, %guiu%: Add, ListView, % " xp yp " nopt " +hwndhTemp", % headeru
    Return hTemp
}

GuiAddCheckBox(options, readerLabel, uiLabel, guiu:="SettingsGUIA", ttip:=0) {
    Gui, %guiu%: Add, Checkbox, % options " +hwndhTemp +0x1000 +0x8000", % readerLabel
    SetImgButtonStyle(hTemp, uiLabel, 1)
    thisu := ttip ? ttip : readerLabel
    ToolTip2ctrl(hTemp, thisu)
}

GuiAddFlipBlendLayers(options, guiu:="SettingsGUIA") {
    Static p := "Swap blended layers: A with B.`nThis will not have any impact on commutative`nblending modes marked with * (asterisk)."
    Gui, %guiu%: Add, Checkbox, % options " +hwndhTemp +0x1000 +0x8000 Checked" BlendModesFlipped " vBlendModesFlipped", Swap blended layers
    SetImgButtonStyle(hTemp, mainExecPath "\resources\toolbar\blending-layers.png", 1)
    ToolTip2ctrl(hTemp, p)
}

GuiAddCloseOnApply(options, guiu:="SettingsGUIA") {
    Static p := "Close window after the «Apply» button is clicked"
    Gui, %guiu%: Add, Checkbox, % options " gToggleClosePanelApply +hwndhTemp +0x1000 +0x8000 Checked" closeEditPanelOnApply " vcloseEditPanelOnApply", Close window on apply
    pk := (uiUseDarkMode=1) ? "" : "-dark"
    SetImgButtonStyle(hTemp, mainExecPath "\resources\toolbar\go-back" pk ".png", 1)
    ToolTip2ctrl(hTemp, p)
}

GuiAddToggleLivePreview(options, guiu:="SettingsGUIA") {
    Static p := "Toggle Live Preview for the current tool [F12]"
    Gui, %guiu%: Add, Checkbox, % options " +hwndhTemp +0x1000 +0x8000 Checked" doImgEditLivePreview " vdoImgEditLivePreview", Live preview
    pk := (uiUseDarkMode=1) ? "" : "-dark"
    SetImgButtonStyle(hTemp, mainExecPath "\resources\toolbar\view-2" pk ".png", 1)
    ToolTip2ctrl(hTemp, p)
}

ActToggleLivePreview() {
    Static lastInvoked := 1
    doImgEditLivePreview := !doImgEditLivePreview
    GuiControl, SettingsGUIA:, doImgEditLivePreview, % doImgEditLivePreview
    If (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)

    lastInvoked := A_TickCount
}

GuiAddPickerColor(options, colorReference, guiu:="SettingsGUIA") {
    Gui, %guiu%: Add, Button, % options " +0x8000 gStartPickingColor vPicku" colorReference " +hwndhTemp", Color pipette
    pk := (uiUseDarkMode=1) ? "" : "-dark"
    SetImgButtonStyle(hTemp, mainExecPath "\resources\toolbar\pipette" pk ".png")
    ToolTip2ctrl(hTemp, "Pick color from the viewport")
}

GuiAddCollapseBtn(options, guiu:="SettingsGUIA") {
    Gui, %guiu%: Add, Button, % options " +0x8000 gtoggleImgEditPanelWindow +hwndhTemp", Collapse panel. F11
    pk := (uiUseDarkMode=1) ? "" : "-dark"
    SetImgButtonStyle(hTemp, mainExecPath "\resources\toolbar\triangle-up" pk ".png")
    ToolTip2ctrl(hTemp, "Collapse panel [F11]")
}

GuiAddShapeEditBtn(options, guiu:="SettingsGUIA") {
    Gui, %guiu%: Add, Button, % options " +0x8000 gMenuResumeDrawingShapes vUIbtnEditShape +hwndhTemp", Edit vector shape
    pk := (uiUseDarkMode=1) ? "" : "-dark"
    SetImgButtonStyle(hTemp, mainExecPath "\resources\toolbar\create-freeform.png")
    ToolTip2ctrl(hTemp, "Edit vector shape")
}

GuiAddButton(options, uiLabel, readerLabel, ttipu:=0, guiu:="SettingsGUIA") {
    Gui, %guiu%: Add, Button, % options " +0x8000 +hwndhTemp", % readerLabel
    protectedHwnd := (guiu="fdTreeGuia" || guiu="QuickMenuSearchGUIA") ? hTemp : ""
    SetImgButtonStyle(hTemp, uiLabel, 0, protectedHwnd)
    p := ttipu ? ttipu : readerLabel
    ToolTip2ctrl(hTemp, p)
    Return hTemp
}

GuiAddColor(options, colorReference, labelu:=0, guiu:="SettingsGUIA") {
    realColor := %colorReference%
    p := labelu ? labelu : "Color."
    If (isWinXP=1)
       Gui, %guiu%: Add, Text, % options " v" colorReference A_Space " +hwndhTemp gInvokeStandardDialogColorPicker +TabStop +0xE", %p% Invoke color picker.
    Else
       Gui, %guiu%: Add, Button, % options " +0x8000 v" colorReference A_Space " +hwndhTemp gInvokeStandardDialogColorPicker", %p% Invoke color picker.

    updateColoredRectCtrl(realColor, colorReference, guiu, hTemp)
    p := labelu ? labelu : "Define color"
    ToolTip2ctrl(hTemp, p)
    Return hTemp
}

trackImageListButtons(actu, r:=0, hwnd:="") {
    Critical, on
    Static HILs := []
    Static counteru := 0
    If (actu="record")
    {
       ; SoundBeep , 300, 100
       counteru++
       HILs[counteru] := [r, hwnd]
       Return
    }

    CreateCollapsedPanelWidget("kill")
    If (ShowAdvToolbar!=1)
       createGUItoolbar("refresh-later")

    listu := new hashtable()
    Loop, % counteru
    {
       If (StrLen(HILs[A_Index, 2])>1)
       {
          ; fnOutputDebug(A_ThisFunc ": skip= " HILs[A_Index, 2])
          Continue
       }

       x := HILs[A_Index, 1]
       If (x!="" && listu[x]!=1)
       {
          ; SoundBeep , 900, 100
          ; fnOutputDebug(A_ThisFunc ": " HILs[A_Index, 1] "=" HILs[A_Index, 2])
          DllCall("Comctl32.dll\ImageList_Destroy", "uptr", x)
          HILs[A_Index, 1] := ""
          listu[x] := 1
       }
    }
    listu := ""
    counteru := 0
}

updateColoredRectCtrl(coloru, varu, guiu:="SettingsGUIA", clrHwnd:=0) {
    If !clrHwnd
       GuiControlGet, clrHwnd, %guiu%: hwnd, %varu%
    If !clrHwnd
       Return 0

    If (isWinXP=1)
       Return oldupdateColoredRectCtrl(coloru, clrHwnd)

    copt1 := [0, "0xFF" coloru, "0xFF" coloru,,,, "0xFF999999", 1, 0] ; normal
    copt2 := [0, "0xFF" coloru, "0xFF" coloru,,,, "0xffaaAAaa", 3, 0] ; hover
    copt3 := [0, "0xFF" coloru, "0xFF" coloru,,,, "0xFF777777", 4, 0] ; clicked
    copt4 := [0, "0xFF" coloru, "0xFF" coloru,,,, "0xFF999999", 2, 0] ; disabled
    copt5 := [0, "0xFF" coloru, "0xFF" coloru,,,, "0xff999999", 4, 0] ; active/focused
    r := ImageButton.Create(clrHwnd, copt1, copt2, copt3, copt4, copt5)
    If (r!="")
       trackImageListButtons("record", r)

    ; ToolTip, % r "|" coloru "|" hwnd  , , , 2
    Return r
}

oldupdateColoredRectCtrl(coloru, clrHwnd) {
    If !clrHwnd
       Return 0

    z := GetWindowPlacement(clrHwnd)
    If (z=0)
       Return 0

    pBitmap := trGdip_CreateBitmap(A_ThisFunc, z.w, z.h)
    G := Gdip_GraphicsFromImage(pBitmap)
    Gdip_GraphicsClear(G, "0xff" coloru)
    Gdip_SetPbitmapCtrl(clrHwnd, pBitmap)
    Gdip_DeleteGraphics(G)
    trGdip_DisposeImage(pBitmap)
    ; ToolTip, % z.w "|" z.h "|" coloru "|" hwnd  , , , 2
    Return 1
}

ProcessRawComboChoiceKBD(strg) {
  Loop, Parse, % "^~#&!+<>$*"
     strg := StrReplace(strg, A_LoopField)

  strg := Trim(strg)
  If (InStr(strg, "vk")=1)
  {
     strg := GetKeyName(strg)
  } Else If (!InStr(strg, "[[") && StrLen(strg)>3)
  {
     strg := StrReplace(strg, "numpad", "Numpad ")
     strg := StrReplace(strg, "PgUp", "Page Up")
     strg := StrReplace(strg, "PgDn", "Page Down")
  }

  If !strg
     strg := "(None)"

  Return strg
}

QuickMenuSearchGUIAGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1

    If (GuiHwnd!=hQuickMenuSearchWin)
       Return

    addBonus := 0
    folderPath := OmniBoxGetSelectedFolder()
    If folderPath
    {
       If FolderExist(folderPath)
       {
          createOmniBoxFoldersContextMenu(folderPath)
          Return
       } Else addBonus := 1
    }

    lastInvoked := A_TickCount
    invokePrefsPanelsContextMenu("omni", addBonus)
}

BTNinvokeQuickSearchMenu() {
    QuickMenuSearchGUIAGuiContextMenu(hQuickMenuSearchWin, 0, 0, 1, 2, 3)
}

OmniBoxGetSelectedFolder(givenRow:=0, isGiven:=0, givenPath:=0) {
    Gui, QuickMenuSearchGUIA: Default
    Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
    If (givenRow>0 && isGiven="yes" && InStr(givenPath, ":\"))
    {
       edithu := givenPath
       RowNumber := givenRow
    } Else
    {
       GuiControlGet, userQuickMenusEdit
       edithu := Trimmer(userQuickMenusEdit)
       edithu := Trimmer(StrReplace(edithu, "\\", "\"), "\")
       RowNumber := LV_GetFirstSelected(hLVquickSearchMenus)
       If !RowNumber
          RowNumber := LV_GetNext(0, "F")
    }

    LV_GetText(funcu, RowNumber, 6)
    LV_GetText(folderu, RowNumber, 1)
    If InStr(funcu, "!OmniNavigateFilteredFolders")
       edithu := SubStr(edithu, 1, InStr(edithu, "\", 0, -1))

    If (SubStr(edithu, 2, 2)=":\" && (InStr(funcu, "!OmniNavigateFolder") || InStr(funcu, "!OmniNavigateFilteredFolders")))
       Return edithu folderu
}

omniBoxFolderImport(dummy:=0, isGiven:=0) {
   If (maxFilesIndex<1 || !CurrentSLD)
   {
      omniBoxFolderOpen()
      Return
   } Else
      folderPath := OmniBoxGetSelectedFolder()

   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   changeMcursor()
   If ((dummy="not" || dummy="recursively") && isGiven="yes")
      r := addNewFolder2list(folderPath, "yes", dummy)
   Else If GetKeyState("Shift", "P")
      r := addNewFolder2list(folderPath, "yes", "recursive")
   Else
      r := addNewFolder2list(folderPath, "yes")

   ResetImgLoadStatus()
   If (r="cancel")
      Return

   currentFileIndex := maxFilesIndex - 1
   dummyTimerDelayiedImageDisplay(50)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
}

MenuAddThisListAtFaves() {
   If CurrentSLD
      addFolderSldATfavorites(CurrentSLD)
}

removeDeadFavedFolders() {
   favesFoldersList := readFoldersFavedList()
   counter := favesFoldersList.Count()
   newListu := ""
   failed := 0
   Loop, % counter
   {
      folderu := favesFoldersList[A_Index]
      If (SubStr(folderu, 1, 5)="\qpv\")
      {
         newListu .= "`n" folderu "`n"
         Continue
      }

      isFile := RegExMatch(folderu, sldsPattern) ? FileExist(folderu) : FolderExist(StrReplace(folderu, "|"))
      If isFile
         newListu .= "`n" folderu "`n"
      Else
         failed++
   }

   FileDelete, % folderFavesFile
   If (ErrorLevel && counter>0)
   {
      showTOOLtip("ERROR: Failed to update the folder favorites list file. Access denied?")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   FileAppend, % newListu, % folderFavesFile, UTF-8
   If ErrorLevel
   {
      showTOOLtip("ERROR: Failed to update the folder favorites list file. Access denied?")
      SoundBeep 300, 100
   } Else
      showTOOLtip("Operation succesfully completed.`n" failed " inexistent folders or files were found.")

   SetTimer, RemoveTooltip, % -msgDisplayTime
}

clearAllFavedFolders() {
  Static lastInvoked := 1
  lastInvoked := A_TickCount
  msgResult := msgBoxWrapper(appTitle ": Favourites", "Are you sure you want to remove all the entries pointing to folders and/or files lists from favourites?", 4, 0, "question")
  If !InStr(msgResult, "yes")
     Return

  If (A_TickCount - lastInvoked<950)
  {
     showTOOLtip("ERROR: User answered the message box too quickly.`nPlease read the message before confirming action.")
     SoundBeep 300, 100
     Return
  }

  FileDelete, % folderFavesFile
  showTOOLtip("All the entries pointing to folders and/or files lists from favourites were removed.")
  SetTimer, RemoveTooltip, % -msgDisplayTime//2
  SetTimer, ResetImgLoadStatus, -150
}

readFoldersFavedList() {
   FileRead, OutputVar, % " *t " folderFavesFile
   thisIndex := 0
   newArrayu := []
   Loop, Parse, OutputVar, `n,`r
   {
      If StrLen(A_LoopField)<4
         Continue
      thisIndex++
      newArrayu[thisIndex] := Trimmer(A_LoopField)
   }
   Return newArrayu
}

OpenDirsFavedEntry(a, b, c) {
   openThisu := SubStr(a, 2, InStr(a, ". ")-2)
   favesFoldersList := readFoldersFavedList()
   folderu := favesFoldersList[openThisu]
   isList := RegExMatch(folderu, sldsPattern) ? 1 : 0

   If FolderExist(StrReplace(folderu, "|"))
      OpenFolders(folderu)
   Else If (FileExist(folderu) && isList=1)
      OpenSLD(folderu)
   Else If (FileRexists(folderu) && RegExMatch(folderu, RegExFilesPattern))
   {
      MenuOpenLastImg(folderu)
      resultedFilesList[currentFileIndex, 5] := 1
      currentImgModified := 0
      SlidesMusicSong := ""
      interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   } Else If (folderu="\QPV\favourite-images-list.SLD")
      retrieveFavesAsList()
   Else If (folderu="\QPV\viewed-images-history|current-session.SLD")
      BtnViewedImages2List()
   Else If InStr(folderu, "\QPV\viewed-images-history|")
   {
      g := StrReplace(folderu, ".sld")
      p := InStr(folderu, "|")
      filteru := "|filteru|" SubStr(g, p + 1)
      If InStr(folderu, "|all.sld")
         filteru := ""

      BtnALLviewedImages2List(filteru)
   } Else
   {
      showTOOLtip("Failed to open favourited list:`n" folderu)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

addFolderSldATfavorites(givenPath) {
   If !givenPath
      Return

   If (InStr(givenPath, "\newFile.SLD") && !FileRexists(givenPath))
   {
      showTOOLtip("WARNING: This file list seems to be inexistend.`nIt was not added to favourites.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   thisu := RegExMatch(givenPath, sldsPattern) ? ".SLD file" : "Folder"
   FileRead, OutputVar, % " *t " folderFavesFile
   Sleep, 5
   FileDelete, % folderFavesFile
   If ErrorLevel
   {
      showTOOLtip("ERROR: Failed to access the folder favorites list file.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   Sleep, 5
   If InStr(OutputVar, "`n" givenPath "`n")
   {
      ; remove entry
      OutputVar := StrReplace(OutputVar, "`n" givenPath "`n", "`n")
      OutputVar := StrReplace(OutputVar, "`n`n`n", "`n`n")
      FileAppend, % OutputVar, % folderFavesFile, UTF-8
      givenPath := PathCompact(givenPath, "a", 1, OSDfontSize)
      If ErrorLevel
      {
         showTOOLtip("ERROR: Failed to update the folder favorites list file. " thisu " was not removed from the favorites list.")
         SoundBeep 300, 100
      } Else showTOOLtip(thisu " removed from the favorites list:`n" givenPath)
   } Else
   {
      OutputVar := "`n" givenPath "`n" OutputVar
      givenPath := PathCompact(givenPath, "a", 1, OSDfontSize)
      FileAppend, % OutputVar, % folderFavesFile, UTF-8
      If ErrorLevel
      {
         showTOOLtip("ERROR: Failed to update the folder favorites list file. " thisu " was not added to the favorites list.")
         SoundBeep 300, 100
      } Else showTOOLtip(thisu " added to the favorites list:`n" givenPath)
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

omniBoxFolderToFaves() {
   folderPath := OmniBoxGetSelectedFolder()
   addFolderSldATfavorites(folderPath)
}

omniBoxFolderExplorerOpen() {
   folderPath := OmniBoxGetSelectedFolder()
   Try Run, "%folderPath%"
   Catch wasError
   {
      If !AnyWindowOpen
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderPath, 0, 0, "error")
   }
}

omniBoxFolderOpen() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   If askAboutFileSave(" and the selected folder will be opened")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("discard it")
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   tryOpenGivenFolder(folderPath, CurrentSLD)
   FileExploreSiblingsNav("reset")
   userQuickMenusEdit := folderPath
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
}

omniBoxFolderNewInstance() {
   folderPath := OmniBoxGetSelectedFolder()
   If folderPath
      OpenNewQPVinstance(folderPath)
}

omniBoxFolderProperties() {
   folderPath := OmniBoxGetSelectedFolder()
   If folderPath
      invokeStandardFolderProperties(folderPath)
}

omniBoxFolderSetProtected() {
   folderPath := OmniBoxGetSelectedFolder()
   If folderPath
      setContaintFolderAsProtected(folderPath)
}

omniBoxFolderCreateNew() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := UIcoreFolderNew(folderPath, newFileName)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
   If r
   {
      prevOmniBoxFolder := newFileName
      SetTimer, PopulateQuickMenuSearch, -150
   }
}

omniBoxFolderCutCopy(a) {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   UIcoreFolderCutCopyExplorer(a, folderPath)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()
}

omniBoxFoldersPaste() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := UIcoreFolderPasteFoldersInto(folderPath)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
   If (r=2)
      PopulateQuickMenuSearch("resel")
}

omniBoxFolderRename() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := UIcoreFolderRename(folderPath, newFileName)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
   If r
   {
      prevOmniBoxFolder := newFileName
      SetTimer, PopulateQuickMenuSearch, -150
   }
}

omniBoxFolderDelete() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return "-"

   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   RowNumber := LV_GetFirstSelected(hLVquickSearchMenus)
   If !RowNumber
      RowNumber := LV_GetNext(0, "F")

   LV_GetText(funcu, RowNumber - 1, 6)
   If (InStr(funcu, "!OmniNavigateFolder") || InStr(funcu, "!OmniNavigateFilteredFolders"))
      LV_GetText(folderu, RowNumber - 1, 1)

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := UIcoreFolderDelete(folderPath)
   If (r="deleted" && InStr(folderu, "\"))
      prevOmniBoxFolder := StrReplace(folderu, "\")

   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   If (r="deleted")
      SetTimer, PopulateQuickMenuSearch, -100

   WinActivate, ahk_id %hQuickMenuSearchWin%
   SetTimer, ResetImgLoadStatus, -100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

omniBoxFolderPasteClippy() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   prevOmniBoxFolder := SubStr(folderPath, InStr(folderPath, "\", 0, -1) + 1)
   r := PasteFilesIntoGivenFolder(folderPath)
   If !VisibleQuickMenuSearchWin
      PanelQuickSearchMenuOptions()

   WinActivate, ahk_id %hQuickMenuSearchWin%
}

omniBoxFolderCopyFiles() {
   triggerQuickFileAction("vk38", 1)
}

omniBoxFolderMoveFiles() {
   triggerQuickFileAction("+vk38", 1)
}

omniBoxFolderCopyPath() {
   folderPath := OmniBoxGetSelectedFolder()
   If !folderPath
      Return

   Try Clipboard := folderPath
   Catch wasError
       Sleep, 1

   If !wasError
   {
      showTOOLtip("Folder path copied to the clipboard:`n" folderPath)
   } Else
   {
      showTOOLtip("ERROR: Failed to copy folder path to the clipboard:`n" folderPath)
      SoundBeep 300, 100
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createOmniBoxFoldersContextMenu(folderPath) {
   deleteMenus()
   Try Menu, PVopenF, Delete
   Try Menu, PVfomni, Delete
   kMenu("PVopenF", "Add", "Open folder now`tCtrl+Enter", "omniBoxFolderOpen")
   kMenu("PVopenF", "Add", "In Explorer", "omniBoxFolderExplorerOpen")
   kMenu("PVopenF", "Add", "With a new QPV instance", "omniBoxFolderNewInstance")

   kMenu("PVfomni", "Add", "Open", ":PVopenF")
   kMenu("PVfomni", "Add", "&Import images into the list`tF3", "omniBoxFolderImport")
   Menu, PVfomni, Add
   kMenu("PVfomni", "Add", "&Create new folder`tF7", "omniBoxFolderCreateNew")
   kMenu("PVfomni", "Add", "C&ut folder (Explorer mode)`tCtrl+X", "omniBoxFolderCutCopy")
   kMenu("PVfomni", "Add", "C&opy folder (Explorer mode)`tCtrl+C", "omniBoxFolderCutCopy")
   kMenu("PVfomni", "Add", "Copy folder path as te&xt", "omniBoxFolderCopyPath")
   kMenu("PVfomni", "Add", "&Paste folder(s) into...", "omniBoxFoldersPaste")
   kMenu("PVfomni", "Add", "&Rename folder`tF2", "omniBoxFolderRename")
   kMenu("PVfomni", "Add", "&Delete folder`tF8", "omniBoxFolderDelete")
   kMenu("PVfomni", "Add/UnCheck", "Se&t as the protected folder", "omniBoxFolderSetProtected")
   If (protectedFolderPath=folderPath && preventDeleteFromProtectedPath=1)
      kMenu("PVfomni", "Check", "Se&t as the protected folder")

   kMenu("PVfomni", "Add", "Folder properties (E&xplorer)`tF12", "omniBoxFolderProperties")
   kMenu("PVfomni", "Add", "Add to/remove from fa&vorites", "omniBoxFolderToFaves")
   Menu, PVfomni, Add
   kMenu("PVfomni", "Add", "Paste clip&board file(s) into...", "omniBoxFolderPasteClippy")
   kMenu("PVfomni", "Add", "Cop&y selected file(s) into...", "omniBoxFolderCopyFiles")
   kMenu("PVfomni", "Add", "&Move selected file(s) into...", "omniBoxFolderMoveFiles")
   showThisMenu("PVfomni", 1)
}

btnHelpKbdContexts() {
   msgBoxWrapper(appTitle ": HELP", "Users can customize keyboard shortcuts based on contexts in the application, such as, but not limited to: image view, files list modes, image editor live tools, et cetera.`n`nThe same keyboard shortcut can do different things based on the context. Or, the same function, if available in multiple contexts, can have a different shortcut for each context.", -1, 0, 0)
}

invokePrefsPanelsContextMenu(modus:=0, addBonus:=0) {
    Menu, ContextMenu, UseErrorLevel
    Try Menu, ContextMenu, Delete
    Sleep, 5

    If (modus="omni")
    {
       If (addBonus=1)
       {
          kMenu("ContextMenu", "Add", "Selected folder is inexistent", "dummy")
          kMenu("ContextMenu", "Disable", "Selected folder is inexistent")
          Menu, ContextMenu, Add
       } Else
       {
          kMenu("ContextMenu", "Add", "Customize keyboard shortcut`tF2", "PanelDefineKbdShortcut")
          ; kMenu("ContextMenu", "Add", "Disable keyboard shortcut", "MenuDisableKbdShortcut")
          ; kMenu("ContextMenu", "Add", "Restore default keyboard shortcut", "MenuRestoreDefaultKBD")
          ; kMenu("ContextMenu", "Add", "Restore default shortcut in all contexts", "MenuRestoreAnyContextDefaultKBD")
       }
       kMenu("ContextMenu", "Add", "&Close panel`tEscape", "QuickMenuSearchGUIAGuiClose")
    } Else
       kMenu("ContextMenu", "Add", "&Close panel`tEscape", "CloseWindow")

    kMenu("ContextMenu", "Add/UnCheck", "Dar&k mode UI", "ToggleDarkModus")
    If (uiUseDarkMode=1)
       kMenu("ContextMenu", "Check", "Dar&k mode UI")

    kMenu("ContextMenu", "Add/UnCheck", "&Large UI fonts", "ToggleLargeUIfonts")
    If (imgEditPanelOpened=1 && modus!="omni")
       kMenu("ContextMenu", "Add", "C&ollapse panel`tF11", "toggleImgEditPanelWindow")
    Menu, ContextMenu, Add,
    If (PrefsLargeFonts=1)
       kMenu("ContextMenu", "Check", "&Large UI fonts")

    kMenu("ContextMenu", "Add", "O&pen QPV settings folder", "openSettingsDir")
    kMenu("ContextMenu", "Add", "Restore ALL defaults", "DeleteAllSettings")
    Menu, ContextMenu, Add
    kMenu("ContextMenu", "Add", "&Visit official site", "OpenGitHub")
    kMenu("ContextMenu", "Add", "&Make a donation", "DonateNow")
    Menu, ContextMenu, Add
    kMenu("ContextMenu", "Add", "&New instance", "OpenNewQPVinstance")
    kMenu("ContextMenu", "Add", "&Restart " appTitle, "restartAppu")
    If (modus="omni")
    {
       Menu, ContextMenu, Add
       kMenu("ContextMenu", "Add", "&Help`tF1", "btnHelpQuickSearchMenus")
    }

    showThisMenu("ContextMenu", 1)
}

btnHelpQuickSearchMenus() {
   msgBoxWrapper(appTitle ": HELP", "This panel allows users to search the available menu options based on the current context. It also allows users to:`n`n- customize keyboard shortcuts; right-click on any menu item and choose «Customize keyboard shortcut»;`n`n- navigate through folders; just type or paste a folder path;`n`n- open folders or add the containing image files to the current files index;`n`n- manage folders; common actions available, such as copy, paste, delete, rename, et cetera;`n`n- jump to a given index in the list; begin with the symbol @ and type a number then press Enter;`n`n- execute internal code functions or display global variable values, if the query begins with >. Users can also set variables by using >set_variableName=NewValue.`n`nDrag and drop is supported between listed folders, and between this panel and the main window or the folders tree panel.", -1, 0, 0)
   WinActivate, ahk_id %hQuickMenuSearchWin%
}

WinMsgBoxGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1

    ; isFakeWin := (isNowFakeWinOpen=1 && AnyWindowOpen>0) ? 1 : 0
    If (!MsgBox2hwnd)
       Return

    If (isRightClick=1 && A_GuiControl!="vprompt")
    {
       If SettingsToolTips()
          Return
       Else If (AnyWindowOpen || isNowFakeWinOpen=1)
          invokePrefsPanelsContextMenu()
    }

    lastInvoked := A_TickCount
    Return
}

identifyParentWind() {
    uz := WinActive("A")
    Az := DllCall("GetParent", "UPtr", uz, "UPtr")
    r := (Az=hSetWinGui || Az=PVhwnd || Az=hGDIwin || Az=hGDIthumbsWin || Az=hGDIinfosWin) ? 1 : 0
    If (uz=PVhwnd || uz=hQPVtoolbar && ShowAdvToolbar=1)
       r := 0
    Return r
}

SettingsToolTips() {
   ActiveWin := WinActive("A")
   ; bActiveWin := WinExist("A")
   thisHwndGood := isVarEqualTo(ActiveWin, hKbdGuia, hSetWinGui, MsgBox2hwnd)
   ;  ToolTip, % isNowFakeWinOpen "==" ActiveWin "==" thisHwndGood "==" PVhwnd "==" hSetWinGui "==" MsgBox2hwnd , , , 2
   If (thisHwndGood!=1) ;  && ActiveWin!=PVhwnd)
      Return

   If (ActiveWin=hKbdGuia)
   {
      Gui, customKbdGUIA: Default
   } Else If (ActiveWin=MsgBox2hwnd)
   {
      Gui, WinMsgBox: Default
   } Else
   {
      If (panelWinCollapsed=1)
      {
         toggleImgEditPanelWindow()
         Return
      }

      Gui, SettingsGUIA: Default
   }

   GuiControlGet, value, , %A_GuiControl%
   ; MouseGetPos, , , , hwnd, 1 ; |2|3]
   GuiControlGet, hwnd, hwnd, %A_GuiControl%
   ControlGetText, info,, ahk_id %hwnd%
   ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
   ControlGet, ctrlActiveState, Enabled,,, ahk_id %hwnd%
   If (info=value)
      info := ""
   If StrLen(info)>0
      info .= "`n"

   If (posuk := InStr(value, "&"))
      hotkeyu := "`nAlt+" SubStr(value, posuk + 1, 1)
   Else If (posuk := InStr(A_GuiControl, "&"))
      hotkeyu := "`nAlt+" SubStr(A_GuiControl, posuk + 1, 1)

   StringUpper, hotkeyu, hotkeyu
   value := StrReplace(value, "&")
   ctrlu := StrReplace(A_GuiControl, "&")
   If (ctrlu=value)
      value := ""
   Else If (ctrlu=SubStr(value, 1, StrLen(ctrlu)))
      ctrlu := ""

   ; btnType := GetButtonType(hwnd)
   If (StrLen(value)>0 && ctrlu!="")
   {
      thisValueNumber := isNumber(Trimmer(value))
      value .= " = "
   }

   ; ToolTip, % info "`n" value "`n" ctrlu , , , 2
   MouseGetPos, , , id, controla, 2
   If !hwnd
      ControlGetText, info, , ahk_id %controla%

   If !hotkeyu
   {
      If (posuk := InStr(info, "&"))
         hotkeyu := "`nAlt+" SubStr(info, posuk + 1, 1)
   }

   info := StrReplace(info, "&")
   WinGetClass, OutputVar, ahk_id %hwnd%
   If OutputVar
   {
      If InStr(OutputVar, "_trackbar")
      {
         SendMessage, 0x0401,,,, ahk_id %hwnd%   ; TBM_GETRANGEMIN
         minu := ErrorLevel
         SendMessage, 0x0402,,,, ahk_id %hwnd%   ; TBM_GETRANGEMAX
         maxu := ErrorLevel
         OutputVar := "Slider: " minu "; " maxu
      } Else If (InStr(OutputVar, "Button") && thisValueNumber=1 && InStr(value, "="))
         OutputVar := "Checkbox"
      Else If InStr(OutputVar, "_updown")
      {
         SendMessage, 0x0400+102,,,, ahk_id %hwnd%   ; UDM_GETRANGE
         UDM_GETRANGE := ErrorLevel
         minu := UDM_GETRANGE >> 16
         maxu := UDM_GETRANGE & 0xFFFF
         OutputVar := "Up/Down range: " minu "; " maxu
      } Else If InStr(OutputVar, "edit")
      {
         OutputVar := "Edit field"
      } Else If (InStr(OutputVar, "static") && value && ctrlu && !InStr(ctrlu, "customSliders"))
      {
         OutputVar := "Maybe clickable" ; value  " - " ctrlu
         controlType := "`n[" OutputVar "]"
      }
      If !InStr(OutputVar, "static")
         controlType := "`n[" OutputVar "]"
   }

   If (InStr(OutputVar, "static") && InStr(ctrlu, "customSliders"))
   {
      ppp := StrReplace(ctrlu, "customSliders")
      pval := %ppp%
      controlType .= " = " pval
   }

   msg2show := info value ctrlu controlType hotkeyu
   ; ToolTip, % A_DefaultGUI "===" msg2show , , , 2
   ; If (ctrlActiveState!=1 && StrLen(msg2show)>2 && btnType)
   ;    msg2show .= "`n[CONTROL DISABLED]"
   If StrLen(listBoxOptions)>3
   {
      countListBoxOptions := ST_Count(listBoxOptions, "`n") + 1
      If (countListBoxOptions>10)
         listBoxOptions := "[too many to list]"
      msg2show .= "`n`nLIST OPTIONS: " countListBoxOptions "`n" listBoxOptions
   }

   ; If (!value && btnType)
   ;    msg2show .= "`n`nCONTROL TYPE:`n" btnType
   If InStr(msg2show, "lib\") || InStr(msg2show, "a href=")
      Return

   msg2show := StrReplace(msg2show, " = customSliders", "`n")
   thisSize := (PrefsLargeFonts=1) ? Round(LargeUIfontValue*1.55) : LargeUIfontValue
   mouseCreateOSDinfoLine(msg2show, thisSize)
   Return msg2show
}

ST_Count(Haystack, searchFor) {
    StrReplace(Haystack, searchFor,, OutputVarCount)
    Return OutputVarCount
}

SetParentID(Window_ID, theOther) {
  r := DllCall("SetParent", "uint", theOther, "uint", Window_ID) ; success = handle to previous parent, failure =null 
  Return r
}

CreateTempGuiButton(btnList, killWin:=0, delayu:=950) {
    Critical, On
    Static lastCreated := 1, bgrColor := 112288, txtColor := "ddeeFF", thisOpacity := 200
         , prevBtnList := "z"
    Global BtnTemp1, BtnTemp2
    
    If (killWin=1)
    {
       prevBtnList := ""
       Gui, TempBtnGui: Destroy
       tempBtnVisible := "null"
       interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
       Return
    }

    If (prevBtnList=btnList && tempBtnVisible!="null" && killWin!=1)
       Return

    If (TouchScreenMode!=1 && killWin!="force") ; || MsgBox2hwnd
       Return
 
    thisFntSize := Round(OSDfontSize*0.45)
    If (thisFntSize<9)
       thisFntSize := 9

    Gui, TempBtnGui: Destroy
    Sleep, 25
    Gui, TempBtnGui: -DPIScale -Caption +ToolWindow +E0x8000000 +hwndhGuiBtn +Owner%PVhwnd%
    Gui, TempBtnGui: Margin, % thisFntSize + 10, % thisFntSize
    Gui, TempBtnGui: Color, c%bgrColor%
    Gui, TempBtnGui: Font, s%thisFntSize% Bold Q5, Arial
    btnArray := StrSplit(btnList, "||")
    tempBtnGuiBtnArray := []
    Loop, % btnArray.Count()
    {
        thisBtnArr := StrSplit(btnArray[A_Index], ",,")
        ; ToolTip, % thisBtnArr[1] "==" thisBtnArr[2] , , , 2
        If (A_Index=1)
           Gui, TempBtnGui: Add, Text, c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
        Else If thisBtnArr[1]
           Gui, TempBtnGui: Add, Text, x+%OSDfontSize% c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
 
        tempBtnGuiBtnArray[A_Index] := thisBtnArr[2]
    }

    tempBtnVisible := hGuiBtn
    RepositionTempBtnGui()
    If InStr(btnList, ",,")
       prevBtnList := btnList
    interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
    SetTimer, DestroyTempBtnGui, % - delayu
    lastCreated := A_TickCount
}

RepositionTempBtnGui(mm:=0) {
    Static lastSize := []
    If (mm="getLast")
       Return lastSize
    If (tempBtnVisible="null")
       Return

    thisFntSize := Round(OSDfontSize*0.45)
    If (thisFntSize<9)
       thisFntSize := 9

    hGuiBtn := tempBtnVisible
    WinGetPos, winPosX, winPosY, Wid, Heig, ahk_id %PVhwnd%
    Gui, TempBtnGui: Default
    Gui, TempBtnGui: Show, NoActivate AutoSize Hide x%winPosX% y%winPosY%, QPVGuiActionBtn
    WinGetPos,,, gWid, gHeig, ahk_id %hGuiBtn%
    If (gWid>Wid - thisFntSize*2.2)
       gWid := Wid - Round(thisFntSize * 2.25) - 5
    If (gWid<5)
       gWid := 5

    offsetuY := scrollBarHy ? scrollBarHy : 0
    Final_y := winPosY + Heig - thisFntSize * 2 - gHeig - offsetuY//2
    hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
    tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
    ; ToolTip, % tlbrBonusX "|" hasTrans , , , 2
    Final_x := winPosX + thisFntSize * 2 + tlbrBonusX
    WinSet, Transparent, 230, ahk_id %hGuiBtn%
    ; WinSet, AlwaysOnTop, On, ahk_id %hGuiBtn%
    roundedCsize := Round(thisFntSize/1.7) + 15
    WinSet, Region, 0-0 R%roundedCsize%-%roundedCsize% w%gWid% h%gHeig%, QPVGuiActionBtn
    Gui, TempBtnGui: Show, NoActivate AutoSize x%Final_x% y%Final_y%, GuiActionBtn
    WinGetPos, x, y, ,, ahk_id %hGuiBtn%
    lastSize := [Final_x, Final_y, Wid, Heig, x, y]
}

tempGuiBtnCall1() {
    coretempGuiBtnCalls(1)
}

tempGuiBtnCall2() {
    coretempGuiBtnCalls(2)
}

tempGuiBtnCall3() {
    coretempGuiBtnCalls(3)
}

tempGuiBtnCall4() {
    coretempGuiBtnCalls(4)
}

tempGuiBtnCall5() {
    coretempGuiBtnCalls(5)
}

tempGuiBtnCall6() {
    coretempGuiBtnCalls(6)
}

coretempGuiBtnCalls(indexu) {
    Static listu := ",reduceCustomShapeLength,ImgVectorUndoAct,togglePathCurveTension,toggleOpenClosedLineEditorCustomShape,"
    thisFunc := tempBtnGuiBtnArray[indexu]
    z := InStr(listu, "," thisFunc ",")
    If !z
       SetTimer, DestroyTempBtnGui, -950

    If (WinActive("A")!=PVhwnd)
       WinActivate, ahk_id %PVhwnd%
    ; ToolTip, % thisfunc "===" indexu , , , 2
    If IsFunc(thisFunc)
       %thisFunc%()
    Else
       addJournalEntry("ERROR " A_ThisFunc "(): no such function to call: " thisFunc)

    If (drawingShapeNow!=1 && !z)
       SetTimer, DestroyTempBtnGui, -950
}

DestroyTempBtnGui(dummy:=0) {
    Critical, On
    MouseGetPos, , , OutputVarWin
    thisWin := WinActive("A")
    okay := (thisWin=PVhwnd || thisWin=hSetWinGui) ? 1 : 0
    ; ToolTip, % OutputVarWin , , , 2
    If (OutputVarWin!=tempBtnVisible) || (okay!=1) || (dummy="now")
       CreateTempGuiButton("Die dummy", 1)  ;   ;-)
    Else
       SetTimer, DestroyTempBtnGui, -950
}

openPreviousPanel(mode:="") {
   thisFunc := prevOpenedWindow[2]
   allowReopen := prevOpenedWindow[3]
   If (IsFunc(thisfunc) && thisFunc && allowReopen=1) || (thisFunc && mode="forced")
   {
      %thisFunc%()
   } Else
   {
      showTOOLtip("No previously opened panel")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

mouseTurnOFFtooltip() {
   Gui, mouseToolTipGuia: Destroy
   mouseToolTipWinCreated := 0
   ; interfaceThread.ahkPostFunction("mouseTurnOFFtooltip", 1)
}

SetImgButtonStyle(hwnd, newLabel:="", checkMode:=0, protectedHwnd:="") {
   Static dopt1 := [0, "0xFF373737","0xFF373737", "0xFFffFFff",,,"0xff778877", 2] ; normal
   , dopt2 := [0, "0xFF656565","0xFF656565", "0xFFffFFff",,,"0xffaaAAaa", 2] ; hover
   , dopt3 := [0, "0xFF000000","0xFF000000", "0xFFeeEEee",,,"0xFF454545", 4] ; clicked
   , doptc := [0, "0xFF1E98A6","0xFF1E98A6", "0xFFeeEEee",,,"0xFF454545", 4] ; clicked
   , dopt4 := [0, "0xFF212121","0xFF212121", "0xFF999999",,,"0xFF454545", 4] ; disabled
   , dopt5 := [0, "0xFF606060","0xFF606060", "0xFFffFFff",,,"0xffaaAAaa", 3] ; active/focused
   , lopt1 := [0, "0xFFddDDdd","0xFFddDDdd", "0xFF111111",,,"0xffbbBBbb", 2] ; normal
   , lopt2 := [0, "0xFFC1DCE6","0xFFC1DCE6", "0xFF000000",,,"0xff8899EE", 2] ; hover
   , lopt3 := [0, "0xFFffffff","0xFFffffff", "0xFF000000",,,"0xFF0099ff", 4] ; clicked
   , loptc := [0, "0xFF83D2F1","0xFF83D2F1", "0xFF000000",,,"0xFF0099ff", 4] ; clicked
   , lopt4 := [0, "0xFFE1E1E1","0xFFE1E1E1", "0xFF666666",,,"0xFFaaaaaa", 1] ; disabled
   , lopt5 := [0, "0xFF83D2F1","0xFF83D2F1", "0xFF000000",,,"0xff000099", 4] ; active/focused

   If (newLabel!="")
   {
      Loop, 5
      {
         pi := (A_Index=3 && checkMode=1) ? "c" : A_Index
         If (uiUseDarkMode=1)
            dopt%pi%[10] := newLabel
         Else
            lopt%pi%[10] := newLabel
      }
   }

   pi := (checkMode=1) ? "c" : 3
   If (uiUseDarkMode=1)
      r := ImageButton.Create(hwnd, dopt1, dopt2, dopt%pi%, dopt4, dopt5)
   Else
      r := ImageButton.Create(hwnd, lopt1, lopt2, lopt%pi%, lopt4, lopt5)

   If (r!="")
      trackImageListButtons("record", r, protectedHwnd)

   Return r
}

repositionWindowCenter(whichGUI, hwndGUI, referencePoint, winTitle:="", winPos:="") {
    Critical, on
    Static lastAsked := 1, BS_PUSHLIKE := 0x1000, WS_CLIPSIBLINGS := 0x4000000
         , BS_CHECKBOX := 0x2, BS_RADIOBUTTON := 0x8, BS_AUTORADIOBUTTON := 0x09
         , RCBUTTONS := BS_CHECKBOX | BS_RADIOBUTTON | BS_AUTORADIOBUTTON

    repositionedWindow := winPos ? 1 : 0
    winPos := (winPos=1) ? "" : winPos
    UnregisterTouchWindow(hwndGUI)
    If !winPos
    {
       SysGet, MonitorCount, 80
       ActiveMonDetails := calcScreenLimits(referencePoint)
       ActiveMon := ActiveMonDetails.m
       ResWidth := ActiveMonDetails.w, ResHeight:= ActiveMonDetails.h
       mCoordRight := ActiveMonDetails.mCRight, mCoordLeft := ActiveMonDetails.mCLeft
       mCoordTop := ActiveMonDetails.mCTop, mCoordBottom := ActiveMonDetails.mCBottom
    }

    If (uiUseDarkMode=1)
    {
       setDarkWinAttribs(hwndGUI)
       WinGet, strControlList, ControlListHwnd, ahk_id %hwndGUI%
       Gui, %whichGUI%: Color, %intWindowColor%, %intControlColor%
       Static clrBG := "303030"
       clrTX := SubStr(darkControlColor, 3)
       For strKey, strControlHwnd in StrSplit(strControlList,"`n","`r`n")
       {
           ; ControlGet, strControlHwnd, HWND, , %strControl%, ahk_id %hwndGUI%
           WinGetClass, CtrlClass, ahk_id %strControlhwnd%
           ControlGet, CtrlStyle, Style, , , ahk_id %strControlhwnd%
           doAttachCtlColor := 0
           ; MsgBox, % CtrlClass
           If InStr(CtrlClass, "systab")
           {
              doAttachCtlColor := -2
              GetWinClientSize(w, h, strControlHwnd, 1)
              WinSet, Region, % "4-5 w" w - 8 " h" h - 25, ahk_id %strControlhwnd%
              ; ToolTip, % w "|" h "`n" nX "|" nY , , , 2
           } Else If InStr(CtrlClass, "progress")
           {
              doAttachCtlColor := -2
           } Else If InStr(CtrlClass, "Button")
           {
              doAttachCtlColor := -2
              If (CtrlStyle & BS_PUSHLIKE)
              {
                 doAttachCtlColor := 0
                 WinSet, Style, +%WS_CLIPSIBLINGS%, ahk_id %strControlhwnd%
                 GetWinClientSize(w, h, strControlHwnd, 1)
                 WinSet, Region, % "1-1 w" w - 2 " h" h - 2, ahk_id %strControlhwnd%
              } Else IF (CtrlStyle & BS_RADIOBUTTON) || ((CtrlStyle & RCBUTTONS) > 1)
              {
                 Sleep, -1
              } Else 
              {
                 doAttachCtlColor := 0
                 ; SetImgButtonStyle(strControlHwnd)
                 WinSet, Style, +%WS_CLIPSIBLINGS%, ahk_id %strControlhwnd%
                 GetWinClientSize(w, h, strControlHwnd, 1)
                 WinSet, Region, % "1-1 w" w - 2 " h" h - 2, ahk_id %strControlhwnd%
              }
           } Else If InStr(CtrlClass, "ComboBox")
           {
              doAttachCtlColor := -2
              CtlColors.Attach(strControlHwnd, clrBG, clrTX)
              If (A_OSVersion="WIN_7")
              {
                 WinSet, Style, +%WS_CLIPSIBLINGS%, ahk_id %strControlhwnd%
                 GetWinClientSize(w, h, strControlHwnd, 1)
                 WinSet, Region, % "1-1 w" w - 3 " h" h - 2, ahk_id %strControlhwnd%
              } Else
                 DllCall("uxtheme\SetWindowTheme", "uptr", strControlHwnd, "str", "DarkMode_CFD", "ptr", 0)
           } Else If InStr(CtrlClass, "sysheader")
           {
              doAttachCtlColor := -2
              ; almost working, but the texts are black on black ;[
              ; I need to somehow set the text color to white of the hDC of the List View Header
              ; hDC := Gdi_GetDC(strControlHwnd)
              ; ll := Gdi_SetTextColor(hDC, "0xffFFff")
              ; DllCall("uxtheme\SetWindowTheme", "uptr", strControlHwnd, "str", "DarkMode_ItemsView", "ptr", 0)
              ; ToolTip, % hDC " l=" ll , , , 2
           } Else If InStr(CtrlClass, "Edit")
           {
              doAttachCtlColor := -1
           } Else If (InStr(CtrlClass, "Static") || InStr(CtrlClass, "syslink"))
              doAttachCtlColor := -2 

           If InStr(CtrlClass, "syslink")
              LinkUseDefaultColor(strControlHwnd, 1, whichGUI)
  
           If (doAttachCtlColor=1) ; it works for drop-downs, listboxes and comboboxes
              CtlColors.Attach(strControlHwnd, clrBG, clrTX)
  
           If (doAttachCtlColor!=2 && doAttachCtlColor!=-2)
              DllCall("uxtheme\SetWindowTheme", "uptr", strControlHwnd, "str", "DarkMode_Explorer", "ptr", 0)
       }
    }

    If (ShowAdvToolbar=1)
    {
       createGUItoolbar()
       SetTimer, fromCurrentPanelToColorsSwatch, -25
    }

    If (MonitorCount>1 && !winPos && A_OSVersion!="WIN_XP")
    {
       ; center window on the monitor/screen where the mouse cursor is
       semiFinal_x := mCoordLeft + 2
       semiFinal_y := mCoordTop + 2
       If !semiFinal_y
          semiFinal_y := 1
       If !semiFinal_x
          semiFinal_x := 1

       Gui, %whichGUI%: Show, Hide AutoSize x%semiFinal_x% y%semiFinal_y%, % winTitle
       Sleep, 25
       GetWinClientSize(msgWidth, msgHeight, hwndGUI, 1)
       If !msgWidth
          msgWidth := 1
       If !msgHeight
          msgHeight := 1

       Final_x := Round(mCoordLeft + ResWidth/2 - msgWidth/2)
       Final_y := Round(mCoordTop + ResHeight/2 - msgHeight/2)
       If (!Final_x) || (Final_x + 1<mCoordLeft)
          Final_x := mCoordLeft + 1
       If (!Final_y) || (Final_y + 1<mCoordTop)
          Final_y := mCoordTop + 1
       Gui, %whichGUI%: Show, x%Final_x% y%Final_y%, % Chr(160) winTitle
    } Else 
    {
       ; SoundBeep 
       ; ToolTip, % winPos , , , 2
       Gui, %whichGUI%: Show, AutoSize %winPos%, % Chr(160) winTitle
    }
    SetTimer, highlightActiveCtrl, -100
}

createSettingsGUI(IDwin, thisCaller:=0, allowReopen:=1, isImgLiveEditor:=0) {
    Critical, on
    ; tabzDarkModus := (uiUseDarkMode=1) ? "-Border +Buttons cFFFFaa " : ""
    combosDarkModus := (uiUseDarkMode=1) ? "-theme -border " : ""
    lastZeitOpenWin := A_TickCount
    lastFilterEditSearch := ""
    If (thumbsDisplaying=1 && isImgLiveEditor=1)
    {
       openingPanelNow := 0
       Return
    }
 
    If (IDwin=AnyWindowOpen && imgEditPanelOpened=1)
    {
       openingPanelNow := 0
       addJournalEntry(A_ThisFunc "(): ERROR: You cannot reopen the same window while it is opened. Close and reopen it :-).")
       Return
    }

    If (isImgLiveEditor=1)
    {
       If throwErrorNoImageLoaded()
       {
          openingPanelNow := 0
          Return
       }

       rzx := isVarEqualTo(IDwin, 12, 23, 24, 25, 31, 32, 55, 65, 66, 70, 89) ? 0 : downscaleHugeImagesForEditing()
       If (rzx<0 || rzx=1)
       {
          openingPanelNow := 0
          Return
       }
    }

    If isNowAlphaPainting()
    {
       openingPanelNow := 0
       toggleAlphaPaintingMode()
       Return
    }

    If AnyWindowOpen
    {
       rz := CloseWindow()
       If rz
       {
          openingPanelNow := 0
          Return
       }
    }

    thisBtnHeight := (PrefsLargeFonts=1) ? 34 : 24
    setLVrowsCount()
    If (slideShowRunning=1)
       ToggleSlideShowu()

    mouseTurnOFFtooltip()
    ; If (editingSelectionNow=1 && imgEditPanelOpened!=1)
    ;    ToggleEditImgSelection()

    uiSlidersArray := []
    lastSlidersPainted := []
    endCaptureCloneBrush() 
    forceLiveAlphaPreviewMode := userAllowClrGradientRecenter := userAllowsGradientRecentering := liveDrawingBrushTool := panelWinCollapsed := 0
    imgEditPanelOpened := isImgLiveEditor
    o_ImgQuality := userimgQuality
    If (imgEditPanelOpened=1)
    {
       If (viewportQPVimage.imgHandle)
       {
          imgFxMode := 1
          dummyTimerDelayiedImageDisplay(250)
       }

       doImgEditLivePreview := 1
       ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
       ToggleVisibilityWindow("show", hGDIthumbsWin)
       ToggleVisibilityWindow("show", hGDIwin)
       If (editingSelectionNow=1)
          ToggleVisibilityWindow("show", hGDIselectwin)

       initQPVmainDLL()
       ForceRefreshNowThumbsList()
       ; dummyTimerDelayiedImageDisplay(150) ; probably needed in some cases ; I do not know 
       recordSelUndoLevelNow()
       If (closeEditPanelOnApply=-1)
          INIaction(0, "closeEditPanelOnApply", "General", 1)

       ; interfaceThread.ahkassign("AnyWindowOpen", IDwin)
       ; TriggerMenuBarUpdate()
       If AnyWindowOpen
          Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%
       ; coreDesiredPixFmt := "0x26200A" ; 32-ARGB
       DestroyGIFuWin()
       Gui, SettingsGUIA: Destroy
       Sleep, 5
       clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       vpWinClientSize(mainWidth, mainHeight)
       drawImgSelectionOnWindow("faker", "-", "-", "-", mainWidth, mainHeight)
    } ; Else CloseWindow()
    If (folderTreeWinOpen=1)
       fdTreeClose()

    If (VisibleQuickMenuSearchWin=1)
       closeQuickSearch()

    Sleep, 15
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: -MaximizeBox +Border +Owner%PVhwnd% +hwndhSetWinGui 
    Gui, SettingsGUIA: Margin, 14, 14
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    If (uiUseDarkMode=1)
    {
       Gui, Color, % darkWindowColor, % darkWindowColor
       Gui, Font, c%darkControlColor%
       setDarkWinAttribs(hSetWinGui)
    }

    AnyWindowOpen := IDwin
    thisPanelTab := TabsPerWindow[AnyWindowOpen] ? TabsPerWindow[AnyWindowOpen] : 1
    uiPanelOpenCloseEvent()
    TriggerMenuBarUpdate()
    If (allowReopen=1)
    {
       prevOpenedWindow := []
       prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 0, o_ImgQuality]
    }

    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    lastZeitOpenWin := A_TickCount
    Return thisBtnHeight
}

setLVrowsCount() {
   uLVr := (PrefsLargeFonts=1) ? 11 + additionalLVrows : 15 + Ceil(additionalLVrows*1.25)
}

PanelSeenStats() {
    Global LViewMetaD, LViewMetaM, LViewMetaH, infoLine
    showTOOLtip("Generating statistics, please wait")
    thisBtnHeight := createSettingsGUI(39, A_ThisFunc)
    btnWid := 105
    txtWid := 150
    lstWid := 199
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := lstWid - 25
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Daily|Monthly|Hourly|Options
    Gui, Tab, 1 ; Daily
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaD AltSubmit -multi gSeenStatsLVaction", "#|Date|Images|%", "Seen images per day")
    Gui, Tab, 2 ; Monthly
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaM AltSubmit -multi gSeenStatsLVaction", "#|Date|Images|%", "Seen images per month")
    Gui, Tab, 3 ; Hourly
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid -multi vLViewMetaH", "#|Hour|Images|%", "Seen images per year")
    Gui, Tab, 4 ; Options
    Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% gCleanDeadFilesSeenImagesDB, &Purge records of inexistent files
    Gui, Add, Button, y+5 hp geraseSeenIMGsDB, &Erase the entire list
    Gui, Add, Button, y+5 hp gBtnCopySeenStats, &Copy statistics to clipboard
    Gui, Add, Button, y+5 hp gBtnALLviewedImages2List, &Retrieve list of recorded seen images
    Gui, Add, Text, y+5 hp +0x200, Charts:
    Gui, Add, Button, x+5 hp gPlotSeenHourStatsNow, &Hours
    Gui, Add, Button, x+2 hp gPlotSeenMonthsStatsNow, &Months
    Gui, Add, Button, x+2 hp gPlotSeenDaysToggleStatsNow, &Days
    Gui, Add, Text, xs+15 y+35 w%txtWid%, To retrieve the images seen on a given day or month`, double click on the date in the list.
    Gui, Add, GroupBox, xp-15 yp-20 wp+30 hp+30, TIP
    Gui, Add, Text, y+10 h%thisBtnHeight% +0x200 w%txtWid% vinfoLine, Please wait...

    Gui, Tab
    Gui, Add, Button, xp y+5 h%thisBtnHeight% w1 h1 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Images seen statistics: " appTitle)
    PopulateSeenStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
}

PanelIndexedImagesStats() {
    Global LViewMetaD, LViewMetaG, LViewMetaU, LViewMetaM, LViewMetaY, LViewMetaS, LViewMetaT, LViewMetaA, LViewMetaI
         , LViewMetaR, StatsUIhistoThingy := 1

    showTOOLtip("Generating image files statistics, please wait")
    thisBtnHeight := createSettingsGUI(48, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%thisPanelTab% hwndhCurrTab, Megapixels|Aspect ratios|DPI|Frames|Pixel formats|Histogram
    Gui, Tab, 1
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaD -multi AltSubmit gIndexStatsLVaction", "#|MPx|Images|%", "Megapixels")
    Gui, Tab, 2
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaY -multi AltSubmit gIndexStatsLVaction", "#|W/H|Images|%", "Aspect ratios")
    Gui, Tab, 3
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaU -multi AltSubmit gIndexStatsLVaction", "#|DPI|Images|%", "DPIs")
    Gui, Tab, 4
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaM -multi AltSubmit gIndexStatsLVaction", "#|Frames|Images|%", "Frames")
    Gui, Tab, 5
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaS -multi AltSubmit gIndexStatsLVaction", "#|Formats|Images|%", "Pixel formats")
    Gui, Tab, 6
    GuiAddDropDownList("y+15 w" lstWid " AltSubmit Choose1 gSwitchUIdlHistoStats vStatsUIhistoThingy", "Averages|Medians|Peak (range)|Minimum (range)|Total (range)", "Histogram data points")
    Gui, Add, ListView, y+10 w%lstWid% r6 Grid vLViewMetaG -multi AltSubmit gIndexStatsLVaction, #|Medians|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaA -multi AltSubmit gIndexStatsLVaction, #|Max|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaI -multi AltSubmit gIndexStatsLVaction, #|Min|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaT -multi AltSubmit gIndexStatsLVaction, #|Avg|Images|`%
    Gui, Add, ListView, yp w%lstWid% r6 Grid vLViewMetaR -multi AltSubmit gIndexStatsLVaction, #|Range|Images|`%

    Gui, Tab
    Gui, Add, Button, xp Section y+5 h%thisBtnHeight% w2 gBtnCloseWindow, &Close
    Gui, Add, Button, x+5 hp gPanelWrapperFilesStats, &Back
    Gui, Add, Button, x+2 yp hp gBtnCopyImageFileStats, Cop&y all to clipboard
    Gui, Add, Text, xs y+2 hp w%lstWid% vinfoLine +0x200 -wrap, Please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Indexed images statistics: " appTitle)
    ; If (SLDtypeLoaded=3)
    ;    PopulateIndexSQLFilesStatsInfos()
    ; Else
       PopulateImagesIndexStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
    SetTimer, SwitchUIdlHistoStats, -300
}

SwitchUIdlHistoStats() {
   If (AnyWindowOpen=48)
   {
      GuiControlGet, StatsUIhistoThingy
      If (StatsUIhistoThingy=1)
      {
         GuiControl, SettingsGUIA: Show, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=2)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Show, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=3)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Show, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=4)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Show, LViewMetaI
         GuiControl, SettingsGUIA: Hide, LViewMetaR
      } Else If (StatsUIhistoThingy=5)
      {
         GuiControl, SettingsGUIA: Hide, LViewMetaT
         GuiControl, SettingsGUIA: Hide, LViewMetaG
         GuiControl, SettingsGUIA: Hide, LViewMetaA
         GuiControl, SettingsGUIA: Hide, LViewMetaI
         GuiControl, SettingsGUIA: Show, LViewMetaR
      }
   }
}

PanelIndexedFilesStats() {
    Global LViewMetaD, LViewMetaM, LViewMetaY, LViewMetaS, LViewMetaT
    showTOOLtip("Generating statistics, please wait")
    RegAction(0, "uiPreferedFileStats",, 1)
    thisBtnHeight := createSettingsGUI(59, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%thisPanelTab% hwndhCurrTab, Days|Months|Years|Sizes|Types
    Gui, Tab, 1 ; Daily
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaD -multi AltSubmit gIndexStatsLVaction", "#|Date|Images|%", "Files per days")
    Gui, Tab, 2 ; Monthly
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaM -multi AltSubmit gIndexStatsLVaction", "#|Date|Images|%", "Files per months")
    Gui, Tab, 3 ; Yearly
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaY -multi AltSubmit gIndexStatsLVaction", "#|Year|Images|%", "Files per years")
    Gui, Tab, 4 ; Sizes
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaS -multi AltSubmit gIndexStatsLVaction", "#|File size ranges|Total size [MB]|Images|%", "Statistics grouped by file sizes")
    Gui, Tab, 5 ; Types
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid vLViewMetaT -multi AltSubmit gIndexStatsLVaction", "#|File types|Images|%", "Statistics grouped by file types")
    friendly := (uiPreferedFileStats=1) ? "modified" : "created"
    Gui, Tab
    Gui, Add, Button, xp Section y+5 h%thisBtnHeight% w2 gBtnCloseWindow, &Close
    Gui, Add, Button, x+2 h%thisBtnHeight% gPanelWrapperFilesStats, &Back
    Gui, Add, Button, x+2 yp wp hp gBtnCopyFileStats, Cop&y
    Gui, Add, Text, x+5 yp hp +0x200 -wrap, Statistics based on the %friendly% file date.
    Gui, Add, Text, xs w%lstWid% vinfoLine +0x200, Please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Indexed files statistics: " appTitle)
    If (SLDtypeLoaded=3)
       PopulateIndexSQLFilesStatsInfos()
    Else
       PopulateIndexFilesStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
}

ToggleFileStatsDating() {
    Gui, SettingsGUIA: Default
    GuiControlGet, uiPreferedFileStats
    ; ToolTip, % "l=" uiPreferedFileStats , , , 2
    RegAction(1, "uiPreferedFileStats")
}

UIeditHammingInterpolation() {
    Gui, SettingsGUIA: Default
    GuiControlGet, hamDistInterpolation

    ; hamDistInterpolation := (editFr=1) ? 6 : 5
    ; ToolTip, % "l=" hamDistInterpolation , , , 2
    ; IniAction(1, "hamDistInterpolation", "General")
    If (SLDtypeLoaded=3)
       IniSLDBWrite("hamDistInterpolation", hamDistInterpolation)
}

PanelWrapperFilesStats() {
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (maxFilesIndex<3 && !filesFilter)
    {
       showTOOLtip("WARNING: Insufficient files are currently indexed.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(58, A_ThisFunc)
    btnWid := 105
    txtWid := 370
    lstWid := 390
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 165
       Gui, Font, s%LargeUIfontValue%
    }

    RegAction(0, "uiPreferedFileStats",, 1)
    ; Gui, Tab, 1
    Gui, Add, Text, x15 y15 w%txtWid%, The statistics panel allows users to filter the indexed files to various criteria by double-clicking on list view entries. It is meant to facilitate the identification of small files, low resolution images, low key or high key, or washed out images in your collection.
    Gui, Add, Text, y+15 Section, File details: size, date modified, type and more.
    Gui, Add, Button, xp+15 y+5 h%thisBtnHeight% gPanelIndexedFilesStats, Open &file statistics panel
    Gui, Add, Button, x+5 hp gBtnCollectFileInfos, &Collect data
    Gui, Add, Checkbox, xs+15 y+5 Checked%uiPreferedFileStats% vuiPreferedFileStats gToggleFileStatsDating, &Generate date statistics based on modified date.
    Gui, Add, Text, xs y+35 Section, Image properties: resolution, frames and more.
    Gui, Add, Button, xp+15 y+5 h%thisBtnHeight% gPanelIndexedImagesStats, Open &images statistics panel
    ; Gui, Add, Button, x+5 h%thisBtnHeight% gPanelFindDupes, Find &duplicates panel
    Gui, Add, Button, xs+15 y+10 hp gBtnCollectImageInfos, Collect image &properties and file details
    If (SLDtypeLoaded=3)
       Gui, Add, Button, xs y+30 h%thisBtnHeight% gOpenFileDupesPanel, Advanced options (Find duplicates panel)
    Else
       Gui, Add, Button, xs y+30 h%thisBtnHeight% gBtnCollectHistoInfos, Collect image properties and &histogram details
    ; Gui, Add, Button, x+5 h%thisBtnHeight% gOpenFileDupesPanel, &Options
    ; Gui, Add, Checkbox, xs+15 y+5 hp Checked%hamDistInterpolation% vhamDistInterpolation gUIeditHammingInterpolation, High-quality resampling (not recommended)

    ; Gui, Tab
    Gui, Add, Button, xs y+35 h%thisBtnHeight% gPanelEnableFilesFilter, C&reate custom filter
    If (SLDtypeLoaded=3)
    {
       Gui, Add, Button, x+5 hp gBtnPurgeCachedSQLdata, Pur&ge caches
       Gui, Add, Button, x+5 hp gPanelStateOFsqlNation, Caches &overview
    }

    wu := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 w%wu% hp Default gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Statistics: " appTitle)
}

OpenFileDupesPanel() {
   BtnCloseWindow()
   Sleep, 25
   PanelFindDupes(3)
}

BtnPurgeCachedSQLdata() {
   BtnCloseWindow()
   AnyWindowOpen := 49
   PanelPurgeCachedSQLdata()
}

SeenStatsLVaction(CtrlHwnd:=0, b:=0, c:=0) {
    Static cl := {1:"D", 2:"M"}
    Gui, SettingsGUIA: Default
    GuiControlGet, CurrentPanelTab
    x := cl[CurrentPanelTab]
    If !x
       Return

    Gui, SettingsGUIA: ListView, LViewMeta%x%
    isOkay := (b="k" && c=32) || (b="DoubleClick") ? 1 : 0
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(dateu, RowNumber, 2)

    ; ToolTip, % A_GuiEvent "=" A_EventInfo , , , 2
    If (StrLen(dateu)<3  || !isOkay)
       Return

    BtnALLviewedImages2List(dateu "|filteru|")
    prevOpenedWindow := [39, "PanelSeenStats", 1, 0, 0, userimgQuality]
}

IndexStatsLVaction(CtrlHwnd:=0, b:=0, c:=0) {
    GuiControlGet, varu, SettingsGUIA: FocusV
    isOkay := (b="k" && c=32) || (b="DoubleClick") ? 1 : 0
    If (!InStr(varu, "LViewMeta") || !isOkay)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, % varu
    GuiControlGet, CurrentPanelTab
    ; MouseGetPos, , , OutputVarWin, OutputVarControl, 3
    RowNumber := LV_GetNext()
    LV_GetText(dateu, RowNumber, 2)
    If (StrLen(dateu)<1 || dateu="date" || InStr(dateu, "file"))
       Return

    r := BtnIndexStatsToList(RowNumber, dateu, varu, 0)
    If (SLDtypeLoaded!=3 && r)
    {
       coreEnableFiltru(r)
       currentFileIndex := maxFilesIndex
       dummyTimerDelayiedImageDisplay(100)
    }
}

BtnIndexStatsToList(RowNumber, dateu, LVvaru, givenQuery) {
   Static minz := {1:0, 2:4999, 3:10002, 4:25002, 5:50002, 6:100002, 7:250002, 8:500002, 9:1000002, 10:2500002, 11:5000002, 12:10000002, 13:25000002, 14:50000002, 15:100000002, 16:250000002}
        , maxz := {1:4998, 2:10001, 3:25001, 4:50001, 5:100001, 6:250001, 7:500001, 8:1000001, 9:2500001, 10:5000001, 11:10000001, 12:25000001, 13:50000001, 14:100000001, 15:250000001, 16:500000001}

   ; ToolTip, % RowNumber "==" dateu "==" LVvaru , , , 2
   winOpen := AnyWindowOpen
   If (AnyWindowOpen && LVvaru!="none")
      BtnCloseWindow()

   If askAboutFileSave(" and the files list will be filtered to given criteria")
      Return -1

   setImageLoading()
   If (LVvaru="none" && SLDtypeLoaded=3)
   {
      showTOOLtip("Retrieving entire files list SQL index, please wait")
   } Else
   {
      showTOOLtip("Gathering entries matching " dateu ", please wait")
      setWindowTitle("Gathering entries matching " dateu ", please wait...", 1)
      If (InStr(LVvaru, "metaT") && winOpen!=48)
      {
         If (SLDtypeLoaded=3)
         {
            givenQuery := "WHERE imgfile LIKE '%." dateu "'"
            LVvaru := "custom"
         } Else
         {
            UsrEditFilter := "(\." dateu ")$"
            userFilterInvertThis := 0
            userFilterStringPos := 4
            userFilterProperty := userFilterWhat := userFilterDoString := 1
            coreEnableFiltru("\>" UsrEditFilter)
            Return
         }
      }
   }

   oDateu := dateu
   arDateu := StrSplit(oDateu, "-")
   RecordSet := ""
   If (winOpen!=48)
      dateu := StrReplace(dateu, "-")

   minRange := (winOpen=48) ? arDateu[1] : minz[RowNumber]
   maxRange := (winOpen=48) ? arDateu[2] : maxz[RowNumber]
   ftableu := (uiPreferedFileStats=1) ? "fmodified" : "Fcreated"

   If !dataColumn
      dataColumn := InStr(LVvaru, "metaS") ? "fsize" : ftableu

   sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
   reorder := StrLen(prevFilesSortMode)>3 ? " ORDER BY " prevFilesSortMode sortMode ";" : " ORDER BY imgidu;"
   k := 14 - StrLen(dateu)
   If (LVvaru="custom")
   {
      theQuery := givenQuery
      theQueryNonDB := givenQuery
   } Else If (LVvaru="none")
   {
      theQuery := ""
      theQueryNonDB := ""
   } Else If (winOpen=48)
   {
      If InStr(LVvaru, "metaM")
      {
         userFilterProperty := 9
         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := FilteruMaxRange := Round(dateu)
         theQuery := "WHERE imgframes='" dateu "'"
         theQueryNonDB := "QPV::query::imgframes::" dateu ":: " dateu
      } Else If InStr(LVvaru, "metaS")
      {
         userFilterDoString := 0
         theQuery := "WHERE imgpixfmt LIKE '" dateu "'"
         theQueryNonDB := "QPV::query::imgpixfmt::" dateu "::" dateu
      } Else If InStr(LVvaru, "metaD")
      {
         userFilterProperty := 5
         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := Floor(dateu)
         FilteruMAxRange := Ceil(dateu)
         theQuery := "WHERE Round(imgmegapix, 1) BETWEEN " dateu " AND " dateu
         theQueryNonDB := "QPV::query::imgmegapix::" dateu "::" dateu
      } Else If InStr(LVvaru, "metaU")
      {
         userFilterProperty := 10
         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := FilteruMAxRange := Round(dateu)
         theQuery := "WHERE imgdpi='" dateu "'"
         theQueryNonDB := "QPV::query::imgdpi::" dateu "::" dateu
      } Else If InStr(LVvaru, "metaY")
      {
         userFilterInvertThis := userFilterProperty := 8
         FilteruMinRange := Round(dateu*10)
         FilteruMAxRange := Round(dateu*10)
         theQuery := "WHERE Round(imgwhratio, 1) BETWEEN " dateu " AND " dateu
         theQueryNonDB := "QPV::query::imgwhratio::" dateu ":: " dateu
      } Else If (InStr(LVvaru, "metaA") || InStr(LVvaru, "metaR") || InStr(LVvaru, "metaI") || InStr(LVvaru, "metaT") || InStr(LVvaru, "metaG"))
      {
         If InStr(LVvaru, "metaA")
         {
            userFilterProperty := 13
            dataColumn := "imghpeak"
         } Else If InStr(LVvaru, "metaI")
         {
            userFilterProperty := 14
            dataColumn := "imghlow"
         } Else If InStr(LVvaru, "metaR")
         {
            userFilterProperty := 15
            dataColumn := "imghrange"
         } Else If InStr(LVvaru, "metaT")
         {
            userFilterProperty := 11
            dataColumn := "imgavg"
         } Else If InStr(LVvaru, "metaG")
         {
            userFilterProperty := 12
            dataColumn := "imgmedian"
         }

         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := Round(minRange)
         FilteruMaxRange := Round(maxRange)
         minRange := Round((minRange + 1)/256, 3)
         maxRange := Round((maxRange + 1)/256, 3)
         theQuery := "WHERE Round(" dataColumn ", 2) BETWEEN " minRange " AND " maxRange
         theQueryNonDB := "QPV::query::" dataColumn "::" minRange "::" maxRange
      }
   } Else
   {
      If (InStr(LVvaru, "metaD") || InStr(LVvaru, "metaM") || InStr(LVvaru, "metaY") || InStr(LVvaru, "LIKE"))
      {
         userFilterProperty := 3
         userFilterInvertThis := userFilterDoString := 0
         FilteruDateMaxRange := FilteruDateMinRange := Format("{1}{2:" k "}", dateu, 0)
         theQuery := "WHERE " dataColumn " LIKE '" dateu "%'"
         theQueryNonDB := "QPV::query::" dataColumn "::" FilteruDateMinRange "::" FilteruDateMaxRange
         theQueryNonDB := StrReplace(theQueryNonDB, A_Space, 0)
      } Else If (InStr(LVvaru, "metaS") || InStr(LVvaru, "BETWEEN"))
      {
         userFilterProperty := 2
         userFilterSizeProperty := 1
         userFilterInvertThis := userFilterDoString := 0
         FilteruMinRange := Round(minRange/1024)
         FilteruMaxRange := Round(maxRange/1024)
         theQuery := "WHERE " dataColumn " BETWEEN " minRange " AND " maxRange
         theQueryNonDB := "QPV::query::" dataColumn "::" minRange "::" maxRange
      }
   }

   If (SLDtypeLoaded=3)
   {
      If !getMaxRowIDsqlDB()
         Return -1

      If !RegExMatch(prevFilesSortMode, "i)(fsize|fmodified|fcreated|imgfile|imgfolder)")
         moreCol := StrLen(prevFilesSortMode)>3 ? ", " prevFilesSortMode : ""
      SQLstr := "SELECT imgidu, fullPath" moreCol " FROM images " theQuery reorder
      ; ToolTip, % SQLstr , , , 2
      If !InitSQLgetTable(SQLstr, activeSQLdb._Handle, errMsg, Rows, Cols, hTable)
      {
         showTOOLtip("ERROR: Failed to open the SQL database:`n" errMsg)
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return -1
      }
   } Else Return theQueryNonDB

   If (Rows<1)
   {
      showTOOLtip("WARNING: No records found in the database matching the query:`n" SQLstr)
      disposeSQLgetTableHandle(hTable)
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   markedSelectFile := 0
   startOperation := A_TickCount
   ; ToolTip, % filesFilter , , , 2
   If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:") && LVvaru!="none")
      remFilesListFilter("simple")

   If (StrLen(filesFilter)<2 && LVvaru!="none")
   {
      bckpResultedFilesList := []
      bckpResultedFilesList := resultedFilesList.Clone()
      bckpMaxFilesIndex := maxFilesIndex
   }

   If (LVvaru!="none")
      showTOOLtip("Generating files list index for " oDateu)

   renewCurrentFilesList()
   performSQLgetTable(Rows, Cols, hTable)
   disposeSQLgetTableHandle(hTable)
   newStaticFoldersListCache := []
   If (LVvaru!="none")
      filesFilter := "SQL:query:" theQuery
   ;  MsgBox, % maxFilesIndex " --- " RecordSet.RowCount
   ForceRefreshNowThumbsList()
   GenerateRandyList()
   CurrentSLD := backCurrentSLD
   If (LVvaru!="none")
   {
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, -500
      SetTimer, ResetImgLoadStatus, -50
      RandomPicture()
   }
}

PlotSeenHourStatsNow() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaH
   LV_ModifyCol(2, "SortDesc")
   widthu := maxValu := maxKvalu := aR := aC := totalu := 0
   dataArray := []
   namesLabel:= new hashtable()
   Loop, 24
   {
       dataArray[A_Index] := 1
       namesLabel[A_Index] := (A_Index < 10) ? "0" . A_Index : A_Index
   }

   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }

       LV_GetText(valu, aR, aC)
       If (isNumber(valu) && aC=3)
       {
          LV_GetText(oindexu, aR, 2)
          oindexu := SubStr(oindexu, 1, 2)
          indexu := (oindexu="00" || !oindexu) ? "24" : LTrim(oindexu, 0)
          thisu := max(maxValu, valu)
          If (thisu!=maxValu)
          {
             maxValu := thisu
             maxKvalu := oindexu
          }

          totalu += valu
          dataArray[indexu] := valu ? valu : 1
          ; namesLabel[indexu] := oindexu
       }
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   itemz := LV_GetCount()
   avgu := groupDigits(Floor(totalu/24))
   vpWinClientSize(W, H)
   Gdip_GraphicsClear(2NDglPG)
   textu := "Seen images chart: HOURS.`nRange: 01:00 to 24:00.`nAverage: " avgu ". Peak at " maxKvalu "h: " groupDigits(maxValu)
   infoBoxBMP := drawTextInBox(textu, OSDFontName, OSDfontSize, w, h, OSDtextColor, OSDbgrColor, 1, 0)
   Scale := imgHUDbaseUnit/40
   ; hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
   tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
   tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
   borderSizeX := imgHUDbaseUnit//10 + tlbrBonusX
   borderSizeY := imgHUDbaseUnit//10 + tlbrBonusY
   plotBMP := BarChart(dataArray, namesLabel, Round(196*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:2, BarHeight:" Scale*3.5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,TextSize:" OSDfontSize//2+1 " BarTextColor:ff999999, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)
   recordGdipBitmaps(plotBMP, A_ThisFunc "<-BarChart()")
   trGdip_GetImageDimensions(plotBMP, imgW, imgH)
   trGdip_GetImageDimensions(infoBoxBMP, boxW, boxH)
   If (imgH>H - boxH - borderSizeY*2)
   {
      plotBMP := resizeBitmapToGivenRef(plotBMP, 0, imgW, H - boxH - borderSizeY*2, 7, 0)
      trGdip_GetImageDimensions(plotBMP, imgW, imgH)
   }

   pBrush := Gdip_BrushCreateSolid("0xee" OSDbgrColor)
   Gdip_FillRectangle(2NDglPG, pBrush, 0, 0, max(imgW, boxW) + borderSizeX, imgH + borderSizeY)
   tzGdip_DrawImage(2NDglPG, plotBMP, borderSizeX, borderSizeY)
   tzGdip_DrawImage(2NDglPG, infoBoxBMP, tlbrBonusX, imgH + borderSizeY)
   trGdip_DisposeImage(infoBoxBMP, 1)
   trGdip_DisposeImage(plotBMP, 1)
   ResetImgLoadStatus()
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   toolTipGuiCreated := 2
   ; ToolTip, % maxValu "=" widthu , , , 2
}

PlotSeenMonthsStatsNow() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaM
   LV_ModifyCol(2, "SortDesc")
   widthu := maxValu := maxKvalu := aR := aC := totalu := 0
   dataArray := []
   namesLabel:= []
   dataSkipped := new hashtable()
   LV_GetText(endPeriod, 1, 2)
   LV_GetText(startPeriod, LV_GetCount(), 2)

   nYear := SubStr(startPeriod, 1, 4)
   nMon:= LTrim(SubStr(startPeriod, 6, 2), "0")
   Loop
   {
      If (nMon>12)
      {
         nMon := 0
         nYear++
      }

      nMon++
      If (nMon=13)
         Continue

      thisM := (nMon<10) ? "0" . nMon : nMon
      dateu := nYear "-" thisM
      If (dateu=endPeriod)
         Break

      If (nYear thisM>=202004)
         dataSkipped[dateu] := 1
   }

   ; ToolTip, % startPeriod "`n" endPeriod , , , 2
   counter := 1
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }

       LV_GetText(valu, aR, aC)
       If (isNumber(valu) && aC=3)
       {
          LV_GetText(oindexu, aR, 2)
          ; oindexu := SubStr(oindexu, 1, 2)
          thisu := max(maxValu, valu)
          If (thisu!=maxValu)
          {
             maxValu := thisu
             maxKvalu := oindexu
          }
          ; fnOutputDebug(A_ThisFunc "==="  oindexu "|" counter "|" valu)
          totalu += valu
          dataArray[counter] := valu ? valu : 1
          namesLabel[counter] := oindexu
          dataSkipped[oindexu] := valu ? 0 : 1
          counter++
       }
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   countSkipped := 0
   For Key, Value in dataSkipped
   {
      If (Value=1)
         countSkipped++
   }

   lacking := (countSkipped>0) ? groupDigits(countSkipped) " months lack data." : ""
   itemz := LV_GetCount()
   avgu := groupDigits(Floor(totalu/counter))
   vpWinClientSize(W, H)
   Gdip_GraphicsClear(2NDglPG)
   textu := "Seen images chart: MONTHS`nTotal: " groupDigits(counter) " months. " lacking "`nRange: " startPeriod " - " endPeriod "`nAverage: " avgu ". Peak on " maxKvalu "=" groupDigits(maxValu)
   infoBoxBMP := drawTextInBox(textu, OSDFontName, OSDfontSize, w, h, OSDtextColor, OSDbgrColor, 1, 0)
   Scale := imgHUDbaseUnit/40

   ; hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
   tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
   tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
   borderSizeX := imgHUDbaseUnit//10 + tlbrBonusX
   borderSizeY := imgHUDbaseUnit//10 + tlbrBonusY
   If (counter>20)
      plotBMP := BarChart(dataArray, namesLabel, Round(106*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:0, BarHeight:" Scale*5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,TextSize:0, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)
   Else
      plotBMP := BarChart(dataArray, namesLabel, Round(196*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:2, BarHeight:" Scale*3.5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,BarTextColor:ff999999, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)

   recordGdipBitmaps(plotBMP, A_ThisFunc "<-BarChart()")
   Gdip_ImageRotateFlip(plotBMP, 6)
   trGdip_GetImageDimensions(plotBMP, imgW, imgH)
   trGdip_GetImageDimensions(infoBoxBMP, boxW, boxH)
   If (imgH>H - boxH - borderSizeY*2)
   {
      plotBMP := resizeBitmapToGivenRef(plotBMP, 0, imgW, H - boxH - borderSizeY*2, 7, 0)
      trGdip_GetImageDimensions(plotBMP, imgW, imgH)
   }

   pBrush := Gdip_BrushCreateSolid("0xee" OSDbgrColor)
   Gdip_FillRectangle(2NDglPG, pBrush, 0, 0, max(imgW, boxW) + borderSizeX, imgH + borderSizeY)
   tzGdip_DrawImage(2NDglPG, plotBMP, borderSizeX, borderSizeY)
   tzGdip_DrawImage(2NDglPG, infoBoxBMP, tlbrBonusX, imgH + borderSizeY)
   trGdip_DisposeImage(infoBoxBMP, 1)
   trGdip_DisposeImage(plotBMP, 1)
   ResetImgLoadStatus()
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   toolTipGuiCreated := 2
   ; ToolTip, % maxValu "=" widthu , , , 2
}

JEE_DateIsValid(vDate) {
   FormatTime, vDate, % vDate, d
   return vDate ? 1 : 0
}

aidAvgHCalc(arrayu, indexu) {
   Static lastValue := 0
   If (arrayu[indexu]="")
      Return lastValue

   lastValue := arrayu[indexu]
   Return lastValue
}

PlotSeenDaysToggleStatsNow() {
   Static lastInvoked := 0
   If !lastInvoked
      PlotSeenDaysStatsNow(0)
   Else If (lastInvoked=1)
      PlotSeenDaysStatsNow("avg-7")
   Else If (lastInvoked=2)
      PlotSeenDaysStatsNow("avg-15")
   Else If (lastInvoked=3)
      PlotSeenDaysStatsNow("avg-30")
   Else
      PlotSeenDaysStatsNow("avg-60")

   lastInvoked := clampInRange(lastInvoked + 1, 0, 4, 1)
}

PlotSeenDaysStatsNow(modus:=0) {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaD
   LV_ModifyCol(2, "SortDesc")
   widthu := maxValu := maxKvalu := aR := aC := totalu := 0
   dataArray := []
   dataAvg := []
   dataSkipped := new hashtable()
   LV_GetText(endPeriod, 1, 2)
   LV_GetText(startPeriod, LV_GetCount(), 2)
   nYear := SubStr(startPeriod, 1, 4)
   nMon:= LTrim(SubStr(startPeriod, 6, 2), "0")
   nDay:= LTrim(SubStr(startPeriod, 9, 2), "0")
   Loop
   {
      nDay++
      thisM := (nMon<10) ? "0" . nMon : nMon
      thisD := (nDay<10) ? "0" . nDay : nDay
      If !JEE_DateIsValid(nYear . thisM . thisD)
      {
         nMon++
         nDay := 1
         thisM := (nMon<10) ? "0" . nMon : nMon
         thisD := (nDay<10) ? "0" . nDay : nDay
      }

      If (nMon>12)
      {
         nMon := 1
         nDay := 0
         thisM := (nMon<10) ? "0" . nMon : nMon
         thisD := (nDay<10) ? "0" . nDay : nDay
         nYear++
      }

      dateu := nYear "-" thisM "-" thisD
      If (nYear . thisM>20200401)
         dataSkipped[dateu] := 1

      If (dateu=endPeriod)
         Break
   }

   counter := 0
   avgLevel := InStr(modus, "avg-") ? SubStr(modus, 5, 2) : 0 
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }

       LV_GetText(valu, aR, aC)
       If (isNumber(valu) && aC=3)
       {
          LV_GetText(oindexu, aR, 2)
          If InStr(oindexu, "1999-")
             Continue

          ; oindexu := SubStr(oindexu, 1, 2)
          thisu := max(maxValu, valu)
          If (thisu!=maxValu)
          {
             maxValu := thisu
             maxKvalu := oindexu
          }
          counter++
          totalu += valu
          dataSkipped[oIndexu] := valu ? 0 : 1
          dataArray[counter] := valu ? valu : 1
          If (counter=1)
             aidAvgHCalc(dataArray, 1)

          If InStr(modus, "avg-")
          {
             sumu := 0
             Loop, % avgLevel
                 sumu += aidAvgHCalc(dataArray, counter - A_Index)
             dataAvg[counter] := (dataArray[counter] + sumu)/(avgLevel + 1)
          }
       }
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   countSkipped := 0
   For Key, Value in dataSkipped
   {
      If (Value=1)
         countSkipped++
   }

   lacking := (countSkipped>0) ? groupDigits(countSkipped) " days lack data." : ""
   itemz := LV_GetCount()
   avgu := groupDigits(Floor(totalu/counter))
   vpWinClientSize(W, H)
   Gdip_GraphicsClear(2NDglPG)
   friendly := InStr(modus, "avg-") ? avgLevel " DAYS AVERAGED" : "DAYS"
   textu := "Seen images chart: " friendly "`nTotal: " groupDigits(counter) " days. " lacking "`nRange: " startPeriod " - " endPeriod "`nAverage: " avgu ". Peak on: " maxKvalu "=" groupDigits(maxValu)
   infoBoxBMP := drawTextInBox(textu, OSDFontName, OSDfontSize, w, h, OSDtextColor, OSDbgrColor, 1, 0)
   Scale := imgHUDbaseUnit/40
   ; hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
   tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
   tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
   borderSize := (counter>200) ? imgHUDbaseUnit/60 : imgHUDbaseUnit/10
   borderSizeX := borderSize + tlbrBonusX
   borderSizeY := borderSize + tlbrBonusY

   If (counter>(avgLevel*2 + 1) && InStr(modus, "avg-"))
      plotBMP := BarChart(dataAvg, namesLabel, Round(106*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:0, BarHeight:" Scale*5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,TextSize:0, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)
   Else If (counter>20)
      plotBMP := BarChart(dataArray, namesLabel, Round(106*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:0, BarHeight:" Scale*5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,TextSize:0, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)
   Else
      plotBMP := BarChart(dataArray, namesLabel, Round(196*Scale), 385, "", "DiagonBlackGreen", "DisplayValues:2, BarHeight:" Scale*3.5 ",BarHeightFactor:1, BarSpacing:" Scale/2 ",BarRoundness:0,AutoCalculateHeight:1, BarColorDirection:2, BgrStyle:3, BarBorderColor:0,BarTextColor:ff999999, BarColorA:ff" OSDtextColor ", ChartBackColorA:00" OSDbgrColor)

   recordGdipBitmaps(plotBMP, A_ThisFunc "<-BarChart()")
   Gdip_ImageRotateFlip(plotBMP, 6)
   trGdip_GetImageDimensions(plotBMP, imgW, imgH)
   trGdip_GetImageDimensions(infoBoxBMP, boxW, boxH)
   If (imgH>H - boxH - borderSizeY*2)
   {
      plotBMP := resizeBitmapToGivenRef(plotBMP, 0, imgW, H - boxH - borderSizeY*2, 7, 0)
      trGdip_GetImageDimensions(plotBMP, imgW, imgH)
   }

   pBrush := Gdip_BrushCreateSolid("0xee" OSDbgrColor)
   Gdip_FillRectangle(2NDglPG, pBrush, 0, 0, max(imgW, boxW) + borderSizeX, imgH + borderSizeY)
   tzGdip_DrawImage(2NDglPG, plotBMP, borderSizeX, borderSizeY)
   tzGdip_DrawImage(2NDglPG, infoBoxBMP, tlbrBonusX, imgH + borderSizeY)
   trGdip_DisposeImage(infoBoxBMP, 1)
   trGdip_DisposeImage(plotBMP, 1)
   ResetImgLoadStatus()
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   toolTipGuiCreated := 2
   ; ToolTip, % maxValu "=" widthu , , , 2
}

BtnCopySeenStats() {
   textu .= "`nMONTHLY SEEN IMAGES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaM", 4)
   textu .= "`nDAILY SEEN IMAGES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaD", 4)
   textu .= "`nHOURLY SEEN IMAGES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaH", 4)

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Failed to copy to clipboard")
         SoundBeep , 300, 100
      } Else showTOOLtip("Images seen statistics copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

getListViewData(guiu, lvu, cols, userDelim:=" | ") {
   Gui, %guiu%: Default
   Gui, %guiu%: ListView, %lvu%

   aR := aC := 0
   textu := ""
   Loop
   {
       aC++
       If (aC>cols)
       {
          aR++
          aC := 1
       }

       LV_GetText(valu, aR, aC)
       delimu := (aC!=cols) ? userDelim : "`n"
       If (valu!="")
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }
   Return textu
}

BtnCopyFileStats() {
   friendly := (uiPreferedFileStats=1) ? "MODIFIED" : "CREATED"
   textu .= "`nFILES " friendly ": DAYS:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaD", 4)
   textu .= "`nFILES " friendly ": MONTHS:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaM", 4)
   textu .= "`nFILES " friendly ": YEARS:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaY", 4)
   textu .= "`nFILE TYPES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaT", 4)
   textu .= "`nFILE SIZES:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaS", 5)

   Gui, SettingsGUIA: Default
   GuiControlGet, infoLine
   textu .= "`n" infoLine "`n"

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Failed to copy to clipboard")
         SoundBeep , 300, 100
      } Else showTOOLtip("Image file properties statistics copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BtnCopyImageFileStats() {
   Gui, SettingsGUIA: Default
   GuiControlGet, infoLine
   textu := "`n" infoLine "`n"

   textu .="This text file contains data about these images detailing the prevalence of megapixels, aspect ratios, DPI, frames, pixel formats and histograms main data points.`n"

   textu .= "`nIMAGES: MEGAPIXELS`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaD", 4)
   textu .= "`nIMAGES: ASPECT RATIOS`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaY", 4)
   textu .= "`nIMAGES: DPIs`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaU", 4)
   textu .= "`nIMAGES: FRAMES`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaM", 4)
   textu .= "`nIMAGES: PIXEL FORMATS`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaS", 4)

   textu .= "`nIMAGES: HISTOGRAM - AVERAGES`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaG", 4)
   textu .= "`nIMAGES: HISTOGRAM - MEDIANS`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaA", 4)
   textu .= "`nIMAGES: HISTOGRAM - PEAK (RANGE)`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaI", 4)
   textu .= "`nIMAGES: HISTOGRAM - MINIMUM (RANGE)`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaT", 4)
   textu .= "`nIMAGES: HISTOGRAM - TOTAL (RANGE)`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaR", 4)

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Failed to copy to clipboard")
         SoundBeep , 300, 100
      } Else showTOOLtip("Image file properties statistics copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateSeenStatsInfos() {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  entriesCount := 0
  RecordSet := ""
  SQL := "SELECT imgViewDate, COUNT(*) FROM images GROUP BY imgViewDate;"
  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entriesD := []
  entriesM := []
  entriesH := []
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[1]
      {
         dateuD := "z" StrReplace(SubStr(Rowu[1], 1, 10), "-")
         dateuM := "z" StrReplace(SubStr(Rowu[1], 1, 7), "-")
         dateuH := "z" StrReplace(SubStr(Rowu[1], 12, 2), "-")
         entriez%dateuD% += Rowu[2]
         entriez%dateuM% += Rowu[2]
         entriez%dateuH% += Rowu[2]
         entriesCount += Rowu[2]
         entriesD[dateuD] := [entriez%dateuD%, SubStr(Rowu[1], 1, 10)]
         entriesM[dateuM] := [entriez%dateuM%, SubStr(Rowu[1], 1, 7)]
         entriesH[dateuH] := [entriez%dateuH%, SubStr(Rowu[1], 12, 2)]
      }
  }

  RecordSet.Free()
  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaD
  GuiControl, -Redraw, LViewMetaD
  GuiControl, -Redraw, LViewMetaM
  GuiControl, -Redraw, LViewMetaH
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesD
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaH
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesH
      LV_Add(A_Index, A_Index, Value[2] ":00", Value[1], Round((Value[1]/entriesCount)*100,1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  GuiControl, +Redraw, LViewMetaD
  GuiControl, +Redraw, LViewMetaM
  GuiControl, +Redraw, LViewMetaH
  entriesCount := groupDigits(entriesCount)
  GuiControl, SettingsGUIA:, infoLine, Total seen images: %entriesCount%
}

QPV_FileGetSizeTime(imgPath, type, imgIndex, b:=0) {
    Switch type
    {
       Case "S":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 6] : resultedFilesList[imgIndex, 6]
       Case "M":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 7] : resultedFilesList[imgIndex, 7]
       Case "C":
          r := (b=1) ? bckpResultedFilesList[imgIndex, 8] : resultedFilesList[imgIndex, 8]
       Case "R":
          r := 0
    }

    If !r
    {
       obju := GetFileAttributesEx(imgPath)
       updateFilesListByID(imgIndex, 6, obju.size, b)
       updateFilesListByID(imgIndex, 7, obju.wTime, b)
       updateFilesListByID(imgIndex, 8, obju.cTime, b)
       Switch type
       {
          Case "S":
             r := obju.size
          Case "M":
             r := obju.wTime
          Case "C":
             r := obju.cTime
       }
    }
    Return r
}

ETAinfos(countTFilez, filesElected, startOperation) {
   Static prevTick := 0, prevStartu, prevTimes := [], prevCountTFilez := 0, prevAvg := 0, prevZeit := 0, prevTotal
   If (prevStartu!=startOperation || countTFilez<prevCountTFilez || prevTotal!=filesElected)
   {
      prevTimes := []
      prevZeit := prevCountTFilez := prevTick := prevAvg := 0
   }

   prevTick++
   thisAmount := countTFilez - prevCountTFilez
   prevTimes.Push([thisAmount, A_TickCount])
   If (prevTick=5)
      prevTimes.RemoveAt(1)

   prevCountTFilez := countTFilez
   theSum := 0
   loops := prevTimes.Count()
   Loop, % loops
       theSum += Round(prevTimes[A_Index, 1])

   theAvg := Round(theSum/loops, 6)
   If prevAvg
      theAvg := Round((prevAvg+theAvg)/2, 6)

   prevAvg := theAvg
   prevTotal := filesElected
   intervalA := Round(prevTimes[2, 2] - prevTimes[1, 2])
   intervalB := Round(prevTimes[3, 2] - prevTimes[2, 2])
   intervalC := Round(prevTimes[4, 2] - prevTimes[3, 2])
   interval := Round((1 + intervalA + intervalB + intervalC)/3, 6)
   zeitLeftA := Round(((filesElected - countTFilez)/theAvg)*interval)
   ; ToolTip, % loops " == " prevTick " == " theSum " == " theAvg , , , 2

   prevTick := clampInRange(prevTick, 1, 4)
   prevStartu := startOperation

   zeitOperation := A_TickCount - startOperation
   percDone := " ( " Round((countTFilez / filesElected) * 100, 1) "% )"
   percLeft := (1 - countTFilez / filesElected) * 100
   zeitLeftB := (zeitOperation/countTFilez) * filesElected - zeitOperation
   etaTime := "`n" groupDigits(countTFilez) " / " groupDigits(filesElected) percDone
   If (A_TickCount - startOperation<2500)
      zeitC := (zeitLeftA+zeitLeftB)/2
   If (A_TickCount - startOperation<5000)
      zeitC := (zeitLeftA+zeitLeftA+zeitLeftB)/3
   Else If (A_TickCount - startOperation<9500)
      zeitC := (zeitLeftA+zeitLeftA+zeitLeftA+zeitLeftB)/4
   Else
      zeitC := zeitLeftA

   zeitF := prevZeit ? (Round(zeitC) + Round(prevZeit))/2 : zeitC
   If !zeitF
      zeitF := zeitLeftB

   prevZeit := zeitC
   etaTime .= "`nEstimated time left: " SecToHHMMSS(Round(zeitF/1000, 3))
   ; etaTime .= "`nEstimated B time left: " SecToHHMMSS(Round(zeitLeft2/1000, 3))
   etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
   Return etaTime
}

collectImageInfosNow(queryString:=0, modus:=0, simple:=0) {
    ; If StrLen(filesFilter)>1
    ;    remFilesListFilter("simple")

    doStartLongOpDance()
    If (simple=1)
    {
       backCurrentSLD := CurrentSLD
       CurrentSLD := ""
    }

    showTOOLtip("Collecting image details, please wait`n0 / " groupDigits(maxFilesIndex))
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
    isFilter := StrLen(filesFilter)>2 ? 1 : 0
    failedFiles := abandonAll := 0
    zEffect := (modus=11) ? Gdip_CreateEffect(6, 0, -100, 0) : 0
    Loop, % thisMaxCount
    {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
          If failedFiles
             etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

          showTOOLtip("Collecting image details, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
          prevMSGdisplay := A_TickCount
       }

       If (modus=9)
          testThis := !isFilter ? resultedFilesList[A_Index, 9] : bckpResultedFilesList[A_Index, 9]
       Else
          testThis := !isFilter ? resultedFilesList[A_Index, 11] : bckpResultedFilesList[A_Index, 11]

       If testThis
          Continue

       imgPath := !isFilter ? resultedFilesList[A_Index, 1] : bckpResultedFilesList[A_Index, 1]
       If queryString
       {
          If !coreSearchIndex(imgPath, queryString, userFilterWhat, userFilterStringIsNot)
             Continue
       }

       thisIndex := A_Index
       If (modus=9)
       {
          r := GetCachableImgFileDetails(imgPath, A_Index, 0, 0, isFilter)
       } Else
       {
          fileInfos := GetFileAttributesEx(imgPath)
          updateFilesListByID(A_Index, 6, fileInfos.size, isFilter)
          updateFilesListByID(A_Index, 7, fileInfos.wTime, isFilter)
          updateFilesListByID(A_Index, 8, fileInfos.cTime, isFilter)
          r := GetCachableHistogramFile(imgPath, A_Index, 0, isFilter, zEffect)
       }

       If !r
          failedFiles++
       ; ; ToolTip, % s "`n" m "`n" , , , 2
       ; Sleep, 200
    }
    ; k := resultedFilesList[3, 7]
    ; ToolTip, % k , , , 2

    Gdip_DisposeEffect(zEffect)
    PopulateIndexFilesStatsInfos("kill")
    SetTimer, ResetImgLoadStatus, -150
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    If (abandonAll!=1)
       SoundBeep, 900, 100

    If (simple=1)
    {
       CurrentSLD := backCurrentSLD
       percDone := " ( " Round((thisIndex / thisMaxCount) * 100, 1) "% )"
       If failedFiles
          percDone .= "`nFailed to collect data for " groupDigits(failedFiles) " files"

       If (abandonAll=1)
       {
          showTOOLtip("Operation abandoned. " groupDigits(thisIndex) " / " groupDigits(thisMaxCount)) percDone
          SoundBeep, 300, 100
       } Else If (abandonAll=1)
          showTOOLtip("Finished collecting data for " groupDigits(thisMaxCount)) " files"

       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -150
       Return
    }
    Return abandonAll
}

collectFileInfosNow(queryString:=0) {
    ; If StrLen(filesFilter)>1
    ;    remFilesListFilter("simple")

    doStartLongOpDance()
    showTOOLtip("Collecting file details, please wait`n0 / " groupDigits(maxFilesIndex))
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
    isFilter := StrLen(filesFilter)>2 ? 1 : 0
    abandonAll := 0
    Loop, % thisMaxCount
    {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
          showTOOLtip("Collecting file details, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
          prevMSGdisplay := A_TickCount
       }

       testThis := !isFilter ? resultedFilesList[A_Index, 6] : bckpResultedFilesList[A_Index, 6]
       If testThis
          Continue

       If queryString
       {
          r := !isFilter ? resultedFilesList[A_Index, 1] : bckpResultedFilesList[A_Index, 1]
          If !coreSearchIndex(r, queryString, userFilterWhat, userFilterStringIsNot)
             Continue
       }

       If !isFilter
          obju := GetFileAttributesEx(resultedFilesList[A_Index, 1])
       Else
          obju := GetFileAttributesEx(bckpResultedFilesList[A_Index, 1])

       updateFilesListByID(A_Index, 6, obju.size ? obju.size : 1, isFilter)
       updateFilesListByID(A_Index, 7, obju.wTime, isFilter)
       updateFilesListByID(A_Index, 8, obju.cTime, isFilter)
       ; ; ToolTip, % s "`n" m "`n" , , , 2
       ; Sleep, 200
    }

    ; k := resultedFilesList[3, 7]
    ; ToolTip, % k , , , 2
    PopulateIndexFilesStatsInfos("kill")
    SetTimer, ResetImgLoadStatus, -150
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    If (abandonAll!=1)
       SoundBeep, 900, 100

    Return abandonAll
}

PopulateIndexFilesStatsInfos(dummy:=0) {
  Static entriesD, entriesM, entriesY, entriesT, prevState, entriesCount, totalSizeu
      , sizer1, sizeTr1, sizer2, sizeTr2, sizer3, sizeTr3, sizer4, sizeTr4
      , sizer5, sizeTr5, sizer6, sizeTr6, sizer7, sizeTr7, sizer8, sizeTr8
      , sizer9, sizeTr9, sizer10, sizeTr10, sizer11, sizeTr11, sizer12, sizer16
      , sizeTr12, sizer13, sizeTr13, sizer14, sizeTr14, sizer15, sizeTr15, sizeTr16

  startZeit := A_TickCount
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  isFilter := StrLen(filesFilter)>2 ? 1 : 0

  If (dummy!="kill")
  {
     doStartLongOpDance()
     showTOOLtip("Generating statistics, please wait`n" groupDigits(thisMaxCount) " files")
     setImageLoading()
     thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  } Else prevState := ""

  If (thisState!=prevState || dummy="kill")
  {
     entriesCount := 0, sizer1:=0, sizeTr1:=0, sizer2:=0, sizeTr2:=0, sizer3:=0, sizeTr3:=0, sizer4:=0, sizeTr4:=0
     sizer5:=0, sizeTr5:=0, sizer6:=0, sizeTr6:=0, sizer7:=0, sizeTr7:=0, sizer8:=0, sizeTr8:=0, sizer9:=0, sizeTr9:=0
     sizer10:=0, sizeTr10:=0, sizer11:=0, sizeTr11:=0, sizer12:=0, sizeTr12:=0, sizer13:=0, sizeTr13:=0, sizer14:=0
     sizeTr14:=0, sizer15:=0, sizeTr15:=0, sizer16:=0, sizeTr16:=0, totalSizeu := 0

     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     If (dummy="kill")
     {
        ; bckpResultedFilesList := []
        ; filteredMap2mainList := []
        ; filesFilter := ""
        ; bckpMaxFilesIndex := 0
        prevState := ""
        PopulateIndexSQLFilesStatsInfos(dummy)
        PopulateImagesIndexStatsInfos(dummy)
        Return
     }

     whichDate := (uiPreferedFileStats=1) ? 7 : 8
     prevMSGdisplay := A_TickCount
     Loop, % thisMaxCount
     {
         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(A_Index, thisMaxCount, startZeit)
            showTOOLtip("Generating statistics, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }

         If (isFilter=1)
         {
            imgPath := bckpResultedFilesList[A_Index, 1]
            dateu := bckpResultedFilesList[A_Index, whichDate]
            sizeu := bckpResultedFilesList[A_Index, 6]
         } Else
         {
            imgPath := resultedFilesList[A_Index, 1]
            dateu := resultedFilesList[A_Index, whichDate]
            sizeu := resultedFilesList[A_Index, 6]
         }

         ; ToolTip, % imgPath "`n" dateu "`n" sizeu , , , 2
         foundPos := InStr(imgPath, ".", 0, -1)
         If foundPos
         {
            fileEXT := SubStr(imgPath, foundPos + 1)
            entriez%fileEXT%++
            entriesT[fileEXT] := [entriez%fileEXT%, fileEXT]
         }

         If dateu
         {
            dateuD := "z" SubStr(dateu, 1, 8)
            dateuM := "z" SubStr(dateu, 1, 6)
            dateuY := "z" SubStr(dateu, 1, 4)
            entriez%dateuD%++
            entriez%dateuM%++
            entriez%dateuY%++
            entriesD[dateuD] := [entriez%dateuD%, dateuD]
            entriesM[dateuM] := [entriez%dateuM%, dateuM]
            entriesY[dateuY] := [entriez%dateuY%, dateuY]
         }

         If (sizeu>0)
         {
            entriesCount++
            totalSizeu += Round(sizeu/(1024**2), 4)
            If (sizeu<=5000001)
            {
               If isInRange(sizeu, 0, 4998)
               {
                  sizeTr1 += sizeu
                  sizer1++
               } Else If isInRange(sizeu, 4999, 10001)
               {
                  sizeTr2 += sizeu
                  sizer2++
               } Else If isInRange(sizeu, 10002, 25001)
               {
                  sizeTr3 += sizeu
                  sizer3++
               } Else If isInRange(sizeu, 25002, 50001)
               {
                  sizeTr4 += sizeu
                  sizer4++
               } Else If isInRange(sizeu, 50002, 100001)
               {
                  sizeTr5 += sizeu
                  sizer5++
               } Else If isInRange(sizeu, 100002, 250001)
               {
                  sizeTr6 += sizeu
                  sizer6++
               } Else If isInRange(sizeu, 250002, 500001)
               {
                  sizeTr7 += sizeu
                  sizer7++
               } Else If isInRange(sizeu, 500002, 1000001)
               {
                  sizeTr8 += sizeu
                  sizer8++
               } Else If isInRange(sizeu, 1000002, 2500001)
               {
                  sizeTr9 += sizeu
                  sizer9++
               } Else If isInRange(sizeu, 2500002, 5000001)
               {
                  sizeTr10 += sizeu
                  sizer10++
               }
            } Else
            {
               If isInRange(sizeu, 5000002, 10000001)
               {
                  sizeTr11 += sizeu
                  sizer11++
               } Else If isInRange(sizeu, 10000002, 25000001)
               {
                  sizeTr12 += sizeu
                  sizer12++
               } Else If isInRange(sizeu, 25000002, 50000001)
               {
                  sizeTr13 += sizeu
                  sizer13++
               } Else If isInRange(sizeu, 50000002, 100000001)
               {
                  sizeTr14 += sizeu
                  sizer14++
               } Else If isInRange(sizeu, 100000002, 250000001)
               {
                  sizeTr15 += sizeu
                  sizer15++
               } Else If isInRange(sizeu, 250000002, 500000001)
               {
                  sizeTr16 += sizeu
                  sizer16++
               }
            }
         }

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            prevState := ""
            Break
         }
     }
     If (abandonAll!=1)
        prevState := thisState
  }

  entriesCount := StrReplace(entriesCount, A_Space)
  ; msgBox, % entriesCount "=" thisMaxCount
  If (entriesCount<Round(thisMaxCount - 1)) && (abandonAll!=1)
  {
     msgResult := msgBoxWrapper(appTitle ": Statistics", appTitle " has not yet indexed the files' details. These are required to populate this panel with statistics. Would you like to collect the data now? This may take awhile...", 4, 0, "question")
     If (msgResult="Yes")
     {
        prevState := ""
        RemoveTooltip()
        BtnCloseWindow()
        r := collectFileInfosNow()
        If !r
           SetTimer, PanelIndexedFilesStats, -250
        Return
     }
  }

  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     executingCanceableOperation := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }
 
  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaD
  GuiControl, -Redraw, LViewMetaD
  GuiControl, -Redraw, LViewMetaM
  GuiControl, -Redraw, LViewMetaY
  GuiControl, -Redraw, LViewMetaS
  GuiControl, -Redraw, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
  {
      stringu := ST_Insert("-", SubStr(Value[2], 2), 5)
      stringu := ST_Insert("-", stringu, 8)
      If (Value[1]>1)
         LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
  {
      stringu := ST_Insert("-", SubStr(Value[2], 2), 5)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, SubStr(Value[2], 2), Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  showTOOLtip("Generating statistics, please wait", 0, 0, 3/10)
  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  LV_Add(1, 1, "<5 KB", Round(sizeTr1/(1024**2), 1), sizer1, Round((sizer1/thisMaxCount)*100, 1))
  LV_Add(2, 2, "5-10 KB", Round(sizeTr2/(1024**2), 1), sizer2, Round((sizer2/thisMaxCount)*100, 1))
  LV_Add(3, 3, "10-25 KB", Round(sizeTr3/(1024**2), 1), sizer3, Round((sizer3/thisMaxCount)*100, 1))
  LV_Add(4, 4, "25-50 KB", Round(sizeTr4/(1024**2), 1), sizer4, Round((sizer4/thisMaxCount)*100, 1))
  LV_Add(5, 5, "50-100 KB", Round(sizeTr5/(1024**2), 1), sizer5, Round((sizer5/thisMaxCount)*100, 1))
  LV_Add(6, 6, "100-250 KB", Round(sizeTr6/(1024**2), 1), sizer6, Round((sizer6/thisMaxCount)*100, 1))
  LV_Add(7, 7, "250-500 KB", Round(sizeTr7/(1024**2), 1), sizer7, Round((sizer7/thisMaxCount)*100, 1))
  LV_Add(8, 8, "0.5-1.0 MB", Round(sizeTr8/(1024**2), 1), sizer8, Round((sizer8/thisMaxCount)*100, 1))
  LV_Add(9, 9, "1.0-2.5 MB", Round(sizeTr9/(1024**2), 1), sizer9, Round((sizer9/thisMaxCount)*100, 1))
  LV_Add(10, 10, "2.5-5.0 MB", Round(sizeTr10/(1024**2), 1), sizer10, Round((sizer10/thisMaxCount)*100, 1))
  LV_Add(11, 11, "5-10 MB", Round(sizeTr11/(1024**2), 1), sizer11, Round((sizer11/thisMaxCount)*100, 1))
  LV_Add(12, 12, "10-25 MB", Round(sizeTr12/(1024**2), 1), sizer12, Round((sizer12/thisMaxCount)*100, 1))
  LV_Add(13, 13, "25-50 MB", Round(sizeTr13/(1024**2), 1), sizer13, Round((sizer13/thisMaxCount)*100, 1))
  LV_Add(14, 14, "50-100 MB", Round(sizeTr14/(1024**2), 1), sizer14, Round((sizer14/thisMaxCount)*100, 1))
  LV_Add(15, 15, "100-250 MB", Round(sizeTr15/(1024**2), 1), sizer15, Round((sizer15/thisMaxCount)*100, 1))
  LV_Add(16, 16, "250-500 MB", Round(sizeTr16/(1024**2), 1), sizer16, Round((sizer16/thisMaxCount)*100, 1))

  Loop, 5
     LV_ModifyCol(A_Index, "AutoHdr Center")

  GuiControl, +Redraw, LViewMetaD
  GuiControl, +Redraw, LViewMetaM
  GuiControl, +Redraw, LViewMetaY
  GuiControl, +Redraw, LViewMetaS
  GuiControl, +Redraw, LViewMetaT
  entriesCount := groupDigits(entriesCount)
  totalFsize := Round(totalSizeu/1024, 1)
  GuiControl, SettingsGUIA:, infoLine, Total images: %entriesCount% [%totalFsize% GB]
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

retrieveGroupSQLimgInfos(which, thisGroup, totalgroups, constrain:="imgwidth") {
   showTOOLtip("Retrieving statistics from the database, please wait`n" thisGroup " / " totalgroups " ( " which " )", 0, 0, thisGroup/totalgroups)
   SQL := "SELECT " which ", Count(*) FROM images WHERE " constrain " IS NOT NULL GROUP BY " which ";"
   If activeSQLdb.GetTable(SQL, RecordSet)
   {
      newArrayu := []
      Loop, % RecordSet.RowCount
      {
         Rowu := RecordSet.Rows[A_Index]
         If (Rowu[1]!="")
            newArrayu[A_Index] := [Rowu[2], Rowu[1]]
      }

      RecordSet.Free()
      Return newArrayu
   }
}

retrieveHistoGroupSQLimgInfos(which, thisGroup, totalgroups, constrain:="imgavg") {
   showTOOLtip("Retrieving statistics from the database, please wait`n" thisGroup " / " totalgroups " ( " which " )", 0, 0, thisGroup/totalgroups)
   SQL := "SELECT Round(" which "*256), Count(*) FROM images WHERE " constrain " IS NOT NULL GROUP BY " which ";"
   entriezHM1 := entriezHM2 := entriezHM3 := entriezHM4 := entriezHM5 := 0
   If activeSQLdb.GetTable(SQL, RecordSet)
   {
      entriesG := []
      Loop, % RecordSet.RowCount
      {
         Rowu := RecordSet.Rows[A_Index]
         If (Rowu[1]!="")
         {
            hmed := Rowu[1]
            If isInRange(hmed, 0, 50)
            {
               entriezHM1 := entriezHM1 + Rowu[2]
               entriesG[1] := [entriezHM1, "0-50"]
            } Else If isInRange(hmed, 50, 100)
            {
               entriezHM2 := entriezHM2 + Rowu[2]
               entriesG[2] := [entriezHM2, "50-100"]
            } Else If isInRange(hmed, 100, 150)
            {
               entriezHM3 := entriezHM3 + Rowu[2]
               entriesG[3] := [entriezHM3, "100-150"]
            } Else If isInRange(hmed, 150, 200)
            {
               entriezHM4 := entriezHM4 + Rowu[2]
               entriesG[4] := [entriezHM4, "150-200"]
            } Else If isInRange(hmed, 200, 258)
            {
               entriezHM5 := entriezHM5 + Rowu[2]
               entriesG[5] := [entriezHM5, "200-255"]
            }
         }
      }

      RecordSet.Free()
      Return entriesG
   }
}

PopulateImagesIndexStatsInfos(dummy:=0) {
  Static entriesR, entriesD, entriesS, entriesU, entriesM, entriesY, entriesT, entriesA, entriesI, entriesG, prevState, entriesCount, prevMaxu

  startZeit := A_TickCount
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  isFilter := StrLen(filesFilter)>2 ? 1 : 0
  If (dummy!="kill")
  {
     doStartLongOpDance()
     showTOOLtip("Generating statistics on images details, please wait`n" groupDigits(thisMaxCount) " files")
     setImageLoading()
     thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount
  } Else prevState := ""

  If (thisState!=prevState || dummy="kill")
  {
     entriesCount := totalSizeu := entriezHM1 := entriezHM2 := entriezHM3 := entriezHM4 := entriezHM5 := prevMaxu := 0
     entriezHL1 := entriezHP1 := entriezHA1 := entriezHL2 := entriezHP2 := entriezHA2 := entriezHL3 := entriezHP3 := entriezHA3 := entriezHL4 := entriezHP4 := entriezHA4 := entriezHL5 := entriezHP5 := entriezHA5 := 0

     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     entriesA := []
     entriesG := []
     entriesU := []
     entriesI := []
     entriesR := []
     If (dummy="kill")
     {
        prevState := ""
        Return
     }

     If (SLDtypeLoaded=3)
     {
        prevMaxu := getTotalIMGsSQLdb()
        ; prevMaxu := getTotalIMGsSQLdb("WHERE imgwidth IS NOT NULL")
        thisMaxCount := prevMaxu
        If !prevMaxu
           Return 0

        entriesS := retrieveGroupSQLimgInfos("imgpixfmt", 2, 12)
        entriesM := retrieveGroupSQLimgInfos("imgframes", 3, 12)
        entriesU := retrieveGroupSQLimgInfos("imgdpi", 4, 12)
        entriesD := retrieveGroupSQLimgInfos("Round(imgmegapix, 1)", 5, 12)
        entriesY := retrieveGroupSQLimgInfos("Round(imgwhratio, 1)", 6, 12)
        entriesT := retrieveHistoGroupSQLimgInfos("imgavg", 7, 12)
        entriesG := retrieveHistoGroupSQLimgInfos("imgmedian", 8, 12)
        entriesA := retrieveHistoGroupSQLimgInfos("imghpeak", 9, 12)
        entriesI := retrieveHistoGroupSQLimgInfos("imghlow", 10, 12)
        entriesR := retrieveHistoGroupSQLimgInfos("imghrange", 11, 12)
     }

     prevMSGdisplay := A_TickCount
     Loop, % thisMaxCount
     {
         If (SLDtypeLoaded=3)
            Break

         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(A_Index, thisMaxCount, startZeit)
            showTOOLtip("Generating statistics, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }

         entriesCount++
         If (isFilter=1)
         {
            mgpx := bckpResultedFilesList[A_Index, 17]
            frames := bckpResultedFilesList[A_Index, 9]
            ratio := bckpResultedFilesList[A_Index, 16]
            pixfmt := bckpResultedFilesList[A_Index, 15]
            havg := bckpResultedFilesList[A_Index, 18]
            hmed := bckpResultedFilesList[A_Index, 19]
            hpeak := bckpResultedFilesList[A_Index, 20]
            hlow := bckpResultedFilesList[A_Index, 21]
            dpiu := bckpResultedFilesList[A_Index, 22]
            hrange := bckpResultedFilesList[A_Index, 25]
         } Else
         {
            mgpx := resultedFilesList[A_Index, 17]
            frames := resultedFilesList[A_Index, 9]
            ratio := resultedFilesList[A_Index, 16]
            pixfmt := resultedFilesList[A_Index, 15]
            havg := resultedFilesList[A_Index, 18]
            hmed := resultedFilesList[A_Index, 19]
            hpeak := resultedFilesList[A_Index, 20]
            hlow := resultedFilesList[A_Index, 21]
            dpiu := resultedFilesList[A_Index, 22]
            hrange := resultedFilesList[A_Index, 25]
         }

         havg := Round(256*havg)
         hmed := Round(256*hmed)
         hpeak := Round(256*hpeak)
         hlow := Round(256*hlow)
         hrange := Round(256*hrange)
         If isInRange(havg, 0, 50)
         {
            entriezHA1++
            entriesT[1] := [entriezHA1, "0-50"]
         } Else If isInRange(havg, 50, 100)
         {
            entriezHA2++
            entriesT[2] := [entriezHA2, "50-100"]
         } Else If isInRange(havg, 100, 150)
         {
            entriezHA3++
            entriesT[3] := [entriezHA3, "100-150"]
         } Else If isInRange(havg, 150, 200)
         {
            entriezHA4++
            entriesT[4] := [entriezHA4, "150-200"]
         } Else If isInRange(havg, 200, 258)
         {
            entriezHA5++
            entriesT[5] := [entriezHA5, "200-255"]
         }

         If isInRange(hmed, 0, 50)
         {
            entriezHM1++
            entriesG[1] := [entriezHM1, "0-50"]
         } Else If isInRange(hmed, 50, 100)
         {
            entriezHM2++
            entriesG[2] := [entriezHM2, "50-100"]
         } Else If isInRange(hmed, 100, 150)
         {
            entriezHM3++
            entriesG[3] := [entriezHM3, "100-150"]
         } Else If isInRange(hmed, 150, 200)
         {
            entriezHM4++
            entriesG[4] := [entriezHM4, "150-200"]
         } Else If isInRange(hmed, 200, 258)
         {
            entriezHM5++
            entriesG[5] := [entriezHM5, "200-255"]
         }

         If isInRange(hpeak, 0, 50)
         {
            entriezHP1++
            entriesA[1] := [entriezHP1, "0-50"]
         } Else If isInRange(hpeak, 50, 100)
         {
            entriezHP2++
            entriesA[2] := [entriezHP2, "50-100"]
         } Else If isInRange(hpeak, 100, 150)
         {
            entriezHP3++
            entriesA[3] := [entriezHP3, "100-150"]
         } Else If isInRange(hpeak, 150, 200)
         {
            entriezHP4++
            entriesA[4] := [entriezHP4, "150-200"]
         } Else If isInRange(hpeak, 200, 258)
         {
            entriezHP5++
            entriesA[5] := [entriezHP5, "200-255"]
         }

         If isInRange(hlow, 0, 50)
         {
            entriezHL1++
            entriesI[1] := [entriezHL1, "0-50"]
         } Else If isInRange(hlow, 50, 100)
         {
            entriezHL2++
            entriesI[2] := [entriezHL2, "50-100"]
         } Else If isInRange(hlow, 100, 150)
         {
            entriezHL3++
            entriesI[3] := [entriezHL3, "100-150"]
         } Else If isInRange(hlow, 150, 200)
         {
            entriezHL4++
            entriesI[4] := [entriezHL4, "150-200"]
         } Else If isInRange(hlow, 200, 258)
         {
            entriezHL5++
            entriesI[5] := [entriezHL5, "200-255"]
         }

         If isInRange(hRange, 0, 50)
         {
            entriezHR1++
            entriesR[1] := [entriezHR1, "0-50"]
         } Else If isInRange(hRange, 50, 100)
         {
            entriezHR2++
            entriesR[2] := [entriezHR2, "50-100"]
         } Else If isInRange(hRange, 100, 150)
         {
            entriezHR3++
            entriesR[3] := [entriezHR3, "100-150"]
         } Else If isInRange(hRange, 150, 200)
         {
            entriezHR4++
            entriesR[4] := [entriezHR4, "150-200"]
         } Else If isInRange(hRange, 200, 258)
         {
            entriezHR5++
            entriesR[5] := [entriezHR5, "200-255"]
         }

         mgpx := Round(mgpx, 1)
         ratio := Round(ratio, 1)
         pixu := "z" StringToASC(pixfmt)
         ratiou := StrReplace(ratio, ".", "q")
         mgpxu := StrReplace(mgpx, ".", "q")
         entriez%ratiou%++
         entriez%pixu%++
         entriezMP%mgpxu%++
         entriezFram%frames%++
         entriezU%dpiu%++
         entriesD[mgpxu] := [entriezMP%mgpxu%, mgpx]
         entriesS[pixu] := [entriez%pixu%, pixFmt]
         entriesY[ratiou] := [entriez%ratiou%, ratio]
         entriesM["z" frames] := [entriezFram%frames%, frames]
         entriesU["z" dpiu] := [entriezU%dpiu%, dpiu]

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            prevState := ""
            Break
         }
     }
     If (SLDtypeLoaded=3)
        RecordSet.Free()

     If (abandonAll!=1)
        prevState := thisState
  }

  If (SLDtypeLoaded=3 && prevMaxu)
     thisMaxCount := prevMaxu

  If (SLDtypeLoaded=3)
  {
     entriesCount := 0
     Loop, % entriesD.Count()
        entriesCount += entriesD[A_Index, 1]
  }

  entriesCount := StrReplace(entriesCount, A_Space)
  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     executingCanceableOperation := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaD
  GuiControl, -Redraw, LViewMetaD
  GuiControl, -Redraw, LViewMetaM
  GuiControl, -Redraw, LViewMetaU
  GuiControl, -Redraw, LViewMetaY

  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  Loop, 4
     LV_ModifyCol(A_Index, "Integer")

  For Key, Value in entriesM
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaU
  Loop, 4
     LV_ModifyCol(A_Index, "Integer")

  For Key, Value in entriesU
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaA
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesA
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaG
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesG
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  Gui, SettingsGUIA: ListView, LViewMetaR
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesR
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")
  Gui, SettingsGUIA: ListView, LViewMetaI
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesI
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")
  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesS
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 5
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(3, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  ; LV_ModifyCol(3, "SortDesc")
  GuiControl, +Redraw, LViewMetaD
  GuiControl, +Redraw, LViewMetaM
  GuiControl, +Redraw, LViewMetaU
  GuiControl, +Redraw, LViewMetaY
  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  percDone := " (" Round((entriesCount / thisMaxCount) * 100, 1) "%)"
  entriesCount := groupDigits(entriesCount)
  thisMaxCount := groupDigits(thisMaxCount)
  GuiControl, SettingsGUIA:, infoLine, Indexed images: %entriesCount% / %thisMaxCount%%percDone%
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

PopulateIndexSQLFilesStatsInfos(dummy:=0) {
  Static entriesD, entriesM, entriesY, entriesT, prevState, entriesCount

  thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  thisState := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded thisMaxCount uiPreferedFileStats
  startZeit := A_TickCount
  If (thisState!=prevState || dummy="kill")
  {
     cachedMode := entriesCount := 0
     entriesD := []
     entriesM := []
     entriesY := []
     entriesS := []
     entriesT := []
     zr := uiFileIndexStatsRetrieveSizeRangeDB(1, q, 1, ":-)", 0, 1)
     If (dummy="kill")
     {
        prevState := ""
        Return 0
     }

     If (sqlFailedInit=1)
     {
        prevState := ""
        Return 0
     }

     RecordSet := ""
     tableu := (uiPreferedFileStats=1) ? "fmodified" : "Fcreated"
     SQL := "SELECT substr(" tableu ", 1, 8), COUNT(*) FROM images GROUP BY substr(" tableu ", 1, 8);"
     If !activeSQLdb.GetTable(SQL, RecordSet)
     {
        throwSQLqueryDBerror(A_ThisFunc)
        prevState := ""
        Return 0
     }

     doStartLongOpDance()
     showTOOLtip("Generating statistics, please wait", 0, 0, 0.4/10)
     setImageLoading()

     Loop, % RecordSet.RowCount
     {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[1]
         {
            dateuD := "z" Rowu[1] ; SubStr(Row[1], 1, 8)
            dateuM := "z" SubStr(Rowu[1], 1, 6)
            dateuY := "z" SubStr(Rowu[1], 1, 4)
            entriez%dateuD% += Rowu[2]
            entriez%dateuM% += Rowu[2]
            entriez%dateuY% += Rowu[2]
            entriesCount += Rowu[2]
            entriesD[dateuD] := [entriez%dateuD%, Rowu[1]] ; SubStr(Row[1], 1, 8)]
            entriesM[dateuM] := [entriez%dateuM%, SubStr(Rowu[1], 1, 6)]
            entriesY[dateuY] := [entriez%dateuY%, SubStr(Rowu[1], 1, 4)]
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }
         }
     }
     prevState := (abandonAll!=1) ? thisState : ""
     RecordSet.Free()
  } Else cachedMode := 1

  entriesCount := StrReplace(entriesCount, A_Space)
  If (abandonAll=1)
  {
     prevState := ""
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  showTOOLtip("Generating statistics, please wait", 0, 0, 1.5/10)
  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaD
  GuiControl, -Redraw, LViewMetaD
  GuiControl, -Redraw, LViewMetaM
  GuiControl, -Redraw, LViewMetaY
  GuiControl, -Redraw, LViewMetaS
  GuiControl, -Redraw, LViewMetaT

  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
  {
      stringu := ST_Insert("-", Value[2], 5)
      stringu := ST_Insert("-", stringu, 8)
      If (Value[1]>1)
         LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  
  LV_ModifyCol(2, "SortDesc")
  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesM
  {
      stringu := ST_Insert("-", Value[2], 5)
      LV_Add(A_Index, A_Index, stringu, Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: ListView, LViewMetaY
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  For Key, Value in entriesY
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  LV_ModifyCol(2, "SortDesc")
  If (determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastLongOperationAbort := A_TickCount
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  isFilter := StrLen(filesFilter)>2 ? 1 : 0
  Gui, SettingsGUIA: ListView, LViewMetaT
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  showTOOLtip("Generating statistics, please wait", 0, 0, 3/10)
  Loop, % thisMaxCount
  {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (isFilter=1)
         imgPath := bckpResultedFilesList[A_Index, 1]
      Else
         imgPath := resultedFilesList[A_Index, 1]

      foundPos := InStr(imgPath, ".", 0, -1)
      If foundPos
      {
         fileEXT := SubStr(imgPath, foundPos + 1)
         entriez%fileEXT%++
         entriesT[fileEXT] := [entriez%fileEXT%, fileEXT]
      }
  }

  For Key, Value in entriesT
      LV_Add(A_Index, A_Index, Value[2], Value[1], Round((Value[1]/thisMaxCount)*100, 1))
  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Center")

  If (abandonAll=1 || determineTerminateOperation()=1)
  {
     showTOOLtip("Operation abandoned by user")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastOtherWinClose := A_TickCount
     interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
     SetTimer, ResetImgLoadStatus, -200
     GuiControl, SettingsGUIA:, infoLine, Operation abandoned by user
     Return
  }

  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewMetaS
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")
  zr := (cachedMode=1) ? "c" : 0
  j := 0
  showTOOLtip("Generating statistics, please wait", 0, 0, 4/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 1, "<5 KB", 0, 4998)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 2, "5-10 KB", 4999, 10001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 3, "10-25 KB", 10002, 25001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 4, "25-50 KB", 25002, 50001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 6/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 5, "50-100 KB", 50002, 100001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 6, "100-250 KB", 100002, 250001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 7, "250-500 KB", 250002, 500001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 8, "0.5-1.0 MB", 500002, 1000001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 8/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 9, "1.0-2.5 MB", 1000002, 2500001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 10, "2.5-5.0 MB", 2500002, 5000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 11, "5-10 MB", 5000002, 10000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 12, "10-25 MB", 10000002, 25000001)
  showTOOLtip("Generating statistics, please wait", 0, 0, 9/10)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 13, "25-50 MB", 25000002, 50000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 14, "50-100 MB", 50000002, 100000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 15, "100-250 MB", 100000002, 250000001)
  zr := uiFileIndexStatsRetrieveSizeRangeDB(zr, j, 16, "250-500 MB", 250000002, 500000001)
  Loop, 5
     LV_ModifyCol(A_Index, "AutoHdr Center")

  entriesCount := groupDigits(entriesCount)
  totalFsize := Round(j/1024, 1)
  GuiControl, +Redraw, LViewMetaD
  GuiControl, +Redraw, LViewMetaM
  GuiControl, +Redraw, LViewMetaY
  GuiControl, +Redraw, LViewMetaS
  GuiControl, +Redraw, LViewMetaT
  GuiControl, SettingsGUIA:, infoLine, Total images: %entriesCount% [%totalFsize% GB]
  zeitOperation := A_TickCount - startZeit
  addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
  SetTimer, ResetImgLoadStatus, -200
}

uiFileIndexStatsRetrieveSizeRangeDB(zr, ByRef totalSizeu, indexu, labelu, minu, maxu) {
  Static cacheInfos := []

  thisCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
  If (zr=1)
  {
     cacheInfos := []
     Return
  } Else If (zr="c")
  {
     LV_Add(indexu, indexu, labelu, cacheInfos[indexu, 1], cacheInfos[indexu, 2], Round((cacheInfos[indexu, 2]/thisCount)*100, 1))
     totalSizeu += cacheInfos[indexu, 1]
     Return "c"
  }

  SQL := "SELECT sum(fsize), COUNT(*) FROM images WHERE fsize BETWEEN " minu " AND " maxu ";"
  If activeSQLdb.GetTable(SQL, RecordSet)
  {
     abandonAll := thisSizeFiles := thisTotalSizeRange := 0
     Loop, % RecordSet.RowCount
     {
         Rowu := RecordSet.Rows[A_Index]
         If Rowu[1]
         {
            thisSizeFiles := Rowu[2]
            thisTotalSizeRange := Rowu[1]
            ; thisSizeFiles++
            ; thisTotalSizeRange += Row[1]
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }
         }
     }
     RecordSet.Free()
     totalSizeu += Round(thisTotalSizeRange/(1024**2), 4)
     cacheInfos[indexu] := [Round(thisTotalSizeRange/(1024**2), 1), thisSizeFiles]
     LV_Add(indexu, indexu, labelu, Round(thisTotalSizeRange/(1024**2), 1), thisSizeFiles, Round((thisSizeFiles/thisCount)*100, 1))
  }

  Return abandonAll
}

PanelImageInfos() {
    Global LViewMetaD, LViewMetaOthers
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, fileNamu, folderu)
    If !FileRexists(imgPath)
    {
       fileMsg := (userPrivateMode=1) ? "" : "`n" fileNamu "`n" folderu "\"
       showTOOLtip("ERROR: File not found or access denied" fileMsg)
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(5, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 230
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisPanelTab := (CurrentPanelTab=1 && thumbsDisplaying=1) ? 2 : clampInRange(CurrentPanelTab, 1, 3)
    Gui, Add, Tab3, %tabzDarkModus% AltSubmit gBtnTabsInfoUpdate hwndhCurrTab vCurrentPanelTab Choose%thisPanelTab%, General|System|Metadata
    Gui, Tab, 1 
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid -multi vLViewMetaD", "Property|Data", "General")
    Gui, Tab, 2
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid -multi vLViewMetaOthers", "Property|Data", "System")
    Gui, Tab, 3
    GuiAddListView("x+15 y+15 w" lstWid " +LV0x10000 r" uLVr " Grid -multi vLViewMetaM", "Property|Data", "Image metadata")
    Gui, Tab

    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddButton("xs y+20 h" thisBtnHeight " w" ml " gInfoBtnPrevImg", "<<", "Previous image")
    GuiAddButton("x+5 hp wp gInfoBtnNextImg", ">>", "Next image")
    Gui, Add, Button, x+15 hp w%btnWid% gcopyIMGinfos2clip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid% gOpenThisFileFolder, &Explore folder
    Gui, Add, Button, x+5 hp w%btnWid% gOpenFileProperties, &File properties
    Gui, Add, Button, x+5 hp w90 Default gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file details: " appTitle)
    PopulateImgInfos()
}

MenuPanelFoldersTree() {
   If (folderTreeWinOpen=1)
      fdTreeClose()
   Else If !AnyWindowOpen
      PanelFoldersTree()
}

PanelFoldersTree() {
    Static hasRan, prevSize := 0
    Global fdTreeInfoLine, BTNfdTreeMenu, BTNfdTreeMainMenu
    If MsgBox2hwnd
       Return

    mouseTurnOFFtooltip()
    setLVrowsCount()
    thisSize := 300 + PrefsLargeFonts + uiUseDarkMode
    If (hasRan=1 && prevSize!=thisSize)
    {
       hasRan := 0
       Gui, fdTreeGuia: Destroy
    }

    If (userPrivateMode=1)
       msgBoxWrapper(appTitle ": WARNING", "QPV is currently in private mode, hiding all file paths and images, for privacy.`n `nWARNING: The folders tree panel DOES NOT WORK in private mode. Proceed with care.", 0, 0, "exclamation")

    If (hasRan=1)
    {
       Gui, fdTreeGuia: Show
       folderTreeWinOpen := 1
       interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
       Return
    }

    INIaction(0, "showFolderTreeDetails", "General", 1)
    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: +Resize -MaximizeBox -MinimizeBox +Owner%PVhwnd% +hwndhfdTreeWinGui +ToolWindow
    Gui, fdTreeGuia: Margin, 1, 1
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    If (uiUseDarkMode=1)
    {
       Gui, Color, % darkWindowColor, % darkWindowColor
       Gui, Font, c%darkControlColor%
       setDarkWinAttribs(hfdTreeWinGui)
    }

    prevSize := thisSize
    thisBtnHeight := (PrefsLargeFonts=1) ? 45 : 35
    btnWid := 105
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 230
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, TreeView, r10 vTVlistFolders AltSubmit +hwndhTVlistFolders gFolderTreeResponder
    GuiAddButton("xp y+1 w" thisBtnHeight " h" thisBtnHeight " gfolderTreeMiniBtn vBTNfdTreeMenu", "\\", "Folder tree",, "fdTreeGuia")
    GuiAddButton("xp y+1 wp hp gfolderTreeContextMenu vBTNfdTreeMainMenu", ">", "Menu options",, "fdTreeGuia")
    Gui, Add, Text, x+2 vfdTreeInfoLine +0x200 gfolderTreeCopyPath -wrap +TabStop, Folder tree status bar...
    Gui, Add, Button, x+1 y+1 w1 h1 -wantTab -TabStop Default gfolderTreeDefaultAction, &Default

    winPos := (prevSetWinPosY && prevSetWinPosX) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("fdTreeGuia", hfdTreeWinGui, 0, "Folders tree view: " appTitle, winPos)
    folderTreeWinOpen := 1
    interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
    interfaceThread.ahkassign("hfdTreeWinGui", hfdTreeWinGui)
    hasRan := 1
    SetTimer, FolderTreeRepopulate, -100
    fdTreeGuiaGuiSize()
}

folderTreeMiniBtn() {
   r := invokeFoldersListerMenu()
   If (r="err")
      folderTreeContextMenu()
}

folderTreeCopyPath(dummy:=0) {
   Static lastInvoked := 1

   If ((A_TickCount - lastInvoked<356) || (dummy="forced") || InStr(dummy, "copy"))
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      folderPath := folderTreeGetSelectedPath(c)
      If !folderPath
      {
         showTOOLtip("WARNING: No folder tree element is selected")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      Try Clipboard := folderPath
      Catch wasError
          Sleep, 1

      If !wasError
      {
         showTOOLtip("Folder path copied to the clipboard:`n" folderPath)
      } Else
      {
         showTOOLtip("ERROR: Failed to copy folder path to the clipboard:`n" folderPath)
         SoundBeep 300, 100
      }
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } 
   lastInvoked := A_TickCount
}

folderTreeAddFolderFaves() {
   folderTreeDefaultAction("faves", "yo")
}

folderTreeSetFolderProtected() {
   folderTreeDefaultAction("protect", "yo")
}

folderTreeOpenInExplorer() {
   folderTreeDefaultAction("explorer", "yo")
}

folderTreeOpenInNewInstance() {
   folderTreeDefaultAction("anew", "yo")
}

folderTreePropertiesFolder() {
   folderTreeDefaultAction("properties", "yo")
}

folderTreeDefaultAction(modus:=0, g:=0) {
   z := 0
   If (modus="faves" && g="yo")
      z := 5
   Else If (modus="protect" && g="yo")
      z := 4
   Else If (modus="properties" && g="yo")
      z := 3
   Else If (GetKeyState("Shift", "P") || (modus="anew" && g="yo") )
      z := 2
   Else If (GetKeyState("Ctrl", "P") || (modus="explorer" && g="yo"))
      z := 1

   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   folderPath := folderTreeGetSelectedPath(c)
   If (z=1 && folderPath)
   {
      Try Run, "%folderPath%"
      Catch wasError
      {
         If !AnyWindowOpen
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderPath, 0, 0, "error")
      }
   } Else If (z=2 && folderPath)
   {
      OpenNewQPVinstance(folderPath)
   } Else If (z=3 && folderPath)
   {
      invokeStandardFolderProperties(folderPath)
   } Else If (z=4 && folderPath)
   {
      setContaintFolderAsProtected(folderPath)
   } Else If (z=5 && folderPath)
   {
      addFolderSldATfavorites(folderPath)
   } Else If folderPath
   {
      If askAboutFileSave(" and the selected folder will be opened")
         Return

      If askAboutSlidesListSave()
         Return

      If askAboutFilesSelect("discard it")
         Return

      tryOpenGivenFolder(folderPath, CurrentSLD)
      FileExploreSiblingsNav("reset")
      Sleep, 1
      WinActivate, ahk_id %hfdTreeWinGui%
   }
}

fdTreeGuiaGuiSize() {
   Critical, on
   GetWinClientSize(Width, Height, hfdTreeWinGui, 0)
   If (!width || !height || folderTreeWinOpen!=1)
      Return
   
   m := (PrefsLargeFonts=1) ? 10 : 8
   GuiControlGet, hButn, fdTreeGuia: hwnd, BTNfdTreeMainMenu
   GuiControlGet, hBtn, fdTreeGuia: hwnd, BTNfdTreeMenu
   GuiControlGet, hText, fdTreeGuia: hwnd, fdTreeInfoLine
   r := GetWindowPlacement(hText)

   SetWindowPlacement(hTVlistFolders, m, m, Width - m*2, Height - r.h - m*2)
   SetWindowPlacement(hText, m*2 + Round(r.h*1.6)*2, Height - r.h - m//2, Width - m*2 - r.h*4, r.h)
   SetWindowPlacement(hBtn, m, Height - r.h - m + 2, Round(r.h*1.5), r.h + m//2)
   SetWindowPlacement(hButn, m + Round(r.h*1.5) + 1, Height - r.h - m + 2, Round(r.h*1.5), r.h + m//2)
   If determineLClickState()
      SetTimer, fdTreeGuiaGuiSize, -300
}

fdTreeClose() {
   lastTimeToggleThumbs := A_TickCount 
   lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   Gui, fdTreeGuia: Hide
   folderTreeWinOpen := 0
   interfaceThread.ahkassign("folderTreeWinOpen", folderTreeWinOpen)
}

fdTreeGuiaGuiClose:
   fdTreeClose()
Return


fdTreeGuiaGuiEscape:
   If (A_TickCount - lastOtherWinClose < 400)
      Return

   fdTreeClose()
Return

FolderTreeResponder(a, b, c) {
   Static lastInvoked, prevCu, doNotAskAgain := 0
   ; ToolTip, % "a=" a " b=" b "|" A_DefaultTreeView "| c=" c , , , 2
   If (b="Normal" && StrLen(c)>3)
   {
      TV_Modify(c)
      zeit := A_TickCount - lastInvoked
      ; ToolTip, % zeit "==" prevCu "==" c , , , 2
      If (zeit<1234 && prevCu=c)
      {
         If TV_Get(c, "Expand")
            TV_Modify(c, "-Expand")
         Else
            TV_Modify(c, "+Expand")
      }
      lastInvoked := A_TickCount
      prevCu := c
   } Else If (b="K" && c=115) ; F4
   {
      WinActivate, ahk_id %PVhwnd%
   } Else If (b="K" && c=116) ; F5
   {
      FolderTreeRepopulate()
   } Else If (b="K" && c=112) ; F1
   {
      btnHelpFolderTree()
   } Else If (b="K" && c=113) ; F2
   {
      folderTreeRenameFolder()
   } Else If (b="K" && c=114) ; F3
   {
      folderTreeAppendFiles()
   } Else If (b="K" && c=186) ; F3
   {
      fromFolderTreeToOmniBox()
   } Else If (b="K" && c=118) ; F7
   {
      folderTreeCreateFolder()
   } Else If (b="K" && (c=119 || c=46)) ; F8 / Delete
   {
      folderTreeDeleteFolder()
   } Else If (b="K" && c=120) ; F9
   {
      FolderTreeFindActiveFile()
      folderTreeInfoStatusLineUpdater()
      prevent := 1
   } Else If (b="K" && c=123) ; F12
   {
      folderTreePropertiesFolder()
   } Else If (b="DoubleClick")
   {
      TV_Modify(c)
      folderTreeDefaultAction()
   } Else If (b="RightClick") || (b="K" && c=93) ; Apps/Menu key
   {
      If (b!="K")
         TV_Modify(c)

      folderTreeContextMenu()
   } Else If (b="K" && c=32) ; Space
   {
      If (b="K")
         c := TV_GetSelection()
      TV_Modify(c)
      folderTreeScanSubbies("no")
      folderTreeInfoStatusLineUpdater("forced")
      prevent := 1
   } Else If (b="d") ; drag'n drop
   {
      thisFolder := dc := nc := r := info := ""
      TV_Modify(c)
      prevMSGdisplay := 1
      While, determineLClickState()
      {
         ; drag and drop
         If (GetKeyState("Escape", "P"))
         {
            func2exec := r := info := ""
            thisFolder := dc := nc := r := info := ""
            Global lastOtherWinClose := A_TickCount
            interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
            Break
         }

         Gui, fdTreeGuia: Default
         Gui, fdTreeGuia: TreeView, TVlistFolders
         info := defineWindowUnderMouse()

         If InStr(info, "tooltip")
         {
            showOSDinfoLineNow(500)
            Continue
         } Else If InStr(info, "tree")
         {
            friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
            GetMouseCoord2wind(hTVlistFolders, nX, nY)
            nc := TVH_HitTest(hTVlistFolders, cr, nX, nY)
            If (nc=c)
               thisFolder := nc := ""

            If nc
            {
               TV_GetText(thisFolder, nc)
               TV_Modify(nc)
            }

            r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
            If thisFolder
               friendly .= "`nDestination: ." thisFolder "\ " r
            Else
               friendly .= "`nNo defined destination."
         } Else If InStr(info, "main")
         {
            r := nc := ""
            TV_Modify(c)
            r := GetKeyState("Shift", "P") ? "`nFolder is to be RECURSIVELY scanned." : "`nHold SHIFT for recursive scanning."
            friendly := "`nDrop folder here to import it into the current list." r
            ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
         } Else If InStr(info, "omnibox window")
         {
            r := dc := nc := ""
            friendly := "`nDrop folder here to begin navigation using the omnibox."
         } Else If InStr(info, "omnibox list")
         {
            TV_Modify(c)
            r := dc := nc := ""
            GetMouseCoord2wind(hLVquickSearchMenus, nX, nY)
            dc := LV_EX_ItemHitTest(hLVquickSearchMenus, kp, nX, nY)
            Gui, QuickMenuSearchGUIA: Default
            Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
            If dc
               LV_Modify(dc, "select focus vis")

            thisFolder := OmniBoxGetSelectedFolder()
            If !thisFolder
               dc := thisFolder := ""

            restu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
            friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
            friendly .= "`nDestination: ." restu "\"
            r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
            friendly .= A_Space r
            If !thisFolder
               friendly := "`nDrop folder here to begin navigate it using the omnibox."

            ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
         } Else 
         {
            r := nc := ""
            TV_Modify(c)
            friendly := "No action associated to this pointer location."
         }

         If (A_TickCount - prevMSGdisplay>100)
         {
            externToolTiput(info friendly)
            prevMSGdisplay := A_TickCount
         }
      }

      If InStr(info, "main")
      {
         z := InStr(r, "scanned") ? "recursive" : "not"
         externTooltiput("Importing folder - please wait")
         folderTreeAppendFiles(z)
      } Else If (InStr(info, "omnibox") && dc && thisFolder)
      {
         externTooltiput("-hide-")
         src := folderTreeGetSelectedPath(c)
         dest := OmniBoxGetSelectedFolder()

         If (doNotAskAgain=0 && src!=dest && InStr(src, ":\") && InStr(dest, ":\") && r)
         {
            msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action from the folders tree panel into the omnibox: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: ." src "\`nDestination: ." dest "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
            If !InStr(msgResult.btn, "Yes")
            {
               SetTimer, PopulateQuickMenuSearch, -200
               Return 1
            } Else doNotaskAgain := msgResult.check
         }

         If (InStr(r, "_") && src!=dest && InStr(src, ":\") && InStr(dest, ":\"))
         {
            externTooltiput("Please wait - performing folder action")
            r := UIcoreFolderPasteFoldersInto(0, "given", r, src, dest)
         }
         externToolTiput("-hide-")
      } Else If InStr(info, "omnibox")
      {
         fromFolderTreeToOmniBox()
      } Else If (InStr(info, "tree") && r && nc)
      {
         externTooltiput("-hide-")
         src := folderTreeGetSelectedPath(c)
         dest := folderTreeGetSelectedPath(nc)
         If (TV_GetParent(nc) = TV_GetParent(c))
         {
            TV_GetText(sr, nc)
            TV_GetText(dst, c)
         } Else
         {
            sr := src
            dst := dest
         }

         If (doNotAskAgain=0 && src!=dest && InStr(src, ":\") && InStr(dest, ":\") && r)
         {
            msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action inside the folders tree: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: ." sr "\`nDestination: ." dst "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
            If !InStr(msgResult.btn, "Yes")
            {
               SetTimer, folderTreeInfoStatusLineUpdater, -125
               Return 1
            } Else doNotaskAgain := msgResult.check
         }

         If (InStr(r, "_") && src!=dest && InStr(src, ":\") && InStr(dest, ":\"))
         {
            externTooltiput("Please wait - performing folder action")
            r := UIcoreFolderPasteFoldersInto(0, "given", r, src, dest)
            If (r=2)
               folderTreeScanSubbies()
         }
      }
      externToolTiput("-hide-")
      prevent := 1
   }

   If !prevent
      SetTimer, folderTreeInfoStatusLineUpdater, -125
   ; ToolTip, % a "==" b "==" c "`n" folderPath , , , 2
}

defineWindowUnderMouse() {
   MouseGetPos, OutputVarX, OutputVarY, OutputVarWin, hwnd, 2
   WinGetClass, OutputType, ahk_id %hwnd%
   If (OutputVarWin=hfdTreeWinGui && InStr(OutputType, "systree") && folderTreeWinOpen=1)
      info := "Folders tree list"
   Else If (OutputVarWin=PVhwnd)
      info := "Main window"
   Else If (OutputVarWin=hQuickMenuSearchWin && hwnd=hLVquickSearchMenus && VisibleQuickMenuSearchWin=1)
      info := "Omnibox list"
   Else If (OutputVarWin=hQuickMenuSearchWin && hwnd=hEditMenuSearch && VisibleQuickMenuSearchWin=1)
      info := "Omnibox window"
   Else If (OutputVarWin=hGuiTip)
      info := "Tooltip"
   Return info
}

btnHelpFolderTree() {
   msgBoxWrapper(appTitle ": HELP", "The folder tree panel facilitates management of files and folders. Common file and folders actions are available: create, cut, copy, paste, delete, rename. Drag and drop is supported between folders, and between this panel and the main window or the omnibox / quick menu search panel.", -1, 0, 0)
}

getFolderInfos(givenDir, ByRef filez:=0, ByRef folderz:=0, ByRef fileSizu:=0, doRecursive:="DF") {
     doStartLongOpDance()
     abandonAll := folderz := filez := fileSizu := 0
     Loop, Files, %givenDir%\*, %doRecursive%
     {
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         fullPath := Trimmer(A_LoopFileFullPath)
         If InStr(A_LoopFileAttrib, "D")
         {
            folderz++
         } Else If (RegExMatch(fullPath, RegExFilesPattern) && A_LoopFileSize>120)
         {
            fileSizu := fileSizu + A_LoopFileSize
            filez++
         }
     }
     Return abandonAll
}

folderTreeInfoStatusLineUpdater(modus:=0) {
    If (folderTreeWinOpen!=1)
       Return

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    c := TV_GetSelection()

    If c
       thisFolder := folderTreeGetSelectedPath(c)
    ; ToolTip, % thisFolder , , , 2
    If (showFolderTreeDetails=1 || modus="forced")
    {
       If c
          TV_GetText(drivu, c)
       thisVfolder := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1))
       If !Trimmer(thisFolder)
          thisVfolder := getDriveInfos(drivu)

       GuiControl, fdTreeGuia:, fdTreeInfoLine, %thisVfolder% | Gathering folder details...
       getFolderInfos(thisFolder, itemz, dirs, sizu)
       ResetImgLoadStatus()
    }

    If (dirs || sizu)
    {
       fbytes := fileSizeFriendly(sizu) " | " groupDigits(itemz) " images | " groupDigits(dirs) " folders"
       GuiControl, fdTreeGuia:, fdTreeInfoLine, % thisVFolder " | " fbytes
       SetTimer, fdTreeGuiaGuiSize, -50
       Return
    }

    thisFolder := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1))
    If (!thisFolder && c)
       TV_GetText(OutputVar, c)
    Else If !thisFolder
       thisFolder := "Folder tree: " TV_GetCount() " elements"

    If InStr(OutputVar, ":\")
       thisFolder := getDriveInfos(OutputVar) " | Folder tree: " TV_GetCount() " elements"

    GuiControl, fdTreeGuia:, fdTreeInfoLine, % fbytes thisFolder
    SetTimer, fdTreeGuiaGuiSize, -50
}

getDriveInfos(OutputVar) {
    Try DriveGet, info, Label, %OutputVar%
    info := Trimmer(info) ? info : OutputVar
    Try DriveGet, size, Capacity, %OutputVar%
    Try DriveSpaceFree, FreeSpace, %OutputVar%
    perc := Round((FreeSpace/size)*100, 1) "%"
    driveInfo .= info " | " perc " free"
    Return driveInfo
}

folderTreeGetSelectedPath(c) {
   If StrLen(c)<2
      Return

   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   TV_GetText(folderPath, c)
   r := c
   Loop
   {
      r := TV_GetParent(r)
      If !r
         Break
      TV_GetText(thisu, r)
      folderPath := thisu folderPath
   }

   folderPath := StrReplace(folderPath, "\\", "\")
   If StrLen(folderPath)<5
      folderPath := ""

   Return folderPath
}

FolderTreeFindActiveFile(givenPath:=0) {
    modus := (validBMP(UserMemBMP) || (maxFilesIndex>0 && CurrentSLD)) ? modus : "welcome"
    If (modus="welcome" && (!givenPath || InStr(givenPath, "`tF9")))
       Return

    If (userPrivateMode=1)
    {
       showTOOLtip("WARNING: Private mode is activated. Access to this feature is denied,`nbecause it would be a breach of privacy.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    showTOOLtip("Scanning folders, please wait")
    z := 0 ; TV_GetNext()
    oimgPath := StrReplace(getIDimage(currentFileIndex), "||")
    imgPath := SubStr(oimgPath, 1, InStr(oimgPath, "\", 0, -1) - 1)
    If FolderExist(givenPath)
    {
       imgPath := givenPath
       wasGiven := 1
    }

    sliced := StrSplit(imgPath, "\")
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...

    g := iterateFDtreeView(1, 0, sliced)
    lvl := g[1]
    z := g[2] ? g[2] : 0
    hasAdded := 0
    ; ToolTip, % lvl "=" gu , , , 2
    Loop, % sliced.Count()
    {
          thisIndex := A_Index - 1 + lvl
          If !sliced[thisIndex]
             Continue

          hasAdded := 1
          If (thisIndex=1)
             z := TV_Add(sliced[thisIndex] "\", z, "Expand Select VisFirst")
          Else
             z := TV_Add("\" sliced[thisIndex], z, "Expand Select VisFirst")
    }

    If (hasAdded!=1 && z)
       TV_Modify(z, "Expand Select VisFirst")

    initialSibling := SubStr(imgPath, InStr(imgPath, "\", 0, -1) + 1)
    If z
       w := TV_GetParent(z)
    ; ToolTip, % initialSibling , , , 2
    mustSkip := new hashtable()
    mustDelete := new hashtable()
    If (w && !wasGiven)
    {
       r := w
       r := TV_GetChild(w)
       Loop
       {
          If (A_Index>1)
             r := TV_GetNext(r)

          If r
             x := TV_GetChild(r)
          Else
             x := ""

          If !r
             Break

          If x
          {
             labelu := ""
             TV_GetText(labelu, r)
             If (Trimmer(labelu, "\")!=initialSibling)
             {
                h := Trimmer(labelu, "\")
                mustSkip[h] := 1
                Continue
             }
          }
 
          mustDelete[r] := 1
       }
    }

    If !wasGiven
    {
       For Key, Value in mustDelete
          TV_Delete(Key)
    }
    setImageLoading()
    doStartLongOpDance()
    mustDelete := ""
    subPath := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
    If (FolderExist(subPath) && w && !wasGiven)
    {
       Loop, Files, % subPath "\*", DF
       {
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }

          If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
          {
             If mustSkip.hasKey(A_LoopFileName)
                Continue

             P%A_Index% := TV_Add("\" A_LoopFileName, w)
             If (A_LoopFileName=initialSibling)
                subsParent := P%A_Index%
          }
       }
    }

    mustSkip := ""
    ResetImgLoadStatus()
    If (subsParent && !wasGiven)
    {
       TV_Modify(subsParent, "Select VisFirst")
       folderTreeScanSubbies()
    }

    TV_Modify(w, "Sort")
    If !wasGiven
    {
       GuiControl, fdTreeGuia: +Redraw, TVlistFolders
       SetTimer, folderTreeInfoStatusLineUpdater, -100
       SetTimer, RemoveTooltip, -100
    }
}

iterateFDtreeView(lvl, z, sliced) {
    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders

    Loop
    {
       labelu := ""
       If z
          TV_GetText(labelu, z)

       If (Trimmer(labelu, "\")=sliced[lvl] && labelu)
       {
          lvl++
          gu := z
          r := TV_GetChild(z)
          If (r!=0)
          {
             g := iterateFDtreeView(lvl, r, sliced)
             lvl := g[1]
             If g[2]
                gu := g[2]
          }
       }

       r := TV_GetNext(z)
       If (r=0)
          Break

       z := r
    }
    Return [lvl, gu]
}

FolderTreeRepopulate(dummy:=0, listuGiven:=0) {
    If (dummy="given" && listuGiven)
    {
       PanelFoldersTree()
       Try SetTimer, FolderTreeRepopulate, Off
    }

    If (userPrivateMode=1)
       Return

    Gui, fdTreeGuia: Default
    Gui, fdTreeGuia: TreeView, TVlistFolders
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...

    If (!HKifs("imgsLoaded") || (dummy="given" && listuGiven))
    {
       If (dummy="given" && listuGiven)
       {
          aListu := listuGiven
          TV_Delete()
       } Else
       {
          aListu := readRecentEntries(0, 0)
          aListu .= readRecentFileDesties()
          If FolderExist(prevFileSavePath)
             aListu .= "`n" prevFileSavePath "`n"
          If FolderExist(prevFileMovePath)
             aListu .= "`n" prevFileMovePath "`n"
          If FolderExist(prevOpenFolderPath)
             aListu .= "`n" prevOpenFolderPath "`n"

          Sort, aListu, UD`n
       }

       Loop, Parse, aListu, `n
       {
          countItemz++
          testThis := StrReplace(A_LoopField, "|")
          If (StrLen(A_LoopField)<4 || !FileExist(testThis))
             Continue
 
          If RegExMatch(testThis, sldsPattern)
             testThis := SubStr(testThis, 1, InStr(testThis, "\", 0, -1) - 1)
 
          bListu .= testThis "`n"
       }
 
       Loop, Parse, bListu, `n
       {
          If A_LoopField
             FolderTreeFindActiveFile(A_LoopField)
       }
       TV_Modify(0, "Select VisFirst")
       folderTreeExpandCollapseAll("collapse")
       GuiControl, fdTreeGuia: +Redraw, TVlistFolders
       SetTimer, folderTreeInfoStatusLineUpdater, -100
       SetTimer, RemoveTooltip, -100
       Return
    }

    z := TV_GetNext()
    If z
       TV_Delete(z)

    showTOOLtip("Scanning folders, please wait")
    parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
    parentsLevels := parentsObj.Count()
    ; ToolTip, % parentsLevels " == " currentParent , , , 2
    Loop, % parentsLevels
    {
       If (A_Index>currentParent)
          Continue
   
       If (A_Index=1 && !InStr(parentsObj[1], ":"))
          Break

       pu := A_Index - 1
       If (A_Index=1)
          P1 := TV_Add(parentsObj[A_Index] "\",, "Expand")
       Else If (A_Index!=currentParent)
          P%A_Index% := TV_Add("\" parentsObj[A_Index], P%pu%, "Expand")

       If (A_Index=currentParent)
          siblingsParent := P%pu%
    }

    sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
    Loop, % sibsObj.Count()
    {
       If !siblingsParent
          Continue

       pu := A_Index - 1
       If (A_Index=currentSib)
          subsParent := TV_Add("\" sibsObj[A_Index], siblingsParent, "Expand Bold")
       Else
          P%A_Index% := TV_Add("\" sibsObj[A_Index], siblingsParent)
    }

    If siblingsParent
       TV_Modify(siblingsParent, "Expand Sort")

    doStartLongOpDance()
    hasAddedSubs := 0
    thisFolder := StrReplace(Trimmer(CurrentSLD), "|")
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", DF
       {
          If determineTerminateOperation()
             Break

          If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
          {
             P%A_Index% := TV_Add("\" A_LoopFileName, subsParent)
             hasAddedSubs := 1
          }
       }
    }

    ResetImgLoadStatus()
    If subsParent
       TV_Modify(subsParent, "Expand Sort")

    countu := TV_GetCount()
    If !countu
       FolderTreeFindActiveFile()

    GuiControl, fdTreeGuia: +Redraw, TVlistFolders
    SetTimer, folderTreeInfoStatusLineUpdater, -100
    SetTimer, RemoveTooltip, -100
}

folderTreeContextMenu() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   If c
      TV_GetText(labelu, c)

   Try Menu, PVfdTree, Delete
   kMenu("PVfdTree", "Add", "Re&generate tree view`tF5", "FolderTreeRepopulate")
   kMenu("PVfdTree", "Add", "&Highlight the focused file location`tF9", "FolderTreeFindActiveFile")
   If c
      kMenu("PVfdTree", "Add", "&Scan for sub-folders`tSpace", "folderTreeScanSubbies")

   If (c && !InStr(labelu, ":"))
   {
      folderPath := folderTreeGetSelectedPath(c)
      If FolderExist(folderPath)
      {
         Try Menu, PVopenF, Delete
         kMenu("PVopenF", "Add", "Open folder now`tEnter", "folderTreeDefaultAction")
         kMenu("PVopenF", "Add", "In Explorer`tShift+Enter", "folderTreeOpenInExplorer")
         kMenu("PVopenF", "Add", "With a new QPV instance`tCtrl+Enter", "folderTreeOpenInNewInstance")
         Menu, PVfdTree, Add
         kMenu("PVfdTree", "Add", "Open", ":PVopenF")
         kMenu("PVfdTree", "Add", "&Import images into the list`tF3", "folderTreeAppendFiles")
         Menu, PVfdTree, Add
         kMenu("PVfdTree", "Add", "&Create new folder`tF7", "folderTreeCreateFolder")
         kMenu("PVfdTree", "Add", "C&ut folder (Explorer mode)`tCtrl+X", "folderTreeCutCopyFolder")
         kMenu("PVfdTree", "Add", "C&opy folder (Explorer mode)`tCtrl+C", "folderTreeCutCopyFolder")
         kMenu("PVfdTree", "Add", "&Paste folder(s) into...", "folderTreePasteFoldersInto")
         kMenu("PVfdTree", "Add", "&Rename folder`tF2", "folderTreeRenameFolder")
         kMenu("PVfdTree", "Add", "&Delete folder`tDelete", "folderTreeDeleteFolder")
         Menu, PVfdTree, Add
         kMenu("PVfdTree", "Add", "Add to/remove from fa&vorites", "folderTreeAddFolderFaves")
         kMenu("PVfdTree", "Add/UnCheck", "Se&t as the protected folder", "folderTreeSetFolderProtected")
         If (protectedFolderPath=folderPath && preventDeleteFromProtectedPath=1)
            kMenu("PVfdTree", "Check", "Se&t as the protected folder")

         kMenu("PVfdTree", "Add", "Folder properties (E&xplorer)`tF12", "folderTreePropertiesFolder")
         Menu, PVfdTree, Add
         kMenu("PVfdTree", "Add", "Paste clip&board file(s) into...", "folderTreePasteClippy")
         If (maxFilesIndex>0 && CurrentSLD)
         {
            kMenu("PVfdTree", "Add", "Cop&y selected file(s) into...`t7", "FolderTreeMenuCopyFiles")
            kMenu("PVfdTree", "Add", "&Move selected file(s) into...`tShift+7", "FolderTreeMenuMoveFiles")
         }
      } Else
      {
         Menu, PVfdTree, Add
         kMenu("PVfdTree", "Add", "Selected folder is inexistent", "dummy")
         kMenu("PVfdTree", "Disable", "Selected folder is inexistent")
         Menu, PVfdTree, Delete, &Scan for sub-folders`tSpace
         Menu, PVfdTree, Add
         addBonus := 1
      }
   } Else addBonus := 1

   If (addBonus=1)
   {
      kMenu("PVfdTree", "Add/UnCheck", "Sho&w folder details", "toggleFDtreeInfos")
      If (showFolderTreeDetails=1)
         kMenu("PVfdTree", "Check", "Sho&w folder details")

      kMenu("PVfdTree", "Add", "Collapse/expand entire folder tree", "folderTreeExpandCollapseAll")
      Menu, PVfdTree, Add
      kMenu("PVfdTree", "Add/UnCheck", "Large UI fonts", "folderTreeToggleLargeUIfonts")
      kMenu("PVfdTree", "Add/UnCheck", "Dar&k mode", "folderTreeToggleDarkie")
      kMenu("PVfdTree", "Add", "Close panel`tEscape", "fdTreeClose")
      If (uiUseDarkMode=1)
         kMenu("PVfdTree", "Check", "Dar&k mode")
      If (PrefsLargeFonts=1)
         kMenu("PVfdTree", "Check", "Large UI fonts")
   }
   showThisMenu("PVfdTree")
}

folderTreeToggleLargeUIfonts() {
    ToggleLargeUIfonts()
    PanelFoldersTree()
}

folderTreeToggleDarkie() {
    ToggleDarkModus()
    PanelFoldersTree()
}

FolderTreeMenuCopyFiles() {
   triggerQuickFileAction("vk37", 1)
}

FolderTreeMenuMoveFiles() {
   triggerQuickFileAction("+vk37", 1)
}

UIcoreFolderNew(thisFolder, ByRef newFileName) {
   msgResult := msgBoxWrapper("Create new folder: " appTitle, "Create new folder in:`n" thisFolder "\`n`nPlease type the new folder name.", "&Create folder|C&ancel", 1, "modify-file", 0, 0, 0, "limit9050", "")
   If InStr(msgResult.btn, "Create")
   {
      newFileName := Trimmer(msgResult.edit)
      If FolderExist(thisFolder "\" newFileName)
      {
         showTOOLtip("WARNING: A folder with the given name already exists:`n" thisFolder "\`n" newFileName "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      newFileName := filterFileName(newFileName)
      If !newFileName
      {
         showTOOLtip("WARNING: Incorrect folder name given.")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      FileCreateDir, %thisFolder%\%newFileName%
      If !ErrorLevel
      {
         Return 1
      } Else
      {
         showTOOLtip("ERROR: An unknown error occured creating the new folder in:`n" thisFolder "\")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

folderTreeCreateFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   If !FolderExist(thisFolder)
   {
      If StrLen(thisFolder)>4
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected folder seems to no longer exist:`n`n" thisFolder "\`n`nWould you like to recreate it? By choosing yes, you will be able to create a new folder inside it.", 4, 0, "question")

      If (msgResult="Yes")
      {
         FileCreateDir, %thisFolder%
         If ErrorLevel
         {
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n`n" thisFolder "\`n`nPossibly access denied.", 0, 0, "error")
            Return
         }
      } Else Return
   }

   r := UIcoreFolderNew(thisFolder, newFileName)
   If r
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      TV_Add("\" newFileName, c)
      TV_Add(c, "Expand Sort")
      GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   }
}

UIcoreFolderDelete(thisFolder) {
   If FolderExist(thisFolder)
   {
      baseu := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1))
      itemu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1))

      msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected: " itemu "`n`nFound in:`n" baseu "`n`nPlease confirm you want to entirely DELETE this folder.", "&Delete|&Cancel", 2, "question")
      If (msgResult="delete")
      {
         destroyGDIfileCache()
         showTOOLtip("Deleting folder, please wait`n" thisFolder "\*")
         changeMcursor()
         ; FileRemoveDir, % thisFolder, 1
         r := ShellFileOperation("FO_DELETE", thisFolder "\", nona, "FOF_ALLOWUNDO|FOF_NOCONFIRMMKDIR", PVhwnd)
         If (!r["error"] && !r["aborted"])
         {
            SoundBeep , 900, 100
            allGood := "deleted"
         } Else If (r["error"] || r["aborted"])
         {
            If r["error"]
            {
               showTOOLtip("Failed to delete selected folder:`n" thisFolder "\")
               allGood := "error"
            } Else
            {
               showTOOLtip("Operation aborted: delete folder`n" thisFolder "\")
               allGood := "abort"
            }
            SoundBeep , 300, 100
         }
      }
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist:`n" thisFolder "\")
      SoundBeep 300, 100
      allGood := "deleted"
   }
   Return allGood
}

folderTreeDeleteFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   r := UIcoreFolderDelete(thisFolder)
   If (r="deleted")
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      RemoveTooltip()
      TV_Delete(c)
      GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   }

   SetTimer, ResetImgLoadStatus, -100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

folderTreePasteFoldersInto() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   r := UIcoreFolderPasteFoldersInto(thisFolder)
   If (r=1 || r=2)
      WinActivate, ahk_id %hfdTreeWinGui%

   If (r=2)
      folderTreeScanSubbies()
}

UIcoreFolderPasteFoldersInto(thisFolder, dummy:="", gactu:="", fSrc:="", fDest:="") {
   If (dummy="given" && InStr(gactu, "_") && InStr(fSrc, ":\") && InStr(fDest, ":\"))
   {
      quickMode := 1
      msgResult := gactu
      thisFolder := fDest
      listu := fSrc "`n"
   }

   If !FolderExist(thisFolder)
   {
      friendly_name := (quickMode!=1) ? "paste the folder(s) inside it" : "perform the intended folder action"
      If StrLen(thisFolder)>4
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Destination folder: " thisFolder "\`n`nIt seems to no longer exist. Would you like to recreate it? By choosing yes, QPV will " friendly_name, 4, 0, "question")

      If (msgResult="Yes")
      {
         FileCreateDir, %thisFolder%
         If ErrorLevel
         {
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n`n" thisFolder "\`n`nPossibly access denied.", 0, 0, "error")
            Return
         }
      } Else Return
   }

   If (quickMode!=1)
   {
      showTOOLtip("Importing clipboard content...")
      Try listu := Clipboard
      SetTimer, RemoveTooltip, -200
   }

   If StrLen(listu)<5
   {
      showTOOLtip("WARNING: Found no folders in the clipboard")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
   
   If (quickMode!=1)  
   {
      isExplorerModeA := IsClipboardFormatAvailable(15)
      msgResult := msgBoxWrapper(appTitle ": Paste folders", "The folders from the clipboard will be pasted into the selected folder. Please choose what operation to perform. Destination folder:`n`n" thisFolder "\", "&Copy|&Move|C&ancel", 1, "question")
      SetTimer, RemoveTooltip, -200
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   If InStr(msgResult, "Copy")
   {
      friendly := "COPYING"
      filesActu := "FO_COPY"
   } Else If InStr(msgResult, "Move")
   {
      friendly := "MOVING"
      filesActu := "FO_MOVE"
   } Else
   {
      Return 1
   }

   destroyGDIfileCache()
   changeMcursor()
   line := ""
   zr := loopsCount := 0
   Loop, Parse, listu, `n,`r
   {
        line := Trimmer(Trimmer(A_LoopField), "\")
        If FolderExist(line)
        {
           loopsCount++
           r := ShellFileOperation(filesActu, line "\", thisFolder "\", "FOF_ALLOWUNDO|FOF_NOCONFIRMMKDIR", PVhwnd)
           If (r["aborted"] || r["error"])
           {
              zr := r["error"] ? 1 : 2
              Break
           }
        }
   }

   folderTreeScanSubbies()
   If zr
   {
      friendly2 := InStr(msgResult, "Copy") ? "COPY" : "MOVE"
      If (zr=1)
         showTOOLtip("Failed to " friendly2 " folder:`n" line "\")
      Else
         showTOOLtip("Operation aborted while " friendly " the folder:`n" line "\")
      SoundBeep , 300, 100
   } Else
   {
      isExplorerModeB := IsClipboardFormatAvailable(15)
      If (filesActu="FO_MOVE" && isExplorerModeA=1 && isExplorerModeB=1 && quickMode!=1)
         Try Clipboard := ""
      
      friendly2 := (quickMode!=1) ? "from the clipboard " : ""
      showTOOLtip("Finished " friendly " folder " friendly2 "into:`n" thisFolder "\")
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   ResetImgLoadStatus()
   Return 2
}

folderTreeCutCopyFolder(a) {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   UIcoreFolderCutCopyExplorer(a, thisFolder)
}

UIcoreFolderCutCopyExplorer(a, thisFolder) {
   userOption := InStr(StrReplace(a, "&"), "cut") ? "CUT" : "COPY"
   If FolderExist(thisFolder)
   {
      destroyGDIfileCache()
      dataHandle := ClipboardSetFiles([thisFolder], userOption, 1)
      Sleep, 5
      testClipType := IsClipboardFormatAvailable(15)
      infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to set the clipboard" : userOption " action: the folder can now be pasted in any file manager or in QPV`n" thisFolder "\"
      showTOOLtip(infoText)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist:`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

folderTreeRenameFolder() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   r := UIcoreFolderRename(thisFolder, newFileName)
   If r
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      TV_Modify(c, "Select Vis Sort", "\" newFileName)
      GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   }
}

UIcoreFolderRename(thisFolder, ByRef newFileName) {
   Static lastChecked := 1
   If !FolderExist(thisFolder)
   {
      showTOOLtip("WARNING: The folder seems to no longer exist:`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   baseu := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1))
   restu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
   msgResult := msgBoxWrapper("Rename folder: " appTitle, "Please type the new folder name for \" restu "`n`nFolder found in:`n" baseu, "&Rename folder|C&ancel", 1, "modify-file", "&Perform search and replace in current list", lastChecked, 0, "limit9050", restu)
   If InStr(msgResult.btn, "Rename")
   {
      newFileName := Trimmer(msgResult.edit)
      If !newFileName
         Return

      lastChecked := msgResult.check
      newFileName := filterFileName(newFileName)
      If !newFileName
      {
         showTOOLtip("WARNING: Incorrect folder name given")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If FolderExist(thisFolder "\" newFileName)
      {
         showTOOLtip("WARNING: A folder with the given name already exists:`n" thisFolder "\`n" newFileName "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      oldPath := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1) - 1)
      FileMoveDir, % thisFolder, % oldPath "\" newFileName, R
      If !ErrorLevel
      {
         performSRinSeenDB := performSRinDynas := 0
         If (lastChecked=1)
            SearchAndReplaceThroughIndex(thisFolder, oldPath "\" newFileName "\", 0, 0)
         Return 1
      } Else
      {
         showTOOLtip("ERROR: An unknown error occured renaming the folder:`n" thisFolder "\")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

invokeOmniBoxCurrentFile() {
   If (drawingShapeNow!=1)
      fromFolderTreeToOmniBox("thisFile", resultedFilesList[currentFileIndex, 1])
}

fromFolderTreeToOmniBox(modus:=0,imgPath:=0) {
   If (modus="thisFile" && InStr(imgPath, ":\"))
   {
      linea := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
   } Else
   {
      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      linea := folderTreeGetSelectedPath(c)
   } 

   If (!linea || !FolderExist(linea))
      Return

   If (VisibleQuickMenuSearchWin!=1)
      PanelQuickSearchMenuOptions()

   newLabelu := userQuickMenusEdit := Trim(StrReplace(linea, "\\", "\"), "\")
   len := StrLen(newLabelu)
   ; ToolTip, % newLabelu "=" len "`n" userQuickMenusEdit , , , 2
   GuiControl, QuickMenuSearchGUIA:, userQuickMenusEdit, % newLabelu
   GuiControl, QuickMenuSearchGUIA: Focus, userQuickMenusEdit
   EM_SETSEL(hEditMenuSearch, len, len)
   SetTimer, PopulateQuickMenuSearch, -150
}

folderTreeAppendFiles(modus:="") {
   If (maxFilesIndex<1 || !CurrentSLD)
   {
      folderTreeDefaultAction()
      Return
   }

   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   linea := folderTreeGetSelectedPath(c)
   If (!linea || !FolderExist(linea) || InStr(DynamicFoldersList, linea "`n"))
      Return

   changeMcursor()
   If GetKeyState("Shift", "P")
      addNewFolder2list(linea, "yes", "recursive")
   Else
      addNewFolder2list(linea, "yes", modus)
   ; SoundBeep 900, 100
   ResetImgLoadStatus()
   currentFileIndex := maxFilesIndex - 1
   dummyTimerDelayiedImageDisplay(50)
}

folderTreeExpandCollapseAll(forceMode:=0) {
   Static prevState := 1
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetNext()
   If !c
      Return

   If (forceMode="collapse")
      prevState := 1
   Else If (forceMode="expand")
      prevState := 0

   act := (prevState=1) ? "-Expand" : "Expand"
   friendly := (prevState=1) ? "COLLAPSED" : "EXPANDED"
   c := TV_Modify(c, act)
   Loop
   {
       c := TV_GetNext(c, "F")
       TV_Modify(c, act)
       If !c
          Break
   }

   c := TV_GetNext()
   c := TV_Modify(c, "VisFirst Select")
   prevState := !prevState
   showTOOLtip("Folder tree: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

folderTreeScanSubbies(prevent:="") {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   ; c := prevTVelement

   If !c
      Return

   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
   {
      TV_GetText(thisFolder, c)
      thisFolder := Trimmer(thisFolder, "\")
   }

   If !thisFolder
      Return

    showTOOLtip("Scanning folders, please wait")
    GuiControl, fdTreeGuia: -Redraw, TVlistFolders
    GuiControl, fdTreeGuia:, fdTreeInfoLine, Please wait...
    ; ToolTip, % A_DefaultTreeView "==" A_DefaultGUI "==" c , , , 2
    changeMcursor()
    mustSkip := new hashtable()
    mustDelete := new hashtable()
    r := c
    r := TV_GetChild(c)
    Loop
    {
       If (A_Index>1)
          r := TV_GetNext(r)

       If r
          x := TV_GetChild(r)
       Else
          x := ""

       If !r
          Break

       If x
       {
          labelu := ""
          TV_GetText(labelu, r)
          If (Trimmer(labelu, "\") && FolderExist(thisFolder labelu))
          {
             h := Trimmer(labelu, "\")
             mustSkip[h] := 1
             Continue
          }
       }

       mustDelete[r] := 1
    }

    For Key, Value in mustDelete
       TV_Delete(Key)

   mustDelete := ""
   hasAddedSubs := 0
   doStartLongOpDance()
   If FolderExist(thisFolder)
   || (StrLen(thisFolder)=2 && InStr(thisFolder, ":"))
   {
      Loop, Files, % thisFolder "\*", DF
      {
         If determineTerminateOperation()
            Break

         If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
         {
            If mustSkip.hasKey(A_LoopFileName)
               Continue

            P%A_Index% := TV_Add("\" A_LoopFileName, c)
            hasAddedSubs := 1
         }
      }
   }

   ResetImgLoadStatus()
   mustSkip := ""
   RemoveTooltip()
   TV_Modify(c, "Expand Vis Select Sort")
   GuiControl, fdTreeGuia: +Redraw, TVlistFolders
   If (prevent!="no")
      SetTimer, folderTreeInfoStatusLineUpdater, -100
   SetTimer, ResetImgLoadStatus, -125
}

folderTreePasteClippy() {
   Gui, fdTreeGuia: Default
   Gui, fdTreeGuia: TreeView, TVlistFolders
   c := TV_GetSelection()
   If !c
      Return

   thisFolder := folderTreeGetSelectedPath(c)
   If !thisFolder
      Return

   r := PasteFilesIntoGivenFolder(thisFolder)
   If r
      WinActivate, ahk_id %hfdTreeWinGui%
}

PasteFilesIntoGivenFolder(folderPath) {
   showTOOLtip("Importing clipboard content...")
   Try listu := Clipboard
   If StrLen(listu)<5
   {
      showTOOLtip("WARNING: Found no files in the clipboard")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
   
   SetTimer, RemoveTooltip, -200
   msgResult := msgBoxWrapper(appTitle ": Paste files", "The files from the clipboard will be pasted into the selected folder. Please choose what operation to perform. Destination folder:`n`n" folderPath "\", "&Copy|&Move|C&ancel", 1, "question")
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   startZeit := A_Now
   If InStr(msgResult, "Copy")
   {
      friendly := "Copying"
      filesActu := 3
   } Else If InStr(msgResult, "Move")
   {
      friendly := "Moving"
      filesActu := 2
   } Else
   {
      Sleep, 1
      Return 1
   }

   If !FolderExist(folderPath)
   {
      FileCreateDir, % folderPath
      If ErrorLevel
      {
         showTOOLtip("ERROR: The folder seems to no longer exist.`nQPV failed to create the folder:`n" folderPath "\")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return 0
      }
   }

   isExplorerModeA := IsClipboardFormatAvailable(15)
   foundFiles := ST_Count(listu, "`n")
   finalDest := folderPath
   filezMoved := countTFilez := 0
   doStartLongOpDance()
   nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   setWhileLoopExec(1)
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   Loop, Parse, listu, `n,`r
   {
      If !A_LoopField
         Continue

      countTFilez++
      file2rem := A_LoopField
      zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If (OldOutDir=finalDest)
      {
         skippedFiles++
         Continue
      }

      originalMtime := ""
      FileGetTime, originalMtime, % file2rem, M
      FileGetTime, originalCtime, % file2rem, C
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, foundFiles, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to perform action on " groupDigits(failedFiles) " files"
         If (skippedFiles>0)
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip(friendly " files to`n" finalDest "\" etaTime, 0, 0, countTFilez/foundFiles)
         prevMSGdisplay := A_TickCount
      }

      file2save := finalDest "\" OldOutFileName
      mustPerformOperation := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, 0, performOverwrite)
  
      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }

      thisFileExists := FileRexists(file2save, 0)
      If (performOverwrite=1 && thisFileExists=1)
      {
         jso := GetFileAttributesEx(file2save)
         originalFileInfos := jso.size "|" jso.wtime "|" jso.ctime
         FileSetAttrib, -R, %file2save%
         Sleep, 2
         FileRecycle, %file2save%
         Sleep, 2
         mustPerformOperation := 1
      } Else If (thisFileExists=1)
      {
         skippedFiles++
         Continue
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (filesActu=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
         }

         filezMoved++
         extraMarker := (thisFileExists=1 && performOverwrite=1) ? "*" : ""
         recordUndoFileActs(file2save, file2rem, extraMarker, filesActu, startZeit, originalFileInfos)
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   setWhileLoopExec(0)
   CurrentSLD := backCurrentSLD
   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (skippedFiles>0)
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)
   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " groupDigits(failedFiles) " files"

   If (filesActu=2)
   {
      isExplorerModeB := IsClipboardFormatAvailable(15)
      If (abandonAll!=1 && isExplorerModeA=1 && isExplorerModeB=1)
         Try Clipboard := ""

      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " groupDigits(filezMoved) " out of " groupDigits(foundFiles) " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BtnCloseWindow() {
   Critical, on
   If isNowAlphaPainting()
   {
      CloseWindow()
      Return
   }

   CloseWindow("yes")
   If AnyWindowOpen
      BtnCloseWindow()
}

InfoBtnNextImg() {
  If ((maxFilesIndex<2 || !maxFilesIndex) && StrLen(mustOpenStartFolder)<3)
     Return

  NextPicture()
  Sleep, 1
  SetTimer, PopulateImgInfos, -150
}

InfoBtnPrevImg() {
  If ((maxFilesIndex<2 || !maxFilesIndex) && StrLen(mustOpenStartFolder)<3)
     Return

  PreviousPicture()
  Sleep, 1
  SetTimer, PopulateImgInfos, -150
}

copyIMGinfos2clip() {
   Gui, SettingsGUIA: Default
   textu := "`nGENERAL DETAILS:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaD", 2, ": ")
   textu .= "`n `nSYSTEM FILE DETAILS:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaOthers", 2, ": ")
   textu .= "`n `nMETADATA:`n"
   textu .= getListViewData("SettingsGUIA", "LViewMetaM", 2, ": ")

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Unable to copy to clipboard file details")
         SoundBeep , 300, 100
      } Else showTOOLtip("File details copied to the clipboard")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateImgInfos() {
   If (AnyWindowOpen!=5)
      Return

   imgPath := getIDimage(currentFileIndex)
   If !FileExist(imgPath)
   {
      informUserFileMissing()
      Return
   }

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewMetaOthers
   LV_Delete()

   zPlitPath(imgPath, 0, fileNamu, folderu)
   ; Gets all of a file's non-blank properties.
   Try PropList := FGP_List(imgPath)
   Loop, Parse, % PropList.CSV,`n
   {
       If !A_LoopField
          Continue
       lineArru := StrSplit(A_LoopField, ",")
       If (lineArru[3]!=fileNamu && lineArru[3]!=folderu)
          LV_Add(A_Index, lineArru[2], lineArru[3])
   }

   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")

   Gui, SettingsGUIA: ListView, LViewMetaD
   LV_Delete()
   If FileExist(imgPath)
   {
      FileGetSize, FileSizu, % imgPath, K
      FileGetTime, FileDateM, % imgPath, M
      FileGetTime, FileDateC, % imgPath, C
      FormatTime, FileDateM, % FileDateM, dddd, d MMMM yyyy, HH:mm:ss
      FormatTime, FileDateC, % FileDateC, dddd, d MMMM yyyy, HH:mm:ss
   } Else notFound := 1

   If (thumbsDisplaying=1 && fileSizu)
   {
      thisFileIndex := currentFileIndex
      If (!resultedFilesList[thisFileIndex, 9] && notFound!=1)
      {
         If !retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12])
            GetCachableImgFileDetails(imgPath, thisFileIndex)
         If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
            updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
      }

      asr := " px (" Round(resultedFilesList[thisFileIndex, 13] / resultedFilesList[thisFileIndex, 14], 2) ") | "
      infoRes := "`nResolution (W x H)||" groupDigits(resultedFilesList[thisFileIndex, 13]) " x " groupDigits(resultedFilesList[thisFileIndex, 14]) asr resultedFilesList[thisFileIndex, 17] " MPx"
      infoRes .= " | " resultedFilesList[thisFileIndex, 22] " DPI"
   } Else If fileSizu
   {
      zoomu := "`nImage to window adapt mode||" DefineImgSizing()
      trGdip_GetImageDimensions(useGdiBitmap(), w, h)
      infoRes := "`nResolution (W x H)||" groupDigits(w) " x " groupDigits(h) " (in pixels)"
      If (currIMGdetails.TooLargeGDI=1)
         infoRes .= "`nOriginal resolution (W x H)||" groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " (in pixels)"
   }

   friendlyLabel := (userPrivateMode=1) ? "" : "File name||" fileNamu "`nLocation||" folderu "\`n"
   generalInfos := friendlyLabel "File size||" groupDigits(fileSizu) " kilobytes`nDate created||" FileDateC "`nDate modified||" FileDateM infoRes zoomu
   Loop, Parse, generalInfos, `n
   {
       lineArru := StrSplit(A_LoopField, "||")
       LV_Add(A_Index, lineArru[1], lineArru[2])
   }

   LV_Add(A_Index, "Colors display mode", DefineFXmodes())
   If (thumbsDisplaying!=1 && validBMP(useGdiBitmap()))
   {
      Gdip_GetHistogram(useGdiBitmap(), 2, ArrChR, ArrChG, ArrChB)
      Loop, 256
      {
          sumTotalR += ArrChR[A_Index] * A_Index
          sumTotalG += ArrChG[A_Index] * A_Index
          sumTotalB += ArrChB[A_Index] * A_Index
      }

      diffRGBtotal := max(sumTotalR, sumTotalG, sumTotalB) - min(sumTotalR, sumTotalG, sumTotalB)
      diffRGBtotal := diffRGBtotal/max(sumTotalR, sumTotalG, sumTotalB)
      If (diffRGBtotal<0.0001 || diffRGBtotal="")
         LV_Add(A_Index, "Grayscale image", 1)
      Else
         LV_Add(A_Index, "Grayscale image", 0)

      LV_Add(A_Index, "Image file format", currIMGdetails.RawFormat)
   }

   v := (thumbsDisplaying=1) ? resultedFilesList[currentFileIndex, 15] : currIMGdetails.PixelFormat
   LV_Add(A_Index, "Image pixel format", v)

   v := (thumbsDisplaying=1) ? resultedFilesList[currentFileIndex, 9] : currIMGdetails.Frames
   If (v>1)
      LV_Add(A_Index, "Embedded frames", v)

   If (currIMGdetails.OpenedWith="[GDI+]" && thumbsDisplaying!=1)
   {
      thumbBMP := trGdip_CreateBitmapFromFile(A_ThisFunc, getIDimage(currentFileIndex))
      If validBMP(thumbBMP)
         MoreProperties := Gdip_GetAllPropertyItems(thumbBMP)
      For ID, Val In MoreProperties
      {
         If ID Is Integer
         {
            PropName := Gdip_GetPropertyTagName(ID)
            PropType := Gdip_GetPropertyTagType(Val.Type)
            If (val.value && StrLen(PropName)>1 && PropName!="unknown" && PropType!="undefined" && PropType!="byte")
            {
               If (InStr(PropName, "nancetable") || InStr(PropName, "jpeg") || InStr(PropName, "thumbnail")
               || InStr(PropName, "printflag") || InStr(PropName, "strip") || InStr(PropName, "chromatic"))
                  Continue
 
               If (PropName="frame delay") || (PropName="bits per sample")
               {
                  valu := SubStr(Val.Value, 1, InStr(Val.Value, A_Space))
                  ; LV_Add(A_Index, PropName, valu "==ID:" ID "; Len:" val.Length "; Type:" val.Type)
                  LV_Add(A_Index, PropName, valu)
               } Else LV_Add(A_Index, PropName, Val.Value)
            }
         }
      }
      trGdip_DisposeImage(thumbBMP, 1)
   }

   If (thumbsDisplaying!=1)
      LV_Add(A_Index, "Image loaded with", currIMGdetails.OpenedWith)

   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")

   If FileExist(mainExecPath "\exiftool.exe")
      populateExifToolInfos()
}

populateExifToolInfos() {
   If (AnyWindowOpen=5)
   {
      Gui, SettingsGUIA: Default
      Gui, SettingsGUIA: ListView, LViewMetaM
      LV_Delete()
      cmdLine := """" mainExecPath "\exiftool.exe"" -all """ getIDimage(currentFileIndex) """ `r`n `r`n"
      output := Cli_RunCMD(cmdLine, A_WorkingDir, "CP850", "", 4500)
      ; ToolTip, % output , , , 2
      hasAdded := 0
      Loop, Parse, % output,`n,`r
      {
          If (!A_LoopField || SubStr(Trimmer(A_LoopField), 2, 2)=":\" || InStr(A_LoopField, "use -b option")
          || InStr(A_LoopField, "exiftool version") || InStr(A_LoopField, "wb rb levels"))
             Continue

          lineArru := StrSplit(A_LoopField, " : ")
          prop := Trimmer(lineArru[1])
          val := Trimmer(lineArru[2])
          If (StrLen(prop)>2 && val!="")
          {
             hasAdded++
             LV_Add(A_Index, prop, val)
          }
      }
      If (hasAdded<2)
         LV_Add(A_Index, "Failed to retrieve the data", "-")

      Loop, 2
          LV_ModifyCol(A_Index, "AutoHdr Left")
   }
}

Trimmer(string, whatTrim:="") {
   If (whatTrim!="")
      string := Trim(string, whatTrim)
   Else
      string := Trim(string, "`r`n `t`f`v`b")
   Return string
}

FileRexists(filePath, loose:=1) {
   obju := GetFileAttributesEx(filePath)
   ; MsgBox, % fileAttribs "`n" fileSizu "`nA" filePath "A"
   If (obju.size<120 && loose=1 || !obju.size || obju.dir=1)
      Return 0
   Else
      Return 1
}

hFindIsFolder(ByRef fileInfos) {
   Static FILE_ATTRIBUTE_DIRECTORY := 0x10
   Return NumGet(&fileInfos,0,"UInt") & FILE_ATTRIBUTE_DIRECTORY
}

hFindGetName(ByRef fileInfos) {
   cFileName := StrGet(&fileInfos + 44, 260, "UTF-16")
   If (cFileName="." || cFileName="..")
      cFileName := ""
   Return cFileName
}

testGetFile(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 1512, 0)
    hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")
    cFileName := hFindGetName(Win32FindData)
    If (hFindIsFolder(Win32FindData) && cFileName)
    {
    ;  MsgBox, folderrr
       testGetFile(filePath "\" cFileName)
    } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
    {
       maxFilesIndex++
       resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
    }

   ; MsgBox, % filePath "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError


 ;   instance.nFileSizeHigh := NumGet(&Win32FindData, 28,  "UInt")
;    instance.nFileSizeLow := NumGet(&Win32FindData, 32,  "UInt")

    While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData))
    {
          cFileName := hFindGetName(Win32FindData)
          If hFindIsFolder(Win32FindData) && cFileName
          {
             testGetFile(filePath "\" cFileName)
          } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
          {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
          }
    ; MsgBox, % filePath "`n" r "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
    }

   ; maxFilesIndex := resultedFilesList.Length()
    ; SoundBeep 
    Return
}

testGetFile2(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 318+1024, 0)
    if (hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")) {
        cFileName := StrGet(&Win32FindData + 44, 260, "UTF-16")
        cAlternateFileName := StrGet(&Win32FindData + 564, 14, "UTF-16")
        
        MsgBox, %  hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
        While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData))
        {
            cFileNamea := StrGet(&Win32FindData + 44, 260, "UTF-16")
            cAlternateFileNamea := StrGet(&Win32FindData + 564, 14, "UTF-16")
            MsgBox, %  r "`n" cFileNameA "`n" cAlternateFileNameA "`n" ErrorLevel "`n" A_LastError
        }
    }
    Return
}

testFileExistence(imgPath) {
  ; https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-getfilesize
  ; H := DllCall("kernel32\GetFileAttributesW", "Str", imgPath)
  ; H := DllCall("shlwapi.dll\PathFileExistsW", "Str", imgPath)
  ; If (h>0)
  ;    Return 256
  VarSetCapacity(dummy, 1024, 0)
  H := DllCall("kernel32\FindFirstFileW", "Str", imgPath, "Ptr", &dummy, "Ptr")
  Return H
}

informUserFileMissing(clearScreen:=0) {
   Critical, on
   If (clearScreen=1)
      clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIwin)

   If (userPrivateMode=1)
   {
      showTOOLtip("ERROR: File not found or access denied")
      winTitle := "[*] " currentFileIndex "/" maxFilesIndex
   } Else
   {
      imgPath := getIDimage(currentFileIndex)
      zPlitPath(imgPath, 0, fileNamu, folderu)
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" folderu "\")
      winTitle := "[*] " currentFileIndex "/" maxFilesIndex " | " fileNamu " | " folderu
   }

   setWindowTitle(winTitle, 1)
   SoundBeep, 300, 100
   If (autoRemDeadEntry=1)
      remCurrentEntry(1)
   If (thumbsDisplaying=1 && maxFilesIndex>0)
      mainGdipWinThumbsGrid()

   SetTimer, RemoveTooltip, % -msgDisplayTime
}

JEE_StrRegExLiteral(vText) {
  Loop, Parse, vText
  {
    If InStr("\.+[{()^$", A_LoopField)
      vOutput .= "\" A_LoopField
    Else If InStr("?*", A_LoopField)
      vOutput .= "." A_LoopField
    Else
      vOutput .= A_LoopField
  }

  Return vOutput
}

FiltersComboAction() {
  If (A_GuiControlEvent="DoubleClick")
     BtnApplyFilesFilter()
}


readRecentFiltersEntries() {
   Loop, 20
   {
       IniRead, newEntry, % mainRecentsFile, RecentFilters, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (InStr(entriesList, newEntry "`n") || !newEntry)
          Continue

       addSel := (newEntry=testFilteru) ? "`n" : ""
       If StrLen(newEntry)>1
          entriesList .= newEntry "`n" addSel
   }

   Return entriesList
}

EraseFilterzHisto() {
  IniDelete, % mainRecentsFile, RecentFilters
  CloseWindow()
  Sleep, 50
  PanelEnableFilesFilter()
}

InitialFilterSettingsPanel(modus) {
    Static o_userFilterDoString, o_userFilterStringPos
         , o_userFilterStringIsNot, o_userFilterInvertThis
         , o_userFilterProperty, o_userFilterWhat
         , o_UsrEditFilter, o_FilteruMaxRange
         , o_FilteruMinRange, o_userFilterSizeProperty

    If (modus=1)
    {
       o_userFilterDoString := userFilterDoString
       o_userFilterStringPos := userFilterStringPos
       o_userFilterStringIsNot := userFilterStringIsNot
       o_userFilterInvertThis := userFilterInvertThis
       o_userFilterProperty := userFilterProperty
       o_userFilterWhat := userFilterWhat
       o_UsrEditFilter := UsrEditFilter
       o_FilteruMaxRange := FilteruMaxRange
       o_FilteruMinRange := FilteruMinRange
       o_userFilterSizeProperty := userFilterSizeProperty
    } Else
    {
       userFilterDoString := o_userFilterDoString
       userFilterStringPos := o_userFilterStringPos
       userFilterStringIsNot := o_userFilterStringIsNot
       userFilterInvertThis := o_userFilterInvertThis
       userFilterProperty := o_userFilterProperty
       userFilterWhat := o_userFilterWhat
       UsrEditFilter := o_UsrEditFilter
       FilteruMaxRange := o_FilteruMaxRange
       FilteruMinRange := o_FilteruMinRange
       userFilterSizeProperty := o_userFilterSizeProperty
    }
}

PanelEnableFilesFilter() {
    Global FilterTypeu := 0
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (testIsDupesList() && InStr(resultedFilesList[currentFileIndex, 23], "_"))
    {
       showTOOLtip("WARNING: The files list is already filtered.`nThe list displays duplicate image pairs filtered by Hamming distance.")
       ; SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, PanelChangeHamDistThreshold, -50
       Return
    }

    If (maxFilesIndex<3 && !filesFilter)
    {
       showTOOLtip("WARNING: Insufficient files are currently indexed.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(6, A_ThisFunc)
    btnWid := 80
    txtWid := 360
    EditWid := 285
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 200
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    If !filesFilter
    {
       userFilterProperty := 1 
       userFilterDoString := 0
    }

    InitialFilterSettingsPanel(1)
    listu := readRecentFiltersEntries()
    If (!InStr(listu, "`n`n") && StrLen(UsrEditFilter)>0 && userFilterDoString=1 && StrLen(filesFilter)>1)
       listu := UsrEditFilter "`n`n" listu

    Gui, +Delimiter`n
    Gui, Add, Tab3, %tabzDarkModus%, Text`nFile and image
    Gui, Tab, 1
    Gui, Add, Checkbox, x+15 y+15 Section gupdateUIFiltersPanel Checked%userFilterDoString% vuserFilterDoString, Filter files list with given string
    Gui, Add, Text, y+7 w1 h1, String filter
    Gui, Add, ComboBox, yp w%EditWid% gUIgenericComboAction vUsrEditFilter, % listu
    GuiAddDropDownList("y+7 w" btnWid " gupdateUIFiltersPanel AltSubmit Choose" userFilterStringPos " vuserFilterStringPos", "Anywhere`nBegins with`nEnds with`nRegEx", "String filter matching mode")
    GuiAddDropDownList("x+2 w" btnWid " gupdateUIFiltersPanel AltSubmit Choose" userFilterWhat " vuserFilterWhat", "Full paths`nFolder paths`nFile names`nParent folders", "Apply filter based on")
    Gui, Add, Checkbox, xs y+7 gupdateUIFiltersPanel Checked%userFilterStringIsNot% vuserFilterStringIsNot, &Must not contain the given string
    Gui, Add, Button, xs y+7 vbtnFldr h%thisBtnHeight% w%btnWid% gEraseFilterzHisto, Erase &history
    Gui, Add, Text, xs y+15 vbtnFldr2, You can use | for OR and the *, ? wildcards in the filter`nto match more files.
    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 Section, Please choose the type of criteria and`nset minimum and maximum range.
    GuiAddDropDownList("xs y+7 w" btnWid " gupdateUIFiltersPanel AltSubmit Choose" userFilterProperty " vuserFilterProperty", "No criteria defined`nFile size`nModified date`nCreated date`nMegapixels`nWidth`nHeight`nAspect ratio`nFrames`nDPI`nAverage`nMedian`nPeak range`nMinimum range`nTotal range`nMode`nMinimum`nRoot-mean suqare`nSelected files`nAlready seen", "Filter criteria")
    Gui, Add, Text, x+5 wp hp +0x200 vFilterTypeu, -
    hEditA := GuiAddEdit("xs y+5 w" btnWid " number limit5 gupdateUIFiltersPanel vFilteruMinRange", FilteruMinRange, "Minimum")
    hEditB := GuiAddEdit("x+5 w" btnWid " number limit5 gupdateUIFiltersPanel vFilteruMaxRange", FilteruMaxRange, "Maximum")
    GuiAddDropDownList("x+5 wp gupdateUIFiltersPanel AltSubmit Choose" userFilterSizeProperty " vuserFilterSizeProperty", "Kilobytes`nMegabytes", "File size unit")
    Gui, Add, DateTime, xs y+7 wp gupdateUIFiltersPanel vFilteruDateMinRange, yyyy/MM/dd
    Gui, Add, DateTime, x+5 wp gupdateUIFiltersPanel vFilteruDateMaxRange, yyyy/MM/dd
    Gui, Add, Checkbox, xs y+7 gupdateUIFiltersPanel Checked%userFilterInvertThis% vuserFilterInvertThis, &Invert filter
    Gui, Tab
    GuiAddEdit("xs y+10 w" EditWid " r2 +0x0800 vInternalFilterString", filesFilter, "Resulted files list filter query.")
    ; Gui, Add, Text, y+7 w%txtWid%, Tip: you can begin the string with \> to use RegEx.

    btnWid := (PrefsLargeFonts=1) ? btnWid - 15 : btnWid - 5
    Gui, Add, Button, xs+0 y+10 h%thisBtnHeight% w%btnWid% Default gBtnApplyFilesFilter, &Apply filter
    If StrLen(filesFilter)>1
       Gui, Add, Button, x+5 hp wp+20 gBTNuiremFilesListFilter, &Remove filters
    btnWid := (PrefsLargeFonts=1) ? 85 : 65
    Gui, Add, Button, x+5 hp w%btnWid% gPanelWrapperFilesStats, S&tats
    Gui, Add, Button, x+5 hp wp gPanelSearchIndex, &Search
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Files list filtering: " appTitle)
    ; EM_SETCUEBANNER(hEditC, "String to match")
    SetTimer, updateUIFiltersPanel, -300
}

BTNuiremFilesListFilter() {
   InitialFilterSettingsPanel(1)
   BtnCloseWindow()
   remFilesListFilter()
   SetTimer, RandomPicture, -90
}

SQLescapeStr(str, likeu:=0) {
   str := StrReplace(str, "'", "''")
   If (likeu=1)
   {
      str := StrReplace(str, "_", ">_")
      str := StrReplace(str, "%", ">%")
      str := StrReplace(str, "[", ">[")
   }
   Return str
}

updateUIFiltersPanel(dummy:=0) {
   Static columnsList := {2:"fsize", 3:"fmodified", 4:"fcreated", 5:"imgmegapix", 6:"imgwidth", 7:"imgheight", 8:"imgwhratio", 9:"imgframes", 10:"imgdpi", 11:"imgavg", 12:"imgmedian", 13:"imghpeak", 14:"imghlow", 15:"imghrange", 16:"imghmode", 17:"imghminu", 18:"imghrms"}

   If (dummy!="external")
   {
      If (AnyWindowOpen!=6)
         Return

      Gui, SettingsGUIA: Default
      GuiControlGet, UsrEditFilter
      GuiControlGet, userFilterDoString
      GuiControlGet, userFilterStringIsNot
      GuiControlGet, userFilterStringPos
      GuiControlGet, userFilterWhat
      GuiControlGet, userFilterProperty
      GuiControlGet, userFilterSizeProperty
      GuiControlGet, userFilterInvertThis
      GuiControlGet, FilteruMinRange
      GuiControlGet, FilteruMaxRange
      GuiControlGet, FilteruDateMaxRange
      GuiControlGet, FilteruDateMinRange

      If (userFilterStringPos!=4)
      {
         Loop, Parse, % "<>/"
            UsrEditFilter := StrReplace(UsrEditFilter, A_LoopField)

         If (userFilterWhat=3)
         {
            Loop, Parse, % ":\"
               UsrEditFilter := StrReplace(UsrEditFilter, A_LoopField)
         }
         UsrEditFilter := StrReplace(UsrEditFilter, "||")
      }

      actu := (userFilterDoString=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, userFilterWhat
      GuiControl, % actu, userFilterStringPos
      GuiControl, % actu, userFilterStringIsNot
      GuiControl, % actu, UsrEditFilter
      GuiControl, % actu, btnFldr
      GuiControl, % actu, btnFldr2

      actu := (userFilterProperty=1 || userFilterProperty=19) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, userFilterInvertThis

      actu := (userFilterProperty=2) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, userFilterSizeProperty

      actu := (userFilterProperty=3 || userFilterProperty=4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, FilteruDateMaxRange
      GuiControl, % actu, FilteruDateMinRange

      actu := (userFilterProperty=2 || isInRange(userFilterProperty, 5, 18)) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, FilteruMinRange
      GuiControl, % actu, FilteruMaxRange

      If isInRange(userFilterProperty, 2, 4)
      {
         GuiControl, SettingsGUIA:, FilterTypeu, File property
      } Else If isInRange(userFilterProperty, 5, 10)
      {
         GuiControl, SettingsGUIA:, FilterTypeu, Image property
      } Else If isInRange(userFilterProperty, 11, 18)
      {
         ; FilteruMaxRange := Round(FilteruMaxRange*1.05)
         ; FilteruMinRange := Round(FilteruMinRange*1.05)
         GuiControl, SettingsGUIA:, FilterTypeu, Histogram details
      } Else
      {
         GuiControl, SettingsGUIA:, FilterTypeu, -
      }
   }

   ; testRegEx := SubStr(UsrEditFilter, 1, 2)
   thisStringFilter := ""
   If (userFilterDoString=1 && SLDtypeLoaded=3)
   {
      thisStringFilter := SQLescapeStr(UsrEditFilter, 1)
      If (userFilterStringPos=4 && thisStringFilter)
         thisStringFilter := thisStringFilter
      Else If (userFilterStringPos=3 && thisStringFilter) 
         thisStringFilter := "%" thisStringFilter
      Else If (userFilterStringPos=2 && thisStringFilter)
         thisStringFilter := thisStringFilter "%"
      Else If (UsrEditFilter!="")
         thisStringFilter := "%" thisStringFilter "%"

      thisStringFilter := StrReplace(thisStringFilter, "?", "_")
      thisStringFilter := StrReplace(thisStringFilter, "*", "_")
      thisStringFilter := StrReplace(thisStringFilter, "|")
   } Else If (userFilterDoString=1)
   {
      If (userFilterStringPos=4 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)" UsrEditFilter
      Else If (userFilterStringPos=3 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")$"
      Else If (userFilterStringPos=2 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)^(" JEE_StrRegExLiteral(UsrEditFilter) ")"
      Else If (UsrEditFilter!="")
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")"
   }

   columnu := columnsList[userFilterProperty]
   minRange := min(FilteruMinRange, FilteruMaxRange)
   maxRange := max(FilteruMinRange, FilteruMaxRange)
   minDrange := min(FilteruDateMinRange, FilteruDateMaxRange)
   maxDrange := max(FilteruDateMinRange, FilteruDateMaxRange)
   If (userFilterProperty>1 && minRange!="")
   {
      If (userFilterProperty=2)
      {
         minRange := (userFilterSizeProperty=2) ? minRange*(1024**2) : minRange*1024
         maxRange := (userFilterSizeProperty=2) ? maxRange*(1024**2) : maxRange*1024
      } Else If (userFilterProperty=3 || userFilterProperty=4)
      {
         minRange := SubStr(minDrange, 1, 8) "010101"
         maxRange := SubStr(maxDrange, 1, 8) "010101"
      } Else If (userFilterProperty=8)
      {
         minRange := Round(minRange/10, 1)
         maxRange := Round(maxRange/10, 1)
      } Else If (userFilterProperty>10)
      {
         minRange := Round(clampInRange(minRange, 1, 256)/256, 5)
         maxRange := Round(clampInRange(maxRange, 1, 256)/256, 5)
      }

      If (SLDtypeLoaded=3)
      {
         isOrNot := (userFilterStringIsNot=1) ? " NOT " : ""
         2ndColumn := (userFilterWhat=1) ? "fullPath" : "imgfolder"
         If (userFilterProperty=8)
            columnu := "Round(imgwhratio, 1)"
         If (userFilterProperty=5)
            columnu := "Round(imgmegapix)"

         If (userFilterWhat=3)
            2ndColumn := "imgfile"

         If (userFilterInvertThis=1)
            invertor := " NOT "

         finalFilteru := "SQL:query:WHERE " columnu invertor " BETWEEN " minRange " AND " maxRange
         If thisStringFilter
            finalFilteru .= " AND " 2ndColumn isOrNot " LIKE '" thisStringFilter "' ESCAPE '>'"
      } Else
      {
         finalFilteru := "QPV::query::" columnu "::" minRange "::" maxRange
         If thisStringFilter
            finalFilteru .= "::" thisStringFilter
      }
   } Else
   {
      If (SLDtypeLoaded=3 && thisStringFilter)
      {
         isOrNot := (userFilterStringIsNot=1) ? " NOT " : ""
         2ndColumn := (userFilterWhat=1) ? "fullPath" : "imgfolder"
         If (userFilterWhat=3)
            2ndColumn := "imgfile"
         finalFilteru := "SQL:query:WHERE " 2ndColumn isOrNot " LIKE '" thisStringFilter "' ESCAPE '>'"
      } Else If thisStringFilter
         finalFilteru := "\>" thisStringFilter
   }

   newFilter := Trimmer(finalFilteru)
   newFilter := StrReplace(newFilter, "||", "|")
   newFilter := Trimmer(newFilter, "|")
   If (userFilterProperty=19)
      newFilter := (SLDtypeLoaded=3) ? "SQL:query:||Prev-Files-Selection||" : "||Prev-Files-Selection||"
   Else If (userFilterProperty=20)
      newFilter := "||Already-Seen-Images||"

   If (dummy!="external")
      GuiControl, SettingsGUIA:, InternalFilterString, % newFilter

   Return newFilter
}

quickFindUnseenImages() {
   quickFindSeenImages("unseen")
}

quickFindSeenImages(dummy:=0) {
   UsrEditFilter := "||Already-Seen-Images||"
   userFilterDoString := 0
   userFilterProperty := 20
   userFilterInvertThis := (dummy="unseen") ? 1 : 0
   updateUIFiltersPanel("external")
   retrieveAlreadySeenImageFromCurrentList()
   InitialFilterSettingsPanel(1)
}

BtnApplyFilesFilter() {
   Gui, SettingsGUIA: Default
   GuiControlGet, UsrEditFilter
   GuiControlGet, userFilterInvertThis
   newFilter := updateUIFiltersPanel()
   Gui, SettingsGUIA: Submit, NoHide
   If !newFilter
   {
      SoundBeep , 300, 100
      showTOOLtip("WARNING: No filter has been defined")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (userFilterProperty=19)
   {
      getSelectedFiles(0, 1)
      If !markedSelectFile
      {
         msgBoxWrapper(appTitle ": WARNING", "You currently have no selected image in the files list. The filter is therefore inapplicable.", 0, 0, "warning")
         Return
      } Else userFilterDoString := 0
   } Else If (userFilterProperty=20)
   {
      InitialFilterSettingsPanel(1)
      BtnCloseWindow()
      retrieveAlreadySeenImageFromCurrentList()
      Return
   }

   InitialFilterSettingsPanel(1)
   BtnCloseWindow()
   If askAboutFileSave(" and the files list will be renewed based on the provided filter criteria")
   {
      userFilterDoString := 0
      userFilterProperty := 1
      UsrEditFilter := ""
      Return
   }

   If (userFilterDoString=1 && UsrEditFilter)
      RecentFiltersManager(UsrEditFilter)

   coreEnableFiltru(newFilter)
   dummyTimerDelayiedImageDisplay(50)
}

RecentFiltersManager(entry2add) {
  If (userPrivateMode=1)
     Return

  entry2add := Trimmer(entry2add)
  mainListu := readRecentFiltersEntries()
  If (StrLen(entry2add)<3 || InStr(entry2add, "{ no filter }"))
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>20)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentFilters, E%countItemz%
  }
}

WinMsgBoxGuiClose:
WinMsgBoxGuiEscape:
  KillMsgbox2Win()
  Gui, WinMsgBox: Destroy
Return


msgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, checkBoxuCaption:="", checkState:=0, dropListu:="",edithu:="", edithuDef:="", listEditMode:=0, setWidth:=0, 2ndDropListu:=0, 2ndlistEditMode:=0) {
    Static msgBoxed := 0

    mouseTurnOFFtooltip()
    If (msgBoxed=1 && MsgBox2hwnd)
       Return

    msgBoxed := 1
    setWinCloseZeit()
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", iconz)

    panelMode := 0
    fontSize := (PrefsLargeFonts=1) ? LargeUIfontValue : 0
    hwnd := (AnyWindowOpen>0 && panelWinCollapsed!=-1) ? hSetWinGui : PVhwnd
    If (InStr(winTitle, "panelu|") && AnyWindowOpen>0 && isNowFakeWinOpen=1)
    {
       winTitle := StrReplace(winTitle, "panelu|")
       panelMode := 1
       hwnd := PVhwnd
    } Else DestroyTempBtnGui("now")

    If (WinActive("A")!=hKbdGuia)
    {
       hasDisabled := []
       If (folderTreeWinOpen=1)
       {
          hasDisabled[1] := 1
          WinSet, Disable,, ahk_id %hfdTreeWinGui%
       }

       If (VisibleQuickMenuSearchWin=1 && az)
       {
          hasDisabled[2] := 1
          WinSet, Disable,, ahk_id %hQuickMenuSearchWin%
       }

       If (imgEditPanelOpened=1 && Hwnd!=PVhwnd)
       {
          hasDisabled[3] := 1
          WinSet, Disable,, ahk_id %PVhwnd%
       }
    } Else hwnd := hKbdGuia

    oc := A_IsCritical 
    Critical, off
    zr := MsgBox2(msg, winTitle, buttonz, defaultBTN, iconz, nullFnt, PrefsLargeFonts, fontSize, hwnd, hwnd, checkBoxuCaption, checkState, dropListu, edithu, edithuDef, listEditMode, setWidth, 2nddropListu, 2ndlistEditMode)
    Critical, %oc%
    r := zr.btn

    If hasDisabled[3]
       WinSet, Enable,, ahk_id %PVhwnd%

    If hasDisabled[2]
       WinSet, Enable,, ahk_id %hQuickMenuSearchWin%

    If hasDisabled[1]
       WinSet, Enable,, ahk_id %hfdTreeWinGui%

    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    If (buttonz!=-1)
       addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
    Else
       addJournalEntry("HELP BOX CLOSED: " winTitle)

    If (panelMode=1) ; fake window panel
    {
       AnyWindowOpen := isNowFakeWinOpen := 0
       interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    }
    createGUItoolbar()
    lastLongOperationAbort := A_TickCount
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", "normal")

    ; SetTimer, setWinCloseZeit, -200, 900
    msgBoxed := 0
    Return (checkBoxuCaption || dropListu || edithu || 2ndDropListu) ? zr : r
}

simpleMsgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, modality:=0, optionz:=0) {
   ; Buttonz options:
   ; 0 = OK (that is, only an OK button is displayed)
   ; 1 = OK/Cancel
   ; 2 = Abort/Retry/Ignore
   ; 3 - Yes/No/Cancel
   ; 4 = Yes/No
   ; 5 = Retry/Cancel
   ; 6 = Cancel/Try Again/Continue

   ; Iconz options:
   ; 16 = Icon Hand (stop/error)
   ; 32 = Icon Question
   ; 48 = Icon Exclamation
   ; 64 = Icon Asterisk (info)

   ; Modality options:
   ; 4096 = System Modal (always on top)
   ; 8192 = Task Modal
   ; 262144 = Always-on-top (style WS_EX_TOPMOST - like System Modal but omits title bar icon)

   If AnyWindowOpen
   {
      If (defaultBTN=2)
         defaultBTN := 255
      Else If (defaultBTN=3)
         defaultBTN := 512
      Else
         defaultBTN := 0
 
      If (iconz=1 || iconz="hand" || iconz="error" || iconz="stop")
         iconz := 16
      Else If (iconz=2 || iconz="question")
         iconz := 32
      Else If (iconz=3 || iconz="exclamation")
         iconz := 48
      Else If (iconz=4 || iconz="info")
         iconz := 64
      Else
         iconz := 0
 
      theseOptionz := buttonz + iconz + defaultBTN + modality
      If optionz
         theseOptionz := optionz
 
      Gui, SettingsGUIA: +OwnDialogs
      MsgBox, % theseOptionz, % winTitle, % msg
      IfMsgBox, Yes
           r := "Yes"
      IfMsgBox, No
           r := "No"
      IfMsgBox, OK
           r := "OK"
      IfMsgBox, Cancel
           r := "Cancel"
      IfMsgBox, Abort
           r := "Abort"
      IfMsgBox, Ignore
           r := "Ignore"
      IfMsgBox, Retry
           r := "Retry"
      IfMsgBox, Continue
           r := "Continue"
      IfMsgBox, TryAgain
           r := "TryAgain"
   } Else r := interfaceThread.ahkFunction("msgBoxWrapper", winTitle, msg, buttonz, defaultBTN, iconz, modality, optionz)

   ; addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
   ; lastLongOperationAbort := A_TickCount
   Return r
}

coreEnableFiltru(stringu, noStringProcessing:=0) {
  startOperation := A_TickCount
  prevFilter := filesFilter
  If (stringu="\>")
     stringu := filesFilter := ""

  backCurrentSLD := CurrentSLD
  userSearchString := CurrentSLD := ""
  friendly := (StrLen(stringu)>1) ? "Applying filter on the list of files, please wait`n" stringu : "Deactivating the files list filter, please wait..."
  showTOOLtip(friendly)
  setImageLoading()

  If StrLen(filesFilter)<2
  {
     thereWasFilter := 0
     bckpResultedFilesList := []
     bckpResultedFilesList := resultedFilesList.Clone()
     bckpCurrentFileIndex := currentFileIndex
     bckpMaxFilesIndex := maxFilesIndex
  } Else thereWasFilter := 1

  If (stringu="||Already-Seen-Images||")
  {
     CurrentSLD := backCurrentSLD
     retrieveAlreadySeenImageFromCurrentList()
     Return
  }

  If (noStringProcessing=0)
  {
     testRegEx := SubStr(stringu, 1, 2)
     If (InStr(stringu, "QPV::query") || InStr(stringu, "SQL:query"))
        filesFilter := stringu
     Else If (testRegEx!="\>")
        filesFilter := JEE_StrRegExLiteral(stringu)
     Else
        filesFilter := SubStr(stringu, 3)
  } Else filesFilter := stringu

  FilterFilesIndex(thereWasFilter, prevFilter)
  If (maxFilesIndex<1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "No files matched your filtering criteria:`n" stringu "`n`nQPV will now restore the complete list of files.", 0, 1, "exclamation")
     filesFilter := ""
     FilterFilesIndex(0, 0)
  } Else If (A_TickCount - startOperation>1500)
     SoundBeep, 900, 100

  CurrentSLD := backCurrentSLD
  If !filesFilter
  {
     bckpResultedFilesList := []
     filteredMap2mainList := []
     toBeExcludedIndexes := []
     resultsDupesArray := []
     dupesHashesData := []
     dupesPixelData := []
     ; ToolTip, haha , , , 2
     currentFileIndex := clampInRange(bckpCurrentFileIndex, 1, maxFilesIndex)
     If (maxFilesIndex>0 && doRandom=1)
        dummyTimerDelayiedImageDisplay(50)
  } Else If (maxFilesIndex>0 && doRandom=1)
  {
     ; SoundBeep 1200, 100
     currentFileIndex := 1
     dummyTimerDelayiedImageDisplay(50)
     ; RandomPicture()
  }

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, TriggerMenuBarUpdate, -50
  SetTimer, createGUItoolbar, -100
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

FilterFilesIndex(thereWasFilter:=0, prevFilter:="") {
   If (InStr(prevFilter, "SQL:query:") && !InStr(filesFilter, "SQL:query:"))
   {
      BtnIndexStatsToList(0, 0, "none", 0) 
      If StrLen(filesFilter)<2
         Return
   }

   startZeit := A_TickCount
   selectedFiles := newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   mustDoQuery := 0
   If InStr(filesFilter, "QPV::query::")
   {
      queryObj := StrSplit(filesFilter, "::")
      queryType := queryObj[3]
      If (queryObj[5]="")
         queryObj[5] := queryObj[4]

      If (queryType="imgpixfmt" && queryObj[4])
      {
         queryMin := queryMax := queryObj[4]
         mustDoQuery := 1
      } Else If (queryType && !isNumber(queryType) && isNumber(queryObj[4]) && isNumber(queryObj[5]))
      {
         queryMin := min(Abs(queryObj[4]), Abs(queryObj[5]))
         queryMax := max(Abs(queryObj[4]), Abs(queryObj[5]))
         mustDoQuery := 1
      }

      queryString := Trimmer(queryObj[6])
      userFilterDoString := StrLen(queryString)>0 ? 1 : 0
      If (userFilterDoString!=1)
         queryString := 0

      If (mustDoQuery=1)
      {
         If RegExMatch(queryType, "i)(fsize|fmodified|fcreated)")
            r := collectFileInfosNow(queryString)
         Else If RegExMatch(queryType, "i)(imgpixfmt|imgwidth|imgheight|imgwhratio|imgmegapix|imgframes|imgdpi)")
            r := collectImageInfosNow(queryString, 9, 0)
         Else If RegExMatch(queryType, "i)(imgavg|imgmedian|imghpeak|imghlow|imghminu|imghmode|imghrms|imghrange)")
            r := collectImageInfosNow(queryString, 11, 0)

         If (r=1)
         {
            resultedFilesList := []
            resultedFilesList := bckpResultedFilesList.Clone()
            bckpResultedFilesList := []
            filesFilter := ""
            SoundBeep, 300, 100
            showTOOLtip("Operation abandoned. The files list was not filtered, because data collection did not complete.")
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }
      ; ToolTip, % queryType "=" queryMin "=" queryMax , , , 2
   }

   ; ToolTip, % filesFilter " = " userFilterWhat " = " userFilterStringIsNot , , , 2
   If (InStr(filesFilter, "SQL:query:WHERE") && SLDtypeLoaded=3)
   {
      If isInRange(userFilterProperty, 2, 4)
         collectSQLFileInfosNow("fsize", 0, 1, 0)
      Else If isInRange(userFilterProperty, 5, 10)
         collectSQLFileInfosNow("imgmegapix", 0, 1, 0)
      Else If isInRange(userFilterProperty, 11, 18)
         collectSQLFileInfosNow("imgmedian", 0, 1, 0)

      markedSelectFile := 0
      filteredMap2mainList := []
      extraFilter := extractSQLqueryFromFilter()
      r := BtnIndexStatsToList(0, extraFilter, "custom", extraFilter)
      If (r=-1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": WARNING", "No files matched the provided filter options:`n" filesFilter "`n`nThe application will now restore the complete list of files.", 0, 1, "exclamation")
         remFilesListFilter("simple")
      } Else bckpResultedFilesList := []
      Return
   } Else If InStr(filesFilter, "||Prev-Files-Selection||")
   {
      Loop, % maxFilesIndex + 1
      {
            r := resultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            If (resultedFilesList[A_Index, 2]!=1) ; is selected ?
               Continue

            newFilesIndex++
            newFilesList[newFilesIndex] := resultedFilesList[A_Index]
            If resultedFilesList[A_Index, 2]
               selectedFiles++

            If (thereWasFilter=1)
            {
               oldIndex := filteredMap2mainList[A_Index]
               newMappingList[newFilesIndex] := oldIndex
            } Else newMappingList[newFilesIndex] := A_Index
      }
   } Else
   {
      isStrFilter := StrLen(filesFilter)>1 ? 1 : 0
      Loop, % bckpMaxFilesIndex + 1
      {
            r := bckpResultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            thisIndex++
            If (mustDoQuery=1)
            {
               If (userFilterDoString=1)
               {
                  If !coreSearchIndex(r, queryString, userFilterWhat, userFilterStringIsNot)
                     Continue
               }

               Switch queryType
               {
                  Case "fmodified":
                     valu := bckpResultedFilesList[A_Index, 7]
                  Case "fcreated":
                     valu := bckpResultedFilesList[A_Index, 8]
                  Case "fsize":
                     valu := bckpResultedFilesList[A_Index, 6]
                  Case "imgmegapix":
                     valu := Round(bckpResultedFilesList[A_Index, 17], 1)
                  Case "imgwidth":
                     valu := bckpResultedFilesList[A_Index, 13]
                  Case "imgheight":
                     valu := bckpResultedFilesList[A_Index, 14]
                  Case "imgpixfmt":
                     valu := bckpResultedFilesList[A_Index, 15]
                  Case "imgdpi":
                     valu := bckpResultedFilesList[A_Index, 22]
                  Case "imgframes":
                     valu := bckpResultedFilesList[A_Index, 9]
                  Case "imgwhratio":
                     valu := Round(bckpResultedFilesList[A_Index, 16], 1)
                  Case "imgmedian":
                     valu := bckpResultedFilesList[A_Index, 19]
                  Case "imgavg":
                     valu := bckpResultedFilesList[A_Index, 18]
                  Case "imghpeak":
                     valu := bckpResultedFilesList[A_Index, 20]
                  Case "imghlow":
                     valu := bckpResultedFilesList[A_Index, 21]
                  Case "imghrms":
                     valu := bckpResultedFilesList[A_Index, 24]
                  Case "imghrange":
                     valu := bckpResultedFilesList[A_Index, 25]
                  Case "imghmode":
                     valu := bckpResultedFilesList[A_Index, 26]
                  Case "imghminu":
                     valu := bckpResultedFilesList[A_Index, 27]
               }

               zuza := isInRange(valu, queryMin, queryMax)
               If (userFilterInvertThis=1)
                  zuza := !zuza

               If !zuza
                  Continue
            } Else If (isStrFilter=1)
            {
               If !coreSearchIndex(r, filesFilter, userFilterWhat, userFilterStringIsNot)
                  Continue
            }

            newFilesIndex++
            newFilesList[newFilesIndex] := bckpResultedFilesList[A_Index]
            If bckpResultedFilesList[A_Index, 2]
               selectedFiles++

            If (isStrFilter=1)
               newMappingList[newFilesIndex] := A_Index
      }
   }

   filteredMap2mainList := []
   renewCurrentFilesList()
   If StrLen(filesFilter)>1
      filteredMap2mainList := newMappingList.Clone()
   resultedFilesList := newFilesList.Clone()
   markedSelectFile := selectedFiles
   maxFilesIndex := newFilesIndex
   newFilesList := []
   newMappingList := []
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
   GenerateRandyList()
}

throwMSGwriteError() {
  Static lastInvoked := 1
  If (ErrorLevel=1) && (A_TickCount - lastInvoked>45100)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the settings files: permission denied.", 0, 0, "error")
     lastInvoked := A_TickCount
  }
}

updateFilesListByID(indexu, indexProperty, value, isFilter) {
   if isFilter
      bckpResultedFilesList[indexu, indexProperty] := value
   else
      resultedFilesList[indexu, indexProperty] := value
}

updateMainUnfilteredList(indexu, indexProperty, value) {
   If (SLDtypeLoaded=3 && hasHamDistCached!=1)
   {
      If InStr(filesFilter, "SQL:query:")
         Return
   }

   If StrLen(filesFilter)>1
   {
      currentFilesListModified := 1
      oldIndex := filteredMap2mainList[indexu]
      If oldIndex
         bckpResultedFilesList[oldIndex, indexProperty] := value
      Return oldIndex
   }
}

singleInListEntriesRemover() {
   InListMultiEntriesRemover("single")
}

InListMultiEntriesRemover(dummy:=0, dontAsk:=0) {
   filesElected := getSelectedFiles(0, 1)
   If (markedSelectFile>1)
      itMultiFiles := 1

   If (itMultiFiles!=1 || dummy="single")
   {
      remCurrentEntry(0)
      Return
   }

   If (filesElected>500 && dontAsk!="y")
   {
      msgResult := msgBoxWrapper(appTitle, "Are you sure you want to remove " groupDigits(filesElected) " entries from the slideshow files list?", 4, 0, "question")
      If (msgResult!="yes")
         Return
   }

   startOperation := A_TickCount
   showTOOLtip("Removing " groupDigits(filesElected) " index entries, please wait")
   prevMSGdisplay := A_TickCount
   ForceRefreshNowThumbsList()
   countTFilez := 0
   doStartLongOpDance()
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   updateMainu := (StrLen(filesFilter)>1 && (!InStr(filesFilter, "SQL:query:") || hasHamDistCached=1)) ? 1 : 0
   Loop, % maxFilesIndex + 1
   {
      thisFileIndex := A_Index ; - countTFilez
      isSelected := resultedFilesList[thisFileIndex, 2]
      imgPath := resultedFilesList[thisFileIndex, 1]
      If (preventDeleteMatchingSearch=1 && imgPath && userSearchString)
      {
         If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
            isSelected := 0
      }

      If (preventDeleteFromProtectedPath=1 && protectedFolderPath)
      {
         If (preventDeleteFromProtectedSubPaths=1)
            OutDir := InStr(imgPath, protectedFolderPath "\") ? protectedFolderPath : 0
         Else
            zPlitPath(imgPath, 0, OutFileName, OutDir)

         If (protectedFolderPath=OutDir)
            isSelected := 0
      }

      If (isSelected!=1 && imgPath)
      {
         newFilesIndex++
         newFilesList[newFilesIndex] := resultedFilesList[thisFileIndex]
         If (updateMainu=1)
            newMappingList[newFilesIndex] := filteredMap2mainList[thisFileIndex]

         Continue
      } Else If !imgPath
         Continue

      If (SLDtypeLoaded=3 && preventDBentryRemoval!=1)
         deleteSQLdbEntry(StrReplace(imgPath, "||"), resultedFilesList[thisFileIndex, 12])

      countTFilez++
      If (updateMainu=1)
         updateMainUnfilteredList(thisFileIndex, 1, "")

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If !startPoint
         startPoint := thisFileIndex
   }

   resultedFilesList := []
   resultedFilesList := newFilesList.Clone()
   maxFilesIndex := newFilesIndex
   newFilesList := []
   filteredMap2mainList := []
   If (updateMainu=1)
      filteredMap2mainList := newMappingList.Clone()

   newMappingList := []
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   } Else currentFilesListModified := 1

   GenerateRandyList()
   getSelectedFiles(0, 1)
   zeitOperation := A_TickCount - startOperation
   etaTime := "Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countTFilez " index entries were removed until now`n" etaTime)
   Else
      showTOOLtip(countTFilez " index entries removed`n" etaTime)

   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         changeMcursor()
         ; showTOOLtip("Removing files list index filter, please wait")
         remFilesListFilter("simple")
         dummyTimerDelayiedImageDisplay(50)
      } Else handleEmptyFilesList(CurrentSLD, "", 1)
   } Else
   {
      startPoint--
      If (startPoint<2)
         startPoint := 1
      currentFileIndex := startPoint
      dummyTimerDelayiedImageDisplay(50)
   }

   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

remCurrentEntry(silentus:=0, whichIndex:=0) {
   Critical, on
   thisFileIndex := !whichIndex ? currentFileIndex : whichIndex
   If (!thisFileIndex || thisFileIndex<0)
      Return

   imgPath := resultedFilesList[thisFileIndex, 1]
   dbIndex := resultedFilesList[thisFileIndex, 12]
   file2remZ := resultedFilesList.RemoveAt(thisFileIndex)
   ; file2remA := file2remZ[1]
   If StrLen(filesFilter)>1
   {

      ; If (resultedFilesList[thisFileIndex, 5]=1)
      ; {
      ;    resultedFilesList[thisFileIndex, 5] := 0
      ;    updateMainUnfilteredList(thisFileIndex, 5, 0)
      ; }
      ; oldIndex :=  filteredMap2mainList[thisFileIndex]
      oldIndex := updateMainUnfilteredList(thisFileIndex, 1, 0)
      file2remC := filteredMap2mainList.RemoveAt(thisFileIndex)
      ; file2remB := bckpResultedFilesList[oldIndex, 1]
      ; Sleep, 200
      ; ToolTip, % thisFileIndex " | " file2remC " | " oldIndex " a " file2remB "`n" file2remA, , , 2
   }

   If (SLDtypeLoaded=3 && preventDBentryRemoval!=1)
      deleteSQLdbEntry(StrReplace(imgPath, "||"), dbIndex)

   maxFilesIndex--
   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (silentus!=1)
   {
      If (thumbsDisplaying!=1)
         Sleep, 50

      zPlitPath(StrReplace(imgPath, "||"), 1, OutFileName, OutDir)
      showDelayedTooltip("Index entry removed: " groupDigits(thisFileIndex) "`n" OutFileName "`n" OutDir "\", 0, 250)
   }

   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         ; showTOOLtip("Removing files list index filter, please wait")
         remFilesListFilter("simple")
         dummyTimerDelayiedImageDisplay(50)
         ; RandomPicture()
      } Else handleEmptyFilesList(CurrentSLD, "", 1)
   } Else 
   {
      currentFileIndex--
      NextPicture()
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

addSQLdbEntry(fileNamu, imgPath, fileSizu, fileMdate, fileCdate, simple:=0, factCheck:=1) {
   Static prevIDu := 0
   fileNamu := Format("{:L}", fileNamu)
   imgPath := Format("{:L}", imgPath)
   fileMdate := SubStr(fileMdate, 1, 12)
   fileCdate := SubStr(fileCdate, 1, 12)
   If (simple=1)
      SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder) VALUES (" sqlDBrowID ", 0, '" fileNamu "', '" imgPath "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
   Else
      SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder, fsize, fmodified, fcreated) VALUES (" sqlDBrowID ", 0, '" fileNamu "', '" imgPath "', '" fileSizu "', '" fileMdate "', '" fileCdate "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"

      ; ToolTip, % activeSQLdb.ErrorMsg " === " sqlDBrowID , , , 2
   If !activeSQLdb.Exec(SQLStr)
   {
      If InStr(activeSQLdb.ErrorMsg, "constraint failed")
         Return "err"

      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      If (simple=1)
         SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder) VALUES (" sqlDBrowID ", 0, " fileNamu ", " imgPath ") ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
      Else
         SQLstr := "INSERT INTO images (imgidu, isDeleted, imgfile, imgfolder, fsize, fmodified, fcreated) VALUES (" sqlDBrowID ", 0, " fileNamu ", " imgPath ", '" fileSizu "', '" fileMdate "', '" fileCdate "') ON CONFLICT(fullPath) DO UPDATE SET isDeleted=0;"
 
      If !activeSQLdb.Exec(SQLStr)
         Return "err"
   }

   If (factCheck=1)
   {
      activeSQLdb.LastInsertRowID(alolu)
      thisIDu := alolu CurrentSLD
      ; ToolTip, % prevIDu "==" thisIDu "==" sqlDBrowID , , , 2
      If (thisIDu!=prevIDu && alolu)
      {
         prevIDu := thisIDu
         sqlDBrowID++
      } Else Return "err"
   } Else sqlDBrowID++
}

updateSQLdbEntryImgRes(fullPath, imgResu, fileInfos, dbIndex, indexu:=0) {
   If (imgResu=1 || imgResu=2)
      thisPart := A_Space getImgPropsValuesSet(indexu, imgResu)
   Else
      thisPart := " imgdpi='" imgResu.dpi "', imgpixfmt='" imgResu.pixFmt "', imgframes='" imgResu.frames "', imgwidth='" imgResu.w "', imgheight='" imgResu.h "'"

   If (fileInfos=1 || fileInfos=2)
      thisPart .= ", " getImgFileValuesSet(indexu, fileInfos)
   Else If IsObject(fileInfos)
      thisPart .= ", fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      ; ToolTip, % A_ThisFunc "() failed to update l=" dbIndex , , , 2
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         addJournalEntry(A_ThisFunc "() - failed commit in database: " fullPath "`n" SQLStr)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)

   Return 1
}

updateSQLdbEntryFileInfos(fullPath, ByRef fileInfos, dbIndex) {
   thisPart := " fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"
   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      ; ToolTip, % A_ThisFunc "() failed to update l=" dbIndex , , , 2
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         addJournalEntry(A_ThisFunc "() - failed commit in database: " fullPath "`n" SQLstr)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)
   Return 1
}

getValueFilesList(indexu, value, modus) {
   If (modus=1)
      Return resultedFilesList[indexu, value]
   Else If (modus=2)
      Return bckpResultedFilesList[indexu, value]
}

getImgFileValuesSet(indexu, m) {
   Return "fsize='" getValueFilesList(indexu, 6, m) "', fmodified='" SubStr(getValueFilesList(indexu, 7, m), 1, 12) "', fcreated='" SubStr(getValueFilesList(indexu, 8, m), 1, 12) "'"
}

getImgPropsValuesSet(indexu, m) {
   Return "imgpixfmt='" getValueFilesList(indexu, 15, m) "', imgframes='" getValueFilesList(indexu, 9, m) "', imgdpi='" getValueFilesList(indexu, 22, m) "', imgwidth='" getValueFilesList(indexu, 13, m) "', imgheight='" getValueFilesList(indexu, 14, m) "'"
}

getImgHistoValuesSet(indexu, m) {
   Return "imgmedian='" getValueFilesList(indexu, 19, m) "', imgavg='" getValueFilesList(indexu, 18, m) "', imghpeak='" getValueFilesList(indexu, 20, m) "', imghlow='" getValueFilesList(indexu, 21, m) "', imghrms='" getValueFilesList(indexu, 24, m) "', imghrange='" getValueFilesList(indexu, 25, m) "',  imghmode='" getValueFilesList(indexu, 26, m) "', imghminu='" getValueFilesList(indexu, 27, m) "', pixelzFsmall='" getValueFilesList(indexu, 29, m) "', pixelzFbig='" getValueFilesList(indexu, 30, m) "', HpixelzFsmall='" getValueFilesList(indexu, 31, m) "', HpixelzFbig='" getValueFilesList(indexu, 32, m) "'"
}

updateSQLdbEntryImgHisto(fullPath, obju, imgResu, fileInfos, dbIndex, indexu:=0) {
   If (obju=1 || obju=2)
      thisPart := A_Space getImgHistoValuesSet(indexu, obju)
   Else
      thisPart := " imgmedian='" obju.median "', imgavg='" obju.avg "', imghpeak='" obju.peak "', imghlow='" obju.low "', imghrms='" obju.rms "', imghrange='" obju.range "',  imghmode='" obju.mode "', imghminu='" obju.minu "', pixelzFsmall='" obju.entireSmall  "', pixelzFbig='" obju.entireBig  "', HpixelzFsmall='" obju.HentireSmall "', HpixelzFbig='" obju.HentireBig "'"

   If (imgResu=1 || imgResu=2)
      thisPart .= ", " getImgPropsValuesSet(indexu, imgResu)
   Else If IsObject(imgResu)
      thisPart .= ", imgdpi='" imgResu.dpi "', imgpixfmt='" imgResu.pixFmt "', imgframes='" imgResu.frames "', imgwidth='" imgResu.W "', imgheight='" imgResu.H "'"

   If (fileInfos=1 || fileInfos=2)
      thisPart .= ", " getImgFileValuesSet(indexu, fileInfos)
   Else If IsObject(fileInfos)
      thisPart .= ", fsize='" fileInfos.size "', fmodified='" SubStr(fileInfos.wTime, 1, 12) "', fcreated='" SubStr(fileInfos.cTime, 1, 12) "'"

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
   SQLstr := "UPDATE images SET" thisPart wherePart
   If !activeSQLdb.Exec(SQLStr)
   {
      zPlitPath(fullPath, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET" thisPart " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
      {
         addJournalEntry(A_ThisFunc "() - failed commit in database: " fullPath "`n" SQLstr)
         Return 0
      }
   } ; Else fnOutputDebug(A_ThisFunc "() - database updated: " fullPath)

   Return 1
}

updateSQLdbEntryCaption(imgPath, txtData, whatSet) {
   imgPath := Format("{:L}", imgPath)
   activeSQLdb.EscapeStr(imgPath)
   activeSQLdb.EscapeStr(txtData)
   SQLstr := "INSERT INTO imagesData (imgfile) VALUES (" imgPath ");"
   activeSQLdb.Exec(SQLStr)
   SQLstr := "UPDATE imagesData SET " whatSet "=" txtData " WHERE imgfile=" imgPath " COLLATE NOCASE;"
   If !activeSQLdb.Exec(SQLStr)
      Return -1
}

retrieveSQLdbEntryCaption(imgPath, whatRetrieve) {
  If (SLDtypeLoaded!=3)
     Return

  RecordSet := ""
  activeSQLdb.EscapeStr(imgPath)
  SQL := "SELECT " whatRetrieve " FROM imagesData WHERE imgfile=" imgPath " COLLATE NOCASE;"
  If !activeSQLdb.GetTable(SQL, RecordSet)
     Return

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      entries .= Rowu[1] A_Space
  }

  RecordSet.Free()
  Return Trimmer(entries)
}

retrieveSQLdbEntryImgInfos(fullPath, imgIndex, dbIndex) {
   Critical, on
   If (SLDtypeLoaded!=3)
      Return 0

   If !dbIndex
      activeSQLdb.EscapeStr(fullPath)

   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
   SQL := "SELECT imgwidth, imgheight, imgframes, imgpixfmt, imgmedian, imgavg, imghpeak, imghlow, imgdpi FROM images" wherePart
   yay := RecordSet := ""

   If !activeSQLdb.GetTable(SQL, RecordSet)
   {
      addJournalEntry(A_ThisFunc "() - failed to query the database: " fullPath "`n" SQL)
      Return 0
   }
   ; ToolTip, % "l= " RecordSet.RowCount , , , 2
   If !RecordSet.RowCount
      Return 0

   Loop, % RecordSet.RowCount
   {
     Rowu := RecordSet.Rows[A_Index]
     If (Rowu[5] || Rowu[6] || Rowu[7])
     {
        countLoops++
        resultedFilesList[imgIndex, 19] := Rowu[5]
        resultedFilesList[imgIndex, 18] := Rowu[6]
        resultedFilesList[imgIndex, 20] := Rowu[7]
        resultedFilesList[imgIndex, 21] := Rowu[8]
     }

     ; ToolTip, % Row[1] " = " Row[5] , , , 2
     If (Rowu[1] && Rowu[2])
     {
        countLoops++
        resultedFilesList[imgIndex, 13] := Rowu[1]
        resultedFilesList[imgIndex, 14] := Rowu[2]
        resultedFilesList[imgIndex, 15] := Rowu[4]
        resultedFilesList[imgIndex, 9] := Rowu[3]
        resultedFilesList[imgIndex, 22] := Rowu[9]
     }
   }

  RecordSet.Free()
  If !countLoops
     fnOutputDebug(A_ThisFunc "() - no cache in database: " fullPath)

  Return yay
}

updateSQLdbEntry(oldEntry, newEntry, updateDates, dbIndex) {
   If (updateDates=1)
      obju := GetFileAttributesEx(newEntry)

   If !dbIndex
      activeSQLdb.EscapeStr(oldEntry)

   zPlitPath(newEntry, 1, newFileName, newFilePath)
   extra := (updateDates=1) ? ", fmodified=" SubStr(obju.wTime, 1, 12) ", fcreated=" SubStr(obju.cTime, 1, 12) ", fsize=" obju.size : ""
   wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" oldEntry " COLLATE NOCASE;"
   SQLstr := "UPDATE images SET isDeleted=0, imgfile='" SQLescapeStr(newFileName) "', imgfolder='" SQLescapeStr(newFilePath) "'" extra wherePart
   If !activeSQLdb.Exec(SQLstr)
   {
      zPlitPath(oldEntry, 1, fileNamu, imgPath)
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      activeSQLdb.EscapeStr(newFileName)
      activeSQLdb.EscapeStr(newFilePath)
      SQLstr := "UPDATE images SET isDeleted=0, imgfile=" newFileName ", imgfolder=" newFilePath extra " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      If !activeSQLdb.Exec(SQLStr)
         Return 0
   }
   Return 1
}

SQLdeleteEntriesMarked() {
    If (SLDtypeLoaded!=3)
       Return

    SQLstr := "DELETE FROM images WHERE isDeleted=1;"
    If !activeSQLdb.Exec(SQLStr)
       throwSQLqueryDBerror(A_ThisFunc)
    Else
       getMaxRowIDsqlDB()
}

deleteSQLdbEntry(fullPath, dbIndex) {
  If !dbIndex
     activeSQLdb.EscapeStr(fullPath)

  wherePart := dbIndex ? " WHERE imgidu=" dbIndex ";" : " WHERE fullPath=" fullPath " COLLATE NOCASE;"
  SQLstr := "DELETE FROM images" wherePart
  If !activeSQLdb.Exec(SQLStr)
  {
     zPlitPath(fullPath, 1, fileNamu, imgPath)
     activeSQLdb.EscapeStr(fileNamu)
     activeSQLdb.EscapeStr(imgPath)
     SQLstr := "DELETE FROM images WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
     activeSQLdb.Exec(SQLStr)
  }
}

openFileDialogWrapper(p_Type, optionz, startPath, msg, pattern, ByRef n_FilterIndex:="", chooseFilterIndex:=1, defaultEditField:="") {
   setWinCloseZeit()
   thisHwnd := (AnyWindowOpen) ? hSetWinGui : PVhwnd
   ; If (p_type="o")
   ;    pattern .= "|All files (*.*)"

   If FolderExist(startPath)
      pathSymbol := "\"

   If !chooseFilterIndex
      chooseFilterIndex := 1

   optionz .= " NoChangeDir HideReadOnly"
   If InStr(p_type, "o")
   {
      entriesList := defaultu "`n" recentOpenedFolders()
      If (p_type="o1")
      {
         thisCombo := "Open selected file only"
         thisCombo .= "`nOpen in a new QPV instance"
         thisCombo .= "`nIndex all images in current folder as well"
         thisCombo .= "`nPerform recursive folder(s) scan to index images"
         thisGroup := "Open mode"
      }

      FileMustExist := InStr(optionz, "FileMustExist") ? 1 : 0
      zr := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, thisCombo, 1, thisGroup, entriesList, 0, pattern, chooseFilterIndex, FileMustExist, defaultEditField)
      r := zr.SelectedDir
      n_FilterIndex := zr.SelectedCombo
   } Else
   {
      If InStr(p_type, "m")
         p_Type := "o"

      r := Dlg_OpenSaveFile(p_Type, thisHwnd, msg, pattern, chooseFilterIndex, startPath pathSymbol, "", optionz)
      n_FilterIndex := NumGet(optionz, (A_PtrSize=8) ? 44:24,"UInt")
      optionz := ""
   }

   r := Trimmer(r)
   If StrLen(r)<4
      r := ""

   SetWorkingDir, % mainCompiledPath
   SetTimer, setWinCloseZeit, -150, 900
   lastLongOperationAbort := A_TickCount
   Return r
}

WritePrefsIntoSLD() {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   startPath := !CurrentSLD ? prevOpenFolderPath : CurrentSLD
   file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save slideshow settings into file...", "Slideshow plain-text (*.sld)")
   If file2save
   {
      If !RegExMatch(file2save, sldsPattern)
         file2save .= ".sld"

      FileReadLine, firstLine, % file2save, 1
      If InStr(firstLine, "[General]")
      {
         Sleep, 10
         writeSlideSettings(file2save)
      } Else 
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgBoxWrapper(appTitle ": ERROR", "The selected file appears not to have the correct file format.`nPlease select a .SLD file already saved by this application.`n`n" OutFileName, 0, 0, "error")
      }
   }
}

recreateDynaFoldersSQLdbList(saveDynaFolders) {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM dynamicfolders;")
   Loop, Parse, saveDynaFolders, `n
   {
       If StrLen(A_LoopField)>2
          addDynamicFolderSQLdb(Trimmer(A_LoopField), 0, "dynamicfolders")
   }

   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

saveSlideSettingsInDB() {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM settings;")
   IniSLDBWrite("SLDcacheFilesList", 1)
   IniSLDBWrite("IMGresizingMode", IMGresizingMode)
   IniSLDBWrite("imgFxMode", imgFxMode)
   IniSLDBWrite("SlideHowMode", SlideHowMode)
   IniSLDBWrite("slideShowDelay", slideShowDelay)
   IniSLDBWrite("slidesFXrandomize", slidesFXrandomize)
   IniSLDBWrite("zoomLevel", zoomLevel)
   IniSLDBWrite("vpIMGrotation", vpIMGrotation)
   IniSLDBWrite("doSlidesTransitions", doSlidesTransitions)
   IniSLDBWrite("WindowBgrColor", WindowBgrColor)
   IniSLDBWrite("FlipImgH", FlipImgH)
   IniSLDBWrite("FlipImgV", FlipImgV)
   IniSLDBWrite("usrColorDepth", usrColorDepth)
   IniSLDBWrite("ColorDepthDithering", ColorDepthDithering)
   IniSLDBWrite("lumosAdjust", lumosAdjust)
   IniSLDBWrite("GammosAdjust", GammosAdjust)
   IniSLDBWrite("lumosGrayAdjust", lumosGrayAdjust)
   IniSLDBWrite("GammosGrayAdjust", GammosGrayAdjust)
   IniSLDBWrite("satAdjust", satAdjust)
   IniSLDBWrite("imageAligned", imageAligned)
   IniSLDBWrite("chnRdecalage", chnRdecalage)
   IniSLDBWrite("chnGdecalage", chnGdecalage)
   IniSLDBWrite("chnBdecalage", chnBdecalage)
   IniSLDBWrite("IntensityAlphaChannel", IntensityAlphaChannel)
   IniSLDBWrite("TouchScreenMode", TouchScreenMode)
   IniSLDBWrite("skipDeadFiles", skipDeadFiles)
   IniSLDBWrite("isAlwaysOnTop", isAlwaysOnTop)
   IniSLDBWrite("bwDithering", bwDithering)
   IniSLDBWrite("zatAdjust", zatAdjust)
   IniSLDBWrite("hueAdjust", hueAdjust)
   IniSLDBWrite("realGammos", realGammos)
   IniSLDBWrite("imgThreshold", imgThreshold)
   IniSLDBWrite("isTitleBarVisible", isTitleBarVisible)
   IniSLDBWrite("animGIFsSupport", animGIFsSupport)
   IniSLDBWrite("thumbsAratio", thumbsAratio)
   IniSLDBWrite("thumbsZoomLevel", thumbsZoomLevel)
   IniSLDBWrite("easySlideStoppage", easySlideStoppage)
   IniSLDBWrite("appVersion", appVersion)
   IniSLDBWrite("usrTextureBGR", usrTextureBGR)
   IniSLDBWrite("syncSlideShow2Audios", syncSlideShow2Audios)
   IniSLDBWrite("autoPlaySNDs", autoPlaySNDs)
   IniSLDBWrite("mediaSNDvolume", mediaSNDvolume)
   IniSLDBWrite("reverseOrderOnSort", reverseOrderOnSort)
   IniSLDBWrite("borderAroundImage", borderAroundImage)
   IniSLDBWrite("resetImageViewOnChange", resetImageViewOnChange)
   IniSLDBWrite("showImgAnnotations", showImgAnnotations)
   IniSLDBWrite("allowGIFsPlayEntirely", allowGIFsPlayEntirely)
   IniSLDBWrite("prevFilesSortMode", prevFilesSortMode)
   IniSLDBWrite("autoPlaySlidesAudio", autoPlaySlidesAudio)
   IniSLDBWrite("SlidesMusicSong", SlidesMusicSong)
   IniSLDBWrite("hamDistInterpolation", hamDistInterpolation)
   IniSLDBWrite("userpHashMode", userpHashMode)
   IniSLDBwrite("dbVersion", dbVersion)
   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

IniSLDBwrite(what, value, whichTable:="settings") {
    SQLstr := "INSERT INTO " whichTable " (paramz, valuez) VALUES ('" what "', '" value "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       activeSQLdb.EscapeStr(value)
       activeSQLdb.EscapeStr(what)
       SQLstr := "UPDATE " whichTable " SET valuez=" value " WHERE paramz=" what " COLLATE NOCASE;"
       z := activeSQLdb.Exec(SQLStr)
       fnOutputDebug(A_ThisFunc "(): " SQLStr " | " z)
    }
}

IniSLDBreadAll(givenFilter:="", whichTable:="settings") {
  startOperation := A_TickCount
  SQL := "SELECT paramz, valuez FROM " whichTable ";"
  RecordSet := ""

  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "(): failed to read settings from SQL database")
     Return -1
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If StrLen(Rowu[1])>2
      {
         paramu := Rowu[1]
         valu := Rowu[2]
         If (StrLen(valu)>0 && (MustLoadSLDprefs=1 || paramu=givenFilter))
            %paramu% := valu
      }
  }

  If (isWinXP=1 || minimizeMemUsage=1)
     doSlidesTransitions := 0

  RecordSet.Free()
}

SQLdbGenerateStaticFolders() {
   If AnyWindowOpen
      BtnCloseWindow()
 
   Sleep, 5
   activeSQLdb.Exec("DELETE FROM staticfolders;")
   SQL := "SELECT DISTINCT imgfolder FROM images;"
   RecordSet := ""
   If !activeSQLdb.GetTable(SQL, RecordSet)
   {
      SoundBeep, 300, 100
      addJournalEntry("Failed to execute SQL command in order to generate the static folders list from the indexed files.")
      Return
   }

   activeSQLdb.Exec("BEGIN TRANSACTION;")
   foldersListArray := new hashtable()
   Loop, % RecordSet.RowCount
   {
       Rowu := RecordSet.Rows[A_Index]
       thisFolder := Trimmer(Rowu[1])
       z := Format("{:L}", thisFolder)
       If (StrLen(thisFolder)>2 && foldersListArray[z]!=1)
       {
          foldersListArray[z] := 1
          addDynamicFolderSQLdb(thisFolder, 0, "staticfolders")
       }
   }
   foldersListArray := ""
   RecordSet.Free()
   If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      throwSQLqueryDBerror(A_ThisFunc)
}

getDynamicFoldersList(fileu:=0) {
   If !fileu
      fileu := RegExMatch(CurrentSLD, sldsPattern) ? CurrentSLD : ""

   listu := (fileu && FileExist(fileu) && (InStr(DynamicFoldersList, "|hexists|") || SLDtypeLoaded=3)) ? coreLoadDynaFolders(fileu) : DynamicFoldersList
   listu := StrReplace(listu, "|hexists|")
   Sort, listu, UD`n
   listu := cleanDynamicFoldersList(listu "`n")
   Return listu
}

rebuildDBfilesList() {
   If StrLen(filesFilter)>1
      MenuRemFilesListFilter()

   If !activeSQLdb.CloseDB()
   {
      showTOOLtip("Failed to close active database")
      SoundBeep 300, 100
      Return
   }

   SLDtypeLoaded := 2
   SaveDBfilesList(CurrentSLD)
}

SaveDBfilesList(enforceFile:=0) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (maxFilesIndex>1)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save files list - database", "The files list is filtered down to " groupDigits(maxFilesIndex) " files from " groupDigits(bckpMaxFilesIndex) ".`n`nTo save the entire list of indexed files, you have to deactivate the filter [Ctrl + Space].`n`nPlease choose how to proceed...", "&Deactivate filter|&Save list as is|&Cancel", 0, "info")
         If InStr(msgResult, "deactivate")
         {
            MenuRemFilesListFilter()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         } Else If InStr(msgResult, "save")
         {
            Sleep, 50
         } Else
         {
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }

      If !FileRexists(enforceFile)
      {
         fileWasGiven := 0
         zPlitPath(CurrentSLD, 0, OutFileName, OutDir, OutFileNameNoExt)
         file2save := openFileDialogWrapper("S", "PathMustExist", OutDir "\" OutFileNameNoExt, "Save files list as SQL slideshow database...", "Slideshow database (*.sldb)")
         If (!RegExMatch(file2save, "i)(.\.sldb)$") && file2save)
            file2save .= ".sldb"
      } Else
      {
         fileWasGiven := 1
         file2save := enforceFile
      }
   } Else Return

   If !file2save
      Return

   If AnyWindowOpen
      BtnCloseWindow()

   Sleep, 10
   If (file2save && SLDtypeLoaded=3 && dbVersion!=dbExpectedVersion && maxFilesIndex>1 && CurrentSLD)
   {
      msgResult := msgBoxWrapper(appTitle ": WARNING", "This database was saved by an older version of " appTitle ". The entire index structure needs to be rebuilt. QPV will now recreate this database with the new structure.`n`nPlease note: all the cached data pertaining to the indexed images will be lost.", "&Continue|C&ancel", 2, "exclamation")
      If !InStr(msgResult, "continue")
         Return

      SLDtypeLoaded := 2
   }

   startOperation := A_TickCount
   If (SLDtypeLoaded!=3 && file2save)
   {
      activeSQLdb.CloseDB()
      If FileExist(file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The destination file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult="Yes")
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            Try FileDelete, %file2save%
            Catch wasErrorB
                  Sleep, 1
         } Else
         {
            SetTimer, PanelSaveSlideShowu, -200
            Return
         }

         If wasErrorB
         {
            msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file: " OutFileName ". Permission denied.`n`nLocation:`n" OutDir "\", 0, 0, "error")
            SetTimer, PanelSaveSlideShowu, -200
            Return
         }
      }

      err := SLDbInitSQLdb(file2save)
      If err
      {
         msgBoxWrapper(appTitle ": ERROR", "Unable to create SQL database file. Fatal error. Please choose the plain-text format to save the files list (slideshow).`n`nError details: " err, 0, 0, "error")
         SetTimer, PanelSaveSlideShowu, -200
         Return
      }

      setImageLoading()
      dbVersion := dbExpectedVersion
      setWindowTitle("Saving SQL files list database, please wait", 1)
      showTOOLtip("Saving the list of folders into the SQL database`n" file2save "`nPlease wait")
      saveDynaFolders := getDynamicFoldersList()
      recreateDynaFoldersSQLdbList(saveDynaFolders)
      saveSlideSettingsInDB()
      IniSLDBwrite("dbVersion", dbExpectedVersion)

      currentFilesListModified := 0
      If (SLDtypeLoaded!=3)
      {
         populatedStaticFolders := 1
         LoadStaticFoldersCached(CurrentSLD, countStaticFolders, "f")
         SQLDBdumpStaticFoldersList()
      }

      doStartLongOpDance()
      showTOOLtip("Saving " groupDigits(maxFilesIndex) " entries in the SQL database`n" file2save "`nPlease wait", 0, 0, 3/100)
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      prevMSGdisplay := A_TickCount
      sqlDBrowID := 1
      failedFiles := 0
      Loop, % maxFilesIndex
      {
         imgPath := resultedFilesList[A_Index, 1]
         If InStr(imgPath, "\\")
         {
            imgPath := StrReplace(imgPath, "\\", "\")
            resultedFilesList[A_Index, 1] := imgPath
         }

         zPlitPath(imgPath, 1, OutFileName, OutDir)
         ; fileInfos := GetFileAttributesEx(imgPath)
         If (resultedFilesList[A_Index, 6] && resultedFilesList[A_Index, 7])
            z := addSQLdbEntry(OutFileName, OutDir, resultedFilesList[A_Index, 6], resultedFilesList[A_Index, 7], resultedFilesList[A_Index, 8], 0)
         Else
            z := addSQLdbEntry(OutFileName, OutDir, 0, 0, 0, 1, 0)

         If z
            failedFiles++

         resultedFilesList[A_Index, 12] := sqlDBrowID
         If (resultedFilesList[A_Index, 11] && resultedFilesList[A_Index, 13])
         {
            updateSQLdbEntryImgHisto(imgPath, 1, 1, 0, sqlDBrowID, A_Index)
         } Else
         {
            If resultedFilesList[A_Index, 11]
               updateSQLdbEntryImgHisto(imgPath, 1, 0, 0, sqlDBrowID, A_Index)
            If resultedFilesList[A_Index, 13]
               updateSQLdbEntryImgRes(imgPath, 1, 0, sqlDBrowID, A_Index)
         }

         If (A_TickCount - prevMSGdisplay>1500)
         {
            etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
            If failedFiles
               someErrors := "`nFailed to insert " groupDigits(failedFiles) " entries"

            showTOOLtip("Inserting entries into the SQL database`n" file2save someErrors etaTime, 0, 0, A_Index/maxFilesIndex)
            prevMSGdisplay := A_TickCount
         }

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
      }

      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)

      ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
      If (populatedStaticFolders!=1)
         SQLdbGenerateStaticFolders()

      If (abandonAll!=1)
      {
         getMaxRowIDsqlDB()
         CurrentSLD := file2save
         SLDtypeLoaded := 3
      } Else activeSQLdb.CloseDB()

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      dummyTimerDelayiedImageDisplay(50)
      RemoveTooltip()
   } Else If (CurrentSLD=file2save && SLDtypeLoaded=3)
   {
      showTOOLtip("Saving SQL files list database, please wait")
      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      getMaxRowIDsqlDB()
      showTOOLtip("Slideshow database saved")
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else If (CurrentSLD!=file2save && SLDtypeLoaded=3)
   {
      activeSQLdb.CloseDB()
      Sleep, 5
      FileCopy, % CurrentSLD, % file2save, 1
      Sleep, 5
      activeSQLdb := new SQLiteDB
      If !activeSQLdb.OpenDB(file2save)
      {
         showTOOLtip("ERROR: Failed to save the slideshow database")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return -1
      }

      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      CurrentSLD := file2save
      getMaxRowIDsqlDB()
      showTOOLtip("Slideshow database saved")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }

   etaTime := "Elapsed time to save the SQL database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

SaveFilesList(enforceFile:=0) {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (!CurrentSLD || maxFilesIndex<2)
   {
      showTOOLtip("WARNING: No files are presently indexed")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (maxFilesIndex>0)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save files list - plain text", "The files list is filtered down to " groupDigits(maxFilesIndex) " files from " groupDigits(bckpMaxFilesIndex) ".`n`nTo save the entire list of indexed files, you have to deactivate the filter [Ctrl + Space].`n`nPlease choose how to proceed...", "&Deactivate filter|&Save list as is|&Cancel", 0, "info")
         If InStr(msgResult, "deactivate")
         {
            MenuRemFilesListFilter()
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         } Else If InStr(msgResult, "save")
         {
            Sleep, 5
         } Else
         {
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }

      If !FileRexists(enforceFile)
      {
         fileWasGiven := 0
         zPlitPath(CurrentSLD, 0, OutFileName, OutDir, OutFileNameNoExt)
         file2save := openFileDialogWrapper("S", "PathMustExist", OutDir "\" OutFileNameNoExt, "Save files list as plain-text slideshow...", "Slideshow plain-text (*.sld)|All (*.*)", 1, 1)
         ; MsgBox, % A_ThisFunc "()`n" file2save
         If (!RegExMatch(file2save, "i)(.\.sld)$") && file2save)
            file2save .= ".sld"
      } Else
      {
         fileWasGiven := 1
         file2save := enforceFile
      }
   } Else
   {
      showTOOLtip("WARNING: Insufficient files added to the index")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir)
      If FileExist(file2save)
      {
         If !fileWasGiven
            msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")

         If (msgResult="Yes" || fileWasGiven=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            If (file2save=CurrentSLD)
            {
               newTmpFile := file2save "-bkcp"
               Try FileMove, %file2save%, %newTmpFile%, 1
               Catch wasErrorA
                     Sleep, 1
            } Else
            {
               Try FileDelete, %file2save%
               Catch wasErrorB
                     Sleep, 1
            }

            If (wasErrorA || wasErrorB)
            {
               msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file. Permission denied or another error occured.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
               Return
            }
         } Else Return
      }

      Sleep, 2
      BtnCloseWindow()
      writeSlideSettings(file2save)
      mainFile := FileOpen(file2save, "a", "UTF-16")
      If !IsObject(mainFile)
      {
         msgBoxWrapper(appTitle ": ERROR", "Unable to write file in the given location. Permission denied or another error occured.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
         Return
      }

      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setImageLoading()
      Sleep, 10
      setWindowTitle("Saving files list index, please wait", 1)
      If (SLDcacheFilesList=1)
         showTOOLtip("Saving list of " groupDigits(maxFilesIndex) " entries into`n" file2save "`nPlease wait")
      Else
         showTOOLtip("Saving folders index in`n" file2save "`nPlease wait")

      thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
      ; ToolTip, % thisTmpFile "=" , , , 2

      saveDynaFolders := getDynamicFoldersList(thisTmpFile)
      mainFile.Write("`n[DynamicFolderz]`n")
      Loop, Parse, saveDynaFolders, `n
      {
          fileTest := StrReplace(A_LoopField, "|")
          If !FolderExist(fileTest)
             Continue

          countDynas++
          mainFile.Write("DF" countDynas "=" A_LoopField "`n")
          changeMcursor()
      }

      changeMcursor()
      mainFile.Write("`n[Folders]`n")
      If (SLDcacheFilesList=1)
      {
         thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
         LoadStaticFoldersCached(thisTmpFile, countStaticFolders, "f")
         Loop, % countStaticFolders
               mainFile.Write("Fi" A_Index "=" newStaticFoldersListCache[A_Index, 2] "*&*" newStaticFoldersListCache[A_Index, 1] "`n")
      }

      mainFile.Write("`n[FilesList]`n")
      If (SLDcacheFilesList=1)
      {
         Loop, % maxFilesIndex
         {
            r := resultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            If InStr(r, "\\")
            {
               r := StrReplace(r, "\\", "\")
               resultedFilesList[A_Index, 1] := r
            }

            mainFile.Write(r "`n")
         }
      }

      mainFile.Close()
      SLDtypeLoaded := 2
      FileDelete, % newTmpFile
      currentFilesListModified := 0
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      CurrentSLD := file2save
      DynamicFoldersList := "|hexists|"
      mustGenerateStaticFolders := 0
      etaTime := "Elapsed time to save plain-text files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
      addJournalEntry(etaTime)
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % wasErrorC ? 300 : 900, 100
      If wasErrorC
         msgBoxWrapper(appTitle ": ERROR", "Errors occured when writing the files list to disk. Permission denied or not enough disk space.", 0, 0, "error")
      dummyTimerDelayiedImageDisplay(50)
   }
}

LoadStaticFoldersCached(fileNamu, ByRef countStaticFolders, allowAsk:=0) {
    countStaticFolders := newStaticFoldersListCache.MaxIndex()
    ths := newStaticFoldersListCache.Count()
    If (StrLen(newStaticFoldersListCache[1, 1])>4 && countStaticFolders>0 && ths>0)
       Return

    countStaticFolders := 0
    hash := new hashtable()
    If (SLDtypeLoaded=3 && (fileNamu=CurrentSLD || allowAsk="f"))
    {
       SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
       If !activeSQLdb.GetTable(SQL, RecordSet)
       {
          throwSQLqueryDBerror(A_ThisFunc)
          Return 0
       }

       newStaticFoldersListCache := []
       Loop, % RecordSet.RowCount
       {
           Rowu := RecordSet.Rows[A_Index]
           z := Format("{:L}", Rowu[1])
           If (StrLen(Rowu[1])>3 && hash[z]!=1)
           {
              hash[z] := 1
              countStaticFolders++
              newStaticFoldersListCache[countStaticFolders] := [Rowu[1], Rowu[2]]
           }
       }

       RecordSet.Free()
       hash := ""
       iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
       Return
    }

    FileRead, tehFileVar, %fileNamu%
    newStaticFoldersListCache := []
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(Fi[0-9].*\=.{14}\*\&\*[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
       {
          lineArru := StrSplit(line, "*&*")
          folderu := lineArru[2]
          oldDateu := lineArru[1]
          oldDateu := SubStr(oldDateu, InStr(oldDateu, "=")+1)
          z := Format("{:L}", folderu)
          If (StrLen(folderu)>3 && hash[z]!=1)
          {
             hash[z] := 1
             countStaticFolders++
             newStaticFoldersListCache[countStaticFolders] := [folderu, oldDateu]
             changeMcursor()
          }
       }
    }

    hash := ""
    If (!countStaticFolders && (allowAsk=1 || allowAsk="f"))
    {
       If (allowAsk!="f")
          msgResult := msgBoxWrapper(appTitle ": Confirmation", "This folders list was not yet generated. Would you like to generate it now?", 4, 0, "question")

       If (msgResult="yes" || allowAsk="f")
       {
          If (StrLen(filesFilter)>2 && msgResult="yes")
             MenuRemFilesListFilter()
          GenerateStaticFoldersListNow()
          countStaticFolders := newStaticFoldersListCache.MaxIndex()
       }
    }

    iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
    changeMcursor("normal")
}

regenerateStaticFoldersList() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
   {
      zr := SQLdbGenerateStaticFolders()
      If !zr
      {
         addJournalEntry("ERROR: Failed to regenerate the static folders list in the database")
         Return
      }

      lastFilterEditSearch := StaticListViewFilteru := ""
      newStaticFoldersListCache := []
      PanelStaticFolderzManager()
      Return
   }

   If StrLen(filesFilter)>2
      MenuRemFilesListFilter()

   lastFilterEditSearch := StaticListViewFilteru := ""
   GenerateStaticFoldersListNow()
   changeMcursor("normal")
   PanelStaticFolderzManager()
}

countFilesDiskPerStaticFolders() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(folderu, RowNumber, 1)
    folderu := newStaticFoldersListCache[folderu, 1]
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    counter := indexu := RowNumber := 0
    total := LV_GetCount()
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    indexList := []
    Loop, % total
    {
       RowNumber := LV_GetNext(RowNumber)
       If !RowNumber
          Break

       LV_GetText(indexu, RowNumber, 1)
       If !indexu
          Continue

       folderu := newStaticFoldersListCache[indexu, 1]
       If folderu
       {
          counter++
          indexList[counter] := [indexu, RowNumber]
       }
    }

    doStartLongOpDance()
    prevMSGdisplay := A_TickCount
    startOperation := A_TickCount
    total := indexList.Count()
    Loop, % total
    {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>2000)
       {
          prevMSGdisplay := A_TickCount
          showTOOLtip("Gathering folders data, please wait`n" groupDigits(total) " selected folders", 0, 0, A_Index/total)
       }

       indexu := indexList[A_Index, 1]
       folderu := newStaticFoldersListCache[indexu, 1]
       If FolderExist(folderu)
       {
          RowNumber := indexList[A_Index, 2]
          filez := folderz := fileSizu := 0
          z := getFolderInfos(folderu, filez, folderz, fileSizu)
          newStaticFoldersListCache[indexu, 5] := filez
          newStaticFoldersListCache[indexu, 6] := fileSizu
          LV_Modify(RowNumber, "Col8", filez)
          If newStaticFoldersListCache[indexu, 3]
             LV_Modify(RowNumber, "Col9", filez - newStaticFoldersListCache[indexu, 3])
          LV_Modify(RowNumber, "Col10", Round(Round(fileSizu/1024, 1)/1024, 1))
          If z
             Break
       }
    }

    CurrentSLD := backCurrentSLD
    ResetImgLoadStatus()
    RemoveTooltip()
}

BTNcountFilesDiskDynaFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_GetNext()
    LV_GetText(folderu, RowNumber, 3)
    LV_GetText(isR, RowNumber, 2)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If !thisIndex
       thisIndex := BTNcountFilesDynaFolders()

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    doStartLongOpDance()
    startOperation := A_TickCount
    If FolderExist(folderu)
    {
       friendly := isR ? "recursively " : ""
       showTOOLtip("Scanning folder " friendly "for image files`n" folderu "\")
       onDisk := folderz := fileSizu := 0
       z := getFolderInfos(folderu, onDisk, folderz, fileSizu, "DF" isR)
       diffu := (onDisk!="" && thisIndex!="") ? onDisk - thisIndex : 0
       LV_Modify(RowNumber, "Col7", onDisk)
       LV_Modify(RowNumber, "Col8", diffu)
       LV_Modify(RowNumber, "Col9", Round(Round(fileSizu/1024, 1)/1024, 1))
       RemoveTooltip()
    } Else
    {
       showTOOLtip("ERROR: The folder no longer exists or access denied`n" folderu "\")
    }

    CurrentSLD := backCurrentSLD
    ResetImgLoadStatus()
}

GenerateStaticFoldersListNow() {
   foldersListArray := new hashtable()
   prevMSGdisplay := A_TickCount
   mustGenerateStaticFolders := 0
   startOperation := A_TickCount
   getSelectedFiles(0, 1)
   foldersSelListArray := new hashtable()
   Loop, % maxFilesIndex + 1
   {
        imgPath := resultedFilesList[A_Index, 1]
        If (InStr(imgPath, "||") || !imgPath)
           Continue

        changeMcursor()
        OutDir := Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1))
        foldersListArray[OutDir] := Round(foldersListArray[OutDir]) + 1
        If markedSelectFile
        {
           If resultedFilesList[A_Index, 2]
              foldersSelListArray[OutDir] := Round(foldersSelListArray[OutDir]) + 1
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
           showTOOLtip("Generating folders list based on the indexed files" etaTime, 0, 0, A_Index/maxFilesIndex)
           prevMSGdisplay := A_TickCount
        }
   }

   counter := 0
   newStaticFoldersListCache := []
   totalLoops := foldersListArray.Count()
   For folderu, Value in foldersListArray
   {
       If !folderu
          Continue

       counter++
       FileGetTime, dirDate, % folderu, M
       If ErrorLevel
          dirDate := "-"
       selVal := foldersSelListArray[folderu]
       newStaticFoldersListCache[counter] := [folderu, dirDate, Value, selVal]
       ; changeMcursor()
       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalLoops, startOperation)
          showTOOLtip("Collecting folders data" etaTime, 0, 0, A_Index/totalLoops)
          prevMSGdisplay := A_TickCount
       }
   }

   RemoveTooltip()
   iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
   foldersListArray := ""
}

determineTerminateOperation() {
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 200)
     Return 0

  lastInvoked := A_TickCount
  Loop 
  {
      p := interfaceThread.ahkgetvar.userPendingAbortOperations
      If (p!=1)
         Break
      Else
         Sleep, 1
  }

  theEnd := interfaceThread.ahkgetvar.mustAbandonCurrentOperations
  If theEnd
     lastLongOperationAbort := A_TickCount
  Return theEnd
}

doStartLongOpDance() {
     startLongOperation := A_TickCount
     imageLoading := runningLongOperation := 1
     interfaceThread.ahkPostFunction("initAppBusyMode")
}

cleanDeadFilesList(dummy:=0) {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (maxFilesIndex>1)
   {
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      startOperation := A_TickCount
      friendlyLabel := (dummy="noFilesCheck") ? "Removing duplicate entries" : "Scanning for missing files"
      friendlyLabel2 := (dummy="noFilesCheck") ? "duplicate entries" : "dead files"
      setWindowTitle(friendlyLabel ", please wait", 1)
      showTOOLtip(friendlyLabel ", please wait")
      prevMSGdisplay := A_TickCount
      doStartLongOpDance()
      If (InStr(backCurrentSLD, "\QPV\viewed-images-history|") && !InStr(backCurrentSLD, "-viewed-images-history|current-session"))
         CleanDeadFilesSeenImagesDB("yesu", StrReplace(backCurrentSLD, "\QPV\", "\"))
      Else If (SLDtypeLoaded=3)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      countTFilez := deadFiles := newFilesIndex := 0
      newFilesList := []
      newMappingList := []
      hash := new hashtable(maxFilesIndex)
      updateMainu := (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:")) ? 1 : 0
      skipDuplicatesCheck := (SLDtypeLoaded=3) ? 1 : 0
      Loop, % maxFilesIndex
      {
            imgPath := resultedFilesList[A_Index, 1]
            If !imgPath
               Continue

            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               skipDuplicatesCheck := 1
               abandonAll := 1
               Break
            }

            If (A_TickCount - prevMSGdisplay>1500)
            {
               etaTime := ETAinfos(countTFilez + deadFiles, maxFilesIndex, startOperation)
               thisPath := PathCompact(SubStr(imgPath, 1, InStr(imgPath, "\", 0, 0) - 1), 45)
               showTOOLtip(friendlyLabel ", please wait`n" thisPath etaTime "`nFound " groupDigits(deadFiles) A_Space friendlyLabel2, 0, 0, (countTFilez+deadFiles)/maxFilesIndex)
               prevMSGdisplay := A_TickCount
            }

            If (skipDuplicatesCheck!=1)
            {
               z := Format("{:L}", imgPath)
               w := hash[z]
            }

            If ((w!=1 || skipDuplicatesCheck=1) && !InStr(imgPath, "||"))
            {
               If (skipDuplicatesCheck!=1 && w!=1)
                  hash[z] := 1

               If (dummy="noFilesCheck")
                  okayu := 1
               Else
                  okayu := (abandonAll=1) ? -2 : FileRexists(imgPath)

               If (okayu=-2 || okayu=1)
               {
                  countTFilez++
                  newFilesList[countTFilez] := resultedFilesList[A_Index]
                  If (updateMainu=1)
                     newMappingList[countTFilez] := filteredMap2mainList[A_Index]
                  Continue
               } Else deadFiles++
            } Else deadFiles++

            If (SLDtypeLoaded=3)
               deleteSQLdbEntry(StrReplace(imgPath, "||"), resultedFilesList[A_Index, 12])

            If (updateMainu=1)
               updateMainUnfilteredList(A_Index, 1, "")

            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
            {
               skipDuplicatesCheck := 1
               abandonAll := 1
               Break
            }
      }

      hash := ""
      If (abandonAll!=1)
      {
         If deadFiles
            currentFilesListModified := 1

         resultedFilesList := []
         resultedFilesList := newFilesList.Clone()
         maxFilesIndex := countTFilez
         newFilesList := []
         filteredMap2mainList := []
         If (updateMainu=1)
            filteredMap2mainList := newMappingList.Clone()

         newMappingList := []
         GenerateRandyList()
      }

      If (SLDtypeLoaded=3)
      {
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            throwSQLqueryDBerror(A_ThisFunc)
      }

      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(deadFiles) " index entries were removed until now" etaTime)
      Else
         showTOOLtip(groupDigits(deadFiles) " index entries removed" etaTime)

      If (maxFilesIndex<1 && StrLen(filesFilter)>1)
      {
         remFilesListFilter("simple")
      } Else If (maxFilesIndex<1 && StrLen(filesFilter)<2)
      {
         ForceRefreshNowThumbsList()
         CurrentSLD := backCurrentSLD
         handleEmptyFilesList(backCurrentSLD, "", 1)
         Return
      }

      ForceRefreshNowThumbsList()
      getSelectedFiles(0, 1)
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      CurrentSLD := backCurrentSLD
      currentFileIndex := clampInRange(currentFileIndex, 1, maxFilesIndex)
      dummyTimerDelayiedImageDisplay(50)
      ; RandomPicture()
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

handleEmptyFilesList(thisSLD, extraInfo:="", modus:=0){
   FadeMainWindow()
   SoundBeep, 300, 100
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
   foldersCount := ST_Count(DynamicFoldersList, "`n")
   If (modus=1)
      bonusBtn := "|Re&generate list"
   Else If (modus=2)
      bonusBtn := "|&Ignore"

   showButtons := (foldersCount>1 || (RegExMatch(thisSLD, sldsPattern) && FileExist(thisSLD)) || FolderExist(thisSLD) || InStr(thisSLD, "\QPV\favourite-images-list.SLD")) ? "&Begin from scratch|&Reload current list" bonusBtn : 0
   If showButtons
      info := "`n`nCurrent files list:`n" thisSLD

   msgResult := msgBoxWrapper(appTitle ": WARNING", "No files left in the index of " appTitle ", please load a files list or folder." info extraInfo, showButtons, 0, "info")
   If InStr(msgResult, "reload")
   {
      CurrentSLD := thisSLD
      currentFilesListModified := 0
      RefreshFilesList()
   } Else If InStr(msgResult, "ignore")
   {
      Sleep, 1
      Return "ignore"
   } Else If InStr(msgResult, "regenerate")
   {
      SetTimer, RegenerateEntireList, -150
   } Else If InStr(msgResult, "scratch")
   {
      currentFilesListModified := 0
      ; ToggleThumbsMode()
      ; FadeMainWindow()
      closeDocuments()
      ; resetMainWin2Welcome()
   }
}

removeFilesListFavouritedImages() {
   removeFilesListSeenImages("faves")
}

removeFilesListSeenImages(modus:=0) {
   ; Critical, on
   Static hasAskedFilter := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   countSeen := 0
   friendlyLabel := (modus="faves") ? "favourite" : "already seen"
   WnoFilesCheck := (noFilesCheck=2) ? 2 : 0
   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and " friendlyLabel " images will be removed from the files list")
         Return

      If (StrLen(filesFilter)>1 && hasAskedFilter=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Remove " friendlyLabel " images from index", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nOnly the files matched by current filter will be scanned.`n`nTo scan all the image files from the index, deactivcate the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel" || InStr(msgResult, "win_close"))
            Return
         Else hasAskedFilter := 1
      }

      remFromDb := 1
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setWindowTitle("Removing " friendlyLabel " images, please wait", 1)
      showTOOLtip("Removing " friendlyLabel " images`nGathering data, please wait")
      setImageLoading()
      If (modus="faves")
         seenEntries := retrieveFavesAsArray(totalSeenIMGs)
      Else
         seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)

      If (totalSeenIMGs<3)
      {
         seenEntries := ""
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         CurrentSLD := backCurrentSLD
         If (SLDtypeLoaded=3)
         {
            If !activeSQLdb.Exec("COMMIT TRANSACTION;")
               throwSQLqueryDBerror(A_ThisFunc)
         }
         dummyTimerDelayiedImageDisplay(50)
         etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
         showTOOLtip("Finished removing " friendlyLabel " images`nNo image was removed from the files list" etaTime)
         SetTimer, RemoveTooltip, % -msgDisplayTime//2
         Return
      }

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      showTOOLtip("Removing " friendlyLabel " images, please wait" etaTime)
      doStartLongOpDance()
      newArrayu := []
      newFilesIndex := 0
      If (SLDtypeLoaded=3)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      Loop, % maxFilesIndex + 1
      {
          r := getIDimage(A_Index)
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Checking for " friendlyLabel " images, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          If (seenEntries[Format("{:L}", r)]=1)
          {
             If (SLDtypeLoaded=3 && remFromDb=1)
                deleteSQLdbEntry(r, resultedFilesList[A_Index, 12])

             If StrLen(filesFilter)>1
                updateMainUnfilteredList(A_Index, 1, "")

             countSeen++
             Continue
          }

          newFilesIndex++
          newArrayu[newFilesIndex] := resultedFilesList[A_Index]
          If resultedFilesList[A_Index, 2]
             selectedFiles++

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (!activeSQLdb.Exec("COMMIT TRANSACTION;") && SLDtypeLoaded=3)
         throwSQLqueryDBerror(A_ThisFunc)

      If (abandonAll=1)
      {
         If (SLDtypeLoaded=3)
            showTOOLtip("Operation aborted. " groupDigits(countSeen) " already removed until now from the database.")
         Else
            showTOOLtip("Operation aborted. Files list left unchanged, no index entries removed.")

         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         newArrayu := ""
         ; dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         Return
      }

      If (newFilesIndex<1)
      {
         friendly := (modus="faves") ? "All images seem to have been added to favourites." : "It seems all the images were viewed."
         showTOOLtip("WARNING: " friendly "`nTherefore, the files list is left unchanged.")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         ; dummyTimerDelayiedImageDisplay(50)
         SetTimer, ResetImgLoadStatus, -150
         Return
      }

      ; renewCurrentFilesList()
      currentFilesListModified := 1
      maxFilesIndex := newFilesIndex
      resultedFilesList := newArrayu.Clone()
      markedSelectFile := selectedFiles
      ForceRefreshNowThumbsList()
      newArrayu := ""
      GenerateRandyList()
      getSelectedFiles(0, 1)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      RandomPicture()
      showDelayedTooltip("Finished removing " friendlyLabel " images`n" groupDigits(countSeen) " images were removed from the files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

SelectFilesFavourited() {
   findFavesInList("faves", "yes")
}

SelectFilesAlreadySeen() {
   findFavesInList("seen", "yes")
}

findFavesInList(modus:=0, doSel:=0) {
   ; Critical, on
   Static hasAskedFilter := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   countSeen := 0
   setImageLoading()
   friendlyLabel := (modus="faves") ? "favourite" : "already seen"
   friendly2 := (modus="faves") ? "added to favourites" : "seen"
   WnoFilesCheck := (noFilesCheck=2) ? 2 : 0
   If (maxFilesIndex>1)
   {
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setImageLoading()
      showTOOLtip("Marking files already " friendly2 "`nGathering data, please wait")
      If (modus="seen")
      {
         seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)
         idIndex := 3
      } Else
      {
         seenEntries := retrieveFavesAsArray(totalSeenIMGs)
         idIndex := 5
      }

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      doStartLongOpDance()
      Loop, % maxFilesIndex + 1
      {
          r := getIDimage(A_Index)
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Identifying files already " friendly2 "`nGathering data, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          If (seenEntries[Format("{:L}", r)]=1)
          {
             If StrLen(filesFilter)>1
                updateMainUnfilteredList(A_Index, idIndex, 1)

             resultedFilesList[A_Index, idIndex] := 1
             If (doSel="yes")
                resultedFilesList[A_Index, 2] := 1
             countSeen++
          } Else
          {
             If StrLen(filesFilter)>1
                updateMainUnfilteredList(A_Index, idIndex, 0)
             resultedFilesList[A_Index, idIndex] := 0
          }

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (abandonAll=1)
      {
         showTOOLtip("Operation aborted. " groupDigits(countSeen) " already marked until now")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         ForceRefreshNowThumbsList()
         ; dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         dummyTimerDelayiedImageDisplay(100)
         Return
      }

      ; renewCurrentFilesList()
      ForceRefreshNowThumbsList()
      ; GenerateRandyList()
      updateFilesSelectionInfos()
      dummyTimerDelayiedImageDisplay(100)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      dummyTimerDelayiedImageDisplay(100)
      If (modus="seen")
         showDelayedTooltip("Finished identifying already seen images`n" groupDigits(countSeen) " images were identified in this files list" etaTime)
      Else
         showDelayedTooltip("Finished identifying favourited images`n" groupDigits(countSeen) " images were identified in this files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

retrieveAlreadySeenImageFromCurrentList() {
   ; Critical, on

   If (slideShowRunning=1)
      ToggleSlideShowu()

   initSeenImagesListDB()
   If (sqlFailedInit=1)
   {
      showTOOLtip("ERROR: Failed to initialize the SQL database engine.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 0
   }

   If (userFilterDoString=1)
   {
      If (userFilterStringPos=4 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)" UsrEditFilter
      Else If (userFilterStringPos=3 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")$"
      Else If (userFilterStringPos=2 && StrLen(UsrEditFilter)>1)
         thisStringFilter := "i)^(" JEE_StrRegExLiteral(UsrEditFilter) ")"
      Else If (UsrEditFilter!="")
         thisStringFilter := "i)(" JEE_StrRegExLiteral(UsrEditFilter) ")"
   }

   If (maxFilesIndex>1)
   {
      friendly2 := (userFilterInvertThis=1) ? "never seen" : "already seen"
      If askAboutFileSave(" and the " friendly2 " images list, from the current list, will be retrieved")
         Return

      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      showTOOLtip("Retrieving " friendly2 " images matching this entire files list`nPlease wait")
      setImageLoading()
      seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)
      If (totalSeenIMGs<2)
      {
         userFilterDoString := 0
         userFilterProperty := 1
         filesFilter := ""
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         CurrentSLD := backCurrentSLD
         dummyTimerDelayiedImageDisplay(50)
         etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
         showTOOLtip("No records found matching the criteria" etaTime)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If (StrLen(filesFilter)>1) ; && filesFilter!="||Already-Seen-Images||") I do not know why i had this extra condition...
         remFilesListFilter("simple")

      zeitOperation := A_TickCount - startOperation
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      doStartLongOpDance()
      newFilesList := []
      newMappingList := []
      countSeen := selectedFiles := newFilesIndex := 0
      Loop, % maxFilesIndex + 1
      {
          r := resultedFilesList[A_Index, 1]
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, maxFilesIndex, startOperation)
             showTOOLtip("Checking for " friendly2 " images, please wait" etaTime "`nFound " groupDigits(countSeen) " of " groupDigits(totalSeenIMGs) " recorded images", 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          zuza := seenEntries[Format("{:L}", r)]
          If (userFilterInvertThis=1)
             zuza := !zuza

          If (zuza=1 && userFilterDoString=1 && thisStringFilter!="")
          {
             If !coreSearchIndex(getIDimage(A_Index), thisStringFilter, userFilterWhat, userFilterStringIsNot)
                zuza := 0
          }

          If (zuza=1)
          {
             newFilesIndex++
             newFilesList[newFilesIndex] := resultedFilesList[A_Index]
             If resultedFilesList[A_Index, 2]
                selectedFiles++
 
             newMappingList[newFilesIndex] := A_Index
             countSeen++
          }

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := ""
      If (abandonAll=1 || countSeen<2)
      {
         If (abandonAll=1)
            showTOOLtip("Operation aborted. Files list left unchanged, no filter applied.")
         Else
            showTOOLtip("No seen images identified. Files list left unchanged, no filter applied.")

         SoundBeep, 300, 100
         userFilterDoString := 0
         userFilterProperty := 1
         filesFilter := ""
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -150
         newFilesList := []
         newMappingList := []
         dummyTimerDelayiedImageDisplay(50)
         lastLongOperationAbort := A_TickCount
         Return
      }

      ; renewCurrentFilesList()
      filteredMap2mainList := newMappingList.Clone()
      bckpResultedFilesList := resultedFilesList.Clone()
      resultedFilesList := newFilesList.Clone()
      If !filesFilter
         bckpMaxFilesIndex := maxFilesIndex

      maxFilesIndex := newFilesIndex
      markedSelectFile := selectedFiles
      filesFilter := "||Already-Seen-Images||"
      userFilterProperty := 20
      ForceRefreshNowThumbsList()
      newFilesList := []
      newMappingList := []
      GenerateRandyList()
      getSelectedFiles(0, 1)

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
      CurrentSLD := backCurrentSLD
      RandomPicture()
      showDelayedTooltip("Finished the identification process of " friendly2 " images`n" groupDigits(countSeen) " images were found in the initial files list" etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

extractSQLqueryFromFilter() {
    If InStr(filesFilter, "SQL:query:WHERE")
    {
       extraFilter := StrReplace(filesFilter, "`n", A_Space)
       extraFilter := SubStr(extraFilter, InStr(extraFilter, ":WHERE ") + 1)
       If InStr(extraFilter, " ORDER BY ")
          extraFilter := SubStr(extraFilter, 1, InStr(extraFilter, " ORDER BY "))
       Return extraFilter
    }
}

PanelStateOFsqlNation(){
   If AnyWindowOpen
   {
      zz := AnyWindowOpen
      BtnCloseWindow()
   }

   backCurrentSLD := CurrentSLD
   CurrentSLD := ""

   setImageLoading()
   showTOOLtip("Gathering database information: total number", 0, 0, 0.1/13)
   totalz := getTotalIMGsSQLdb()
   showTOOLtip("Gathering database information: ignored files", 0, 0, 1/13)
   ignored := getTotalIMGsSQLdb("WHERE isDeleted=1 ")
   showTOOLtip("Gathering database information: file details", 0, 0, 2/13)
   fsize := totalz - getTotalIMGsSQLdb("WHERE ifnull(fsize, '')='' ")
   showTOOLtip("Gathering database information: image details", 0, 0, 3/13)
   imgmegapix := totalz - getTotalIMGsSQLdb("WHERE ifnull(imgmegapix, '')='' ")
   showTOOLtip("Gathering database information: image histograms", 0, 0, 4/13)
   imgmedian := totalz - getTotalIMGsSQLdb("WHERE ifnull(imgmedian, '')='' ")
   showTOOLtip("Gathering database information: pixel data", 0, 0, 5/13)
   pixelzFsmall := totalz - getTotalIMGsSQLdb("WHERE ifnull(pixelzFsmall, '')='' ")
   showTOOLtip("Gathering database information: pixel data (flipped)", 0, 0, 6/13)
   HpixelzFsmall := totalz - getTotalIMGsSQLdb("WHERE ifnull(HpixelzFsmall, '')='' ")
   showTOOLtip("Gathering database information: image hashes", 0, 0, 7/13)
   dHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(dHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes", 0, 0, 8/13)
   pHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(pHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes", 0, 0, 9/13)
   lHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(lHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes (flipped)", 0, 0, 10/13)
   hdHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(hdHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes (flipped)", 0, 0, 11/13)
   hpHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(hpHash, '')='' ")
   showTOOLtip("Gathering database information: image hashes (flipped)", 0, 0, 12/13)
   hlHash := totalz - getTotalIMGsSQLdb("WHERE ifnull(hlHash, '')='' ")

   showTOOLtip("Gathering database information: finishing", 0, 0, 13/13)
   ignored := "Ignored or known deleted files: " groupDigits(ignored) " ( " Round(ignored / totalz * 100, 2) "% )"
   fsize := "File details: " groupDigits(fsize) " ( " Round(fsize / totalz * 100, 2) "% )"
   imgmegapix := "Image details: " groupDigits(imgmegapix) " ( " Round(imgmegapix / totalz * 100, 2) "% )"
   imgmedian := "Image histogram details: " groupDigits(imgmedian) " ( " Round(imgmedian / totalz * 100, 2) "% )"
   pixelzFsmall := "Pixels data (8x8, 32x32): " groupDigits(pixelzFsmall) " ( " Round(pixelzFsmall / totalz * 100, 2) "% )"
   HpixelzFsmall := "Flipped pixels data (8x8, 32x32): " groupDigits(HpixelzFsmall) " ( " Round(HpixelzFsmall / totalz * 100, 2) "% )"
   dHash := " `nImage hashes:`ndHash (8x8): " groupDigits(dHash) " ( " Round(dHash / totalz * 100, 2) "% )"
   pHash := "pHash (32x32): " groupDigits(pHash) " ( " Round(pHash / totalz * 100, 2) "% )"
   lHash := "lHash (8x8): " groupDigits(lHash) " ( " Round(lHash / totalz * 100, 2) "% )"
   hdHash := " `ndHash (8x8, flipped): " groupDigits(hdHash) " ( " Round(hdHash / totalz * 100, 2) "% )"
   hpHash := "pHash (32x32, flipped): " groupDigits(hpHash) " ( " Round(hpHash / totalz * 100, 2) "% )"
   hlHash := "lHash (8x8, flipped): " groupDigits(hlHash) " ( " Round(hlHash / totalz * 100, 2) "% )"
   SetTimer, RemoveTooltip, -150
   SetTimer, ResetImgLoadStatus, -50
   CurrentSLD := backCurrentSLD
   infou := (dbVersion!=dbExpectedVersion) ? " (outdated)" : ""
   msgu := "Database version: " dbVersion infou "`nTotal indexed files: " groupDigits(totalz) "`n" ignored "`n" fsize "`n" imgmegapix "`n" imgmedian "`n" pixelzFsmall "`n" HpixelzFsmall "`n" dHash "`n" pHash "`n" lHash "`n" hdHash "`n" hpHash "`n" hlHash 
   widthu := (PrefsLargeFonts=1) ? 1150 : 660
   msgResult := msgBoxWrapper("Database overview: " appTitle, "This is an overview of how much data was collected pertaining to the indexed files.`n`n" msgu, "&Back|C&lose", 1, 0, 0, 0, "", "", 0, 0, widthu)
   If InStr(msgResult, "back")
   {
      If (zz=58)
         PanelWrapperFilesStats()
      Else If (zz=49)
         PanelFindDupes()
   }
}

collectSQLFileInfosNow(scu, modus, asku, doFilterExtra:=1, showInfos:=1, stringu:=0, mustNotHave:=0, strPosu:=0, whatu:=0) {
   Static noQuestion := 0
   If (asku=1 && noQuestion=1)
   {
      addJournalEntry(A_ThisFunc "(): user chose to never be asked to collect data in this session.")
      Return 0
   }

   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   If (doFilterExtra=1)
   {
      extraFilter := extractSQLqueryFromFilter()
   } Else If (doFilterExtra=2 && stringu)
   {
      stringu := processSQLsearchIndexString(stringu, strPosu, whatu)
      extraFilter := (mustNotHave=1) ? " WHERE " whatu " NOT LIKE '" stringu "'" : " WHERE " whatu " LIKE '" stringu "'"
   }

   friendly := extraFilter ? "`nCurrent files list filter:`n" extraFilter : ""
   ; If showInfos
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait" friendly)

   If RegExMatch(scu, "i)(imgmedian|imgavg|imghpeak|imghlow|imghmode|imghminu|imghrange|imghrms|lHash|dHash|pHash|pixelzFsmall|pixelzFbig)")
      adaptedSortCriteria := 3
   Else If RegExMatch(scu, "i)(imgmegapix|imgdpi|imgwidth|imgframes|imgpixfmt|imgheight|imgwhratio)")
      adaptedSortCriteria := 2
   Else If RegExMatch(scu, "i)(fcreated|fmodified|fsize|kbfsize)")
      adaptedSortCriteria := 1
   Else
      adaptedSortCriteria := 0

   ; MsgBox, % scu "=" extraFilter
   failedFiles := failedSQLfiles := 0
   If adaptedSortCriteria
   {
      addJournalEntry("Must collect files data in mode: " adaptedSortCriteria " | " scu)
      If !getMaxRowIDsqlDB()
      {
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      thisWhere := extraFilter ? extraFilter " AND ifnull(" scu ", '')='' AND isDeleted=0" : "WHERE ifnull(" scu ", '')='' AND isDeleted=0"
      SQLstr := "SELECT imgidu, fullPath FROM images " thisWhere " ORDER BY fullPath;"
      ; addJournalEntry(SQLstr)
      If !activeSQLdb.GetTable(SQLstr, RecordSet)
      {
         throwSQLqueryDBerror(A_ThisFunc)
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      failedFiles := countTFilez := 0
      filesToBeSorted := RecordSet.RowCount
      thisMaxCount := StrLen(filesFilter)>2 ? bckpMaxFilesIndex : maxFilesIndex
      alreadySorted := thisMaxCount - filesToBeSorted
      ; MsgBox, % strPosu "=" whatu "`n" SQLstr 
      zEffect := (adaptedSortCriteria=3 && filesToBeSorted>0) ? Gdip_CreateEffect(6, 0, -100, 0) : 0
      If (asku=1 && noQuestion=0 && filesToBeSorted>10 && filesToBeSorted!=thisMaxCount)
      {
         thisFriendly := (SLDtypeLoaded=3) ? "`n`nThe data will be automatically cached in the database and you can stop and resume this process at anytime." : ""
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected to perform an operation that relies on collected file and image details. " appTitle " needs to scan " groupDigits(filesToBeSorted) " out of " groupDigits(thisMaxCount) " files. By refusing to the collect data, the operation you chose (sort, filter, generate statistics or find duplicates) will likely give incomplete or erroneous results." thisFriendly, "Collect &data now|&Continue with incomplete data", 0, "question", "&Do not collect file data and never ask again in this session", 0)
         If (InStr(msgResult.btn, "incomplete") || InStr(msgResult.btn, "collect"))
            noQuestion := msgResult.Check

         If !InStr(msgResult.btn, "collect")
         {
            CurrentSLD := backCurrentSLD
            SetTimer, RemoveTooltip, % -msgDisplayTime
            SetTimer, ResetImgLoadStatus, -200
            Return 0
         }
      }

      If (filesToBeSorted>0)
         activeSQLdb.Exec("BEGIN TRANSACTION;")

      prevMSGdisplay := A_TickCount
      prevSaveData := A_TickCount
      Loop, % RecordSet.RowCount
      {
          Row := RecordSet.Rows[A_Index]
          If Row[2]
          {
             okay := rs := 1
             countTFilez++
             fInfos := GetFileAttributesEx(Row[2])
             If (!fInfos.size || fInfos.size<3)
             {
                failedFiles++
                okay := 0
             }

             If (adaptedSortCriteria=1 && okay=1)
             {
                ; file properties
                rs := updateSQLdbEntryFileInfos(Row[2], fInfos, Row[1])
             } Else If (adaptedSortCriteria=2 && okay=1)
             {
                ; image properties and file properties
                objul := GetCachableImgFileDetails(Row[2], Row[1], 0, 1)
                If IsObject(objul)
                   rs := updateSQLdbEntryImgRes(Row[2], objul, fInfos, Row[1])
                Else
                   failedFiles++
             } Else If (adaptedSortCriteria=3 && okay=1)
             {
                ; gather histogram main points and pixel data
                objul := GetCachableHistogramFile(Row[2], Row[1], 1, 0, zEffect)
                If IsObject(objul[1])
                   rs := updateSQLdbEntryImgHisto(Row[2], objul[1], objul[2], fInfos, Row[1])
                Else
                   failedFiles++
             } Else
                markSQLdbEntryDeleted(Row[1], 1)

             If !rs
                failedSQLfiles++
          }

          If (A_TickCount - prevSaveData>300100)
          {
             prevSaveData := A_TickCount
             If !activeSQLdb.Exec("COMMIT TRANSACTION;")
             {
                SoundBeep 300, 100
                ErrorMsgS := "ERROR: Failed to commit collected data to the SQL database`n" activeSQLdb.ErrorMsg "`n"
             } Else
                activeSQLdb.Exec("BEGIN TRANSACTION;")
          }

          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
             thisPath := PathCompact(SubStr(Row[2], 1, InStr(Row[2], "\", 0, 0) - 1), 45)
             If (failedFiles>0)
                etaTime .= "`nFailed to collect data for " groupDigits(failedFiles) " files"
             If (failedSQLfiles>0)
                etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

             showTOOLtip(ErrorMsgS "Gathering files information, please wait`n" thisPath etaTime, 0, 0, countTFilez / filesToBeSorted)
             prevMSGdisplay := A_TickCount
             If (A_TickCount - prevSaveData>9000)
                ErrorMsgS := ""
          }

          executingCanceableOperation := A_TickCount
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      Gdip_DisposeEffect(zEffect)
      RecordSet.Free()
      If (filesToBeSorted>0)
      {
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            ErrorMsg := "ERROR: failed to commit collected data to the SQL database`n" activeSQLdb.ErrorMsg "`n"
      }
   }

   PopulateIndexFilesStatsInfos("kill")
   CurrentSLD := backCurrentSLD
   someErrors := ""
   If (failedFiles>0)
      someErrors .= "`nFailed to collect data for " groupDigits(failedFiles) " files"
   If (failedSQLfiles>0)
      someErrors .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      If (modus=1)
         showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone "`nFiles list not sorted, because data collection did not complete.")
      Else
         showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   If (modus!=1 && filesToBeSorted>1)
   {
      showTOOLtip(ErrorMsg "Finished collecting data for " groupDigits(filesToBeSorted) " files`nFor " groupDigits(alreadySorted) " files the data was already collected" someErrors)
      SoundBeep 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
   } Else
      addJournalEntry(ErrorMsg "Finished collecting data for " groupDigits(filesToBeSorted) " files`nFor " groupDigits(alreadySorted) " files the data was already collected" someErrors)

   Return 0
}

calcPHashAlgo(givenArray, size:=32, compareMethod:=1) {
   ; givenArray is the pixels fingerprint
   ; calculte DCT for rows
   trow := [] ; current/this row
   rows := []
   x := y := 0
   Loop, % size ; y
   {
      trow := []
      y := A_Index - 1
      Loop, % size ; x
         trow[A_Index - 1] := givenArray[A_Index - 1 + size*y]

      rows[y] := calculateDCT(trow.Clone(), size)
   }

   ; calculte DCT for columns
   x := y := 0
   matrix := []
   col  := []
   Loop, % size
   {
      col := []
      x := A_Index - 1
      Loop, % size
      {
          y := A_Index - 1
          col[y] := rows[y, x]
      }
      matrix[x] := calculateDCT(col.Clone(), size)
   }

   ; extract the top 8x8 pixels from the DCT matrix
   x := y := thisIndex := 0
   fpexels := []
   Loop, 8
   {
      y := A_Index - 1
      Loop, 8
      {
          If (matrix[y, A_Index - 1]!="")
          {
             thisIndex++
             fpexels[thisIndex] := matrix[y, A_Index - 1]
          }
      }
   }

   ; Calculate hash
   bits := ""
   compareTerm := calcArrayAvgMedian(fpexels, compareMethod, thisIndex)
   ; fnOutputDebug("ahk DCT compareTerm=" compareTerm "|" thisIndex) ; "=fpexels" printArrayStr(fpexels)
   Loop, % thisIndex
       bits .= (fpexels[A_Index] > compareTerm) ? 1 : 0

   return bits
}

calcDLLpHashAlgo(arrayChars, ByRef givenArray, modus) {
    ; givenArray holds the 32x32 image pixels, grayscale
    static runs := 0
    ; stringu := ""
    Loop, % arrayChars.Count() ; 1024 ; 32*32
    ; {
    ;     stringu .= Ord(arrayChars[A_Index]) - 161 ","
        NumPut(arrayChars[A_Index], givenArray, A_Index - 1, "char")
    ; }

    r := DllCall(whichMainDLL "\calcPHashAlgo", "UPtr", &givenArray, "uint", 32, "Int", modus, "INT64")
    if (r!="")
    {
       hashu := ConvertBase(10, 16, r)
       ; hashu := ""
       ; Loop, 64
          ; hashu .= NumGet(resultsArray, A_Index - 1, "char")
       ; fnOutputDebug("phash=" hashu)
    }
    return hashu
}

calcArrayAvgMedian(o_givenArray, modus, size) {
    if (modus=1) ; median
    {
        thisCount := size / 2
        givenArray := numericSortArray(o_givenArray)
        if (thisCount=Round(thisCount))
        {
            value := givenArray[Round(thisCount) - 1] + givenArray[Round(thisCount / 2)]
            return (value / 2)
        }
        return givenArray[Round(thisCount)]
    } else
    {
        ; Calculate the average value from top 8x8 pixels, except for the first one.
        thisSum := 0
        Loop, % size
        {
           ; If (A_Index>1)
              thisSum += o_givenArray[A_Index]
        }

        return (thisSum / size)
    }
}

numericSortArray(givenArray, forMode:=0) {
   listu := printArrayStr(givenArray, "|", forMode)
   Sort, listu, ND|
   newArray := StrSplit(Trim(listu, "|"), "|")
   Return newArray
}

calculateDCT(matrix, size) {
     Static hasRan := 0, pi := 3.141592653
          , z := 0.70710678 ; 1 / sqrt(2)
          , coeffsArray := []

     transformed := []
     g := (size=32) ? 0.25 : sqrt(2 / size)
     thisIndex := 0

     If (hasRan!=size)
     {
        hasRan := size
        Loop, % size
        {
            i := A_Index - 1
            Loop, % size
            {
                j := A_Index - 1
                thisIndex++
                coeffsArray[thisIndex] := cos(i * pi * (j + 0.5) / size)
            }
        }
        thisIndex := 0
     }

     Loop, % size
     {
         i := A_Index - 1
         sum := 0
         Loop, % size
         {
             j := A_Index - 1
             thisIndex++
             ; sum += matrix[j] * cos(i * pi * (j + 0.5) / size)
             sum += matrix[j] * coeffsArray[thisIndex]
         }

         sum *= g
         if (i=0)
             sum *= z
         
         transformed[i] := sum
         ; fnOutputDebug("ahk matrix[" i "] DCT = " matrix[i])
     }
     ; msgbox, % A_ThisFunc "=" printArrayStr(transformed,,1)
     return transformed
}

calcLhashAlgo(pixArray) {
    ; ToolTip, % RecordSet.RowCount "|" countTFilez "=" whichHashu "==" arrayChars.Count()  , , , 2
    summo := 0
    ; pixArray := []
    linezArray := []
    colsArray := []
    cols := linez := thisIndex := 1
    Loop, % pixArray.Count()
    {
       If (thisIndex>8)
       {
          thisIndex := 1
          linezArray[linez] := summo/8
          ; fnOutputDebug(A_Index "summo[" linez "]=" Round(summo/16))
          summo := 0
          linez++
       }

       ; pixArray[A_Index] := discretizeValue(Ord(arrayChars[A_Index]) - 161, graylevelCompressor)
       col%thisIndex% += pixArray[A_Index]
       summo += pixArray[A_Index]
       thisIndex++
       If (A_Index=64)
       {
          Loop, 8
             colsArray[A_Index] := col%A_Index%/8
       }
    }

    hashu := ""
    allIndex := 0
    Loop, 8
    {
       thisIndex := 0
       mainIndexu := A_Index
       Loop, 8
       {
          allIndex++
          thisIndex := A_Index
          avg := Round((colsArray[mainIndexu] + linezArray[thisIndex])/2)
          hashu .= pixArray[allIndex] > avg ? 1 : 0
          ; hashu .= (avg>linezArray[mainIndexu, 17]) ? 1 : 0
          ; fnOutputDebug("avg[" mainIndexu ", " thisIndex "]=" avg)
       }
    }

    Return hashu
}

discretizeValue(valu, levelu) {
   Return (levelu!=1) ? Round(valu/levelu) * levelu : valu
}

processPixArrayCharsAsSTR(ByRef arrayChars) {
   newStr := ""
   newArray := StrSplit(arrayChars)
   If (graylevelCompressor!=1)
   {
      Loop, % newArray.Count()
          newStr .= discretizeValue(Ord(newArray[A_index]) - 161, graylevelCompressor) "|"
   } Else
   {
      Loop, % newArray.Count()
          newStr .= Ord(newArray[A_index]) - 161 "|"
   }
   Return newStr
}

processPixArrayChars(ByRef arrayChars) {
   newArray := StrSplit(arrayChars)
   If (graylevelCompressor!=1)
   {
      Loop, % newArray.Count()
          newArray[A_Index] := discretizeValue(Ord(newArray[A_Index]) - 161, graylevelCompressor)
   } Else
   {
      Loop, % newArray.Count()
          newArray[A_Index] := Ord(newArray[A_Index]) - 161
   }
   Return newArray
}

generateSQLimageFingerPrintHash(O_whichHashu, flippedModus, stringu, mustNotHave, strPosu, whatu) {
   Static userFriendly := {1:"NONE", 2:"dHash", 3:"pHash", 4:"lHash"}
   setImageLoading()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   startOperation := A_TickCount
   If (flippedModus=1)
      moreInfo := " (flipped)"

   showTOOLtip("Generating images " userFriendly[o_whichHashu] moreInfo " hashes for " groupDigits(maxFilesIndex) " files, please wait" friendly)
   failedFiles := failedSQLfiles := 0
   If !getMaxRowIDsqlDB()
   {
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   whichHashu := userFriendly[o_whichHashu]
   If (flippedModus=1)
   {
      sH := "h" ; the silent H ;-) - horizontally flipped
      whichHashu := "H" whichHashu
   }

   stringu := processSQLsearchIndexString(stringu, strPosu, whatu)
   If stringu ; allow query database  filtering?
      containsT := (mustNotHave=1) ? " AND " whatu " NOT LIKE '" stringu "'" : " AND " whatu " LIKE '" stringu "'"

   If (InStr(whichHashu, "dHash") || InStr(whichHashu, "lHash"))
   {
      b := 1
      SQLstr := "SELECT imgidu, " sH "pixelzFsmall, " whichHashu " FROM images WHERE isDeleted=0 AND ifnull(" sH "pixelzFsmall, '')!='' AND " whichHashu " IS NULL" containsT ";"
   } Else If InStr(whichHashu, "pHash")
   {
      b := 0
      SQLstr := "SELECT imgidu, " sH "pixelzFbig, " whichHashu " FROM images WHERE isDeleted=0 AND ifnull(" sH "pixelzFbig, '')!='' AND " whichHashu " IS NULL" containsT ";"
   }

   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return -1
   }

   If InStr(whichHashu, "pHash")
      VarSetCapacity(givenArray, 4 * 1024 + 1)

   failedFiles := countTFilez := 0
   filesToBeSorted := RecordSet.RowCount
   If (filesToBeSorted>0)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   ; ToolTip, % RecordSet.RowCount "==" whichHashu "==" SQLstr , , , 2
   ; MsgBox, % RecordSet.RowCount "===" findFlippedDupes "=" SQLstr
   prevMSGdisplay := A_TickCount
   prevSaveData := A_TickCount
   ErrorMsgS := ""
   Loop, % RecordSet.RowCount
   {
       Row := RecordSet.Rows[A_Index]
       If Row[1]
       {
          hashu := ""
          countTFilez++
          arrayChars := processPixArrayChars(Row[2])
          If (o_whichHashu=4) ; lHash
          {
             hashu := calcLhashAlgo(arrayChars)
             hash := ConvertBase(2, 16, hashu)
          } Else If (o_whichHashu=2)
          {
             ; ToolTip, % RecordSet.RowCount "|" countTFilez "=" whichHashu "==" arrayChars.Count()  , , , 2
             Loop, % arrayChars.Count() ; 8x9 = 72
             {
                thisIndex++
                If (thisIndex=9)
                {
                   thisIndex := 0
                   Continue
                }
                hashu .= (arrayChars[A_Index] < arrayChars[A_Index + 1]) ? 1 : 0
             }

             hash := ConvertBase(2, 16, hashu)
          } Else If (o_whichHashu=3)
          {
             hash := calcDLLpHashAlgo(arrayChars, givenArray, userpHashMode + 1)
             ; pixelsArray := []
             ; Loop, % arrayChars.Count() ; 1024 ; 32*32
             ;    pixelsArray[A_Index - 1] := Ord(arrayChars[A_Index]) - 161
             ; hashu := calcPHashAlgo(pixelsArray, 32, userpHashMode + 1)
          }

          if (hash!="")
          {
             SQLstr := "UPDATE images SET " whichHashu "='" hash "' WHERE imgidu=" Row[1] ";"
             If !activeSQLdb.Exec(SQLstr)
                failedSQLfiles++
          }
       }

       If (A_TickCount - prevSaveData>300100)
       {
          prevSaveData := A_TickCount
          If !activeSQLdb.Exec("COMMIT TRANSACTION;")
          {
             SoundBeep 300, 100
             ErrorMsgS := "ERROR: Failed to commit generated hashes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
          } Else
             activeSQLdb.Exec("BEGIN TRANSACTION;")
       }

       If (A_TickCount - prevMSGdisplay>2000)
       {
          etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
          If (failedSQLfiles>0)
             etaTime .= "`nFailed to commit data to database for " groupDigits(failedSQLfiles) " files"

          showTOOLtip(ErrorMsgS "Generating image " whichHashu moreInfo " fingerprints, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
          prevMSGdisplay := A_TickCount
          If (A_TickCount - prevSaveData>9000)
             ErrorMsgS := ""
       }

       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }
   }

   givenArray := resultsArray := ""
   RecordSet.Free()
   If (filesToBeSorted>0)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      {
         ErrorMsg := "ERROR: failed to commit generated hashes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
         addJournalEntry(A_ThisFunc "(): " ErrorMsg)
      }
   }

   someErrors := ""
   If (failedSQLfiles>0)
   {
      someErrors .= "`nFailed to commit to database " groupDigits(failedSQLfiles) " hashes"
      addJournalEntry(A_ThisFunc "(): " someErrors)
   }

   someErrors .= "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   CurrentSLD := backCurrentSLD
   If (abandonAll=1)
   {
      percDone := " ( " Round((countTFilez / filesToBeSorted) * 100, 1) "% )" someErrors
      showTOOLtip(ErrorMsg "Operation aborted. " groupDigits(countTFilez) " / " groupDigits(filesToBeSorted) percDone)
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return 1
   }

   ; showTOOLtip(ErrorMsg "Finished generating hashes for " groupDigits(filesToBeSorted) " files" someErrors)
   ; SoundBeep, 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -200
   Return 0
}

BtnCollectFileInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
   {
      collectSQLFileInfosNow("fsize", 0, 0)
      PopulateIndexSQLFilesStatsInfos("kill")
   } Else
   {
      collectFileInfosNow()
      PopulateIndexFilesStatsInfos("kill")
   }

   PanelWrapperFilesStats()
}

BtnCollectImageInfos() {
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow("imgmegapix", 0, 0)
   Else
      collectImageInfosNow(0, 9, 1)

   PopulateImagesIndexStatsInfos("kill")
   PanelWrapperFilesStats()
}

BtnCollectHistoInfos() {
   scu :=  (dummy="dupes" && findFlippedDupes=1) ? "HpixelzFsmall" : "pixelzFsmall"
   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      collectSQLFileInfosNow(scu, 0, 0)
   Else
      collectImageInfosNow(0, 11, 1)

   PopulateImagesIndexStatsInfos("kill")
   openPreviousPanel()
}

dbSortingCached(SortCriterion) {
   If (maxFilesIndex>0)
   {
      If (testIsDupesList() && InStr(resultedFilesList[currentFileIndex, 23], "_"))
      {
         showTOOLtip("WARNING: Files list sorting not allowed.`nThe files list is comprised of duplicate image pairs filtered by Hamming distance.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If AnyWindowOpen
         BtnCloseWindow()

      If askAboutFileSave(" and the files list will be sorted")
         Return

      abandonAll := collectSQLFileInfosNow(SortCriterion, 1, 1)
      If (!getMaxRowIDsqlDB() || abandonAll=1)
      {
         SetTimer, ResetImgLoadStatus, -200
         Return
      }

      sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
      prevFilesSortMode := SortCriterion
      IniSLDBWrite("prevFilesSortMode", SortCriterion)
      setWindowTitle("Sorting files list by " SortCriterion ", please wait", 1)
      If testIsDupesList()
      {
         retrieveDupesByProperties(0, SortCriterion)
         Return
      }

      setImageLoading()
      doStartLongOpDance()
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait")
      extraFilter := extractSQLqueryFromFilter()

      If !RegExMatch(prevFilesSortMode, "i)(fsize|fmodified|fcreated|imgfile|imgfolder)")
         moreCol := StrLen(prevFilesSortMode)>3 ? ", " prevFilesSortMode : ""

      SQLstr := "SELECT imgidu, fullPath" moreCol " FROM images " extraFilter " ORDER BY " SortCriterion sortMode ";"
      addJournalEntry("Database query used to sort the files list: " SQLstr)
      If !InitSQLgetTable(SQLstr, activeSQLdb._Handle, errMsg, Rows, Cols, hTable)
      {
         showTOOLtip("ERROR: Failed to retrieve the sorted images list from the SQL database:`n" errMsg)
         SoundBeep, 300, 100
         CurrentSLD := backCurrentSLD
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      If !Rows
      {
         CurrentSLD := backCurrentSLD
         showTOOLtip("No image records found in the database matching:`n" SQLstr)
         disposeSQLgetTableHandle(hTable)
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -200
         Return -1
      }

      newStaticFoldersListCache := []
      previmgPath := getIDimage(currentFileIndex)
      If StrLen(filesFilter)>1
         backFilesFilter := filesFilter

      showTOOLtip("Generating sorted files list index")
      If (markedSelectFile>1)
      {
         newArray := []
         Loop, % maxFilesIndex
         {
            If (resultedFilesList[A_Index, 2]=1)
            {
               z := resultedFilesList[A_Index, 12]
               newArray[z] := 1
            }
         }
      }

      markedSelectFile := 0
      renewCurrentFilesList()
      performSQLgetTable(Rows, Cols, hTable)
      disposeSQLgetTableHandle(hTable)
      If IsObject(newArray)
      {
         thisIndex := 0
         Loop, % maxFilesIndex
         {
            z := resultedFilesList[A_Index, 12]
            If (newArray[z]=1)
            {
               thisIndex++
               resultedFilesList[A_Index, 2] := 1
            }
         }
         markedSelectFile := thisIndex
      }

      ForceRefreshNowThumbsList()
      If extraFilter
         filesFilter := "SQL:query:" extraFilter

      CurrentSLD := backCurrentSLD
      If (StrLen(backfilesFilter)>1 && !extraFilter && !InStr(backFilesFilter, "SQL:query:JOIN"))
         coreEnableFiltru(backFilesFilter, 1)
      Else
         GenerateRandyList()

      zeitOperation := A_TickCount - startOperation
      addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 25
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      IDshowImage(currentFileIndex)
      ; MsgBox, % maxFilesIndex "=" CurrentSLD
  }
  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}

ActSortName() {
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder, imgfile")
   Else
      SortFilesList("name-entire")
}

ActSortSize() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fsize")
   Else
      SortFilesList("size")
   etaTime := "Elapsed time to sort files list by file size: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortPath() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder")
   Else
      SortFilesList("name-folder")
   etaTime := "Elapsed time to sort files list by folder name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortDupeGroups() {
   startOperation := A_TickCount
   If testIsDupesList()
      retrieveDupesByProperties(0, 1)

   etaTime := "Elapsed time to sort files list by duplicates image group IDs: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortFileName() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfile")
   Else
      SortFilesList("name-file")
   etaTime := "Elapsed time to sort files list by file name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortModified() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fmodified")
   Else
      SortFilesList("modified")
   etaTime := "Elapsed time to sort files list by file modified date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortCreated() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fcreated")
   Else
      SortFilesList("created")
   etaTime := "Elapsed time to sort files list by file created date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortHistogram(modus) {
   Static listuA := {1:"imgavg", 2:"imgmedian", 3:"imghpeak", 4:"imghlow", 5:"imghrange", 6:"imghmode", 7:"imghminu", 8:"imghrms"}
        , listuB := {1:"avg", 2:"median", 3:"peak", 4:"low", 5:"range", 6:"mode", 7:"minu", 8:"hrms"}

   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1 && listuA[modus])
      dbSortingCached(listuA[modus])
   Else If listuB[modus]
      SortFilesList("histogram-" listuB[modus])

   etaTime := "Elapsed time to sort files list by histogram mode " modus ": " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortImageProperties(modus) {
   Static listuA := {1:"imgmegapix", 2:"imgwidth", 3:"imgheight", 4:"imgwhratio", 5:"imgdpi", 6:"imgframes"}
        , listuB := {1:"resolution", 2:"width", 3:"height", 4:"wh-ratio", 5:"dpi", 6:"frames"}

   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1 && listuA[modus])
      dbSortingCached(listuA[modus])
   Else If listuB[modus]
      SortFilesList("image-" listuB[modus])

   etaTime := "Elapsed time to sort files list by image properties mode " modus ": " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

warnXPhistoSort() {
   If isWinXP
   {
      msgBoxWrapper(appTitle ": ERROR", "There is no support in GDI+ for extracting histogram data from images on your system... Therefore, you cannot sort the images by histogram.", 0, 0, "error")
      Return 1
   }
}

SortFilesList(SortCriterion) {
   ; Critical, on
   Static hasAskedFilter := 0

   If AnyWindowOpen
      BtnCloseWindow()

   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and the files list will be sorted")
         Return

      filesToBeSorted := maxFilesIndex
      If (StrLen(filesFilter)>1 && hasAskedFilter=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Sort operation", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nOnly the files matched by current filter will be sorted, not all the files.`n`nTo sort all files, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel" || InStr(msgResult, "win_close"))
            Return
         Else
            hasAskedFilter := 1
      }

      startOperation := A_TickCount
      setImageLoading()
      previmgPath := getIDimage(currentFileIndex)
      showTOOLtip("Gathering information for " groupDigits(maxFilesIndex) " files, please wait")
      setWindowTitle("Sorting files list, please wait", 1)
      backCurrentSLD := CurrentSLD
      CurrentSLD := filterBehaviour := ""
      newIndex :=  := 0
      If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:"))
      {
         filterBehaviour := 1
         showTOOLtip("Preparing the files list, please wait")
         Loop, %maxFilesIndex%   ; marking index entries to be sorted
             updateMainUnfilteredList(A_Index, 10, 1)

         backfilesFilter := filesFilter
         remFilesListFilter("simple")
         Sleep, 25
         RemoveTooltip()
      }

      newFilesList := []
      prevMSGdisplay := A_TickCount
      adaptedSortCriteria := StrReplace(SortCriterion, "image-")
      adaptedSortCriteria := StrReplace(adaptedSortCriteria, "histogram-")
      If (!InStr(SortCriterion, "image-") && !InStr(SortCriterion, "histogram-"))
         prevFolderSortMode := SortCriterion
      Else
         prevFolderSortMode := 0

      sortPages := sortedFiles := 0
      unSortPages := unSortedFiles := 0
      If ((OnSortdoFilesCheck=1 || InStr(SortCriterion, "image-") || InStr(SortCriterion, "histogram-")) && SLDtypeLoaded=3)
      {
         activeSQLdb.Exec("BEGIN TRANSACTION;")
         If InStr(SortCriterion, "histogram")
            zEffect := Gdip_CreateEffect(6, 0, -100, 0)
      }

      countTFilez := 0
      ; doFilesCheck := InStr(SortCriterion, "name-") ? 0 : OnSortdoFilesCheck
      doStartLongOpDance()
      Loop, % maxFilesIndex + 1
      {
          r := resultedFilesList[A_Index, 1]
          If (InStr(r, "||") || !r)
             Continue

          If (filterBehaviour=1 || filterBehaviour=2)
          {
             If !resultedFilesList[A_Index, 10]
             {
                ; building the sorted new files list array; this is the unsorted section
                newIndex++
                newFilesList[newIndex] := resultedFilesList[A_Index]
                Continue
             }
          }

          changeMcursor()
          countTFilez++
          If (A_TickCount - prevMSGdisplay>2000)
          {
             etaTime := ETAinfos(countTFilez, filesToBeSorted, startOperation)
             If (failedFiles>0)
                etaTime .= "`nFailed to sort " groupDigits(failedFiles) " files"

             showTOOLtip("Gathering files information, please wait" etaTime, 0, 0, countTFilez / filesToBeSorted)
             prevMSGdisplay := A_TickCount
          }

          If (OnSortdoFilesCheck=1)
          {
             If !FileRexists(r)
             {
                resultedFilesList[A_Index, 10] := 0
                If (SLDtypeLoaded=3)
                   deleteSQLdbEntry(r, resultedFilesList[A_Index, 12])

                failedFiles++
                Continue
             }
          }

          If (SortCriterion="size")
          {
             SortBy := QPV_FileGetSizeTime(r, "S", A_Index)
          } Else If (SortCriterion="modified")
          {
             SortBy := QPV_FileGetSizeTime(r, "M", A_Index)
          } Else If (SortCriterion="created")
          {
             SortBy := QPV_FileGetSizeTime(r, "C", A_Index)
          } Else If (SortCriterion="name-folder")
          {
             zPlitPath(r, 1, OutFileName, OutDir)
             SortBy := OutDir
          } Else If (SortCriterion="name-file")
          {
             zPlitPath(r, 1, OutFileName, OutDir)
             SortBy := OutFileName
          } Else If (SortCriterion="name-entire")
          {
             SortBy := r
          } Else If InStr(SortCriterion, "image-")
          {
             If !resultedFilesList[A_Index, 9]
                GetCachableImgFileDetails(r, A_Index)

             If resultedFilesList[A_Index, 13]
             {
                If (SLDtypeLoaded=3)
                   updateSQLdbEntryImgRes(r, 1, 1, resultedFilesList[A_Index, 12], A_Index)

                Switch adaptedSortCriteria
                {
                   Case "resolution":
                      SortBy := resultedFilesList[A_Index, 17]
                   Case "width":
                      SortBy := resultedFilesList[A_Index, 13]
                   Case "height":
                      SortBy := resultedFilesList[A_Index, 14]
                   Case "wh-ratio":
                      SortBy := resultedFilesList[A_Index, 16]
                   Case "dpi":
                      SortBy := resultedFilesList[A_Index, 22]
                   Case "frames":
                      SortBy := resultedFilesList[A_Index, 9]
                }
             } Else
             {
                failedFiles++
                SortBy := 0
             }
          } Else If InStr(SortCriterion, "histogram")
          {
             If !resultedFilesList[A_Index, 11]
                GetCachableHistogramFile(r, A_Index, 0, 0, zEffect)

             If (resultedFilesList[A_Index, 11])
             {
                If (SLDtypeLoaded=3)
                {
                   fInfos := GetFileAttributesEx(r)
                   updateSQLdbEntryImgHisto(r, 1, 1, fInfos, resultedFilesList[A_Index, 12], A_Index)
                }

                Switch adaptedSortCriteria
                {
                   Case "median":
                      SortBy := resultedFilesList[A_Index, 19]
                   Case "avg":
                      SortBy := resultedFilesList[A_Index, 18]
                   Case "peak":
                      SortBy := resultedFilesList[A_Index, 20]
                   Case "low":
                      SortBy := resultedFilesList[A_Index, 21]
                   Case "hrms":
                      SortBy := resultedFilesList[A_Index, 24]
                   Case "range":
                      SortBy := resultedFilesList[A_Index, 25]
                   Case "mode":
                      SortBy := resultedFilesList[A_Index, 26]
                   Case "minu":
                      SortBy := resultedFilesList[A_Index, 27]
                }
             } Else
             {
                failedFiles++
                SortBy := 0
             }
          }

          executingCanceableOperation := A_TickCount
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }

          sortedFiles++
          filesListu%sortPages% .= SortBy "|!\!|" A_Index "`n"
          If (sortedFiles>3102)
          {
             sortedFiles := 0
             sortPages++
          }
      }

      If ((OnSortdoFilesCheck=1 || InStr(SortCriterion, "image-") || InStr(SortCriterion, "histogram-")) && SLDtypeLoaded=3)
      {
         Gdip_DisposeEffect(zEffect)
         If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            addJournalEntry(A_ThisFunc "() failed to commit transactions to SQL database")
      }

      If (abandonAll=1)
      {
         If errorOccured
            msgInfos := "`nErrors occured. Multi-threading error."
         If (failedFiles && SLDtypeLoaded=3 && OnSortdoFilesCheck=1)
            msgInfos .= "`n" failedFiles " inexistent files were removed from the SQL database index"

         If StrLen(backfilesFilter)>1
         {
            ; rebuilding the filtered files list index, as it was
            thisIndex := 0
            newFilesList := []
            newMappingList := []
            filesFilter := backfilesFilter
            Loop, % maxFilesIndex + 1
            {
               r := resultedFilesList[A_Index, 1]
               If (InStr(r, "||") || !r)
                  Continue

               If resultedFilesList[A_Index, 10]
               {
                  thisIndex++
                  newFilesList[thisIndex] := resultedFilesList[A_Index]
                  newMappingList[thisIndex] := A_Index
                  If resultedFilesList[A_Index, 2]
                     selectedFiles++
               }
            }

            filteredMap2mainList := []
            filteredMap2mainList := newMappingList.Clone()
            newMappingList := []
            bckpResultedFilesList := resultedFilesList.Clone()
            resultedFilesList := newFilesList.Clone()
            newFilesList := []
            bckpMaxFilesIndex := maxFilesIndex
            maxFilesIndex := thisIndex
            markedSelectFile := selectedFiles
         }

         showTOOLtip("Operation aborted. Files list unchanged. " msgInfos)
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         lastLongOperationAbort := A_TickCount
         SetTimer, ResetImgLoadStatus, -50
         Return
      }

      showTOOLtip("Preparing gathered data`n" unSortPages " / " sortPages)
      prevMSGdisplay := A_TickCount
      changeMcursor()
      Loop, % sortPages + 1
      {
         thisIndex := A_Index - 1
         entireString .= filesListu%thisIndex%
      }

      showTOOLtip("Sorting gathered data")
      sortMode := (reverseOrderOnSort=1) ? "R" : ""
      If InStr(SortCriterion, "name-")
         Sort, entireString, %sortMode% D`n
      Else
         Sort, entireString, %sortMode% N D`n

      If (A_TickCount - prevMSGdisplay>1500)
         showTOOLtip("Generating sorted files list index")

      2ndnewIndex := 0
      2ndnewFilesList := []
      newMappingList := []
      histoObj := []
      prevMSGdisplay := A_TickCount
      Loop, Parse, entireString,`n,`r
      {
          If !A_LoopField
             Continue

          2ndnewIndex++
          line := StrSplit(A_LoopField, "|!\!|")
          2ndnewFilesList[2ndnewIndex] := resultedFilesList[line[2]]
          If filterBehaviour
          {
             2ndnewFilesList[2ndnewIndex, 10] := 0
             newMappingList[2ndnewIndex] := A_Index
          }

          If (A_TickCount - prevMSGdisplay>1500)
          {
             changeMcursor()
             etaTime := ETAinfos(A_Index, countTFilez, startOperation)
             showTOOLtip("Generating sorted files list index" etaTime, 0, 0, A_Index/countTFilez)
             prevMSGdisplay := A_TickCount
          }
      }

      ; and now build the final files list array with sorted and unsorted sections of the initial array
      finalNewList := []
      Loop, % 2ndnewIndex   ; the sorted section
         finalNewList[A_Index] := 2ndnewFilesList[A_Index]

      If filterBehaviour
      {
         Loop, % newIndex    ; the unsorted section
            finalNewList[A_Index + 2ndnewIndex] := newFilesList[A_Index]

         filteredMap2mainList := newMappingList.Clone()
         bckpResultedFilesList := finalNewList.Clone()
         bckpMaxFilesIndex := newIndex + 2ndnewIndex
      }

      maxFilesIndex := 2ndnewIndex
      resultedFilesList := 2ndnewFilesList.Clone()
      newFilesList := []
      2ndnewFilesList := []
      finalNewList := []
      ForceRefreshNowThumbsList()
      If StrLen(backfilesFilter)>1
         filesFilter := backfilesFilter

      GenerateRandyList()
      entireString := entireNotSortedString := ""
      currentFilesListModified := 1
      zeitOperation := A_TickCount - startOperation
      ; ToolTip, % zeitOperation , , , 2
      If (zeitOperation>5600)
         prevFolderSortMode := 0
      addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 5
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      If (maxFilesIndex<1 && StrLen(filesFilter)>1)
         remFilesListFilter("simple")
      Else If (maxFilesIndex<1)
         handleEmptyFilesList(CurrentSLD, "", 1)
      Else
         IDshowImage(currentFileIndex)
   }
}

getSelectedFilesListString(maxList, ByRef countTFilez, ByRef filesListu) {
  trenchSize := maxList//systemCores
  countTFilez := 0
  filesListu := []
  selectedFilesArray := []
  showTOOLtip("Preparing workload for multi-threaded processing")
  Loop, % maxFilesIndex
  {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      r := resultedFilesList[A_Index, 1]
      If (InStr(r, "||") || !r)
         Continue

      countTFilez++
      selectedFilesArray[countTFilez] := A_Index "?" r "`n"
  }

  selectedFilesArray := Random_ShuffleArray(selectedFilesArray)
  maxList := selectedFilesArray.Count()
  trenchSize := maxList//systemCores
  r := 0
  Loop, % systemCores - 1
  {
      thisIndex := A_Index
      Loop, % trenchSize
      {
          realIndex := trenchSize*(thisIndex - 1) + A_Index
          line := selectedFilesArray[realIndex]
          If !line
             Continue

          filesListu[thisIndex] .= line
      }
  }

  Loop, % maxList - trenchSize*(systemCores - 1)
  {
      realIndex := trenchSize*(systemCores - 1) + A_Index
      line := selectedFilesArray[realIndex]
      If !line
         Continue

      filesListu[systemCores] .= line
  }
}

WorkLoadMultiCoresJpegLL(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-jpegll||" jpegDesiredOperation "=0=" relativeImgSelCoords "=" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  setForceRefreshThumbsFilesIndex(1)
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }
            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to process " groupDigits(failedFiles) " files"
            If (skippedFiles>0)
               etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image files processing, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Performing JPEG lossless operations, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

   Loop, % systemCores
       FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt

   processedFiles := skippedFiles := failedFiles := 0
   Loop, % systemCores
   {
      RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
      filesStatusArr := StrSplit(filesStatus, "/")
      If (filesStatusArr[1]>0)
         processedFiles += filesStatusArr[1]
      If (filesStatusArr[2]>0)
         failedFiles += filesStatusArr[2]
      If (filesStatusArr[3]>0)
         skippedFiles += filesStatusArr[3]
   }

   zeitOperation := A_TickCount - startOperation
   someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
   If (failedFiles>0)
      someErrors .= "`nFailed to process " groupDigits(failedFiles) " files"
   If (skippedFiles>0)
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)
    
  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. JPEG lossless processing aborted. `n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countFilez) " selected files were processed until now." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  CurrentSLD := backCurrentSLD
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " groupDigits(markedSelectFile) " selected files were processed until now" someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected JPEG files were processed" someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  Return r
}

testProcessExists(pid) {
   If StrLen(pid)<2
      Return 0

   Process, Exist, % pid
   R := (ErrorLevel=pid) ? 1 : 0
   Return R
}

calculateCoresRequired(filesElected) {
   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<1 && realSystemCores>1)
      systemCores := filesElected//2
   Else If (filesPerCore<2 && realSystemCores>1)
      systemCores := filesElected//3
   Else If (filesPerCore<3 && realSystemCores>1)
      systemCores := filesElected//4
   Else
      systemCores := realSystemCores

   filesPerCore := filesElected//systemCores
   Return filesPerCore
}

WorkLoadMultiCoresConvertFormat(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-fmtconv"
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  setWhileLoopExec(1)
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := theseFailures := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  theseFailures += filesStatusArr[3]
               If (filesStatusArr[4]>0)
                  skippedFiles += filesStatusArr[4]
            }

            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to convert " groupDigits(failedFiles) " files"
            If (theseFailures>0)
               etaTime .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
            If (skippedFiles>0)
               etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image file formats conversion, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Converting to ." rDesireWriteFMT " format, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         lastLongOperationAbort := A_TickCount
         abandonAll := 1
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := theseFailures := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        theseFailures += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  If (SLDtypeLoaded=3)
     activeSQLdb.Exec("BEGIN TRANSACTION;")

  Loop, Parse, theFinalList,`n,`r
  {
       If StrLen(A_LoopField)>2
       {
          lineArr := StrSplit(A_LoopField, "?")
          thisIndex := lineArr[1]
          imgPath := lineArr[2]
          initial := resultedFilesList[thisIndex, 1]
          If (imgPath && isNumber(thisIndex) && thisIndex>0 && initial!=imgPath && OnConvertKeepOriginals=0)
          {
             currentFilesListModified := 1
             resultedFilesList[thisIndex, 1] := imgPath
             updateMainUnfilteredList(thisIndex, 1, imgPath)
             If (SLDtypeLoaded=3)
                updateSQLdbEntry(initial, imgPath, 1, resultedFilesList[thisIndex, 12])
          }
       }
  }

  If (SLDtypeLoaded=3)
  {
     If !activeSQLdb.Exec("COMMIT TRANSACTION;")
        throwSQLqueryDBerror(A_ThisFunc)
  }

  setWhileLoopExec(0)
  zeitOperation := A_TickCount - startOperation
  percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFailed to convert " groupDigits(failedFiles) " files"
  If (theseFailures>0)
     someErrors .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
  If (skippedFiles>0)
     someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

  If (fatalError=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     ; RemoveTooltip()
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image file formats conversion aborted.`n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countFilez) " selected files were processed until now." someErrors, 0, 0, "error")
     r := "error"
  }

  CurrentSLD := backCurrentSLD
  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " markedSelectFile " selected files were converted to ." rDesireWriteFMT " until now" someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were converted to ." rDesireWriteFMT someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  Return r
}

WorkLoadMultiCoresSimpleImgProcessing(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-simpleimgproc||" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2 "=" editingSelectionNow "=" simpleOpRotationAngle
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
         ; sleep, 450
         ; ToolTip, % jobsRunning "//" jobDone "//" threadsCrashed "//" totalEnded , , , 2
         ; ToolTip, % thisThreadStatus " // " isPIDalive , , , 2
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }

            etaTime := ETAinfos(processedFiles, countTFilez, startOperation)
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed"
            If (failedFiles>0)
               etaTime .= "`nFailed to process " groupdigits(failedFiles) " files"
            If (skippedFiles>0)
               etaTime .= "`nSkipped files: " groupdigits(skippedFiles)

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed"
               showTOOLtip("Abandoning image files processing, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Processing image files, please wait" etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := skippedFiles := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        skippedFiles += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
  zeitOperation := A_TickCount - startOperation
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFailed to process " groupDigits(failedFiles) " files"
  If (skippedFiles>0)
     someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image processing aborted. `n`nPlease try again with multi-threading disabled.`n`n" groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were processed until now..." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " groupDigits(processedFiles) " out of " groupDigits(markedSelectFile) " selected files were processed until now." someErrors)
  Else If (fatalError!=1)
     showTOOLtip(groupDigits(processedFiles) " out of " groupDigits(countTFilez) " selected files were processed" someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
     r := "abandoned"
  }

  CurrentSLD := backCurrentSLD
  Return r
}

multiCoresJpegLL(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  jpegOperation := argumentsArray[1]
  mustCrop := argumentsArray[2]
  relativeImgSelCoords := argumentsArray[3]
  imgSelX1 := argumentsArray[4]
  imgSelX2 := argumentsArray[5]
  imgSelY1 := argumentsArray[6]
  imgSelY2 := argumentsArray[7]
  prcSelX1 := argumentsArray[8]
  prcSelX2 := argumentsArray[9]
  prcSelY1 := argumentsArray[10]
  prcSelY2 := argumentsArray[11]
  failedFiles := skippedFiles := countFilez := operationDone := 0
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       If !RegExMatch(imgPath, "i)(.\.(jpeg|jpg|jpe))$")
       {
          skippedFiles++
          Continue
       }

       r := coreJpegLossLessAction(imgPath, jpegOperation)
       If !r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

multiCoresSimpleImgProcessing(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  ReadSettingsImageProcessing()
  imgSelX1 := argumentsArray[1]
  imgSelX2 := argumentsArray[2]
  imgSelY1 := argumentsArray[3]
  imgSelY2 := argumentsArray[4]
  prcSelX1 := argumentsArray[5]
  prcSelX2 := argumentsArray[6]
  prcSelY1 := argumentsArray[7]
  prcSelY2 := argumentsArray[8]
  editingSelectionNow := argumentsArray[9]
  simpleOpRotationAngle := argumentsArray[10]
  skippedFiles := failedFiles := countFilez := operationDone := 0
  thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       imgPath := StrReplace(imgPath, "||")
       If !RegExMatch(imgPath, thisRegEX)
       {
          skippedFiles++
          Continue
       }

       zPlitPath(imgPath, 0, OutFileName, OutDir)
       destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
       file2save := destImgPath "\" OutFileName
       If (ResizeUseDestDir=1)
       {
          If (FileExist(file2save) && !FolderExist(file2save))
             file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)
       }

       If !file2save
       {
          skippedFiles++
          Continue
       } Else If (file2save="abort")
       {
          abandonAll := 1
          Break
       }

       r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor, SimpleOperationsScaleYimgFactor)
       If r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

ReadSettingsFormatConvert() {
    coreReadSettingsImageProcessing(0)
}

WriteSettingsFormatConvert() {
    coreReadSettingsImageProcessing(1)
}

ReadSettingsImageProcessing() {
    coreReadSettingsImageProcessing(0)
}

WriteSettingsImageProcessing() {
    coreReadSettingsImageProcessing(1)
}

coreReadSettingsImageProcessing(act) {
    IniAction(act, "allowToneMappingImg", "General", 1)
    IniAction(act, "cmrRAWtoneMapAlgo", "General", 2, 1, 2)
    IniAction(act, "cmrRAWtoneMapParamA", "General", 2, -8, 10)
    IniAction(act, "cmrRAWtoneMapParamB", "General", 2, -8, 10)
    RegAction(act, "OnConvertKeepOriginals",, 1)
    RegAction(act, "PreserveDateTimeOnSave",, 1)
    RegAction(act, "convertFormatUseMultiThreads",, 1)
    RegAction(act, "ResizeApplyEffects",, 1)
    RegAction(act, "ResizeCropAfterRotation",, 1)
    RegAction(act, "ResizeDestFolder",, 6)
    RegAction(act, "ResizeInPercentage",, 1)
    RegAction(act, "ResizeKeepAratio",, 1)
    RegAction(act, "ResizeMustPerform",, 1)
    RegAction(act, "ResizeQualityHigh",, 1)
    RegAction(act, "ResizeRotationUser",, 2, -180, 180)
    RegAction(act, "ResizeUseDestDir",, 1)
    RegAction(act, "ResizeWithCrop",, 1)
    RegAction(act, "convertFormatAutoSkip",, 1)
    RegAction(act, "SimpleOperationsDoCrop",, 1)
    RegAction(act, "SimpleOperationsFlipH",, 1)
    RegAction(act, "SimpleOperationsFlipV",, 1)
    RegAction(act, "SimpleOperationsRotateAngle",, 2, 1, 4)
    RegAction(act, "SimpleOperationsScaleXimgFactor",, 2, 1, 32750)
    RegAction(act, "SimpleOperationsScaleYimgFactor",, 2, 1, 32750)
    RegAction(act, "userActionConflictingFile",, 2, 1, 3)
    RegAction(act, "userDesireWriteFMT",, 2, 1, 16)
    RegAction(act, "userJpegQuality",, 2, 1, 100)
    IniAction(act, "userHQraw", "General", 1)
    If (act=0)
    {
       cleanResizeUserOptionsVars()
       rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
    }
}

multiCoresFormatConvert(coreThread, filesList) {
  resultsList := ""
  failedFiles := theseFailures := countFilez := operationDone := 0
  ; FileRead, filesList, %thumbsCacheFolder%\tempList%coreThread%.txt
  ReadSettingsFormatConvert()
  initFIMGmodule()
  ; fnOutputDebug(A_ThisHotkey "|" coreThread "|" convertFormatAutoSkip)
  Loop, Parse, filesList,`n,`r
  {
      hasAsked := 0
      If A_LoopField
      {
         lineArr := StrSplit(A_LoopField, "?")
         imgPath := lineArr[2]
         If !imgPath
            Continue
      } Else Continue

      RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
      If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
      {
         abandonAll := 1
         Break
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
      If (InStr(imgPath, "||") || !imgPath)
      {
         skippedFiles++
         Continue
      }

      isSameFormat := RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") ? 1 : 0
      If (isSameFormat=1 && convertFormatAutoSkip=1)
      {
         If (ResizeUseDestDir=1)
         {
            If (FileExist(file2save) && !FolderExist(file2save))
               file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

            If file2save
            {
               If (file2save="abort")
               {
                  abandonAll := 1
                  Break
               }

               FileGetTime, originalMtime, % imgPath, M
               FileGetTime, originalCtime, % imgPath, C
               If (OnConvertKeepOriginals=1)
                  FileCopy, % imgPath, % file2save, 1
               Else
                  FileMove, % imgPath, % file2save, 1

               If !ErrorLevel
               {
                  countFilez++
                  resultsList .= lineArr[1] "?" file2save "`n"
                  RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
                  If originalMtime
                  {
                     FileSetTime, % originalMtime, % file2save, M
                     FileSetTime, % originalCtime, % file2save, C
                  }
               } Else failedFiles++
            } Else skippedFiles++
            Continue
         } Else
         {
            skippedFiles++
            Continue
         }
      }

      of := file2save
      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If !file2save
      {
         If (ResizeUseDestDir!=1 && convertFormatAutoSkip=0 && isSameFormat=1)
         {
            file2save := of
         } Else
         {
            skippedFiles++
            Continue
         }
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }

      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         countFilez++

      wasSucces := r ? 0 : 1
      If (OnConvertKeepOriginals!=1 && !r)
      {
         If (imgPath!=file2save)
         {
            FileSetAttrib, -R, %imgPath%
            Sleep, 2
            FileRecycle, %imgPath%
            If ErrorLevel
               theseFailures++
         }

         If (wasSucces=1)
            resultsList .= lineArr[1] "?" file2save "`n"
      }

      RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   }

   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   If resultsList
      Try FileAppend, % resultsList, %thumbsCacheFolder%\tempList%coreThread%.txt, UTF-16
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

readSlideSettings(readThisFile, act) {
     IniAction(act, "allowGIFsPlayEntirely", "General", 1,0,0,, readThisFile)
     IniAction(act, "ambiTexBrushSize", "General", 2, 25, 950,, readThisFile)
     IniAction(act, "animGIFsSupport", "General", 1,0,0,, readThisFile)
     IniAction(act, "UserGIFsDelayu", "General", 2,-9500,9500,, readThisFile)
     IniAction(act, "autoPlaySlidesAudio", "General", 1,0,0,, readThisFile)
     IniAction(act, "autoPlaySNDs", "General", 1,0,0,, readThisFile)
     IniAction(act, "borderAroundImage", "General", 1,0,0,, readThisFile)
     IniAction(act, "bwDithering", "General", 1,0,0,, readThisFile)
     IniAction(act, "chnBdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "chnGdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "chnRdecalage", "General", 2,-30,30,, readThisFile)
     IniAction(act, "ColorDepthDithering", "General", 1,0,0,, readThisFile)
     IniAction(act, "doSlidesTransitions", "General", 1,0,0,, readThisFile)
     IniAction(act, "easySlideStoppage", "General", 1,0,0,, readThisFile)
     IniAction(act, "FlipImgH", "General", 1,0,0,, readThisFile)
     IniAction(act, "FlipImgV", "General", 1,0,0,, readThisFile)
     IniAction(act, "GammosAdjust", "General", 2,-25,1,, readThisFile)
     IniAction(act, "GammosGrayAdjust", "General", 2,-25,1,, readThisFile)
     IniAction(act, "hueAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "imageAligned", "General", 2,1,5,, readThisFile)
     IniAction(act, "imgFxMode", "General", 2,1,10,, readThisFile)
     IniAction(act, "IMGresizingMode", "General", 2,1,5,, readThisFile)
     IniAction(act, "imgThreshold", "General", 2,0,1,, readThisFile)
     IniAction(act, "IntensityAlphaChannel", "General", 2,1,30,, readThisFile)
     IniAction(act, "isAlwaysOnTop", "General", 1,0,0,, readThisFile)
     IniAction(act, "isTitleBarVisible", "General", 1,0,0,, readThisFile)
     IniAction(act, "lummyAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "lumosAdjust", "General", 2,0.001,25,, readThisFile)
     IniAction(act, "lumosGrayAdjust", "General", 2,0.001,25,, readThisFile)
     IniAction(act, "mediaSNDvolume", "General", 2,1,100,, readThisFile)
     IniAction(act, "realGammos", "General", 2,0.01,10,, readThisFile)
     IniAction(act, "resetImageViewOnChange", "General", 1,0,0,, readThisFile)
     IniAction(act, "satAdjust", "General", 2,0,3,, readThisFile)
     IniAction(act, "showHUDnavIMG", "General", 1,0,0,, readThisFile)
     IniAction(act, "showImgAnnotations", "General", 1,0,0,, readThisFile)
     IniAction(act, "skipDeadFiles", "General", 1,0,0,, readThisFile)
     IniAction(act, "SLDcacheFilesList", "General", 1,0,0,, readThisFile)
     IniAction(act, "SlideHowMode", "General", 2,1,3,, readThisFile)
     IniAction(act, "slidesFXrandomize", "General", 1,0,0,, readThisFile)
     IniAction(act, "slideShowDelay", "General", 2,90,25000,, readThisFile)
     IniAction(act, "SlidesMusicSong", "General", 0,0,0,, readThisFile)
     IniAction(act, "specialColorFXmode", "General", 2,1,7,, readThisFile)
     IniAction(act, "syncSlideShow2Audios", "General", 1,0,0,, readThisFile)
     IniAction(act, "TouchScreenMode", "General", 1,0,0,, readThisFile)
     IniAction(act, "uiColorCurveFXchannel", "General", 2,1,4,, readThisFile)
     IniAction(act, "uiColorCurveFXmode", "General", 2,1,7,, readThisFile)
     IniAction(act, "usrColorDepth", "General", 2,0,9,, readThisFile)
     IniAction(act, "usrTextureBGR", "General", 1,0,0,, readThisFile)
     IniAction(act, "vpIMGrotation", "General", 2,0,359,, readThisFile)
     IniAction(act, "WindowBgrColor", "General", 3,0,0,, readThisFile)
     IniAction(act, "zatAdjust", "General", 2,-300,300,, readThisFile)
     IniAction(act, "zoomLevel", "General", 2,0.01,20,, readThisFile)

     If (act=0)
     {
        If (isWinXP=1 || minimizeMemUsage=1)
           doSlidesTransitions := 0

        If (imageAligned!=1)
           imageAligned := 5

        If (scriptInit=1)
           interfaceThread.ahkFunction("updateWindowColor")

        defineColorDepth()
        recalculateThumbsSizes()
    } Else
    {
       IniAction(1, "appVersion", "General", 0,0,0,, readThisFile)
    }
}

writeMainSettingsApp() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 350)
    {
       lastInvoked := A_TickCount
       SetTimer, writeMainSettingsApp, -500
       Return
    }

    readMainSettingsApp(1)
    lastInvoked := A_TickCount
}

loadCustomUserKbds() {
    userCustomKeysDefined := []
    If (allowCustomKeys!=1)
       Return

    FileRead, pk, % customKbdFile
    Loop, Parse, pk,`n,`r
    {
       If !A_LoopField
          Continue

       sp := StrSplit(A_LoopField, sillySeparator)
       c := sp[5],        funcu := sp[2],    defu := sp[6]

       phFuncu := isFunc(funcu) ? funcu : SubStr(funcu, 2)
       userCustomKeysDefined[c "." phFuncu] := [funcu, sp[3], sp[4], c, defu, sp[7], A_Index, sp[1]] ; [funcu, menu-name, menu-location, context-id, default-kbd, new-kbd-human, file-line, user-kbdu]

       kbdu := c . sp[1]
       userCustomKeysDefined[kbdu] := [funcu, sp[3], sp[4], c, defu, sp[7], A_Index, sp[1]] ; [funcu, menu-name, menu-location, context-id, default-kbd, new-kbd-human, file-line, user-kbdu]
       If (defu!="" && StrLen(userCustomKeysDefined[defu, 1])<3 && !InStr(funcu, "?") && sp[1]!=sp[6])
       {
          kp := processKkbdNameToHuman(defu)
          userCustomKeysDefined[c . defu] := ["?_" funcu, "generic", "anywhere", c, defu, kp, A_Index, sp[1]]  ; [funcu, menu-name, menu-location, context-id, default-kbd, new-kbd-human, file-line, user-kbdu]
       }
    }
}

updateCustomUserKbds(newLine, skipLine, bonusSkipLine:=0, bonusLine:=0) {
    newu .= []
    FileRead, pk, % customKbdFile
    If !pk
       Return 0

    Loop, Parse, pk,`n,`r
    {
       If (A_Index=skipLine)
          Continue

       If (A_Index=bonusSkipLine && bonusSkipLine)
          Continue

       If A_LoopField
          newu .= A_LoopField "`n"
    }
    Sleep, 5
    FileDelete, % customKbdFile
    Sleep, 5
    If IsObject(newLine)
    {
       nova := ""
       Loop, % newLine.Count()
           nova .= newLine[A_Index] sillySeparator
    }

    newu .= nova ? nova "`n" : newLine "`n"
    If bonusLine
       newu .= bonusLine "`n"

    FileAppend, % newu, % customKbdFile, UTF-8
    r := ErrorLevel ? 0 : 1
    Return r
}

restoreDefaultCustomUserKbds(keyu, funcu, contextu, modus) {
    newu .= []
    FileRead, txt, % customKbdFile
    dfunkt := "?" funcu
    dafunkt := keyu sillySeparator "?_generic"
    ; ToolTip, % dafunkt , , , 2
    Loop, Parse, txt,`n,`r
    {
       pk := StrSplit(A_LoopField, sillySeparator)
       If (((pk[2]=funcu || pk[2]=dfunkt) && (pk[5]=contextu || modus="all")))
       || (InStr(A_LoopField, dafunkt)=1 && keyu!="" && pk[5]=contextu)
          Continue

       newu .= A_LoopField "`n"
    }

    Sleep, 5
    FileDelete, % customKbdFile
    Sleep, 5
    FileAppend, % newu, % customKbdFile, UTF-8
    r := ErrorLevel ? 0 : 1
    Return r
}

readMainSettingsApp(act) {
    EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
    readSlideSettings(mainSettingsFile, act)
    IniAction(act, "allowFreeIMGpanning", "General", 1)
    IniAction(act, "allowMultiCoreMode", "General", 1)
    IniAction(act, "allowRecordHistory", "General", 1)
    IniAction(act, "allowUserQuickFileActions", "General", 1)
    IniAction(act, "allowToneMappingImg", "General", 1)
    IniAction(act, "alwaysOpenwithFIM", "General", 1)
    IniAction(act, "askDeleteFiles", "General", 1)
    IniAction(act, "autoRemDeadEntry", "General", 1)
    IniAction(act, "closeEditPanelOnApply", "General", 1)
    IniAction(act, "cmrRAWtoneMapAlgo", "General", 2, 1, 2)
    IniAction(act, "cmrRAWtoneMapParamA", "General", 2, -8, 10)
    IniAction(act, "cmrRAWtoneMapParamB", "General", 2, -8, 10)
    IniAction(act, "cycleFavesOpenIMG", "General", 1)
    IniAction(act, "deleteFileActAfter", "General", 2, 1, 3)
    IniAction(act, "DisplayTimeUser", "General", 2, 1, 99)
    IniAction(act, "enableThumbsCaching", "General", 1)
    IniAction(act, "OSDfontBolded", "General", 1)
    IniAction(act, "OSDfontItalica", "General", 1)
    IniAction(act, "highlightAlreadySeenImages", "General", 1)
    IniAction(act, "histogramMode", "General", 2, 1, 3)
    IniAction(act, "LimitSelectBoundsImg", "General", 1)
    IniAction(act, "lockZoomLevel", "General", 1)
    IniAction(act, "maxMemThumbsCache", "General", 2, 6, 950)
    IniAction(act, "minimizeMemUsage", "General", 1)
    IniAction(act, "multilineStatusBar", "General", 1)
    IniAction(act, "MustLoadSLDprefs", "General", 1)
    IniAction(act, "mustRecordSeenImgs", "General", 1)
    IniAction(act, "additionalLVrows", "General", 2, 0, 15)
    IniAction(act, "OnSortdoFilesCheck", "General", 1)
    IniAction(act, "OSDbgrColor", "General", 3)
    IniAction(act, "OSDfontSize", "General", 2, 10, 350)
    IniAction(act, "OSDFontName", "General", 5)
    IniAction(act, "OSDtextColor", "General", 3)
    IniAction(act, "PasteFntSize", "General", 2, 10, 350)
    IniAction(act, "PrefsLargeFonts", "General", 1)
    IniAction(act, "preventUndoLevels", "General", 1)
    IniAction(act, "prevFileMovePath", "General", 6)
    IniAction(act, "prevFileSavePath", "General", 6)
    IniAction(act, "prevOpenFolderPath", "General", 6)
    IniAction(act, "reverseOrderOnSort", "General", 1)
    IniAction(act, "SeenIMGprivateFolder", "General", 5)
    IniAction(act, "rotateSelBoundsKeepRatio", "General", 1)
    IniAction(act, "ShowAdvToolbar", "General", 1)
    IniAction(act, "showFilesListMap", "General", 1)
    IniAction(act, "showHistogram", "General", 2, 1, 6)
    IniAction(act, "showInfoBoxHUD", "General", 2, 0, 2)
    IniAction(act, "showMainMenuBar", "General", 1)
    IniAction(act, "showSelectionGrid", "General", 1)
    IniAction(act, "skipSeenImageSlides", "General", 1)
    IniAction(act, "thumbsColumns", "General", 2, 2, 100)
    IniAction(act, "thumbsAratio", "General", 2, 1, 3)
    IniAction(act, "thumbsZoomLevel", "General", 2, 0.35, 3)
    IniAction(act, "thumbsListViewMode", "General", 2, 1, 4)
    IniAction(act, "uiUseDarkMode", "General", 1)
    IniAction(act, "useCachedSLDdata", "General", 1)
    IniAction(act, "userHQraw", "General", 1)
    IniAction(act, "userimgGammaCorrect", "General", 1)
    IniAction(act, "userimgQuality", "General", 1)
    IniAction(act, "userMultiCoresLimit", "General", 2, 2, thisSystemCores)
    IniAction(act, "usrTextAlign", "General", 5)
    IniAction(act, "preventDeleteFromProtectedPath", "General", 1)
    IniAction(act, "protectedFolderPath", "General", 6)
    IniAction(act, "allowCustomKeys", "General", 1)
    IniAction(act, "thumbsModeItemHighlight", "General", 1)
    RegAction(act, "mainWinMaximized",, 1)
    RegAction(act, "mainWinPos",, 5)
    RegAction(act, "mainWinSize",, 5)
    RegAction(act, "HUDnavBoxSize",, 2, 75, 250)
    RegAction(act, "slidesRandoMode",, 2, 1, 3)
    loadCustomUserKbds()

    If (act=0)
    {
       If (LimitSelectBoundsImg=1)
          lockSelectionAspectRatio := 1

       If (cmrRAWtoneMapAlgo=1)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, 0, 9.9)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, -8, 8)
       } Else If (cmrRAWtoneMapAlgo=2)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, -8, 8)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, 0, 1)
       } Else If (cmrRAWtoneMapAlgo=3)
       {
          cmrRAWtoneMapParamA := clampInRange(cmrRAWtoneMapParamA, 0, 1)
          cmrRAWtoneMapParamB := clampInRange(cmrRAWtoneMapParamB, 0, 1)
       }

       If !InStr(mainWinPos, "|")
          mainWinPos := ""
       If !InStr(mainWinSize, "|")
          mainWinSize := ""

       imgQuality := (userimgQuality=1) ? 6 : 5
       isTxtAlignOkay := (usrTextAlign="Left" || usrTextAlign="Right" || usrTextAlign="Center") ? 1 : 0
       If !isTxtAlignOkay
          usrTextAlign := "Left"

       If !prevOpenFolderPath
          prevOpenFolderPath := A_WorkingDir

       If !ResizeDestFolder
       {
          If prevOpenFolderPath
             ResizeDestFolder := prevOpenFolderPath
          Else
             ResizeDestFolder := A_WorkingDir
       }

       realSystemCores := userMultiCoresLimit
       SetVolume(mediaSNDvolume)
       calcHUDsize()
       msgDisplayTime := DisplayTimeUser*1000
    }
    setLVrowsCount()
}

calcHUDsize() {
   imgHUDbaseUnit := (PrefsLargeFonts=1) ? Round(OSDfontSize*2.5) : Round(OSDfontSize*2)
}

writeSlideSettings(file2save) {
    readSlideSettings(file2save, 1)
    ; throwMSGwriteError()
}

readRecentEntries(forceNewList:=0, doFiltering:=1) {
   Static lastInvoked := 1, historyList

   If (StrLen(forceNewList)>4)
   {
      historyList := forceNewList
      lastInvoked := A_TickCount
      Return
   }

   If (StrLen(historyList)>4 && (A_TickCount - lastInvoked<5500))
   {
      lastInvoked := A_TickCount
      Return historyList
   }

   historyList := ""
   Loop, % maxRecentOpenedFolders
   {
       IniRead, newEntry, % mainRecentsFile, RecentOpen, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>4 && doFiltering=1)
          historyList .= newEntry "`n"
       Else If (doFiltering!=1)
          historyList .= newEntry "`n"
   }
  
   List_MakeUnique(historyList, "`n", 0, 1)
   lastInvoked := A_TickCount
   Return historyList
}

List_MakeUnique(ByRef oList, Delimiter:="`n", Case_Sensitive:=0, keepAsEmpty:=0) {
; By [VxE], removes duplicate entries from a list. Special thanks to SKAN.
; SOURCE: https://autohotkey.com/board/topic/34715-removing-duplicates-from-the-list-without-sorting-it/page-2
; modified by Marius Șucan

   ; VarSetCapacity( New_List, StrLen( List ) )
   New_List := Delimiter
   entriesCount := 0
   Loop, Parse, oList, % Delimiter
   {
      If (keepAsEmpty!=1 && !A_LoopField)
         Continue

      If (!InStr(New_List, Delimiter . A_LoopField . Delimiter, !!Case_Sensitive))
         New_List .= A_LoopField . Delimiter
      Else If (keepAsEmpty=1)
         New_List .= A_Space . Delimiter

      entriesCount++
   }
   oList := SubStr(New_List, 2, -1)
   Return entriesCount
}

readMiniFavesEntries() {
   Static lastInvoked := 1, prevList, prevCall

   fileInfos := GetFileAttributesEx(mainFavesFile)
   thisCall := "zzz" fileInfos.size "=" fileInfos.wTime "=" fileInfos.cTime
   If (thisCall!=prevCall || !prevList)
   {
      FileRead, contentu, % miniFavesFile
      Loop, Parse, contentu, `n, `r
      {
           If RegExMatch(A_LoopField, RegExFilesPattern)
           {
              thisIndex++
              historyList .= A_LoopField "`n"
           }

           If (thisIndex>16)
              Break
      }

      prevList := historyList
      prevCall := thisCall
      ; FileRead, historyList, % mainFavesFile
   } Else historyList := prevList

   lastInvoked := A_TickCount
   Return historyList
}

RecentFilesManager(entry2add) {
  If (StrLen(entry2add)<5 || !allowRecordHistory || userPrivateMode=1)
     Return

  historyList := readRecentEntries()
  historyList := entry2add "`n" historyList
  List_MakeUnique(historyList, "`n", 0, 0)
  Loop, Parse, historyList, `n, `r
  {
      If (A_Index>maxRecentOpenedFolders)
         Break

      If (StrLen(A_LoopField)<5 || !FileExist(StrReplace(A_LoopField, "|")))
         Continue

      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentOpen, E%countItemz%
      newHistoryList .= A_LoopField "`n"
  }

  readRecentEntries(newHistoryList)
}

markUndefinedFavedList() {
   Loop, % maxFilesIndex
   {
        If (!InStr(resultedFilesList[A_Index, 5], "||") && resultedFilesList[A_Index, 5]="")
           resultedFilesList[A_Index, 5] := 1
   }
}

KbdToggleImgFavourites() {
   ToggleImgFavourites(0, 0, 1)
}

ToggleImgFavourites(thisImg:=0, actu:=0, directCall:=0) {
  Static lastInvoked := 1, prevImg, prevRemSpeed := 1
  imgPath := thisImg ? thisImg : getIDimage(currentFileIndex)
  isPipe := InStr(imgPath, "||")
  imgPath := StrReplace(imgPath, "||")
  If (A_TickCount - lastInvoked<550) && (directCall=1 && prevImg=imgPath) || !imgPath
     Return

  prevImg := imgPath
  resetSlideshowTimer(1)
  isFaved := resultedFilesList[currentFileIndex, 5]
  If (!isFaved && actu!="rem")
  {
     If !userAddedFavesCount
        IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)

     If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
     {
        userAddedFavesCount++
        resultedFilesList[currentFileIndex, 5] := 1
        resultedFilesList[currentFileIndex, 1] := imgPath
        updateMainUnfilteredList(currentFileIndex, 5, 1)
        zPlitPath(imgPath, 0, OutFileName, OutDir)
        If (userPrivateMode=1)
        {
           OutFileName := "*******.***"
           OutDir := "*:\******\*****"
        } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

        IniAction(1, "userAddedFavesCount", "General")
        showTOOLtip("Image ADDED back to favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(userAddedFavesCount), 0, 0, userAddedFavesCount/maxFavesEntries)
        currentFilesListModified := 1
        dummyTimerDelayiedImageDisplay(50)
        lastInvoked := A_TickCount
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If (userAddedFavesCount>maxFavesEntries - 1)
     {
        showTOOLtip("WARNING: You have reached the maximum allowed favourite images: " maxFavesEntries " entries.")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime//2
        Return
     }

     lastInvoked := A_TickCount
     whichFile := (userAddedFavesCount>19) ? mainFavesFile : miniFavesFile
     FileAppend, % imgPath "`n", % whichFile, UTF-8
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list`nThe image was not added to favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     whichFiled := (userAddedFavesCount>19) ? miniFavesFile : mainFavesFile
     If !FileExist(whichFiled)
        FileAppend, % "`n", % whichFiled, UTF-8

     userAddedFavesCount++
     IniAction(1, "userAddedFavesCount", "General")
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     If (userPrivateMode=1)
     {
        OutFileName := "*******.***"
        OutDir := "*:\******\*****"
     } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

     showTOOLtip("Image ADDED to favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(userAddedFavesCount), 0, 0, userAddedFavesCount/maxFavesEntries)
     resultedFilesList[currentFileIndex, 5] := 1
     updateMainUnfilteredList(currentFileIndex, 5, 1)
     If !thisImg
     {
        resultedFilesList[currentFileIndex, 1] := imgPath
        updateMainUnfilteredList(currentFileIndex, 1, imgPath)
     }

     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  } Else
  {
     If (!thisImg && InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
     {
        If !userAddedFavesCount
           IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)

        userAddedFavesCount--
        resultedFilesList[currentFileIndex, 5] := 0
        resultedFilesList[currentFileIndex, 1] := "||" imgPath
        updateMainUnfilteredList(currentFileIndex, 5, 0)
        zPlitPath(imgPath, 0, OutFileName, OutDir)
        IniAction(1, "userAddedFavesCount", "General")
        If (userPrivateMode=1)
        {
           OutFileName := "*******.***"
           OutDir := "*:\******\*****"
        } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

        showTOOLtip("Image REMOVED from favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(userAddedFavesCount), 0, 0, userAddedFavesCount/maxFavesEntries)
        currentFilesListModified := 1
        dummyTimerDelayiedImageDisplay(50)
        lastInvoked := A_TickCount
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     ToolTip, Please wait...
     startZeit := A_TickCount
     lastInvoked := A_TickCount
     IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)
     FileRead, historyList, % mainFavesFile
     FileRead, miniList, % miniFavesFile
     If ErrorLevel
     {
        Tooltip
        showTOOLtip("Failed to read the favourites list file`nUnable to remove image from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     historyList := StrReplace(miniList, imgPath) "`n" StrReplace(historyList, imgPath)
     hash := new hashtable()
     arrayList := []
     doDeduplication := (prevRemSpeed<765 && userAddedFavesCount<12345) ? 1 : 0
     miniF:= fileOpen(miniFavesFile, "w")
     If IsObject(miniF)
        mainF:= fileOpen(mainFavesFile, "w", "UTF-8")

     If (!IsObject(miniF) || !IsObject(mainF))
     {
        Tooltip
        showTOOLtip("Failed to read and write the favourites list file`nUnable to remove image from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If !thisImg
     {
        resultedFilesList[currentFileIndex, 5] := 0
        If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
           resultedFilesList[currentFileIndex, 1] := "||" imgPath

        updateMainUnfilteredList(currentFileIndex, 5, 0)
     }

     ; ToolTip, % doDeduplication "==" prevRemSpeed , , , 2
     Loop, Parse, historyList,`n,`r
     {
         If (realCount>maxFavesEntries)
            Break

         If !RegExMatch(A_LoopField, RegExFilesPattern)
            Continue

         If (doDeduplication=1)
         {
            z := Format("{:L}", A_LoopField)
            w := hash[z]
         }

         If (w!=1)
         {
            realCount++
            If (doDeduplication=1)
               hash[z] := 1

            lineu := A_LoopField "`n"
            If (realCount<20)
               miniF.Write(lineu)
            Else
               mainF.Write(lineu)
         }
     }

     mainF.Close()
     miniF.Close()
     hash := ""
      ; List_MakeUnique(historyList, "`n", 0, 0)
     userAddedFavesCount := realCount
     IniAction(1, "userAddedFavesCount", "General")
     Tooltip
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list file`nThe image was not succesfully removed from favourites")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     If (doDeduplication=1)
        prevRemSpeed := A_TickCount - startZeit

     zPlitPath(imgPath, 0, OutFileName, OutDir)
     If (userPrivateMode=1)
     {
        OutFileName := "*******.***"
        OutDir := "*:\******\*****"
     } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

     showTOOLtip("Image REMOVED from favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " groupDigits(realCount), 0, 0, realCount/maxFavesEntries)
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  }

  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

retrieveFavesAsArray(ByRef countItemz) {
    FileRead, historyList, % mainFavesFile
    FileRead, miniList, % miniFavesFile
    historyList := miniList "`n" historyList
    hash := new hashtable(userAddedFavesCount+50)
    Loop, Parse, historyList, `n,`r
    {
       imgu := Trimmer(A_LoopField)
       If (StrLen(imgu)<4 || !RegExMatch(imgu, RegExFilesPattern))
          Continue

       posu := InStr(imgu, ":\", 0, -1)
       If (posu>4)
       {
          oimgu := imgu
          imgu := SubStr(imgu, 1, posu - 2)
          bonus := SubStr(oimgu, posu - 1)
          If (StrLen(bonus)>4 && RegExMatch(bonus, RegExFilesPattern))
             hash[Format("{:L}", bonus)] := 1
       }

       hash[Format("{:L}", imgu)] := 1
    }

    countItemz := hash.Count()
    Return hash
}

retrieveFavesAsList(dummy:=0) {
    If GetKeyState("Ctrl", "P")
       ctrlState := 1

    If askAboutFileSave(". The current files list will be discarded as well")
       Return
 
    If AnyWindowOpen
       BtnCloseWindow()

    If askAboutSlidesListSave()
       Return

    If askAboutFilesSelect("discard it")
       Return

    showTOOLtip("Loading favourites list, please wait")
    FileRead, historyList, % mainFavesFile
    FileRead, miniList, % miniFavesFile
    historyList := miniList "`n" historyList
    thisList := []
    IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)
    doDeduplication := (userAddedFavesCount<12345) ? 1 : 0
    hash := new hashtable(userAddedFavesCount+50)
    If !ctrlState
       ctrlState := (GetKeyState("Ctrl", "P") || userAddedFavesCount<20101) ? 1 : 0

    ; ToolTip, % "f=" userAddedFavesCount , , , 2
    mustRenewList := countItemz := thisIndexu := 0
    ;  realCount := List_MakeUnique(historyList, "`n", 0, 0)
    Loop, Parse, historyList, `n,`r
    {
       imgu := Trimmer(A_LoopField)
       If InStr(imgu, "\\")
          imgu := StrReplace(imgu, "\\", "\")

       If (StrLen(imgu)<4 || !RegExMatch(imgu, RegExFilesPattern))
       {
          If A_LoopField
             mustRenewList := 1
          Continue
       }

       posu := InStr(imgu, ":\", 0, -1)
       If (posu>4)
       {
          oimgu := imgu
          imgu := SubStr(imgu, 1, posu - 2)
          bonus := SubStr(oimgu, posu - 1)
          thisIndexu++
          thisList[thisIndexu] := [bonus]
          thisList[thisIndexu, 5] := 1
       }

       If (doDeduplication=1)
       {
         z := Format("{:L}", imgu)
         w := hash[z]
       }

       If (w!=1)
       {
          thisIndexu++
          thisList[thisIndexu] := [imgu]
          thisList[thisIndexu, 5] := 1
          ; If (ctrlState=1)
          If (doDeduplication=1)
             hash[z] := 1
       } Else mustRenewList := 1
    }

   hash := ""
   If (thisIndexu> maxFavesEntries - 1)
      msgBoxWrapper(appTitle ": WARNING", "Please take note, you have exceeded the limit of favourite image entries: " maxFavesEntries ".", 0, 0, "exclamation")

   userAddedFavesCount := thisIndexu
   IniAction(1, "userAddedFavesCount", "General")
   If (thisIndexu<2)
   {
      showTOOLtip("WARNING: Found insufficient favourite images")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   If (SLDtypeLoaded=3)
   {
      SLDtypeLoaded := 0
      activeSQLdb.CloseDB()
   }

   PopulateIndexFilesStatsInfos("kill")
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := "\QPV\favourite-images-list.SLD"
   resultedFilesList := thisList.Clone()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SLDtypeLoaded := 2
   maxFilesIndex := thisList.Count()
   currentFileIndex := (isNumber(dummy)=1 && dummy>0) ? dummy : clampInRange(maxFilesIndex - 1, 1, maxFilesIndex)
   seenEntries := []
   If (mustRenewList=1 || !miniList)
      saveFavesListBasedOnIndexList()

   currentFilesListModified := 0
   INIaction(0, "SlidesMusicSong", "General")
   INIaction(0, "autoPlaySlidesAudio", "General", 1)
   If (thumbsDisplaying!=1 && !isNumber(dummy))
      MenuDummyToggleThumbsMode()

   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   GenerateRandyList()
   createGUItoolbar()
   p := (ShowAdvToolbar=1 && lockToolbar2Win=1) ? 100 : 50
   dummyTimerDelayiedImageDisplay(p)
   SetTimer, mainGdipWinThumbsGrid, % -p*2
   SetTimer, TriggerMenuBarUpdate, -90
   showDelayedTooltip("Favourites list loaded`nTotal entries: " groupDigits(maxFilesIndex), 0, 200)
   ; RandomPicture()
}

saveFavesListBasedOnIndexList() {
   ; If StrLen(filesFilter)>1
   ;    Return
   newListu := ""
   If StrLen(filesFilter)>1
   {
      lastInvoked := A_TickCount
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "The current files list has " groupDigits(maxFilesIndex) " images indexed. It is the result of a filter applied on the favourite images list.`n`nPlease confirm you want to save the favourites list as is, filtered. The total of " groupdigits(bckpMaxFilesIndex) " favourited images will no longer be retrievable.", "&Deactivate filter|&Save list|&Cancel", 0, "question")
      If InStr(msgResult, "deactivate")
      {
         MenuRemFilesListFilter()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, ResetImgLoadStatus, -150
         Return
      } Else If InStr(msgResult, "save")
      {
         If (A_TickCount - lastInvoked<950)
         {
            showTOOLtip("WARNING: The destructive option was chosen too fast.`nPlease elaborate allow yourself at least one second to read the message box.")
            SoundBeep , 300, 100
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
         Sleep, 100
      } Else
      {
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }
 
   realCount := 0
   testFile := FileOpen(mainFavesFile, "a", "UTF-8")
   If !IsObject(testFile)
   {
      showTOOLtip("ERROR: Unable to open the QPV favourites list file.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   testFile.Close()
   Sleep, 5

   mainFile := FileOpen(mainFavesFile, "w", "UTF-8")
   If IsObject(mainFile)
      miniFile := FileOpen(miniFavesFile, "w", "UTF-8")
   If (!IsObject(mainFile) || !IsObject(miniFile))
   {
      showTOOLtip("ERROR: Unable to open the QPV favourites list file.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   setImageLoading()
   changeMcursor()
   showTOOLtip("Saving favourites list, please wait")
   Loop, % maxFilesIndex
   {
       ; isFaved := resultedFilesList[currentFileIndex, 5]
       ; If !isFaved
       ;    Continue

       If (realCount>maxFavesEntries)
          Break

       ; If StrLen(filesFilter)>1
       ;    thisImg := bckpResultedFilesList[filteredMap2mainList[A_Index], 1]
       ; Else
          thisImg := resultedFilesList[A_Index, 1]

       If (StrLen(thisImg)>3 && !InStr(thisImg, "||"))
       {
          realCount++
          If (A_Index<20)
             miniFile.Write(thisImg "`n")
             ; miniList .= thisImg "`n"
          Else
             mainFile.Write(thisImg "`n")
             ; newListu .= thisImg "`n"
       }
   }

   mainFile.Close()
   miniFile.Close()
   userAddedFavesCount := realCount
   IniAction(1, "userAddedFavesCount", "General")
   showTOOLtip("Favourites list saved")
   SoundBeep, 900, 100

   currentFilesListModified := 0
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -150
}

eraseAllFavedIMGs() {
  Static lastInvoked := 1
  lastInvoked := A_TickCount
  msgResult := msgBoxWrapper(appTitle ": Favourites", "Are you sure you want to remove all the entries from the favourites list?", 4, 0, "question")
  If !InStr(msgResult, "yes")
     Return

  If (A_TickCount - lastInvoked<950)
  {
     showTOOLtip("ERROR: User answered the message box too quickly.`nPlease read the message before confirming action.")
     SoundBeep 300, 100
     Return
  }

  FileDelete, % mainFavesFile
  FileDelete, % miniFavesFile
  userAddedFavesCount := 0
  IniAction(1, "userAddedFavesCount", "General")
  showTOOLtip("All entries from the favourites list were removed.")
  SetTimer, RemoveTooltip, % -msgDisplayTime//2
  SetTimer, ResetImgLoadStatus, -150
}

RandomPicture(modus:=0) {
   ; Static inLoop := 0
   okayu := (thumbsDisplaying=1 || undoLevelsRecorded<2 || currentImgModified!=1) || (modus!="key") ? 1 : 0
   If (!maxFilesIndex && !CurrentSLD) || (okayu!=1)
      Return

   If (modus="key")
      resetSlideshowTimer()

   If (RandyIMGnow=-1 || !RandyIMGids.Count())
      coreGenerateRandomList()

   currentFileIndex := coreNextPrevImage(1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

PrevRandyPicture(modus:=0) {
   okayu := (thumbsDisplaying=1 || undoLevelsRecorded<2 || currentImgModified!=1) || (modus!="key") ? 1 : 0
   If (!maxFilesIndex && !CurrentSLD) || (okayu!=1)
      Return

   resetSlideshowTimer()
   If (RandyIMGnow=-1 || !RandyIMGids.Count())
      coreGenerateRandomList()

   currentFileIndex := coreNextPrevImage(-1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

getSelectedFiles(getItem:=0, forceSort:=0) {
   Critical, on
   Static firstItem, lastItem, lastIDcount := 0

   If (getItem=0 && forceSort=0)
      Return markedSelectFile
   Else If (getItem=1 && markedSelectFile)
      Return firstItem
   Else If (getItem="L" && markedSelectFile)
      Return lastItem

   If (forceSort=1 && getItem=0)
   {
      thisIDcount := "z" CurrentSLD DynamicFoldersList SLDtypeLoaded filesFilter maxFilesIndex bckpMaxFilesIndex markedSelectFile lastZeitFileSelect
      If (lastIDcount=thisIDcount)
         Return markedSelectFile

      Sleep, 1
      ; ToolTip, % thisIDcount "`n" lastIDcount , , , 2
      lastIDcount := thisIDcount
      firstItem := lastItem := markedSelectFile := 0
      changeMcursor()
      startZeit := A_TickCount
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]=1)
         {
            markedSelectFile++
            lastItem := A_Index
            If !firstItem
               firstItem := A_Index
         }
      }

      If (markedSelectFile=1)
      {
         markedSelectFile := 0
         resultedFilesList[firstItem, 2] := 0
         lastZeitFileSelect := A_TickCount
         If (thumbsDisplaying=1)
            mainGdipWinThumbsGrid()
      }
      changeMcursor("normal")
      Return markedSelectFile
   }
}

filterToFilesSelection() {
   userFilterProperty := 19
   userFilterInvertThis := userFilterDoString := 0
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   dummyTimerDelayiedImageDisplay(50)
}

invertFilesSelection() {
   If (thumbsDisplaying!=1 || maxFilesIndex<3)
      Return

   markedSelectFile := 0
   Loop, % maxFilesIndex
   {
       sel := resultedFilesList[A_Index, 2]
       resultedFilesList[A_Index, 2] := !sel
       If (sel!=1)
          markedSelectFile++
   }

   lastZeitFileSelect := A_TickCount
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)

   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
   showTOOLtip("Files selection inverted`n" groupDigits(markedSelectFile) " files are now selected")
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dropFilesSelection(silentMode:=0) {
   If (!markedSelectFile && silentMode=1)
      Return

   EntryMarkedMoveIndex := markedSelectFile := 0
   Loop, % maxFilesIndex
       resultedFilesList[A_Index, 2] := 0

   updateFilesSelectionInfos()
   ; selectAllFiles("none")
   ; ToolTip, % A_TickCount - startZeit, , , 2
   If (silentMode!=1)
   {
      showTOOLtip("Files selection dropped")
      If (thumbsDisplaying=1)
         mainGdipWinThumbsGrid()
      Else
         dummyTimerDelayiedImageDisplay(50)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

markThisFileNow(thisFileIndex:=0) {
  if !IsNumber(thisFileIndex)
     thisFileIndex := 0

  If (currentFileIndex=0 || maxFilesIndex<2 || AnyWindowOpen>0)
     Return

  If !thisFileIndex
     thisFileIndex := currentFileIndex

  DestroyGIFuWin()
  oSel := resultedFilesList[thisFileIndex, 2]
  sel := oSel ? 0 : 1
  resultedFilesList[thisFileIndex, 2] := sel
  ; sel := (oSel && !sel) ? 0 : 1
  If (oSel!=sel)
  {
     If sel
        markedSelectFile++
     Else
        markedSelectFile--
  }

  lastZeitFileSelect := A_TickCount
  If (markedSelectFile<0)
     getSelectedFiles(0, 1)
  Else If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
  Else
     dummyTimerDelayiedImageDisplay(25)

  interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
  interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
}

jumpToFilesSelBorderFirst() {
   jumpToFilesSelBorder(-1)
}

jumpToFilesSelBorderLast() {
   jumpToFilesSelBorder(1)
}

jumpToFilesSelBorder(destination) {
  Static prevImgIndex, prevIndexu

  If (slideShowRunning=1)
     ToggleSlideShowu()

  totalCount := getSelectedFiles(0, 1)
  If !totalCount
     Return

  theFirst := getSelectedFiles(1)
  theLast := getSelectedFiles("L")
  currentFileIndex := (destination=-1) ? theFirst : theLast
  FriendlyName := (destination=-1) ? "First" : "Last"
  dummyTimerDelayiedImageDisplay(50)
  showTOOLtip(FriendlyName " selected element index: " groupDigits(currentFileIndex) "`n" groupDigits(markedSelectFile) " total images selected")
  interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
  interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

navSelectedFilesNext() {
   navSelectedFiles(1)
}

navSelectedFilesPrev() {
   navSelectedFiles(1)
}

navSelectedFiles(direction) {
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   changeMcursor()

   If !markedSelectFile
   {
      getSelectedFiles(0, 1)
      If !markedSelectFile
      {
         changeMcursor("normal")
         CurrentSLD := backCurrentSLD
         showTOOLtip("No files are currently selected")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   startIndex := currentFileIndex
   newIndex := 0
   Loop, % maxFilesIndex
   {
        thisIndex := (direction=-1) ? currentFileIndex - A_Index : currentFileIndex + A_Index
        r := getIDimage(thisIndex)
        isSelected := resultedFilesList[thisIndex, 2]
        If (isSelected!=1 || !r || InStr(r, "||"))
           Continue

        newIndex := thisIndex
        Break
   }

   CurrentSLD := backCurrentSLD
   changeMcursor("normal")
   If (!newIndex && direction=-1)
   {
      jumpToFilesSelBorderLast()
      Return
   } Else If (!newIndex && direction=1)
   {
      jumpToFilesSelBorderFirst()
      Return
   }

   currentFileIndex := (newIndex) ? newIndex : startIndex
   dummyTimerDelayiedImageDisplay(25)
}

coreSearchIndex(imgPath, givenRegEx, whatu, invertu:=0) {
   If !givenRegEx
      Return

   ; ToolTip, % imgPath "`n" givenRegEx , , , 2
   If (whatu=1)
   {
      stringu := imgPath
   } Else ; If (userSearchWhat=1)
   {
      parentu := zPlitPath(imgPath, 1, OutFileName, OutDir)
      If (whatu=2)
         stringu := OutDir
      Else If (whatu=3)
         stringu := OutFileName
      Else If (whatu=4)
         stringu := parentu
   }

   ; ToolTip, % stringu "`n" thisSearchString "`n" z , , , 2
   If !invertu
      Return RegExMatch(stringu, givenRegEx)
   Else
      Return RegExMatch(stringu, givenRegEx) ? 0 : 1
}

processSearchIndexString(inputu) {
   testRegEx := SubStr(inputu, 1, 2)
   If (testRegEx="\>" && StrLen(inputu)>2)
   {
      thisFilter := SubStr(inputu, 3)
   } Else If (InStr(inputu, ">") && StrLen(inputu)>1)
   {
      thisFilter := StrReplace(inputu, ">")
      If thisFilter
         thisFilter := "i)(" JEE_StrRegExLiteral(thisFilter) ")$"
   } Else If (InStr(inputu, "/") && StrLen(inputu)>1)
   {
      thisFilter := StrReplace(inputu, "/")
      If (thisFilter!="")
         thisFilter := "i)^(" JEE_StrRegExLiteral(thisFilter) ")"
   } Else If (inputu!="")
      thisFilter := "i)(" JEE_StrRegExLiteral(inputu) ")"

   Return thisFilter
}

processSQLsearchIndexString(inputu, strPosu, ByRef whatu) {
   If (whatu=2)
      whatu := "imgfolder"
   Else If (whatu=3)
      whatu := "imgfile"
   Else ; If (whatu=1)
      whatu := "fullPath"

   inputu := StrReplace(inputu, "'")
   inputu := StrReplace(inputu, "_", "\_")
   inputu := StrReplace(inputu, "%", "_")
   inputu := StrReplace(inputu, "*", "_")
   inputu := StrReplace(inputu, "?", "_")
   inputu := StrReplace(inputu, "|", "_")
   inputu := StrReplace(inputu, "\>")
   inputu := StrReplace(inputu, "/")

   If (strPosu=3 && StrLen(inputu)>1)
   {
      thisFilter := "%" inputu
   } Else If (strPosu=2 && StrLen(inputu)>1)
   {
      thisFilter := inputu "%"
   } Else If inputu
      thisFilter := "%" inputu "%"

   Return thisFilter
}

searchNextIndex(direction, inLoop:=0) {
   thisFilter := processSearchIndexString(userSearchString)
   If (thisFilter="")
   {
      thisSearchString := userSearchString := ""
      SetTimer, PanelSearchIndex, -100
      Return
   }

   thisSearchString := thisFilter
   friendly := (direction=-1) ? "previous" : "next"
   showTOOLtip("Searching " friendly " in index matching:`n" userSearchString)
   originalIndex := startIndex := currentFileIndex
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""

   newIndex := 0
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalLoops := (direction=1 && inLoop!=1) ? maxFilesIndex - startIndex + 1 : startIndex + 1
   If (inLoop=1 && direction=-1)
      totalLoops := startIndex := maxFilesIndex + 1
   Else If (inLoop=1)
      startIndex := (direction=1) ? 0 : maxFilesIndex + 1

   ; msgbox, % startIndex "==" totalLoops "==" direction
   Loop, % totalLoops
   {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>1000)
        {
           etaTime := ETAinfos(A_Index, totalLoops, startOperation)
           showTOOLtip("Searching in index, please wait" etaTime, 0, 0, A_Index/totalLoops)
           prevMSGdisplay := A_TickCount
        }

        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        imgPath := getIDimage(thisIndex)
        If (!coreSearchIndex(imgPath, thisSearchString, userSearchWhat) || !imgPath)
           Continue

        If (skipDeadFiles=1 && thumbsDisplaying!=1)
        {
           If !FileExist(imgPath)
           {
              Continue
           } Else
           {
              newIndex := thisIndex
              Break
           }
        } Else
        {
           newIndex := thisIndex
           Break
        }
   }

   ResetImgLoadStatus()
   CurrentSLD := backCurrentSLD
   If (abandonAll=1)
   {
      showTOOLtip("Search abandoned by user")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep , 300, 100
      Return
   }

   If (!newIndex && inLoop!=1)
   {
      ; SoundBeep , 500, 100
      searchNextIndex(direction, 1)
      Return
   }

   If (!newIndex && inLoop=1)
   {
      userSearchString := ""
      showTOOLtip("WARNING: No indexed file matched the search criteria:`n" userSearchString)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep , 900, 100
      Return
   }

   RemoveTooltip()
   currentFileIndex := newIndex ? newIndex : originalIndex
   dummyTimerDelayiedImageDisplay(25)
   SetTimer, ResetImgLoadStatus, -100
}

setContaintFolderAsProtected(givenPath:=0) {
     If (givenPath=protectedFolderPath && preventDeleteFromProtectedPath=1)
     {
        preventDeleteFromProtectedPath := 0
        IniAction(1, "preventDeleteFromProtectedPath", "General")
        showTOOLtip("The files in the folder are no longer protected:`n" protectedFolderPath "\")
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }

     imgPath := FolderExist(givenPath) ? givenPath : getIDimage(currentFileIndex)
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     protectedFolderPath := OutDir
     preventDeleteFromProtectedPath := 1
     IniAction(1, "protectedFolderPath", "General")
     IniAction(1, "preventDeleteFromProtectedPath", "General")
     showTOOLtip("The protected folder path is now:`n" OutDir "\")
     SetTimer, RemoveTooltip, % -msgDisplayTime
}

UItoggleMultiDelProtectFolder() {
    If (AnyWindowOpen!=16)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, preventDeleteFromProtectedPath
    GuiControlGet, preventDeleteFromProtectedSubPaths

    IniAction(1, "preventDeleteFromProtectedPath", "General")
    IniAction(1, "preventDeleteFromProtectedSubPaths", "General")
    actu := preventDeleteFromProtectedPath ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, preventDeleteFromProtectedSubPaths
    GuiControl, % actu, btnFldr
}

PanelMultiFileDelete() {
    Static lastInvoked := 1

    filesElected := getSelectedFiles(0, 1)
    thisBtnHeight := createSettingsGUI(16, A_ThisFunc, 0)
    btnWid := 130
    txtWid := 290
    If (PrefsLargeFonts=1)
    {
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    IniAction(0, "userMultiDelChoice", "General", 2, 1, 3)
    IniAction(0, "preventDeleteFromProtectedPath", "General", 1)
    IniAction(0, "preventDeleteFromProtectedSubPaths", "General", 1)
    IniAction(0, "protectedFolderPath", "General", 6)
    If (A_TickCount - lastInvoked>10500)
       move2recycler := 1 

    If !userSearchString
       preventDeleteMatchingSearch := 0

    If !protectedFolderPath
       preventDeleteFromProtectedSubPaths := preventDeleteFromProtectedPath := 0

    lastInvoked := A_TickCount
    thisInfo := protectedFolderPath ? protectedFolderPath "\" : "NONE"
    Gui, Add, Text, x15 y15 Section w%txtWid% +hwndhTemp, Please choose what to remove:
    GuiAddDropDownList("xs+15 y+10 wp gTglMultiDelChoice AltSubmit Choose" userMultiDelChoice " vuserMultiDelChoice", "Delete selected files|Remove file entries from the list|Do both: remove files and the index entries", [hTemp])
    Gui, Add, Checkbox, xs y+10 gTglOptionMove2recycler Checked%move2recycler% vmove2recycler, Move to Recycle Bin the deleted files (undo possible)
    Gui, Add, Checkbox, y+10 Checked%preventDBentryRemoval% vpreventDBentryRemoval, Do not remove the entries from the database 
    Gui, Add, Checkbox, y+10 Checked%preventDeleteMatchingSearch% vpreventDeleteMatchingSearch, Skip the files that match the files list search criteria
    Gui, Add, Checkbox, y+10 gUItoggleMultiDelProtectFolder Checked%preventDeleteFromProtectedPath% vpreventDeleteFromProtectedPath, Skip the files found in the protected folder:
    Gui, Add, Text, xp+15 y+10 w%txtWid% vbtnFldr, % thisInfo
    Gui, Add, Checkbox, y+10 Checked%preventDeleteFromProtectedSubPaths% vpreventDeleteFromProtectedSubPaths, Skip files found in its sub-folders as well 
    Gui, Font, Bold
    Gui, Add, Text, xs y+20, % "Selected entries: " groupDigits(filesElected) "." 
    Gui, Font, Normal
    If (SLDtypeLoaded!=3 || userMultiDelChoice=1)
       GuiControl, Disable, preventDBentryRemoval

    If (userMultiDelChoice=2)
       GuiControl, Disable, move2recycler

    If !protectedFolderPath
    {
       GuiControl, Disable, preventDeleteFromProtectedPath
       GuiControl, Disable, preventDeleteFromProtectedSubPaths
       GuiControl, Disable, btnFldr
    }

    If !userSearchString
       GuiControl, Disable, preventDeleteMatchingSearch

    Gui, Add, Button, xs y+15 h%thisBtnHeight% w%btnWid% gBTNactiveFileDel, &Delete focused file only
    Gui, Add, Button, x+5 hp w95 gBTNmultiDel Default, &Proceed
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Delete files: " appTitle)
    SetTimer, UItoggleMultiDelProtectFolder, -100
}

BTNactiveFileDel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, preventDBentryRemoval

   BtnCloseWindow()
   DeleteActivePicture()
   preventDBentryRemoval := 0
}

DeleteActiveImgFileAndEntry() {
   If !HKifs("imgsLoaded")
      Return

    DeleteActivePicture()
    Sleep, 300
    If (maxFilesIndex>1 && currentFileIndex>0)
       singleInListEntriesRemover()
}

DeleteActivePicture() {
   If !HKifs("imgsLoaded")
      Return

   DeletePicture("single")
   getSelectedFiles(0, 1)
}

BTNmultiDel() {
   ; Critical, on
   If !AnyWindowOpen
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, preventDBentryRemoval
   GuiControlGet, preventDeleteMatchingSearch
   GuiControlGet, preventDeleteFromProtectedPath
   GuiControlGet, preventDeleteFromProtectedSubPaths
   GuiControlGet, userMultiDelChoice
   IniAction(1, "preventDeleteFromProtectedPath", "General")
   IniAction(1, "preventDeleteFromProtectedSubPaths", "General")
   Sleep, 10
   dontAlterIndex := (userMultiDelChoice=3) ? "yes" : 0
   TglOptionMove2recycler()
   filesElected := getSelectedFiles(0, 1)
   If (filesElected<2)
      Return

   If (userMultiDelChoice=3 || userMultiDelChoice=1)
   {
      If (filesElected>50 && move2recycler!=1) || (filesElected>95 && move2recycler=1)
      {
         msgInfos := (move2recycler=1) ? " " : "`n`nThe files will be PERMANENTLY deleted."
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete " groupDigits(filesElected) " files?" msgInfos, 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      BtnCloseWindow()
      r := batchFileDelete(dontAlterIndex)
   } Else r := 0

   If (userMultiDelChoice=3 || userMultiDelChoice=2) && (r=0)
   {
      If AnyWindowOpen
         BtnCloseWindow()
      Sleep, 500
      InListMultiEntriesRemover(0, "y")
   }

   preventDBentryRemoval := 0
   If AnyWindowOpen
      BtnCloseWindow()
}

TglMultiDelChoice() {
   TglOptionMove2recycler()
}

TglOptionMove2recycler() {
  Gui, SettingsGUIA: Default
  GuiControlGet, move2recycler
  GuiControlGet, userMultiDelChoice
  If (SLDtypeLoaded=3)
  {
     GuiControlGet, preventDBentryRemoval
     actu := (userMultiDelChoice=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
     GuiControl, % actu, preventDBentryRemoval
  }

  INIaction(1, "userMultiDelChoice", "General")
  actu := (userMultiDelChoice=1 || userMultiDelChoice=3) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
  GuiControl, % actu, move2recycler
}

batchRemoveMetaData() {
   Static doNotAskAgain := 0
   If !FileExist(mainExecPath "\exiftool.exe")
   {
      showTOOLtip("ERROR: Missing file: exiftool.exe. This feature is not available.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   imgPath := StrReplace(getIDimage(currentFileIndex), "||")
   zPlitPath(imgPath, 0, OutFileName, OutDir)
   getSelectedFiles(0, 1)
   filesElected := markedSelectFile
   If (markedSelectFile>3 && doNotAskAgain=0)
   {
      msgResult := msgBoxWrapper(appTitle ": Remove metadata", "You have selected to remove the metadata from " groupDigits(markedSelectFile) " image files. Please confirm this IRREVERSIBLE action.`n`nPlease note, You should NOT do this to Camera RAW images (except DNG) since proprietary RAW formats often contain information in the makernotes that is necessary for converting the image.", "&Remove metadata|&Cancel", 2, "question", "Do not ask again in this session")
      If !InStr(msgResult.btn, "remove")
         Return
      Else
         doNotAskAgain := msgResult.check
   } Else If (!markedSelectFile && !FileExist(imgPath))
   {
      showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep, 300, 100
      Return
   }

   ; cmdExifTool := new cli("CMD.exe","","CP850")
   cmdExifTool := new cli("""" mainExecPath "\exiftool.exe"" -stay_open true -@ ""-""" ,"","CP850")
   baseCmdLine := "`n-preserve`n-overwrite_original`n-all=`n"
   ; cmdLine := """" mainExecPath "\exiftool.exe"" -stay_open true -@ ""-""`r`n `r`n"
   ; cmdExifTool.Write(cmdLine)
   ; Sleep, 300
   ; output := cmdExifTool.Read()
   ; msgbox % output
   ; cmdExifTool.Write("`n-ver`n-execute`n")
   ; Sleep, 300
   ; output := cmdExifTool.Read()
   ; msgbox % output

   BtnCloseWindow()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   destroyGDIfileCache()
   doStartLongOpDance()
   yayFiles := abandonAll := failedFiles := skippedFiles := 0
   countTFilez := otherLoops := thisFileIndex := 0
   lastInvoked := 1
   If !markedSelectFile
   {
      thisFileIndex := currentFileIndex - 2
      resultedFilesList[currentFileIndex, 2] := 1
      showTOOLtip("Removing metadata from the selected file, please wait")
   } Else
      showTOOLtip("Removing metadata from " groupDigits(filesElected) " files, please wait")

   Loop
   {
      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If failedFiles
            etaTime .= "`nFailed to remove metadata for " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip("Removing metadata from selected files, please wait" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      output := cmdExifTool.Read()
      If (InStr(output, "{ready" thisFileIndex "}") || !countTFilez)
      {
         thisFileIndex++
         If (thisFileIndex>maxFilesIndex)
         {
            If InStr(output, "due to errors")
               failedFiles++
            Else If InStr(output, "0 image files updated")
               skippedFiles++
            Break
         }

         If (resultedFilesList[thisFileIndex, 2]!=1)
            Continue

         If InStr(output, "due to errors")
            failedFiles++
         Else If InStr(output, "0 image files updated")
            skippedFiles++
         Else
            yayFiles++

         ; MsgBox, % output "`n00`n" cmdLine
         countTFilez++
         imgPath := StrReplace(getIDimage(thisFileIndex), "||")
         cmdLine := baseCmdLine imgPath "`n-execute" thisFileIndex "`n"
         cmdExifTool.Write(cmdLine)
         lastInvoked := A_TickCount
         If !markedSelectFile
         {
            resultedFilesList[currentFileIndex, 2] := 0
            Break
         }

         Sleep, 0
      } Else otherLoops++

      ; If (A_TickCount - lastInvoked>500)
      ; {
      ;    fnOutputDebug(otherLoops "|" thisFileIndex "|" output "|" cmdLine)
      ;    lastInvoked := A_TickCount
      ; }
   }

   cmdExifTool.Write("`n-stay_open`n0`n-execute`n")
   cmdExifTool.Close()
   SetTimer, ResetImgLoadStatus, -50
   If markedSelectFile
   {
      If failedFiles
         someErrors := "Failed to remove metadata from " groupDigits(failedFiles) " files`n"
      If skippedFiles
         someErrors .= "Skipped files: " groupDigits(skippedFiles) "`n"

      If (abandonAll=1)
      {
         SoundBeep, 300, 100
         showTOOLtip(someErrors "Operation aborted. Metadata removed succesfully for " groupDigits(yayFiles) " out of " groupDigits(filesElected) " selected files until now")
      } Else
      {
         SoundBeep, 900, 100
         showTOOLtip(someErrors "Metadata removed succesfully for " groupDigits(yayFiles) " out of " groupDigits(filesElected) " selected files")
      }
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else RemoveTooltip()

   Return abandonAll
}

batchFileDelete(dontAlterIndex:=0) {
   If (userPrivateMode=1)
   {
      showTOOLtip("WARNING: You are not allowed to delete images when private mode is enabled")
      SoundBeep 300, 100
      Return
   }

   BtnCloseWindow()
   filesElected := markedSelectFile
   friendly := (move2recycler=1) ? "Moving to recycle bin" : "Permanently deleting"
   showTOOLtip(friendly A_Space groupDigits(filesElected) " files, please wait")
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   destroyGDIfileCache()
   doStartLongOpDance()
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   startZeit := A_Now
   filesRemoved := abandonAll := failedFiles := skippedFiles := 0
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   setWhileLoopExec(1)
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If failedFiles
            etaTime .= "`nFailed to remove " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip(friendly " selected files, please wait" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      thisFileIndex := A_Index
      file2rem := StrReplace(getIDimage(thisFileIndex), "||")
      If (preventDeleteMatchingSearch=1 && file2rem && userSearchString)
      {
         If coreSearchIndex(file2rem, thisSearchString, userSearchWhat)
         {
            skippedFiles++
            Continue
         }
      }

      If (preventDeleteFromProtectedPath=1 && protectedFolderPath)
      {
         If (preventDeleteFromProtectedSubPaths=1)
            OutDir := InStr(file2rem, protectedFolderPath "\") ? protectedFolderPath : ""
         Else
            OutDir := SubStr(file2rem, 1, InStr(file2rem, "\", 0, -1) - 1)

         If (protectedFolderPath=OutDir)
         {
            skippedFiles++
            Continue
         }
      }

      If (move2recycler=1)
      {
         FileGetSize, fSize, % file2rem
         FileGetTime, oFileDateM, % file2rem, M
         FileRecycle, % file2rem
      } Else
      {
         FileDelete, % file2rem
      }

      err := ErrorLevel ? 1 : 0
      If err
      {
         Try FileSetAttrib, -R, %file2rem%
         Sleep, 0
         If (move2recycler=1)
            FileRecycle, %file2rem%
         Else
            FileDelete, %file2rem%
         err := ErrorLevel ? 1 : 0
      }

      If !err
      {
         If (move2recycler=1)
            recordUndoFileActs(file2rem, "recycler", fSize "|" oFileDateM, 1, startZeit)

         If (SLDtypeLoaded=3)
            markSQLdbEntryDeleted(resultedFilesList[thisFileIndex, 12], 1)

         filesRemoved++
         If (dontAlterIndex!="yes")
         {
            resultedFilesList[thisFileIndex, 1] := "||" file2rem
            ; resultedFilesList[thisFileIndex, 2] := 1
            updateMainUnfilteredList(thisFileIndex, 1, "||" file2rem)
         }
      } Else failedFiles++
   }
   setWhileLoopExec(0)
   CurrentSLD := backCurrentSLD
   currentFilesListModified := 1
   If failedFiles
      someErrors := "Failed to delete " groupDigits(failedFiles) " files`n"
   If skippedFiles
      someErrors .= "Skipped files: " groupDigits(skippedFiles) "`n"

   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      {
         someErrors .= "Failed to update the database"
         throwSQLqueryDBerror(A_ThisFunc)
      }
   }

   watchFolderDetails := ""
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   If (abandonAll=1)
   {
      SoundBeep, 300, 100
      showTOOLtip(someErrors "Operation aborted. " groupDigits(filesRemoved) " out of " groupDigits(countTFilez) " selected files deleted until now")
   } Else
   {
      SoundBeep, 900, 100
      showTOOLtip(someErrors groupDigits(filesRemoved) " out of " groupDigits(countTFilez) " selected files deleted")
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return abandonAll
}

DeletePicture(dummy:=0) {
  Static lastInvoked := 1, prevDelFileIndex := -1
  getSelectedFiles(0, 1)
  If (markedSelectFile>1 && dummy!="single")
  {
     PanelMultiFileDelete()
     Return
  }

  If (slideShowRunning=1)
  {
     ToggleSlideShowu()
     Return
  }

  If (A_TickCount - lastInvoked<200) && (askDeleteFiles!=1)
  {
     lastInvoked := A_TickCount
     Return
  }

  file2rem := getIDimage(currentFileIndex)
  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir)
  If (askDeleteFiles=1 && dummy!="single") || (editingSelectionNow=1 && thumbsDisplaying!=1)
  {
     msgTimer := A_TickCount
     fakeWinCreator(37, A_ThisFunc, 1)
     msgResult := msgBoxWrapper("panelu|Delete confirmation: " appTitle, "Please confirm you want to delete this image file.`n`n" OutFileName "`n`n" OutDir "\", "&Remove index entry|&Delete|&Cancel", 3, "trash", "Permanently delete file, do not move to recycle bin", 0, "Always prompt before file delete`f`fNo longer prompt before file delete in this session`fNever prompt before file delete")
     If InStr(msgResult.btn, "Delete")
     {
        good2go := 1
     } Else If InStr(msgResult.btn, "remove index")
     {
        remCurrentEntry(0)
        Return
     }

     If (A_TickCount - msgTimer < 550) && InStr(msgResult.btn, "Delete")
     {
        showTOOLtip("Operation aborted. User answered affirmatively too quickly.")
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     }
  } Else good2go := 1

  If (msgResult.list>1 && good2go=1 && msgResult.check!=1)
  {
     askDeleteFiles := 0
     If (msgResult.list=3)
        INIaction(1, "askDeleteFiles", "General")
  }

  If (good2go!=1) || (imageLoading=1 && animGIFplaying!=1)
  {
     SetTimer, ResetImgLoadStatus, -50
     Return
  }

  Sleep, 2
  If (animGIFplaying=1)
  {
     DestroyGIFuWin()
     showDelayedTooltip("GIF animation stopped", 0, 250)
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  If (userPrivateMode=1)
  {
     showTOOLtip("WARNING: You are not allowed to delete images when private mode is enabled")
     SoundBeep 300, 100
     Return
  }

  Sleep, 2
  if (!validBMP(UserMemBMP) && thumbsDisplaying!=1)
  {
     prevDelFileIndex := currentFileIndex
     UserMemBMP := cloneGDItoMem(A_ThisFunc, gdiBitmap)
  } If (thumbsDisplaying=1 && undoLevelsRecorded<2)
     terminateIMGediting()

  destroyGDIfileCache(0, 1)
  FileGetSize, fSize, % file2rem
  If (fSize>0)
  {
     fileMsg := "`nFile size: " fileSizeFriendly(fSize)
     oFileDateM := QPV_FileGetSizeTime(file2rem, "M", thisFileIndex)
     oFileDateC := QPV_FileGetSizeTime(file2rem, "C", thisFileIndex)
     Try FormatTime, FileDateM, % oFileDateM, dd/MM/yyyy, HH:mm
     Try FormatTime, FileDateC, % oFileDateC, dd/MM/yyyy, HH:mm
     fileMsg .= "`nDate created: " FileDateC "`nDate modified: " FileDateM
  }

  Try FileSetAttrib, -R, %file2rem%
  Sleep, 1
  If (userPrivateMode!=1)
     OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

  shiftState := (GetKeyState("Shift", "P") && askDeleteFiles!=1) ? 1 : 0
  If (msgResult.check=1 || shiftState=1)
  {
     FileDelete, % file2rem
     canUndo := 0
  } Else
  {
     FileRecycle, % file2rem
     canUndo := 1
  }

  If ErrorLevel
  {
     If (thumbsDisplaying=1 && !FileExist(file2rem))
     {
        If (prevDelFileIndex=currentFileIndex)
           terminateIMGediting()

        remCurrentEntry(0)
     } Else
     {
        fileMsg := (userPrivateMode=1) ? "" : "`n" OutFileName "`n" OutDir "\"
        showTOOLtip("ERROR: File already deleted or access denied" fileMsg)
        SoundBeep, 300, 100
     }
  } Else
  {
     If (SLDtypeLoaded=3)
        markSQLdbEntryDeleted(resultedFilesList[currentFileIndex, 12])

     If (resultedFilesList[currentFileIndex, 5]=1 && !InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
     {
        ToggleImgFavourites(file2rem, "rem")
        resultedFilesList[currentFileIndex, 5] := 0
        updateMainUnfilteredList(currentFileIndex, 5, 0)
     }

     currentFilesListModified := 1
     resultedFilesList[currentFileIndex, 1] := "||" file2rem
     updateMainUnfilteredList(currentFileIndex, 1, "||" file2rem)
     fileMsg := (userPrivateMode=1) ? "" : "`n" groupDigits(currentFileIndex) " | " OutFileName "`n" OutDir "\" fileMsg
     If (canUndo=1)
     {
        showTOOLtip("File moved to recycle bin" fileMsg)
        recordUndoFileActs(file2rem, "recycler", fSize "|" oFileDateM, 1, A_Now)
     } Else
        showTOOLtip("File permanently deleted" fileMsg)

     lastOSDtooltipInvoked := 1
     If (deleteFileActAfter=2)
        NextPicture(0, 1)
     Else If (deleteFileActAfter=3)
        PreviousPicture(0, 1)
  }

  preventDBentryRemoval := 0
  Sleep, 2
  watchFolderDetails := ""
  lastInvoked := A_TickCount
  SetTimer, RemoveTooltip, % -msgDisplayTime
  SetTimer, ResetImgLoadStatus, -50
  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

readRecentMultiRenameEntries() {
   entriesList := ""
   If (userPrivateMode=1)
      Return

   Loop, 35
   {
       IniRead, newEntry, % mainRecentsFile, RecentMultiRename, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>1 && !InStr(entriesList, newEntry "`n"))
          entriesList .= newEntry "`n"
   }
   Return entriesList
}

PanelMultiRenameFiles() {
    Global UsrEditNewFileName
    getSelectedFiles(0, 1)
    If (maxFilesIndex<2 || markedSelectFile<2)
       Return

    thisBtnHeight := createSettingsGUI(8, A_ThisFunc)
    btnWid := 100
    txtWid := 390
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       txtWid := txtWid + 220
       Gui, Font, s%LargeUIfontValue%
    }
    lstWid := EditWid
    EditWid -= btnWid + 10
    RegAction(0, "PreserveDateTimeOnSave",, 1)
    thisu := groupDigits(markedSelectFile)
    listu := readRecentMultiRenameEntries()
    uiLVoffset := 0
    Gui, +Delimiter`n
    Gui, Add, Text, x15 y15 w%txtWid% Section, Selected files: %thisu%. Type a pattern to rename the files.
    Gui, Add, Text, y+10 w1 h1, Files rename pattern.
    Gui, Add, ComboBox, yp w%EditWid% gUIgenericComboAction vUsrEditNewFileName, % listu
    Gui, Add, Button, x+5 hp w%btnWid% gEraseMultiRenameHisto, Erase &history
    GuiAddListView("xs y+1 w" lstWid " -multi +LV0x10000 +LV0x400 r" uLVr " Grid AltSubmit vLViewOthers gUIlvMultiRenameResponder", "Original`nRenamed`nFolder path`n#", "Renaming files preview")
    ml := (PrefsLargeFonts=1) ? 40 : 30
    sml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddButton("xs y+5 h" thisBtnHeight " w" ml " gUImultiRenameChangeLVoffset", "<<", "First")
    GuiAddButton("x+1 hp w" sml " gUImultiRenameChangeLVoffset", "<", "Previous")
    GuiAddButton("x+1 hp wp gUImultiRenameChangeLVoffset", ">", "Next")
    GuiAddButton("x+1 hp w" ml " gUImultiRenameChangeLVoffset", ">>", "Last")
    Gui, Add, Checkbox, x+10 hp Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    thisW := (PrefsLargeFonts=1) ? 155 : 115
    Gui, Add, Text, xs y+10 +hwndhTemp, Action on file name collisions:
    GuiAddDropDownList("x+10 w" thisW " AltSubmit Choose" onConflictMultiRenameAct " vonConflictMultiRenameAct", "Skip files`nAuto-rename`nOverwrite`nAsk user", [hTemp])

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gcoreBatchMultiRenameFiles, &Rename files
    Gui, Add, Button, x+5 hp wp gBTNdoSoloRename, &Solo rename
    ml := (PrefsLargeFonts=1) ? 85 : 60
    Gui, Add, Button, x+5 hp w%ml% gBtnHelpMultiRename, H&elp
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Rename multiple files: " appTitle)
}

BTNdoSoloRename() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(idu, RowNumber, 4)
   If (idu && RowNumber)
      currentFileIndex := clampInRange(idu, 1, maxFilesIndex)

   BtnCloseWindow()
   dummyTimerDelayiedImageDisplay(50)
   fn := Func("PanelRenameThisFile").Bind("single")
   SetTimer, % fn, -100
}

UImultiRenameChangeLVoffset(a:=0, b:=0, c:=0) {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   GuiControlGet, UsrEditNewFileName
   If isNumber(a)
      ControlGetText, info, , ahk_id %a%
   Else
      info := a

   ; ToolTip, % info "|" a , , , 2
   totalListed := LV_GetCount()
   If (totalListed<1 || StrLen(UsrEditNewFileName)<1 || userPrivateMode=1)
   {
      If (userPrivateMode=1)
         showTOOLtip("WARNING: Nothing to preview at the moment.`nPrivate mode is activated")
      Else
         showTOOLtip("WARNING: Nothing to preview at the moment.`nPlease ensure you provided a renaming pattern.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   totalIndex := markedSelectFile
   If (totalListed>=totalIndex)
   {
      showTOOLtip("All selected entries are listed and previewed in the table")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (info="first")
      uiLVoffset := 0
   Else If (info="previous")
      uiLVoffset := clampInRange(uiLVoffset - totalListed, 0, totalIndex)
   Else If (info="next")
      uiLVoffset := clampInRange(uiLVoffset + totalListed, 0, totalIndex - uLVr*2)
   Else If (info="last")
      uiLVoffset := clampInRange(totalIndex - uiLVoffset, 0, totalIndex - uLVr*2)
   ; ToolTip, % a "=" b "=" c "=" info , , , 2
   SetTimer, PopulateLVmultiRename, -250
}

BtnHelpMultiRename() {
    GuiControlGet, PreserveDateTimeOnSave
    RegAction(1, "PreserveDateTimeOnSave")
    msgBoxWrapper(appTitle ": HELP", "Patterns available to rename the files:`n`na) Whatever file prefix [this] or suffix with tokens`n[this] - file name`n[pfdname] - parent folder name`n[fDateM] or [fDateC] - file modified/created date`n[counter] - count all files, regardless of their location`ntrim{X,Y} - X and Y designate how many letters to trim from the beginning and/or end of the original file name`ncase{U} - change letters to {U}pper, {L}ower or {T}itle case`n`nb) Replace given string//with this one`nUse // to perform search and replace in file names. Begin with \> to use RegEx. Trim function and the tokens mentioned earlier can be used only after //.`n`nc) abcdefgh01234>>any string`nEvery enumerated character before >> will be replaced with a single character or a string specified after >>. The tokens from a) can be used after >>.`n`nd) any file name without tokens`nThe files will be counted according to their containing folder. This is to avoid naming conflicts and applies only if [this], >> and // are not used.`n`ne) $.NewFileExtension`nMust begin with $. and cannot be used in combination with other patterns.", -1, 0, 0)
}

UIgenericComboAction(a:=0, b:=0, c:=0) {
   hwnd := Format("{1:#x}", a) 
   GuiControlGet, thisV, %A_Gui%:, %A_GuiControl%
   z := GetComboBoxInfo(hwnd)
   hwnd := Format("{1:#x}", z[1])
   allowCtrlBkspEdit(hwnd, thisV)
   If (AnyWindowOpen=8)
      SetTimer, PopulateLVmultiRename, -450
   Else If (AnyWindowOpen=61)
      SetTimer, dummyPopulateAboutKbdShortcutsList, -200
   Else If (AnyWindowOpen=6)
      SetTimer, updateUIFiltersPanel, -150
}

dummyPopulateAboutKbdShortcutsList() {
   PopulateAboutKbdShortcutsList(1)
}

decideMultiRename(ByRef OriginalNewFileName) {
   obju := []
   obju.renamingCount := 0
   obju.TrimmingMode := 0
   obju.rechecherRemplaceMode := 0
   obju.charsRemplaceMode := 0
   obju.regExRemplaceMode := 0
   obju.caseChange := 0
   obju.IndexModeCount := 0
   obju.forceCaseChange := 0
   If RegExMatch(OriginalNewFileName, "i)^(\$\..)")
   {
      obju.newExtu := SubStr(OriginalNewFileName, 3)
      Return obju
   }

   If RegExMatch(OriginalNewFileName, "i)(case\{.\})")
   {
      If InStr(OriginalNewFileName, "case{U}")
         obju.caseChange := 1
      Else If InStr(OriginalNewFileName, "case{L}")
         obju.caseChange := 2
      Else If InStr(OriginalNewFileName, "case{T}")
         obju.caseChange := 3

      OriginalNewFileName := StrReplace(OriginalNewFileName, "case{U}")
      OriginalNewFileName := StrReplace(OriginalNewFileName, "case{L}")
      OriginalNewFileName := StrReplace(OriginalNewFileName, "case{T}")
      If !Trimmer(OriginalNewFileName)
         obju.forceCaseChange := 1
   }
 
   If (Trimmer(OriginalNewFileName)="[counter]")
      OriginalNewFileName := "[this] ([counter])"
   Else If (obju.forceCaseChange=1)
      OriginalNewFileName := "[this]"
 
   matchFoundPosA := RegExMatch(OriginalNewFileName, "i)trim\{..?.?\, ?..?.?\}", matchedStringu)
   If InStr(OriginalNewFileName, "//")
      strArr := StrSplit(OriginalNewFileName, "//")
   Else If InStr(OriginalNewFileName, "\\")
      strArr := StrSplit(OriginalNewFileName, "\\")
   Else If InStr(OriginalNewFileName, ">>")
      chrStrArr := StrSplit(OriginalNewFileName, ">>")
   Else If (!InStr(OriginalNewFileName, "[this]") && !matchedStringu)
      obju.renamingCount := 1
 
   If (InStr(OriginalNewFileName, "[counter]") ) ; && obju.renamingCount!=1)
   {
      obju.IndexModeCount := 1
      obju.renamingCount := 0
   }
 
   If (IsObject(strArr) && obju.renamingCount!=1)
   {
      testRegEx := SubStr(strArr[1], 1, 2)
      If (testRegEx="\>")
      {
         obju.regExRemplaceMode := 1
         obju.strArrA := SubStr(strArr[1], 3)
         obju.strArrB := strArr[2]
      } Else
      {
         obju.strArrA := strArr[1]
         If (strArr[2]=A_Space || strArr[2]=0 || strArr[2]="  ")
            obju.strArrB := strArr[2]
         Else
            obju.strArrB := (filterFileName(strArr[2])!="") ? strArr[2] : ""
      }
 
      If (obju.strArrA="")
         Return "err"
      ; If (obju.strArrB="" && StrLen(obju.strArr[2])>0)
      ;    Return "err"
 
      obju.rechecherRemplaceMode := 1 
   } Else If (IsObject(chrStrArr) && obju.renamingCount!=1)
   {
      obju.strArrA := chrStrArr[1]
      If (chrStrArr[2]=A_Space || chrStrArr[2]=0 || chrStrArr[2]=" ")
         obju.strArrB := chrStrArr[2]
      Else
         obju.strArrB := filterFileName(chrStrArr[2]) ? chrStrArr[2] : ""
 
      If (obju.strArrA="")
         Return "err"
 
      obju.charsRemplaceMode := 1 
   } Else obju.newName := filterFileName(OriginalNewFileName)
 
   If (obju.renamingCount!=1)
   {
      obju.origMatchedStringu := matchedStringu
      matchedStringu := StrReplace(matchedStringu, A_Space)
      matchedStringu := StrReplace(matchedStringu, A_Space)
      matchedStringu := StrReplace(matchedStringu, .)
      matchedStringu := StrReplace(matchedStringu, "trim{")
      matchedStringu := StrReplace(matchedStringu, "}")
      If InStr(matchedStringu, ",")
      {
         trimuObj := StrSplit(matchedStringu, ",")
         obju.leftTrimu := trimuObj[1]
         obju.righttTrimu := trimuObj[2]
         obju.TrimmingMode := (isNumber(obju.leftTrimu) && isNumber(obju.righttTrimu)) ? 1 : 0
      }
      ; ToolTip, % obju.origMatchedStringu "`n" matchedStringu "`n" trimuObj[1] "==" trimuObj[2] , , , 2
   }
 
   Return obju
}

ChrReplace(string, chars, replacer) {
   If (chars!="")
   {
      Loop, Parse, chars
           string := StrReplace(string, A_LoopField, replacer)
   }

   Return string
}

decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez, parentFolderName, imgPath, obju) {
   If (StrLen(obju.newExtu)>1)
      Return fileNamuNoEXT
   
   If (obju.regExRemplaceMode=1)
      newFileName := RegExReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.rechecherRemplaceMode=1)
      newFileName := StrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.charsRemplaceMode=1)
      newFileName := ChrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (!InStr(OriginalNewFileName, "[this]") && obju.TrimmingMode!=1 && obju.IndexModeCount!=1)
      newFileName := OriginalNewFileName " (" countFilez ")"
   Else ; If (obju.TrimmingMode=1)
      newFileName := OriginalNewFileName

   If (InStr(newFileName, "[pfdname]") && InStr(OriginalNewFileName, "[pfdname]"))
      newFileName := StrReplace(newFileName, "[pfdname]", parentFolderName)

   If (InStr(newFileName, "[counter]") && InStr(OriginalNewFileName, "[counter]") && obju.IndexModeCount=1)
      newFileName := StrReplace(newFileName, "[counter]", countFilez)

   If (InStr(newFileName, "[fDateM]") && InStr(OriginalNewFileName, "[fDateM]"))
   {
      FileGetTime, dateu, % imgPath, M
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateM]", dateu)
   }

   If (InStr(newFileName, "[fDateC]") && InStr(OriginalNewFileName, "[fDateC]"))
   {
      FileGetTime, dateu, % imgPath, C
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateC]", dateu)
   }

   If (InStr(newFileName, "[this]") && InStr(OriginalNewFileName, "[this]"))
      newFileName := StrReplace(newFileName, "[this]", fileNamuNoEXT)

   If (obju.TrimmingMode=1 && obju.origMatchedStringu && obju.renamingCount!=1)
   {
      clampedL := clampInRange(obju.leftTrimu + 1, 0, StrLen(fileNamuNoEXT) - 1)
      trimmedFileName := SubStr(fileNamuNoEXT, clampedL)
      clampedR := clampInRange(obju.righttTrimu, 1, StrLen(trimmedFileName) - 1)
      If (obju.righttTrimu>0)
         trimmedFileName := SubStr(trimmedFileName, 1, StrLen(trimmedFileName) - clampedR)
      newFileName := StrReplace(newFileName, obju.origMatchedStringu, trimmedFileName)
      ; ToolTip, % clampedL "==" clampedR "`n" trimmedFileName "`n" newFileName , , , 2
   }
   ; ToolTip, % obju.TrimmingMode "==" obju.origMatchedStringu "==" obju.renamingCount , , , 2

   If (obju.caseChange=1)
      newFileName := Format("{:U}", StrReplace(newFileName, "case{U}"))
   Else If (obju.caseChange=2)
      newFileName := Format("{:L}", StrReplace(newFileName, "case{L}"))
   Else If (obju.caseChange=3)
      newFileName := Format("{:T}", StrReplace(newFileName, "case{T}"))

   Return newFileName
}

UIlvMultiRenameResponder(a, b, c) {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(indexu, RowNumber, 4)
   If !indexu
   {
      If (b="RightClick")
         invokePrefsPanelsContextMenu()
      Return
   }

   ; If (b="k")
   ;    ToolTip, % b "=" c , , , 2

   focusEdit := (b="k" && (isInRange(c, 33, 40) || isInRange(c, 48, 59)  || isInRange(c, 65, 90))) ? 0 : 1
   bfocusEdit := RegExMatch(b, "i)^(normal|s|f|i|c|d|a|colclick|right)") ? 1 : 0
   If (b="k" && c=112) ; F1
   {
      BtnHelpMultiRename()
   } Else If (b="k" && c=120) ; F9
   {
      UImultiRenameChangeLVoffset("first")
   } Else If (b="k" && c=121) ; F10
   {
      UImultiRenameChangeLVoffset("previous")
   } Else If (b="k" && c=122) ; F11
   {
      UImultiRenameChangeLVoffset("next")
   } Else If (b="k" && c=123) ; F12
   {
      UImultiRenameChangeLVoffset("last")
   } Else If (b="DoubleClick")
   {
      currentFileIndex := indexu
      dummyTimerDelayiedImageDisplay(50)
   } Else If (b="RightClick")
   {
      invokePrefsPanelsContextMenu()
   } Else If (bfocusEdit!=1 && focusEdit=1)
   {
      GuiControl, SettingsGUIA: Focus, UsrEditNewFileName
      highlightActiveCtrl()
   }
}

PopulateLVmultiRename() {
  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewOthers
  GuiControlGet, UsrEditNewFileName
  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  If (OriginalNewFileName="[this]" || OriginalNewFileName="")
  {
     LV_Delete()
     GuiControl, +Redraw, LViewOthers
     Return
  }

  OriginalNewFileName := UsrEditNewFileName
  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName
  
  If (objuTemp="err" || StrLen(OriginalNewFileName)<2)
  {
     LV_Delete()
     GuiControl, +Redraw, LViewOthers
     Return
  }

  loopzu := 0
  startOperation := A_TickCount
  If (StrLen(OriginalNewFileName)>1)
  {
     GuiControl, -Redraw, LViewOthers
     LV_Delete()
     filesElected := getSelectedFiles(0, 1)
     If (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"

     counterFilez := new hashtable()
     selCounter := 0
     maxItems := (userPrivateMode=1) ? 100 : 9100
     Loop, % maxFilesIndex
     {
         If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
            Continue

         selCounter++
         If (A_Index<uiLVoffset)
            Continue

         thisFileIndex := A_Index
         imgPath := resultedFilesList[A_Index, 1]
         parentFolderName := zPlitPath(imgPath, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)
         If (StrLen(objuTemp.newExtu)>1)
            fileEXTu := objuTemp.newExtu

         If (userPrivateMode=1)
         {
            newFileName := "*********."
            OutFileName := "********." fileEXTu
            OutDir := "*:\******\*******"
         } Else
         {
            If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
            {
               OutDirAsc := (objuTemp.IndexModeCount=1) ? "a" : OutDir
               counterFilez[OutDirAsc] := Round(counterFilez[OutDirAsc]) + 1
            }

            If (objuTemp.IndexModeCount=1)
               counterFilez[OutDirAsc] := selCounter

            newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, counterFilez[OutDirAsc], parentFolderName, imgPath, objuTemp)
         }
         ; ToolTip, % fileEXTu "|" newFileName , , , 2
         file2save := OutDir "\" newFileName "." fileEXTu
         If (file2save==imgPath || newFileName="" || newFileName=A_Space || newFileName="  " || newFileName=".")
            Continue

         loopzu++
         LV_Add(A_Index, OutFileName, newFileName "." fileEXTu, OutDir "\", A_Index)
         ; ToolTip, % A_Index , , , 2
         If ((loopzu>=maxItems) || (loopzu>15 && (A_TickCount - startOperation>1000)))
            Break
     }

     counterFilez := ""
     LV_ModifyCol(3, "AutoHdr Left")
     LV_ModifyCol(4, "AutoHdr Left")
     GuiControl, +Redraw, LViewOthers
  }
}

coreBatchMultiRenameFiles() {
  Critical, on
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditNewFileName
  GuiControlGet, PreserveDateTimeOnSave
  GuiControlGet, onConflictMultiRenameAct

  RegAction(1, "PreserveDateTimeOnSave")
  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  If (OriginalNewFileName="[this]" || OriginalNewFileName="")
  {
     showTOOLtip("WARNING: Incorrect multi-rename pattern provided")
     SoundBeep 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  OriginalNewFileName := UsrEditNewFileName
  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName
  
  If (objuTemp="err" || StrLen(OriginalNewFileName)<2)
  {
     showTOOLtip("WARNING: Incorrect multi-rename pattern provided")
     SoundBeep 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  backCurrentSLD := CurrentSLD
  If (StrLen(OriginalNewFileName)>1)
  {
     filesElected := getSelectedFiles(0, 1)
     If (filesElected>100)
     {
        msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to rename the selected files.`n`nYou have selected " filesElected " files to be renamed...", 4, 0, "question")
        If (msgResult!="Yes")
           Return
     }

     BtnCloseWindow()
     showTOOLtip("Renaming " groupDigits(filesElected) " files, please wait`nPattern: " OriginalNewFileName)
     startOperation := A_TickCount
     prevMSGdisplay := A_TickCount
     startZeit := A_Now
     destroyGDIfileCache()
     RecentMultiRenamesManager(OriginalNewFileName)
     doStartLongOpDance()
     If (SLDtypeLoaded=3)
        activeSQLdb.Exec("BEGIN TRANSACTION;")

     filezRenamed := countFilez := 0
     nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
     countTFilez := skippedFiles := failedFiles := overwrittenFiles := 0
     if (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"

     counterFilez := new hashtable()
     CurrentSLD := ""
     setWhileLoopExec(1)
     Loop, % maxFilesIndex
     {
         If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
            Continue

         changeMcursor()
         wasError := 0
         thisFileIndex := A_Index
         file2rem := getIDimage(thisFileIndex)
         parentFolderName := zPlitPath(file2rem, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)
         If (StrLen(objuTemp.newExtu)>1)
            fileEXTu := objuTemp.newExtu

         countTFilez++
         If !FileExist(file2rem)
         {
            failedFiles++
            Continue
         }

         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            someErrors := ETAinfos(countTFilez, filesElected, startOperation)
            If (failedFiles>0)
               someErrors .= "`nFailed to rename: " groupDigits(failedFiles) " files"
            If (skippedFiles>0)
               someErrors .= "`nSkipped files: " groupDigits(skippedFiles)
            If (overwrittenFiles>0)
               someErrors .= "`nOverwritten files: " groupDigits(overwrittenFiles)

            showTOOLtip("Renaming selected files, please wait`nPattern: " OriginalNewFileName someErrors, 0, 0, countTFilez/filesElected)
            prevMSGdisplay := A_TickCount
         }

         If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
         {
            OutDirAsc := (objuTemp.IndexModeCount=1) ? "a" : OutDir
            counterFilez[OutDirAsc] := Round(counterFilez[OutDirAsc]) + 1
         }

         If (objuTemp.IndexModeCount=1)
            counterFilez[OutDirAsc] := countTFilez

         newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, counterFilez[OutDirAsc], parentFolderName, file2rem, objuTemp)
         file2save := OutDir "\" newFileName "." fileEXTu
         If (file2save==file2rem || newFileName="" || newFileName=A_Space || newFileName="." || newFileName="  ")
         {
            skippedFiles++
            Continue
         }

         If (PreserveDateTimeOnSave=1)
         {
            originalMtime := ""
            FileGetTime, originalMtime, %file2save%, M
            FileGetTime, originalCtime, %file2save%, C
         }

         If (FileExist(file2save) && !FolderExist(file2save))
         {
            file2save := askAboutFileCollision(file2rem, file2save, 1, 0, onConflictMultiRenameAct, performOverwrite)
            If !file2save
            {
               skippedFiles++
               Continue
            } Else If (file2save="abort")
            {
               abandonAll := 1
               Break
            }
         }

         originalFileInfos := ""
         thisFileExists := FileRexists(file2save, 0)
         If (performOverwrite=1 && objuTemp.renamingCount!=1 && thisFileExists=1)
         {
            overwrittenFiles++
            jso := GetFileAttributesEx(file2save)
            originalFileInfos := jso.size "|" jso.wtime "|" jso.ctime
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            FileRecycle, %file2save%
            If ErrorLevel
               wasError++
            Sleep, 1
         } Else If (thisFileExists=1)
         {
            skippedFiles++
            Continue
         }

         FileSetAttrib, -R, %file2rem%
         Sleep, 1
         FileMove, %file2rem%, %file2save%, 1
         If ErrorLevel
         {
            failedFiles++
            wasError++
         } Else
         {
            updateDates := 1
            If (originalMtime && PreserveDateTimeOnSave=1)
            {
               Sleep, 0
               FileSetTime, % originalMtime, % file2save, M
               FileSetTime, % originalCtime, % file2save, C
               updateDates := 0
            } 

            filezRenamed++
            extraMarker := (thisFileExists=1 && performOverwrite=1 && objuTemp.renamingCount!=1) ? "*" : ""
            recordUndoFileActs(file2save, resultedFilesList[thisFileIndex, 1], extraMarker, 2, startZeit, originalFileInfos)
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[thisFileIndex, 12])

            resultedFilesList[thisFileIndex, 1] := file2save
            ; resultedFilesList[thisFileIndex, 2] := 1
            updateMainUnfilteredList(thisFileIndex, 1, file2save)
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }

     setWhileLoopExec(0)
     counterFilez := someErrors := ""
     CurrentSLD := backCurrentSLD
     If (SLDtypeLoaded=3)
     {
        If !activeSQLdb.Exec("COMMIT TRANSACTION;")
           someErrors .= "Failed to commit changes to the SQL database`n"
     } Else
        currentFilesListModified := 1

     If (failedFiles>0)
        someErrors .= "`nFailed to rename: " groupDigits(failedFiles) " files"
     If (skippedFiles>0)
        someErrors .= "`nSkipped files: " groupDigits(skippedFiles)
     If (overwrittenFiles>0)
        someErrors .= "`nOverwritten files: " groupDigits(overwrittenFiles)

     watchFolderDetails := ""
     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(100)
     If (abandonAll=1)
        showTOOLtip("Operation aborted. " groupDigits(filezRenamed) " out of " groupDigits(filesElected) " selected files were renamed" someErrors)
     Else
        showTOOLtip("Finished renaming " groupDigits(filezRenamed) " out of " groupDigits(filesElected) " selected files" someErrors)

     SetTimer, ResetImgLoadStatus, -50
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
  }
}

RecentMultiRenamesManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentMultiRenameEntries()
  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>35)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentMultiRename, E%countItemz%
  }
}

EraseMultiRenameHisto() {
  IniDelete, % mainRecentsFile, RecentMultiRename
  CloseWindow()
  Sleep, 1
  PanelRenameThisFile()
}

PanelfolderThanEraseThumbsCache() {
   If AnyWindowOpen
      Return

   fakeWinCreator(11, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Clear cached thumbnails: " appTitle, "Erase thumbnails cached older than... (in days)", "&Clean old cache|&Empty entire cache|C&ancel", 3, "trash", "&Always cache generated thumbnails", enableThumbsCaching, 0, "limit3 number -multi", 0)
   remCacheOldDays := Trimmer(msgResult.edit)
   If InStr(msgResult.btn, "old")
   {
      enableThumbsCaching := msgResult.check
      If !remCacheOldDays
         SetTimer, PanelfolderThanEraseThumbsCache, -150 ; allows for this execution line to cease peacefully ^_^ 
      Else
         EraseThumbsCache("daysITis", remCacheOldDays)
   } Else If InStr(msgResult.btn, "entire")
   {
      enableThumbsCaching := msgResult.check
      EraseThumbsCache()
   }
}

defineSQLdbSort() {
   reorder := StrLen(prevFilesSortMode)>3 ? "z" prevFilesSortMode ";" : ";"
   If InStr(reorder, "fsize")
      defaultSort := "File size"
   Else If InStr(reorder, "imgfolder, imgfile;")
      defaultSort := "Path and name"
   Else If InStr(reorder, "imgfolder;")
      defaultSort := "Folder path"
   Else If InStr(reorder, "zimgfile;")
      defaultSort := "File name"
   Else If InStr(reorder, "fmodified")
      defaultSort := "Modified date"
   Else If InStr(reorder, "fcreated")
      defaultSort := "Created date"
   Else If InStr(reorder, "imgwidth")
      defaultSort := "Image width"
   Else If InStr(reorder, "imgheight")
      defaultSort := "Image height"
   Else If InStr(reorder, "imgmegapix")
      defaultSort := "Megapixels"
   Else If InStr(reorder, "imgframes")
      defaultSort := "Frames"
   Else If InStr(reorder, "imgwhratio")
      defaultSort := "Aspect ratio [W/H]"
   Else If InStr(reorder, "imgdpi")
      defaultSort := "Image DPI"
   Else If InStr(reorder, "imgavg")
      defaultSort := "Histogram average"
   Else If InStr(reorder, "imgmedian")
      defaultSort := "Histogram median"
   Else If InStr(reorder, "imghrms")
      defaultSort := "Histogram RMS"
   Else If InStr(reorder, "imghmode")
      defaultSort := "Histogram mode"
   Else If InStr(reorder, "imghpeak")
      defaultSort := "Histogram max [range]"
   Else If InStr(reorder, "imghlow")
      defaultSort := "Histogram min [range]"
   Else If InStr(reorder, "imghrange")
      defaultSort := "Histogram range"
   Else If InStr(reorder, "imghminu")
      defaultSort := "Histogram minimum"
   Else If (StrLen(prevFilesSortMode)>2 && !Instr(reorder, "imgidu"))
      defaultSort := prevFilesSortMode
   Else 
      defaultSort := "None/manual"

   Return defaultSort
}

MenuMoveMarkedEntries() {
    EntryMarkedMoveIndex := 1
    moveMarkedEntryNow(currentFileIndex, "move")
}

moveMarkedEntryNow(indexu, modus:=0) {
   If StrLen(filesFilter)>1
   {
      showTOOLtip("WARNING: Index entries cannot be reordered when the files list is filtered.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (thumbsDisplaying!=1 || maxFilesIndex<2)
      Return

   If !isNumber(indexu)
      indexu := currentFileIndex

   If !EntryMarkedMoveIndex
   {
      EntryMarkedMoveIndex := indexu
   } Else If (EntryMarkedMoveIndex=indexu)
   {
      EntryMarkedMoveIndex := 0
   } Else If isNumber(EntryMarkedMoveIndex)
   {
      If (modus="move")
         reorderIndexEntryManually(EntryMarkedMoveIndex, indexu)
      Else
         switchIndexEntries(EntryMarkedMoveIndex, indexu)

      ; currentFileIndex := EntryMarkedMoveIndex
      EntryMarkedMoveIndex := 0
   }

   mainGdipWinThumbsGrid()
}

reorderIndexEntryManually(oldIndex, newFileIndex)  {
   Static countu := 0
   getSelectedFiles(0, 1)
   If markedSelectFile
   {
      newArrayu := []
      Loop, % maxFilesIndex
      {
          If resultedFilesList[A_Index, 2]
          {
             thisCounter++
             newArrayu[thisCounter] := resultedFilesList[A_Index]
          }
      }

      finalArrayu := []
      mainIndex := thisIndex := firstu := 0
      Loop, % maxFilesIndex
      {
          If (A_Index=newFileIndex)
          {
             Loop, % newArrayu.Count()
             {

                thisIndex++
                mainIndex++
                finalArrayu[mainIndex] := newArrayu[thisIndex]
                If !firstu
                   firstu := mainIndex
             }
          }

          If !resultedFilesList[A_Index, 2]
          {
             mainIndex++
             finalArrayu[mainIndex] := resultedFilesList[A_Index]
          }
      }

      resultedFilesList := []
      resultedFilesList := finalArrayu.Clone()
      currentFileIndex := firstu ? firstu : newFileIndex
   } Else
   {
      old := resultedFilesList.RemoveAt(oldIndex)
      resultedFilesList.InsertAt(newFileIndex, old)
      currentFileIndex := newFileIndex
   }

   ; prevLastImg[2] := prevLastImg[1]
   prevLastImg[2] := [oldIndex, resultedFilesList[oldIndex, 1]]
   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (SLDtypeLoaded=3 && countu<5)
   {
      countu++
      showTOOLtip("Reordering of index entries is temporary.`nThe changes are not saved in the database.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

switchIndexEntries(newFileIndex, oldIndex) {
   If (SLDtypeLoaded=3)
   {
      SQLstr := "UPDATE images SET imgidu=999999999 WHERE imgidu=" newFileIndex ";"
      If activeSQLdb.Exec(SQLStr)
      {
         SQLstr := "UPDATE images SET imgidu=" newFileIndex " WHERE imgidu=" oldIndex ";"
         If activeSQLdb.Exec(SQLStr)
         {
            SQLstr := "UPDATE images SET imgidu=" oldIndex " WHERE imgidu=999999999;"
            If !activeSQLdb.Exec(SQLStr)
            {
               addJournalEntry("Failed to change index entry position in the SQL database.")
               Return
            } ; Else ToggleDBdefaultSQLsort()
         }
      }
   }

   tempA := resultedFilesList[oldIndex]
   tempB := resultedFilesList[newFileIndex]
   ; ToolTip, % tempA "`n" tempB "`n" oldIndex "===" newFileIndex , , , 2
   resultedFilesList[oldIndex] := tempB
   resultedFilesList[newFileIndex] := tempA
   ; If (StrLen(filesFilter)>1 && !InStr(filesFilter, "SQL:query:"))
   ; {
   ;    tempA := bckpResultedFilesList[filteredMap2mainList[oldIndex], 1]
   ;    tempB := bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1]
   ;    bckpResultedFilesList[filteredMap2mainList[oldIndex], 1] := tempB
   ;    bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1] := tempA
   ; }

   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   currentFileIndex := oldIndex
   ; prevLastImg[2] := prevLastImg[1]
   prevLastImg[2] := [newFileIndex, resultedFilesList[newFileIndex, 1]]
   dummyTimerDelayiedImageDisplay(100)
}

PanelUpdateThisFileIndex(dummy:=0) {
    Global newFileName
    If (currentFileIndex=0)
       Return

   imgPath := getIDimage(currentFileIndex)
   fakeWinCreator(21, A_ThisFunc, 1)
   sqlSort := defineSQLdbSort()
   friendlyIndex := "" ;  (maxFilesIndex>1 && StrLen(filesFilter)<2) ? currentFileIndex "|" : ""
   If (!InStr(sqlSort, "none") && SLDtypeLoaded=3)
      friendlyIndex := ""

   If friendlyIndex
      msgInfos := "`n`nYou can type a new index number before | to move this entry elsewhere in the list."

   typeu := (userPrivateMode=1) ? " Password " : ""
   msgResult := msgBoxWrapper("panelu|Update files list index entry: " appTitle, "Please type the new file path and name.`nCurrent index: " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) "." msgInfos, "&Update entry|&Erase entry|&Browse file|C&ancel", 1, "modify-entry", 0, 0, 0, "limit9050" typeu, friendlyIndex imgPath)
   If InStr(msgResult.btn, "update")
   {
      newFileName := Trimmer(msgResult.edit)
      If (newFileName=imgPath) || (newFileName=currentFileIndex "|" imgPath)
         Return

      If askAboutFileSave(" and the current index entry will be updated")
         Return

      If (posu := InStr(newFileName, "|"))
      {
         newFileIndex := SubStr(newFileName, 1, posu - 1)
         newFileIndex := StrReplace(newFileIndex, ".")
         newFileIndex := StrReplace(newFileIndex, ",")
         If !isNumber(newFileIndex)
            newFileIndex := 0
         Else
            newFileIndex := clampInRange(newFileIndex, 1, maxFilesIndex)
 
         If (newFileIndex=currentFileIndex || maxFilesIndex<2)
            newFileIndex := 0
 
         newFileName := SubStr(newFileName, posu + 1)
         newFileName := Trimmer(newFileName)
      }

      If (!newFileName && maxFilesIndex>1)
      {
         remCurrentEntry(0)
         Return
      } Else If (newFileName!=imgPath && newFileName)
         r := UpdateIndexBTNaction(newFileName, currentFileIndex)

      If (!r && newFileName!=imgPath && newFileName)
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      } Else If (newFileIndex!=currentFileIndex && newFileIndex && friendlyIndex && !filesFilter)
         switchIndexEntries(newFileIndex, currentFileIndex)
   } Else If (InStr(msgResult.btn, "erase") && maxFilesIndex>1)
   {
      If askAboutFileSave(" and the current index entry will be erased")
         Return

      remCurrentEntry(0)
   } Else If InStr(msgResult.btn, "browse")
   {
      preventer := 1
      BrowseReplaceIndexEntry()
   } Else If (dummy="reopen")
   {
      preventer := 1
      fn := Func("PanelRenameThisFile").Bind("single")
      SetTimer, % fn, -100
   }

   If (dummy="reviewer" && !preventer)
      SetTimer, PanelReviewSelectedFiles, -100
}

PanelBrowseAudioAnnotation() {
    If (currentFileIndex=0 || SLDtypeLoaded!=3 || AnyWindowOpen)
       Return

   fakeWinCreator(38, A_ThisFunc, 1)
   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
   AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
   editFieldAudioFileu := StrLen(AudioFileu)>3 ? AudioFileu : OutDir "\" OutNameNoExt ". WAV or MP3 or WMA"

   msgResult := msgBoxWrapper("panelu|Associate audio file with image: " appTitle, "Please type or browse the file path of an audio file to associate with the current image.", "&Update entry|&Browse file|&Disassociate|C&ancel", 1, "audio-file", 0, 0, 0, "limit9050", editFieldAudioFileu)
   If InStr(msgResult.btn, "update")
   {
      AudioFileu := Trimmer(msgResult.edit)
      ; If InStr(AudioFileu, OutDir "\" OutNameNoExt ".") || !FileExist(AudioFileu)
      If !FileExist(AudioFileu)
      {
         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         showTOOLtip("ERROR: Incorrect file path, inexistent audio file or access denied:`n" OutFileName "`n" OutDir "\")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelBrowseAudioAnnotation, -150
         Return
      }

      updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
   } Else If InStr(msgResult.btn, "disassociate")
   {
      updateSQLdbEntryCaption(imgPath, "", "imgAudio")
   } Else If InStr(msgResult.btn, "browse")
   {
      patternObj := {}
      patternObj["Supported audio file formats"] := "*.wav;*.mp3;*.wma"
      startPath := AudioFileu ? AudioFileu : imgPath
      AudioFileu := openFileDialogWrapper("O", "FileMustExist", startPath, "Browse sound file", patternObj, chosenOption, 2)
      AudioFileu := Trimmer(AudioFileu)
      If StrLen(AudioFileu)>3
      {
         If AnyWindowOpen
            BtnCloseWindow()
         Sleep, 25
         updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
      }
      SetTimer, PanelBrowseAudioAnnotation, -150
   }
}

UIeditQuickMenuSearchTrigger() {
   delayu := (omniBoxMode=1) ? -250 : -50
   SetTimer, PopulateQuickMenuSearch, % delayu
}

PanelQuickSearchMenuOptions(whatu:=0,given:=0) {
    Global LVsearchMenus, StatusLineQuickSearch, UIclearBtn, UImenuQSbtn
    Static lastState := 0
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If (AnyWindowOpen=61 || AnyWindowOpen=83)
       CloseWindow()

    If (animGIFplaying)
       DestroyGIFuWin()

    mouseTurnOFFtooltip()
    If (given="yes" && StrLen(whatu)>1 && createdQuickMenuSearchWin=1)
       GuiControl, QuickMenuSearchGUIA:, userQuickMenusEdit, % whatu

    thisState := "a" uiUseDarkMode PrefsLargeFonts
    If (createdQuickMenuSearchWin=1 && thisState=lastState && VisibleQuickMenuSearchWin=1)
    {
       WinActivate, ahk_id %hQuickMenuSearchWin%
       interfaceThread.ahkassign("VisibleQuickMenuSearchWin", VisibleQuickMenuSearchWin)
       PopulateQuickMenuSearch("resel")
       Return
    } Else If (createdQuickMenuSearchWin=1 && thisState=lastState)
    {
       Gui, QuickMenuSearchGUIA: Show
       EM_SETSEL(hEditMenuSearch, 0, StrLen(userQuickMenusEdit))
       VisibleQuickMenuSearchWin := 1
       interfaceThread.ahkassign("VisibleQuickMenuSearchWin", VisibleQuickMenuSearchWin)
       PopulateQuickMenuSearch("resel")
       SetTimer, updateUistatusLineQuickSearch, -50
       Return
    }

    setLVrowsCount()
    Gui, QuickMenuSearchGUIA: Destroy
    Sleep, 25
    mr := (PrefsLargeFonts=1) ? 10 : 5
    Gui, QuickMenuSearchGUIA: Default
    Gui, QuickMenuSearchGUIA: +Resize -MaximizeBox -MinimizeBox +ToolWindow +Owner%PVhwnd% hwndhQuickMenuSearchWin
    Gui, QuickMenuSearchGUIA: Margin, % mr, % mr
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    If (uiUseDarkMode=1)
    {
       Gui, Color, % darkWindowColor, % darkWindowColor
       Gui, Font, c%darkControlColor%
       setDarkWinAttribs(hQuickMenuSearchWin)
    }

    thisBtnHeight := (PrefsLargeFonts=1) ? 34 : 24
    btnWid := 105
    txtWid := 360
    lstWid := 600
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 215
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    tp := (given="yes" && StrLen(whatu)>1) ? whatu : userQuickMenusEdit
    hEditMenuSearch := GuiAddEdit("x15 y15 Section -multi w" lstWid " gUIeditQuickMenuSearchTrigger vuserQuickMenusEdit", tp, "Search query or file path", "QuickMenuSearchGUIA")
    Gui, Add, Button, x+2 yp+0 w2 hp -TabStop Default gBTNquickSearchHidden, Execute
    GuiAddButton("x+1 yp w45 hp -TabStop gBtnClearQuickSearchEdit vUIclearBtn", "X", "Clear edit field",, "QuickMenuSearchGUIA")
    hLVquickSearchMenus := GuiAddListView("xs y+20 w" lstWid " +LV0x10000 +LV0x400 r" uLVr " -multi gLVquickSearchMenusResponder vLVsearchMenus AltSubmit", "Action|X|Shortcut|Menu|Keywords|Function|#|Score", "Search results", "QuickMenuSearchGUIA")
    GuiAddButton("x+1 yp w45 h45 gBTNinvokeQuickSearchMenu vUImenuQSbtn", ">", "Options",, "QuickMenuSearchGUIA")
    Gui, Add, Text, xs y+2 wp vStatusLineQuickSearch +0x200 -wrap, Status bard
    ; Gui, Add, Button, x+5 wp hp gBtnCloseWindow, C&lose
    LV_EX_SetColumnOrder(hLVquickSearchMenus, [2,1,3,4,5,6,7,8])
    VisibleQuickMenuSearchWin := 1
    createdQuickMenuSearchWin := 1
    lastLVquickSearchSortCol := [8, "SortDesc"]
    interfaceThread.ahkassign("VisibleQuickMenuSearchWin", VisibleQuickMenuSearchWin)
    interfaceThread.ahkassign("hQuickMenuSearchWin", hQuickMenuSearchWin)
    lastState := thisState
    repositionWindowCenter("QuickMenuSearchGUIA", hQuickMenuSearchWin, PVhwnd, "Quick menu options search")
    QuickMenuSearchGUIAGuiSize()
    PopulateQuickMenuSearch()
}

BtnClearQuickSearchEdit() {
   userQuickMenusEdit := ""
   lastLVquickSearchSortCol := [8, "SortDesc"]
   GuiControl, QuickMenuSearchGUIA:, userQuickMenusEdit,
   GuiControl, QuickMenuSearchGUIA:Focus, userQuickMenusEdit
}

LVquickSearchMenusResponder(a:=0, b:=0, c:=0) {
   Critical, on
   Static lastInvoked := 1, doNotaskAgain := 0, lastSortDirection := 0

   ; If (b="k")  
   If (b="ColClick" && c>0)
   {
   ;   ToolTip, % a "|" b "|" c , , , 2
      lastSortDirection := !lastSortDirection
      If (c!=lastLVquickSearchSortCol[1])
         lastSortDirection := 0

      diru := (lastSortDirection=1) ? "SortDesc" : "Sort"
      lastLVquickSearchSortCol := [c, diru]
   }

   If (b="a" || b="i" || b="f") || (A_TickCount - zeitSillyPrevent<350) && (b!="DoubleClick" && b!="d")
      Return

   focusEdit := (b="k" && isInRange(c, 33, 40)) ? 0 : 1
   bfocusEdit := RegExMatch(b, "i)^(normal|s|f|i|c|d|a|colclick|right)") ? 1 : 0
   If (b="K" && c=112) ; f1
   {
      btnHelpQuickSearchMenus()
   } Else If (b="K" && c=113) ; F2
   {
      omniBoxFolderRename()
   } Else If (b="K" && c=114) ; F3
   {
      omniBoxFolderImport()
   } Else If (b="K" && c=116) ; F5
   {
      SetTimer, PopulateQuickMenuSearch, -150
   } Else If (b="K" && c=118) ; F7
   {
      omniBoxFolderCreateNew()
   } Else If (b="K" && c=45) ; Insert
   {
      omniBoxFolderOpen()
   } Else If (b="K" && c=119) ; F8
   {
      r := omniBoxFolderDelete()
      If (r="-" && omniBoxMode!=1)
      {
         closeQuickSearch()
         SetTimer, openPreviousPanel, -200
      }
   } Else If (b="K" && c=32) || (b="DoubleClick") ; enter
   {
      actu := (b="DoubleClick") ? "forced" : ""
      BTNquickSearchHidden(actu)
   } Else If (b="K" && c=93) ; appskey
   {
      QuickMenuSearchGUIAGuiContextMenu(hQuickMenuSearchWin, 0, "RightClick", 1, 0, 0)
   } Else If (b="D" && omniBoxMode=1) ; drag'n drop
   {
      Gui, QuickMenuSearchGUIA: Default
      GuiControlGet, userQuickMenusEdit
      edithu := Trimmer(userQuickMenusEdit)
      edithu := Trimmer(StrReplace(edithu, "\\", "\"), "\")
      r := info := ""
      initialRow := c
      initialFolder := OmniBoxGetSelectedFolder(c, "yes", edithu)
      prevMSGdisplay := 1
      While, determineLClickState()
      {
         ; drag and drop
         If (GetKeyState("Escape", "P"))
         {
            func2exec := r := info := ""
            thisFolder := dc := nc := r := info := ""
            Global lastOtherWinClose := A_TickCount
            interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
            Break
         }

         info := defineWindowUnderMouse()
         If InStr(info, "tooltip")
         {
            showOSDinfoLineNow(500)
            Continue
         } Else If InStr(info, "tree")
         {
            LV_Modify(initialRow, "select")
            friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
            GetMouseCoord2wind(hTVlistFolders, nX, nY)
            nc := TVH_HitTest(hTVlistFolders, cr, nX, nY)
            If nc
            {
               Gui, fdTreeGuia: Default
               Gui, fdTreeGuia: TreeView, TVlistFolders
               TV_GetText(thisFolder, nc)
               TV_Modify(nc)
            }

            friendly .= nc ? "`nDestination: ." thisFolder "\" : "No destination folder."
            r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
            If nc
               friendly .= A_Space r
         } Else If InStr(info, "main")
         {
            r := dc := nc := ""
            LV_Modify(initialRow, "select")
            r := GetKeyState("Shift", "P") ? "`nFolder is to be RECURSIVELY scanned." : "`nHold SHIFT for recursive scanning."
            friendly := "`nDrop folder here to import it into the current list." r
            ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
         } Else If InStr(info, "omnibox list")
         {
            thisFolder := r := dc := nc := ""
            GetMouseCoord2wind(hLVquickSearchMenus, nX, nY)
            dc := LV_EX_ItemHitTest(hLVquickSearchMenus, kp, nX, nY)
            thisFolder := OmniBoxGetSelectedFolder(dc, "yes", edithu)
            If (dc=initialRow || !thisFolder || thisFolder=initialFolder)
            {
               dc := thisFolder := ""
               LV_Modify(initialRow, "select")
            } Else
            {
               ; Gui, QuickMenuSearchGUIA: Default
               ; Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
               LV_Modify(dc, "select")
            }

            restu := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
            friendly := "`nMove or copy folder into another one. Hold SHIFT to MOVE."
            r := GetKeyState("Shift", "P") ? "[_MOVE_]" : "[_COPY_]"
            friendly2 := "`nDestination: ." restu "\ " r
            friendly .= thisFolder ? friendly2 : "`nNo destination folder is currently underneath."
            ; r := GetKeyState("Shift", "P") ? "[MOVE]" : "[COPY]"
         } Else 
         {
            r := dc := nc := ""
            friendly := "`nNo action associated to this pointer location."
         }

         If (A_TickCount - prevMSGdisplay>100)
         {
            externToolTiput(info friendly)
            prevMSGdisplay := A_TickCount
         }
      }

      If InStr(info, "main")
      {
         z := InStr(r, "scanned") ? "recursive" : "not"
         externTooltiput("Importing folder - please wait")
         omniBoxFolderImport(z, "yes")
      } Else If (InStr(info, "omnibox") && dc && thisFolder)
      {
         externTooltiput("-hide-")
         src := OmniBoxGetSelectedFolder(initialRow, "yes", edithu)
         dest := OmniBoxGetSelectedFolder(dc, "yes", edithu)
         rSrc := SubStr(src, InStr(src, "\", 0, -1) + 1)
         rDest := SubStr(dest, InStr(dest, "\", 0, -1) + 1)

         If (doNotAskAgain=0 && src!=dest && InStr(src, ":\") && InStr(dest, ":\") && r)
         {
            msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action inside the omnibox: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: .\" rSrc "\`nDestination: .\" rDest "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
            If !InStr(msgResult.btn, "Yes")
            {
               SetTimer, PopulateQuickMenuSearch, -200
               Return 1
            } Else doNotaskAgain := msgResult.check
         }

         If (InStr(r, "_") && src!=dest && InStr(src, ":\") && InStr(dest, ":\"))
         {
            externTooltiput("Please wait - performing folder action")
            r := UIcoreFolderPasteFoldersInto(0, "given", r, src, dest)
         }
         externTooltiput("-hide-")
      } Else If (InStr(info, "tree") && r && nc)
      {
         externTooltiput("-hide-")
         src := OmniBoxGetSelectedFolder(initialRow, "yes", edithu)
         dest := folderTreeGetSelectedPath(nc)
         If (doNotAskAgain=0 && src!=dest && InStr(src, ":\") && InStr(dest, ":\") && r)
         {
            msgResult := msgBoxWrapper(appTitle ": Drag and drop action", "You have performed a drag and drop action from the omnibox to the folders tree panel: " SubStr(r, 3, 4) ". Please confirm with Yes that this was not accidental.`n`nSource: ." src "\`nDestination: ." dest "\", "&Yes|&No", 2, "question", "Do not ask again in this session")
            If !InStr(msgResult.btn, "Yes")
            {
               SetTimer, folderTreeInfoStatusLineUpdater, -125
               Return 1
            } Else doNotaskAgain := msgResult.check
         }

         externTooltiput("Please wait - performing folder action")
         If (InStr(r, "_") && src!=dest && InStr(src, ":\") && InStr(dest, ":\"))
         {
            r := UIcoreFolderPasteFoldersInto(0, "given", r, src, dest)
            If (r=2)
               folderTreeScanSubbies()
         }
      }
      externTooltiput("-hide-")
      prevent := 1
   } Else If (b="k" && c=8 && omniBoxMode=1) ; backspace
   {
      GoQuickSearchAction(0, "yes", "!OmniNavigateUpFolder")
   } Else If (bfocusEdit!=1 && focusEdit=1)
   {
      GuiControl, QuickMenuSearchGUIA: Focus, userQuickMenusEdit
      highlightActiveCtrl()
   }

   SetTimer, updateUistatusLineQuickSearch, -50
   zeitSillyPrevent := A_TickCount
   ; fnOutputDebug(a "=" b "=" c)
}

BTNquickSearchHidden(actu) {
   Gui, QuickMenuSearchGUIA: Default
   GuiControlGet, userQuickMenusEdit
   userQuickMenusEdit := Trimmer(userQuickMenusEdit)
   testu := SubStr(userQuickMenusEdit, 1, 1)
   If isVarEqualTo(testu, ":", "|", ".", ">")
   {
      thisu := SubStr(userQuickMenusEdit, 2)
      If RegExMatch(thisu, "i)^(set\_..*\=..*)")
      {
         paramSet := SubStr(thisu, 5, InStr(thisu, "=") - 5)
         paramSetValue := SubStr(thisu, InStr(thisu, "=") + 1)
         If (paramSet && paramSetValue!="")
         {
            %paramSet% := paramSetValue
            thisu := paramSet
            kk := " changed now by user"
         } Else Return
      }

      pp := %thisu%
      If IsObject(pp)
      {
         listu := A_Space thisu " (object):`n"
         For Key, Value in pp
         {
             If (A_Index>50)
                Break

             pl := IsObject(Value) ? " (sub-object)" : ""
             listu .= Key "," Value pl "`n"
         }
      } Else If IsFunc(thisu)
      {
         closeQuickSearch()
         Sleep, 5
         %thisu%()
         Return
      } Else 
      {
         listu := %thisu%
         listu := " (variable" kk ")`n" thisu " = " listu
      }

      showTOOLtip("Result:" listu)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else If ((userQuickMenusEdit=";o" || userQuickMenusEdit=".\o"))
      fromFolderTreeToOmniBox("thisFile", prevOpenFolderPath)
   Else If ((userQuickMenusEdit=";f" || userQuickMenusEdit=".\f") && folderTreeWinOpen=1)
      fromFolderTreeToOmniBox()
   Else If (userQuickMenusEdit=";" || userQuickMenusEdit=".\")
      invokeOmniBoxCurrentFile()
   Else If GetKeyState("Alt", "P")
      omniBoxFolderImport()
   Else If (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P"))
      omniBoxFolderOpen()
   Else
      GoQuickSearchAction(actu)
}

updateUistatusLineQuickSearch() {
   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   RowNumber := LV_GetFirstSelected(hLVquickSearchMenus)
   If !RowNumber
      RowNumber := LV_GetNext(0, "F")

   If !RowNumber
   {
      If (SubStr(userQuickMenusEdit, 2, 2)=":\")
         GuiControl, QuickMenuSearchGUIA:, StatusLineQuickSearch, % AnyWindowOpen ? "You cannot navigate through folders while a panel is opened." : "The provided folder path does not exist."
      Else
         GuiControl, QuickMenuSearchGUIA:, StatusLineQuickSearch, No results found matching the provided query.
      Return
   }

   LV_GetText(kbd, RowNumber, 3)
   LV_GetText(manu, RowNumber, 4)
   LV_GetText(funcu, RowNumber, 6)

   kbdu .= kbd!="" ? kbd : "NONE"
   kbdu := StrReplace(kbdu, "○", "Accelerator: ")
   If (omniBoxMode=1)
   {
      LV_GetText(kbdu, RowNumber, 7)
      If (kbdu>0)
         kbdu := kbdu " images"
   }

   manu := manu!="" ? " | " manu : " | ---"
   GuiControl, QuickMenuSearchGUIA:, StatusLineQuickSearch, % kbdu manu " | " funcu "()"
}

changeOptionQuickSearch(keyu) {
   Static lastInvoked := 1
   If (A_TickCount - zeitSillyPrevent<250)
      Return

   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   RowNumber := LV_GetNext(0, "F")
   totals := LV_GetCount()
   If !totals
      Return

   stepu := (A_TickCount - lastInvoked<100) ? 3 : 1
   okayu := (stepu=1) ? 1 : 0
   If InStr(keyu, "down")
      RowNumber := clampInRange(RowNumber + stepu, 1, totals, okayu)
   Else
      RowNumber := clampInRange(RowNumber - stepu, 1, totals, okayu)

   LV_Modify(RowNumber, "Select Focus Vis")
   lastInvoked := A_TickCount
   SetTimer, updateUistatusLineQuickSearch, -50
}

GoQuickSearchAction(dummy:="", isGiven:=0, ef:=0) {
   If (A_TickCount - zeitSillyPrevent<350) && (dummy!="forced")
      Return

   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   GuiControlGet, userQuickMenusEdit

   userQuickMenusEdit := Trimmer(userQuickMenusEdit)
   userQuickMenusEdit := Trimmer(StrReplace(userQuickMenusEdit, "\\", "\"), "\")
   RowNumber := LV_GetFirstSelected(hLVquickSearchMenus)
   If !RowNumber
      RowNumber := LV_GetNext(0, "F")

   If !RowNumber
      Return

   LV_GetText(funcu, RowNumber, 6)
   LV_GetText(indexu, RowNumber, 7)
   If (isGiven="yes" && ef)
      funcu := ef

   If (SubStr(funcu, 1, 1)="!")
   {
      If !InStr(funcu, "!OmniNavigate")
         closeQuickSearch()

      prevOmniBoxFolder := ""
      If (funcu="!IndexJump")
      {
         currentFileIndex := clampInRange(SubStr(userQuickMenusEdit, 2), 1, maxFilesIndex)
         dummyTimerDelayiedImageDisplay(50)
      } Else If (funcu="!OmniOpenRfolder")
      {
         OpenFolders(userQuickMenusEdit)
      } Else If (funcu="!OmniNavigateFolder")
      {
         LV_GetText(folderu, RowNumber, 1)
         newLabelu := userQuickMenusEdit "\" Trim(Trimmer(folderu), "\")
      } Else If (funcu="!OmniNavigateFilteredFolders")
      {
         LV_GetText(folderu, RowNumber, 1)
         newLabelu := SubStr(userQuickMenusEdit, 1, InStr(userQuickMenusEdit, "\", 0, -1))
         newLabelu .= "\" Trim(Trimmer(folderu), "\")
      } Else If (funcu="!OmniNavigateUpFolder")
      {
         prevOmniBoxFolder := Trim(Trimmer(SubStr(userQuickMenusEdit, InStr(userQuickMenusEdit, "\", 0, -1) + 1)), "\")
         newLabelu := SubStr(userQuickMenusEdit, 1, InStr(userQuickMenusEdit, "\", 0, -1))
      } Else If (funcu="!OmniOpenFolder")
      {
         OpenFolders("|" userQuickMenusEdit)
      } Else If (funcu="!OmniImportFolder")
      {
         addNewFolder2list(userQuickMenusEdit, "yes", "not")
         ResetImgLoadStatus()
         currentFileIndex := maxFilesIndex - 1
         dummyTimerDelayiedImageDisplay(50)
         SetTimer, TriggerMenuBarUpdate, -90
         SetTimer, createGUItoolbar, -100
      } Else If (funcu="!OmniImportRfolder")
      {
         addNewFolder2list(userQuickMenusEdit, "yes", "recursive")
         ResetImgLoadStatus()
         currentFileIndex := maxFilesIndex - 1
         dummyTimerDelayiedImageDisplay(50)
         SetTimer, TriggerMenuBarUpdate, -90
         SetTimer, createGUItoolbar, -100
      } Else If (funcu="!OmniNewInstance")
      {
         If (RegExMatch(userQuickMenusEdit, RegExFilesPattern) && FileExist(userQuickMenusEdit))
            OpenWithNewQPVinstance(0, userQuickMenusEdit, 2)
         Else
            OpenNewQPVinstance(userQuickMenusEdit)
      } Else If (funcu="!OmniOpenSLD")
      {
         OpenSLD(userQuickMenusEdit)
      } Else If (funcu="!OmniImportSLD")
      {
         If askAboutFileSave(" and the selected files list will be imported to the list")
            Return

         If StrLen(SelectedDir)>3
         {
            zPlitPath(userQuickMenusEdit, 1, fileu, SelectedDir)
            prevOpenFolderPath := SelectedDir
            INIaction(1, "prevOpenFolderPath", "General")
         }

         If (RegExMatch(userQuickMenusEdit, "i)(.\.sldb)$") && SLDtypeLoaded!=3)
            importSLDBintoPlainText(userQuickMenusEdit)
         Else If (RegExMatch(userQuickMenusEdit, "i)(.\.sldb)$") && SLDtypeLoaded=3)
            importSLDBintoSLDB(userQuickMenusEdit)
         Else If RegExMatch(userQuickMenusEdit, "i)(.\.sld)$")
            importSLDplainText(userQuickMenusEdit)

         currentFilesListModified := 1
         SetTimer, TriggerMenuBarUpdate, -90
         SetTimer, createGUItoolbar, -100
         SetTimer, ResetImgLoadStatus, -200
      } Else If (funcu="!OmniOpenImage")
      {
         If (allowRecordHistory=1)
            IniWrite, % userQuickMenusEdit, % mainSettingsFile, General, LastOpenedImg
         MenuOpenLastImg(userQuickMenusEdit)
      } Else If (funcu="!OmniImportImage")
      {
         zPlitPath(userQuickMenusEdit, 1, fileu, SelectedDir)
         mustOpenStartFolder := ""
         coreAddNewFiles(userQuickMenusEdit, 1, SelectedDir)
         GenerateRandyList()
         currentFilesListModified := 1
         currentFileIndex := maxFilesIndex
         ForceRefreshNowThumbsList()
         ResetImgLoadStatus()
         dummyTimerDelayiedImageDisplay(50)
         SetTimer, TriggerMenuBarUpdate, -90
         SetTimer, createGUItoolbar, -100
      }

      If InStr(funcu, "!OmniNavigate")
      {
         newLabelu := userQuickMenusEdit := StrReplace(newLabelu, "\\", "\")
         len := StrLen(newLabelu)
         ; ToolTip, % newLabelu "=" len "`n" userQuickMenusEdit , , , 2
         GuiControl, QuickMenuSearchGUIA:, userQuickMenusEdit, % newLabelu
         ; GuiControl, QuickMenuSearchGUIA: Focus, userQuickMenusEdit
         EM_SETSEL(hEditMenuSearch, len, len)
         SetTimer, PopulateQuickMenuSearch, -250
      }
   } Else If IsFunc(funcu)
   {
      objs := kMenu(0, "give", 0)
      mainList := objs[1]
      If !mainList[indexu, 12] ; keep panel opened or not
      {
         closeQuickSearch()
         Sleep, 3
      }
      %funcu%()
   } Else If IsLabel(funcu)
   {
      closeQuickSearch()
      Sleep, 3
      Gosub, %funcu%
   } Else
   {
      showTOOLtip("ERROR: Found no such function in the code to execute:`n" funcu "()")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

closeQuickSearch() {
   Critical, on
   lastTimeToggleThumbs := A_TickCount 
   Gui, QuickMenuSearchGUIA: Hide
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   ; hQuickMenuSearchWin := ""
   VisibleQuickMenuSearchWin := 0
   interfaceThread.ahkassign("VisibleQuickMenuSearchWin", VisibleQuickMenuSearchWin)
}

QuickMenuSearchGUIAGuiEscape:
   If (A_TickCount - lastOtherWinClose < 400)
      Return
 
   closeQuickSearch()
Return

QuickMenuSearchGUIAGuiClose:
   closeQuickSearch()
Return

QuickMenuSearchGUIAGuiSize() {     
   Critical, on
   ; (GuiHwnd, EventInfo, Width, Height)
   GetWinClientSize(Width, Height, hQuickMenuSearchWin, 0)
   If (!width || !height || VisibleQuickMenuSearchWin!=1)
      Return

   m := (PrefsLargeFonts=1) ? 10 : 8
   GuiControlGet, hBtn, QuickMenuSearchGUIA: hwnd, UIclearBtn
   GuiControlGet, hButn, QuickMenuSearchGUIA: hwnd, UImenuQSbtn
   GuiControlGet, hLine, QuickMenuSearchGUIA: hwnd, StatusLineQuickSearch
   r := GetWindowPlacement(hEditMenuSearch)
   btnW := Round(r.h * 1.5)
   SetWindowPlacement(hEditMenuSearch, m, m, Width - m*2 - btnW, r.h)
   SetWindowPlacement(hBtn, Width - m*1 - btnW, m, btnW, r.h)
   SetWindowPlacement(hLVquickSearchMenus, m, m + r.h + 1, Width - m*2, Height - m*2 - r.h*2)
   SetWindowPlacement(hLine, btnW + m, m + r.h + 1 + Height - m*1.5 - r.h*2, Width - m*2 - btnW, r.h)
   SetWindowPlacement(hButn, m, m + r.h + 1 + Height - m*1.25 - r.h*2, Round(r.h*1.3), Round(r.h*0.9))
   If determineLClickState()
      SetTimer, QuickMenuSearchGUIAGuiSize, -300
}

GetControlPosGui(WinID, ctrlID, byref x, byref y, byref w, byref h) {
   ControlGetPos, exx, eyy, w, h, , ahk_id %ctrlID%
   GetClientPos(WinID, ex, ey, eww, ehh)
   x := exx - ex,   y := eyy - ey
   ; ToolTip, % y "==" eyy "==" ey , , , 2
}

MenuUndoImgJumpy() {
   ImgUndoAction("j")
}

MenuRedoImgJumpy() {
   ImgRedoAction("j")
}

MenuIncGIFspeed() {
   changeGIFsDelayu(1)
}

MenuDecGIFspeed() {
   changeGIFsDelayu(-1)
}

MenuIncSelAreaSize() {
   changeSelectZoom(1)
}

MenuDecSelAreaSize() {
   changeSelectZoom(-1)
}

MenuIncSelAreaCavity() {
   changeSelectionAreaCavity(1)
}

MenuDecSelAreaCavity() {
   changeSelectionAreaCavity(-1)
}

testFuncIsInMenus(funcu) {
   Static lastInvoked := 1
   If (A_TickCount -lastInvoked < 200)
   {
      listu := kMenu(0, "FuncGive", 0)
      Return listu[funcu, 1]
   }

   simulateMenusMode := 1
   buildQuickSearchMenus()
   simulateMenusMode := 0
   listu := kMenu(0, "FuncGive", 0)
   lastInvoked := A_TickCount
   Return listu[funcu, 1]
}

displayFileHeaderRaw() {
   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)
   If (userPrivateMode=1)
      OutFileName := "***********." fileEXTu

   fakeWinCreator(85, A_ThisFunc, 1)
   FileRead, OutputVar, % imgPath
   kl := pp := 0
   header := ""
   Loop
   {
      pk := SubStr(OutputVar, A_Index, 1)
      If (ord(pk)>=32)
      {
         pp++
         header .= pk
      } Else
         header .= A_Space

      kl++
      If (pp>128 || kl>2048)
         Break
   }
   header := StrReplace(header, "   ", A_Space)

   kl := pp := 0
   ln := StrLen(OutputVar) + 1
   endu := ""
   Loop
   {
      pk := SubStr(OutputVar, ln - A_Index, 1)
      If (ord(pk)>=32)
      {
         pp++
         endu := pk endu
      } Else
         endu := A_Space endu

      kl++
      If (pp>128 || kl>2048)
         Break
   }
   endu := StrReplace(endu, "   ", A_Space)
   OutputVar := ""
   msgResult := msgBoxWrapper("panelu|File header: " appTitle, "File name: " OutFileName "`n`nHeader ( first readable 128 chars):`n" header "`n`nEnding (last readable 128 chars):`n" endu, 0, 0, 0, 0, 0, 0)
}

buildQuickSearchMenus() {
   deleteMenus()
   mustPreventMenus := 1
   BuildMainMenu("forced")
   If (maxFilesIndex>0)
      kMenu("PVmenu", "Add", "Show file header", "displayFileHeaderRaw")

   If (isImgEditingNow()=1 && imgEditPanelOpened=1)
      createMenuBonusImageLiveEditMode()
   Else If (!AnyWindowOpen && !drawingShapeNow)
      createMenuBonusNoImageOpened()

   zeitSillyPrevent := A_TickCount
   If (drawingShapeNow!=1)
      BuildSecondMenu()
   mustPreventMenus := 0
}

PopulateQuickMenuSearch(a:=0, b:=0, c:=0) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<350) && (a!="resel")
   {
      SetTimer, PopulateQuickMenuSearch, -150
      SetTimer, updateUistatusLineQuickSearch, -200
      Return
   }

   Gui, QuickMenuSearchGUIA: Default
   Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus
   GuiControlGet, userQuickMenusEdit
   userQuickMenusEdit := Trimmer(userQuickMenusEdit)
   userQuickMenusEdit := allowCtrlBkspEdit(hEditMenuSearch, userQuickMenusEdit)
   userQuickMenusEdit := Trimmer(StrReplace(userQuickMenusEdit, "\\", "\"), "\")
   RowNumber := LV_GetNext(0, "F")
   initialCount := LV_GetCount()
   omniBoxMode := 0
   interfaceThread.ahkassign("omniBoxMode", omniBoxMode)
   GuiControl, -Redraw, LVsearchMenus
   prevEditu := userQuickMenusEdit
   mustReselect := 0
   LV_Delete()
   allowMenuSearch := 1
   tj := SubStr(userQuickMenusEdit, 1, 1)
   ndiaz := SubStr(userQuickMenusEdit, 2)
   If (isNumber(ndiaz) && (tj="@" || tj="#") && maxFilesIndex>1 && CurrentSLD && !AnyWindowOpen)
   {
      IndexJump := 1
   } Else If (SubStr(userQuickMenusEdit, 2, 2)=":\" && !AnyWindowOpen)
   {
      pathModus := 1
      allowMenuSearch := 0
   }

   OutDir := SubStr(userQuickMenusEdit, 1, InStr(userQuickMenusEdit, "\", 0, -1))
   If (IndexJump=1)
   {
      allowMenuSearch := 0
      labelu := PathCompact(resultedFilesList[ndiaz, 1], 50)
      xu := resultedFilesList[ndiaz, 2] ? "■" : "○"
      If labelu
         LV_Add(1, labelu, xu, "-", "Files list index", "", "!IndexJump", 1, 1)
   } Else If ((FolderExist(OutDir) || FolderExist(userQuickMenusEdit)) && pathModus=1 && !RegExMatch(userQuickMenusEdit, RegExFilesPattern))
   {
      hasAddedItems := 0
      allowMenuSearch := 0
      If FolderExist(userQuickMenusEdit)
      {
         hasAddedItems += 2
         labelu1 := "Open folder"
         labelu2 := "Open folder recursively"
         LV_Add(1, labelu1, xu, "-", "-", "", "!OmniOpenFolder", 1, 8)
         LV_Add(1, labelu2, xu, "-", "-", "", "!OmniOpenRfolder", 1, 9)
         If (CurrentSLD && maxFilesIndex>1)
         {
            hasAddedItems += 2
            labelu3 := "Import folder into list"
            labelu4 := "Import folder recursively into list"
            LV_Add(1, labelu3, xu, "-", "-", "", "!OmniImportFolder", 1, 1)
            LV_Add(1, labelu4, xu, "-", "-", "", "!OmniImportRfolder", 1, 5)
         }
      }

      startOperation := A_TickCount
      setImageLoading()
      doStartLongOpDance()
      abandonAll := hasAddedSubs := 0
      showTOOLtip("Scanning for files and folders in`n" userQuickMenusEdit "\")
      GuiControl, QuickMenuSearchGUIA:, StatusLineQuickSearch, Scanning folder content...
      omniBoxMode := 1
      interfaceThread.ahkassign("omniBoxMode", omniBoxMode)
      hasAddedItems++
      filesFound := 0
      LV_Add(A_Index, "...\", xu, "-", "Folder: up-one level", "", "!OmniNavigateUpFolder", 0, 0)
      Loop, Files, % Trimmer(userQuickMenusEdit, "\") "\*", DF
      {
         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         If InStr(A_LoopFileAttrib, "D")
         {
            hasAddedSubs++
            hasAddedItems++
            LV_Add(A_Index, "\" A_LoopFileName, xu, "-", "Change folder", "", "!OmniNavigateFolder", 0, 0)
            If (A_LoopFileName=prevOmniBoxFolder && prevOmniBoxFolder)
               mustReselect := hasAddedItems
         } Else If RegExMatch(A_LoopFileFullPath, RegExFilesPattern)
            filesFound++
      }

      LV_Modify(1, "Col7", filesFound)
      LV_Modify(2, "Col7", ">" filesFound)
      If (CurrentSLD && maxFilesIndex>1)
      {
         LV_Modify(3, "Col7", filesFound)
         LV_Modify(4, "Col7", ">" filesFound)
      }

      If (!hasAddedSubs && userPrivateMode!=1 && abandonAll!=1)
      {
         restu := SubStr(userQuickMenusEdit, InStr(userQuickMenusEdit, "\", 0, -1) + 1)
         OutDir := SubStr(userQuickMenusEdit, 1, InStr(userQuickMenusEdit, "\", 0, -1))
         Loop, Files, % Trimmer(OutDir, "\") "\*", DF
         {
            executingCanceableOperation := A_TickCount
            If (determineTerminateOperation()=1)
               Break

            If (InStr(A_LoopFileAttrib, "D") && InStr(A_LoopFileName, restu) && restu!=A_LoopFileName)
               LV_Add(A_Index, "\" A_LoopFileName, xu, "-", "Change folder", "", "!OmniNavigateFilteredFolders", 0, 0)
         }
      }
      RemoveTooltip()
      ResetImgLoadStatus()
   } Else If (FileRexists(userQuickMenusEdit) && pathModus=1 && RegExMatch(userQuickMenusEdit, RegExFilesPattern))
   {
      allowMenuSearch := 0
      labelu1 := "Open image"
      labelu3 := "Open image in a new instance of QPV"
      LV_Add(1, labelu1, xu, "-", "-", "", "!OmniOpenImage", 1, 7)
      LV_Add(1, labelu3, xu, "-", "-", "", "!OmniNewInstance", 1, 3)
      If (CurrentSLD && maxFilesIndex>1)
      {
         labelu2 := "Import image into list"
         LV_Add(1, labelu2, xu, "-", "-", "", "!OmniImportImage", 1, 9)
      }
   } Else If (FileRexists(userQuickMenusEdit) && pathModus=1 && RegExMatch(userQuickMenusEdit, sldsPattern))
   {
      allowMenuSearch := 0
      labelu1 := "Open files list file"
      LV_Add(1, labelu1, xu, "-", "-", "", "!OmniOpenSLD", 1, 7)
      If (CurrentSLD && maxFilesIndex>1)
      {
         labelu2 := "Import files list"
         LV_Add(1, labelu2, xu, "-", "-", "", "!OmniImportSLD", 1, 9)
      }
   }

   zeitSillyPrevent := A_TickCount
   If (allowMenuSearch=1)
   {
      omniBoxMode := 0
      interfaceThread.ahkassign("omniBoxMode", omniBoxMode)
      buildQuickSearchMenus()
      mustPreventMenus := 0
      objs := kMenu(0, "give", 0)
      userQuery := fuzzifyString(prevEditu)
      userQuery := StrSplit(userQuery, A_Space)
      userCountWords := userQuery.Count()
      matches := score := 0
      mainList := objs[1]
      groups := objs[3]
      thisList := new hashtable()
      fzgrupu := zgrupu := accels := ""
      Gui, QuickMenuSearchGUIA: Default
      Gui, QuickMenuSearchGUIA: ListView, LVsearchMenus

      Loop, % mainList.Count()
      {
         score := 0
         groupu := mainList[A_Index, 6]
         fgroupu := mainList[A_Index, 12]
         zgrupu := Trimmer(groups[groupu, 1])
         fzgrupu := Trimmer(groups[groupu, 3])
         accels := groups[groupu, 4]
         If (zgrupu && groups[groupu, 2])
         {
            zkl := groups[groupu, 2]
            If (zkl && groups[zkl, 1])
            {
               zgrupu :=  Trimmer(groups[zkl, 1]) " \ " zgrupu
               fzgrupu .= A_Space groups[zkl, 3]
               accels := (accels && groups[zkl, 4]) ? accels ", " groups[zkl, 4] : ""
               xkl := groups[zkl, 2]
               If (xkl && groups[xkl, 2])
               {
                  zgrupu := Trimmer(groups[xkl, 1]) " \ " zgrupu
                  fzgrupu .= A_Space groups[xkl, 3]
                  accels := (accels && groups[xkl, 4]) ? accels ", " groups[xkl, 4] : ""
               }
            }
         }

         groupu := zgrupu ? " \ " zgrupu : " \ " groupu
         groupu := StrReplace(groupu, " \ PVmenu")
         fgroupu := fzgrupu ? fzgrupu : fgroupu
         fgroupu := StrReplace(fgroupu, "PVmenu")
         labelu := Trimmer(mainList[A_Index, 1])
         flabelu := mainList[A_Index, 9]
         keywords := mainList[A_Index, 3]
         fkwds := mainList[A_Index, 10]
         funcu := mainList[A_Index, 2]
         ffuncu := mainList[A_Index, 11]
         zlu := (mainList[A_Index, 4]=1 && funcu!="dummy") ? flabelu A_Space fgroupu A_Space fkwds A_Space ffuncu : ""
         ; fnOutputDebug(editF2 "===" zlu)
         haystacku := StrSplit(zlu, A_Space)
         If userQuickMenusEdit
         {
            offsetu := 0
            Loop, % userCountWords
            {
               thisUserWord := userQuery[A_Index]
               If !thisUserWord
                  Continue

               matches := 0
               If StrLen(thisUserWord)<2
               {
                  If (thisUserWord=haystacku[A_Index])
                     score += 10
                  score += ST_Count(zlu, thisUserWord)
               } Else
               {
                  If InStr(haystacku[A_Index], thisUserWord)
                     score += 15

                  score += ST_Count(zlu, thisUserWord)
                  If (thisUserWord=haystacku[A_Index])
                     score += 10

                  Loop, % haystacku.Count()
                  {
                     haysWord := haystacku[A_Index]
                     If !haysWord
                        Continue

                     offsetu += 0.006
                     score += fuzzybit(thisUserWord, haysWord, 0.85 + offsetu, exactMatch)
                     matches += exactMatch
                  }

                  If (matches>=userCountWords)
                     score += matches*2
               }
            }
            If (score<1.1)
               Continue
         }

         If (mainList[A_Index, 4] && funcu!="dummy")
         {
            kbdu := mainList[A_Index, 7]
            ; If (kbdu="" && mainList[A_Index, 8])
            ;    kbdu := "○" mainList[A_Index, 8]

            If !thisList[funcu labelu]
            {
               xu := (mainList[A_Index, 5]=1) ? "■" : ""
               If (mainList[A_Index, 5]=-1)
                  xu := "○"

               thisList[funcu labelu] := 1
               LV_Add(A_Index, labelu, xu, kbdu, StrReplace(groupu, " \ ", "\"), keywords, funcu, A_Index, Round(score*100))
            }
         }
      }
   }

   groups := thisList := mainList := ""
   ; msgp := lastLVquickSearchSortCol[1] "|" lastLVquickSearchSortCol[2]
   ; ToolTip, % msgp , , , 2
   Loop, 8
       LV_ModifyCol(A_Index, "AutoHdr Left")
   LV_ModifyCol(7, "Integer")
   LV_ModifyCol(8, "Integer")
   LV_ModifyCol(lastLVquickSearchSortCol[1], lastLVquickSearchSortCol[2])

   If (allowMenuSearch=0 && pathModus=1 && mustReselect>0 && prevOmniBoxFolder)
      LV_Modify(mustReselect, "Focus Select Vis")
   Else If (a="resel" && LV_GetCount()=initialCount && RowNumber)
      LV_Modify(RowNumber, "Focus Select Vis")
   Else
      LV_Modify(1, "Focus Select Vis")

   If !LV_GetCount()
      lastLVquickSearchSortCol := [8, "SortDesc"]

   EM_SETCUEBANNER(hEditMenuSearch, "Please type the search query here... " LV_GetCount() " options listed.", 1)

   ; prevOmniBoxFolder := ""
   mustReselect := 0
   GuiControl, +Redraw, LVsearchMenus
   zeitSillyPrevent := A_TickCount
   lastInvoked := A_TickCount
   SetTimer, updateUistatusLineQuickSearch, -50
}

fuzzifyString(toFuzz) {
   master := RegExReplace(toFuzz, "i)(e|i)", "e")
   master := RegExReplace(master, "i)(o|u)", "o")
   master := StrReplace(master, "ou", "o")
   master := StrReplace(master, "ee", "e")
   master := StrReplace(master, "oo", "o")
   master := StrReplace(master, "pp", "p")
   master := StrReplace(master, "dd", "d")
   master := StrReplace(master, "ll" , "l")
   master := StrReplace(master, "ss" , "s")
   master := StrReplace(master, "yi", "y")
   master := StrReplace(master, "  ", " ")
   Return master
}

fuzzybit(fuzz, master, limitu, ByRef exactMatch) {
/*
Name: fuzzybit
Version 1.0 (Thursday, April 23, 2020)
Created: Thursday, April 23, 2020
Author: tidbit

Description: a loose fuzzy search. 
   fuzz   = string to look for, in order
   master = where to look in
   returns a percentage. if half of the letters we found in the proper order, returns 0.5
; modified by Marius Șucan   
*/

   ; ToolTip, % master "=" fuzz , , , 2
   score := 0, posu := 1
   exactMatch := 0
   If (StrLen(master)<2)
   {
      Return 0
   } Else If (StrLen(fuzz)=1)
   {
      Return (ST_Count(master, fuzz)+1)/StrLen(master)
   } Else If (master=fuzz)
   {
      exactMatch := 5
      score := 20
   } Else If RegExMatch(master, "i)^(" fuzz ")")
   {
      exactMatch := 0.1
      score := 15
   } Else If InStr(master, fuzz)
   {
      score := 6.5
   }

   If (ST_Count(master, fuzz)>1)
      score += 0.2

   If (exactMatch=5 || score>7)
      Return score

   hasFound :=0
   ; ToolTip, % "s=" score , , , 2
   for k, char in StrSplit(fuzz)
   {
      segment := substr(master, posu)
      foundPos := inStr(segment, char)
      if (foundPos>0)
      {
         hasFound := 1
         master := segment
         score += 1
         posu := foundPos + 1
         continue ; we found a match, check the next letter to find
      }
   }
   If !hasFound
      score -= 4

   r := score/strLen(fuzz)
   If (r<limitu)
      r := 0
 
   return r
}

PanelSetSlidesMusic() {
   If !CurrentSLD
      Return

   fakeWinCreator(67, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Associate song with slideshow: " appTitle, "Please type or browse the file path of an audio file to associate with the current slideshow / files list. The selected file will be played during the slideshow.", "&Update|&Browse file|&Disassociate|&Test|&Close", 1, "audio-file", 0, 0, 0, "limit9050", SlidesMusicSong)
   AudioFileu := Trimmer(msgResult.edit)
   If (InStr(msgResult.btn, "update") && audioFileu)
   {
      If !FileExist(AudioFileu)
      {
         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         msgBoxWrapper(appTitle ": ERROR", "ERROR: Incorrect file path, inexistent audio file or access denied:`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
         ; SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelSetSlidesMusic, -150
         Return
      }
      If (SlidesMusicSong!=AudioFileu)
         currentFilesListModified := 1

      zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      SlidesMusicSong := AudioFileu
      autoPlaySlidesAudio := 1
      saveMusicSlideInfos()
      showTOOLtip("Slideshow music is now set to`n" OutFileName "`n" OutDir "\")
   } Else If (InStr(msgResult.btn, "disassociate") || (InStr(msgResult.btn, "update") && !audioFileu))
   {
      If StrLen(SlidesMusicSong)>3
         currentFilesListModified := 1
      SlidesMusicSong := ""
      autoPlaySlidesAudio := 0
      saveMusicSlideInfos()
      showTOOLtip("Slideshow music set to: NONE")
   } Else If (InStr(msgResult.btn, "test") && StrLen(SlidesMusicSong)>3)
   {
      zPlitPath(SlidesMusicSong, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      startSlidesMusicNow()
      If hSNDsong
      {
         milisec := MCI_Length(hSNDsong)
         lenghtu := MCI_ToHHMMSS(milisec)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Currently playing: " OutFileName " ( " lenghtu " ).`n`nPlease confirm you can hear the audio file.", 4, 0, "question")
         StopMediaPlaying(1)
         If (msgResult="no")
         {
            SlidesMusicSong := ""
            autoPlaySlidesAudio := 0
            saveMusicSlideInfos()
            SetTimer, PanelSetSlidesMusic, -120
            Return
         }
      } Else msgBoxWrapper(appTitle ": ERROR", "ERROR: Unable to properly decode the audio file.`n`n" OutFileName "`n" OutDir "\", 0, 0, "error")
      SetTimer, PanelSetSlidesMusic, -120
   } Else If InStr(msgResult.btn, "browse")
   {
      patternObj := {}
      patternObj["Supported audio file formarts"] := "*.wav;*.mp3;*.wma"
      startPath := StrLen(SlidesMusicSong)>3 ? SlidesMusicSong : CurrentSLD
      AudioFileu := openFileDialogWrapper("O", "FileMustExist", startPath, "Browse music file", patternObj, chosenOption, 2)
      AudioFileu := Trimmer(AudioFileu)
      If StrLen(AudioFileu)>3
      {
         If (SlidesMusicSong!=AudioFileu)
            currentFilesListModified := 1

         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         If AnyWindowOpen
            BtnCloseWindow()
         Sleep, 25
         SlidesMusicSong := AudioFileu
         autoPlaySlidesAudio := 1
         saveMusicSlideInfos()
         showTOOLtip("Slideshow music is now set to`n" OutFileName "`n" OutDir "\")
      }
      SetTimer, PanelSetSlidesMusic, -150
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

saveMusicSlideInfos() {
   If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
   {
      INIaction(1, "SlidesMusicSong", "General")
      INIaction(1, "autoPlaySlidesAudio", "General")
      currentFilesListModified := 0
   } Else If (SLDtypeLoaded=3)
   {
      IniSLDBWrite("autoPlaySlidesAudio", autoPlaySlidesAudio)
      IniSLDBWrite("SlidesMusicSong", SlidesMusicSong)
      currentFilesListModified := 0
   } Else currentFilesListModified := 1
}

fileImgFormatsOpenDialog(modus:=0) {
    patternObj := []
    patternObj["All files"] := "*.*"
    patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
    patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.ico"
    patternObj["JPEGs"] := "*.jpg;*.j2k;*.jfif;*.jng;*.jp2;*.jif;*.jxr;*.jpe;*.jpeg"
    patternObj["TIFFs"] := "*.tif;*.tiff"
    patternObj["Windows BMP"] := "*.bmp"
    patternObj["PNG"] := "*.png"
    patternObj["HDR / OpenEXR"] := "*.hdr;*.exr"
    patternObj["GDI+ supported"] := "*.bmp;*.dib;*.rle;*.jpg;*.jpeg;*.jfif;*.gif;*.tif;*.tiff;*.png;*.ico;*.wmf;*.emf"
    If (WICmoduleHasInit=1 && InStr(openFptrnWIC, "*."))
       patternObj["WIC-only supported"] := openFptrnWIC
    If (modus=1)
       patternObj["QPV slideshows"] := "*.sld;*.sldb"
    Return patternObj
}

BrowseReplaceIndexEntry() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   ; pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn3 ")"
   ; pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
   patternObj := fileImgFormatsOpenDialog(0)
   imgPath := openFileDialogWrapper("O", "FileMustExist", prevOpenFolderPath, "Replace index entry...", patternObj, chosenOption, 3)
   imgPath := Trimmer(imgPath)
   If !imgPath
   {
      SetTimer, PanelUpdateThisFileIndex, -150
      Return "cancel"
   }

   If AnyWindowOpen
      BtnCloseWindow()
   Sleep, 25
   If StrLen(imgPath)>3
   {
      zPlitPath(imgPath, 0, OutFileName, SelectedDir)
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      If askAboutFileSave(" and the current index entry will be updated")
         Return

      r := UpdateIndexBTNaction(imgPath, currentFileIndex)
      If !r
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      }
   }
   ResetImgLoadStatus()
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

SingularRenameFile() {
   PanelRenameThisFile("single")
}

coreDialogConflictsMsgBox(title, sMsg, dMsg, filez, btnList, checkBoxCaption, checkBoxState, srcInfos, extraMsg:="") {
  ; based on the msgbox2() dialog box
  ; Critical, off
  Global UsrCheckBoxu
  If !InStr(btnList, "|")
     Return

  modalHwnd := (AnyWindowOpen>0 && panelWinCollapsed!=-1) ? hSetWinGui : PVhwnd
  ownerHwnd := (AnyWindowOpen>0 && panelWinCollapsed!=-1) ? hSetWinGui : PVhwnd
  fontSize := (PrefsLargeFonts=1) ? LargeUIfontValue : 8

  oCritic := A_IsCritical 
  ; Thread, Priority, -2100
  thisHwnd := ownerHwnd ? ownerHwnd : modalHwnd
  If !thisHwnd
     thisHwnd := "mouse"

  ActiveMon := calcScreenLimits(thisHwnd)
  rMaxW := Floor(ActiveMon.w*0.95)
  rMaxH := Floor(ActiveMon.h*0.95)

  MsgBox2hwnd := 0
  MsgBox2Result := ""

  thisFontSize := !fontSize ? 8 : fontSize
  btnDim := GetMsgDimensions("Again?!", fontFace, fontSize, rMaxW, rMaxH, 1, doBold)
  bH := btnDim.h
  bH += Round(bH*0.8)
  If !bH
     bH:= Round(thisFontSize*2.5)

  minBW := Round(bH*2.5)
  btnCount := btnTotalWidth := 0
  btnDimensions := []
  If InStr(btnList, "|")
  {
     Loop, Parse, btnList, |
     {
        If !A_LoopField
           Continue
 
        btnText := Trim(A_LoopField)
        newBtnList .= btnText "|"
        If (A_Index=btnDefault)
           textbtnDefault := btnText

        btnCount++
        btnDimensions[btnCount] := GetMsgDimensions(btnText, fontFace, fontSize, rMaxW, rMaxH, 1, doBold)
        btnTotalWidth += btnDimensions[btnCount].w + bH
     }
     btnList := Trim(newBtnList, "|")
  }

  If !btnTotalWidth
     btnTotalWidth := btnDim.w + bH

  btnTotalWidth := max(btnTotalWidth, listWidth, setWidth)
  If (btnCount=0 && StrLen(btnList)>0)
     btnCount := 1

  btnDefault := !btnDefault ? 1 : btnDefault
  marginsGui := bH//2
  marginz := bH//3
  Gui, WinMsgBox: Default
  Gui, WinMsgBox: -MinimizeBox -DPIScale +HwndMsgBox2hwnd
  Gui, WinMsgBox: Margin, %marginsGui%, %marginsGui%
  If (uiUseDarkMode=1)
  {
     Gui, Color, % darkWindowColor, % darkWindowColor
     Gui, Font, c%darkControlColor%
     setDarkWinAttribs(MsgBox2hwnd)
  }
  If (fontSize>0)
     Gui, Font, s%fontSize% Q4

  If (PrefsLargeFonts=1)
     Gui, Font, Bold Q4,

  yPos := "y+" marginsGui
  xPos := "x" marginsGui
  Global UIvSmsg, UIvDmsg
  thumbu := (PrefsLargeFonts=1) ? 250 : 200
  msgW := (PrefsLargeFonts=1) ? 850 : 480
  msgH := (PrefsLargeFonts=1) ? 180 : 100
  Gui, Add, Text, %xPos% %yPos% Section, %extraMsg%File names conflict. Please choose what action to perform.

  Gui, Add, Text, xs %yPos% w1 h1 hide -wrap, Source file thumbnail
  Gui, Add, Text, xp yp w%thumbu% h%thumbu% +Border +0x1000 +0xE +hwndhConflictThumbSrc  gdummy, Preview source file
  Gui, Add, Text, x+15 w%msgW% hp -wrap +hwndhTemp vUIvSmsg gdummy, %sMsg%
  ToolTip2ctrl(hTemp, "Source file:`n" filez.st)

  Gui, Add, Text, xs %yPos% w1 h1 hide -wrap, Destination file thumbnail
  Gui, Add, Text, xp yp w%thumbu% h%thumbu% +Border +0x1000 +0xE +hwndhConflictThumbDst  gdummy, Preview destination file
  Gui, Add, Text, x+15 w%msgW% hp -wrap +hwndhTemp vUIvDmsg gdummy, %dMsg%
  ToolTip2ctrl(hTemp, "Destination file:`n" filez.dt)

  Gui, Add, Text, xs y+1 wp BackgroundTrans, %A_Space%
  If checkBoxCaption
     Gui, Add, Checkbox, xs y+10 w%msgW% Checked%checkBoxState% vUsrCheckBoxu, %checkBoxCaption%

  Loop, Parse, btnList, |
  {
      ; list specified buttons
      If !A_LoopField
         Continue

      btnText := A_LoopField
      def := (A_Index=btnDefault) ? " +Default" : ""
      thisBW := btnDimensions[A_Index].w + bH
      If (thisBW<minBW)
         thisBW := minBW

      If (A_Index=1)
      {
         Gui, Add, Button, gMsgBoxConflictEvent xp y+%marginz% w%thisBW% h%bH% %def% -wrap, %btnText%
      } Else
      {
         Gui, Add, Button, gMsgBoxConflictEvent x+5 w%thisBW% hp %def% -wrap +hwndhTempus, %btnText%
         If InStr(btnText, "auto")
            ToolTip2ctrl(hTempus, "Into the destination folder, the source file will have an added suffix.`nExample: Image_File_Name (2).jpg")
      }
  }

  Gui, Add, Text, xp yp w1 h1 BackgroundTrans,% A_Space
  If StrLen(ownerHwnd)>1
     Try Gui, +Owner%ownerHwnd%

  If modalHwnd
     WinSet, Disable,, ahk_id %modalHwnd%

  repositionWindowCenter("WinMsgBox", MsgBox2hwnd, thisHwnd, title)
  ; fnc := Func("uiPopulateConflictImgThumbs").Bind(filez.src, filez.dst, hConflictThumbSrc, hConflictThumbDst, sMsg, dMsg)
  ; SetTimer, % fnc, -50, 92000

  If checkBoxCaption
     GuiControl, WinMsgBox: Focus, UsrCheckBoxu
  Else
     GuiControl, WinMsgBox: Focus, Button%btnDefault%

  SetTimer, WatchMsgBox2Win, 300, -800
  MsgBox2Result := "wait-ask"
  hasSrc := hasDst := 0
  startu := A_TickCount
  While, (MsgBox2Result="wait-ask")
  {
     Sleep, 5
     If ((A_TickCount - startu>100) && hasSrc!=1)
     {
        uiPopulateConflictImgThumbs(filez.src, 0, hConflictThumbSrc, hConflictThumbDst, sMsg, dMsg, srcInfos)
        startu := A_TickCount
        hasSrc := 1
     }
     If ((A_TickCount - startu>100) && hasDst!=1)
     {
        uiPopulateConflictImgThumbs(0, filez.dst, hConflictThumbSrc, hConflictThumbDst, sMsg, dMsg, srcInfos)
        startu := A_TickCount
        hasDst := 1
     }
  }
  
  ; MsgBox2InputHook := InputHook("V") ; "V" for not blocking input
  ; MsgBox2InputHook.KeyOpt("{BackSpace}{Delete}{PgUp}{PgDn}{Enter}{Escape}{F4}{NumpadEnter}","N")
  ; MsgBox2InputHook.OnKeyDown := Func("MsgBox2InputHookKeyDown")
  ; MsgBox2InputHook.Start()
  ; MsgBox2InputHook.Wait()
  r := []
  Sleep, 1
  Gui, WinMsgBox: Default
  GuiControlGet, UsrCheckBoxu
  r.btn := StrReplace(MsgBox2Result, "&")
  If (MsgBox2Result="usr-dbl-clk")
     r.btn := StrReplace(textbtnDefault, "&")

  r.check := !checkBoxCaption ? 0 : UsrCheckboxu
  If modalHwnd
     WinSet, Enable,, ahk_id %modalHwnd%

  Gui, WinMsgBox: Destroy
  Sleep, 1
  If (thisHwnd && thisHwnd!="mouse")
     WinActivate, ahk_id %thisHwnd%

  SetTimer, CloseMsgBox2Win, Delete
  SetTimer, WatchMsgBox2Win, Delete
  MsgBox2hwnd := 0
  ; Critical, % oCritic 
  return r
}

MsgBoxConflictEvent(CtrlHwnd, GuiEvent, EventInfo) {
  Gui, WinMsgBox: Default
  GuiControlGet, btnFocused, WinMsgBox: FocusV
  ControlGetText, btnText, , ahk_id %CtrlHwnd%
  MsgBox2Result := btnFocused ? btnText : "close"
  MsgBox2InputHook.Stop()
}

uiPopulateConflictImgThumbs(srcFile, destFile, hwndSrc, hwndDst, sMsg, dMsg, srcInfos) {
   If !MsgBox2hwnd
      Return
 
   Gui, WinMsgBox: Default
   If srcFile
   {
      srcBitmap := LoadBitmapFromFileu(srcFile)
      If validBMP(srcBitmap)
      {
         trGdip_GetImageDimensions(srcBitmap, w, h)
         dd := "`n" groupDigits(w) " x " groupDigits(h) " | " Round((w * h)/1000000,2) " MPx"
      }

      If (srcInfos=1)
         sMsg .= dd

      GuiControl, WinMsgBox:, UIvSmsg, % sMsg
      GuiControl, WinMsgBox: +Redraw, UIvSmsg
      ToolTip2ctrl(hwndSrc, "Source image dimensions:" dd)
      If validBMP(srcBitmap)
      {
         Gdip_SetPbitmapCtrl(hwndSrc, srcBitmap, 0, 0, 1, 1)
         trGdip_DisposeImage(srcBitmap)
      }
   }
   If !MsgBox2hwnd
      Return

   If destFile
   {
      dstBitmap := LoadBitmapFromFileu(destFile)
      If validBMP(dstBitmap)
      {
         trGdip_GetImageDimensions(dstBitmap, w2, h2)
         dd := "`n" groupDigits(w2) " x " groupDigits(h2) " | " Round((w2 * h2)/1000000,2) " MPx"
      }
      dMsg .= dd
      ToolTip2ctrl(hwndDst, "Destination image dimensions:" dd)
      GuiControl, WinMsgBox:, UIvDmsg, % dMsg
      GuiControl, WinMsgBox: +Redraw, UIvDmsg
      If validBMP(dstBitmap)
      {
         Gdip_SetPbitmapCtrl(hwndDst, dstBitmap, 0, 0, 1, 1)
         trGdip_DisposeImage(dstBitmap)
      }
   }
}

askAboutFileCollision(srcFile, destFile, allowSkip, doLastOption, forceOption, ByRef performOverwrite, srcInfos:=1, extraMsg:="") {
   ; Critical, off
   Static lastOption, useLastOption := 0

   If (doLastOption=3)
   {
      lastOption := useLastOption := 0
      Return
   }

   zPlitPath(srcFile, 0, sOutFileName, sOutDir)
   zPlitPath(destFile, 0, dOutFileName, dOutDir, dfileNamuNoEXT, dFileExt)
   If (doLastOption=2)
      useLastOption := 1
   Else If (doLastOption=1)
      useLastOption := 0

   skipBtn := (allowSkip=1) ? "&Skip file|" : ""
   checkBtn := (allowSkip=1) ? "&Do not prompt again, apply the same option for all the subsequent conflicts" : ""
   If (useLastOption=1 && lastOption)
   {
      msgResult := lastOption
   } Else If !isInRange(forceOption, 1, 3)
   {
      FileGetSize, destFileSizu, % destFile, K
      FileGetSize, srcFileSizu, % srcFile, K
      FileGetTime, srcFileDateM, % srcFile, M
      FileGetTime, destFileDateM, % destFile, M

      FormatTime, srcFileDateM, % srcFileDateM, dd/MM/yyyy, HH:mm
      FormatTime, destFileDateM, % destFileDateM, dd/MM/yyyy, HH:mm
      xsrc := PathCompact(sOutDir, 49)
      xdst := PathCompact(dOutDir, 49)
      sMsg := "SOURCE FILE:`n" sOutFileName "`n" xsrc "\`n" groupDigits(srcFileSizu) " Kilobytes (" srcFileDateM ")"
      dMsg := "DESTINATION FILE:`n" dOutFileName "`n" xdst "\`n" groupDigits(destFileSizu) " Kilobytes (" destFileDateM ")"
      filez := []
      filez.st := sOutFileName "`n" sOutDir "\"
      filez.dt := dOutFileName "`n" dOutDir "\"
      filez.src := srcFile
      filez.dst := destFile
      msgResult := coreDialogConflictsMsgBox(appTitle ": File name conflict", sMsg, dMsg, filez, "&Overwrite|&Auto-rename|" skipBtn "&Cancel", checkBtn, doLastOption, srcInfos, extraMsg)
   }

   If IsObject(msgResult)
      useLastOption := msgResult.check

   If (forceOption=1)
      msgResult := "skip"
   Else If (forceOption=2)
      msgResult := "auto-rename"
   Else If (forceOption=3)
      msgResult := "overwrite"

   r := ""
   performOverwrite := 0
   msgR := IsObject(msgResult) ? msgResult.btn : msgResult
   If InStr(msgR, "rename")
   {
      performOverwrite := 2
      Loop
      {
          z := dOutDir "\" dfileNamuNoEXT " [" A_Index "]." dFileExt
          If !FileExist(z)
          {
             r := z
             Break
          }
      } Until (A_Index>9500)
   } Else If InStr(msgR, "overwrite")
   {
      performOverwrite := 1
      r := destFile
   } Else If InStr(msgR, "skip")
   {
      performOverwrite := 3
      r := ""
   } Else
   {
      lastOption := r := msgR := ""
   }

   If (InStr(msgResult.btn, "cancel") || InStr(msgResult.btn, "win_close"))
      r := "abort"

   ; fnOutputDebug("r=" r " | " msgR " || " msgResult.btn)
   ; ToolTip, % doLastOption "|" useLastOption "|" lastOption , , , 2
   lastOption := (r="abort") ? "" : msgR
   Return r
}

PanelRenameThisFile(dummy:=0) {
    Global newFileName
    Static doLastOption := 0
    If (currentFileIndex=0)
       Return

    getSelectedFiles(0, 1)
    If (markedSelectFile>1 && dummy!="single")
    {
       PanelMultiRenameFiles()
       Return
    }

    Sleep, 2
    file2rem := StrReplace(getIDimage(currentFileIndex), "||")
    zPlitPath(file2rem, 0, OutFileName, OutDir)
    resultedFilesList[currentFileIndex, 1] := file2rem
    If !FileExist(file2rem)
    {
       showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Sleep, 900
       PanelUpdateThisFileIndex()
       Return
    }
    If !doLastOption
       askAboutFileCollision(0, 0, 1, 3, 0, nullvar)

   fakeWinCreator(7, A_ThisFunc, 1)
   obju := friendlyFileUndoInfos(file2rem)
   undoBtn := (obju.typu="rename") ? "&Undo rename|" : ""
   multiBtn := (markedSelectFile>1) ? "&Multi-rename|" : ""
   fileMsg := (userPrivateMode=1) ? "" : "File location:`n" OutDir "\`n`n"
   typeu := (userPrivateMode=1) ? " Password " : ""
   msgResult := msgBoxWrapper("panelu|Rename file: " appTitle, fileMsg "Please type the new file name.", "&Rename file|" undoBtn multiBtn "&Modify index entry|C&ancel", 1, "modify-file", "On file name collision, use previously given answer", doLastOption, 0, "limit9050" typeu, OutFileName)
   If InStr(msgResult.btn, "multi")
   {
      SetTimer, PanelMultiRenameFiles, -100
   } Else If InStr(msgResult.btn, "Rename")
   {
      If InStr(msgResult.btn, "undo")
      {
         corefileUndoAction(currentFileIndex)
         Return
      }

      doLastOption := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      file2rem := getIDimage(currentFileIndex)
      zPlitPath(file2rem, 0, OutFileName, OutDir)
      If ((Trimmer(OutFileName)=newFileName) || !newFileName)
         Return

      If askAboutFileSave(" and the current file will be renamed and reloaded")
         Return

      r := BTNrenameSoloFileAct(Trimmer(msgResult.edit), file2rem, doLastOption)
      If !r 
      {
         Sleep, 100
         PanelRenameThisFile(dummy)
      } Else
      {
         file2rem := getIDimage(currentFileIndex)
         If (resultedFilesList[currentFileIndex, 5]=1)
            ToggleImgFavourites(file2rem, "rem")

         resultedFilesList[currentFileIndex, 5] := 0
         updateMainUnfilteredList(currentFileIndex, 5, 0)
         ForceRefreshNowThumbsList()
         dummyTimerDelayiedImageDisplay(50)
      }
   } Else If InStr(msgResult.btn, "modify")
   {
      fn := Func("PanelUpdateThisFileIndex").Bind("reopen")
      SetTimer, % fn, -100
   }
}

PanelSetThumbColumnOptions() {
    If (thumbsDisplaying!=1 || thumbsListViewMode>1 && thumbsDisplaying=1)
    {
       If (thumbsDisplaying!=1)
          PanelColorsAdjusterWindow()
       Return
    }

    thisBtnHeight := createSettingsGUI(40, A_ThisFunc)
    btnWid := 100, btnHeight := 25
    txtWid := slideWid := 210
    txtWid2 := txtWid + 80
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 135
       txtWid2 := txtWid2 + 195
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "fadeOtherDupeGroups", "General", 1)
    ReadSettingsVPgrid()
    slideWid2 := txtWid//2 + 10
    Global UIthumbsAratio, UIvpImgAlignCenter, UIimgFxMode
    UIimgFxMode := (imgFxMode>3) ? imgFxMode - 1 : imgFxMode
    UIvpImgAlignCenter := (imageAligned=5) ? 1 : 0
    UIthumbsAratio := thumbsAratio
    thisW := (PrefsLargeFonts=1) ? 90 : 65
    Gui, Add, Text, x15 y15 Section w%txtWid2%, Please note, most of the options listed here are shared with the full image view.
    Gui, Add, Text, xs y+15 w%slideWid2%, Flip thumbnails:
    Gui, Add, Checkbox, x+10 wp-15 gupdateUIthumbsView Checked%FlipImgH% vFlipImgH, &horizontally
    Gui, Add, Checkbox, x+10 gupdateUIthumbsView Checked%FlipImgV% vFlipImgV, &vertically
    Gui, Add, Text, xs y+15 w%slideWid2%, Highlight images:
    Gui, Add, Checkbox, x+10 wp-15 gupdateUIthumbsView Checked%highlightAlreadySeenImages% vhighlightAlreadySeenImages, &already seen
    Gui, Add, Checkbox, x+10 gupdateUIthumbsView Checked%markSearchMatches% vmarkSearchMatches, &matching search query
    GuiAddDropDownList("xs y+15 w" txtWid " gupdateUIthumbsView AltSubmit Choose" UIimgFxMode " vUIimgFxMode", "Original image colors|Personalized colors|Grayscale|Red channel|Green channel|Blue channel|-|Inverted colors|Sepia", "Viewport color adjustments mode")
    Gui, Add, Button, x+5  w%thisW% hp vbtnFldr1 gHardResetImageView, &Reset
    GuiAddDropDownList("xs y+5 w" txtWid " gupdateUIthumbsView AltSubmit Choose" usrColorDepth " vusrColorDepth", "Default color depth|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]", "Simulate viewport color depth")
    Gui, Add, Checkbox, x+5 hp gupdateUIthumbsView Checked%ColorDepthDithering% vColorDepthDithering, Dithering
    GuiAddDropDownList("xs y+5 w" slideWid2 " AltSubmit gupdateUIthumbsView Choose" UIthumbsAratio " vUIthumbsAratio", "Wide (1.81)|Tall (0.48)|Square (1.00)", "Thumbnails aspect ratio")
    Gui, Add, Checkbox, x+10 hp gupdateUIthumbsView Checked%UIvpImgAlignCenter% vUIvpImgAlignCenter, &Centered alignment
    Gui, Add, Checkbox, xs y+10 gupdateUIthumbsView Checked%fadeOtherDupeGroups% vfadeOtherDupeGroups, Fade the other groups of image duplicates
    Gui, Add, Checkbox, xs y+10 gupdateUIthumbsView Checked%multilineStatusBar% vmultilineStatusBar, Two lines status bar
    Gui, Add, Checkbox, xs y+10 gupdateUIthumbsView Checked%thumbsModeItemHighlight% vthumbsModeItemHighlight, Solid active item hilighting
    Gui, Add, Text, xs y+15 hp +0x200 w%slideWid2%, Thumbnail columns:
    GuiAddEdit("x+10 w70 gupdateUIthumbsView number -multi limit3 veditF5", thumbsColumns)
    Gui, Add, UpDown, gupdateUIthumbsView vthumbsColumns Range2-99, % thumbsColumns
    Gui, Add, Text, xs+15 y+7 w%txtWid2%, You can press the + / - keys or Ctrl + Wheel Up / Down to increase or decrease the number of columns.

    If !testIsDupesList()
       GuiControl, SettingsGUIA: Disable, fadeOtherDupeGroups

    If (mustRecordSeenImgs!=1)
       GuiControl, SettingsGUIA: Disable, highlightAlreadySeenImages

    If StrLen(userSearchString)<2
       GuiControl, SettingsGUIA: Disable, markSearchMatches

    If (minimizeMemUsage=1)
       GuiControl, SettingsGUIA: Disable, imgFxMode

    Gui, Add, Button, xs y+25 w%thisW% h%thisBtnHeight% Default gBtnCloseWindow, &Close
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Thumbnails options: " appTitle, winPos)
}

updateUIthumbsView() {
   If (AnyWindowOpen!=40)
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   GuiControlGet, UIvpImgAlignCenter
   GuiControlGet, UIthumbsAratio
   GuiControlGet, UIimgFxMode
   imgFxMode := (UIimgFxMode>2) ? UIimgFxMode + 1 : UIimgFxMode
   act := (usrColorDepth>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, ColorDepthDithering
   act := (imgFxMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, btnFldr1

   ; thumbsColumns := editF5
   imageAligned := (UIvpImgAlignCenter=1) ? 5 : 1
   thumbsAratio := clampInRange(UIthumbsAratio, 1, 3)
   defineColorDepth()
   recalculateThumbsSizes()
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   ; SetTimer, DeepRefreshThumbsNow, -50
   SetTimer, WriteThumbnailsSettingsPanel, -200
}

WriteThumbnailsSettingsPanel() {
   INIaction(1, "ColorDepthDithering", "General")
   INIaction(1, "fadeOtherDupeGroups", "General")
   INIaction(1, "FlipImgH", "General")
   INIaction(1, "FlipImgV", "General")
   INIaction(1, "highlightAlreadySeenImages", "General")
   INIaction(1, "imageAligned", "General")
   INIaction(1, "imgFxMode", "General")
   INIaction(1, "markSearchMatches", "General")
   INIaction(1, "multilineStatusBar", "General")
   INIaction(1, "thumbsAratio", "General")
   INIaction(1, "thumbsColumns", "General")
   INIaction(1, "usrColorDepth", "General")
   INIaction(1, "thumbsModeItemHighlight", "General")
}

PanelSetSystemCores() {
   EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
   fakeWinCreator(41, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Multi-threading options: " appTitle, "Please specify the number of threads to use when generating thumbnails and for batch processing of files. Maximum allowed threads on this system is " thisSystemCores ".`n`nAfter changing this value, a restart of QPV might be necessary.", "&Apply|&Cancel", 1, "gear", "Generate thumbnails using multiple threads [experimental]", allowMultiCoreMode, 0, "limit2 number", userMultiCoresLimit)
   If InStr(msgResult.btn, "apply")
   {
      allowMultiCoreMode := msgResult.check
      userMultiCoresLimit := Trimmer(msgResult.edit)
      userMultiCoresLimit := clampInRange(userMultiCoresLimit, 2, thisSystemCores)
      INIaction(1, "allowMultiCoreMode", "General")
      INIaction(1, "userMultiCoresLimit", "General")
      realSystemCores := userMultiCoresLimit
      If (thumbsDisplaying=1 && thumbsListViewMode=1 && multiCoreThumbsInitGood="n")
         initAHKhThumbThreads()
      ; dummyTimerDelayiedImageDisplay(50)
   }
}

PanelSaveSlideShowu() {
    Global userDesiredSlideFMT := 1

    If (maxFilesIndex<2)
    {
       showTOOLtip("WARNING: Insufficient image files are indexed")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    thisBtnHeight := createSettingsGUI(36, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 360
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    showSave := (SLDtypeLoaded>1 && FileRexists(CurrentSLD)) || InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") ? 1 : 0
    INIaction(0, "prevFileSavePath", "General", 6)
    userDesiredSlideFMT := (SLDtypeLoaded=3) ? 2 : 1
    If (SLDtypeLoaded=3)
       SLDcacheFilesList := 1

    dlWid := editWid - btnWid2
    Gui, Add, Text, x15 y15 Section +0x200 +hwndhTemp, Slideshow format for save as:
    GuiAddDropDownList("xs y+5 w" dlWid " gUItoggleSLDformat AltSubmit Choose" userDesiredSlideFMT " vuserDesiredSlideFMT", ".SLD - Plain-text format|.SLDB - SQLite Database format (file details cached)", [hTemp])
    If (showSave=1)
       Gui, Add, Button, x+1 hp w%btnWid2% gBTNsaveSlideshowPanel, Save &as

    Gui, Add, Checkbox, xs y+10 Checked%SLDcacheFilesList% vSLDcacheFilesList, Cache files list (ensures rapid slideshow loading)`nIf this is left unchecked, only the dynamic folders list will be saved.
    If (SLDtypeLoaded=3)
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList

    ; Gui, Add, Checkbox, xs y+10 Checked%ForceRegenStaticFolders% vForceRegenStaticFolders, Regenerate static folders list`nThe static folders list enables partial files list later updates
    Gui, Add, Text, xs y+10 w%EditWid%, Regardless of the chosen format, the current %appTitle% settings will be stored.
    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
       infoThisSLD := "Currently opened: «Favourite images list» (plain-text)."
    Else If (SLDtypeLoaded=2)
       infoThisSLD := "Currently opened: plain-text files list`n" CurrentSLD
    Else If (SLDtypeLoaded=3)
       infoThisSLD := "Currently opened: SQLite database files list`nMost actions applied on the files index are automatically saved. Under rare circumstances resaving is required.`n" CurrentSLD
    Else
       infoThisSLD := "No saved files list currently opened."

    If (SLDtypeLoaded=2 && currentFilesListModified=1)
       infoThisSLD .= "`nFiles list has been modified. The changes are unsaved."

    btnWid3 := InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") ? 2 : btnWid
    Gui, Add, Text, xs y+20 w%EditWid%, % infoThisSLD
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid3% gBTNopenPanelDynamicFolderzWindow, &Manage folders

    If (showSave=1)
       Gui, Add, Button, x+5 hp w%btnWid2% Default gBTNsaveCurrentSlideshow, &Save
    Else
       Gui, Add, Button, x+5 hp w%btnWid2% Default gBTNsaveSlideshowPanel, Save &as

    If (maxFilesIndex>1 && CurrentSLD && dbVersion!=dbExpectedVersion && SLDtypeLoaded=3)
       Gui, Add, Button, x+5 hp w%btnWid2% gBTNrebuildDBpanel, &Rebuild

    Gui, Add, Button, x+15 hp w%btnWid2% gBTNhelpSlideshows, &Help
    Gui, Add, Button, x+5 hp wp-5 gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save indexed files list: " appTitle)
    checkDLLfiles()
}

BTNrebuildDBpanel() {
    msgResult := msgBoxWrapper(appTitle ": WARNING", "This database was saved by an older version of " appTitle ". The entire index structure needs to be rebuilt. QPV will now recreate this database with the new structure.`n`nPlease note: all the cached data pertaining to the indexed images will be lost.", "&Continue|C&ancel", 2, "exclamation")
    If !InStr(msgResult, "continue")
       Return

    BtnCloseWindow()
    rebuildDBfilesList()
}

BTNhelpSlideshows() {
    msgu := "In the plain-text SLD format QPV can store:`n- the settings pertaining to the viewport and slideshow`n- a folders list [so-called «main» folders list]; "
    msgu .= "this is the source of the files list and can be [re]scanned at any time.`n- the actual files list. If it is not cached / present when the SLD is opened, the main folders "
    msgu .= "list will be scanned for images to populate the files list index.`n- a «static» folders list; this list is automatically generated when the SLD is saved based on the indexed "
    msgu .= "files' paths - only if the user chooses to cache the files list. In later sessions, one can rescan any of these folders, allowing users to selectively update the files list "
    msgu .= "whenever needed.`n`nIn addition to all of the above, the SQL-Lite database SLDB format can store:`n- image captions [no need for external text files] and also allows users "
    msgu .= "to attach audio files to image files without the constraint of having them located in the same folder(s) with the image(s).`n- file and image details cache: file size, file "
    msgu .= "date created, modified, image information (resolution, pixel format, histogram details and so on)`n`nThe caching of data facilitates management of large image collections, "
    msgu .= "because files list sorting, image and file statistics are performed MUCH faster once the data is cached. The cached data is stored and reused between sessions and can be "
    msgu .= "generated gradually in multiple QPV sessions."
    msgBoxWrapper(appTitle ": HELP", msgu, -1, 0, 0)
}

BTNopenPanelDynamicFolderzWindow() {
    PanelDynamicFolderzWindow("reopen")
}

BTNsaveCurrentSlideshow() {
    BtnCloseWindow()
    Sleep, 1
    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
       saveFavesListBasedOnIndexList()
    Else If (SLDtypeLoaded=2 && FileRexists(CurrentSLD) && maxFilesIndex>0)
       SaveFilesList(CurrentSLD)
    Else If (SLDtypeLoaded=3 && FileRexists(CurrentSLD) && maxFilesIndex>0)
       SaveDBfilesList(CurrentSLD)
    Else If (maxFilesIndex>1 && CurrentSLD)
       PanelSaveSlideShowu()
    ; BtnCloseWindow()
}

UItoggleSLDformat() {
    GuiControlGet, userDesiredSlideFMT
    If (userDesiredSlideFMT=1)
    {
       GuiControl, SettingsGUIA: Enable, SLDcacheFilesList
    } Else
    {
       SLDcacheFilesList := 1
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList
       GuiControl, , SLDcacheFilesList, 1
    }
}

BTNsaveSlideshowPanel() {
    Gui, SettingsGUIA: Default
    GuiControlGet, SLDcacheFilesList
    GuiControlGet, userDesiredSlideFMT
    If (userDesiredSlideFMT=1)
       SaveFilesList()
    Else
       SaveDBfilesList()

    RecentFilesManager(CurrentSLD)
}

FolderExist(filePath) {
   If StrLen(filePath)<4
      Return
   Else
      Return InStr(FileExist(filePath), "D")
}

PanelExtractFrames() {
    If (thumbsDisplaying!=1)
    {
       If throwErrorNoImageLoaded()
          Return
    }

    thisBtnHeight := createSettingsGUI(84, A_ThisFunc)
    RegAction(0, "ResizeDestFolder",, 6)
    RegAction(0, "userExtractFramesFmt",, 2, 1, 15)
    RegAction(0, "userJpegQuality",, 2, 1, 100)
    btnWid := 100
    txtWid := 330
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := (PrefsLargeFonts=1) ? btnWid - 40 : btnWid - 25
    RegAction(0, "userJpegQuality",, 2, 1, 100)
    filesElected := getSelectedFiles(0, 1)
    UserCropOnSave := 0
    depthChoice := (currIMGdetails.HasAlpha=1) ? 1 : 2
    thisWid := (PrefsLargeFonts=1) ? 70 : 45
    ml := (PrefsLargeFonts=1) ? 190 : 150
    ; Gui, Add, Checkbox, Checked%UserCropOnSave% vUserCropOnSave, C&rop image to selected area on save
    Gui, Add, Text, x15 y15 Section, Save options:
    ; Gui, Add, Text, xs y+0 wp h2 +0x1007, 
    Gui, Add, Text, xp+15 y+7 w%ml% hp+5 +0x200, Image quality `%:
    GuiAddEdit("x+10 w" thisWid " number -multi limit3 veditF5", userJpegQuality)
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    thisWid := (PrefsLargeFonts=1) ? 145 : 115
    Gui, Add, Text, xs+15 y+7 w%ml% hp +0x200 +hwndhTemp, Color depth:
    GuiAddDropDownList("x+10 w" thisWid " AltSubmit Choose" depthChoice " vuserSaveBitsDepth", "32 bits RGBA|24 bits RGB|16 bits RGB|8 bits RGB [256 colors]", [hTemp])
    sml := (PrefsLargeFonts=1) ? 40 : 30
    GuiAddButton("x+5 w" sml " hp gbtnHelpSaveImgPanel", " ?", "Help")
    Gui, Add, Text, xs+15 y+7 w%ml% +0x200 +hwndhTemp -wrap, File format on save:
    thisWid := (PrefsLargeFonts=1) ? 110 : 80
    GuiAddDropDownList("x+10 w" thisWid " AltSubmit Choose" userExtractFramesFmt " vuserExtractFramesFmt", userPossibleWriteFMTs, [hTemp])
    Gui, Add, Text, xs y+10 hp w%ml% +0x200, Folder destination:
    thisWid := (PrefsLargeFonts=1) ? 105 : 65
    ml := (PrefsLargeFonts=1) ? 250 : 205
    GuiAddEdit("xp+15 y+5 w" ml " r1 -Border right -wrap vResizeDestFolder", ResizeDestFolder)
    Gui, Add, Button, x+5 hp w%thisWid% gBTNchangeResizeDestFolder vbtnFldr, C&hoose

    thisW := (PrefsLargeFonts=1) ? 155 : 115
    Gui, Add, Text, xs+15 y+10 +0x200 +hwndhTemp, Action on file name collisions:
    GuiAddDropDownList("x+10 w" thisW " AltSubmit Choose" OnExtractConflictOverwrite " vOnExtractConflictOverwrite", "Skip files|Auto-rename|Overwrite|Ask user", [hTemp])
    If (filesElected>1)
       Gui, Add, Text, xs y+20, % groupDigits(filesElected) " files are selected."

    ; GuiControl, SettingsGUIA: Disable, ResizeDestFolder
    btnWid2 := (PrefsLargeFonts=1) ? btnWid - 40 : btnWid - 25
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBTNperformExtractFrames, &Proceed
    If (filesElected>1)
       Gui, Add, Button, x+5 hp wp gBTNperformExtractFrames, &Active file only
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Extract frames: " appTitle)
}

BtnChangeMultiPageFmt() {
   If (AnyWindowOpen!=75)
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   actu := (userCombineFramesFmt=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, txtLine2
   GuiControl, % actu, userCombineGIFframeDelay
   GuiControl, % actu, editF5

   actu := (userCombineFramesFmt=2) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, txtLine1
   GuiControl, % actu, userSaveBitsDepth

   actu := (userCombineFramesFmt=3) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, txtLine3
   GuiControl, % actu, txtLine4
   GuiControl, % actu, txtLine5
   GuiControl, % actu, UserCombinePDFpageSize
   GuiControl, % actu, ResizeApplyEffects
   GuiControl, % actu, combinePDFpageHighQuality
   GuiControl, % actu, combinePDFpageLandscape
   GuiControl, % actu, editF6
   GuiControl, % actu, userJpegQuality
   GuiControl, % actu, TextInAreaAlign
   GuiControl, % actu, TextInAreaValign
}

PanelCombineImagesMultipage() {
    Static hasOpened := 0
    If !hasOpened
    {
       TextInAreaAlign := TextInAreaValign := 2
       userSaveBitsDepth := 5
    }

    filesElected := getSelectedFiles(0, 1)
    If !filesElected
    {
       showTOOLtip("WARNING: Insufficient files selected to join.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(75, A_ThisFunc)
    btnWid := 100
    txtWid := 330
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsCombineIMGs()
    ; btnWid2 := (PrefsLargeFonts=1) ? btnWid - 40 : btnWid - 25
    ; depthChoice := (currIMGdetails.HasAlpha=1) ? 1 : 2
    thisWid := (PrefsLargeFonts=1) ? 70 : 45
    ml := (PrefsLargeFonts=1) ? 275 : 175
    ; Gui, Add, Checkbox, Checked%UserCropOnSave% vUserCropOnSave, C&rop image to selected area on save
    Gui, Add, Text, x15 y15 Section, Please choose the multi-page format.`nThe newly created file will contain the selected images.
    ; Gui, Add, Text, xs y+0 wp h2 +0x1007, 
    Gui, Add, Text, xs+15 y+10 w%ml% +0x200 +hwndhTemp, File format on save:
    GuiAddDropDownList("x+1 w" thisWid " gBtnChangeMultiPageFmt AltSubmit Choose" userCombineFramesFmt " vuserCombineFramesFmt", ".gif|.tiff|.pdf", [hTemp])
    Gui, Add, Checkbox, xs+30 y+5 hp Checked%userCombineSubFrames% vuserCombineSubFrames, Join contained frames from selected files
    thisWid := (PrefsLargeFonts=1) ? 145 : 115
    Gui, Add, Text, xs+15 y+10 w%ml% hp +0x200 vtxtLine1 +hwndhTemp, TIFF maximum color depth:
    GuiAddDropDownList("x+1 w" thisWid " AltSubmit Choose" userSaveBitsDepth " vuserSaveBitsDepth", "32 bits RGBA|24 bits RGB|16 bits RGB|8 bits RGB [256 colors]", [hTemp])
    Gui, Add, Checkbox, x+5 hp Checked%userCombineDepthDithering% vuserCombineDepthDithering, Dithering
    Gui, Add, Text, xs+15 y+10 w%ml% hp +0x200 vtxtLine2, GIFs frames delay (in milisec.)
    thisWid := (PrefsLargeFonts=1) ? 70 : 45
    GuiAddEdit("x+1 w" thisWid " number -multi limit4 veditF5", userCombineGIFframeDelay)
    Gui, Add, UpDown, vuserCombineGIFframeDelay Range1-9500, % userCombineGIFframeDelay
    thisWid := (PrefsLargeFonts=1) ? 145 : 115
    Gui, Add, Text, xs+15 y+10 w%ml% hp +0x200 vtxtLine3 +hwndhTemp, PDF page size:
    GuiAddDropDownList("x+1 w" thisWid " AltSubmit Choose" UserCombinePDFpageSize " vUserCombinePDFpageSize", "A4 (1.41)|Business Card (0.63)|Poster (1.33)|Letter (1.29)|Ledger (1.54)|Legal (1.65)", [hTemp])
    Gui, Add, Checkbox, x+5 hp Checked%combinePDFpageLandscape% vcombinePDFpageLandscape, Landscape
    thisWid := (PrefsLargeFonts=1) ? 90 : 65
    ml -= 15
    Gui, Add, Text, xs+30 y+10 w%ml% hp +0x200 vtxtLine4, Image alignment on page:
    GuiAddDropDownList("x+1 w" thisWid " Choose" TextInAreaAlign " AltSubmit vTextInAreaAlign", "Left|Center|Right", "Text horizontal alignment")
    GuiAddDropDownList("x+5 wp Choose" TextInAreaValign " AltSubmit vTextInAreaValign", "Top|Center|Bottom", "Text vertical alignment")
    Gui, Add, Checkbox, xs+30 y+10 Checked%combinePDFpageHighQuality% vcombinePDFpageHighQuality, High resolution pages (192 dpi)
    Gui, Add, Checkbox, xs+30 y+10 gTglRszApplyEffects Checked%ResizeApplyEffects% vResizeApplyEffects, Apply viewport color adjustments and effects
    thisWid := (PrefsLargeFonts=1) ? 70 : 45
    Gui, Add, Text, xs+30 y+7 w%ml% hp+5 +0x200 vtxtLine5, Image quality `%:
    GuiAddEdit("x+1 w" thisWid " number -multi limit3 veditF6", userJpegQuality)
    Gui, Add, UpDown, vuserJpegQuality Range3-97, % userJpegQuality
    thisWid := (PrefsLargeFonts=1) ? 145 : 115

    Gui, Font, Bold
    ml := (PrefsLargeFonts=1) ? 20 : 10
    If (filesElected>1)
       Gui, Add, Text, xs y+%ml%, % groupDigits(filesElected) " files are selected."

    If (filesElected>=maxMultiPagesAllowed)
       Gui, Add, Text, xs y+%ml%, The resulted file will be limited to %maxMultiPagesAllowed% frames / pages.

    Gui, Font, Normal
    ; GuiControl, SettingsGUIA: Disable, ResizeDestFolder
    ; btnWid2 := (PrefsLargeFonts=1) ? btnWid - 40 : btnWid - 25
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBTNperformCombineIMGs, &Join images
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBtnHelpCombineImgs, &Help
    Gui, Add, Button, x+5 hp w%btnWid2% gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Join images into a single file: " appTitle)
    SetTimer, BtnChangeMultiPageFmt, -100
}

BtnHelpCombineImgs() {
   msgBoxWrapper(appTitle ": HELP", "This tool allows users to combine multiple images into one image. GIF, TIFF and PDF formats are the supported destination formats.`n`nIf any of the selected files has multiple frames or pages and the option «Join contained frames from selected files», these pages will be processed and become part of the newly created file.`n`nThe resulted order of the pages will reflect the order of originally selected files.`n`nFor proper GIF animations, please select files having the same resolution. Please note, GIF export option is EXPERIMENTAL.`n`nPDFs without the «high resolution» option selected will have a DPI of 96. The images are embedded as JPEGs in the PDF. To influence the size of the resulted PDF, you must change the JPEG quality level.`n`nThe TIFFs created use the LZW compression method.", -1, 0, 0)
}

BTNperformCombineIMGs() {
   Static fmtz := {1:"gif", 2:"tiff", 3:"pdf"}
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   GuiControlGet, userJpegQuality
   BtnCloseWindow()
   f := fmtz[userCombineFramesFmt]
   IniAction(1, "prevFileSavePath", "General", 6)
   RegAction(1, "userJpegQuality")
   animus := (userCombineFramesFmt=1) ? 1 : 0
   file2save := openFileDialogWrapper("S", "PathMustExist", prevFileSavePath, "Choose ." f " file destination", f " files (*." f ")|All (*.*)", 1, 1)
   If !file2save
   {
      SetTimer, PanelCombineImagesMultipage, -250
      Return
   }

   If (!RegExMatch(file2save, "i)(.\." f ")$") && file2save)
      file2save .= "." f

   zPlitPath(file2save, 0, OutFileName, OutDir)
   prevFileSavePath := OutDir
   IniAction(1, "prevFileSavePath", "General", 6)
   WriteSettingsCombineIMGs()
   ; prevFileSavePath := file2save
   ; MsgBox, % A_ThisFunc "()`n" file2save
   If (userCombineFramesFmt=2)
      combineImagesMultiTiffGDIp(file2save)
   Else If (userCombineFramesFmt=3)
      CombineImgsIntoPDF(file2save)
   Else
      combineImagesMultiPage(userSaveBitsDepth, animus, file2save)
}

CombineImgsIntoPDF(file2save) {
   If (markedSelectFile>1)
   {
      zPlitPath(file2save, 0, OutFileName, OutDir)
      tempusDir := OutDir "\qpv-tmp-pdf-generator"
      If !FolderExist(tempusDir)
      {
         FileCreateDir, % tempusDir
         If ErrorLevel
         {
            showTOOLtip("ERROR: Unable to create temporary folder required to create the PDF.`nOperation abandoned.")
            SoundBeep 300, 100
            SetTimer, RemoveTooltip, % -msgDisplayTime
            Return
         }
      }

      ; process images to suit the desired page layout
      Static pageSizesH := {1:2245, 2:416, 3:3840, 4:2112, 5:3264, 6:2688}
           , pageSizesW := {1:1587, 2:657, 3:2880, 4:1632, 5:2112, 6:1632}
      Static pageSizesInchH := {1:11.69, 2:2.16, 3:20, 4:11, 5:17, 6:14}
           , pageSizesInchW := {1:8.27, 2:3.42, 3:15, 4:8.5, 5:11, 6:8.5}

      pageW := (combinePDFpageLandscape=1) ? pageSizesH[UserCombinePDFpageSize] : pageSizesW[UserCombinePDFpageSize]
      pageH := (combinePDFpageLandscape=1) ? pageSizesW[UserCombinePDFpageSize] : pageSizesH[UserCombinePDFpageSize]
      If (combinePDFpageHighQuality!=1)
      {
         pageW := pageW // 2
         pageH := pageH // 2
      }

      dpi := (combinePDFpageHighQuality=1) ? 192 : 96
      newBitmap := trGdip_CreateBitmap(A_ThisFunc, pageW, pageH)
      If validBMP(newBitmap)
         G := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)

      If (FileExist(file2save) && G)
      {
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The destination file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult="Yes")
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            Try FileDelete, %file2save%
            Catch wasErrorB
                  Sleep, 1

            If wasErrorB
            {
               abandoned := 1
               msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file: " OutFileName ". Permission denied.`n`nLocation:`n" OutDir "\", 0, 0, "error")
            }
         } Else abandoned := 1
      }

      If (!G || abandoned=1)
      {
         If tempusDir
            FileRemoveDir, % tempusDir, 1

         If (abandoned!=1)
            showTOOLtip("ERROR: Failed to create the PDF page layout required to process images")

         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         ResetImgLoadStatus()
         Return
      }

      Gdip_BitmapSetResolution(newBitmap, dpi, dpi)
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      doStartLongOpDance()
      fileIndex := thisIndex := failedFiles := 0
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      tempList := []
      showTOOLtip("Phase 1: Processing the PDF pages, please wait")
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
            Continue

         mainIndex := A_Index
         imgPath := resultedFilesList[A_Index, 1]
         ; zPlitPath(file2save, 0, OutFileName, OutDir)
         pBitmap := LoadBitmapFromFileu(imgPath)
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>3000)
         {
            etaTime := ETAinfos(A_Index, markedSelectFile, startOperation)
            If (failedFiles>0)
               etaTime .= "`nFailed to process " groupDigits(failedFiles) " images"

            showTOOLtip("Phase 1: Processing images into PDF pages, please wait`n" OutFileName "`nImages processed: " groupDigits(thisIndex) etaTime, 0, 0, A_Index / markedSelectFile)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1 || abandonAll=1)
         {
            abandonAll := 1
            Break
         }

         If validBMP(pBitmap)
         {
            totalFlames := (userCombineSubFrames=1) ? mainLoadedIMGdetails.Frames + 1 : 1
            Loop, % totalFlames
            {
               If (A_Index>1)
               {
                  pBitmap := LoadBitmapFromFileu(imgPath, 0, 0, A_Index - 1)
                  If (determineTerminateOperation()=1)
                  {
                     abandonAll := 1
                     Break
                  }
               }

               If ((A_TickCount - prevMSGdisplay>3500) && yay=1)
               {
                  etaTime := ETAinfos(mainIndex, markedSelectFile, startOperation)
                  If (failedFiles>0)
                     etaTime .= "`nFailed to process " groupDigits(failedFiles) " images"

                  showTOOLtip("Phase 1: Processing images into PDF pages, please wait`n" OutFileName "`nImages processed: " groupDigits(thisIndex) etaTime, 0, 0, A_Index / totalFlames)
               }

               yay := !yay
               Gdip_GraphicsClear(G, "0xffFFFFFF")
               trGdip_GetImageDimensions(pBitmap, imgW, imgH)
               calcIMGdimensions(imgW, imgH, pageW, pageH, ResizedW, ResizedH)
               posX := posY := 0
               If (TextInAreaAlign=2)
                  posX := Round(pageW/2 - ResizedW/2)
               If (TextInAreaValign=2)
                  posY := Round(pageH/2 - ResizedH/2)
               If (TextInAreaAlign=3)
                  posX := pageW - ResizedW
               If (TextInAreaValign=3)
                  posY := pageH - ResizedH

               If (ResizeApplyEffects=1)
               {
                  pBitmap := applyVPeffectsOnBMP(pBitmap, 1, mainLoadedIMGdetails.HasAlpha, "y")
                  flipBitmapAccordingToViewPort(pBitmap)
               }
 
               fileIndex++
               trGdip_DrawImage(A_ThisFunc, G, pBitmap, posX, posY, ResizedW, ResizedH)
               pBitmap := trGdip_DisposeImage(pBitmap, 1)
               f := Gdip_SaveBitmapToFile(newBitmap, tempusDir "\" fileIndex ".jpg", userJpegQuality)
               If f
               {
                  failedFiles++
               } Else
               {
                  thisIndex++
                  tempList[thisIndex] := fileIndex
               }

               If (thisIndex>=maxMultiPagesAllowed)
               {
                  showTOOLtip("WARNING: Maximum allowed pages limit reached: " maxMultiPagesAllowed)
                  SoundBeep 300, 100
                  fattalErr := 1
                  Sleep, 2000
                  Break
               }
            }
            If fattalErr
               Break
         } Else failedFiles++
         ; fnOutputDebug("zzz=" pBitmap " | " f " | " A_LoopFileLongPath)
      }

      z := Round(tempList.Count())
      Gdip_DeleteGraphics(G)
      trGdip_DisposeImage(newBitmap)
      ResetImgLoadStatus()
      If (z>1 && abandonAll!=1)
      {
         setImageLoading()
         VarSetCapacity(fListArray, 8 * z + 1, 0)
         Loop, % z
            NumPut(tempList[A_Index], fListArray, (A_Index - 1) * 4, "uint")

         showTOOLtip("Phase 2: Saving the PDF file, please wait`n" groupDigits(z) " images to be embedded")
         pageWpdf := (combinePDFpageLandscape=1) ? pageSizesInchH[UserCombinePDFpageSize] : pageSizesInchW[UserCombinePDFpageSize]
         pageHpdf := (combinePDFpageLandscape=1) ? pageSizesInchW[UserCombinePDFpageSize] : pageSizesInchH[UserCombinePDFpageSize]
         ; fnOutputDebug("pdf dll precall = " z)
         r := DllCall(whichMainDLL "\CreatePDFfile", "AStr", tempusDir, "AStr", file2save, "AStr", mainCompiledPath, "UPtr", &fListArray, "int", z, "float", pageWpdf, "float", pageHpdf, "Int", dpi)
         ; fnOutputDebug("pdf dll call = " r)
      } Else If (abandonAll=1)
         z := 0

      If (failedFiles>0)
         rr .= "`nFailed to load " groupDigits(failedFiles) " images out of " groupDigits(filesElected)

      OutputVar := "a"
      erm := "Failed to create the PDF file. "
      If (z<=1 && abandonAll!=1)
      {
         showTOOLtip(erm "No image was succesfully processed.")
      } Else If (r<0)
      {
         If (r=-1)
            showTOOLtip(erm "Init_BeginPDFdocument() failure. Error code: " r)
         Else If (r=-2)
            showTOOLtip(erm "Unable to locate the destination folder. Error code: " r)
         Else If (r=-6)
            showTOOLtip(erm "Error encountered when writing to the disk. Error code: " r)
         Else If (r=-7)
            showTOOLtip(erm "PDF_GetFinalDocument() failure. Error code: " r)
         Else
            showTOOLtip("Failed to properly create the PDF file. Error code: " r rr)
      } Else If (abandonAll=1)
      {
         showTOOLtip("Operation aborted by user. No .PDF file was created.")
      } Else If z
      {
         FileGetSize, OutputVar, % file2save
         If (r>0)
            moreInfos := " out of " groupDigits(z)

         xu := (r>=0) ? groupDigits(z - r) : 0
         If (OutputVar>400)
         {
            showTOOLtip("Finished creating the .PDF file:`n" OutFileName "`nImages embedded: " xu moreInfos "`nFile size: " fileSizeFriendly(OutputVar) rr)
            SoundBeep , 900, 100
         } Else
         {
            showTOOLtip("ERROR: Malformed .PDF file generated:`n" OutFileName "`nImages embedded: NONE`nFile size: " fileSizeFriendly(OutputVar) rr)
            SoundBeep , 300, 100
         }
      }

      fListArray := ""
      If (OutputVar!="a")
         SoundBeep , % (z>1) ? 900 : 300, 100
      fnOutputDebug("delete temp dir=" tempusDir)
      If tempusDir
         FileRemoveDir, % tempusDir, 1

      CurrentSLD := backCurrentSLD
      SetTimer, RemoveTooltip, % -msgDisplayTime
      ResetImgLoadStatus()
   }
}

BTNperformExtractFrames(a) {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeDestFolder
   GuiControlGet, userJpegQuality
   GuiControlGet, userSaveBitsDepth
   GuiControlGet, OnExtractConflictOverwrite
   GuiControlGet, userExtractFramesFmt
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   RegAction(1, "ResizeDestFolder")
   RegAction(1, "userJpegQuality")
   RegAction(1, "userExtractFramesFmt")
   ControlGetText, c,, ahk_id %a%
   If !FolderExist(ResizeDestFolder)
   {
      FileCreateDir, % ResizeDestFolder
      If ErrorLevel
      {
         showTOOLtip("ERROR: Destination folder does not exist:`n" ResizeDestFolder)
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   BtnCloseWindow()
   nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   If (markedSelectFile>1 && !InStr(c, "active"))
   {
      batchExtractFramesFromImages()
   } Else
   {
      r := coreExtractFramesFromImage(currentFileIndex, 0, 0, 0, failedFrames)
      If (r=-5)
         showTOOLtip("WARNING: User abandoned operation.`nSeveral frames or pages may have been extracted already.")
      Else If (r=-4)
         showTOOLtip("ERROR: Failed to load the image. No frames or pages were extracted")
      Else If (r=-3)
         showTOOLtip("WARNING: The image format does not have support for multiple frames.`nNo frames or pages were extracted.")
      Else If (r=-2)
         showTOOLtip("The image has no frames or pages to extract")
      Else If (r>1)
         showTOOLtip("Succesfully extracted " groupDigits(r - failedFrames) " frames out of " r)
      Else 
         showTOOLtip("ERROR: An undefined error has occured.`nNo frames or pages were extracted.")

      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

WriteSettingsThumbsSheetPanel() {
   ReadSettingsThumbsSheetPanel(1)
}

calculateThumbsSheetDimensions(ByRef width, ByRef height) {
   frame := Round((userThumbsSheetFrame/100) * userThumbsSheetSpacing)
   thisFntSize := clampInRange(TextInAreaFontSize, 5, userThumbsSheetHeight//1.7)
   labelHeight := (userThumbsSheetShowLabel=1) ? Round(thisFntSize*1.25) : 0
   width := frame*2 + (userThumbsSheetWidth + userThumbsSheetSpacing) * userThumbsSheetColumns - userThumbsSheetSpacing
   height := frame*2 + (userThumbsSheetHeight + userThumbsSheetSpacing + labelHeight) * Ceil(markedSelectFile / userThumbsSheetColumns) - userThumbsSheetSpacing
}

getSaveDialogIndexForFile(imgPath, ByRef defFMTindex, allowExtended:=0) {
   Static extended := {"hdr":17, "exr":18, "pfm":19}
   defFMTindex := 1
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
   Loop, Parse, dialogSaveFptrn, |
   {
        If InStr(A_LoopField, "." oEXT)
           defFMTindex := A_Index
   }
   If (allowExtended=1 && extended[oExt])
      defFMTindex := extended[oExt]
}

generateThumbsSheet() {
   initFIMGmodule()
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   WriteSettingsThumbsSheetPanel()
   calculateThumbsSheetDimensions(width, height)
   RegAction(0, "userDesireWriteFMT",, 2, 1, 16)
   INIaction(0, "prevFileSavePath", "General", 6)
   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
   defaultu := !FolderExist(prevFileSavePath) ? OutDir "\thumbs-sheet" : prevFileSavePath "\thumbs-sheet"
   mustdoDeleteFile := 0
   getSaveDialogIndexForFile(imgPath, defFMTindex)
   file2save := openFileDialogWrapper("S", "PathMustExist", defaultu, "Save thumbnails sheet as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)
   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      prevFileSavePath := OutDir
      INIaction(1, "prevFileSavePath", "General", 6)
      If !nExt
      {
         nExt := dialogSaveIndexes[dialogFmtIndex]
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]
      }

      If isImgSizeTooLarge(width, height, nExt)
      {
         If (Round((width * height)/1000000, 1) > 715.3)
            msgResult := msgBoxWrapper(appTitle ": WARNING", "The thumbnails sheet image cannot exceed 715 megapixels. Please reduce the size of the thumbnails and the spacing amongst them.", "&OK", 1, "exclamation")
         Else
            msgResult := msgBoxWrapper(appTitle ": WARNING", "The thumbnails sheet image will have a dimension of " groupDigits(width) " x " groupDigits(height) " pixels. The image file format you chose cannot handle such large dimensions through QPV.`n`nPlease choose a different image file format, eg., TIFF.", "&OK", 1, "exclamation")
         Return
      }

      If FileExist(file2save)
      {
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The destination file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult="Yes")
         {
            mustdoDeleteFile := 1
         } Else Return
      }
   } Else Return

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, width, height, "0x21808")
   If validBMP(pBitmap)
      Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)

   If (mustdoDeleteFile=1 && FileExist(file2save) && Gu)
   {
      FileSetAttrib, -R, %file2save%
      Sleep, 1
      Try FileDelete, %file2save%
      Catch wasErrorB
            Sleep, 1

      If wasErrorB
      {
         Gdip_DeleteGraphics(Gu)
         trGdip_DisposeImage(pBitmap)
         msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file: " OutFileName ". Permission denied.`n`nLocation:`n" OutDir "\", 0, 0, "error")
         Return
      }
   }

   If !Gu
   {
      trGdip_DisposeImage(pBitmap)
      showTOOLtip("ERROR: Failed to generate the thumbnails sheet. Init malfunction.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   If (userThumbsSheetShowLabel=1)
   {
      isBold := (TextInAreaFontBold=1) ? " Bold" : ""
      isUline := (TextInAreaFontUline=1) ? " Underline" : ""
      isItalica := (TextInAreaFontItalic=1) ? " Italic" : ""
      isAlign := (TextInAreaAlign=1) ? " Left" : " Right"
      If (TextInAreaAlign=2)
         isAlign := " Center"

      txtColor := makeRGBAcolor(TextInAreaFontColor, TextInAreaFontOpacity)
      thisFntSize := clampInRange(TextInAreaFontSize, 5, userThumbsSheetHeight//1.7)
      pBrush := Gdip_BrushCreateSolid(txtColor)
      theseTxtOptions := isBold isUline isItalica isAlign " NoWrap vCenter c" txtColor " s" thisFntSize
      labelHeight := Round(thisFntSize*1.25)
      txtPos := " x0 y0"
   } Else labelHeight := 0

   If (userThumbsSheetBgrShade=1)
      shadeBrush := Gdip_BrushCreateSolid("0x33111111")
   Else If (userThumbsSheetBgrShade=3)
      shadeBrush := Gdip_BrushCreateSolid("0x33eeEEee")

   Gdip_GraphicsClear(Gu, "0xFF" userThumbsSheetBgrColor)
   destroyGDIfileCache()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   sizesDesired := []
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   sizesDesired[1] := [userThumbsSheetWidth, userThumbsSheetHeight, 1, 0, 6]
   getSelectedFiles(0, 1)
   showTOOLtip("Generating the thumbnails sheet:`n" groupDigits(markedSelectFile) " images selected.")
   frame := Round((userThumbsSheetFrame/100) * userThumbsSheetSpacing)
   px := py := frame
   cols := 1
   setWhileLoopExec(1)
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      countTFilez++
      changeMcursor()
      imgPath := getIDimage(A_Index)
      changeMcursor()
      If !FileExist(imgPath)
      {
         failedFiles++
         Continue
      }

      nBitmap := LoadBitmapFromFileu(imgPath, 0, 0, 0, sizesDesired)
      If !validBMP(nBitmap)
      {
         failedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to load " groupDigits(failedFiles) " images"

         showTOOLtip("Generating the thumbnails sheet:" etaTime, 0, 0, countTFilez/markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (ResizeApplyEffects=1)
      {
         nBitmap := applyVPeffectsOnBMP(nBitmap, 1, mainLoadedIMGdetails.HasAlpha, "y")
         nBitmap := flipBitmapAccordingToViewPort(nBitmap)
      }

      trGdip_GetImageDimensions(nBitmap, oW, oH)
      opx := px + (userThumbsSheetWidth - oW)//2
      opy := py + (userThumbsSheetHeight - oH)//2
      If (userThumbsSheetBgrShade=1 || userThumbsSheetBgrShade=3)
         Gdip_FillRectangle(Gu, shadeBrush, px, py, userThumbsSheetWidth, userThumbsSheetHeight + labelHeight)

      E := trGdip_DrawImage(A_ThisFunc, Gu, nBitmap, opx, opy, oW, oH)
      If (userThumbsSheetShowLabel=1)
      {
         zPlitPath(imgPath, 1, OutFileName, OutDir, OutFileNameNoExt)
         thisu := (userThumbsSheetHideExt=1) ? OutFileNameNoExt : OutFileName
         ERR := Gdip_TextToGraphics(Gu, thisu, theseTxtOptions " x" px " y" py + userThumbsSheetHeight, TextInAreaFontName, userThumbsSheetWidth, labelHeight, 0, pBrush, 2)
      }

      trGdip_DisposeImage(nBitmap, 1)
      If (E="fail")
         failedFiles++

      px := px + userThumbsSheetWidth + userThumbsSheetSpacing
      cols++
      If (cols>userThumbsSheetColumns)
      {
         cols := 1
         px := frame
         py := py + userThumbsSheetHeight + userThumbsSheetSpacing + labelHeight
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   setWhileLoopExec(0)
   If pBrush
      Gdip_DeleteBrush(pBrush)
   If shadeBrush
      Gdip_DeleteBrush(shadeBrush)

   Gdip_DeleteGraphics(Gu)
   If (failedFiles>=markedSelectFile)
   {
      showTOOLtip("Failed to generate the thumbnails sheet for " groupDigits(filesElected) " images.`nUnable to load any selected image.")
      SoundBeep 300, 100
      CurrentSLD := backCurrentSLD
      trGdip_DisposeImage(pBitmap)
      Return
   }

   someErrors := ((A_TickCount - startOperation)<2000) ? "" : "`nElapsed time: " SecToHHMMSS((A_TickCount - startOperation)/1000) "."
   If (failedFiles>0)
      someErrors .= "`nFailed to load " groupDigits(failedFiles) " images."

   If (abandonAll=1)
   {
      CurrentSLD := backCurrentSLD
      showTOOLtip("Operation aborted. The thumbnails sheet was not generated." someErrors)
      SoundBeep , 300, 100
   } Else
   {
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      showTOOLtip("Saving the thumbnails sheet image:`n" OutFileName "`n" PathCompact(OutDir, 35) "\`nResolution: " groupDigits(width) " x " groupDigits(height) " pixels.")
      r := QPV_SaveImageFile(A_ThisFunc, pBitmap, file2save, userJpegQuality, 2)
      CurrentSLD := backCurrentSLD
      If !r
      {
         showTOOLtip("Finished generating the thumbnails sheet for " groupDigits(markedSelectFile) " images." someErrors "`nFile saved: " OutFileName "`n" PathCompact(OutDir, 35) "\")
         SoundBeep , 900, 100
      } Else
      {
         showTOOLtip("Failed to save the generated thumbnails sheet comprised of " groupDigits(markedSelectFile) " images." someErrors)
         SoundBeep , 300, 100
      }
   }

   trGdip_DisposeImage(pBitmap)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -50
}

PanelCreateIMGthumbsSheet() {
    filesElected := getSelectedFiles(0, 1)
    If (!filesElected || filesElected>50109)
    {
       If !filesElected
          showTOOLtip("WARNING: At least two images must be selected to create a thumbnails sheet.")
       Else
          showTOOLtip("WARNING: Too many images selected. A thumbnails sheet cannot be created with over 10 000 images.")

       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(86, A_ThisFunc)
    btnWid := 100
    txtWid := 330
    EditWid := 395
    slideWid2 := 140
    If (PrefsLargeFonts=1)
    {
       EditWid += 230
       btnWid += 80
       txtWid += 120
       slideWid2 += 110
       Gui, Font, s%LargeUIfontValue%
    }

    thisWid := (PrefsLargeFonts=1) ? 70 : 45
    ml := (PrefsLargeFonts=1) ? 275 : 175
    mk := groupDigits(filesElected)
    Global PickuUserThumbsSheetBgrColor
    ReadSettingsThumbsSheetPanel()
    Gui, Add, Tab3, %tabzDarkModus% AltSubmit gBtnTabsInfoUpdate hwndhCurrTab vCurrentPanelTab, Grid options|Labels
    Gui, Tab, 1
    Gui, Add, Text, x+15 y+15 Section +0x200 w%slideWid2% +hwndhTemp, Grid columns:
    GuiAddEdit("x+10 w70 number -multi limit3 gupdateUIthumbsSheet vEditF1", userThumbsSheetColumns)
    Gui, Add, UpDown, gupdateUIthumbsSheet vuserThumbsSheetColumns Range2-256, % userThumbsSheetColumns

    Gui, Add, Text, xs y+10 hp +0x200 w%slideWid2%, Grid spacing (in pixels):
    GuiAddEdit("x+10 w70 number -multi limit3 gupdateUIthumbsSheet vEditF2", userThumbsSheetSpacing)
    Gui, Add, UpDown, gupdateUIthumbsSheet vuserThumbsSheetSpacing Range2-256, % userThumbsSheetSpacing

    Gui, Add, Text, xs y+10 hp +0x200 w%slideWid2%, Sheet frame (in `%):
    GuiAddEdit("x+10 w70 number -multi limit3 gupdateUIthumbsSheet vEditF3", userThumbsSheetFrame)
    Gui, Add, UpDown, gupdateUIthumbsSheet vuserThumbsSheetFrame Range0-250, % userThumbsSheetFrame

    Gui, Add, Text, xs y+10 w%slideWid2% hp +0x200, Image quality (1`% - 100`%):
    GuiAddEdit("x+10 w70 number -multi limit3 veditF7", userJpegQuality)
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality

    widu := (PrefsLargeFonts=1) ? 29 : 25
    Gui, Add, Text, xs y+10 hp +0x200 w%slideWid2%, Background color:
    GuiAddColor("x+10 hp w" widu*2, "userThumbsSheetBgrColor", "Thumbnails sheet background color")
    GuiAddPickerColor("x+5 hp w" widu, "userThumbsSheetBgrColor")

    Gui, Add, Checkbox, xs y+10 gTglRszApplyEffects Checked%ResizeApplyEffects% vResizeApplyEffects, Apply viewport color adjustments and effects

    EditWid := (PrefsLargeFonts=1) ? 250 : 150
    ml := (PrefsLargeFonts=1) ? 70 : 50
    Gui, Add, Text, xs y+15 hp +0x200 w%slideWid2%, Thumbnails size (W x H):
    GuiAddDropDownList("xs y+7 w" editWid//2 " gupdateUIthumbsSheet Choose" userThumbsSheetBgrShade " AltSubmit vuserThumbsSheetBgrShade", "Dark shade|No shade|Bright shade", "Thumbnail background shade")
    GuiAddEdit("x+10 w" ml " number -multi limit4 gupdateUIthumbsSheet vEditF4", userThumbsSheetWidth, "Thumbnails width")
    Gui, Add, UpDown, gupdateUIthumbsSheet vuserThumbsSheetWidth Range32-1024, % userThumbsSheetWidth
    Gui, Add, Text, x+10 hp +0x200, x
    GuiAddEdit("x+10 w" ml " number -multi limit4 gupdateUIthumbsSheet vEditF5", userThumbsSheetHeight, "Thumbnails height")
    Gui, Add, UpDown, gupdateUIthumbsSheet vuserThumbsSheetHeight Range32-1024, % userThumbsSheetHeight
    Gui, Add, Text, x+5 hp +0x200, (in pixels)

    Gui, Add, Text, xs y+15 vinfoLine, Final output dimensions (W x H): ( WWW )`nTBA.

    Gui, Tab, 2
    Gui, Add, Checkbox, x+15 y+15 Section gupdateUIthumbsSheet Checked%userThumbsSheetShowLabel% vuserThumbsSheetShowLabel, Show file names as labels
    Gui, Add, Text, xs+15 y+15 w%EditWid% Section, Font name:
    GuiAddDropDownList("xs y+5 wp Sort gupdateUIthumbsSheet Choose1 vTextInAreaFontName", TextInAreaFontName)
    Gui, Add, Text, xs y+15, Text size and color:
    GuiAddEdit("xs+0 y+5 w" editWid//2 " gupdateUIthumbsSheet r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF6 ", TextInAreaFontSize, "Font size")
    Gui, Add, UpDown, vTextInAreaFontSize gupdateUIthumbsSheet Range10-950, % TextInAreaFontSize
    GuiAddColor("x+2 hp w" widu*2, "TextInAreaFontColor", "Text color")
    GuiAddPickerColor("x+2 hp w" widu, "TextInAreaFontColor")
    GuiAddSlider("TextInAreaFontOpacity", 10, 255, 255, "Text opacity", "updateUIthumbsSheet", 1, "xs y+5 w" EditWid " hp")

    Gui, Add, Text, xs y+15, Text alignment and style:
    GuiAddDropDownList("xs y+5 w" editWid//2 " gupdateUIthumbsSheet Choose" TextInAreaAlign " AltSubmit vTextInAreaAlign", "Left|Center|Right", "Text horizontal alignment")
    GuiAddCheckbox("x+2 yp hp+1 w" widu " gupdateUIthumbsSheet Checked" TextInAreaFontBold " vTextInAreaFontBold", "Bold", "B")
    GuiAddCheckbox("x+2 yp hp wp gupdateUIthumbsSheet Checked" TextInAreaFontItalic " vTextInAreaFontItalic", "Italic", "I")
    GuiAddCheckbox("x+2 yp hp wp gupdateUIthumbsSheet Checked" TextInAreaFontUline " vTextInAreaFontUline", "Underline", "&U")
    Gui, Add, Checkbox, xs y+15 Section gupdateUIthumbsSheet Checked%userThumbsSheetHideExt% vuserThumbsSheetHideExt, &Hide file extensions

    Gui, Tab
    Gui, Add, Text, xm+15 y+15 Section, %mk% images selected.
    ; Gui, Add, Checkbox, xs+15 y+5 Checked%uiPreferedFileStats% vuiPreferedFileStats gToggleFileStatsDating, &Generate date statistics based on modified date.
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default ggenerateThumbsSheet, &Generate image
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBtnCloseWindow, C&ancel
    GuiRefreshSliders()
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Create a thumbnails sheet: " appTitle)
}

updateUIthumbsSheet() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide 
   calculateThumbsSheetDimensions(width, height)
   w := groupDigits(width)
   h := groupDigits(height)
   mgpx := Round((width * height)/1000000, 1)
   If (mgpx>715.3)
      friendly := " ( !!! )"
   GuiControl, SettingsGUIA:, infoLine, Final output dimensions (W x H):%friendly%`n%w% x %h% (%mgpx% MPx).
}

PanelSetWallpaper() {
    Global userMonitorIDu, btn1, btn2, btn3, PickumonitorBgrColor
    If !getIDimage(currentFileIndex)
       Return

    If (A_OSVersion="WIN_7" || isWinXP)
    {
       setImageWallpaper(1, getIDimage(currentFileIndex), 1)
       Return
    }

    thisBtnHeight := createSettingsGUI(76, A_ThisFunc)
    btnWid := 100
    txtWid := 330
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }
    RegAction(0, "userMonitorImgPos")
    RegAction(0, "monitorBgrColor")

    dw := new IDesktopWallpaper
    dw.GetMonitorDevicePathCount(monitors)
    listu := ""
    Loop, % monitors
    {
        dw.GetMonitorDevicePathAt(A_Index - 1, MonitorID)
        dw.GetMonitorRECT(MonitorID, blah, width, height)
        pk := StrSplit(MonitorID, "#")
        pp := pk[1] " / " pk[2]
        pp := SubStr(pp, 5)
        listu .= A_Index ": (" width " x " height  ") " pp "|"
    }
 
    dw := ""
    dw := Delete IDesktopWallpaper
    listu := Trim(listu, "|")
    
    ml := (PrefsLargeFonts=1) ? 450 : 285
    thisWid := (PrefsLargeFonts=1) ? 70 : 45
    warnu := (thumbsDisplaying!=1) ? "The active image file will be set as a wallpaper, which may differ from the image you see in the viewport (if altered)." : ""
    Gui, Add, Text, x15 y15 Section w%ml%, Please choose the monitor and the image position and size adaptation mode on the desktop.

    GuiAddDropDownList("xs y+10 wp AltSubmit Choose1 vuserMonitorIDu", listu, "Monitor")
    GuiAddDropDownList("xs y+10 wp-100 AltSubmit Choose" userMonitorImgPos " vuserMonitorImgPos", "Centered|Tiled|Stretched|Fit|Fill|Span", "Adapt to desktop mode")
    GuiAddColor("x+5 hp w55", "monitorBgrColor", "Desktop background color")
    GuiAddPickerColor("x+5 hp wp-20", "monitorBgrColor")
    If warnu
       Gui, Add, Text, xs y+15 w%ml%, %warnu%

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBTNsetImgWallpaper vbtn1, &Set wallpaper
    Gui, Add, Button, x+5 hp wp-10 gBTNremWallpaper vbtn3, &No wallpaper
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBtnCloseWindow vbtn2, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Set image as wallpaper: " appTitle)
}

BTNremWallpaper() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userMonitorIDu
   GuiControlGet, userMonitorImgPos
   dw := new IDesktopWallpaper
   dw.GetMonitorDevicePathAt(monitorIndex, MonitorID)
   dw.SetWallpaper(MonitorID, "")
   dw.SetBackgroundColor("0x" rgb2bgr(monitorBgrColor))
   dw.GetMonitorDevicePathCount(counter)
   dw := ""
   dw := Delete IDesktopWallpaper
   If (counter<2)
      BtnCloseWindow()
}

BTNsetImgWallpaper() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userMonitorIDu
   GuiControlGet, userMonitorImgPos
   GuiControl, SettingsGUIA: Disable, btn1
   GuiControl, SettingsGUIA: Disable, btn2
   GuiControl, SettingsGUIA: Disable, btn3
   GuiControl, SettingsGUIA: Hide, monitorBgrColor
   imgPath := getIDimage(currentFileIndex)
   r := setImageWallpaper(userMonitorIDu - 1, imgPath, userMonitorImgPos - 1)
   GuiControl, SettingsGUIA: Show, monitorBgrColor
   GuiControl, SettingsGUIA: Enable, btn1
   GuiControl, SettingsGUIA: Enable, btn2
   GuiControl, SettingsGUIA: Enable, btn3
   RegAction(1, "userMonitorImgPos")
   RegAction(1, "monitorBgrColor")
   If !r
      BtnCloseWindow()
}

PanelSaveImg() {
    Global userDestinationFolder, editF5, UserCropOnSave

    If (thumbsDisplaying=1)
    {
       PanelSaveSlideShowu()
       Return
    }

    If throwErrorNoImageLoaded()
       Return

    thisBtnHeight := createSettingsGUI(35, A_ThisFunc)
    btnWid := 100
    txtWid := 330
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := (PrefsLargeFonts=1) ? btnWid - 40 : btnWid - 25
    RegAction(0, "userDesireWriteFMT",, 2, 1, 16)
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)

    INIaction(0, "prevFileSavePath", "General", 6)
    RegAction(0, "usePrevSaveFolder",, 1)
    RegAction(0, "PreserveDateTimeOnSave",, 1)
    RegAction(0, "userJpegQuality",, 2, 1, 100)

    entriesList := StrReplace(recentOpenedFolders(), "`n", "|")
    delim := InStr(entriesList, prevFileSavePath "|") ? "|" : ""
    entriesList := StrReplace(entriesList, prevFileSavePath delim, prevFileSavePath "||")
    If StrLen(entriesList)<4
    {
       usePrevSaveFolder := 0
       GuiControl, Disable, usePrevSaveFolder
    } Else If !InStr(entriesList, "||")
       entriesList .= "|"

    UserCropOnSave := 0
    imgPath := getIDimage(currentFileIndex)
    If (InStr(imgPath, "\temporary memory object\") || !imgPath)
    {
       fileStatus := imgPath "`n`nImage bitmap unsaved to disk."
    } Else
    {
       fileStatus := PathCompact(imgPath, 47)
       If !FileExist(imgPath)
          fileStatus .= "`n`nThe image file no longer seems to exist. It will be recreated on save."
       Else If (currentImgModified=1)
          fileStatus .= "`n`nThe image has been modified."
       Else If (currentImgModified=2)
          fileStatus .= "`n`nThe image changes have been saved."
       Else
          fileStatus .= "`n`nThe image has not been modified."
    }

    oldTimes := lastZeitIMGsaved[1]
    FormatTime, timea, % oldTimes , HH:mm
    If oldTimes
       InfosPreviousSave := "Last time saved: " timea "`n" PathCompact(lastZeitIMGsaved[5] "\" lastZeitIMGsaved[4], 47) "`nUndo levels state: " lastZeitIMGsaved[2] "/" lastZeitIMGsaved[3]

    QPV_FileGetSizeTime(imgPath, "R", currentFileIndex)
    ofileSizu := resultedFilesList[currentFileIndex, 6]
    fileSizu := (ofileSizu>15) ? fileSizeFriendly(ofileSizu) : "N/A"
    If (ofileSizu>15)
    {
       FileDateM := QPV_FileGetSizeTime(imgPath, "M", currentFileIndex)
       yday += -1, days
       Try formattime, yday, %yday%, dd/MM/yyyy
       Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
       Try FormatTime, nowDate, % A_Now, dd/MM/yyyy
       If InStr(FileDateM, yday)
          FileDateM := "Yesterday, " FileDateM
       Else If InStr(FileDateM, nowDate)
          FileDateM := "Today, " FileDateM
       FileDateM := "`nLast modified: " FileDateM
    }

    depthChoice := (currIMGdetails.HasAlpha=1) ? 1 : 2
    If (viewportQPVimage.imgHandle)
    {
       depthChoice := 5
       bonusChoice := "|Original"
    }

    thisWid := (PrefsLargeFonts=1) ? 70 : 45
    Gui, Add, Checkbox, x15 y15 Section gTglUsePrevSaveFoderu Checked%usePrevSaveFolder% vusePrevSaveFolder, &Open file dialog in a previous location
    GuiAddDropDownList("xp+15 y+7 wp+135 vuserDestinationFolder", entriesList, "Recent folders")
    Gui, Add, Text, xs y+10 hp +0x200, Save options:
    Gui, Add, Checkbox, xp+15 y+10 hp Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time

    thisWid := (PrefsLargeFonts=1) ? 145 : 115
    GuiAddSlider("userJpegQuality", 2,100, 95, "Quality", "iniSaveJPGquality", 1, "xp y+8 w" thisWid + 10 " hp", "This only applies to the JPEG and WEBP file formats")
    GuiAddDropDownList("x+10 w" thisWid " AltSubmit Choose" depthChoice " vuserSaveBitsDepth", "32 bits RGBA|24 bits RGB|16 bits RGB|8 bits RGB [256 colors]" bonusChoice, "Color depth")
    sml := (PrefsLargeFonts=1) ? 40 : 30
    GuiAddButton("x+5 w" sml " hp gbtnHelpSaveImgPanel", " ?", "Help")
    Gui, Add, Text, xs y+10, Image file status
    ; Gui, Add, Text, xs y+0 wp h2 +0x1007, 
    Gui, Add, Text, xp+15 y+7 w%txtWid% -wrap, % "File size: " fileSizu FileDateM "`n" fileStatus
    If oldTimes
    {
       Gui, Add, Text, xs y+10, Previous file saved:
       Gui, Add, Text, xp+15 y+7 w%txtWid% +wrap, % InfosPreviousSave
    }

    If !usePrevSaveFolder
       GuiControl, Disable, userDestinationFolder

    btnWid2 := (PrefsLargeFonts=1) ? btnWid - 40 : btnWid - 25
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBTNsaveImgPanel, &Save image
    Gui, Add, Button, x+0 h%thisBtnHeight% w35 gBTNsaveBrowseImgPanel, &AS
    Gui, Add, Button, x+15 hp w%btnWid% gBtnCopyImageClip, &Copy to clipboard
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBtnCloseWindow, C&ancel
    GuiRefreshSliders()
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save image file: " appTitle)
}

btnHelpSaveImgPanel() {
   msgBoxWrapper(appTitle ": HELP", "Quality level applies only for JPG, JP2, J2K, JXR and WEBP files.`n`nThe color depth option is not applicable to all of the supported image file formats.", -1, 0, 0)
}

PanelBrushTool(dummy:=0, modus:=0) {
    Static userWasWarned := 0
    initQPVmainDLL()
    If (dupesDCTcoeffsInit!=1 && userWasWarned=0)
    {
       userWasWarned := 1
       msgBoxWrapper(appTitle ": WARNING", appTitle " has failed to initialize the main DLL file: qpvmain.dll. Options within this panel and others will likely not function properly.", 0, 0, "error")
    }

    openingPanelNow := 1
    If !(thisBtnHeight := createSettingsGUI(64, A_ThisFunc, 1, 1))
       Return

    btnWid := 100
    EditWid := 395
    txtWid := 285, slideWid := 155
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 60
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    slideWid2 := slideWid//2
    Global PickuBrushToolAcolor, PickuBrushToolBcolor, UIbtnBrushColorA, UIbtnBrushColorB, uiBtnSetCloner
         , infoSymmetryLabel, BTNuiSetLabelSymmetry

    ReadSettingsBrushPanel()
    FloodFillSelectionAdj := 0
    liveDrawingBrushTool := 1
    interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
    interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
    If (modus="e" && isNumber(dummy))
    {
       BrushToolType := dummy
       If (BrushToolType=2)
          BrushToolWetness := 0
    } Else If (modus="w" && dummy=2)
    {
       ; wet soft brush
       If (BrushToolWetness<3)
          BrushToolWetness := 10
       BrushToolType := dummy
    } Else If (modus="b" && dummy=5)
    {
       ; blur FX brush
       BrushToolApplyColorFX := 0
       If (BrushToolBlurStrength<5)
          BrushToolBlurStrength := 25
       BrushToolType := dummy
    } Else If (modus="fx" && dummy=5)
    {
       ; colors FX brush
       BrushToolApplyColorFX := 1 
       BrushToolBlurStrength := 0
       BrushToolType := dummy
    }

    sml := (PrefsLargeFonts=1) ? 30 : 20
    hasa := (PrefsLargeFonts=1) ? 27 : 18
    Gui, Add, Tab3, %tabzDarkModus% AltSubmit Choose%thisPanelTab% vCurrentPanelTab gBtnTabsInfoUpdate hwndhCurrTab, General|Effects options|Randomize
    Gui, Tab, 1 ; general
    GuiAddDropDownList("x+15 y+15 w" slideWid " Section AltSubmit gupdateUIbrushTool Choose" BrushToolType " vBrushToolType", "Simple solid color|Soft edges brush|Cloner|Eraser|Effects|Smudge|Pinch|Bulge", "Brush type")
    Gui, Add, Checkbox, x+10 hp wp +0x1000 gupdateUIbrushTool Checked%BrushToolEraserRestore% vBrushToolEraserRestore , Restore pixels opacity
    wo := (PrefsLargeFonts=1) ? slideWid // 2 + 40 : slideWid // 2 + 5
    Gui, Add, Button, xp yp hp w%wo% gBtnSetClonerBrushSource vuiBtnSetCloner, &Define source
    Gui, Add, Text, xs y+10 h%hasa% w%sml% +0x200 Center gBtnToggleBrushColors vUIbtnBrushColorA +TabStop +hwndhBtnTglClrA, [X]
    ToolTip2ctrl(hBtnTglClrA, "Toggle active color")
    GuiAddPickerColor("x+5 hp w" sml, "BrushToolAcolor")
    GuiAddColor("x+5 hp w60", "BrushToolAcolor")
    opaciSlideW := (PrefsLargeFonts=1) ? 130 : 85
    GuiAddSlider("BrushToolAopacity", 2,255, 255, "Opacity", "updateUIbrushTool", 1, "x+5 w" opaciSlideW " hp")
    Gui, Add, Checkbox, x+5 hp wp +0x1000 Checked%BrushToolAutoAngle% vBrushToolAutoAngle gupdateUIbrushTool, Auto-rotate

    Gui, Add, Text, xs y+10 hp w%sml% +0x200 Center gBtnToggleBrushColors vUIbtnBrushColorB +TabStop +hwndhBtnTglClrB, [X]
    ToolTip2ctrl(hBtnTglClrB, "Toggle active color")
    GuiAddPickerColor("x+5 hp w" sml, "BrushToolBcolor")
    GuiAddColor("x+5 hp w60", "BrushToolBcolor")
    GuiAddSlider("BrushToolBopacity", 2,255, 255, "Opacity", "updateUIbrushTool", 1, "x+5 w" opaciSlideW " hp")
    Gui, Add, Checkbox, x+5 hp wp gupdateUIbrushTool Checked%BrushToolDoubleSize% vBrushToolDoubleSize, Size × 2

    GuiAddSlider("BrushToolSize", 1,950, 25, "Brush size: $€", "updateUIbrushTool", 1, "xs y+15 w" slideWid " hp")
    GuiAddSlider("BrushToolStepping", 0,251, 0, ".updateLabelBrushStep", "updateUIbrushTool", 1, "x+10 wp hp")
    GuiAddSlider("BrushToolAspectRatio", -100,100, 0, "Aspect ratio", "updateUIbrushTool", 2, "xs y+10 wp hp")
    GuiAddSlider("BrushToolAngle", -180,180, 0, "Angle: $€°", "updateUIbrushTool", 2, "x+10 wp hp")
    GuiAddSlider("BrushToolSoftness", 1,100, 35, "Softness", "updateUIbrushTool", 1, "xs y+10 wp hp")
    GuiAddSlider("BrushToolDryingRate", 0,20, 0, "Dry-out rate", "updateUIbrushTool", 1, "x+10 wp hp")
    GuiAddDropDownList("xs y+10 wp AltSubmit gupdateUIbrushTool Choose" BrushToolTexture " vBrushToolTexture", "Soft circle|Decals A|Cloudies|Scratchy|Decals B|Decals C|Gradial|Dots|Vertical dots", "Brush texture")
    GuiAddDropDownList("x+10 wp gupdateUIbrushTool AltSubmit Choose" BrushToolOutsideSelection " vBrushToolOutsideSelection", "Ignore selection area|Paint inside selection|Paint outside selection", "Selection fill mode")

    gW := gH := (PrefsLargeFonts=1) ? 60 : 45
    Gui, Add, Text, xs y+10 w1 h1 hide, Brush preview
    Gui, Add, Text, xp yp w%gW% h%gH% -border +0xE +hwndhCropCornersPic gUIresponderPanelsLivePreview +TabStop, Brush preview
    Gui, Add, Checkbox, x+10 gupdateUIbrushTool Checked%BrushToolOverDraw% vBrushToolOverDraw , &Airbrush mode / deformer option
    Gui, Add, Checkbox, y+10 gupdateUIbrushTool Checked%BrushToolDynamicCloner% vBrushToolDynamicCloner , D&ynamic X/Y source coordinates

    Gui, Tab, 2 ; FX
    GuiAddSlider("BrushToolBlurStrength", 0,99, 0, "Blur strength", "updateUIbrushTool", 1, "x+15 y+15 w" slideWid " h" hasa)
    GuiAddSlider("BrushToolWetness", 0,22, 0, "Wetness", "updateUIbrushTool", 1, "x+10 wp hp")

    Gui, Add, Checkbox, xs y+10 wp gupdateUIbrushTool Checked%BrushToolApplyColorFX% vBrushToolApplyColorFX, Color adjustments
    GuiAddDropDownList("x+10 wp-27 gupdateUIbrushTool AltSubmit Choose" BrushToolBlendMode " vBrushToolBlendMode", "No blend mode|" userBlendModesList, "Blending mode")
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIbrushTool")

    GuiAddSlider("PasteInPlaceHue", -180,180, 0, "Hue: $€°", "updateUIbrushTool", 2, "xs y+15 w" slideWid * 2 + 5 " h" hasa)
    GuiAddSlider("PasteInPlaceSaturation", -100,100, 0, "Saturation", "updateUIbrushTool", 2, "xs y+10 wp hp")
    GuiAddSlider("PasteInPlaceLight", -255,255, 0, "Brightness", "updateUIbrushTool", 2, "xs y+10 wp hp")
    GuiAddSlider("PasteInPlaceGamma", -100,100, 0, "Contrast", "updateUIbrushTool", 2, "xs y+10 wp hp")
    Gui, Add, Text, xs y+10 w1 h1 hide, Brush preview
    Gui, Add, Text, xp yp w%gW% h%gH% -border +0xE +hwndhCropCornersPic2 gUIresponderPanelsLivePreview +TabStop, Brush preview

    sml := (PrefsLargeFonts=1) ? 55 : 35
    Gui, Add, Text, x+10 h%hasa% +0x200 vinfoSymmetryLabel, Apply symmetry on: 
    Gui, Add, Checkbox, y+5 w%sml% hp gupdateUIbrushTool Checked%BrushToolSymmetryX% vBrushToolSymmetryX, X
    Gui, Add, Checkbox, x+5 wp hp gupdateUIbrushTool Checked%BrushToolSymmetryY% vBrushToolSymmetryY, Y
    Gui, Add, Button, x+5 hp gBtnSetBrushSymmetryCoords vBTNuiSetLabelSymmetry, S&et center

    Gui, Tab, 3 ; randomize
    GuiAddSlider("BrushToolRandomSize", 0,200, 0, "Brush size", "updateUIbrushTool", 1, "xs y+15 w" slideWid " h" hasa)
    GuiAddSlider("BrushToolRandomSoftness", 0,80, 0, "Softness", "updateUIbrushTool", 1, "x+10 wp hp")
    GuiAddSlider("BrushToolRandomAspectRatio", 0,80, 0, "Aspect ratio", "updateUIbrushTool", 1, "xs y+15 wp hp")
    GuiAddSlider("BrushToolRandomAngle", 0,150, 0, "Angle: $€°", "updateUIbrushTool", 1, "x+10 wp hp")
    GuiAddSlider("BrushToolRandomPosX", 0,200, 0, "Offset X", "updateUIbrushTool", 1, "xs y+15 wp hp")
    GuiAddSlider("BrushToolRandomPosY", 0,200, 0, "Offset Y", "updateUIbrushTool", 1, "x+10 wp hp")
    GuiAddSlider("BrushToolRandomHue", 0,180, 0, "Hue", "updateUIbrushTool", 1, "xs y+15 wp hp")
    GuiAddSlider("BrushToolRandomSat", 0,90, 0, "Saturation", "updateUIbrushTool", 1, "x+10 wp hp")
    GuiAddSlider("BrushToolRandomLight", 0,90, 0, "Lightness", "updateUIbrushTool", 1, "xs y+15 wp hp")
    GuiAddSlider("BrushToolRandomDark", 0,90, 0, "Darkness", "updateUIbrushTool", 1, "x+10 wp hp")
    Gui, Add, Text, xs y+10, Please read the help section for more details.

    Gui, Tab 
    btnWid := (PrefsLargeFonts=1) ? 90 : 55
    GuiAddCollapseBtn("xm+1 y+15 h" thisBtnHeight " w35")
    Gui, Add, Button, x+5 hp w%btnWid% gBtnHelpBrushes, &Help
    Gui, Add, Button, x+5 hp wp-5 Default gBtnCloseWindow, C&lose

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Brushes tool: " appTitle, winPos)
    SetTimer, updateUIbrushTool, -125
    SetTimer, resetOpeningPanel, -300
}

BtnHelpBrushes() {
   msgBoxWrapper(appTitle ": HELP", "The brushes tool panel offers 8 distinct types of brushes and each customizable in its own ways. You can use keyboard shortcuts to switch brush types or control their settings when the main window is active. Please see the keyboard shortcuts help panel for more details.`n`nPlease note, the deformer brushes (smudge, pinch and bulge) give best results when the brush softness is set to about 45% and opacity 100%. These brushes may yield undesired results in areas with partially opaque pixels.`n`nBy setting stepping option to a low value, the application may freeze at times, while it paints brushes at every given step.`n`nSome of the brush randomize options apply only to some types of brushes. They might apply at the beginning of a brush stroke or continously during painting, based on brush settings.", -1, 0, 0)
}

btnHelpToolbar() {
   msgBoxWrapper(appTitle ": HELP", "The QPV toolbar contains multi-functional buttons that help users perform actions with ease. The associated actions may change depending on the currently active context or tool, even if the icons do not change visually. However, the tooltips will always reflect this. Regardless, the associated actions will always have a similar underlying meaning.`n`nSilder icons`nThe icons can act as sliders. You have to click and drag up or down to decrease the associated value; e.g., brush related parameters or image zoom level.`n`nTwo actions.`nThe tool tips may indicate L or R actions. These are actions associated with the Left and Right click buttons.`n`nThe toolbar can be navigated with the keyboard. To access it, one can press Shift+Tab. Once the toolbar is focused, users can use the arrow keys to navigate between the icons. Enter is associated with the L-click action and Shift+Enter to the R-click one.", -1, 0, 0)
}

ToggleBrushColors() {
   BtnToggleBrushColors("infoz")
}

readableColorFromHEX(given) {
   Gdip_FromARGB("0xFF" given, cA, cR, cG, cB)
   Return pixelColor := cR ", " cG ", " cB
}

BtnToggleBrushColors(dummy:=0, kk:=0) {
   ; If (BrushToolType!=1 && BrushToolType!=2)
   ;    Return

   BrushToolUseSecondaryColor := !BrushToolUseSecondaryColor
   If (AnyWindowOpen=74)
   {
      UpdateUIadjustVPcolors()
   } Else If (AnyWindowOpen=89 && liveDrawingBrushTool=1)
   {
      UpdateUIsimpleAdjustColors()
   } Else If (AnyWindowOpen=70)
   {
      updateUIalphaMaskerPanel()
   } Else If (AnyWindowOpen=64)
   {
      updateUIbrushTool()
   } Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
   {
      updateUIpastePanel()
   } Else If (AnyWindowOpen=23 && liveDrawingBrushTool=1)
   {
      updateUIfillPanel()
   } Else If (AnyWindowOpen=23)
   {
      flipVars(FillAreaColor, FillArea2ndColor)
      flipVars(FillAreaOpacity, FillArea2ndOpacity)
      updateColoredRectCtrl(FillArea2ndColor, "FillArea2ndColor")
      updateColoredRectCtrl(FillAreaColor, "FillAreaColor")
      uiSlidersArray["FillArea2ndOpacity", 14] := -1
      uiSlidersArray["FillAreaOpacity", 14] := -1
      BrushToolAcolor := (BrushToolUseSecondaryColor=1) ? FillArea2ndColor : FillAreaColor
      BrushToolBcolor := (BrushToolUseSecondaryColor=1) ? FillAreaColor : FillArea2ndColor
      BrushToolAopacity := (BrushToolUseSecondaryColor=1) ? FillArea2ndOpacity : FillAreaOpacity
      BrushToolBopacity := (BrushToolUseSecondaryColor=1) ? FillAreaOpacity : FillArea2ndOpacity
      GuiRefreshSliders()
   } Else If (AnyWindowOpen=30 || AnyWindowOpen=65)
   {
      If (BrushToolAcolor!=DrawLineAreaColor && BrushToolBcolor!=DrawLineAreaColor)
      {
         BrushToolAcolor := DrawLineAreaColor
         BrushToolAopacity := DrawLineAreaOpacity
      }
      thisA := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      thisAop := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      updateColoredRectCtrl(thisA, "DrawLineAreaColor")
      DrawLineAreaColor := thisA
      DrawLineAreaOpacity := thisAop
      uiSlidersArray["DrawLineAreaOpacity", 14] := -1
      GuiRefreshSliders()
   } Else If (AnyWindowOpen=66) ; flood fill tool
   {
      If (BrushToolAcolor!=FloodFillColor && BrushToolBcolor!=FloodFillColor)
      {
         BrushToolAcolor := FloodFillColor
         BrushToolAopacity := FloodFillClrOpacity
      }
      thisA := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      thisAop := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      updateColoredRectCtrl(thisA, "FloodFillColor")
      FloodFillColor := thisA
      FloodFillClrOpacity := thisAop
      uiSlidersArray["FloodFillClrOpacity", 14] := -1
      GuiRefreshSliders()
   } Else If (AnyWindowOpen=68) ; fill behind tool
   {
      If (BrushToolAcolor!=FillBehindColor && BrushToolBcolor!=FillBehindColor)
      {
         BrushToolAcolor := FillBehindColor
         BrushToolAopacity := FillBehindClrOpacity
      }
      thisA := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      thisAop := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      updateColoredRectCtrl(thisA, "FillBehindColor")
      FillBehindColor := thisA
      FillBehindClrOpacity := thisAop
      uiSlidersArray["FillBehindClrOpacity", 14] := -1
      GuiRefreshSliders()
   } Else If (AnyWindowOpen=32 && liveDrawingBrushTool=1)
   {
      updateUIInsertTextPanel()
   } Else If (AnyWindowOpen=32)
   {
      flipVars(TextInAreaBgrColor, TextInAreaFontColor)
      flipVars(TextInAreaBgrOpacity, TextInAreaFontOpacity)
      updateColoredRectCtrl(thisA, "TextInAreaFontColor")
      updateColoredRectCtrl(thisB, "TextInAreaBgrColor")
      uiSlidersArray["TextInAreaFontOpacity", 14] := -1
      uiSlidersArray["TextInAreaBgrOpacity", 14] := -1
      BrushToolAcolor := (BrushToolUseSecondaryColor=1) ? TextInAreaBgrColor : TextInAreaFontColor
      BrushToolBcolor := (BrushToolUseSecondaryColor=1) ? TextInAreaFontColor : TextInAreaBgrColor
      BrushToolAopacity := (BrushToolUseSecondaryColor=1) ? TextInAreaBgrOpacity : TextInAreaFontOpacity
      BrushToolBopacity := (BrushToolUseSecondaryColor=1) ? TextInAreaFontOpacity : TextInAreaBgrOpacity
      GuiRefreshSliders()
   }

   If (dummy="infoz")
   {
      labelu := (AnyWindowOpen=64 || isNowAlphaPainting()) ? "Brush" : "Primary"
      thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
      thisColorH := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
      thisColor := readableColorFromHEX(thisColorH)
      moreInfos .= "`nOpacity: " Round(thisOpacity/255*100) "%"
      If (kk!="no-leds")
         showLEDprimaryColor()

      If (BrushToolType>2 && AnyWindowOpen=64)
         showTOOLtip("Opacity: " Round(thisOpacity/255*100) "%`nThe current brush has no color option")
      Else
         showTOOLtip(labelu " color: " thisColor moreInfos, "ToggleBrushColors", 1)
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } 

   If (ShowAdvToolbar=1)
   {
      delayedWriteTlbrColors(1)
      updateTlbrColorsSwatch()
   }

   If (imgEditPanelOpened=1 && AnyWindowOpen)
      livePreviewsImageEditing()
}

showLEDprimaryColor() {
   If (WinActive("A")=hSetWinGui)
   {
      SetTimer, StopColorPicker, % -msgDisplayTime//2 + 250
      Return
   }

   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisColorH := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   GetPhysicalCursorPos(pX, pY)
   a := 2 - Round(thisOpacity/128, 2)
   f := Round(2*a, 2) - Round(thisOpacity/256, 2)
   z := Round(thisOpacity*f)
   If (z>192 || thisOpacity>100)
      z := 192 + (thisOpacity - 100)//2.5
   ; ToolTip, % a "=" f "=" z "=" thisOpacity, , , 2
   createLEDgui(imgHUDbaseUnit, clampInRange(z, 2, 255), pX + 2, pY + 2, thisColorH)
   ; showLEDgui(thisColorH, pX + 2, pY + 2)
   SetTimer, StopColorPicker, % -msgDisplayTime//2 + 250
}

updateTlbrColorsSwatch() {
   thisHwnd := tlbrIconzList["BTNcolorsSwatch", 1]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   If thisHwnd
      tlbrSetImageIcon("colorz-swatch", thisHwnd, W, H)
}

distanceBetweenTwoPoints(x1, y1, x2, y2) {
   Return Sqrt((x2 - x1)**2+(y2 - y1)**2)
}

pointsOnCircle(radius, angle, cx, cy) {
    Static pi := 3.14159265
    obj := []
    angle := angle * (pi /180)   ; Convert from Degrees to Radians
    obj.x := cx + radius * sin(angle)
    obj.y := cy + radius * cos(angle)
    return obj
}

MouseDeltaAngle180(X1,Y1,X2,Y2) {
   ; from Bugz000
   return round((dllcall("msvcrt\atan2", "Double", (y2 - y1), "Double", (x2-x1), "CDECL Double") * (180/3.14159265358979323846264338327950288419716939937)),3)
}

MouseDeltaAngle360(X1,Y1,X2,Y2) {
   Static 2p := 2*3.14159265358979
   static TOdeg := 180/3.14159265358979
   px := x2 - x1
   py := y2 - y1

   r := DllCall("msvcrt\atan2", "Double", py, "Double", px, "CDECL Double")
   r := (r<0) ? r + 2p : r
   zr := Round( r * TOdeg, 8 )
   return zr
}

getAngleBetweenTwoPoints(x1, y1, x2, y2, mode:=1) {
   ; function from tidbit
   ; based on http://stackoverflow.com/questions/2339487/calculate-angle-of-2-points
   ; returns 0-359.999
  angle := APIatan2(y1-y2, x1-x2)*(180/3.14159)*-1
  if (mode=2)
     angle += (angle<0) ? 360 : 0 ; or should it be 359? whatever.
  return angle
}

APIatan2(y,x) { 
   Return dllcall("msvcrt\atan2","Double",y, "Double",x, "CDECL Double")
}

ResetColorsToBW() {
   If (isNowAlphaPainting()=1 || BrushToolType!=3 && AnyWindowOpen=64)
   {
      showTOOLtip("Colors set to black and white")
      isOkay := (BrushToolAopacity>=254 && BrushToolBopacity>=254) ? 1 : 0
      SetTimer, RemoveTooltip, % -msgDisplayTime//1.5
      showLEDprimaryColor()
      isGood := (BrushToolAcolor="ffFFff" && BrushToolBcolor="000000") || (BrushToolBcolor="ffFFff" && BrushToolAcolor="000000") ? 1 : 0
      ; fnOutputDebug(isGood "." isOkay " opacities now:" BrushToolAopacity " / " BrushToolBopacity)
      If (isOkay=1 && isGood=1)
         Return

      BrushToolAcolor := "ffFFff"
      BrushToolBcolor := "000000"
      updateColoredRectCtrl(BrushToolAcolor, "BrushToolAcolor")
      updateColoredRectCtrl(BrushToolBcolor, "BrushToolBcolor")
      BtnResetBrushColorBopacity()
      BtnResetBrushColorAopacity()
      delayedWriteTlbrColors(1)
      showLEDprimaryColor()
      If (ShowAdvToolbar=1)
         updateTlbrColorsSwatch()
      lastInvoked := A_TickCount
   }
}

BtnSetClonerBrushSource() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<450)
      Return

   If (AnyWindowOpen!=64 || !isImgEditingNow())
      Return

   If (BrushToolType!=3)
      toggleBrushTypeCloner()

   liveDrawingBrushTool := 1
   showTOOLtip("Please click inside the image area to set the cloner brush source")
   ; SetTimer, RemoveTooltip, % -msgDisplayTime//2
   mustCaptureCloneBrush := 1
   interfaceThread.ahkPostFunction("setMenuBarState", "Disable", "PVmenu")
   interfaceThread.ahkassign("mustCaptureCloneBrush", mustCaptureCloneBrush)
   createGUItoolbar()
   If (panelWinCollapsed=0)
      toggleImgEditPanelWindow()
   lastInvoked := A_TickCount
}

BtnResetGradientCenter() {
   If (alphaMaskingMode>=1 && alphaMaskingMode!=5)
   {
      showTOOLtip("Alpha mask gradient center was reset")
      alphaMaskOffsetX := alphaMaskOffsetY := alphaMaskCoffsetX := alphaMaskCoffsetY := 0
      If (imgEditPanelOpened=1 && AnyWindowOpen>0)
      {
         livePreviewsImageEditing()
         UItriggerBrushUpdate()
      }
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BtnResetSpiralRayCenter() {
   f := (DrawLineAreaBorderCenter=4) ? "Rays" : "Spiral"
   If (DrawLineAreaBorderCenter=5)
      f := "Grid"

   showTOOLtip(f " center was reset")
   alphaMaskOffsetX := alphaMaskOffsetY := 0
   If (AnyWindowOpen=30)
      SetTimer, updateUIDrawLinesPanel, -150
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return
}

BtnSetTextureSource() {
   If (FillAreaColorMode!=6)
   {
      showTOOLtip("Color gradient center was reset")
      clrGradientOffX := clrGradientOffY := clrGradientCoffX := clrGradientCoffY := 0
      If (AnyWindowOpen=23)
         SetTimer, updateUIfillPanel, -150
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   showTOOLtip("Please click inside the image area to set the texture source coordinates")
   ; SetTimer, RemoveTooltip, % -msgDisplayTime//2
   mustCaptureCloneBrush := 1
   interfaceThread.ahkPostFunction("setMenuBarState", "Disable", "PVmenu")
   interfaceThread.ahkassign("mustCaptureCloneBrush", mustCaptureCloneBrush)
   createGUItoolbar()
   If (panelWinCollapsed=0)
      toggleImgEditPanelWindow()
}

updateUIfloodFillPanel() {
   If (AnyWindowOpen!=66)
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide

   actu := (FloodFillTolerance<3) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % actu, FloodFillDynamicOpacity
   GuiControl, % actu, FloodFillCartoonMode
   GuiControl, % actu, FloodFillEightWays
   GuiControl, % actu, FloodFillAltToler

   If (FloodFillTolerance<3)
   {
      FloodFillCartoonMode := 0
      GuiControl, SettingsGUIA: , FloodFillCartoonMode, 0
   }

   uiSlidersArray["FloodFillOpacity", 10] := !FloodFillCartoonMode
   uiSlidersArray["FloodFillClrOpacity", 10] := !FloodFillCartoonMode

   actu := (FloodFillCartoonMode=1 || FloodFillTolerance<3) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % actu, FloodFillDynamicOpacity

   actu := (FloodFillCartoonMode=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % actu, FloodFillBlendMode
   GuiControl, % actu, PickuFloodFillColor
   actu := (FloodFillCartoonMode=1) ? "SettingsGUIA: Hide" : "SettingsGUIA: Show"
   GuiControl, % actu, FloodFillColor

   If (FloodFillTolerance>1 && FloodFillCartoonMode!=1)
      GuiControl, SettingsGUIA: Enable, FloodFillDynamicOpacity

   actu := (FloodFillModus!=1 && FloodFillTolerance>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, FloodFillEightWays
   If (viewportQPVimage.imgHandle)
      GuiControl, SettingsGUIA: Disable, FloodFillUseAlpha

   thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
   %thisOpa% := FloodFillClrOpacity
   GuiRefreshSliders()
   SetTimer, dummyRefreshImgSelectionWindow, -150
   SetTimer, WriteSettingsFloodFillPanel, -200
}

ReadSettingsFloodFillPanel(act:=0) {
   RegAction(act, "BrushToolOutsideSelection",, 2, 1, 3)
   RegAction(act, "FloodFillOpacity",, 2, 4, 255)
   RegAction(act, "FloodFillBlendMode",, 2, 1, 23)
   RegAction(act, "FloodFillColor",, 3)
   RegAction(act, "FloodFillClrOpacity",, 2, 1, 255)
   RegAction(act, "FloodFillAltToler",, 2, 1, 3)
   RegAction(act, "FloodFillDynamicOpacity",, 1)
   RegAction(act, "FloodFillModus",, 1)
   RegAction(act, "FloodFillUseAlpha",, 1)
   RegAction(act, "FloodFillTolerance",, 2, 0, 256)
}

WriteSettingsFloodFillPanel() {
   ReadSettingsFloodFillPanel(1)
}

updateLabelFillAreaTextureX() {
    Return "Size X: " 3*FillAreaGradientPosA " px"
}

updateLabelFillAreaTextureY() {
    texSize := 3 * FillAreaGradientPosA
    thisu := texSize + Round(texSize * (FillAreaGradientPosB/250))
    Return "Size Y: " thisu " px"
}

updateLabelColorGammaLevel() {
    Return "Gamma: " Round(userImgAdjustGamma/300,2)
}

updateLabelDrawLineThickness() {
    If (viewportQPVimage.imgHandle)
       Return "Line width: " Round(DrawLineAreaContourThickness * (DrawLineAreaThickScale/100)) " pixels"
    Else
       Return "Line width: " DrawLineAreaContourThickness " pixels"
}

updateLabelBrushStep() {
   stepu := (BrushToolStepping<=2 || BrushToolStepping=251) ? "AUTO" : BrushToolStepping " px"
   If (BrushToolStepping=0)
      stepu := "NONE"
   Return "Steps interpolation: " stepu
}

updateLabelMaskCurvePath() {
   contrLvl := "Points tension: " Round(alphaMaskClrBintensity/255, 2)
   If (alphaMaskClrBintensity<15)
      contrLvl := "Path mode: polygonal"
   Else If (alphaMaskClrBintensity>250)
      contrLvl := "Path mode: Bézier"

   Return contrLvl
}

updateUIbrushTool() {
   If (AnyWindowOpen!=64)
      Return

   Gui, SettingsGUIA: Submit, NoHide
   If (BrushToolType>2)
      BrushToolUseSecondaryColor := 0

   liveDrawingBrushTool := 1
   If (CurrentPanelTab=1)
   {
      uiSlidersArray["BrushToolBopacity", 10] := (BrushToolUseSecondaryColor!=1) ? 0 : 1
      uiSlidersArray["BrushToolAopacity", 10] := (BrushToolUseSecondaryColor=1) ? 0 : 1
      actuA := (BrushToolUseSecondaryColor=1) ? "SettingsGUIA: Hide" : "SettingsGUIA: Show"
      actuB := (BrushToolUseSecondaryColor!=1) ? "SettingsGUIA: Hide" : "SettingsGUIA: Show"
      GuiControl, % actuB, PickuBrushToolBcolor
      GuiControl, % actuA, PickuBrushToolAcolor
      GuiControl, % actuB, BrushToolBcolor
      GuiControl, % actuA, BrushToolAcolor
      If (BrushToolUseSecondaryColor=1)
      {
         GuiControl, SettingsGUIA:, UIbtnBrushColorB, X
         GuiControl, SettingsGUIA:, UIbtnBrushColorA, -
         allGood := 0
      } Else
      {
         GuiControl, SettingsGUIA:, UIbtnBrushColorB, -
         GuiControl, SettingsGUIA:, UIbtnBrushColorA, X
         allGood := 1
      }

      If (BrushToolType>2)
      {
         GuiControl, SettingsGUIA: Disable, UIbtnBrushColorB
         GuiControl, SettingsGUIA: Disable, UIbtnBrushColorA
         GuiControl, SettingsGUIA: Hide, PickuBrushToolAcolor
         GuiControl, SettingsGUIA: Hide, BrushToolAcolor
         GuiUpdateVisibilitySliders("SettingsGUIA: Hide", "BrushToolBopacity")
      } Else
      {
         GuiUpdateVisibilitySliders("SettingsGUIA: Show", "BrushToolBopacity")
         GuiControl, SettingsGUIA: Enable, UIbtnBrushColorB
         GuiControl, SettingsGUIA: Enable, UIbtnBrushColorA
         If (allGood=1)
         {
            GuiControl, SettingsGUIA: Show, PickuBrushToolAcolor
            GuiControl, SettingsGUIA: Show, BrushToolAcolor
         }
      }

      actu := (BrushToolType=3) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, BrushToolOverDraw

      tehLabel := (BrushToolType>=6) ? "&Auto-scale deformer" : "&Airbrush mode"
      GuiControl, SettingsGUIA: Text, BrushToolOverDraw, %tehLabel%
      uiSlidersArray["BrushToolStepping", 10] :=  (BrushToolType>=7) ? 0 : 1
      uiSlidersArray["BrushToolSoftness", 10] := (BrushToolTexture>1 || BrushToolType=1) ? 0 : 1
      uiSlidersArray["BrushToolAspectRatio", 10] := (BrushToolTexture>1 && BrushToolType>1) ? 0 : 1

      actu := (BrushToolType=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, BrushToolTexture

      actu := (BrushToolType=3) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
      GuiControl, % actu, uiBtnSetCloner

      actu := (BrushToolType=3 || BrushToolType=8) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, BrushToolDynamicCloner

      tehLabel := (BrushToolType=8) ? "Bulge out&wards more" : "D&ynamic X/Y source coordinates"
      GuiControl, SettingsGUIA: Text, BrushToolDynamicCloner, %tehLabel%

      actu := (BrushToolType=4) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
      GuiControl, % actu, BrushToolEraserRestore

      theSizeLabel := (BrushToolDoubleSize!=1) ? "Diameter: $€ px" : "Radius: $€ px"
      uiSlidersArray["BrushToolAngle", 10] := !BrushToolAutoAngle
      uiSlidersArray["BrushToolSize", 5] := theSizeLabel

      If (BrushToolType=1 && BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
         GuiControl, SettingsGUIA: Disable, BrushToolOverDraw
      Else If (BrushToolType=1 || BrushToolType=2)
         GuiControl, SettingsGUIA: Enable, BrushToolOverDraw

      SetTimer, WriteSettingsBrushPanel, -300
   } Else If (CurrentPanelTab=2)
   {
      uiSlidersArray["BrushToolWetness", 10] := (BrushToolType<=2 || BrushToolType>=6) ? 1 : 0
      uiSlidersArray["BrushToolBlurStrength", 10] := (BrushToolType=3 || BrushToolType=5) ? 1 : 0

      actu := (BrushToolType=2) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, BrushToolBlendMode
      GuiControl, % actu, BlendModesFlipped

      actu := (BrushToolType=3 || BrushToolType=5) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, BrushToolApplyColorFX

      actu2 := (BrushToolApplyColorFX=1 && (BrushToolType=3 || BrushToolType=5)) ? 1 : 0
      uiSlidersArray["PasteInPlaceLight", 10] := actu2
      uiSlidersArray["PasteInPlaceGamma", 10] := actu2
      uiSlidersArray["PasteInPlaceHue", 10] := actu2
      uiSlidersArray["PasteInPlaceSaturation", 10] := actu2

      wetLabel := (BrushToolType>=6) ? "Deform intensity" : "Wetness"
      uiSlidersArray["BrushToolWetness", 5] := wetLabel

      actu := (BrushToolType<6) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, infoSymmetryLabel
      GuiControl, % actu, BTNuiSetLabelSymmetry
      GuiControl, % actu, BrushToolSymmetryX
      GuiControl, % actu, BrushToolSymmetryY
      SetTimer, WriteSettingsBrushPanel, -300
   } Else If (CurrentPanelTab=3)
   {
      actu := (BrushToolType>1 && BrushToolTexture=1) ? 1 : 0
      uiSlidersArray["BrushToolRandomSoftness", 10] := actu
   }

   createLivePreviewBrush()
   GuiRefreshSliders()
   SetTimer, dummyRefreshImgSelectionWindow, -400
}

UItriggerBrushUpdate(actu:="noPreview", delayu:=100) {
   If (AnyWindowOpen=32)
   {
      fn := Func("updateUIInsertTextPanel").Bind(actu)
      SetTimer, % fn, % -delayu
   } Else If (AnyWindowOpen=23)
   {
      fn := Func("updateUIfillPanel").Bind(actu)
      SetTimer, % fn, % -delayu
   } Else If (AnyWindowOpen=26 || AnyWindowOpen=78)
   {
      SetTimer, updateUIblurPanel, % -delayu
   } Else If (AnyWindowOpen=69)
   {
      SetTimer, updateUIzoomBlurPanel, % -delayu
   } Else If (AnyWindowOpen=74)
   {
      SetTimer, UpdateUIadjustVPcolors, % -delayu
   } Else If (AnyWindowOpen=70)
   {
      fn := Func("updateUIalphaMaskerPanel").Bind(actu)
      SetTimer, % fn, % -delayu
   } Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
   {
      fn := Func("updateUIpastePanel").Bind(actu)
      SetTimer, % fn, % -delayu
   } Else If (AnyWindowOpen=64)
   {
      SetTimer, updateUIbrushTool, % -delayu
   } Else If (AnyWindowOpen=81)
   {
      SetTimer, updateUIsymmetricaPanel, % -delayu
   } Else If (AnyWindowOpen=89)
   {
      SetTimer, UpdateUIsimpleAdjustColors, % -delayu
   }
}

createBrushShapePath(brushSize, tkX, tkY, thisAR, angleu, obju:=0) {
   If (brushSize=1)
      brushSize := 1.25

   If (obju.arVP!=obju.arImg && IsObject(obju))
   {
      mustRotate := (angleu!=0 && thisAR!=0) ? 1 : 0
      brushSizeW := Round(brushSize * (obju.imgW / obju.pVPimgW), 5)
      brushSizeH := Round(brushSize * (obju.imgH / obju.pVPimgH), 5)
      brushSize := 0 ; max(brushSizeW, brushSizeH)
      ; ToolTip, % brushSize "||" brImgSelW "|" brImgSelH , , , 2
      ; brimgSelPx := 0 - Round(brushSize/2 - brImgSelW/2)
      ; brimgSelPy := 0 - Round(brushSize/2 - brImgSelH/2)
      ; ToolTip, % arVP "|" arImg "`n" scfX "|" scfY "|" brushSize , , , 2
   } Else
   {
      mustRotate := (angleu!=0 && brushSize>1 && thisAR!=0) ? 1 : 0
      brushSizeW := brushSizeH := brushSize
   }

   thisAR := 1 - Abs(thisAR)/105
   brImgSelW := (BrushToolAspectRatio>0) ? brushSizeW * thisAR : brushSizeW
   brImgSelH := (BrushToolAspectRatio<0) ? brushSizeH * thisAR : brushSizeH
   brimgSelPx := 0 - (brImgSelW - brushSize)/2
   brimgSelPy := 0 - (brImgSelH - brushSize)/2
   tmpMatrix := Gdip_CreateMatrix()
   tmpPath := Gdip_CreatePath()

   Gdip_AddPathEllipse(tmpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
   If (mustRotate=1)
      trGdip_RotatePathAtCenter(tmpPath, angleu)

   If (brushSize<2)
      brushSize := 1.5
   Gdip_TranslateMatrix(tmpMatrix, tkX - brushSize/2, tkY - brushSize/2)
   Gdip_TransformPath(tmpPath, tmpMatrix)
   Gdip_DeleteMatrix(tmpMatrix)
   Return tmpPath
}

createLivePreviewBrush() {
    Static imgBoxSize := 100
    whichBitmap := useGdiBitmap()
    If !validBMP(whichBitmap)
       Return

    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, imgBoxSize, imgBoxSize, coreDesiredPixFmt)
    If !validBMP(cornersBMP)
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GraphicsClear(G, "0xFF888888")
    brushSize := (BrushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
    whichBitmap := useGdiBitmap()
    If ((BrushToolType=3 || BrushToolType=5) && CurrentPanelTab=2)
    {
       brushu := createClonedBrushBitmap(brushSize, 101 - BrushToolSoftness, BrushToolAngle, BrushToolAspectRatio, whichBitmap, 0, 0, 1, 1, 1)
       applyPersonalizedColorsBMP(brushu, 1, BrushToolBlurStrength, BrushToolApplyColorFX)
       thisMainOpacity := 1
    } Else If (BrushToolType=3 && CurrentPanelTab=1)
    {
       brushu := createClonedBrushBitmap(brushSize, 101 - BrushToolSoftness, BrushToolAngle, BrushToolAspectRatio, whichBitmap, 0, 0, 1, 0, 1)
       thisMainOpacity := BrushToolAopacity / 255
    } Else
    {
       thisMainOpacity := 1
       If (BrushToolTexture>1)
          thisMainOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity / 255 : BrushToolAopacity / 255

       startToolColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
       If (BrushToolType>2)
          startToolColor := "ffFFff"

       thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       thisOpacity := Format("{1:#x}", thisOpacity)
       brushSofty := (BrushToolType=1) ? 99 : 101 - BrushToolSoftness
       brushu := createGradientBrushBitmap(startToolColor, brushSofty, imgBoxSize, BrushToolAngle, BrushToolAspectRatio, thisOpacity)
    }

    tzGdip_DrawImage(G, brushu, 2, 2, 95, 95, , , , , thisMainOpacity)
    thisX := (BrushToolDoubleSize=1) ? imgBoxSize//2 : 0
    If (BrushToolAngle=0 && BrushToolAspectRatio=0)
       Gdip_FillRectangle(G, pBrushD, thisX, imgBoxSize//2 - 2, imgBoxSize, 4)

    thisHwnd := (CurrentPanelTab=2) ? hCropCornersPic2 : hCropCornersPic
    Gdip_SetPbitmapCtrl(thisHwnd, cornersBMP)
    Gdip_DeleteGraphics(G)
    trGdip_DisposeImage(brushu, 1)
    trGdip_DisposeImage(cornersBMP, 1)
}

PanelChangeHamDistThreshold() {
    Global editFa, editFb, txtline3

    If !testIsDupesList()
       msgu := "WARNING: The files list does not seem to contain pairs of images identified as duplicates"

    If (!InStr(resultedFilesList[currentFileIndex, 23], "_") && !msgu)
       msgu := "WARNING: The files list does not seem to contain pairs of images filtered by Hamming distance"

    If (dupesHashesData.Count()<2 && !msgu)
       msgu := "WARNING: The files list does not seem to have cached data to allow changing the similarity threshold"

    If msgu
    {
       showTOOLtip(msgu)
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       If (SLDtypeLoaded=3)
          SetTimer, PanelFindDupes, -200
       Return
    }

    thisBtnHeight := createSettingsGUI(62, A_ThisFunc)
    btnWid := 70
    txtWid := 260
    If (PrefsLargeFonts=1)
    {
       btnWid := btnWid + 80
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    EditWid := Round(btnWid*2.5)
    If !hamUppLim
       hamUppLim := userFindDupesHamDistLvl

    UserHamDistCacheFilterMonoGroups := 1
    Gui, Add, Text, x15 y15 w%txtWid% Section, Please set the range for the Hamming distance threshold. Lower ranges equate to a stricter criteria - more closely looking images. Cached threshold range: 0 - %userFindDupesHamDistLvl%.
    Gui, Add, Text, y+15 w%btnWid%, Lower limit:
    Gui, Add, Text, x+15 wp, Upper limit:
    GuiAddEdit("xs y+5 wp number -multi limit2 veditF5", hamLowLim, "Lower limit")
    Gui, Add, UpDown, vhamLowLim Range0-%userFindDupesHamDistLvl%, % hamLowLim

    GuiAddEdit("x+15 wp number -multi limit2 veditF6", hamUppLim, "Upper limit")
    Gui, Add, UpDown, vhamUppLim Range0-%userFindDupesHamDistLvl%, % hamUppLim

    sml := (PrefsLargeFonts=1) ? 35 : 25
    Gui, Add, Text, xs y+%sml% vtxtLine1, Mean-Squared Difference threshold:
    Gui, Add, Text, y+15 w%btnWid% vtxtLine2, Lower limit:
    Gui, Add, Text, x+15 wp vtxtLine3, Upper limit:
    GuiAddEdit("xs y+5 wp number -multi limit3 vEditFa", mseLowLim, "Lower limit")
    Gui, Add, UpDown, vmseLowLim Range0-950, % mseLowLim

    GuiAddEdit("x+15 wp number -multi limit3 vEditFb", mseUppLim, "Upper limit")
    Gui, Add, UpDown, vmseUppLim Range0-950, % mseUppLim
    Gui, Add, Text, xs y+15 wp, String filter:
    Gui, Add, Checkbox, x+15 Checked%UserHamDistStringInvert% vUserHamDistStringInvert, &Must not contain it
    GuiAddEdit("xs y+5 w" EditWid " -multi gUIeditsGenericAllowCtrlBksp vUserHamDistStringFilter", UserHamDistStringFilter, "String filter")
    GuiAddButton("x+1 hp w45 gUIstringEditFilterErase", "X", "Clear edit field")
    GuiAddDropDownList("xs y+7 w" btnWid " gupdateUIFiltersPanel AltSubmit Choose" userHamDistStringStringPos " vuserHamDistStringStringPos", "Anywhere|Begins with|Ends with|RegEx", "String filter matching mode")
    GuiAddDropDownList("x+2 w" btnWid " gupdateUIFiltersPanel AltSubmit Choose" userHamDistStringFilterWhat " vuserHamDistStringFilterWhat", "Full path|Folder path|File name", "Apply filter based on")
    Gui, Add, Checkbox, xs y+25 Checked%UserHamDistCacheFilterMonoGroups%  vUserHamDistCacheFilterMonoGroups, &Filter out matches without pairs
    Gui, Add, Checkbox, xs y+7 Checked%BreakDupesGroups%  vBreakDupesGroups, &Break the groups based on the similarity index
    If (testWasMSEdupes()!=1)
    {
       GuiControl, SettingsGUIA: Disable, mseUppLim 
       GuiControl, SettingsGUIA: Disable, mseLowLim 
       GuiControl, SettingsGUIA: Disable, editFa 
       GuiControl, SettingsGUIA: Disable, editFb 
       GuiControl, SettingsGUIA: Disable, txtLine1
       GuiControl, SettingsGUIA: Disable, txtLine2
       GuiControl, SettingsGUIA: Disable, txtLine3
    }

    Gui, Add, Button, xs y+25 w%btnWid% h%thisBtnHeight% Default gBtnChangeHamDistThreshold, &Update
    Gui, Add, Button, x+5 hp wp+10 gPanelFindDupes, &Main panel
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Change hashes threshold: " appTitle)
}

BtnChangeHamDistThreshold() {
   Gui, SettingsGUIA: Default
   GuiControlGet, hamUppLim
   GuiControlGet, hamLowLim
   GuiControlGet, mseUppLim
   GuiControlGet, mseLowLim
   GuiControlGet, UserHamDistStringFilter
   GuiControlGet, UserHamDistStringInvert
   GuiControlGet, userHamDistStringFilterWhat
   GuiControlGet, userHamDistStringStringPos
   GuiControlGet, UserHamDistCacheFilterMonoGroups
   GuiControlGet, BreakDupesGroups

   BtnCloseWindow()
   r := changeHdistLevelCached(0, hamLowLim, hamUppLim, mseLowLim, mseUppLim)
   If (r<1)
   {
      showTOOLtip("Found no duplicate images in the specified Hamming distance range.`nFiles list unchanged.")
      SoundBeep 300, 100
      SetTimer, PanelChangeHamDistThreshold, -350
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else 
   {
      currentFileIndex := 1
      dummyTimerDelayiedImageDisplay(150)
   }
}

PanelSearchAndReplaceIndex() {
    Global editF5, editF6, performSRinSeenDB, performSRinDynas
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (maxFilesIndex<3 && !filesFilter)
    {
       showTOOLtip("WARNING: Insufficient files are currently indexed.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    getSelectedFiles(0, 1)
    thisBtnHeight := createSettingsGUI(56, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    If (SLDtypeLoaded=3)
       infos := "`n`nThis action will affect only folder paths."

    If (mustRecordSeenImgs!=1 || performSRinSeenDB="")
       performSRinSeenDB := 0

    If (performSRinDynas="")
       performSRinDynas := 0

    If (markedSelectFile<2 || SLDtypeLoaded=3)
       limitSearchReplaceSelected := 0

    imgPath := resultedFilesList[currentFileIndex, 1]
    doPwd := (userPrivateMode=1) ? " password " : ""
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    Gui, Add, Text, x15 y15 w%txtWid% Section, Please type what to search for and what to replace it with. This panel is meant to help you fix broken files lists. e.g., files moved to a different folder. RegEx, tokens or wildcards are not supported. %infos%
    Gui, Add, Text, y+15 wp, Search for:
    GuiAddEdit("y+5 wp " doPwd " veditF5 r1 gUIeditsGenericAllowCtrlBksp", OutDir)
    Gui, Add, Text, y+15 wp, Replace with:
    GuiAddEdit("y+5 wp " doPwd " veditF6 r1 gUIeditsGenericAllowCtrlBksp", "")
    Gui, Add, Checkbox, y+15 Checked%performSRinSeenDB% vperformSRinSeenDB gUItogglePerformSearchSeenDB, Perform action in the seen images database as well
    Gui, Add, Checkbox, y+15 Checked%performSRinDynas% vperformSRinDynas , Perform action over the main folders list as well
    Gui, Add, Checkbox, y+15 Checked%limitSearchReplaceSelected% vlimitSearchReplaceSelected gUItogglePerformSearchSeenDB, Apply action only on the selected files
    If (mustRecordSeenImgs!=1)
       GuiControl, Disable, performSRinSeenDB

    If (markedSelectFile<2 || SLDtypeLoaded=3)
       GuiControl, Disable, limitSearchReplaceSelected

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBTNperformIndexSearchReplace, &Perform
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Search and replace through the files index: " appTitle)
}

UItogglePerformSearchSeenDB() {
   Gui, SettingsGUIA: Default
   GuiControlGet, performSRinSeenDB
   GuiControlGet, limitSearchReplaceSelected
   ; actu := (performSRinSeenDB=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   ; GuiControl, % actu, performSRinDynas

   ; actu := (performSRinSeenDB=1 || SLDtypeLoaded=3 || markedSelectFile<2) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   ; GuiControl, % actu, limitSearchReplaceSelected
}

BTNperformIndexSearchReplace() {
   Gui, SettingsGUIA: Default
   GuiControlGet, editF5
   GuiControlGet, editF6
   GuiControlGet, limitSearchReplaceSelected
   GuiControlGet, performSRinSeenDB
   GuiControlGet, performSRinDynas
   If (editF5="")
   {
      showTOOLtip("WARNING: No search criteria given")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (editF5==editF6)
   {
      showTOOLtip("WARNING: Both fields are equal: what to search for and replace with.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   If (mustRecordSeenImgs=1 && performSRinSeenDB=1)
   {
      SearchAndReplaceSeenDB(editF5, editF6)
      Sleep, 500
   }

   SearchAndReplaceThroughIndex(editF5, editF6, 0, 0)
   If (performSRinDynas=1)
   {
      listu := getDynamicFoldersList()
      listu := StrReplace(listu, "`n", "\`n")
      listu := StrReplace(listu, editF5, editF6)
      listu := StrReplace(listu, "\\", "\")
      DynamicFoldersList := StrReplace(listu, "\`n", "`n")
      If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
         recreateDynaFoldersSQLdbList(DynamicFoldersList)
   }
}

toggleQuickMoveActionKeys() {
   allowUserQuickFileActions := !allowUserQuickFileActions
   friendly := (allowUserQuickFileActions=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Quick file action shortcuts: " friendly, A_ThisFunc, 1)
   IniAction(1, "allowUserQuickFileActions", "General")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

updateUIquickFileActs(zz:=0) {
   If (zz!="z")
   {
      GuiControlGet, allowUserQuickFileActions
      IniAction(1, "allowUserQuickFileActions", "General")
   }

   actu := (allowUserQuickFileActions=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   Loop, 6
   {
      a := A_Index
      GuiControl, % actu, btnFldr%a%
      GuiControl, % actu, txtLine%a%
      GuiControl, % actu, QuickFileActFolder%a%
      GuiControl, % actu, QuickFileActAfter%a%
   }
}

UIeditsGenericAllowCtrlBksp(a, b, c) {
   hwnd := Format("{1:#x}", a) 
   GuiControlGet, thisV, %A_Gui%:, %A_GuiControl%
   allowCtrlBkspEdit(hwnd, thisV)
   ; TulTip(0, " - ", a, b, c, hwnd, A_GuiControl, thisV, A_Gui)
}

PanelQuickMoveConfigure() {
    Global btnFldr1, btnFldr2, btnFldr3, btnFldr4, btnFldr5, btnFldr6, txtLine5, txtLine6
    Static afterActionsList := "Do nothing after|Go to next image |Go to previous image"

    thisBtnHeight := createSettingsGUI(47, A_ThisFunc)
    btnWid := 60
    txtWid := 395
    EditWid := 305
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 100
       btnWid := btnWid + 30
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    tiny := (PrefsLargeFonts=1) ? 55 : 30
    tiny2 := (PrefsLargeFonts=1) ? 85 : 50
    thisW := (PrefsLargeFonts=1) ? 190 : 120

    ReadSettingsQuickKeysActsPanel()
    Gui, Add, Checkbox, x15 y15 Section w%txtWid% Checked%allowUserQuickFileActions% vallowUserQuickFileActions gupdateUIquickFileActs, Associate the keyboard keys from 1 to 6 to quick actions: move or copy images to user-defined destination folders.
    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine1, [ 1 ]
    GuiAddEdit("x+5 w" EditWid " r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder1", QuickFileActFolder1, "Folder destination #1.")
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr1, Browse
    GuiAddDropDownList("x+5 w" thisW " AltSubmit Choose" QuickFileActAfter1 " vQuickFileActAfter1", afterActionsList, "Once file action #1 executed")

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine2, [ 2 ]
    GuiAddEdit("x+5 w" EditWid " r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder2", QuickFileActFolder2, "Folder destination #2.")
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr2, Browse
    GuiAddDropDownList("x+5 w" thisW " AltSubmit Choose" QuickFileActAfter2 " vQuickFileActAfter2", afterActionsList, "Once file action #2 executed")

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine3, [ 3 ]
    GuiAddEdit("x+5 w" EditWid " r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder3", QuickFileActFolder3, "Folder destination #3.")
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr3, Browse
    GuiAddDropDownList("x+5 w" thisW " AltSubmit Choose" QuickFileActAfter3 " vQuickFileActAfter3", afterActionsList, "Once file action #3 executed")

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine4, [ 4 ]
    GuiAddEdit("x+5 w" EditWid " r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder4", QuickFileActFolder4, "Folder destination #4.")
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr4, Browse
    GuiAddDropDownList("x+5 w" thisW " AltSubmit Choose" QuickFileActAfter4 " vQuickFileActAfter4", afterActionsList, "Once file action #4 executed")

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine5, [ 5 ]
    GuiAddEdit("x+5 w" EditWid " r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder5", QuickFileActFolder5, "Folder destination #5.")
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr5, Browse
    GuiAddDropDownList("x+5 w" thisW " AltSubmit Choose" QuickFileActAfter5 " vQuickFileActAfter5", afterActionsList, "Once file action #5 executed")

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny% vtxtLine6, [ 6 ]
    GuiAddEdit("x+5 w" EditWid " r1 -wrap gUIeditsGenericAllowCtrlBksp vQuickFileActFolder6", QuickFileActFolder6, "Folder destination #6.")
    Gui, Add, Button, x+5 hp w%tiny2% gBTNchooseQuickActDestFolder vbtnFldr6, Browse
    GuiAddDropDownList("x+5 w" thisW " AltSubmit Choose" QuickFileActAfter6 " vQuickFileActAfter6", afterActionsList, "Once file action #6 executed")

    Gui, Add, Text, xs y+15 Center +0x200 w%tiny%, [ Del ]
    Gui, Add, Checkbox, x+5 w%EditWid% Checked%askDeleteFiles% vaskDeleteFiles, &Prompt before delete
    GuiAddDropDownList("x+5 w" thisW " AltSubmit Choose" deleteFileActAfter " vdeleteFileActAfter", afterActionsList, "After a file was deleted")
    Gui, Add, Text, xs y+10 hp +0x200 +hwndhTemp, Action on file name conflicts:
    GuiAddDropDownList("x+5 w" thisW - 20 " AltSubmit Choose" QuickFileActConflict " vQuickFileActConflict", "Skip files|Auto-rename|Overwrite|Ask user", [hTemp])
    Gui, Add, Text, xs y+15, Use Shift to move to given destination folder. Use Alt to open it in Explorer.

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBtnApplyQuickActionsPanel, &Apply
    Gui, Add, Button, x+5 hp wp gBtnHelpCopyMovePanel, Hel&p
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    updateUIquickFileActs("z")
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Configure quick action keys: " appTitle)
}

BtnApplyQuickActionsPanel() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   WriteSettingsQuickKeysActsPanel()
   BtnCloseWindow()
}

BTNchooseQuickActDestFolder(CtrlHwnd) {
   Static lastFolder
   If !lastFolder
      lastFolder := ResizeDestFolder ? ResizeDestFolder : A_MyDocuments

   GuiControlGet, varu, SettingsGUIA: Name, % CtrlHwnd
   ; ToolTip, % varu "`n" a "|" b "|" c , , , 2

   thisVar := SubStr(varu, 0)
   SelectImg := openFoldersDialogWrapper(lastFolder)
   OutDir := Trimmer(SelectImg)
   If !FolderExist(OutDir)
   {
      WinActivate, ahk_id %hSetWinGui%
   } Else
   {
      lastFolder := SelectImg
      GuiControl, SettingsGUIA:, QuickFileActFolder%thisVar%, % OutDir
   }
}

triggerQuickFileAction(keyu, forceIT:=0) {
   Static hasLoadedSettings := 0, lastInvoked := 1
   If (allowUserQuickFileActions=0 && forceIT=0)
      Return

   If (slideShowRunning=1)
   {
      ToggleSlideShowu()
      Return
   }

   If ((!resultedFilesList[currentFileIndex, 1] || AnyWindowOpen || drawingShapeNow=1)
   || (A_TickCount - lastInvoked<250))
   {
      lastInvoked := A_TickCount
      Return
   }

   If !hasLoadedSettings
   {
      ReadSettingsQuickKeysActsPanel()
      hasLoadedSettings := 1
   }

   thisVar := SubStr(keyu, 0)
   UsrCopyMoveOperation := InStr(keyu, "+") ? 2 : 3   ; 2 = move ; 3 = copy
   UsrEditFileDestination := QuickFileActFolder%thisVar%
   If (thisVar=7)
   {
      If !folderTreeWinOpen
         Return

      Gui, fdTreeGuia: Default
      Gui, fdTreeGuia: TreeView, TVlistFolders
      c := TV_GetSelection()
      UsrEditFileDestination := folderTreeGetSelectedPath(c)
      If !UsrEditFileDestination
         Return

      If FolderExist(UsrEditFileDestination)
      {
         prevFileMovePath := UsrEditFileDestination
         INIaction(1, "prevFileMovePath", "General")
         RecentCopyMoveManager(UsrEditFileDestination)
      }
   } Else If (thisVar=8)
   {
      If !VisibleQuickMenuSearchWin
         Return

      UsrEditFileDestination := OmniBoxGetSelectedFolder()
      If !UsrEditFileDestination
         Return

      If FolderExist(UsrEditFileDestination)
      {
         prevFileMovePath := UsrEditFileDestination
         INIaction(1, "prevFileMovePath", "General")
         RecentCopyMoveManager(UsrEditFileDestination)
      }
   }

   If StrLen(UsrEditFileDestination)<5
   {
      PanelQuickMoveConfigure()
      Return
   }

   altState := GetKeyState("Alt", "P")
   ctrlState := GetKeyState("Ctrl", "P")
   lastInvoked := A_TickCount
   If (altState=1 && ctrlState!=1)
   {
      Try Run, "%UsrEditFileDestination%"
      UsrEditFileDestination := ""
      Return
   } Else If (ctrlState=1 && altState=1)
   {
      OpenNewQPVinstance(UsrEditFileDestination)
      UsrEditFileDestination := ""
      Return
   }

   copyMoveDoLastOption := 4
   nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   afterAct := QuickFileActAfter%thisVar%
   ForceRefreshNowThumbsList()
   r := BtnCopyMoveAction("quick-actu")
   lastInvoked := A_TickCount
   If (afterAct=2 && !validBMP(UserMemBMP) && r=1)
      NextPicture(0, 1)
   Else If (afterAct=3 && !validBMP(UserMemBMP) && r=1)
      PreviousPicture(0, 1)

   UsrEditFileDestination := ""
   lastInvoked := A_TickCount
}

WriteSettingsQuickKeysActsPanel() {
    ReadSettingsQuickKeysActsPanel(1)
}

ReadSettingsQuickKeysActsPanel(act:=0) {
   Loop, 6
   {
      INIaction(act, "QuickFileActAfter" A_Index, "General", 2, 1, 3)
      INIaction(act, "QuickFileActFolder" A_Index, "General", 5)
   }
   INIaction(act, "deleteFileActAfter", "General", 2, 1, 3)
   INIaction(act, "QuickFileActConflict", "General", 2, 1, 4)
   INIaction(act, "askDeleteFiles", "General", 1)
   INIaction(act, "allowUserQuickFileActions", "General", 1)
}

TglUsePrevSaveFoderu() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   actu := (usePrevSaveFolder=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, userDestinationFolder
   RegAction(1, "usePrevSaveFolder")
}

BTNsaveImgPanel() {
   If (AnyWindowOpen!=35)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userDestinationFolder
   GuiControlGet, userSaveBitsDepth
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   RegAction(1, "usePrevSaveFolder")
   RegAction(1, "PreserveDateTimeOnSave")
   imgPath := getIDimage(currentFileIndex)
   If InStr(imgPath, "\temporary memory object\")
      SaveClipboardImage(userDestinationFolder, 0)
   Else
      SaveClipboardImage("current", 1)
}

BTNsaveBrowseImgPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userDestinationFolder
   GuiControlGet, userSaveBitsDepth
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   RegAction(1, "usePrevSaveFolder")
   RegAction(1, "PreserveDateTimeOnSave")
   imgPath := getIDimage(currentFileIndex)
   If (usePrevSaveFolder=1 || InStr(imgPath, "\temporary memory object\"))
      SaveClipboardImage(userDestinationFolder, 0)
   Else
      SaveClipboardImage("current", 0)
}

BtnCopyImageClip() {
   Gui, SettingsGUIA: Default
   GuiControlGet, usePrevSaveFolder
   GuiControlGet, PreserveDateTimeOnSave
   RegAction(1, "PreserveDateTimeOnSave")
   BtnCloseWindow()
   Sleep, 5
   CopyImage2clip()
}

fakeWinCreator(idWin, thisCaller, allowReopen) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    mouseTurnOFFtooltip()
    AnyWindowOpen := idWin
    interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    prevOpenedWindow := []
    prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 1]
    isNowFakeWinOpen := 1
    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    ; hSetWinGui := PVhwnd
}

PanelAutoSelectDupes() {
   Static SearchdStringz
   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to search for")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If filesFilter
         SetTimer, PanelEnableFilesFilter, -200
      Return
   }

   If !testIsDupesList()
   {
      showTOOLtip("WARNING: The files list does not seem to contain pairs of images identified as duplicates")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (SLDtypeLoaded=3)
         SetTimer, PanelFindDupes, -200
      Return
   }

   fakeWinCreator(50, A_ThisFunc, 1)
   SearchdStringz := Trimmer(SearchdStringz) "`f"
   widthu := (PrefsLargeFonts=1) ? 1060 : 560
   msgResult := msgBoxWrapper("panelu|Auto-select duplicate images " appTitle, "When Automatic mode is selected, the smallest image (in MPx) will be selected. If all dupes in the group have the same resolution, then the smallest file will be selected. If both size and resolution are equal, the images' folder paths that match the string below will NOT be selected.`n`nYou can use | as the OR operator for multiple keywords. Wildcards ? and * are supported as well.`n`nBegin with one of the following symbols to...`n   / match folder paths that begin with given string`n   > match folder paths that end with given string.`n   \> to use Regular Expressions", "&Select files|&Find duplicates|C&ancel", 1, "search", "", 0, SearchdStringz "`f`f", nullEdit,nullEdit, 1, widthu, "Automatic`f`fSmallest files`fSmallest resolution (MPx)", 2)
   If InStr(msgResult.btn, "select")
   {
      thisString := Trimmer(msgResult.list)
      thisString := StrReplace(thisString, "||", "|")
      thisString := Trimmer(thisString, "|")
      thisStringo := processSearchIndexString(thisString)
      If (thisStringo && !InStr(SearchdStringz, thisString "`f"))
         SearchdStringz .= thisString "`f"
      autoSelectDupesInGroups(msgResult.2ndlist, thisStringo)
   } Else If InStr(msgResult.btn, "find")
      PanelFindDupes()
}

SearchIndexSelectAll(modus:="") {
   thisFilter := processSearchIndexString(userSearchString)
   If !thisFilter
   {
      thisSearchString := userSearchString := ""
      SetTimer, PanelSearchIndex, -100
      Return
   }

   showTOOLtip("Searching index for matching files:`n" userSearchString)
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection based on the search criteria.", "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel" || InStr(msgResult, "win_close"))
      {
         SetTimer, RemoveTooltip, -250
         thisSearchString := userSearchString := ""
         Return
      }
   }

   thisSearchString := thisFilter
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   wasReplace := 0
   doStartLongOpDance()
   If (msgResult="replace" || !msgResult)
   {
      wasReplace := 1
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   Loop, % maxFilesIndex
   {
      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := resultedFilesList[A_Index, 1]
      If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
      {
         thisIndex++
         resultedFilesList[A_Index, 2] := (msgResult="add" || !msgResult) ? 1 : 0
      }
   }

   CurrentSLD := backCurrentSLD
   friendly := thisIndex ? "The files selection was altered." : "The files selection is unchanged."
   ResetImgLoadStatus()
   updateFilesSelectionInfos()
   ForceRefreshNowThumbsList()
   If (abandonAll=1)
      showDelayedTooltip("User abandoned the search.`n" friendly)
   Else If !thisIndex
      showDelayedTooltip("No matches found for:`n" userSearchString "`n" friendly)
   Else If (modus!="quick" && wasReplace=1)
      navSelectedFiles(1)

   dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

SelectFilesDead() {
   showTOOLtip("Identifying inexistent files:`n" groupDigits(maxFilesIndex))
   getSelectedFiles(0, 1)
   If (markedSelectFile>2)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Some files are already selected in the list. You can choose to add, substract the files selection when the file is inexistent.", "&Replace|&Add|&Substract|&Cancel", 0, "question")
      If (msgResult="cancel" || InStr(msgResult, "win_close"))
      {
         SetTimer, RemoveTooltip, -250
         Return
      }
   }

   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   wasReplace := 0
   doStartLongOpDance()
   If (msgResult="replace" || !msgResult)
   {
      wasReplace := 1
      If (msgResult="replace")
         msgResult := ""

      dropFilesSelection(1)
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   thisIndex := 0
   Loop, % maxFilesIndex
   {
       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }
 
       imgPath := resultedFilesList[A_Index, 1]
       If !FileRexists(imgPath)
       {
          thisIndex++
          resultedFilesList[A_Index, 2] := (msgResult="add" || !msgResult) ? 1 : 0
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
          showTOOLtip("Identifying inexistent image files in the index`nMissing files: " groupDigits(thisIndex) etaTime, 0, 0, A_Index/maxFilesIndex)
          prevMSGdisplay := A_TickCount
       }
   }

   CurrentSLD := backCurrentSLD
   friendly := thisIndex ? "The files selection was altered.`nDead files found: " groupDigits(thisIndex) : "Found no inexistent files to select."
   ResetImgLoadStatus()
   updateFilesSelectionInfos()
   ForceRefreshNowThumbsList()
   If (abandonAll=1)
      showDelayedTooltip("User abandoned the operation.`n" friendly)
   Else
      showDelayedTooltip(friendly)

   dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

QuickSelectFilesSameFolder(modus:=0, external:=0) {
    imgPath := (isNumber(modus) && modus>0 && external="aye") ? modus : getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    If (!OutDir || !currentFileIndex || maxFilesIndex<3)
       Return

    o := markSearchMatches
    oz := userSearchString
    od := userSearchWhat
    og := thisSearchString

    markSearchMatches := 0
    userSearchWhat := 1
    userSearchString := OutDir "\"
    SearchIndexSelectAll("quick")
    userSearchWhat := od
    userSearchString := oz
    markSearchMatches := o
    thisSearchString := og
    dummyTimerDelayiedImageDisplay(50)
}

SelectFilesSearchIndex() {
   PanelSearchIndex("select")
}

EraseSearchEdit() {
   If (AnyWindowOpen=29)
   {
      GuiControlGet, UsrEditFilter
      BtnCloseWindow()
   }

   If StrLen(UsrEditFilter)<2
      SearchedStringz := ""
   userSearchString := ""
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      RefreshThumbsList()
}

PanelSearchIndex(dummy:="") {
    Global editFa, editFb, txtline3
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()
 
    If (maxFilesIndex<2)
    {
       showTOOLtip("WARNING: Insufficient indexed files to search for")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }
 
    If (AnyWindowOpen=6)
       BtnCloseWindow()
    Else If AnyWindowOpen
       Return

    SearchedStringz := Trimmer(SearchedStringz)
    ; ToolTip, % SearchedStringz , , , 2
    thisBtnHeight := createSettingsGUI(29, A_ThisFunc)
    btnWid := 80
    txtWid := 260
    If (PrefsLargeFonts=1)
    {
       txtWid := txtWid + 185
       btnWid := btnWid + 80
       Gui, Font, s%LargeUIfontValue%
    }

    lst := btnWid + 50
    infou := (dummy="select") ? "Please type the string by which to select files" : "Please type the string to search for in the indexed files"

    sml := (PrefsLargeFonts=1) ? 30 : 20
    iconFile := "imageres.dll", iconNum := 169
    this := userSearchString ? userSearchString : A_Space
    Gui, +Delimiter`n
    Gui, Add, Picture, x20 y20 h%thisBtnHeight% Icon%iconNum% w-1, %iconFile%
    Gui, Add, Text, x+20 w%txtWid% Section, %infou%. Use | as the OR operator. Wildcards ? and * are supported as well.
    Gui, Add, Text, y+7 wp h1 Hide, Search string
    Gui, Add, ComboBox, yp wp gUIgenericComboAction vUsrEditFilter, % SearchedStringz "`n" this "`n`n"
    GuiAddButton("x+1 w" sml " hp gEraseSearchEdit", "X", "Discard search criteria")
    GuiAddDropDownList("xs y+10 w" lst " AltSubmit Choose" userSearchPos " vuserSearchPos", "Anywhere`nBegins with`nEnds with`nRegEx", "Search matching mode")
    GuiAddDropDownList("x+2 wp AltSubmit Choose" userSearchWhat " vuserSearchWhat", "Full paths`nFolder paths`nFile names`nParent folders", "Limit search to...")
    Gui, Add, Checkbox, xs y+5 Checked%markSearchMatches% vmarkSearchMatches, &Highlight matching files in the list view mode
    If (dummy="select")
    {
       Gui, Add, Button, xs y+25 w%btnWid% h%thisBtnHeight% gBtnPerformSearchNow, Select &matches
       GuiControl, Disable, markSearchMatches
    } Else
    {
       Gui, Add, Button, xs y+25 w%btnWid% h%thisBtnHeight% Default gBtnPerformSearchNow, &Search next
       Gui, Add, Button, x+5 hp wp+10 gBtnPerformSearchNow, Select &matches
    }

    w := (PrefsLargeFonts=1) ? 85 : 55
    Gui, Add, Button, x+5 hp wp-40 gOpenFilterPanelBTNaction, &Filter list
    Gui, Add, Button, x+5 hp w%w% gBtnCloseWindow, C&ancel
    infou := (dummy="select") ? "Select files by given string" : "Search indexed files"
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, infou ": " appTitle)
}

BtnPerformSearchNow(a, b, c) {
   ; ToolTip, % a "=" b "=" c , , , 2
   If askAboutFileSave(" and the files index search will be performed")
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, markSearchMatches
   GuiControlGet, userSearchWhat
   GuiControlGet, userSearchPos
   GuiControlGet, UsrEditFilter
   ControlGetText, btnText,, ahk_id %a%

   userSearchString := ""
   INIaction(1, "markSearchMatches", "General")
   thisString := StrReplace(UsrEditFilter, "||", "|")
   thisString := Trim(thisString, "|")

   ; fnOutputDebug(A_ThisFunc "(1): " thisString)
   If (thisString!="")
   {
      thisString := StrReplace(thisString, "\>")
      thisString := StrReplace(thisString, "/")
      thisString := StrReplace(thisString, ">")
      If (userSearchPos=2)
         thisString := "/" thisString
      Else If (userSearchPos=3)
         thisString := ">" thisString
      Else If (userSearchPos=4)
         thisString := "\>" thisString
      userSearchString := thisString
      ; givenRegEx := processSearchIndexString(thisString)
   }

   ; fnOutputDebug(A_ThisFunc "(2): " userSearchString)
   If (userSearchString!="")
   {
      If !InStr(SearchedStringz, userSearchString "`n")
      {
         SearchedStringz .= "`n" userSearchString "`n"
         SearchedStringz := StrReplace(SearchedStringz, "`n`n", "`n")
      }

      ; Sort, SearchedStringz, UD`f
      BtnCloseWindow()
      If InStr(btnText, "search")
      {
         searchNextIndex(1)
      } Else If InStr(btnText, "select")
      {
         markSearchMatches := 0
         SearchIndexSelectAll()
      }
   } Else
   {
      showTOOLtip("WARNING: no valid search criteria was given.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

OpenFilterPanelBTNaction() {
   userSearchString := ""
   BtnCloseWindow()
   PanelEnableFilesFilter()
}

PanelEditImgCaption() {
    Global newFileName, UsrStoreCaptionDB := 1
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If !FileExist(imgPath)
    {
       showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Return
    }

    thisBtnHeight := createSettingsGUI(22, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    If (SLDtypeLoaded!=3)
       UsrStoreCaptionDB := 0

    Gui, Add, Text, x15 y15 w%txtWid%, Please type the caption or annotation you want associated with this image file.
    GuiAddEdit("y+7 w" EditWid " r15 gUIeditsGenericAllowCtrlBksp limit2048 -wantTab vnewFileName", textFileContent, "Image caption")
    Gui, Add, Checkbox, y+7 Checked%UsrStoreCaptionDB% vUsrStoreCaptionDB, &Store image caption into the SQL database
    Gui, Add, Checkbox, y+7 Checked%showImgAnnotations% vshowImgAnnotations, &Display image captions on the viewport
    If (currentUndoLevel>2 && thumbsDisplaying!=1)
       Gui, Add, Text, y+7 , WARNING: Image captions are not displayed when an image is being edited.

    If (SLDtypeLoaded!=3)
       GuiControl, SettingsGUIA: Disable, UsrStoreCaptionDB

    thisW := (PrefsLargeFonts=1) ? 90 : 60
    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddButton("xs y+20 h" thisBtnHeight " w" ml " gBtnPrevCaptionPic vBtn1", "<<", "Previous image")
    GuiAddButton("x+5 hp wp gBtnNextCaptionPic vBtn2", ">>", "Next image")
    If (currentUndoLevel>2)
    {
       GuiControl, SettingsGUIA: Disable, Btn1
       GuiControl, SettingsGUIA: Disable, Btn2
    }

    Gui, Add, Button, x+5 hp w%thisW% Default gBTNsaveCaptionAction, &Save
    Gui, Add, Button, x+5 hp wp gBTNdeleteCaptionAction, &Delete
    Gui, Add, Button, x+5 hp wp gBTNhelpCaptions, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    If (SLDtypeLoaded!=3)
       GuiControl, Disable, UsrStoreCaptionDB

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Edit image caption: " appTitle)
    updateUIcaptionsPanel()
}

BtnNextCaptionPic() {
   NextPicture()
   SetTimer, updateUIcaptionsPanel, -100
}

BtnPrevCaptionPic() {
   PreviousPicture()
   SetTimer, updateUIcaptionsPanel, -100
}

updateUIcaptionsPanel() {
    Gui, SettingsGUIA: Default
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3)
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

    If !textFileContent
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       Try FileRead, textFileContent, % " *t " textFile
    }
    ; ToolTip, % imgPath "`n" textFileContent  , , , 2
    GuiControl, SettingsGUIA:, newFileName, % textFileContent
}

BTNhelpCaptions() {
    msgBoxWrapper(appTitle ": HELP", "Image file captions [annotations] are stored in .TXT files [as plain text], where the image file is located, under the same file name.`n`nFor example:`nC:\example-folder\image-file.jpg`nC:\example-folder\image-file.txt`n`nIf you are using SQLite slideshow databases, you have the option to store the captions in the database, not as individual files for each image. However, please keep in mind, when the files list is renewed or regenerated, the captions or audio annotations might get lost.", -1, 0, 0)
}

BTNdeleteCaptionAction() {
    Gui, SettingsGUIA: Default
    GuiControlGet, UsrStoreCaptionDB
    GuiControlGet, showImgAnnotations
    ; INIaction(1, "UsrStoreCaptionDB", "General")
    ; BtnCloseWindow()
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"
    If FileExist(textFile)
       mustShowError := 1

    Try FileDelete, % textFile
    Catch wasError
          Sleep, 2

    If (mustShowError && wasError)
    {
       showTOOLtip("ERROR: Unable to delete text file:`n" OutNameNoExt ".txt`n" OutDir "\")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    } Else If (SLDtypeLoaded!=3)
       SoundBeep , 900, 100

    If (SLDtypeLoaded=3)
    {
       r := updateSQLdbEntryCaption(imgPath, "", "imgCaption")
       If (r=-1)
       {
          showTOOLtip("ERROR: Failed to update the image caption in the database.")
          SoundBeep 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
       }
    }

    INIaction(1, "showImgAnnotations", "General")
    SetTimer, updateUIcaptionsPanel, -150
    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

BTNsaveCaptionAction() {
    Gui, SettingsGUIA: Default
    GuiControlGet, newFileName
    GuiControlGet, UsrStoreCaptionDB
    GuiControlGet, showImgAnnotations
    ; INIaction(1, "UsrStoreCaptionDB", "General")
    textu := Trimmer(newFileName)
    If !textu
    {
       BTNdeleteCaptionAction()
       Return
    }

    ; BtnCloseWindow()
    INIaction(1, "showImgAnnotations", "General")
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3 && UsrStoreCaptionDB=1)
    {
       r := updateSQLdbEntryCaption(imgPath, textu, "imgCaption")
       If (r=-1)
       {
          showTOOLtip("ERROR: Failed to update the image caption in the database.")
          SoundBeep 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
       }
    } Else
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       FileDelete, % textFile
       Sleep, 2
       Try FileAppend, % textu, % textFile, UTF-16
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "Failed to write text file. Permission denied.`n" OutNameNoExt ".txt`n" OutDir "\", 0, 0, "error")
       If !wasError
          SoundBeep 900, 100
    }

    SetTimer, updateUIcaptionsPanel, -150
    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

InvokeUpdateIndexPanelBTNaction() {
   CloseWindow()
   Sleep, 1
   PanelUpdateThisFileIndex()
}

filterFileName(ostring) {
  Static forbiddenCharsREGex := "\<|\>|\:|\""|\/|\\|\||\?|\*"
  Static forbiddenNames := "CON|PRN|AUX|NUL|COM1|COM2|COM3|COM4|COM5|COM6|COM7|COM8|COM9|LPT1|LPT2|LPT3|LPT4|LPT5|LPT6|LPT7|LPT8|LPT9"
  string := Trimmer(ostring)
  string := Trim(string, ".")
  string := Trim(string, ",")
  string := StrReplace(string, "/", "\")
  string := RegExReplace(string, "\\{2,}", "\")
  If RegExMatch(string, forbiddenCharsREGex)
     Return

  Loop, Parse, forbiddenNames, |
  {
     If (A_LoopField=string)
        Return
  }

  Return string
}

BTNrenameSoloFileAct(newFileName, file2rem, doLastOption) {
  newFileName := filterFileName(newFileName)
  If (StrLen(newFileName)>3)
  {
     zPlitPath(file2rem, 0, OutFileName, OutDir, fileNamuNoEXT, oldEXT)
     If !InStr(newFileName, ".")
        newFileName .= "." oldEXT

     If (Trimmer(OutFileName)=newFileName)
        Return 1

     If !FileExist(file2rem)
        Return 0

     destroyGDIfileCache()
     file2save := OutDir "\" newFileName
     If FileRexists(file2save, 0)
        file2save := askAboutFileCollision(file2rem, file2save, 0, doLastOption + 1, 0, performOverwrite)

     If (file2save="abort" || !file2save)
     {
        SetTimer, SingularRenameFile, -150
        Return
     }

     FileGetTime, originalMtime, % file2rem, M
     FileGetTime, originalCtime, % file2rem, C
     thisFileExists := FileRexists(file2save, 0)
     If (performOverwrite=1 && thisFileExists=1)
     {
        jso := GetFileAttributesEx(file2save)
        originalFileInfos := jso.size "|" jso.wtime "|" jso.ctime
        FileSetAttrib, -R, %file2save%
        Sleep, 2
        FileRecycle, %file2save%
        Sleep, 2
     } Else If (thisFileExists=1)
     {
        showTOOLtip("WARNING: Rename operation abandoned.`nA file with the provided name already exists.`nFile name conflict`n" newFileName)
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     }

     FileSetAttrib, -R, %file2rem%
     Sleep, 2
     FileMove, %file2rem%, %file2save%, 1
     If ErrorLevel
     {
        OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)
        showTOOLtip("ERROR: Access denied. The file could not be renamed.`n" OutFileName "`n" OutDir "\")
        SoundBeep, 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     } Else
     {
        updateDates := 1
        If originalMtime
        {
           Sleep, 0
           FileSetTime, % originalMtime, % file2save, M
           FileSetTime, % originalCtime, % file2save, C
           updateDates := 0
        }

        extraMarker := (thisFileExists=1 && performOverwrite=1) ? "*" : ""
        recordUndoFileActs(file2save, resultedFilesList[currentFileIndex, 1], extraMarker, 2, A_Now, originalFileInfos)
        If (SLDtypeLoaded=3)
           updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[currentFileIndex, 12])
        Else
           currentFilesListModified := 1

        resultedFilesList[currentFileIndex, 1] := file2save
        updateMainUnfilteredList(currentFileIndex, 1, file2save)
        watchFolderDetails := ""
        dummyTimerDelayiedImageDisplay(50)
        If (userPrivateMode=1)
        {
           OutDir := "*:\*******\******"
           newFileName := "******.***"
        } Else OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)

        zPlitPath(file2save, 0, OutFileName, OutDir, fileNamuNoEXT, oldEXT)
        showTOOLtip("File renamed succesfully to:`n" OutFileName "`n" OutDir "\")
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 1
     }
  } Else Return 0
}

UpdateIndexBTNaction(newFileName, whichIndex) {
  ; GuiControlGet, newFileName
  ; ToolTip, % newFileName , , , 2
  newFileName := Trimmer(newFileName)
  newFileName := StrReplace(newFileName, "/", "\")
  newFileName := RegExReplace(newFileName, "\\{2,}", "\")
  allGood := 1
  If !RegExMatch(newFileName, "i)^(.\:\\.)")
     allGood := 0

  strArr := StrSplit(newFileName, "\")
  Loop, % strArr.Count()
  {
      testThis := filterFileName(strArr[A_Index])
      If (!testThis && A_Index>1)
         allGood := 0
  }

  If !RegExMatch(newFileName, RegExFilesPattern)
     allGood := 0

  If !FileRexists(newFileName)
  {
     If (allGood=1)
        fileNotFound := 1
     allGood := 0
  }

  If (StrLen(newFileName)>2 && allGood=1)
  {
     oldFileName := resultedFilesList[whichIndex, 1]
     resultedFilesList[whichIndex, 1] := newFileName
     resultedFilesList[whichIndex, 4] := 1    ; 4_forceThumbRefresh
     If (SLDtypeLoaded=3)
        updateSQLdbEntry(oldFileName, newFileName, 0, resultedFilesList[whichIndex, 12])

     updateMainUnfilteredList(whichIndex, 1, newFileName)
     ForceRefreshNowThumbsList()
     currentFilesListModified := 1
     dummyTimerDelayiedImageDisplay(150)
     showTOOLtip("File index entry updated: " groupDigits(whichIndex))
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return 1
  } Else If (StrLen(newFileName)>2)
  {
     If (fileNotFound=1)
        showTOOLtip("ERROR: The file index entry was not updated.`nFile not found or access denied`n" newFileName)
     Else
        showTOOLtip("ERROR: The file index entry was not updated.`nIncorrect file name provided:`n" newFileName)
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return 0
  }
}

updateUIpastePanel(actionu:=0, b:=0) {
    Critical, on
    Static lastInvoked := 1
    isWinOpen := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
    If (isWinOpen!=1)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIpastePanel, -150
       Return
    }

    If (coreDesiredPixFmt="0x21808")
    {
       alphaMaskingMode := 1
       GuiControl, Disable, alphaMaskingMode
       GuiControl, Choose, alphaMaskingMode, 1
    }

    decideCustomShapeStyle()
    If (CurrentPanelTab=1)
    {
       actu := (PasteInPlaceBlurAmount>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, PasteInPlaceBlurEdgesSoft

       actu := (PasteInPlaceToolMode=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, PasteInPlaceEraseInitial

       actu := (viewportQPVimage.imgHandle) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, PasteInPlaceAutoExpandIMG
       uiSlidersArray["PasteInPlaceBlurAmount", 10] := (viewportQPVimage.imgHandle) ? 0 : 1

       actu := (PasteInPlaceAdaptMode=2) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, PasteInPlaceAlignment
    } Else If (CurrentPanelTab=2)
    {
       actu := (PasteInPlaceCropSel=2) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiUpdateVisibilitySliders(actu, "FillAreaRectRoundness")

       actu := (PasteInPlaceCropSel=3 && !viewportQPVimage.imgHandle) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiUpdateVisibilitySliders(actu, "FillAreaEllipseSection")

       actu := (PasteInPlaceCropSel=7) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, FillAreaCurveTension

       uiSlidersArray["PasteInPlaceCropAngular", 10] := PasteInPlaceCropDo
       uiSlidersArray["FillAreaRectRoundness", 10] := PasteInPlaceCropDo
       uiSlidersArray["FillAreaEllipseSection", 10] := PasteInPlaceCropDo
       uiSlidersArray["userUIshapeCavity", 10] :=  (viewportQPVimage.imgHandle && !(PasteInPlaceCropSel=1 || PasteInPlaceCropSel=3)) ? 0 : PasteInPlaceCropDo

       actu := (PasteInPlaceCropDo=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, PasteInPlaceCropSel
       GuiControl, % actu, FillAreaCurveTension
       actu := (!viewportQPVimage.imgHandle && PasteInPlaceCropDo=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, PasteInPlaceCropAdaptImg
    } Else If (CurrentPanelTab=3)
    {
       actu := (PasteInPlaceBlendMode>1 && !viewportQPVimage.imgHandle) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, PasteInPlaceGlassy

       actu := (PasteInPlaceApplyColorFX=1) ? 1 : 0
       uiSlidersArray["PasteInPlaceLight", 10] := actu
       uiSlidersArray["PasteInPlaceGamma", 10] := actu
       uiSlidersArray["PasteInPlaceHue", 10] := actu
       uiSlidersArray["PasteInPlaceSaturation", 10] := actu
    } Else If (CurrentPanelTab=4)
    {
       updateUIalphaMaskStuff(1)
    } Else If (CurrentPanelTab=5)
       updateUIalphaMaskStuff(2)

    GuiRefreshSliders()
    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsPasteInPlacePanel, -350
    SetTimer, WriteSettingsBrushPanel, -350
    SetTimer, WriteSettingsAlphaMaskPanel, -250
}

updateUIalphaMaskStuff(tabu) {
    If (tabu=1)
    {
       pl := (alphaMaskingMode=5) ? "Blur strength" : "Scale: $€%"
       pkd := (alphaMaskingMode=5) ? 1 : 100
       GuiSetSliderProperties("alphaMaskGradientScale", 1, 300, pkd, pl)
       uiSlidersArray["alphaMaskGradientScale", 10] := (alphaMaskingMode>1) ? 1 : 0

       actu := (alphaMaskingMode>=5 || alphaMaskingMode=1) ? "SettingsGUIA: Hide" : "SettingsGUIA: Show"
       GuiControl, % actu, alphaMaskGradientWrapped

       actu := (alphaMaskingMode>1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, alphaMaskReplaceMode
       GuiControl, % actu, alphaMaskColorReversed
       If (AnyWindowOpen!=70)
          GuiControl, % actu, UIviewAlpha

       actu := isInRange(alphaMaskingMode, 2, 4) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiUpdateVisibilitySliders(actu, "alphaMaskGradientPosA")
       GuiUpdateVisibilitySliders(actu, "alphaMaskGradientPosB")

       actu := (alphaMaskingMode=5) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiUpdateVisibilitySliders(actu, "alphaMaskBMPbright")
       GuiUpdateVisibilitySliders(actu, "alphaMaskBMPcontrast")

       actu := (alphaMaskingMode=5) ? "SettingsGUIA: Hide" : "SettingsGUIA: Show"
       GuiUpdateVisibilitySliders(actu, "alphaMaskClrAintensity")
       GuiUpdateVisibilitySliders(actu, "alphaMaskClrBintensity")

       actu := (alphaMaskingMode=5) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, alphaMaskRefBMP
       GuiControl, % actu, alphaMaskBMPchannel
       GuiControl, % actu, infoAlphaFile

       uiSlidersArray["alphaMaskClrAintensity", 5] := (alphaMaskingMode=6) ? "Blur strength" : "Intensity A"
       uiSlidersArray["alphaMaskClrBintensity", 5] := (alphaMaskingMode=6) ? ".updateLabelMaskCurvePath" : "Intensity B"

       actu := isInRange(alphaMaskingMode, 2, 4) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, infoAlphaMaskGradientView
       GuiControl, % actu, UIresetAlphaCenter
       If InStr(actu, "show")
          updateUIgradientPreviewAlphaMask(1)

       actu := (alphaMaskingMode=5 && alphaMaskRefBMP=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, UIremAlpha

       actu := (alphaMaskingMode>1) ? 1 : 0
       uiSlidersArray["alphaMaskGradientAngle", 10] := actu
       uiSlidersArray["alphaMaskClrAintensity", 10] := actu
       uiSlidersArray["alphaMaskClrBintensity", 10] := actu
       If (viewportQPVimage.imgHandle)
          GuiControl, SettingsGUIA: Disable, alphaMaskingMode
    } Else If (tabu=2)
    {
       actu := (liveDrawingBrushTool=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, BrushToolBcolor
       GuiControl, % actu, BrushToolAcolor
       GuiControl, % actu, BrushToolDoubleSize

       actu := (liveDrawingBrushTool=1 && BrushToolAspectRatio!=0) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, BrushToolAutoAngle

       actu := (liveDrawingBrushTool=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, BrushToolType
       GuiControl, % actu, PickuBrushToolAcolor
       GuiControl, % actu, PickuBrushToolBcolor
       GuiControl, % actu, UIbtnBrushColorA
       GuiControl, % actu, UIbtnBrushColorB

       uiSlidersArray["BrushToolAngle", 10] := (liveDrawingBrushTool=1 && BrushToolAutoAngle=0 && BrushToolAspectRatio!=0) ? 1 : 0
       actu := (liveDrawingBrushTool=1) ? 1 : 0
       uiSlidersArray["BrushToolAopacity", 10] := actu
       uiSlidersArray["BrushToolBopacity", 10] := actu
       uiSlidersArray["BrushToolAspectRatio", 10] := actu
       uiSlidersArray["BrushToolDryingRate", 10] := actu
       uiSlidersArray["BrushToolSize", 10] := actu
       uiSlidersArray["BrushToolStepping", 10] := actu

       actu := (liveDrawingBrushTool=1 && BrushToolType=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, BrushToolOverDraw

       If (BrushToolType=1)
          uiSlidersArray["BrushToolSoftness", 10] := 0
       Else
          uiSlidersArray["BrushToolSoftness", 10] := (liveDrawingBrushTool=1) ? 1 : 0

       theSizeLabel := (BrushToolDoubleSize!=1) ? "Diameter: $€ px" : "Radius: $€ px"
       uiSlidersArray["BrushToolSize", 5] := theSizeLabel
       If (BrushToolUseSecondaryColor=1)
       {
          If (liveDrawingBrushTool=1)
          {
             GuiControl, SettingsGUIA: Enable, PickuBrushToolBcolor
             uiSlidersArray["BrushToolBopacity", 10] := 1
             GuiControl, SettingsGUIA: Enable, BrushToolBcolor
          }
          GuiControl, SettingsGUIA: Disable, PickuBrushToolAcolor
          uiSlidersArray["BrushToolAopacity", 10] := 0
          GuiControl, SettingsGUIA: Disable, BrushToolAcolor
          GuiControl, SettingsGUIA:, UIbtnBrushColorB, X
          GuiControl, SettingsGUIA:, UIbtnBrushColorA, -
       } Else
       {
          GuiControl, SettingsGUIA:, UIbtnBrushColorB, -
          GuiControl, SettingsGUIA:, UIbtnBrushColorA, X
          If (liveDrawingBrushTool=1)
          {
             GuiControl, SettingsGUIA: Enable, PickuBrushToolAcolor
             uiSlidersArray["BrushToolAopacity", 10] := 1
             GuiControl, SettingsGUIA: Enable, BrushToolAcolor
          }
          GuiControl, SettingsGUIA: Disable, PickuBrushToolBcolor
          uiSlidersArray["BrushToolBopacity", 10] := 0
          GuiControl, SettingsGUIA: Disable, BrushToolBcolor
       }
       If (viewportQPVimage.imgHandle)
          GuiControl, SettingsGUIA: Disable, uiPasteInPlaceAlphaDrawMode
    }
}

updateUIgradientPreviewAlphaMask(modus) {
   Static rImgW := 125, rimgH := 125
   gradMode := (modus=1) ? alphaMaskingMode : FillAreaColorMode
   If !isInRange(gradMode, 2, 4)
      Return

   If (modus=1)
   {
      thisColorA := Gdip_ToARGB("0xFF", alphaMaskClrAintensity, alphaMaskClrAintensity, alphaMaskClrAintensity)
      thisColorB := Gdip_ToARGB("0xFF", alphaMaskClrBintensity, alphaMaskClrBintensity, alphaMaskClrBintensity)
      If (alphaMaskColorReversed=1)
         flipVars(thisColorA, thisColorB)
   } Else
   {
      thisColorA := makeRGBAcolor(FillAreaColor, FillAreaOpacity)
      thisColorB := makeRGBAcolor(FillArea2ndColor, FillArea2ndOpacity)
      If (FillAreaColorReversed=1)
         flipVars(thisColorA, thisColorB)
   }

   G := ""
   newBitmap := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
   If validBMP(newBitmap)
      G := Gdip_GraphicsFromImage(newBitmap)

   If !G
   {
      trGdip_DisposeImage(newBitmap, 1)
      Return
   }

   scaleu := (modus=1) ? alphaMaskGradientScale : FillAreaGradientScale
   posuA := (modus=1) ? alphaMaskGradientPosA : FillAreaGradientPosA
   posuB := (modus=1) ? alphaMaskGradientPosB : FillAreaGradientPosB
   angelu := (modus=1) ? alphaMaskGradientAngle : FillAreaGradientAngle
   angelu := (angelu>0) ? angelu : 360 + angelu
   cOffX := (modus=1) ? alphaMaskOffsetX : clrGradientOffX
   cOffY := (modus=1) ? alphaMaskOffsetY : clrGradientOffY
   rCoffX := (modus=1) ? alphaMaskCoffsetX : clrGradientCoffX
   rCoffY := (modus=1) ? alphaMaskCoffsetY : clrGradientCoffY
   gradientWrapMode := (modus=1) ? alphaMaskGradientWrapped - 1 : FillAreaGradientWrapped - 1
   brImgSelW := rImgW*(scaleu/100)
   brImgSelH := rImgH*(scaleu/100)
   If (gradMode=2)
   {
      brimgSelPx := 0 - (brImgSelW - rImgW)//2
      brimgSelPy := 0 - (brImgSelH - rImgH)//2
      gradBrush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + Round(brImgSelW*cOffX), brimgSelPy + Round(brImgSelH*cOffY), brimgSelW, brimgSelH, thisColorA, thisColorB, 1, clampInRange(gradientWrapMode, 0, 3, 1))
      If gradBrush
      {
         Gdip_SetLinearGrBrushPresetBlend(gradBrush, [posuA/200, posuB/200], [thisColorA, thisColorB])
         Gdip_RotateLinearGrBrushAtCenter(gradBrush, Round(angelu), 1)
         Gdip_SetLinearGrBrushGammaCorrection(gradBrush, userimgGammaCorrect)
      }
   } Else If (gradMode=3 || gradMode=4)
   {
      cX := Round(rImgW * (0.5 + cOffX + rCoffX * scaleu/100))
      cY := Round(rImgH * (0.5 + cOffY + rCoffY * scaleu/100))
      brimgSelPx := Round(rImgW/2 * (1 + 2 * cOffX) - brImgSelW/2)
      brimgSelPy := Round(rImgH/2 * (1 + 2 * cOffY) - brImgSelH/2)
      cX := clampInRange(cX, brimgSelPx, brimgSelPx + brImgSelW)
      cY := clampInRange(cY, brimgSelPy, brimgSelPy + brImgSelH)

      grpPath := Gdip_CreatePath()
      If (gradMode=3 && grpPath)
         Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
      Else If grpPath
         Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
  
      If grpPath
         gradBrush := Gdip_PathGradientCreateFromPath(grpPath)
  
      If gradBrush
      {
         Gdip_PathGradientSetCenterPoint(gradBrush, cX, cY)
         Gdip_SetLinearGrBrushGammaCorrection(gradBrush, userimgGammaCorrect)
         Gdip_SetLinearGrBrushPresetBlend(gradBrush, [posuA/200, posuB/200], [thisColorA, thisColorB])
         Gdip_RotatePathGradientAtCenter(gradBrush, Round(angelu), 1)
         Gdip_PathGradientSetWrapMode(gradBrush, gradientWrapMode)
      }
   }

   If (modus=1)
      Gdip_GraphicsClear(G, thisColorB)

   Gdip_FillRectangle(G, gradBrush, 0, 0, rImgW, rImgH)
   Gdip_DeleteBrush(gradBrush)
   Gdip_DeletePath(grpPath)
   Gdip_DeleteGraphics(G)
   If (modus!=1)
   {
      QPV_FillBitmapHoles(newBitmap, thisColorB)
      fBitmap := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
      If validBMP(fBitmap)
      {
         G2 := Gdip_GraphicsFromImage(fBitmap)
         brh := Gdip_BrushCreateHatch("0xFFeeEEee", "0xFF222222", 4) 
         Gdip_FillRectangle(G2, brh, 0, 0, rImgW, rImgH)
         tzGdip_DrawImageFast(G2, newBitmap)
         Gdip_DeleteGraphics(G2)
         trGdip_DisposeImage(newBitmap, 1)
         Gdip_DeleteBrush(brh)
         newBitmap := fBitmap
      }
   }

   hwndu := (modus=1) ? hGradientAlphaMSKpreview : hGradientFillpreview
   Gdip_SetPbitmapCtrl(hwndu, newBitmap)
   trGdip_DisposeImage(newBitmap, 1)
}

WriteSettingsPasteInPlacePanel() {
   ReadSettingsPasteInPlace(1)
}

throwErrorSelectionOutsideBounds(whichBitmap:=0) {
    whichBitmap := validBMP(whichBitmap) ? whichBitmap : useGdiBitmap()
    If testSelectOutsideImgEntirely(whichBitmap)
    {
       SoundBeep , 300, 100
       showDelayedTooltip("WARNING: Invalid image selection area.`nIt seems to be too small or entirely outside the image boundaries.")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return 1
    }
}

BtnPasteInSelectedArea() {
    Critical, on
    If (PasteInPlaceAutoExpandIMG!=1 || PasteInPlaceBlendMode>1)
    {
       If throwErrorSelectionOutsideBounds()
          Return
    }

    updateUIpastePanel("noPreview")
    Sleep, 1
    CloseWindow(0, 0)
    ToggleEditImgSelection("show-edit")
    Sleep, 1
    If (viewportQPVimage.imgHandle)
       HugeImagesApplyPasteInPlace()
    Else
       PasteInPlaceSelectedArea()
}

importEditGivenImageFile() {
   If !prevLoadedImageIndex
      Return

   imgPath := StrReplace(getIDimage(currentFileIndex), "||")
   If !FileExist(imgPath)
   {
      showTOOLtip("ERROR: The selected image cannot be imported`nFile does not exist or access denied.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   currentFileIndex := prevLoadedImageIndex
   MenuReturnIMGedit()
   Sleep, 2
   If (editingSelectionNow!=1)
      ToggleEditImgSelection()
   ; ToggleEditImgSelection("show-edit")
   Sleep, 2
   MainPanelTransformArea(imgPath, "paste", "extern-file")
}

importAlphaMaskGivenImageFile() {
   If !prevLoadedImageIndex
      Return

   imgPath := StrReplace(getIDimage(currentFileIndex), "||")
   If !FileExist(imgPath)
   {
      showTOOLtip("ERROR: The selected image cannot be imported`nFile does not exist or access denied.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   zBitmap := LoadBitmapFromFileu(imgPath)
   SetImageAsAlphaMask("yes-bitmap", zBitmap)
   trGdip_DisposeImage(zBitmap)
}

importAlphaMaskFromClipboard() {
    setImageLoading()
    changeMcursor()
    calcScreenLimits()
    showTOOLtip("Retrieving clipboard, please wait")
    If PasteHDropFiles(1)
    {
       ResetImgLoadStatus()
       SetTimer, RemoveTooltip, -500
       Return
    }

    clipBMP := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 1)
    If !validBMP(clipBMP)
    {
       ResetImgLoadStatus()
       SetTimer, RemoveTooltip, -500
       Return
    }

   SetImageAsAlphaMask("yes-bitmap", clipBMP)
   trGdip_DisposeImage(clipBMP)
}

ReadSettingsPasteInPlace(act:=0) {
    If (act=0)
    {
       RegAction(0, "initialCustomShapeCoords",, 5)
       If !InStr(FillAreaCustomShape, "|")
          RegAction(0, "FillAreaCustomShape",, 5)

       If (drawingShapeNow!=1)
          RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
    } Else If (act=1)
    {
       RegAction(1, "FillAreaCurveTension",, 2, 1, 5)
       If InStr(FillAreaCustomShape, "|")
          RegAction(1, "FillAreaCustomShape")
    }
    
    RegAction(act, "FillAreaRectRoundness",, 2, 4, 98)
    RegAction(act, "PasteInPlaceGlassy",, 2, 1, 6)
    RegAction(act, "PasteInPlaceBlendMode",, 2, 1, 24)
    RegAction(act, "PasteInPlaceAdaptMode",, 2, 1, 3)
    RegAction(act, "alphaMaskClrAintensity",, 2, 0, 255)
    RegAction(act, "alphaMaskClrBintensity",, 2, 0, 255)
    RegAction(act, "PasteInPlaceApplyColorFX",, 1)
    RegAction(act, "PasteInPlaceBlurAmount",, 2, 0, 255)
    RegAction(act, "PasteInPlaceBlurEdgesSoft",, 1)
    RegAction(act, "PasteInPlaceAlignment",, 2, 1, 5)
    RegAction(act, "PasteInPlaceCropDo",, 1)
    RegAction(act, "PasteInPlaceCropSel",, 2, 1, 7)
    RegAction(act, "PasteInPlaceCropAngular",, 2, -180, 180)
    RegAction(act, "PasteInPlaceEraseInitial",, 1)
    RegAction(act, "PasteInPlaceCropAdaptImg",, 1)
    RegAction(act, "PasteInPlaceGamma",, 2, -100, 100)
    RegAction(act, "PasteInPlaceHue",, 2, -180, 180)
    RegAction(act, "PasteInPlaceLight",, 2, -255, 255)
    RegAction(act, "PasteInPlaceSaturation",, 2, -100, 100)
    RegAction(act, "PasteInPlaceOpacity",, 2, 1, 512)
    RegAction(act, "PasteInPlaceOrientation",, 2, 1, 7)
    RegAction(act, "PasteInPlaceOrientFlipX",, 1)
    RegAction(act, "PasteInPlaceOrientFlipY",, 1)
    RegAction(act, "PasteInPlaceQuality",, 1)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
    RegAction(act, "userimgGammaCorrect",, 1)
}

togglePasteInPlaceAdaptModes() {
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceAdaptMode := clampInRange(PasteInPlaceAdaptMode + 1, 1, 3, 1)
      GuiControl, SettingsGUIA: Choose, PasteInPlaceAdaptMode, % PasteInPlaceAdaptMode
      updateUIpastePanel()
   }
}

toggleErasePasteInPlace() {
   If ((AnyWindowOpen=31 || AnyWindowOpen=24) && PasteInPlaceToolMode=1)
   {
      PasteInPlaceEraseInitial := !PasteInPlaceEraseInitial
      GuiControl, SettingsGUIA:, PasteInPlaceEraseInitial, % PasteInPlaceEraseInitial
      updateUIpastePanel()
   }
}

toggleRevealRectPasteInPlace() {
   If ((AnyWindowOpen=31 || AnyWindowOpen=24) && PasteInPlaceToolMode=1)
   {
      PasteInPlaceRevealOriginal := !PasteInPlaceRevealOriginal
      dummyTimerDelayiedImageDisplay(100)
   }
}

togglePasteInPlaceColorsFX() {
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceApplyColorFX := !PasteInPlaceApplyColorFX
      GuiControl, SettingsGUIA:, PasteInPlaceApplyColorFX, % PasteInPlaceApplyColorFX
      updateUIpastePanel()
   }
}

togglePasteInPlaceCropShapes() {
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceCropSel := clampInRange(PasteInPlaceCropSel + 1, 1, 7, 1)
      GuiControl, SettingsGUIA: Choose, PasteInPlaceCropSel, % PasteInPlaceCropSel
      updateUIpastePanel()
   }
}

togglePasteInPlaceCropNone() {
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceCropDo := !PasteInPlaceCropDo
      GuiControl, SettingsGUIA: , PasteInPlaceCropDo, % PasteInPlaceCropDo
      updateUIpastePanel()
   }
}

FlipVtransformedIMGpanel() {
   Static kl := {4:2, 3:1, 2:4, 1:3}
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceOrientation := kl[PasteInPlaceOrientation]
      GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, % PasteInPlaceOrientation
      updateUIpastePanel()
   }
}

FlipHtransformedIMGpanel() {
   Static kl := {4:3, 3:4, 2:1, 1:2}
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      PasteInPlaceOrientation := kl[PasteInPlaceOrientation]
      GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, % PasteInPlaceOrientation
      updateUIpastePanel()
   }
}

PanelTransformSelectedArea() {
   MainPanelTransformArea(0, "transform")
}

PanelPasteInPlace(dummy:="") {
   MainPanelTransformArea(dummy, "paste")
}

throwWarningHugeImagesFeatureNotAvailable() {
   If (viewportQPVimage.imgHandle)
   {
      showTOOLtip("WARNING: A very large image is currently opened.`nThis option is not available at the moment.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }

   If (markedSelectFile && AnyWindowOpen=89)
   {
      showTOOLtip("WARNING: Multiple files are selected for batch processing. Alpha masking not supported.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }
}

BTNtoggleAlphaPainting() {
   If throwWarningHugeImagesFeatureNotAvailable()
      Return

   GuiControlGet, uiPasteInPlaceAlphaDrawMode, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode
   If (!uiPasteInPlaceAlphaDrawMode && liveDrawingBrushTool!=1)
      Return

   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   UItriggerBrushUpdate()
   toggleAlphaPaintingMode()
   RemoveTooltip()
   Global lastOtherWinClose := A_TickCount
   uiPanelOpenCloseEvent()
}

MainPanelTransformArea(dummy:="", toolu:="", modalia:=0) {
    userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    If (viewportQPVimage.imgHandle)
    {
       If warnHugeImageNotFIM()
          Return

       bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
       If warnIncorrectColorDepthHugeImage(bpp, 1)
          Return
    }

    imgPath := getIDimage(currentFileIndex)
    wasGiven := (FileRexists(dummy) && modalia="extern-file" && toolu="paste") ? 1 : 0
    If (wasGiven=0 && modalia="extern-file" && toolu="paste")
    {
       showTOOLtip("ERROR: Failed to import given file")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (thumbsDisplaying=1 || editingSelectionNow!=1 || openingPanelNow=1 || isFailed=1)
       Return

    calcScreenLimits()
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If throwErrorSelectionOutsideBounds()
       Return

    PasteInPlaceRevealOriginal := 0
    openingPanelNow := 1
    DestroyGIFuWin()
    changeMcursor()
    setImageLoading()
    vpWinClientSize(mainWidth, mainHeight)
    If (viewportQPVimage.imgHandle)
    {
       oPasteInPlaceCropAngular := (VPselRotation>=0) ? VPselRotation : VPselRotation + 360
       If (EllipseSelectMode=1)
          oPasteInPlaceCropSel := 3
       Else If (EllipseSelectMode=2)
          oPasteInPlaceCropSel := 7
       Else
          oPasteInPlaceCropSel := 1
       oPasteInPlaceCropDo := (EllipseSelectMode>0 || VPselRotation || innerSelectionCavityX || innerSelectionCavityY) ? 1 : 0
    }

    If (toolu="transform")
    {
       trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
       If (viewportQPVimage.imgHandle)
       {
          bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
          oldSelectionArea := [imgSelX1, imgSelY1, imgSelX2, imgSelY2, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, innerSelectionCavityX, innerSelectionCavityY, bpp]
          VPselRotation := EllipseSelectMode := innerSelectionCavityX := innerSelectionCavityY := 0
          x1 := clampInRange(ImgSelX1, 0, imgW - 1)
          y1 := clampInRange(ImgSelY1, 0, imgH - 1)
          x2 := clampInRange(ImgSelX2, ImgSelX1 + 1, imgW)
          y2 := clampInRange(ImgSelY2, ImgSelY1 + 1, imgH)
          imgSelX1 := x1, imgSelY1 := y1
          imgSelX2 := x2, imgSelY2 := y2
          defineRelativeSelCoords(imgW, imgH)
          oldSelectionArea[12] := imgSelX2 - imgSelX1
          oldSelectionArea[13] := imgSelY2 - imgSelY1
       }

       zW := imgSelX2 - imgSelX1
       zH := imgSelY2 - imgSelY1
       showTOOLtip("Retrieving image selected area, please wait")
       calcIMGdimensions(zW, zH, mainWidth - 1, mainHeight - 1, newW, newH)
       userClipBMPpaste := getSelectedImageArea(useGdiBitmap(), 0, 1, 1, newW, newH)
       If validBMP(userClipBMPpaste)
       {
          trGdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
          Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)

          QPV_PrepareAlphaChannelBlur(viewportStampBMP, 1, 1)
       }
    } Else If (toolu="paste")
    {
       If (wasGiven=1)
          showTOOLtip("Loading image, please wait")
       Else
          showTOOLtip("Retrieving clipboard image, please wait")

       If (wasGiven=1)
       {
          If (viewportQPVimage.imgHandle)
          {
             hFIFimgA := LoadBitmapAsFreeImage(dummy, -1, oImgW, oImgH, imgBPP)
             userClipBMPpaste := rescaleFIMbmpGDIp(hFIFimgA, mainWidth, mainHeight)
          } Else
             userClipBMPpaste := LoadBitmapFromFileu(dummy)
       } Else
       {
          userClipBMPpaste := corePasteClipboardImg(1, ResolutionWidth*3, ResolutionHeight*4, 0)
          If (validBMP(userClipBMPpaste) && viewportQPVimage.imgHandle)
          {
             hFIFimgA := ConvertPBITMAPtoFIM(userClipBMPpaste)
             If !hFIFimgA
             {
                trGdip_DisposeImage(userClipBMPpaste)
                addJournalEntry("(): Failed to convert the clipboard image to a FreeImage bitmap object.")
             }
          }
       }

       If validBMP(userClipBMPpaste)
       {
          If (hFIFimgA && viewportQPVimage.imgHandle)
          {
             FreeImage_GetImageDimensions(hFIFimgA, ow, oh)
             imgBPP := FreeImage_GetBPP(hFIFimgA)
             oPasteInPlaceCropDo := 0
          }

          oldSelectionArea := [imgSelX1, imgSelY1, imgSelX2, imgSelY2, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, innerSelectionCavityX, innerSelectionCavityY, imgBPP, hFIFimgA, ow, oh]
          VPselRotation := EllipseSelectMode := innerSelectionCavityX := innerSelectionCavityY := 0
          trGdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
          {
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
             If (viewportQPVimage.imgHandle && validBMP(viewportStampBMP))
             {
                trGdip_DisposeImage(userClipBMPpaste)
                userClipBMPpaste := trGdip_CloneBitmap(A_ThisFunc, viewportStampBMP)
             }
          } Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)

          QPV_PrepareAlphaChannelBlur(viewportStampBMP, 1, 1)
       }
    }

    If (!validBMP(userClipBMPpaste) || !validBMP(viewportStampBMP))
    {
       openingPanelNow := 0
       oldSelectionArea := []
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       showTOOLtip("ERROR: Failed to retrieve and prepare image to perform transformations")
       SoundBeep , 300, 100
       SetTimer, resetOpeningPanel, -200
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return
    }

    imgEditPanelOpened := 1
    viewportIDstampBMP := A_TickCount
    prevVPselRotation := VPselRotation
    prevrotateSelBoundsKeepRatio := rotateSelBoundsKeepRatio
    prevEllipseSelectMode := EllipseSelectMode
    previnnerSelectionCavityX := innerSelectionCavityX
    previnnerSelectionCavityY := innerSelectionCavityY
    prevImgSelX1 := imgSelX1, prevImgSelX2 := imgSelX2
    prevImgSelY1 := imgSelY1, prevImgSelY2 := imgSelY2
    If (toolu="transform")
    {
       recordSelUndoLevelNow()
       trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
       pB := GetPathRelativeBounds(pPath, imgSelPx, imgSelPy)
       imgSelX1 := pB.x, imgSelY1 := pB.y
       imgSelX2 := pB.x + pB.w
       imgSelY2 := pB.y + pB.h
       VPstampBMPx := pB.x, VPstampBMPy := pB.y
       PasteInPlaceToolMode := 1
       dummyRefreshImgSelectionWindow()
       thisBtnHeight := createSettingsGUI(31, "PanelTransformSelectedArea", 1, 1)
    } Else If (toolu="paste")
    {
       PasteInPlaceToolMode := 0
       flipBitmapAccordingToViewPort(viewportStampBMP)
       thisBtnHeight := createSettingsGUI(24, "PanelPasteInPlace", 1, 1)
    }

    shearImgX := shearImgY := innerSelectionCavityX := innerSelectionCavityY := EllipseSelectMode := VPselRotation := 0
    ResetImgLoadStatus()
    ReadSettingsPasteInPlace()
    ReadSettingsBrushPanel()
    ReadSettingsAlphaMaskPanel()
    If (viewportQPVimage.imgHandle)
    {
       PasteInPlaceCropAdaptImg := 1
       PasteInPlaceCropSel := oPasteInPlaceCropSel
       PasteInPlaceCropDo := oPasteInPlaceCropDo
       PasteInPlaceCropAngular := oPasteInPlaceCropAngular
       innerSelectionCavityX := oldSelectionArea[8]
       innerSelectionCavityY := oldSelectionArea[9]
    }

    If (PasteInPlaceToolMode=0)
       PasteInPlaceEraseInitial := 0

    If !isNumber(PasteInPlaceCropAngular)
       PasteInPlaceCropAngular := 0

    If isWinXP
       PasteInPlaceBlendMode := 1

    If (coreDesiredPixFmt="0x21808" || viewportQPVimage.imgHandle)
       alphaMaskingMode := 1

    btnWid := 90,  txtWid := 310
    EditWid := 60, slideWid := 150
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 55
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid2 := txtWid//2
    trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (toolu="transform")
       prevModeViewPortSelectionManager(prevDestPosX, prevDestPosY, oImgW, oImgH)

    customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
    FillAreaClosedPath := FillAreaEllipsePie := 1
    userUIshapeCavity := Round((innerSelectionCavityX + innerSelectionCavityY) / 2 * 400)
    thisOpacity := Round((PasteInPlaceOpacity / 255) * 100)
    Global btnReset, btnLiveApplyTool, infoAlphaFile, uiPasteInPlaceAlphaDrawMode, UIremAlpha
    If (viewportQPVimage.imgHandle)
    {
       imgW := oldSelectionArea[12]
       imgH := oldSelectionArea[13]
    } Else
       trGdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)

    bonusTabs := (viewportQPVimage.imgHandle) ? "" : "|Alpha mask|Paint alpha mask"
    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Main|Crop|Adjust colors%bonusTabs%
    Gui, Tab, 1 ; general
    fr :=  (toolu="transform") ? "Transformed" : "Clipboard"
    Gui, Add, Text, x+15 y+15 Section w%txtWid%, Canvas: %oImgW% x %oImgH% px.`n%fr% object: %imgW% x %imgH% px.
    If (viewportQPVimage.imgHandle)
       PasteInPlaceBlurAmount := PasteInPlaceAutoExpandIMG := 0

    sml := (PrefsLargeFonts=1) ? 70 : 55
    widu := (PrefsLargeFonts=1) ? 30 : 25
    GuiAddDropDownList("xs y+7 wp gupdateUIpastePanel AltSubmit Choose" PasteInPlaceAdaptMode " vPasteInPlaceAdaptMode", "Adjust image to selection|Fill selection area entirely (ignore aspect ratio)|Original image size", "Image adapt mode to selection")
    GuiAddDropDownList("xs y+7 gupdateUIpastePanel w" txtWid2 " AltSubmit Choose" PasteInPlaceAlignment " vPasteInPlaceAlignment", "Top, left corner|Top, right corner|Center point|Bottom, left corner|Bottom, right corner", "Anchor point in selection area")
    GuiAddDropDownList("x+2 gupdateUIpastePanel w" txtWid2 - widu*2 - 4 " AltSubmit Choose" PasteInPlaceOrientation " vPasteInPlaceOrientation", "0°|90°|180°|270°", "Image orientation")
    GuiAddCheckbox("x+2 yp hp w" widu " gupdateUIpastePanel Checked" PasteInPlaceOrientFlipX " vPasteInPlaceOrientFlipX", "Flip horizontally", "X")
    GuiAddCheckbox("x+2 yp hp wp gupdateUIpastePanel Checked" PasteInPlaceOrientFlipY " vPasteInPlaceOrientFlipY", "Flip vertically", "Y")
    bpp := (viewportQPVimage.imgHandle) ? FreeImage_GetBPP(viewportQPVimage.imgHandle) : 32
    bppz := (bpp!=32 && PasteInPlaceToolMode=1) ? "initial area (must be a RGBA image)" : "the initially selected area "
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceEraseInitial% vPasteInPlaceEraseInitial +hwndhTemp, &Erase %bppz%
    ToolTip2ctrl(hTemp, "The preview will be inaccurate for the erased area when using blending modes or alpha masks.")
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceQuality% vPasteInPlaceQuality, &High quality image resampling
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas to fit image object
    GuiAddSlider("PasteInPlaceBlurAmount", 0,255, 0, "Image blur", "updateUIpastePanel", 1, "xs y+10 w" txtWid2 " hp")
    Gui, Add, Checkbox, x+5 hp gupdateUIpastePanel Checked%PasteInPlaceBlurEdgesSoft% vPasteInPlaceBlurEdgesSoft, &Soft edges
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%forceSlowLivePreviewMode% vforceSlowLivePreviewMode +hwndhTemp, &Force larger than viewport preview
    ToolTip2ctrl(hTemp, "QPV can become utterly slow if this option is activated...")
    If (coreDesiredPixFmt="0x21808")
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+10 w%txtWid%, WARNING: 32-bits RGBA mode is not activated. This tool may yield erroneous results.
       Gui, Font, Normal
    }

    slimeWid := (PrefsLargeFonts=1) ? 215 : 155
    Gui, Tab, 2 ; crop
    Gui, Add, Checkbox, x+15 y+15 gupdateUIpastePanel Checked%PasteInPlaceCropDo% vPasteInPlaceCropDo, &Crop manipulated image
    GuiAddDropDownList("xs y+7 w" slimeWid " AltSubmit Choose" PasteInPlaceCropSel " vPasteInPlaceCropSel gupdateUIpastePanel", "Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape", "Crop shape")
    GuiAddDropDownList("x+5 wp AltSubmit Choose" FillAreaCurveTension " vFillAreaCurveTension gupdateUIpastePanel", "Polygonal|Smooth corners|Curve|Round curve|Bézier", "Vector path type")
    GuiAddSlider("FillAreaRectRoundness", 4,98, 10, "Roundness", "updateUIpastePanel", 1, "xp yp wp hp")
    GuiAddSlider("FillAreaEllipseSection", -270,850, 850, ".updateLabelEllipseSect", "updateUIpastePanel", 3, "xp yp wp hp")
    GuiAddSlider("userUIshapeCavity", 0,400, 0, "Shape cavity", "updateFillInnerCavity", 1, "xs y+5 w" slimeWid " hp")
    GuiAddSlider("PasteInPlaceCropAngular", -180,180, 0, "Shape rotation: $€°", "updateUIpastePanel", 2, "x+5 wp hp")
    Gui, Add, Checkbox, xs y+10 gupdateUIpastePanel Checked%PasteInPlaceCropAdaptImg% vPasteInPlaceCropAdaptImg, &Adapt the shape to its size and position

    Gui, Tab, 3 ; colors
    GuiAddDropDownList("x+15 y+15 w" txtWid2 " Section gupdateUIpastePanel AltSubmit Choose" PasteInPlaceBlendMode " vPasteInPlaceBlendMode", "No blend mode|" userBlendModesList, "Blending mode")
    GuiAddFlipBlendLayers("x+1 yp hp w" widu " gupdateUIpastePanel")
    GuiAddDropDownList("x+2 w" txtWid2 - widu - 3 " AltSubmit Choose" PasteInPlaceGlassy " vPasteInPlaceGlassy gupdateUIpastePanel", "No glass effect|Weak|Mild|Moderate|Strong|Extreme", "Glass effect")
    GuiAddSlider("PasteInPlaceOpacity", 1,512, 255, ".updateLabelPasteImgOpacity", "updateUIpastePanel", 1, "xs y+10 w" txtWid - widu - 2 " hp", "Opacity above 100% allows user to restore partially`nvisible pixels in the manipulated image object.")
    GuiAddCheckbox("x+1 hp w" widu " gupdateUIpastePanel Checked" BlendModesPreserveAlpha " vBlendModesPreserveAlpha", "Protect alpha channel", "P",, "Preserve the alpha channel of the background`nimage unaltered by blend modes")
    Gui, Add, Checkbox, xs y+15 w%txtWid2% hp gupdateUIpastePanel Checked%PasteInPlaceApplyColorFX% vPasteInPlaceApplyColorFX, Color adjustments
    Gui, Add, Checkbox, x+5 wp hp gupdateUIpastePanel Checked%userimgGammaCorrect% vuserimgGammaCorrect, Gamma correction
    GuiAddGeneralColorAdjustCtrls(txtWid, "updateUIpastePanel")

    uiADDalphaMaskTabs(4, 5, "updateUIpastePanel")
    Gui, Tab
    ; friendlyBtn := (toolu="paste") ? "&Paste" : "&Transform"
    sml := (PrefsLargeFonts=1) ? 82 : 65
    ml := (PrefsLargeFonts=1) ? 35 : 25
    friendlyTitle := (toolu="paste") ? "Paste in place image: " : "Transform selected area: "
    GuiAddCollapseBtn("xm+0 y+15 Section h" thisBtnHeight " w" ml)
    GuiAddToggleLivePreview("x+5 yp hp wp gupdateUIpastePanel")
    Gui, Add, Button, x+5 w%sml% hp Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    Gui, Add, Button, x+5 hp wp vbtnReset gBtnPasteResetOptions, &Reset
    Gui, Add, Button, x+5 hp wp-5 gBtnHelpTransform, &Help
    Gui, Add, Button, x+5 hp wp+5 gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, friendlyTitle appTitle, winPos)
    SetTimer, updateUIpastePanel, -350
    SetTimer, resetOpeningPanel, -300
}

BtnHelpTransform() {
    msgBoxWrapper(appTitle ": HELP", "The transform panel hosts a multitude of functions: clone, crop, resize, skew, rotate, align images side by side, color adjust and/or blend images.`n`nClone image area. Select an image area and open this panel and make sure effects are applied by clicking on the Reset button.`n`nRotate the image. Locate the dot in the center of the selection area with the mouse cursor in the viewport, and click 'n drag to adjust the rotation angle. Alternatively, set the object orientation angle found in the Main tab.`n`nCrop an image. Set the first drop-down found in the Main tab, to «Original image size», make the selection as small as you need it to be and set the alignment of the pivot (Main tab). Then go to the Crop tab and set to the preferences available: crop shape, angle and so on.`n`nAdjust colors and blend images. In the «Adjust colors» tab one can activate the colour adjustments check-box, adjust opacity and choose different blending modes.`n`nWhen alpha masking is activated and the tab pertaining to this is also activated, users can click 'n drag inside the selection area to adjust the mask's gradient center. To reset the position, press Alt+L-Click inside the selection area.", -1, 0, 0)
}

MenuResetTransformToolPos() {
    If (PasteInPlaceToolMode!=1)
       Return

    PasteInPlaceOrientFlipX := PasteInPlaceOrientFlipY := PasteInPlaceRevealOriginal := 0
    PasteInPlaceAdaptMode := PasteInPlaceOrientation := PasteInPlaceCropSel := 1
    PasteInPlaceCropDo := VPselRotation := shearImgX := shearImgY := 0
    PasteInPlaceAlignment := 3
    ImgSelX1 := prevImgSelX1, ImgSelX2 := prevImgSelX2
    ImgSelY1 := prevImgSelY1, ImgSelY2 := prevImgSelY2
    If (viewportQPVimage.imgHandle)
    {
       PasteInPlaceCropAngular := oldSelectionArea[6]
       If (oldSelectionArea[5]=1)
          PasteInPlaceCropSel := 3
       Else If (oldSelectionArea[5]=2)
          PasteInPlaceCropSel := 7
       Else
          PasteInPlaceCropSel := 1

       PasteInPlaceCropDo := (oldSelectionArea[6] || oldSelectionArea[8] || oldSelectionArea[9]) ? 1 : 0
       innerSelectionCavityX := oldSelectionArea[8]
       innerSelectionCavityY := oldSelectionArea[9]
       userUIshapeCavity := Round((innerSelectionCavityX + innerSelectionCavityY) / 2 * 400)
    }

    If (AnyWindowOpen && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, PasteInPlaceCropSel, % PasteInPlaceCropSel
       GuiControl, SettingsGUIA: Choose, PasteInPlaceAlignment, 3
       GuiControl, SettingsGUIA: Choose, PasteInPlaceAdaptMode, 1
       GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, 1
       GuiControl, SettingsGUIA: , PasteInPlaceCropDo, % PasteInPlaceCropDo
       GuiControl, SettingsGUIA: , PasteInPlaceOrientFlipX, 0
       GuiControl, SettingsGUIA: , PasteInPlaceOrientFlipY, 0
       GuiUpdateSliders("PasteInPlaceCropAngular")
       GuiUpdateSliders("userUIshapeCavity")
    }

    dummyTimerDelayiedImageDisplay(100)
}

BtnResetPanelsSpecificControl(CtrlHwnd, b, c) {
   ; unused function
   ; GuiControlGet, varu, SettingsGUIA: FocusV
   If (isAlphaMaskWindow()=1)
      GuiControlGet, modus, SettingsGUIA:, alphaMaskingMode

   GuiControlGet, varu, SettingsGUIA: Name, % CtrlHwnd
   ; ToolTip, % varu "`n" a "|" b "|" c , , , 2

   UItriggerBrushUpdate(1)
}

BtnPasteResetOptions() {
   If (liveDrawingBrushTool=1)
   {
      toggleAlphaPaintingMode()
      Return
   }

   PasteInPlaceGlassy := PasteInPlaceBlendMode := PasteInPlaceCropSel := PasteInPlaceOrientation := PasteInPlaceAdaptMode := alphaMaskingMode := 1
   PasteInPlaceOrientFlipX := PasteInPlaceOrientFlipY := PasteInPlaceBlurAmount := PasteInPlaceHue := PasteInPlaceSaturation := PasteInPlaceLight := FillAreaGradientAngle := 0
   userImgAdjustInvertColors := PasteInPlaceCropDo := PasteInPlaceBlurAmount := PasteInPlaceApplyColorFX := PasteInPlaceGamma := 0
   PasteInPlaceAlignment := 3
   PasteInPlaceOpacity := 255
   uiSlidersArray["PasteInPlaceHue", 14] := 1
   uiSlidersArray["PasteInPlaceApplyColorFX", 14] := 1
   uiSlidersArray["PasteInPlaceSaturation", 14] := 1
   uiSlidersArray["PasteInPlaceLight", 14] := 1
   uiSlidersArray["PasteInPlaceGamma", 14] := 1
   uiSlidersArray["PasteInPlaceOpacity", 14] := 1
   uiSlidersArray["PasteInPlaceBlurAmount", 14] := 1
   uiSlidersArray["FillAreaGradientAngle", 14] := 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceBlendMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceGlassy, 1
   GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAlignment, 3
   GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAdaptMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceCropSel, 1
   GuiControl, SettingsGUIA: , PasteInPlaceApplyColorFX, 0
   GuiControl, SettingsGUIA: , PasteInPlaceCropDo, 0
   GuiControl, SettingsGUIA: , PasteInPlaceOrientFlipX, 0
   GuiControl, SettingsGUIA: , PasteInPlaceOrientFlipY, 0
   GuiControl, SettingsGUIA: , userImgAdjustInvertColors, 0
   ; WriteSettingsPasteInPlacePanel()
   updateUIpastePanel()
}

WriteSettingsFillBehindAreaPanel() {
   ReadSettingsFillBehindAreaPanel(1)
}

ReadSettingsFillBehindAreaPanel(act:=0) {
    If (act=0)
    {
       RegAction(0, "initialCustomShapeCoords",, 5)
       If !InStr(FillAreaCustomShape, "|")
          RegAction(0, "FillAreaCustomShape",, 5)

       If (drawingShapeNow!=1)
          RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
    } Else If (act=1)
    {
       RegAction(1, "FillAreaCurveTension",, 2, 1, 5)
       If InStr(FillAreaCustomShape, "|")
          RegAction(1, "FillAreaCustomShape")
    }

    RegAction(act, "FillBehindOpacity",, 2, 1, 512)
    RegAction(act, "FillBehindClrOpacity",, 2, 2, 255)
    RegAction(act, "FillBehindInvert",, 1)
    RegAction(act, "freeHandSelectionMode",, 1)
    RegAction(act, "FillBehindColor",, 3)
    RegAction(act, "FillAreaRectRoundness",, 2, 4, 98)
}

ReadSettingsFillAreaPanel(act:=0) {
    If (act=0)
    {
       RegAction(0, "initialCustomShapeCoords",, 5)
       If !InStr(FillAreaCustomShape, "|")
          RegAction(0, "FillAreaCustomShape",, 5)

       If (drawingShapeNow!=1)
          RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
    } Else If (act=1)
    {
       RegAction(1, "FillAreaCurveTension",, 2, 1, 5)
       If InStr(FillAreaCustomShape, "|")
          RegAction(1, "FillAreaCustomShape")
    }

    RegAction(act, "FillAreaColor",, 3)
    RegAction(act, "FillAreaOpacity",, 2, 1, 255)
    RegAction(act, "FillArea2ndColor",, 3)
    RegAction(act, "FillArea2ndOpacity",, 2, 1, 255)
    RegAction(act, "FillAreaBlendMode",, 2, 1, 24)
    RegAction(act, "FillAreaCutGlass",, 1)
    RegAction(act, "FillAreaClosedPath",, 1)
    RegAction(act, "FillAreaColorMode",, 2, 1, 6)
    RegAction(act, "FillAreaColorReversed",, 1)
    RegAction(act, "FillAreaGlassy",, 2, 1, 6)
    RegAction(act, "FillAreaRectRoundness",, 2, 4, 98)
    RegAction(act, "FillAreaGradientAngle",, 2, -180, 180)
    RegAction(act, "FillAreaGradientPosA",, 2, 0, 200)
    RegAction(act, "FillAreaGradientPosB",, 2, 0, 200)
    RegAction(act, "FillAreaGradientScale",, 2, 1, 300)
    RegAction(act, "FillAreaGradientWrapped", 2, 1, 5)
    RegAction(act, "FillAreaInverted",, 1)
    RegAction(act, "FillAreaRemBGR",, 1)
    RegAction(act, "FillAreaDoContour",, 1)
    RegAction(act, "FillAreaApplyColorFX",, 1)
    RegAction(act, "freeHandSelectionMode",, 1)
    RegAction(act, "DrawLineAreaColor",, 3)
    RegAction(act, "DrawLineAreaOpacity",, 2, 1, 255)
    RegAction(act, "DrawLineAreaCapsStyle",, 1)
    RegAction(act, "DrawLineAreaDoubles",, 1)
    RegAction(act, "DrawLineAreaContourAlign",, 2, 1, 3)
    RegAction(act, "DrawLineAreaDashStyle",, 2, 1, 4)
    RegAction(act, "DrawLineAreaContourThickness",, 2, 1, 700)
    RegAction(act, "PasteInPlaceGamma",, 2, -100, 100)
    RegAction(act, "PasteInPlaceHue",, 2, -180, 180)
    RegAction(act, "PasteInPlaceLight",, 2, -255, 255)
    RegAction(act, "PasteInPlaceSaturation",, 2, -100, 100)
    RegAction(act, "alphaMaskClrAintensity",, 2, 0, 255)
    RegAction(act, "alphaMaskClrBintensity",, 2, 0, 255)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
    IniAction(act, "userimgGammaCorrect", "General", 1)
}

ReadSettingsDrawShapeAreaPanel(act:=0) {
    If (act=0)
    {
       RegAction(0, "initialCustomShapeCoords",, 5)
       If !InStr(FillAreaCustomShape, "|")
          RegAction(0, "FillAreaCustomShape",, 5)

       If (drawingShapeNow!=1)
          RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
    } Else If (act=1)
    {
       RegAction(1, "FillAreaCurveTension",, 2, 1, 5)
       If InStr(FillAreaCustomShape, "|")
          RegAction(1, "FillAreaCustomShape")
    }

    RegAction(act, "DrawLineAreaColor",, 3)
    RegAction(act, "DrawLineAreaOpacity",, 2, 1, 255)
    RegAction(act, "DrawLineAreaCapsStyle",, 1)
    RegAction(act, "DrawLineAreaDoubles",, 1)
    RegAction(act, "DrawLineAreaContourAlign",, 2, 1, 3)
    RegAction(act, "DrawLineAreaDashStyle",, 2, 1, 4)
    RegAction(act, "DrawLineAreaContourThickness",, 2, 1, 700)
    RegAction(act, "DrawLineAreaBlendMode",, 2, 1, 24)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
    RegAction(act, "FillAreaClosedPath",, 1)
    RegAction(act, "freeHandSelectionMode",, 1)
}

WriteSettingsCombineIMGs() {
   ReadSettingsCombineIMGs(1)
}

ReadSettingsCombineIMGs(act:=0) {
    RegAction(act, "TextInAreaAlign",, 2, 1, 3)
    RegAction(act, "TextInAreaValign",, 2, 1, 3)
    RegAction(act, "UserCombinePDFpageSize",, 2, 1, 6)
    RegAction(act, "userCombineDepthDithering",, 1)
    RegAction(act, "userSaveBitsDepth",, 2, 1, 4)
    RegAction(act, "userCombineFramesFmt",, 2, 1, 3)
    RegAction(act, "combinePDFpageLandscape",, 1)
    RegAction(act, "combinePDFpageHighQuality",, 1)
    RegAction(act, "ResizeApplyEffects",, 1)
    RegAction(act, "userCombineSubFrames",, 1)
    RegAction(act, "userJpegQuality",, 2, 1, 100)
}

ReadSettingsVPgrid(act:=0) {
    RegAction(act, "vpGridSize",, 2, 10, 350)
    RegAction(act, "vpGridAlpha",, 2, 1, 255)
    RegAction(act, "vpGridColor",, 3)
    RegAction(act, "vpGridFixedSize",, 1)
    RegAction(act, "vpGridStepu",, 2, 2, 20)
    RegAction(act, "vpGridThickness",, 2, 1, 15)
    If (editingSelectionNow!=1 && drawingShapeNow!=1)
       INIaction(act, "LimitSelectBoundsImg", "General", 1)
}

ReadSettingsAlphaMaskPanel(act:=0) {
    If (customShapePoints.Count()<3 && act=0)
    {
       RegAction(0, "FillAreaCustomShape",, 5)
       RegAction(0, "initialCustomShapeCoords",, 5)
       customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
       If (drawingShapeNow!=1)
          RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
    }

    RegAction(act, "BrushToolDoubleSize",, 1)
    RegAction(act, "BrushToolOverDraw",, 1)
    RegAction(act, "BrushToolAutoAngle",, 1)
    RegAction(act, "alphaMaskReplaceMode",, 1)
    RegAction(act, "alphaMaskColorReversed",, 1)
    RegAction(act, "alphaMaskGradientWrapped",, 2, 1, 5)
    ; RegAction(act, "alphaMaskGradientScale",, 2, 1, 300)
    RegAction(act, "alphaMaskGradientPosA",, 2, 0, 200)
    RegAction(act, "alphaMaskGradientPosB",, 2, 0, 200)
    RegAction(act, "alphaMaskClrAintensity",, 2, 0, 255)
    RegAction(act, "alphaMaskClrBintensity",, 2, 0, 255)
    RegAction(act, "alphaMaskPreviewOpacity",, 2, 10, 255)
    RegAction(act, "brushAclrAlpha",, 3)
    RegAction(act, "brushBclrAlpha",, 3)
    If (alphaMaskingMode=1 && alphaMaskGradientScale<3)
       alphaMaskGradientScale := 100
}

ReadSettingsBrushPanel(act:=0) {
   ; If (ShowAdvToolbar=1)
      delayedWriteTlbrColors(act)

   RegAction(act, "BrushToolSize",, 2, 2, 950)
   RegAction(act, "BrushToolAutoAngle",, 1)
   RegAction(act, "BrushToolDoubleSize",, 1)
   RegAction(act, "BrushToolSoftness",, 2, 1, 100)
   RegAction(act, "brushToolStepping",, 2, 0, 251)
   RegAction(act, "BrushToolType",, 2, 1, 8)
   RegAction(act, "BrushToolAngle",, 2, -180, 180)
   RegAction(act, "BrushToolAspectRatio",, 2, -100, 100)
   RegAction(act, "BrushToolDryingRate",, 2, 0, 20)
   RegAction(act, "BrushToolOverDraw",, 1)
   If (AnyWindowOpen=64)
   {
      RegAction(act, "BrushToolTexture",, 2, 1, 9)
      RegAction(act, "BrushToolBlurStrength",, 2, 0, 99)
      RegAction(act, "BrushToolDynamicCloner",, 1)
      RegAction(act, "BrushToolEraserRestore",, 1)
      RegAction(act, "BrushToolOutsideSelection",, 2, 1, 3)
      RegAction(act, "BrushToolWetness",, 2, 0, 22)
      RegAction(act, "BrushToolApplyColorFX",, 1)
      RegAction(act, "PasteInPlaceGamma",, 2, -100, 100)
      RegAction(act, "PasteInPlaceHue",, 2, -180, 180)
      RegAction(act, "PasteInPlaceLight",, 2, -255, 255)
      RegAction(act, "PasteInPlaceSaturation",, 2, -100, 100)
   }
}

customKbdGUIAGuiContextMenu:
   SettingsToolTips()
Return

customKbdGUIAGuiClose:
customKbdGUIAGuiEscape:
   BtnCloseKbdDefine()
Return

mouseCreateOSDinfoLine(msg:=0, largus:=0, unClickable:=0, givenCoords:=0) {
    ; Critical, On
    Static prevMsg, lastInvoked := 1
    Global TippyMsg

    ; ToolTip, % givenCoords "===" largus "==" msg , , , 2
    thisHwnd := PVhwnd
    If (StrLen(msg)<3) || (prevMsg=msg && mouseToolTipWinCreated=1) || (A_TickCount - lastInvoked<100) || !thisHwnd
       Return

    lastInvoked := A_TickCount
    Gui, mouseToolTipGuia: Destroy
    thisFntSize := (largus=1) ? Round(LargeUIfontValue*1.55) : LargeUIfontValue
    If (thisFntSize<5)
       thisFntSize := 5
    If (largus>5)
       thisFntSize := largus

    bgrColor := OSDbgrColor
    txtColor := OSDtextColor
    isBold := (FontBolded=1) ? " Bold" : ""
    lastTippyWin := WinActive("A")
    Sleep, 25
    Gui, mouseToolTipGuia: -Caption -DPIScale +Owner%thisHwnd% +ToolWindow +hwndhGuiTip
    Gui, mouseToolTipGuia: Margin, % thisFntSize * 1.25, % thisFntSize * 1.25
    Gui, mouseToolTipGuia: Color, c%bgrColor%
    Gui, mouseToolTipGuia: Font, s%thisFntSize% Bold Q5, Arial
    Gui, mouseToolTipGuia: Add, Text, c%txtColor% gdestroyMouseGuiTooltipu vTippyMsg, % msg
    Gui, mouseToolTipGuia: Show, NoActivate AutoSize Hide x1 y1, QPV tooltip window
    prevMsg := msg
    If (unClickable=1)
      WinSet, ExStyle, +0x20, ahk_id %hGuiTip%

    mouseToolTipWinCreated := 1
    delayu := StrLen(msg) * 75 + 950
    lastZeitToolTip := A_TickCount
    showOSDinfoLineNow(delayu, givenCoords)
}

showOSDinfoLineNow(delayu, givenCoords:=0) {
    If !mouseToolTipWinCreated
       Return

    GetPhysicalCursorPos(mX, mY)
    If IsObject(givenCoords)
    {
       If (givenCoords.x && givenCoords.y)
       {
          forced := 1
          mX := givenCoords.x 
          mY := givenCoords.y + givenCoords.h
       }
    } Else If InStr(givenCoords, "|")
    {
       pk := StrSplit(givenCoords, "|")
       mX := pk[1], mY := pk[2]
    }

    If (!isWinXP && forced!=1)
    {
       GetWinClientSize(Wid, Heig, hGuiTip, 1)
       k := WinMoveZ(hGuiTip, 0, mX + 20, mY + 29, Wid, Heig, 2)
       Final_x := k[1], Final_y := k[2]
    } Else
    {
       tipX := (forced=1) ?  mX : mX + 20
       tipY := (forced=1) ?  mY : mY + 20
       ResWidth := adjustWin2MonLimits(hGuiTip, tipX, tipY, Final_x, Final_y, Wid, Heig)
       MaxWidth := Floor(ResWidth*0.85)
       If (MaxWidth<Wid && MaxWidth>10)
       {
          GuiControl, mouseToolTipGuia: Move, TippyMsg, w1 h1
          GuiControl, mouseToolTipGuia:, TippyMsg,
          Gui, mouseToolTipGuia: Add, Text, xp yp c%txtColor% gmouseClickTurnOFFtooltip w%MaxWidth%, %msg%
          Gui, mouseToolTipGuia: Show, NoActivate AutoSize Hide x1 y1, QPV tooltip window
          ResWidth := adjustWin2MonLimits(hGuiTip, tipX, tipY, Final_x, Final_y, Wid, Heig)
       }
    }

    If (Final_x!="" && Final_y!="")
       Gui, mouseToolTipGuia: Show, NoActivate AutoSize x%Final_x% y%Final_y%, QPV tooltip window

    WinSet, Transparent, 225, ahk_id %hGuiTip%
    If (delayu<msgDisplayTime/2)
       delayu := msgDisplayTime//2 + 1
    WinSet, AlwaysOnTop, On, ahk_id %hGuiTip%
    ; WinSet, ExStyle, +0x20, ahk_id %hGuiTip%
    SetTimer, mouseTurnOFFtooltip, % -delayu
}

adjustWin2MonLimits(winHwnd, winX, winY, ByRef rX, ByRef rY, ByRef Wid, ByRef Heig) {
   GetWinClientSize(Wid, Heig, winHwnd, 1)
   ActiveMon := MWAGetMonitorMouseIsIn(winX, winY)
   If ActiveMon
   {
      SysGet, bCoord, Monitor, %ActiveMon%
      rX := max(bCoordLeft, min(winX, bCoordRight - Wid))
      rY := max(bCoordTop, min(winY, bCoordBottom - Heig*1.2))
      ResWidth := Abs(max(bCoordRight, bCoordLeft) - min(bCoordRight, bCoordLeft))
      ; ResHeight := Abs(max(bCoordTop, bCoordBottom) - min(bCoordTop, bCoordBottom))
   } Else
   {
      rX := winX
      rY := winY
   }

   Return ResWidth
}

mouseToolTipGuiaGuiClose:
mouseToolTipGuiaGuiEscape:
   mouseTurnOFFtooltip()
Return

destroyMouseGuiTooltipu() {
   mouseTurnOFFtooltip()
   Sleep, 1
   WinActivate, ahk_id %lastTippyWin%
   ; MouseGetPos, ,, OutputVarWin
   ; If (OutputVarWin=hQPVtoolbar && ShowAdvToolbar=1)
   ;    MouseClick, Left
}

LEDguiGuiClose:
LEDguiGuiEscape:
   StopColorPicker()
Return

createLEDgui(LEDu, thisOpacity:=255, pX:=2, pY:=2, clr:=0) {
   Gui, LEDgui: -DPIScale +AlwaysOnTop -Caption +ToolWindow +E0x20 +0x800000 +hwndhColorPrev
   Gui, LEDgui: Color, %clr%
   Gui, LEDgui: Add, Text, x1 y1 w%LEDu% h%LEDu% gStopColorPicker, -
   Gui, LEDgui: Show, NoActivate x%pX% y%pY% w%LEDu% h%LEDu%, QPVcolorPicker
   WinSet, AlwaysOnTop, On, ahk_id %hColorPrev%
   If (thisOpacity<253)
      WinSet, Transparent, % thisOpacity, ahk_id %hColorPrev%
   Sleep, 1
   Return hColorPrev
}

showLEDgui(clr, pX, pY) {
   Static prev_clr
   If (clr="prev")
      clr := prev_clr
   Else
      prev_clr := clr

   Gui, LEDgui: Color, %clr%
   Gui, LEDgui: Show, NoActivate x%pX% y%pY%
   Gui, LEDgui: +AlwaysOnTop
   return prev_clr
}

StopColorPicker() {
   Critical, on
   colorPickerModeNow := 0
   Gui, LEDgui: Destroy
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   interfaceThread.ahkassign("colorPickerModeNow", colorPickerModeNow)
   interfaceThread.ahkassign("colorPickerMustEnd", 0)
   interfaceThread.ahkPostFunction("setMenuBarState", "Enable", "PVmenu")
}

StartPickingColor(a:=0, b:=0, c:=0, d:=0) {
   ; fnOutputDebug(a "=" b "=" c)
   g := A_Gui, ctrl := A_GuiControl
   If (a="isGiven")
   {
      g := b
      ctrl := c
   }

   ctrl := StrReplace(ctrl, "picku")
   initialColor := %ctrl%
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   endCaptureCloneBrush()
   If (editingSelectionNow=1)
      toggleLiveEditObject("hide")

   Sleep, 1
   diffH := diffW := 0
   interfaceThread.ahkPostFunction("setMenuBarState", "Disable", "PVmenu")
   CoordMode, Pixel, Screen
   LEDu := imgHUDbaseUnit
   hColorPrev := createLEDgui(LEDu)
   Sleep, 1
   colorPickerModeNow := 1
   colorPickerMustEnd := 0
   If (panelWinCollapsed!=1 && AnyWindowOpen)
      toggleImgEditPanelWindow("forced")

   ll := pll := pX := pY := errorOccured := 0
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   interfaceThread.ahkassign("colorPickerModeNow", colorPickerModeNow)
   interfaceThread.ahkassign("colorPickerMustEnd", colorPickerMustEnd)
   WinActivate, ahk_id %PVhwnd%
   createGUItoolbar()
   setWhileLoopExec(1)
   While, (colorPickerModeNow=1)
   {
      If (errorOccured>700)
         Break

      If (A_Index>2950)
      {
         errorOccured := 750
         Break
      }

      cc := interfaceThread.ahkgetvar.colorPickerMustEnd
      If (cc=1 || colorPickerMustEnd=1 || (determineLClickState() && hwnd=hColorPrev) || GetKeyState("Enter") || GetKeyState("Numpad5"))
         Break

      If (cc=-1 || colorPickerMustEnd=-1 || GetKeyState("Escape") || GetKeyState("Space") || GetKeyState("Tab") || GetKeyState("MButton") || GetKeyState("RButton"))
      {
         errorOccured := 750
         Break
      }

      Sleep, -1
      GetPhysicalCursorPos(pX, pY)
      ll := "a" pX "." pY
      If (ll!=pll)
      {
         PixelGetColor, colorHex, %pX%, %pY%, RGB Alt
         h := StrReplace(colorHex, "0x")
         If (h="")
         {
            Sleep, 5
            errorOccured++
            Continue
         }
   
         ; createColorPrevWin(h)
         pX -= LEDu + 35, pY -= LEDu + 35
         showLEDgui(h, pX, pY)
         hwnd := WinActive("A")
         pll := ll
         ; ToolTip, % h "|" px "|" py , , , 2
      }
      Sleep, 5
   }

   h := showLEDgui("prev", pX, pY)
   setWhileLoopExec(0)
   StopColorPicker()
   createGUItoolbar()
   If (panelWinCollapsed=1 && AnyWindowOpen && d!="leave-it")
      toggleImgEditPanelWindow("forced")

   If (errorOccured>690)
      Return

   If (a="isGiven")
      BrushToolWetness := clampInRange(BrushToolWetness, 0, 19)

   If (isNowAlphaPainting()=1 && InStr(ctrl, "brushtool"))
      h := convertColorToGrayscale(h)

   ; https://autohotkey.com/board/topic/43945-fast-pixelgetcolor-workaround-for-aero-windows-7-and-vista/
   o := %ctrl%
   SoundBeep, 900, 100
   ; ToolTip, % r "`n" ctrl "`n" o "`n" h "`n" g "`n" z , , , 2
   %ctrl% := h

   If ctrl
   {
      If (ctrl="WindowBGRcolor")
         INIaction(1, ctrl, "General")
      Else
         RegAction(1, ctrl)
   }

   If (AnyWindowOpen && g && ctrl)
      updateColoredRectCtrl(h, ctrl, g)

   If (AnyWindowOpen=63)
   {
      updateUIgridPanel()
   } Else If (imgEditPanelOpened=1 && g)
   {
      SetTimer, fromCurrentPanelToColorsSwatch, -200
      livePreviewsImageEditing()
   }
   Return [h, initialColor]    ; new color, old color 
}


fromCurrentPanelToColorsSwatch() {
   If !ShowAdvToolbar
      Return

   If isNowAlphaPainting()
   {
      updateTlbrColorsSwatch()
   } Else If (AnyWindowOpen=66)
   {
      fromPanelColorsToColorsSwatch("FloodFillColor", FloodFillColor)
   } Else If (AnyWindowOpen=27 || AnyWindowOpen=28)
   {
      fromPanelColorsToColorsSwatch("OutlierFillColor", OutlierFillColor)
   } Else If (AnyWindowOpen=68)
   {
      fromPanelColorsToColorsSwatch("FillBehindColor", FillBehindColor)
   } Else If (AnyWindowOpen=23)
   {
      fromPanelColorsToColorsSwatch("FillAreaColor", FillAreaColor)
      fromPanelColorsToColorsSwatch("FillArea2ndColor", FillArea2ndColor)
   } Else If (AnyWindowOpen=32)
   {
      fromPanelColorsToColorsSwatch("TextInAreaBgrColor", TextInAreaBgrColor)
      fromPanelColorsToColorsSwatch("TextInAreaFontColor", TextInAreaFontColor)
   } Else If (AnyWindowOpen=30 || AnyWindowOpen=65)
   {
      fromPanelColorsToColorsSwatch("DrawLineAreaColor", DrawLineAreaColor)
   } Else 
      updateTlbrColorsSwatch()
}

fromPanelColorsToColorsSwatch(ctrl, newColor) {
   If (ShowAdvToolbar=1)
   {
      If (ctrl="TextInAreaBgrColor")
      {
         BrushToolBcolor := newColor
         BrushToolBopacity := TextInAreaBgrOpacity
      } Else If (ctrl="TextInAreaFontColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := TextInAreaFontOpacity
      } Else If (ctrl="DrawLineAreaColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := DrawLineAreaOpacity
      } Else If (ctrl="FillBehindColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := FillBehindClrOpacity
      } Else If (ctrl="FloodFillColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := FloodFillClrOpacity
      } Else If (ctrl="OutlierFillColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := OutlierFillOpacity
      } Else If (ctrl="FillAreaColor")
      {
         BrushToolAcolor := newColor
         BrushToolAopacity := DrawLineAreaOpacity
      } Else If (ctrl="FillArea2ndColor")
      {
         BrushToolBcolor := newColor
         BrushToolBopacity := FillArea2ndOpacity
      }

      updateTlbrColorsSwatch()
      delayedWriteTlbrColors(1)
   }
}

delayedWriteTlbrColors(act) {
   RegAction(act, "BrushToolAcolor",, 3)
   RegAction(act, "BrushToolBcolor",, 3)
   RegAction(act, "BrushToolAopacity",, 2, 1, 255)
   RegAction(act, "BrushToolBopacity",, 2, 1, 255)
   RegAction(act, "BrushToolUseSecondaryColor",, 1)
}

convertColorToGrayscale(hexClr) {
   Gdip_FromARGB("0xFF" hexClr, A, R, G, B)
   R := R * 0.308
   G := G * 0.650
   B := B * 0.095
   Z := Round(snapToValues(R + G + B, 0, 255, 2, 1))
   thisColor := Gdip_ToARGB("0xFF", Z, Z, Z)
   clr := SubStr(Format("{1:#x}", thisColor), 5)
   ; ToolTip, % thisColor "`n" R "=" G "=" B "=" Z , , , 2
   Return clr
}

snapToValues(given, valA, valB, errMargin, clamping) {
   If isInRange(given, valA - errMargin, valA + errMargin)
      Return valA
   Else If isInRange(given, valB - errMargin, valB + errMargin)
      Return valB
   Else If (clamping=1)
      Return clampInRange(given, valA, valB)
   Else
      Return given
}

MenuCancelDrawingShape() {
   stopDrawingShape("cancel")
}

stopDrawingShape(dummy:="") {
    Critical, on
    If (drawingShapeNow!=1)
       Return

    vectorToolModus := 1
    If (customShapePoints.Count()>2000)
       showTOOLtip("Exiting vector tool mode...")
    handleOpenCloseBezier("kill")
    zeitSillyPrevent := A_TickCount
    VPcreateSelPath("kill", 0, 0, 0, 0, 0, 0, 0, 0)
    drawLiveCreateCustomShape("kill", 0, 0)
    If (dummy="cancel")
    {
       VPselRotation := vpFreeformShapeOffset[4]
       innerSelectionCavityX := vpFreeformShapeOffset[5]
       innerSelectionCavityY := vpFreeformShapeOffset[6]
       EllipseSelectMode := vpFreeformShapeOffset[7]
       If vpFreeformShapeOffset[8]
          FillAreaCurveTension := vpFreeformShapeOffset[8]
       closedLineCustomShape := vpFreeformShapeOffset[9]
       bezierSplineCustomShape := vpFreeformShapeOffset[10]
       customShapePoints := oldCustomShapePoints.Clone()
       RegAction(1, "FillAreaCurveTension",, 2, 1, 5)
       RegAction(1, "closedLineCustomShape",, 1)
       decideCustomShapeStyle()
    } Else
    {
       prevVectorShapeSymmetryMode[1, 2] := CustomShapeSymmetry
       customShapePoints := convertEditorCustomShape2viewerCoords(customShapePoints, 1)
       customShapeCountPoints := customShapePoints.Count()
    }

    ; ToolTip, % "l=" postVectorWinOpen , , , 2
    If (drawingVectorLiveMode=1 || drawingVectorLiveMode=3)
       Gdip_DeletePen(PenuDrawLive)
    Else
       Gdip_DeleteBrush(PenuDrawLive)

    PenuDrawLive := ""
    drawingShapeNow := 0
    DestroyTempBtnGui("now")
    If (customShapePoints.Count()<3 || dummy="cancel")
    {
       If (dummy!="cancel")
       {
          EllipseSelectMode := 0
          If !AnyWindowOpen
             editingSelectionNow := 0
       }

       dummyRefreshImgSelectionWindow()
       noOpen := (dummy="cancel" && InStr(postVectorWinOpen, "c")) ? 1 : 0
       If (!AnyWindowOpen && drawingVectorLiveMode!=3 && noOpen!=1)
          BTNopenPrevPanel(StrReplace(postVectorWinOpen, "c"), "yes", "n")
       ; SetTimer, RemoveTooltip, % -msgDisplayTime
       showDelayedTooltip("Drawing abandoned")
    } Else
    {
       saveVectorShapeInRegistry()
       editingSelectionNow := 1
       EllipseSelectMode := 2
       dummyTimerDelayiedImageDisplay(100)
       If (!AnyWindowOpen && drawingVectorLiveMode!=3)
          BTNopenPrevPanel(StrReplace(postVectorWinOpen, "c"), "yes", "n")
    }

    postVectorWinOpen := currentVectorUndoLevel := 0
    undoVectorShapesLevelsArray := []
    Global zeitSillyPrevent := A_TickCount
    Global lastOtherWinClose := A_TickCount
    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    interfaceThread.ahkassign("drawingShapeNow", 0)
    createGUItoolbar()
    updateUIctrl()
    MouseMoveResponder()
    If (showMainMenuBar=1)
       TriggerMenuBarUpdate()
}

predefinedVectorShapes(whichShape) {
; 1 = right triangle
; 2 = triangle
; 3 = rhombus
; 4 = box callout
; 5 = star-5
; 6 = star-4
; 7 = cross
   Static shape1c := "0.0,0.0|0.0,1.0|1.0,1.0"
        , shape1t := 1
        , shape2c := "0.5,0.0|0.0,1.0|1.0,1.0"
        , shape2t := 1
        , shape3c := "0.5,0.0|1.0,0.5|0.5,1.0|0.0,0.5"
        , shape3t := 1
        , shape4c := "0.0,0.0|1.0,0.0|1.0,0.7|0.7,0.7|0.87,1.0|0.5,0.7|0.0,0.7"
        , shape4t := 1
        , shape5c := "0.5,0.0|0.3,0.4|0.0,0.45|0.25,0.65|0.1,1.0|0.5,0.77|0.9,1.0|0.75,0.65|1.0,0.45|0.7,0.4"
        , shape5t := 1
        , shape6c := "0.5,0.0|0.35,0.35|0.0,0.5|0.35,0.65|0.5,1.0|0.65,0.65|1.0,0.5|0.65,0.35"
        , shape6t := 1
        , shape7c := "0.35,0|0.35,0.20|0,0.20|0,0.35|0.35,0.35|0.35,1|0.65,1|0.65,0.35|1,0.35|1,0.20|0.65,0.20|0.65,0"
        , shape7t := 1

     bezierSplineCustomShape := 0
     If (whichShape=9)
     {
        RegAction(0, "FillAreaCustomShape",, 5)
        RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
     } Else
     {
        thisTension := "shape" whichShape "t"
        thisShape := "shape" whichShape "c"
        FillAreaCurveTension := %thisTension%
        FillAreaCustomShape := %thisShape%
        RegAction(1, "FillAreaCurveTension")
     }

     customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
     decideCustomShapeStyle()
     dummyTimerDelayiedImageDisplay(50)
}

flipWHcustomShape(modus) {
    If (editingSelectionNow!=1 || EllipseSelectMode!=2)
       Return

    Loop, % customShapePoints.Count()
    {
       c := customShapePoints[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       thisIndex++
       If (modus="h")
          customShapePoints[thisIndex] := [1 - c[1], c[2]]
       Else
          customShapePoints[thisIndex] := [c[1], 1 - c[2]]
    }

    modus := (modus="h") ? "HORIZONTALLY" : "VERTICALLY"
    showDelayedTooltip("Custom shape flipped: " modus)
    decideCustomShapeStyle()
    dummyTimerDelayiedImageDisplay(50)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

addFluidPointsCustomShape() {
   If (drawingShapeNow!=1 || GetKeyState("Shift", "P"))
      Return

   lastInvoked := 1
   vpWinClientSize(mainWidth, mainHeight)
   newArrayu := new hashtable()
   dotsSize := (FillAreaCurveTension>1) ? SelDotsSize : SelDotsSize//2 + 1
   If (FillAreaCurveTension=3)
      dotsSize := SelDotsSize*2 + 1
   Else If (FillAreaCurveTension=4)
      dotsSize := SelDotsSize*3 + 2

   prevMX := prevMY := 0
   setWhileLoopExec(1)
   While, (determineLClickState()=1)
   {
      If (A_TickCount - lastInvoked<50)
         Continue

      GetMouseCoord2wind(PVhwnd, mX, mY)
      ogmX := (FlipImgH=1) ? mainWidth - mX : mX
      ogmY := (FlipImgV=1) ? mainHeight - mY : mY
      If (newArrayu[ogmX ogmY]=1) || isDotInRect(ogmX, ogmY, prevMX - dotsSize, prevMX + dotsSize, prevMY - dotsSize, prevMY + dotsSize)
         Continue

      getVectorCoordsFromVPpoint(ogmX, ogmY, gmX, gmY)
      customShapePoints.Push([gmX, gmY])
      thisIndex := customShapePoints.MaxIndex()
      customShapePropPoints[thisIndex] := [0, 0]
      lastInvoked := A_TickCount
      newArrayu[ogmX ogmY] := 1
      newArrayu[ogmX + 1 ogmY + 1] := 1
      newArrayu[ogmX - 1 ogmY - 1] := 1
      newArrayu[ogmX + 1 ogmY - 1] := 1
      newArrayu[ogmX - 1 ogmY + 1] := 1
      lastZeitFileSelect := A_TickCount
      prevMX := ogmX
      prevMY := ogmY
      dummyRefreshImgSelectionWindow()
   }

   setWhileLoopExec(0)
   newArrayu := []
   SetTimer, addFluidPointsCustomShape, Off
}

adjustAnchorPointsCustomShape(thisIndex:=0) {
    If (drawingShapeNow!=1)
       Return

    handleOpenCloseBezier("kill")
    lastInvoked := A_TickCount
    vpWinClientSize(mainWidth, mainHeight)
    prevState := thisState := prevMX := prevMY := 0
    setWhileLoopExec(1)
    canDoSymmetry := isNowSymmetricVectorShape()
    totalCount := customShapePoints.Count()
    GetMouseCoord2wind(PVhwnd, mX, mY)
    zmX := (FlipImgH=1) ? mainWidth - mX : mX
    zmY := (FlipImgV=1) ? mainHeight - mY : mY
    doFlippuX := (zmX<vpSymmetryPointXdp && CustomShapeSymmetry=1) ? 1 : 0
    doFlippuY := (zmY<vpSymmetryPointYdp && CustomShapeSymmetry=2) ? 1 : 0
    cB := customShapePoints[thisIndex]
    t := (autoReflectVectorAnchors=1 && totalCount>4) ? thisIndex : thisIndex - 1
    thisNode := (doFlippuX || doFlippuY) ? 5 : thisIndex - 3
    thisK := (doFlippuX || doFlippuY) ? 2 : 3

    ; ToolTip, % thisIndex "|" totalCount , , , 2
    hasLooped := 0
    oppoIndex := totalCount - t + 1
    zwpk := (autoReflectVectorAnchors=1) ? 0 : 2
    While, (determineLClickState()=1)
    {
         If (A_TickCount - lastInvoked<125)
            Continue

         If !hasLooped
         {
            If (autoReflectVectorAnchors=1 && totalCount=7 && canDoSymmetry)
               reflectGivenAnchorInPath(3, totalCount, 3, canDoSymmetry, 1, 0)
            Else If (autoReflectVectorAnchors=1 && totalCount>3)
               reflectGivenAnchorInPath(thisK, totalCount, thisNode, canDoSymmetry, 0, 0)

            drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", thisIndex - 2)
            hasLooped := 1
         }

         zeitSillyPrevent := A_TickCount
         GetMouseCoord2wind(PVhwnd, mX, mY)
         ogmX := (FlipImgH=1) ? mainWidth - mX : mX
         ogmY := (FlipImgV=1) ? mainHeight - mY : mY
         getVectorCoordsFromVPpoint(ogmX + SelDotsSize, ogmY + SelDotsSize, pmX, pmY)
         getVectorCoordsFromVPpoint(ogmX, ogmY, gmX, gmY)
         If (canDoSymmetry && totalCount>2)
         {
            hasSymmetry := calculateSymmetricVectorPoint(ogmX, ogmY, nX, nY)
            getVectorCoordsFromVPpoint(nX, nY, nX, nY)
         }

         If (doFlippuX || doFlippuY)
         {
            customShapePoints[t] := [nX, nY]
            If (autoReflectVectorAnchors=1)
               customShapePoints[2] := [gmX, gmY]
            Else
               customShapePoints[3] := [gmX, gmY]

            If (thisIndex>4 && autoReflectVectorAnchors=0)
            {
               customShapePoints[2] := [pmX, pmY]
               calculateSymmetricVectorPoint(ogmX + SelDotsSize, ogmY + SelDotsSize, nX, nY)
               getVectorCoordsFromVPpoint(nX, nY, nX, nY)
               customShapePoints[totalCount - 2 + 1] := [nX, nY]
            }
            ; ToolTip, % thisIndex "|" t "=lol" , , , 2
         } Else 
         {
            ; ToolTip, % thisIndex "|" t "=looooooooool" , , , 2
            customShapePoints[t] := [gmX, gmY]
            If (canDoSymmetry && totalCount>2)
               customShapePoints[oppoIndex] := [nX, nY]

            If (thisIndex>4 && autoReflectVectorAnchors=0)
            {
               customShapePoints[thisIndex] := [pmX, pmY]
               If (canDoSymmetry && totalCount>2)
               {
                  calculateSymmetricVectorPoint(ogmX + SelDotsSize, ogmY + SelDotsSize, nX, nY)
                  getVectorCoordsFromVPpoint(nX, nY, nX, nY)
                  customShapePoints[totalCount - thisIndex + 1] := [nX, nY]
               }
            }
         }

         thisState := "a" gmX gmY mX mY
         If (thisState!=prevState)
         {
            prevState := thisState
            showTOOLtip("P'[" t "] = (" ogmX ", " ogmY ")")
            drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", thisIndex - zwpk)
            ; dummyRefreshImgSelectionWindow()
         }
         Sleep, 2
    }

    RemoveTooltip()
    MouseMove, 2, 0, 2, R
    MouseMove, -2, 0, 2, R
    setWhileLoopExec(0)
    SetTimer, dummyForcedRefreshImgSelectionWindow, -150
    SetTimer, adjustAnchorPointsCustomShape, Off
}

resumeCustomShapeSelection(thisZL) {
   If !thisZL
      thisZL := zoomLevel

   fX := vpFreeformShapeOffset[1] ? vpFreeformShapeOffset[1] : 0
   fY := vpFreeformShapeOffset[2] ? vpFreeformShapeOffset[2] : 0
   fS := vpFreeformShapeOffset[3] ? vpFreeformShapeOffset[3] : 1
   zImgSelX1 := imgSelX1 * thisZL
   zImgSelY1 := imgSelY1 * thisZL
   zImgSelX2 := imgSelX2 * thisZL
   zImgSelY2 := imgSelY2 * thisZL
   vPimgSelPx := prevDestPosX + min(zImgSelX1, zImgSelX2)
   vPimgSelPy := prevDestPosY + min(zImgSelY1, zImgSelY2)
   vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
   offX := offY := 0

   PointsList := convertCustomShape2givenArea(customShapePoints, vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH, 1, !bezierSplineCustomShape, bezierSplineCustomShape)
   tempPath := Gdip_CreatePath()
   Gdip_AddPathPolygon(tempPath, PointsList)
   If (VPselRotation!=0)
      trGdip_RotatePathAtCenter(tempPath, VPselRotation, 1, 1, rotateSelBoundsKeepRatio, 1)

   vpFreeformShapeOffset := centerPath2bounds(tempPath, vPimgSelPx, vPimgSelPy, VPimgSelW, VPimgSelH, 0, 1, 2)
   PointsList := Gdip_GetPathPoints(tempPath, 1)
   pp := Gdip_GetPathPointsCount(tempPath)
   Gdip_DeletePath(tempPath)
   zpp := (pp=customShapePoints.Count()) ? 0 : 1
   If (bezierSplineCustomShape=1 && zpp=1)
   {
      If (testIsBezierAltViewPathClosed()=1 && closedLineCustomShape=1)
         PointsList.Push(PointsList[1], PointsList[2])
      Else
         PointsList.Push(PointsList[pp*2 - 1], PointsList[pp*2])
   }

   If (bezierSplineCustomShape=1)
   {
      simpleFixBrokenBezierPath(PointsList)
      viewerAutoCloseOpenPath(PointsList, closedLineCustomShape, 22)
      ; ToolTip, % PointsList.Count() "==zz" , , , 2
   }

   customShapePoints := convertShapePointsViewerToEditPoints(PointsList, PointsList.Count()//2)
   If (prevVectorShapeSymmetryMode[1, 2]=1)
      configVectorShapeSymmetryPoint("x", 1, ( customShapePoints.Count() ) // 2 + 1, 0, 0)
   Else If (prevVectorShapeSymmetryMode[1, 2]=2)
      configVectorShapeSymmetryPoint("y", 1, ( customShapePoints.Count() ) // 2 + 1, 0, 0)

   ; ToolTip, % customShapePoints.Count() "===" PointsList , , , 2
}

startDrawingShape(modus, dummy:=0, forcePanel:=0, wasOpen:=0, brr:=0) {
     If !CustomShapeSymmetry
        CustomShapeLockedSymmetry := 0

     prevOpenedWindow[4] := 1
     vpSymmetryPointXdp := vpSymmetryPointYdp := 0
     If (thumbsDisplaying=1 || !validBMP(gdiBitmap))
        Return

     If (mustCaptureCloneBrush=1)
     {
        StopCaptureClickStuff(dummy)
        Return
     }

     If isNowAlphaPainting()
     {
        toggleAlphaPaintingMode()
        Return
     }

     If (dummy="resume" && customShapePoints.Count()<3)
        dummy := ""

     If (VisibleQuickMenuSearchWin=1)
        closeQuickSearch()

     vectorToolModus := 1
     postVectorWinOpen := 0
     If (AnyWindowOpen && imgEditPanelOpened=1)
     {
        isWinOpen := AnyWindowOpen
        BtnCloseWindow()
        postVectorWinOpen := isWinOpen
        If (dummy="resume")
           modus := (isWinOpen=65) ? "line" : "shape"
     }

     Sleep, 5
     If (customShapePoints.Count()>2000)
        showTOOLtip("Entering vector editor mode...")
     If (editingSelectionNow=1)
        recordSelUndoLevelNow()

     If InStr(forcePanel, "draw")
        postVectorWinOpen := isWinOpen ? isWinOpen "c" : wasOpen "c"

     If (wasOpen && brr!=1)
        postVectorWinOpen := StrReplace(postVectorWinOpen, "c")

     drawingShapeNow := 1
     If (customShapePoints.Count()>2)
        oldCustomShapePoints := customShapePoints.Clone()

     interfaceThread.ahkassign("drawingShapeNow", 1)
     CustomShapeSymmetry := CustomShapeLockedSymmetry := 0
     If (dummy="resume")
     {
        resumeCustomShapeSelection(zoomLevel)
        performBezierActivePathAutoFixNow()
     } Else 
     {
        vpFreeformShapeOffset := []
        vpFreeformShapeOffset := [0, 0, 0, VPselRotation, innerSelectionCavityX, innerSelectionCavityY, EllipseSelectMode, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape]
        prevVectorShapeSymmetryMode := []
        customShapePoints := []
        ToggleEditImgSelection("show-edit")
     }

     Gdip_SetPenWidth(pPen8, SelDotsSize)
     RegAction(0, "FillAreaColor",, 3)
     RegAction(0, "FillBehindColor",, 3)
     RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
     RegAction(0, "closedLineCustomShape",, 1)
     RegAction(0, "autoReflectVectorAnchors",, 1)
     RegAction(0, "showNewVectorPointPreview",, 1)
     RegAction(0, "showContextualStatusBar",, 1)
     decideCustomShapeStyle()
     If (bezierSplineCustomShape=1)
        closedLineCustomShape := 0

     thisColorA := (modus="line") ? "0xAA" FillAreaColor : "0x88" FillAreaColor
     If InStr(postVectorWinOpen, "68")
        thisColorA := "0xAA" FillBehindColor

     If (modus="line")
     {
        RegAction(0, "DrawLineAreaColor",, 3)
        RegAction(0, "DrawLineAreaOpacity",, 2, 1, 255)
        RegAction(0, "DrawLineAreaCapsStyle",, 1)
        RegAction(0, "DrawLineAreaContourThickness",, 2, 1, 700)
        DrawLineAreaDoubles := 0
        DrawLineAreaDashStyle := 1
        RegAction(1, "DrawLineAreaDoubles",, 1)
        RegAction(1, "DrawLineAreaDashStyle",, 2, 1, 4)
        If (InStr(postVectorWinOpen, "c") || dummy!="resume" || brr=1)
        {
           DrawLineAreaOpacity := clampInRange(DrawLineAreaOpacity, 128, 255)
           RegAction(1, "DrawLineAreaOpacity",, 2, 1, 255)
        }

        thisThick := InStr(postVectorWinOpen, "c") ? imgHUDbaseUnit//10 : DrawLineAreaContourThickness * zoomLevel
        PenuDrawLive := createDrawLinesPen(thisThick)
        ; PenuDrawLive := (isWinOpen=10) ? Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10) : Gdip_CreatePen(thisColorA, imgHUDbaseUnit//7)
        drawingVectorLiveMode := 1
     } Else If (modus="shape")
     {
        If (isWinOpen=55)
           PenuDrawLive := Gdip_CloneBrush(pBrushF)
        Else
           PenuDrawLive := (isWinOpen=25) ? Gdip_CloneBrush(useHatchedBrush()) : Gdip_BrushCreateSolid(thisColorA)
        drawingVectorLiveMode := 2
     } Else If (modus="selection")
     {
        drawingVectorLiveMode := 3
        PenuDrawLive := Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10)
        LimitSelectBoundsImg := VPselRotation := innerSelectionCavityX := innerSelectionCavityY := 0
        lockSelectionAspectRatio := 1
        ; closedLineCustomShape :=  1
     }

     EllipseSelectMode := 2
     ; ToolTip, % modus "==" drawingVectorLiveMode , , , 2
     customShapeHasSelectedPoints := 0
     customShapePropPoints := []
     Loop, % customShapePoints.Count()
        customShapePropPoints[A_Index] := [0, 0]

     LabelCurve := defineVectorPathType()
     LabelType := (drawingVectorLiveMode=1) ? "path" : "filled shape"
     If (drawingVectorLiveMode=1)
     {
        LabelOpenLine := (closedLineCustomShape=1) ? "closed " : "open "
     } Else If (drawingVectorLiveMode=3)
     {
        LabelOpenLine := LabelCurve " selection area"
        LabelCurve := LabelType := ""
     }

     If (showMainMenuBar=1)
        TriggerMenuBarUpdate()

     showTOOLtip("Draw freeform " LabelOpenLine LabelCurve A_Space LabelType "`nPress Right Click for the menu options")
     If (dummy="resume")
     {
        If (customShapePoints.Count()>4 && bezierSplineCustomShape=1)
           closedLineCustomShape := testIsEditorBezierPathClosed()
        Else If (bezierSplineCustomShape=1)
           closedLineCustomShape := 0

        recordVectorUndoLevels()
     }

     CreateTempGuiButton("Die dummy", 1)
     updateUIctrl()
     createGUItoolbar()
     showQuickActionButtonsDrawingShape()
     If (showViewPortGrid=1)
        dummyTimerDelayiedImageDisplay(250)

     SetTimer, dummyForcedRefreshImgSelectionWindow, -50
     SetTimer, RemoveTooltip, % -msgDisplayTime
}

reduceCustomShapeLength(k:=0) {
   ; foundPos := InStr(customShapePoints, "|", 0, -1)
   ; customShapePoints := SubStr(customShapePoints, 1, foundPos)
   If (k!="z")
   {
      recordVectorUndoLevels()
      handleOpenCloseBezier("kill")
   }

   If (bezierSplineCustomShape=1)
      r := testIsEditorBezierPathClosed()

   customShapePoints.Pop()
   customShapePropPoints.Pop()
   zr := 1
   If (bezierSplineCustomShape=1)
   {
      If (r=1)
      {
         closedLineCustomShape := 0
         RegAction(1, "closedLineCustomShape")
      }

      customShapePoints.Pop()
      customShapePropPoints.Pop()
      zr := 2
      If (customShapePoints.Count()>=4)
      {
         zr := 3
         customShapePoints.Pop()
         customShapePropPoints.Pop()
      }
   }

   If isNowSymmetricVectorShape()
   {
      customShapePoints.RemoveAt(1)
      customShapePropPoints.RemoveAt(1)
      prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] - 1
      If (bezierSplineCustomShape=1)
      {
         customShapePoints.RemoveAt(1)
         customShapePropPoints.RemoveAt(1)
         prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] - 1
         If (customShapePoints.Count()>=4)
         {
            customShapePoints.RemoveAt(1)
            customShapePropPoints.RemoveAt(1)
            prevVectorShapeSymmetryMode[1, 1] := prevVectorShapeSymmetryMode[1, 1] - 1
         }
      }
   } ; Else CustomShapeLockedSymmetry := 0

   If (customShapePoints.Count()<7)
      lastZeitFileSelect := A_TickCount
   Else 
      fr := 1

   If (customShapePoints.Count()<1 && bezierSplineCustomShape=0 || customShapePoints.Count()<2 && bezierSplineCustomShape=1)
      CustomShapeSymmetry := CustomShapeLockedSymmetry := vpSymmetryPointXdp := vpSymmetryPointYdp := 0

   If (fr && k!="z")
   {
      vpWinClientSize(mainWidth, mainHeight)
      drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-rem-last", zr)
   }

   If (drawingShapeNow=1 && k!="z")
      showQuickActionButtonsDrawingShape()

   SetTimer, dummyRefreshImgSelectionWindow, -150
}

toggleOpenClosedViewerCustomShape() {
   closedLineCustomShape := !closedLineCustomShape
   RegAction(1, "closedLineCustomShape")
   SetTimer, dummyRefreshImgSelectionWindow, -100
}

toggleOpenClosedLineEditorCustomShape() {
   closedLineCustomShape := !closedLineCustomShape
   RegAction(1, "closedLineCustomShape")
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()

   handleOpenCloseBezier()
   SetTimer, dummyRefreshImgSelectionWindow, -150
}

handleOpenCloseBezier(mm:=0) {
   Static prevEndsOpen, prevEndsClosed, prevEndsAny, prevPoints := []
   If (mm="kill" || bezierSplineCustomShape!=1)
   {
      prevPoints := []
      prevEndsOpen := prevEndsClosed := prevEndsAny := ""
      Return
   }

   If isNowSymmetricVectorShape()
      CustomShapeSymmetry := CustomShapeLockedSymmetry := vpSymmetryPointXdp := vpSymmetryPointYdp := 0

   isClosed := testIsEditorBezierPathClosed()
   firstu := testBezierFirstLastPointsCollapsed("first")
   lastu := testBezierFirstLastPointsCollapsed("last")
   totalz := customShapePoints.Count()
   f  := customShapePoints[1],   l := customShapePoints[totalz]
   fi := customShapePoints[2],  li := customShapePoints[totalz - 1]

   pz := (lastu=1 && firstu=1) ? 1 : 0
   zthisID := f[1] "|" f[2] "|" fi[1] "|" fi[2] "|" li[1] "|" li[2] "|" l[1] "|" l[2]
   If isClosed
      prevEndsClosed := zthisID
   Else
      prevEndsOpen := zthisID

   If (prevEndsAny>=1)
   {
      ; ToolTip, % "yaaaaaay" , , , 2
      totalUndos := Round(undoVectorShapesLevelsArray.Count())
      currentVectorUndoLevel := clampInRange(currentVectorUndoLevel - 1, 1, totalUndos)
      restoreGivenVectorUndoLevel(currentVectorUndoLevel)
      closedLineCustomShape := testIsEditorBezierPathClosed()
      SetTimer, dummyRefreshImgSelectionWindow, -150
   } Else If (prevEndsOpen=zthisID && closedLineCustomShape=1 && isClosed=0 && prevEndsClosed)
   {
      ; ToolTip, % "open" , , , 2
      p := StrSplit(prevEndsClosed, "|")
      customShapePoints[1] := [p[1], p[2]],  customShapePoints[totalz - 1] := [p[5], p[6]]
      customShapePoints[2] := [p[3], p[4]],  customShapePoints[totalz] := [p[7], p[8]]
   } Else If (prevEndsClosed=zthisID && closedLineCustomShape=0 && isClosed=1 && prevEndsOpen)
   {
      ; ToolTip, % "closed" , , , 2
      p := StrSplit(prevEndsOpen, "|")
      customShapePoints[1] := [p[1], p[2]],  customShapePoints[totalz - 1] := [p[5], p[6]]
      customShapePoints[2] := [p[3], p[4]],  customShapePoints[totalz] := [p[7], p[8]]
   } Else If ((firstu=1 || lastu=1) && (closedLineCustomShape=1 && isClosed=0) && pk!=1)
   {
      ; ToolTip, % isClosed "|bt" totalz "|" firstu "|" lastu , , , 2
      If lastu 
         customShapePoints[totalz] := [f[1], f[2]]
      Else
         customShapePoints[1] := [l[1], l[2]]
   } Else If ((firstu!=1 || lastu!=1) && (closedLineCustomShape=0 && isClosed=1))
   {
      ; ToolTip, %  isClosed "|at" totalz "|" firstu "|" lastu , , , 2
      If !lastu 
         customShapePoints[totalz] := [li[1], li[2]]
      Else
         customShapePoints[1] := [fi[1], fi[2]]
   } Else If (closedLineCustomShape=1 && isClosed=0)
   {
      ; ToolTip, % thisIndex "=l" , , , 2
      thisIndex := customShapePoints.Count() - 1
      getVPcoordsVectorPoint(1, mX, mY)
      pushEndNewVectorPoint(mX, mY, 1, 1)
      reflectGivenAnchorInPath(2, customShapePoints.Count(), 2, 0, 0, 0)
      reflectGivenAnchorInPath(3, customShapePoints.Count(), thisIndex, 0, 0, 0)
      recordVectorUndoLevels()
      actz := 1
   } Else If (closedLineCustomShape=0 && isClosed=1)
   {
      reduceCustomShapeLength("K")
      If (testIsEditorBezierPathClosed()=1)
         reduceCustomShapeLength("K")
      recordVectorUndoLevels()
      actz := 2
   }

   Sleep, 2
   isClosed := testIsEditorBezierPathClosed()
   ntotalz := customShapePoints.Count()
   zf  := customShapePoints[1],   lz := customShapePoints[ntotalz]
   zfi := customShapePoints[2],  liz := customShapePoints[ntotalz - 1]
   thisID := zf[1] "|" zf[2] "|" zfi[1] "|" zfi[2] "|" liz[1] "|" liz[2] "|" lz[1] "|" lz[2]
   If isClosed
      prevEndsClosed := thisID
   Else
      prevEndsOpen := thisID

   If (totalz!=ntotalz && actz>=1)
   {
      prevEndsAny := actz
      prevEndsClosed := prevEndsOpen := ""
   } Else
      prevEndsAny := 0

   lastZeitFileSelect := A_TickCount
}

testIsEditorBezierPathClosed(m:=0) {
    ; this assumes drawingShapeNow = 1 ;
    totalz := customShapePoints.Count()
    If (totalz<4)
       Return -1

    getVPcoordsVectorPoint(1, mX, mY)
    getVPcoordsVectorPoint(totalz, nX, nY)
    If (m=1)
       r := isDotInRect(mX, mY, SelDotsSize/2, SelDotsSize/2, nX, nY, 1) ; too loose
    Else
       r := (mX=nX && mY=nY) ? 1 : 0

    ; ToolTip, % r "|" m "|" SelDotsSize//2 , , , 2
    Return r
}

testIsBezierViewPathClosed(ByRef PointsList) {
    ; this assumes drawingShapeNow = 0 ;
    totalz := PointsList.Count()//2
    xA := PointsList[1],                  yA := PointsList[2]
    xB := PointsList[totalz*2 - 1],       yB := PointsList[totalz*2]
    ; ToolTip, % xA "==" yA "`n" xB "==" yB "`n" totalz, , , 2
    r := (xA=xB && yA=yB) ? 1 : 0
    Return r
}

testIsBezierAltViewPathClosed() {
    totalz := customShapePoints.Count()
    If (totalz<4)
       Return -1

    ; this assumes drawingShapeNow = 0 ;
    xA := customShapePoints[1, 1],        yA := customShapePoints[1, 2]
    xB := customShapePoints[totalz, 1],   yB := customShapePoints[totalz, 2]
    r := (xA=xB && yA=yB) ? 1 : 0
    Return r
}

testBezierFirstLastPointsCollapsed(modus) {
    totalz := customShapePoints.Count()
    If (totalz<4)
       Return -1

    ; this assumes drawingShapeNow = 0 ;
    f := (modus="first") ? 2 : totalz
    xA := customShapePoints[f - 1, 1],        yA := customShapePoints[f - 1, 2]
    xB := customShapePoints[f, 1],            yB := customShapePoints[f, 2]
    r := (xA=xB && yA=yB) ? 1 : 0
    Return r
}

toggleAutoReflectAnchors() {
   autoReflectVectorAnchors := !autoReflectVectorAnchors
   RegAction(1, "autoReflectVectorAnchors")
   friendly := (autoReflectVectorAnchors=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Automatically reflect anchors: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

togglePreviewVectorNewPoint() {
   showNewVectorPointPreview := !showNewVectorPointPreview
   RegAction(1, "showNewVectorPointPreview")
   friendly := (showNewVectorPointPreview=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Live preview for new point: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (drawingShapeNow=1)
      showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, -150
}

defineVectorPathType() {
   labelu := (cardinalCurveCustomShape=1) ? "Curved" : "Polygonal"
   If (bezierSplineCustomShape=1 || FillAreaCurveTension=5)
      labelu := "Bézier"
   Return labelu
}

showQuickActionButtonsDrawingShape() {
  If ((showMainMenuBar=1 || ShowAdvToolbar=1) && tempBtnVisible="null")
     Return

  LabelCurve := defineVectorPathType()
  LabelOpenLine := (closedLineCustomShape=1) ? "Open path" : "Closed path"
  btnOpenLine := "||" LabelOpenLine ",,toggleOpenClosedLineEditorCustomShape"
  If (FillAreaCurveTension=1)
     ll := "Polygonal"
  Else If (FillAreaCurveTension=5)
     ll := "Bézier"
  Else
     ll := "Tension: " tensionCurveCustomShape

  LabelTension := "||" ll ",,togglePathCurveTension"
  CreateTempGuiButton("Undo,,ImgVectorUndoAct||Cancel,,MenuCancelDrawingShape||Done,,stopDrawingShape" btnOpenLine LabelTension, "Forced", msgDisplayTime*10000)
  SetTimer, DestroyTempBtnGui, Off
}

decideCustomShapeStyle() {
   bezierSplineCustomShape := 0
   If (FillAreaCurveTension=5)
      bezierSplineCustomShape := 1
   Else If (FillAreaCurveTension=4)
      tensionCurveCustomShape := 0.95
   Else If (FillAreaCurveTension=3)
      tensionCurveCustomShape := 0.5
   Else If (FillAreaCurveTension=2)
      tensionCurveCustomShape := 0.2
   Else
      tensionCurveCustomShape := 0.1

   cardinalCurveCustomShape := (FillAreaCurveTension>1) ? 1 : 0
}

togglePathCurveTension() {
   If (EllipseSelectMode!=2 || editingSelectionNow!=1)
   {
      showTOOLtip("WARNING: Please activate or create a freeform path.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   FillAreaCurveTension := clampInRange(FillAreaCurveTension + 1, 1, 5, 1)
   decideCustomShapeStyle()
   If (FillAreaCurveTension=1)
     ll := "Polygonal"
   Else If (FillAreaCurveTension=5)
     ll := "Bézier"
   Else
     ll := "Tension: " tensionCurveCustomShape

   showTOOLtip("Path: " ll)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   RegAction(1, "FillAreaCurveTension")
   If (drawingShapeNow=1)
   {
      performBezierActivePathAutoFixNow()
      showQuickActionButtonsDrawingShape()
   }

   SetTimer, dummyRefreshImgSelectionWindow, -150
}

BtnTabsInfoUpdate(modus:=0,b:=0) {
   If (panelWinCollapsed=1 && modus!="ignore-panel")
   {
      ; CurrentPanelTab := TabsPerWindow[AnyWindowOpen]
      ; GuiControl, SettingsGUIA: Choose, CurrentPanelTab, % CurrentPanelTab
      toggleImgEditPanelWindow()
      Return
   }

   GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
   labelu := TabCtrl_GetItemText(hCurrTab, CurrentPanelTab)
   If (InStr(labelu, "alpha") && isNowAlphaPainting()=1)
   {
      CurrentPanelTab++
      GuiControl, SettingsGUIA: Choose, CurrentPanelTab, % CurrentPanelTab
   }

   TabsPerWindow[AnyWindowOpen] := CurrentPanelTab
   mouseTurnOFFtooltip()
   UItriggerBrushUpdate("noPreview")
}

UIcycleFillShapes() {
   FillAreaShape := clampInRange(FillAreaShape + 1, 1, 7, 1)
   GuiControl, SettingsGUIA: Choose, FillAreaShape, % FillAreaShape
   If (AnyWindowOpen=65)
      updateUIdrawShapesPanel()
   Else If (AnyWindowOpen=23)
      updateUIfillPanel()
   Else If (AnyWindowOpen=68)
      updateUIfillBehindPanel()
}

BtnResetBlendMode() {
   If (AnyWindowOpen=23)
   {
      FillAreaBlendMode := 1
      GuiControl, SettingsGUIA: Choose, FillAreaBlendMode, % FillAreaBlendMode
      updateUIfillPanel()
   } Else If (AnyWindowOpen=81)
   {
      UserSymmetricaBlendMode := 1
      GuiControl, SettingsGUIA: Choose, UserSymmetricaBlendMode, % UserSymmetricaBlendMode
      updateUIsymmetricaPanel()
   } Else If (AnyWindowOpen=65 || AnyWindowOpen=30)
   {
      DrawLineAreaBlendMode := 1
      GuiControl, SettingsGUIA: Choose, DrawLineAreaBlendMode, % DrawLineAreaBlendMode
      If (AnyWindowOpen=30)
         updateUIDrawLinesPanel()
      Else
         updateUIdrawShapesPanel()
   } Else
   {
      BlurAreaBlendMode := 1
      GuiControl, SettingsGUIA: Choose, BlurAreaBlendMode, % BlurAreaBlendMode
      If (AnyWindowOpen=69)
         updateUIzoomBlurPanel()
      Else If (AnyWindowOpen=44)
         updateUIaddNoisePanel()
      Else
         updateUIblurPanel()
   }
}

BtnResetTextBlendMode() {
   TextInAreaBlendMode := 1
   GuiControl, SettingsGUIA: Choose, TextInAreaBlendMode, % TextInAreaBlendMode
   updateUIInsertTextPanel()
}

BtnResetEdgesBlendMode() {
   IDedgesBlendMode := 1
   GuiControl, SettingsGUIA: Choose, IDedgesBlendMode, % IDedgesBlendMode
   If (AnyWindowOpen=44)
      updateUIaddNoisePanel()
   Else
      updateUIedgesPanel()
}

BtnResetGlassFX() {
   FillAreaGlassy := 1
   GuiControl, SettingsGUIA: Choose, FillAreaGlassy, % FillAreaGlassy
   updateUIfillPanel()
}

WriteSettingsEditorResizePanel() {
   ReadSettingsEditorResizePanel(1)
}

ReadSettingsEditorResizePanel(actu:=0) {
    RegAction(actu, "ResizeKeepAratio",, 1)
    RegAction(actu, "ResizeInPercentage",, 1)
    RegAction(actu, "ResizeQualityHigh",, 1)
    RegAction(actu, "ResizeEnforceCanvas",, 1)
    RegAction(actu, "ResizeFillCanvasMode",, 2, 1, 4)
    RegAction(actu, "adjustCanvasCentered",, 1)
    RegAction(actu, "OutlierFillColor",, 3)
    RegAction(actu, "OutlierFillOpacity",, 2, 1, 255)
}

PanelEditorImgResize() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight

    If (thumbsDisplaying=1 || AnyWindowOpen)
       Return

    r1 := trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (!oImgH || !oImgH)
    {
       showTOOLtip("ERROR: No image seems to be loaded or it is malformed")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    ReadSettingsEditorResizePanel()
    thisBtnHeight := createSettingsGUI(73, A_ThisFunc)
    btnWid := 90
    txtWid := 265
    editWid := 55
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 37
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    Global InfoResized
    friendly := (isImgEditingNow() && editingSelectionNow=1) ? "|Selection area||" : "||"
    Gui, Add, Text, x15 y15 Section, Original image size: %oImgW% x %oImgH% pixels.
    Gui, Add, Text, xs y+10, Set new dimensions (W x H):
    GuiAddDropDownList("xs+15 y+7 wp gupdateUIresizeImgEditPanel AltSubmit vPredefinedDocsSizes", "Viewport size|Screen size|Current image size|640x480|800x600|1024x768|HD 480p|HD 720p|HD 1080p|HD 2160p [4K]|A4 @ 300 dpi|A4 @ 150 dpi|Custom dimensions" friendly, "Dimensions preset")
    GuiAddEdit("xp y+5 w" editWid " r1 limit5 -multi number -wrap gupdateUIresizeImgEditPanel vuserEditWidth", (ResizeInPercentage=1) ? 100 : oImgW, "Width")
    GuiAddEdit("x+5 wp r1 limit5 -multi number -wrap gupdateUIresizeImgEditPanel vuserEditHeight", (ResizeInPercentage=1) ? 100 : oImgH, "Height")
    Gui, Add, Checkbox, x+5 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, Use `% percentages
    Gui, Add, Checkbox, xs+15 y+5 hp gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp Checked%adjustCanvasCentered% vadjustCanvasCentered, Centered image
    If (viewportQPVimage.imgHandle)
       ResizeEnforceCanvas := 0
    clrW := (PrefsLargeFonts=1) ? 65 : 45
    Gui, Add, Text, xs y+15 vInfoResized, Resulted dimensions for the resized image: TO DECIDE! `n and canvas
    Gui, Add, Checkbox, xs y+10 hp Checked%ResizeEnforceCanvas% vResizeEnforceCanvas gupdateUIresizeImgEditPanel, Set the given dimensions as canvas size
    sml := (PrefsLargeFonts=1) ? 90 : 60
    ha := (PrefsLargeFonts=1) ? 28 : 19
    GuiAddDropDownList("xs+15 y+7 wp-" sml " AltSubmit Choose" ResizeFillCanvasMode " vResizeFillCanvasMode gupdateUIresizeImgEditPanel", "Transparent background|Extend image borders|Solid color|Blurred image", "Canvas fill mode")
    GuiAddPickerColor("xp y+10 w25 hp", "OutlierFillColor")
    GuiAddColor("x+2 hp w" clrW " hp", "OutlierFillColor", "Background color")
    GuiAddSlider("OutlierFillOpacity", 3,255, 255, "Opacity", "iniSaveOutlierClrOpaciy", 1, "x+5 w" clrW*2 + 10 " hp")

    Gui, Add, Checkbox, xs y+15 hp Checked%ResizeQualityHigh% vResizeQualityHigh gupdateUIresizeImgEditPanel, &High quality image resampling
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% gBTNimgResizeEditor Default, &Resize image
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize image: " appTitle)
    updateUIresizeImgEditPanel()
}

BTNimgResizeEditor() {
    obju := updateUIresizeImgEditPanel("gimme")
    tUserNewWidth := Round(obju[1, 3])
    tUserNewHeight := Round(obju[1, 4])
    imgW := Round(obju[1, 1])
    imgH := Round(obju[1, 2])
    cmpx := Round((tUserNewWidth * tUserNewHeight)/1000000, 1)
    impx := Round((imgW * imgH)/1000000, 1)
    If (max(cmpx, impx)>536.7 && !viewportQPVimage.imgHandle)
    {
       msgResult := msgBoxWrapper(appTitle ": WARNING", "You are trying to resize the currently opened image to a very large resolution: " Round(max(cmpx, impx)) " megapixels. Just a few image editing tools will still be available with such images: resize, crop, flip, rotate by 90, etc. Additionally, no undo levels will be recorded and the current undo levels will be discarded if you choose to continue. Some of the options in this panel will be ignored upon resize.`n`nPlease choose how to proceed.", "&Continue|C&ancel", 1, "exclamation")
       If InStr(msgResult, "Continue")
       {
          BtnCloseWindow()
          convertImageIntoHugeImage(max(imgW, tUserNewWidth), max(imgH, tUserNewHeight), ResizeQualityHigh)
          Return
       }
       ; showTOOLtip("WARNING: Resulted image cannot exceed 536.7 megapixels.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    mergeViewPortRotationImgEditing()
    whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
    trGdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    If (oImgW=tUserNewWidth && oImgH=tUserNewHeight)
    {
       showTOOLtip("WARNING: The provided values are identical with the original size")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If ((min(imgW, imgH, tUserNewWidth, tUserNewHeight)<3
    || max(imgW, imgH, tUserNewWidth, tUserNewHeight)>199000) && !viewportQPVimage.imgHandle)
    {
       showTOOLtip("WARNING: Incorrect values provided to resize image.`nValues must be between 3 and 199000 pixels.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    WriteSettingsEditorResizePanel()
    BtnCloseWindow()
    If (viewportQPVimage.imgHandle)
    {
       HugeImagesCropResizeRotate(imgW, imgH, "resize", 0, 0, 0, 0, ResizeQualityHigh)
       Return
    }

    showTOOLtip("Resizing image to:`n" groupDigits(tUserNewWidth) " x " groupDigits(tUserNewHeight) " (" Round(cmpx, 1) " MPx)")
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, tUserNewWidth, tUserNewHeight, coreDesiredPixFmt)
    If warnUserFatalBitmapError(newBitmap, A_ThisFunc)
    {
       showTOOLtip("Failed to resize image")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return
    }

    thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, thisImgQuality)
    If !G2
    {
       showTOOLtip("Failed to create the graphics object to resize image")
       trGdip_DisposeImage(newBitmap)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return
    }

    setImageLoading()
    Gdip_SetPixelOffsetMode(G2, 2)
    dpX := (adjustCanvasCentered=1) ? Round(tUserNewWidth/2 - imgW/2) : 0
    dpY := (adjustCanvasCentered=1) ? Round(tUserNewHeight/2 - imgH/2) : 0
    isOkay := (imgW<tUserNewWidth || imgH<tUserNewHeight) ? 1 : 0
    currIMGdetails.HasAlpha := 1
    ; TulTip(0, "-", ResizeKeepAratio, ResizeEnforceCanvas, ResizeFillCanvasMode, isOkay)
    If (ResizeKeepAratio=1 && ResizeEnforceCanvas=1 && ResizeFillCanvasMode=3 && isOkay=1)
    {
       Gdip_SetClipRect(G2, dpX, dpY, imgW, imgH, 4)
       thisColor := makeRGBAcolor(OutlierFillColor, OutlierFillOpacity)
       trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       Gdip_ResetClip(G2)
    } Else If (ResizeKeepAratio=1 && ResizeEnforceCanvas=1 && ResizeFillCanvasMode=4 && isOkay=1)
    {
       Gdip_SetClipRect(G2, dpX, dpY, imgW, imgH, 4)
       zBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, oImgW//2 + 1, oImgH//2, 0, 5)
       zA := Gdip_CreateEffect(1, 250, 0, 0)
       Gdip_BitmapApplyEffect(zBitmap, zA)
       r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0, tUserNewWidth, tUserNewHeight)
       Gdip_DisposeEffect(zA)
       trGdip_DisposeImage(zBitmap, 1)
       Gdip_ResetClip(G2)
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, dpX, dpY, imgW, imgH)
    If (ResizeKeepAratio=1 && ResizeEnforceCanvas=1 && ResizeFillCanvasMode=2 && isOkay=1)
    {
       ; Gdip_SetClipRect(G2, dpX + 1, dpY + 1, imgW - 2, imgH - 2, 4)
       If (adjustCanvasCentered!=1)
       {
          dpX := (imgW<tUserNewWidth) ? ImgW - 3 : imgW
          dpY := (imgH<tUserNewHeight) ? ImgH - 3 : imgH
       }

       If (imgW<tUserNewWidth)
       {
          If (adjustCanvasCentered=1)
          {
             astripA := trGdip_CloneBitmapArea(A_ThisFunc, whichBitmap, 0, 0, 1, oImgH)
             stripA := QPV_ResizeBitmap(astripA, dpX + 3, imgH, 2)
             tzGdip_DrawImageFast(G2, stripA, 0, 0)
          }

          lW := (adjustCanvasCentered=1) ? dpX + 1 : tUserNewWidth - imgW + 1
          lX := (adjustCanvasCentered=1) ? dpX + imgW - 1 : dpX - 1
          astripB := trGdip_CloneBitmapArea(A_ThisFunc, whichBitmap, oImgW - 1, 0, 1, oImgH)
          stripB := QPV_ResizeBitmap(astripB, lW, imgH, 2)
          tzGdip_DrawImageFast(G2, stripB, lX, 0)
          ; ToolTip, % imgW "|" tUserNewWidth "|" lX "|" offX , , , 2
       }

       If (imgH<tUserNewHeight)
       {
          If (adjustCanvasCentered=1)
          {
             astripA := trGdip_CloneBitmapArea(A_ThisFunc, whichBitmap, 0, 0, oImgW, 1)
             stripA := QPV_ResizeBitmap(astripA, imgW, dpY + 3, 2)
             tzGdip_DrawImageFast(G2, stripA, 0, 0)
          }

          lY := (adjustCanvasCentered=1) ? dpY + imgH - 1 : dpY - 1
          lH := (adjustCanvasCentered=1) ? dpY + imgH : tUserNewHeight - imgH + 1
          astripB := trGdip_CloneBitmapArea(A_ThisFunc, whichBitmap, 0, oImgH - 1, oImgW, 1)
          stripB := QPV_ResizeBitmap(astripB, imgW, lH, 2)
          tzGdip_DrawImageFast(G2, stripB, 0, lY)
       }
       ; TulTip(0, " | ", stripA, stripB, dpX, dpY, modus, oImgW, oImgH)
       trGdip_DisposeImage(stripA, 1)
       trGdip_DisposeImage(stripB, 1)
       trGdip_DisposeImage(astripA, 1)
       trGdip_DisposeImage(astripB, 1)
       Gdip_ResetClip(G2)
    }

    Gdip_DeleteGraphics(G2)
    wrapRecordUndoLevelNow(newBitmap)
    SoundBeep 900, 100
    updateUIctrl()
    MouseMoveResponder()
    usrColorDepth := 1
    vpIMGrotation := 0
    dropFilesSelection(1)
    RemoveTooltip()
    dummyTimerDelayiedImageDisplay(50)
    SetTimer, createGUItoolbar, -100
    SetTimer, TriggerMenuBarUpdate, -90
    SetTimer, ResetImgLoadStatus, -50
}

updateUIresizeImgEditPanel(dummy:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=73) || (A_TickCount - lastInvoked<50)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    GuiControlGet, userEditWidth
    GuiControlGet, userEditHeight

    actu2 := (ResizeFillCanvasMode=3 && ResizeEnforceCanvas=1 && ResizeKeepAratio=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, PickuOutlierFillColor
    actu2 := (ResizeFillCanvasMode=3 && ResizeEnforceCanvas=1 && ResizeKeepAratio=1) ? 1 : 0
    uiSlidersArray["OutlierFillOpacity", 10] := actu2

    actu2 := (ResizeFillCanvasMode=3 && ResizeEnforceCanvas=1 && ResizeKeepAratio=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu2, OutlierFillColor

    actu1 := (ResizeKeepAratio=1 && !viewportQPVimage.imgHandle) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu1, ResizeEnforceCanvas

    actu1 := (ResizeEnforceCanvas=1 && ResizeKeepAratio=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu1, ResizeFillCanvasMode
    GuiControl, % actu1, adjustCanvasCentered

    actu := (PredefinedDocsSizes=13) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    If (PredefinedDocsSizes!=13)
    {
       ResizeInPercentage := 0
       GetPresetDocSizes(PredefinedDocsSizes, userEditWidth, userEditHeight, nulli)
       GuiControl, SettingsGUIA:, userEditWidth, % userEditWidth
       GuiControl, SettingsGUIA:, userEditHeight, % userEditHeight
       GuiControl, SettingsGUIA:, ResizeInPercentage, 0
    }
    GuiControl, % actu, userEditWidth
    GuiControl, % actu, userEditHeight
    GuiControl, % actu, ResizeInPercentage

    trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    obju := calcIMGuserResizer(oImgW, oImgH, userEditWidth, userEditHeight, ResizeInPercentage, ResizeKeepAratio)
    thisWidth := obju[1, 1], thisHeight := obju[1, 2]
    canvasWidth := obju[1, 3], canvasHeight := obju[1, 4]
    doFriendly := 0
    If (ResizeEnforceCanvas=1 && ResizeKeepAratio=1)
    {
       doFriendly := 1
    } Else
    {
       canvasWidth := thisWidth
       canvasHeight := thisHeight
    }

    ; pk := capIMGdimensionsGDIPlimits(canvasWidth, canvasHeight)
    ; If pk
    ; {
    ;    thisWidth := Floor(thisWidth * pk)
    ;    thisHeight := Floor(thisHeight * pk)
    ; }

    mpx := Round((canvasWidth * canvasHeight)/1000000, 1)
    If (mpx>536.7 && !viewportQPVimage.imgHandle)
       mpx := "! " mpx

    If (doFriendly=1)
       friendly := "`nCanvas size: " groupDigits(Round(canvasWidth)) " x " groupDigits(Round(canvasHeight)) " px (" mpx " MPx)"

    lastInvoked := A_TickCount
    mpx := Round((thisWidth * thisHeight)/1000000, 1)
    If (mpx>536.7 && !viewportQPVimage.imgHandle)
       mpx := "! " mpx

    GuiControl, SettingsGUIA:, infoResized, % "Image size: " groupDigits(Round(thisWidth)) " x " groupDigits(Round(thisHeight)) " px (" mpx " MPx)" friendly
    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := OutlierFillOpacity
    If (dummy="gimme")
    {
       obju := []
       obju[1] := [thisWidth, thisHeight, canvasWidth, canvasHeight]
       Return obju
    } Else GuiRefreshSliders()
 
    SetTimer, WriteSettingsImageProcessing, -250
}

calcIMGuserResizer(oImgW, oImgH, givenW, givenH, isPercent, keepRatio) {
    thisWidth := (isPercent=1) ? (oImgW/100)*givenW : givenW
    thisHeight := (isPercent=1) ? (oImgH/100)*givenH : givenH
    canvasWidth := (isPercent=1) ? (oImgW/100)*givenW : givenW
    canvasHeight := (isPercent=1) ? (oImgH/100)*givenH : givenH
    ; ToolTip, % scaleu "|" thisWidth "|" thisHeight , , , 2
    If (keepRatio=1 && isPercent=1)
    {
       ; avgWH := (givenW + givenH)/2
       ; calcIMGdimensions(oImgW, oImgH, (thisWidth/100)*avgWH, (thisHeight/100)*avgWH, thisWidth, thisHeight)
       calcIMGdimensions(oImgW, oImgH, thisWidth, thisHeight, thisWidth, thisHeight)
    } Else If (keepRatio=1)
    {
       If (keepRatio=1)
       {
          omgpx := oImgW * oImgH
          mgpx := givenW * givenH
          scaleu := mgpx/omgpx
       } Else scaleu := 1

       calcIMGdimensions(oImgW, oImgH, thisWidth, thisHeight, thisWidth, thisHeight)
       If (oImgW=thisWidth && oimgH=thisHeight)
       {
          thisWidth *= scaleu
          thisHeight *= scaleu
          canvasWidth *= scaleu
          canvasHeight *= scaleu
       }
    }
    obju := []
    obju[1] := [thisWidth, thisHeight, canvasWidth, canvasHeight]
    Return obju
}

PanelManageVectorShapes() {
    Static LViewDynas
    If (imgEditPanelOpened=1 && AnyWindowOpen && thumbsDisplaying=0)
       postVectorWinOpen := AnyWindowOpen

    zz := postVectorWinOpen
    thisBtnHeight := createSettingsGUI(72, A_ThisFunc)
    postVectorWinOpen := zz
    btnWid := 120
    txtWid := 360
    lstWid := 535
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 175
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 Section, Freeform vector shapes already saved
    hLVmainu := GuiAddListView("xs y+10 w" lstWid " +LV0x10000 +LV0x400 r" uLVr " Grid gBTNlvCustomShapes -multi AltSubmit vLViewDynas", "Name|Date|#", "Saved vector shapes")

    btnWid2 := (PrefsLargeFonts=1) ? 95 : 60
    Gui, Add, Button, xs+0 y+15 h%thisBtnHeight% w%btnWid2% Default gBTNloadCustomShape, &Load
    If !postVectorWinOpen
    {
       If (EllipseSelectMode=2)
          Gui, Add, Button, x+5 hp wp gBtnSaveVectorShape, &Save
       Gui, Add, Button, x+5 hp wp+10 gBTNrenameCustomShape, &Rename
       Gui, Add, Button, x+5 hp wp+15 gBTNopenCustomShapesFolder +hwndhTemp, &Open folder
       ToolTip2ctrl(hTemp, "Open the folder containing the saved vector shapes")
       Gui, Add, Button, x+5 hp wp-25 gBTNdeleteCustomShape, &Delete
       Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    } Else  Gui, Add, Button, x+5 hp wp gBTNopenPrevPanel, &Back

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Manage vector shapes: " appTitle)
    Sleep, 25
    PopulateCustomVectorShapesList()
}

BTNopenCustomShapesFolder() {
   Try Run, % mainCompiledPath "\resources\vector-shapes\"
}

BTNlvCustomShapes(a, b, c) {
   If (b="DoubleClick")
      BTNloadCustomShape()
}

BTNdeleteCustomShape() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   ; RowNumber := LV_GetNext(0, "F")
   RowNumber := LV_GetFirstSelected(hLVmainu)
   LV_GetText(givenName, RowNumber, 1)
   LV_GetText(datu, RowNumber, 2)
   If (datu="-" || !RowNumber)
      Return

   If (StrLen(givenName)<2 || !FileExist(mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"))
      Return

   msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected to DELETE the vector shape named: " givenName ". Please confirm with Yes you want to remove it.", 4, 0, "exclamation")
   If (msgResult="Yes")
   {
      FileRecycle, % mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"
      BtnCloseWindow()
      showTOOLtip("Vector shape file moved to recycle bin:`n " givenName ".vqpv")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, PanelManageVectorShapes, -250
   }
}

BTNrenameCustomShape() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetFirstSelected(hLVmainu)
   ; RowNumber := LV_GetNext(0, "F")
   LV_GetText(givenName, RowNumber, 1)
   LV_GetText(datu, RowNumber, 2)
   ; ToolTip, % givenName "|" datu "|" RowNumber , , , 2
   If (datu="-" || !RowNumber || RowNumber<1)
      Return

   If (StrLen(givenName)<2 || !FileExist(mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"))
   {
      showTOOLtip("ERROR: The file no longer seems to exist: " givenName ".vqpv`n" mainCompiledPath "\resources\vector-shapes\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
   oldName := givenName
   Static forbiddenChars := "<`~@>:""/\|?*.,;"
   widthu := (PrefsLargeFonts=1) ? 950 : 460
   msgResult := msgBoxWrapper("Rename vector shape: " appTitle, "Please type the new name for: " givenName ".", "&Rename|&Cancel", 1, "modify-file", 0, 0, 0, "limit350", prevNameSavedVectorShape, 0, widthu)
   If InStr(msgResult.btn, "rename")
   {
      BtnCloseWindow()
      givenName := msgResult.edit
      Loop, Parse, forbiddenChars
          givenName := StrReplace(givenName, A_LoopField)

      givenName := filterFileName(givenName)
      If StrLen(givenName)>1
      {
         If FileExist(mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv")
         {
            showTOOLtip("ERROR: Another vector shape exists with the provided name: " givenName "`nOperation abandoned.")
            SoundBeep 300, 100
         } Else
         {
            FileMove, % mainCompiledPath "\resources\vector-shapes\" oldName ".vqpv", % mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"
         }
      } Else
      {
         showTOOLtip("WARNING: Incorrect name provided for the rename")
         SoundBeep 300, 100
      }
      SetTimer, PanelManageVectorShapes, -250
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

saveVectorShapeInRegistry() {
    FillAreaCustomShape := convertShapePointsArrayToStr(customShapePoints, 65305)
    RegAction(1, "FillAreaCustomShape")
    RegAction(1, "FillAreaCurveTension")
    RegAction(1, "closedLineCustomShape")
}

BTNloadCustomShape(isGiven:=0, whichFile:=0) {
   externMode := (isGiven="yes" && FileExist(whichFile) && whichFile) ? 1 : 0
   If (externMode!=1)
   {
      Gui, SettingsGUIA: Default
      Gui, SettingsGUIA: ListView, LViewDynas
      RowNumber := LV_GetFirstSelected(hLVmainu)
      If !RowNumber
         Return

      LV_GetText(givenName, RowNumber, 1)
      LV_GetText(datu, RowNumber, 2)
      LV_GetText(whichShape, RowNumber, 3)
      If !givenName
         Return
      mustOpenWin := postVectorWinOpen
   }

   If (datu="-" && externMode!=1)
   {
      BtnCloseWindow()
      If (editingSelectionNow!=1)
         ToggleEditImgSelection()

      If (whichShape="d8")
      {
         ; torus
         EllipseSelectMode := 1
         VPselRotation := 0
         innerSelectionCavityX := innerSelectionCavityY := 0.45
         prevNameSavedVectorShape := ""
         saveVectorShapeInRegistry()
         dummyTimerDelayiedImageDisplay(100)
         BTNopenPrevPanel(mustOpenWin, "yes")
         Return
      }

      VPcreateSelPath("kill", 0, 0, 0, 0, 0, 0, 0, 0)
      EllipseSelectMode := 2
      bezierSplineCustomShape := 0
      closedLineCustomShape := 1
      vpFreeformShapeOffset := []
      prevVectorShapeSymmetryMode := []
      customShapePoints := []
      VPselRotation := innerSelectionCavityX := innerSelectionCavityY := 0
      customShapePropPoints := []
      prevNameSavedVectorShape := ""
      predefinedVectorShapes(SubStr(whichShape, 2))
      Loop, % customShapePoints.Count()
           customShapePropPoints[A_Index] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]

      saveVectorShapeInRegistry()
      dummyTimerDelayiedImageDisplay(100)
      BTNopenPrevPanel(mustOpenWin, "yes")
      undoVectorShapesLevelsArray := []
      currentVectorUndoLevel := 1
      customShapeHasSelectedPoints := 0
      Return
   }

   If (externMode!=1)
   {
      OutDir := PathCompact(mainCompiledPath "\resources\vector-shapes", "a", 1, OSDfontSize)
      If (StrLen(givenName)<2 || !FileExist(mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"))
      {
         showTOOLtip("ERROR: The file no longer seems to exist: " givenName ".vqpv`n" OutDir)
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
      BtnCloseWindow()
   }

   If (externMode=1)
      FileRead, contentu, % whichFile
   Else
      FileRead, contentu, % mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"

   If StrLen(contentu)<5
   {
      If (externMode=1)
      {
         OutDir := PathCompact(whichFile, "a", 1, OSDfontSize)
         showTOOLtip("Failed to read file contents:`n" OutDir)
      } Else
      {
         showTOOLtip("Failed to read file contents: " givenName ".vqpv`n" OutDir)
         BTNopenPrevPanel(mustOpenWin, "yes")
      }
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   undoVectorShapesLevelsArray := []
   currentVectorUndoLevel := 1
   customShapeHasSelectedPoints := 0
   VPcreateSelPath("kill", 0, 0, 0, 0, 0, 0, 0, 0)
   obju := StrSplit(contentu, "`n", "`r `t")
   newArrayu := convertShapePointsStrToArray(obju[1])
   If (newArrayu.Count()<3)
   {
      showTOOLtip("ERROR: Incorrect file format. Found no points defining the vector shape.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (externMode!=1)
         BTNopenPrevPanel(mustOpenWin, "yes")
      Return
   }

   customShapeHasSelectedPoints := 0
   If (editingSelectionNow!=1)
      ToggleEditImgSelection()

   customShapePropPoints := []
   Loop, % newArrayu.Count()
        customShapePropPoints[A_Index] := [prevDestPosX, prevDestPosY, 0, prevResizedVPimgW, prevResizedVPimgH]

   EllipseSelectMode := 2
   vpFreeformShapeOffset := []
   prevVectorShapeSymmetryMode := []
   customShapePoints := []
   customShapePoints := newArrayu.Clone()
   VPselRotation := clampInRange(obju[2], 0, 360)
   FillAreaCurveTension := clampInRange(obju[3], 1, 5)
   innerSelectionCavityX := clampInRange(obju[4], 0, 0.49)
   innerSelectionCavityY := clampInRange(obju[5], 0, 0.49)
   closedLineCustomShape := Trim(obju[6])
   RegAction(1, "closedLineCustomShape")
   prevVectorShapeSymmetryMode[1] := [obju[7], obju[8]]
   prevNameSavedVectorShape := givenName
   decideCustomShapeStyle()
   saveVectorShapeInRegistry()
   dummyTimerDelayiedImageDisplay(100)
   If (externMode!=1)
      BTNopenPrevPanel(mustOpenWin, "yes")
}

PopulateCustomVectorShapesList() {
    Static defaultShapes := {1:"right triangle", 2:"triangle", 3:"rhombus", 4:"box callout", 5:"star-5", 6:"star-4", 7:"christian cross", 8:"torus", 9:"Last temporarily saved"}

    thisIndex := 0
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    Loop, % mainCompiledPath "\resources\vector-shapes\*.vqpv"
    {
        thisIndex++
        Try FormatTime, datu, % A_LoopFileTimeModified, dd/MM/yyyy, HH:mm
        LV_Add(A_Index, StrReplace(A_LoopFileName, ".vqpv"), datu, A_Index)
    }

    thisIndex := 0
    For Key, Value in defaultShapes
    {
       thisIndex++
       StringUpper, value, value, T
       LV_Add(thisIndex, value, "-", "D" thisIndex)
    }

    Loop, 3
        LV_ModifyCol(A_Index, "AutoHdr Left")
}

BtnSaveVectorShape() {
   Static forbiddenChars := "<`~@>:""/\|?*.,;"
   If (EllipseSelectMode!=2)
      Return

   If (AnyWindowOpen=72)
   {
      Gui, SettingsGUIA: Default
      Gui, SettingsGUIA: ListView, LViewDynas
      RowNumber := LV_GetNext(0, "F")
      LV_GetText(prevNameSavedVectorShape, RowNumber, 1)
   }

   widthu := (PrefsLargeFonts=1) ? 950 : 460
   msgResult := msgBoxWrapper("Save vector shape: " appTitle, "Please type a name for the vector shape to be saved.", "&Save|&Cancel", 1, "save", 0, 0, 0, "limit350", prevNameSavedVectorShape, 0, widthu)
   If InStr(msgResult.btn, "save")
   {
      givenName := msgResult.edit
      Loop, Parse, forbiddenChars
          givenName := StrReplace(givenName, A_LoopField)

      givenName := filterFileName(givenName)
      If StrLen(givenName)>1
      {
         r := saveCurrentVectorShape(givenName)
         If (AnyWindowOpen=72 && !r)
         {
            BtnCloseWindow()
            SetTimer, PanelManageVectorShapes, -250
         }
      } Else
      {
         showTOOLtip("WARNING: Incorrect name provided for the vector shape")
         SoundBeep 300, 100
         SetTimer, BtnSaveVectorShape, -250
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }
}

saveCurrentVectorShape(givenName, allowMsg:=1) {
   If (EllipseSelectMode!=2)
      Return

   If !FolderExist(mainCompiledPath "\resources\vector-shapes")
   {
      FileCreateDir, %mainCompiledPath%\resources\vector-shapes
      If ErrorLevel
         errorOccured := 1

      Sleep, 1
   }

   thisFile := mainCompiledPath "\resources\vector-shapes\" givenName ".vqpv"
   If (FileExist(thisFile) && allowMsg=1)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "A vector shape was already defined with the provided name: " givenName ". Do you want to overwrite it? This action is irreversible.", "&Overwrite|&Cancel", 2, "exclamation")
      If (msgResult!="overwrite")
         Return
   }

   contentu := convertShapePointsArrayToStr(customShapePoints) "`n"
   contentu .= VPselRotation "`n" FillAreaCurveTension "`n" innerSelectionCavityX "`n" innerSelectionCavityY "`n" closedLineCustomShape "`n" Round(prevVectorShapeSymmetryMode[1, 1]) "`n" Round(prevVectorShapeSymmetryMode[1, 2]) "`n"
   FileDelete, % thisFile
   FileAppend, % contentu, % thisFile , UTF-8
   If ErrorLevel
      errorOccured := 1

   If (allowMsg=1)
   {
      If (errorOccured=1)
      {
         showTOOLtip("Failed to save vector shape into:`n" mainCompiledPath "\")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      } Else prevNameSavedVectorShape := givenName
   }

   Return errorOccured
}

updateLabelPasteImgOpacity() {
   Return "Image opacity: " Round(PasteInPlaceOpacity / 255 * 100) "%"
}

updateLabelEllipseSect() {
   Static minV := -270
   perc := (FillAreaEllipseSection - minV) / 1120
   If (FillAreaEllipseSection>=847)
      f := "100%"
   Else If (FillAreaEllipsePie=1)
      f := clampInRange(Round((1 - perc)*100), 1, 99) "%"
   Else
      f := Round(perc*100) "%"
   Return "Circumference: " f
}

updateFillInnerCavity() {
   ; GuiControlGet, userUIshapeCavity
   If (userUIshapeCavity<2)
      innerSelectionCavityX := innerSelectionCavityY := 0
   Else
      innerSelectionCavityX := innerSelectionCavityY := clampInRange(userUIshapeCavity/400, 0, 0.99)

   If (AnyWindowOpen=23)
      updateUIfillPanel()
   Else If (AnyWindowOpen=24 || AnyWindowOpen=31)
      updateUIpastePanel()
   Else If (AnyWindowOpen=65)
      updateUIdrawShapesPanel()
   Else If (AnyWindowOpen=68)
      updateUIfillBehindPanel()
   Else If (AnyWindowOpen=34)
      dummyRefreshImgSelectionWindow()
}

GuiAddGeneralColorAdjustCtrls(slideWid, funcu) {
    ha := (PrefsLargeFonts=1) ? 27 : 18
    sml := (PrefsLargeFonts=1) ? 30 : 20
    GuiAddSlider("PasteInPlaceHue", -180,180, 0, "Hue: $€°", funcu, 2, "xs y+15 w" slideWid " h" ha)
    If (viewportQPVimage.imgHandle)
       GuiAddCheckbox("x+1 hp+1 w" sml " g" funcu " Checked" userImgAdjustInvertColors " vuserImgAdjustInvertColors", "Invert colors", "I")
    GuiAddSlider("PasteInPlaceSaturation", -100,100, 0, "Saturation", funcu, 2, "xs y+10 w" slideWid " hp")
    If (viewportQPVimage.imgHandle)
       GuiAddCheckbox("x+1 hp+1 w" sml " g" funcu " Checked" userImgAdjustAltSat " vuserImgAdjustAltSat", "Alternate saturation adjustment mode", "A")
    GuiAddSlider("PasteInPlaceLight", -255,255, 0, "Brightness", funcu, 2, "xs y+10 w" slideWid " hp")
    If (viewportQPVimage.imgHandle)
       GuiAddCheckbox("x+1 hp+1 w" sml " g" funcu " Checked" userImgAdjustAltBright " vuserImgAdjustAltBright", "Alternate brightness adjustment mode", "A")
    GuiAddSlider("PasteInPlaceGamma", -100,100, 0, "Contrast", funcu, 2, "xs y+10 w" slideWid " hp")
}

PanelFillSelectedArea(dummy:=0, which:=0) {
    openingPanelNow := 1
    If !(thisBtnHeight := createSettingsGUI(23, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsFillAreaPanel()
    ReadSettingsBrushPanel()
    ReadSettingsAlphaMaskPanel()
    If (EllipseSelectMode=1)
       FillAreaShape := 3
    Else If (EllipseSelectMode=0)
       FillAreaShape := 1
    Else If (EllipseSelectMode=2)
       FillAreaShape := 7

    If (dummy="tlbr" && isInRange(which, 1, 7))
       FillAreaShape := which

    customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60, EllipseSelectMode := 0
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 40
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    minislideWid := slideWid//2
    If isWinXP
    {
       FillAreaBlendMode := 1
       FillAreaGlassy := 1
    }

    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1

    If (viewportQPVimage.imgHandle)
    {
       FillAreaDoContour := 0
       FillAreaEllipseSection := 850
       FillAreaGlassy := alphaMaskingMode := 1
    } Else FillAreaDoBehind := 0

    Global PickuFillAreaColor, PickuFillArea2ndColor, txtLine4, uiPasteInPlaceAlphaDrawMode, infoFillAreaGradientView, UIbtnEditShape

    FillAreaClosedPath := FillAreaEllipsePie := 1
    userUIshapeCavity := Round((innerSelectionCavityX + innerSelectionCavityY) / 2 * 400)
    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "None"
    ha := (PrefsLargeFonts=1) ? 27 : 18
    bonusTabs := !(viewportQPVimage.imgHandle) ? "|Border|Alpha mask|Paint mask" : ""
    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Main|Fill|Adjust colors%bonusTabs%

    Gui, Tab, 1 ; main options
    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddDropDownList("x+10 y+10 Section w" slideWid " AltSubmit Choose" FillAreaShape " vFillAreaShape gupdateUIfillPanel", "Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape", "Shape to fill")
    GuiAddDropDownList("x+5 wp-" ml + 5 " AltSubmit Choose" FillAreaCurveTension " vFillAreaCurveTension gupdateUIfillPanel", "Polygonal|Smooth corners|Curve|Round curve|Bézier", "Vector path type")
    GuiAddSlider("FillAreaRectRoundness", 4,98, 10, "Roundness", "updateUIfillPanel", 1, "xp yp w" slideWid " hp")
    GuiAddSlider("FillAreaEllipseSection", -270,850, 850, ".updateLabelEllipseSect", "updateUIfillPanel", 3, "xp yp wp hp")
    GuiAddShapeEditBtn("xp+" slideWid - ml " yp hp w" ml)
    GuiAddSlider("userUIshapeCavity", 0,400, 0, "Shape cavity", "updateFillInnerCavity", 1, "xs y+5 w" slideWid " hp")
    GuiAddSlider("FillAreaBlurAmount", -255, 255, 0, "Object blur", "updateUIfillPanel", 2, "x+5 yp wp hp")
    zpl := slideWid + 5
    Gui, Add, Checkbox, xs y+7 Checked%freeHandSelectionMode% vfreeHandSelectionMode gupdateUIfillPanel, &Freehand draw mode
    Gui, Add, Checkbox, xs y+5 Checked%FillAreaRemBGR% vFillAreaRemBGR gupdateUIfillPanel, &Erase background behind the object
    If (viewportQPVimage.imgHandle)
    {
       Gui, Add, Checkbox, xs y+5 gupdateUIfillPanel Checked%FillAreaDoBehind% vFillAreaDoBehind, Fill &behind (semi-) transparent pixels
       Gui, Add, Checkbox, xs y+5 w1 h1 gupdateUIfillPanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas if outside
    } Else
    {
       Gui, Add, Checkbox, xs y+5 gupdateUIfillPanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas if outside
       Gui, Add, Checkbox, xs y+5 w1 h1 gupdateUIfillPanel Checked%FillAreaDoBehind% vFillAreaDoBehind, Fill &behind (semi-) transparent pixels
    }

    sml := slideWid  - 27
    Gui, Add, Checkbox, xs y+1 hp Checked%FillAreaInverted% vFillAreaInverted gupdateUIfillPanel, &Invert selection area
    Gui, Add, Text, xs y+10 hp +0x200 w%slideWid% +TabStop gBtnResetGlassFX vtxtLine1, Glass effect
    GuiAddDropDownList("x+1 w" slideWid - 27 " AltSubmit Choose" FillAreaGlassy " vFillAreaGlassy gupdateUIfillPanel", "Not activated|Weak|Mild|Moderate|Strong|Extreme", "Glass effect")
    GuiAddCheckbox("x+1 yp hp w26 gupdateUIfillPanel Checked" FillAreaCutGlass " vFillAreaCutGlass", "Protect alpha channel", "P",, "Preserve the alpha channel of the background`nimage unaltered by blend modes")
    Gui, Add, Text, xs y+7 w%sml% hp +TabStop gBtnResetBlendMode vtxtLine2, Blending mode
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIfillPanel")
    GuiAddDropDownList("x+1 w" slideWid " gupdateUIfillPanel AltSubmit Choose" FillAreaBlendMode " vFillAreaBlendMode", infoBlend "|" userBlendModesList, "Blending mode")

    Gui, Tab, 2 ; colors
    sml := (PrefsLargeFonts=1) ? 66 : 44
    wml := (PrefsLargeFonts=1) ? 112 : 75
    bonusDl := (viewportQPVimage.imgHandle) ? "" : "|Random patterns|Texture"
    GuiAddDropDownList("x+10 y+10 Section w" slideWid " AltSubmit Choose" FillAreaColorMode " vFillAreaColorMode gupdateUIfillPanel", "Solid color|Linear gradient|Radial gradient|Box gradient" bonusDl, "Shape fill mode")
    kplo := (PrefsLargeFonts=1) ? 0 : 40
    Gui, Add, Button, x+5 vbtnFldr5 wp-%kplo% hp -wrap gBtnSetTextureSource, &Reset gradient center
    GuiAddPickerColor("xs y+5 h" ha " w25", "FillAreaColor")
    GuiAddColor("x+5 hp w" sml, "FillAreaColor")
    GuiAddSlider("FillAreaOpacity", 3,255, 255, "Opacity", "updateUIfillPanel", 1, "x+5 w" wml " hp")
    kak := Round(ha*2.2), kuk := (PrefsLargeFonts=1) ? sml*2 - 13 : sml*2 - 7
    Gui, Add, Text, xp+%kuk% yp w%kak% h%kak% -Border +0xE gGradientsPreviewResponder vinfoFillAreaGradientView +hwndhGradientFillpreview, Gradient preview
    ToolTip2ctrl(hGradientFillpreview, "Click and drag to adjust the gradient offset.`nHold Alt while dragging to adjust its center.")

    kak := ha + 5
    GuiAddPickerColor("xs yp+" kak " h" ha " w25", "FillArea2ndColor")
    GuiAddColor("x+5 hp w" sml, "FillArea2ndColor")
    GuiAddSlider("FillArea2ndOpacity", 3,255, 255, "Opacity", "updateUIfillPanel", 1, "x+5 w" wml " hp")
    GuiAddSlider("FillAreaGradientAngle", -180,180, 0, "Angle: $€°", "updateUIfillPanel", 2, "xs y+15 w" slideWid " h" ha)
    GuiAddDropDownList("xp yp wp AltSubmit gupdateUIfillPanel Choose" FillAreaWelcomePattern " vFillAreaWelcomePattern", "Horizontal lines|Random squares|Random circles|Corner anchored circles|Vertical lines|Random circles|Maurer rose", "Pattern generator type")
    GuiAddSlider("FillAreaGradientScale", 1,300, 100, "Scale: $€%", "updateUIfillPanel", 1, "x+5 wp h" ha)
    GuiAddSlider("FillAreaGradientPosA", 0,200, 0, "Position A", "updateUIfillPanel", 3, "xs y+15 wp hp")
    GuiAddSlider("FillAreaGradientPosB", 0,200, 200, "Position B", "updateUIfillPanel", 3, "x+5 wp hp")
    GuiAddDropDownList("xs y+15 wp AltSubmit Choose" FillAreaGradientWrapped " vFillAreaGradientWrapped gupdateUIfillPanel", "Tiled gradient|Tiled - flip X|Tiled - flip Y|Tiled - flip X/Y|No gradient tiling", "Gradient tiling mode")
    Gui, Add, Checkbox, x+5 hp Checked%FillAreaColorReversed% vFillAreaColorReversed gupdateUIfillPanel, &Reverse colors
    Gui, Add, Checkbox, xs y+8 hp Checked%userimgGammaCorrect% vuserimgGammaCorrect gupdateUIfillPanel, &Gamma correction

    Gui, Tab, 3 ; apply fx
    Gui, Add, Checkbox, x+10 y+10 Section Checked%FillAreaApplyColorFX% vFillAreaApplyColorFX gupdateUIfillPanel, &Apply color adjustments
    GuiAddGeneralColorAdjustCtrls(txtWid, "updateUIfillPanel")
    If (viewportQPVimage.imgHandle)
       Gui, Add, Text, xs y+10 Section, These only apply with blending modes.
    Else
       Gui, Add, Text, xs y+10 Section, These only apply with blending modes and/or`nwhen texture fill mode is used.

    If !(viewportQPVimage.imgHandle)
    {
       Gui, Tab, 4 ; draw border
       tml := (PrefsLargeFonts=1) ? 60 : 45
       Gui, Add, Checkbox, x+10 y+10 Section Checked%FillAreaDoContour% vFillAreaDoContour gupdateUIfillPanel, &Draw shape outline
       Gui, Add, Checkbox, x+15 hp gupdateUIfillPanel Checked%FillAreaClosedPath% vFillAreaClosedPath, &Closed path
       Gui, Add, Text, xs y+15 h%ha% +0x200 vtxtLine5, Border color
       GuiAddPickerColor("x+10 hp w25", "DrawLineAreaColor")
       GuiAddColor("x+5 hp w" tml, "DrawLineAreaColor", "Line color")
       GuiAddSlider("DrawLineAreaOpacity", 3,255, 255, "Opacity", "updateUIfillPanel", 1, "x+5 w" btnWid " hp")
       GuiAddDropDownList("xs y+7 w" btnWid " gupdateUIfillPanel AltSubmit Choose" DrawLineAreaBlendMode " vDrawLineAreaBlendMode", "No blend mode|" userBlendModesList, "Blending mode")

       Gui, Add, Text, xs y+15 w%btnWid% vtxtLine3, Alignment
       Gui, Add, Text, x+10 wp vtxtLine4, Styling
       GuiAddDropDownList("xs y+7 wp AltSubmit Choose" DrawLineAreaContourAlign " vDrawLineAreaContourAlign gupdateUIfillPanel", "Inside|Centered|Outside", "Line alignment")
       GuiAddDropDownList("x+10 wp AltSubmit Choose" DrawLineAreaDashStyle " vDrawLineAreaDashStyle gupdateUIfillPanel", "Continous|Dashes|Dots|Dashes and dots", "Line style")
       Gui, Add, Checkbox, xs y+5 w%btnWid% h%btnHeight% Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles gupdateUIfillPanel, &Double line
       Gui, Add, Checkbox, x+10 wp hp gupdateUIfillPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, &Round caps
       GuiAddSlider("DrawLineAreaContourThickness", 1,450, 5, "Contour thickness: $€ pixels", "updateUIfillPanel", 1, "xs y+15 w" txtWid - 25 " h" ha)

       uiADDalphaMaskTabs(5, 6, "updateUIfillPanel")
    }

    Gui, Tab
    thisW := (PrefsLargeFonts=1) ? 80 : 60
    GuiAddCollapseBtn("xm+0 y+15 h" thisBtnHeight " w" ml)
    GuiAddCloseOnApply("x+5 yp hp wp")
    GuiAddToggleLivePreview("x+5 yp hp wp gupdateUIfillPanel")
    Gui, Add, Button, x+5 w%thisW% hp Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Fill shapes in selected area: " appTitle, winPos)
    SetTimer, updateUIfillPanel, -50
    SetTimer, resetOpeningPanel, -300
}

PanelSoloAlphaMasker() {
    If (imgEditPanelOpened=1 && AnyWindowOpen && AnyWindowOpen!=70 && thumbsDisplaying=0)
       postVectorWinOpen := AnyWindowOpen

    zz := postVectorWinOpen
    If !(thisBtnHeight := createSettingsGUI(70, A_ThisFunc, 1, 1))
       Return

    postVectorWinOpen := zz
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsBrushPanel()
    ReadSettingsAlphaMaskPanel()
    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60, EllipseSelectMode := 0
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    minislideWid := slideWid//2
    Global PickuFillAreaColor, PickuFillArea2ndColor, txtLine4, uiPasteInPlaceAlphaDrawMode

    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Alpha mask|Painting mode
    Gui, Tab, 1
    ; Gui, Add, Text, x+10 y+10 Section w%slideWid%, Hello vorld

    uiADDalphaMaskTabs(1, 2, "updateUIalphaMaskerPanel")
    Gui, Tab, 1
    ha := (PrefsLargeFonts=1) ? 27 : 18
    opaciSlideW := (PrefsLargeFonts=1) ? 130 : 85
    GuiAddSlider("alphaMaskPreviewOpacity", 1,255, 255, "Preview opacity", "updateUIalphaMaskerPanel", 1, "xs yp wp hp")

    Gui, Tab
    thisW := (PrefsLargeFonts=1) ? 85 : 65
    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddCollapseBtn("xm+0 y+15 h" thisBtnHeight " w" ml)
    ; GuiAddToggleLivePreview("x+5 yp hp wp gupdateUIpastePanel")
    defu := postVectorWinOpen ? "" : "Default"
    If postVectorWinOpen
       Gui, Add, Button, x+5 hp w%thisW% gBTNopenPrevPanel Default, &Back

    Gui, Add, Button, x+5 hp w%thisW% %defu% gBtnCloseWindow, &Close

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Define alpha mask: " appTitle, winPos)
    SetTimer, ForceRemoveTooltip, -100
    SetTimer, updateUIalphaMaskerPanel, -50
}

BTNopenPrevPanel(givenZZ:=0, isGiven:=0, morrigan:=0) {
   If isNowAlphaPainting()
   {
      toggleAlphaPaintingMode()
      Return
   }

   zz := postVectorWinOpen
   If (isNumber(givenZZ) && givenZZ>0 && isGiven="yes")
      zz := givenZZ
   Else If (isGiven="yes")
      Return

   If (morrigan!="n")
      CloseWindow()

   If (zz=66)
      f := "PanelFloodFillTool"
   Else If (zz=10)
      f := "PanelColorsAdjusterWindow"
   Else If (zz=23)
      f := "PanelFillSelectedArea"
   Else If (zz=25)
      f := "PanelEraseSelectedArea"
   Else If (zz=55)
      f := "PanelDesatureSelectedArea"
   Else If (zz=64)
      f := "PanelBrushTool"
   Else If (zz=65)
      f := "PanelDrawShapesInArea"
   Else If (zz=66)
      f := "PanelFloodFillTool"
   Else If (zz=68)
      f := "PanelFillBehindBgrImage"
   Else If (zz=70)
      f := "PanelSoloAlphaMasker"
   Else If (zz=74)
      f := "PanelColorsAdjusterImage"
   Else If (zz=81)
      f := "PanelSymmetricaImage"
   Else If (zz=89)
      f := "PanelAdjustColorsSimpleWindow"

   If f 
      SetTimer, % f, -100
   Else If (morrigan="n")
      SetTimer, openPreviousPanel, -100
}

PanelDrawShapesInArea(dummy:=0, which:=0) {
    If !(thisBtnHeight := createSettingsGUI(65, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsDrawShapeAreaPanel()
    If (EllipseSelectMode=1)
       FillAreaShape := 3
    Else If (EllipseSelectMode=0)
       FillAreaShape := 1
    Else If (EllipseSelectMode=2)
       FillAreaShape := 7

    If (dummy="tlbr" && isInRange(which, 1, 7))
       FillAreaShape := which

    customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60, EllipseSelectMode := 0
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 45
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    If (viewportQPVimage.imgHandle)
    {
       DrawLineAreaContourAlign := 2
       DrawLineAreaDashStyle := DrawLineAreaCapsStyle := 1
    }

    minislideWid := (PrefsLargeFonts=1) ? slideWid//2.32 : slideWid//2.52
    Global PickuFillAreaColor, PickuFillArea2ndColor

    userUIshapeCavity := Round((innerSelectionCavityX + innerSelectionCavityY) / 2 * 400)
    GuiAddDropDownList("x+5 y+15 Section w" slideWid " AltSubmit Choose" FillAreaShape " vFillAreaShape gupdateUIdrawShapesPanel", "Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape", "Shape to draw")
    GuiAddDropDownList("x+5 wp-30 AltSubmit Choose" FillAreaCurveTension " vFillAreaCurveTension gupdateUIdrawShapesPanel", "Polygonal|Smooth corners|Curve|Round curve|Bézier", "Vector path type")
    Gui, Add, Checkbox, xp yp wp hp Checked%FillAreaEllipsePie% vFillAreaEllipsePie gupdateUIdrawShapesPanel, &Sliced pie
    GuiAddSlider("userUIshapeCavity", 0,400, 0, "Shape cavity", "updateFillInnerCavity", 1, "xs y+5 w" slideWid " hp")
    GuiAddSlider("FillAreaRectRoundness", 4,98, 10, "Roundness", "updateUIdrawShapesPanel", 1, "x+5 yp+0 wp-25 hp")
    GuiAddSlider("FillAreaEllipseSection", -270,850, 850, ".updateLabelEllipseSect", "updateUIdrawShapesPanel", 3, "xp yp wp hp")
    Gui, Add, Checkbox, xp yp w%minislideWid% hp +0x1000 gupdateUIdrawShapesPanel Checked%FillAreaClosedPath% vFillAreaClosedPath, &Closed
    Gui, Add, Button, x+2 w%minislideWid% hp gMenuStartDrawingLines vBtn1, Modify
    Gui, Add, Checkbox, xs y+7 hp Checked%freeHandSelectionMode% vfreeHandSelectionMode gupdateUIdrawShapesPanel, &Freehand draw mode

    ml := (PrefsLargeFonts=1) ? 60 : 45
    Gui, Add, Text, xs y+15 w%btnWid% hp +0x200, Line color
    GuiAddColor("x+5 hp w" ml, "DrawLineAreaColor", "Line color")
    GuiAddPickerColor("x+2 hp w25", "DrawLineAreaColor")
    GuiAddSlider("DrawLineAreaOpacity", 3,255, 255, "Color opacity", "updateUIdrawShapesPanel", 1, "xs y+5 w" btnWid*2 + 5 " hp")
    GuiAddCheckbox("x+1 hp w26 gupdateUIdrawShapesPanel Checked" BlendModesPreserveAlpha " vBlendModesPreserveAlpha", "Protect alpha channel", "P",, "Preserve the alpha channel of the background`nimage unaltered by blend modes")
    Gui, Add, Text, xs y+15 w%btnWid% hp +0x200 gBtnResetBlendMode +hwndhTemp, Blending mode
    GuiAddDropDownList("x+5 wp gupdateUIdrawShapesPanel AltSubmit Choose" DrawLineAreaBlendMode " vDrawLineAreaBlendMode", "None|" userBlendModesList, [hTemp])
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIdrawShapesPanel")

    If (!viewportQPVimage.imgHandle)
    {
       Gui, Add, Text, xs y+15 w%btnWid%, Alignment
       Gui, Add, Text, x+5 wp, Styling
       GuiAddDropDownList("xs y+7 wp AltSubmit Choose" DrawLineAreaContourAlign " vDrawLineAreaContourAlign gupdateUIdrawShapesPanel", "Inside|Centered|Outside", "Line alignment")
       GuiAddDropDownList("x+5 wp AltSubmit Choose" DrawLineAreaDashStyle " vDrawLineAreaDashStyle gupdateUIdrawShapesPanel", "Continous|Dashes|Dots|Dashes and dots", "Line style")
       Gui, Add, Checkbox, xs y+6 wp h%btnHeight% +0x1000 Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles gupdateUIdrawShapesPanel, &Double line
       Gui, Add, Checkbox, x+5 wp hp +0x1000 gupdateUIdrawShapesPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, &Round caps
    } Else
    {
       Gui, Add, Checkbox, xs y+7 w%btnWid% Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles gupdateUIdrawShapesPanel, &Double line
       ; Gui, Add, Checkbox, x+5 Checked%FillAreaDoBehind% vFillAreaDoBehind gupdateUIdrawShapesPanel, &Fill behind the image
    }

    GuiAddSlider("DrawLineAreaContourThickness", 1,700, 45, ".updateLabelDrawLineThickness", "updateUIdrawShapesPanel", 1, "xs y+15 w" txtWid " hp")
    If (!viewportQPVimage.imgHandle)
       Gui, Add, Checkbox, xs y+10 gupdateUIdrawShapesPanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas to fit selection area
    Else
       GuiAddSlider("DrawLineAreaThickScale", 100, 500, 100, "Thickness scale: $€ %", "updateUIdrawShapesPanel", 1, "xs y+7 wp hp")

    btnWid := (PrefsLargeFonts=1) ? 105 : 65
    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddCollapseBtn("xs y+20 h" thisBtnHeight " w" ml)
    GuiAddCloseOnApply("x+5 yp hp wp")
    GuiAddToggleLivePreview("x+5 yp hp wp gupdateUIdrawShapesPanel")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    If (!viewportQPVimage.imgHandle)
       Gui, Add, Button, x+5 wp hp gBtnOpenPanelLines, &Lines
    Gui, Add, Button, x+5 wp hp gBtnCloseWindow, &Cancel

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Draw shapes in selected area: " appTitle, winPos)
    SetTimer, updateUIdrawShapesPanel, -50
}

toggleViewPortGridu(modus="") {
   showViewPortGrid := !showViewPortGrid
   If (showViewPortGrid=1)
      ReadSettingsVPgrid()

   friendly := (showViewPortGrid=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Viewport grid: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If isImgEditingNow()
      dummyTimerDelayiedImageDisplay(100)
   If (AnyWindowOpen=63)
      updateUIgridPanel()

   If (modus="tlbr")
   {
      setWhileLoopExec(1)
      While, (determineLClickState()=1 || A_Index=1)
          Sleep, 5
      setWhileLoopExec(0)
   }
}

toggleGridFixedSize() {
   vpGridFixedSize := !vpGridFixedSize
   RegAction(1, "vpGridFixedSize",, 1)
   friendly := (vpGridFixedSize=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Fixed size viewport grid: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyTimerDelayiedImageDisplay(50)
}

PanelConfigVPgrid() {
    If (thumbsDisplaying=1)
       Return

    If (imgEditPanelOpened=1 && AnyWindowOpen && thumbsDisplaying=0)
       postVectorWinOpen := AnyWindowOpen

    zz := postVectorWinOpen
    thisBtnHeight := createSettingsGUI(63, A_ThisFunc)
    postVectorWinOpen := zz
    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 155
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsVPgrid()
    slideWid2 := slideWid
    slideWid := slideWid*2
    Global PickuvpGridColor

    ml := (PrefsLargeFonts=1) ? 55 : 40
    Gui, Add, Checkbox, x15 y15 w%slideWid2% Section gupdateUIgridPanel Checked%showViewPortGrid% vshowViewPortGrid, &Show viewport grid
    GuiAddPickerColor("xs+16 y+10 hp+5 w25", "vpGridColor")
    GuiAddColor("x+5 hp w" ml, "vpGridColor", "Grid color")
    
    ml := (PrefsLargeFonts=1) ? 115 : 80
    GuiAddSlider("vpGridAlpha", 3,255, 128, "Opacity", "updateUIgridPanel", 1, "x+5 w" ml " hp")
    Gui, Add, Checkbox, xs y+10 w%slideWid2% hp gupdateUIgridPanel Checked%vpGridFixedSize% vvpGridFixedSize, &Fixed size grid
    Gui, Add, Checkbox, x+0 hp gupdateUIgridPanel Checked%LimitSelectBoundsImg% vLimitSelectBoundsImg, &Limit to image bounds
    GuiAddSlider("vpGridSize", 10,350, 25, "Grid size: $€", "updateUIgridPanel", 1, "xs y+10 w" slideWid - 20 " hp")
    GuiAddSlider("vpGridThickness", 1,15, 1, "Line thickness: $€", "updateUIgridPanel", 1, "y+10 wp hp")
    GuiAddSlider("vpGridStepu", 2,20, 2, "Stepping: $€", "updateUIgridPanel", 1, "y+10 wp hp")
    Gui, Add, Text, xs y+15 w%slideWid%, You can use Alt + [-] / [=] in the main window to change the dimensions of the grid.

    thisW := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, xs y+15 w%thisW% h%thisBtnHeight% Default gBtnCloseWindow, &Close
    If postVectorWinOpen
       Gui, Add, Button, x+5 hp wp gBTNopenPrevPanel, &Back

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Viewport grid: " appTitle, winPos)
    SetTimer, updateUIgridPanel, -50
}

VPchangeGridSize(dir) {
   If (thumbsDisplaying=1)
      Return

   If (showViewPortGrid!=1)
   {
      If (dir=1)
         toggleViewPortGridu()
      Return
   }

   thisGridThickness := vpGridThickness + imgHUDbaseUnit//30
   If (dir=1)
      vpGridSize += 5
   Else
      vpGridSize -= 5

   If (vpGridSize<thisGridThickness + 6)
   {
      vpGridSize := clampInRange(vpGridSize, 10, 350)
      toggleViewPortGridu()
      Return
   }

   vpGridSize := clampInRange(vpGridSize, 10, 350)
   showTOOLtip("Viewport grid size: " vpGridSize, A_ThisFunc, 2, vpGridSize/350)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (AnyWindowOpen=63)
      GuiUpdateSliders("vpGridSize")

   RegAction(1, "vpGridSize")
   dummyResizeImageGDIwin()
   ; dummyTimerDelayiedImageDisplay(90)
}

updateUIgridPanel() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide

   actu := (showViewPortGrid=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
   GuiControl, % actu, vpGridColor

   actu := (showViewPortGrid=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, PickuvpGridColor
   uiSlidersArray["vpGridStepu", 10] := showViewPortGrid
   uiSlidersArray["vpGridThickness", 10] := showViewPortGrid
   uiSlidersArray["vpGridSize", 10] := showViewPortGrid
   uiSlidersArray["vpGridAlpha", 10] := showViewPortGrid
   GuiControl, % actu, vpGridFixedSize
   GuiControl, % actu, LimitSelectBoundsImg
   GuiRefreshSliders()

   dummyTimerDelayiedImageDisplay(100)
   SetTimer, WriteSettingsVPgrid, -150
}

WriteSettingsVPgrid() {
   ReadSettingsVPgrid(1)
}

WriteSettingsBrushPanel() {
   ReadSettingsBrushPanel(1)
}

ToggleClosePanelApply() {
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   INIaction(1, "closeEditPanelOnApply", "General")
}

ReadSettingsDrawLinesArea(act:=0) {
    RegAction(act, "DrawLineAreaColor",, 3)
    RegAction(act, "DrawLineAreaOpacity",, 2, 1, 255)
    RegAction(act, "DrawLineAreaKeepBounds",, 1)
    RegAction(act, "DrawLineAreaSnapLine",, 1)
    RegAction(act, "DrawLineAreaCapsStyle",, 1)
    RegAction(act, "DrawLineAreaDoubles",, 1)
    RegAction(act, "DrawLineAreaContourAlign",, 2, 1, 3)
    RegAction(act, "DrawLineAreaDashStyle",, 2, 1, 4)
    RegAction(act, "DrawLineAreaBlendMode",, 2, 1, 24)
    RegAction(act, "DrawLineAreaContourThickness",, 2, 1, 700)
    RegAction(act, "DrawLineAreaBorderTop",, 1)
    RegAction(act, "DrawLineAreaBorderBottom",, 1)
    RegAction(act, "DrawLineAreaBorderLeft",, 1)
    RegAction(act, "DrawLineAreaBorderRight",, 1)
    RegAction(act, "DrawLineAreaBorderArcA",, 1)
    RegAction(act, "DrawLineAreaBorderArcB",, 1)
    RegAction(act, "DrawLineAreaBorderArcC",, 1)
    RegAction(act, "DrawLineAreaBorderArcD",, 1)
    RegAction(act, "DrawLineAreaBorderConnector",, 1)
    RegAction(act, "DrawLineAreaBorderCenter",, 2, 1, 6)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
    RegAction(act, "freeHandSelectionMode",, 1)
}

PanelDrawLines() {
    If !(thisBtnHeight := createSettingsGUI(30, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsDrawLinesArea()
    txtWid := 245
    EditWid := 60
    EllipseSelectMode := 0
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid := (PrefsLargeFonts=1) ? 166 : 105
    sml := (PrefsLargeFonts=1) ? 55 : 34
    BtnHeight := thisBtnHeight - 5
    Global infoDrawLineAreaOpacity, infoDrawLineAreaContour, PickuDrawLineAreaColor
    ; Gui, Add, Text, x15 y15 Section, Please configure what lines to draw and how.

    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Style

    Gui, Tab, 1
    Gui, Add, Text, x+15 y+15 w%btnWid% Section, Line generator
    Gui, Add, Text, x+10 wp vtxtLine2, Crop output
    GuiAddDropDownList("xs y+8 wp gupdateUIDrawLinesPanel AltSubmit Choose" DrawLineAreaBorderCenter " vDrawLineAreaBorderCenter", "Margins|Mid lines|Diagonals|Rays|Grid|Spiral", "Lines generator type")
    GuiAddDropDownList("x+10 wp gupdateUIDrawLinesPanel AltSubmit Choose" DrawLineAreaCropShape " vDrawLineAreaCropShape", "No cropping|Rectangular|Elliptical", "Crop output")
    Gui, Add, Checkbox, xs y+10 Section w%sml% h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcA% vDrawLineAreaBorderArcA,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderTop% vDrawLineAreaBorderTop,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcB% vDrawLineAreaBorderArcB,○
    Gui, Add, Checkbox, xs y+1 w%sml% h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderLeft% vDrawLineAreaBorderLeft,▏
    Gui, Add, Text, x+1 wp hp Center vtxtLine1,.
    GuiControl, Hide, txtLine1
    ; Gui, Add, Checkbox, x+1 wp hp +0x1000 Checked%DrawLineAreaDoSpiral% vDrawLineAreaDoSpiral,S
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderRight% vDrawLineAreaBorderRight,▏
    Gui, Add, Checkbox, xs y+1 w%sml% h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcC% vDrawLineAreaBorderArcC,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderBottom% vDrawLineAreaBorderBottom,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcD% vDrawLineAreaBorderArcD,○
    ha := (PrefsLargeFonts=1) ? 27 : 18
    GuiAddSlider("DrawLineAreaGridX", 1,350, 6, "Density X", "updateUIDrawLinesPanel", 1, "xs ys w" btnWid " h" ha)
    GuiAddSlider("DrawLineAreaGridY", 1,350, 6, "Density Y", "updateUIDrawLinesPanel", 1, "x+10 wp hp")
    Gui, Add, Checkbox, xs y+5 hp wp +0x1000 -wrap gupdateUIDrawLinesPanel Checked%DrawLineAreaEqualGrid% vDrawLineAreaEqualGrid, E&qual grid size
    Gui, Add, Checkbox, x+10 yp hp wp +0x1000 -wrap gupdateUIDrawLinesPanel Checked%DrawLineAreaAtomizedGrid% vDrawLineAreaAtomizedGrid, &Separated lines
    Gui, Add, Text, xs y+13 hp+3 wp -wrap +0x200 gdummy vinfoLine +hwndhTemp, Centering mode
    ToolTip2ctrl(hTemp, "This defines the behaviour of the object when rotated")
    GuiAddDropDownList("x+10 wp gupdateUIDrawLinesPanel AltSubmit Choose" DrawLineAreaSpiralCenterMode " vDrawLineAreaSpiralCenterMode", "Cone|Inverted cone|Rotobilæ", "Spiral center mode")
    GuiAddDropDownList("xp yp wp gupdateUIDrawLinesPanel AltSubmit Choose" DrawLineAreaGridCenter " vDrawLineAreaGridCenter", "Bulge warp|Center warp|Vertical courtain|Horizontal courtain", "Grid center mode")

    GuiAddSlider("DrawLineAreaRaysLimit", 0,125, 0, "Circum. cut-off", "updateUIDrawLinesPanel", 3, "xp ys wp h" ha)
    GuiAddSlider("DrawLineAreaSpiralLength", 50,5678, 900, "Spiral frequency", "updateUIDrawLinesPanel", 1, "xs ys wp hp")
    GuiAddSlider("DrawLineAreaAltRays", 0,200, 0, "Alternate radius", "updateUIDrawLinesPanel", 1, "xs y+10 wp hp")
    GuiAddSlider("DrawLineAreaCenterCut", -1,350, 0, "Cut-off limit: $€", "updateUIDrawLinesPanel", 1, "x+10 yp wp hp")
    Gui, Add, Checkbox, xp yp gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderConnector% vDrawLineAreaBorderConnector, &Join lines using arcs
    Gui, Add, Checkbox, xp yp gupdateUIDrawLinesPanel Checked%DrawLineAreaSnapLine% vDrawLineAreaSnapLine, &Snap lines to 0/90°
    Gui, Add, Checkbox, xs y+50 gupdateUIDrawLinesPanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas to fit selection area
    Gui, Add, Checkbox, xs y+10 gupdateUIDrawLinesPanel Checked%freeHandSelectionMode% vfreeHandSelectionMode, &Freehand draw mode

    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 Section w%btnWid%, Line style
    Gui, Add, Text, x+10 wp -wrap, Pen alignment
    GuiAddDropDownList("xs y+8 w" btnWid " gupdateUIDrawLinesPanel AltSubmit Choose" DrawLineAreaDashStyle " vDrawLineAreaDashStyle", "Continous|Dashes|Dots|Dashes and dots", "Line style")
    GuiAddDropDownList("x+10 wp gupdateUIDrawLinesPanel AltSubmit Choose" DrawLineAreaContourAlign " vDrawLineAreaContourAlign", "Inside|Centered|Outside", "Line alignment")
    Gui, Add, Checkbox, xs y+5 wp h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, Rounded caps
    Gui, Add, Checkbox, x+10 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaKeepBounds% vDrawLineAreaKeepBounds +hwndhTemp, &Within bounds
    ToolTip2ctrl(hTemp, "Rotate object within the boundaries of the selection area")
    Gui, Add, Checkbox, xs y+5 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles, Double line

    sml := (PrefsLargeFonts=1) ? 30 : 20
    ml := (PrefsLargeFonts=1) ? 72 : 25
    Gui, Add, Text, xs y+%sml% w%ml% +0x200 hp, Color
    ml := (PrefsLargeFonts=1) ? 56 : 42
    GuiAddColor("x+10 w" ml " hp", "DrawLineAreaColor", "Line color")
    GuiAddPickerColor("x+1 hp w25", "DrawLineAreaColor")
    GuiAddSlider("DrawLineAreaOpacity", 3,255, 255, "Opacity", "updateUIDrawLinesPanel", 1, "x+10 w" btnWid " h" ha)
    GuiAddCheckbox("x+1 hp w26 gupdateUIDrawLinesPanel Checked" BlendModesPreserveAlpha " vBlendModesPreserveAlpha", "Protect alpha channel", "P",, "Preserve the alpha channel of the background`nimage unaltered by blend modes")
    Gui, Add, Text, xs y+15 w%btnWid% hp +0x200 gBtnResetBlendMode +hwndhTemp, Blending mode
    GuiAddDropDownList("x+10 wp gupdateUIDrawLinesPanel AltSubmit Choose" DrawLineAreaBlendMode " vDrawLineAreaBlendMode", "None|" userBlendModesList, [hTemp])
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIDrawLinesPanel")
    GuiAddSlider("DrawLineAreaContourThickness", 1,450, 5, "Line width: $€ pixels", "updateUIDrawLinesPanel", 1, "xs y+10 w" btnWid*2 + 8 " hp")

    Gui, Tab
    btnWid := (PrefsLargeFonts=1) ? 105 : 65
    sml := (PrefsLargeFonts=1) ? 35 : 20
    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddCollapseBtn("xm+0 y+" sml " h" thisBtnHeight " w" ml)
    GuiAddCloseOnApply("x+5 yp hp wp")
    GuiAddToggleLivePreview("x+5 yp hp wp gupdateUIDrawLinesPanel")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    Gui, Add, Button, x+5 wp hp gBtnOpenPanelShapes, &Shapes
    Gui, Add, Button, x+5 wp hp gBtnCloseWindow, &Cancel

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Draw parametric lines in selected area: " appTitle, winPos)
    SetTimer, updateUIDrawLinesPanel, -50
}

BtnOpenPanelShapes() {
   BtnCloseWindow()
   Sleep, 2
   SetTimer, PanelDrawShapesInArea, -50
}

BtnOpenPanelLines() {
   BtnCloseWindow()
   Sleep, 2
   SetTimer, PanelDrawLines, -50
}

WriteSettingsDesaturateSelPanel() {
   ReadSettingsDesaturateSelPanel(1)
}

ReadSettingsDesaturateSelPanel(actu) {
   RegAction(actu, "DesaturateAreaAmount",, 2, 1, 255)
   RegAction(actu, "DesaturateAreaHue",, 2, -180, 180)
   RegAction(actu, "DesaturateAreaDither",, 1)
   RegAction(actu, "DesaturateAreaChannel",, 2, 1, 5)
   RegAction(actu, "DesaturateAreaLevels",, 2, 1, 8)
   RegAction(actu, "DesaturateAreaInvert",, 1)
   RegAction(actu, "DesaturateAreaBright",, 2, -65535, 65535)
   RegAction(actu, "DesaturateAreaContra",, 2, -65535, 65535)
   RegAction(actu, "EraseAreaInvert",, 1)
}

PanelDesatureSelectedArea() {
    If !(thisBtnHeight := createSettingsGUI(55, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsDesaturateSelPanel(0)
    btnWid := 70
    txtWid := 340
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 20
       txtWid := txtWid + 110
       Gui, Font, s%LargeUIfontValue%
    }

    If (viewportQPVimage.imgHandle)
       EraseAreaUseAlpha := 0

    btnWid2 := btnWid + 20
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please experiment with the provided options to control how the image is desatured.
    GuiAddDropDownList("xs w" btnWid2 " AltSubmit Choose" DesaturateAreaLevels " gupdateUIdesaturatePanel vDesaturateAreaLevels", "None|4|8|16|32|64|128|256", "Quantization level")
    GuiAddDropDownList("x+8 wp AltSubmit Choose" DesaturateAreaChannel " gupdateUIdesaturatePanel vDesaturateAreaChannel", "All channels|All (alt)|Red|Green|Blue", "Color channel")
    Gui, Add, Checkbox, x+10 yp hp Checked%DesaturateAreaDither% vDesaturateAreaDither gupdateUIdesaturatePanel, &Dithering
    ml := (PrefsLargeFonts=1) ? txtWid//2 + 4 : txtWid//2 + 18
    GuiAddSlider("DesaturateAreaAmount", 3, 255, 255, "Intensity", "updateUIdesaturatePanel", 1, "xs y+10 w" ml " hp")
    Gui, Add, Checkbox, x+10 yp hp Checked%DesaturateAreaInvert% vDesaturateAreaInvert gupdateUIdesaturatePanel, &Invert image
    GuiAddSlider("DesaturateAreaHue", -180, 180, 0, "Relight: $€°", "updateUIdesaturatePanel", 2, "xs y+10 w" ml " hp")
    Gui, Add, Checkbox, x+10 yp hp Checked%EraseAreaInvert% vEraseAreaInvert gupdateUIdesaturatePanel, &Invert selection area
    GuiAddSlider("DesaturateAreaBright", -65535, 65535, 0, "Brightness", "updateUIdesaturatePanel", 2, "xs y+10 w" ml " hp")
    Gui, Add, Checkbox, x+10 yp hp Checked%EraseAreaUseAlpha% vEraseAreaUseAlpha gupdateUIdesaturatePanel, Apply alpha mas&k
    GuiAddSlider("DesaturateAreaContra", -65535, 65535, 0, "Contrast", "updateUIdesaturatePanel", 2, "xs y+10 w" ml " hp")

    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddCollapseBtn("xm+0 y+20 h" thisBtnHeight " w" ml)
    GuiAddCloseOnApply("x+5 yp hp wp")
    GuiAddToggleLivePreview("x+5 yp hp wp gupdateUIdesaturatePanel")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Desaturate selected area: " appTitle, winPos)
    SetTimer, updateUIdesaturatePanel, -150
}

PanelSymmetricaImage() {
    If !(thisBtnHeight := createSettingsGUI(81, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    btnWid := 70
    txtWid := 270
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 20
       txtWid := txtWid + 110
       Gui, Font, s%LargeUIfontValue%
    }

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "None"
    If (coreDesiredPixFmt="0x21808")
       UserSymmetricaBlendMode := 1

    ReadSettingsSymmetricaPanel()
    tinyPrevAreaCoordX := lastSymmetryCoords[1] ? lastSymmetryCoords[1] : imgSelX1 + 125
    tinyPrevAreaCoordY := lastSymmetryCoords[2] ? lastSymmetryCoords[2] : imgSelY1 + 125

    btnWid2 := (PrefsLargeFonts=1) ? btnWid + 60 : btnWid + 20
    Gui, Add, Tab3, %tabzDarkModus% x+15 y+15 gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Color options
    Gui, Tab, 1
    Gui, Add, Text, x+15 y+15 Section +hwndhTemp, Symmetry mode:
    GuiAddDropDownList("x+10 w" btnWid2 " AltSubmit gupdateUIsymmetricaPanel Choose" UserSymmetricaMode " vUserSymmetricaMode", "X|Y|Both X/Y|X/Y and diagonal", [hTemp])
    GuiAddDropDownList("x+5 wp-20 AltSubmit gupdateUIsymmetricaPanel Choose" UserSymmetricaSrcAlign " vUserSymmetricaSrcAlign", "Top, left|Bottom, right", "Symmetry source corner")
    Gui, Add, Checkbox, xs y+10 gupdateUIsymmetricaPanel Checked%UserSymmetricaCenteringMode% vUserSymmetricaCenteringMode, Allo&w symmetry center positioning
    Gui, Add, Text, xs y+15 +0x200, Source image options:
    ha := (PrefsLargeFonts=1) ? 27 : 18
    btnWid2 += 20
    GuiAddSlider("UserSymmetricaScaleX", 1,200, 200, "Scale X", "updateUIsymmetricaPanel", 1, "xp+20 y+5 w" btnWid2 " h" ha)
    GuiAddSlider("UserSymmetricaScaleY", 1,200, 200, "Scale Y", "updateUIsymmetricaPanel", 1, "x+10 wp hp")
    Gui, Add, Checkbox, xs+20 y+10 Checked%UserSymmetricaSrcFlipX% vUserSymmetricaSrcFlipX gupdateUIsymmetricaPanel, &Flip X
    Gui, Add, Checkbox, x+5 Checked%UserSymmetricaSrcFlipY% vUserSymmetricaSrcFlipY gupdateUIsymmetricaPanel, Flip &Y
    Gui, Add, Checkbox, x+10 Checked%UserSymmetricaSrcRotated% vUserSymmetricaSrcRotated gupdateUIsymmetricaPanel, 90° rotation
    Gui, Add, Checkbox, xs y+15 Checked%UserSymmetricaSelAligned% gupdateUIsymmetricaPanel vUserSymmetricaSelAligned, &Align to selection area

    GuiAddSlider("UserSymmetricaSelOffX", 0,200, 0, "Offset X", "updateUIsymmetricaPanel", 1, "xs+20 y+5 w" btnWid2 " h" ha)
    GuiAddSlider("UserSymmetricaSelOffY", 0,200, 0, "Offset Y", "updateUIsymmetricaPanel", 1, "x+10 wp hp")
    Gui, Add, Checkbox, xs y+10 Checked%UserSymmetricaInvertArea% gupdateUIsymmetricaPanel vUserSymmetricaInvertArea, &Invert selection area
    Gui, Add, Checkbox, x+15 Checked%UserSymmetricaUseAlpha% gupdateUIsymmetricaPanel vUserSymmetricaUseAlpha, Use alpha mas&k

    Gui, Tab, 2
    ml := (PrefsLargeFonts=1) ? 35 : 25
    Gui, Add, Text, x+15 y+15 Section gBtnResetBlendMode +TabStop +hwndhTemp, Blending mode: 
    GuiAddDropDownList("x+10 wp+15 gupdateUIsymmetricaPanel AltSubmit Choose" UserSymmetricaBlendMode " vUserSymmetricaBlendMode", infoBlend "|" userBlendModesList, [hTemp])
    GuiAddFlipBlendLayers("x+1 yp hp w" ml " gupdateUIsymmetricaPanel")
    GuiAddCheckbox("x+1 hp wp gupdateUIsymmetricaPanel Checked" BlendModesPreserveAlpha " vBlendModesPreserveAlpha", "Protect alpha channel", "P",, "Preserve the alpha channel of the background`nimage unaltered by blend modes")
    GuiAddSlider("UserSymmetricaOpacity", 3,255, 255, "Opacity", "updateUIsymmetricaPanel", 1, "xs y+15 w" txtWid " hp")

    Gui, Add, Checkbox, xs y+15 hp Checked%BlurAreaApplyFX% gupdateUIsymmetricaPanel vBlurAreaApplyFX, &Apply color adjustments
    GuiAddSlider("BlurAreaHue", -180,180, 0, "Hue: $€°", "updateUIsymmetricaPanel", 2, "xs y+15 w" txtWid " hp")
    GuiAddSlider("BlurAreaSaturation", -100,100, 0, "Saturation", "updateUIsymmetricaPanel", 2, "xs y+10 wp hp")
    GuiAddSlider("BlurAreaLight", -255,255, 0, "Brightness", "updateUIsymmetricaPanel", 2, "xs y+10 wp hp")
    GuiAddSlider("BlurAreaGamma", -100,100, 0, "Contrast", "updateUIsymmetricaPanel", 2, "xs y+10 wp hp")

    Gui, Tab
    GuiAddCollapseBtn("xm+0 y+30 h" thisBtnHeight " w" ml)
    GuiAddCloseOnApply("x+5 yp hp wp")
    GuiAddToggleLivePreview("x+5 yp hp wp gupdateUIsymmetricaPanel")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Generate symmetries: " appTitle, winPos)
    updateUIsymmetricaPanel()
}

updateUIsymmetricaPanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=81)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    actu := (UserSymmetricaInvertArea=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
    GuiControl, % actu, UserSymmetricaSelAligned

    actu := (UserSymmetricaMode=4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, UserSymmetricaSrcAlign

    isActive := (UserSymmetricaMode=1 || UserSymmetricaMode>=3) ? 1 : 0
    uiSlidersArray["UserSymmetricaScaleX", 10] := isActive

    isActive := (UserSymmetricaMode=2 || UserSymmetricaMode>=3) ? 1 : 0
    uiSlidersArray["UserSymmetricaScaleY", 10] := isActive

    isActive := (UserSymmetricaSelAligned=1 && UserSymmetricaInvertArea=0) ? 1 : 0
    uiSlidersArray["UserSymmetricaSelOffX", 10] := isActive
    uiSlidersArray["UserSymmetricaSelOffY", 10] := isActive
    uiSlidersArray["BlurAreaLight", 10] := blurAreaApplyFX
    uiSlidersArray["BlurAreaGamma", 10] := blurAreaApplyFX
    uiSlidersArray["BlurAreaHue", 10] := blurAreaApplyFX
    uiSlidersArray["BlurAreaSaturation", 10] := blurAreaApplyFX

    If (A_TickCount - lastInvoked>50)
       GuiRefreshSliders()

    If (actionu!="noPreview")
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)
    lastInvoked := A_TickCount
    SetTimer, WriteSettingsSymmetricaPanel, -350
}

PanelFloodFillTool() {
    Static userWasWarned := 0
    initQPVmainDLL()
    If (dupesDCTcoeffsInit!=1 && userWasWarned=0)
    {
       userWasWarned := 1
       msgBoxWrapper(appTitle ": WARNING", appTitle " has failed to initialize the main DLL file: qpvmain.dll. Options within this panel and others will likely not function properly.", 0, 0, "error")
    }

    If !(thisBtnHeight := createSettingsGUI(66, A_ThisFunc, 1, 1))
       Return

    ReadSettingsFloodFillPanel()
    btnWid := 100
    txtWid := 250
    EditWid := 60
    FloodFillSelectionAdj := 0
    interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 205
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid2 := (PrefsLargeFonts=1) ? txtWid//2 + 5 : txtWid//2 + 15
    xCol := (PrefsLargeFonts=1) ? 285 : 195
    txtWid3 := (PrefsLargeFonts=1) ? txtWid//2 + 25 : txtWid//2 + 35
    txtWid := (PrefsLargeFonts=1) ? txtWid + 25 : txtWid + 40
    FloodFillUseAlpha := decideAlphaMaskingFeaseable(FloodFillUseAlpha)
    Global PickuFloodFillColor

    Gui, Add, Text, x15 y15 Section, Flood fill (bucket) color:
    Gui, Add, Checkbox, x%xCol% yp+0 gupdateUIfloodFillPanel Checked%FloodFillCartoonMode% vFloodFillCartoonMode, Cartoon mode
    ha := (PrefsLargeFonts=1) ? 27 : 18
    ml := (PrefsLargeFonts=1) ? 55 : 35
    GuiAddPickerColor("xs+15 y+10 h" ha " w25", "FloodFillColor")
    GuiAddColor("x+1 hp w" ml, "FloodFillColor", "Flood fill color")
    GuiAddSlider("FloodFillClrOpacity", 3,255, 255, "Opacity", "updateUIfloodFillPanel", 1, "x+3 w" btnWid - 10 " hp")
    Gui, Add, Checkbox, x%xCol% yp+0 hp gupdateUIfloodFillPanel Checked%FloodFillUseAlpha% vFloodFillUseAlpha, Apply alpha mas&k

    pw := (PrefsLargeFonts=1) ? xCol - 42 : xCol - 42
    GuiAddSlider("FloodFillOpacity", 3,255, 255, "Flooding opacity", "updateUIfloodFillPanel", 1, "xs+15 y+15 w" pw " hp")
    GuiAddDropDownList("x" xCol " yp+0 wp-25 gupdateUIfloodFillPanel AltSubmit Choose" FloodFillBlendMode " vFloodFillBlendMode", "No blend mode|" StrReplace(userBlendModesList, "*"), "Blending mode")
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIfloodFillPanel")
    Gui, Add, Checkbox, xs+14 y+8 hp gupdateUIfloodFillPanel Checked%FloodFillDynamicOpacity% vFloodFillDynamicOpacity, Reduce flooding opacity based on color similarity

    kl := (PrefsLargeFonts=1) ? 335 : 225
    Gui, Add, Text, xs y+15 hp Section +0x200, Color similarity:
    GuiAddSlider("FloodFillTolerance", 0,255, 10, "Tolerance", "updateUIfloodFillPanel", 1, "x+6 w" kl " h" ha)
    GuiAddDropDownList("xs+15 y+10  w" txtWid2 " gupdateUIfloodFillPanel AltSubmit Choose" FloodFillAltToler " vFloodFillAltToler +hwndhTemp", "Grayscale [fast]|L*a'b' based grayscale|CIE 2000 Delta E [accurate]", "Color similarity algorithm", "The selected algorithm is used to determine the degree of similarity between the colors")
    Gui, Add, Checkbox, x%xCol% yp+0 hp gupdateUIfloodFillPanel Checked%FloodFillEightWays% vFloodFillEightWays , Follow thin lines
    Gui, Add, Checkbox, xs+15 y+10 gupdateUIfloodFillPanel Checked%FloodFillModus% vFloodFillModus, Replace the similar colors anywhere

    sml := (PrefsLargeFonts=1) ? 40 : 30
    GuiAddCollapseBtn("xm+0 y+25 h" thisBtnHeight " w" sml)
    ; Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp wp+30 gBtnCloseWindow Default, &Close

    txtWid2 := (PrefsLargeFonts=1) ? 200 : 110
    GuiAddDropDownList("x+5 w" txtWid2 " gupdateUIfloodFillPanel AltSubmit Choose" BrushToolOutsideSelection " vBrushToolOutsideSelection", "Ignore selection|Flood inside|Flood outside", "Selection fill mode")

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Color bucket tool: " appTitle, winPos)
    SetTimer, updateUIfloodFillPanel, -190
}

PanelEraseSelectedArea() {
    If !(thisBtnHeight := createSettingsGUI(25, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    RegAction(0, "EraseAreaFader",, 1)
    RegAction(0, "EraseAreaOpacity",, 2, 4, 250)
    RegAction(0, "EraseAreaInvert",, 1)
    EraseAreaUseAlpha := decideAlphaMaskingFeaseable(EraseAreaUseAlpha)
    btnWid := 80
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    If (viewportQPVimage.imgHandle)
       EraseAreaUseAlpha := 0
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please decide how to erase or fade selected area:
    Gui, Add, Checkbox, xs y+10 hp+6 Checked%EraseAreaInvert% vEraseAreaInvert gupdateUIerasePanel, &Invert selection area
    Gui, Add, Checkbox, x+10 wp hp Checked%EraseAreaFader% vEraseAreaFader gupdateUIerasePanel, &Fade selected area

    Gui, Add, Checkbox, xs y+10 wp hp Checked%EraseAreaUseAlpha% vEraseAreaUseAlpha gupdateUIerasePanel, Apply alpha mas&k
    GuiAddSlider("EraseAreaOpacity", 0,250, 128, "Eraser opacity", "updateUIerasePanel", 1, "x+10 wp hp")
    If (viewportQPVimage.imgHandle)
    {
       GuiControl, Disable, EraseAreaUseAlpha
       bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
       If (bpp<32)
          Gui, Add, Text, xs y+15 w%txtWid%, The image does not seem to have an alpha channel. Please convert it to 32 bits for optimal results.
    }

    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddCollapseBtn("xm+0 y+20 h" thisBtnHeight " w" ml)
    GuiAddCloseOnApply("x+5 yp hp wp")
    GuiAddToggleLivePreview("x+5 yp hp wp gupdateUIerasePanel")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Erase selected area: " appTitle, winPos)
    SetTimer, updateUIerasePanel, -150
}

PanelFillBehindBgrImage() {
    If (viewportQPVimage.imgHandle)
    {
       FillAreaDoBehind := 1
       SetTimer, PanelFillSelectedArea, -10
       Return
    }

    If !(thisBtnHeight := createSettingsGUI(68, A_ThisFunc, 1, 1))
       Return

    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    If (EllipseSelectMode=1)
       FillAreaShape := 3
    Else If (EllipseSelectMode=0)
       FillAreaShape := 1
    Else If (EllipseSelectMode=2)
       FillAreaShape := 7

    ReadSettingsFillBehindAreaPanel()
    customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
    FillAreaClosedPath := FillAreaEllipsePie := 1
    userUIshapeCavity := Round((innerSelectionCavityX + innerSelectionCavityY) / 2 * 400)
    btnWid := 80,    txtWid := 350,    EditWid := 60
    slideWid := 155
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 105
       slideWid := slideWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    Global PickuFillBehindColor
    ml := (PrefsLargeFonts=1) ? 35 : 25
    Gui, Add, Text, x15 y15 Section, Please set the shape, color and opacity options`nto fill behind (semi-) transparent pixels.
    GuiAddDropDownList("xs y+10 Section w" slideWid " AltSubmit Choose" FillAreaShape " vFillAreaShape gupdateUIfillBehindPanel", "Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape", "Shape to fill")
    GuiAddDropDownList("x+5 wp-" ml + 5 " AltSubmit Choose" FillAreaCurveTension " vFillAreaCurveTension gupdateUIfillBehindPanel", "Polygonal|Smooth corners|Curve|Round curve|Bézier", "Vector path type")
    GuiAddSlider("FillAreaRectRoundness", 4,98, 10, "Roundness", "updateUIfillPanel", 1, "xp yp w" slideWid " hp")
    GuiAddSlider("FillAreaEllipseSection", -270,850, 850, ".updateLabelEllipseSect", "updateUIfillBehindPanel", 3, "xp yp wp hp")
    GuiAddShapeEditBtn("xp+" slideWid - ml " yp hp w" ml)
    GuiAddSlider("userUIshapeCavity", 0,400, 0, "Shape cavity", "updateFillInnerCavity", 1, "xs y+5 w" slideWid " hp")
    GuiAddSlider("FillBehindOpacity", 2,255, 255, "Image opacity", "updateUIfillBehindPanel", 1, "x+5 wp hp")
    zpl := slideWid + 5
    Gui, Add, Checkbox, xs y+7 hp Checked%freeHandSelectionMode% vfreeHandSelectionMode gupdateUIfillBehindPanel, &Freehand draw mode

    Gui, Add, Text, xs y+15 hp +0x200, Fill color:
    GuiAddColor("x+5 hp wp-15", "FillBehindColor", "Background color")
    GuiAddPickerColor("x+1 hp w" ml, "FillBehindColor")
    If (wasSelect!=1 && EllipseSelectMode=0 && VPselRotation=0)
       FillBehindInvert := 0

    GuiAddSlider("FillBehindClrOpacity", 2,255, 255, "Opacity", "updateUIfillBehindPanel", 1, "x+5 w" slideWid - 20 " hp")
    Gui, Add, Checkbox, xs y+10 hp Checked%FillBehindInvert% gupdateUIfillBehindPanel vFillBehindInvert, &Invert selection area

    GuiAddCollapseBtn("xm+0 y+25 h" thisBtnHeight " w" ml)
    GuiAddCloseOnApply("x+5 yp hp wp")
    GuiAddToggleLivePreview("x+5 yp hp wp gupdateUIfillBehindPanel")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    ; Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    GuiRefreshSliders()
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Fill behind image: " appTitle, winPos)
    SetTimer, updateUIfillBehindPanel, -150
}

updateUIfillBehindPanel(actionu:="", b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=68)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    decideCustomShapeStyle()
    actu := (FillAreaShape=2) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiUpdateVisibilitySliders(actu, "FillAreaRectRoundness")

    actu := (FillAreaShape=3 && !viewportQPVimage.imgHandle) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiUpdateVisibilitySliders(actu, "FillAreaEllipseSection")

    actu := (FillAreaShape=7) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu, FillAreaCurveTension
    GuiControl, % actu, UIbtnEditShape

    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := FillBehindClrOpacity
    EllipseSelectMode := (FillAreaShape=7) ? 2 : 0
    If (FillAreaShape=3)
       EllipseSelectMode := 1

    GuiRefreshSliders()
    SetTimer, WriteSettingsFillBehindAreaPanel, -150
    If (actionu!="noPreview") && (A_TickCount - lastInvoked>50)
    {
       lastInvoked := A_TickCount
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)
       SetTimer, dummyRefreshImgSelectionWindow, -100
    }
}

createHatchBrush(thisOpacity) {
   thisBase := (coreDesiredPixFmt="0x21808") ? "010101" : "FF999999"
   thisColorA := makeRGBAcolor(thisBase, 255 - thisOpacity)
   thisColorB := makeRGBAcolor("111111", 255 - thisOpacity)
   thisBrush := Gdip_BrushCreateHatch(thisColorA, thisColorB, 50)
   Return thisBrush
}

getClampedVPimgBounds(ByRef dpX, ByRef dpY, ByRef kX, ByRef kY, ByRef kW, ByRef kH) {
   vpWinClientSize(mainWidth, mainHeight)
   dpX := clampInRange(prevDestPosX, 0, mainWidth)
   dpY := clampInRange(prevDestPosY, 0, mainHeight)
   kX := clampInRange(prevDestPosX + prevResizedVPimgW, 2, mainWidth)
   kY := clampInRange(prevDestPosY + prevResizedVPimgH, 2, mainHeight)
   kW := max(dpX, kX) - min(dpX, kX)
   kH := max(dpY, kY) - min(dpY, kY)
   If (kW < 1)
      kW := 1
   If (kH < 1)
      kH := 1
}

getClampedVPselToWindow(clampToImage, mainWidth, mainHeight, thisW, thisH, ByRef dpX, ByRef dpY, ByRef selW, ByRef selH) {
   If (LimitSelectBoundsImg=0 && clampToImage=1)
   {
      LimitSelectBoundsImg := -1
      ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, thisW, thisH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, selW, selH, dpX, dpY)
      LimitSelectBoundsImg := 0
   }

   offX := (dpX<0) ? abs(dpX) : 0
   offY := (dpY<0) ? abs(dpY) : 0
   dpX := clampInRange(dpX, 0, mainWidth)
   dpY := clampInRange(dpY, 0, mainHeight)
   kX := clampInRange(dpX - offX + selW, 2, mainWidth)
   kY := clampInRange(dpY - offY + selH, 2, mainHeight)
   selW := max(dpX, kX) - min(dpX, kX)
   selH := max(dpY, kY) - min(dpY, kY)
   If (selW < 1)
      selW := 1
   If (selH < 1)
      selH := 1
}

livePreviewEraseArea() {
   If (doImgEditLivePreview!=1)
      Return

   vpWinClientSize(mainWidth, mainHeight)
   trGdip_GetImageDimensions(useGdiBitmap(), thisW, thisH)
   objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, thisW, thisH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   pPath := VPcreateSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, VPselRotation, 1, mainWidth, mainHeight, 0)
   invertPath := Gdip_ClonePath(pPath)
   Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
   tx := (imgSelPx > prevDestPosX) ? prevDestPosX : max(imgSelPx, prevDestPosX)
   ty := (imgSelPy > prevDestPosY) ? prevDestPosY : max(imgSelPy, prevDestPosY)
   twx := ((imgSelPx + imgSelW) > (prevDestPosX + prevResizedVPimgW)) ? prevDestPosX + prevResizedVPimgW : max(imgSelPx + imgSelW, prevDestPosX + prevResizedVPimgW)
   twy := ((imgSelPy + imgSelH) > (prevDestPosY + prevResizedVPimgH)) ? prevDestPosY + prevResizedVPimgH : max(imgSelPy + imgSelH, prevDestPosY + prevResizedVPimgH)
   Gdip_AddPathRectangle(invertPath, tx, ty, twx - tx, twy - ty)
   If (EraseAreaInvert=1)
      getClampedVPimgBounds(imgSelPx, imgSelPy, kX, kY, imgSelW, imgSelH)
   Else
      getClampedVPselToWindow(1, mainWidth, mainHeight, thisW, thisH, imgSelPx, imgSelPy, imgSelW, imgSelH)

   allowAlphaMasking := decideAlphaMaskingFeaseable(EraseAreaUseAlpha)
   If viewportQPVimage.imgHandle
      allowAlphaMasking := 0

   fnOutputDebug("redraw: " A_ThisFunc)
   ; sizu := (EraseAreaFader=1 && allowAlphaMasking=0) ? 10 : 4
   thisub := GDIcreateCheckersBrush(4, 1, EraseAreaOpacity)
   thisBrush := (EraseAreaFader=1 && allowAlphaMasking=0) ? thisub : GDIPbrushHatch
   thisOpacity := (EraseAreaFader=1) ? 255 - EraseAreaOpacity : 0
   thisBrush2 := (EraseAreaFader=1) ? thisub : GDIPbrushHatch
   If (viewportQPVimage.imgHandle)
   {
      black := makeRGBAcolor("010101", 255 - thisOpacity)
      bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
      If (bpp<32)
      {
         blackBrush := Gdip_BrushCreateSolid(black)
         thisuuby := thisBrush := thisBrush2 := thisub := blackBrush
      }
   }

   whichPath := (EraseAreaInvert=1) ? invertPath : pPath
   If (allowAlphaMasking=1)
   {
      getVPselSize(zW, zH, 1, EraseAreaInvert)
      ; ToolTip, % oImgW "|" oImgH "`n" imgSelW "|" imgSelH , , , 2
      objSel.dw := imgSelW,    objSel.dh := imgSelH
      objSel.dx := imgSelPx,   objSel.dy := imgSelPy
      objSel.nw := imgSelW,    objSel.nh := imgSelH
      objSel.zw := zw,         objSel.zh := zh
      objSel.invertArea := EraseAreaInvert

      zBitmap := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH)
      G3 := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
      pMatrix := Gdip_CreateMatrix()
      Gdip_TranslateMatrix(pMatrix, -imgSelPx , -imgSelPy)
      E := Gdip_TransformPath(whichPath, pMatrix)
      Gdip_FillPath(G3, GDIPbrushHatch, whichPath)
      Gdip_DeleteMatrix(zPath)
      Gdip_DeleteGraphics(G3)
      modus := (EraseAreaInvert=1) ? 4 : 0
      og := alphaMaskColorReversed
      alphaMaskColorReversed := !og
      partu := getVPselIDs("saiz-vpos-xy") VPselRotation EllipseSelectMode imgSelW imgSelH rotateSelBoundsKeepRatio innerSelectionCavityX innerSelectionCavityY prevDestPosX prevDestPosY zoomLevel
      thisIDu := "a" alphaMaskColorReversed alphaMaskingMode userAlphaMaskBmpPainted VPselRotation imgSelPx imgSelPy imgSelW imgSelH EraseAreaInvert EraseAreaOpacity EraseAreaFader partu
      ; realtimePasteInPlaceAlphaMasker(1, zBitmap, thisIDu, newBitmap, 0, 0, 0, 0)
      realtimePasteInPlaceAlphaMasker(1, zBitmap, thisIDu, newBitmap, objSel, 0, 0, 0, 0, 0, 0)
      If validBMP(newBitmap)
      {
         trGdip_DisposeImage(zBitmap, 1)
         zBitmap := newBitmap
      }

      alphaMaskColorReversed := og
      thisOpacity := (EraseAreaFader=1) ? EraseAreaOpacity/255 : 1
      r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
      trGdip_DisposeImage(zBitmap, 1)
   } Else
      Gdip_FillPath(2NDglPG, thisBrush, whichPath)

   Gdip_ResetClip(2NDglPG)
   Gdip_DeletePath(pPath)
   Gdip_DeletePath(invertPath)
   If (blackBrush && blackBrush=thisub)
      Gdip_DeleteBrush(blackBrush)
   Else
      Gdip_DeleteBrush(thisub)
}

livePreviewAlphaMasking(dummy:=0, dummyOpacity:=0) {
   Critical, on
   If (alphaMaskingMode<2 || (alphaMaskPreviewOpacity<2 && dummy="live") || (doImgEditLivePreview!=1 && dummy="live"))
      Return

   friendly := defineCurrentAlphaMask()
   If InStr(friendly, "inexistent")
   {
      showTOOLtip("WARNING: The referenced alpha mask bitmap does not exist")
      If (dummy!="live")
         SoundBeep 300, 100
      SetTimer, RemoveTooltip, -1050
      ToolTip
      Return
   }

   dotsSize := SelDotsSize
   ; fnOutputDebug("redraw: " A_ThisFunc)
   vpWinClientSize(mainWidth, mainHeight)
   trGdip_GetImageDimensions(useGdiBitmap(), thisW, thisH)
   objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, thisW, thisH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, vPimgSelW, vPimgSelH, vPimgSelX, vPimgSelY)
   transformTool := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
   If ((AnyWindowOpen=32 || transformTool=1) && doImgEditLivePreview=1) ; insert text and transform tools
   {
      getPrevAlphaMaskCoords(xa, ya, ww, hh, vPimgSelW, vPimgSelH, vPimgSelX, vPimgSelY)
      vPimgSelX := xa,  vPimgSelY := ya
      vPimgSelW := ww,  vPimgSelH := hh
      objSel.sw := vPimgSelW,   objSel.sh := vPimgSelH
      objSel.sx := vPimgSelX,   objSel.sy := vPimgSelY
      ; ToolTip, %  vPimgSelX "|" vPimgSelY , , , 2
      doClamping := 0
   } Else doClamping := 1

   doInvertPreview := (AnyWindowOpen=81 && UserSymmetricaInvertArea=1) || (AnyWindowOpen=66 && FloodFillUseAlpha=1 && (BrushToolOutsideSelection=1 || BrushToolOutsideSelection=3)) || (AnyWindowOpen=23 && FillAreaInverted=1) || ((AnyWindowOpen=25 || AnyWindowOpen=55) && EraseAreaInvert=1) ? 1 : 0
   If (doInvertPreview=1 && dummy!="live")
   {
      If (AnyWindowOpen=66 && FloodFillUseAlpha=1 && BrushToolOutsideSelection=3)|| (AnyWindowOpen=23 && FillAreaInverted=1) || ((AnyWindowOpen=25 || AnyWindowOpen=55) && EraseAreaInvert=1)
         pPath := createImgSelPath(vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)

      getClampedVPimgBounds(vPimgSelX, vPimgSelY, kX, kY, vPimgSelW, vPimgSelH)
   } Else
      getClampedVPselToWindow(doClamping, mainWidth, mainHeight, thisW, thisH, vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH)

   If (dummy!="live")
   {
      Sleep, -1
   } Else If validBMP(userAlphaMaskBmpPainted)
   {
      trGdip_GetImageDimensions(userAlphaMaskBmpPainted, w, h)
      viewportDynamicOBJcoords.x := objSel.sx,  viewportDynamicOBJcoords.y := objSel.sy
      viewportDynamicOBJcoords.w := objSel.sw,  viewportDynamicOBJcoords.h := objSel.sH
      viewportDynamicOBJcoords.zl := (objSel.sw/w + objSel.sh/h)/2 + 0.0001
   }

   ; ToolTip, % oImgW "|" oImgH "`n" imgSelW "|" imgSelH , , , 2
   getVPselSize(zW, zH, 1, 0)
   objSel.dw := vPimgSelW,    objSel.dh := vPimgSelH
   objSel.dx := vPimgSelX,    objSel.dy := vPimgSelY
   objSel.zw := zw,           objSel.zh := zh
   objSel.nw := zw,           objSel.nh := zh
   objSel.invertArea := (doInvertPreview=1 && dummy!="live") ? 1 : 0

   imgSelW := Round( max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2) )
   imgSelH := Round( max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2) )
   ; pEffectGray := Gdip_CreateEffect(6, 0, -100, 0)
   thisOpacity := (alphaMaskPreviewOpacity<254 && AnyWindowOpen=70) ? alphaMaskPreviewOpacity/255 : 1
   If dummyOpacity
      thisOpacity := dummyOpacity

   clrMatrix := (alphaMaskColorReversed=1) ? GenerateColorMatrix(6, a, b, c, thisOpacity) : thisOpacity
   If isNowAlphaPainting()
   {
      trGdip_GetImageDimensions(userAlphaMaskBmpPainted, oImgW, oImgH)
      objSel.nw := oImgW,      objSel.nh := oImgH
      wBitmap := getRectFromBitmap(userAlphaMaskBmpPainted, objSel, 1)
      ; trGdip_GetImageDimensions(wBitmap, ww, hh)
      ; fnOutputDebug(A_ThisFunc "(): " zkw "|" zkh "||" ww "|" hh "||" oImgW "|" oImgH)
      trGdip_DrawImage(A_ThisFunc, 2NDglPG, wBitmap, vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH,,,,, clrMatrix)
      trGdip_DisposeImage(wBitmap)
      trGdip_GetImageDimensions(userAlphaMaskBmpPainted, w, h)
      msg := "Alpha mask type: user painted bitmap (raw)`nDimensions: " groupDigits(w) " x " groupDigits(h) " (" Round(w/h, 2) ")`nSelection area: " groupDigits(imgSelW) " x " groupDigits(imgSelH) " (" Round(imgSelW/imgSelH, 2) ")"
   } Else
   {
      w := vPimgSelW , h := vPimgSelH
      If InStr(friendly, "user painted")
         trGdip_GetImageDimensions(userAlphaMaskBmpPainted, w, h)
      Else If InStr(friendly, "main image")
         trGdip_GetImageDimensions(useGdiBitmap(), w, h)
      Else If InStr(friendly, "transformed")
         trGdip_GetImageDimensions(userClipBMPpaste, w, h)

      thisIDu := "a" alphaMaskingMode alphaMaskColorReversed userAlphaMaskBmpPainted ImgSelW ImgSelH VPselRotation zoomLevel userPrevAlphaMaskBmpPainted
      transformTool := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
      alphaMaskGray := generateAlphaMaskBitmap(0, 1, zw, zh, 0, 0, thisIDu, 1, transformTool)
      msg := "Alpha mask type: " friendly "`nDimensions: " groupDigits(w) " x " groupDigits(h) " (" Round(w/h, 2) ")`nSelection dimensions: " groupDigits(imgSelW) " x " groupDigits(imgSelH) " (" Round(imgSelW / imgSelH, 2) ")"
      If validBMP(alphaMaskGray)
      {
         vpWinClientSize(mainWidth, mainHeight)
         thisu := ((objSel.sw != objSel.dh || objSel.sh != objSel.dh) && objSel.invertArea=0) ? 0 : 0
         If ((!isSelEntirelyWithinIMGbounds() || !isSelEntireVisible(mainWidth, mainHeight)) && objSel.invertArea=0 || objSel.invertArea=1 || thisu=1)
         {
            thisAlphaBitmap := getRectFromBitmap(alphaMaskGray, objSel, 1)
            If validBMP(thisAlphaBitmap)
               alphaMaskGray := thisAlphaBitmap
         }

         trGdip_DrawImage(A_ThisFunc, 2NDglPG, alphaMaskGray, vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH,,,,, clrMatrix)
         ; trGdip_DisposeImage(alphaMaskGray)
         If (dummy!="live" && !AnyWindowOpen)
            generateAlphaMaskBitmap("kill", 0)
         Else
            toolTipGuiCreated := 2
      }
   }
   ; ToolTip, % vPimgSelX "|" vPimgSelY "|" vPimgSelW "|" vPimgSelH , , , 2
   If (dummy!="live")
   {
      If pPath
      {
         ; thisBrush := createHatchBrush(1)
         Gdip_FillPath(2NDglPG, GDIPbrushHatch, pPath)
         ; Gdip_DeleteBrush(thisBrush)
      }

      Gdip_ResetWorldTransform(2NDglPG)
      BoxBMP := drawTextInBox(msg, OSDFontName, OSDfontSize, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0, 0)
      trGdip_DrawImage(A_ThisFunc, 2NDglPG, BoxBMP, 0, 0)
      trGdip_DisposeImage(BoxBMP, 1)
   }
   If pPath
      Gdip_DeletePath(pPath)
   ; Gdip_DisposeEffect(pEffectGray)
}

livePreviewFillBehindArea(modus:=0) {
   If (modus="kill")
   {
      getImgOriginalSelectedAreaEdit("kill", 0, 0, 0, 0, 0, 0, 0)
      Return
   }

   If (doImgEditLivePreview!=1 || testSelectOutsideImgEntirely(useGdiBitmap()) || FillBehindInvert=0 && imgSelOutViewPort=1)
      Return

   vpWinClientSize(mainWidth, mainHeight)
   trGdip_GetImageDimensions(useGdiBitmap(), thisW, thisH)
   objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, thisW, thisH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   ; pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH, FillAreaShape, VPselRotation, rotateSelBoundsKeepRatio)
   pPath := VPcreateSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, VPselRotation, 1, mainWidth, mainHeight, 0)
   tx := (imgSelPx > prevDestPosX) ? prevDestPosX : max(imgSelPx, prevDestPosX)
   ty := (imgSelPy > prevDestPosY) ? prevDestPosY : max(imgSelPy, prevDestPosY)
   twx := ((imgSelPx + imgSelW) > (prevDestPosX + prevResizedVPimgW)) ? prevDestPosX + prevResizedVPimgW : max(imgSelPx + imgSelW, prevDestPosX + prevResizedVPimgW)
   twy := ((imgSelPy + imgSelH) > (prevDestPosY + prevResizedVPimgH)) ? prevDestPosY + prevResizedVPimgH : max(imgSelPy + imgSelH, prevDestPosY + prevResizedVPimgH)
   If (FillBehindInvert=1)
   {
      invertPath := Gdip_ClonePath(pPath)
      Gdip_AddPathRectangle(invertPath, tx, ty, twx - tx, twy - ty)
      whichPath := invertPath
      getClampedVPimgBounds(imgSelPx, imgSelPy, kX, kY, imgSelW, imgSelH)
   } Else
   {
      whichPath := pPath
      getClampedVPselToWindow(1, mainWidth, mainHeight, thisW, thisH, imgSelPx, imgSelPy, imgSelW, imgSelH)
   }

   mu := (FillBehindInvert=1) ? 1 : 2
   If (imgSelOutViewPort!=1 || FillBehindInvert=1)
      pBitmap := getImgOriginalSelectedAreaEdit(mu, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, 1)

   thisColorA := makeRGBAcolor(FillBehindColor, FillBehindClrOpacity)
   thisBrush := Gdip_BrushCreateSolid(thisColorA)
   Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
   If validBMP(pBitmap)
   {
      ; If (FillBehindOpacity<254 || FillBehindClrOpacity<254 || FillBehindInvert=1)
      If (FillBehindInvert!=1)
      {
         tx := clampInRange(imgSelPx, 0, mainWidth)
         ty := clampInRange(imgSelPy, 0, mainWidth)
         twx := clampInRange(imgSelPx + imgSelW, 0, mainWidth) - tx
         twy := clampInRange(imgSelPy + imgSelH, 0, mainWidth) - ty
         Gdip_FillRectangle(2NDglPG, GDIPbrushHatch, tx, ty, twx, twy)
      } Else
         Gdip_FillRectangle(2NDglPG, GDIPbrushHatch, tx, ty, twx, twy)

      If (userimgGammaCorrect=1)
         Gdip_SetCompositingQuality(2NDglPG, 2)

      thisOpacity := FillBehindOpacity/255
      Gdip_FillPath(2NDglPG, thisBrush, whichPath)
      modus := (FillBehindInvert=1) ? 4 : 0
      ; Gdip_SetClipPath(2NDglPG, pPath, modus)
      ; trGdip_GetImageDimensions(pBitmap, w, h)
      ; ToolTip, % w "|" h "`n" imgSelW "|" imgSelH , , , 2
      trGdip_DrawImage(A_ThisFunc, 2NDglPG, pBitmap, imgSelPx, imgSelPy, , , , , , , thisOpacity)
      If (userimgGammaCorrect=1)
         Gdip_SetCompositingQuality(2NDglPG, 1)

      Gdip_ResetClip(2NDglPG)
      trGdip_DisposeImage(pBitmap)
   }
   Gdip_DeletePath(pPath)
   Gdip_DeletePath(invertPath)
   Gdip_DeleteBrush(thisBrush)
   ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
}

getImgOriginalSelectedAreaEdit(doInvert, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, allowFX) {
   Static prevBMP, prevState
   If (doInvert="kill")
   {
      trGdip_DisposeImage(prevBMP, 1)
      prevBMP := prevState := ""
      Return
   }

   fx := (allowFX=1) ? getIDvpFX() : "a"
   thisState := "a" mainWidth mainHeight zoomLevel prevResizedVPimgW prevResizedVPimgH prevDestPosX prevDestPosY IMGresizingMode imageAligned fx useGdiBitmap() currentUndoLevel undoLevelsRecorded vpIMGrotation
   ; thisState := "a" imgSelPx imgSelPy imgSelW imgSelH mainWidth mainHeight zoomLevel thisu doInvert IMGresizingMode imageAligned fx useGdiBitmap() currentUndoLevel undoLevelsRecorded prevDestPosX prevDestPosY
   If (prevState!=thisState || !validBMP(prevBMP))
   {
      fnOutputDebug("redraw: " A_ThisFunc)
      If validBMP(prevBMP)
         trGdip_DisposeImage(prevBMP, 1)

      mainBMP := useGdiBitmap()
      MouseCoords2Image(1, 1, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, xa, ya)
      MouseCoords2Image(mainWidth, mainHeight, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, xb, yb)
      nnw := clampInRange(xb - xa, 3, xb)
      nnh := clampInRange(yb - ya, 3, yb)
      pBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, mainBMP, xa, ya, nnw, nnh, 0, 0, 1)
      If (allowFX=1)
         pBitmap := applyVPeffectsOnBMP(pBitmap)

      nnw := Round(nnw * zoomLevel),       nnh := Round(nnh * zoomLevel)
      nnw := clampInRange(nnw, 3, 23000)
      nnh := clampInRange(nnh, 3, 23000)
      pBitmap := resizeBitmapToGivenRef(pBitmap, 0, nnw, nnh, 5, 0)
      prevBMP := validBMP(pBitmap) ? trGdip_CloneBitmap(A_ThisFunc, pBitmap) : ""
      prevState := validBMP(prevBMP) ? thisState : 0
      ; fnOutputDebug(A_ThisFunc "(recache): " imgSelW "=" imgSelH "`n" nnw "=" nnh)
   } Else If validBMP(prevBMP)
      pBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMP)

   If (doInvert=1)
   {
      Return pBitmap
   } Else
   {
      tx := (prevDestPosX>0) ? imgSelPx - prevDestPosX : imgSelPx
      ty := (prevDestPosY>0) ? imgSelPy - prevDestPosY : imgSelPy
      zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, pBitmap, tx, ty, imgSelW, imgSelH, 0, 0, 1)
      ; fnOutputDebug(A_ThisFunc "(cached): " imgSelW "=" imgSelH "`n" tx "=" ty)
      If validBMP(zBitmap)
      {
         trGdip_DisposeImage(pBitmap)
         Return zBitmap
      }
   }

   Return pBitmap
}

PasteInPlaceEraseArea(G2, mode) {
      If (mode=1)
      {
         imgSelPx := x1 := prevSelDotX + SelDotsSize//2, x2 := prevSelDotAx + SelDotsSize//2
         imgSelPy := y1 := prevSelDotY + SelDotsSize//2, y2 := prevSelDotAy + SelDotsSize//2
         imgSelW := max(X1, X2) - min(X1, X2)
         imgSelH := max(Y1, Y2) - min(Y1, Y2)
      } Else
      {
         trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
         calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 1)
      }

      If (viewportQPVimage.imgHandle)
         pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, oldSelectionArea[5], oldSelectionArea[6], oldSelectionArea[7], 0, 1, 1, oldSelectionArea[8], oldSelectionArea[9])
      Else
         pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, prevEllipseSelectMode, prevVPselRotation, prevrotateSelBoundsKeepRatio, 0, 1, 1, previnnerSelectionCavityX, previnnerSelectionCavityY)

      If (mode=1)
      {
         If pPath
         {
            If (viewportQPVimage.imgHandle)
            {
               black := makeRGBAcolor("010101", 255 - thisOpacity)
               bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
               If (bpp<32)
               {
                  hasFilled := 1
                  blackBrush := Gdip_BrushCreateSolid(black)
                  Gdip_FillPath(G2, blackBrush, pPath)
                  Gdip_DeleteBrush(blackBrush)
               }
            }

            If !hasFilled
               Gdip_FillPath(G2, GDIPbrushHatch, pPath)
         }
      } Else
      {
         If pPath
            Gdip_SetClipPath(G2, pPath)
         trGdip_GraphicsClear(A_ThisFunc, G2)
         Gdip_ResetClip(G2)
      }

      Gdip_DeletePath(pPath)
}

WriteSettingsBlurPanel() {
    ReadSettingsBlurPanel(1)
}

WriteSettingsZoomBlurPanel() {
    ReadSettingsZoomBlurPanel(1)
}

ReadSettingsZoomBlurPanel(act:=0) {
    RegAction(act, "zoomBlurMode",, 2, 1, 3)
    RegAction(act, "BlurAreaAlphaMask",, 1)
    RegAction(act, "blurAreaOpacity",, 2, 3, 255)
    RegAction(act, "BlurAreaInverted",, 1)
    RegAction(act, "BlurAreaBlendMode",, 2, 1, 24)
    RegAction(act, "BlurAreaGamma",, 2, -100, 100)
    RegAction(act, "BlurAreaHue",, 2, -180, 180)
    RegAction(act, "BlurAreaLight",, 2, -255, 255)
    RegAction(act, "BlurAreaSaturation",, 2, -100, 100)
    RegAction(act, "uiZoomBlurAreaXamount",, 2, 1, 254)
}

ReadSettingsBlurPanel(act:=0) {
    RegAction(act, "BlurAreaGamma",, 2, -100, 100)
    RegAction(act, "BlurAreaHue",, 2, -180, 180)
    RegAction(act, "BlurAreaLight",, 2, -255, 255)
    RegAction(act, "BlurAreaSaturation",, 2, -100, 100)
    RegAction(act, "blurAreaAmount",, 2, 0, 255)
    RegAction(act, "blurAreaYamount",, 2, 0, 255)
    RegAction(act, "blurAreaEqualXY",, 1)
    RegAction(act, "blurAreaMode",, 2, 1, 8)
    RegAction(act, "blurAreaPixelizeAmount",, 2, 0, 6789)
    RegAction(act, "blurAreaPixelizeMethod",, 2, 1, 3)
    RegAction(act, "blurAreaOpacity",, 2, 3, 255)
    RegAction(act, "BlurAreaInverted",, 1)
    RegAction(act, "blurAreaSoftEdges",, 1)
    RegAction(act, "blurAreaSoftLevel",, 2, 1, 6)
    RegAction(act, "BlurAreaBlendMode",, 2, 1, 24)
    RegAction(act, "blurAreaTwice",, 1)
    RegAction(act, "BlurAreaAlphaMask",, 1)
    RegAction(act, "blurAreaApplyFX",, 1)
}

PanelZoomBlurSelectedArea() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(69, A_ThisFunc)
    ReadSettingsZoomBlurPanel()
    btnWid := 75
    txtWid := 266
    EditWid := 60
    thisW := 130
    If (PrefsLargeFonts=1)
    {
       EditWid += 50
       btnWid += 40
       txtWid += 100
       thisW += 50
       Gui, Font, s%LargeUIfontValue%
    }

    Global infoBlurAmount
    If !testAllowSelInvert()
       BlurAreaInverted := 0

    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    tinyPrevAreaCoordX := !isNumber(tinyPrevAreaCoordX) ? imgW/2 : clampInRange(tinyPrevAreaCoordX, 0, imgW)
    tinyPrevAreaCoordY := !isNumber(tinyPrevAreaCoordY) ? imgH/2 : clampInRange(tinyPrevAreaCoordY, 0, imgH)
    friendly := (isWinXP=1) ? " (unsupported)" : ""
    gH := gW := (PrefsLargeFonts=1) ? 385 : 330
    If (isWinXP=1 || A_OSVersion="WIN_7")
       gH := gH//1.2

    ; gH := (PrefsLargeFonts=1) ? 640 : 540
    Gui, -DPIScale
    Gui, Font
    Gui, Add, Text, x20 y20 w%gW% h%gH% Section -Border +0xE gUIresponderPanelsLivePreview +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click in the viewport to set the origin for the zoom.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%
    Gui, +DPIScale

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "None"
    If (coreDesiredPixFmt="0x21808")
       BlurAreaBlendMode := 1

    infoMask := defineCurrentAlphaMask()
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       BlurAreaAlphaMask := 0

    Gui, Add, Tab3, %tabzDarkModus% x+20 ys gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Color options
    Gui, Tab, 1
    Gui, Add, Text, x+10 y+10 w%thisW% Section +hwndhTemp, Blur mode: 
    GuiAddDropDownList("x+5 wp gupdateUIzoomBlurPanel AltSubmit Choose" zoomBlurMode " vzoomBlurMode", "Zoom H/V|Horizontal|Vertical", [hTemp])
    GuiAddSlider("uiZoomBlurAreaXamount", 1,254, 15, "Intensity", "updateUIzoomBlurPanel", 1, "xs y+10 w" txtWid " hp")
    GuiAddSlider("blurAreaOpacity", 3,255, 255, "Opacity", "updateUIzoomBlurPanel", 1, "xs y+10 w" txtWid " hp")
    Gui, Add, Checkbox, xs y+10 Checked%BlurAreaAlphaMask% vBlurAreaAlphaMask gupdateUIzoomBlurPanel, Apply alpha mas&k
    Gui, Add, Checkbox, xs y+10 Checked%BlurAreaInverted% vBlurAreaInverted gupdateUIzoomBlurPanel, &Invert selection area
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       GuiControl, Disable, BlurAreaAlphaMask

    If !testAllowSelInvert()
       GuiControl, Disable, BlurAreaInverted

    Gui, Tab, 2
    Gui, Add, Text, x+10 y+10 Section w%thisW% gBtnResetBlendMode +TabStop +hwndhTemp, Blending mode: 
    GuiAddDropDownList("x+5 wp-27 gupdateUIzoomBlurPanel AltSubmit Choose" BlurAreaBlendMode " vBlurAreaBlendMode", infoBlend "|" userBlendModesList, [hTemp])
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIzoomBlurPanel")
    Gui, Add, Checkbox, xs y+10 Checked%BlurAreaApplyFX% vBlurAreaApplyFX gupdateUIzoomBlurPanel, &Apply color adjustments
    GuiAddSlider("BlurAreaHue", -180,180, 0, "Hue: $€°", "updateUIzoomBlurPanel", 2, "xs y+10 w" txtWid " hp")
    GuiAddSlider("BlurAreaSaturation", -100,100, 0, "Saturation", "updateUIzoomBlurPanel", 2, "xs y+10 wp hp")
    GuiAddSlider("BlurAreaLight", -255,255, 0, "Brightness", "updateUIzoomBlurPanel", 2, "xs y+10 wp hp")
    GuiAddSlider("BlurAreaGamma", -100,100, 0, "Contrast", "updateUIzoomBlurPanel", 2, "xs y+10 wp hp")

    Gui, Tab
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnZoomBlurSelectedArea, &Proceed
    Gui, Add, Button, x+6 hp wp gOpenPanelBlur, &Gaussian
    Gui, Add, Button, x+6 hp wp gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Radial blur in selected area: " appTitle, winPos)
    SetTimer, updateUIzoomBlurPanel, -100
}

OpenPanelBlur() {
   BtnCloseWindow()
   PanelBlurSelectedArea()
}

PanelPixelizeSelectedArea() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(78, A_ThisFunc)
    ReadSettingsBlurPanel()
    btnWid := 89
    txtWid := 280
    EditWid := 60
    thisW := 190
    If (PrefsLargeFonts=1)
    {
       EditWid += 50
       btnWid += 40
       txtWid += 105
       thisW += 70
       Gui, Font, s%LargeUIfontValue%
    }

    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125
    friendly := (isWinXP=1) ? " (unsupported)" : ""
    gW := (PrefsLargeFonts=1) ? 385 : 325
    gH := (PrefsLargeFonts=1) ? 505 : 390
    If (isWinXP=1 || A_OSVersion="WIN_7")
       gH := gH//1.75

    Gui, Font
    Gui, -DPIScale
    Gui, Add, Text, x20 y20 w%gW% h%gH% Section -Border +0xE gUIresponderPanelsLivePreview +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag to change the preview area, or in the viewport.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "None"
    If (coreDesiredPixFmt="0x21808")
       BlurAreaBlendMode := 1

    infoMask := defineCurrentAlphaMask()
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none") || viewportQPVimage.imgHandle)
       BlurAreaAlphaMask := 0
    If !testAllowSelInvert()
       BlurAreaInverted := 0

    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    mpxu := Round((imgW * imgH)/1000000, 1)
    maxu := (mpxu > 530) ? 2048 : 1024
    If (mpxu > 5250)
       maxu := 6785
    Else If (mpxu > 4250)
       maxu := 5630
    Else If (mpxu > 2250)
       maxu := 4315
    Else If (mpxu > 1250)
       maxu := 3000

    Gui, +DPIScale
    Gui, Add, Tab3, %tabzDarkModus% x+20 ys gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Color options
    Gui, Tab, 1
    Gui, Add, Text, x+10 y+10 Section w%thisW%, Pixelization mode:
    listu := (viewportQPVimage.imgHandle) ? "Rescale (Nearest neighbour)|Rescale (Bicubic)|Rescale (Bilinear)" : "Loose fitting|Rescale (Nearest neighbour)|Rescale (Bicubic)"
    GuiAddDropDownList("xs y+10 wp AltSubmit Choose" blurAreaPixelizeMethod " gupdateUIblurPanel vblurAreaPixelizeMethod", listu)
    GuiAddSlider("blurAreaPixelizeAmount", 0,maxu, 15, "Pixelize amount: $€", "updateUIblurPanel", 1, "xs y+10 wp hp")
    GuiAddSlider("blurAreaAmount", 0,255, 0, "Blur radius: $€", "updateUIblurPanel", 1, "xs y+10 wp hp")
    GuiAddSlider("blurAreaOpacity", 3,255, 255, "Opacity", "updateUIblurPanel", 1, "xs y+10 wp hp")
    Gui, Add, Checkbox, xs y+10 wp Checked%BlurAreaAlphaMask% vBlurAreaAlphaMask gupdateUIblurPanel, Apply alpha mas&k
    Gui, Add, Checkbox, xs y+10 wp Checked%BlurAreaInverted% vBlurAreaInverted gupdateUIblurPanel, &Invert selection area
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none") || viewportQPVimage.imgHandle)
       GuiControl, Disable, BlurAreaAlphaMask

    If !testAllowSelInvert()
       GuiControl, Disable, BlurAreaInverted

    Gui, Tab, 2
    sml := (PrefsLargeFonts=1) ? 30 : 20
    Gui, Add, Text, x+10 y+10 Section w%thisW% gBtnResetBlendMode +TabStop, Blending mode: 
    GuiAddDropDownList("xs y+10 wp" - sml*2 " gupdateUIblurPanel AltSubmit Choose" BlurAreaBlendMode " vBlurAreaBlendMode", infoBlend "|" userBlendModesList)
    GuiAddFlipBlendLayers("x+1 hp w" sml " gupdateUIblurPanel")
    GuiAddCheckbox("x+1 hp wp gupdateUIblurPanel Checked" BlendModesPreserveAlpha " vBlendModesPreserveAlpha", "Protect alpha channel", "P",, "Preserve the alpha channel of the background`nimage unaltered by blend modes")
    Gui, Add, Checkbox, xs y+10 Checked%BlurAreaApplyFX% vBlurAreaApplyFX gupdateUIblurPanel, &Apply color adjustments
    If (viewportQPVimage.imgHandle)
       thisW -= sml

    GuiAddSlider("BlurAreaHue", -180,180, 0, "Hue: $€°", "updateUIblurPanel", 2, "xs y+10 w" thisW " hp")
    If (viewportQPVimage.imgHandle)
       GuiAddCheckbox("x+1 hp+1 w" sml " Checked" userImgAdjustInvertColors " vuserImgAdjustInvertColors", "Invert colors", "I")
    GuiAddSlider("BlurAreaSaturation", -100,100, 0, "Saturation", "updateUIblurPanel", 2, "xs y+10 w" thisW " hp")
    If (viewportQPVimage.imgHandle)
       GuiAddCheckbox("x+1 hp+1 w" sml " Checked" userImgAdjustAltSat " vuserImgAdjustAltSat", "Alternate saturation adjustment mode", "A")
    GuiAddSlider("BlurAreaLight", -255,255, 0, "Brightness", "updateUIblurPanel", 2, "xs y+10 w" thisW " hp")
    If (viewportQPVimage.imgHandle)
       GuiAddCheckbox("x+1 hp+1 w" sml " Checked" userImgAdjustAltBright " vuserImgAdjustAltBright", "Alternate brightness adjustment mode", "A")
    GuiAddSlider("BlurAreaGamma", -100,100, 0, "Contrast", "updateUIblurPanel", 2, "xs y+10 w" thisW " hp")

    Gui, Tab
    Gui, Add, Button, xs+0 y+10 h%thisBtnHeight% Default w%btnWid% gBtnPixelizeSelectedArea, &Pixelize area
    Gui, Add, Button, x+6 hp wp-15 gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Pixelize selected area: " appTitle, winPos)
    SetTimer, updateUIblurPanel, -100
}

PanelBlurSelectedArea() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(26, A_ThisFunc)
    ReadSettingsBlurPanel()
    btnWid := 75
    txtWid := 280
    EditWid := 60
    thisW := 135
    If (PrefsLargeFonts=1)
    {
       EditWid += 50
       btnWid += 40
       txtWid += 105
       thisW += 50
       Gui, Font, s%LargeUIfontValue%
    }

    If !testAllowSelInvert()
    {
       blurAreaSoftEdges := 0
       BlurAreaInverted := 0
    }

    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125
    If (isWinXP=1 && blurAreaMode=1)
    {
       blurAreaMode := 2
       blurAreaSoftEdges := 0
    }
    
    If (coreDesiredPixFmt="0x21808")
       blurAreaSoftEdges := 0

    friendly := (isWinXP=1) ? " (unsupported)" : ""
    gW := (PrefsLargeFonts=1) ? 385 : 325
    gH := (PrefsLargeFonts=1) ? 520 : 395
    If (isWinXP=1 || A_OSVersion="WIN_7")
       gH := gH//1.75

    Gui, Font
    Gui, -DPIScale
    Gui, Add, Text, x20 y20 w%gW% h%gH% Section -Border +0xE gUIresponderPanelsLivePreview +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag to change the preview area, or in the viewport.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "None"
    If (coreDesiredPixFmt="0x21808")
       BlurAreaBlendMode := 1

    infoMask := defineCurrentAlphaMask()
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none") || viewportQPVimage.imgHandle)
       BlurAreaAlphaMask := 0

    If (!testAllowSelInvert() || viewportQPVimage.imgHandle)
       BlurAreaInverted := 0

    Global mainBtnACT
    Gui, +DPIScale
    Gui, Add, Tab3, %tabzDarkModus% x+20 ys gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Color options
    Gui, Tab, 1
    Gui, Add, Checkbox, x+10 y+10 w%thisW% Section Checked%blurAreaSoftEdges% vblurAreaSoftEdges gupdateUIblurPanel +hwndhTemp, &Soft edges%friendly%
    GuiAddDropDownList("x+5 w60 AltSubmit Choose" blurAreaSoftLevel " gupdateUIblurPanel vblurAreaSoftLevel", "0.3x|0.6x|1x|2x|3x|4x", "Edges softness level")
    Gui, Add, Checkbox, xs y+5 hp Checked%blurAreaTwice% vblurAreaTwice gupdateUIblurPanel, &Blur twice in one go (for large images)
    Gui, Add, Text, xs y+15 w%thisW% hp +0x200 -wrap +hwndhTemp, Blur mode:
    GuiAddDropDownList("x+5 wp AltSubmit Choose" blurAreaMode " gupdateUIblurPanel vblurAreaMode", "Gaussian (GDI+)" friendly "|Gaussian (cImg)|Box blur|Dilate|Erode|Open|Close|Dissolve", [hTemp])
    GuiAddSlider("blurAreaAmount", 0,255, 25, "Blur X: $€", "updateUIblurPanel", 1, "xs y+5 w" txtWid " hp")
    GuiAddSlider("blurAreaYamount", 0,255, 25, "Blur Y: $€", "updateUIblurPanel", 1, "xs y+5 w" txtWid " hp")
    Gui, Add, Checkbox, xs y+10 w%thisW% hp Checked%blurAreaEqualXY% vblurAreaEqualXY gupdateUIblurPanel, &Equal X/Y
    Gui, Add, Checkbox, x+5 hp Checked%blurAreaCircular% vblurAreaCircular gupdateUIblurPanel, Circular (SLOW)
    Gui, Add, Checkbox, xs y+5 hp w%thisW% Checked%BlurAreaInverted% vBlurAreaInverted gupdateUIblurPanel, &Invert selection
    Gui, Add, Checkbox, x+5 hp Checked%BlurAreaAlphaMask% vBlurAreaAlphaMask gupdateUIblurPanel, Apply alpha mas&k

    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none") || viewportQPVimage.imgHandle)
       GuiControl, Disable, BlurAreaAlphaMask
    If (viewportQPVimage.imgHandle)
       GuiControl, Disable, BlurAreaInverted

    If !testAllowSelInvert()
    {
       GuiControl, Disable, BlurAreaInverted
       GuiControl, Disable, blurAreaSoftEdges
       GuiControl,, BlurAreaInverted, 0
       GuiControl,, blurAreaSoftEdges, 0
    }

    Gui, Tab, 2
    Gui, Add, Text, x+10 y+10 Section w%thisW% gBtnResetBlendMode +TabStop +hwndhTemp, Blending mode: 
    GuiAddDropDownList("x+5 wp-25 gupdateUIblurPanel AltSubmit Choose" BlurAreaBlendMode " vBlurAreaBlendMode", infoBlend "|" userBlendModesList, [hTemp])
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIblurPanel")
    Gui, Add, Checkbox, xs y+10 Checked%BlurAreaApplyFX% vBlurAreaApplyFX gupdateUIblurPanel, &Apply color adjustments
    GuiAddSlider("blurAreaOpacity", 3,255, 255, "Opacity", "updateUIblurPanel", 1, "xs y+15 w" txtWid - 27 " hp")
    GuiAddCheckbox("x+1 hp w26 gupdateUIblurPanel Checked" BlendModesPreserveAlpha " vBlendModesPreserveAlpha", "Protect alpha channel", "P",, "Preserve the alpha channel of the background`nimage unaltered by blend modes")
    GuiAddSlider("BlurAreaHue", -180,180, 0, "Hue: $€°", "updateUIblurPanel", 2, "xs y+15 w" txtWid " hp")
    GuiAddSlider("BlurAreaSaturation", -100,100, 0, "Saturation", "updateUIblurPanel", 2, "xs y+10 wp hp")
    GuiAddSlider("BlurAreaLight", -255,255, 0, "Brightness", "updateUIblurPanel", 2, "xs y+10 wp hp")
    GuiAddSlider("BlurAreaGamma", -100,100, 0, "Contrast", "updateUIblurPanel", 2, "xs y+10 wp hp")

    Gui, Tab
    Gui, Add, Button, xs+0 y+10 h%thisBtnHeight% Default w%btnWid% gBtnBlurSelectedArea vmainBtnACT, &Proceed
    Gui, Add, Button, x+6 hp wp gOpenPanelZoomBlur, &Radial blur
    Gui, Add, Button, x+6 hp wp gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Blur selected area: " appTitle, winPos)
    SetTimer, updateUIblurPanel, -100
}

OpenPanelZoomBlur() {
   BtnCloseWindow()
   PanelZoomBlurSelectedArea()
}

WriteSettingsEdgesPanel() {
    ReadSettingsEdgesPanel(1)
}

WriteSettingsAddNoisePanel() {
    ReadSettingsAddNoisePanel(1)
}

WriteSettingsSymmetricaPanel() {
    ReadSettingsSymmetricaPanel(1)
}

ReadSettingsSymmetricaPanel(act:=0) {
    RegAction(act, "UserSymmetricaMode",, 2, 1, 4)
    RegAction(act, "UserSymmetricaOpacity",, 2, 3, 255)
    RegAction(act, "UserSymmetricaSrcFlipX",, 1)
    RegAction(act, "UserSymmetricaSrcFlipY",, 1)
    RegAction(act, "UserSymmetricaSrcAlign",, 2, 1, 2)
    RegAction(act, "UserSymmetricaSrcRotated",, 1)
    RegAction(act, "UserSymmetricaScaleX",, 2, 1, 200)
    RegAction(act, "UserSymmetricaScaleY",, 2, 1, 200)
    RegAction(act, "UserSymmetricaSelAligned",, 1)
    RegAction(act, "UserSymmetricaSelOffX",, 2, 0, 200)
    RegAction(act, "UserSymmetricaSelOffY",, 2, 0, 200)
    RegAction(act, "UserSymmetricaUseAlpha",, 1)
    RegAction(act, "UserSymmetricaInvertArea",, 1)
    RegAction(act, "UserSymmetricaBlendMode",, 2, 1, 23)
    RegAction(act, "blurAreaApplyFX",, 1)
}

ReadSettingsEdgesPanel(act:=0) {
    RegAction(act, "IDedgesOpacity",, 2, 3, 255)
    RegAction(act, "IDedgesEmphasis",, 2, -255, 255)
    RegAction(act, "IDedgesContrast",, 2, -100, 100)
    RegAction(act, "IDedgesBlendMode",, 2, 1, 23)
    RegAction(act, "IDedgesCenterAmount",, 2, 1, 6)
    RegAction(act, "IDedgesXuAmount",, 2, 1, 7)
    RegAction(act, "IDedgesYuAmount",, 2, 1, 7)
    RegAction(act, "IDedgesAfterBlur",, 2, 1, 5)
    RegAction(act, "IDedgesEmbossLvl",, 2, 1, 6)
    RegAction(act, "IDedgesInvert",, 1)
}

ReadSettingsAddNoisePanel(act:=0) {
    RegAction(act, "IDedgesOpacity",, 2, 3, 255)
    RegAction(act, "IDedgesEmphasis",, 2, -255, 255)
    RegAction(act, "IDedgesContrast",, 2, -100, 100)
    RegAction(act, "IDedgesInvert",, 1)
    RegAction(act, "IDedgesBlendMode",, 2, 1, 23)
    RegAction(act, "UserAddNoiseGrays",, 1)
    RegAction(act, "UserAddNoiseIntensity",, 2, 1, 100)
    RegAction(act, "UserAddNoiseTransparent",, 1)
    RegAction(act, "UserAddNoiseDetails",, 2, 1, 100)
    RegAction(act, "UserAddNoiseBlurAmount",, 2, 0, 255)
    RegAction(act, "UserAddNoisePixelizeAmount",, 2, 0, 1024)
    RegAction(act, "UserAddNoiseMode",, 2, 1, 3)
    RegAction(act, "BlurAreaAlphaMask",, 1)
    RegAction(act, "blurAreaEqualXY",, 1)
    RegAction(act, "blurAreaYamount",, 2, 0, 255)
}

PanelDetectEdgesImage() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(43, A_ThisFunc)
    ReadSettingsEdgesPanel()
    btnWid := 100
    txtWid := 265
    thisW := 100
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 53
       Gui, Font, s%LargeUIfontValue%
    }

    2ndcol := (PrefsLargeFonts=1) ? 155 : 130
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125
    gW := (PrefsLargeFonts=1) ? 385 : 330
    gH := (PrefsLargeFonts=1) ? 580 : 435
    If (isWinXP=1 || A_OSVersion="WIN_7")
       gH := gH//1.7

    Gui, -DPIScale
    Gui, Font
    Gui, Add, Text, x20 y20 w%gW% h%gH% Section -Border +0xE gUIresponderPanelsLivePreview +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag to change the preview area, or click in the viewport.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    thisW := (PrefsLargeFonts=1) ? 68 : 48
    Gui, +DPIScale
    Gui, Add, Text, x+20 ys Section, Direction of edge detection:
    Gui, Add, Text, xs y+10 w%thisW%, X
    Gui, Add, Text, x+3 wp, Y
    Gui, Add, Text, x+3 wp, C
    Gui, Add, Text, x+3 wp -wrap vtxtLine1, Iterations
    GuiAddDropDownList("xs y+7 w" thisW " gupdateUIedgesPanel AltSubmit Choose" IDedgesXuAmount " vIDedgesXuAmount", "-3|-2|-1|0|1|2|3", "X offset")
    GuiAddDropDownList("x+3 wp gupdateUIedgesPanel AltSubmit Choose" IDedgesYuAmount " vIDedgesYuAmount", "-3|-2|-1|0|1|2|3", "Y offset")
    GuiAddDropDownList("x+3 wp gupdateUIedgesPanel AltSubmit Choose" IDedgesCenterAmount " vIDedgesCenterAmount", "0|1|2|3|4|5", "C offset")
    GuiAddDropDownList("x+3 wp gupdateUIedgesPanel AltSubmit Choose" IDedgesEmbossLvl " vIDedgesEmbossLvl", "1|2|3|4|5|6", "Emboss amount")
    If !testAllowSelInvert()
       BlurAreaInverted := 0

    GuiAddSlider("IDedgesEmphasis", -255,255, 0, "Brightness", "updateUIedgesPanel", 2, "xs y+10 w" txtWid " hp")
    GuiAddSlider("IDedgesContrast", -100,100, 0, "Contrast", "updateUIedgesPanel", 2, "xs y+10 wp hp")
    GuiAddSlider("IDedgesOpacity", 3,255, 255, "Opacity", "updateUIedgesPanel", 1, "xs y+10 wp hp")
    Gui, Add, Checkbox, xs y+10 w%2ndcol% hp gupdateUIedgesPanel Checked%IDedgesInvert% vIDedgesInvert, &Invert image
    GuiAddDropDownList("x+5 wp AltSubmit gupdateUIedgesPanel Choose" IDedgesAfterBlur " vIDedgesAfterBlur", "No blur|4|6|8|10", "Blur level")
    Gui, Add, Text, xs y+10 wp hp +0x200 -wrap gBtnResetEdgesBlendMode +TabStop, Blending mode:
    GuiAddDropDownList("x+5 wp-27 gupdateUIedgesPanel AltSubmit Choose" IDedgesBlendMode " vIDedgesBlendMode", "None|" userBlendModesList)
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIedgesPanel")
    Gui, Add, Checkbox, xs y+10 hp gupdateUIedgesPanel Checked%BlurAreaInverted% vBlurAreaInverted, Invert &selection area
    If !testAllowSelInvert()
       GuiControl, Disable, BlurAreaInverted

    thisW := (PrefsLargeFonts=1) ? 90 : 65
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default gBtnIDedgesNow w%btnWid%, &Process image
    Gui, Add, Button, x+5 hp w%thisW% gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Detect edges in selected area: " appTitle, winPos)
    SetTimer, updateUIedgesPanel, -200
}

BtnUIpresetsClouds() {
   Gui, SettingsGUIA: Default
   GuiControlGet, UserAddNoiseMode
   uiSlidersArray["UserAddNoiseIntensity", 14] := 1
   uiSlidersArray["blurAreaYamount", 14] := 1
   uiSlidersArray["UserAddNoiseDetails", 14] := 1
   uiSlidersArray["IDedgesContrast", 14] := 1
   uiSlidersArray["IDedgesEmphasis", 14] := 1
   uiSlidersArray["IDedgesOpacity", 14] := 1
   uiSlidersArray["UserAddNoiseBlurAmount", 14] := 1
   uiSlidersArray["UserAddNoisePixelizeAmount", 14] := 1

   If (UserAddNoiseMode!=3)
   {
      GuiControl, SettingsGUIA:, blurAreaEqualXY, 1
      GuiControl, SettingsGUIA:, UserAddNoiseGrays, 1
      GuiControl, SettingsGUIA:, UserAddNoiseTransparent, 0
      GuiControl, SettingsGUIA: Choose, UserAddNoiseMode, 3
      GuiControl, SettingsGUIA: Choose, IDedgesBlendMode, 1
      UserAddNoiseIntensity := 30
      UserAddNoiseDetails := 80
      IDedgesInvert := 0
      IDedgesEmphasis := 35
      IDedgesContrast := 25
      IDedgesOpacity := 255
      UserAddNoisePixelizeAmount := 55
      UserAddNoiseBlurAmount := 40
   } Else
   {
      GuiControl, SettingsGUIA:, blurAreaEqualXY, 1
      GuiControl, SettingsGUIA:, UserAddNoiseGrays, 0
      GuiControl, SettingsGUIA:, UserAddNoiseTransparent, 1
      GuiControl, SettingsGUIA: Choose, UserAddNoiseMode, 2
      GuiControl, SettingsGUIA: Choose, IDedgesBlendMode, 10
      UserAddNoiseIntensity := 15
      IDedgesInvert := 0
      IDedgesEmphasis := 0
      IDedgesContrast := 0
      IDedgesOpacity := 200
      UserAddNoisePixelizeAmount := 0
      UserAddNoiseBlurAmount := 0
   }
   updateUIaddNoisePanel()
}

PanelAddNoiserImage() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(44, A_ThisFunc)
    ReadSettingsAddNoisePanel()
    btnWid := 70
    txtWid := 266
    thisW := 100
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 110
       Gui, Font, s%LargeUIfontValue%
    }

    2ndcol := (PrefsLargeFonts=1) ? 185 : 127
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125
    gW := (PrefsLargeFonts=1) ? 385 : 330
    gH := (PrefsLargeFonts=1) ? 640 : 490
    If (isWinXP=1 || A_OSVersion="WIN_7")
       gH := gH//1.75

    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w%gW% h%gH% Section -Border +0xE gUIresponderPanelsLivePreview +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag to change the preview area, or click in the viewport.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    Gui, +DPIScale
    infoMask := defineCurrentAlphaMask()
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       BlurAreaAlphaMask := 0

    If (viewportQPVimage.imgHandle)
    {
       UserAddNoiseMode := 1
       ppk := "+Disabled"
    }

    sml := (PrefsLargeFonts=1) ? 30 : 20
    Gui, Add, Text, x+20 ys w%2ndcol% Section -wrap +hwndhTemp %ppk%, Noise type:
    GuiAddDropDownList("x+7 wp-30 AltSubmit gupdateUIaddNoisePanel Choose" UserAddNoiseMode " vUserAddNoiseMode", "Gaussian noise|Dynamic noise|Plasma / clouds", [hTemp])
    If (!viewportQPVimage.imgHandle)
       GuiAddButton("x+1 w" sml " hp gBtnUIpresetsClouds", "D", "Reset to default presets: noise or clouds")
    GuiAddSlider("UserAddNoiseIntensity", 1,100, 30, "Noise cut-off", "updateUIaddNoisePanel", 1, "xs y+10 w" txtWid//2 - 4 " hp")
    GuiAddSlider("UserAddNoiseDetails", 1,100, 20, "Plasmagon", "updateUIaddNoisePanel", 1, "x+5 wp hp")
    GuiAddSlider("IDedgesEmphasis", -255,255, 0, "Brightness", "updateUIaddNoisePanel", 2, "xs y+8 w" txtWid - 2 " hp")
    GuiAddSlider("IDedgesContrast", -100,100, 0, "Contrast", "updateUIaddNoisePanel", 2, "xs y+8 wp hp")
    GuiAddSlider("UserAddNoisePixelizeAmount", 0,100, 0, "Pixelize: $£", "updateUIaddNoisePanel", 1, "xs y+10 wp hp")
    GuiAddSlider("UserAddNoiseBlurAmount", 0,255, 0, "Blur X: $€", "updateUIaddNoisePanel", 1, "xs y+8 w" txtWid//2 - 4 " hp")
    GuiAddSlider("blurAreaYamount", 0,255, 0, "Blur Y: $€", "updateUIaddNoisePanel", 1, "x+5 wp hp")

    Gui, Add, Checkbox, xs y+10 w%2ndcol% hp Checked%blurAreaEqualXY% vblurAreaEqualXY gupdateUIaddNoisePanel, &Equal X/Y blur
    Gui, Add, Checkbox, x+7 hp gupdateUIaddNoisePanel Checked%UserAddNoiseTransparent% vUserAddNoiseTransparent, &Allow transparency
    Gui, Add, Checkbox, xs y+10 w%2ndcol% hp gupdateUIaddNoisePanel Checked%IDedgesInvert% vIDedgesInvert, &Invert noise
    Gui, Add, Checkbox, x+7 hp gupdateUIaddNoisePanel Checked%UserAddNoiseGrays% vUserAddNoiseGrays, &Grayscale

    Gui, Add, Text, xs y+7 hp w%2ndcol% +0x200 gBtnResetEdgesBlendMode +TabStop +hwndhTemp, Blending mode:
    GuiAddDropDownList("x+7 wp-27 gupdateUIaddNoisePanel AltSubmit Choose" IDedgesBlendMode " vIDedgesBlendMode", "None|" userBlendModesList, [hTemp])
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIaddNoisePanel")
    GuiAddSlider("IDedgesOpacity", 3,255, 255, "Opacity", "updateUIaddNoisePanel", 1, "xs y+10 w" txtWid - 1 " hp")

    thisW := (PrefsLargeFonts=1) ? 85 : 65
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default gBtnAddNoiseNow w%btnWid%, &Add noise
    Gui, Add, Button, x+5 hp w%thisW% gBtnCloseWindow, &Cancel
    If (!viewportQPVimage.imgHandle)
    {
       Gui, Add, Checkbox, x+5 hp Checked%BlurAreaAlphaMask% vBlurAreaAlphaMask gupdateUIaddNoisePanel, Use alpha mas&k
       If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
          GuiControl, Disable, BlurAreaAlphaMask
    }

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Add noise in selected area: " appTitle, winPos)
    SetTimer, updateUIaddNoisePanel, -200
}

BtnIDedgesNow() {
    If (downscaleHugeImagesForEditing()<0)
       Return

    updateUIedgesPanel("no")
    CloseWindow()
    detectEdgesSelectedArea()
}

BtnAddNoiseNow() {
   updateUIaddNoisePanel("no")
   CloseWindow()
   If (viewportQPVimage.imgHandle)
      HugeImagesApplyGenericFilters("noise filter")
   Else
      addNoiseSelectedArea()
}

updateUIedgesPanel(dummy:=0, b:=0) {
    Static lastInvoked := 1
    isOkay := (AnyWindowOpen=43 || AnyWindowOpen=79) ? 1 : 0
    If (isOkay!=1)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (AnyWindowOpen=43)
    {
       actu := (IDedgesBlendMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, IDedgesEmbossLvl
    }

    If (dummy!="no")
    {
       GuiRefreshSliders()
       SetTimer, WriteSettingsEdgesPanel, -150
       updateLiveTinyPreviewsWindow(dummy, b)
    }
    lastInvoked := A_TickCount
}

updateUIaddNoisePanel(dummy:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=44)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide

    If (UserAddNoiseMode=1)
       uiSlidersArray["UserAddNoiseIntensity", 5] := "Amplitude"
    Else If (UserAddNoiseMode=3)
       uiSlidersArray["UserAddNoiseIntensity", 5] := "Plasmadia"
    Else
       uiSlidersArray["UserAddNoiseIntensity", 5] := "Noise cut-off"

    uiSlidersArray["blurAreaYamount", 10] := (blurAreaEqualXY=0 && UserAddNoiseMode>1) ? 1 : 0
    uiSlidersArray["UserAddNoisePixelizeAmount", 5] := (UserAddNoiseMode=3) ? "Plasma scale" : "Pixelize"
    uiSlidersArray["UserAddNoiseDetails", 10] := (UserAddNoiseMode=3) ? 1 : 0

    actu := (UserAddNoiseMode>1) ? 1 : 0
    uiSlidersArray["IDedgesContrast", 10] := actu
    uiSlidersArray["IDedgesEmphasis", 10] := actu
    uiSlidersArray["UserAddNoiseBlurAmount", 10] := actu
    uiSlidersArray["UserAddNoisePixelizeAmount", 10] := actu
    If (viewportQPVimage.imgHandle)
    {
       uiSlidersArray["IDedgesEmphasis", 10] := 1
       uiSlidersArray["UserAddNoisePixelizeAmount", 10] := 1
       GuiControl, SettingsGUIA: Disable, UserAddNoiseMode
    }

    actu := (UserAddNoiseMode>1 || viewportQPVimage.imgHandle) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, IDedgesBlendMode
    GuiControl, % actu, UserAddNoiseGrays

    actu := (UserAddNoiseMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, IDedgesInvert
    GuiControl, % actu, UserAddNoiseTransparent
    GuiControl, % actu, blurAreaEqualXY
    GuiRefreshSliders()
    If (dummy!="no")
    {
       SetTimer, WriteSettingsAddNoisePanel, -150
       updateLiveTinyPreviewsWindow(dummy, b)
    }
}

PanelNewImage() {
    If (thumbsDisplaying=1)
       Return

    thisBtnHeight := createSettingsGUI(27, A_ThisFunc)
    RegAction(0, "NewDocUseColor",, 1)
    RegAction(0, "PredefinedDocsSizes",, 2, 1, 13)
    RegAction(0, "NewImageReverseDimensions",, 1)
    RegAction(0, "OutlierFillColor",, 3)
    RegAction(0, "OutlierFillOpacity",, 2, 1, 255)
    If (!UserNewWidth || !UserNewHeight || !UserNewDPI)
       PredefinedDocsSizes := 1
    Else If (UserNewWidth && UserNewHeight &&UserNewDPI)
       PredefinedDocsSizes := 13

    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    Global PickuOutlierFillColor, infoResultRes
    Gui, Add, Text, x15 y15 Section, Create new RGBA image. Please set image dimensions.
    GuiAddDropDownList("y+10 wp gupdateUInewImagePanel AltSubmit Choose" PredefinedDocsSizes " vPredefinedDocsSizes", "Viewport size|Screen size|Current image size|640x480|800x600|1024x768|HD 480p|HD 720p|HD 1080p|HD 2160p [4K]|A4 @ 300 dpi|A4 @ 150 dpi|Previously used dimensions", "Image dimensions preset")
    Gui, Add, Text, xs y+10 w%EditWid%, Width (px)
    Gui, Add, Text, x+4 wp, Height (px)
    Gui, Add, Text, x+4 wp, DPI
    GuiAddEdit("xs y+7 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewWidth", UserNewWidth, "Width")
    GuiAddEdit("x+5 wp gNewImageEditResponder r1 limit5 +number -multi -wantTab -wrap vUserNewHeight", UserNewHeight, "Height")
    GuiAddEdit("x+5 wp-10 gNewImageEditResponder r1 limit5 +number -multi -wantTab -wrap vUserNewDPI", UserNewDPI, "DPI")
    Gui, Add, Text, x+5 hp wp+55 +0x200 vinfoLine -wrap, -
    Gui, Add, Checkbox, xs y+10 Checked%NewImageReverseDimensions% vNewImageReverseDimensions, Rotate canvas 90° degrees
    Gui, Add, Checkbox, xs y+10 gupdateUInewImagePanel Checked%NewDocUseColor% vNewDocUseColor, Fill background with color
    ha := (PrefsLargeFonts=1) ? 28 : 19
    clrW := (PrefsLargeFonts=1) ? 65 : 45
    GuiAddPickerColor("xs+17 y+10 w26 h" ha, "OutlierFillColor")
    GuiAddColor("x+2 hp w" clrW, "OutlierFillColor", "Background color")
    txtWid -= 95
    GuiAddSlider("OutlierFillOpacity", 3,255, 255, "Opacity", "iniSaveOutlierClrOpaciy", 1, "x+5 w" clrW*2 + 20 " hp")

    ml := (PrefsLargeFonts=1) ? 85 : 65
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnCreateNewImage, &Create new image
    Gui, Add, Button, x+5 hp w%btnWid% gOpenNewQPVinstance, &New instance
    Gui, Add, Button, x+5 hp w%ml% gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "New image: " appTitle)
    SetTimer, updateUInewImagePanel, -150
}

iniSaveOutlierClrOpaciy() {
    RegAction(1, "OutlierFillOpacity")
}

ReadSettingsThumbsSheetPanel(act:=0) {
    RegAction(act, "userJpegQuality",, 2, 1, 100)
    RegAction(act, "TextInAreaAlign",, 2, 1, 3)
    ; RegAction(act, "TextInAreaValign",, 2, 1, 3)
    RegAction(act, "TextInAreaFontColor",, 3)
    RegAction(act, "TextInAreaFontOpacity",, 2, 3, 255)
    RegAction(act, "TextInAreaFontName",, 5)
    RegAction(act, "TextInAreaFontBold",, 1)
    RegAction(act, "TextInAreaFontItalic",, 1)
    RegAction(act, "TextInAreaFontUline",, 1)
    RegAction(act, "TextInAreaFontSize",, 2, 5, 995)
    RegAction(act, "userThumbsSheetWidth",, 2, 32, 1024)
    RegAction(act, "userThumbsSheetHeight",, 2, 32, 1024)
    RegAction(act, "userThumbsSheetColumns",, 2, 1, 256)
    RegAction(act, "userThumbsSheetSpacing",, 2, 1, 256)
    RegAction(act, "userThumbsSheetFrame",, 2, 0, 250)
    RegAction(act, "userThumbsSheetBgrShade",, 2, 1, 3)
    RegAction(act, "userThumbsSheetBgrColor",, 3)
    RegAction(act, "userThumbsSheetShowLabel",, 1)
    RegAction(act, "userThumbsSheetHideExt",, 1)
    RegAction(act, "ResizeApplyEffects",, 1)
}

ReadSettingsPrintPanel(act:=0) {
    RegAction(act, "TextInAreaAlign",, 2, 1, 3)
    RegAction(act, "TextInAreaValign",, 2, 1, 3)
    RegAction(act, "TextInAreaFontColor",, 3)
    RegAction(act, "TextInAreaFontOpacity",, 2, 3, 255)
    RegAction(act, "TextInAreaFontName",, 5)
    RegAction(act, "TextInAreaFontBold",, 1)
    RegAction(act, "TextInAreaFontItalic",, 1)
    RegAction(act, "TextInAreaFontUline",, 1)
    RegAction(act, "PrintTxtSize",, 2, 24, 999)
    RegAction(act, "PrintDimensionsXYWH",, 5)
    RegAction(act, "PrintImgAngleOrientation",, 2, -180, 180)
    RegAction(act, "PrintDoFlipuH",, 1)
    RegAction(act, "PrintDoFlipuV",, 1)
    RegAction(act, "PrintColorMode",, 1)
    RegAction(act, "PrintAdaptToFit",, 1)
    RegAction(act, "PrintUseViewportColors",, 1)
    RegAction(act, "PrintStrechedSize",, 1)
    RegAction(act, "PrintPaperOrient",, 1)
}

UIresponderPrintPreview(a, m_event) {
   Gui, SettingsGUIA: Default
   GuiControlGet, PrintAdaptToFit
   If (PrintAdaptToFit=1)
   {
      PrintAdaptToFit := 0
      GuiControl, SettingsGUIA: , PrintAdaptToFit, 0
      SoundBeep 900, 100
      updateUIprintPreview()
      Return
   }

   hwnd := "0x" Format("{:x}", a)
   WinGetPos, , , w, h, ahk_id %hwnd%
   lastInvoked := A_TickCount
   zx := zy := 0
   modus := GetKeyState("Ctrl", "P") ? 1 : 0
   While, (determineLClickState()=1)
   {
      GetPhysicalCursorPos(mX, mY)
      If (isInRange(mX, zX - 2, zX + 2) && isInRange(mY, zY - 2, zY + 2) && A_Index>1)
         Continue

      GetMouseCoord2wind(hwnd, nX, nY)
      Sleep, 1
      zX := mX, zY := mY
      newX := clampInRange( Round( (nX / w, 1) * 100) , 0, 100)
      newY := clampInRange( Round( (nY / h, 1) * 100) , 0, 100)
      If (modus!=1)
      {
         PrintPosX := newX
         PrintPosY := newY
         GuiUpdateSliders("PrintPosX")
         GuiUpdateSliders("PrintPosY")
      } Else
      {
         PrintPosW := clampInRange(newX - PrintPosX, 1, 100)
         PrintPosH := clampInRange(newY - PrintPosY, 1, 100)
         GuiUpdateSliders("PrintPosW")
         GuiUpdateSliders("PrintPosH")
      }
      ; ToolTip, % wx "|" w "|" rangeu "|" newValue , , , 2
      If (A_TickCount - lastInvoked>150)
      {
         updateUIprintPreview()
         lastInvoked := A_TickCount
      }
   }
   updateUIprintPreview()
}

PanelPrintImage() {
    Global PrintCopies, SelectedPrinteru, PrintDoFlipuH, PrintDoFlipuV, PrinterPageInfos
         , UserTextArea, editF1, PickuTextInAreaFontColor

    If AnyWindowOpen
       Return

    If (thumbsDisplaying=1)
    {
       ToggleThumbsMode()
       SetTimer, PanelPrintImage, -300
       Return
    }

    filesElected := getSelectedFiles(0, 1)
    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    vpWinClientSize(mainWidth, mainHeight)
    If validBMP(useGdiBitmap())
       viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, useGdiBitmap(), 450, 450, 1, 3, -1)

    If !validBMP(viewportStampBMP)
    {
       showTOOLtip("ERROR: Unable to load or prepare the image.`nUnable to print the image.")
       SoundBeep 300, 100
       Return
    }

    thisBtnHeight := createSettingsGUI(57, A_ThisFunc)
    ReadSettingsPrintPanel()
    printDims := StrSplit(PrintDimensionsXYWH, "|")
    PrintPosX := printDims[1]
    PrintPosY := printDims[2]
    PrintPosW := printDims[3]
    PrintPosH := printDims[4]
    TextInAreaFontOpacity := clampInRange(TextInAreaFontOpacity, 10, 255)

    btnWid := 70
    txtWid := 350
    EditWid := 70
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 25
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    gW := (PrefsLargeFonts=1) ? 226 : 186
    gH := (PrefsLargeFonts=1) ? 319 : 263
    printerlist := SGDIPrint_GetDefaultPrinter() "||" SGDIPrint_EnumPrinters("|") 
    Gui, Add, Text, x20 y20 w%gW% h%gH% Section -Border +0xE +hwndhCropCornersPic gUIresponderPrintPreview, Print preview
    ToolTip2ctrl(hCropCornersPic, "Click to set image position on page.`nCtrl+click to set its size.")
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, -`n-`n-`n-
    Gui, Add, Tab3, %tabzDarkModus% x+20 ys Section, General|Text line

    Gui, Tab, 1
    Gui, Add, Text, x+15 y+15 Section, Please choose printer:
    GuiAddDropDownList("y+7 wp+90 gupdateUIprintPreview vSelectedPrinteru", printerlist, "Device")
    Gui, Add, Button, x+5 hp gBtnSetPrinterDefault, Set as &default
    GuiAddDropDownList("xs y+10 w" EditWid " gupdateUIprintPreview AltSubmit Choose" PrintPaperOrient " vPrintPaperOrient", "Portrait|Landscape", "Page orientation")
    GuiAddEdit("x+5 w" EditWid " gupdateUIprintPreview r1 limit2 +number -multi -wantTab -wrap veditFc", PrintCopies, "Copies")
    Gui, Add, UpDown, vPrintCopies gupdateUIprintPreview Range1-99, % PrintCopies
    Gui, Add, Text, x+5 hp +0x200, copies to print
    Gui, Add, Checkbox, xs y+10 hp gupdateUIprintPreview Checked%PrintAdaptToFit% vPrintAdaptToFit, Automatically adapt image to cover page
    GuiAddSlider("PrintPosX", 0,100, 0, "X", "updateUIprintPreview", 1, "xs+15 y+10 w" EditWid " hp")
    GuiAddSlider("PrintPosY", 0,100, 0, "Y", "updateUIprintPreview", 1, "x+2 wp hp")
    GuiAddSlider("PrintPosW", 1,100, 50, "W", "updateUIprintPreview", 1, "x+2 wp hp")
    GuiAddSlider("PrintPosH", 1,100, 50, "H", "updateUIprintPreview", 1, "x+2 wp hp")
    Gui, Add, Checkbox, xs+15 y+10 hp gupdateUIprintPreview Checked%PrintStrechedSize% vPrintStrechedSize, &Stretch to given dimensions
    Gui, Add, Checkbox, xs y+10 hp gupdateUIprintPreview Checked%PrintDoFlipuH% vPrintDoFlipuH, Flip V
    Gui, Add, Checkbox, x+10 hp gupdateUIprintPreview Checked%PrintDoFlipuV% vPrintDoFlipuV, Flip H
    GuiAddSlider("PrintImgAngleOrientation", -180,180, 0, "Angle: $€°", "updateUIprintPreview", 2, "x+10 w" EditWid+10 " hp")
    Gui, Add, Checkbox, xs y+10 gupdateUIprintPreview Checked%PrintColorMode% vPrintColorMode, Print &with colors
    Gui, Add, Checkbox, xs y+10 gupdateUIprintPreview Checked%PrintUseViewportColors% vPrintUseViewportColors, Apply &viewport color adjustments
    If (filesElected>1)
       Gui, Add, Text, xs y+10, % groupDigits(filesElected) " files are selected for printing."

    Gui, Tab, 2
    EditWid2 := (PrefsLargeFonts!=1) ? 290 : 450
    Gui, Add, Text, x+15 y+15 Section, Text to insert on the page:
    hEditField := GuiAddEdit("xs y+5 w" EditWid2 " r3 gupdateUIprintPreview vUserTextArea limit2048", UserTextArea)
    Gui, Add, Text, xs y+15 wp, Font name:
    GuiAddDropDownList("xs y+5 wp Sort gupdateUIprintPreview Choose1 vTextInAreaFontName", TextInAreaFontName)
    Gui, Add, Text, xs y+15, Text size and color:
    GuiAddEdit("xs+0 y+5 w" editWid " gupdateUIprintPreview r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF1 ", PrintTxtSize, "Font size")
    Gui, Add, UpDown, vPrintTxtSize gupdateUIprintPreview Range25-999, % PrintTxtSize
    GuiAddColor("x+2 w55 hp", "TextInAreaFontColor", "Text color")
    GuiAddPickerColor("x+2 hp w27", "TextInAreaFontColor")
    GuiAddSlider("TextInAreaFontOpacity", 10, 255, 255, "Opacity", "updateUIprintPreview", 1, "x+5 w" EditWid2//2 " hp")

    Gui, Add, Text, xs y+15, Text alignment and style:
    GuiAddDropDownList("xs y+5 w" editWid " gupdateUIprintPreview Choose" TextInAreaAlign " AltSubmit vTextInAreaAlign", "Left|Center|Right", "Text horizontal alignment")
    GuiAddDropDownList("x+2 wp gupdateUIprintPreview Choose" TextInAreaValign " AltSubmit vTextInAreaValign", "Top|Center|Bottom", "Text vertical alignment")
    widu := (PrefsLargeFonts=1) ? 29 : 25
    GuiAddCheckbox("x+2 yp hp+1 w" widu " gupdateUIprintPreview Checked" TextInAreaFontBold " vTextInAreaFontBold", "Bold", "B")
    GuiAddCheckbox("x+2 yp hp wp gupdateUIprintPreview Checked" TextInAreaFontItalic " vTextInAreaFontItalic", "Italic", "I")
    GuiAddCheckbox("x+2 yp hp wp gupdateUIprintPreview Checked" TextInAreaFontUline " vTextInAreaFontUline", "Underline", "&U")
    If (filesElected>1)
       Gui, Add, Text, xs y+10, Use "{fname}" as a place-holder for the current file name.

    Gui, Tab
    f := (filesElected>1) ? "all" : "now"
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnStartPrintingNow, &Print %f%
    If (filesElected>1)
       Gui, Add, Button, x+5 hp wp gBtnStartPrintingNow, &Active only

    Gui, Add, Button, x+5 hp gBtnOpenPrinterOptions, &More options
    Gui, Add, Button, x+5 hp w80 gBtnCloseWindow, &Cancel
    PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Print image: " appTitle)
    ; SetTimer, updateUIprintPreview, -500
}

BtnOpenPrinterOptions() {
   GuiControlGet, SelectedPrinteru
   if (lastSelPrinterName!=SelectedPrinteru)
      printerDevModeOptions := ""

   SGDIPrint_OpenPrintingOptions(SelectedPrinteru, printerDevModeOptions, hSetWinGui)
   lastSelPrinterName := SelectedPrinteru
   updateUIprintPreview("extern")
}

BtnSetPrinterDefault() {
   Gui, SettingsGUIA: Default
   GuiControlGet, SelectedPrinteru
   If (lastSelPrinterName!=SelectedPrinteru)
      printerDevModeOptions := ""

   lastSelPrinterName := SelectedPrinteru
   If !SGDIPrint_SetDefaultPrinter(SelectedPrinteru)
      msgBoxWrapper(appTitle ": ERROR", "Failed to set " SelectedPrinteru " as default.", 0, 0, "error")
}

printSettingsObj() {
   Static dmSize := A_IsUnicode ? 68 : 36
        , dmFields := dmSize + 4
        , DM_COPIES := "0x100" , DM_COLOR := "0x800" , DM_ORIENTATION := "0x1"
        , ansiUnicodeOffSet := (A_IsUnicode=1) ? 32 : 0

   If (AnyWindowOpen!=57)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, PrintAdaptToFit
   GuiControlGet, PrintColorMode
   GuiControlGet, PrintCopies
   GuiControlGet, SelectedPrinteru
   GuiControlGet, PrintPaperOrient
   GuiControlGet, PrintDoFlipuH
   GuiControlGet, PrintDoFlipuV
   GuiControlGet, PrintUseViewportColors
   GuiControlGet, TextInAreaAlign
   GuiControlGet, TextInAreaValign
   GuiControlGet, TextInAreaFontName
   GuiControlGet, TextInAreaFontBold
   GuiControlGet, TextInAreaFontItalic
   GuiControlGet, TextInAreaFontUline
   GuiControlGet, PrintTxtSize
   GuiControlGet, PrintStrechedSize
   GuiControlGet, UserTextArea

   PrintOptions := []
   If (lastSelPrinterName!=SelectedPrinteru)
      printerDevModeOptions := ""

   UserTextArea := Trimmer(UserTextArea)
   UserTextArea := allowCtrlBkspEdit(hEditField, UserTextArea)
   If (!printerDevModeOptions)
   {
      pPrinterName := Trim(SelectedPrinteru)
      VarSetCapacity(pPrinter , A_PtrSize, 0)
      out := DllCall("Winspool.drv\OpenPrinter", "UPtr", &pPrinterName, "UPtr*", pPrinter, "Ptr", 0, "Ptr")

      sizeDevMode := DllCall("Winspool.drv\DocumentProperties", "Ptr", PVhwnd, "Ptr", pPrinter, "Ptr", &pPrinterName, "Ptr", 0, "Ptr", 0, "UInt", 0, "Int")
      VarSetCapacity(printerDevModeOptions, sizeDevMode, 0)
      out2 := DllCall("Winspool.drv\DocumentProperties", "Ptr", PVhwnd, "Ptr", pPrinter, "Ptr", &pPrinterName, "UPtr", &printerDevModeOptions, "Ptr", 0, "UInt", 2, "Int")

      updateFields := 0 | DM_COLOR | DM_ORIENTATION | DM_COPIES
      NumPut(PrintPaperOrient, printerDevModeOptions, 44 + ansiUnicodeOffSet, "Short")
      NumPut(Trim(PrintCopies), printerDevModeOptions, 54 + ansiUnicodeOffSet, "Short")
      NumPut(PrintColorMode + 1, printerDevModeOptions, 60 + ansiUnicodeOffSet, "Short")
      NumPut(updateFields, printerDevModeOptions, dmFields, "UInt")
      out3 := DllCall("Winspool.drv\DocumentProperties", "UPtr", PVhwnd, "Ptr", pPrinter, "Ptr", &pPrinterName, "UPtr", &printerDevModeOptions, "UPtr", &printerDevModeOptions, "UInt", 10, "Int") 
      DllCall("ClosePrinter", "Ptr", pPrinter)
   } Else
   {
      NumPut(PrintPaperOrient, printerDevModeOptions, 44 + ansiUnicodeOffSet, "Short")
      NumPut(Trim(PrintCopies), printerDevModeOptions, 54 + ansiUnicodeOffSet, "Short")
      NumPut(PrintColorMode + 1, printerDevModeOptions, 60 + ansiUnicodeOffSet, "Short")
   }

   lastSelPrinterName := SelectedPrinteru
   PrintOptions.pPrinterName := SelectedPrinteru
   PrintOptions.adaptFit := PrintAdaptToFit
   PrintOptions.userImgX := PrintPosX
   PrintOptions.userImgY := PrintPosY
   PrintOptions.userImgW := PrintPosW
   PrintOptions.userImgH := PrintPosH
   PrintOptions.colorsMode := PrintColorMode
   PrintOptions.imgOrient := PrintImgAngleOrientation
   PrintOptions.paperOrient := PrintPaperOrient
   PrintOptions.copiez := PrintCopies
   PrintOptions.flipuV := PrintDoFlipuH
   PrintOptions.flipuH := PrintDoFlipuV
   PrintOptions.applyFX := PrintUseViewportColors
   PrintOptions.text := Trimmer(UserTextArea)
   PrintDimensionsXYWH := PrintPosX "|" PrintPosY "|" PrintPosW "|" PrintPosH

   uiSlidersArray["PrintPosX", 10] := !PrintAdaptToFit
   uiSlidersArray["PrintPosY", 10] := !PrintAdaptToFit
   uiSlidersArray["PrintPosW", 10] := !PrintAdaptToFit
   uiSlidersArray["PrintPosH", 10] := !PrintAdaptToFit
   GuiRefreshSliders()
   act := (PrintAdaptToFit=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, % act, PrintStrechedSize
   SetTimer, WriteSettingsPrintPanel, -200
   Return PrintOptions
}

WriteSettingsPrintPanel() {
    ReadSettingsPrintPanel(1)
}

updateUIprintPreview(dummy:=0) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<350)
   {
      SetTimer, updateUIprintPreview, -500
      Return
   }

   If (dummy="extern")
   {
      ansiUnicodeOffSet := (A_IsUnicode=1) ? 32 : 0
      DC_Orientation := NumGet(printerDevModeOptions, 44 + ansiUnicodeOffSet, "Short")
      DC_Copies := NumGet(printerDevModeOptions, 54 + ansiUnicodeOffSet, "Short")
      DC_Color := NumGet(printerDevModeOptions, 60 + ansiUnicodeOffSet , "Short")
      PrintCopies := DC_Copies
      PrintPaperOrient := DC_Orientation
      PrintColorMode := DC_Color - 1
      GuiControl, SettingsGUIA: Choose, PrintPaperOrient, % DC_Orientation
      GuiControl, SettingsGUIA:, PrintCopies, % DC_Copies
      GuiControl, SettingsGUIA:, PrintColorMode, % DC_Color - 1
   }

   PrintOptions := printSettingsObj()
   zPlitPath(getIDimage(currentFileIndex), 0, OutFileName, OutDir)
   printImageNow(viewportStampBMP, PrintOptions, 1, 0, OutFileName)
   lastInvoked := A_TickCount
}

BtnStartPrintingNow(a, b) {
   PrintOptions := printSettingsObj()
   ControlGetText, c,, ahk_id %a%
   WriteSettingsPrintPanel()
   BtnCloseWindow()
   showTOOLtip("Please wait, preparing to print image")
   zPlitPath(getIDimage(currentFileIndex), 0, OutFileName, OutDir)
   Sleep, 2
   If (markedSelectFile>1 && !InStr(c, "active"))
      batchImgPrinting(PrintOptions)
   Else
      printImageNow(useGdiBitmap(), PrintOptions, 0, 0, OutFileName)

   Sleep, 2
   RemoveTooltip()
}

batchImgPrinting(PrintOptions) {
   filesElected := getSelectedFiles(0, 1)
   showTOOLtip("Printing " groupDigits(filesElected) " images, please wait")
   prevMSGdisplay := A_TickCount
   thisFileIndex := tFrames := failedFiles := countFilez := countTFilez := 0
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   prevMSGdisplay := 1
   startOperation := A_TickCount
   lastInvoked := 2
   doStartLongOpDance()
   CurrentSLD := ""
   Loop
   {
      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - lastInvoked>3100) ; avoid creating printing jobs too fast
      {
         thisFileIndex++
         If (thisFileIndex>maxFilesIndex)
            Break

         If (resultedFilesList[thisFileIndex, 2]!=1)
            Continue

         imgPath := getIDimage(thisFileIndex)
         If (InStr(imgPath, "||") || !imgPath)
            Continue
    
         countTFilez++
         oBitmap := LoadBitmapFromFileu(imgPath)
         If !validBMP(oBitmap)
         {
            failedFiles++
            Continue
         }

         zPlitPath(imgPath, 1, OutFileName, OutDir)
         r := printImageNow(oBitmap, PrintOptions, 0, 1, OutFileName)
         trGdip_DisposeImage(oBitmap)
         If r
            failedFiles++
         Else
            countFilez++
         lastInvoked := A_TickCount
      }

      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFor " groupDigits(failedFiles) " files, the operations failed"

         showTOOLtip("Processing images to be printed, please wait" etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }
   }

   CurrentSLD := backCurrentSLD
   If (failedFiles>0)
      someErrors .= "`nFor " groupDigits(failedFiles) " files, printing failed"

   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files`nthe printing process began" someErrors)
   Else
      showTOOLtip(groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed for printing." someErrors)

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return
}

PanelIMGselProperties() {
    If (thumbsDisplaying=1)
       Return

    If (imgEditPanelOpened=1 && AnyWindowOpen && thumbsDisplaying=0)
       postVectorWinOpen := AnyWindowOpen

    zz := postVectorWinOpen
    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    thisBtnHeight := createSettingsGUI(34, A_ThisFunc)
    postVectorWinOpen := zz
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := EditWid//2 - 2
    Global NewPosX1, NewPosY1, NewPosX2, NewPosY2, NewVProt
         , BtnPosX1m, BtnPosX1p, BtnPosY1m, BtnPosY1p, BtnPosX2m, BtnPosX2p, BtnPosY2m, BtnPosY2p
         , BtnPosXm, BtnPosXp, BtnPosYm, BtnPosYp, BtnPosZm, BtnPosZp

    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    Gui, Add, Text, x15 y15 Section, Current image size: %imgW% x %imgH% px.
    Gui, Add, Checkbox, y+7 gupdateUIselPropPanel Checked%userDefinedSelCoords% vuserDefinedSelCoords, Define image selection coordinates in:
    sml := (PrefsLargeFonts=1) ? 150 : 90
    GuiAddDropDownList("x+1 w" sml " AltSubmit gupdateUIchangeSelectionType vSelectionCoordsType", "Pixels||Percentages", "Coordinates mode")
    Gui, Add, Text, xs+15 y+10 w%EditWid% vtxtLine1, X1
    Gui, Add, Text, x+3 wp vtxtLine2, Y1
    Gui, Add, Text, x+3 wp vtxtLine3, X2
    Gui, Add, Text, x+3 wp vtxtLine4, Y2
    ; Gui, Add, Text, x+3 wp, Rotation
    GuiAddEdit("xs+15 y+7 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosX1", imgSelX1, "X1")
    GuiAddEdit("x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosY1", imgSelY1, "Y1")
    GuiAddEdit("x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosX2", imgSelX2, "X2")
    GuiAddEdit("x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselPropPanel vNewPosY2", imgSelY2, "Y2")
    ; Gui, Add, Text, x+3 wp h1 Hide, Rotation
    ; Gui, Add, ComboBox, xp yp wp limit9 -multi -wrap gupdateUIselPropPanel vNewVProt, 0|45|90|105|135|150|180|200|225|250|270|300|315|%VPselRotation%||
    Gui, Add, Text, xs y+10, Adjust current selection coordinates:
    Gui, Add, Button, xs+15 y+7 w%btnWid2% gOffsetSelProperPanel vbtnFldr6, &Align
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosX1m, X1
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosY1m, Y1
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosX2m, X2
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosY2m, Y2
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosXm, V
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp gOffsetSelProperPanel vBtnPosYm, H
    Gui, Add, Text, Border +TabStop Center +0x200 x+3 hp wp+10 gOffsetSelProperPanel vBtnPosZm, Size
    slideWid := (PrefsLargeFonts=1) ? 215 : 150
    userUIshapeCavity := Round((innerSelectionCavityX + innerSelectionCavityY) / 2 * 400)
    GuiAddSlider("userUIshapeCavity", 0,400, 0, "Cavity", "updateFillInnerCavity", 1, "xs y+7 w" slideWid " hp")
    GuiAddSlider("VPselRotation", 0,359, 0, "Rotation: $€°", "dummyRefreshImgSelectionWindow", 1, "x+5 wp hp")
    Gui, Add, Checkbox, xs y+15 gupdateUIselPropPanel Checked%LimitSelectBoundsImg% vLimitSelectBoundsImg, &Limit selection to image boundaries
    Gui, Add, Checkbox, xs y+10 gupdateUIselPropPanel Checked%rotateSelBoundsKeepRatio% vrotateSelBoundsKeepRatio, &Keep aspect ratio on rotation
    Gui, Add, Text, xs y+10 hp +0x200 +hwndhTemp, Lock aspect ratio:
    thisW := (PrefsLargeFonts=1) ? 190 : 120
    GuiAddDropDownList("x+10 w" thisW " gupdateUIselPropPanel AltSubmit Choose" lockSelectionAspectRatio " vlockSelectionAspectRatio", "Unlocked|Current selection ratio|Current window|Current image|Square [1:1]|SDTV [4:3]|35mm film [3:2]|HDTV [16:9]|Wide screens [16:10]|Phone", [hTemp])

    thisW := (PrefsLargeFonts=1) ? 125 : 80
    Gui, Add, Button, xs y+25 w%thisW% h%thisBtnHeight% gBTNselectEntireImg, &Select all
    Gui, Add, Button, x+5 wp hp gBTNselectNoneImg, &Select none
    thisW := (PrefsLargeFonts=1) ? 80 : 55
    Gui, Add, Button, x+5 w%thisW% hp gBTNcopySelCoords, C&opy
    Gui, Add, Button, x+5 wp hp gBTNpasteSelCoords, &Paste
    If postVectorWinOpen
       Gui, Add, Button, x+10 wp hp gBTNopenPrevPanel Default, &Back
    Else
       Gui, Add, Button, x+10 wp hp gBtnCloseWindow Default, &Close

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Selection properties: " appTitle, winPos)
    ; SetTimer, updateUIselPropPanel, -350
    GuiUpdateSliders("VPselRotation")
    GuiUpdateSliders("userUIshapeCavity")
    updateUIselPropPanel()
}

BTNcopySelCoords() {
   txt := imgSelX1 "|" imgSelY1 "|" imgSelX2 "|" imgSelY2 "|" VPselRotation "|" rotateSelBoundsKeepRatio "|" innerSelectionCavityX "|" innerSelectionCavityY
   Try Clipboard := txt
   Catch wasError
         Sleep, 1

   If wasError
   {
      showTOOLtip("Failed to copy selection coordinates to the clipboard")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BTNpasteSelCoords() {
   Try txt := Clipboard
   txt := SubStr(txt, 1, 4500)
   arr := StrSplit(txt, "|")
   If isNumber(arr[1])
   {
      imgSelX1 := arr[1]
      If isNumber(arr[2])
      {
         imgSelY1 := arr[2]
         If isNumber(arr[3])
         {
            imgSelX2 := arr[3]
            If isNumber(arr[4])
               imgSelY2 := arr[4]
         }
      }
   }

   If isNumber(arr[5])
   {
      VPselRotation := clampInRange(arr[5], 0, 359.9)
      GuiUpdateSliders("VPselRotation")
   }

   If (arr[6]=1 || arr[6]=0)
   {
      rotateSelBoundsKeepRatio := arr[6]
      GuiControl, SettingsGUIA:, rotateSelBoundsKeepRatio, % rotateSelBoundsKeepRatio
   }

   If (isNumber(arr[7]) && isNumber(arr[8]))
   {
      innerSelectionCavityX := clampInRange(arr[7], 0, 0.99)
      innerSelectionCavityY := clampInRange(arr[8], 0, 0.99)
      userUIshapeCavity := Round((innerSelectionCavityX + innerSelectionCavityY) / 2 * 400)
      GuiUpdateSliders("userUIshapeCavity")
   }

   nImgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := min(imgSelY1, imgSelY2)
   nImgSelX2 := max(imgSelX1, imgSelX2)
   nImgSelY2 := max(imgSelY1, imgSelY2)
   ImgSelX1 := Round(nImgSelX1),     ImgSelY1 := Round(nImgSelY1)
   imgSelX2 := Round(nImgSelX2),     ImgSelY2 := Round(nImgSelY2)
   SelectionCoordsType := lockSelectionAspectRatio := 1
   GuiControl, SettingsGUIA: Choose, SelectionCoordsType, 1
   GuiControl, SettingsGUIA: Choose, lockSelectionAspectRatio, 1
   GuiControl, SettingsGUIA:, NewPosX1, % ImgSelX1
   GuiControl, SettingsGUIA:, NewPosY1, % ImgSelY1
   GuiControl, SettingsGUIA:, NewPosX2, % ImgSelX2
   GuiControl, SettingsGUIA:, NewPosY2, % ImgSelY2
   updateUIselPropPanel()
}

BTNselectNoneImg() {
   BtnCloseWindow()
   editingSelectionNow := 0
   updateUIctrl()
   MouseMoveResponder()
   dummyTimerDelayiedImageDisplay(50)
}

dummyOffsetSelProperPanel() {
    If (determineLClickState()=1)
    {
       SetTimer, dummyOffsetSelProperPanel, -25
       OffsetSelProperPanel("usePrev")
    }
}

updateUIselEditsPropPanel() {
   If (SelectionCoordsType=1)
   {
      GuiControl, SettingsGUIA:, NewPosX1, % imgSelX1
      GuiControl, SettingsGUIA:, NewPosY1, % imgSelY1
      GuiControl, SettingsGUIA:, NewPosX2, % imgSelX2
      GuiControl, SettingsGUIA:, NewPosY2, % imgSelY2
   } Else
   {
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      X1 := Round(imgSelX1 / imgW*100, 2)
      Y1 := Round(imgSelY1 / imgH*100, 2)
      X2 := Round(imgSelX2 / imgW*100, 2)
      Y2 := Round(imgSelY2 / imgH*100, 2)
 
      GuiControl, SettingsGUIA:, NewPosX1, % X1
      GuiControl, SettingsGUIA:, NewPosY1, % Y1
      GuiControl, SettingsGUIA:, NewPosX2, % X2
      GuiControl, SettingsGUIA:, NewPosY2, % Y2
   }
}

OffsetSelProperPanel(dummy:=0) {
   Static prevVaru, lastInvoked := 1
   If (AnyWindowOpen!=34)
      Return

   GuiControlGet, SelectionCoordsType
   stepu := (A_TickCount - lastInvoked<350) ? 4 : 2
   If (dummy!="usePrev")
      ; GuiControlGet, varu, SettingsGUIA: FocusV
      ControlGetText, varu,, ahk_id %dummy%
   Else
      varu := prevVaru

   If (varu="&align")
   {
      deleteMenus()
      createMenuSelectionAlign("selProp")
      showThisMenu("PVselAlign")
      SetTimer, updateUIselEditsPropPanel, -250
      Return
   }

   givenStep := 0
   If (GetKeyState("Ctrl", "P") && varu!="size")
   {
      Random, randy, 100, 950
      isvh := (varu="v" || varu="h") ? 1 : 0
      more := isvh ? " in pixels relative to the current position" : " in pixels"
      msgResult := msgBoxWrapper("panelu|Define coordinates: " appTitle, "Please input the new value for " varu more ".", "&OK|&Cancel", 1, "question", 0, 0, 0, "limit9050", randy)
      If InStr(msgResult.btn, "ok")
         givenStep := (isvh=1) ? - Round(Trimmer(msgResult.edit) / 4) : Trimmer(msgResult.edit)
      If (!InStr(msgResult.btn, "ok") || (givenStep=0 && isvh=1) || !isNumber(givenStep))
         Return

      If (isvh=0)
      {
         ImgSel%varu% := givenStep
         SelectionCoordsType := 1
         GuiControl, SettingsGUIA: Choose, SelectionCoordsType, 1
         nImgSelX1 := min(imgSelX1, imgSelX2)
         nImgSelY1 := min(imgSelY1, imgSelY2)
         nImgSelX2 := max(imgSelX1, imgSelX2)
         nImgSelY2 := max(imgSelY1, imgSelY2)
         ImgSelX1 := Round(nImgSelX1),     ImgSelY1 := Round(nImgSelY1)
         ImgSelX2 := Round(nImgSelX2),     ImgSelY2 := Round(nImgSelY2)
         GuiControl, SettingsGUIA:, NewPosX1, % ImgSelX1
         GuiControl, SettingsGUIA:, NewPosY1, % ImgSelY1
         GuiControl, SettingsGUIA:, NewPosX2, % ImgSelX2
         GuiControl, SettingsGUIA:, NewPosY2, % ImgSelY2
         updateUIselPropPanel()
         Return
      }
   }

   cX := 0, cY := 0
   GetPhysicalCursorPos(oX, oY)
   setWhileLoopExec(1)
   ToolTip, Move up/down relative to this point on screen to adjust %varu%
   While, (determineLClickState()=1 || A_Index=1)
   {
      GetPhysicalCursorPos(mX, mY)
      dir := (oY<mY) ? -1 : 1
      If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
         Continue

      cX := mX, cY := mY
      stepu := (A_Index>50) ? 4 : 2
      If (viewportQPVimage.imgHandle)
         stepu *= 2
      If givenStep
         stepu := givenStep

      If (varu="H")
      {
         arrowKeysAdjustSelectionArea(dir * -1, 1, stepu, 1)
         arrowKeysAdjustSelectionArea(dir * -1, 2, stepu, 1)
      } Else If (varu="V")
      {
         arrowKeysAdjustSelectionArea(dir * -2, 1, stepu, 1)
         arrowKeysAdjustSelectionArea(dir * -2, 2, stepu, 1)
      } Else If (varu="size")
         changeSelectZoom(dir, 1)
      Else If (varu="X1")
         arrowKeysAdjustSelectionArea(dir * -1, 1, stepu, 1)
      Else If (varu="Y1")
         arrowKeysAdjustSelectionArea(dir * -2, 1, stepu, 1)
      Else If (varu="X2")
         arrowKeysAdjustSelectionArea(dir * -1, 2, stepu, 1)
      Else If (varu="Y2")
         arrowKeysAdjustSelectionArea(dir * -2, 2, stepu, 1)

      updateUIselEditsPropPanel()
      If givenStep
         Break
   }

   setWhileLoopExec(0)
   Tooltip
   lastInvoked := A_TickCount
   prevVaru := varu
   SetTimer, updateUIselEditsPropPanel, -150
   If !givenStep
      SetTimer, dummyOffsetSelProperPanel, -250
}

updateUIchangeSelectionType() {
   If (AnyWindowOpen!=34)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, SelectionCoordsType
   GuiControlGet, userDefinedSelCoords
   trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   GuiControl, SettingsGUIA:, NewPosX1, 0
   GuiControl, SettingsGUIA:, NewPosY1, 0
   If (SelectionCoordsType=1)
   {
      GuiControl, SettingsGUIA:, NewPosX2, % imgW//2
      GuiControl, SettingsGUIA:, NewPosY2, % imgH//2
   } Else
   {
      GuiControl, SettingsGUIA:, NewPosX2, 50
      GuiControl, SettingsGUIA:, NewPosY2, 50
   }
   updateUIselPropPanel()
}

BTNselectEntireImg() {
   BtnCloseWindow()
   selectEntireImage()
}

updateUIselPropPanel() {
   If (AnyWindowOpen!=34)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, NewPosX1, SettingsGUIA:, NewPosX1
   GuiControlGet, NewPosY1, SettingsGUIA:, NewPosY1
   GuiControlGet, NewPosX2, SettingsGUIA:, NewPosX2
   GuiControlGet, NewPosY2, SettingsGUIA:, NewPosY2
   ; GuiControlGet, NewVProt, SettingsGUIA:, NewVProt
   GuiControlGet, lockSelectionAspectRatio, SettingsGUIA:, lockSelectionAspectRatio
   GuiControlGet, userDefinedSelCoords, SettingsGUIA:, userDefinedSelCoords
   GuiControlGet, SelectionCoordsType, SettingsGUIA:, SelectionCoordsType
   GuiControlGet, LimitSelectBoundsImg, SettingsGUIA:, LimitSelectBoundsImg
   GuiControlGet, rotateSelBoundsKeepRatio, SettingsGUIA:, rotateSelBoundsKeepRatio
   
   If (lockSelectionAspectRatio>1)
   {
      userDefinedSelCoords := 0
      LimitSelectBoundsImg := 0
      GuiControl, SettingsGUIA:, userDefinedSelCoords, 0
      GuiControl, SettingsGUIA:, LimitSelectBoundsImg, 0
      GuiControl, SettingsGUIA: Disable, userDefinedSelCoords
      GuiControl, SettingsGUIA: Disable, LimitSelectBoundsImg
   } Else
   {
      GuiControl, SettingsGUIA: Enable, userDefinedSelCoords
      GuiControl, SettingsGUIA: Enable, LimitSelectBoundsImg
   }

   defineSelectionAspectRatios()
   ; ToggleEditImgSelection("show-edit")
   trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   actuA := (userDefinedSelCoords=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   INIaction(1, "LimitSelectBoundsImg", "General")
   ; If (userDefinedSelCoords=1)
   ;    lockSelectionAspectRatio := 0

   If (lockSelectionAspectRatio>1)
   {
      GuiControl, SettingsGUIA: Disable, BtnPosX1m
      GuiControl, SettingsGUIA: Disable, BtnPosX2m
   } Else
   {
      GuiControl, % actuA, BtnPosX1m
      GuiControl, % actuA, BtnPosX2m
   }

   GuiControl, % actuA, btnFldr6
   GuiControl, % actuA, BtnPosY1m
   GuiControl, % actuA, BtnPosY2m
   GuiControl, % actuA, BtnPosXm
   GuiControl, % actuA, BtnPosYm
   GuiControl, % actuA, BtnPosZm

   actuB := (userDefinedSelCoords=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actuB, txtLine1
   GuiControl, % actuB, txtLine2
   GuiControl, % actuB, txtLine3
   GuiControl, % actuB, txtLine4
   GuiControl, % actuB, NewPosX1
   GuiControl, % actuB, NewPosY1
   GuiControl, % actuB, NewPosX2
   GuiControl, % actuB, NewPosY2
   GuiControl, % actuB, SelectionCoordsType
   If (userDefinedSelCoords=1)
   {
      If (SelectionCoordsType=1)
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := imgW//2
         If !IsNumber(NewPosY2)
            NewPosY2 := imgH//2
         imgSelX1 := Round(NewPosX1), imgSelY1 := Round(NewPosY1)
         imgSelX2 := Round(NewPosX2), imgSelY2 := Round(NewPosY2)
      } Else
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := 50
         If !IsNumber(NewPosY2)
            NewPosY2 := 50
         wNewPosX1 := min(NewPosX1, NewPosX2)
         wNewPosX2 := max(NewPosX1, NewPosX2)

         wNewPosY1 := min(NewPosY1, NewPosY2)
         wNewPosY2 := max(NewPosY1, NewPosY2)
         imgSelX1 := Round(imgW*(Abs(wNewPosX1)/100), 3), imgSelY1 := Round(imgH*(Abs(wNewPosY1)/100), 3)
         imgSelX2 := Round(imgW*(Abs(wNewPosX2)/100), 3), imgSelY2 := Round(imgH*(Abs(wNewPosY2)/100), 3)
      }
   }

   ; If !IsNumber(NewVProt)
   ;    NewVProt := 0

   ; VPselRotation := clampInRange(Round(NewVProt), 0, 360, 1)
   dummyTimerDelayiedImageDisplay(50)
   Return
}

updateUInewImagePanel() {
    If (AnyWindowOpen!=27)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, PredefinedDocsSizes
    GuiControlGet, NewDocUseColor
    GuiControlGet, NewImageReverseDimensions

    actu := (NewDocUseColor=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, PickuOutlierFillColor
    actu := (NewDocUseColor=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu, OutlierFillColor
    uiSlidersArray["OutlierFillOpacity", 10] := NewDocUseColor

    GetPresetDocSizes(PredefinedDocsSizes, UserNewWidth, UserNewHeight, UserNewDPI)
    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := OutlierFillOpacity
    GuiRefreshSliders()
    If (PredefinedDocsSizes<13)
    {
       GuiControl, SettingsGUIA:, UserNewWidth, % UserNewWidth
       GuiControl, SettingsGUIA:, UserNewHeight, % UserNewHeight
       GuiControl, SettingsGUIA:, UserNewDPI, % UserNewDPI
    }
}

GetPresetDocSizes(docSize, ByRef UserNewWidth, ByRef UserNewHeight, ByRef UserNewDPI) {
    If (docSize=1)
    {
       vpWinClientSize(UserNewWidth, UserNewHeight, PVhwnd, 0)
       UserNewDPI := A_ScreenDPI
    } Else If (docSize=2)
    {
       calcScreenLimits()
       UserNewWidth := ResolutionWidth
       UserNewHeight := ResolutionHeight
       UserNewDPI := A_ScreenDPI
    } Else If (docSize=3)
    {
       If useGdiBitmap()
       {
          Gdip_BitmapGetDPIResolution(useGdiBitmap(), dpix, dpiy)
          trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
          UserNewDPI := (dpix + dpiy)//2
       } Else
       {
          vpWinClientSize(imgW, imgH, PVhwnd, 0)
          UserNewDPI := A_ScreenDPI
       }
       UserNewWidth := imgW
       UserNewHeight := imgH
    } Else If (docSize=4)
    {
       UserNewWidth := 640
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (docSize=5)
    {
       UserNewWidth := 800
       UserNewHeight := 600
       UserNewDPI := 72
    } Else If (docSize=6)
    {
       UserNewWidth := 1024
       UserNewHeight := 768
       UserNewDPI := 72
    } Else If (docSize=7)
    {
       UserNewWidth := 858
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (docSize=8)
    {
       UserNewWidth := 1280
       UserNewHeight := 720
       UserNewDPI := 72
    } Else If (docSize=9)
    {
       UserNewWidth := 1920
       UserNewHeight := 1080
       UserNewDPI := 72
    } Else If (docSize=10)
    {
       UserNewWidth := 3860
       UserNewHeight := 2160
       UserNewDPI := 72
    } Else If (docSize=11)
    {
       UserNewWidth := 2480
       UserNewHeight := 3508
       UserNewDPI := 300
    } Else If (docSize=12)
    {
       UserNewWidth := 1240
       UserNewHeight := 1754
       UserNewDPI := 150
    } Else If (docSize=14)
    {
       UserNewWidth := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
       UserNewHeight := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
       UserNewDPI := 72
    }
}

NewImageEditResponder() {
   If (AnyWindowOpen!=27)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, UserNewWidth
   GuiControlGet, UserNewHeight
   GuiControlGet, UserNewDPI
   GuiControlGet, whichFocused, FocusV

   If (whichFocused="UserNewWidth" || whichFocused="UserNewHeight" || whichFocused="UserNewDPI")
   {
      PredefinedDocsSizes := 13
      GuiControl, SettingsGUIA: Choose, PredefinedDocsSizes, 13
   }
   mpx := Round((UserNewWidth * UserNewHeight)/1000000, 1)
   f := isImgSizeTooLarge(UserNewWidth, UserNewHeight) ? "(!) " : ""
   GuiControl, SettingsGUIA: , infoline, %f%%mpx% MPx
}

BtnCreateNewImage() {
    Static clippyCount
    If (AnyWindowOpen!=27)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, UserNewWidth
    GuiControlGet, UserNewHeight
    GuiControlGet, UserNewDPI
    GuiControlGet, NewDocUseColor
    GuiControlGet, NewImageReverseDimensions
    If (UserNewWidth<5 || UserNewHeight<5 || UserNewDPI<5)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": WARNING", "Incorrect dimensions provided for the new image. Please increase the dimensions.", 0, 0, "exclamation")
       Return
    }

    If isImgSizeTooLarge(UserNewWidth, UserNewHeight)
    {
       SoundBeep, 300, 100
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image dimensions exceed the maximum limits. Width and height cannot exceed 199000 pixels, and total image size cannnot exceed 536 MPx.`n`nWould you like to adapt the dimensions and create the new image?", "&Yes|&No", 1, "exclamation")
       If (msgResult="Yes")
          capIMGdimensionsGDIPlimits(UserNewWidth, UserNewHeight)
       Else
          Return
    }

    RegAction(1, "NewDocUseColor")
    RegAction(1, "PredefinedDocsSizes")
    RegAction(1, "NewImageReverseDimensions")
    DestroyGIFuWin()
    BtnCloseWindow()
    isImgOpen := isImgEditingNow()
    If (viewportQPVimage.imgHandle)
    {
       If askAboutFileSave(" and new image will be created")
          Return

       discardSRCfileCaches()
       destroyGDIfileCache()
       discardViewPortCaches()
       disposeCacheIMGs()
       terminateIMGediting()
       isImgOpen := 0
    }

    showTOOLtip("Creating the new image, please wait")
    PredefinedDocsSizes := 13
    setImageLoading()
    calcScreenLimits()
    mustOpenStartFolder := ""
    ; terminateIMGediting()
    discardViewPortCaches()
    clippyCount++
    If (NewImageReverseDimensions=1)
    {
       tUserNewWidth := UserNewHeight
       tUserNewHeight := UserNewWidth
    } Else
    {
       tUserNewWidth := UserNewWidth
       tUserNewHeight := UserNewHeight
    }

    newBitmap := trGdip_CreateBitmap(A_ThisFunc, tUserNewWidth, tUserNewHeight, coreDesiredPixFmt)
    If !validBMP(newBitmap)
    {
       showTOOLtip("Failed to create new image.`nUnable to allocate the new bitmap.")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       clippyCount--
       Return
    }

    zoomLevel := IMGresizingMode := 1
    Gdip_BitmapSetResolution(newBitmap, UserNewDPI, UserNewDPI)
    If (NewDocUseColor=1)
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
       If G2
       {
          thisColor := makeRGBAcolor(OutlierFillColor, OutlierFillOpacity)
          Gdip_GraphicsClear(G2, thisColor)
          ; Gdip_SetClipRect(G2, tUserNewWidth//2, 0, tUserNewWidth, tUserNewHeight)
          ; Gdip_GraphicsClear(G2, "0x99FFaa22")
          ; Gdip_SetClipRect(G2, tUserNewWidth//1.25, 0, tUserNewWidth, tUserNewHeight)
          ; Gdip_GraphicsClear(G2, "0x99FF1122")
          Gdip_DeleteGraphics(G2)
       } Else
          addJournalEntry("Failed to fill the new image with the user defined background color. GDI+ object was not created.")
    }

    If (!currentFileIndex || !CurrentSLD || !maxFilesIndex)
    {
       maxFilesIndex := currentFileIndex := 0
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\New-" clippyCount ".img"
    }

    currIMGdetails.HasAlpha := 1
    If (NewDocUseColor=1 && OutlierFillOpacity>253)
       currIMGdetails.HasAlpha := 0

    imgIndexEditing := currentFileIndex
    currentImgModified := usrColorDepth := imgFxMode := 1
    vpIMGrotation := FlipImgH := FlipImgV := 0
    UserMemBMP := newBitmap
    resetImgSelection()
    INIaction(1, "FlipImgH", "General")
    INIaction(1, "FlipImgV", "General")
    INIaction(1, "usrColorDepth", "General")
    INIaction(1, "imgFxMode", "General")
    INIaction(1, "vpIMGrotation", "General")
    dropFilesSelection(1)
    RemoveTooltip()
    If isImgOpen
       wrapRecordUndoLevelNow(newBitmap)
    Else
       gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, newBitmap)

    dummyTimerDelayiedImageDisplay(5)
    SetTimer, createGUItoolbar, -100
    SetTimer, TriggerMenuBarUpdate, -90
    SetTimer, ResetImgLoadStatus, -50
}

BtnDrawLinesSelectedArea() {
  If throwErrorSelectionOutsideBounds()
     Return

  updateUIDrawLinesPanel("noPreview")
  GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply

  If (DrawLineAreaBorderTop=0 && DrawLineAreaBorderBottom=0 && DrawLineAreaBorderLeft=0 && DrawLineAreaBorderRight=0
  && DrawLineAreaBorderCenter=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=0)
  {
     SoundBeep , 300, 100
     showTOOLtip("WARNING: No lines to draw selected")
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
  If (closeEditPanelOnApply=1)
     BtnCloseWindow()

  Sleep, 1
  prevImgEditZeit := A_TickCount
  ToggleEditImgSelection("show-edit")
  DrawLinesInSelectedArea(1)
  prevImgEditZeit := A_TickCount
  SetTimer, RemoveTooltip, -250
}

updateUIDrawLinesPanel(actionu:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=30)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    actu := (DrawLineAreaBorderCenter<4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, freeHandSelectionMode

    actu := isInRange(DrawLineAreaBorderCenter, 4, 6) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, DrawLineAreaCropShape
    GuiControl, % actu, txtLine2

    actu := (DrawLineAreaBorderCenter<4) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu, DrawLineAreaBorderTop
    GuiControl, % actu, DrawLineAreaBorderLeft

    actu := (DrawLineAreaBorderCenter=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu, DrawLineAreaBorderArcD
    GuiControl, % actu, DrawLineAreaBorderArcC
    GuiControl, % actu, DrawLineAreaBorderArcB
    GuiControl, % actu, DrawLineAreaBorderArcA
    GuiControl, % actu, DrawLineAreaBorderRight
    GuiControl, % actu, DrawLineAreaBorderBottom
    GuiControl, % actu, DrawLineAreaBorderConnector

    actu := (freeHandSelectionMode=1 && DrawLineAreaBorderCenter=3) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
    GuiControl, % actu, DrawLineAreaBorderLeft
    GuiControl, % actu, DrawLineAreaBorderTop

    actu := (freeHandSelectionMode=1 && DrawLineAreaBorderCenter=3) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu, DrawLineAreaSnapLine

    stringu := (DrawLineAreaBorderCenter=4) ? "Lines density" : "Density X"
    uiSlidersArray["DrawLineAreaGridX", 5] := stringu

    actu := (DrawLineAreaBorderCenter=4 || DrawLineAreaBorderCenter=6) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiUpdateVisibilitySliders(actu, "DrawLineAreaRaysLimit")
    GuiUpdateVisibilitySliders(actu, "DrawLineAreaAltRays")

    isActive := (DrawLineAreaEqualGrid=1) ? 0 : 1
    uiSlidersArray["DrawLineAreaGridY", 10] := isActive

    isActive := (DrawLineAreaBorderCenter=4) ? 1 : 0
    uiSlidersArray["DrawLineAreaRaysLimit", 10] := isActive
    uiSlidersArray["DrawLineAreaAltRays", 10] := isActive

    actu := (DrawLineAreaBorderCenter=4 || DrawLineAreaBorderCenter=6) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiUpdateVisibilitySliders(actu, "DrawLineAreaCenterCut")

    actu := (DrawLineAreaBorderCenter=5) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiUpdateVisibilitySliders(actu, "DrawLineAreaGridY")
    GuiControl, % actu, DrawLineAreaEqualGrid
    GuiControl, % actu, DrawLineAreaAtomizedGrid
    GuiControl, % actu, DrawLineAreaGridCenter

    actu := isInRange(DrawLineAreaBorderCenter, 5, 6) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu, infoLine

    actu := (DrawLineAreaBorderCenter=4 || DrawLineAreaBorderCenter=5) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiUpdateVisibilitySliders(actu, "DrawLineAreaGridX")

    actu := (DrawLineAreaBorderCenter=6) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiUpdateVisibilitySliders(actu, "DrawLineAreaSpiralLength")
    GuiControl, % actu, DrawLineAreaSpiralCenterMode

    If (actionu!="noPreview") && (A_TickCount - lastInvoked>50)
    {
       GuiRefreshSliders()
       lastInvoked := A_TickCount
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)
    }
 
    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := DrawLineAreaOpacity
    SetTimer, WriteSettingsDrawLinesPanel, -250
}

WriteSettingsDrawLinesPanel() {
    ReadSettingsDrawLinesArea(1)
}

updateUIdrawShapesPanel(actionu:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=65)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide

    decideCustomShapeStyle()
    actu := (FillAreaShape=2) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiUpdateVisibilitySliders(actu, "FillAreaRectRoundness")

    actu := (FillAreaShape=3 && !viewportQPVimage.imgHandle) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu, FillAreaEllipsePie
    actu := (FillAreaShape=3) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiUpdateVisibilitySliders(actu, "FillAreaEllipseSection")
    If (viewportQPVimage.imgHandle)
       uiSlidersArray["userUIshapeCavity", 10] := (FillAreaShape=7) ? 0 : 1

    actu := (FillAreaEllipseSection<848 && !viewportQPVimage.imgHandle) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, FillAreaEllipsePie

    actu := (FillAreaShape=7) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu, btn1
    GuiControl, % actu, FillAreaClosedPath
    GuiControl, % actu, FillAreaCurveTension
    If (FillAreaShape=3)
       EllipseSelectMode := 1
    Else If (FillAreaShape=7)
       EllipseSelectMode := 2
    Else
       EllipseSelectMode := 0

    GuiRefreshSliders()
    closedLineCustomShape := FillAreaClosedPath
    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := DrawLineAreaOpacity
    ; ToggleEditImgSelection("show-edit")
    If (actionu!="noPreview") && (A_TickCount - lastInvoked>50)
    {
       lastInvoked := A_TickCount
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)
    }
    SetTimer, dummyRefreshImgSelectionWindow, -50
    SetTimer, WriteSettingsDrawShapeAreaPanel, -250
}

updateUIzoomBlurPanel(a:=0,b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=69)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (coreDesiredPixFmt="0x21808")
    {
       BlurAreaBlendMode := 0
       GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
       GuiControl, SettingsGUIA: Disable, BlurAreaBlendMode
       GuiControl, SettingsGUIA: Choose, BlurAreaBlendMode, 1
    }
    actu := (BlurAreaBlendMode>1) ? "Enabled" : "Disabled"
    GuiControl, SettingsGUIA: %actu%, blurAreaApplyFX
    isActive := (BlurAreaBlendMode>1 && blurAreaApplyFX=1) ? 1 : 0
    uiSlidersArray["BlurAreaLight", 10] := isActive
    uiSlidersArray["BlurAreaGamma", 10] := isActive
    uiSlidersArray["BlurAreaHue", 10] := isActive
    uiSlidersArray["BlurAreaSaturation", 10] := isActive
    GuiRefreshSliders()

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsZoomBlurPanel, -300
    If (a!="no-preview")
       updateLiveTinyPreviewsWindow(a, b)
}

updateUIblurPanel(a:=0,b:=0) {
    Static lastInvoked := 1
    okayu := (AnyWindowOpen=78 || AnyWindowOpen=26) ? 1 : 0
    If (okayu!=1)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (coreDesiredPixFmt="0x21808")
    {
       BlurAreaBlendMode := 0
       GuiControl, SettingsGUIA: Disable, BlurAreaBlendMode
       GuiControl, SettingsGUIA: Choose, BlurAreaBlendMode, 1
    }

    If (AnyWindowOpen=78)
    {
       actu := (blurAreaPixelizeAmount>1 && !viewportQPVimage.imgHandle) ? 1 : 0
       uiSlidersArray["blurAreaAmount", 10] := actu
       actu := (blurAreaPixelizeAmount>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, blurAreaPixelizeMethod
       GuiControl, % actu, mainBtnACT
    } Else If (AnyWindowOpen=26)
    {
       If (coreDesiredPixFmt="0x21808")
       {
          blurAreaSoftEdges := 0
          GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
          GuiControl, SettingsGUIA:, blurAreaSoftEdges, 0
       }

       pr := (blurAreaEqualXY=1) ? blurAreaAmount : max(blurAreaAmount, blurAreaYamount)
       actu := testAllowSelInvert() ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       If (pr>1)
       {
          GuiControl, SettingsGUIA: Enable, blurAreaMode
          GuiControl, SettingsGUIA: Enable, mainBtnACT
          GuiControl, % actu, blurAreaSoftEdges
          GuiControl, % actu, blurAreaSoftLevel
          If (blurAreaSoftEdges=1)
             GuiControl, SettingsGUIA: Enable, blurAreaTwice
       } Else
       {
          GuiControl, SettingsGUIA: Disable, blurAreaMode
          GuiControl, SettingsGUIA: Disable, blurAreaTwice
          GuiControl, SettingsGUIA: Disable, mainBtnACT
          GuiControl, % actu, blurAreaSoftEdges
          GuiControl, % actu, blurAreaSoftLevel
       }

       actu := (blurAreaMode>=4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, blurAreaCircular

       actu := (blurAreaSoftEdges=1 && pr>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, blurAreaSoftLevel

       actu2 := (blurAreaMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, blurAreaEqualXY

       isActive := (blurAreaMode>1 && blurAreaEqualXY!=1) ? 1 : 0
       uiSlidersArray["blurAreaYamount", 10] := isActive
    }

    actu := (BlurAreaBlendMode>1) ? "Enabled" : "Disabled"
    GuiControl, SettingsGUIA: %actu%, blurAreaApplyFX
    isActive := (BlurAreaBlendMode>1 && blurAreaApplyFX=1) ? 1 : 0
    uiSlidersArray["BlurAreaLight", 10] := isActive
    uiSlidersArray["BlurAreaGamma", 10] := isActive
    uiSlidersArray["BlurAreaHue", 10] := isActive
    uiSlidersArray["BlurAreaSaturation", 10] := isActive
    GuiRefreshSliders()
    lastInvoked := A_TickCount
    If (a!="no-preview")
       updateLiveTinyPreviewsWindow(a, b)

    SetTimer, WriteSettingsBlurPanel, -300
}

gradientsPreviewResponder(thisHwnd:=0) {
   keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0
   otherKeyState := GetKeyState("Alt", "P") ? 1 : 0
   If (thisHwnd=hCropCornersPic && AnyWindowOpen=64)
      winOpen := 64
   Else If (thisHwnd=hGradientFillpreview && AnyWindowOpen=23)
      winOpen := 23
   Else If (thisHwnd=hGradientAlphaMSKpreview && isAlphaMaskWindow())
      winOpen := "x"
   Else
      Return

   GetPhysicalCursorPos(zX, zY)
   setWhileLoopExec(1)
   If (otherKeyState=1)
   {
      varXvalue := (winOpen!=23) ? alphaMaskCoffsetX : clrGradientCoffX
      varYvalue := (winOpen!=23) ? alphaMaskCoffsetY : clrGradientCoffY
   } Else
   {
      varXvalue := (winOpen!=23) ? alphaMaskOffsetX : clrGradientOffX
      varYvalue := (winOpen!=23) ? alphaMaskOffsetY : clrGradientOffY
   }

   WinGetPos, , , W, H, ahk_id %thisHwnd%
   px := w, py := ph
   w *=2, h *= 2
   While, (determineLClickState()=1)
   {
      Sleep, 1
      If !keysState
         keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

      GetPhysicalCursorPos(mX, mY)
      If (isInRange(mX, zX - 2, zX + 2) && isInRange(mY, zY - 2, zY + 2))
         Continue

      GetMouseCoord2wind(thisHwnd, nX, nY)
      Sleep, 1
      varXvalue := clampInRange( Round( (nX / w) * 2, 4) , 0, 2) - 1
      varYvalue := clampInRange( Round( (nY / h) * 2, 4) , 0, 2) - 1
      If (otherKeyState=1)
      {
         If (winOpen=23)
         {
            clrGradientCoffX := clampInRange(varXvalue, -0.999, 0.999)
            clrGradientCoffY := clampInRange(varYvalue, -0.999, 0.999)
         } Else
         {
            alphaMaskCoffsetX := clampInRange(varXvalue, -0.999, 0.999)
            alphaMaskCoffsetY := clampInRange(varYvalue, -0.999, 0.999)
         }
      } Else
      {
         If (winOpen=23)
         {
            clrGradientOffX := clampInRange(varXvalue, -0.999, 0.999)
            clrGradientOffY := clampInRange(varYvalue, -0.999, 0.999)
         } Else
         {
            alphaMaskOffsetX := clampInRange(varXvalue, -0.999, 0.999)
            alphaMaskOffsetY := clampInRange(varYvalue, -0.999, 0.999)
         }
      }

      zX := mX, zY := mY
      Sleep, 2
      If (winOpen=64)
      {
         createLivePreviewBrush()
      } Else 
      {
         livePreviewsImageEditing()
         zz := (winOpen=23) ? 0 : 1
         updateUIgradientPreviewAlphaMask(zz)
      }
   }

   setWhileLoopExec(0)
   ; ToolTip, % vPosX "==" vPosY "`n" alphaMaskOffsetX "==" alphaMaskOffsetY , , , 2
   If (keysState=1 && winOpen=23)
      clrGradientOffX := clrGradientOffY := clrGradientCoffX := clrGradientCoffY := 0
   Else If (keysState=1)
      alphaMaskOffsetX := alphaMaskOffsetY := alphaMaskCoffsetX := alphaMaskCoffsetY := 0

   zz := (winOpen=23) ? 0 : 1
   If (winOpen=64)
      SetTimer, updateUIbrushTool, -150
   Else
      updateUIgradientPreviewAlphaMask(zz)
}

UIresponderPanelsLivePreview(a, b, c) {
   ; ToolTip, % a "=" b "=" c , , , 2
   SetTimer, PanelsPanIMGpreviewClick, -15
}

PanelsPanIMGpreviewClick(a:=0) {
   Static noPreview := 0
   keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0
   If (AnyWindowOpen=64 && !(BrushToolType=3 || BrushToolType=5))
      Return

   trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   ; vpWinClientSize(mainWidth, mainHeight)
   Sleep, 0
   GetPhysicalCursorPos(oX, oY)
   newPosZeit := A_TickCount
   oDx := tinyPrevAreaCoordX, oDy := tinyPrevAreaCoordY
   zX := oX, zY := oY
   thisZeit := A_TickCount
   startZeit := A_TickCount
   hasRun := 0
   setWhileLoopExec(1)
   While, (determineLClickState()=1)
   {
      Sleep, 1
      If !keysState
         keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

      GetPhysicalCursorPos(mX, mY)
      skipLoop := (isInRange(mX, zX - 2, zX + 2) && isInRange(mY, zY - 2, zY + 2)) ? 1 : 0
      Dx := mX - oX + 1
      Dy := mY - oY + 1
      tinyPrevAreaCoordX := oDx - Dx
      tinyPrevAreaCoordY := oDy - Dy
      tinyPrevAreaCoordX := clampInRange(tinyPrevAreaCoordX, 120, imgW)
      tinyPrevAreaCoordY := clampInRange(tinyPrevAreaCoordY, 120, imgH)
      If (A_TickCount - newPosZeit>750) || (mX=oX && mY=oY)
      {
         newPosZeit := A_TickCount
         zX := mX, zY := mY
         If (skipLoop=1)
            Continue
      } Else If (skipLoop=1)
         Continue

      If (A_TickCount - thisZeit>15)
      {
         hasRun := 1
         noPreview := 0
         ; If (A_TickCount - thisZeit>95)
         ; zeitSillyPrevent := A_TickCount
         coreUpdateLiveTinyPreviewsWindow()
         dummyRefreshImgSelectionWindow()
         thisZeit := A_TickCount
      }
   }
   setWhileLoopExec(0)
   If !keysState
      keysState := (GetKeyState("Shift", "P") || GetKeyState("Ctrl", "P")) ? 1 : 0

   If (keysState=1 && hasRun=0 && noPreview=0)
   {
      noPreview := 1
      livePreviewsPanelNoEffects()
   } Else If !hasRun
   {
      If (noPreview=0 && (A_TickCount - startZeit<350))
         doubleBlurPreviewArea := !doubleBlurPreviewArea

      noPreview := 0
      If (AnyWindowOpen=26 || AnyWindowOpen=78)
         updateUIblurPanel()
      Else If (AnyWindowOpen=43 || AnyWindowOpen=79)
         updateUIedgesPanel()
      Else If (AnyWindowOpen=44)
         updateUIaddNoisePanel()
      Else If (AnyWindowOpen=69)
         updateUIzoomBlurPanel()
   }
}

livePreviewBlurPanel() {
    WinGetPos, , , uiboxSizeW, uiboxSizeH, ahk_id %hCropCornersPic%
    o_uiBoxSizeW := uiBoxSizeW,    o_uiBoxSizeH := uiBoxSizeH
    imgBoxSizeW := (doubleBlurPreviewArea=1) ? uiboxSizeW*2 : uiboxSizeW
    imgBoxSizeH := (doubleBlurPreviewArea=1) ? uiboxSizeH*2 : uiboxSizeH
    WriteSettingsBlurPanel()
    whichBmp := useGdiBitmap()
    If !validBMP(whichBmp)
       Return

    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSizeW, uiboxSizeH, coreDesiredPixFmt)
    If !validBMP(cornersBMP)
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GraphicsClear(G, "0xFF666666")
    fnOutputDebug("redraw: " A_ThisFunc)
    trGdip_GetImageDimensions(whichBmp, imgW, imgH)
    cX := (uiboxSizeW<imgW) ? 0 : uiboxSizeW//2 - imgW//2
    cY := (uiboxSizeH<imgH) ? 0 : uiboxSizeH//2 - imgH//2
    ald := (uiboxSizeH<imgH) ? 1 : 0
    imgBoxSizeW := min(imgW, imgBoxSizeW)
    imgBoxSizeH := min(imgH, imgBoxSizeH)
    uiBoxSizeW := min(imgW, uiBoxSizeW)
    uiBoxSizeH := min(imgH, uiBoxSizeH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSizeW//2, 0, imgW - imgBoxSizeW)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSizeH//2, 0, imgH - imgBoxSizeH)
    uiBoxSizeW := o_uiBoxSizeW,    uiBoxSizeH := o_uiBoxSizeH
    imgBoxSizeW := (doubleBlurPreviewArea=1 && ald=1) ? uiboxSizeW*2 : uiboxSizeW
    imgBoxSizeH := (doubleBlurPreviewArea=1 && ald=1) ? uiboxSizeH*2 : uiboxSizeH

    thisBlurMode := blurAreaMode
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    thisOpacity := blurAreaOpacity/255
    thisBlurAmount := (doubleBlurPreviewArea=1) ? blurAreaAmount//2 : blurAreaAmount
    thisBlurAmountY := (doubleBlurPreviewArea=1) ? blurAreaYamount//2 : blurAreaYamount
    If (AnyWindowOpen=78)
       thisBlurAmount := thisBlurAmountY := 0

    If (blurAreaEqualXY=1 && AnyWindowOpen=26)
    {
       thisBlurAmountY := (doubleBlurPreviewArea=1) ? blurAreaAmount//2 : blurAreaAmount
       If (blurAreaMode=2)
       {
          thisBlurAmount := Round(thisBlurAmount*0.5)
          thisBlurAmountY := Round(thisBlurAmountY*0.5)
       }
    }

    If (thisBlurMode=1)
       bEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)

    If (viewportQPVimage.imgHandle)
    {
       thisBMP := viewportQPVimage.ImageGetResizedRect(thisPrevieCoordX, thisPrevieCoordY, imgBoxSizeW, imgBoxSizeH, imgBoxSizeW, imgBoxSizeH, userimgQuality)
       r1 := trGdip_DrawImage(A_ThisFunc, G, thisBMP, cX, cY, uiboxSizeW, uiboxSizeH)
       trGdip_DisposeImage(thisBMP)
    } Else
       r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, cX, cY, uiboxSizeW, uiboxSizeH, thisPrevieCoordX, thisPrevieCoordY, imgBoxSizeW, imgBoxSizeH)

    If (BlurAreaBlendMode>1)
       bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, cornersBMP)

    If pEffect
       Gdip_BitmapApplyEffect(cornersBMP, pEffect)

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    r1 := trGdip_DrawImage(A_ThisFunc, G, zBitmap, 0, 0, uiboxSizeW, uiboxSizeH, 0, 0, uiboxSizeW, uiboxSizeH, 1, 2, imageAttribs)
    yBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    If (blurAreaPixelizeAmount>1 && AnyWindowOpen=78)
    {
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSizeW, uiboxSizeH, coreDesiredPixFmt)
       QPV_PixelateBitmap(yBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, min(uiboxSizeW, uiboxSizeH)))
       prevBMPu := yBitmap
       yBitmap:= pixiBMP
    }

    Gdip_DisposeImageAttributes(imageAttribs)
    If (blurAreaTwice=1 && AnyWindowOpen=26)
    {
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, uiboxSizeW//2, uiboxSizeH//2, 1, 3, -1)
       If validBMP(xBitmap)
       {
          prevBMPa := yBitmap
          yBitmap := xBitmap
       }

       If (bEffect && thisBlurMode=1)
          ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
       Else If (thisBlurMode=2)
          QPV_BoxBlurBitmap(yBitmap, thisBlurAmount, thisBlurAmountY, 0)
       Else If (thisBlurMode=8)
       {
          zyBitmap := QPV_DissolveBitmap(yBitmap, thisBlurAmount*1.5, thisBlurAmountY*1.5)
          If validBMP(zyBitmap)
          {
             trGdip_DisposeImage(yBitmap)
             yBitmap := zyBitmap
          }
       } Else If (thisBlurMode>=3)
          QPV_BoxBlurBitmap(yBitmap, thisBlurAmount, thisBlurAmountY, thisBlurMode - 2, 0, blurAreaCircular, 1)

       cBitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, uiboxSizeW, uiboxSizeH, 1, 3, -1)
       If validBMP(cBitmap)
       {
          prevBMPc := yBitmap
          yBitmap := cBitmap
          sF := 1
       } Else sF := 1
    } Else sF := 1

    thisBlur := (doubleBlurPreviewArea=1) ? blurAreaAmount//2 : blurAreaAmount
    If (AnyWindowOpen=78 && blurAreaAmount>2)
       QPV_BoxBlurBitmap(yBitmap, thisBlur, thisBlur, 0)
    Else If (bEffect && thisBlurMode=1)
       ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
    Else If (thisBlurMode=2)
       QPV_BoxBlurBitmap(yBitmap, thisBlurAmount, thisBlurAmountY, 0)
    Else If (thisBlurMode=8)
    {
       zyBitmap := QPV_DissolveBitmap(yBitmap, thisBlurAmount*1.5, thisBlurAmountY*1.5)
       If validBMP(zyBitmap)
       {
          trGdip_DisposeImage(yBitmap)
          yBitmap := zyBitmap
       }
    } Else If (thisBlurMode>=3)
       QPV_BoxBlurBitmap(yBitmap, thisBlurAmount, thisBlurAmountY, thisBlurMode - 2, 0, blurAreaCircular, 1)

    If (BlurAreaBlendMode>1)
    {
       applyBlurColorsFX(yBitmap)
       rz := QPV_BlendBitmaps(bgrBMPu, yBitmap, BlurAreaBlendMode - 1, 0, BlendModesFlipped)
       ; ToolTip, % "l=" rz , , , 2
       ou := yBitmap
       yBitmap := bgrBMPu
       bgrBMPu := ou
    }

    ; thisBMP := (BlurAreaBlendMode>1) ? bgrBMPu : cornersBMP
    r1 := trGdip_DrawImage(A_ThisFunc, G, yBitmap, 0, 0, uiboxSizeW, uiboxSizeH, 0, 0, uiboxSizeW // sF, uiboxSizeH // sF, thisOpacity)
    Gdip_DeleteGraphics(G)
    flipBitmapAccordingToViewPort(cornersBMP, 1)
    If (r1!="fail")
       Gdip_SetPbitmapCtrl(hCropCornersPic, cornersBMP)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(yBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    trGdip_DisposeImage(prevBMPu, 1)
    trGdip_DisposeImage(prevBMPa, 1)
    trGdip_DisposeImage(prevBMPc, 1)
    trGdip_DisposeImage(cornersBMP, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(bEffect)
}

livePreviewZoomBlurPanel() {
    WinGetPos, , , uiboxSizeW, uiboxSizeH, ahk_id %hCropCornersPic%
    o_uiBoxSizeW := uiBoxSizeW,    o_uiBoxSizeH := uiBoxSizeH
    imgBoxSizeW := (doubleBlurPreviewArea=1) ? uiboxSizeW*2 : uiboxSizeW
    imgBoxSizeH := (doubleBlurPreviewArea=1) ? uiboxSizeH*2 : uiboxSizeH
    whichBmp := useGdiBitmap()
    If !validBMP(whichBmp)
       Return

    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSizeW, uiboxSizeH, coreDesiredPixFmt)
    If !validBMP(cornersBMP)
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    fnOutputDebug("redraw: " A_ThisFunc)
    Gdip_GraphicsClear(G, "0xFF666666")
    trGdip_GetImageDimensions(whichBmp, imgW, imgH)
    cX := (uiboxSizeW<imgW) ? 0 : uiboxSizeW//2 - imgW//2
    cY := (uiboxSizeH<imgH) ? 0 : uiboxSizeH//2 - imgH//2
    ald := (uiboxSizeH<imgH) ? 1 : 0
    imgBoxSizeW := min(imgW, imgBoxSizeW)
    imgBoxSizeH := min(imgH, imgBoxSizeH)
    uiBoxSizeW := min(imgW, uiBoxSizeW)
    uiBoxSizeH := min(imgH, uiBoxSizeH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSizeW//2, 0, imgW - imgBoxSizeW)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSizeH//2, 0, imgH - imgBoxSizeH)
    uiBoxSizeW := o_uiBoxSizeW,    uiBoxSizeH := o_uiBoxSizeH
    imgBoxSizeW := (doubleBlurPreviewArea=1 && ald=1) ? uiboxSizeW*2 : uiboxSizeW
    imgBoxSizeH := (doubleBlurPreviewArea=1 && ald=1) ? uiboxSizeH*2 : uiboxSizeH

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    thisOpacity := blurAreaOpacity/255
    zoomBlurAreaXamount := uiZoomBlurAreaXamount/10
    thisBlurAmount := (doubleBlurPreviewArea=1) ? zoomBlurAreaXamount*2 : zoomBlurAreaXamount*4
    If (viewportQPVimage.imgHandle)
    {
       thisBMP := viewportQPVimage.ImageGetResizedRect(thisPrevieCoordX, thisPrevieCoordY, imgBoxSizeW, imgBoxSizeH, imgBoxSizeW, imgBoxSizeH, userimgQuality)
       r1 := trGdip_DrawImage(A_ThisFunc, G, thisBMP, cX, cY, uiboxSizeW, uiboxSizeH)
       trGdip_DisposeImage(thisBMP)
    } Else
       r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, cX, cY, uiboxSizeW, uiboxSizeH, thisPrevieCoordX, thisPrevieCoordY, imgBoxSizeW, imgBoxSizeH)

    If (BlurAreaBlendMode>1)
       bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, cornersBMP)

    If pEffect
       Gdip_BitmapApplyEffect(cornersBMP, pEffect)

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    r1 := trGdip_DrawImage(A_ThisFunc, G, zBitmap, 0, 0, uiboxSizeW, uiboxSizeH, 0, 0, uiboxSizeW, uiboxSizeH, 1, 2, imageAttribs)
    yBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)

    Gdip_DisposeImageAttributes(imageAttribs)
    thisBlurAmount := clampInRange(5 + Round(zoomBlurAreaXamount/2) - 2, 5, 20) ; A_Index * thisBlur
    If (doubleBlurPreviewArea=1)
       thisBlurAmount := thisBlurAmount//2 + 1

    opEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
    gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, yBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 1)
    G3 := trGdip_GraphicsFromImage(A_ThisFunc, gBitmap, 5)
    thisO := 0.85
    imgSelPx := imgSelPy := 0
    dimgSelPx := dimgSelPy := 0
    imgSelW := imgSelH := uiboxSizeW
    dimgSelW := dimgSelH := uiboxSizeH

    b := (doubleBlurPreviewArea=1) ? zoomBlurAreaXamount/3 : zoomBlurAreaXamount/2
    If isInRange(zoomBlurMode, 1, 3)
    {
       Loop
       {
          thisO -= 0.1 ; thisOpacity - (A_Index - 1) * startOpacity
          If (thisO<0)
             Break

          ; showTOOLtip("Radial blur: step " A_Index,, , (1 - thisO)/1)
          ; fnOutputDebug(thisBlurAmount "=" thisO)
          ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, opEffect)
          If (zoomBlurMode=1 || zoomBlurMode=2)
             dimgSelW += A_Index * b*2
          If (zoomBlurMode=1 || zoomBlurMode=3)
             dimgSelH += A_Index * b*2

          If (zoomBlurMode=1 || zoomBlurMode=2)
             dimgSelPx -= A_Index * b
          If (zoomBlurMode=1 || zoomBlurMode=3)
             dimgSelPy -= A_Index * b

          r1 := trGdip_DrawImage(A_ThisFunc, G3, yBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH,,,,, thisO)
          trGdip_DisposeImage(yBitmap, 1)
          yBitmap := trGdip_CloneBitmap(A_ThisFunc, gBitmap)
       }
    } Else
    {
       f := (doubleBlurPreviewArea=1) ? (zoomBlurAreaXamount*8)/2 : zoomBlurAreaXamount*8
       ff := (doubleBlurPreviewArea=1) ? ((zoomBlurAreaXamount*8)/2)/2 : (zoomBlurAreaXamount*8)/2
       If (zoomBlurMode=4)
       {
          wbitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, imgSelW//ff, imgSelH, 0, 5)
          rbitmap := trGdip_ResizeBitmap(A_ThisFunc, wBitmap, imgSelW//f, imgSelH, 0, 7)
       } Else
       {
          wbitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, imgSelW, imgSelH//ff, 0, 5)
          rbitmap := trGdip_ResizeBitmap(A_ThisFunc, wBitmap, imgSelW, imgSelH//f, 0, 7)
       }
       fbitmap := trGdip_ResizeBitmap(A_ThisFunc, rBitmap, imgSelW, imgSelH, 0, 7)
       r1 := trGdip_DrawImage(A_ThisFunc, G3, fBitmap, 0, 0, imgSelW, imgSelH)
       trGdip_DisposeImage(wBitmap)
       trGdip_DisposeImage(rBitmap)
       trGdip_DisposeImage(fBitmap)
    }

    Gdip_DeleteGraphics(G3)
    If (BlurAreaBlendMode>1)
    {
       applyBlurColorsFX(gBitmap)
       rz := QPV_BlendBitmaps(bgrBMPu, gBitmap, BlurAreaBlendMode - 1, 0, BlendModesFlipped)
       ; ToolTip, % "l=" rz , , , 2
       ou := gBitmap
       gBitmap := bgrBMPu
       bgrBMPu := ou
    }

    ; thisBMP := (BlurAreaBlendMode>1) ? bgrBMPu : cornersBMP
    r1 := trGdip_DrawImage(A_ThisFunc, G, gBitmap, 0, 0, uiboxSizeW, uiboxSizeH, 0, 0, uiboxSizeW, uiboxSizeH, thisOpacity)
    Gdip_DeleteGraphics(G)
    flipBitmapAccordingToViewPort(cornersBMP, 1)
    If (r1!="fail")
       Gdip_SetPbitmapCtrl(hCropCornersPic, cornersBMP)

    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(yBitmap, 1)
    trGdip_DisposeImage(gBitmap, 1)
    trGdip_DisposeImage(bgrBMPu, 1)
    trGdip_DisposeImage(cornersBMP, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(opEffect)
}

updateUIerasePanel(actionu:=0, b:=0, c:=0) {
    If (AnyWindowOpen!=25)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide

    RegAction(1, "EraseAreaOpacity")
    RegAction(1, "EraseAreaFader")
    RegAction(1, "EraseAreaInvert")
    uiSlidersArray["EraseAreaOpacity", 10] := EraseAreaFader
    If (actionu!="noPreview")
    {
       GuiRefreshSliders()
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)
    }
}

updateUIdesaturatePanel(actionu:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=55)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide

    actu := (DesaturateAreaLevels>1 && !viewportQPVimage.imgHandle) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, DesaturateAreaDither
    isActive := (DesaturateAreaChannel=2) ? 0 : 1
    uiSlidersArray["DesaturateAreaHue", 10] := isActive

    If (viewportQPVimage.imgHandle)
    {
       GuiControl, SettingsGUIA: Disable, DesaturateAreaLevels
       GuiControl, SettingsGUIA: Disable, EraseAreaUseAlpha
    }

    SetTimer, WriteSettingsDesaturateSelPanel, -200
    If (actionu!="noPreview")
    {
       GuiRefreshSliders()
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)
    }
    lastInvoked := A_TickCount
}

BtnResetAllSimpleAdjustColors() {
   userImgAdjustBright := userImgAdjustContra := userImgAdjustShadows := userImgAdjustHighs := userImgAdjustHue := userImgAdjustSat := userImgAdjustTintAmount := userImgAdjustTintDeg := userImgAdjustOffA := userImgAdjustOffR := userImgAdjustOffG := userImgAdjustOffB := userImgAdjustInvertColors := 0
   userImgAdjustThreR := userImgAdjustThreG := userImgAdjustThreB := userImgAdjustThreA := -1
   userImgAdjustNoisePoints := userImgAdjustBlackPoint := userImgAdjustAltContra := 0
   userImgAdjustWhitePoint := 65535
   imgColorsFXopacity := 255
   userImgAdjustGamma := 300
   userImgAdjustSeeThrough := alphaMaskingMode := 1
   GuiControl, SettingsGUIA:, userImgAdjustInvertColors, 0
   GuiControl, SettingsGUIA:, userImgAdjustNoisePoints, 0
   GuiControl, SettingsGUIA:, userImgAdjustAltContra, 0
   GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 1
   GuiControl, SettingsGUIA: Choose, userImgAdjustSeeThrough, 1
   GuiRefreshSliders(1)
   WriteSettingsSimpleColorAdjustsPanel()
   UpdateUIsimpleAdjustColors()
}

UpdateUIsimpleAdjustColors(actionu:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=89)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (CurrentPanelTab=1)
    {
        actu := (userImgAdjustHiPrecision=1) ? "Enable" : "Disable"
        GuiControl, SettingsGUIA: %actu%, userImgAdjustNoClamp
    } If (CurrentPanelTab=3)
    {
       uiSlidersArray["userImgAdjustThreR", 5] := (userImgAdjustLinkThresholds=1) ? "RGB" : "Red"
       uiSlidersArray["userImgAdjustThreG", 10] := !userImgAdjustLinkThresholds
       uiSlidersArray["userImgAdjustThreB", 10] := !userImgAdjustLinkThresholds
       isActive := (currIMGdetails.HasAlpha=1 || markedSelectFile) ? 1 : 0
       uiSlidersArray["userImgAdjustThreA", 10] := isActive
    } Else If (CurrentPanelTab=2)
    {
       isActive := (currIMGdetails.HasAlpha=1 || markedSelectFile) ? 1 : 0
       uiSlidersArray["userImgAdjustOffA", 10] := isActive
       isActive := (userImgAdjustTintAmount>0) ? 1 : 0
       uiSlidersArray["userImgAdjustTintDeg", 10] := isActive
       GuiUpdateSliders("userImgAdjustTintDeg")
       GuiUpdateSliders("userImgAdjustOffA")
    } Else If (CurrentPanelTab=4 && !viewportQPVimage.imgHandle)
       updateUIalphaMaskStuff(1)
    Else If (CurrentPanelTab=5 && !viewportQPVimage.imgHandle)
       updateUIalphaMaskStuff(2)

    If !(viewportQPVimage.imgHandle)
    {
       SetTimer, WriteSettingsBrushPanel, -350
       SetTimer, WriteSettingsAlphaMaskPanel, -250
    }

    SetTimer, WriteSettingsSimpleColorAdjustsPanel, -250
    If (actionu!="noPreview")
    {
       GuiRefreshSliders()
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)
    }
    lastInvoked := A_TickCount
}

BtnEraseSelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   If throwErrorAllSelectedInvert(EraseAreaInvert)
      Return

   updateUIerasePanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()

   prevImgEditZeit := A_TickCount
   ToggleEditImgSelection("show-edit")
   If (viewportQPVimage.imgHandle)
      HugeImagesApplyGenericFilters("erase selected area")
   Else
      EraseSelectedArea()
   prevImgEditZeit := A_TickCount
}

BtnFillBehindSelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   updateUIfillBehindPanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()

   prevImgEditZeit := A_TickCount
   ToggleEditImgSelection("show-edit")
   FillBehindSelectedArea()
   prevImgEditZeit := A_TickCount
}

livePreviewAdjustColorsArea(modus:=0) {
   livePreviewSimpleColorsAdjustImage(modus, "vp-colors")
}

coreSymmetricaImageGenerator(zBitmap) {
   Static lim := 3
   trGdip_GetImageDimensions(zBitmap, rImgW, rImgH)
   If (UserSymmetricaSrcFlipX=1 && UserSymmetricaSrcFlipY=1)
      Gdip_ImageRotateFlip(zBitmap, 2)
   Else If (UserSymmetricaSrcFlipX=1)
      Gdip_ImageRotateFlip(zBitmap, 4)
   Else If (UserSymmetricaSrcFlipY=1)
      Gdip_ImageRotateFlip(zBitmap, 6)

   If (UserSymmetricaSrcRotated=1)
      Gdip_ImageRotateFlip(zBitmap, 1)

   trGdip_GetImageDimensions(zBitmap, imgW, imgH)
   trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   fx := imgW/oImgW,  fy := imgH/oImgH
   scX := Round(tinyPrevAreaCoordX * fX)
   scY := Round(tinyPrevAreaCoordY * fY)
   maxX := ImgW - 2, maxY := ImgH - 2
   coordsX := clampInRange(scX, lim, maxX)
   coordsY := clampInRange(scY, lim, maxY)
   If (scX<3 || scY<3)
   {
      ; when the reference tile is very small, we just fill with a color
      ; ToolTip, % scX "|" scY "=" maxX "|" maxY "`n" tinyPrevAreaCoordX "|" tinyPrevAreaCoordY , , , 2
      coloru := getPixelColorAvg(zBitmap, 1, 1, "0xFF" Gdip_GetPixelColor(zBitmap, 2, 2, 4))
      pGU := Gdip_GraphicsFromImage(zBitmap)
      Gdip_GraphicsClear(pGU, coloru)
      Gdip_DeleteGraphics(pGU)
      Return zBitmap
   }
   ; ToolTip, % fx "|" fy "|" coordsX "|" coordsY "`n" imgW "|" imgH "=" oImgW "|" oImgH , , , 2
   ; fnOutputDebug(imgW "|" imgH "=" oImgW "|" oImgH)
   If (UserSymmetricaMode>3)
   {
      ; prepare tile for diagonal mode
      cavg := (coordsX + coordsY)//2
      maxu := min(imgW, imgH)
      imgSelW := imgSelH := clampInRange(cavg, lim, maxu)
      ; ToolTip, % cavg "|" maxu "=" imgSelW "`n" tinyPrevAreaCoordX "|" tinyPrevAreaCoordY , , , 2
      coordsX := coordsY := imgSelW
      pPath := Gdip_CreatePath()
      If (UserSymmetricaSrcAlign=1)
      {
         cX1 := cY1 := cX2 := 0
         cY2 := cY3 := imgSelH
         cX3 := imgSelW
      } Else
      {
         cY2 := cX3 := cY3 := 0
         cX1 := cX2 := imgSelW
         cY1 := imgSelH
      }
      px := py := 0
      ; ToolTip, % px "==" py "==" UserSymmetricaSrcAlign , , , 2
      Gdip_AddPathPolygon(pPath, [cX1, cY1, cX2, cY2, cX3, cY3])
      nBitmap := trGdip_CloneBitmapArea(A_ThisFunc, zBitmap, px, py, imgSelW, imgSelH)
      zG := trGdip_GraphicsFromImage(A_ThisFunc, nBitmap)
      Gdip_SetClipPath(zG, pPath, 4)
      Gdip_GraphicsClear(zG)
      Gdip_DeleteGraphics(zG)

      yBitmap := trGdip_CloneBitmap(A_ThisFunc, zBitmap)
      Gdip_ImageRotateFlip(yBitmap, 6)
      Gdip_ImageRotateFlip(yBitmap, 1)

      rBitmap := trGdip_CloneBitmapArea(A_ThisFunc, yBitmap, px, py, imgSelW, imgSelH)
      trGdip_DisposeImage(yBitmap)
      zG := trGdip_GraphicsFromImage(A_ThisFunc, rBitmap)
      Gdip_SetClipPath(zG, pPath)
      Gdip_GraphicsClear(zG)
      Gdip_DeletePath(pPath)
      tzGdip_DrawImageFast(zG, nBitmap)
      trGdip_DisposeImage(nBitmap)
      Gdip_DeleteGraphics(zG)

      ; render into the initial bitmap the tile
      pG := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
      ; Gdip_GraphicsClear(pG)
      tzGdip_DrawImage(pG, rBitmap, 0, 0, imgSelW, imgSelH)
      Gdip_DeleteGraphics(pG)
      trGdip_DisposeImage(rBitmap)
      ; Return rBitmap
   }

   sx := (UserSymmetricaMode=2) ? 1 : UserSymmetricaScaleX/200
   sy := (UserSymmetricaMode=1) ? 1 : UserSymmetricaScaleY/200
   If (sx!=1 || sy!=1 || UserSymmetricaSrcRotated=1)
   {
      thisImgQuality := (userimgQuality=1) ? 7 : 5
      If (sx!=1 || sy!=1)
         pBitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, Floor(imgW * sx), Floor(imgH * sy), 0, thisImgQuality, -1)
      Else
         pBitmap := trGdip_CloneBitmap(A_ThisFunc, zBitmap)

      trGdip_GetImageDimensions(pBitmap, gW, gH)
      fx := gW/oImgW,  fy := gH/oImgH
      scX := Round(tinyPrevAreaCoordX * fX),   scY := Round(tinyPrevAreaCoordY * fY)
      maxX := gW - 2, maxY := gH - 2

      coordsX := clampInRange(scX, lim, maxX)
      coordsY := clampInRange(scY, lim, maxY)
      If (UserSymmetricaMode>3)
         coordsX := coordsY := clampInRange((coordsX + coordsY)//2, lim, min(gW, gH))

      ; ToolTip, % scX "|" scY "=" maxX "|" maxY "`n" tinyPrevAreaCoordX "|" tinyPrevAreaCoordY , , , 2
      newBitmap := trGdip_CreateBitmap(A_ThisFunc, rimgW, rimgH)
      Gp := Gdip_GraphicsFromImage(newBitmap)
      ; Gdip_SetClipRect(Gp, 0, 0, gW, gH, 4)
      ; tzGdip_DrawImageFast(Gp, pBitmap, 2, 2)
      Gdip_SetClipRect(Gp, 0, 0, gW, gH)
      Gdip_GraphicsClear(Gp)
      tzGdip_DrawImageFast(Gp, pBitmap)
      Gdip_DeleteGraphics(Gp)
      trGdip_DisposeImage(pBitmap)
      pBitmap := newBitmap
      If (coordsX>=gW)
         coordsX := gW - 1
      If (coordsY>=gH)
         coordsY := gH - 1
   } Else
   {
      ; SoundBeep , 450, 100
      pBitmap := trGdip_CloneBitmapArea(A_ThisFunc, zBitmap, 0, 0, imgW, imgH, "0x26200A")
      ; kl := Gdip_GetImagePixelFormat(pBitmap, 2)
      ; ToolTip, % kl , , , 2
   }

   If (UserSymmetricaMode>3)
      coordsX := coordsY - 2

   If (UserSymmetricaMode=2)
      coordsX := gW ? gW : imgW
   ; no else if
   If (UserSymmetricaMode=1)
      coordsY := gH ? gH : imgH

   ; ToolTip, % imgW "==" imgH "`n"  gW "==" gH "`n" coordsX "==" coordsY , , , 2
   trGdip_DisposeImage(zBitmap)
   QPV_SymmetricaBitmap(pBitmap, Ceil(coordsX), Ceil(coordsY) - 1)
   Return pBitmap
}

livePreviewSymmetricaImgArea(modus:=0) {
   Critical, on
   Static prevState, prevBMP

   If (modus="kill")
   {
      trGdip_DisposeImage(prevBMP, 1)
      prevBMP := prevState := ""
      Return
   }

   lastSymmetryCoords := [tinyPrevAreaCoordX, tinyPrevAreaCoordY]
   Gdip_ResetClip(2NDglPG)
   If (doImgEditLivePreview!=1)
      Return

   ; trGdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
   whichBitmap := useGdiBitmap()
   vpWinClientSize(mainWidth, mainHeight)
   trGdip_GetImageDimensions(whichBitmap, mW, mH)
   objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, mW, mH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   pPath := VPcreateSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, VPselRotation, 1, mainWidth, mainHeight, 0)

   If (prevResizedVPimgW<mainWidth && prevResizedVPimgH<mainHeight)
      calcIMGdimensions(mW, mH, prevResizedVPimgW, prevResizedVPimgH, ResizedW, ResizedH)
   Else If (IMGlargerViewPort=1)
      calcIMGdimensions(mW, mH, prevResizedVPimgW//3, prevResizedVPimgH//3, ResizedW, ResizedH)
   Else
      calcIMGdimensions(mW, mH, prevResizedVPimgW//2, prevResizedVPimgH//2, ResizedW, ResizedH)

   If (ResizedW*ResizedH>19000000 || ResizedW>10000 || ResizedH>10000)
      calcIMGdimensions(mW, mH, 4000, 4000, ResizedW, ResizedH)

   ; ToolTip, % mW "|" mH "`n" tinyPrevAreaCoordX "|" tinyPrevAreaCoordY , , , 2
   thisState := "a" getIDvpFX() useGdiBitmap() currentUndoLevel undoLevelsRecorded ResizedW ResizedH mW mH
   If (prevState!=thisState || !validBMP(prevBMP))
   {
      ; the viewport original sized bitmap is rescaled to a small size and cached
      fnOutputDebug("redraw: " A_ThisFunc)
      prevBMP := trGdip_DisposeImage(prevBMP, 1)
      If (mW!=ResizedW || mH!=ResizedH)
      {
         zBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, ResizedW, ResizedH, 0, 5)
         pBitmap := validBMP(zBitmap) ? zBitmap : ""
      } Else pBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)

      pBitmap := applyVPeffectsOnBMP(pBitmap)
      prevBMP := pBitmap
      prevState := thisState
      ; ToolTip, % mW "=" mH "`n" ResizedW "=" ResizedH "`n" prevResizedVPimgW "=" prevResizedVPimgH , , , 2
   } Else If validBMP(prevBMP)
      pBitmap := prevBMP

   If !validBMP(pBitmap)
   {
      addJournalEntry(A_ThisFunc "(): invalid bitmap to process as a live preview")
      Gdip_DeletePath(pPath)
      Return
   }

   ; pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
   ; trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
   modus := (UserSymmetricaInvertArea=1) ? 4 : 0
   ; Gdip_SetClipPath(2NDglPG, pPath, modus)
   zBitmap := coreSymmetricaImageGenerator(trGdip_CloneBitmap(A_ThisFunc, pBitmap))
   trGdip_GetImageDimensions(zBitmap, zw, zh)
   ; ToolTip, % nw "|" nh "`n" zw "|" zh "`n" mW "=" mH "`n" ResizedW "=" ResizedH "||" hasResized  , , , 2
   If (UserSymmetricaInvertArea!=1)
   {
      ozw := zw,                       ozh := zh
      fx := zw/prevResizedVPimgW,      fy := zh/prevResizedVPimgH
      zfx := zw/mw,                    zfy := zh/mh
      xx := Round(min(imgSelX1, imgSelX2) * zfx)
      yy := Round(min(imgSelY1, imgSelY2) * zfy)
      zw := imgSelW * fx
      zh := imgSelH * fy

      mxz := clampInRange(ozw - zw, 0, zw)
      tx := Round(zw * (UserSymmetricaSelOffX/200))
      myz := clampInRange(ozh - zh, 0, zh)
      ty := Round(zh * (UserSymmetricaSelOffY/200))
      offX := clampInRange(tx, 0, mxz)
      offY := clampInRange(ty, 0, myz)
      ; ToolTip, % xx "|" zw "|" mxz "|" offX , , , 2
      bx := (UserSymmetricaSelAligned=1) ? offX : xx
      by := (UserSymmetricaSelAligned=1) ? offY : yy
      zw := Round(zw),      zh := Round(zh)
      kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, zBitmap, bx, by, zw, zh, 0, 0, 1)
      If validBMP(kBitmap)
      {
         trGdip_DisposeImage(zBitmap, 1)
         zBitmap := kBitmap
      }
      ; fnOutputDebug(nx "==" ny "|" nw "==" nh)
   }

   If (UserSymmetricaInvertArea=1)
   {
      tx := (imgSelPx > prevDestPosX) ? prevDestPosX : max(imgSelPx, prevDestPosX)
      ty := (imgSelPy > prevDestPosY) ? prevDestPosY : max(imgSelPy, prevDestPosY)
      twx := ((imgSelPx + imgSelW) > (prevDestPosX + prevResizedVPimgW)) ? prevDestPosX + prevResizedVPimgW : max(imgSelPx + imgSelW, prevDestPosX + prevResizedVPimgW)
      twy := ((imgSelPy + imgSelH) > (prevDestPosY + prevResizedVPimgH)) ? prevDestPosY + prevResizedVPimgH : max(imgSelPy + imgSelH, prevDestPosY + prevResizedVPimgH)
      invertPath := Gdip_ClonePath(pPath)
      Gdip_AddPathRectangle(invertPath, tx, ty, twx - tx, twy - ty)
      getClampedVPimgBounds(imgSelPx, imgSelPy, kX, kY, imgSelW, imgSelH)
      whichPath := invertPath
   } Else
   {
      whichPath := pPath
      getClampedVPselToWindow(1, mainWidth, mainHeight, mw, mH, imgSelPx, imgSelPy, imgSelW, imgSelH)
   }

   trGdip_GetImageDimensions(zBitmap, oImgW, oImgH)
   objSel.dw := imgSelW,    objSel.dh := imgSelH
   objSel.dx := imgSelPx,   objSel.dy := imgSelPy
   objSel.nw := imgSelW,      objSel.nh := imgSelH
   getVPselSize(zW, zH, 1, UserSymmetricaInvertArea)
   objSel.zw := zw,        objSel.zh := zh
   objSel.invertArea := UserSymmetricaInvertArea
   wBitmap := getRectFromBitmap(zBitmap, objSel, 1)
   If validBMP(wBitmap)
   {
      zBitmap := trGdip_DisposeImage(zBitmap)
      zBitmap := wBitmap
   } Else addJournalEntry(A_ThisFunc "(): failed to get rect from gradients bitmap")

   trGdip_GetImageDimensions(zBitmap, bW, bH)
   ; ToolTip, % imgSelW "|" imgSelH "`n" bW "|" bH "`n" oImgW "|" oImgH , , , 2
   applyBlurColorsFX(zBitmap)
   If (UserSymmetricaBlendMode>1)
   {
      If (currIMGdetails.HasAlpha=1 && !viewportQPVimage.imgHandle)
         bgrBMP := getImgOriginalSelectedAreaEdit(0, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, 1)
      Else
         bgrBMP := getImgSelectedAreaEditMode(1, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0, imgSelW, imgSelH, 0)

      zr := QPV_BlendBitmaps(bgrBMP, zBitmap, UserSymmetricaBlendMode - 1, BlendModesPreserveAlpha, BlendModesFlipped)
      If zr
      {
         trGdip_DisposeImage(zBitmap)
         zBitmap := bgrBMP
      } Else
         trGdip_DisposeImage(bgrBMP)
   }

   allowAlphaMasking := decideAlphaMaskingFeaseable(UserSymmetricaUseAlpha)
   If (allowAlphaMasking=1 && validBMP(zBitmap))
   {
      thisIDu := "a" alphaMaskColorReversed alphaMaskingMode userAlphaMaskBmpPainted VPselRotation EllipseSelectMode imgSelPx imgSelPy imgSelW imgSelH UserSymmetricaInvertArea currentUndoLevel undoLevelsRecorded useGdiBitmap() prevDestPosX prevDestPosY prevResizedVPimgW prevResizedVPimgH UserSymmetricaBlendMode tinyPrevAreaCoordX tinyPrevAreaCoordY blurAreaApplyFX BlurAreaHue BlurAreaSaturation BlurAreaLight BlurAreaGamma BlendModesFlipped BlendModesPreserveAlpha UserSymmetricaMode UserSymmetricaScaleX UserSymmetricaScaleY UserSymmetricaSrcAlign UserSymmetricaSelAligned UserSymmetricaSrcFlipX UserSymmetricaSrcFlipY UserSymmetricaSrcRotated UserSymmetricaSelOffX UserSymmetricaSelOffY
      realtimePasteInPlaceAlphaMasker(1, zBitmap, thisIDu, newBitmap, objSel, 0, 0, 0)
      If validBMP(newBitmap)
      {
         trGdip_DisposeImage(zBitmap, 1)
         zBitmap := newBitmap
      }
   }

   liveCarvePathBitmap(pPath, zBitmap, imgSelPx, imgSelPy, UserSymmetricaInvertArea)
   px := imgSelPx,    py := imgSelPy
   pw := imgSelW,     ph := imgSelH
   r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, zBitmap, px, py, pw, ph,,,,, UserSymmetricaOpacity/255)
   ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
   Gdip_ResetClip(2NDglPG)
   Gdip_DeletePath(pPath)
   Gdip_DeletePath(invertPath)
   trGdip_DisposeImage(zBitmap, 1)
}

livePreviewDesaturateArea(modus:=0) {
   livePreviewSimpleColorsAdjustImage(modus, "desaturate")
}

liveCarvePathBitmap(pPath, pBitmap, cX, cY, invertArea) {
   ; this function is used instead of Gdip_SetClipPath(); the GDI+ function gets insanely slow with very large selection areas
   startZeit := A_TickCount
   trGdip_GetImageDimensions(pBitmap, w, h)
   nBitmap := trGdip_CreateBitmap(A_ThisFunc, w, h)
   Gu := Gdip_GraphicsFromImage(nBitmap)
   Gdip_GraphicsClear(Gu, "0xFF000000")
   br := Gdip_BrushCreateSolid("0xFFffFFff")
   zPath := Gdip_ClonePath(pPath)
   pMatrix := Gdip_CreateMatrix()
   Gdip_TranslateMatrix(pMatrix, -cX , -cY)
   E := Gdip_TransformPath(zPath, pMatrix)
   Gdip_FillPath(Gu, br, zPath)
   Gdip_DeleteGraphics(Gu)
   Gdip_DeleteBrush(br)
   Gdip_DeletePath(zPath)
   Gdip_DeleteMatrix(pMatrix)
   r := QPV_SetBitmapAsAlphaChannel(pBitmap, nBitmap, invertArea)
   If !r
      addJournalEntry(A_ThisFunc "(): failed to process the bitmap")
   trGdip_DisposeImage(nBitmap)
   fnOutputDebug(A_ThisFunc "(): " A_TickCount - startZeit " ms.")
}

getRectFromBitmap(oBitmap, selObj, doResize) {
   If !validBMP(oBitmap)
      Return

   trGdip_GetImageDimensions(oBitmap, imgW, imgH)
   If (selObj.invertArea=1)
   {
      trGdip_GetImageDimensions(useGdiBitmap(), rimgW, rimgH)
      vpWinClientSize(mainWidth, mainHeight)
      MouseCoords2Image(1, 1, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, sfPosX1, sfPosY1)
      zx1f := clampInRange(sfPosX1 / rimgW, 0, 0.9999)
      zy1f := clampInRange(sfPosY1 / rimgH, 0, 0.9999)
      MouseCoords2Image(mainWidth, mainHeight, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, sfPosX1, sfPosY1)
      zx2f := clampInRange(sfPosX1 / rimgW, 0, 1)
      zy2f := clampInRange(sfPosY1 / rimgH, 0, 1)
   } Else
   {
      zx1f := (selObj.dx >= selObj.sx) ? (selObj.dx - selObj.sx) / selObj.sw : 0
      zy1f := (selObj.dy >= selObj.sy) ? (selObj.dy - selObj.sy) / selObj.sh : 0
      skx := selObj.sx + selObj.sw,   sky := selObj.sy + selObj.sh
      dkx := selObj.dx + selObj.dw,   dky := selObj.dy + selObj.dh
      zx2f := (dkx <= skx) ? 1 - (skx - dkx) / selObj.sw : 1
      zy2f := (dky <= sky) ? 1 - (sky - dky) / selObj.sh : 1
   }

   ; ToolTip, % imgW "|" imgH "`n" zx1f "|" zy1f "`n" zx2f "|" zy2f , , , 2
   nx1 := clampInRange(Round(zx1f * imgW), 0, imgW - 2)
   ny1 := clampInRange(Round(zy1f * imgH), 0, imgH - 2)
   nx2 := clampInRange(Round(zx2f * imgW), nx1 + 1, imgW)
   ny2 := clampInRange(Round(zy2f * imgH), ny1 + 1, imgH)
   now := nx2 - nx1
   If (now<3)
      now := 2

   noh := ny2 - ny1
   If (noh<3)
      noh := 2

   nBitmap := trGdip_CloneBitmapArea(A_ThisFunc, oBitmap, nx1, ny1, now, noh)
   If (doResize!=1)
      Return nBitmap

   If (validBMP(nBitmap) && (now!=selObj.nw || noh!=selObj.nh))
   {
      pw := (selObj.nw < 3) ? 2 : selObj.nw
      ph := (selObj.nh < 3) ? 2 : selObj.nh
      gBitmap := trGdip_ResizeBitmap(A_ThisFunc, nBitmap, pw, ph, 0, 5)
      ; trGdip_GetImageDimensions(gBitmap, fw, fh)
      trGdip_DisposeImage(nBitmap)
   } Else gBitmap := nBitmap

   ; fnOutputDebug(A_ThisFunc "(): " now "|" noh " || " selObj.nw "|" selObj.nh " || " fw "|" fh " || " imgW "|" imgH)
   ; ToolTip, % nx1 "|" ny1 "`n" nx2 "|" ny2 , , , 2
   Return gBitmap
}

livePreviewSimpleColorsAdjustImage(modus:=0, extraMode:=0) {
   Critical, on
   Static prevBMP, prevIDu
   Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:16}
   If (modus="kill")
   {
      trGdip_DisposeImage(prevBMP, 1)
      getImgOriginalSelectedAreaEdit("kill", 0, 0, 0, 0, 0, 0, 0)
      getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
      prevIDu := prevBMP := ""
      Return
   }

   If (forceLiveAlphaPreviewMode=1 && liveDrawingBrushTool=1)
   {
      livePreviewAlphaMasking("live")
      Return
   }

   thisInvertArea := isVarEqualTo(extraMode, "vp-colors", "desaturate") ? EraseAreaInvert : userImgAdjustInvertArea
   Gdip_ResetClip(2NDglPG)
   If (doImgEditLivePreview!=1 || testSelectOutsideImgEntirely(useGdiBitmap()) && PasteInPlaceAutoExpandIMG=0 || thisInvertArea=0 && imgSelOutViewPort=1)
      Return

   If markedSelectFile
   {
      EllipseSelectMode := imgSelX1 := imgSelY1 := 0
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      imgSelX2 := imgW, imgSelY2 := imgH
   }

   vpWinClientSize(mainWidth, mainHeight)
   trGdip_GetImageDimensions(useGdiBitmap(), thisW, thisH)
   objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, thisW, thisH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
   pPath := VPcreateSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, VPselRotation, 1, mainWidth, mainHeight, 0)
   If (thisInvertArea=1)
   {
      tx := (imgSelPx > prevDestPosX) ? prevDestPosX : max(imgSelPx, prevDestPosX)
      ty := (imgSelPy > prevDestPosY) ? prevDestPosY : max(imgSelPy, prevDestPosY)
      twx := ((imgSelPx + imgSelW) > (prevDestPosX + prevResizedVPimgW)) ? prevDestPosX + prevResizedVPimgW : max(imgSelPx + imgSelW, prevDestPosX + prevResizedVPimgW)
      twy := ((imgSelPy + imgSelH) > (prevDestPosY + prevResizedVPimgH)) ? prevDestPosY + prevResizedVPimgH : max(imgSelPy + imgSelH, prevDestPosY + prevResizedVPimgH)
      invertPath := Gdip_ClonePath(pPath)
      Gdip_AddPathRectangle(invertPath, tx, ty, twx - tx, twy - ty)
      getClampedVPimgBounds(imgSelPx, imgSelPy, kX, kY, imgSelW, imgSelH)
      whichPath := invertPath
   } Else
   {
      whichPath := pPath
      getClampedVPselToWindow(1, mainWidth, mainHeight, thisW, thisH, imgSelPx, imgSelPy, imgSelW, imgSelH)
   }

   If (imgSelOutViewPort!=1 || thisInvertArea=1)
   {
      If (currIMGdetails.HasAlpha=1 && !viewportQPVimage.imgHandle)
         zBitmap := getImgOriginalSelectedAreaEdit(thisInvertArea, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, 0)
      Else
         zBitmap := getImgSelectedAreaEditMode(1, imgSelPx, imgSelPy, imgSelW, imgSelH, imgSelW, imgSelH, 0, imgSelW, imgSelH, 0)
   }

   If validBMP(zBitmap)
   {
      allowAlphaMasking := live := 0
      If (alphaMaskingMode>1 && liveDrawingBrushTool=1 && AnyWindowOpen=89)
         live := 1
      Else
         allowAlphaMasking := (extraMode="desaturate") ?  decideAlphaMaskingFeaseable(EraseAreaUseAlpha) : decideAlphaMaskingFeaseable(1)

      modus := (thisInvertArea=1) ? 4 : 0
      Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
      If (extraMode!="vp-colors")
         zBitmap := applyVPeffectsOnBMP(zBitmap)
      If (allowAlphaMasking=1 || live=1 || extraMode="vp-colors" && imgColorsFXopacity<255)
         pBitmap := trGdip_CloneBitmap(A_ThisFunc, zBitmap)

      thisBitsDepth := bitsOptions[DesaturateAreaLevels]
      doClrDepths := (isVarEqualTo(extraMode,"vp-colors", "desaturate") && thisBitsDepth>1) ? 1 : 0
      If (currIMGdetails.HasAlpha=1)
      {
         ; Gdip_FillRectangle(2NDglPG, GDIPbrushHatch, imgSelPx, imgSelPy, imgSelW, imgSelH)
         Gdip_FillPath(2NDglPG, GDIPbrushHatch, whichPath)
      }

      threB := (userImgAdjustLinkThresholds=1) ? userImgAdjustThreR : userImgAdjustThreB
      threG := (userImgAdjustLinkThresholds=1) ? userImgAdjustThreR : userImgAdjustThreG
      partu := getVPselIDs("saiz-vpos-xy") VPselRotation EllipseSelectMode imgSelW imgSelH innerSelectionCavityX innerSelectionCavityY rotateSelBoundsKeepRatio zoomLevel prevDestPosX prevDestPosY
      thisIDu := "a" getIDvpFX() imgColorsFXopacity userImgAdjustInvertColors userImgAdjustAltSat userImgAdjustSat userImgAdjustAltBright userImgAdjustBright userImgAdjustAltContra userImgAdjustContra userImgAdjustAltHiLows userImgAdjustShadows userImgAdjustHighs userImgAdjustHue userImgAdjustTintDeg userImgAdjustTintAmount userImgAdjustAltTint userImgAdjustGamma userImgAdjustOffR userImgAdjustOffG userImgAdjustOffB userImgAdjustOffA userImgAdjustThreR ThreG ThreB userImgAdjustThreA userImgAdjustSeeThrough userImgAdjustNoClamp userImgAdjustHiPrecision userImgAdjustWhitePoint userImgAdjustBlackPoint userImgAdjustNoisePoints userimgGammaCorrect DesaturateAreaLevels DesaturateAreaDither DesaturateAreaAmount DesaturateAreaInvert DesaturateAreaChannel DesaturateAreaBright DesaturateAreaContra DesaturateAreaHue partu thisInvertArea userImgChannelAlphaAdd
      trGdip_GetImageDimensions(zBitmap, oImgW, oImgH)
      ; ToolTip, % oImgW "|" oImgH "`n" imgSelW "|" imgSelH , , , 2
      objSel.dw := imgSelW,    objSel.dh := imgSelH
      objSel.dx := imgSelPx,   objSel.dy := imgSelPy
      objSel.nw := oImgW,      objSel.nh := oImgH
      If (thisIDu!=prevIDu || !validBMP(prevBMP))
      {
         trGdip_DisposeImage(prevBMP, 1)
         fnOutputDebug("redraw: " A_ThisFunc " : QPV_AdjustImageColors")
         If (doClrDepths=1)
         {
            Gdip_BitmapSetColorDepth(zBitmap, thisBitsDepth, DesaturateAreaDither)
            Gdip_BitmapSetColorDepth(zBitmap, 32)
         }

         livePreviewPrepareSelectionArea(objSel, thisInvertArea, EllipseSelectMode)
         If (extraMode="vp-colors")
         {
            zBitmap := applyVPeffectsOnBMP(zBitmap)
            If (imgColorsFXopacity<255)
               QPV_MergeBitmapsWithMask(zBitmap, pBitmap, 0, 0, 255 - imgColorsFXopacity)
            If (userImgChannelAlphaAdd>0)
               QPV_AlterAlphaChannel(zBitmap, userImgChannelAlphaAdd, 0)
         } Else If (extraMode="desaturate")
            QPV_AdjustImageColors(zBitmap, DesaturateAreaAmount, DesaturateAreaInvert, DesaturateAreaChannel - 1, -65535, 1, DesaturateAreaBright, 0, DesaturateAreaContra, 0, 0, 0, DesaturateAreaHue, 0, 0, 0, 300, 0, 0, 0, 0, -1, -1, -1, -1, 1, 0, 0, 65535, 0, 0, -1)
         Else
            QPV_AdjustImageColors(zBitmap, imgColorsFXopacity, userImgAdjustInvertColors, userImgAdjustAltSat, userImgAdjustSat, userImgAdjustAltBright, userImgAdjustBright, userImgAdjustAltContra, userImgAdjustContra, userImgAdjustAltHiLows, userImgAdjustShadows, userImgAdjustHighs, userImgAdjustHue, userImgAdjustTintDeg, userImgAdjustTintAmount, userImgAdjustAltTint, userImgAdjustGamma, userImgAdjustOffR, userImgAdjustOffG, userImgAdjustOffB, userImgAdjustOffA, userImgAdjustThreR, ThreG, ThreB, userImgAdjustThreA, userImgAdjustSeeThrough, userImgAdjustInvertArea, userImgAdjustNoClamp, userImgAdjustWhitePoint, userImgAdjustBlackPoint, userImgAdjustNoisePoints, -1)

         If (!viewportQPVimage.imgHandle && allowAlphaMasking!=1)
            liveCarvePathBitmap(pPath, zBitmap, imgSelPx, imgSelPy, thisInvertArea)

         prevBMP := trGdip_CloneBitmap(A_ThisFunc, zBitmap)
         prevIDu := thisIDu
      } Else 
      {
         trGdip_DisposeImage(zBitmap, 1)
         zBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMP)
      }

      If (live=1 && validBMP(pBitmap))
      {
         trGdip_GetImageDimensions(userAlphaMaskBmpPainted, zImgW, zImgH)
         viewportDynamicOBJcoords.x := objSel.sx,  viewportDynamicOBJcoords.y := objSel.sy
         viewportDynamicOBJcoords.w := objSel.sw,  viewportDynamicOBJcoords.h := objSel.sH
         viewportDynamicOBJcoords.zl := (objSel.sw/zImgW + objSel.sh/zImgH)/2 + 0.0001
         wBitmap := getRectFromBitmap(userAlphaMaskBmpPainted, objSel, 1)
         alphaMaskGray := validBMP(wBitmap) ? wBitmap : userAlphaMaskBmpPainted

         ; QPV_SetBitmapAsAlphaChannel(zBitmap, alphaMaskGray, alphaMaskColorReversed, alphaMaskReplaceMode, alphaMaskBMPchannel, 3)
         QPV_MergeBitmapsWithMask(zBitmap, pBitmap, alphaMaskGray, !alphaMaskColorReversed)
         If validBMP(wBitmap)
            trGdip_DisposeImage(wBitmap, 1)
      }

      If (allowAlphaMasking=1 && validBMP(pBitmap) && live!=1)
      {
         getVPselSize(zW, zH, 1, thisInvertArea)
         objSel.zw := zw,        objSel.zh := zh
         objSel.invertArea := thisInvertArea
         thisIDu := thisIDu "a" getAlphaMaskIDu() thisInvertArea currentUndoLevel undoLevelsRecorded useGdiBitmap() 
         realtimePasteInPlaceAlphaMasker(1, zBitmap, thisIDu, newBitmap, objSel, 0, 0, 0, 0, pBitmap, 0)
         If validBMP(newBitmap)
         {
            trGdip_DisposeImage(zBitmap, 1)
            zBitmap := newBitmap
         }
      }

      If (!viewportQPVimage.imgHandle && EllipseSelectMode>0)
         liveCarvePathBitmap(pPath, zBitmap, imgSelPx, imgSelPy, thisInvertArea)

      r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, zBitmap, imgSelPx, imgSelPy)
      Gdip_ResetClip(2NDglPG)
      trGdip_DisposeImage(zBitmap, 1)
      trGdip_DisposeImage(pBitmap, 1)
   }
   Gdip_DeletePath(pPath)
   Gdip_DeletePath(invertPath)
   ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
}

throwErrorAllSelectedInvert(userBias) {
   If (!testAllowSelInvert() && userBias=1)
   {
      showTOOLtip("WARNING: The entire canvas is selected,`nbut the option «Invert selection area» is activated.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }   
}

BtnGraySelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   If throwErrorAllSelectedInvert(EraseAreaInvert)
      Return

   updateUIdesaturatePanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   prevImgEditZeit := A_TickCount
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()
 
   ToggleEditImgSelection("show-edit")
   If (viewportQPVimage.imgHandle)
      HugeImagesApplyGenericFilters("grayscale filter")
   Else
      GraySelectedArea()
   prevImgEditZeit := A_TickCount
}

BtnSymmetrySelectedArea() {
   If throwErrorSelectionOutsideBounds()
      Return

   If throwErrorAllSelectedInvert(UserSymmetricaInvertArea)
      Return

   updateUIsymmetricaPanel("noPreview")
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   prevImgEditZeit := A_TickCount
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()
   ToggleEditImgSelection("show-edit")
   SymmetrySelectedArea()
   prevImgEditZeit := A_TickCount
}

BtnAdjustColorsImgSelectedArea() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   If throwErrorSelectionOutsideBounds()
      Return

   If throwErrorAllSelectedInvert(EraseAreaInvert)
      Return

   RegAction(1, "imgColorsFXopacity")
   RegAction(1, "EraseAreaInvert")
   o_imgFxMode := imgFxMode
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   prevImgEditZeit := A_TickCount
   wasVPfxBefore := 0
   of := 0
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()
   Else
      of := ForceNoColorMatrix
   
   ToggleEditImgSelection("show-edit")
   ForceNoColorMatrix := 0
   AdjustColorsLegacySelectedArea(o_imgFxMode)
   ForceNoColorMatrix := of
   prevImgEditZeit := A_TickCount
}

BtnAdjustColorsSimpleImgSelArea() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   If throwErrorSelectionOutsideBounds()
      Return

   If throwErrorAllSelectedInvert(userImgAdjustInvertArea)
      Return

   threB := (userImgAdjustLinkThresholds=1) ? userImgAdjustThreR : userImgAdjustThreB
   threG := (userImgAdjustLinkThresholds=1) ? userImgAdjustThreR : userImgAdjustThreG
   thisIDu := "a" userImgAdjustInvertColors userImgAdjustSat  userImgAdjustBright userImgAdjustContra userImgAdjustShadows userImgAdjustHighs userImgAdjustHue userImgAdjustTintAmount userImgAdjustGamma userImgAdjustOffR userImgAdjustOffG userImgAdjustOffB userImgAdjustOffA userImgAdjustThreR ThreG ThreB userImgAdjustThreA userImgAdjustWhitePoint userImgAdjustBlackPoint
   If (thisIDu="a000000003000000-1-1-1-1655350")
   {
      showTOOLtip("WARNING: No color filters to apply.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   WriteSettingsSimpleColorAdjustsPanel()
   getSelectedFiles(0, 1)
   If markedSelectFile
   {
      SoundBeep 300, 100
      msgBoxWrapper(appTitle ": WARNING", "You have selected " groupDigits(markedSelectFile) " images for batch processing. You cannot apply the tool on the image active in the viewport in this context.`n`nTo edit an image individually, close the panel, drop the files selection and reopen this panel.", 0, 0, "exclamation")
      Return
   }

   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
   prevImgEditZeit := A_TickCount
   If (closeEditPanelOnApply=1)
      BtnCloseWindow()

   ToggleEditImgSelection("show-edit")
   If (viewportQPVimage.imgHandle)
      HugeImagesApplyGenericFilters("color filters")
   Else
      AdjustColorsSimpleSelectedArea()

   prevImgEditZeit := A_TickCount
}

BtnBlurSelectedArea() {
   If (downscaleHugeImagesForEditing()<0)
      Return

   updateUIblurPanel("no-preview")
   BtnCloseWindow()
   ToggleEditImgSelection("show-edit")
   BlurSelectedArea()
}

BtnPixelizeSelectedArea() {
   ; If (downscaleHugeImagesForEditing()<0)
   ;    Return

   updateUIblurPanel("no-preview")
   BtnCloseWindow()
   If (viewportQPVimage.imgHandle)
   {
      HugeImagesApplyGenericFilters("pixelize")
      Return
   }

   ToggleEditImgSelection("show-edit")
   BlurSelectedArea("pixelize")
}

BtnZoomBlurSelectedArea() {
   If (downscaleHugeImagesForEditing()<0)
      Return

   updateUIzoomBlurPanel("no-preview")
   BtnCloseWindow()
   ToggleEditImgSelection("show-edit")
   zoomBlurSelectedArea()
}

updateUIfillPanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=23)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIfillPanel, -150
       Return
    }

    decideCustomShapeStyle()
    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1
    If (FillAreaInverted=1 && FillAreaBlendMode>1)
       FillAreaGradientWrapped := 1

    closedLineCustomShape := FillAreaClosedPath
    If (CurrentPanelTab=1)
    {
       actu := (FillAreaShape=2) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiUpdateVisibilitySliders(actu, "FillAreaRectRoundness")

       actu := (FillAreaShape=3 && !viewportQPVimage.imgHandle) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiUpdateVisibilitySliders(actu, "FillAreaEllipseSection")

       actu := (FillAreaShape=7) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, FillAreaCurveTension
       GuiControl, % actu, UIbtnEditShape

       actu := (FillAreaInverted=1 || viewportQPVimage.imgHandle) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, PasteInPlaceAutoExpandIMG

       actu := (FillAreaRemBGR=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, txtLine1
       GuiControl, % actu, txtLine2
       GuiControl, % actu, FillAreaGlassy
       GuiControl, % actu, FillAreaBlendMode
       GuiControl, % actu, FillAreaCutGlass
       GuiControl, % actu, BlendModesFlipped
       actu := (viewportQPVimage.imgHandle) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, FillAreaDoBehind

       actu := (FillAreaDoBehind=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, FillAreaRemBGR

       actu := (viewportQPVimage.imgHandle || FillAreaRemBGR=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, txtLine1
       GuiControl, % actu, FillAreaGlassy
       uiSlidersArray["userUIshapeCavity", 10] := (viewportQPVimage.imgHandle && !(FillAreaShape=1 || FillAreaShape=3)) ? 0 : 1
       uiSlidersArray["FillAreaBlurAmount", 10] := (viewportQPVimage.imgHandle || FillAreaRemBGR=1) ? 0 : 1
       If (coreDesiredPixFmt="0x21808")
          GuiControl, SettingsGUIA: Disable, FillAreaBlendMode
    } Else If (CurrentPanelTab=2)
    {
       gradMode := isInRange(FillAreaColorMode, 2, 4)
       If (FillAreaColorMode=5)
       {
          GuiControl, SettingsGUIA: Show, FillAreaWelcomePattern
          GuiUpdateVisibilitySliders("SettingsGUIA: Hide", "FillAreaGradientAngle")
          FillAreaGradientScale := clampInRange(FillAreaGradientScale, 1, 100)
          FillAreaGradientPosB := clampInRange(FillAreaGradientPosB, 0, 9)
          FillAreaGradientPosA := clampInRange(FillAreaGradientPosA, 0, 9)
          GuiSetSliderProperties("FillAreaGradientScale", 1, 100, 10, "Iterations")
          GuiSetSliderProperties("FillAreaGradientPosA", 0, 9, 1, "Style: $€")
          GuiSetSliderProperties("FillAreaGradientPosB", 0, 9, 1, "Petal details", 1)
          uiSlidersArray["FillAreaGradientPosA", 10] := (FillAreaWelcomePattern=4 || FillAreaWelcomePattern=7) ? 1 : 0
          uiSlidersArray["FillAreaGradientPosB", 10] := (FillAreaWelcomePattern=7) ? 1 : 0
       } Else
       {
          GuiControl, SettingsGUIA: Hide, FillAreaWelcomePattern
          GuiUpdateVisibilitySliders("SettingsGUIA: Show", "FillAreaGradientAngle")
          uiSlidersArray["FillAreaGradientPosB", 10] := 1
          If (FillAreaColorMode=6)
          {
             GuiSetSliderProperties("FillAreaGradientScale", 1,300, 100, "Scale", 1)
             GuiSetSliderProperties("FillAreaGradientPosA", 10,250, 30, ".updateLabelFillAreaTextureX", 1)
             GuiSetSliderProperties("FillAreaGradientPosB", 10,250, 30, ".updateLabelFillAreaTextureY", 1)
          } Else
          {
             GuiSetSliderProperties("FillAreaGradientScale", 1,300, 100, "Scale: $€%", 1)
             GuiSetSliderProperties("FillAreaGradientPosA", 0,200, 0, "Position A", 3)
             GuiSetSliderProperties("FillAreaGradientPosB", 0,200, 200, "Position B", 3)
          }
       }

       If (FillAreaColorMode=5)
       {
          GuiControl, SettingsGUIA: Hide, FillAreaGradientWrapped
          uiSlidersArray["FillArea2ndOpacity", 5] := "Color"
          uiSlidersArray["FillAreaOpacity", 5] := "Pattern"
       } Else If (FillAreaColorMode=6)
       {
          GuiControl, SettingsGUIA: Show, FillAreaGradientWrapped
          uiSlidersArray["FillAreaOpacity", 5] := "Opacity"
       } Else
       {
          uiSlidersArray["FillAreaOpacity", 5] := "Opacity"
          uiSlidersArray["FillArea2ndOpacity", 5] := "Opacity"
          actu := (FillAreaColorMode=1) ? "SettingsGUIA: Hide" : "SettingsGUIA: Show"
          GuiControl, % actu, FillAreaGradientWrapped
       }

       actu := (FillAreaColorMode=1) ? 0 : 1
       uiSlidersArray["FillAreaGradientAngle", 10] := actu
       uiSlidersArray["FillAreaGradientScale", 10] := actu
       If (FillAreaColorMode!=5)
       {
          uiSlidersArray["FillAreaGradientPosA", 10] := actu
          uiSlidersArray["FillAreaGradientPosB", 10] := actu
       }

       uiSlidersArray["FillArea2ndOpacity", 10] := (FillAreaColorMode=1 || FillAreaColorMode=6) ? 0 : 1
       actu := (gradMode=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, FillAreaColorReversed

       actu := (gradMode=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, infoFillAreaGradientView

       actu := (FillAreaColorMode>4) ? "SettingsGUIA: Hide" : "SettingsGUIA: Show"
       GuiControl, % actu, PickuFillAreaColor
       GuiControl, % actu, FillAreaColor
       If (gradMode=1)
          updateUIgradientPreviewAlphaMask(0)

       actu := (FillAreaColorMode=1 || FillAreaColorMode=6) ? "SettingsGUIA: Hide" : "SettingsGUIA: Show"
       GuiControl, % actu, PickuFillArea2ndColor
       GuiControl, % actu, FillArea2ndColor
       GuiUpdateVisibilitySliders(actu, "FillArea2ndOpacity")

       actu := (gradMode=1 || FillAreaColorMode=6) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, btnFldr5

       actu := (FillAreaColorMode=6) ? "&Set texture source" : "&Reset gradient center"
       GuiControl, SettingsGUIA: , btnFldr5, % actu
    } Else If (CurrentPanelTab=4)
    {
       actu2 := (FillAreaDoContour=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu2, DrawLineAreaColor

       actu := (FillAreaShape=7) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, FillAreaClosedPath

       actu2 := (FillAreaDoContour=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, PickuDrawLineAreaColor
       GuiControl, % actu2, DrawLineAreaKeepBounds
       GuiControl, % actu2, DrawLineAreaCapsStyle
       GuiControl, % actu2, DrawLineAreaDoubles
       GuiControl, % actu2, DrawLineAreaContourAlign
       GuiControl, % actu2, DrawLineAreaDashStyle
       GuiControl, % actu2, DrawLineAreaBlendMode
       GuiControl, % actu2, FillAreaClosedPath
       GuiControl, % actu2, txtLine3
       GuiControl, % actu2, txtLine4
       GuiControl, % actu2, txtLine5
       uiSlidersArray["DrawLineAreaContourThickness", 10] := (FillAreaDoContour=1) ? 1 : 0
       uiSlidersArray["DrawLineAreaOpacity", 10] := (FillAreaDoContour=1) ? 1 : 0
       If (viewportQPVimage.imgHandle)
          GuiControl, SettingsGUIA: Disable, FillAreaDoContour
    } Else If (CurrentPanelTab=3)
    {
       If (viewportQPVimage.imgHandle)
          bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)

       thisBehind := (FillAreaDoBehind=1 && bpp=32) ? 1 : 0
       actu := (FillAreaGlassy>1 || FillAreaColorMode>=5 || FillAreaBlendMode>1 && thisBehind!=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, FillAreaApplyColorFX

       actu := (FillAreaApplyColorFX=1 && InStr(actu, "enable")) ? 1 : 0
       uiSlidersArray["PasteInPlaceLight", 10] := actu
       uiSlidersArray["PasteInPlaceGamma", 10] := actu
       uiSlidersArray["PasteInPlaceHue", 10] := actu
       uiSlidersArray["PasteInPlaceSaturation", 10] := actu
    } Else If (CurrentPanelTab=5)
    {
       updateUIalphaMaskStuff(1)
    } Else If (CurrentPanelTab=6)
       updateUIalphaMaskStuff(2)

    EllipseSelectMode := (FillAreaShape=7) ? 2 : 0
    If (FillAreaShape=3)
       EllipseSelectMode := 1
    ; ToggleEditImgSelection("show-edit")
    GuiRefreshSliders()
    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing()

    If (ShowAdvToolbar=1 && FillAreaColorMode=1 && liveDrawingBrushTool!=1)
    {
       thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
       %thisOpa% := FillAreaOpacity
    } Else If (ShowAdvToolbar=1 && liveDrawingBrushTool!=1)
    {
       BrushToolAopacity := FillAreaOpacity
       BrushToolBopacity := FillArea2ndOpacity
    }

    lastInvoked := A_TickCount
    SetTimer, dummyRefreshImgSelectionWindow, -50
    SetTimer, WriteSettingsFillAreaPanel, -350
    If !(viewportQPVimage.imgHandle)
    {
       SetTimer, WriteSettingsBrushPanel, -350
       SetTimer, WriteSettingsAlphaMaskPanel, -250
    }
}

updateUIalphaMaskerPanel(actionu:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=70)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If (CurrentPanelTab=1)
       updateUIalphaMaskStuff(1)
    Else If (CurrentPanelTab=2)
       updateUIalphaMaskStuff(2)
    
    EllipseSelectMode := 0
    GuiRefreshSliders()
    ; ToggleEditImgSelection("show-edit")
    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
       livePreviewsImageEditing()

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsBrushPanel, -350
    SetTimer, WriteSettingsAlphaMaskPanel, -250
}

WriteSettingsFillAreaPanel() {
    ReadSettingsFillAreaPanel(1)
}

WriteSettingsAlphaMaskPanel() {
    ReadSettingsAlphaMaskPanel(1)
}

WriteSettingsDrawShapeAreaPanel() {
    ReadSettingsDrawShapeAreaPanel(1)
}

BtnFillSelectedArea() {
    Gui, SettingsGUIA: Default
    If throwErrorAllSelectedInvert(FillAreaInverted)
       Return

    If (FillAreaInverted=1)
       PasteInPlaceAutoExpandIMG := 0

    If (PasteInPlaceAutoExpandIMG!=1)
    {
       If throwErrorSelectionOutsideBounds()
          Return
    }

    updateUIfillPanel("noPreview")
    If (viewportQPVimage.imgHandle)
    {
       bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
       If (FillAreaDoBehind=1 && bpp!=32)
       {
          msgBoxWrapper(appTitle ": WARNING", "You have selected to fill behind semi-transparent pixels. However, the current image does not seem to have an alpha channel or is not a 32-bits image. Operation abandoned.", 0, 0, "exclamation")
          Return
       }
    }

    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    Sleep, 1
    prevImgEditZeit := A_TickCount
    If (closeEditPanelOnApply=1)
       CloseWindow("yes", 0)
    ; Sleep, 1
    modus := (FillAreaDoBehind=1) ? " behind " : A_Space
    ToggleEditImgSelection("show-edit")
    If (viewportQPVimage.imgHandle)
       HugeImagesApplyGenericFilters("fill" modus "selected area")
    Else
       FillSelectedArea()
    prevImgEditZeit := A_TickCount
    SetTimer, RemoveTooltip, -250
}

BtnDrawShapeSelectedArea() {
    If throwErrorSelectionOutsideBounds()
       Return

    Gui, SettingsGUIA: Default
    updateUIfillPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    Sleep, 1
    prevImgEditZeit := A_TickCount
    If (closeEditPanelOnApply=1)
       CloseWindow("yes", 0)
    ; Sleep, 1
    ToggleEditImgSelection("show-edit")
    If (viewportQPVimage.imgHandle)
       HugeImagesDrawLineShapes()
    Else
       DrawLinesInSelectedArea(2)
    prevImgEditZeit := A_TickCount
    SetTimer, RemoveTooltip, -250
}

BtnInsertTextSelectedArea() {
    If (PasteInPlaceAutoExpandIMG!=1 || TextInAreaBlendMode>1)
    {
       If throwErrorSelectionOutsideBounds()
          Return
    }

    Gui, SettingsGUIA: Default
    updateUIInsertTextPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
    Sleep, 1
    If (closeEditPanelOnApply=1)
       BtnCloseWindow()
    ; Sleep, 1
    prevImgEditZeit := A_TickCount
    ToggleEditImgSelection("show-edit")
    If (viewportQPVimage.imgHandle)
       HugeImagesApplyInsertText()
    Else
       InsertTextSelectedArea()
    prevImgEditZeit := A_TickCount
    SetTimer, RemoveTooltip, -250
}

BtnViewedImages2List() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (userSeenSlideImages<2)
   {
      showTOOLtip("No images were seen in this session")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("discard it")
      Return

   BtnCloseWindow()
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := "\QPV\viewed-images-history|current-session.SLD"
   For Key, Value in userSeenSessionImagesArray
       resultedFilesList[Value] := [Key]

   SLDtypeLoaded := 2
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   RandomPicture()
}

BtnALLviewedImages2List(dummy:=0) {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("discard it")
      Return

   BtnCloseWindow()
   startOperation := A_TickCount
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   showTOOLtip("Gathering seen images list, please wait")
   setImageLoading()
   friendly := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : "ALL"
   dummy := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : ""
   seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 1, dummy)
   If (totalSeenIMGs<3)
   {
      seenEntries := ""
      SetTimer, ResetImgLoadStatus, -50
      CurrentSLD := backCurrentSLD
      If (SLDtypeLoaded=3)
         activeSQLdb.Exec("COMMIT TRANSACTION;")
      showTOOLtip("Found no already seen images in the database")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   PopulateIndexFilesStatsInfos("kill")
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := "\QPV\viewed-images-history|" friendly ".SLD"
   For Key, Value in seenEntries
       resultedFilesList[A_Index] := [Key,,1]

   seenEntries := ""
   SLDtypeLoaded := 2
   currentFilesListModified := 0
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   etaTime := "Elapsed time to retrieve seen images list from the database:`n" SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   RandomPicture()
}

PanelJournalWindow(tabu:=1) {
    If (AnyWindowOpen=1)
       CloseWindow()

    thisBtnHeight := createSettingsGUI(33, A_ThisFunc)
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 40
       Gui, Font, s%LargeUIfontValue%
    }

    textList := ""
    txtWid := Round(editWid*6.25)
    totalIndex := QPVjournal.Count()
    For Key, Value in QPVjournal
    {
        currentEntry := totalIndex - A_Index
        line := Trimmer(Value)
        If line
           textList .= "(" currentEntry ") " Trimmer(line) "`n`n"
    }

    errList := ""
    totalIndex := QPVerrJournal.Count()
    For Key, Value in QPVerrJournal
    {
        currentEntry := totalIndex - A_Index
        line := Trimmer(Value)
        If line
           errList .= "(" currentEntry ") " Trimmer(line) "`n`n"
    }

    userSeenSlideImages := userSeenSessionImagesArray.Count()
    WinGetTitle, thisTitle, ahk_id %PVhwnd%
    If (tabu=2)
       thisPanelTab := 3

    showTOOLtip("Please wait... opening " A_ThisFunc)
    errList := SubStr(errList, 1, 65530)
    textList := SubStr("WinTitle: " thisTitle "`n`n" textList, 1, 65100)
    Gui, Add, Tab3, %tabzDarkModus% AltSubmit gBtnTabsInfoUpdate hwndhCurrTab vCurrentPanelTab Choose%thisPanelTab%, Journal|Errors|Seen images
    Gui, Tab, 1
    Gui, Add, Button, x+15 y+15 w1 h1 gBtnCloseWindow Default, Clo&se
    GuiAddEdit("x+0 y+0 Section ReadOnly w" txtWid " r15", textList, "QPV events journal")
    Gui, Tab, 2
    GuiAddEdit("x+15 y+15 Section ReadOnly w" txtWid " r15", errList, "QPV errors journal")
    ; Gui, Add, Button, xs y+2 h%thisBtnHeight% gPanelSeenIMGsOptions, &Seen images database options

    Gui, Tab, 3
    If (mustRecordSeenImgs=1)
    {
       Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.
       typeu := (userPrivateMode=1) ? " Password " : ""
       Gui, Add, Button, xs y+15 h%thisBtnHeight% gBtnALLviewedImages2List, &Retrieve list of all recorded seen images
       Gui, Add, Button, y+5 hp wp gCleanDeadFilesSeenImagesDB, &Purge records of inexistent files
       Gui, Add, Button, y+5 hp wp geraseSeenIMGsDB, &Erase the entire list
       Gui, Add, Button, y+5 hp wp gPanelSeenStats, &Seen images statistics panel
       Gui, Add, Text, y+10 wp hp +0x200 gBtnApplyPrivateFolder +hwndhTempu, Private folder / privacy filter:
       ToolTip2ctrl(hTempu, "You can type keyword(s) or a complete folder path in the edit field.`nAny image that matches the content of this edit field will not be recorded as seen.")
       pw := (userPrivateMode=1) ? " +Password " : ""
       GuiAddEdit("y+5 wp r1 veditF1 " typeu pw, SeenIMGprivateFolder)
       Gui, Add, Button, xs y+5 hp gBtnBrowsePrivateFolder, &Browse
       Gui, Add, Button, x+2 hp wp gBtnApplyPrivateFolder, &Apply
       Gui, Add, Button, x+2 hp wp gBtnRemPrivateFolder +hwndhTempu, &None
       ToolTip2ctrl(hTempu, "Clear the private folder edit field and apply change")
       ; Gui, Add, Text, xs y+5 wp+50, TIP: To retrieve the images seen on a given day or month`, open the statistics panel.
    } Else
    {
       Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.
       Gui, Add, Text, xs y+10 hp +0x200, Seen images are not recorded in the database.
       Gui, Add, Button, xs+15 y+5 hp gBtnActivateRecordSeen, &Activate this
    }

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Application journal: " appTitle)
    SetTimer, ResetImgLoadStatus, -100
    RemoveTooltip()
}

BtnApplyPrivateFolder() {
   Gui, SettingsGUIA: Default
   GuiControlGet, editF1
   editF1 := Trimmer(editF1)
   editF1 := Trimmer(editF1, "\")
   SeenIMGprivateFolder := StrLen(editF1)>2 ? editF1 : ""
   GuiControl, SettingsGUIA:, editF1, % SeenIMGprivateFolder
   INIaction(1, "SeenIMGprivateFolder", "General")
   SoundBeep 900, 100
}

BtnRemPrivateFolder() {
   Gui, SettingsGUIA: Default
   SeenIMGprivateFolder := ""
   GuiControl, SettingsGUIA:, editF1, % SeenIMGprivateFolder
   INIaction(1, "SeenIMGprivateFolder", "General")
}

BtnBrowsePrivateFolder() {
   GuiControlGet, editF1
   editF1 := Trimmer(editF1)
   editF1 := Trimmer(editF1, "\")
   openu := FolderExist(editF1) ? editF1 : prevOpenFolderPath
   SelectedDir := openFoldersDialogWrapper(openu, "Select the folder to be ignored")
   If (SelectedDir)
   {
      SelectedDir := Trimmer(StrReplace(SelectedDir, "\\", "\"), "\")
      SeenIMGprivateFolder := SelectedDir "\"
      GuiControl, SettingsGUIA:, editF1, % SeenIMGprivateFolder
      INIaction(1, "SeenIMGprivateFolder", "General")
   }
}

BtnActivateRecordSeen() {
   BtnCloseWindow()
   Sleep, 10
   ToggleRecordSeenImages()
}

PanelSeenIMGsOptions() {
    PanelJournalWindow(2)
}

ReadSettingsTextInArea(act:=0) {
    RegAction(act, "TextInAreaFlipV",, 1)
    RegAction(act, "TextInAreaFlipV",, 1)
    RegAction(act, "TextInAreaAlign",, 2, 1, 3)
    RegAction(act, "TextInAreaCharSpacing",, 2, -100, 255)
    RegAction(act, "TextInAreaBlendMode",, 2, 1, 23)
    RegAction(act, "TextInAreaValign",, 2, 1, 3)
    RegAction(act, "TextInAreaBlurAmount",, 2, 1, 255)
    RegAction(act, "TextInAreaBlurBorderAmount",, 2, 1, 255)
    RegAction(act, "TextInAreaUsrMarginz",, 2, 0, 500)
    RegAction(act, "TextInAreaBgrColor",, 3)
    RegAction(act, "TextInAreaBgrEntire",, 1)
    RegAction(act, "TextInAreaBgrUnified",, 1)
    RegAction(act, "TextInAreaCutOutMode",, 1)
    RegAction(act, "TextInAreaBgrOpacity",, 2, 3, 255)
    RegAction(act, "TextInAreaBorderSize",, 2, 1, 650)
    RegAction(act, "TextInAreaBorderOut",, 2, 1, 3)
    RegAction(act, "TextInAreaBorderColor",, 3)
    RegAction(act, "TextInAreaBorderOpacity",, 2, 3, 255)
    RegAction(act, "TextInAreaFontBold",, 1)
    RegAction(act, "TextInAreaFontColor",, 3)
    RegAction(act, "TextInAreaFontItalic",, 1)
    RegAction(act, "TextInAreaFontName",, 5)
    RegAction(act, "TextInAreaFontLineSpacing",, 2, -950, 950)
    RegAction(act, "TextInAreaFontOpacity",, 2, 3, 255)
    RegAction(act, "TextInAreaFontSize",, 2, 5, 995)
    RegAction(act, "TextInAreaFontStrike",, 1)
    RegAction(act, "TextInAreaFontUline",, 1)
    RegAction(act, "TextInAreaOnlyBorder",, 1)
    RegAction(act, "TextInAreaPaintBgr",, 1)
    RegAction(act, "TextInAreaRoundBoxBgr",, 1)
    RegAction(act, "TextInAreaAutoWrap",, 1)
    RegAction(act, "TextInAreaCaseTransform",, 2, 1, 5)
    RegAction(act, "PasteInPlaceAutoExpandIMG",, 1)
    IniAction(act, "userimgGammaCorrect", "General", 1)
}

BtnResetTextAligns() {
   TextInAreaAlign := 1
   TextInAreaValign := 1
   GuiControl, SettingsGUIA: Choose, TextInAreaAlign, % TextInAreaAlign
   GuiControl, SettingsGUIA: Choose, TextInAreaValign, % TextInAreaValign
   updateUIInsertTextPanel()
}

BtnResetBrushColorBopacity() {
   BrushToolBopacity := 255
   GuiUpdateSliders("BrushToolBopacity")
}

BtnResetBrushColorAopacity() {
   BrushToolAopacity := 255
   GuiUpdateSliders("BrushToolAopacity")
}

PanelInsertTextArea() {
    openingPanelNow := 1
    If !(thisBtnHeight := createSettingsGUI(32, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    ReadSettingsTextInArea()
    ReadSettingsBrushPanel()
    ReadSettingsAlphaMaskPanel()
    btnWid := 70,       txtWid := 350
    columnBpos := 165,  slideWid := 150
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos := columnBpos + 95
       slideWid := slideWid + 55
       EditWid := EditWid + 40
       btnWid := btnWid + 20
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    EllipseSelectMode := 0
    ddWid := Round(editWid*3.25)
    txtWid := (PrefsLargeFonts=1) ? Round(editWid*4.5) : Round(editWid*5)
    Global editF1, editF2, editF3, editF4, editF5, editF6,  editF7, editF8, editF9, editF10, editF11
         , editF12, PickuTextInAreaFontColor, PickuTextInAreaBgrColor, PickuTextInAreaBorderColor, uiPasteInPlaceAlphaDrawMode

    If (viewportQPVimage.imgHandle)
       PasteInPlaceAutoExpandIMG := 0

    widu := (PrefsLargeFonts=1) ? 55 : 40
    ml := (PrefsLargeFonts=1) ? 35 : 24
    bonusTabs := (viewportQPVimage.imgHandle) ? "" : "|Alpha mask|Paint mask"
    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Text|Styling|Colors%bonusTabs%
    Gui, Tab, 1
    hEditField := GuiAddEdit("x+15 y+15 Section w" txtWid " r10 gupdateUIInsertTextPanel vUserTextArea", UserTextArea, "Text to draw")
    Gui, Add, Button, gBtnFntDlgInsertText, Font options
    GuiAddEdit("x+2 hp w" widu " gupdateUIInsertTextPanel limit3 -multi number -wantCtrlA -wantTab -wrap veditF1", TextInAreaFontSize, "Font size")
    Gui, Add, UpDown, vTextInAreaFontSize Range5-995, % TextInAreaFontSize
    widu := (PrefsLargeFonts=1) ? 30 : 25
    GuiAddCheckbox("x+2 yp hp+1 w" widu " gupdateUIInsertTextPanel Checked" TextInAreaFontBold " vTextInAreaFontBold", "Bold", "B")
    GuiAddCheckbox("x+2 yp hp wp gupdateUIInsertTextPanel Checked" TextInAreaFontItalic " vTextInAreaFontItalic", "Italic", "I")
    GuiAddCheckbox("x+2 yp hp wp gupdateUIInsertTextPanel Checked" TextInAreaFontUline " vTextInAreaFontUline", "Underline", "&U")
    GuiAddCheckbox("x+2 yp hp wp gupdateUIInsertTextPanel Checked" TextInAreaFontStrike " vTextInAreaFontStrike", "Strike through", "S")
    ; GuiAddDropDownList("x+5 w" ddWid " Sort Choose1 gupdateUIInsertTextPanel vTextInAreaFontName", TextInAreaFontName)
    Gui, Add, Checkbox, x+5 hp +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaAutoWrap% vTextInAreaAutoWrap, Word-&wrap
    GuiAddDropDownList("xs y+5 wp+20 gupdateUIInsertTextPanel Choose" TextInAreaCaseTransform " AltSubmit vTextInAreaCaseTransform", "No transform|CAPITALIZED|lowercase|Title Case|Leet speak", "Text case transformation")
    GuiAddCheckbox("x+5 wp-35 hp+1 gupdateUIInsertTextPanel Checked" TextInAreaFlipV " vTextInAreaFlipV", "Flip text vertically", "Flip V")
    GuiAddCheckbox("x+5 wp hp gupdateUIInsertTextPanel Checked" TextInAreaFlipH " vTextInAreaFlipH", "Flip text horizontally", "Flip H")
    GuiAddButton("x+5 hp w" ml " gBTNapplyCaseTransfm vbtn5", ">", "Apply test case transformation in the edit field")

    ha := (PrefsLargeFonts=1) ? 27 : 18
    wa := (PrefsLargeFonts=1) ? 145 : 100
    opaciSlideW := (PrefsLargeFonts=1) ? 130 : 85
    opaciSlideW := Round(opaciSlideW*1.7)

    Gui, Tab, 2
    GuiAddSlider("TextInAreaUsrMarginz", 0,500, 0, "Text margins: $€ px", "updateUIInsertTextPanel", 1, "x+15 y+15 Section w" opaciSlideW " h" ha)
    GuiAddSlider("TextInAreaCharSpacing", -100,255, 0, "Letters spacing: $€", "updateUIInsertTextPanel", 3, "x+5 wp hp")
    GuiAddSlider("TextInAreaFontLineSpacing", -950,950, 0, "Line spacing: $€ px", "updateUIInsertTextPanel", 2, "xs y+10 wp hp")
    Gui, Add, Checkbox, x+5 yp hp gupdateUIInsertTextPanel Checked%TextInAreaOnlyBorder% vTextInAreaOnlyBorder, &Draw only the border

    GuiAddDropDownList("xs y+10 wp gupdateUIInsertTextPanel Altsubmit Choose" TextInAreaBorderOut " vTextInAreaBorderOut", "No border|Centered|Contour", "Text border type")
    GuiAddSlider("TextInAreaBorderSize", 1,650, 1, "Border thickness: $€ px", "updateUIInsertTextPanel", 1, "x+5 wp h" ha)

    Gui, Add, Text, xs y+10 wp hp +0x200 +TabStop gBtnResetTextAligns, Text alignment:
    GuiAddDropDownList("x+3 w" editWid " gupdateUIInsertTextPanel Choose" TextInAreaAlign " AltSubmit vTextInAreaAlign", "Left|Center|Right", "Text horizontal alignment")
    GuiAddDropDownList("x+5 wp gupdateUIInsertTextPanel Choose" TextInAreaValign " AltSubmit vTextInAreaValign", "Top|Center|Bottom", "Text vertical alignment")

    Gui, Add, Checkbox, xm+15 yp+%ml% w%opaciSlideW% Section gupdateUIInsertTextPanel Checked%TextInAreaPaintBgr% vTextInAreaPaintBgr, Draw background
    Gui, Add, Checkbox, x+1 yp hp gupdateUIInsertTextPanel Checked%TextInAreaVerticalia% vTextInAreaVerticalia, Rotate text by 90°
    Gui, Add, Checkbox, xs yp+%ml% w%opaciSlideW% gupdateUIInsertTextPanel Checked%TextInAreaBgrUnified% vTextInAreaBgrUnified, Unified block
    Gui, Add, Checkbox, x+1 yp hp gupdateUIInsertTextPanel Checked%TextInAreaRoundBoxBgr% vTextInAreaRoundBoxBgr, Rounded corners
    Gui, Add, Checkbox, xs yp+%ml% w%opaciSlideW% gupdateUIInsertTextPanel Checked%TextInAreaCutOutMode% vTextInAreaCutOutMode, Cut-out mode
    Gui, Add, Checkbox, x+1 yp hp gupdateUIInsertTextPanel Checked%TextInAreaBgrEntire% vTextInAreaBgrEntire, Fill entire line(s)
    Gui, Add, Checkbox, xs yp+%ml% gupdateUIInsertTextPanel Checked%PasteInPlaceAutoExpandIMG% vPasteInPlaceAutoExpandIMG, &Auto-expand canvas to fit selection area
    If (viewportQPVimage.imgHandle)
       GuiControl, Disable, PasteInPlaceAutoExpandIMG

    Gui, Tab, 3
    clrW := (PrefsLargeFonts=1) ? 65 : 45
    opaciSlideW := (PrefsLargeFonts=1) ? 130 : 90

    Gui, Add, Text, x+15 y+15 h%ha% w%wa% +0x200 Section vtxtLine6, Text
    GuiAddPickerColor("x+1 hp w27", "TextInAreaFontColor")
    GuiAddColor("x+2 w" clrW " hp", "TextInAreaFontColor", "Text color")
    GuiAddSlider("TextInAreaFontOpacity", 2,255, 255, "Opacity", "updateUIInsertTextPanel", 1, "x+5 w" opaciSlideW " hp")

    ml := (PrefsLargeFonts=1) ? 12 : 8
    Gui, Add, Text, xs y+%ml% h%ha% w%wa% +0x200 vtxtLine1, Border
    GuiAddPickerColor("x+1 hp w27", "TextInAreaBorderColor")
    GuiAddColor("x+2 w" clrW " hp", "TextInAreaBorderColor", "Border color")
    GuiAddSlider("TextInAreaBorderOpacity", 2,255, 255, "Opacity", "updateUIInsertTextPanel", 1, "x+5 w" opaciSlideW " hp")

    Gui, Add, Text, xs y+%ml% h%ha% w%wa% +0x200 vtxtLine2, Background
    GuiAddPickerColor("x+1 hp w27", "TextInAreaBgrColor")
    GuiAddColor("x+2 w" clrW " hp", "TextInAreaBgrColor", "Background color")
    GuiAddSlider("TextInAreaBgrOpacity", 2,255, 255, "Opacity", "updateUIInsertTextPanel", 1, "x+5 w" opaciSlideW " hp")
    Gui, Add, Text, xs y+10 w%wa% hp +0x200 +TabStop gBtnResetTextBlendMode +hwndhTemp, Blending mode
    GuiAddDropDownList("x+1 wp gupdateUIInsertTextPanel AltSubmit Choose" TextInAreaBlendMode " vTextInAreaBlendMode", "None|" userBlendModesList, [hTemp])
    GuiAddFlipBlendLayers("x+1 yp hp w26 gupdateUIInsertTextPanel")
    Gui, Add, Checkbox, xs y+%ml% Checked%userimgGammaCorrect% vuserimgGammaCorrect gupdateUIInsertTextPanel, &Apply gamma corrections

    Gui, Add, Checkbox, xs y+%ml% gupdateUIInsertTextPanel Checked%TextInAreaDoBlurs% vTextInAreaDoBlurs, Apply blur effect
    sml := (PrefsLargeFonts=1) ? 55 : 35
    GuiAddSlider("TextInAreaBlurAmount", 0,255, 0, "Text blur", "updateUIInsertTextPanel", 1, "xs+15 y+8 w" opaciSlideW + sml " h" ha)
    GuiAddSlider("TextInAreaBlurBorderAmount", 0,255, 0, "Border blur", "updateUIInsertTextPanel", 1, "x+5 wp hp")

    If !viewportQPVimage.imgHandle
       uiADDalphaMaskTabs(4, 5, "updateUIInsertTextPanel")

    Gui, Tab
    ml := (PrefsLargeFonts=1) ? 90 : 70
    sml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddCollapseBtn("xm+0 y+15 h" thisBtnHeight " w" sml)
    GuiAddCloseOnApply("x+5 yp hp wp")
    GuiAddToggleLivePreview("x+5 yp hp wp gBTNuiToggleLiveInsertTextPreview")
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    Gui, Add, Button, x+5 hp w%ml% gBtnCloseWindow, &Cancel
    ; PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Insert text in image: " appTitle, winPos)
    SetTimer, updateUIInsertTextPanel, -250
    SetTimer, resetOpeningPanel, -300
}

BTNuiToggleLiveInsertTextPreview() {
   livePreviewInsertTextinArea("soft-kill", 0)
   updateUIInsertTextPanel()
}

uiADDalphaMaskTabs(t1, t2, labelu) {
    Global uiPasteInPlaceAlphaDrawMode, UIviewAlpha, infoAlphaMaskGradientView, UIresetAlphaCenter
    btnWid := 90,  txtWid := 310
    EditWid := 60, slideWid := 150

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 60
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid2 := txtWid//2
    sml := (PrefsLargeFonts=1) ? 30 : 20
    transformTool := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
    If (transformTool=0 && alphaMaskRefBMP=3)
       alphaMaskRefBMP := 1

    Gui, Tab, %t1% ; alpha mask
    friendlyMaskInfo := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "No alpha mask"
    GuiAddDropDownList("x+15 y+15 Section w" txtWid2 " AltSubmit Choose" alphaMaskingMode " valphaMaskingMode g" labelu, friendlyMaskInfo "|Linear gradient|Radial gradient|Box gradient|Image bitmap|Custom shape", "Alpha mask type")
    If (AnyWindowOpen!=70)
       GuiAddButton("x+1 w" sml " hp vUIviewAlpha gUIbtnViewAlphaMaskNow", "P", "Alpha mask preview", "Show a temporary preview of the alpha mask in the viewport")
    
    ml := (PrefsLargeFonts=1) ? 170 : 125
    GuiAddDropDownList("x+5 w" ml " AltSubmit Choose" alphaMaskGradientWrapped " valphaMaskGradientWrapped g" labelu, "Tiled gradient|Tiled - flip X|Tiled - flip Y|Tiled - flip X/Y|No gradient tiling", "Gradient tiling mode")
    GuiAddSlider("alphaMaskClrAintensity", 0,255, 0, "Intensity A", labelu, 1, "xs y+10 w" slideWid " hp")
    GuiAddSlider("alphaMaskBMPbright", -255,255, 0, "Brightness", labelu, 2, "xp yp wp hp")
    GuiAddSlider("alphaMaskClrBintensity", 0,255, 255, "Intensity B", labelu, 1, "x+5 wp hp")
    GuiAddSlider("alphaMaskBMPcontrast", -100,100, 0, "Contrast", labelu, 2, "xp yp wp hp")
    GuiAddSlider("alphaMaskGradientAngle", -180,180, 0, "Angle: $€°", labelu, 2, "xs y+10 wp hp")
    GuiAddSlider("alphaMaskGradientScale", 1,300, 100, "Scale: $€ %", labelu, 1, "x+5 wp hp")
    GuiAddSlider("alphaMaskGradientPosA", 0,200, 0, "Position A", labelu, 3, "xs y+10 Section wp hp")
    GuiAddSlider("alphaMaskGradientPosB", 0,200, 200, "Position B", labelu, 3, "x+5 wp hp")

    ha := (PrefsLargeFonts=1) ? 27 : 18
    kak := Round(ha*2.2)
    Gui, Add, Text, xs ys+2 vinfoAlphaFile, Alpha mask bitmap:
    GuiAddDropDownList("xs y+10 Section w" txtWid2 " g" labelu " AltSubmit valphaMaskRefBMP Choose" alphaMaskRefBMP, (transformTool=1) ? "User painted bitmap|Main image|Transformed object" : "User painted bitmap|Main image", "Alpha mask bitmap source")
    GuiAddDropDownList("x+5 wp-90 AltSubmit Choose" alphaMaskBMPchannel " valphaMaskBMPchannel g" labelu " +hwndhTemp", "Red|Green|Blue|Alpha|All gray", "Alpha mask bitmap color channel to use")
    GuiAddButton("x+2 w" sml " hp vUIremAlpha gdiscardUserPaintedAlpha", "X", "Discard user bitmap", "Destroy the user painted bitmap")
    Gui, Add, Text, xs ys+5 w%kak% h%kak% -Border +0xE gGradientsPreviewResponder vinfoAlphaMaskGradientView +hwndhGradientAlphaMSKpreview, Alpha mask gradient preview
    ToolTip2ctrl(hGradientAlphaMSKpreview, "Click and drag to adjust the gradient offset.`nHold Alt while dragging to adjust its center.")

    kak := Round(ha*1.5)
    Gui, Add, Button, x+10 h%ha% vUIresetAlphaCenter gBtnResetGradientCenter, &Reset gradient center
    If (AnyWindowOpen!=70)
    {
       Gui, Add, Checkbox, xs y+%kak% w%txtWid2% Checked%alphaMaskColorReversed% valphaMaskColorReversed g%labelu%, Invert mas&k
       Gui, Add, Checkbox, x+0 hp Checked%alphaMaskReplaceMode% valphaMaskReplaceMode g%labelu% +hwndhTemp, &Replace alpha channel
       ToolTip2ctrl(hTemp, "When this is checked, users can restore partially transparent pixels")
    } Else
    {
       Gui, Add, Checkbox, xp y+5 wp Checked%alphaMaskColorReversed% valphaMaskColorReversed g%labelu%, Invert mas&k
       Gui, Add, Checkbox, x+0 w1 h1 -TabStop Checked%alphaMaskReplaceMode% valphaMaskReplaceMode, &Replace alpha channel
    }

    Gui, Tab, %t2% ; paint alpha
    BrushToolType := clampInRange(BrushToolType, 1, 2)
    Gui, Add, Checkbox, x+15 y+15 Section gBTNtoggleAlphaPainting Choose%uiPasteInPlaceAlphaDrawMode% vuiPasteInPlaceAlphaDrawMode, Enable alpha mask painting mode
    GuiAddDropDownList("xs y+10 Section AltSubmit w" txtWid2 " g" labelu " Choose" BrushToolType " vBrushToolType", "Simple solid color|Soft edges brush", "Brush type")
    Gui, Add, Checkbox, x+10 hp gupdateUIbrushTool Checked%BrushToolOverDraw% vBrushToolOverDraw , &Airbrush mode
    Gui, Add, Text, xs y+10 hp w%sml% +0x200 Center gBtnToggleBrushColors vUIbtnBrushColorA +TabStop +hwndhBtnTglClrA, [X]
    GuiAddPickerColor("x+5 hp w" sml, "BrushToolAcolor")
    GuiAddColor("x+5 hp w60", "BrushToolAcolor")

    opaciSlideW := (PrefsLargeFonts=1) ? 130 : 85
    GuiAddSlider("BrushToolAopacity", 2,255, 255, "Opacity", labelu, 1, "x+5 w" opaciSlideW " hp")
    Gui, Add, Checkbox, x+5 hp wp +0x1000 -wrap Checked%BrushToolAutoAngle% vBrushToolAutoAngle g%labelu%, Auto-rotate
    Gui, Add, Text, xs y+10 hp w%sml% +0x200 Center gBtnToggleBrushColors vUIbtnBrushColorB +TabStop +hwndhBtnTglClrB, [X]
    GuiAddPickerColor("x+5 hp w" sml, "BrushToolBcolor")
    GuiAddColor("x+5 hp w60", "BrushToolBcolor")
    GuiAddSlider("BrushToolBopacity", 2,255, 255, "Opacity", labelu, 1, "x+5 w" opaciSlideW " hp")
    Gui, Add, Checkbox, x+5 hp wp +0x1000 g%labelu% Checked%BrushToolDoubleSize% vBrushToolDoubleSize, Size × 2

    ToolTip2ctrl(hBtnTglClrA, "Toggle active color")
    ToolTip2ctrl(hBtnTglClrB, "Toggle active color")
    GuiAddSlider("BrushToolSize", 2,950, 25, "Brush size: $€", labelu, 1, "xs y+15 w" slideWid " hp")
    GuiAddSlider("BrushToolStepping", 0,251, 0, ".updateLabelBrushStep", labelu, 1, "x+10 wp hp")
    GuiAddSlider("BrushToolAspectRatio", -100,100, 0, "Aspect ratio", labelu, 2, "xs y+10 wp hp")
    GuiAddSlider("BrushToolAngle", -180,180, 0, "Angle: $€°", labelu, 2, "x+10 wp hp")
    GuiAddSlider("BrushToolSoftness", 1,100, 3, "Softness", labelu, 1, "xs y+10 wp hp")
    GuiAddSlider("BrushToolDryingRate", 0,20, 0, "Dry-out rate", labelu, 1, "x+10 wp hp")
}

PopulateFontsList(thisCtrl, guiu) {
    If !FontList._NewEnum()[k, v]
    {
       Fnt_GetListOfFontsSimplified()
       FontList := trimArray(FontList)
    }

    Loop, % FontList.Count()
    {
        fontNameInstalled := FontList[A_Index]
        If (fontNameInstalled ~= "i)(@|biz ud|ud digi kyo|oem|extb|symbol|marlett|wst_|glyph|reference specialty|system|terminal|mt extra|small fonts|cambria math|this font is not|fixedsys|emoji|hksc| mdl|wingdings|webdings)") || (fontNameInstalled=OSDFontName)
           Continue

        GuiControl, %guiu%:, %thisCtrl%, %fontNameInstalled%
    }
}

BtnFntDlgInsertText() {
   fntObj := []
   fntObj.name := TextInAreaFontName
   fntObj.size := TextInAreaFontSize//2
   fntObj.strike := TextInAreaFontStrike
   fntObj.underline := TextInAreaFontUline
   fntObj.bold := TextInAreaFontBold
   fntObj.italic := TextInAreaFontItalic
   ; fntObj.color := TextInAreaFontColor
   WinSet, Disable,, ahk_id %PVhwnd%
   oc := A_IsCritical
   Critical, Off
   nFntObj := Dlg_FontSelect(fntObj, hSetWinGui, 1)
   Critical, %oc%
   WinSet, Enable,, ahk_id %PVhwnd%
   If IsObject(nFntObj)
   {
      Gui, SettingsGUIA: Default
      TextInAreaFontName := nfntObj.name
      TextInAreaFontSize := nfntObj.size * 2
      TextInAreaFontStrike := nfntObj.strike
      TextInAreaFontUline := nfntObj.underline
      TextInAreaFontBold := nfntObj.bold
      TextInAreaFontItalic := nfntObj.italic
      GuiControl, SettingsGUIA:, TextInAreaFontSize, % TextInAreaFontSize
      GuiControl, SettingsGUIA:, TextInAreaFontStrike, % TextInAreaFontStrike
      GuiControl, SettingsGUIA:, TextInAreaFontUline, % TextInAreaFontUline
      GuiControl, SettingsGUIA:, TextInAreaFontBold, % TextInAreaFontBold
      GuiControl, SettingsGUIA:, TextInAreaFontItalic, % TextInAreaFontItalic
      ; TextInAreaFontColor := nfntObj.color
      If (doImgEditLivePreview=1)
         livePreviewsImageEditing()

      SetTimer, WriteSettingsTextAreaPanel, -100
   }
}

updateUIInsertTextPanel(actionu:=0, b:=0) {
    Static lastInvoked := 1
    If (AnyWindowOpen!=32)
       Return

    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    If !isNumber(TextInAreaFontLineSpacing)
       TextInAreaFontLineSpacing := 0

    If (TextInAreaBorderSize>=TextInAreaFontSize*2)
       TextInAreaBorderSize := TextInAreaFontSize*2

    If (A_TickCount - lastInvoked < 70)
    {
       SetTimer, updateUIInsertTextPanel, -200
       Return
    }

    If (CurrentPanelTab=1)
    {
       UserTextArea := Trimmer(UserTextArea)
       UserTextArea := allowCtrlBkspEdit(hEditField, UserTextArea)
       actu := (TextInAreaCaseTransform!=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, btn5
    } Else If (CurrentPanelTab=2)
    {
       actu := (TextInAreaPaintBgr=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, TextInAreaBgrUnified
       GuiControl, % actu, TextInAreaBgrEntire
       GuiControl, % actu, TextInAreaCutOutMode

       actu := (TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, TextInAreaBgrEntire

       actu2 := (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, TextInAreaRoundBoxBgr

       actu2 := (TextInAreaBorderOut>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu2, TextInAreaOnlyBorder

       uiSlidersArray["TextInAreaBorderSize", 3] := TextInAreaFontSize*2
       uiSlidersArray["TextInAreaBorderSize", 10] := (TextInAreaBorderOut>1) ? 1 : 0
    } Else If (CurrentPanelTab=3)
    {
       actu := (TextInAreaBorderOut>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, txtLine1
       GuiControl, % actu, PickuTextInAreaBorderColor
       uiSlidersArray["TextInAreaBorderOpacity", 10] := (TextInAreaBorderOut>1) ? 1 : 0

       actu := (TextInAreaBorderOut>1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, TextInAreaBorderColor

       pku := (TextInAreaCutOutMode=1 && TextInAreaPaintBgr=1 || TextInAreaOnlyBorder=1 && TextInAreaBorderOut>1) ? 1 : 0 
       actu := (pku=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
       GuiControl, % actu, txtLine6
       GuiControl, % actu, PickuTextInAreaFontColor
       uiSlidersArray["TextInAreaFontOpacity", 10] := !pku

       actu := (pku=1) ? "SettingsGUIA: Hide" : "SettingsGUIA: Show"
       GuiControl, % actu, TextInAreaFontColor

       actu := (TextInAreaPaintBgr=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
       GuiControl, % actu, txtLine2
       GuiControl, % actu, PickuTextInAreaBgrColor
       uiSlidersArray["TextInAreaBgrOpacity", 10] := TextInAreaPaintBgr

       actu := (TextInAreaPaintBgr=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
       GuiControl, % actu, TextInAreaBgrColor

       uiSlidersArray["TextInAreaBlurBorderAmount", 10] := (TextInAreaDoBlurs=1 && TextInAreaBorderOut>1) ? 1 : 0
       uiSlidersArray["TextInAreaBlurAmount", 10] := (TextInAreaDoBlurs=1) ? 1 : 0
    } Else If (CurrentPanelTab=4)
    {
       updateUIalphaMaskStuff(1)
    } Else If (CurrentPanelTab=5)
       updateUIalphaMaskStuff(2)

    GuiRefreshSliders()
    If (actionu!="noPreview")
       livePreviewsImageEditing(0, A_ThisFunc, actionu, b)

    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    If (liveDrawingBrushTool!=1 && ShowAdvToolbar=1 && (TextInAreaPaintBgr=1 && TextInAreaCutOutMode=1 && TextInAreaBgrUnified=0))
    {
       %thisOpa% := TextInAreaBgrOpacity
    } Else If (liveDrawingBrushTool!=1 && ShowAdvToolbar=1 && TextInAreaPaintBgr=0)
    {
       %thisOpa% := TextInAreaFontOpacity
    } Else If (liveDrawingBrushTool!=1 && ShowAdvToolbar=1)
    {
       BrushToolAopacity := TextInAreaFontOpacity
       BrushToolBopacity := TextInAreaBgrOpacity
    }

    lastInvoked := A_TickCount
    SetTimer, WriteSettingsTextAreaPanel, -300
    SetTimer, WriteSettingsBrushPanel, -350
    SetTimer, WriteSettingsAlphaMaskPanel, -250
}

WriteSettingsTextAreaPanel() {
     ReadSettingsTextInArea(1)
}

PanelPrefsWindow() {
    If AnyWindowOpen
       Return

    thisBtnHeight := createSettingsGUI(14, A_ThisFunc)
    btnWid := 100
    txtWid := 350
    EditWid := 60
    columnBpos2 := 255
    If (PrefsLargeFonts=1)
    {
       columnBpos2 := columnBpos2 + 50
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Global editF4, editF5, editF6, PickuWindowBGRcolor, PickuOSDbgrColor, PickuOSDtextColor
    Gui, Add, Text, x15 y15 w%txtWid%, The text style options apply to the On-Screen Display in the viewport. The same text style is used to render as images texts pasted from the clipboard.
    Gui, Add, Text, y+15 Section, Font name
    Gui, Add, Text, xs yp+30, Font size (OSD / clipboard)
    Gui, Add, Text, xs yp+30, Text color and style
    Gui, Add, Text, xs yp+30, Alignment (captions / paste)
    Gui, Add, Text, xs yp+30, OSD background color
    Gui, Add, Text, xs yp+30, Display time (in sec.)
    Gui, Add, Text, xs yp+30, Window background color
    Gui, Add, Text, xs yp+30, Add rows in list views
    Gui, Add, Checkbox, xs yp+30 gupdateUIsettings Checked%usrTextureBGR% vusrTextureBGR, &Ambiental textured background

    GuiAddDropDownList("xs+" columnBpos2 " ys+0 Section w190 gupdateUIsettings Sort Choose1 vOSDFontName", OSDFontName, "OSD font name")
    GuiAddEdit("xs+0 yp+30 w" editWid " r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF5", OSDfontSize, "OSD font size")
    Gui, Add, UpDown, vOSDfontSize Range10-350, %OSDfontSize%
    GuiAddEdit("x+2 w" editWid " r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF4", PasteFntSize, "Text on paste font size")
    Gui, Add, UpDown, vPasteFntSize Range12-350, %PasteFntSize%

    GuiAddColor("xs yp+30 w" editWid " h28", "OSDtextColor", "OSD text color")
    GuiAddPickerColor("x+5 hp w25", "OSDtextColor")
    GuiAddCheckbox("x+2 yp hp w27 gupdateUIsettings Checked" OSDfontBolded " vOSDfontBolded","Bold", "B")
    GuiAddCheckbox("x+2 yp hp w27 gupdateUIsettings Checked" OSDfontItalica " vOSDfontItalica", "Italic", "I")
    GuiAddDropDownList("xs yp+30 w" editWid " gupdateUIsettings vusrTextAlign", usrTextAlign "||Left|Right|Center", "Text alignment")
    GuiAddColor("xs+0 yp+30 w" editWid " hp", "OSDbgrColor", "OSD background color")
    GuiAddPickerColor("x+5 hp w25", "OSDbgrColor")
    GuiAddEdit("xs+0 yp+30 gupdateUIsettings w" editWid " hp r1 limit2 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF6", DisplayTimeUser, "OSD display time in seconds")
    Gui, Add, UpDown, vDisplayTimeUser Range1-99, %DisplayTimeUser%
    GuiAddColor("xs+0 yp+30 w" editWid " hp", "WindowBGRcolor", "Window background color")
    GuiAddPickerColor("x+5 hp w25", "WindowBGRcolor")
    GuiAddEdit("xs+0 yp+30 gupdateUIsettings w" editWid " hp r1 limit2 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF8", additionalLVrows, "Additional list view rows")
    Gui, Add, UpDown, vadditionalLVrows Range0-15, % additionalLVrows
    GuiAddEdit("xs+0 yp+30 gupdateUIsettings w" editWid " hp r1 limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF7", ambiTexBrushSize, "Texture size")
    Gui, Add, UpDown, vambiTexBrushSize Range25-950, %ambiTexBrushSize%
    Gui, Add, Checkbox, x15 y+10 hp gupdateUIsettings Checked%borderAroundImage% vborderAroundImage, &Highlight image borders in the viewport

    PopulateFontsList("OSDFontName", "SettingsGUIA")
    Gui, Add, Button, xm+0 y+20 h%thisBtnHeight% w%btnWid% gOpenUImenu, &More options
    Gui, Add, Button, x+5 hp w90 gPrefsCloseBTN Default, Clo&se
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Interface settings: " appTitle)
}

WriteSettingsAdjustToneMapPanel() {
   ReadSettingsAdjustToneMapPanel(1)
}

ReadSettingsAdjustToneMapPanel(actu:=0) {
    IniAction(actu, "cmrRAWtoneMapAlgo", "General", 2, 1, 2)
    IniAction(actu, "cmrRAWtoneMapParamA", "General", 2, -8, 10)
    IniAction(actu, "cmrRAWtoneMapParamB", "General", 2, -8, 10)
    IniAction(actu, "allowToneMappingImg", "General", 1)
    IniAction(actu, "userHQraw", "General", 1)
    RegAction(actu, "UIuserToneMapParamA", "General", 2, 0, 400)
    RegAction(actu, "UIuserToneMapParamB", "General", 2, 0, 400)
}

PanelAdjustToneMapping() {
    If AnyWindowOpen
       Return

    thisBtnHeight := createSettingsGUI(42, A_ThisFunc)
    ReadSettingsAdjustToneMapPanel()
    btnWid := 100
    txtWid := 500
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 20
       Gui, Font, s%LargeUIfontValue%
    }

    showTOOLtip("Initializing tone-mapping panel, please wait")
    Global SliderA, SliderB, infoSliderA, infoSliderB
    Gui, -DPIScale
    Gui, Add, Text, x15 y15 w460 h320 +0x1000 +0xE +hwndhLVmainu, Image before 
    Gui, Add, Text, x480 y15 w460 h320 +0x1000 +0xE +hwndhCropCornersPic, Image after
    Gui, +DPIScale
    Gui, Add, Text, x15 y+10 Section w%txtWid% vinfoLine, Image pixel format: %globalInfohFIFbmp%`n.
    Gui, Add, Checkbox, xs y+10 gupdateUItoneMappingPanel Checked%allowToneMappingImg% vallowToneMappingImg, Apply tone mapping to images
    GuiAddDropDownList("xs y+10 w" txtWid " AltSubmit gupdateUItoneMappingPanel Choose" cmrRAWtoneMapAlgo " vcmrRAWtoneMapAlgo", "F. Drago: Adaptive logarithmic mapping (2003)|E. Reinhard: HDR reduction inspired by photoreceptors physiology (2005)", "HDR tone mapping algorithm")
    GuiAddSlider("UIuserToneMapParamA", 1,400, 74, "Tone-mapping: Param A", "updateUItoneMappingPanel", 1, "xs y+10 wp hp+2")
    GuiAddSlider("UIuserToneMapParamB", 1,400, 200, "Tone-mapping: Param B", "updateUItoneMappingPanel", 1, "xs y+10 wp hp")
    Gui, Add, Checkbox, xs y+10 wp gupdateUItoneMappingPanel Checked%userHQraw% vuserHQraw, Load camera RAW images at high quality

    initializeFimPreviewIMG(getIDimage(currentFileIndex))
    ml := (PrefsLargeFonts=1) ? 35 : 25
    cl := (PrefsLargeFonts=1) ? 90 : 60
    pp := (maxFilesIndex<2) ? " +Disabled " : ""
    GuiAddButton("xs y+25 h" thisBtnHeight " w" ml pp " gBtnPrevToneMapPic", "<<", "Previous image")
    GuiAddButton("x+5 hp wp gBtnNextToneMapPic" pp, ">>", "Next image")
    Gui, Add, Button, x+5 h%thisBtnHeight% w%cl% gBTNtoneMapRefresh Default, &Apply
    Gui, Add, Button, x+5 hp wp gBTNresetToneMap, &Reset
    Gui, Add, Button, x+5 hp wp gBtnHelpToneMapping, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, Clo&se
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "HDR tone-mapping options: " appTitle, winPos)
    RemoveTooltip()
    SetTimer, updateUItoneMappingPanel, -350
}

BtnHelpToneMapping() {
   msgBoxWrapper(appTitle ": HELP", "High-dynamic range images (HDRIs) must be converted to 24 bits to be displayed on screen. You can choose the algorithm to use for this and also configure it.`n`nWhen the option to load Camera RAW images with high quality is activated, the tone-mapping options can be applied on these as well.`n`nDeactivating tone-mapping for HDR, EXR and PFM image file formats is not possible.", -1, 0, 0)
}

killToneMapImageCacheObj() {
    If globalhFIFimg
    {
       ; related to PanelAdjustToneMapping()
       FreeImage_UnLoad(globalhFIFimg)
       globalhFIFimg := ""
    }
}

BtnNextToneMapPic() {
    killToneMapImageCacheObj()
    BtnNextImg()
    updateUIfimBeforeIMG("r")
    initializeFimPreviewIMG(getIDimage(currentFileIndex))
    SetTimer, updateUItoneMappingPanel, -350
}

BtnPrevToneMapPic() {
    killToneMapImageCacheObj()
    BtnPrevImg()
    updateUIfimBeforeIMG("r")
    initializeFimPreviewIMG(getIDimage(currentFileIndex))
    SetTimer, updateUItoneMappingPanel, -350
}

initializeFimPreviewIMG(imgPath) {
  Static uiBoxW := 460, uiBoxH := 320
  initFIMGmodule()
  If !wasInitFIMlib
     Return 0

  loadArgs := 0
  killToneMapImageCacheObj()
  GFT := FreeImage_GetFileType(imgPath)
  pk := FreeImage_GetFileType(imgPath, 1)
  If (GFT=2 && loadArgs=0)
     loadArgs := 8

  hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
  If hFIFimgA
  {
     FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
     calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
     imgType := FreeImage_GetImageType(hFIFimgA, 1)
     imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
     ColorsType := FreeImage_GetColorType(hFIFimgA)
     mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba") && GFT!=13) || (imgBPP>64) ? 1 : 0
     globalInfohFIFbmp := imgBPP "-" ColorsType " | " imgType ".`nFile format: " pk
     If (mustApplyToneMapping=1)
     {
        hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, 0)
        FreeImage_UnLoad(hFIFimgA)
        hFIFimgA := ""
     }
  } Else
     globalInfohFIFbmp := "Failed to load the image file."

  GuiControl, SettingsGUIA:, infoLine, Image pixel format: %globalInfohFIFbmp%. Dimensions: %imgW% x %imgH% (pixels).
  If !hFIFimgB
  {
     FreeImage_UnLoad(globalhFIFimg)
     If hFIFimgA
        FreeImage_UnLoad(hFIFimgA)
     globalInfohFIFbmp := ""
     globalhFIFimg := ""
     Return 0
  }

  globalhFIFimg := hFIFimgB
  If !globalhFIFimg
     Return 0
  Else
     Return 1
}

updateUIfimBeforeIMG(modus:=0) {
   Static prevImg := 0
   Static uiBoxW := 460, uiBoxH := 320
   If (modus="r")
   {
      prevImg := 0
      Return
   }

   thisImg := getIDimage(currentFileIndex) "|" currentFileIndex "|" maxFilesIndex "|" globalhFIFimg
   If (prevImg!=thisImg)
   {
      tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, coreDesiredPixFmt)
      If !validBMP(tempBMP)
      {
         prevImg := 0
         Return 0
      }
 
      Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
      If !Gu
      {
         prevImg := 0
         trGdip_DisposeImage(tempBMP, 1)
         Return 0
      }
 
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
      thisX := uiBoxW//2 - thisW//2
      thisY := uiBoxH//2 - thisH//2
      Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
      r1 := trGdip_DrawImage(A_ThisFunc, Gu, useGdiBitmap(), thisX, thisY, thisW, thisH)
      hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
      SetImage(hLVmainu, hBitmap)
      Gdi_DeleteObject(hBitmap)
      trGdip_DisposeImage(tempBMP, 1)
      Gdip_DeleteGraphics(Gu)
      prevImg := thisImg
   }
}

updateUIfimToneMappedIMG() {
   Static uiBoxW := 460, uiBoxH := 320
   If !globalhFIFimg
   {
      showTOOLtip("ERROR: The image failed to be loaded or does not have a high color depth required for tone mapping.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   updateUIfimBeforeIMG()
   GFT := FreeImage_GetFileType(getIDimage(currentFileIndex))
   imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgE), "-"))
   thisAllow := (isVarEqualTo(GFT, 32, 26, 29) && imgBPP>32) ? 1 : allowToneMappingImg
   If (thisAllow=1)
      hFIFimgE := FreeImage_ToneMapping(globalhFIFimg, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
   Else
      hFIFimgE := FreeImage_Clone(globalhFIFimg)

   If (imgBPP!=32)
      hFIFimgD := FreeImage_ConvertTo(hFIFimgE, "32Bits")

   hFIFimgZ := hFIFimgD ? hFIFimgD : hFIFimgE
   pBitmap := ConvertFIMtoPBITMAP(hFIFimgZ)
   If StrLen(pBitmap)>2
      recordGdipBitmaps(pBitmap, A_ThisFunc)
   Else Return

   tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, coreDesiredPixFmt)
   If !validBMP(tempBMP)
   {
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      trGdip_DisposeImage(tempBMP, 1)
      Return
   }

   trGdip_GetImageDimensions(pBitmap, imgW, imgH)
   calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
   thisX := uiBoxW//2 - thisW//2
   thisY := uiBoxH//2 - thisH//2
   Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
   r1 := trGdip_DrawImage(A_ThisFunc, Gu, pBitmap, thisX, thisY, thisW, thisH)
   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
   SetImage(hCropCornersPic, hBitmap)
   Gdi_DeleteObject(hBitmap)
   trGdip_DisposeImage(tempBMP, 1)
   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(pBitmap, 1)

   FreeImage_UnLoad(hFIFimgE)
   If hFIFimgD
      FreeImage_UnLoad(hFIFimgD)
}

BTNtoneMapRefresh() {
   updateUItoneMappingPanel()
   killQPVscreenImgSection()
   discardViewPortCaches()
   disposeCacheIMGs()
   RefreshImageFileAction()
}

BTNresetToneMap() {
   If (AnyWindowOpen!=42)
      Return

   allowToneMappingImg := 1
   Gui, SettingsGUIA: Default
   GuiControl, SettingsGUIA: Choose, cmrRAWtoneMapAlgo, 1
   GuiControl, SettingsGUIA: , allowToneMappingImg, 1
   UIuserToneMapParamA := 76
   UIuserToneMapParamB := 200
   uiSlidersArray["UIuserToneMapParamA", 14] := 1
   uiSlidersArray["UIuserToneMapParamB", 14] := 1
   Sleep, 1
   updateUItoneMappingPanel()
}

updateUItoneMappingPanel() {
   Static lastInvoked := 1
   If (AnyWindowOpen!=42)
      Return

   If (A_TickCount - lastInvoked<100)
   {
      SetTimer, updateUItoneMappingPanel, -250
      Return
   }

   Gui, SettingsGUIA: Default
   GuiControlGet, cmrRAWtoneMapAlgo
   GuiControlGet, userHQraw
   GuiControlGet, allowToneMappingImg
   prcA := UIuserToneMapParamA/400
   prcB := UIuserToneMapParamB/400
   If (cmrRAWtoneMapAlgo=1)
   {
      cmrRAWtoneMapParamA := 9.9*prcA
      cmrRAWtoneMapParamB := 16*prcB - 8
      uiSlidersArray["UIuserToneMapParamA", 5] := "|Gamma: " Round(cmrRAWtoneMapParamA, 2)
      uiSlidersArray["UIuserToneMapParamB", 5] := "|Exposure: " Round(cmrRAWtoneMapParamB, 2)
      ; uiSlidersArray["UIuserToneMapParamA", 4] := 38
   } Else If (cmrRAWtoneMapAlgo=2)
   {
      cmrRAWtoneMapParamA := 16*prcA - 8
      cmrRAWtoneMapParamB := prcB
      uiSlidersArray["UIuserToneMapParamA", 5] := "|Intensity: " Round(cmrRAWtoneMapParamA, 2)
      uiSlidersArray["UIuserToneMapParamB", 5] := "|Contrast: " Round(cmrRAWtoneMapParamB, 2)
      ; uiSlidersArray["UIuserToneMapParamA", 4] := 100
   } 

   GuiRefreshSliders()
   updateUIfimToneMappedIMG()
   lastInvoked := A_TickCount
   SetTimer, WriteSettingsAdjustToneMapPanel, -350
}

updateUIsettings() {
     If (AnyWindowOpen!=14)
        Return

     Gui, SettingsGUIA: Default
     Gui, SettingsGUIA: Submit, NoHide

     calcHUDsize()
     setLVrowsCount()
     msgDisplayTime := DisplayTimeUser*1000
     SetTimer, WriteSettingsUI, -90
     If !throwErrorNoImageLoaded(1)
        SetTimer, RefreshImageFile, -250
}

WriteSettingsUI() {
  INIaction(1, "ambiTexBrushSize", "General")
  INIaction(1, "borderAroundImage", "General")
  INIaction(1, "DisplayTimeUser", "General")
  INIaction(1, "OSDfontBolded", "General")
  INIaction(1, "OSDfontItalica", "General")
  INIaction(1, "OSDbgrColor", "General")
  INIaction(1, "OSDfontSize", "General")
  INIaction(1, "OSDFontName", "General")
  INIaction(1, "OSDtextColor", "General")
  INIaction(1, "PasteFntSize", "General")
  INIaction(1, "usrTextAlign", "General")
  INIaction(1, "usrTextureBGR", "General")
  INIaction(1, "WindowBgrColor", "General")
  INIaction(1, "additionalLVrows", "General")
}

PrefsCloseBTN() {
   updateUIsettings()
   interfaceThread.ahkFunction("updateWindowColor")
   BtnCloseWindow()
}

InvokeStandardDialogColorPicker(hC, event, c) {
; Function by Drugwash
; Critical MUST be disabled below! If that's not done, script will enter a deadlock !
  Static
  If (event="RightClick")
  {
     g := A_Gui, c := A_GuiControl
     Sleep, 1
     mouseTurnOFFtooltip()
     fn := Func("StartPickingColor").Bind("isGiven", g, c)
     SetTimer, % fn, -100
     ; SetTimer, mouseTurnOFFtooltip, -50
     Return
  } Else If (event!="Normal")
     Return

  g := A_Gui, ctrl := A_GuiControl
  GuiControlGet, clrHwnd, %g%: hwnd, %ctrl%
  pastedClr := 0
  mods := (  GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P") || GetKeyState("Alt", "P") ) ? 1 : 0
  If (mods=1)
  {
     msg2show := "HEX color: " %ctrl% "`nShift + L-click to copy`nAlt+Click to paste"
     If GetKeyState("Shift", "P")
     {
        Try Clipboard := %ctrl%
        Catch wasError
              Sleep, 1

        msg2show := (wasError) ? " Failed to copy the color to clipboard" : "HEX color copied to clipboard: " %ctrl%
     } Else If GetKeyState("Alt", "P")
     {
        Try clr := Trimmer(Clipboard)
        If (clr ~= "[^[:xdigit:]]") || (StrLen(clr)!=6)
           Return

        msg2show := "HEX color pasted: " clr
        pastedClr := 1
     }

     thisSize := (PrefsLargeFonts=1) ? Round(LargeUIfontValue*1.55) : LargeUIfontValue
     mouseCreateOSDinfoLine(msg2show, thisSize)
     If (pastedClr!=1)
        Return
  }

  mods := 0
  oc := A_IsCritical
  Critical, Off
  ; ToolTip, % event , , , 2
  If (pastedClr=1)
     theColor := clr
  Else
     theColor := createStandardColorzDialog(%ctrl%, hC, ctrl)

  Critical, %oc%
  If (theColor="-")
     Return

  r := %ctrl% := theColor
  updateColoredRectCtrl(theColor, ctrl, g, clrHwnd)
  ; GuiControl, %g%:+Buckground%r%, %ctrl%
  If (ctrl="WindowBGRcolor")
     INIaction(1, ctrl, "General")
  Else
     RegAction(1, ctrl)

  If (AnyWindowOpen=64)
  {
     createLivePreviewBrush()
     delayedWriteTlbrColors(1)
     SetTimer, fromCurrentPanelToColorsSwatch, -100
  } Else If (AnyWindowOpen=63)
  {
     updateUIgridPanel()
  } Else If (AnyWindowOpen=14)
  {
     interfaceThread.ahkassign("WindowBGRcolor", WindowBGRcolor)
     interfaceThread.ahkFunction("updateWindowColor")
     updateUIsettings()
     refreshWinBGRbrush()
     dummyTimerDelayiedImageDisplay(50)
  } Else If (imgEditPanelOpened=1)
  {
     SetTimer, fromCurrentPanelToColorsSwatch, -200
     livePreviewsImageEditing()
  }
}

getCustomColorsFromImage(whichBitmap) {
  trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
  calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
  c := []
  c[1] := Gdip_GetPixelColor(whichBitmap, X1, Y1, 3)
  c[2] := Gdip_GetPixelColor(whichBitmap, X2, Y2, 3)
  c[3] := Gdip_GetPixelColor(whichBitmap, X1, Y2, 3)
  c[4] := Gdip_GetPixelColor(whichBitmap, X2, Y1, 3)
  c[5] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1 + imgSelH//2, 3)
  c[6] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1, 3)
  c[7] := Gdip_GetPixelColor(whichBitmap, X1, Y1 + imgSelH//2, 3)
  c[8] := Gdip_GetPixelColor(whichBitmap, X2, Y2 - imgSelH//2, 3)
  c[9] := Gdip_GetPixelColor(whichBitmap, X2 - imgSelW//2, Y2, 3)
  c[10] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//4, Y1 + imgSelH//4, 3)
  c[11] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2 + imgSelW//4, Y1 + imgSelH//2 + imgSelH//4, 3)
  c[12] := Gdip_GetPixelColor(whichBitmap, 1, 1, 3)
  c[13] := Gdip_GetPixelColor(whichBitmap, 1, imgH - 1, 3)
  c[14] := Gdip_GetPixelColor(whichBitmap, imgW - 1, imgH - 1, 3)
  c[15] := Gdip_GetPixelColor(whichBitmap, imgW - 1, 1, 3)
  c[16] := Gdip_GetPixelColor(whichBitmap, imgW//2, imgH//2, 3)
  Return c
}

createStandardColorzDialog(coloru, hwnd, ctrlName) {
  WinSet, Disable,, ahk_id %PVhwnd%
  customColors := getCustomColorsFromImage(useGdiBitmap())
  nc := Dlg_Color(coloru, hwnd, customColors)
  WinSet, Enable,, ahk_id %PVhwnd%
  If (nc="-")
     Return "-"

  theColor := nc ; Gdi_ColorRef2RGB(nc)
  If (isNowAlphaPainting()=1 && InStr(ctrlName, "brushtool"))
     theColor := convertColorToGrayscale(theColor)

  Return theColor
}

OpenUImenu(givenCoords:=0) {
   deleteMenus()
   createMenuInterfaceOptions()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PvUIprefs") : givenCoords
   showThisMenu("PvUIprefs")
}

createTlbrContextMenu() {
    invokeTlbrContextMenu("extern")
}

invokeTlbrContextMenu(givenCoords:=0) {
   If (givenCoords!="extern")
   {
      deleteMenus()
      kMenu("PvUItoolbarMenu", "Add", "S&earch menu options`t;", "PanelQuickSearchMenuOptions", "actions")
      kMenu("PvUItoolbarMenu", "Add/Uncheck", "Show &menu bar`tF10", "ToggleMenuBaru", "toolbar")
      If (showMainMenuBar=1)
         kMenu("PvUItoolbarMenu", "Check", "Show &menu bar`tF10")
   }

   If (userCustomizedToolbar!=1)
   {
      kMenu("PvUItoolbarMenu", "Add/Uncheck", "&Viewer mode toolbar", "ToggleToolBarViewModa", "advanced")
      If (toolbarViewerMode=1)
         kMenu("PvUItoolbarMenu", "Check", "&Viewer mode toolbar")
   }

   k := (ShowAdvToolbar=1) ? "Hide" : "Show"
   If (givenCoords!="extern")
      kMenu("PvUItoolbarMenu", "Add", k " toolbar`tShift+F10", "toggleAppToolbar")

   Menu, PvUItoolbarMenu, Add
   kMenu("PvUItoolbarMenu", "Add/Uncheck", "Show toolbar tooltips", "ToggleToolBarToolTips")
   If (ShowToolTipsToolbar=1)
      kMenu("PvUItoolbarMenu", "Check", "Show toolbar tooltips")

   kMenu("PvUItoolbarMenu", "Add/Uncheck", "&Vertical toolbar", "ToggleToolBarValign")
   If (TLBRverticalAlign=1 || TLBRtwoColumns=1)
      kMenu("PvUItoolbarMenu", "Check", "&Vertical toolbar")

   kMenu("PvUItoolbarMenu", "Add/Uncheck", "&Two columns vertical", "toggleToolbarTwoColumns",, " (toolbar)")
   If (TLBRtwoColumns=1)
      kMenu("PvUItoolbarMenu", "Check", "&Two columns vertical",,, " (toolbar)")

   kMenu("PvUItoolbarMenu", "Add/Uncheck", "Attach to main &window", "ToggleToolbarLockPositionWin",, " (toolbar)")
   If (lockToolbar2Win=1)
      kMenu("PvUItoolbarMenu", "Check", "Attach to main &window",,, " (toolbar)")
   If (lockToolbar2Win=1)
      kMenu("PvUItoolbarMenu", "Add", "&Reset position", "MenuTlbrResetPosition",, " for toolbar")

   If (ShowAdvToolbar=1)
   {
      kMenu("PvUItoolbarMenu", "Add", "Customi&ze toolbar", "PanelCustomizeToolbar")
      If ((thumbsDisplaying=1 && maxFilesIndex>1 || isImgEditingNow()=1) && !AnyWindowOpen && drawingShapeNow!=1)
      {
         kMenu("PvUItoolbarMenu", "Add/Uncheck", "Use customi&zed toolbar", "toggleCustomaToolbara")
         If (userCustomizedToolbar=1)
            kMenu("PvUItoolbarMenu", "Check", "Use customi&zed toolbar")
      } Else kMenu("PvUItoolbarMenu", "Disable", "Customi&ze toolbar")

      If (mustPreventMenus!=1)
      {
         Menu, PvUItoolbarMenu, Add
         kMenu("PvUItoolbarMenu", "Add", "Scale: " Round(ToolbarScaleFactor, 2) "x", "dummy")
         kMenu("PvUItoolbarMenu", "Disable", "Scale: " Round(ToolbarScaleFactor, 2) "x", "dummy")
         kMenu("PvUItoolbarMenu", "Add", "0.50x", "SetToolbarScaling")
         kMenu("PvUItoolbarMenu", "Add", "0.75x", "SetToolbarScaling")
         kMenu("PvUItoolbarMenu", "Add", "1.00x", "SetToolbarScaling")
         kMenu("PvUItoolbarMenu", "Add", "1.25x", "SetToolbarScaling")
         kMenu("PvUItoolbarMenu", "Add", "1.50x", "SetToolbarScaling")
         kMenu("PvUItoolbarMenu", "Add", "2.00x", "SetToolbarScaling")
         kMenu("PvUItoolbarMenu", "Add", "3.00x", "SetToolbarScaling")
      }
   }

   If (givenCoords!="extern")
   {
      Menu, PvUItoolbarMenu, Add
      kMenu("PvUItoolbarMenu", "Add", "Help", "btnHelpToolbar")
      globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PvUItoolbarMenu") : givenCoords
      showThisMenu("PvUItoolbarMenu")
   }
}

SetToolbarScaling(a, b, c) {
   ToolbarScaleFactor := StrReplace(a, "x")
   IniAction(1, "ToolbarScaleFactor", "General")
   createGUItoolbar()
}

InvokeOpenRecentMenu(givenCoords:=0) {
   If (givenCoords="tlbr" && AnyWindowOpen)
      Return

   deleteMenus()
   createMenuOpenRecents()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVopenF") : givenCoords
   showThisMenu("PVopenF")
}

PanelDefineEntireSlideshowLength() {
    Global userHourDur, userMinDur, userSecDur, infoLine, userDefinedSpeedSlideshow
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (maxFilesIndex<3)
       Return

    thisBtnHeight := createSettingsGUI(19, A_ThisFunc)
    btnWid := 130
    txtWid := 350
    EditWid := 35
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 2
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    infoSliSpeed := DefineSlidesRate()
    etaTime := EstimateSlideShowLength()
    infou := groupDigits(maxFilesIndex)
    Gui, Add, Text, x15 y15 Section w%txtWid%, Define the total time of the slideshow`nfor %infou% images.
    Gui, Add, Text, y+15 w85, Hours:
    GuiAddEdit("x+5 wp gUpdateSlideshowPanel r1 limit9 Number -multi -wantTab -wrap vuserHourDur", Round(Hrs))
    Gui, Add, Checkbox, x+5 hp Checked%doSlidesTransitions% vdoSlidesTransitions gUpdateSlideshowPanel, &Smooth slide transitions
    Gui, Add, Text, xs y+5 w85, Minutes:
    GuiAddEdit("x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserMinDur", Round(Min))
    Gui, Add, Text, xs y+5 wp, Seconds:
    GuiAddEdit("x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserSecDur", Round(Sec))
    Gui, Add, Text, xs y+5 wp +0x200 +hwndhTemp, Speed:
    GuiAddDropDownList("x+5 wp gChooseSlideSpeed AltSubmit vuserDefinedSpeedSlideshow", "-||30 FPS|15 FPS|7 FPS|2 FPS|1 sec.|2 sec.|4 sec.|8 sec.|16 sec.", [hTemp])
    Gui, Add, Button, x+5 hp w75 gTimeLapseInfoBox, Infos
    thisW := (PrefsLargeFonts=1) ? 105 : 80
    Gui, Add, Button, x+5 hp w%thisW% gSetTimeLapseMode, Timelapse
    Gui, Add, Text, xs y+5 w85 +0x200 +hwndhTemp, Mode:
    GuiAddDropDownList("x+5 wp gUpdateSlideshowPanel AltSubmit Choose" SlideHowMode " vSlideHowMode", "Random|Backwards|Forwards", [hTemp])
    Gui, Add, Checkbox, x+5 hp Checked%allowGIFsPlayEntirely% vallowGIFsPlayEntirely gUpdateSlideshowPanel, &Allow GIFs play entirely

    Gui, Add, Text, xs y+15 w%txtWid% vinfoLine, One image every: %infoSliSpeed%`nEstimated slideshow duration: %etaTime%
    ; Gui, Add, Text, xp+15 y+7 wp-20, - based on current file index position, direction and previous image load time;

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gStartSlideINtotalTimeBTNaction, &Start slideshow
    Gui, Add, Button, x+5 hp w90 gResetSlideSpeed, De&fault
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Define total slideshow time: " appTitle)
}

TimeLapseInfoBox() {
    msgBoxWrapper(appTitle ": HELP", "The estimated slideshow duration displayed in the panel includes the time estimated to load each image. Based on previously loaded images, it takes about " groupDigits(drawModeCzeit) " miliseconds to load an image.`n `nIf the option to allow GIFs play entirely during slideshows is selected, the duration of the slideshow will be influenced by how many GIFs are indexed and how long they are.`n `nFor optimal timelapses [or very fast slideshows] set zoom at 100`%, disable image rotation and color adjustments and «skip already seen images».", -1, 0, 0)
}

SetTimeLapseMode() {
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to set slideshow mode to timelapse? This will set zoom level to 100% and disable any image effect or adjustment.`n`nThe slideshow speed will be set at ~30 FPS [33 images/sec.].", 4, 0, "question")
    If (msgResult="Yes")
    {
       IMGresizingMode := 4
       customZoomAdaptMode := 0
       interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
       mustRecordSeenImgs := 0
       imgFxMode := usrColorDepth := zoomLevel := 1
       vpIMGrotation := FlipImgH := FlipImgV := 0
       coreResetSlideSpeed(33, 1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 2
       dummyTimerDelayiedImageDisplay(50)
    }
}

ResetSlideSpeed() {
    coreResetSlideSpeed(4000, 1)
    GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 8
}

ChooseSlideSpeed() {
    GuiControlGet, userDefinedSpeedSlideshow
    If (userDefinedSpeedSlideshow=2)
       coreResetSlideSpeed(33, 1)
    Else If (userDefinedSpeedSlideshow=3)
       coreResetSlideSpeed(67, 1)
    Else If (userDefinedSpeedSlideshow=4)
       coreResetSlideSpeed(143, 1)
    Else If (userDefinedSpeedSlideshow=5)
       coreResetSlideSpeed(500, 1)
    Else If (userDefinedSpeedSlideshow=6)
       coreResetSlideSpeed(1000, 1)
    Else If (userDefinedSpeedSlideshow=7)
       coreResetSlideSpeed(2000, 1)
    Else If (userDefinedSpeedSlideshow=8)
       coreResetSlideSpeed(4000, 1)
    Else If (userDefinedSpeedSlideshow=9)
       coreResetSlideSpeed(8000, 1)
    Else If (userDefinedSpeedSlideshow=10)
       coreResetSlideSpeed(16000, 1)
}

coreResetSlideSpeed(varu, noDDLjump:=0) {
    slideShowDelay := varu
    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    GuiControl, SettingsGUIA:, userHourDur, % Round(Hrs)
    GuiControl, SettingsGUIA:, userMinDur, % Round(Min)
    GuiControl, SettingsGUIA:, userSecDur, % Round(Sec)
    If (noDDLjump!=1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    DefineSlidesTotalTimeBTNaction()
}

DefineSlidesRate() {
   slidesDuration := slideShowDelay
   ; slidesDuration := (slideShowDelay<drawModeCzeit) ? Round((drawModeCzeit*0.7+slideShowDelay)//2) : slideShowDelay
  ; If (slidesDuration<1995 && slidesDuration!=1000)
  ;    miliSec := slidesDuration " milisec."
   ; Else
      duration := SecToHHMMSS(Round(slidesDuration/1000, 3))
   Return miliSec ? miliSec : duration
}

StartSlideINtotalTimeBTNaction() {
   DefineSlidesTotalTimeBTNaction()
   BtnCloseWindow()
   Sleep, 300
   delayu := (thumbsDisplaying=1) ? 400 : 25
   lastOtherWinClose := 1
   If (thumbsDisplaying=1)
      ToggleThumbsMode()
   Settimer, dummyInfoToggleSlideShowu, % -delayu
}

UpdateSlideshowPanel() {
    Static lastInvoked := 1
    If (AnyWindowOpen!=19)
       Return

    Gui, SettingsGUIA: Default
    DefineSlidesTotalTimeBTNaction()
    GuiControlGet, doSlidesTransitions
    GuiControlGet, allowGIFsPlayEntirely
    GuiControlGet, WhatsFocused, SettingsGUIA: FocusV
    GuiControlGet, WhatsFocused, SettingsGUIA: FocusV
    actu := (slideShowDelay<900) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
    GuiControl, % actu, doSlidesTransitions

    INIaction(1, "doSlidesTransitions", "General")
    INIaction(1, "allowGIFsPlayEntirely", "General")
    If (WhatsFocused="userHourDur" || WhatsFocused="userMinDur" || WhatsFocused="userSecDur")
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    lastInvoked := A_TickCount
}

DefineSlidesTotalTimeBTNaction() {
    If (AnyWindowOpen!=19)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, SlideHowMode
    GuiControlGet, userHourDur
    GuiControlGet, userMinDur
    GuiControlGet, userSecDur
    slideShowDelay := 0    
    slideShowDelay += userSecDur*1000
    slideShowDelay += (userMinDur*60)*1000
    slideShowDelay += ((userHourDur*60)*60)*1000
    slideShowDelay := Round(slideShowDelay/maxFilesIndex)
    If (slideShowDelay<16)
       slideShowDelay := 16

    etaTime := EstimateSlideShowLength(0, 1)
    infoSliSpeed := DefineSlidesRate()
    IniAction(1, "SlideHowMode", "General")
    GuiControl, SettingsGUIA:, InfoLine, One image every: %approxMarker%%infoSliSpeed%`nEstimated slideshow duration: %approxMarker%%etaTime%
}

EstimateSlideShowLength(noPrecision:=0, totalu:=0) {
    slidesDuration := (slideShowDelay<drawModeCzeit) ? (drawModeCzeit + slideShowDelay)/2 : drawModeCzeit*0.9 + slideShowDelay
    ; slidesDuration := (slideShowDelay<drawModeCzeit) ? drawModeCzeit : slideShowDelay
    approxMarker := (slideShowDelay<drawModeCzeit) ? "~" : ""
    If (totalu=1)
       infoFilesSel := maxFilesIndex
    Else If (SlideHowMode=1)
       infoFilesSel := maxFilesIndex - RandyIMGnow
    Else If (SlideHowMode=2)
       infoFilesSel := currentFileIndex
    Else If (SlideHowMode=3)
       infoFilesSel := maxFilesIndex - currentFileIndex
    Else
       infoFilesSel := (maxFilesIndex>0) ? maxFilesIndex : 1
    slidesDuration := Round(slidesDuration/1000, 3) * infoFilesSel
    ; MsgBox, % etaTime "--" slidesDuration "--" slideShowDelay "--" drawModeCzeit "--" maxFilesIndex
    etaTime := approxMarker SecToHHMMSS(slidesDuration)
    If (noPrecision=1)
       etaTime := RegExReplace(etaTime, "\...s", "s")
    Return etaTime
}

jumpPreviousImage() {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    okayu := (thumbsDisplaying=1 || undoLevelsRecorded<2) ? 1 : 0
    If !okayu
       Return

    If askAboutFileSave(" and another image will be loaded")
       Return

    currentFileIndex := clampInRange(prevLastImg[2, 1], 1, maxFilesIndex)
    dummyTimerDelayiedImageDisplay(50)
}

PanelJump2index() {
   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex<2)
   {
      showTOOLtip("WARNING: Insufficient indexed files to open panel")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (RandyIMGnow=-1 || !RandyIMGids.Count())
      coreGenerateRandomList()

   imgPath := getIDimage(currentFileIndex)
   isAnim := (RegExMatch(imgPath, "i)(.\.(gif))$") && totalFramesIndex>1) ? "`fSkip to given frame index" : ""
   fakeWinCreator(13, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Skip to given index: " appTitle, "Please type a number to skip at in the files list`nand choose the action.`n`nTotal entries: " groupDigits(maxFilesIndex) "`nCurrent random index: " groupDigits(RandyIMGnow), "&Skip to...|C&ancel", 1, "fast-forward", 0, 0, "Skip to the given file index`f`fSkip to the given index in the random list`fSelect from the current file index to the given index" isAnim, "limit9050 +number", currentFileIndex, 2)
   If InStr(msgResult.btn, "skip")
   {
      usrJumpIndex := Trimmer(msgResult.edit)
      If !usrJumpIndex
         Return

      newJumpIndex := clampInRange(usrJumpIndex, 1, maxFilesIndex)
      If (newJumpIndex=currentFileIndex && newJumpIndex>0 && msgResult.list!=4)
         Return

      If askAboutFileSave(" and another image will be loaded")
         Return

      If (IsNumber(newJumpIndex) && newJumpIndex>=1)
      {
         If (msgResult.list=4)
         {
            desiredFrameIndex := clampInRange(usrJumpIndex, 1, totalFramesIndex)
            RefreshImageFile()
            Return
         } Else If (msgResult.list=2)
         {
            RandyIMGnow := newJumpIndex
            currentFileIndex := clampInRange(RandyIMGids[newJumpIndex], 1, maxFilesIndex)
            ; ToolTip, % RandyIMGids "==" newJumpIndex "==" currentFileIndex , , , 2
            RefreshImageFile()
            Return
         } Else If (msgResult.list=3)
            jumpSelectRangeGiven(currentFileIndex, newJumpIndex)

         currentFileIndex := newJumpIndex
         dummyTimerDelayiedImageDisplay(50)
      }
   }
}

saveHugeVPimageFile(imgPath, file2save, hFIFimgA, depth) {
   If (viewportQPVimage.LoadedWith!="fim")
      Return "err-no-fim"

   If (usrColorDepth>1 || imgFxMode>1)
   {
      msgResult := msgBoxWrapper(appTitle ": WARNING", "In the viewport, the image seems to be displayed with color adjustments. QPV cannot apply these on the image itself, because of the very large size. The image will be saved with its original colors.`n`nGo to Image > Filters > Adjust image colors, to apply color filters on huge images.``n`nDo you want to continue?", "&Yes|&No", 2, "exclamation")
      If (msgResult!="Yes")
         Return "user-abort"
   }

   typu := FreeImage_GetFileType(file2save, 1)
   If (isVarEqualTo(typu, "j2k","jp2","targa","bmp","jxr","tiff","png","ico","webp") && depth>0)
   {
      objDepth := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
      If (depth=32 && objDepth!=32)
         hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "32Bits")
      Else If (depth=24 && objDepth!=24)
         hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")
      Else If (depth=16 && objDepth!=16)
         hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "16Bits")
      Else If (depth=8 && objDepth!=8)
         hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "8Bits")
   }

   If hFIFimgB
   {
      If (FlipImgH=1)
         FreeImage_FlipHorizontal(hFIFimgB)
      If (FlipImgV=1)
         FreeImage_FlipVertical(hFIFimgB)

      r := coreConvertImgFormat(imgPath, file2save, hFIFimgB)
      ; hFIFimgB disposed by coreConvertImgFormat()
      Return r
   } Else
   {
      If (FlipImgH=1)
      {
         FreeImage_FlipHorizontal(hFIFimgA)
         FlipImgH := 0
      }

      If (FlipImgV=1)
      {
         FreeImage_FlipVertical(hFIFimgA)
         FlipImgV := 0
      }
      Static redMASK   := "0x00FF0000" ; FI_RGBA_RED_MASK;
           , greenMASK := "0x0000FF00" ; FI_RGBA_GREEN_MASK;
           , blueMASK  := "0x000000FF" ; FI_RGBA_BLUE_MASK;

      FreeImage_GetImageDimensions(hFIFimgA, ImgW, ImgH)
      bpp := FreeImage_GetBPP(hFIFimgA)
      Stride := (bpp * imgW) / 8 ; (bitsDepth=32) ? imgW * 4 : imgW * 3
      doFlip := (viewportQPVimage.FimBuffer!="") ? 1 : 0
      bufferu := (viewportQPVimage.FimBuffer!="") ? viewportQPVimage.FimBuffer : FreeImage_GetBits(hFIFimgA)
      hFIFimgB := FreeImage_CreateView(hFIFimgA, 0, 0, imgW, imgH)
      If !hFIFimgB
         hFIFimgB := FreeImage_ConvertFromRawBitsEx(0, bufferu, 1, imgW, imgH, Stride, bpp, redMASK, greenMASK, blueMASK, doFlip)
      If !hFIFimgB
         Return "err-no-fim-create-view"
      r := coreConvertImgFormat(imgPath, file2save, hFIFimgB)
      ; hFIFimgB disposed by coreConvertImgFormat()
      killQPVscreenImgSection()
      Return r
   }
}

SaveClipboardImage(dummy:=0, noDialog:=0) {
   Static lastInvoked := 1, dephtus := {1:32, 2:24, 3:16, 4:8, 5:0}

   If throwErrorNoImageLoaded()
      Return

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   initFIMGmodule()
   RegAction(0, "userDesireWriteFMT",, 2, 1, 16)
   INIaction(0, "prevFileSavePath", "General", 6)
   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
   defaultu := (dummy="current") ? OutDir "\" OutNameNoExt : prevFileSavePath "\" OutNameNoExt
   If !defaultu
      defaultu := prevFileSavePath "\" OutNameNoExt
   If FolderExist(dummy)
      defaultu := dummy "\" OutNameNoExt

   getSaveDialogIndexForFile(imgPath, defFMTindex)
   If (noDialog=1)
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "PathMustExist", defaultu, "Save image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)

   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
      {
         nExt := dialogSaveIndexes[dialogFmtIndex]
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]
      }

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      huge := (viewportQPVimage.imgHandle) ? 1 : 0
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      If (isImgSizeTooLarge(imgW, imgH, nExt, 0) && nExt="webp")
      {
         SoundBeep, 300, 100
         mgpx := Round((ImgW * ImgH)/1000000, 1)
         thisLimit := "The limit is 16350 px in width or height and 267.2 megapixels."
         msgBoxWrapper(appTitle ": ERROR", "The image dimensions exceed the accepted limits of the file format selected: .WEBP. To preserve its dimensions choose another file format, eg., JPG, PNG or TIFF. " thisLimit "`n`nImage dimensions: " imgW " x " imgH " px (" mgpx " MPx).", 0, 0, "error")
         Return
      } Else If (isImgSizeTooLarge(imgW, imgH, nExt, !huge) && isVarEqualTo(nExt, "jng", "jpg", "jpeg", "jfif", "gif", "tga"))
      {
         SoundBeep, 300, 100
         mgpx := Round((ImgW * ImgH)/1000000, 1)
         thisLimit := "The limit is 65530 px in width or height and 4294 megapixels."
         msgBoxWrapper(appTitle ": ERROR", "The image dimensions exceed the accepted limits of the file format selected: ." Format("{:U}", nExt) ". Please resize the image or choose another file format, eg., PNG or TIFF. " thisLimit "`n`nImage dimensions: " imgW " x " imgH " px (" mgpx " MPx).", 0, 0, "error")
         Return
      } Else If (isImgSizeTooLarge(imgW, imgH, nExt, !huge) && isVarEqualTo(nExt, "jp2", "j2k"))
      {
         SoundBeep, 300, 100
         mgpx := Round((ImgW * ImgH)/1000000, 1)
         thisLimit := "The limit is 32760 px in width or height and 1073 megapixels."
         msgBoxWrapper(appTitle ": ERROR", "The image dimensions exceed the accepted limits of the file format selected: .JP2. Please resize the image or choose another file format, eg., PNG or TIFF. " thisLimit "`n`nImage dimensions: " imgW " x " imgH " px (" mgpx " MPx).", 0, 0, "error")
         Return
      }

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      alphau := 0
      If (viewportQPVimage.imgHandle)
         alphau := InStr(FreeImage_GetColorType(viewportQPVimage.imgHandle), "rgba") ? 1 : 0
      Else If alertReduceSaveColorDepth()
         Return

      If (!RegExMatch(file2save, saveAlphaTypesRegEX) && (userSaveBitsDepth=1 || userSaveBitsDepth=1 && alphau=1))
      {
         msgResult := msgBoxWrapper(appTitle ": WARNING", "The selected image format does not have support for alpha channel. The image may look different after saving it in this format. Do you want to continue?", "&Yes|&No", 2, "exclamation")
         If (msgResult!="Yes")
            Return
      }

      If (FileExist(file2save) && imgPath!=file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      If FileExist(imgPath)
      {
         FileGetTime, originalMtime, % imgPath, M
         FileGetTime, originalCtime, % imgPath, C
         Sleep, 1
         FileSetAttrib, -R, % file2save
      }

      ForceRefreshNowThumbsList()
      If (AnyWindowOpen=35)
         BtnCloseWindow()

      lastInvoked := A_TickCount
      prevFileSavePath := OutDir
      fdp := dephtus[userSaveBitsDepth] ? dephtus[userSaveBitsDepth] : "ORIGINAL"
      showTOOLtip("Saving image, please wait`n" OutFileName "`nIntended color format: " fdp " bits")
      INIaction(1, "prevFileSavePath", "General")
      huge := (viewportQPVimage.imgHandle) ? 1 : 0
      If (huge=2)
         newBitmap := zBitmap
      Else If (huge=1)
         r := saveHugeVPimageFile(viewportQPVimage.ImgFile, file2save, viewportQPVimage.imgHandle, dephtus[userSaveBitsDepth])
      Else
         newBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap())))

      If (validBMP(newBitmap) && huge!=1)
      {
         If (nExt="ico")
         {
            icoSize := 256
            trGdip_GetImageDimensions(newBitmap, imgW, imgH)
            kBitmap := trGdip_CreateBitmap(A_ThisFunc, icoSize, icoSize)
            If validBMP(kBitmap)
            {
               Gup := Gdip_GraphicsFromImage(kBitmap)
               Gdip_SetPixelOffsetMode(Gup, 2)
               capIMGdimensionsFormatlimits("ico", 1, imgW, imgH)
               xpos := clampInRange((icoSize - imgW)//2, 0, icoSize//2)
               ypos := clampInRange((icoSize - imgH)//2, 0, icoSize//2)
               er := tzGdip_DrawImage(Gup, newBitmap, xpos, ypos, imgW, imgH)
               Gdip_DeleteGraphics(Gup)
               If !er
               {
                  trGdip_DisposeImage(newBitmap, 1)
                  newBitmap := kBitmap
               } Else
                  trGdip_DisposeImage(kBitmap, 1)
            }
         }

         changeMcursor()
         destroyGDIfileCache(1, 1)
         r := QPV_SaveImageFile(A_ThisFunc, newBitmap, file2save, userJpegQuality, userSaveBitsDepth)
         trGdip_DisposeImage(newBitmap, 1)
      } Else If (huge!=1)
      {
         r := "err-no-main-bmp"
      }

      If (PreserveDateTimeOnSave=1 && !r && originalMtime && imgPath=file2save)
      {
         resultedFilesList[currentFileIndex, 4] := 1
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
      }

      If r
      {
         sOutDir := PathCompact(OutDir, "a", 1, OSDfontSize)
         showTOOLtip("Failed to save image file`n" OutFileName "`n" sOutDir "\")
         msgBoxWrapper(appTitle ": ERROR", appTitle " was unable to save the image file due to an undetermined cause.`n`n" OutFileName "`n" OutDir "\`nError code: " r, 0, 0, "error")
      } Else
      {
         FileGetSize, OutputVar, % OutDir "\" OutFileName
         If (OutputVar>2)
            friendly := "`nFile size: " fileSizeFriendly(OutputVar)

         sOutDir := PathCompact(OutDir, "a", 1, OSDfontSize)
         showTOOLtip("Image file succesfully saved`n" OutFileName "`n" sOutDir "\" friendly)
         testMem := getIDimage(currentFileIndex)
         lastZeitIMGsaved := [A_Now, currentUndoLevel, undoLevelsRecorded, OutFileName, OutDir, currentFileIndex]
         If (currentFileIndex=0 && maxFilesIndex<1) || (InStr(testMem, "\temporary memory object\") && maxFilesIndex<1)
         {
            currentFileIndex := maxFilesIndex := 1
            resultedFilesList[1, 1] := file2save
            DynamicFoldersList := OutDir "`n"
            prevOpenFolderPath := OutDir
            CurrentSLD := "|" OutDir
            SLDtypeLoaded := 1
         } Else If (imgPath=file2save)
            resultedFilesList[currentFileIndex, 1] := file2save

         If (SLDtypeLoaded=3)
            selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

         imgIndexEditing := currentFileIndex
         currentImgModified := 2
      }

      SoundBeep, % r ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -50
   }
}

BtnCpyMvChooseFilesDest() {
   SelectedDir := openFoldersDialogWrapper(prevFileMovePath)
   SelectedDir := Trimmer(SelectedDir)
   If FolderExist(SelectedDir)
      GuiControl, SettingsGUIA:, UsrEditFileDestination, % SelectedDir
   Else
      WinActivate, ahk_id %hSetWinGui%
}

BtnCpyMvStrctrdChooseFilesDst() {
   GuiControlGet, UsrEditFileSource
   GuiControlGet, UsrEditFileDestination
   UsrEditFileSource := Trimmer(UsrEditFileSource)
   UsrEditFileSource := Trimmer(UsrEditFileSource, "\")
   UsrEditFileDestination := Trimmer(UsrEditFileDestination)
   UsrEditFileDestination := Trimmer(UsrEditFileDestination, "\")

   p := FolderExist(UsrEditFileDestination) ? UsrEditFileDestination : UsrEditFileSource
   If !FolderExist(p)
      p := FolderExist(prevFileMovePath) ? prevFileMovePath : prevOpenFolderPath

   SelectedDir := openFoldersDialogWrapper(p)
   SelectedDir := Trimmer(SelectedDir)
   If FolderExist(SelectedDir)
      GuiControl, SettingsGUIA:, UsrEditFileDestination, % SelectedDir
   Else
      WinActivate, ahk_id %hSetWinGui%
}

BtnCpyMvStrctrdChooseFilesSrc() {
   GuiControlGet, UsrEditFileSource
   GuiControlGet, UsrEditFileDestination
   UsrEditFileSource := Trimmer(UsrEditFileSource)
   UsrEditFileSource := Trimmer(UsrEditFileSource, "\")
   UsrEditFileDestination := Trimmer(UsrEditFileDestination)
   UsrEditFileDestination := Trimmer(UsrEditFileDestination, "\")

   p := FolderExist(UsrEditFileSource) ? UsrEditFileSource : UsrEditFileDestination
   If !FolderExist(p)
      p := FolderExist(prevFileMovePath) ? prevFileMovePath : prevOpenFolderPath

   SelectedDir := openFoldersDialogWrapper(p)
   SelectedDir := Trimmer(SelectedDir)
   If FolderExist(SelectedDir)
      GuiControl, SettingsGUIA:, UsrEditFileSource, % SelectedDir
   Else
      WinActivate, ahk_id %hSetWinGui%
}

zPlitPath(inputu, fastMode, ByRef fileNamu, ByRef folderu, ByRef fileNamuNoEXT:=0, ByRef fileEXT:=0) {
    If (fastMode=0)
    {
       inputu := Trimmer(StrReplace(inputu, "|"))
       FileGetAttrib, OutputAttribs, %inputu%
    } Else StringRight, OutputVar, inputu, 1

    If InStr(OutputAttribs, "D") || (OutputVar="\")
    {
       ; fnOutputDebug("hmm = " OutputVar "||" OutputAttribs)
       ; SoundBeep , 300, 100
       folderu := inputu
       fileEXT := fileNamuNoEXT := fileNamu := ""
       fileParentFolder := SubStr(folderu, 1, InStr(folderu, "\", 0, -1) - 1)
    } Else
    {
       lineArr := StrSplit(inputu, "\")
       maxuIndex := lineArr.Count()
       fileNamu := lineArr[maxuIndex]
       fileParentFolder := lineArr[maxuIndex - 1]
       ; folderu := SubStr(inputu, 1, StrLen(inputu) - StrLen(fileNamu) - 1)
       ; fileEXTpos := RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
       fileEXTpos := InStr(fileNamu, ".", 0, -1) ; RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
       If fileEXTpos
          fileEXT := Trimmer(SubStr(fileNamu, fileEXTpos + 1))

       If (fileExt="")
       {
          fileNamu := fileEXTpos := ""
          folderu := Trim(Trimmer(inputu), "\")
       } Else
       {
          folderu := ""
          Loop, % maxuIndex - 1
          {
             If (lineArr[A_Index]!="")
                folderu .= lineArr[A_Index] "\"
          }
          folderu := Trim(folderu, "\")
       }

       ; fnOutputDebug("goop=" fileEXTpos "|" fileEXT "|" fileNamu)
       ; fileNamuNoEXT := fileEXTpos ? RegExReplace(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$") : fileNamu
       fileNamuNoEXT := (fileEXTpos!="") ? SubStr(fileNamu, 1, fileEXTpos - 1) : fileNamu
    }
    Return fileParentFolder
}

StringToASC(string) {
   Static lastInvoked, lastAsc
   If (String="")
      Return

   If (string=lastInvoked)
      Return lastAsc

   ; AscString := StrLen(string)
   Loop, Parse, string 
      AscString .= RegExMatch(A_LoopField, "[[:alnum:]]") ? A_LoopField : Ord(A_LoopField)

   ; ToolTip, % AscString , , , 2 
   lastInvoked := string
   lastAsc := AscString
   Return AscString
}

readRecentFileDesties(modus:=0) {
   listu := ""
   If (modus!=1)
   {
      If FolderExist(prevFileMovePath)
         listu .= prevFileMovePath "`n"
      If FolderExist(prevFileSavePath)
         listu .= prevFileSavePath "`n"
      If FolderExist(prevOpenFolderPath)
         listu .= prevOpenFolderPath "`n"
   }

   Loop, 15
   {
       IniRead, newEntry, % mainRecentsFile, RecentFDestinations, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (FolderExist(newEntry) && !InStr(listu, newEntry "`n"))
          listu .= newEntry "`n"
   }
   Return listu
}

PanelMoveCopyFiles() {
   UsrCopyMoveOperation := 2
   CopyMovePanelWindow()
}

InvokeCopyFiles() {
   UsrCopyMoveOperation := 3
   If (maxFilesIndex>0)
      CopyMovePanelWindow()
}

CopyMovePanelWindow() {
    Global BtnCpyMv, LViewDynas, lastInvoked := 1
    ; Static prevmainDynaFoldersListu, prevCurrentSLD

    openingPanelNow := 1
    thisBtnHeight := createSettingsGUI(9, A_ThisFunc)
    sml := (PrefsLargeFonts=1) ? 90 : 72
    btnWid := 125
    btnWid2 := 60
    txtWid := 360
    EditWid := 385
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       btnWid2 += 60
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    EditWid -= sml
    lstWid := sml + editWid

    ToolTip, Please wait...,,, 2
    listu := readRecentFileDesties()
    listu .= "--={ other destinations }=--`n"
    setImageLoading()
    historyList := readRecentEntries()
    Loop, Parse, historyList, `n
    {
       If (A_Index>10)
          Break 

       If StrLen(A_LoopField<4)
          Continue 

       changeMcursor()
       OutDir := StrReplace(A_LoopField, "|")
       If InStr(listu, OutDir "`n") || !FolderExist(OutDir)
          Continue

       listu .= OutDir "`n"
    } 

    thisDynaList := getDynamicFoldersList()
    ; DynamicFoldersList := mainDynaFoldersListu
    prevCurrentSLD := CurrentSLD
    lastInvoked := A_TickCount
    Loop, Parse, thisDynaList, `n
    {
        If (A_Index>15)
           Break

        If StrLen(A_LoopField)<4
           Continue

        changeMcursor()
        folderu := StrReplace(A_LoopField, "|")
        If InStr(listu, folderu "`n") || !FolderExist(folderu)
           Continue

        listu .= folderu "`n"
    }

    List_MakeUnique(listu, "`n", 0, 0)
    Loop, Parse, listu, `n
    {
        If !A_LoopField
           Continue

        changeMcursor()
        ; indexu := InStr(A_LoopField, "{ other dest") ? "" : A_Index - 1 "; "
        finalListu .= A_LoopField "`n"
        If (A_Index=1)
           finalListu .= "`n"
    }

    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       finalListu .= "[group-by-month-year]`n[group-by-years]`n[group-by-file-types]"
       infoSelection := "Selected files: " groupDigits(markedSelectFile) ". "
    }

    Gui, +Delimiter`n
    sml := (PrefsLargeFonts=1) ? 90 : 72
    Gui, Add, Text, x15 y15 Section, Destination folder:
    GuiAddEdit("xs y+5 w" EditWid " gUIeditsGenericAllowCtrlBksp vUsrEditFileDestination r1 -wrap -multi -WantReturn", prevFileMovePath)
    Gui, Add, Button, x+1 w%sml% hp gBtnCpyMvChooseFilesDest, &Browse
    hLVmainu := GuiAddListView("xs y+5 w" lstWid " gBTNlvRecentFileDesties -multi r10 Grid AltSubmit vLViewDynas", "Recent destination folders`n#", "Recent destination folders")
    thisW := (PrefsLargeFonts=1) ? 190 : 120
    Gui, Add, Text, xs y+5 +hwndhTempu +0x200 +BackgroundTrans, On file name conflicts:
    zh := GuiAddDropDownList("x+10 w" thisW " AltSubmit Choose" copyMoveDoLastOption " vcopyMoveDoLastOption", "Skip files`nAuto-rename`nOverwrite`nAsk user", [hTempu])
    Gui, Add, Button, x+5 hp wp-25 gEraseCopyMoveHisto, Erase &history

    Loop, Parse, finalListu, `n
    {
       If StrLen(A_LoopField)>2
          LV_Add(A_Index, A_LoopField, A_Index)
    }

    Loop, 3
        LV_ModifyCol(A_Index, "AutoHdr Left")

    ToolTip,,,,2
    SetTimer, ResetImgLoadStatus, -50
    btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
    Gui, Add, Text, xs y+5 +hwndhTemp +0x200 +BackgroundTrans, Action to perform:
    GuiAddDropDownList("x+10 w" thisW " gchangeCopyMoveAction AltSubmit Choose" UsrCopyMoveOperation " vUsrCopyMoveOperation", "Choose...`nMove file(s)`nCopy file(s)", [hTemp, hTempu, zh])
    If infoSelection
       Gui, Add, Text, xs y+5 hp +0x200 +BackgroundTrans, % infoSelection

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBtnCopyMoveAction vBtnCpyMv, &Proceed
    Gui, Add, Button, x+5 hp wp+85 gBtnMarkFilesExplorer, &Mark file(s) (Explorer)
    Gui, Add, Button, x+5 hp w70 gBtnHelpCopyMovePanel, Hel&p
    Gui, Add, Button, x+5 hp wp+10 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, btnName " file(s) to...: " appTitle)
    SetTimer, resetOpeningPanel, -300
}

BtnIdentifyFileRoots() {
   ToolTip, Please wait...
   alistu := IdentifyFileFolderRoots("cached")
   listu := alistu[1]
   Try Menu, Manna, Delete
   Loop, Parse, listu, `n
   {
      If (A_Index>10)
         Break
      If !A_LoopField
         Continue

      entryu := A_Index ". " PathCompact(A_LoopField, 35) "\"
      Menu, Manna, Add, % entryu, menuSetSourceStructuredOper
   }

   If (alistu[2]>10)
   {
      Try Menu, Manna, Add, % "... and " alistu[2] - 10 " folders more", dummy
      Try Menu, Manna, Disable, % "... and " alistu[2] - 10 " folders more"
   }
   Try Menu, Manna, Show
   ToolTip
}

menuSetSourceStructuredOper(menuItem) {
   openThisu := SubStr(menuItem, 1, InStr(menuItem, ".") - 1)
   alistu := IdentifyFileFolderRoots("cached")
   listu := alistu[1]
   ; ToolTip, % menuitem "==" openThisu , , , 2
   Loop, Parse, listu, `n
   {
      If (openThisu=A_Index)
         GuiControl, SettingsGUIA:, UsrEditFileSource, % A_LoopField
   }
}

IdentifyFileFolderRoots(modus) {
   Static gList, counter
   If (modus="kill")
   {
      counter := 0
      gList := ""
      Return
   }

   If (gList && modus="cached")
      Return [gList, counter]

   foldersListArray := new hashtable()
   Loop, % maxFilesIndex + 1
   {
        imgPath := resultedFilesList[A_Index, 1]
        If (InStr(imgPath, "||") || !imgPath || resultedFilesList[A_Index, 2]!=1)
           Continue

        OutDir := Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1))
        foldersListArray[OutDir] := 1
   }

   listu := ""
   For Key, Value in foldersListArray
   {
      If key
         listu .= key "`n"
   }

   foldersListArray := ""
   flist := ""
   Loop, Parse, listu, `n
   {
      n := ST_Count(A_LoopField, "\")
      If (n>0)
         flist .= n "|" A_LoopField "`n"
   }

   nList := ""
   Sort, flist, ND`n
   Loop, Parse, flist, `n
   {
      If !A_LoopField
         Continue

      k := InStr(A_LoopField, "|") + 1
      p := SubStr(A_LoopField, k, InStr(A_LoopField, "\", 0, -1) - k)
      If !InStr(nList, p "`n")
         nList .= p "`n"
   }

   flist := ""
   Loop, Parse, nList, `n
   {
      If !A_LoopField
         Continue

      n := ST_Count(A_LoopField, "\")
      If (n>0)
         flist .= n "|" A_LoopField "`n"
   }
   Sort, flist, ND`n

   p := 0
   nList := ""
   Loop, Parse, flist, `n
   {
      If !A_LoopField
         Continue
      k := StrSplit(A_LoopField, "|")
      If (p=0)
         p := k[1]
      if (k[1]>p + 1)
         Break
      nList .= k[2] "`n"
   }

   Sort, nList, D`n
   counter := 0
   prevu := gList := ""
   Loop, Parse, nList, `n
   {
      If !A_LoopField
         Continue

      If (!InStr(A_LoopField, prevu "\") || !prevu)
      {
         gList .= A_LoopField "`n"
         prevu := A_LoopField
         counter++
      }
   }

   ; Sort, nList, D`n
   ; Try Clipboard := gList "`n===`n" nList "`n====`n" flist
   Return [glist, counter]
}

BtnUiSharpenTabsInfoUpdate() {
   BtnTabsInfoUpdate()
   If (viewportQPVimage.imgHandle)
      GuiControl, SettingsGUIA: Choose, CurrentPanelTab, 1
   Else If (CurrentPanelTab=2 && ImageSharpenMode!=3)
      GuiControl, SettingsGUIA: Choose, ImageSharpenMode, 3

   updateUIsharpenPanel()
}

iniSaveJPGquality() {
    RegAction(1, "userJpegQuality")
}

PanelCustomizeToolbar() {
    thisBtnHeight := createSettingsGUI(82, A_ThisFunc)
    btnWid := 195
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 130
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid := btnWid * 2 + 5
    Global UImainTlbrList, UIuserTlbrList, PickuToolbarBgrColor
    btnzList := CoreGUItoolbar("getBtnList")
    userList := CoreGUItoolbar("getCustomList", thumbsDisplaying)
    ; ToolTip, % btnzList , , , 2
    Sort, btnzList, D|
    ml := (PrefsLargeFonts=1) ? 60 : 45
    k := (thumbsDisplaying=1) ? "thumbnails / list view" : "image view"
    Gui, Add, Text, x+10 y+15 w%txtWid% Section , Active toolbar mode: %k%.
    Gui, Add, Text, xs y+15 w%btnWid% Section , Buttons available for this mode:
    Gui, Add, Text, x+10 wp , User defined custom list:
    Gui, Add, ListBox, xs y+5 wp r10 Choose1 vUImainTlbrList gBtnMainListToolbarIconsAction, % btnzList
    Gui, Add, ListBox, x+10 wp r10 Choose1 vUIuserTlbrList gBtnUserListToolbarIconsAction , % userList
    Gui, Add, Button, xs y+5 wp h%thisBtnHeight% gBTNaddCustomTlbrIcon vtxtLine1, A&dd to custom list
    Gui, Add, Button, x+10 wp hp gBTNremCustomTlbrIcon vtxtLine2, &Remove from custom list
    Gui, Add, Checkbox, xs y+10 wp hp Checked%ShowToolTipsToolbar% vShowToolTipsToolbar, &Show tooltips on icon hover
    Gui, Add, Checkbox, x+10 wp hp Checked%userCustomizedToolbar% vuserCustomizedToolbar gBTNtglCustoTlbr, &Use customized toolbar
    Gui, Add, Text, xs y+9 hp +0x200, Toolbar background color:
    GuiAddPickerColor("x+5 hp w35", "ToolbarBgrColor")
    GuiAddColor("x+5 hp w" ml, "ToolbarBgrColor", "Toolbar background color")
 
    thisW := (PrefsLargeFonts=1) ? 90 : 65
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%thisW% Default gBtnSaveCustomToolbar, &Apply
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    Tooltip
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Customize toolbar: " appTitle)
    SetTimer, resetOpeningPanel, -300
    BTNtglCustoTlbr()
}

PanelCustomKeysMiniManager() {
    If (allowCustomKeys!=1)
    {
        msgResult := msgBoxWrapper(appTitle ": Confirmation", "To customize keyboard shortcuts, the option to allow custom user defined keyboard shortcuts must be activated. Would you like to activate it now?", 4, 0, "question")
        If (msgResult="Yes")
        {
           ToggleCustomKBDsMode()
           SetTimer, PanelCustomKeysMiniManager, -100
           Return
        } Else Return
    }

    thisBtnHeight := createSettingsGUI(83, A_ThisFunc)
    btnWid := 195
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 130
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid := btnWid * 2 + 5
    Global UImainTlbrList, UIuserTlbrList, whichUIkbdContext
    ml := (PrefsLargeFonts=1) ? 60 : 45
    listu := defineKBDcontexts(3)
    lp := defineKBDcontexts(0)
    Gui, Add, Text, x+10 y+15 Section +0x200 +hwndhTemp, Application contexts:
    GuiAddDropDownList("x+10 w" btnWid " AltSubmit Choose" lp " vwhichUIkbdContext gupdateUIKeysListManager", listu, [hTemp])
    GuiAddListView("xs y+10 w" txtWid " -multi +LV0x10000 +LV0x400 r7 Grid vLViewOthers gBtnLVcustomKBDies", "Key|Menu item|Menu container|Function", "User defined shortcuts")
    Gui, Add, Text, xs y+10 wp, The shortcuts can be customized in the Quick Menus Search box.`nTo open it, click Customize.`n`nThis panel is meant to provide an overview of the already defined custom keyboard shortcuts.
 
    thisW := (PrefsLargeFonts=1) ? 130 : 115
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%thisW% Default gPanelQuickSearchMenuOptions, C&ustomize
    Gui, Add, Button, x+5 hp wp-25 gBtnCloseWindow, &Cancel
    Tooltip
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Customized keyboard shortcuts overview: " appTitle)
    SetTimer, resetOpeningPanel, -300
    updateUIKeysListManager()
}

BtnLVcustomKBDies(a, b, c) {
   If (b!="DoubleClick")
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, whichUIkbdContext
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(funcu, RowNumber, 4)
   If InStr(funcu, "()")
   {
      funcu := StrReplace(funcu, "()")
      userQuickMenusEdit := funcu
      BtnCloseWindow()
      PanelQuickSearchMenuOptions(funcu, "yes")
      SetTimer, PanelDefineKbdShortcut, -150
   }
}

updateUIKeysListManager() {
   Gui, SettingsGUIA: Default
   GuiControlGet, whichUIkbdContext
   Gui, SettingsGUIA: ListView, LViewOthers
   GuiControl, -Redraw, LViewOthers
   LV_Delete()

   For Key, V in userCustomKeysDefined
   {
      If (SubStr(key, 2, 1)=".")
         Continue

      If (V[4]=whichUIkbdContext)
      {
         funcu := (InStr(V[1], "?")=1) ? "{Disabled}" : V[1] "()"
         LV_Add(A_Index, V[6], V[2], V[3], funcu)
      }

   }

   Loop, 4
     LV_ModifyCol(A_Index, "AutoHdr Left")

   GuiControl, +Redraw, LViewOthers
}

BTNtglCustoTlbr() {
   GuiControlGet, OutputVar, SettingsGUIA:, userCustomizedToolbar
   actu := (OutputVar=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, UImainTlbrList
   GuiControl, % actu, UIuserTlbrList
   GuiControl, % actu, txtLine1
   GuiControl, % actu, txtLine2
}

BtnMainListToolbarIconsAction(a,b) {
   If (b="DoubleClick")
      BTNaddCustomTlbrIcon()
}

BtnUserListToolbarIconsAction(a,b) {
   If (b="DoubleClick")
      BTNremCustomTlbrIcon()
}

BtnSaveCustomToolbar() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userCustomizedToolbar
   GuiControlGet, ShowToolTipsToolbar
   GuiControlGet, hwnd, hwnd, UIuserTlbrList
   ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
   btnzListArray := CoreGUItoolbar("getListArray")
   listu := ""
   Loop, Parse, listBoxOptions,`n
   {
      thisu := SubStr(A_LoopField, InStr(A_LoopField, " [") + 1)
      thisu := Trim(thisu, "[ ]")
      If btnzListArray[thisu]
         listu .= btnzListArray[thisu] ","
   }

   listu := Trim(listu, ",")
   If (thumbsDisplaying=1)
      userThumbsToolbarList := listu
   Else
      userImgViewToolbarList := listu

   If !InStr(listu, ",")
      userCustomizedToolbar := 0

   BtnCloseWindow()
   createGUItoolbar("forced")
   RegAction(1, "ShowToolTipsToolbar", "General")
   IniAction(1, "ToolbarBgrColor", "General")
   IniAction(1, "userCustomizedToolbar", "General")
   IniAction(1, "userThumbsToolbarList", "General")
   IniAction(1, "userImgViewToolbarList", "General")
}

BTNaddCustomTlbrIcon() {
   Gui, SettingsGUIA: Default
   GuiControlGet, UImainTlbrList
   GuiControlGet, UIuserTlbrList
   ; ToolTip, % UImainTlbrList , , , 2
   thisu := SubStr(UImainTlbrList, InStr(UImainTlbrList, " ["))
   GuiControlGet, hwnd, hwnd, UIuserTlbrList
   ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
   If (InStr(listBoxOptions, thisu) || InStr(listBoxOptions, UImainTlbrList "`n"))
      Return

   If UIuserTlbrList
   {
      listBoxOptions := StrReplace(listBoxOptions "`n", UIuserTlbrList "`n", UIuserTlbrList "`n" UImainTlbrList "`n`n")
      GuiControl, SettingsGUIA:, UIuserTlbrList, % "|" Trim(StrReplace(listBoxOptions, "`n", "|"), "|")
   } Else
   {
      listBoxOptions := listBoxOptions "`n" UImainTlbrList "`n`n"
      GuiControl, SettingsGUIA:, UIuserTlbrList, % "|" StrReplace(listBoxOptions, "`n", "|")
   }
}

BTNremCustomTlbrIcon() {
   Gui, SettingsGUIA: Default
   GuiControlGet, UIuserTlbrList
   ; ToolTip, % UImainTlbrList , , , 2
   GuiControlGet, hwnd, hwnd, UIuserTlbrList
   ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
   listBoxOptions := StrReplace(listBoxOptions "`n", UIuserTlbrList "`n", "`n")
   listBoxOptions := Trim(listBoxOptions, "`n")
   If !InStr(listBoxOptions, "`n`n")
      listBoxOptions .= "`n`n"

   GuiControl, SettingsGUIA:, UIuserTlbrList, % "|" StrReplace(listBoxOptions, "`n", "|")
}

PanelAutoColors() {
    If (thumbsDisplaying=1)
    {
       Tooltip, Please wait...
       getSelectedFiles(0, 1)
       If !markedSelectFile
       {
          lastOtherWinClose := 1
          ToggleThumbsMode()
          SetTimer, PanelAutoColors, -150
          Tooltip
          Return
       }
    }

    initQPVmainDLL()
    thisBtnHeight := createSettingsGUI(80, A_ThisFunc)
    RegAction(0, "PreserveDateTimeOnSave",, 1)
    RegAction(0, "userJpegQuality",, 2, 1, 100)
    btnWid := thisW := 100
    txtWid := 270
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 60
       Gui, Font, s%LargeUIfontValue%
    }

    infoMask := defineCurrentAlphaMask()
    If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
       EraseAreaUseAlpha := 0

    Gui, Add, Text, x+10 y+15 Section, Automatically adjust:
    GuiAddDropDownList("xs y+10 wp+50 AltSubmit Choose" userAutoColorAdjustMode " vuserAutoColorAdjustMode", "Image contrast|RGB levels|Both")
    If (thumbsDisplaying!=1)
       Gui, Add, Button, x+5 hp wp-30 gPanelAdjustColorsSimpleWindow, &Manual adjustments

    ha := (PrefsLargeFonts=1) ? 27 : 18
    GuiAddSlider("userAutoColorIntensity", 5, 255, 255, "Intensity", "dummy", 1, "xs y+10 Section wp+30 h" ha)
    If (thumbsDisplaying=1)
    {
       Gui, Add, Checkbox, xs y+10 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve files date and time
       GuiAddSlider("userJpegQuality", 1,100, 95, "JPEG / WEBP quality on save", "iniSaveJPGquality", 1, "xs y+10 wp h" ha)
    }

    If (thumbsDisplaying!=1)
    {
       Gui, Add, Checkbox, xs y+10 Checked%EraseAreaUseAlpha% vEraseAreaUseAlpha, Apply alpha mas&k
       If (viewportQPVimage.imgHandle || InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
          GuiControl, Disable, EraseAreaUseAlpha
       Gui, Add, Checkbox, xs y+10 Checked%userAutoColorAdjustAll% vuserAutoColorAdjustAll, &Adjust the colors based on the entire image,`nregardless of the selected area
    } Else
       Gui, Add, Text, xs y+10, Selected files: %markedSelectFile%.`n`nImages in unsupported write formats will be skipped.

    thisW := (PrefsLargeFonts=1) ? 90 : 65
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBTNdoAutoImgColors, % (thumbsDisplaying=1) ? "&Process images" : "&Auto-adjust"
    Gui, Add, Button, x+5 hp w%thisW% gBtnCloseWindow, C&ancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    Tooltip
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Auto-adjust image colors: " appTitle)
    SetTimer, resetOpeningPanel, -300
    GuiRefreshSliders()
}

BTNdoAutoImgColors() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userAutoColorAdjustAll
   GuiControlGet, userAutoColorAdjustMode
   GuiControlGet, EraseAreaUseAlpha
   If (thumbsDisplaying=1)
   {
      GuiControlGet, PreserveDateTimeOnSave
      RegAction(1, "PreserveDateTimeOnSave")
      If !markedSelectFile
         Return
      
      batchAutoColorsFiles()
      Return
   }

   BtnCloseWindow()
   If (viewportQPVimage.imgHandle)
   {
      HugeImagesApplyAutoColors()
      Return
   }

   If (downscaleHugeImagesForEditing()<0)
      Return

   If (userAutoColorAdjustMode=3)
   {
      PolarRectSelectedArea(A_ThisFunc, 3, 1, userAutoColorAdjustAll)
      PolarRectSelectedArea(A_ThisFunc, 3, 2, userAutoColorAdjustAll)
   } Else
      PolarRectSelectedArea(A_ThisFunc, 3, userAutoColorAdjustMode, userAutoColorAdjustAll)
}

PanelSharpenImage() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisBtnHeight := createSettingsGUI(79, A_ThisFunc)
    ReadSettingsEdgesPanel()
    btnWid := 100
    txtWid := 205
    thisW := 100
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       thisW := 200
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 110
       Gui, Font, s%LargeUIfontValue%
    }

    2ndcol := (PrefsLargeFonts=1) ? 155 : 100
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125
    gW := (PrefsLargeFonts=1) ? 385 : 330
    gH := (PrefsLargeFonts=1) ? 500 : 370
    If (isWinXP=1 || A_OSVersion="WIN_7")
       gH := gH//1.7
    If (viewportQPVimage.imgHandle)
       ImageSharpenMode := 1

    IDedgesOpacity := 255
    IDedgesBlendMode := IDedgesEmbossLvl := 1
    Gui, -DPIScale
    Gui, Font
    Gui, Add, Text, x20 y20 w%gW% h%gH% Section -Border +0xE gUIresponderPanelsLivePreview +hwndhCropCornersPic +TabStop, Preview area
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click and drag to change the preview area, or click in the viewport.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%
    If !testAllowSelInvert()
       BlurAreaInverted := 0

    thisW := (PrefsLargeFonts=1) ? 68 : 48
    Gui, +DPIScale
    Gui, Add, Tab3, %tabzDarkModus% x+20 ys gBtnUiSharpenTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab, General|Edges filter
    Gui, Tab, 1
    Gui, Add, Text, x+10 y+10 Section +hwndhTemp, Sharpen mode:
    GuiAddDropDownList("x+5 wp gupdateUIsharpenPanel AltSubmit Choose" ImageSharpenMode " vImageSharpenMode", "cImg|GDI+|Advanced", [hTemp])
    GuiAddSlider("ImageSharpenAmount", 0,100, 10, "Sharpen amount", "updateUIsharpenPanel", 1, "xs y+10 w" txtWid " hp")
    GuiAddSlider("ImageSharpenRadius", 0,255, 15, "Radius: $€", "updateUIsharpenPanel", 1, "xs y+10 wp hp")
    Gui, Add, Checkbox, xs y+10 Checked%BlurAreaInverted% vBlurAreaInverted gupdateUIsharpenPanel, &Invert selection area
    Gui, Add, Text, xs y+10 w%txtWid% vtxtLine3, In advanced mode, the effect is masked using the edges detection filter.

    If !testAllowSelInvert()
       GuiControl, Disable, BlurAreaInverted
    If (viewportQPVimage.imgHandle)
       GuiControl, Disable, ImageSharpenMode

    Gui, Tab, 2
    Gui, Add, Text, x+10 y+10 Section, Direction of edge detection:
    Gui, Add, Text, xs y+5 w%thisW%, X
    Gui, Add, Text, x+3 wp, Y
    Gui, Add, Text, x+3 wp, C
    GuiAddDropDownList("xs y+7 w" thisW " gupdateUIedgesPanel AltSubmit Choose" IDedgesXuAmount " vIDedgesXuAmount", "-3|-2|-1|0|1|2|3", "X offset")
    GuiAddDropDownList("x+3 wp gupdateUIedgesPanel AltSubmit Choose" IDedgesYuAmount " vIDedgesYuAmount", "-3|-2|-1|0|1|2|3", "Y offset")
    GuiAddDropDownList("x+3 wp gupdateUIedgesPanel AltSubmit Choose" IDedgesCenterAmount " vIDedgesCenterAmount", "0|1|2|3|4|5", "C offset")
    GuiAddSlider("IDedgesEmphasis", -255,255, 0, "Brightness", "updateUIedgesPanel", 2, "xs y+10 w" txtWid " hp")
    GuiAddSlider("IDedgesContrast", -100,100, 0, "Contrast", "updateUIedgesPanel", 2, "xs y+10 wp hp")
    Gui, Add, Checkbox, xs y+10 w%2ndcol% hp gupdateUIedgesPanel Checked%IDedgesInvert% vIDedgesInvert, &Invert image
    GuiAddDropDownList("x+5 wp AltSubmit gupdateUIedgesPanel Choose" IDedgesAfterBlur " vIDedgesAfterBlur", "No blur|4|6|8|10", "Blur level")

    Gui, Tab
    thisW := (PrefsLargeFonts=1) ? 90 : 65
    Gui, Add, Button, xs y+25 h%thisBtnHeight% w%btnWid% Default gBTNdoSharpenFX, &Sharpen image
    Gui, Add, Button, x+5 hp w%thisW% gBtnCloseWindow, C&ancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Sharpen image selected area: " appTitle)
    SetTimer, updateUIsharpenPanel, -200
    SetTimer, resetOpeningPanel, -300
}

testAllowSelInvert(imgW:=0, imgH:=0) {
    r := (EllipseSelectMode=0 && VPselRotation=0 && innerSelectionCavityX=0 && innerSelectionCavityY=0 && testEntireImgSelected(imgW, imgH)) ? 0 : 1
    If ((AnyWindowOpen=23 || AnyWindowOpen=68) && FillAreaShape>1)
       r := 1
    Return r
}

updateUIsharpenPanel() {
    If (AnyWindowOpen!=79)
       Return

    updateUIedgesPanel()
    actu := (ImageSharpenMode>1) ? 1 : 0
    uiSlidersArray["ImageSharpenRadius", 10] := actu
    GuiRefreshSliders()
}

BTNdoSharpenFX() {
   If (downscaleHugeImagesForEditing()<0)
      Return 1

   updateUIsharpenPanel()
   BtnCloseWindow()
   SharpenSelectedArea()
}

PanelStructuredCopyMoveWindow() {
    Global BtnCpyMv, UsrEditFileSource, lastInvoked := 1
    ; Static prevmainDynaFoldersListu, prevCurrentSLD

    openingPanelNow := 1
    IdentifyFileFolderRoots("kill")
    thisBtnHeight := createSettingsGUI(77, A_ThisFunc)
    sml := (PrefsLargeFonts=1) ? 90 : 72
    btnWid := 125
    btnWid2 := 60
    txtWid := 360
    If (PrefsLargeFonts=1)
    {
       btnWid := btnWid + 70
       btnWid2 += 60
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    EditWid := (PrefsLargeFonts=1) ? 455 : 290
    lstWid := sml + editWid

    ToolTip, Please wait...,,, 2
    UsrCopyMoveOperation := 1
    zPlitPath(getIDimage(currentFileIndex), 1, OldOutFileName, OutDir, OutFileNameNoExt, OutFileExt)

    pk := (uiUseDarkMode=1) ? "" : "-dark"
    pp := mainExecPath "\resources\toolbar\"
    getSelectedFiles(0, 1)
    ml := (PrefsLargeFonts=1) ? 110 : 70
    Gui, +Delimiter`n
    sml := (PrefsLargeFonts=1) ? 50 : 30
    Gui, Add, Text, x15 y15 Section, %infoSelection%This panels allows users to copy or move folder structures.`nPlease select source and destination folders.`nThe files not found in the defined source folder (or in a sub-folder of it)`, will be skipped.
    Gui, Add, Text, xs y+10 w%ml%, Source: 
    GuiAddEdit("x+5 w" EditWid " gUIeditsGenericAllowCtrlBksp r1 -WantReturn -wantTab -multi vUsrEditFileSource", OutDir)
    Gui, Add, Button, x+1 hp gBtnCpyMvStrctrdChooseFilesSrc hwndhTemp, &Browse
    ToolTip2ctrl(hTemp, "Please define the correct source path for the optimal experience.`nYou must choose the root folder of all the images to be copied or moved.`nThe selected files that are not in this source path [or in a sub-folder], will be skipped.")
    GuiAddButton("x+1 w" sml " hp gBtnIdentifyFileRoots", pp "triangle-down" pk ".png", "Possible source paths", "Automatically identify possible source paths based on the selected files.`nThe number of listed folders in the menu is an indicator`nof how dispersed are the locations of the selected files.")
    Gui, Add, Text, xs y+10 w%ml% hp +0x200, Destination:
    GuiAddEdit("x+5 w" EditWid " gUIeditsGenericAllowCtrlBksp r1 -WantReturn -wantTab -multi vUsrEditFileDestination", UsrEditFileDestination)
    Gui, Add, Button, x+1 hp gBtnCpyMvStrctrdChooseFilesDst hwndhTemp, B&rowse
    ToolTip2ctrl(hTemp, "In the destination folder, the folder structure will be created containing the selected files.")
    thisW := (PrefsLargeFonts=1) ? 190 : 120
    Gui, Add, Text, xs y+15 hp +0x200 +hwndhTempu, On file name conflicts:
    zh := GuiAddDropDownList("x+5 w" thisW " AltSubmit Choose" userCopyMoveStructuredConflictMode " vuserCopyMoveStructuredConflictMode", "Skip files`nAuto-rename`nOverwrite`nAsk user", [hTempu])
    Gui, Add, Text, xs y+10 hp +0x200 +hwndhTemp, Action to perform:
    GuiAddDropDownList("xp yp w" thisW " AltSubmit Choose" UsrCopyMoveOperation " vUsrCopyMoveOperation", "Choose...`nMove file(s)`nCopy file(s)", [hTemp, hTempu, zh])
    getSelectedFiles(0, 1)
    infoSelection := "Selected files: " groupDigits(markedSelectFile) ". "

    ToolTip,,,,2
    sml := (PrefsLargeFonts=1) ? 90 : 72
    SetTimer, ResetImgLoadStatus, -50

    Gui, Add, Button, xs y+25 h%thisBtnHeight% w%btnWid2% Default gBTNuiProceedStructuredOperation vBtnCpyMv, &Proceed
    Gui, Add, Button, x+5 hp w%sml% gBtnCloseWindow, C&ancel
    Gui, Add, Text, x+5 hp +0x200, % infoSelection
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Structured copy/move file(s): " appTitle)
    SetTimer, resetOpeningPanel, -300
}

BTNuiProceedStructuredOperation() {
   Gui, SettingsGUIA: Default
   GuiControlGet, UsrEditFileSource
   GuiControlGet, UsrEditFileDestination
   GuiControlGet, userCopyMoveStructuredConflictMode
   GuiControlGet, UsrCopyMoveOperation
   If (UsrCopyMoveOperation=1)
   {
      showTOOLtip("ERROR: Please select action to perform: copy or move files.") 
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   fS := Trim(UsrEditFileSource, "\")
   dS := Trim(UsrEditFileDestination, "\")
   fS := StrReplace(fS, "/", "\")
   dS := StrReplace(dS, "/", "\")
   fS := Trimmer(fS)
   dS := Trimmer(dS)

   If !FolderExist(fS)
   {

      showTOOLtip("ERROR: Please choose an existing source folder.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If !FolderExist(dS)
   {
      If StrLen(dS)>4
      {
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The destination folder seems to not exist.`n`n" dS "\`n`nWould you like to create it now?", 4, 0, "question")
         If (msgResult="Yes")
         {
            FileCreateDir, %dS%
            If ErrorLevel
            {
               msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n`n" dS "\`n`nPossibly access denied.", 0, 0, "error")
               Return
            }
         } Else Return
      } Else
      {
         showTOOLtip("ERROR: Please choose an existing destination folder.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   If (dS=fS)
   {
      showTOOLtip("ERROR: The source and destination folders cannot be the same.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   copyMoveStructuredFolders(fS, dS)
}

BTNlvRecentFileDesties(a, b, c) {
   If !(b="RightClick" || b="k" ||  b="normal" || b="DoubleClick")
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(givenName, RowNumber, 1)
   GuiControl, SettingsGUIA: , UsrEditFileDestination, % givenName
   If (b="DoubleClick")
      BtnCopyMoveAction()
}

BtnHelpCopyMovePanel() {
  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  If (AnyWindowOpen=9)
     moreInfo := "`n`nIf you click on «Mark files (Explorer)» button, the selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle "."

  msgBoxWrapper(appTitle ": HELP", "Recognized patterns:`n`na) " btnName " files to parent folder: .\`n`nb) " btnName " files to a new or existing sub-folder: \given-folder`n`nc) " btnName " files into a new or existing folder within the parent folder: .\given-folder`n`nThe destination folder for every selected file(s) will be calculated relative to its own location path.`n `nUse [group-by-month-year], [group-by-years] or [group-by-file-types] as folder name to automatically group files in newly created folders named based on files' modification date or file types." moreInfo, -1, 0, 0)
}

changeCopyMoveAction() {
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrCopyMoveOperation
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  ; GuiControl, SettingsGUIA:, BtnCpyMv, &%btnName% file(s)
  Gui, SettingsGUIA: Show,, %btnName% file(s) to...: %appTitle%
  actu := (UsrCopyMoveOperation=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
  GuiControl, % actu, BtnCpyMv
}

allowCtrlBkspEdit(hwnd, oldValue) {
   Static bksp := "", delims := "|:;?!@\_/, (.-)"
   If InStr(oldValue, bksp)
   {
      ; handle ctrl+backspace
      posu := 0
      newValue := ""
      value := StrReplace(oldValue, "`t", "  ")
      value := StrReplace(value, bksp bksp, bksp)
      remPlus := 0
      delim := StrSplit(delims)
      k := ""
      For w, g in delim
      {
          If InStr(value, g bksp)
             k := g
      }

      If (k!="")
      {
         remPlus := 1
         value := StrReplace(value, k bksp, bksp k)
      }
      posuX := InStr(value, bksp)
      posuS := 0
      Loop, Parse, value
      {
         If (A_Index>=posuX)
            Break

         z := A_LoopField
         thisIndex := A_Index
         Loop, Parse, delims
         {
            If (z=A_LoopField)
            {
               posuS := thisIndex
               Break
            }
         }
      }

      a := SubStr(value, 1, posuS)
      b := SubStr(value, posuX + 1 + remPlus)
      ; TulTip(0, "==", posuX, posuS, a, b, "`n" oldValue)
      newValue := a . b
      If (newValue!=oldValue)
      {
         posuS += ST_Count(a, "`n")
         newValue := StrReplace(newValue, bksp)
         ControlSetText, , % newValue , ahk_id %hwnd%
         EM_SETSEL(hwnd, posuS, posuS)
      } Else newValue := oldValue
   } Else newValue := oldValue

   Return newValue
}

EraseCopyMoveHisto() {
  IniDelete, % mainRecentsFile, RecentFDestinations
  BtnCloseWindow()
  CopyMovePanelWindow()
}

BtnMarkFilesExplorer() {
  Gui, SettingsGUIA: Default
  GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
  GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
  GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
  If (UsrCopyMoveOperation=1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "Please choose an action to perform: copy or move.`n`nThe selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle ".", 0, 0, "exclamation")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  BtnCloseWindow()
  If (UsrCopyMoveOperation=3)
     MenuExplorerCopyFiles()
  Else
     MenuExplorerCutFiles()
}

BtnCopyMoveAction(dummy:=0) {
  If (dummy!="quick-actu")
  {
     Gui, SettingsGUIA: Default
     GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
     GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
     GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
     If (UsrCopyMoveOperation=1)
     {
        showTOOLtip("WARNING: Please choose an action to perform: copy or move")
        SoundBeep, 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     }
  }

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  folderu := Trimmer(UsrEditFileDestination)
  folderu := StrReplace(folderu, "/", "\")
  folderu := RegExReplace(folderu, "\\{2,}", "\")
  groupingMode := 0
  If (folderu="[group-by-month-year]" || folderu="[group-by-years]" || folderu="[group-by-file-types]")
  {
     ; group files by given criteria
     groupingMode := 1
     folderu := OutDir "\" folderu
  } Else If (folderu=".\")
  {
     ; move files one level up
     relativePath := folderu
     folderu := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
  } Else If RegExMatch(folderu, "^(\\.)")
  {
     ; move files to a given sub-folder
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)

     If folderu
     {
        relativePath := "\" folderu
        folderu := OutDir "\" folderu
     }
  } Else If RegExMatch(folderu, "^(\.\\.)")
  {
     ; move files to a given sibling folder
     OutDir := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)
     If folderu
     {
        relativePath := ".\" folderu
        folderu := OutDir "\" folderu
     }
  }

  folderu := StrReplace(folderu, "\\", "\")
  folderu := Trimmer(folderu, "\")
  folderu := Trimmer(folderu, ".")
  If (b := InStr(folderu, "; "))
     folderu := SubStr(folderu, b + 2)

  wrongNames := 0
  testFolderu := SubStr(folderu, 4)
  Loop, Parse, testFolderu, \
  {
      IF (!filterFileName(A_LoopField) && A_LoopField)
         wrongNames := 1
  }

  If (InStr(folderu, "[group-by-month-year]") || InStr(folderu, "[group-by-file-types]") || InStr(folderu, "[group-by-years]"))
     groupingMode := 1

  If (!RegExMatch(folderu, "^(.\:\\.)") && !relativePath || wrongNames=1)
  {
     showTOOLtip("WARNING: Incorrect file path given:`n" folderu)
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return 0
  }

  nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
  If (FolderExist(folderu) || groupingMode=1 || relativePath)
  {
     Sleep, 2
     r := QuickMoveFile2Dest(folderu, groupingMode, dummy, relativePath)
     dummyTimerDelayiedImageDisplay(50)
  } Else If (StrLen(folderu)>4)
  {
     If (dummy!="quick-actu")
        msgResult := msgBoxWrapper(appTitle, "Destination folder does not seem to exist:`n" folderu "\`n`nDo you want to create the folder?", 4, 0, "question")

     If (msgResult="yes" || dummy="quick-actu")
     {
        FileCreateDir, % folderu
        If ErrorLevel
        {
           OutDir := PathCompact(folderu, "a", 1, OSDfontSize)
           SoundBeep , 300, 100
           If (dummy="quick-actu")
              showTOOLtip("Failed to create the destination folder:`n" OutDir "\")
           Else
              msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder:`n" folderu "\", 0, 0, "error")
           Return 0
        } Else
        {
           Sleep, 2
           r := QuickMoveFile2Dest(folderu, groupingMode, dummy)
           dummyTimerDelayiedImageDisplay(50)
        }
     }
  }
  ; MsgBox, %folderu% -- %newentry%
  Return r
}

RecentCopyMoveManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentFileDesties(1)

  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu,`n
  {
      If (A_LoopField=entry2add)
      {
         isAddedAlready := 1
         Break
      }
  }

  If (isAddedAlready=1)
     Return

  mainListu := entry2add "`n" mainListu
  Loop, Parse, mainListu, `n
  {
      If (A_Index>15)
         Break

      folderu := Trimmer(A_LoopField)
      folderu := Trimmer(folderu, "\")
      If (!FolderExist(folderu) || !InStr(folderu, ":\"))
         Continue

      countItemz++
      IniWrite, % folderu, % mainRecentsFile, RecentFDestinations, E%countItemz%
  }
}

QuickMoveFile2Dest(finalDest, groupingMode:=0, dummy:=0, relativePath:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()
 
    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       batchCopyMoveFile(finalDest, groupingMode, dummy, relativePath)
       Return 0
    } 

    file2rem := getIDimage(currentFileIndex)
    zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
    If !FileExist(file2rem)
    {
       sOldOutDir := PathCompact(OldOutDir, "a", 1, OSDfontSize)
       ResetImgLoadStatus()
       SoundBeep, 300, 100 
       If (dummy="quick-actu")
          showTOOLtip("Failed to perform action. File not found or access denied.`n" OldOutFileName "`n" sOldOutDir "\")
       Else
          msgBoxWrapper(appTitle ": ERROR", "Failed to perform action. File not found or access denied.`n`n" OldOutFileName "`n" OldOutDir "\", 0, 0, "error")
       Return 0
    }

    FileGetTime, originalMtime, % file2rem, M
    FileGetTime, originalCtime, % file2rem, C
    If (groupingMode=1)
       finalDest := determineCreateFileGroupFolder(finalDest, originalMtime, OutFileExt)

    If (OldOutDir=finalDest && UsrCopyMoveOperation=3 && dummy!="quick-actu")
       mustCreateDupe := 1

    If (OldOutDir=finalDest && mustCreateDupe!=1)
    {
       sOldOutDir := PathCompact(OldOutDir, "a", 1, OSDfontSize)
       SetTimer, ResetImgLoadStatus, -200
       SoundBeep, 300, 100 
       If (dummy="quick-actu")
          showTOOLtip("WARNING: Illegal operation. The destination folder is the same with the initial location:`n" sOldOutDir "\")
       Else
          msgBoxWrapper(appTitle ": WARNING", "Illegal operation. The destination folder is the same with the initial location:`n" finalDest "\", 0, 0, "exclamation")
       Return 0
    }

    BtnCloseWindow()
    Sleep, 2
    destroyGDIfileCache()
    file2save := finalDest "\" OldOutFileName
    If (mustCreateDupe=1)
       forceConflictOption := 2
    Else
       forceConflictOption := (dummy="quick-actu") ? QuickFileActConflict : copyMoveDoLastOption

    If (FileExist(file2save) && !FolderExist(file2save))
    {
       file2save := askAboutFileCollision(file2rem, file2save, 0, 0, forceConflictOption, performOverwrite)
       If !file2save
       {
          OutDir := PathCompact(finalDest, "a", 1, OSDfontSize)
          showTOOLtip("WARNING: Another file with the same file name already exists in the destination folder:`n" OldOutFileName "`n" OutDir "\`nOperation aborted.")
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SetTimer, ResetImgLoadStatus, -200
          Return 0
       }
    }

    If (file2save="abort" || !file2save)
    {
       If (UsrCopyMoveOperation!=2 && dummy!="quick-actu")
          SetTimer, InvokeCopyFiles, -150
       Else If (dummy!="quick-actu")
          SetTimer, PanelMoveCopyFiles, -150
       SetTimer, ResetImgLoadStatus, -200
       Return 0
    }

    operationExecuted := mustPerformOperation := 0
    thisFileExists := FileRexists(file2save, 0)
    If (performOverwrite=1 && thisFileExists=1)
    {
       jso := GetFileAttributesEx(file2save)
       originalFileInfos := jso.size "|" jso.wtime "|" jso.ctime
       FileSetAttrib, -R, %file2save%
       Sleep, 5
       FileRecycle, %file2save%
       Sleep, 5
       mustPerformOperation := 1
    } Else If (thisFileExists=1)
    {
       OutDir := PathCompact(finalDest, "a", 1, OSDfontSize)
       showTOOLtip("WARNING: Operation aborted. A file with the same name already exists in the destination folder.`n" OldOutFileName "`n" OutDir "\")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -25
       Return
    } Else mustPerformOperation := 1

    If (mustPerformOperation=1)
    {
       operationExecuted := 1
       If (UsrCopyMoveOperation=2)
          FileMove, %file2rem%, %file2save%
       Else
          FileCopy, %file2rem%, %file2save%
       If ErrorLevel
          wasError := 1
    }

    If (wasError!=1 && operationExecuted=1)
    {
       updateDates := 1
       If (originalMtime)
       {
          FileSetTime, % originalMtime, % file2save, M
          FileSetTime, % originalCtime, % file2save, C
          updateDates := 0
       }

       If (dummy!="quick-actu")
       {
          prevFileMovePath := finalDest
          INIaction(1, "prevFileMovePath", "General")
          RecentCopyMoveManager(finalDest)
       }

       actName := (UsrCopyMoveOperation=2) ? "MOVED" : "COPIED"
       zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
       OutDir := PathCompact(finalDest, "a", 1, OSDfontSize)
       showTOOLtip("File " actName " to`n" OldOutFileName "`n" OutDir "\")
       extraMarker := (thisFileExists=1 && performOverwrite=1) ? "*" : ""
       recordUndoFileActs(file2save, resultedFilesList[currentFileIndex, 1], extraMarker, UsrCopyMoveOperation, A_Now, originalFileInfos)
       If (UsrCopyMoveOperation=2)
       {
          resultedFilesList[currentFileIndex, 1] := file2save
          updateMainUnfilteredList(currentFileIndex, 1, file2save)
          If (SLDtypeLoaded=3)
             updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[currentFileIndex, 12])
          Else
             currentFilesListModified := 1
       }
       Sleep, 1
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -25
       Return 1
    } Else If (operationExecuted=1)
    {
       actName := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
       OutDir := PathCompact(finalDest, "a", 1, OSDfontSize)
       showTOOLtip("ERROR: Failed to " actName " file:`n" OldOutFileName "`nDestination:`n" OutDir "\")
       SoundBeep, 300, 100
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -25
    Return 0
}

determineCreateFileGroupFolder(oFinalDest, originalMtime, OutFileExt) {
   If ((InStr(oFinalDest, "[group-by-month-year]") && originalMtime)
   || (InStr(oFinalDest, "[group-by-file-types]") && OutFileExt)
   || (InStr(oFinalDest, "[group-by-years]") && originalMtime))
   {
      FormatTime, grouper, % originalMtime, yyyy-MM-MMMM
      FormatTime, groupery, % originalMtime, yyyy
      finalDest := StrReplace(oFinalDest, "[group-by-month-year]", grouper)
      finalDest := StrReplace(finalDest, "[group-by-file-types]", OutFileExt)
      finalDest := StrReplace(finalDest, "[group-by-years]", groupery)
      If !FolderExist(finalDest)
      {
         FileCreateDir, % finalDest
         Sleep, 2
      }
   } Else finalDest := oFinalDest 
   Return FinalDest
}

batchCopyMoveFile(finalDest, groupingMode:=0, dummy:=0, relativePath:=0) {
   Static lastInvoked := 1
   ; Critical, off
   ; Thread, Priority, -4100
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>150) ; ((A_TickCount - lastInvoked > 29500) && dummy!="quick-actu")
   {
      wording := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to " wording " the selected files.`n`nSelected: " groupDigits(filesElected) " files.`nDestination: " finalDest "\", 4, 0, "question")
      If (msgResult!="Yes")
         Return 0
   }

   BtnCloseWindow()
   lastInvoked := A_TickCount
   friendly := (UsrCopyMoveOperation=2) ? "Moving " : "Copying "
   showTOOLtip(friendly groupDigits(filesElected) " files to`n" finalDest "\`nPlease wait")
   If (dummy!="quick-actu")
   {
      prevFileMovePath := finalDest
      RecentCopyMoveManager(finalDest)
   }

   destroyGDIfileCache()
   Sleep, 25
   nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   startZeit := A_Now
   doStartLongOpDance()
   failedFolders := countTFilez := filezMoved := failedFiles := skippedFiles := 0
   oFinalDest := finalDest
   forceConflictOption := (dummy="quick-actu") ? QuickFileActConflict : copyMoveDoLastOption
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   If relativePath
   {
      relativeModePath := (SubStr(relativePath, 1, 2)=".\") ? 1 : 3
      If (relativeModePath=1 && StrLen(relativePath)=2)
         relativeModePath := 2
      
      relativeStringPath := (relativeModePath=1) ? SubStr(relativePath, 2) : relativePath
      If (relativeModePath=2)
         relativeStringPath := ""
   }

   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   ; fnOutputDebug(groupingMode "|" relativeModePath "|" relativeStringPath "|" finalDest)
   setWhileLoopExec(1)
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      changeMcursor()
      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
      countTFilez++
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If relativeModePath
      {
         parentu :=SubStr(OldOutDir, 1, InStr(OldOutDir, "\", 0, -1) - 1)
         If (relativeModePath=1 || relativeModePath=2)
            finalDest := parentu relativeStringPath
         Else
            finalDest := OldOutDir relativeStringPath

         finalDest := StrReplace(finalDest, "\\", "\")
         ftestu := (SubStr(finalDest, 2, 2)=":\") ? 1 : 0
         If (groupingMode!=1 && ftestu=1)
         {
            If !FolderExist(finalDest)
            {
               FileCreateDir, % finalDest
               If ErrorLevel
                  failedFolders++
               Sleep, 2
            }
         }

         ; fnOutputDebug(ftestu "|" groupingMode "|" relativeModePath "|" relativeStringPath "|" finalDest "|" parentu)
         If (ftestu=0)
         {
            failedFiles++
            Continue
         } Else oFinalDest := finalDest
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to perform action on " groupDigits(failedFiles) " files"
         If (failedFolders>0)
            etaTime .= "`nFailed to create " groupDigits(failedFolders) " folders"
         If (skippedFiles>0)
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip(friendly " files to`n" finalDest "\" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      If (OldOutDir=finalDest || !finalDest)
      {
         skippedFiles++
         Continue
      }

      originalMtime := ""
      FileGetTime, originalMtime, % file2rem, M
      If (groupingMode=1)
      {
         finalDest := determineCreateFileGroupFolder(oFinalDest, originalMtime, OutFileExt)
         If (OldOutDir=finalDest || !finalDest)
         {
            skippedFiles++
            Continue
         }
      }

      FileGetTime, originalCtime, % file2rem, C
      file2save := finalDest "\" OldOutFileName
      originalFileInfos := mustPerformOperation := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, forceConflictOption, performOverwrite)
  
      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }

      thisFileExists := FileRexists(file2save, 0)
      If (performOverwrite=1 && thisFileExists=1)
      {
         jso := GetFileAttributesEx(file2save)
         originalFileInfos := jso.size "|" jso.wtime "|" jso.ctime
         FileSetAttrib, -R, %file2save%
         Sleep, 2
         FileRecycle, %file2save%
         Sleep, 2
         mustPerformOperation := 1
      } Else If (thisFileExists=1)
      {
         skippedFiles++
         Continue
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (UsrCopyMoveOperation=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         updateDates := 1
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
            updateDates := 0
         }

         filezMoved++
         extraMarker := (thisFileExists=1 && performOverwrite=1) ? "*" : ""
         recordUndoFileActs(file2save, resultedFilesList[thisFileIndex, 1], extraMarker, UsrCopyMoveOperation, startZeit, originalFileInfos)
         ; zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
         If (UsrCopyMoveOperation=2)
         {
            resultedFilesList[thisFileIndex, 1] := file2save
            ; resultedFilesList[thisFileIndex, 2] := 1
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(file2rem, file2save, updateDates, resultedFilesList[thisFileIndex, 12])

            updateMainUnfilteredList(thisFileIndex, 1, file2save)
         }
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   setWhileLoopExec(0)
   CurrentSLD := backCurrentSLD
   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         someErrors .= "`nFailed to commit changes to the SQL database"
   }

   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " groupDigits(failedFiles) " files"
   If (failedFolders>0)
      etaTime .= "`nFailed to create " groupDigits(failedFolders) " folders"
   If (skippedFiles>0)
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   watchFolderDetails := ""
   If (UsrCopyMoveOperation=2 && filezMoved>0)
      currentFilesListModified := 1

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (UsrCopyMoveOperation=2)
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " groupDigits(filezMoved) " out of " groupDigits(filesElected) " selected files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " groupDigits(filezMoved) " out of " groupDigits(filesElected) " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   Return 0
}

batchConvert2format(modus:=0) {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50 && modus!="pdf")
   {
      msgInfos := "Are you sure you want to convert " groupDigits(filesElected) " files to the ." rDesireWriteFMT " format ? "
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      If (userActionConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."
      If (OnConvertKeepOriginals!=1)
         msgInfos .= "`n`nThe original files will be ERASED."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
   {
      FileCreateDir, % ResizeDestFolder
      If ErrorLevel
      {
         showTOOLtip("ERROR: Destination folder does not seem to exist or permission denied.`nAn unsuccesful attempt was made to create the destination folder.`nOperation abandoned.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   setImageLoading()
   filesPerCore := calculateCoresRequired(filesElected)
   bonusInfo := (modus="pdf") ? "Preparing files for the PDF: Phase 1`n" : ""
   showTOOLtip(bonusInfo "Converting to ." rDesireWriteFMT " format " groupDigits(filesElected) " files, please wait")
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (convertFormatUseMultiThreads=1 && systemCores>1 && filesPerCore>=2) ? 1 : 0
   If (mustDoMultiCore=1 && modus!="pdf")
   {
      setPriorityThread(-2)
      addJournalEntry("Preparing " systemCores " threads to start. " filesPerCore " files per thread.")
      infoResult := WorkLoadMultiCoresConvertFormat(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("JPEG lossless processing: failed to initialize multi-threaded processing")

   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   If (ResizeUseDestDir=1 && userPrivateMode!=1)
      destInfo := "`nDestination folder:`n" PathCompact(ResizeDestFolder, 50)

   doStartLongOpDance()
   initFIMGmodule()
   skipDeadFiles := theseFailures := failedFiles := countTFilez := filesConverted := 0
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   CurrentSLD := ""
   nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to convert " groupDigits(failedFiles) " files"
         If (theseFailures>0)
            etaTime .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
         If (skippedFiles>0)
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip(bonusInfo "Converting to ." rDesireWriteFMT " format, please wait" destInfo etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (InStr(imgPath, "||") || !imgPath)
      {
         skippedFiles++
         Continue
      }

      If (filesConverted>=maxMultiPagesAllowed && modus="pdf")
      {
         SoundBeep 300, 100
         Break
      }

      countTFilez++
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := (modus="pdf") ? destImgPath "\" thisFileIndex "." rDesireWriteFMT : destImgPath "\" OutNameNoExt "." rDesireWriteFMT
      isSameFormat := RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") ? 1 : 0
      If (isSameFormat=1 && convertFormatAutoSkip=1 && modus!="pdf")
      {
         If (ResizeUseDestDir=1)
         {
            ; if the user defined destination format is the same with the initial file format
            ; perform only a move file, ONLY IF ResizeUseDestDir=1 and convertFormatAutoSkip=1
            If (FileExist(file2save) && !FolderExist(file2save) && modus!="pdf")
               file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

            If (file2save="abort")
            {
               abandonAll := 1
               Break
            } Else If file2save
            {
               originalMtime := ""
               FileGetTime, originalMtime, % imgPath, M
               FileGetTime, originalCtime, % imgPath, C
               If (OnConvertKeepOriginals=1)
                  FileCopy, % imgPath, % file2save, 1
               Else
                  FileMove, % imgPath, % file2save, 1

               If !ErrorLevel
               {
                  filesConverted++
                  If (OnConvertKeepOriginals=0 && file2save!=imgPath)
                  {
                     currentFilesListModified := 1
                     resultedFilesList[thisFileIndex, 1] := file2save
                     updateMainUnfilteredList(thisFileIndex, 1, file2save)
                     If (SLDtypeLoaded=3)
                        updateSQLdbEntry(imgPath, file2save, 1, resultedFilesList[thisFileIndex, 12])
                  }

                  If originalMtime
                  {
                     FileSetTime, % originalMtime, % file2save, M
                     FileSetTime, % originalCtime, % file2save, C
                  }
               } Else failedFiles++
            } Else skippedFiles++
            Continue
         } Else
         {
            skippedFiles++
            Continue
         }
      }

      of := file2save
      If (FileExist(file2save) && !FolderExist(file2save) && modus!="pdf")
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If (file2save="abort")
      {
         abandonAll := 1
         Break
      } Else If !file2save
      {
         If (ResizeUseDestDir!=1 && convertFormatAutoSkip=0 && isSameFormat=1)
         {
            file2save := of
         } Else
         {
            skippedFiles++
            Continue
         }
      }

      changeMcursor()
      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         filesConverted++

      If (OnConvertKeepOriginals=0 && !r && modus!="pdf" && imgPath!=file2save)
      {
         FileSetAttrib, -R, % imgPath
         Sleep, 2
         FileRecycle, % imgPath
         If ErrorLevel
            theseFailures++

         currentFilesListModified := 1
         resultedFilesList[thisFileIndex, 1] := file2save
         ; resultedFilesList[thisFileIndex, 2] := 1
         updateMainUnfilteredList(thisFileIndex, 1, file2save)
         If (SLDtypeLoaded=3)
            updateSQLdbEntry(imgPath, file2save, 1, resultedFilesList[thisFileIndex, 12])
      }
   }

   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         throwSQLqueryDBerror(A_ThisFunc)
   }

   someErrors := "`nElapsed time: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
   If (failedFiles>0)
      someErrors .= "`nFailed to convert " groupDigits(failedFiles) " files"
   If (theseFailures>0)
      someErrors .= "`nUnable to remove " groupDigits(theseFailures) " original files after conversion"
   If (skippedFiles>0)
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files were converted to ." rDesireWriteFMT " until now" someErrors)
   Else
      showTOOLtip("Finished converting to ." rDesireWriteFMT " format`n" groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return (abandonAll=1) ? -2 : filesConverted
}

FIMalphaChannelFix(alphaBitmap, hFIFimgE) {
   hFIFimgXu := FreeImage_ConvertTo(alphaBitmap, "Greyscale")
   eRR := FreeImage_GetHistogram(hFIFimgXu, 5, histoArray)
   mustInvert := eRR
   Loop, 256
   {
      If (histoArray[A_Index - 1]>5 && A_Index>2)
         mustInvert := 0
   }

   HasAlpha := 0
   Loop, 256
   {
      If (histoArray[A_Index - 1]>5 && isInRange(A_Index, 3, 254))
         HasAlpha := 1
   }

   ; ToolTip, %  eRR " - " mustInvert  " / " HasAlpha , , , 2
   If (mustInvert=1)
   {
      FreeImage_Invert(hFIFimgXu)
      FreeImage_SetChannel(hFIFimgE, hFIFimgXu, 4)
   }

   FreeImage_UnLoad(hFIFimgXu)
   FreeImage_UnLoad(alphaBitmap)
   Return HasAlpha
}

FIMrescaleOBJbmp(hFIFimgC, imgW, imgH, indexu, sizesDesired) {
   forceW := sizesDesired[indexu, 1]
   forceH := sizesDesired[indexu, 2]
   If (forceW>1 && forceH>1 && noBPPconv=0 && noBMP=0)
   {
      changeMcursor()
      keepAratio := sizesDesired[indexu, 3]
      ScaleAnySize := sizesDesired[indexu, 4]
      thisImgQuality := (sizesDesired[indexu, 5]=6) ? 1 : 0
      doFlipu := sizesDesired[indexu, 6]
      If (imgW>forceW || imgH>forceH || ScaleAnySize=1)
      {
         If (keepAratio=1)
         {
            calcIMGdimensions(imgW, imgH, forceW, forceH, xForceW, xForceH)
            hFIFimgX := FreeImage_Rescale(hFIFimgC, xForceW, xForceH, thisImgQuality)
         } Else
            hFIFimgX := FreeImage_Rescale(hFIFimgC, forceW, forceH, thisImgQuality)

         If (doFlipu=4)
            hFIFimgX := FreeImage_FlipHorizontal(hFIFimgX)
         Else If (doFlipu=4)
            hFIFimgX := FreeImage_FlipVertical(hFIFimgX)
      } 
   }

   Return hFIFimgX
}

FIMdecideLoadArgs(imgPath, qualityRaw, ByRef GFT) {
   loadArgs := 0
   GFT := FreeImage_GetFileType(imgPath)
   If (GFT=34 && loadArgs=0 && RegExMatch(imgPath, "i)(.\.(dng))$"))
      loadArgs := (qualityRaw=1) ? 0 : 2
   Else If (GFT=34)
      loadArgs := (qualityRaw=1) ? 0 : 1
   Else If (GFT=2)
      loadArgs := 8
   Return loadArgs
}

FIMapplyToneMapper(hFIFimgA, GFT, imgBPP, ColorsType, externCondition, ByRef hasAppliedToneMap) {
   hasAppliedToneMap := ""
   thisAllow := (isVarEqualTo(GFT, 32, 26, 29) && imgBPP>32) ? 1 : allowToneMappingImg
   mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba") && GFT!=13) || (imgBPP>64) ? 1 : 0
   If (mustApplyToneMapping=1 && thisAllow=1 && externCondition=1)
   {
      ; setWindowTitle("Applying adaptive logarithmic tone mapping to display high color depth image")
      changeMcursor()
      hFIFimgB := FreeImage_ToneMapping(hFIFimgA, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
      If hFIFimgB
      {
         hasAppliedToneMap := " (TONE-MAPPED)"
         FreeImage_UnLoad(hFIFimgA)
         hFIFimgA := hFIFimgB
      }
   } Else If ((mustApplyToneMapping=1 || isVarEqualTo(GFT, 32, 34, 36, 26, 29)) && imgBPP>32)
      hasAppliedToneMap := " (TONE-MAPPABLE)"

   Return hFIFimgA
}

FIMrescaleICOmode(hFIFimgA, imgW, imgH, icoSize, ByRef hasIconified) {
   hasIconified := 0
   hFIFimgX := FreeImage_ConvertTo(hFIFimgA, "32Bits")
   If hFIFimgX
      newBitmap := FreeImage_Allocate(icoSize, icoSize, 32)

   If (newBitmap && hFIFimgX)
   {
      xpos := clampInRange((icoSize - imgW)//2, 0, icoSize//2)
      ypos := clampInRange((icoSize - imgH)//2, 0, icoSize//2)
      zz := FreeImage_Paste(newBitmap, hFIFimgX, xpos, ypos, 255)
      If zz
      {
         hasIconified := 1
         FreeImage_UnLoad(hFIFimgA)
         hFIFimgA := newBitmap
      }
   }

   If hFIFimgX
      FreeImage_UnLoad(hFIFimgX)

   Return hFIFimgA
}

coreConvertImgFormat(imgPath, file2save, externBMP:=0) {
  Static gifOPT := "-s8-f1-",            ppmOPT := "-s24-f1-f9-"
       , jngOPT := "-s24-f1-",           xpmOPT := "-s24-f1-"
       , jpegOPT := "-s24-s8-f1-",       hdrOPT := "-f11-"
       , webpOPT := "-s32-s24-f1-",      exrOPT := "-f6-f11-f12-"
       , pfmOPT := "-f6-f11-",           icoOPT := "-s32-s24-s16-s8-s4-f1-"
       , pngOPT := "-s32-s24-s8-s4-f1-f2-f9-f10-"
       , tiffOPT := "-s32-s24-s8-s4-f1-f2-f3-f4-f5-f6-f7-f8-f9-f10-f11-f12-"
       , jxrOPT := "-s32-s24-s16-*s8-f1-f2-f6-f9-f10-f11-f12-"
       , bmpOPT := "-s32-s24-s16-s8-s4-f1-"
       , targaOPT := "-s32-s24-*s16-s8-f1-"
       , jp2OPT := "-s32-s24-*s8-f1-f2-f9-f10-"
       , j2kOPT := "-s32-s24-*s8-f1-f2-f9-f10-"

   If (PreserveDateTimeOnSave=1 && !externBMP)
   {
      FileGetTime, originalMtime, % imgPath, M
      FileGetTime, originalCtime, % imgPath, C
   }

   loadArgs := FIMdecideLoadArgs(imgPath, userHQraw, GFT)
   hFIFimgA := externBMP ? externBMP : FreeImage_Load(imgPath, -1, loadArgs)
   If !hFIFimgA
   {
      If (RegExMatch(imgPath, RegExWICfmtPtrn) && WICmoduleHasInit=1 && allowWICloader=1)
      {
         oBitmap := LoadWICimage(imgPath, 0, 0)
         If validBMP(oBitmap)
         {
            hFIFimgA := ConvertPBITMAPtoFIM(oBitmap)
            trGdip_DisposeImage(oBitmap)
         }
      }
   }

   FreeImage_GetImageDimensions(hFIFimgA, oImgW, oImgH)
   If (!hFIFimgA || !oImgW || !oImgH)
   {
      If hFIFimgA
         FreeImage_UnLoad(hFIFimgA)

      addJournalEntry("Failed to load file with FreeImage:`n" imgPath)
      Return -1
   }

   noDepthConvert := 0
   typu := FreeImage_GetFileType(file2save, 1)
   formatDepths := %typu%OPT
   imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
   ColorsType := FreeImage_GetColorType(hFIFimgA)
   imgType := FreeImage_GetImageType(hFIFimgA, 1)
   imgIDtype := FreeImage_GetImageType(hFIFimgA)
   hdrMode := 0
   If (InStr(formatDepths, "-f" imgIDtype "-") && imgIDtype>1)
   {
      ; prevent tone-mapping HDR formats when destination can handle it
      noDepthConvert := 1
   } Else If (varContains(formatDepths, "-f9-", "-f10-", "-f11-", "-f12-") && imgIDtype>=9)
   {
      noDepthConvert := 1
      If (imgIDtype=9 || isVarEqualTo(typu, "hdr", "pfm"))
         hdrMode := "RGBF"   ; 11
      Else If (imgIDtype=10)
         hdrMode := InStr(formatDepths, "-f12-") ? "RGBAF" : "RGBF"  ; 12
      Else If (imgIDtype=11)
         hdrMode := "RGB16"  ; 9
      Else If (imgIDtype=12)
         hdrMode := InStr(formatDepths, "-f10-") ? "RGBA16": "RGB16" ; 10
   }

   hFIFimgA := FIMapplyToneMapper(hFIFimgA, GFT, imgBPP, ColorsType, !noDepthConvert, hasAppliedToneMap)
   If (FileExist(file2save) && hFIFimgA)
   {
      Try FileSetAttrib, -R, % file2save
      Sleep, 1
      FileMove, % file2save, % file2save "-tmp"
      If !ErrorLevel
         tempFileExists := 1

      Sleep, 1
   }

   imgW := oImgW, imgH := oImgH
   saveArg := getFIMsaveArgs(file2save)
   capIMGdimensionsFormatlimits(typu, 1, imgW, imgH)
   If (imgW!=oImgW || imgH!=oImgH)
   {
      hasResized := 1
      resizeFilter := (ResizeQualityHigh=1) ? 4 : 0
      hFIFimgX := FreeImage_Rescale(hFIFimgA, imgW, imgH, resizeFilter)
      If hFIFimgX
      {
         FreeImage_UnLoad(hFIFimgA)
         hFIFimgA := hFIFimgX
      }

      If (typu="ico")
         hFIFimgA := FIMrescaleICOmode(hFIFimgA, imgW, imgH, 256, hasIconified)
   }

   ColorsType := FreeImage_GetColorType(hFIFimgA)
   If (GFT=0 && InStr(ColorsType, "rgba"))
   {
      alphaBitmap := FreeImage_GetChannel(hFIFimgA, 4)
      If alphaBitmap
         FIMalphaChannelFix(alphaBitmap, hFIFimgA)
   }

   r := "w"
   objDepth := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
   ; MsgBox, % objDepth "|" userGivenDepth "|" typu
   highestDepth := Trim(formatDepths, "-")
   highestDepth := SubStr(highestDepth, 2, InStr(highestDepth, "-") - 1)
   objDepthOkay := InStr(formatDepths, "-s" objDepth "-") ? 1 : 0
   If (objDepthOkay=1 || noDepthConvert=1)
   {
      savedMode := 1
      savedMode := "OKAY"
      changeMcursor()
      ; ToolTip, % formatDepths "`n" hdrMode , , , 2
      If (hdrMode)
      {
         hFIFimgB := FreeImage_ConvertTo(hFIFimgA, hdrMode)
         If hFIFimgB
         {
            r := FreeImage_Save(hFIFimgB, file2save)
            FreeImage_UnLoad(hFIFimgB)
         }
      } Else
         r := FreeImage_Save(hFIFimgA, file2save, saveArg)
   }

   If (!r || r="w")
   {
      r := 0
      changeMcursor()
      If (typu="gif")
      {
         savedMode := "GIF"
         hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")
         If hFIFimgB
            hFIFimgX := FreeImage_ColorQuantize(hFIFimgB)

         If hFIFimgX
         {
            r := FreeImage_Save(hFIFimgX, file2save, saveArg)
            FreeImage_UnLoad(hFIFimgX)
         }
         If hFIFimgB
            FreeImage_UnLoad(hFIFimgB)
      } Else If (!InStr(ColorsType, "rgba") && InStr(formatDepths, "-s24-") || isVarEqualTo(typu, "jpeg", "ppm", "jng", "xpm"))
      {
         savedMode := "24Bits"
         hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")
         If hFIFimgB
         {
            r := FreeImage_Save(hFIFimgB, file2save, saveArg)
            FreeImage_UnLoad(hFIFimgB)
         }
      } Else If (InStr(formatDepths, "-s32-"))
      {
         savedMode := "32bits"
         hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "32Bits")
         If hFIFimgB
         {
            r := FreeImage_Save(hFIFimgB, file2save, saveArg)
            FreeImage_UnLoad(hFIFimgB)
         }
      }
   }

   ; FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
   ; fnOutputDebug(hasIconified "|" hasResized "|" imgW "|" imgH "|" objDepthOkay "|" noDepthConvert "| conversion mode = " savedMode)
   FreeImage_UnLoad(hFIFimgA)
   If (!r && tempFileExists=1) || (!FileRexists(file2save, 0) && tempFileExists=1)
   {
      r := 0
      FileDelete, % file2save
      Sleep, 1
      FileMove, % file2save "-tmp", % file2save
   } Else If (tempFileExists=1)
      FileDelete, % file2save "-tmp"

   r := !r
   If (PreserveDateTimeOnSave=1 && !r && originalMtime && !externBMP)
   {
      FileSetTime, % originalMtime, % file2save, M
      FileSetTime, % originalCtime, % file2save, C
      ; fnOutputDebug("original date ... set")
   }
   ; fnOutputDebug(r "= has convert: " imgPath)
   Return r
}

getFIMsaveArgs(file2save) {
   saveArg := 0
   If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
      saveArg := clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
   Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
      saveArg := clampInRange(Round(userJpegQuality), 1, 100)
   Else If RegExMatch(file2save, "i)(.\.bmp)$")
      saveArg := 1 ; RLE compression
   Else If RegExMatch(file2save, "i)(.\.(tga|targa))$")
      saveArg := 2 ; RLE compression

   Return saveArg
}

convert2format(givenIndex) {
  Critical, on
  If (givenIndex=0)
     Return "err"

  If (slideShowRunning=1)
     ToggleSlideShowu()

  file2rem := getIDimage(givenIndex)
  If (RegExMatch(file2rem, "i)(.\.(" rDesireWriteFMT "))$") && convertFormatAutoSkip=1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "The image file seems to be already in the given file format: ." rDesireWriteFMT ". Please choose another format.", 0, 0, "exclamation")
     Return "err"
  }

  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If (FileExist(file2save) && convertFormatAutoSkip=1)
  {
     ToolTip
     zPlitPath(file2save, 0, OutFileName, OutDir)
     msgResult := msgBoxWrapper(appTitle ": Confirmation", "A file with the same name already exists in the destination folder... Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
     forceOverwrite := (msgResult="Yes") ? 1 : 0
     If !forceOverwrite
     {
        SetTimer, ResetImgLoadStatus, -150
        Return
     }
  }

  BtnCloseWindow()
  destroyGDIfileCache()
  Sleep, 1
  changeMcursor()
  setImageLoading()
  showTOOLtip("Converting image file, please wait")
  If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
     FileCreateDir, % ResizeDestFolder

  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If FileExist(file2save)
     FileSetAttrib, -R, %file2save%

  changeMcursor()
  r := coreConvertImgFormat(file2rem, file2save)
  SetTimer, ResetImgLoadStatus, -50
  FileGetSize, OutputVar, % file2save
  If (OutputVar>2 && !r)
     friendly := "`nFile size: " fileSizeFriendly(OutputVar)
 
  If r
     showTOOLtip("Failed to convert file`n" OutFileName "`n" OutDir "\")
  Else
     showTOOLtip("File converted succesfully to ." rDesireWriteFMT "`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\" friendly)

  SoundBeep, % r ? 300 : 900, 100
  If (OnConvertKeepOriginals!=1 && !r && file2rem!=file2save)
  {
     currentFilesListModified := 1
     Try FileSetAttrib, -R, %file2rem%
     Sleep, 1
     FileRecycle, %file2rem%
     If ErrorLevel
        showTOOLtip("Failed to remove original file, however the file was converted succesfully to ." rDesireWriteFMT "`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\")

     resultedFilesList[givenIndex, 1] := file2save
     resultedFilesList[givenIndex, 4] := 1
     If (SLDtypeLoaded=3)
        updateSQLdbEntry(file2rem, file2save, 1, resultedFilesList[givenIndex, 12])

     updateMainUnfilteredList(givenIndex, 1, file2save)
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
  SetTimer, ResetImgLoadStatus, -150
}

batchExtractFramesFromImages() {
   filesElected := getSelectedFiles(0, 1)
   showTOOLtip("Extracting frames from " groupDigits(filesElected) " files, please wait")
   prevMSGdisplay := A_TickCount
   tFramFailed := tFrames := failedFiles := countFilez := countTFilez := 0
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   prevMSGdisplay := 1
   startOperation := A_TickCount
   doStartLongOpDance()
   CurrentSLD := ""
   nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If (InStr(imgPath, "||") || !imgPath)
         Continue
 
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         percF := Round((1 - tFramFailed / tFrames) * 100, 1)
         thisFramesInfo := "`nFrames extracted: " groupDigits(tFrames - tFramFailed) " / " groupDigits(tFrames) " ( " percF "% )"
         If (failedFiles>0)
            etaTime .= "`nFor " groupDigits(failedFiles) " files, the operations failed"
         If (skippedFiles>0)
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip("Extracting frames from the images, please wait" thisFramesInfo etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      If !RegExMatch(imgPath, "i)(.\.(gif|tif|tiff|webp))$")
      {
         skippedFiles++
         Continue
      }

      percS := Round((countTFilez / filesElected) * 100, 1)
      bonusMsg := "`nTotal files: " groupDigits(countTFilez) " / " groupDigits(filesElected) " ( " percS "% ) "
      r := coreExtractFramesFromImage(thisFileIndex, 1, prevMSGdisplay, bonusMsg, failedFrames)
      If (r>1)
      {
         tFrames += r
         tFramFailed += failedFrames
      }

      If (r=-4)
         failedFiles++
      Else If (r=-3)
         skippedFiles++
      Else If (r=-2)
         skippedFiles++
      Else If (r>1)
         countFilez++
      Else 
         failedFiles++
   }

   CurrentSLD := backCurrentSLD
   percF := Round((1 - tFramFailed / tFrames) * 100, 1)
   someErrors := "`nFrames extracted: " groupDigits(tFrames - tFramFailed) " / " groupDigits(tFrames) " ( " percF "% )"
   If (failedFiles>0)
      someErrors .= "`nFor " groupDigits(failedFiles) " files, the operations failed"
   If (skippedFiles>0)
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip(groupDigits(countFilez) " out of " groupDigits(countTFilez) " selected files were processed" someErrors)

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return
}

coreExtractFramesFromTiff(imgPath, inLoop, prevMSGdisplay, bonusMsg, ByRef failedFrames) {
   abandonAll := yay := 0
   GFT := FreeImage_GetFileType(imgPath)
   hMultiBMP := FreeImage_OpenMultiBitmap(imgPath, GFT, 0, 1, 1, 0)
   If StrLen(hMultiBMP)>1
   {
      hasOpenedMulti := 1
      tFrames := FreeImage_GetPageCount(hMultiBMP)
      If (tFrames<0 || !tFrames)
      {
         tFrames := 0
         FreeImage_CloseMultiBitmap(hMultiBMP, 0)
         Return -2
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt)
      If (inLoop!=1)
      {
         showTOOLtip("Extracting " groupDigits(tFrames) " frames from:`n" OutFileName)
         doStartLongOpDance()
      }

      Loop, % tFrames
      {
         file2save := ResizeDestFolder "\" OutNameNoExt "_" A_Index "." saveImgFormatsList[userExtractFramesFmt]
         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         If ((A_TickCount - prevMSGdisplay>3000) && inLoop=1 && yay=1)
            showTOOLtip("Extracting frames: " groupDigits(A_Index) " / " groupDigits(tFrames) " ( " Round((A_Index / tFrames) * 100, 1) "% )" bonusMsg "`nCurrent file:`n" OutFileName, 0, 0, A_Index / tFrames)

         yay := !yay
         If (FileExist(file2save) && !FolderExist(file2save))
            file2save := askAboutFileCollision(imgPath, file2save, 1, 0, OnExtractConflictOverwrite, performOverwrite)

         If (file2save="abort")
         {
            abandonAll := 1
            Break
         } Else If !file2save
            Continue

         frameu := clampInRange(A_Index, 0, tFrames - 1)
         hPage := FreeImage_LockPage(hMultiBMP, frameu)
         ; msgbox, % a_thisfunc "=" totalFramesIndex "==" desiredFrameIndex
         If (hPage!="")
         {
            hFIFimgA := FreeImage_Clone(hPage)
            FreeImage_UnlockPage(hMultiBMP, hPage, 0)
         } Else hFIFimgA := ""

         If !hFIFimgA
         {
            failedFrames++
            Continue
         }

         FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
         If (!imgW || !imgH)
         {
            FreeImage_UnLoad(hFIFimgA)
            failedFrames++
            Continue
         }

         If isImgSizeTooLarge(imgW, imgH, saveImgFormatsList[userExtractFramesFmt])
         {
            capIMGdimensionsFormatlimits(saveImgFormatsList[userExtractFramesFmt], 1, imgW, imgH)
            hFIFimgB := FreeImage_Rescale(hFIFimgA, imgW, imgH)
            If hFIFimgB
            {
               rz := coreConvertImgFormat(imgPath, file2save, hFIFimgB)
            } Else
            {
               rz := "err"
               FreeImage_UnLoad(hFIFimgA)
            }
         } Else rz := coreConvertImgFormat(imgPath, file2save, hFIFimgA)

         ; FreeImage_UnLoad(hFIFimgA) object discarded by coreConvertImgFormat()
         If rz
            failedFrames++
      }

      ; ToolTip, % hasMultiTrans "==" frameu "==" frameu , , , 2
      FreeImage_CloseMultiBitmap(hMultiBMP, 0)
      If (inLoop!=1)
         ResetImgLoadStatus()

      Return (abandonAll=1) ? -5 : clampInRange(tFrames, 0, 9892899)
   } Else Return -1
}

coreExtractFramesFromWEBP(imgPath, inLoop, prevMSGdisplay, bonusMsg, ByRef failedFrames) {
   thisImgQuality := (userimgQuality=1) ? 6 : 5
   sizesDesired := []
   sizesDesired[1] := [32750, 32750, 1, 0, thisImgQuality]
   oBitmap := LoadWICimage(imgPath, 0, 0, sizesDesired)
   tFrames := mainLoadedIMGdetails.Frames
   If !validBMP(oBitmap)
      Return -4

   If (tFrames<0 || !tFrames)
   {
      trGdip_DisposeImage(oBitmap)
      Return -2
   }

   abandonAll := yay := 0
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt)
   file2save := ResizeDestFolder "\" OutNameNoExt "_0." dialogSaveIndexes[userExtractFramesFmt]
   QPV_SaveImageFile(A_ThisFunc, oBitmap, file2save, userJpegQuality, userSaveBitsDepth)
   trGdip_DisposeImage(oBitmap)
   If (inLoop!=1)
   {
      showTOOLtip("Extracting " groupDigits(tFrames) " frames from:`n" OutFileName)
      doStartLongOpDance()
   }

   Loop, % tFrames
   {
      If (A_Index=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
      If ((A_TickCount - prevMSGdisplay>3000) && inLoop=1 && yay=1)
         showTOOLtip("Extracting frames: " groupDigits(A_Index) " / " groupDigits(tFrames) " ( " Round((A_Index / tFrames) * 100, 1) "% )" bonusMsg "`nCurrent file:`n" OutFileName, 0, 0, A_Index / tFrames)

      yay := !yay
      file2save := ResizeDestFolder "\" OutNameNoExt "_" A_Index "." saveImgFormatsList[userExtractFramesFmt]
      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, OnExtractConflictOverwrite, performOverwrite)

      If (file2save="abort")
      {
         abandonAll := 1
         Break
      } Else If !file2save
         Continue

      nBitmap := LoadWICimage(imgPath, 0, A_Index - 1, sizesDesired)
      If !validBMP(nBitmap)
      {
         failedFrames++
         Continue
      }

      trGdip_GetImageDimensions(nBitmap, imgW, imgH)
      If isImgSizeTooLarge(imgW, imgH, saveImgFormatsList[userExtractFramesFmt])
      {
         capIMGdimensionsFormatlimits(saveImgFormatsList[userExtractFramesFmt], 1, imgW, imgH)
         kBitmap := trGdip_ResizeBitmap(A_ThisFunc, nBitmap, imgW, imgH, 1)
         If validBMP(kBitmap)
         {
            r := QPV_SaveImageFile(A_ThisFunc, kBitmap, file2save, userJpegQuality, userSaveBitsDepth)
            trGdip_DisposeImage(kBitmap)
         } Else r := 1
      } Else r := QPV_SaveImageFile(A_ThisFunc, nBitmap, file2save, userJpegQuality, userSaveBitsDepth)

      If r
         failedFrames++

      trGdip_DisposeImage(nBitmap)
   }
   If (inLoop!=1)
      ResetImgLoadStatus()
   Return (abandonAll=1) ? -5 : clampInRange(tFrames, 0, 9892899)
}

coreExtractFramesFromImage(indexu, inLoop, prevMSGdisplay, bonusMsg, ByRef failedFrames) {
   yay := failedFrames := 0
   imgPath := isNumber(indexu) ? resultedFilesList[indexu, 1] : indexu
   If RegExMatch(imgPath, "i)(.\.webp)$")
   {
      r := coreExtractFramesFromWEBP(imgPath, inLoop, prevMSGdisplay, bonusMsg, thisu)
      failedFrames := thisu
      Return r
   } Else If (RegExMatch(imgPath, "i)(.\.(tif|tiff))$") && wasInitFIMlib=1 && allowFIMloader=1)
   {
      r := coreExtractFramesFromTiff(imgPath, inLoop, prevMSGdisplay, bonusMsg, thisu)
      failedFrames := thisu
      Return r
   } Else 
   {
      oBitmap := trGdip_CreateBitmapFromFile(A_ThisFunc, imgPath)
      If !validBMP(oBitmap)
         Return -4

      rawFmt := Gdip_GetImageRawFormat(oBitmap)
   }

   If RegExMatch(rawFmt, "i)(gif|tiff)$")
   {
      tFrames := Gdip_GetBitmapFramesCount(oBitmap) - 1
      If (tFrames<0 || !tFrames)
      {
         trGdip_DisposeImage(oBitmap)
         Return -2
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt)
      If (inLoop!=1)
      {
         showTOOLtip("Extracting " groupDigits(tFrames) " frames from:`n" OutFileName)
         doStartLongOpDance()
      } 

      Loop, % tFrames
      {
         file2save := ResizeDestFolder "\" OutNameNoExt "_" A_Index "." saveImgFormatsList[userExtractFramesFmt]
         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         If ((A_TickCount - prevMSGdisplay>3000) && inLoop=1 && yay=1)
            showTOOLtip("Extracting frames: " groupDigits(A_Index) " / " groupDigits(tFrames) " ( " Round((A_Index / tFrames) * 100, 1) "% )" bonusMsg "`nCurrent file:`n" OutFileName, 0, 0, A_Index / tFrames)

         yay := !yay
         If (FileExist(file2save) && !FolderExist(file2save))
            file2save := askAboutFileCollision(imgPath, file2save, 1, 0, OnExtractConflictOverwrite, performOverwrite)

         If (file2save="abort")
         {
            abandonAll := 1
            Break
         } Else If !file2save
            Continue

         Gdip_BitmapSelectActiveFrame(oBitmap, A_Index)
         trGdip_GetImageDimensions(oBitmap, imgW, imgH)
         nBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH)
         If !validBMP(nBitmap)
         {
            failedFrames++
            Continue
         }

         Gu := trGdip_GraphicsFromImage(A_ThisFunc, nBitmap)
         If !Gu
         {
            trGdip_DisposeImage(nBitmap)
            failedFrames++
            Continue
         }

         trGdip_DrawImage(A_ThisFunc, Gu, oBitmap)
         Gdip_DeleteGraphics(Gu)
         trGdip_GetImageDimensions(nBitmap, imgW, imgH)
         If isImgSizeTooLarge(imgW, imgH, saveImgFormatsList[userExtractFramesFmt])
         {
            capIMGdimensionsFormatlimits(saveImgFormatsList[userExtractFramesFmt], 1, imgW, imgH)
            kBitmap := trGdip_ResizeBitmap(A_ThisFunc, nBitmap, imgW, imgH, 1)
            If validBMP(kBitmap)
            {
               r := QPV_SaveImageFile(A_ThisFunc, kBitmap, file2save, userJpegQuality, userSaveBitsDepth)
               trGdip_DisposeImage(kBitmap)
            } Else r := 1
         } Else r := QPV_SaveImageFile(A_ThisFunc, nBitmap, file2save, userJpegQuality, userSaveBitsDepth)

         trGdip_DisposeImage(nBitmap)
         If r
            failedFrames++
      }

      If (inLoop!=1)
         ResetImgLoadStatus()

      trGdip_DisposeImage(oBitmap)
      Return (abandonAll=1) ? -5 : clampInRange(tFrames, 0, 9892899)
   } Else
   {
      trGdip_DisposeImage(oBitmap)
      Return -3
   }
}

combineImagesMultiTiffGDIp(destFilePath) {
   Static EncoderParameterValueTypeLong := 4
        , EncoderValueFrameDimensionPage := 23
        , EncoderValueMultiFrame := 18
        , EncoderValueFlush := 20
   ; inspiration: https://senapi.blogspot.com/2010/04/creating-multi-page-tiff-vc-gdi.html
   ; https://docs.microsoft.com/en-us/windows/win32/gdiplus/-gdiplus-creating-and-saving-a-multiple-frame-image-use

   zPlitPath(destFilePath, 0, OutFileName, OutDir)
   ; fnOutputDebug("file=" OutFileName "|" OutDir)
   If !FolderExist(OutDir)
   {
      FileCreateDir, % OutDir
      If ErrorLevel
      {
         showTOOLtip("ERROR: Unable to create destination folder of the multipaged file.`nOperation abandoned.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   If FileExist(destFilePath)
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "The destination file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
      If (msgResult="Yes")
      {
         FileSetAttrib, -R, %destFilePath%
         Sleep, 1
         Try FileDelete, %destFilePath%
         Catch wasErrorB
               Sleep, 1

         If wasErrorB
         {
            abandoned := 1
            msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file: " OutFileName ". Permission denied.`n`nLocation:`n" OutDir "\", 0, 0, "error")
            Return
         }
      } Else Return
   }

   filesElected := getSelectedFiles(0, 1)
   rg := Gdip_GetImageEncoder(".tif", pCodec, ci)
   If !pCodec
      rg := Gdip_GetImageEncoder(".tif", pCodec, ci)
   If !pCodec
      rg := Gdip_GetImageEncoder(".tif", pCodec, ci)

   If !pCodec
   {
      showTOOLtip("ERROR: Unable to initialize the .TIFF encoder.`nOperation abandoned.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   tFrames := failedFiles := countTFilez := 0
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   prevMSGdisplay := 1
   startOperation := A_TickCount
   doStartLongOpDance()
   CurrentSLD := ""
   thisBitsDepth := 0
   If (userSaveBitsDepth=1)
      thisBitsDepth := 32
   Else If (userSaveBitsDepth=2)
      thisBitsDepth := 24
   Else If (userSaveBitsDepth=3)
      thisBitsDepth := 16
   Else If (userSaveBitsDepth=4)
      thisBitsDepth := 8

   _p := elem := selectedFiles := 0
   pad := (A_PtrSize=8) ? 4 : 0
   encoderParameters := 0
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1 || abandonAll=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If (InStr(imgPath, "||") || !imgPath)
         Continue

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to embed " groupDigits(failedFiles) " images"

         showTOOLtip("Adding images into the .TIFF file, please wait`n" OutFileName "`nImages embedded: " groupDigits(selectedFiles) etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      ; fnOutputDebug(A_ThisFunc ": " imgPath)
      thisBitmap := LoadBitmapFromFileu(imgPath)
      If !validBMP(thisBitmap)
      {
         failedFiles++
         Continue
      }

      totalFlames := (userCombineSubFrames=1) ? mainLoadedIMGdetails.Frames + 1 : 1
      Loop, % totalFlames
      {
         If (A_Index>1)
         {
            thisBitmap := LoadBitmapFromFileu(imgPath, 0, 0, A_Index - 1)
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }
         }

         If ((A_TickCount - prevMSGdisplay>3000) && yay=1)
         {
            etaTime := ETAinfos(countTFilez, filesElected, startOperation)
            If (failedFiles>0)
               etaTime .= "`nFailed to embed " groupDigits(failedFiles) " images"

            showTOOLtip("Adding images into the .TIFF file, please wait`n" OutFileName "`nImages embedded: " groupDigits(selectedFiles) etaTime, 0, 0, A_Index / totalFlames)
            prevMSGdisplay := A_TickCount
         }

         yay := !yay
         selectedFiles++
         If thisBitsDepth
         {
            pix := Gdip_GetImagePixelFormat(thisBitmap, 2)
            If (SubStr(pix, 1, InStr(pix, "-") - 1)>thisBitsDepth)
               Gdip_BitmapSetColorDepth(thisBitmap, thisBitsDepth, userCombineDepthDithering)
         }

         If (selectedFiles=1)
         {
            multiBitmap := thisBitmap
            nCount := Gdip_GetEncoderParameterList(multiBitmap, pCodec, EncoderParameters)
            If !nCount
            {
               ; SoundBeep 300, 100
               nCount := Gdip_GetEncoderParameterList(multiBitmap, pCodec, EncoderParameters)
            }

            If !nCount
            {
               showTOOLtip("ERROR: Failed to get TIFF encoder properties. Please try again.")
               SoundBeep 300, 100
               fnOutputDebug("paramsCount=" nCount "|pCodec=" pCodec)
               trGdip_DisposeImage(thisBitmap)
               fattalErr := 1
               Break
            }

            Loop, % nCount
            {
               elem := (24+A_PtrSize)*(A_Index-1) + 4 + pad
               If (NumGet(EncoderParameters, elem+16, "UInt") = 1) ; number of values = 1
               && (NumGet(EncoderParameters, elem+20, "UInt") = EncoderParameterValueTypeLong)
               {
                  _p := elem + &EncoderParameters - pad - 4
                  NumPut(EncoderValueMultiFrame, NumGet(NumPut(4, NumPut(1, _p+0)+20, "UInt")), "UInt")
                  Break
               }
            }

            _E := DllCall("gdiplus\GdipSaveImageToFile", "UPtr", multiBitmap, "WStr", destFilePath, "UPtr", pCodec, "uint", _p)
            fnOutputDebug(rg " first img=" _E "p=" _p "; elem=" elem "; nCount=" nCount "; nSize=" nSize "; pCodec=" pCodec)
            If _E
            {
               showTOOLtip("ERROR: Failed to create the multipaged .TIFF file. Error code: " _E)
               SoundBeep 300, 100
               trGdip_DisposeImage(thisBitmap)
               fattalErr := 1
               Break
            }
         } Else
         {
            If (selectedFiles=2)
               NumPut(EncoderValueFrameDimensionPage, NumGet(NumPut(4, NumPut(1, _p+0)+20, "UInt")), "UInt")
   
            If thisBitsDepth
            {
               pix := Gdip_GetImagePixelFormat(thisBitmap, 2)
               If (SubStr(pix, 1, InStr(pix, "-") - 1)>thisBitsDepth)
                  Gdip_BitmapSetColorDepth(thisBitmap, thisBitsDepth, userCombineDepthDithering)
            }

            _E := Gdip_SaveAddImage(multiBitmap, thisBitmap, _p)
            If _E
               failedFiles++
            trGdip_DisposeImage(thisBitmap)
            ; fnOutputDebug("tiff-gdi+:" multiBitmap  " | new=" thisBitmap " | e=" _E " | p=" _p)
         }
      }
      if fattalErr
         Break
   }
 
   NumPut(EncoderValueFlush, NumGet(NumPut(4, NumPut(1, _p+0)+20, "UInt")), "UInt")
   _E := DllCall("gdiplus\GdipSaveAddImage", "UPtr", multiBitmap, "uint", _p)
   ; this call fails, I do not know why; err-code = 2 ; invalid parameter; 
   ; however the file is created succesfully
   ; fnOutputDebug("TIFF end: " _E)
   trGdip_DisposeImage(multiBitmap)
   encoderParameters := ""
   
   If (abandonAll=1)
   {
      showTOOLtip("Operation aborted by user. Multipaged .TIFF file not created.")
      SoundBeep , 900, 100
      FileDelete, % destFilePath
   } Else If (!fattalErr && !abandonAll)
   {
      If (failedFiles>0)
         rr .= "`nFailed to embed " groupDigits(failedFiles) " images.`nFiles selected to embed: " groupDigits(filesElected)

      FileGetSize, OutputVar, % destFilePath
      showTOOLtip("Finished creating the multipaged .TIFF file:`n" OutFileName "`nImages embedded: " groupDigits(selectedFiles) "`nFile size: " fileSizeFriendly(OutputVar) rr)
      SoundBeep , 900, 100
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   ResetImgLoadStatus()
   CurrentSLD := backCurrentSLD
}

combineImagesMultiPage(modus, animus, destFilePath) {
   zPlitPath(destFilePath, 0, OutFileName, OutDir)
   If !FolderExist(OutDir)
   {
      FileCreateDir, % OutDir
      If ErrorLevel
      {
         showTOOLtip("ERROR: Unable to create destination folder of the multipaged file.`nOperation abandoned.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   If (animus=1)
   {
      showTOOLtip("WARNING: Create animated GIF. Experimental feature.`nQPV will likely crash.")
      SoundBeep , 300, 100
      sleep, 3000
   }

   filesElected := getSelectedFiles(0, 1)
   showTOOLtip("Phase 1: Preparing " groupDigits(filesElected) " image files, please wait")
   tFrames := failedFiles := countFilez := countTFilez := 0
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   prevMSGdisplay := 1
   startOperation := A_TickCount
   doStartLongOpDance()
   CurrentSLD := ""
   formatu := (animus=1) ? 25 : 18
   extFile := (animus=1) ? ".gif" : ".tiff"
   imgList := []
   BMPmemSize := 0
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If (InStr(imgPath, "||") || !imgPath)
         Continue
 
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to load " groupDigits(failedFiles) " images"

         showTOOLtip("Phase 1: Preparing images to combine into a " extFile " file, please wait`nMemory usage: " fileSizeFriendly(BMPmemSize) etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      ; fnOutputDebug(A_ThisFunc ": " imgPath)
      r := coreImgCombinerLoadFimFile(imgPath, modus, animus, otherFrames)
      If (r!="")
      {
         If (otherFrames.Count()>0)
         {
            Loop, % otherFrames.Count()
            {
               tFrames++
               If (modus!=5 && animus=0 || animus=1)
                  z := combineImgsConvertDepth(otherFrames[A_Index], modus, animus)
   
               If z
               {
                  BMPmemSize += FreeImage_GetMemorySize(z)
                  FreeImage_UnLoad(otherFrames[A_Index])
                  imgList[tFrames] := z
               } Else
               {
                  BMPmemSize += FreeImage_GetMemorySize(otherFrames[A_Index])
                  imgList[tFrames] := otherFrames[A_Index]
               }
            }
         } Else If (r!="f")
         {
            tFrames++
            BMPmemSize += FreeImage_GetMemorySize(r)
            imgList[tFrames] := r
         }
      } Else
         failedFiles++

      If (tFrames>=maxMultiPagesAllowed || BMPmemSize>maxMemLimitMultiPage)
      {
         SoundBeep , 300, 100
         msgu := (BMPmemSize>maxMemLimitMultiPage) ? "The maximum allowed file size limit was reached: " fileSizeFriendly(maxMemLimitMultiPage) : "The limit of maximum allowed pages was reached: " maxMultiPagesAllowed
         msgResult := msgBoxWrapper(appTitle ": ERROR", msgu ". If you choose to continue, the remaining selected files will be skipped and the multipaged file will be created. It will have " groupDigits(tFrames) " pages.", "&Continue|&Abort", 0, "error")
         If (msgResult="abort")
            abandonAll := 1
         Break
      }
      ; ToolTip, % fileSizeFriendly(BMPmemSize) , , , 2
   }

   CurrentSLD := backCurrentSLD
   If (failedFiles>0)
      someErrors := "`nFailed to load " groupDigits(failedFiles) " images"

   If (abandonAll=1)
   {
      showTOOLtip("Operation aborted. No multipaged image file created.")
      Loop, % tFrames
         FreeImage_UnLoad(imgList[A_Index])
   
      mustEnd := 1
   } Else If (tFrames<2)
   {
      showTOOLtip("ERROR: Failed to load selected images. No multipaged image file created.")
      Loop, % tFrames
         FreeImage_UnLoad(imgList[A_Index])

      mustEnd := 1
   } Else
      showTOOLtip(groupDigits(tFrames) " out of " groupDigits(countTFilez) " selected files were processed" someErrors)

   If (mustEnd=1)
   {
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(100)
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % (mustEnd=1) ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   file2save := destFilePath
   If FileExist(file2save)
   {
      FileDelete, % file2save
      Sleep, 100
   }

   zPlitPath(file2save, 0, OutFileName, OutDir)
   multiFim := FreeImage_OpenMultiBitmap(file2save, formatu, 1, 0)
   dwFrameTime := userCombineGIFframeDelay
   showTOOLtip("Phase 2: Creating the multipaged image: " groupDigits(tFrames) " pages`n" OutFileName)
   bonusList := []
   bonux := 0
   prevMSGdisplay := 1
   startOperation := A_TickCount
   doStartLongOpDance()

   Loop, % tFrames
   {
      i := A_Index
      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(A_Index, tFrames, startOperation)
         showTOOLtip("Phase 2: Adding pages to the multipaged " extFile " image:" etaTime, 0, 0, A_Index / tFrames)
         prevMSGdisplay := A_TickCount
      }

      ; clear any animation metadata used by this dib as we’ll adding our own ones
      g := FreeImage_SetMetadata(imgList[i], NULL, 9, NULL)   ; FIMD_ANIMATION = 9
      ; add animation tags to dib[i]
      If (animus=1)
      {
         tag := FreeImage_CreateTag()
         if tag
         {
            p := FreeImage_SetTagKey(tag, "FrameTime")
            FreeImage_SetTagType(tag, 4)        ; FIDT_LONG = 4
            FreeImage_SetTagCount(tag, 1)
            FreeImage_SetTagLength(tag, 4)
            k := FreeImage_SetTagValue(tag, dwFrameTime)
            h := FreeImage_GetTagKey(tag)
            j := FreeImage_SetMetadata(imgList[i], tag, 9, h)   ; FIMD_ANIMATION = 9
            FreeImage_DeleteTag(tag)
         }
      }

      FreeImage_AppendPage(multiFim, imgList[i])
      ; fnOutputDebug(A_ThisFunc ": " i " | " g "." p "." k "." j "." t "." h " | " imgW " x " imgH)
   }

   z := FreeImage_GetPageCount(multiFim)
   showTOOLtip("Phase 3: Saving multipaged image file: " groupDigits(tFrames) " pages`n" OutFileName)
   ; fnOutputDebug(multiFim "|" z "==" file2save)
   r := FreeImage_CloseMultiBitmap(multiFim, 0)
   ; fnOutputDebug("closed and saved = " r)
   Loop, % tFrames
      FreeImage_UnLoad(imgList[A_Index])

   If (animus=1 && bonux>0)
   {
      Loop, % bonux
         FreeImage_UnLoad(bonusList[A_Index])
   }
   showTOOLtip("Finished creating the multipaged image file: " groupDigits(tFrames) " pages`n" OutFileName "`n" OutDir "\")
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (mustEnd=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ; fnOutputDebug("the end")
}

LoadBitmapAsFreeImage(imgPath, allowHDR, ByRef oImgW, ByRef oImgH, ByRef imgBPP) {
   loadArgs := FIMdecideLoadArgs(imgPath, userHQraw, GFT)
   hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
   If !hFIFimgA
   {
      If (RegExMatch(imgPath, RegExWICfmtPtrn) && WICmoduleHasInit=1 && allowWICloader=1)
      {
         oBitmap := LoadWICimage(imgPath, 0, 0)
         If validBMP(oBitmap)
         {
            hFIFimgA := ConvertPBITMAPtoFIM(oBitmap)
            trGdip_DisposeImage(oBitmap)
         }
      }
   }

   FreeImage_GetImageDimensions(hFIFimgA, oImgW, oImgH)
   If (!hFIFimgA || !oImgW || !oImgH)
   {
      If hFIFimgA
         FreeImage_UnLoad(hFIFimgA)
      addJournalEntry("Failed to load file with FreeImage:`n" imgPath)
      Return
   }

   imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
   ColorsType := FreeImage_GetColorType(hFIFimgA)
   imgType := FreeImage_GetImageType(hFIFimgA, 1)
   imgIDtype := FreeImage_GetImageType(hFIFimgA)
   If (allowHDR=-1)
   {
      hFIFimgA := FIMapplyToneMapper(hFIFimgA, GFT, imgBPP, ColorsType, 1, hasAppliedToneMap)
      imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
      ColorsType := FreeImage_GetColorType(hFIFimgA)
      If (GFT=0 && InStr(ColorsType, "rgba"))
      {
         alphaBitmap := FreeImage_GetChannel(hFIFimgA, 4)
         If (imgBPP!=32)
            hFIFimgD := FreeImage_ConvertTo(hFIFimgA, "32Bits")

         If hFIFimgD
         {
            FreeImage_UnLoad(hFIFimgA)
            hFIFimgA := hFIFimgD
         }

         If (alphaBitmap!="")
            FIMalphaChannelFix(alphaBitmap, hFIFimgA)
      }

      imgBPP := FreeImage_GetBPP(hFIFimgA)
      ColorsType := FreeImage_GetColorType(hFIFimgA)
      If (imgBPP!=24 && imgBPP!=32)
      {
         If InStr(ColorsType, "rgba")
            hFIFimgD := FreeImage_ConvertTo(hFIFimgA, "32Bits")
         Else
            hFIFimgD := FreeImage_ConvertTo(hFIFimgA, "24Bits")

         If hFIFimgD
         {
            FreeImage_UnLoad(hFIFimgA)
            hFIFimgA := hFIFimgD
         } Else
         {
            addJournalEntry(A_ThisFunc "(): Failed to convert imported image to 24/32-bits color depth.")
            FreeImage_UnLoad(hFIFimgA)
            hFIFimgA := ""
         }
      }
   } Else If (allowHDR=0)
      hFIFimgA := FIMapplyToneMapper(hFIFimgA, GFT, imgBPP, ColorsType, 1, hasAppliedToneMap)

   Return hFIFimgA
}

coreImgCombinerLoadFimFile(imgPath, modus, animus, ByRef otherFrames) {
  Critical, on
  sTime := A_TickCount

  loadArgs := FIMdecideLoadArgs(imgPath, userHQraw, GFT)
  multiFlags := (GFT=25) ? 2 : 0
  changeMcursor()
  If (GFT=18 || GFT=25)
     hMultiBMP := FreeImage_OpenMultiBitmap(imgPath, GFT, 0, 1, 1, multiFlags)

  thisIndex := 0
  otherFrames := []
  If StrLen(hMultiBMP)>1
  {
     tFrames := FreeImage_GetPageCount(hMultiBMP)
     If (tFrames<0 || !tFrames)
        tFrames := 0

     If (tFrames>1)
     {
        preventer := 1
        Loop, % tFrames + 1
        {
           frameu := clampInRange(A_Index - 1, 0, tFrames - 1)
           ; fnOutputDebug("fT=" tFrames " | f=" frameu " | " imgPath)
           hPage := FreeImage_LockPage(hMultiBMP, frameu)
           If hPage
           {
              thisIndex++
              otherFrames[thisIndex] := FreeImage_Clone(hPage)
              FreeImage_UnlockPage(hMultiBMP, hPage, 0)
           }
        }
     }

     FreeImage_CloseMultiBitmap(hMultiBMP, 0)
     If (preventer=1)
        Return "f"
  }

  hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs) ; load image
  If !hFIFimgA
  {
     addJournalEntry("Failed to load image file using FreeImage library: " imgPath)
     Return
  }

  If (hFIFimgA!="")
  {
     imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
     ColorsType := FreeImage_GetColorType(hFIFimgA)
     imgType := FreeImage_GetImageType(hFIFimgA, 1)
     hFIFimgA := FIMapplyToneMapper(hFIFimgA, GFT, imgBPP, ColorsType, 1, hasAppliedToneMap)
     If (modus!=5 && animus=0 || animus=1)
        hFIFimgC := combineImgsConvertDepth(hFIFimgA, modus, animus)

     ; eTime := A_TickCount - sTime
     If hFIFimgC
     {
        FreeImage_UnLoad(hFIFimgA)
        Return hFIFimgC
     } Else Return hFIFimgA
  }
  ; ToolTip, % imgW ", " imgW2,,,2
}

combineImgsConvertDepth(k, modus, animus) {
  imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(k), "-"))
  ; fnOutputDebug("depth=" imgBPPc "| m=" modus "| a=" animus)
  If (imgBPPc!=8 && animus=1)
     hFIFimgC := FreeImage_ColorQuantize(k)
  Else If (imgBPPc!=32 && modus=1)
     hFIFimgC := FreeImage_ConvertTo(k, "32Bits")
  Else If (imgBPPc!=24 && modus=2)
     hFIFimgC := FreeImage_ConvertTo(k, "24Bits")
  Else If (imgBPPc!=16 && modus=3)
     hFIFimgC := FreeImage_ConvertTo(k, "16bits")
  Else If (imgBPPc!=8 && modus=4)
     hFIFimgC := FreeImage_ColorQuantize(k)

  If StrLen(hFIFimgC)>1
     Return hFIFimgC
}

OpenFolders(dummy:=0) {
   If (AnyWindowOpen || imageLoading=1)
      Return

   initQPVmainDLL()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If FolderExist(StrReplace(dummy, "|"))
      SelectedDir := dummy
   Else
      SelectedDir := openFoldersDialogWrapper(prevOpenFolderPath, "Select the folder to open recursively")

   If (SelectedDir)
   {
      SelectedDir := Trimmer(StrReplace(SelectedDir, "\\", "\"), "\")
      If askAboutFileSave(" and another image will be loaded")
         Return

      If askAboutSlidesListSave()
         Return

      If askAboutFilesSelect("discard it")
         Return

      newStaticFoldersListCache := []
      prevOpenFolderPath := StrReplace(SelectedDir, "|")
      INIaction(1, "prevOpenFolderPath", "General")
      coreOpenFolder(SelectedDir, 1, 1, 1)
      If (maxFilesIndex>0)
         SLDtypeLoaded := 1
      ; Else resetMainWin2Welcome()
   }
}

openFoldersDialogWrapper(startPath, msg:="") {
   Static defaultu := "<Use current folder>"
   setWinCloseZeit()
   thisHwnd := (AnyWindowOpen>0) ? hSetWinGui : PVhwnd
   entriesList := defaultu "`n" recentOpenedFolders()
   r := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, entriesList, 1, "History", entriesList)
   If (!InStr(r.SelectedCombo, defaultu) && StrLen(r.SelectedCombo)>3)
      z := r.SelectedCombo
   Else If StrLen(r.SelectedDir)>4
      z := r.SelectedDir

   SetTimer, setWinCloseZeit, -150, 900
   lastLongOperationAbort := A_TickCount
   Return z
}

renewCurrentFilesList() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && mustRecordSeenImgs=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
   }

   RandyIMGnow := -1
   RandyIMGids := []
   resultedFilesList := []
   prevLastImg := []
   reviewSelectedIndexes := []
   markedSelectFile := EntryMarkedMoveIndex := maxFilesIndex := 0
   lastZeitFileSelect := editingSelectionNow := hasHamDistCached := 0
   ForceRefreshNowThumbsList()
   updateUIctrl()
   currentFileIndex := 1
   prevLoadedImageIndex := ""
   currentImgModified := allImagesWereSeen := 0
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   If (forceProtectLoadedImg!=1)
   {
      discardSRCfileCaches()
      destroyGDIfileCache()
      discardViewPortCaches()
      disposeCacheIMGs()
      terminateIMGediting()
   }

   hudBTNfuncu := thisSearchString := userSearchString := ""
   If hSNDmedia
      StopMediaPlaying()
}

FileExploreUpDownLevel(direction, returnObj:=0, ByRef iLevel:=0, forceLevel:=0) {
   Static thisLevel := 0, prevPathArray := []
   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   oldFolder := baseFolder
   initialLevel := thisLevel
   thisFolder := StrReplace(Trimmer(baseFolder), "|")
   prevMaxLevels := prevPathArray.Length()
   If (prevMaxLevels=thisLevel)
   {
      doStartLongOpDance()
      Loop, Files, % thisFolder "\*", DF
      {
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
         {
            thisFolder .= "\" A_LoopFileName
            Break
         }
      }
      If (abandonAll=1)
      {
         ResetImgLoadStatus()
         Return
      }

      If (direction=1)
      {
         Loop, Files, % thisFolder "\*", DF
         {
            If (determineTerminateOperation()=1)
            {
               abandonAll := 1
               Break
            }

            If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
            {
               thisFolder .= "\" A_LoopFileName
               Break
            }
         }
      }
      ResetImgLoadStatus()
      If (abandonAll=1)
         Return
   }

   thisFolder := StrReplace(thisFolder, "\\", "\")
   thisFolder := Trimmer(thisFolder, "\")
   folderPathArray := StrSplit(thisFolder, "\")
   maxLevels := folderPathArray.Length()
   Loop, % maxLevels
   {
        If (folderPathArray[A_Index]!=prevPathArray[A_Index])
        {
           thisLevel := 0
           prevPathArray := folderPathArray.Clone()
           Break
        }
   }

   thisParent := SubStr(oldFolder, InStr(oldFolder, "\", 0, -1) + 1)
   If !thisLevel
   {
      Loop, % maxLevels + 1
      {
           If (folderPathArray[A_Index]=thisParent)
           {
              thisLevel := A_Index
              Break
           }
      }
   }

   oldIndex := currentFileIndex
   prevMaxLevels := prevPathArray.Length()
   If (returnObj=1)
   {
      iLevel := thisLevel
      Return prevPathArray
   }

   If (direction=-1)
      thisLevel := clampInRange(thisLevel - 1, 1, prevMaxLevels)
   Else
      thisLevel := clampInRange(thisLevel + 1, 1, prevMaxLevels)

   If forceLevel
      thisLevel := forceLevel

   Loop, % prevMaxLevels
   {
      newFolder .= prevPathArray[A_Index] "\"
      If (A_Index=thisLevel)
         Break
   }

   newFolder := Trimmer(newFolder, "\")
   If (initialLevel!=thisLevel)
      tryOpenGivenFolder(newFolder, oldFolder)
}

FileExploreSiblingsNav(direction, isInLoop:=0, returnObj:=0, ByRef iLevel:=0, forceLevel:=0) {
   Static thisLevel, prevFolder, subFoldersArray := []
   If (direction="reset")
   {
      prevFolder := thisLevel := ""
      subFoldersArray := []
      Return
   }

   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   initialLevel := thisLevel
   oldFolder := baseFolder
   thisFolder := StrReplace(Trimmer(baseFolder), "|")
   initialSibling := SubStr(thisFolder, InStr(thisFolder, "\", 0, -1) + 1)
   thisFolder := SubStr(thisFolder, 1, InStr(thisFolder, "\", 0, -1) - 1)
   If (thisFolder!=prevFolder)
   {
      subFoldersArray := []
      thisIndex := 0
      prevFolder := thisFolder
      doStartLongOpDance()
      Loop, Files, % thisFolder "\*", DF
      {
         If (determineTerminateOperation()=1)
            Break

         If !InStr(A_LoopFileAttrib, "D")
            Continue

         thisIndex++
         If (A_LoopFileName=initialSibling)
            thisLevel := thisIndex

         If (A_LoopFileName!="")
            subFoldersArray[thisIndex] := A_LoopFileName
      }
      ResetImgLoadStatus()
   }

   oldIndex := currentFileIndex
   maxLevels := subFoldersArray.Count()
   If (maxLevels<2)
   {
      showTOOLtip("No sibling folders found")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (returnObj=1)
   {
      iLevel := thisLevel
      Return subFoldersArray
   }

   If (direction=-1)
      thisLevel := clampInRange(thisLevel - 1, 1, maxLevels, 1)
   Else
      thisLevel := clampInRange(thisLevel + 1, 1, maxLevels, 1)

   If forceLevel
      thisLevel := forceLevel

   If (subFoldersArray[thisLevel]!="")
   {
      newFolder := thisFolder "\" subFoldersArray[thisLevel]
   } Else If (isInLoop<maxLevels)
   {
      isInLoop++
      FileExploreSiblingsNav(direction, isInLoop)
      Return
   } Else
   {
      showTOOLtip("No sibling folders found")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (initialLevel!=thisLevel && FolderExist(newFolder))
   {
      r := tryOpenGivenFolder(newFolder, oldFolder)
      If (r=1)
      {
         subFoldersArray[thisLevel] := ""
         thisLevel := initialLevel
      } Else showDelayedTooltip("Sibling folders navigation: " thisLevel " / " maxLevels "`n.\" subFoldersArray[thisLevel] "\")
   } Else If !FolderExist(newFolder)
   {
      ; subFoldersArray[thisLevel] := ""
      FileExploreSiblingsNav(direction, 1)
   }
}

coreOpenFolder(thisFolder, doOptionals:=1, openFirst:=0, doReset:=0, safeMode:=0) {
   testThis := StrReplace(thisFolder, "|")
   mustOpenStartFolder := ""
   If FolderExist(testThis)
   {
      If ((A_TickCount - scriptStartTime>350) && AnyWindowOpen)
         BtnCloseWindow()

      filesFilter := CurrentSLD := ""
      setWindowTitle("Indexing files, please wait...", 1)
      renewCurrentFilesList()
      ; activeSQLdb.Exec("DELETE FROM images;")
      r := GetFilesList(thisFolder "\*")
      If (maxFilesIndex<1 || !maxFilesIndex) && (safeMode=0)
      {
         If (!CurrentSLD || doReset=1)
            resetMainWin2Welcome()
         Else
            FadeMainWindow()

         showTOOLtip("ERROR: Found no recognized image files in the folder`n" thisFolder "\")
         SoundBeep, 300, 100
         setWindowTitle(appTitle " v" appVersion, 1)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      GenerateRandyList()
      mustGenerateStaticFolders := 1
      DynamicFoldersList := thisFolder "`n"
      CurrentSLD := thisFolder
      watchFolderDetails := ""
      If (safeMode=0)
         RecentFilesManager(CurrentSLD)

      If (r=1)
      {
         clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
         RemoveTooltip()
      } Else SetTimer, RemoveTooltip, % -msgDisplayTime

      If (doOptionals=1)
      {
         If (maxFilesIndex>0 && r!=1)
            RandomPicture()
         Else
            dummyTimerDelayiedImageDisplay(25)
      }
   } Else
   {
      setWindowTitle(appTitle " v" appVersion, 1)
      If (!CurrentSLD || maxFilesIndex<2 || !maxFilesIndex)
         resetMainWin2Welcome()
      Else
         FadeMainWindow()

      showTOOLtip("ERROR: The folder seems to be inexistent`n" testThis "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

addDynamicFolderSQLdb(whichFolder, renewList, whichTable) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM dynamicfolders;")

    folderu := Format("{:L}", StrReplace(whichFolder, "|"))
    If !FolderExist(folderu)
       Return

    FileGetTime, fileMdate, % folderu, M
    SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES ('" SQLescapeStr(whichFolder) "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Return 0
    }
    Return 1
}

addStaticFolderSQLdb(whichFolder, fileMdate, renewList) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM staticfolders;")

    whichFolder := Format("{:L}", whichFolder)
    SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES ('" whichFolder "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Sleep, 0
    }
}

RefreshImageFileAction() {
   isThumbMode := (thumbsDisplaying=1 && maxFilesIndex>1) ? 1 : 0
   ; imgPath := getIDimage(currentFileIndex)
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (thumbsDisplaying!=1)
   {
      If throwErrorNoImageLoaded(0, 0)
         Return

      If InStr(imgPath, "\temporary memory object\")
      {
         showTOOLtip("WARNING: This image is currently unsaved. Unable to refresh object.")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If askAboutFileSave(" and the original file will be reloaded")
         Return

      currentImgModified := 0
      viewportQPVimage.DiscardImage()
      killQPVscreenImgSection()
      discardViewPortCaches()
      terminateIMGediting()
      FlipImgV := FlipImgH := vpIMGrotation := 0
      imgFxMode := 1
      INIaction(1, "IMGresizingMode", "General")
      INIaction(1, "imgFxMode", "General")
      INIaction(1, "FlipImgH", "General")
      INIaction(1, "FlipImgV", "General")
      INIaction(1, "vpIMGrotation", "General")

      r := IDshowImage(currentFileIndex, 3)
      If !r
         informUserFileMissing(1)
      Else If (toolTipGuiCreated!=1)
         showTOOLtip("Image file reloaded")

      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateTempGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   } Else If (thumbsDisplaying=1)
      RefreshFilesList()
}

RefreshImageFile() {
   ; disposeCacheIMGs()
   r := IDshowImage(currentFileIndex, 3)
   If !r
      informUserFileMissing(1)
}

RefreshFilesList() {
  If !CurrentSLD
  {
     showTOOLtip("WARNING: No folder or files list index currently opened")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
  {
     retrieveFavesAsList()
     Return
  } Else If InStr(CurrentSLD, "\QPV\file-acts-history.SLD")
  {
     BTNhistoFileActsList()
     Return
  } Else If InStr(CurrentSLD, "\viewed-images-history-")
  {
     showTOOLtip("The current files list index is: `n" CurrentSLD)
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If RegExMatch(CurrentSLD, sldsPattern)
  {
     If askAboutFileSave(" and the files list will be reloaded")
        Return

     If askAboutSlidesListSave()
        Return

     thisIndex := currentFileIndex
     OpenSLD(CurrentSLD, 1)
     currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
     dummyTimerDelayiedImageDisplay(50)
  } Else If StrLen(CurrentSLD)>3
     RegenerateEntireList()
     ; coreOpenFolder(CurrentSLD)
}

OpenDialogFiles() {
    Static lastInvoked := A_TickCount
    If (AnyWindowOpen || imageLoading=1 || (A_TickCount - lastInvoked<250))
       Return

    lastInvoked := A_TickCount
    initQPVmainDLL()
    If (slideShowRunning=1)
       ToggleSlideShowu()

    pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.sld*)"
    patternObj := fileImgFormatsOpenDialog(1)
    If isWinXP
       FileSelectFile, imgPath, 3, % prevOpenFolderPath, Open Image file, % pattern
    Else
       imgPath := openFileDialogWrapper("O1", "-", prevOpenFolderPath, "Open image or slideshow...", patternObj, chosenOption, 3, "open-folder")

    lastInvoked := A_TickCount
    If !imgPath
       Return

    If !InStr(chosenOption, "instance")
    {
       If askAboutFileSave(" and another image will be loaded")
          Return
    }

   zPlitPath(imgPath, 0, OutFileName, SelectedDir)
   If !FolderExist(SelectedDir)
      SelectedDir := SubStr(SelectedDir, 1, InStr(SelectedDir, "\", 0, -1) - 1)

   ; ToolTip, % SelectedDir , , , 2
   If FolderExist(SelectedDir)
   {
      If InStr(chosenOption, "instance")
      {
         If RegExMatch(imgPath, RegExFilesPattern)
            OpenWithNewQPVinstance(0, imgPath, 2)
         Else
            OpenNewQPVinstance(SelectedDir)
         Return
      }

      newStaticFoldersListCache := []
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      lastInvoked := A_TickCount
      If RegExMatch(imgPath, sldsPattern)
      {
         OpenSLD(imgPath)
         Return
      }

      PopulateIndexFilesStatsInfos("kill")
      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }
 
      doNotRecursive := InStr(chosenOption, "perform") ? "" : "|"
      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath) && InStr(chosenOption, "selected"))
      {
         SLDtypeLoaded := 1
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg
         MenuOpenLastImg(imgPath)
         currentFilesListModified := 0
      } Else 
      {
         coreOpenFolder(doNotRecursive SelectedDir, 0, 0, 1)
         currentFilesListModified := 0
         SlidesMusicSong := ""
         If (doNotRecursive && maxFilesIndex<1)
         {
            msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " SelectedDir "\ to open without recursive scanning. QPV found no supported image files.`n`nWould you like to recursively scan the given folder?", 4, 0, "question")
            If (msgResult="Yes")
               coreOpenFolder(SelectedDir, 0, 0, 1)
         }
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         SlidesMusicSong := ""
         If FileRexists(imgPath)
         {
            currentFileIndex := detectFileID(imgPath)
            If (allowRecordHistory=1)
               IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

            IDshowImage(currentFileIndex)
         } Else If (OutFileName!="")
         {
            FriendlyName := FileExist(imgPath) ? "malformed" : "inexistent"
            msgBoxWrapper(appTitle ": ERROR", "Error opening file: " OutFileName ". It seems to be " FriendlyName " .`n`nAnother file from the folder will be displayed now. Files indexed: " groupDigits(maxFilesIndex) ".", 0, 0, "error")
            RandomPicture()
         }
      } Else If (maxFilesIndex>0)
      {
         SlidesMusicSong := ""
         SLDtypeLoaded := 1
         RandomPicture()
      } ; Else resetMainWin2Welcome()
   }

   SetTimer, createGUItoolbar, -100
   SetTimer, TriggerMenuBarUpdate, -90
   lastInvoked := A_TickCount
}

askAboutSlidesListSave() {
   Static lastInvoked := 1, prevAnswer
   If (A_TickCount - lastInvoked<300)
      Return prevAnswer

   r := 0
   If (currentFilesListModified=1 && RegExMatch(CurrentSLD, "i)(.\.sld)$") && FileExist(CurrentSLD) && maxFilesIndex>1 && SLDtypeLoaded=2)
   || (currentFilesListModified=1 && maxFilesIndex>1 && InStr(CurrentSLD, "\QPV\favourite-images-list.SLD"))
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      zPlitPath(CurrentSLD, 0, OutFileName, OutDir)
      msgResult := msgBoxWrapper(appTitle ": Save files list", "The currently opened files list has been modified and the changes have not been saved. To continue with the action you chose, select the Discard button.`n`nWould like to save the currently opened files list?`n`n" OutFileName, "&Save|&Discard|&Cancel", 0, "question")
      If (msgResult="Save")
      {
         SetTimer, PanelSaveSlideShowu, -150
         r := 1
      } Else If (msgResult="Discard")
      {
         r := 0
      } Else ; If (msgResult="Ok")
         r := 1

      lastInvoked := A_TickCount
   }

   prevAnswer := r
   Return r
}

askAboutFileSave(msg:="", lvls:=1, dontOpen:=0) {
   Static lastInvoked := 1, prevAnswer
   lvls := (minimizeMemUsage=1 || A_PtrSize=4) ? 1 : 2
   If (preventUndoLevels=1)
      lvls := -1

   isOkay := (validBMP(UserMemBMP) && undoLevelsRecorded>lvls || viewportQPVimage.imgHandle && viewportQPVimage.actions>1) ? 1 : 0
   If (isOkay=1 && currentImgModified=1) && (A_TickCount - lastInvoked<300)
      Return prevAnswer

   r := 0
   imgPath := getIDimage(imgIndexEditing)
   If (isOkay=1 && imgPath && currentImgModified=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      zPlitPath(imgPath, 0, OutFileName, OutDir)
      msgResult := msgBoxWrapper(appTitle ": Save image", "The currently modified image is about to be discarded" msg ".`n`nWould you like to save the current image?`n`n" OutFileName, "&Save|&Discard|&Cancel", 0, "question")
      If (msgResult="Save")
      {
         If (dontOpen!="yes")
            SetTimer, PanelSaveImg, -150
         r := 1
      } Else If (msgResult="Discard")
         r := 0
      Else ; If (msgResult="Ok")
         r := (dontOpen="yes") ? 2 : 1

      lastInvoked := A_TickCount
   }

   prevAnswer := r
   Return r
}

MenuOpenLastImg(forceOpenGiven:=0) {
   If (thumbsDisplaying=1)
   {
      MenuDummyToggleThumbsMode()
      Sleep, 25
   }

   If !FileRexists(forceOpenGiven)
   {
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      LastOpenedImg := Trimmer(LastOpenedImg)
   } Else LastOpenedImg := Trimmer(forceOpenGiven)

   If RegExMatch(LastOpenedImg, RegExFilesPattern) && FileRexists(LastOpenedImg)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return

      If askAboutSlidesListSave()
         Return

      If (thumbsDisplaying=1)
         ToggleThumbsMode()

      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      PopulateIndexFilesStatsInfos("kill")
      renewCurrentFilesList()
      setImageLoading()
      currentFileIndex := maxFilesIndex := 1
      resultedFilesList[1, 1] := LastOpenedImg
      IDshowImage(currentFileIndex)
      zPlitPath(LastOpenedImg, 0, OutFileName, OutDir)
      DynamicFoldersList := OutDir "`n"
      prevOpenFolderPath := OutDir
      CurrentSLD := "|" OutDir
      SLDtypeLoaded := 1
      SlidesMusicSong := ""
      currentFilesListModified := 0
      interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
      interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
      updateUIctrl()
      INIaction(1, "prevOpenFolderPath", "General")
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
      winPrefix := defineWinTitlePrefix()
  
      SetTimer, GuiGDIupdaterResize, Off
      mustOpenStartFolder := OutDir
      ; currentFileIndex := detectFileID(LastOpenedImg)
      pVwinTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
      setWindowTitle(pVwinTitle, 1)
      SetTimer, RemoveTooltip, -250
      SetTimer, TriggerMenuBarUpdate, -100
      SetTimer, ResetImgLoadStatus, -50
      SetTimer, createGUItoolbar, -200
      If (RegExMatch(OutFileName, "i)(\.gif)$") && totalFramesIndex>1 && animGIFsSupport=1)
      {
         animGIFplaying := 0
         allowNextSlide := 1
         prevAnimGIFwas := ""
         dummyTimerDelayiedImageDisplay(250)
      }
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateTempGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   }
}

OpenArgFile(inputu) {
    setImageLoading()
    Global scriptStartTime := A_TickCount
    currentFileIndex := maxFilesIndex := 1
    interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
    interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)

    ; usrColorDepth := imgFxMode := 1
    ; vpIMGrotation := FlipImgH := FlipImgV := 0
    resultedFilesList[1, 1] := inputu
    IDshowImage(currentFileIndex)
    Global scriptStartTime := A_TickCount
    zPlitPath(inputu, 0, OutFileName, OutDir)
    DynamicFoldersList := OutDir "`n"
    zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
    winPrefix := defineWinTitlePrefix()

    SetTimer, GuiGDIupdaterResize, Off
    mustOpenStartFolder := OutDir
    ; coreOpenFolder("|" OutDir, 0)
    Global scriptStartTime := A_TickCount
    ; currentFileIndex := detectFileID(inputu)
    winTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
    setWindowTitle(winTitle, 1)
    SetTimer, RemoveTooltip, -250
    SetTimer, ResetImgLoadStatus, -50
    CurrentSLD := "|" OutDir
    prevOpenFolderPath := OutDir
    INIaction(1, "prevOpenFolderPath", "General")
    If (allowRecordHistory=1 && FileRexists(inputu))
       IniWrite, % inputu, % mainSettingsFile, General, LastOpenedImg

    updateUIctrl()
    SLDtypeLoaded := 1
    SetTimer, createGUItoolbar, -100
    If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
       CreateTempGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)

    SetTimer, TriggerMenuBarUpdate, -90
    ; Else resetMainWin2Welcome()
    ; IDshowImage(currentFileIndex)
}

addNewFile2list() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ")"
   pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
   pattern .= "|QPV files lists / slideshows (*.sld;*.sldb)"

   imgsListu := openFileDialogWrapper("M", "AllowMultiSelect FileMustExist", prevOpenFolderPath, "Add image file(s) to the list...", pattern, null, 1)
   If !imgsListu
      Return "cancel"

   If AnyWindowOpen
      BtnCloseWindow()

   Sleep, 25
   If askAboutFileSave(" and the selected file(s) will be added to the list")
      Return

   showTOOLtip("Processing files list, please wait")
   setImageLoading()
   If InStr(imgsListu, "`n")
      firstFile := Trimmer(SubStr(imgsListu, 1, InStr(imgsListu, "`n")))
   Else
      firstFile := Trimmer(imgsListu)

   zPlitPath(firstFile, 0, OutFileName, SelectedDir)
   countFiles := ST_Count(imgsListu, "`n") + 1
   ; msgbox, % firstFile "a`n" countFiles "`n" imgsListu
   If StrLen(SelectedDir)>3
   {
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
   }

   If (RegExMatch(firstFile, "i)(.\.sldb)$") && SLDtypeLoaded!=3)
   {
      importSLDBintoPlainText(firstFile)
   } Else If (RegExMatch(firstFile, "i)(.\.sldb)$") && SLDtypeLoaded=3)
   {
      importSLDBintoSLDB(firstFile)
   } Else If RegExMatch(firstFile, "i)(.\.sld)$")
   {
      importSLDplainText(firstFile)
   } Else If StrLen(imgsListu)>3
   {
      showTOOLtip("Processing files list, please wait")
      setImageLoading()
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir)
      GenerateRandyList()
      currentFileIndex := maxFilesIndex
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(50)
   }

   SetTimer, TriggerMenuBarUpdate, -90
   SetTimer, createGUItoolbar, -100
   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

importSLDplainText(whichFile) {
   If (!RegExMatch(whichFile, "i)(.\.sld)$") || !RegExMatch(CurrentSLD, "i)(.\.sld)$"))
      Return

   If (whichFile=CurrentSLD)
   {
      showTOOLtip("WARNING: Illegal operation. You cannot import the already opened files list`nNo one likes duplicates :-)")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If StrLen(filesFilter)>1
   {
      showTOOLtip("Deactivating the files list filter, please wait")
      remFilesListFilter("simple")
      Sleep, 10
      RemoveTooltip()
   }

   mustOpenStartFolder := ""
   zPlitPath(whichFile, 0, OutFileName, SelectedDir)
   showTOOLtip("Importing plain-text files list, please wait`n" OutFileName "`n" SelectedDir "\")
   If (SLDtypeLoaded=2)
      DynamicFoldersList := getDynamicFoldersList()

   FileReadLine, firstLine, % whichFile, 1
   FileRead, tehFileVar, % whichFile
   mustRemQuotes := InStr(firstLine, "[General]") ? 0 : 1
   If !mustRemQuotes
   {
      IniRead, testDynaFolderz, % whichFile, DynamicFolderz, DF1, @
      If StrLen(testDynaFolderz)>4
         DynamicFoldersList .= "`n" coreLoadDynaFolders(whichFile)
   } Else
   {
      tehFileVar := StrReplace(tehFileVar, """-")
      tehFileVar := StrReplace(tehFileVar, """")
   }

   Sort, DynamicFoldersList, UD`n
   DynamicFoldersList := cleanDynamicFoldersList(DynamicFoldersList)
   If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
      recreateDynaFoldersSQLdbList(DynamicFoldersList)

   countFiles := ST_Count(tehFileVar, "`n") + 1
   coreAddNewFiles(tehFileVar, countFiles, SelectedDir)

   ; res := sldGenerateFilesList(whichFile, 0, mustRemQuotes, 0)
   SoundBeep , 900, 100
   currentFilesListModified := 1
   GenerateRandyList()
   RandomPicture()
   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

importSLDBintoSLDB(whichFile) {
   If (!RegExMatch(whichFile, "i)(.\.sldb)$") || SLDtypeLoaded!=3)
      Return

   If StrLen(filesFilter)>1
   {
      showTOOLtip("Deactivating the files list filter, please wait")
      remFilesListFilter("simple")
      Sleep, 10
      RemoveTooltip()
   }

   If (whichFile=CurrentSLD)
   {
      showTOOLtip("WARNING: Illegal operation. You cannot import the already opened database")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (dbVersion!=dbExpectedVersion)
   {
      showTOOLtip("WARNING: Illegal operation. You cannot import into the currently opened database, because it was saved with a different version of QPV. Please rebuild this database.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   startZeit := A_TickCount
   mustOpenStartFolder := ""
   zPlitPath(CurrentSLD, 0, OutFileName, SelectedDir)
   showTOOLtip("Preparing main database content, please wait`n" OutFileName "`n" SelectedDir "\")
   setImageLoading()
   Static  SQLa := "SELECT imgfile, imgfolder, fsize, fmodified, fcreated, imgwidth, imgheight, imgframes, imgdpi, imgpixfmt, imgavg, imghpeak, imghlow, imghmode, imghrms, imghminu, imghrange, dHash, pHash, pixelzFsmall, pixelzFbig, lHash, imgmedian FROM images"
   If !activeSQLdb.GetTable(SQLa, mainRecordSet)
   {
      ResetImgLoadStatus()
      throwSQLqueryDBerror(A_ThisFunc)
      Return
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   countFiles := mainRecordSet.RowCount
   totalArrayu := []
   mainArrayu := []
   uniqueArrayu := new hashtable()
   doStartLongOpDance()
   allIndex := 0
   Loop, % mainRecordSet.RowCount
   {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, countFiles, startOperation)
           showTOOLtip("Preparing main database content, please wait" etaTime, 0, 0, A_Index/countFiles)
           prevMSGdisplay := A_TickCount
        }

        Rowu := mainRecordSet.Rows[A_Index]
        If Rowu[2]
        {
           allIndex++
           mainArrayu[allIndex] := A_Index
           totalArrayu[allIndex] := "m"
           uniqueArrayu[Rowu[2] "\" Rowu[1]] := 1
        }
   }

   If (abandonAll=1)
   {
      showTOOLtip("Database import operation aborted by user")
      mainArrayu := ""
      totalArrayu := ""
      uniqueArrayu := ""
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      ResetImgLoadStatus()
      Return
   }

   zPlitPath(whichFile, 0, OutFileName, SelectedDir)
   otherSQLdb := new SQLiteDB
   If !otherSQLdb.OpenDB(whichFile)
   {
      mainArrayu := ""
      totalArrayu := ""
      uniqueArrayu := ""
      throwSQLqueryDBerror(A_ThisFunc)
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   showTOOLtip("Retrieving imported database content, please wait`n" OutFileName "`n" SelectedDir "\")
   If !otherSQLdb.GetTable(SQLa, otherRecordSet)
   {
      mainArrayu := ""
      totalArrayu := ""
      uniqueArrayu := ""
      mainRecordSet.Free()
      throwSQLqueryDBerror(A_ThisFunc)
      otherSQLdb.CloseDB()
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   countFiles := otherRecordSet.RowCount
   otherArrayu := []
   Loop, % otherRecordSet.RowCount
   {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, countFiles, startOperation)
           showTOOLtip("Retrieving imported database content, please wait" etaTime, 0, 0, A_Index/countFiles)
           prevMSGdisplay := A_TickCount
        }

        Rowu := otherRecordSet.Rows[A_Index]
        If Rowu[2]
        {
           allIndex++
           otherArrayu[allIndex] := A_Index
           totalArrayu[allIndex] := uniqueArrayu.hasKey(Rowu[2] "\" Rowu[1]) ? "b" : "o"
        }
   }

   If (abandonAll=1)
   {
      showTOOLtip("Database import operation aborted by user")
      SoundBeep 300, 100
      totalArrayu := ""
      mainArrayu := ""
      uniqueArrayu := ""
      otherArrayu := ""
      otherRecordSet.Free()
      mainRecordSet.Free()
      otherSQLdb.CloseDB()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return
   }

   showTOOLtip("Merging databases contents, please wait")
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM images;")

   sqlDBrowID := 1
   baseSQLstr := "INSERT INTO images (imgidu, imgfile, imgfolder, fsize, fmodified, fcreated, imgwidth, imgheight, imgframes, imgdpi, imgpixfmt, imgavg, imghpeak, imghlow, imghmode, imghrms, imghminu, imghrange, dHash, pHash, pixelzFsmall, pixelzFbig, lHash, imgmedian) VALUES ("
   k1 := k2 := k3 := k4 := k5 := k6 := k7 := k8 := k9 := k10 := k11 := k12 := k13 := k14 := k15 := k16 := k17 := k18 := k19 := k20 := k21 := k22 := k23 := k24 := ""

   newIndex := 0
   newArrayu := []
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   countFiles := allIndex ; totalArrayu.Count()
   ; For Key, Value in totalArrayu
   Loop, % allIndex
   {
      key := A_Index
      value := totalArrayu[key]
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>1500)
      {
         etaTime := ETAinfos(A_Index, countFiles, startOperation)
         If errorsOccured
            moreSpam := "`n" groupDigits(errorsOccured) " errors occured until now"

         showTOOLtip("Merging databases contents, please wait" moreSpam etaTime, 0, 0, A_Index/countFiles)
         prevMSGdisplay := A_TickCount
      }

      If (value="m")
      {
         thisIndex := mainArrayu[key]
         Rowu := mainRecordSet.Rows[thisIndex]
      } Else If (value="o")
      {
         thisIndex := otherArrayu[key]
         Rowu := otherRecordSet.Rows[thisIndex]
      } Else If (value="b")
      {
         thisIndex := otherArrayu[key]
         oRowu := otherRecordSet.Rows[thisIndex]
         thisIndex := mainArrayu[key]
         mRowu := mainRecordSet.Rows[thisIndex]
         Loop, 23
            k%A_Index% := oRowu[A_Index] ? oRowu[A_Index] : mRowu[A_Index]
      }

      If (value="m" || value="o")
      {
         Loop, 23
            k%A_Index% := Rowu[A_Index]
      }

      activeSQLdb.EscapeStr(k1)
      activeSQLdb.EscapeStr(k2)
      moreSQL := baseSQLstr "'" sqlDBrowID "', " k1 ", " k2 ", '" k3 "', '" k4 "', '" k5 "', '" k6 "', '" k7 "', '" k8 "', '" k9 "', '" k10 "', '" k11 "', '" k12 "', '" k13 "', '" k14 "', '" k15 "', '" k16 "', '" k17 "', '" k18 "', '" k19 "', '" k20 "', '" k21 "', '" k22 "', '" k23 "');"
      If !activeSQLdb.Exec(moreSQL)
      {
         errorsOccured++
      } Else
      {
         newIndex++
         sqlDBrowID++
      }
   }

   If (abandonAll=1)
   {
      showTOOLtip("Database import operation aborted by user")
      SoundBeep 300, 100
      activeSQLdb.Exec("ROLLBACK TRANSACTION;")
      totalArrayu := ""
      mainArrayu := ""
      otherArrayu := ""
      newArrayu := ""
      uniqueArrayu := ""
      otherRecordSet.Free()
      mainRecordSet.Free()
      otherSQLdb.CloseDB()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -200
      Return
   }

   showTOOLtip("Finalising database import operations, please wait")
   Static cols := "fsize,fmodified,fcreated,imgwidth,imgheight,imgframes,imgdpi,imgpixfmt,imgavg,imghpeak,imghlow,imghmode,imghrms,imghminu,imghrange,dHash,pHash,pixelzFsmall,pixelzFbig,lHash,imgmedian"
   Loop, Parse, cols, CSV
   {
      If !activeSQLdb.Exec("UPDATE images SET " A_LoopField " = NULL WHERE " A_LoopField "='';")
         errorsOccured++
   }

   If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      throwSQLqueryDBerror(A_ThisFunc)

   SQL := "SELECT imgfolder FROM dynamicfolders;"
   otherSQLdb.GetTable(SQL, gRecordSet)
   Loop, % gRecordSet.RowCount
   {
       Rowu := gRecordSet.Rows[A_Index]
       If Rowu[1]
          DynamicFoldersList .= Rowu[1] "`n"
   }

   maxFilesIndex := newIndex
   resultedFilesList := []
   ; resultedFilesList := newArrayu.Clone()
   newArrayu := []
   totalArrayu := []
   mainArrayu := []
   otherArrayu := []
   uniqueArrayu := []
   gRecordSet.Free()
   otherRecordSet.Free()
   mainRecordSet.Free()
   otherSQLdb.CloseDB()
   Sort, DynamicFoldersList, UD`n
   newListu := cleanDynamicFoldersList(DynamicFoldersList)
   recreateDynaFoldersSQLdbList(newListu)
   If errorsOccured
      someErrors := "`n" groupDigits(errorsOccured) " errors occured during merger."

   zeitOperation := A_TickCount - startZeit
   etaTime := SecToHHMMSS(Round(zeitOperation/1000, 3))
   OpenSLD(CurrentSLD, 1)
   showDelayedTooltip("Databases merger has finished in " etaTime someErrors "`nTotal files: " groupDigits(maxFilesIndex))
   ; res := sldGenerateFilesList(whichFile, 0, mustRemQuotes, 0)
   SoundBeep , % errorsOccured ? 300 : 900, 100
   ; GenerateRandyList()
   ; RandomPicture()
   SetTimer, ResetImgLoadStatus, -200
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

importSLDBintoPlainText(whichFile) {
   If !RegExMatch(whichFile, "i)(.\.sldb)$")
      Return

    If CurrentSLD
       dropFilesSelection(1)

    mustOpenStartFolder := ""
    zPlitPath(whichFile, 0, OutFileName, SelectedDir)
    showTOOLtip("Importing files list from database`n" OutFileName "`n" SelectedDir "\")
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    OpenSLDBdataBase(whichFile, 1)
    currentFilesListModified := 1
    Sort, DynamicFoldersList, UD`n
    DynamicFoldersList := cleanDynamicFoldersList(DynamicFoldersList)
    If (!CurrentSLD && maxFilesIndex>0)
       CurrentSLD := SelectedDir "\newFile.SLD"

    GenerateRandyList()
    RandomPicture()
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -150
}

coreAddNewFiles(imgsListu, countFiles, SelectedDir, selectNewOnes:=0) {
    If CurrentSLD
       dropFilesSelection(1)

    showTOOLtip("Adding " groupDigits(countFiles) " files into the current files list")
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    doStartLongOpDance()
    If (SLDtypeLoaded=3)
    {
       getMaxRowIDsqlDB()
       activeSQLdb.Exec("BEGIN TRANSACTION;")
    }

    isFaves := InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") ? 1 : 0
    prevMSGdisplay := A_TickCount
    startOperation := A_TickCount
    Loop, Parse, imgsListu, `n`r
    {
       line := Trimmer(A_LoopField)
       If StrLen(line)<3
          Continue

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, countFiles, startOperation)
          showTOOLtip("Adding image files to the current list" etaTime, 0, 0, A_Index/countFiles)
          prevMSGdisplay := A_TickCount
       }

       executingCanceableOperation := A_TickCount
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          If (SLDtypeLoaded=3 && maxFilesIndex>0)
          {
             zPlitPath(line, 1, OutFileName, OutDir)
             erru := addSQLdbEntry(OutFileName, OutDir, 0, 0, 0, 1)
          }

          If !erru
          {
             added++
             maxFilesIndex++
             If (selectNewOnes=1)
                markedSelectFile++

             resultedFilesList[maxFilesIndex] := [line, selectNewOnes]
             If (isFaves=1)
                resultedFilesList[maxFilesIndex, 5] := 1

             If (SLDtypeLoaded=3 && maxFilesIndex>0)
                resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
          }
       }
    }

    If (SLDtypeLoaded=3)
    {
       If !activeSQLdb.Exec("COMMIT TRANSACTION;")
          throwSQLqueryDBerror(A_ThisFunc)
       getMaxRowIDsqlDB()
    }

    If added
       currentFilesListModified := 1

    If (!CurrentSLD && maxFilesIndex>0)
    {
       SLDtypeLoaded := 2
       CurrentSLD := SelectedDir "\newFile.SLD"
    }

    mustOpenStartFolder := ""
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -150
}

wrapperAddNewFolderToList(folderu, forceRemAll, isInLoop:=0, noRemAtAll:=0) {
    showTOOLtip("Preparing files list to import:`n" folderu "\")
    z := coreAddNewFolder(folderu, forceRemAll, 0, 0, 0, noRemAtAll)
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=2 && isInLoop!=1)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1 || InStr(folderu, "|"))
          good2go := "null"
    } Else good2go := "null"

    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
    {
       good2go := 0
       SQLdeleteEntriesMarked()
       isPipe := InStr(folderu, "|") ? 1 : 0
       folderuz := StrReplace(folderu, "|")
       SQLdbRetrieveGivenFolder(folderuz, !isPipe)
       getMaxRowIDsqlDB()
    }

    If (isInLoop=1)
       Return z
    Else
       GenerateRandyList()

    Return good2go
}

addNewFolder2list(givenPath:=0, externMode:=0, actu:=0) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (FolderExist(givenPath) && externMode="yes")
   {
      SelectImg := givenPath
   } Else If (externMode!="yes")
   {
      SelectImg := openFoldersDialogWrapper(prevOpenFolderPath, "Add new folder(s) to the list")
      If !Trim(SelectImg)
         Return "cancel"
   }

   SelectedDir := Trimmer(SelectImg)
   If SelectedDir
   {
      If askAboutFileSave(" and new files will be added from the selected folder")
         Return

      If InStr(DynamicFoldersList, SelectedDir "`n")
      {
         hasAskedAboutDupes := 1
         msgResult := msgBoxWrapper(appTitle, "The folder you want to add, seems to be already indexed. Are you sure you want to add it again? This action will likely lead to duplicate entries in the list.`n`n" SelectedDir "\", 4, 0, "question")
         If (msgResult!="yes")
            Return "cancel"
      }

      If (actu="not" || actu="recursive")
      {
         If (actu="not")
            isNotRecursive := "|"
      } Else
      {
         msgResult := msgBoxWrapper(appTitle, "Do you want to scan for image files recursively, through all its subfolders?`n`n" SelectedDir "\", 3, 0, "question")
         If (msgResult="no")
            isNotRecursive := "|"
         Else If (msgResult="cancel" || InStr(msgResult, "win_close"))
            Return "cancel"
      }

      BtnCloseWindow()
      Sleep, 1
      prevOpenFolderPath := SelectedDir
      setImageLoading()
      INIaction(1, "prevOpenFolderPath", "General")
      mainListu := retrieveListFoldersIndexed()
      If (mainListu[Format("{:L}", SelectedDir)] && hasAskedAboutDupes!=1)
      {
         msgu := "The folder seems to be already indexed:`n`n" SelectedDir "\"
         msgResult := msgBoxWrapper(appTitle ": Confirmation", msgu "`n`nDo you want to add it to the list? This may lead to duplicate entries.", 4, 0, "question")
         If (msgResult!="Yes")
         {
            mainListu := ""
            SetTimer, RemoveTooltip, % -msgDisplayTime
            ResetImgLoadStatus()
            Return "cancel"
         }
      }

      mustOpenStartFolder := ""
      modus := isNotRecursive ? 1 : 0
      z := wrapperAddNewFolderToList(isNotRecursive SelectedDir, !modus)
      If (z!="null" && RegExMatch(CurrentSLD, sldsPattern))
         updateCachedStaticFolders(SelectedDir, modus)
      Else
         mustGenerateStaticFolders := 1

      listu := DynamicFoldersList "`n" isNotRecursive SelectedDir "`n"
      Sort, listu, UD`n
      DynamicFoldersList := cleanDynamicFoldersList(listu)
      If (SLDtypeLoaded=3 && RegExMatch(CurrentSLD, sldsPattern))
         recreateDynaFoldersSQLdbList(DynamicFoldersList)

      If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
         markUndefinedFavedList()

      ResetImgLoadStatus()
      SoundBeep 900, 100
      If !CurrentSLD
      {
         SLDtypeLoaded := 2
         CurrentSLD := SelectedDir "\newFilesList.SLD"
         RandomPicture()
      }
   }
}

coreAddNewFolder(SelectedDir, forceRemAll, noRandom:=0, forReal:=1, fastu:=1, noRemAtAll:=0) {
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    ; markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    thisFolder := (forceRemAll=1) ? StrReplace(SelectedDir, "|") : SelectedDir
    If (forReal=0 && SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    If (noRemAtAll=0)
       remFilesFromList(thisFolder, 1, forReal)

    z := GetFilesList(SelectedDir "\*", 0, 1, fastu)
    If (fastu=1)
    {
       GenerateRandyList()
       SoundBeep, 900, 100
    }

    CurrentSLD := backCurrentSLD
    If (noRandom=1)
    {
       currentFileIndex := maxFilesIndex - 1
       dummyTimerDelayiedImageDisplay(150)
    } Else RandomPicture()
    Return z
}

detectFileID(imgPath, zeroStart:=0) {
    good := (zeroStart=1) ? 0 : 1
    Loop, % maxFilesIndex + 1
    {
       If (resultedFilesList[A_Index, 1]=imgPath)
       {
          good := A_Index
          Break
       }
    }
    Return good
}

GuiDroppedFiles(imgsListu, foldersListu, sldFile, countFiles, isCtrlDown) {
   Critical, on
   Static lastInvoked := 1, noAsking := 0
   If (A_TickCount - lastInvoked<900)
      Return

   If (!imgsListu && !foldersListu && !sldFile)
   {
      SetTimer, ResetImgLoadStatus, -50
      Return
   }

   ; ToolTip, % imgsListu "|" foldersListu "|" sldFile , , , 2
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   lastInvoked := A_TickCount
   If (imgsListu && isCtrlDown=1)
   {
      OpenWithNewQPVinstance(0, imgsListu, countFiles)
      Return
   }

   initQPVmainDLL()
   If sldFile
   {
      If (RegExMatch(sldFile, "i)(.\.vqpv)$"))
      {
         If (thumbsDisplaying!=1 && isImgEditingNow()=1)
            BTNloadCustomShape("yes", sldFile)
         ResetImgLoadStatus()
         Return
      }

      zPlitPath(sldFile, 0, FileName, OutDir)
      If (CurrentSLD && maxFilesIndex>1)
         msgResult := msgBoxWrapper(appTitle ": Import file", "Would you like to import the dropped files list into the current one?`n`nFile to open or import:`n" FileName "`n" OutDir "\", "&Import|&Open files list|&Cancel", 1, "question")
      Else msgResult := "open"

      If (msgResult="import")
      {
         If (RegExMatch(sldFile, "i)(.\.sldb)$") && SLDtypeLoaded!=3)
            importSLDBintoPlainText(sldFile)
         Else If (RegExMatch(sldFile, "i)(.\.sldb)$") && SLDtypeLoaded=3)
            importSLDBintoSLDB(sldFile)
         Else If RegExMatch(sldFile, "i)(.\.sld)$")
            importSLDplainText(sldFile)

         SetTimer, createGUItoolbar, -100
         TriggerMenuBarUpdate()
      } Else If InStr(msgResult, "open")
         OpenSLD(sldFile)
      lastInvoked := A_TickCount
      ResetImgLoadStatus()
      Return
   }

   If (CurrentSLD && maxFilesIndex>1 && StrLen(foldersListu)>3)
      msgResult := msgBoxWrapper(appTitle ": Import files", "Would you like to import the dropped folder(s) to the current files list?", "&Import|&New list|&Cancel", 1, "question")

   If (msgResult="cancel" || InStr(msgResult, "win_close"))
   {
      lastInvoked := A_TickCount
      ResetImgLoadStatus()
      Return
   } Else If InStr(msgResult, "new")
   {
      If askAboutFileSave(" and the new files list will be created")
         Return

      SlidesMusicSong := ""
      mainFoldersListu := CurrentSLD := DynamicFoldersList := ""
      renewCurrentFilesList()
      AnyWindowOpen := 1000
      resetMainWin2Welcome()
      AnyWindowOpen := ""
   }

   watchFolderDetails := ""
   updateUIctrl()
   If StrLen(foldersListu)>3
   {
      If askAboutFileSave(" and the dropped image files will be added to the files list")
         Return

      mustOpenStartFolder := ""
      mainFoldersListu := getDynamicFoldersList()
      doStartLongOpDance()
      dropFilesSelection(1)
      setWhileLoopExec(1)
      showTOOLtip("Preparing to import dropped folders, please wait")
      If StrLen(filesFilter)>1
         remFilesListFilter("simple")

      prlist := ""
      mainListu := retrieveListFoldersIndexed()
      For zKey, zValue in mainListu
          prlist .= zKey "\`n"

      newListu := DynamicFoldersList "`n"
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      Loop, Parse, foldersListu,`n,`r
      {
          linea := Trimmer(A_LoopField)
          If StrLen(linea)<4
             Continue

          noRemAtAll := 1
          If (mainListu[Format("{:L}", linea)] && noAsking!=1)
          {
             msgu := "The following folder seems to be already indexed:`n`n" linea "\"
             msgResult := msgBoxWrapper(appTitle ": Confirmation", msgu "`n`nDo you want to add it to the list? This may lead to duplicate entries.", "&Yes|&No|&Abort", 2, "question", "Do not ask again in this application session")
             noAsking := msgResult.check
             If (msgResult.btn="No")
                Continue
             Else If (msgResult.btn="Abort")
                Break
             Else
                noRemAtAll := 0
          } Else If InStr(prlist, linea "\")
             noRemAtAll := 0

          changeMcursor()
          r := wrapperAddNewFolderToList(linea, 1, 1, noRemAtAll)
          ; r := GetFilesList(linea "\*")
          If (r="abandoned")
             Break

          stuffAdded := 1
          lastOne := linea
          newListu .= "`n" linea "`n"
      }

      mainListu := ""
      CurrentSLD := backCurrentSLD
      If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
         markUndefinedFavedList()

      DynamicFoldersList := cleanDynamicFoldersList(newListu)
      If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
      {
         recreateDynaFoldersSQLdbList(DynamicFoldersList)
         thisIndex := currentFileIndex
         OpenSLD(CurrentSLD, 1)
         currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
         hasReopened := 1
      }

      ForceRefreshNowThumbsList()
      If (stuffAdded=1)
      {
         newStaticFoldersListCache := []
         mustGenerateStaticFolders := 1
         GenerateRandyList()
      }

      setWhileLoopExec(0)
      If !CurrentSLD
      {
         If FolderExist(StrReplace(Trimmer(DynamicFoldersList), "|"))
         {
            SLDtypeLoaded := 1
            CurrentSLD := Trimmer(DynamicFoldersList)
         } Else
         {
            SLDtypeLoaded := 2
            CurrentSLD := lastOne "\newFile.SLD"
         }
      }

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (hasReopened!=1)
      {
         SetTimer, createGUItoolbar, -100
         TriggerMenuBarUpdate()
         currentFileIndex := maxFilesIndex - 1
      }
      dummyTimerDelayiedImageDisplay(10)
   } Else If (imgsListu && countFiles=1 && !CurrentSLD)
   {
      imgPath := Trimmer(imgsListu)
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      If (OutDir="")
      {
         lastInvoked := A_TickCount
         SetTimer, ResetImgLoadStatus, -50
         Return
      }

      If (thumbsDisplaying!=1 && countFiles=1 && isImgEditingNow()=1 && !AnyWindowOpen)
      {
         msgResult := msgBoxWrapper(appTitle ": Import image", "You dropped an image file into the QPV window.`n`nWould you like to open it and add it to the files list`nor paste it in place, in the opened image?", "&Open image|&Paste in place|&Cancel", 0, "question")
         If InStr(msgResult, "paste")
         {
            If (editingSelectionNow!=1)
               ToggleEditImgSelection()
            Sleep, 2
            MainPanelTransformArea(Trimmer(imgsListu), "paste", "extern-file")
            Return
         }
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath))
      {
         SLDtypeLoaded := 1
         lastInvoked := A_TickCount
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

         MenuOpenLastImg(imgPath)
         lastInvoked := A_TickCount
         SetTimer, ResetImgLoadStatus, -150
         Return
      } Else resetMainWin2Welcome()
   } Else If StrLen(imgsListu)>3
   {
      If (thumbsDisplaying!=1 && countFiles=1 && isImgEditingNow()=1 && !AnyWindowOpen)
      {
         msgResult := msgBoxWrapper(appTitle ": Import image", "You dropped an image file into the QPV window.`n`nWould you like to open it and add it to the files list`nor paste it in place, in the opened image?", "&Open image|&Paste in place|&Cancel", 0, "question")
         If InStr(msgResult, "paste")
         {
            If (editingSelectionNow!=1)
               ToggleEditImgSelection()
            Sleep, 2
            MainPanelTransformArea(Trimmer(imgsListu), "paste", "extern-file")
            Return
         } Else If InStr(msgResult, "open")
         {
            Sleep, 1
         } Else
         {
            SetTimer, ResetImgLoadStatus, -100
            Return
         }
      }

      If askAboutFileSave(" and the dropped image files will be added to the files list")
         Return

      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, prevOpenFolderPath)
      mustGenerateStaticFolders := 1
      ForceRefreshNowThumbsList()
      GenerateRandyList()
      SetTimer, ResetImgLoadStatus, -50
      If (A_TickCount - lastInvoked>2000)
         SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      currentFileIndex := maxFilesIndex
      SetTimer, createGUItoolbar, -10
      TriggerMenuBarUpdate()
      dummyTimerDelayiedImageDisplay(150)
      If (thumbsDisplaying=1 && thumbsListViewMode=1)
         SetTimer, mainGdipWinThumbsGrid, -100
   }

   SetTimer, updateUIctrl, -100
   lastInvoked := A_TickCount
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyPrevShowToolTip() {
   showTOOLtip("nully")
}

dummyDelayShowToolTip() {
   showTOOLtip(delayiedHUDmsg, 0, 0, delayiedHUDperc)
}

showDelayedTooltip(msg, perc:=0, delayu:=450, expire:=0) {
    if InStr(msg, "error")
       addJournalEntry(msg)

    delayiedHUDmsg := msg
    delayiedHUDperc := perc
    SetTimer, dummyDelayShowToolTip, % -delayu
    expire := (expire<100) ? msgDisplayTime + delayu*2 : expire + delayu
    SetTimer, RemoveTooltip, % -expire
}

showTOOLtip(msg, funcu:=0, typeFuncu:=0, perc:=0) {
   Critical, on
   Static prevMsg
   If (msg="nully" && prevMsg)
      msg := prevMsg

   If (funcu!="nully")
      prevMsg := msg

   CreateOSDinfoLine(msg, 0, 0, perc, funcu, typeFuncu)
   If (AnyWindowOpen>0 && WinActive("A")=hSetWinGui && panelWinCollapsed=0)
   {
      GetPhysicalCursorPos(mX, mY)
      If ((InStr(msg, "error") || InStr(msg, "failed") || InStr(msg, "warning")) && !perc && AnyWindowOpen!=70)
      {
         If (z := InStr(msg, "`n"))
         {
            a := SubStr(msg, 1, z - 1)
            b := SubStr(msg, z + 1)
            BalloonTip(b, a, "I=2 T=10", uiUseDarkMode)
         } Else BalloonTip(appTitle, msg, "I=2 T=5", uiUseDarkMode)
      } Else ToolTip
      ; Else If !perc
      ; ToolTip, % msg, % mX + 25, % mY + 25
   } Else If (AnyWindowOpen>0)
      ToolTip
}

RemoveTooltip() {
   Tooltip
   lastOSDtooltipInvoked := 1
   CreateOSDinfoLine(1, 1)
}

ForceRemoveTooltip() {
   Tooltip
   lastOSDtooltipInvoked := 1
   BalloonTip_Kill()
   CreateOSDinfoLine(2, 1)
}

PanelAssociateQPV() {
   If isWinStore()
   {
      msgBoxWrapper(appTitle ": WARNING", "You are currently running " appTitle " (QPV) from the Microsoft Store. Due to stringent security measures on the store, QPV cannot change file format associations. Therefore, you must manually associate QPV with the desired image file formats.`n`nOpen Explorer and use «Open with» and select " apptitle " from the list. Make sure to check «Always use this app».", 0, 1, "exclamation")
      Return
   }

   fakeWinCreator(52, A_ThisFunc, 1)
   p := TestQPVisAssociated() ? "`n`nQPV seems to be associated with the file format of the selected image file." : ""
   msgResult := msgBoxWrapper("panelu|Associate " appTitle, "Please choose what to associate " appTitle " with." p "`n`nPlease note, you may receive several warnings about system settings being changed and to allow to execute the command line app. To succesfully associate QPV with the image file formats, please answer affirmatively when prompted.", "&Proceed|C&ancel", 1, "settings", "Add ""Open in QPV"" file explorer context menu for folders", 0, "Associate with common image formats`f`fAssociate with all supported image formats`fAssociate with QPV slideshow / files list formats`fRemove QPV files associations`fDo not change files associations", 0, 0)
   If InStr(msgResult.btn, "Proceed")
   {
      ; If (!A_IsCompiled && !isWinStore())
      ; {
      ;    msgBoxWrapper(appTitle ": ERROR", "This feature is only available when this application is compiled.", 0, 0, "error")
      ;    Return
      ; }

      associateWithImages(msgResult.list)
      If (msgResult.check=1)
         associateWithExplorer(1)
      Else
         associateWithExplorer(3)
   }
}

associateWithExplorer(modus, bza:=-1) {
   Static q := Chr(34)
   zPlitPath(fullPath2exe, 0, OutFileName, OutDir)
   Cmd := A_IsCompiled ? q fullPath2exe q A_Space q "%1" q : q fullPath2exe q A_Space q A_ScriptFullPath q A_Space q "%1" q
   Cmd := StrReplace(Cmd, "\", "\\")
   Cmd := StrReplace(Cmd, """", "\""")

   regFile := "Windows Registry Editor Version 5.00`n`n"
   If (modus=1)
   {
      k := !A_IsCompiled ? "\""" StrReplace(A_ScriptFullPath, "\", "\\") "\"" " : ""
      regFile .= "[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer]`n""Icon""=" q StrReplace(fullPath2exe, "\", "\\") q "`n"
      regFile .= "@=""Open with QPV""`n"
      regFile .= "[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer\Command]`n"
      regFile .= "@=""\" q StrReplace(fullPath2exe, "\", "\\") "\"" " k "fd=|\""%1\" q q "`n"
   } Else If (modus=3) ; remove explorer context menu
   {
      regFile .= "[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\QuickPictoViewer]`n"
   } Else If (modus=4) ; remove file associations
   {
      regFile .= "[-HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "]`n"
      regFile .= "[-HKEY_CLASSES_ROOT\QPVslideshow]`n"
      regFile .= "[-HKEY_LOCAL_MACHINE\Software\Classes\QPVslideshow]`n"
      allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")
      Loop, Parse, allFormats, |
      {
         If !A_LoopField
            Continue

         regFile .= "[-HKEY_CLASSES_ROOT\QPVimg." A_LoopField "]`n"
         regFile .= "[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\QPVimg." A_LoopField "]`n"
      }
   } Else
   {
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "]`n" q "FriendlyAppName""=" q appTitle q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell]`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell\open]`n" q "FriendlyAppName""=" q appTitle q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\shell\open\command]`n@=" q Cmd q "`n"
      regFile .= "[HKEY_LOCAL_MACHINE\Software\Classes\Applications\" OutFileName "\SupportedTypes]`n"
      If (bza=1)
         allFormats := "|png|bmp|gif|jpg|tif|tga|webp|jpeg|tiff|exr|hdr|psd|"
      Else
         allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")

      Loop, Parse, allFormats, |
      {
         If !A_LoopField
            Continue

         regFile .= q "." A_LoopField q "=" q q "`n"
      }
   }

   If !FolderExist(mainCompiledPath "\regFiles")
   {
      FileCreateDir, %mainCompiledPath%\regFiles
      If ErrorLevel
         errorOccured := 1

      Sleep, 1
   }

   FileDelete, %mainCompiledPath%\regFiles\RegExplGeneral.reg
   FileDelete, %mainCompiledPath%\regFiles\runThis.bat
   Sleep, 1
   FileAppend, % regFile, %mainCompiledPath%\regFiles\RegExplGeneral.reg, UTF-16
   If ErrorLevel
      errorOccured := 1

   runTarget := "Reg Import " q mainCompiledPath "\regFiles\RegExplGeneral.reg" q "`n"
   FileAppend, % runTarget, %mainCompiledPath%\regFiles\runThis.bat
   If ErrorLevel
      errorOccured := 1

   ;  msgbox, % "loool=" A_ThisFunc "==" modus
   If !errorOccured
      Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
   Sleep, 1
   FileDelete, %mainCompiledPath%\regFiles\RegExplGeneral.reg
   FileDelete, %mainCompiledPath%\regFiles\runThis.bat
   If (errorOccured && modus!=2)
      msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while associating " appTitle " with Explorer context menu options.", 0, 0, "error")

}

associateSLDsNow() {
    bonus := A_IsCompiled ? "" : A_ScriptFullPath
    z := ShellFileAssociate("QPVslideshow",".sld", fullPath2exe, 0, mainCompiledPath, bonus)
    If z
       ShellFileAssociate("QPVslideshow",".sldb", fullPath2exe, 0, mainCompiledPath, bonus)
    Else
       msgBoxWrapper(appTitle ": ERROR", "An unknown error occured when associating " appTitle " with slideshow / files list formats.", 0, 0, "error")
}

associateWithImages(modus) {
  Static FileFormatsCommon := "|png|bmp|gif|jpg|tif|tga|webp|jpeg|tiff|exr|hdr|psd|"
       , allFormats := 0 ; "dib|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif"

  If !allFormats
     allFormats := StrReplace(SubStr(RegExFilesPattern, 17), "))$")

  If (modus=3)
  {
     associateSLDsNow()
     Return
  } Else If (modus=4)
  {
     associateWithExplorer(4)
     Return
  } Else If (modus>2)
     Return

  bonus := A_IsCompiled ? "" : A_ScriptFullPath
  Loop, Parse, FileFormatsCommon, |
  {
      If !A_LoopField
         Continue

      z := ShellFileAssociate("QPVimg." A_LoopField,"." A_LoopField, fullPath2exe, 1, mainCompiledPath, bonus)
      If !z
      {
         errorOccured := 1
         Break
      }
  }

  Sleep, 25
  If !errorOccured
     Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
  Sleep, 5
  FileDelete, %mainCompiledPath%\regFiles\*.reg
  FileDelete, %mainCompiledPath%\regFiles\*.bat

  ; msgResult := msgBoxWrapper(appTitle, appTitle " was now associated with common image file formats. Would you like to associate it with all the 85 supported file formats?", 4, 0, "question")
  ; If (msgResult="yes")
  If (modus=2 && !errorOccured)
  {
     Loop, Parse, allFormats, |
     {
         If (!A_LoopField || InStr(FileFormatsCommon, "|" A_LoopField "|"))
            Continue
 
         z := ShellFileAssociate("QPVimg." A_LoopField,"." A_LoopField, fullPath2exe, 1, mainCompiledPath, bonus)
         If !z
         {
            errorOccured := 1
            Break
         }
     }
 
     Sleep, 25
     If !errorOccured
        Try RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
     Sleep, 5
     FileDelete, %mainCompiledPath%\regFiles\*.reg
     FileDelete, %mainCompiledPath%\regFiles\*.bat
  }

  If errorOccured
  {
     msgBoxWrapper(appTitle ": ERROR", "An unknown error occured during associating " appTitle " with image file formats.", 0, 0, "error")
     Return
  } Else associateWithExplorer(2, modus)

  addJournalEntry(appTitle " has been associated with image file formats")
}

closeDocuments() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (animGIFplaying=1)
   {
      DestroyGIFuWin()
      Return
   }

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("discard it")
      Return

   If AnyWindowOpen
   {
      BtnCloseWindow()
      SetTimer, closeDocuments, -700
      Return
   }

   trackImageListButtons("kill")
   createGUItoolbar("refresh-later")
   terminateIMGediting()
   interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
   PopulateIndexFilesStatsInfos("kill")
   SLDtypeLoaded := 1
   resetMainWin2Welcome()
   addJournalEntry("All images/documents closed.")
   ResetImgLoadStatus()
}

restartAppu() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will restart")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("restart")
      Return

   ; writeMainSettings()
   If (A_IsCompiled || isWinStore())
      Try Run, "%fullPath2exe%"
   Else
      Try Run, %unCompiledExePath%

   TrueCleanup()
   Sleep, 5
   ExitApp
}

exitAppu(dummy:=0) {
   If (MsgBox2hwnd && InStr(dummy, "external"))
   {
      interfaceThread.ahkPostFunction("dummyTimerExit")
      terminateIMGediting()
      TrueCleanup()
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will exit")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("exit")
      Return

   terminateIMGediting()
   TrueCleanup()
}

askAboutFilesSelect(act) {
   Static doNotAskAgain := 0
   If (isInRange(markedSelectFile, 50, maxFilesIndex - 3) && maxFilesIndex>250 && doNotAskAgain=0)
   {
      msgResult := msgBoxWrapper(appTitle ": Discard selection", "The current opened files list has " groupDigits(markedSelectFile) " files selected. Are you sure you want to " act " ?", "&Yes|&No", 2, "question", "Do not ask again in the current session")
      If !InStr(msgResult.btn, "Yes")
         Return 1
      Else
         doNotaskAgain := msgResult.check
   }
}

InitGuiContextForcedMenu() {
   InitGuiContextMenu("forced")
}

InitGuiContextMenu(keyu:=0, mX:="-", mY:=0, givenCoords:=0, ctrlu:=0) {
   Static lastInvoked := 1
   Critical, off
   If (A_TickCount - lastPointerUseZeit<600)
      Return

   If !isNumber(mX)
      GetMouseCoord2wind(PVhwnd, mX, mY)

   globalMenuOptions := givenCoords
   If (keyu!="forced")
   {
      If (A_TickCount - lastInvoked<250) && (keyu="extern") || (A_TickCount - zeitSillyPrevent<250)
         Return

      vpWinClientSize(mainWidth, mainHeight)
      Au := WinActive("A")
      If !InStr(keyu, "appsk")
         MouseGetPos, , , Bu
      Else
         Bu := Au

      okay := (isVarEqualTo(Au, PVhwnd, hGDIwin, hGDIthumbsWin) && isVarEqualTo(Bu, PVhwnd, hGDIwin, hGDIthumbsWin)) ? 1 : 0
      If (okay!=1)
         Return 1

      setWhileLoopExec(0)
      If (slideShowRunning=1)
         ToggleSlideShowu()

      DestroyGIFuWin()
      If (thumbsDisplaying=0 && editingSelectionNow=1 && adjustNowSel=0 && drawingShapeNow=0)
         dotActiveObj := determineSelAreaClickRect(mX, mY, SelDotsSize, mainWidth, mainHeight, 1)

      If (showHUDnavIMG=1 && hasDrawnImageMap=1 && !dotActiveObj.n && (IMGlargerViewPort=1 && thumbsDisplaying=0 || thumbsDisplaying=1) && InStr(ctrlu, "|ImgNavBox|"))
      {
         invokeMenuNavBoxImgSizeVP()
         lastInvoked := A_TickCount
         Return
      } Else If (dotActiveObj.n>0 && dotActiveObj.n!=9 && editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1)
      {
         If (imgEditPanelOpened=1)
            BuildImgLiveEditMenu()
         Else
            invokeSelectionAreaMenu("DoubleClick")
         lastInvoked := A_TickCount
         Return
      } Else If (showHistogram>1 && hasDrawnHistoMap=1 && !dotActiveObj.n && thumbsDisplaying=0 && drawingShapeNow=0 && InStr(ctrlu, "|ImgHistoBox|"))
      ; && isDotInRect(mX, mY, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3], HUDobjHistoBoxu[4], HUDobjHistoBoxu[2] + HUDobjHistoBoxu[4]))
      {
         invokeHistoMenu()
         lastInvoked := A_TickCount
         Return
      }

      delayu := 1
      If (thumbsDisplaying=1 && maxFilesIndex>1 && !InStr(keyu, "appskey"))
      {
         delayu := 10
         r := WinClickAction("rclick", "nona", mX, mY)
         dummyTimerDelayiedImageDisplay(50)
      }
   } Else If (drawingShapeNow=0)
      Sleep, 350

   If (drawingShapeNow=1)
   {
      vpWinClientSize(mainWidth, mainHeight)
      ; GetMouseCoord2wind(PVhwnd, mX, mY)
      PerformVectorShapeActions(mX, mY, mainWidth, mainHeight, "rClick", 0, 0)
      Return
   }

   If (r="scrollbar")
      SetTimer, invokeNavigationMenu, -10
   Else If (r="StatusBar")
      SetTimer, MenuPanelFoldersTree, -10
   Else If (r="FsoloMenu")
      SetTimer, invokeFileOptionsMenu, -10
   Else If (InStr(keyu, "+") || InStr(keyu, "^"))
      SetTimer, BuildSecondMenu, % -10 - Round(delayu)
   Else If (r!="none")
      SetTimer, BuildMainMenu, % -10 - Round(delayu)

   lastInvoked := A_TickCount
   ; WinActivate, ahk_id %PVhwnd%
}

MeasureStringGdipLight(stringu, fontName, isBold, Size, xpos, ypos, Width, Height, Unit:=0, NoWrap:=1) {
   hFontFamily := Gdip_FontFamilyCreate(fontName)
   If !hFontFamily
      hFontFamily := Gdip_FontFamilyCreateGeneric(1)
   If !hFontFamily
      Return 0

   hFont := Gdip_FontCreate(hFontFamily, Size, isBold, Unit)
   If !hFont
      Return 0

   FormatStyle := NoWrap ? 0x4000 | 0x1000 : 0x4000
   hStringFormat := Gdip_StringFormatCreate(FormatStyle)
   If !hStringFormat
      hStringFormat := Gdip_StringFormatGetGeneric(1)

   CreateRectF(RC, xpos, ypos, Width, Height)
   ReturnRC := Gdip_MeasureString(2NDglPG, stringu, hFont, hStringFormat, RC)
   ReturnRCtest := StrSplit(ReturnRC, "|")
   testW := Floor(ReturnRCtest[3])

   Gdip_DeleteFont(hFont)
   Gdip_DeleteFontFamily(hFontFamily)
   Gdip_DeleteStringFormat(hStringFormat)
   RC := ""
   Return testW
}

PathCompact(givenPath, CharMax, allowOverflow:=0, fontSizeu:=0, givenWidth:=0, minChars:=0) {
    If (CharMax="a")
    {
       vpWinClientSize(mainWidth, mainHeight)
       mainWidth := givenWidth ? givenWidth : mainWidth//1.6 + 1
       borderSize := imgHUDbaseUnit//5
       txtResW := MeasureStringGdipLight(givenPath, OSDFontName, OSDfontBolded, fontSizeu, borderSize, 0, mainWidth*3, mainHeight)
       If (txtResW>=mainWidth - borderSize)
       {
          CharMax := Round((mainWidth/(txtResW / StrLen(givenPath))) + mainWidth/fontSizeu)//2 + 1
          If (CharMax<minChars)
             CharMax := minChars
       } Else CharMax := StrLen(givenPath)
       ; ToolTip, % txtResW "=" mainWidth "==" CharMax , , , 2
    }

    If (StrLen(givenPath)>CharMax+3)
    {
       partB := SubStr(givenPath, InStr(givenPath, "\", 0, 0))
       If (StrLen(partB)>CharMax && allowOverflow=0)
          partB := SubStr(givenPath, 1, 3) "[...]" SubStr(givenPath, -CharMax + 3)
       Else
          partA := SubStr(givenPath, 1, max(CharMax - StrLen(partB), 3)) "..."
       Return partA partB
    } Else Return givenPath
}

createMenuSelectionRotationAspectRatio() {
   ; defiSelAR := defineSelectionAspectRatios()
   kMenu("PVselRatio", "Add", "&Increase rotation by 1°`tShift+0", "MenuSelIncRotation",, " (selection area)", 1)
   kMenu("PVselRatio", "Add", "&Decrease rotation by 1°`tShift+9", "MenuSelDecRotation",, " (selection area)", 1)
   kMenu("PVselRatio", "Add", "R&otate selection by 45°`tShift+R", "MenuSelRotation",,, 1)
   If (VPselRotation>0)
      kMenu("PVselRatio", "Add", "R&eset rotation`tShift+\", "resetSelectionRotation",, " (selection area)")

   kMenu("PVselRatio", "Add/Uncheck", "&Keep aspect ratio on rotation", "ToggleSelKeepRatioRotation",, " (selection area)")
   If (rotateSelBoundsKeepRatio=1)
      kMenu("PVselRatio", "Check", "&Keep aspect ratio on rotation",,, " (selection area)")

   kMenu("PVselRatio", "Add", "Set to s&quare ratio (1:1)`tR", "makeSquareSelection",, " (selection area)")
   If (lockSelectionAspectRatio>1)
      kMenu("PVselRatio", "Disable", "Set to s&quare ratio (1:1)`tR",,, " (selection area)")

   Menu, PVselRatio, Add
   kMenu("PVselRatio", "Add", "Cycle loc&k aspect ratios`tShift+A", "toggleImgSelectionAspectRatio",,,1)
   kMenu("PVselRatio", "Add/Uncheck", "&Unlocked", "MenuSetLockSelRatioUnlocked",," aspect ratio (selection)")
   kMenu("PVselRatio", "Add/Uncheck", "&Active selection`tCtrl+Shift+A", "MenuSetLockSelRatioSelu",, "Lock aspect ratio to " sillySeparator)
   kMenu("PVselRatio", "Add/Uncheck", "&Current window", "MenuSetLockSelRatioWindow",, " (selection aspect ratio)")
   kMenu("PVselRatio", "Add/Uncheck", "&Current image", "MenuSetLockSelRatioImage",, " (selection aspect ratio)")
   kMenu("PVselRatio", "Add/Uncheck", "&Square [1:1]", "MenuSetLockSelRatioSquare",, " (selection aspect ratio)")
   kMenu("PVselRatio", "Add/Uncheck", "&SDTV [4:3]", "MenuSetLockSelRatioSDTV",, " (selection aspect ratio)")
   kMenu("PVselRatio", "Add/Uncheck", "&35mm film [3:2]", "MenuSetLockSelRatio35mmFilm",, " (selection aspect ratio)")
   kMenu("PVselRatio", "Add/Uncheck", "&HDTV [16:9]", "MenuSetLockSelRatioHDTV",, " (selection aspect ratio)")
   kMenu("PVselRatio", "Add/Uncheck", "&Wide screens [16:10]", "MenuSetLockSelRatioWide",, " (selection aspect ratio)")
   kMenu("PVselRatio", "Add/Uncheck", "&Phone", "MenuSetLockSelRatioPhone",, " (selection aspect ratio)")
   If (lockSelectionAspectRatio<=1)
      kMenu("PVselRatio", "Check", "&Unlocked",,, " aspect ratio (selection)")
   Else If (lockSelectionAspectRatio=2)
      kMenu("PVselRatio", "Check", "&Active selection`tCtrl+Shift+A",,, "Lock aspect ratio to " sillySeparator)
   Else If (lockSelectionAspectRatio=3)
      kMenu("PVselRatio", "Check", "&Current window",,, " (selection aspect ratio)")
   Else If (lockSelectionAspectRatio=4)
      kMenu("PVselRatio", "Check", "&Current image",,, " (selection aspect ratio)")
   Else If (lockSelectionAspectRatio=5)
      kMenu("PVselRatio", "Check", "&Square [1:1]",,, " (selection aspect ratio)")
   Else If (lockSelectionAspectRatio=6)
      kMenu("PVselRatio", "Check", "&SDTV [4:3]",,, " (selection aspect ratio)")
   Else If (lockSelectionAspectRatio=7)
      kMenu("PVselRatio", "Check", "&35mm film [3:2]",,, " (selection aspect ratio)")
   Else If (lockSelectionAspectRatio=8)
      kMenu("PVselRatio", "Check", "&HDTV [16:9]",,, " (selection aspect ratio)")
   Else If (lockSelectionAspectRatio=9)
      kMenu("PVselRatio", "Check", "&Wide screens [16:10]",,, " (selection aspect ratio)")
   Else If (lockSelectionAspectRatio=10)
      kMenu("PVselRatio", "Check", "&Phone",,, " (selection aspect ratio)")
}

createMenuSelectionAlign(modus:=0) {
   labelu := (modus="selProp") ? "Selection alignment" : "Inside"
   kMenu("PVselAlign", "Add", labelu, "dummy")
   kMenu("PVselAlign", "Disable", labelu)
   kbdu := (modus!="selProp") ? "`tCtrl+NumPad 8" : ""
   kMenu("PVselAlign", "Add", "&Top" kbdu, "alignImgSelectTop",, "Align selection: " sillySeparator)
   kbdu := (modus!="selProp") ? "`tCtrl+NumPad 2" : ""
   kMenu("PVselAlign", "Add", "&Bottom" kbdu, "alignImgSelectBottom",, "Align selection: " sillySeparator)
   kbdu := (modus!="selProp") ? "`tCtrl+NumPad 4" : ""
   kMenu("PVselAlign", "Add", "&Left" kbdu, "alignImgSelectLeft",, "Align selection: " sillySeparator)
   kbdu := (modus!="selProp") ? "`tCtrl+NumPad 6" : ""
   kMenu("PVselAlign", "Add", "&Right" kbdu, "alignImgSelectRight",, "Align selection: " sillySeparator)
   Menu, PVselAlign, Add
   kbdu := (modus!="selProp") ? "`tCtrl+NumPad 5" : ""
   kMenu("PVselAlign", "Add", "&Center horizontally" kbdu, "alignImgSelectCenterH",, "Align selection: " sillySeparator)
   kbdu := (modus!="selProp") ? "`tCtrl+NumPad 0" : ""
   kMenu("PVselAlign", "Add", "Center &vertically" kbdu, "alignImgSelectCenterV",, "Align selection: " sillySeparator)
   kMenu("PVselAlign", "Add", "Centere&d", "alignImgSelectCentered",, "Align selection: " sillySeparator)
   If (isVarEqualTo(AnyWindowOpen, 74, 65, 32, 31, 24, 23) && !viewportQPVimage.imgHandle)
   {
      Menu, PVselAlign, Add
      kMenu("PVselAlign", "Add", "Outside", "dummy")
      kMenu("PVselAlign", "Disable", "Outside")
      kMenu("PVselAlign", "Add", "&Top", "alignImgSelectOutTop",, "Align selection outside: " sillySeparator)
      kMenu("PVselAlign", "Add", "&Bottom", "alignImgSelectOutBottom",, "Align selection outside: " sillySeparator)
      kMenu("PVselAlign", "Add", "&Left", "alignImgSelectOutLeft",, "Align selection outside: " sillySeparator)
      kMenu("PVselAlign", "Add", "&Right", "alignImgSelectOutRight",, "Align selection outside: " sillySeparator)
   }
}

createMenuSelectShapeTension() {
   keyuA := (drawingShapeNow=1) ? "`tB" : ""
   kMenu("PVshapeTension", "Add/Uncheck", "Bézier spline" keyuA, "MenuToggleBezierMode", "bezier bspline shape tension anchors")

   Menu, PVshapeTension, Add
   keyuB := (drawingShapeNow=1) ? "`tT" : ""
   kMenu("PVshapeTension", "Add", "&Cycle smoothness levels" keyuB, "togglePathCurveTension", "shape tension")
   Menu, PVshapeTension, Add
   kMenu("PVshapeTension", "Add/Uncheck", "&Polygonal", "MenuSetShapeTensionP", "shape tension")
   kMenu("PVshapeTension", "Add/Uncheck", "&Smooth corners", "MenuSetShapeTensionS", "shape tension")
   kMenu("PVshapeTension", "Add/Uncheck", "&Curve", "MenuSetShapeTensionC", "shape tension")
   kMenu("PVshapeTension", "Add/Uncheck", "&Rounded curve", "MenuSetShapeTensionR", "shape tension")
   If (FillAreaCurveTension=1)
      kMenu("PVshapeTension", "Check", "&Polygonal")
   Else If (FillAreaCurveTension=2)
      kMenu("PVshapeTension", "Check", "&Smooth corners")
   Else If (FillAreaCurveTension=3)
      kMenu("PVshapeTension", "Check", "&Curve")
   Else If (FillAreaCurveTension=4)
      kMenu("PVshapeTension", "Check", "&Rounded curve")

   ; kMenu("PVshapeTension", "Disable", "&Cycle smoothness levels" keyuB, "togglePathCurveTension", "shape tension")
   If (bezierSplineCustomShape=1)
      kMenu("PVshapeTension", "Check", "Bézier spline" keyuA)

   If (bezierSplineCustomShape=1 || FillAreaCurveTension>1)
   {
      Menu, PVshapeTension, Add
      kMenu("PVshapeTension", "Add", "Convert to polygonal shape", "MenuConvertShapeToPoly", "rasterize")
      If (drawingShapeNow!=1)
         kMenu("PVshapeTension", "Disable", "Convert to polygonal shape")
   }
}

createMenuSelectSizeShapes(dummy:=0, b:=0) {
   If (dummy!="simple")
   {
      kMenu("PVselSize", "Add", "C&ycle selection types`tShift+E", "toggleEllipseSelection")
      kMenu("PVselSize", "Add/Uncheck", "&Rectangular", "MenuSetSelectionShapeRect", "shape type", "Selection type: " sillySeparator)
      kMenu("PVselSize", "Add/Uncheck", "&Ellipse / oval", "MenuSetSelectionShapeEllipse", "shape type", "Selection type: " sillySeparator)
      kMenu("PVselSize", "Add/Uncheck", "&Custom shape", "MenuSetSelectionShapeFreeform", "freeform type spline polygonal", "Selection type: " sillySeparator)

      If (EllipseSelectMode=1)
         kMenu("PVselSize", "Check", "&Ellipse / oval",,, "Selection type: " sillySeparator)
      Else If (EllipseSelectMode=2)
         kMenu("PVselSize", "Check", "&Custom shape",,, "Selection type: " sillySeparator)
      Else
         kMenu("PVselSize", "Check", "&Rectangular",,, "Selection type: " sillySeparator)
   }

   friendly := AnyWindowOpen ? "" : "Manage / "
   If (dummy!="mnb" && b!="mnb")
   {
      Menu, PVselSize, Add
      kMenu("PVselSize", "Add", friendly "Load custom shapes", "PanelManageVectorShapes", "freeform presets vector restore premade forms triangle moon cloud crescent heart water droplet rhombus star christian cross callout")
   }

   infoKbd := (EllipseSelectMode!=2) ? "`tShift+L" : ""
   If (dummy!="simple" && dummy!="mnb")
      kMenu("PVselSize", "Add", "&Define new freeform shape" infoKbd, "MenuStartDrawingSelectionArea", "edit freeform draw selection")

   If (EllipseSelectMode=2)
   {
      Menu, PVselSize, Add
      createMenuSelectShapeTension()
      If !AnyWindowOpen
         kMenu("PVselSize", "Add", "Save vector shape", "BtnSaveVectorShape")
      kMenu("PVselSize", "Add", "&Modify custom shape`tShift+L", "MenuResumeDrawingShapes", "edit draw freeform selection")
      keyu := (AnyWindowOpen) ? "`tShift+H" : ""
      kMenu("PVselSize", "Add", "Flip shape &horizontally" keyu, "MenuSelectionFlipH")
      keyu := (AnyWindowOpen) ? "`tShift+V" : ""
      kMenu("PVselSize", "Add", "&Flip shape vertically" keyu, "MenuSelectionFlipV")
      kMenu("PVselSize", "Add/Uncheck", "&Open ended path", "toggleOpenClosedViewerCustomShape", "opened closed vector")
      kMenu("PVselSize", "Add", "Set &points tension", ":PVshapeTension")
      If (closedLineCustomShape=0)
         kMenu("PVselSize", "Check", "&Open ended path")
   }
}

MenuSelAreaMoveUp() {
   arrowKeysAdjustSelectionArea(-2, 1)
   arrowKeysAdjustSelectionArea(-2, 2)
}

MenuSelAreaMoveDown() {
   arrowKeysAdjustSelectionArea(2, 1)
   arrowKeysAdjustSelectionArea(2, 2)
}

MenuSelAreaMoveLeft() {
   arrowKeysAdjustSelectionArea(-1, 1)
   arrowKeysAdjustSelectionArea(-1, 2)
}

MenuSelAreaMoveRight() {
   arrowKeysAdjustSelectionArea(1, 1)
   arrowKeysAdjustSelectionArea(1, 2)
}

focusToolbarNavKeys() {
   If (ShowAdvToolbar=1 && hQPVtoolbar)
   {
      WinActivate, ahk_id %hQPVtoolbar%
      isToolbarKBDnav := 1
      displayNowToolbarHelp(2)
      interfaceThread.ahkassign("isToolbarKBDnav", isToolbarKBDnav)
   }
}

addMenuBonusesSelectionArea() {
   If (mustPreventMenus=1 && editingSelectionNow=1)
   {
      kMenu("PVselv", "Add", "Move selection: up`tHome", "MenuSelAreaMoveUp",,,1)
      kMenu("PVselv", "Add", "Move selection: down`tEnd", "MenuSelAreaMoveDown",,,1)
      kMenu("PVselv", "Add", "Move selection: right`tPage up", "MenuSelAreaMoveLeft",,,1)
      kMenu("PVselv", "Add", "Move selection: left`tPage down", "MenuSelAreaMoveRight",,,1)
      kMenu("PVselv", "Add", "Enlarge selection area`tShift+-", "MenuIncSelAreaSize", "increase size",,1)
      kMenu("PVselv", "Add", "Shrink selection area`tShift+=", "MenuDecSelAreaSize", "decrease size",,1)
      kMenu("PVselv", "Add", "Increase exclusion (selection area)`tCtrl+.", "MenuIncSelAreaCavity", "hallow",,1)
      kMenu("PVselv", "Add", "Decrease exclusion (selection area)`tCtrl+,", "MenuDecSelAreaCavity", "hallow",,1)
      If (innerSelectionCavityX>0 && innerSelectionCavityY>0 || VPselRotation!=0)
         kMenu("PVselv", "Add", "Reset selection area rotation and exclusion`tAlt+\", "MenuResetSelAreaCavityRotation")
   }
}

MenuSearchNextIndex() {
   searchNextIndex(1)
}

MenuSearchPrevIndex() {
   searchNextIndex(-1)
}

testUndoImgSelections() {
   totalSelUndos := Round(undoSelLevelsArray.Count())
   isOkay := (validBMP(UserMemBMP) || viewportQPVimage.imgHandle && viewportQPVimage.actions>0) ? 1 : 0
   r := ((undoLevelsRecorded>1 && undoLevelsRecorded!="" || isOkay=1) && totalSelUndos>0 && editingSelectionNow=1) ? 1 :
   Return r
}

createMenuSelectionArea(modus:=0) {
   If (modus="DoubleClick")
   {
      kMenu("PVselv", "Add", "Main menu`tAppsKey", "InitGuiContextForcedMenu")
      Menu, PVselv, Add 
   }

   infoImgEditingNow := isImgEditingNow()
   If (infoImgEditingNow=1 && testUndoImgSelections()=1)
   {
      friendly := (modus="DoubleClick") ? " selection" : ""
      f := (modus="DoubleClick") ? "" : " (selection area)"
      kMenu("PVselv", "Add", "&Undo" friendly "`tCtrl+Shift+Z", "ImgSelUndoAct",, f)
      kMenu("PVselv", "Add", "&Redo" friendly "`tCtrl+Shift+Y", "ImgSelRedoAct",, f)
      Menu, PVselv, Add
   }

   If (infoImgEditingNow=1)
   {
      keyword := (editingSelectionNow=1) ? "hide" : " display"
      kMenu("PVselv", "Add/Uncheck", "&Show selection area`tE", "ToggleEditImgSelection", keyword)
      If (editingSelectionNow=1)
         kMenu("PVselv", "Check", "&Show selection area`tE")
   }

   addMenuBonusesSelectionArea()
   If (modus!="DoubleClick")
      kMenu("PVselv", "Add", "&Drop and reset`tCtrl+D", "resetImgSelection", "hide", " (selection area)")

   If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
      kMenu("PVselv", "Add", "R&eset exclusion area`tShift+\", "resetSelectionAreaCavity",, " (selection area)")

   If (infoImgEditingNow=1)
      kMenu("PVselv", "Add", "Se&lect all`tCtrl+A", "selectEntireImage",, " (image canvas)")

   If (editingSelectionNow=1 && infoImgEditingNow=1)
   {
      createMenuSelectSizeShapes()
      createMenuSelectionAlign()
      kMenu("PVselv", "Add/Uncheck", "Limit to image bo&undaries`tL", "toggleLimitSelection",, " (selection area)")
      kMenu("PVselv", "Add", "Flip width / &height`tW", "flipSelectionWH",, " (selection area)")
      If (LimitSelectBoundsImg=1)
         kMenu("PVselv", "Check", "Limit to image bo&undaries`tL",,, " (selection area)")

      createMenuSelectionRotationAspectRatio()
      kMenu("PVselv", "Add", "&Selection shapes", ":PVselSize")
      kMenu("PVselv", "Add", "Ali&gnment", ":PVselAlign")
      kMenu("PVselv", "Add", "Rotation and &aspect ratio", ":PVselRatio")
      Menu, PVselv, Add, 
      If isSelEntireOutside()
         kMenu("PVselv", "Add", "Focus selection area", "focusImgSelArea", "find viewport", " (selection area)")
      keyword := (editingSelectionNow=1) ? "hide" : " display"
      kMenu("PVselv", "Add/Uncheck", "Sho&w grid", "ToggleSelectGrid", keyword, " (selection area)")
      If (showSelectionGrid=1)
         kMenu("PVselv", "Check", "Sho&w grid",,, " (selection area)")
   }

   If (infoImgEditingNow=1)
      kMenu("PVselv", "Add", "Selection properties`tAlt+E", "PanelIMGselProperties")

   If (infoImgEditingNow=1 && modus="DoubleClick")
   {
      createMenuImageEditSubMenus()
      createMenuAlphaMask()
      Menu, PVselv, Add
      If (editingSelectionNow=1)
         kMenu("PVselv", "Add", "C&ut selected area`tCtrl+X", "CutSelectedArea", "image")

      kMenu("PVselv", "Add", "&Copy to clipboard`tCtrl+C", "CopyImage2clip", "image")
      If (editingSelectionNow=1)
         kMenu("PVselv", "Add", "&Paste in place`tCtrl+Shift+V", "PanelPasteInPlace", "image editing")

      Menu, PVselv, Add
      Try kMenu("PVselv", "Add", "Alpha mas&k", ":PValpha")
      kMenu("PVselv", "Add", "&Filters", ":PVimgFilters")
      kMenu("PVselv", "Add", "&Draw", ":PVimgDraw")
      kMenu("PVselv", "Add", "&Transform", ":PVimgTransform")
   }
}

createMenuConvertColorDepths() {
   Try Menu, PVimgClrDepths, Delete
   If (!viewportQPVimage.imgHandle || viewportQPVimage.LoadedWith!="fim")
      Return

   If (mustPreventMenus!=1)
   {
      kMenu("PVimgClrDepths", "Add", "CURRENT DEPTH:", "dummy")
      kMenu("PVimgClrDepths", "Disable", "CURRENT DEPTH:")
      If !viewportQPVimage.clrinfo
      {
         oimgBPP := FreeImage_GetBPP(viewportQPVimage.imgHandle)
         ColorsType := FreeImage_GetColorType(viewportQPVimage.imgHandle)
         viewportQPVimage.clrinfo := oimgBPP "-bit " ColorsType
      }
      infou := viewportQPVimage.clrinfo
      kMenu("PVimgClrDepths", "Add", infou, "dummy")
      kMenu("PVimgClrDepths", "Disable", infou)
      kMenu("PVimgClrDepths", "AddSeparator", 0)
   }

   kMenu("PVimgClrDepths", "Add", "Black and white (1-bit, dithered)", "MenuConvertClrBW", "grayscale")
   kMenu("PVimgClrDepths", "Add", "8-bit (greyscale)", "MenuConvertClrGray", "grayscale")
   kMenu("PVimgClrDepths", "Add", "8-bit (dithered colors)", "MenuConvertClr8bit")
   kMenu("PVimgClrDepths", "Add", "16-bit", "MenuConvertClr16bit")
   kMenu("PVimgClrDepths", "Add", "24-bit", "MenuConvertClr24bit")
   kMenu("PVimgClrDepths", "Add", "32-bit", "MenuConvertClr32bit")
}

MenuConvertClrBW() {
   HugeImagesConvertClrDepth("bw")
}
MenuConvertClrGray() {
   HugeImagesConvertClrDepth("gray")
}

MenuConvertClr8bit() {
   HugeImagesConvertClrDepth(8)
}

MenuConvertClr16bit() {
   HugeImagesConvertClrDepth(16)
}


MenuConvertClr24bit() {
   HugeImagesConvertClrDepth(24)
}

MenuConvertClr32bit() {
   HugeImagesConvertClrDepth(32)
}

createMenuImageEditSubMenus(modus:=0) {
   infoImgEditingNow := isImgEditingNow()
   If (thumbsDisplaying!=1 && infoImgEditingNow=1)
   {
      createMenuConvertColorDepths()
      kMenu("PVimgFilters", "Add", "&Gaussian and other blur modes`tShift+B", "PanelBlurSelectedArea", "effects motion directional dissolve dilate erode box glow")
      kMenu("PVimgFilters", "Add", "&Radial blur", "PanelZoomBlurSelectedArea", "effects motion directional zoom")
      kMenu("PVimgFilters", "Add", "&Pixelize", "PanelPixelizeSelectedArea", "pixelization mozaic deform", " image")
      kMenu("PVimgFilters", "Add", "S&harpen", "PanelSharpenImage", "effects", " image")
      Menu, PVimgFilters, Add
      kMenu("PVimgFilters", "Add", "A&utomatic contrast / levels", "PanelAutoColors")
      kMenu("PVimgFilters", "Add", "&Invert colors`tShift+I", "InvertSelectedArea", "effects negative")
      kMenu("PVimgFilters", "Add", "Desaturate color&s`tCtrl+G", "PanelDesatureSelectedArea", "grayscale effects")
      kMenu("PVimgFilters", "Add", "Ad&just image colors`tU", "PanelAdjustColorsSimpleWindow", "grayscale effects lightness contrast saturation levels brightness")
      If (AnyWindowOpen!=10)
         kMenu("PVimgFilters", "Add", "Appl&y viewport color effects`tCtrl+Shift+U", "ApplyVPcolorAdjustSelectedArea")

      Menu, PVimgFilters, Add
      kMenu("PVimgFilters", "Add", "&Add noise", "PanelAddNoiserImage", "effects clouds plasma")
      kMenu("PVimgFilters", "Add", "Create s&ymmetry or patterns", "PanelSymmetricaImage", "generate textures tiles mirroring patterns")
      kMenu("PVimgFilters", "Add", "&Detect edges", "PanelDetectEdgesImage", "emboss effects")
      If (modus="filters")
         Return

      kMenu("PVimgDraw", "Add", "Define f&reeform filled shape`tShift+P", "MenuRealStartDrawingShapes", "curve polygonal")
      kMenu("PVimgDraw", "Add", "Define freeform &outline`tAlt+P", "MenuRealStartDrawingLines", "curve polygonal lines")
      kMenu("PVimgDraw", "Add", "&Paint brushes`tP", "PanelBrushTool", "pinch bulge effects draw deformer smudge cloner effects")
      kMenu("PVimgDraw", "Add", "&Erase or fade area`tDelete", "PanelEraseSelectedArea")
      kMenu("PVimgDraw", "Add", "&Flood fill / color bucket`tK", "PanelFloodFillTool", "colorize similarity cartoon")
      kMenu("PVimgDraw", "Add", "&Fill shapes`tAlt+Backspace", "tlbrFillShape", "curve polygonal glass effects blur pie ellipse triangle rhombus gradients rectangle")
      kMenu("PVimgDraw", "Add", "Fill be&hind image", "PanelFillBehindBgrImage", "background")
      kMenu("PVimgDraw", "Add", "Draw s&hape contours`tCtrl+L", "tlbrDrawShapesContour", "lines curve polygonal pie ellipse triangle rhombus rectangle arcs")
      kMenu("PVimgDraw", "Add", "&Draw parametric lines", "PanelDrawLines", "lines arcs diagonals spiral rays spokes grids")
      kMenu("PVimgDraw", "Add", "Insert te&xt`tShift+T", "PanelInsertTextArea", "write add draw type")

      kMenu("PVimgTransform", "Add", "Rectangular to &polar", "doRectPolarTransformSelectedArea", "coordinates transform circular deform")
      kMenu("PVimgTransform", "Add", "Polar to rectan&gular", "doPolarRectTransformSelectedArea", "coordinates transform circular deform")
      Menu, PVimgTransform, Add
      kMenu("PVimgTransform", "Add", "&Adjust canvas size`tAlt+A", "PanelAdjustImageCanvasSize")
      kMenu("PVimgTransform", "Add", "&Resize image`tCtrl+R", "PanelEditorImgResize")
      kMenu("PVimgTransform", "Add", "A&uto-crop image(s)`tAlt+Y", "PanelImgAutoCrop")
      kMenu("PVimgTransform", "Add", "A&dvanced live transform`tCtrl+T", "PanelTransformSelectedArea", "crop rotate resize clone blend alpha-masking flip blur glass effects adjust colors")
      Menu, PVimgTransform, Add 
      f := (editingSelectionNow=1) ? "selected " : ""
      keyu := (AnyWindowOpen) ? "" : "`tShift+H"
      kMenu("PVimgTransform", "Add", "Flip " f "&horizontally" keyu, "FlipSelectedAreaH")
      keyu := (AnyWindowOpen) ? "" : "`tShift+V"
      kMenu("PVimgTransform", "Add", "Flip " f "&vertically" keyu, "FlipSelectedAreaV")
      kMenu("PVimgTransform", "Add", "Rotate image by 90°`tCtrl+Shift+R", "MenuRotateEditImagePlus")
      kMenu("PVimgTransform", "Add", "Rotate image by -90°", "MenuRotateEditImageMinus")
      Menu, PVimgTransform, Add 
      kMenu("PVimgTransform", "Add", "&Crop image to selection`tShift+Enter", "CropImageInViewPortToSelection")
      kMenu("PVimgTransform", "Add", "&Resize image to selection`tAlt+R", "ResizeIMGviewportSelection")

      If (editingSelectionNow!=1)
      {
         kMenu("PVimgDraw", "Disable", "&Erase or fade area`tDelete")
         kMenu("PVimgTransform", "Disable", "A&dvanced live transform`tCtrl+T")
         kMenu("PVimgTransform", "Disable", "&Crop image to selection`tShift+Enter")
         kMenu("PVimgTransform", "Disable", "&Resize image to selection`tAlt+R")
      }
   }
}

InvokeMenuBarVectorFile(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarFile, Delete

   kMenu("pvMenuBarFile", "Add", "Vector drawing mode", "dummy")
   kMenu("pvMenuBarFile", "Disable", "Vector drawing mode")
   Menu, pvMenuBarFile, Add
   createVectorMenuToolModes()
   kMenu("pvMenuBarFile", "Add", "&Tool mode", ":pvVectModes")
   Menu, pvMenuBarFile, Add
   kMenu("pvMenuBarFile", "Add", "&Apply / done`tEnter", "stopDrawingShape")
   kMenu("pvMenuBarFile", "Add", "&Exit pen tool mode`tEscape", "MenuCancelDrawingShape")
   showThisMenu("pvMenuBarFile", 0, 1, manuID)
}

InvokeMenuBarVectorInterface(manuID) {
   deleteMenus()
   createMenuInterfaceOptions()
   showThisMenu("PvUIprefs", 0, 1, manuID)
}

InvokeMenuBarVectorView(manuID, modus:=0) {
   If (modus!="extern")
      deleteMenus()
   Try Menu, pvMenuBarView, Delete

   createMenuImgSizeAdapt()
   kMenu("pvMenuBarView", "Add", "Zoom adapt modes", ":PvImgAdapt")
   Menu, pvMenuBarView, Add
   createMenuImgColorsFX()
   kMenu("pvMenuBarView", "Add", "Colors F&X and display modes", ":PVimgColorsFX")
   kMenu("pvMenuBarView", "Add", "Reset vie&wport adjustments`t\", "ResetImageView", "image")
   Menu, pvMenuBarView, Add
   kMenu("pvMenuBarView", "Add", "Focus end point/first selected`tW", "focusVectorEndPoint")
   kMenu("pvMenuBarView", "Add/Uncheck", "Show viewport &grid`tG", "toggleViewPortGridu")
   kMenu("pvMenuBarView", "Add/Uncheck", "Fi&xed grid size", "toggleGridFixedSize")
   If (vpGridFixedSize=1)
      kMenu("pvMenuBarView", "Check", "Fi&xed grid size")
   If (showViewPortGrid=1)
      kMenu("pvMenuBarView", "Check", "Show viewport &grid`tG")

   kMenu("pvMenuBarView", "Add", "Increase grid size`tAlt+=", "MenuIncVPgridSize",,,1)
   kMenu("pvMenuBarView", "Add", "Decrease grid size`tAlt+-", "MenuDecVPgridSize",,,1)
   Menu, pvMenuBarView, Add
   kMenu("pvMenuBarView", "Add/Uncheck", "Centered &alignment`tA", "ToggleIMGalign", "viewport image position")
   If (imageAligned=5)
      kMenu("pvMenuBarView", "Check", "Centered &alignment`tA")

   kMenu("pvMenuBarView", "Add/Uncheck", "Allo&w outside viewport image panning", "toggleFreePanning")
   If (allowFreeIMGpanning=1)
      kMenu("pvMenuBarView", "Check", "Allo&w outside viewport image panning")

   If (modus!="extern")
      showThisMenu("pvMenuBarView", 0, 1, manuID)
}

InvokeMenuBarVectorSelection(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarSelection, Delete

   kMenu("pvMenuBarSelection", "Add", "Select all points`tCtrl+A", "MenuSelAllVectorPoints")
   kMenu("pvMenuBarSelection", "Add", "Total points: " groupDigits(customShapePoints.count()), "dummy")
   kMenu("pvMenuBarSelection", "Disable", "Total points: " groupDigits(customShapePoints.count()))
   If (customShapeHasSelectedPoints=1)
   {
      Menu, pvMenuBarSelection, Add
      If (bezierSplineCustomShape!=1)
         kMenu("pvMenuBarSelection", "Add", "Cop&y points", "MenuCopyVectorPoints")

      kMenu("pvMenuBarSelection", "Add", "Deselect points`tCtrl+D", "MenuSelNoVectorPoints")
      kMenu("pvMenuBarSelection", "Add", "In&vert points selection`tShift+I", "MenuSelInvertVectorPoints")
      kMenu("pvMenuBarSelection", "Add", "&Delete selected points`tDelete", "MenuRemSelVectorPoints")
      If (bezierSplineCustomShape=1)
      {
         kMenu("pvMenuBarSelection", "Add", "&Collapse anchors for selected points", "MenuCollapseSelectedAnchorPoints")
         kMenu("pvMenuBarSelection", "Add", "&Expand anchors for selected points", "MenuExpandSelectedAnchorPoints")
      }
   }

   showThisMenu("pvMenuBarSelection", 0, 1, manuID)
}

InvokeMenuBarVectorEdit(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarEdit, Delete

   undos := undoVectorShapesLevelsArray.Count()
   If (currentVectorUndoLevel>1 || undos>1)
   {
      kMenu("pvMenuBarEdit", "Add", "&Undo`tCtrl+Z", "ImgVectorUndoAct")
      kMenu("pvMenuBarEdit", "Add", "&Redo`tCtrl+Y", "ImgVectorRedoAct")
      kMenu("pvMenuBarEdit", "Add", "Levels: " groupDigits(undos), "dummy")
      kMenu("pvMenuBarEdit", "Disable", "Levels: " groupDigits(undos))
      Menu, pvMenuBarEdit, Add
   }

   kMenu("pvMenuBarEdit", "Add", "&Remove end point`tBackspace", "reduceCustomShapeLength")
   kMenu("pvMenuBarEdit", "Add", "C&ycle symmetry modes`tY", "toggleBrushSymmetryModes")
   createMenuSelectShapeTension()
   kMenu("pvMenuBarEdit", "Add", "&Path type / smoothness", ":PVshapeTension")
   If (vectorToolModus<3)
   {
      kMenu("pvMenuBarEdit", "Add/Uncheck", "&Preview new point`tP", "togglePreviewVectorNewPoint")
      If (showNewVectorPointPreview=1)
         kMenu("pvMenuBarEdit", "Check", "&Preview new point`tP")
   }

   If (bezierSplineCustomShape=1)
   {
      kMenu("pvMenuBarEdit", "Add/Uncheck", "Symmetrical anchors`tR", "toggleAutoReflectAnchors")
      If (autoReflectVectorAnchors=1)
         kMenu("pvMenuBarEdit", "Check", "Symmetrical anchors`tR")
   }

   kMenu("pvMenuBarEdit", "Add/Uncheck", "&Open ended path`tO", "toggleOpenClosedLineEditorCustomShape", "opened closed vector")
   If (closedLineCustomShape=0)
      kMenu("pvMenuBarEdit", "Check", "&Open ended path`tO")

   showThisMenu("pvMenuBarEdit", 0, 1, manuID)
}

InvokeMenuBarEditorFile(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarFile, Delete

   kMenu("pvMenuBarFile", "Add", "Live tool mode", "dummy")
   kMenu("pvMenuBarFile", "Disable", "Live tool mode")
   kMenu("pvMenuBarFile", "Add/Uncheck", "&Collapse tool panel`tF11", "toggleImgEditPanelWindow")
   If (panelWinCollapsed=1)
      kMenu("pvMenuBarFile", "Check", "&Collapse tool panel`tF11")

   drawing := isNowAlphaPainting()
   If (drawing!=1)
      kMenu("pvMenuBarFile", "Add", "&Cancel / close panel`tEscape", "BtnCloseWindow")

   If (!isVarEqualTo(AnyWindowOpen, 10  64, 66) && imgEditPanelOpened=1)
      kMenu("pvMenuBarFile", "Add", "Appl&y tool`tEnter", "applyIMGeditFunction")

   Try Menu, PVtActFile, Delete
   zPlitPath(resultedFilesList[currentFileIndex, 1], 0, OutFileName, OutDir)
   If FileExist(resultedFilesList[currentFileIndex, 1])
   {
      kMenu("PVtActFile", "Add", "Open with default application", "OpenWithDefaultApp")
      kMenu("PVtActFile", "Add", "&Open with external app", "OpenThisFileMenu")
      kMenu("PVtActFile", "Add", "Open file in a new &QPV instance", "SoloNewQPVinstance")
      kMenu("PVtActFile", "Add", "System «Open with» dialog", "MenuInvokeSHopenWith", "external")

      Menu, pvMenuBarFile, Add
      kMenu("pvMenuBarFile", "Add", "Open this&...", ":PVtActFile")
      kMenu("pvMenuBarFile", "Add", "&New QPV instance`tCtrl+Shift+N", "OpenNewQPVinstance")
      kMenu("pvMenuBarFile", "Add", "File prope&rties (Explorer)", "OpenFileProperties")
      kMenu("pvMenuBarFile", "Add", "&Explore containing folder", "OpenThisFileFolder")
      If !FolderExist(OutDir)
         kMenu("pvMenuBarFile", "Disable", "&Explore containing folder")
   }

   showThisMenu("pvMenuBarFile", 0, 1, manuID)
}

InvokeMenuBarFile(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarFile, Delete
   createMenuOpenRecents("simple")
   createMenuFavourites()

   If (thumbsDisplaying!=1)
   {
      kMenu("pvMenuBarFile", "Add", "New image`tCtrl+N", "PanelNewImage", "image editing")
      If isImgEditingNow()
      {
         If validBMP(UserMemBMP)
         {
            kMenu("pvMenuBarFile", "Add", "&Save image`tCtrl+S", "PanelSaveImg", "image edit")
            If FileExist(resultedFilesList[currentFileIndex, 1])
               kMenu("pvMenuBarFile", "Add", "&Revert changes...`tF5", "RefreshImageFileAction", "reload refresh")
         } Else
            kMenu("pvMenuBarFile", "Add", "&Save image as...`tCtrl+S", "PanelSaveImg", "image editing")
         
         kMenu("pvMenuBarFile", "Add", "Print image(s)`tCtrl+P", "PanelPrintImage")
         If FileExist(getIDimage(currentFileIndex))
            kMenu("pvMenuBarFile", "Add", "&Reload file`tF5", "RefreshImageFileAction", "purge revert")
      }

      kMenu("pvMenuBarFile", "Add", "Ac&quire image (WIA)", "AcquireWIAimage", "capture devices")
      Menu, pvMenuBarFile, Add
   }

   kMenu("pvMenuBarFile", "Add", "&Open image or slideshow`tCtrl+O", "OpenDialogFiles", "open image files")
   kMenu("pvMenuBarFile", "Add", "&Open folder recursively`tShift+O", "OpenFolders", "open image folder files")
   kMenu("pvMenuBarFile", "Add", "&New QPV instance`tCtrl+Shift+N", "OpenNewQPVinstance")
   If (maxFilesIndex<1 || !CurrentSLD)
   {
      kMenu("pvMenuBarFile", "Add", "Insert &file(s)`tInsert", "addNewFile2list", "images list")
      kMenu("pvMenuBarFile", "Add", "&Manage folders list`tAlt+U", "PanelDynamicFolderzWindow")
   }

   Menu, pvMenuBarFile, Add
   kMenu("pvMenuBarFile", "Add", "&Recents", ":PVopenF", "files recent")
   kMenu("pvMenuBarFile", "Add", "Fa&vourites", ":PVfaves", "files favourites")
   If (thumbsDisplaying=1 && maxFilesIndex>0)
   {
      Menu, pvMenuBarFile, Add,
      If (markedSelectFile>0)
      {
         createMenuSoloFile("simple")
         kMenu("pvMenuBarFile", "Add", "Active / focused file", ":PVtActFile")
         Menu, pvMenuBarFile, Add
      }

      If !markedSelectFile
      {
         createMenuOpenFileOptions("simple")
         kMenu("pvMenuBarFile", "Add", "Open this&...", ":PVtFileOpen")
         kMenu("pvMenuBarFile", "Add", "File inform&ations`tAlt+Enter", "PanelImageInfos")
         kMenu("pvMenuBarFile", "Add", "File prope&rties (Explorer)", "OpenFileProperties")
         kMenu("pvMenuBarFile", "Add", "&Containing folder properties (Explorer)", "OpenThisFilePropFolder", "external")
      } Else
         kMenu("pvMenuBarFile", "Add", "Open files in new &QPV instances`tCtrl+Enter", "OpenWithNewQPVinstance")

      Menu, pvMenuBarFile, Add,
      kMenu("pvMenuBarFile", "Add", "Print image(s)`tCtrl+P", "PanelPrintImage")
      kMenu("pvMenuBarFile", "Add", "&Delete file(s)`tDelete", "DeletePicture", "erase")
      kMenu("pvMenuBarFile", "Add", "&Rename file(s)`tF2", "PanelRenameThisFile")
      If (markedSelectFile>1)
         kMenu("pvMenuBarFile", "Add", "Structured file operations", "PanelStructuredCopyMoveWindow", "hierarchy backup copy move folders directories dirs")
      kMenu("pvMenuBarFile", "Add", "&Move file(s) to...`tM", "PanelMoveCopyFiles")
      kMenu("pvMenuBarFile", "Add", "&Copy file(s) to...`tC", "InvokeCopyFiles")
   } Else If FileExist(resultedFilesList[currentFileIndex, 1])
   {
      Menu, pvMenuBarFile, Add
      Try Menu, PVtActFile, Delete

      zPlitPath(resultedFilesList[currentFileIndex, 1], 0, OutFileName, OutDir)
      kMenu("PVtActFile", "Add", "Open with default application", "OpenWithDefaultApp")
      kMenu("PVtActFile", "Add", "&Open with external app`tO", "OpenThisFileMenu")
      kbdu := (thumbsDisplaying=1) ? "`tAlt+E" : ""
      kMenu("PVtActFile", "Add", "Open file in a new &QPV instance`tCtrl+Enter", "SoloNewQPVinstance")
      kMenu("PVtActFile", "Add", "Open in QPV the containin&g folder" kbdu, "OpenQPVfileFolder")
      kMenu("PVtActFile", "Add", "&Explore containing folder`tCtrl+E", "OpenThisFileFolder")
      If ((!FolderExist(OutDir) || StrReplace(CurrentSLD, "|")=OutDir) && !mustOpenStartFolder)
         kMenu("PVtActFile", "Disable", "Open in QPV the containin&g folder" kbdu)

      kMenu("PVtActFile", "Add", "System «Open with» dialog", "MenuInvokeSHopenWith", "external")
      kMenu("pvMenuBarFile", "Add", "Open this&...", ":PVtActFile")
      Menu, pvMenuBarFile, Add
      kMenu("pvMenuBarFile", "Add", "&File information`tAlt+Enter", "PanelImageInfos", "properties image details")
      kMenu("pvMenuBarFile", "Add", "File prope&rties (Explorer)", "OpenFileProperties")
      If !FolderExist(OutDir)
         kMenu("pvMenuBarFile", "Disable", "&Explore containing folder`tCtrl+E")
      Menu, pvMenuBarFile, Add
      kMenu("pvMenuBarFile", "Add", "&Delete file`tDelete", "DeleteActivePicture")
      kMenu("pvMenuBarFile", "Add", "&Rename file`tShift+F2", "SingularRenameFile")
      kMenu("pvMenuBarFile", "Add", "&Move file(s) to...`tM", "PanelMoveCopyFiles")
      kMenu("pvMenuBarFile", "Add", "&Copy file(s) to...`tC", "InvokeCopyFiles")
   }

   Menu, pvMenuBarFile, Add
   modus := (validBMP(UserMemBMP) || (maxFilesIndex>0 && CurrentSLD)) ? 0 : "welcome"
   If (modus!="welcome")
      kMenu("pvMenuBarFile", "Add", "Close ima&ge and files list`tCtrl+F4", "closeDocuments", "reset")
   kMenu("pvMenuBarFile", "Add", "Restart`tShift+Esc", "restartAppu", "close renew")
   kMenu("pvMenuBarFile", "Add", "Exit`tEscape", "exitAppu", "close")
   showThisMenu("pvMenuBarFile", 0, 1, manuID)
}

InvokeMenuBarEdit(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarEdit, Delete

   infoImgEditingNow := isImgEditingNow()
   If (thumbsDisplaying!=1)
   {
      kMenu("pvMenuBarEdit", "Add", "&Undo`tCtrl+Z", "ImgUndoAction", "image edit")
      kMenu("pvMenuBarEdit", "Add", "&Redo`tCtrl+Y", "ImgRedoAction", "image edit")
      If (viewportQPVimage.imgHandle)
      {
         kMenu("pvMenuBarEdit", "Add", "Actions: " Round(viewportQPVimage.actions), "dummy")
         kMenu("pvMenuBarEdit", "Disable", "Actions: " Round(viewportQPVimage.actions))
      } Else If !(undoLevelsRecorded>1 && undoLevelsRecorded!="" && infoImgEditingNow=1)
      {
         kMenu("pvMenuBarEdit", "Disable", "&Undo`tCtrl+Z")
         kMenu("pvMenuBarEdit", "Disable", "&Redo`tCtrl+Y")
      } Else
      {
         kMenu("pvMenuBarEdit", "Add", "Levels: " currentUndoLevel "/" undoLevelsRecorded, "dummy")
         kMenu("pvMenuBarEdit", "Disable", "Levels: " currentUndoLevel "/" undoLevelsRecorded)
      }

      kMenu("pvMenuBarEdit", "Add/Uncheck", "&Record undo levels", "TogglePreventUndos", "history")
      If (preventUndoLevels!=1)
         kMenu("pvMenuBarEdit", "Check", "&Record undo levels")

      Menu, pvMenuBarEdit, Add
      kMenu("pvMenuBarEdit", "Add", "C&ut selected area`tCtrl+X", "CutSelectedArea", "image editing")
      kMenu("pvMenuBarEdit", "Add", "&Copy to clipboard`tCtrl+C", "CopyImage2clip", "image")

      If (infoImgEditingNow!=1)
         kMenu("pvMenuBarEdit", "Disable", "&Copy to clipboard`tCtrl+C")

      kMenu("pvMenuBarEdit", "Add", "P&aste clipboard`tCtrl+V", "PasteClipboardIMG", "image memory")
      kMenu("pvMenuBarEdit", "Add", "&Paste in place`tCtrl+Shift+V", "PanelPasteInPlace")
      If !AnyWindowOpen
      {
         hasAdded := 1
         Menu, pvMenuBarEdit, Add
         kMenu("pvMenuBarEdit", "Add", "&Crop image to selection`tShift+Enter", "CropImageInViewPortToSelection")
         kMenu("pvMenuBarEdit", "Add", "&Resize image to selection`tAlt+R", "ResizeIMGviewportSelection")
      }

      If AnyWindowOpen
         kMenu("pvMenuBarEdit", "Disable", "P&aste clipboard`tCtrl+V")

      If (editingSelectionNow!=1 || infoImgEditingNow!=1 || AnyWindowOpen)
      {
         kMenu("pvMenuBarEdit", "Disable", "C&ut selected area`tCtrl+X")
         kMenu("pvMenuBarEdit", "Disable", "&Paste in place`tCtrl+Shift+V")
         If hasAdded
         {
            kMenu("pvMenuBarEdit", "Disable", "&Crop image to selection`tShift+Enter", "CropImageInViewPortToSelection")
            kMenu("pvMenuBarEdit", "Disable", "&Resize image to selection`tAlt+R", "ResizeIMGviewportSelection")
         }
      }

      If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      {
         Menu, pvMenuBarEdit, Add
         createMenuCopyFile("PVcopy")
         kMenu("pvMenuBarEdit", "Add", "&Modify index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
         kMenu("pvMenuBarEdit", "Add", "&Copy...", ":PVcopy")
      }

      If (imgEditPanelOpened=1)
      {
         If isVarEqualTo(AnyWindowOpen, 64, 31, 24, 23)
         {
            added := 1
            Menu, pvMenuBarEdit, Add
         }

         If (editingSelectionNow=1 && AnyWindowOpen=23 && liveDrawingBrushTool!=1)
         {
            If isInRange(FillAreaColorMode, 2, 4)
            {
               kMenu("pvMenuBarEdit", "Add", "&Reset gradient center", "BtnSetTextureSource")
               kMenu("pvMenuBarEdit", "Add/Uncheck", "&Allow gradient center repositioning", "toggleClrGradientCenterRepose")
               If (userAllowClrGradientRecenter=1)
                  kMenu("pvMenuBarEdit", "Check", "&Allow gradient center repositioning")
            } Else If (FillAreaColorMode=6)
               kMenu("pvMenuBarEdit", "Add", "&Set texture fill source`tS", "BtnSetTextureSource")
         } Else If (AnyWindowOpen=64 && BrushToolType<4)
         {
            kMenu("pvMenuBarEdit", "Add", "&Cycle symmetry modes`tY", "toggleBrushSymmetryModes")
            kMenu("pvMenuBarEdit", "Add", "&Define symmetry point`tShift+Y", "BtnSetBrushSymmetryCoords")
            If (BrushToolType=3)
               kMenu("pvMenuBarEdit", "Add", "Define cloner &source`tS", "BtnSetClonerBrushSource")
         } Else If isVarEqualTo(AnyWindowOpen, 31, 24)
         {
            kMenu("pvMenuBarEdit", "Add", "Reset to &initial position", "MenuResetTransformToolPos")
            If (shearImgX!=0 || shearImgY!=0)
               kMenu("pvMenuBarEdit", "Add", "&Reset image skew offsets", "resetImgSkewOffsets")
      
            If (PasteInPlaceToolMode=1 && (prevEllipseSelectMode>0 || prevVPselRotation!=0 || previnnerSelectionCavityX!=0 || previnnerSelectionCavityY!=0))
            {
               kMenu("pvMenuBarEdit", "Add/Uncheck", "Re&veal initial rect", "toggleRevealRectPasteInPlace")
               If (PasteInPlaceRevealOriginal=1)
                  kMenu("pvMenuBarEdit", "Check", "Re&veal initial rect")
            }
         }

         If isVarEqualTo(AnyWindowOpen, 64, 66)
         {
            additions := FloodFillSelectionAdj
            labelu := (AnyWindowOpen=64) ? "Painting" : "Bucket"
            kMenu("pvMenuBarEdit", "Add/Uncheck", "&" labelu " mode`tCtrl+K", "toggleAlphaPaintingMode")
            kMenu("pvMenuBarEdit", "Add", "&Cycle " labelu " modes`tShift+K", "toggleBrushDrawInOutModes")
            If (liveDrawingBrushTool=1 && AnyWindowOpen=64) || (FloodFillSelectionAdj!=1 && AnyWindowOpen=66)
               kMenu("pvMenuBarEdit", "Check", "&" labelu " mode`tCtrl+K")
         }

         If (!isVarEqualTo(AnyWindowOpen, 10, 64, 66, 12) && liveDrawingBrushTool!=1)
         {
            If !added
               Menu, pvMenuBarEdit, Add
            kMenu("pvMenuBarEdit", "Add", "&Hide dynamic object`tD", "toggleLiveEditObject", "preview")
         }
      }
   } Else
   {
      kMenu("pvMenuBarEdit", "Add", "&Undo file action`tCtrl+Z", "ImgUndoAction", "history restore actions records")
      kMenu("pvMenuBarEdit", "Add", "Undo history", "PanelFileUndoHistory", "records actions files rename move copy restore")
      kMenu("pvMenuBarEdit", "Add", "Undo last actions(s) (chronologically)`tCtrl+Shift+Z", "doUndoFileActsChronos", "records actions files rename move copy history restore")
      If !hasFileIndexUndo(currentFileIndex)
         kMenu("pvMenuBarEdit", "Disable", "&Undo file action`tCtrl+Z")

      Menu, pvMenuBarEdit, Add
      createMenuCopyFile("pvMenuBarEdit")
      Menu, pvMenuBarEdit, Add
      kMenu("pvMenuBarEdit", "Add", "&Paste file(s) to list`tCtrl+V", "MenuPasteHDropFiles", "index list clipboard")
      If markedSelectFile
      {
         Menu, pvMenuBarEdit, Add
         kMenu("pvMenuBarEdit", "Add", "Re&group selected dispersed files", "regroupSelectedFiles")
      }

      Menu, pvMenuBarEdit, Add
      If !EntryMarkedMoveIndex
         kMenu("pvMenuBarEdit", "Add", "Mar&k entry to reorder`tX", "moveMarkedEntryNow")
      Else
         kMenu("pvMenuBarEdit", "Add", "Move mar&ked entry to focused index`tX", "moveMarkedEntryNow")

      kMenu("pvMenuBarEdit", "Add", "Remove inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
      If markedSelectFile
         kMenu("pvMenuBarEdit", "Add", "Remove selected inde&x entries", "InListMultiEntriesRemover", "erase")

      kMenu("pvMenuBarEdit", "Add", "&Modify index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
      If (validBMP(UserMemBMP) && thumbsDisplaying=1)
      {
         Menu, pvMenuBarEdit, Add
         kMenu("pvMenuBarEdit", "Add", "&Return to image editing", "MenuReturnIMGedit", "back")
      }
   }

   showThisMenu("pvMenuBarEdit", 0, 1, manuID)
}

InvokeMenuBarEditorSelection(manuID) {
   deleteMenus()
   infoImgEditingNow := isImgEditingNow()
   kMenu("PVselv", "Add", "&Undo`tCtrl+Shift+Z", "ImgSelUndoAct")
   kMenu("PVselv", "Add", "&Redo`tCtrl+Shift+Y", "ImgSelRedoAct")
   If !(infoImgEditingNow=1 && testUndoImgSelections()=1)
   {
      kMenu("PVselv", "Disable", "&Undo`tCtrl+Shift+Z")
      kMenu("PVselv", "Disable", "&Redo`tCtrl+Shift+Y")
   } Else
   {
      totalSelUndos := Round(undoSelLevelsArray.Count())
      kMenu("PVselv", "Add", "Levels: " groupDigits(totalSelUndos), "dummy")
      kMenu("PVselv", "Disable", "Levels: " groupDigits(totalSelUndos))
   }

   Menu, PVselv, Add
   If (isVarEqualTo(AnyWindowOpen, 10, 12, 64, 66) && imgEditPanelOpened=1)
   {
      kMenu("PVselv", "Add/Uncheck", "&Show selection`tE", "ToggleEditImgSelection")
      If (editingSelectionNow=1)
         kMenu("PVselv", "Check", "&Show selection`tE")
      Else
         kMenu("PVselv", "Add", "&Select all`tCtrl+A", "selectEntireImage")
   }

   isWinCustomShapeFriendly := isVarEqualTo(AnyWindowOpen, 89, 81, 74, 68, 66, 65, 64, 55, 25, 23, 10)
   drawing := isNowAlphaPainting()
   decideLiveSelectionBasedOnWindow(angleu, isToolGood)
   If isVarEqualTo(AnyWindowOpen, 81, 65, 23)
      isToolGood := 1

   If (editingSelectionNow=1)
   {
      additions := 1
      If (AnyWindowOpen=23)
         additions := !liveDrawingBrushTool
      Else If isVarEqualTo(AnyWindowOpen, 64, 66)
         additions := FloodFillSelectionAdj
   }

   If (additions=1)
   {
      If (isToolGood=1 && isWinCustomShapeFriendly=1 && editingSelectionNow=1)
      {
         kMenu("PVselv", "Add", "&Load custom shapes", "PanelManageVectorShapes", "freeform presets premade forms triangle moon cloud crescent heart water droplet rhombus star christian cross callout")
         If (EllipseSelectMode=2 && editingSelectionNow=1)
         {
            createMenuSelectSizeShapes("simple", "mnb")
            kMenu("PVselv", "Add", "&Custom shape options", ":PVselSize")
         }
         Menu, PVselv, Add
      }

      If (isToolGood=1)
      {
         infoSelShape := DefineVPselAreaMode()
         kMenu("PVselv", "Add", "C&ycle selection types`tShift+E", "MenuCycleSelectionShapes")
         kMenu("PVselv", "Add", infoSelShape, "dummy")
         kMenu("PVselv", "Disable", infoSelShape)
         Menu, PVselv, Add
      }

      kMenu("PVselv", "Add", "&Select all`tCtrl+A", "selectEntireImage")
      If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
         kMenu("PVselv", "Add", "R&eset exclude area`tShift+\", "resetSelectionAreaCavity")

      kMenu("PVselv", "Add", "&Flip selection area W/H`tW", "flipSelectionWH")
      kMenu("PVselv", "Add/Uncheck", "&Limit selection to image area`tL", "toggleLimitSelection")
      If (LimitSelectBoundsImg=1)
         kMenu("PVselv", "Check", "&Limit selection to image area`tL")

      kMenu("PVselv", "Add", "&Reset selection area", "newImgSelection")
      If isSelEntireOutside()
         kMenu("PVselv", "Add", "Focus selection area", "focusImgSelArea", "find viewport", " (selection area)")
      kMenu("PVselv", "Add/Uncheck", "Sho&w grid", "ToggleSelectGrid",, " (selection area)")
      If (showSelectionGrid=1)
         kMenu("PVselv", "Check", "Sho&w grid",,, " (selection area)")

      createMenuSelectionAlign()
      createMenuSelectionRotationAspectRatio()
      kMenu("PVselv", "Add", "Ali&gnment", ":PVselAlign")
      kMenu("PVselv", "Add", "&Rotation and aspect ratio", ":PVselRatio")
      If (imgEditPanelOpened=1 && isWinCustomShapeFriendly=1)
      {
         Menu, PVselv, Add
         kMenu("PVselv", "Add", "Selection &properties`tAlt+E", "PanelIMGselProperties")
      }
   } Else If (isVarEqualTo(AnyWindowOpen, 64, 66) && editingSelectionNow=1)
   {
      kMenu("PVselv", "Add", "&Activate selection mode`tCtrl+K", "toggleAlphaPaintingMode")
   }

   showThisMenu("PVselv", 0, 1, manuID)
}

InvokeMenuBarSelection(manuID) {
   deleteMenus()
   Try Menu, pvMenuBarSelection, Delete

   If (thumbsDisplaying=1)
   {
      createMenuFilesSelections("pvMenuBarSelection")
      If StrLen(filesFilter)>1
      {
         If testIsDupesList()
         {
            Menu, pvMenuBarSelection, Add
            kMenu("pvMenuBarSelection", "Add", "Auto-select &duplicates", "PanelAutoSelectDupes")
         }
      }
   } Else
   {
      infoImgEditingNow := isImgEditingNow()
      kMenu("pvMenuBarSelection", "Add", "&Undo`tCtrl+Shift+Z", "ImgSelUndoAct")
      kMenu("pvMenuBarSelection", "Add", "&Redo`tCtrl+Shift+Y", "ImgSelRedoAct")
      If !(infoImgEditingNow=1 && testUndoImgSelections()=1)
      {
         kMenu("pvMenuBarSelection", "Disable", "&Undo`tCtrl+Shift+Z")
         kMenu("pvMenuBarSelection", "Disable", "&Redo`tCtrl+Shift+Y")
      } Else
      {
         totalSelUndos := Round(undoSelLevelsArray.Count())
         kMenu("pvMenuBarSelection", "Add", "Levels: " groupDigits(totalSelUndos), "dummy")
         kMenu("pvMenuBarSelection", "Disable", "Levels: " groupDigits(totalSelUndos))
      }

      Menu, pvMenuBarSelection, Add
      keyword := (editingSelectionNow=1) ? "hide" : " display"
      If (editingSelectionNow!=1 && imgSelX2=-1 && imgSelY2=-1)
      {
         kMenu("pvMenuBarSelection", "Add", "Create &selection area`tE", "newImgSelection", "image editing")
         If (infoImgEditingNow!=1)
            kMenu("pvMenuBarSelection", "Disable", "Create &selection area`tE")
      } Else
      {
         kMenu("pvMenuBarSelection", "Add/UnCheck", "Sho&w selection area`tE", "ToggleEditImgSelection", "image editing")
         If (editingSelectionNow=1)
            kMenu("pvMenuBarSelection", "Check", "Sho&w selection area`tE")
         If (infoImgEditingNow!=1)
            kMenu("pvMenuBarSelection", "Disable", "Sho&w selection area`tE")
      }

      friendly := AnyWindowOpen ? "" : "Manage / "
      kMenu("pvMenuBarSelection", "Add", friendly "Load custom shapes", "PanelManageVectorShapes", "freeform presets premade forms triangle moon cloud crescent heart water droplet rhombus star christian cross callout")
      infoKbd := (EllipseSelectMode!=2) ? "`tShift+L" : ""
      kMenu("pvMenuBarSelection", "Add", "&Define new freeform shape" infoKbd, "MenuStartDrawingSelectionArea", "edit freeform draw selection")
      kMenu("pvMenuBarSelection", "Add", "Se&lect all`tCtrl+A", "selectEntireImage")
      If (infoImgEditingNow!=1)
      {
         kMenu("pvMenuBarSelection", "Disable", "Se&lect all`tCtrl+A")
         kMenu("pvMenuBarSelection", "Disable", "&Define new freeform shape" infoKbd)
         kMenu("pvMenuBarSelection", "Disable", friendly "Load custom shapes")
      }

      If (editingSelectionNow=1 && infoImgEditingNow=1)
      {
         createMenuSelectSizeShapes("mnb")
         createMenuSelectionAlign()
         If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
            kMenu("pvMenuBarSelection", "Add", "R&eset exclude area`tShift+\", "resetSelectionAreaCavity")

         kMenu("pvMenuBarSelection", "Add", "&Drop and reset`tCtrl+D", "resetImgSelection", "hide")
         If isSelEntireOutside()
            kMenu("pvMenuBarSelection", "Add", "Focus selection area", "focusImgSelArea", "find viewport", " (selection area)")

         kMenu("pvMenuBarSelection", "Add/Uncheck", "Limit to image bo&undaries`tL", "toggleLimitSelection")
         kMenu("pvMenuBarSelection", "Add", "Flip width / &height`tW", "flipSelectionWH")
         If (LimitSelectBoundsImg=1)
            kMenu("pvMenuBarSelection", "Check", "Limit to image bo&undaries`tL")

         createMenuSelectionRotationAspectRatio()
         kMenu("pvMenuBarSelection", "Add", "&Shape options", ":PVselSize")
         kMenu("pvMenuBarSelection", "Add", "Ali&gnment", ":PVselAlign")
         kMenu("pvMenuBarSelection", "Add", "Rotation and &aspect ratio", ":PVselRatio")
         Menu, pvMenuBarSelection, Add, 
         keyword := (editingSelectionNow=1) ? "hide" : " display"
         kMenu("pvMenuBarSelection", "Add/Uncheck", "Sho&w grid", "ToggleSelectGrid", keyword)
         If (showSelectionGrid=1)
            kMenu("pvMenuBarSelection", "Check", "Sho&w grid")
      }
      If (infoImgEditingNow=1)
         kMenu("pvMenuBarSelection", "Add", "Selection properties`tAlt+E", "PanelIMGselProperties")
      Menu, pvMenuBarSelection, Add, 
      friendly := resultedFilesList[currentFileIndex, 2] ? "De&select" : "&Select"
      kMenu("pvMenuBarSelection", "Add", friendly " file`tTab", "markThisFileNow")
      If (maxFilesIndex<2)
         kMenu("pvMenuBarSelection", "Disable", friendly " file`tTab")
   }

   showThisMenu("pvMenuBarSelection", 0, 1, manuID)
}

InvokeMenuBarImage(manuID) {
  deleteMenus()
  Try Menu, pvMenuBarImage, Delete
  infoImgEditingNow := isImgEditingNow()
  If (infoImgEditingNow=1)
  {
     If ((isAlphaMaskPartialWin()=1 || isAlphaMaskWindow()=1) && imgEditPanelOpened=1 || !AnyWindowOpen)
     {
        createMenuAlphaMask()
        Try kMenu("pvMenuBarImage", "Add", "Alpha mas&k", ":PValpha")
     }

     If !AnyWindowOpen
     {
        createMenuImageEditSubMenus()
        Try kMenu("pvMenuBarImage", "Add", "&Filters", ":PVimgFilters")
        Try kMenu("pvMenuBarImage", "Add", "&Draw", ":PVimgDraw")
        Try kMenu("pvMenuBarImage", "Add", "&Transform", ":PVimgTransform")
        Try kMenu("pvMenuBarImage", "Add", "&Convert color depth", ":PVimgClrDepths")
     } Else If (editingSelectionNow=1 && dummy!="mbr")
     {
        createMenuImageEditSubMenus("filters")
        Try kMenu("pvMenuBarImage", "Add", "&Filters", ":PVimgFilters")
        keyu := (AnyWindowOpen) ? "" : "`tShift+H"
        kMenu("pvMenuBarImage", "Add", "Flip selected &horizontally" keyu, "FlipSelectedAreaH")
        keyu := (AnyWindowOpen) ? "" : "`tShift+V"
        kMenu("pvMenuBarImage", "Add", "Flip selected &vertically" keyu, "FlipSelectedAreaV")
        ; kMenu("pvMenuBarImage", "Add", "&Invert colors`tShift+I", "InvertSelectedArea")
     }

     Menu, pvMenuBarImage, Add
     kMenu("pvMenuBarImage", "Add/Uncheck", "&Use gamma correction", "toggleImgEditGammaCorrect", "image colors")
     If (userimgGammaCorrect=1)
        kMenu("pvMenuBarImage", "Check", "&Use gamma correction")

     If (imgEditPanelOpened=1)
        kMenu("pvMenuBarImage", "Add", "Pic&k color from image`tC", "changeBrushColorPicker", "pipette picker")

     If !AnyWindowOpen
     {
        Menu, pvMenuBarImage, Add
        kMenu("pvMenuBarImage", "Add", "Adjust &HDR tone-mapping", "PanelAdjustToneMapping", "colors dynamic exposure gamma hdr raw")
        If !InStr(currIMGdetails.PixelFormat, "TONE-MAPP")
           kMenu("pvMenuBarImage", "Disable", "Adjust &HDR tone-mapping")

        kMenu("pvMenuBarImage", "Add", "Set as &wallpaper", "PanelSetWallpaper", "desktop image") 
        kMenu("pvMenuBarImage", "Add", "Extract frames/pa&ges", "PanelExtractFrames")
        If (currIMGdetails.Frames<2 && !markedSelectFile)
           kMenu("pvMenuBarImage", "Disable", "Extract frames/pa&ges")

        kMenu("pvMenuBarImage", "Add", "Con&vert file format(s) to...`tCtrl+K", "PanelFileFormatConverter", "image conversion")
        imgPath := getIDimage(currentFileIndex)
        kMenu("pvMenuBarImage", "Add", "&JPEG lossless operations`tShift+J", "PanelJpegPerformOperation")
        If (!RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && !markedSelectFile)
           kMenu("pvMenuBarImage", "Disable", "&JPEG lossless operations`tShift+J")
  
        If (ShowAdvToolbar=1 && userCustomizedToolbar!=1)
        {
           Menu, pvMenuBarImage, Add
           kMenu("pvMenuBarImage", "Add/Uncheck", "&Advanced mode toolbar", "ToggleToolBarViewModa")
           If (toolbarViewerMode!=1)
              kMenu("pvMenuBarImage", "Check", "&Advanced mode toolbar")
        }
     }
  } Else If (thumbsDisplaying=1 && maxFilesIndex>0)
  {
     If (!markedSelectFile && FileRexists(resultedFilesList[currentFileIndex, 1]) && thumbsDisplaying=1)
     {
        kMenu("pvMenuBarImage", "Add", "&Import into currently loaded image", "importEditGivenImageFile")
        kMenu("pvMenuBarImage", "Add", "&Import as alpha mask bitmap", "importAlphaMaskGivenImageFile")
        Menu, pvMenuBarImage, Add
     }

     createMenuImageFileActions("pvMenuBarImage")
     kMenu("pvMenuBarImage", "Add", "Con&vert file format(s) to...`tCtrl+K", "PanelFileFormatConverter", "image conversion")
     kMenu("pvMenuBarImage", "Add", "Set as &wallpaper", "PanelSetWallpaper", "desktop image")
     kMenu("pvMenuBarImage", "Add", "Extract frames/pa&ges", "PanelExtractFrames")
     kMenu("pvMenuBarImage", "Add", "Join images into...", "PanelCombineImagesMultipage", "pdf create document")
     kMenu("pvMenuBarImage", "Add", "&Create a thumbnails sheet", "PanelCreateIMGthumbsSheet")
     If !markedSelectFile
     {
        kMenu("pvMenuBarImage", "Disable", "Join images into...")
        kMenu("pvMenuBarImage", "Disable", "&Create a thumbnails sheet")
     }

     If (ShowAdvToolbar=1 && userCustomizedToolbar!=1)
     {
        Menu, pvMenuBarImage, Add
        kMenu("pvMenuBarImage", "Add/Uncheck", "&Advanced mode toolbar", "ToggleToolBarViewModa")
        If (toolbarViewerMode!=1)
           kMenu("pvMenuBarImage", "Check", "&Advanced mode toolbar")
     }
  } Else
  {
     kMenu("pvMenuBarImage", "Add", "No image loaded", "dummy")
     kMenu("pvMenuBarImage", "Disable", "No image loaded")
  }
  showThisMenu("pvMenuBarImage", 0, 1, manuID)
}

InvokeMenuBarFind(manuID) {
  deleteMenus()
  Try Menu, pvMenuBarFind, Delete
  If (maxFilesIndex>1)
  {
     kMenu("pvMenuBarFind", "Add", "Searc&h index`tCtrl+F3", "PanelSearchIndex", "files list")
     If userSearchString
     {
        kMenu("pvMenuBarFind", "Add", "S&earch next`tF3", "MenuSearchNextIndex")
        kMenu("pvMenuBarFind", "Add", "Search p&revious`tShift+F3", "MenuSearchPrevIndex")
        kMenu("pvMenuBarFind", "Add", "Erase search &criteria", "EraseSearchEdit")
        Menu, pvMenuBarFind, Add
     }

     kMenu("pvMenuBarFind", "Add", "Search and re&place`tCtrl+H", "PanelSearchAndReplaceIndex", "files index list")
     kMenu("pvMenuBarFind", "Add", "&Find duplicate images", "PanelFindDupes")
     kMenu("pvMenuBarFind", "Add", "&Keywords indexer", "PanelKeywordsDetector")
     If (maxFilesIndex<4)
     {
        kMenu("pvMenuBarFind", "Disable", "&Find duplicate images", "PanelFindDupes")
        kMenu("pvMenuBarFind", "Disable", "&Keywords indexer", "PanelKeywordsDetector")
     }

     Menu, pvMenuBarFind, Add
     kMenu("pvMenuBarFind", "Add", "&Define index filter(s)`tCtrl+F", "PanelEnableFilesFilter", "files list")
     If (StrLen(filesFilter)>1)
     {
        kMenu("pvMenuBarFind", "Add", "Remove files list filter`tCtrl+Space", "MenuRemFilesListFilter")
        If testIsDupesList()
        {
           If InStr(resultedFilesList[currentFileIndex, 23], "_")
           {
              kMenu("pvMenuBarFind", "Disable", "&Define index filter(s)`tCtrl+F")
              kMenu("pvMenuBarFind", "Add", "Change dupes filter threshold`tCtrl+F", "PanelChangeHamDistThreshold")
           }
        }
     }
  } Else
  {
     If StrLen(mustOpenStartFolder)>3
     {
        kMenu("pvMenuBarFind", "Add", "Searc&h index`tCtrl+F3", "PanelSearchIndex", "files list")
        Menu, pvMenuBarFind, Add
     }

     kMenu("pvMenuBarFind", "Add", "Insufficient files indexed", "dummy")
     kMenu("pvMenuBarFind", "Disable", "Insufficient files indexed")
  }

  showThisMenu("pvMenuBarFind", 0, 1, manuID)
}

InvokeMenuBarList(manuID) {
  deleteMenus()
  Try Menu, pvMenuBarList, Delete
  showThese := (StrLen(mustOpenStartFolder)>3 || maxFilesIndex>1) ? 1 : 0
  If (showThese!=1)
  {
     kMenu("pvMenuBarList", "Add", "Insufficient files indexed", "dummy")
     kMenu("pvMenuBarList", "Disable", "Insufficient files indexed")
     showThisMenu("pvMenuBarList", 0, 1, manuID)
     Return
  }

  kMenu("pvMenuBarList", "Add", "I&mport list / insert file(s)`tInsert", "addNewFile2list")
  kMenu("pvMenuBarList", "Add", "&Add folder(s)`tShift+Insert", "addNewFolder2list")
  kMenu("pvMenuBarList", "Add", "Mana&ge folder(s) list`tAlt+U", "PanelDynamicFolderzWindow")
  labelu := (FileExist(CurrentSLD) && RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? "&Update files list selectively`tCtrl+U" : "Folders containin&g indexed files`tCtrl+U"
  kMenu("pvMenuBarList", "Add", labelu, "PanelStaticFolderzManager", "folders manage")
  If StrLen(DynamicFoldersList)>6
     kMenu("pvMenuBarList", "Add", "&Regenerate the entire list", "RegenerateEntireList")
  Menu, pvMenuBarList, Add
  If (SLDtypeLoaded=2 && currentFilesListModified=1 && CurrentSLD && maxFilesIndex>1)
     kMenu("pvMenuBarList", "Add", "&Save files list no&w`tCtrl+S", "BTNsaveCurrentSlideshow")
  If (maxFilesIndex>1)
     kMenu("pvMenuBarList", "Add", "Save files list as .S&LD`tCtrl+Shift+S", "PanelSaveSlideShowu")

  infoMenuRefresh := RegExMatch(CurrentSLD, sldsPattern) ? "Reload .SLD file" : "Refresh opened folder(s)"
  pathu := PathCompact(CurrentSLD, 40)
  If pathu
      kMenu("pvMenuBarList", "Add", infoMenuRefresh "`tShift+F5", "RefreshFilesList", "reload refresh list files")

  If (maxFilesIndex>3)
  {
     createMenuStatistics()
     Menu, pvMenuBarList, Add
     kMenu("pvMenuBarList", "Add", "&Statistics", ":PVstats")
  }

  If (maxFilesIndex>2)
  {
     Menu, pvMenuBarList, Add
     kMenu("pvMenuBarList", "Add/Uncheck", "Auto-remove entries of dead files", "ToggleAutoRemEntries")
     If (autoRemDeadEntry=1)
        kMenu("pvMenuBarList", "Check", "Auto-remove entries of dead files")

     ; If RegExMatch(CurrentSLD, sldsPattern)
     labelu := (SLDtypeLoaded=3) ? "Clean inexistent files entries" : "Clean &duplicate and inexistent entries"
     kMenu("pvMenuBarList", "Add", labelu, "cleanDeadFilesList", "remove dead files erase")
     If (mustRecordSeenImgs=1)
        kMenu("pvMenuBarList", "Add", "Remove alread&y seen images", "removeFilesListSeenImages", "eliminate")
     If !InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
        kMenu("pvMenuBarList", "Add", "Remove fa&vourited images from list", "removeFilesListFavouritedImages", "eliminate")

     Menu, pvMenuBarList, Add
     If (mustRecordSeenImgs=1)
     {
        kMenu("pvMenuBarList", "Add", "Identify &already seen images", "quickFindSeenImages", "saw")
        kMenu("pvMenuBarList", "Add", "Identify &never seen images", "quickFindUnseenImages", "unseen")
     }

     If !InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
        kMenu("pvMenuBarList", "Add", "&Identify favourited images", "findFavesInList", "faved faves stared")
  }
  showThisMenu("pvMenuBarList", 0, 1, manuID)
}

InvokeMenuBarView(manuID) {
  deleteMenus()
  If (isImgEditingNow() || thumbsDisplaying=1 && maxFilesIndex>0)
  {
     createMenuMainView()
  } Else
  {
     kMenu("PVview", "Add", "No image loaded", "dummy")
     kMenu("PVview", "Disable", "No image loaded")
  }
  showThisMenu("PVview", 0, 1, manuID)
}

InvokeMenuBarEditorTools(manuID) {
  deleteMenus()
  If isVarEqualTo(AnyWindowOpen, 31, 24)
  {
     kMenu("PVlTools", "Add", "`Options disabled", "dummy")
     kMenu("PVlTools", "Disable", "Options disabled")
     showThisMenu("PVlTools", 0, 1, manuID)
  } Else If isImgEditingNow()
  {
     createMenuLiveTools("mbr")
     showThisMenu("PVlTools", 0, 1, manuID)
  }
}

InvokeMenuBarAlphaMask(manuID) {
   deleteMenus()
   kMenu("PValpha", "Add", "Painting mode", "dummy")
   kMenu("PValpha", "Disable", "Painting mode")
   kMenu("PValpha", "Add", "E&xit tool`tEnter", "applyIMGeditFunction")
   Menu, PValpha, Add
   createMenuAlphaMask("PValpha")
   showThisMenu("PValpha", 0, 1, manuID)
}

InvokeMenuBarInterface(manuID) {
   deleteMenus()
   createMenuInterfaceOptions()
   showThisMenu("PvUIprefs", 0, 1, manuID)
}

InvokeMenuBarNavigate(manuID) {
   deleteMenus()
   createMenuNavigation()
   showThisMenu("PVnav", 0, 1, manuID)
}

InvokeMenuBarCaptions(manuID) {
   deleteMenus()
   createMenuAnnotations()
   showThisMenu("PVsounds", 0, 1, manuID)
}

InvokeMenuBarSlides(manuID) {
   deleteMenus()
   createMenuSlideshows()
   showThisMenu("PVslide", 0, 1, manuID)
}

InvokeMenuBarSort(manuID) {
   deleteMenus()
   createMenuFilesSort()
   showThisMenu("PVsort", 0, 1, manuID)
}

InvokeMenuBarSettings(manuID) {
   deleteMenus()
   createMenuMainPreferences()
   showThisMenu("PVprefs", 0, 1, manuID)
}

InvokeMenuBarHelp(manuID) {
   deleteMenus()
   createMenuHelpQPV()
   showThisMenu("PVhelp", 0, 1, manuID)
}

createMenuNavigation() {
   If (thumbsDisplaying!=1)
   {
      kMenu("PVnav", "Add/Uncheck", "&Skip missing files", "ToggleSkipDeadFiles", "dead inexistent", " in image view")
      If (skipDeadFiles=1)
         kMenu("PVnav", "Check", "&Skip missing files",,, " in image view")
      If (maxFilesIndex<2)
         kMenu("PVnav", "Disable", "&Skip missing files",,, " in image view")
      Menu, PVnav, Add
   } Else 
   {
      kMenu("PVnav", "Add", "&Display the files list map now`tW", "MenuDrawFilesListMap")
      kMenu("PVnav", "Add/Uncheck", "&Show files list map on scrollbar click", "ToggleFilesMap")
      If (showFilesListMap=1)
         kMenu("PVnav", "Check", "&Show files list map on scrollbar click")
      If !(maxFilesIndex>10 && markedSelectFile>1)
         kMenu("PVnav", "Disable", "&Show files list map on scrollbar click")
      Menu, PVnav, Add
   }

   kMenu("PVnav", "Add", "&First`tHome", "FirstPicture",, " image in index")
   If (thumbsDisplaying!=1)
   {
      kMenu("PVnav", "Add", "&Previous`tPage down", "PreviousPicture",, " image in index")
      kMenu("PVnav", "Add", "&Next`tPage up", "NextPicture",, " image in index")
   } Else If (mustPreventMenus=1 && thumbsDisplaying=1)
   {
      kMenu("PVnav", "Add", "Select to first in index`tShift+Home", "MenuSelectHomeFiles")
      kMenu("PVnav", "Add", "Select to last in index`tShift+End", "MenuSelectEndFiles")
   }

   kMenu("PVnav", "Add", "&Last`tEnd", "LastPicture",, " image in index")
   If (thumbsDisplaying=1)
   {
      kMenu("PVnav", "Add", "&Previous page`tPage down", "MenuPrevThumbsPage",, " image index")
      kMenu("PVnav", "Add", "&Next page`tPage up", "MenuNextThumbsPage",, " image index")
   }

   kMenu("PVnav", "Add", "&Previously displayed image`tCtrl+Backspace", "jumpPreviousImage")
   If (thumbsDisplaying!=1)
   {
      Menu, PVnav, Add
      kMenu("PVnav", "Add", "Previous &frame`tShift+Page Down", "MenuPrevDesiredFrame", "gifs tiffs multipage")
      kMenu("PVnav", "Add", "Ne&xt frame`tShift+Page Up", "MenuNextDesiredFrame", "gifs tiffs multipageNP")
      If (totalFramesIndex<1)
      {
         kMenu("PVnav", "Disable", "Previous &frame`tShift+Page Down")
         kMenu("PVnav", "Disable", "Ne&xt frame`tShift+Page Up")
      }
   }

   If (markedSelectFile>1 && thumbsDisplaying!=1)
   {
      Menu, PVnav, Add,
      kMenu("PVnav", "Add", "F&irst selected`tCtrl+Home", "jumpToFilesSelBorderFirst")
      kMenu("PVnav", "Add", "Pr&evious selected`tCtrl+Left", "navSelectedFilesPrev")
      kMenu("PVnav", "Add", "Nex&t selected`tCtrl+Right", "navSelectedFilesNext")
      kMenu("PVnav", "Add", "L&ast selected`tCtrl+End", "jumpToFilesSelBorderLast")
   }

   thisFolder := StrReplace(Trimmer(CurrentSLD), "|")
   imgPath := getIDimage(currentFileIndex)
   OutDir := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1))
   showThese := (StrLen(mustOpenStartFolder)>3 || maxFilesIndex>1) ? 1 : 0
   Menu, PVnav, Add
   If showThese
   {
      kMenu("PVnav", "Add", "&Skip to index`tJ", "PanelJump2index", "frames")
      kMenu("PVnav", "Add", "Next &random image`tShift+Backspace", "RandomPicture")
      kMenu("PVnav", "Add", "Pre&vious random image`tBackspace", "PrevRandyPicture", "previous")
   }

   If (FolderExist(thisFolder) || FolderExist(OutDir) || FileRexists(imgPath))
   {
      If (thumbsDisplaying=1 && SLDtypeLoaded=1)
      {
         Menu, PVnav, Add
         kMenu("PVnav", "Add", "Open child folder`tCtrl+Page Down", "MenuFolderExplorerBreadDeeper")
         kMenu("PVnav", "Add", "Open parent folder`tCtrl+Page Up", "MenuFolderExplorerBreadHigher")
         kMenu("PVnav", "Add", "Next sibling folder`tAlt+Page Down", "MenuFolderExplorerNextSiblings")
         kMenu("PVnav", "Add", "Previous sibling folder`tAlt+Page Up", "MenuFolderExplorerPrevSiblings")
      }

      Menu, PVnav, Add
      kMenu("PVnav", "Add", "Open &omnibox to file location`tShift+;", "invokeOmniBoxCurrentFile")
      kMenu("PVnav", "Add", "Folders e&xplorer menu for active file`tShift+F4", "chainInvokerFoldersListMenu")
      kMenu("PVnav", "Add/UnCheck", "Show folders tree panel`tF4", "MenuPanelFoldersTree", "window treeview directories explore")
      If (folderTreeWinOpen=1)
         kMenu("PVnav", "Check", "Show folders tree panel`tF4")
   }

   If !showThese
   {
      kMenu("PVnav", "Add", "&First`tHome", "FirstPicture",, " image in index")
      If (thumbsDisplaying!=1)
      {
         kMenu("PVnav", "Add", "&Previous`tPage down", "PreviousPicture",, " image index")
         kMenu("PVnav", "Add", "&Next`tPage up", "NextPicture",, " image in index")
      }
      kMenu("PVnav", "Add", "&Last`tEnd", "LastPicture",, " image in index")
      kMenu("PVnav", "Add", "&Skip to index`tJ", "PanelJump2index", "frames")
      kMenu("PVnav", "Add", "Next &random image`tShift+Backspace", "RandomPicture")
      kMenu("PVnav", "Add", "Pre&vious random image`tBackspace", "PrevRandyPicture", "previous")
   }
}

MenuNextThumbsPage() {
   ThumbsNavigator("PgDn", "PgDn")
}

MenuPrevThumbsPage() {
   ThumbsNavigator("PgUp", "PgUp")
}

createMenuAlphaMask(givenMenu:="PValpha") {
   isThisWin := (isAlphaMaskWindow()=1 && imgEditPanelOpened=1) ? 1 : 0
   If (alphaMaskingMode>1 && alphaMaskingMode!=5 && isThisWin=1)
   {
      kMenu(givenMenu, "Add", "&Reset gradient offset", "BtnResetGradientCenter")
      kMenu(givenMenu, "Add/Uncheck", "&Allow gradient repositioning", "toggleAlphaGradientCenterReposition")
      If (userAllowsGradientRecentering=1)
         kMenu(givenMenu, "Check", "&Allow gradient repositioning")
   }

   If (editingSelectionNow=1 && alphaMaskingMode>1 && AnyWindowOpen!=70)
   {
      kMenu(givenMenu, "Add/Uncheck", "Previe&w the alpha mask`tM", "ViewAlphaMaskNow")
      If (forceLiveAlphaPreviewMode=1 && liveDrawingBrushTool=1)
         kMenu(givenMenu, "Check", "Previe&w the alpha mask`tM")
   } Else
   {
      kMenu(givenMenu, "Add", "Previe&w the alpha mask`tM", "dummy")
      kMenu(givenMenu, "Disable", "Previe&w the alpha mask`tM", "dummy")
   }

   If validBMP(userAlphaMaskBmpPainted)
   {
      keyu := isNowAlphaPainting() ? "`tCtrl+Z" : ""
      If (editingSelectionNow=1 && alphaMaskingMode=5 && alphaMaskRefBMP=1 && validBMP(userPrevAlphaMaskBmpPainted))
         kMenu(givenMenu, "Add", "Undo alpha mask" keyu, "performUndoAlphaPainting")

      If isThisWin
      {
         kMenu(givenMenu, "Add/Uncheck", "&Keep painted mask between tools", "toggleKeepAlphMask")
         If (keepUserPaintAlphaMask=1)
            kMenu(givenMenu, "Check", "&Keep painted mask between tools")
      }

      kMenu(givenMenu, "Add", "&Discard the painted alpha mask", "discardUserPaintedAlpha")
      If (liveDrawingBrushTool=1)
      {
         kMenu(givenMenu, "Disable", "&Discard the painted alpha mask")
         kMenu(givenMenu, "Add", "Flip painted mask &horizontally`tShift+H", "FlipHalphaMask")
         kMenu(givenMenu, "Add", "Flip painted mask &vertically`tShift+V", "FlipValphaMask")
      } Else
      {
         If (editingSelectionNow=1 && alphaMaskingMode=5 && alphaMaskRefBMP=1)
            kMenu(givenMenu, "Add", "Resize &bitmap to selection dimensions", "ResizeAlphaMask2sel")
      }
   } Else
   {
      kMenu(givenMenu, "Add", "&Discard the painted alpha mask", "dummy")
      kMenu(givenMenu, "Disable", "&Discard the painted alpha mask")
      kMenu(givenMenu, "Add", "Flip painted mask &horizontally`tShift+H", "dummy")
      kMenu(givenMenu, "Add", "Flip painted mask &vertically`tShift+V", "dummy")
      kMenu(givenMenu, "Add", "Resize &bitmap to selection dimensions", "dummy")
      kMenu(givenMenu, "Disable", "Flip painted mask &horizontally`tShift+H")
      kMenu(givenMenu, "Disable", "Flip painted mask &vertically`tShift+V")
      kMenu(givenMenu, "Disable", "Resize &bitmap to selection dimensions")
   }

   If isThisWin
      kMenu(givenMenu, "Add/Uncheck", "&Paint alpha mask`tCtrl+K", "toggleAlphaPaintingMode")
   Else
      kMenu(givenMenu, "Add", "&Define alpha mask`tM", "PanelSoloAlphaMasker")

   infoMask := defineCurrentAlphaMask()
   If (liveDrawingBrushTool!=1)
      kMenu(givenMenu, "Add", "Import clipboard as alpha mask", "importAlphaMaskFromClipboard")

   kMenu(givenMenu, "Add", "Copy to clipboard", "CopyAlphaMask2clippy",, " alpha mask bitmap")
   If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
      kMenu(givenMenu, "Disable", "Copy to clipboard",, " alpha mask bitmap")

   If (alphaMaskingMode>1)
   {
      keyu := (isThisWin=1 || isAlphaMaskPartialWin()=1) ? "`tN" : ""
      If (liveDrawingBrushTool!=1 && editingSelectionNow=1)
         kMenu(givenMenu, "Add", "Rasteri&ze alpha mask", "RasterizeAlphaMaskNow")
      kMenu(givenMenu, "Add/Uncheck", "&Invert alpha mask" keyu, "toggleInvertAlphaMask")
      If (alphaMaskColorReversed=1)
         kMenu(givenMenu, "Check", "&Invert alpha mask" keyu)
   } Else
   {
      kMenu(givenMenu, "Add", "Rasteri&ze alpha mask", "dummy")
      kMenu(givenMenu, "Disable", "Rasteri&ze alpha mask")
      kMenu(givenMenu, "Add", "&Invert alpha mask", "dummy")
      kMenu(givenMenu, "Disable", "&Invert alpha mask")
   }

   If (liveDrawingBrushTool=1)
   {
      kMenu(givenMenu, "Add", "&Reset brush colors to B/W`tD", "ResetColorsToBW")
      kMenu(givenMenu, "Check", "&Paint alpha mask`tCtrl+K")
      kMenu(givenMenu, "Check", "&Paint alpha mask`tCtrl+K")
   } Else If (editingSelectionNow=1)
      kMenu(givenMenu, "Add", "&Capture selected area as alpha mask", "SetImageAsAlphaMask")
}

createMenuHelpQPV() {
   If (thumbsDisplaying=1 && maxFilesIndex>1)
   {
      kMenu("PVhelp", "Add", "Capture screen shot of QPV", "ScreenCaptureListView", "screenshot")
      Menu, PVhelp, Add,
   }

   kMenu("PVhelp", "Add", "&Search menu options`t;", "PanelQuickSearchMenuOptions", "keyboard fast help where")
   kMenu("PVhelp", "Add", "&Keyboard shortcuts`tF1", "PanelHelpWindow", "keyboard shortcuts")
   kMenu("PVhelp", "Add", "Session &events journal`tShift+``", "PanelJournalWindow", "journal history errors logs")
   kMenu("PVhelp", "Add", "&Command line options", "MenuCmdLineHelp")
   kMenu("PVhelp", "Add", "&Video demos", "MenuOpenVideoDemos", "youtube recordings")
   If (TouchScreenMode=1)
      kMenu("PVhelp", "Add", "&Viewport help map", "MenuDrawViewportHelpMap")

   Menu, PVhelp, Add,
   kMenu("PVhelp", "Add", "C&heck for updates", "checkForUpdatesNow", "version")
   kMenu("PVhelp", "Add", "&Official QPV page", "OpenGitHub", "site")
   kMenu("PVhelp", "Add", "&Make a donation", "DonateNow", "paypal")
   kMenu("PVhelp", "Add", "&About", "PanelAboutWindow", "author developer")
}

MenuOpenVideoDemos() {
   Try, Run https://www.youtube.com/playlist?list=PLlfQlmy-i21bWEoFJKKH2dBZvt0yabRBV
}

MenuSetShapeTensionP() {
   MenuSetShapeTension(1,1,1)
}

MenuSetShapeTensionS() {
   MenuSetShapeTension(1,2,1)
}

MenuSetShapeTensionC() {
   MenuSetShapeTension(1,3,1)
}

MenuSetShapeTensionR() {
   MenuSetShapeTension(1,4,1)
}

MenuSetShapeTension(a,b,c) {
   FillAreaCurveTension := b
   If (AnyWindowOpen=23)
      GuiControl, SettingsGUIA: Choose, FillAreaCurveTension, % FillAreaCurveTension

   decideCustomShapeStyle()
   RegAction(1, "FillAreaCurveTension")
   SetTimer, dummyRefreshImgSelectionWindow, -150
   ; If (imgEditPanelOpened=1)
   ;    livePreviewsImageEditing()
}

checkForUpdatesNow() {
  If isWinStore()
  {
     Try Run, ms-windows-store://pdp/?productid=9N07RF144FV1
     Return
  }

  Static iniURL := "https://marius.sucan.ro/media/files/blog/ahk-scripts/qpv-version.ini"
  iniTMP := mainCompiledPath "\resources\update-infos.ini"
  BtnCloseWindow()
  showTOOLtip("Checking for updates, please wait")
  newVersion := newDate := 0
  FileDelete, %iniTmp%
  Sleep, 150
  UrlDownloadToFile, %iniURL%, %iniTmp%
  Sleep, 950
  If FileExist(iniTMP)
  {
     FileRead, OutputVar, %iniTmp%
     Loop, Parse, OutputVar, `n,`r
     {
        If InStr(A_LoopField, "version=")
        {
           klop := StrSplit(A_LoopField, "=")
           newVersion := Trimmer(klop[2])
        } Else If InStr(A_LoopField, "ReleaseDate=")
        {
           klop := StrSplit(A_LoopField, "=")
           newDate := Trimmer(klop[2])
        }
        If (A_Index>10)
           Break
     }
  }

  failed := (InStr(newVersion, ".") && InStr(newDate, "/")) ? 0 : 1
  new := (newVersion=appVersion && newDate=vReleaseDate) ? 0 : 1
  If (failed=1)
  {
     msg := "Failed to check for updates... Please click on «Manual check» to open the " appTitle " web site."
     friendly := "Manual check"
  } Else
  {
     msg := "Running version:`n" appVersion " [ " vReleaseDate " ]"
     msg .= "`n`nOnline version:`n" newVersion " [ " newDate " ]"
     msg .= (new=1) ? "`n`nA" : "`n`nNo"
     msg .= " new version seems to be available."
     friendly := (new!=1) ? "Open QPV web page" : "Download latest version"
  }
  RemoveTooltip()
  msgResult := msgBoxWrapper(appTitle ": Check for updates", msg, "&" friendly "|&Cancel", 0, "settings")

  If (InStr(msgResult, "open") || InStr(msgResult, "manual") || InStr(msgResult, "download"))
     OpenGitHub()

  RemoveTooltip()
}

MenuCmdLineHelp() {
   PanelHelpWindow("cmdu")
}

createMenuBonusNoImageOpened() {
   kMenu("PVmenu", "Add", "O&pen QPV settings folder", "openSettingsDir")
   kMenu("PVmenu", "Add", "&Close everything`tCtrl+F4", "closeDocuments")
   If (maxFilesIndex>1 && CurrentSLD)
      kMenu("PVmenu", "Add", "&Identify favourited images in the list", "findFavesInList", "faved faves stared")

   If (thumbsDisplaying=1)
   {
      If (mustPreventMenus=1 && showMainMenuBar=1)
      {
         createMenuSlideshows()
         kMenu("PVmenu", "Add", "&Slideshow", ":PVslide")
      } Else 
         kMenu("PVmenu", "Add", "&Play slideshow now", "MenuGoPlaySlidesNow")

      kMenu("PVmenu", "Add", "&Edit image captions`tShift+N", "PanelEditImgCaption", "modify annotations")
      keywords := (showImgAnnotations=1) ? "hide" : "display"
      kMenu("PVmenu", "Add/Uncheck", "&Show image captions`tN", "ToggleImgCaptions", keywords " viewport annotations")
      If (showImgAnnotations=1)
         kMenu("PVmenu", "Check", "&Show image captions`tN")

      kMenu("PVmenu", "Add/Uncheck", "&Two lines status bar", "ToggleMultiLineStatus", "statusbar info")
      If (multilineStatusBar=1)
         kMenu("PVmenu", "Check", "&Two lines status bar")
   }

   If (undoLevelsRecorded<1 && thumbsDisplaying!=1 && hasFileIndexUndo(currentFileIndex))
      kMenu("PVmenu", "Add", "Undo file action", "BtnUndoSingleFileAct", "history restore actions records")

   If (undoLevelsRecorded<1 && fileActsHistoryArray.Count()>0)
      kMenu("PVmenu", "Add", "Undo history", "PanelFileUndoHistory", "history restore actions records")

   kMenu("PVmenu", "Add/Uncheck", "Allow WIC loader", "ToggleWICloader")
   If (allowWICloader=1)
      kMenu("PVmenu", "Check", "Allow WIC loader")

   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (userSeenSlideImages>1 && maxFilesIndex>2 && CurrentSLD)
      kMenu("PVmenu", "Add", "Select seen images in current session", "selectSeenFilesSession")

   kMenu("PVmenu", "Add/Uncheck", "Allow FreeImage loader", "ToggleFIMloader")
   kMenu("PVmenu", "Add/Uncheck", "Private mode UI", "TogglePrivateMode")
   If (userPrivateMode=1)
      kMenu("PVmenu", "Check", "Private mode UI")
   If (allowFIMloader=1)
      kMenu("PVmenu", "Check", "Allow FreeImage loader")

   If (isImgEditingNow()=1 && animGIFsSupport=1)
   {
      kMenu("PVmenu", "Add", "&Increase GIFs playback speed`tAlt+.", "MenuIncGIFspeed",,,1)
      kMenu("PVmenu", "Add", "&Decrease GIFs playback speed`tAlt+,", "MenuDecGIFspeed",,,1)
   }
}

createMenuBonusImageLiveEditMode() {
   kMenu("PVtActFile", "Add", "&Open with external app (menu)", "OpenThisFileMenu")
   kMenu("PVtActFile", "Add", "File prope&rties (Explorer)", "OpenFileProperties")
   kMenu("PVtActFile", "Add", "&New QPV instance`tCtrl+Shift+N", "OpenNewQPVinstance")
   kMenu("PVtActFile", "Add", "Cop&y file path(s) as text", "CopyImagePath", "clipboard")
   kMenu("PVtActFile", "Add", "Open file in a new &QPV instance", "SoloNewQPVinstance")
   kMenu("PVtActFile", "Add", "&Explore the containing folder", "OpenThisFileFolder", "external open")

   If !isVarEqualTo(AnyWindowOpen, 31, 24)
   {
      createMenuImageEditSubMenus("filters")
      Try kMenu("PVmenu", "Add", "&Image filters", ":PVimgFilters")
   }

   kMenu("PVmenu", "Add", "File actions", ":PVtActFile")
   kMenu("PVmenu", "Add", "Pic&k color from image`tC", "changeBrushColorPicker", "picker pipette")
   kMenu("PVmenu", "Add/Uncheck", "&Apply image gamma correction", "toggleImgEditGammaCorrect", "image colors")
   If (userimgGammaCorrect=1)
      kMenu("PVmenu", "Check", "&Apply image gamma correction")
}

createMenuSoloFile(modus:=0) {
   Try Menu, PVtActFile, Delete
   If hasFileIndexUndo(currentFileIndex)
   {
      kMenu("PVtActFile", "Add", "&Undo file action`tCtrl+Z", "BtnUndoSingleFileAct")
      Menu, PVtActFile, Add
   }

   kMenu("PVtActFile", "Add", "&Open with external app`tO", "OpenThisFileMenu")
   kMenu("PVtActFile", "Add", "Open file in a new &QPV instance", "SoloNewQPVinstance")
   zPlitPath(resultedFilesList[currentFileIndex, 1], 0, OutFileName, OutDir)
   kbdu := (thumbsDisplaying=1) ? "`tAlt+E" : ""
   kMenu("PVtActFile", "Add", "Open in QPV the containin&g folder" kbdu, "OpenQPVfileFolder")
   kMenu("PVtActFile", "Add", "&Explore containing folder`tCtrl+E", "OpenThisFileFolder")
   If !FolderExist(OutDir)
   {
      kMenu("PVtActFile", "Disable", "Open in QPV the containin&g folder`tAlt+E")
      kMenu("PVtActFile", "Disable", "&Explore containing folder`tCtrl+E")
   }
   If (StrReplace(CurrentSLD, "|")=OutDir)
      kMenu("PVtActFile", "Disable", "Open in QPV the containin&g folder" kbdu)

   kMenu("PVtActFile", "Add", "Set containing folder as the &protected folder", "setContaintFolderAsProtected")
   If (mustPreventMenus=1)
   {
      kMenu("PVtActFile", "Add", "Open with default application", "OpenWithDefaultApp")
      kMenu("PVtActFile", "Add", "System «Open with» dialog", "MenuInvokeSHopenWith", "external")
   }

   Menu, PVtActFile, Add
   If (modus!="simple")
   {
      If (thumbsDisplaying=1)
      {
         If !EntryMarkedMoveIndex
            kMenu("PVtActFile", "Add", "Mar&k entry to reorder`tX", "moveMarkedEntryNow")
         Else
            kMenu("PVtActFile", "Add", "Move mar&ked entry to focused index`tX", "moveMarkedEntryNow")
      }

      friendly := resultedFilesList[currentFileIndex, 2] ? "De&select" : "&Select"
      If !markedSelectFile
         kMenu("PVfilesActs", "Add", friendly " file`tTab", "markThisFileNow")

      kMenu("PVtActFile", "Add", "Remove inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
      kMenu("PVtActFile", "Add", "&Modify index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
      Menu, PVtActFile, Add
   }

   kMenu("PVtActFile", "Add", "&Delete file`tCtrl+Delete", "DeleteActivePicture")
   kMenu("PVtActFile", "Add", "&Delete file and index entry`tShift+Delete", "DeleteActiveImgFileAndEntry")
   kMenu("PVtActFile", "Add", "&Rename file`tShift+F2", "SingularRenameFile")
   ; If (thumbsDisplaying!=1 && modus!="simple")
      kMenu("PVtActFile", "Add", "&File information`tAlt+Enter", "PanelImageInfos", "show details properties image")
}

chainInvokerFoldersListMenu() {
   Global lastOtherWinClose := 1
   SetTimer, invokeFoldersListerMenu, -60
}

MenuIncVProtation() {
   changeImgRotationInVP(1)
}

MenuDecVProtation() {
   changeImgRotationInVP(-1)
}

MenuLIncVProtation() {
   changeImgRotationInVP(1, 1)
}

MenuLDecVProtation() {
   changeImgRotationInVP(-1, 1)
}

MenuResetVProtation() {
   vpIMGrotation := 0
   INIaction(1, "vpIMGrotation", "General")
   dummyTimerDelayiedImageDisplay(50)
}

MenuChangeIncContrast() {
   VPchangeGammos(-1)
}
MenuChangeDecContrast() {
   VPchangeGammos(1)
}
MenuChangeIncSaturat() {
   VPchangeSaturation(1)
}
MenuChangeDecSaturat() {
   VPchangeSaturation(-1)
}
MenuChangeIncGamma() {
   VPchangeRealGamma(1)
}
MenuChangeDecGamma() {
   VPchangeRealGamma(-1)
}
MenuChangeIncBright() {
   VPchangeLumos(1)
}
MenuChangeDecBright() {
   VPchangeLumos(-1)
}
MenuIncBrushSize() {
   changeBrushSize(1)
}
MenuIncBrushAngle() {
   changeBrushRatioAngle(1, 2)
}
MenuDecBrushAngle() {
   changeBrushRatioAngle(-1, 2)
}
MenuIncBrushAspectRatio() {
   userChangeBrushRatio(0, 1)
}
MenuDecBrushAspectRatio() {
   userChangeBrushRatio(0, -1)
}
MenuIncBrushSoftness() {
   userChangeBrushSoft(0, 1)
}
MenuIncBrushWetness() {
   changeBrushWetness(1)
}
MenuIncBrushOpacity() {
   changeBrushOpacity(-1,0)
}
MenuDecBrushSize() {
   changeBrushSize(-1)
}
MenuDecBrushSoftness() {
   userChangeBrushSoft(0, -1)
}
MenuDecBrushWetness() {
   changeBrushWetness(-1)
}
MenuDecBrushOpacity() {
   changeBrushOpacity(1,0)
}

createMenuImgVProtation() {
   kMenu("PVimgVProt", "Add", "&Rotate by +5°`t0", "MenuIncVProtation",, " (image)", 1)
   kMenu("PVimgVProt", "Add", "R&otate by -5°`t9", "MenuDecVProtation",, " (image)", 1)
   If (mustPreventMenus=1)
   {
      kMenu("PVimgVProt", "Add", "&Rotate by +1°`tAlt+0", "MenuLIncVProtation",, " (image)", 1)
      kMenu("PVimgVProt", "Add", "&Rotate by -1°`tAlt+9", "MenuLDecVProtation",, " (image)", 1)
   }

   If (vpIMGrotation>0)
   {
      Menu, PVimgVProt, Add
      kMenu("PVimgVProt", "Add", "&Reset rotation`t\", "MenuResetVProtation",, " (image)")
   }

   If (mustPreventMenus!=1)
   {
      Menu, PVimgVProt, Add
      kMenu("PVimgVProt", "Add", "0°", "MenuSetVProt")
      kMenu("PVimgVProt", "Add", "23°", "MenuSetVProt")
      kMenu("PVimgVProt", "Add", "45°", "MenuSetVProt")
      kMenu("PVimgVProt", "Add", "90°", "MenuSetVProt")
      kMenu("PVimgVProt", "Add", "135°", "MenuSetVProt")
      kMenu("PVimgVProt", "Add", "180°", "MenuSetVProt")
      kMenu("PVimgVProt", "Add", "225°", "MenuSetVProt")
      kMenu("PVimgVProt", "Add", "270°", "MenuSetVProt")
      kMenu("PVimgVProt", "Add", "315°", "MenuSetVProt")
      kMenu("PVimgVProt", "Add", vpIMGrotation "°", "dummy")
      kMenu("PVimgVProt", "Check/Disable", vpIMGrotation "°")
   }
}

createMenuNavBox() {
   infoThumbsList := defineListViewModes()
   infoThumbsMode := (thumbsDisplaying=1) ? "Switch to image view" : "Switch to " infoThumbsList " list view"
   If (thumbsDisplaying=1)
      kMenu("PvImgAdapt", "Add", "C&ycle view modes`tL", "toggleListViewModeThumbs")

   If (maxFilesIndex>0 && !AnyWindowOpen)
      kMenu("PvImgAdapt", "Add", infoThumbsMode "`tEnter", "MenuDummyToggleThumbsMode")

   If (mustRecordSeenImgs=1 && thumbsDisplaying=1)
   {
      Menu, PvImgAdapt, Add
      kMenu("PvImgAdapt", "Add/Uncheck", "&Highlight already seen images", "ToggleMarkSeenIMGs", "thumbnails")
      If (highlightAlreadySeenImages=1)
         kMenu("PvImgAdapt", "Check", "&Highlight already seen images")
      Menu, PvImgAdapt, Add
   }

   keyword := (folderTreeWinOpen=1) ? " hide" : " display"
   kMenu("PvImgAdapt", "Add/Uncheck", "Show &folders tree panel`tF4", "MenuPanelFoldersTree", "window treeview directories explore" keyword)
   If (folderTreeWinOpen=1)
      kMenu("PvImgAdapt", "Check", "Show &folders tree panel`tF4")

   keyword := (ShowAdvToolbar=1) ? "hide" : "display"
   kMenu("PvImgAdapt", "Add/Uncheck", "Show &toolbar`tShift+F10", "toggleAppToolbar", keyword)
   If (ShowAdvToolbar=1)
      kMenu("PvImgAdapt", "Check", "Show &toolbar`tShift+F10")

   If (maxFilesIndex>0 && CurrentSLD)
   {
      keyword := (showInfoBoxHUD=1) ? "hide" : "show display"
      kMenu("PvImgAdapt", "Add/Uncheck", "&Show viewport info-box`tI", "ToggleInfoBoxu", "files details information properties " keyword)
      If (showInfoBoxHUD>=1)
         kMenu("PvImgAdapt", "Check", "&Show viewport info-box`tI")
   }

   kMenu("PvImgAdapt", "Add/Uncheck", "&Show image preview`tZ", "ToggleImgNavBox")
   If (showHUDnavIMG=1)
   {
      kMenu("PvImgAdapt", "Check", "&Show image preview`tZ")
      kMenu("PvImgAdapt", "Add/Uncheck", "&Large preview size", "ToggleImgNavSizeBox")
      If (HUDnavBoxSize>=125)
         kMenu("PvImgAdapt", "Check", "&Large preview size")
   }
}

createMenuImgSizeAdapt(dummy:=0) {
   keyu := (drawingShapeNow=1 || liveDrawingBrushTool=1 && thumbsDisplaying!=1) ? "" : "`tT"
   kMenu("PvImgAdapt", "Add", "C&ycle adapt to window modes" keyu, "ToggleImageSizingMode",, " (image)", 1)
   kMenu("PvImgAdapt", "Add", "Cycle custom zoom modes`tCtrl+/", "toggleCustomZLmodes",,,1)
   Menu, PvImgAdapt, Add
   kMenu("PvImgAdapt", "Add/Uncheck", "&Adapt all to fit window`t/", "MenuSetImageAdaptAll",, " (image)")
   If (imgEditPanelOpened!=1)
   {
      kMenu("PvImgAdapt", "Add/Uncheck", "Adapt only &large images", "MenuSetImageAdaptLarge",, " (image)")
      If (IMGresizingMode=2)
         kMenu("PvImgAdapt", "Check", "Adapt only &large images",,, " (image)")
   
      kMenu("PvImgAdapt", "Add/Uncheck", "Stretched to &window", "MenuSetImageStretchedWin",, " (image)")
      If (IMGresizingMode=5)
         kMenu("PvImgAdapt", "Check", "Stretched to &window",,, " (image)")
   }

   kMenu("PvImgAdapt", "Add/Uncheck", "Custom &zoom level (" Round(zoomLevel*100) "%)", "MenuSetImageCustomZoom",, " (image)")
   kMenu("PvImgAdapt", "Add/Uncheck", "&Adapt to window width`tNumpad *", "toggleCustomZLadaptW",, " (image)")
   kMenu("PvImgAdapt", "Add/Uncheck", "&Adapt to window height`tNumpad *", "toggleCustomZLadaptH",, " (image)")
   If (customZoomAdaptMode=1 && IMGresizingMode=4)
      kMenu("PvImgAdapt", "Check", "&Adapt to window width`tNumpad *",,, " (image)")
   Else If (customZoomAdaptMode=2 && IMGresizingMode=4)
      kMenu("PvImgAdapt", "Check", "&Adapt to window height`tNumpad *",,, " (image)")

   If (IMGresizingMode=1)
      kMenu("PvImgAdapt", "Check", "&Adapt all to fit window`t/",,, " (image)")
   Else If (IMGresizingMode=4 && customZoomAdaptMode=0)
      kMenu("PvImgAdapt", "Check", "Custom &zoom level (" Round(zoomLevel*100) "%)",,, " (image)")

   If (mustPreventMenus!=1)
   {
      Menu, PvImgAdapt, Add
      If (dummy!="bonus")
      {
         kMenu("PvImgAdapt", "Add", "6%", "MenuSetImgZoom")
         kMenu("PvImgAdapt", "Add", "12%", "MenuSetImgZoom")
         kMenu("PvImgAdapt", "Add", "25%", "MenuSetImgZoom")
      }
      kMenu("PvImgAdapt", "Add", "50%", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "100% (original size)`tNumpad *", "MenuSetImgZoom")
      kMenu("PvImgAdapt", "Add", "200%", "MenuSetImgZoom")
      If (dummy!="bonus")
      {
         kMenu("PvImgAdapt", "Add", "400%", "MenuSetImgZoom")
         kMenu("PvImgAdapt", "Add", "800%", "MenuSetImgZoom")
      }
      Menu, PvImgAdapt, Add
   }

   kMenu("PvImgAdapt", "Add/Uncheck", "&High quality image resampling", "ToggleImgQuality", "settings performance")
   If (userimgQuality=1)
      kMenu("PvImgAdapt", "Check", "&High quality image resampling")

   If (IMGresizingMode=4 && drawingShapeNow=0)
   {
      kMenu("PvImgAdapt", "Add/Uncheck", "&Keep zoom level between images", "toggleLockZoom")
      If (lockZoomLevel=1 && customZoomAdaptMode=0)
         kMenu("PvImgAdapt", "Check", "&Keep zoom level between images")
   }

   If (dummy="bonus")
   {
      Menu, PvImgAdapt, Add
      kMenu("PvImgAdapt", "Add/Uncheck", "&Show image navigator`tZ", "ToggleImgNavBox")
      If (showHUDnavIMG=1)
      {
         kMenu("PvImgAdapt", "Check", "&Show image navigator`tZ")
         kMenu("PvImgAdapt", "Add/Uncheck", "&Large navigator size", "ToggleImgNavSizeBox")
         If (HUDnavBoxSize>=125)
            kMenu("PvImgAdapt", "Check", "&Large navigator size")
      }

      If (drawingShapeNow=0 && mustCaptureCloneBrush=0)
      {
         If (InStr(currIMGdetails.PixelFormat, "TONE-MAPP") && !AnyWindowOpen)
            kMenu("PVview", "Add", "Adjust &HDR tone-mapping", "PanelAdjustToneMapping", "colors dynamic exposure gamma hdr raw")

         If !AnyWindowOpen
            kMenu("PVview", "Add", "Viewport and color adjustments panel`tU", "PanelColorsAdjusterWindow")

         kMenu("PVview", "Add", "Reset vie&wport adjustments`t\", "ResetImageView", "image")
         kMenu("PVview", "Add/Uncheck", "Centered &alignment`tA", "ToggleIMGalign", "viewport image position", " (image)")
         If (imageAligned=5)
            kMenu("PVview", "Check", "Centered &alignment`tA",,, " (image)")

         If (thumbsDisplaying!=1)
         {
            kMenu("PVview", "Add/Uncheck", "Allo&w outside viewport image panning", "toggleFreePanning")
            If (allowFreeIMGpanning=1)
               kMenu("PVview", "Check", "Allo&w outside viewport image panning")
         }

         If (thumbsDisplaying!=1 && (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen!=24 && AnyWindowOpen!=31))
            kMenu("PVview", "Add", "Configure viewport &grid", "PanelConfigVPgrid")

         kMenu("PVview", "Add/Uncheck", "Show viewport &grid", "toggleViewPortGridu", keyword)
         If (showViewPortGrid=1)
            kMenu("PVview", "Check", "Show viewport &grid")

         kMenu("PVview", "Add", "C&ycle histogram modes`tG", "ToggleImgHistogram",,,1)
         keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1 || AnyWindowOpen=63) ? "" : "`tQ"
         kMenu("PVview", "Add", "C&ycle simulate color depths" keyu, "ToggleImgColorDepth",,,1)
         kMenu("PVview", "Add", "C&ycle colors display modes`tF", "ToggleImgFX",,,1)

         infoThumbsList := defineListViewModes()
         infoThumbsMode := (thumbsDisplaying=1) ? "Switch to image view" : "Switch to " infoThumbsList " list view"
         If (maxFilesIndex>0 && !AnyWindowOpen)
            kMenu("PVview", "Add", infoThumbsMode "`tEnter", "MenuDummyToggleThumbsMode")

         If (maxFilesIndex>1 && !AnyWindowOpen && prevOpenedWindow[2])
            kMenu("PVview", "Add", "Open pre&vious panel`tF8", "openPreviousPanel", "show")

         keyword := (ShowAdvToolbar=1) ? "hide" : "display"
         kMenu("PVview", "Add/Uncheck", "Show &toolbar`tShift+F10", "toggleAppToolbar", keyword)
         If (ShowAdvToolbar=1)
            kMenu("PVview", "Check", "Show &toolbar`tShift+F10")

         If (maxFilesIndex>0 && CurrentSLD)
         {
            keyword := (showInfoBoxHUD=1) ? "hide" : "show display"
            kMenu("PVview", "Add/Uncheck", "&Show viewport info-box`tI", "ToggleInfoBoxu", "files details information properties " keyword)
            If (showInfoBoxHUD>=1)
               kMenu("PVview", "Check", "&Show viewport info-box`tI")
         }
         kMenu("PvImgAdapt", "Add", "&More options", ":PVview")
      } Else
      {
         kMenu("PvImgAdapt", "Add/Uncheck", "Centered &alignment`tA", "ToggleIMGalign", "viewport image position", " (image)")
         If (imageAligned=5)
            kMenu("PvImgAdapt", "Check", "Centered &alignment`tA",,, " (image)")

         If (thumbsDisplaying!=1)
         {
            kMenu("PvImgAdapt", "Add/Uncheck", "Allo&w outside viewport image panning", "toggleFreePanning")
            If (allowFreeIMGpanning=1)
               kMenu("PvImgAdapt", "Check", "Allo&w outside viewport image panning")
         }
      }
   }
}

createMenuMainPreferences() {
   kMenu("PVperfs", "Add/Uncheck", "&Limit memory usage", "ToggleLimitMemUsage")
   kMenu("PVperfs", "Add/Uncheck", "&Record undo levels", "TogglePreventUndos", "history")
   If (preventUndoLevels!=1)
      kMenu("PVperfs", "Check", "&Record undo levels")

   kMenu("PVperfs", "Add/Uncheck", "&Multi-threaded processing", "PanelSetSystemCores")
   If (minimizeMemUsage=1)
      kMenu("PVperfs", "Disable", "&Multi-threaded processing")

   If (A_PtrSize=4)
   {
      kMenu("PVperfs", "Disable", "&Multi-threaded processing")
      kMenu("PVperfs", "Disable", "&Limit memory usage")
      kMenu("PVperfs", "Check", "&Limit memory usage")
   }

   kMenu("PVperfs", "Add/Uncheck", "&High quality image resampling", "ToggleImgQuality")
   kMenu("PVperfs", "Add/Uncheck", "&Perform dithering on color depth changes", "ToggleImgColorDepthDithering")
   kMenu("PVperfs", "Add/Uncheck", "&Apply gamma correction", "toggleImgEditGammaCorrect", "image colors")
   kMenu("PVperfs", "Add/Uncheck", "&Load Camera RAW files at high quality", "ToggleRAWquality")
   If (userimgGammaCorrect=1)
      kMenu("PVperfs", "Check", "&Apply gamma correction")
   If (minimizeMemUsage=1)
      kMenu("PVperfs", "Check", "&Limit memory usage")
   If (allowMultiCoreMode=1)
      kMenu("PVperfs", "Check", "&Multi-threaded processing")
   If (ColorDepthDithering=1)
      kMenu("PVperfs", "Check", "&Perform dithering on color depth changes")
   If (userimgQuality=1)
      kMenu("PVperfs", "Check", "&High quality image resampling")
   If (userHQraw=1)
      kMenu("PVperfs", "Check", "&Load Camera RAW files at high quality")

   kMenu("PVprefs", "Add", "Save settings into a .SLD file", "WritePrefsIntoSLD")
   kMenu("PVprefs", "Add/Uncheck", "&Never load settings from a .SLD", "ToggleIgnoreSLDprefs")
   kMenu("PVprefs", "Add", "Associate QPV with image formats", "PanelAssociateQPV", "system")
   If !A_IsAdmin
      kMenu("PVprefs", "Add", "Run in admin mode", "RunAdminMode")

   Menu, PVprefs, Add, 
   kMenu("PVprefs", "Add/Uncheck", "Load an&y image format using FreeImage", "ToggleAlwaysFIMus")
   kMenu("PVprefs", "Add", "Performance options", ":PVperfs")
   Menu, PVprefs, Add, 
   If (thumbsDisplaying!=1)
   {
      kMenu("PVprefs", "Add/Uncheck", "Auto-play an&imated GIFs", "ToggleAnimGIFsupport")
      If (animGIFsSupport=1)
         kMenu("PVprefs", "Check", "Auto-play an&imated GIFs")
      If (alwaysOpenwithFIM=1)
         kMenu("PVprefs", "Disable", "Auto-play an&imated GIFs")
   }

   kMenu("PVprefs", "Add/Uncheck", "Allo&w custom keyboard shortcuts", "ToggleCustomKBDsMode")
   If (allowCustomKeys=1)
      kMenu("PVprefs", "Check", "Allo&w custom keyboard shortcuts")
   kMenu("PVprefs", "Add", "C&ustom keyboard shortcuts", "PanelCustomKeysMiniManager", "customize defined users manage personal")
   kMenu("PVprefs", "Add", "&Quick file actions", "PanelQuickMoveConfigure", "index list fast")
   If (mustPreventMenus=1)
   {
      kMenu("PVprefs", "Add/Uncheck", "&Toggle Quick file action shortcuts", "toggleQuickMoveActionKeys", "index list fast")
      If (allowUserQuickFileActions=1)
         kMenu("PVprefs", "Check", "&Toggle Quick file action shortcuts")
   }

   kMenu("PVprefs", "Add/Uncheck", "&Record seen images", "ToggleRecordSeenImages", "history")
   If (mustRecordSeenImgs=1)
      kMenu("PVprefs", "Check", "&Record seen images")

   kMenu("PVprefs", "Add/Uncheck", "&Prompt before file delete", "TogglePromptDelete")
   If (askDeleteFiles=1)
      kMenu("PVprefs", "Check", "&Prompt before file delete")
   If (MustLoadSLDprefs=0)
      kMenu("PVprefs", "Check", "&Never load settings from a .SLD")

   Menu, PVprefs, Add, 
   If (mustRecordSeenImgs=1)
      kMenu("PVprefs", "Add", "Seen images database options", "PanelSeenIMGsOptions")

   If FolderExist(thumbsCacheFolder)
      kMenu("PVprefs", "Add", "Erase cached thumbnails", "PanelfolderThanEraseThumbsCache")

   kMenu("PVprefs", "Add/Uncheck", "Cache generated thumbnails", "ToggleThumbsCaching")
   If (alwaysOpenwithFIM=1)
      kMenu("PVprefs", "Check", "Load an&y image format using FreeImage")

   If (enableThumbsCaching=1)
   {
      If (thumbsDisplaying=1)
         kMenu("PVprefs", "Add", "Generate all thumbnails no&w", "generateAllThumbsNow")

      kMenu("PVprefs", "Check", "Cache generated thumbnails")
   }
}

createMenuMainView() {
   If (thumbsDisplaying=1)
   {
      kMenu("PVview", "Add", "C&ycle view modes`tL", "toggleListViewModeThumbs")
      kMenu("PVview", "Add", defineListViewModes(), "dummy")
      kMenu("PVview", "Disable", defineListViewModes())

      Menu, PVview, Add
      kMenu("PVview", "Add/Uncheck", "&Two lines status bar", "ToggleMultiLineStatus", "statusbar info")
      If (multilineStatusBar=1)
         kMenu("PVview", "Check", "&Two lines status bar")

      kMenu("PVview", "Add/Uncheck", "Private mode UI", "TogglePrivateMode")
      If (userPrivateMode=1)
         kMenu("PVview", "Check", "Private mode UI")

      If (testIsDupesList()=1)
      {
         kMenu("PVview", "Add/Uncheck", "&Fade the other dupe groups", "ToggleTDupesGroupsFading")
         If (fadeOtherDupeGroups=1)
            kMenu("PVview", "Check", "&Fade the other dupe groups")
      }

      If (mustRecordSeenImgs=1)
      {
         kMenu("PVview", "Add/Uncheck", "&Highlight seen images", "ToggleMarkSeenIMGs", "thumbnails")
         If (highlightAlreadySeenImages=1)
            kMenu("PVview", "Check", "&Highlight seen images")
      }

      If (thumbsListViewMode=1)
      {
         infoThumbZoom := thumbsColumns " | " thumbsW "x" thumbsH " px" ; " (" Round(thumbsZoomLevel*100) "%)"
         kMenu("PVview", "Add", "&Cycle aspect ratios`tT", "ToggleThumbsAratio")
         Try kMenu("PVview", "Add", defineThumbsAratio(), "dummy")
         Try kMenu("PVview", "Disable", defineThumbsAratio())
         Menu, PVview, Add
         kMenu("PVview", "Add", "&Set columns and other options`tU", "PanelSetThumbColumnOptions")
         ; kMenu("PVview", "Disable", "Thumbnails columns and size:")
         kMenu("PVview", "Add", infoThumbZoom, "dummy")
         kMenu("PVview", "Disable", infoThumbZoom)
      }
   } Else
   {
      createMenuImgSizeAdapt()
      createMenuImgVProtation()
      If (InStr(currIMGdetails.PixelFormat, "TONE-MAPP") && !AnyWindowOpen)
         kMenu("PVview", "Add", "Adjust &HDR tone-mapping", "PanelAdjustToneMapping", "colors dynamic exposure gamma hdr raw")

      If (!AnyWindowOpen || isNowAlphaPainting()!=1 && imgEditPanelOpened=1 && AnyWindowOpen!=24 && AnyWindowOpen!=31)
         kMenu("PVview", "Add", "Viewport and color adjustments panel`tShift+U", "PanelColorsAdjusterWindow")

      ; createMenuVPhudHisto()
      ; kMenu("PVview", "Add", "Show histogram", ":PVimgHistos")
      friendlyPix := (coreDesiredPixFmt="0x21808") ? "24-RGB" : "32-RGBA"
      Menu, PVview, Add
      If (A_PtrSize=4)
         kMenu("PVview", "Add", "Pi&xel format mode: " friendlyPix, "ToggleCorePixFmt")

      ; If (!AnyWindowOpen || mustPreventMenus=1)
         kMenu("PVview", "Add", "&Rotation ("vpIMGrotation "°)", ":PVimgVProt")
      kMenu("PVview", "Add", "&Zoom and adapt modes", ":PvImgAdapt")
   }

   If (thumbsListViewMode=1 || thumbsDisplaying!=1)
   {
      createMenuColorDepth()
      dontShow := (thumbsDisplaying=1 && minimizeMemUsage=1) ? 1 : 0
      Menu, PVview, Add
      kMenu("PVview", "Add", "Simulated color &depth", ":PVimgSdepth")
      If (dontShow!=1)
      {
         createMenuImgColorsFX()
         kMenu("PVview", "Add", "Colors F&X and display modes", ":PVimgColorsFX")
      }

      Menu, PVview, Add
      kMenu("PVview", "Add/Uncheck", "Centered &alignment`tA", "ToggleIMGalign", "viewport image position")
      If (imageAligned=5)
         kMenu("PVview", "Check", "Centered &alignment`tA")

      kMenu("PVview", "Add/Uncheck", "Mirror &vertically`tV", "VPflipImgV", "viewport flip image")
      If (FlipImgV=1)
         kMenu("PVview", "Check", "Mirror &vertically`tV")
   }

   kMenu("PVview", "Add/Uncheck", "Mirror &horizontally`tH", "VPflipImgH", "viewport flip image")
   If (FlipImgH=1)
      kMenu("PVview", "Check", "Mirror &horizontally`tH")

   Menu, PVview, Add
   If (thumbsDisplaying!=1)
   {
      kMenu("PVview", "Add/Uncheck", "Allo&w outside viewport image panning", "toggleFreePanning")
      If (allowFreeIMGpanning=1)
         kMenu("PVview", "Check", "Allo&w outside viewport image panning")
   }

   If (thumbsDisplaying!=1 || thumbsListViewMode=1)
      kMenu("PVview", "Add", "Reset vie&wport adjustments`t\", "ResetImageView", "image")
   If (mustPreventMenus=1)
      kMenu("PVview", "Add", "Deep reset of vie&wport adjustments`tCtrl+\", "HardResetImageView", "image")

   keyword := (showViewPortGrid=1) ? "hide" : "display"
   If (mustPreventMenus=1 && thumbsDisplaying!=1)
   {
      kMenu("PVview", "Add", "Increase viewport grid size`tAlt+=", "MenuIncVPgridSize",,,1)
      kMenu("PVview", "Add", "Decrease viewport grid size`tAlt+-", "MenuDecVPgridSize",,,1)
   }
 
   If (mustPreventMenus=1)
   {
      If (thumbsDisplaying=1)
      {
         If (thumbsListViewMode>1)
         {
            kMenu("PVview", "Add", "Increase viewport text size`tCtrl+=", "MenuChangeOSDZoomPlus", "disability handicap eyes eyesight large",,1)
            kMenu("PVview", "Add", "Decrease viewport text size`tCtrl+-", "MenuChangeOSDZoomMinus", "disability handicap eyes eyesight large",,1)
         } Else
         {
            kMenu("PVview", "Add", "Decrease thumbnails size`t=", "MenuChangeImgZoomPlus")
            kMenu("PVview", "Add", "Increase thumbnails size`t-", "MenuChangeImgZoomMinus")
         }
      } Else
      {
         kMenu("PVview", "Add", "Zoom in (image)`t=", "MenuChangeImgZoomPlus",,, 1)
         kMenu("PVview", "Add", "Zoom out (image)`t-", "MenuChangeImgZoomMinus",,, 1)
      }

      keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1) ? "" : "`tShift+]"
      kMenu("PVview", "Add", "Increase image contrast" keyu, "MenuChangeIncContrast",,, 1)
      keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1) ? "" : "`tShift+["
      kMenu("PVview", "Add", "Decrease image contrast" keyu, "MenuChangeDecContrast",,, 1)
      keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1) ? "" : "`tCtrl+]"
      kMenu("PVview", "Add", "Increase image saturation" keyu, "MenuChangeIncSaturat",,, 1)
      keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1) ? "" : "`tCtrl+["
      kMenu("PVview", "Add", "Decrease image saturation" keyu, "MenuChangeDecSaturat",,, 1)
      keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1) ? "" : "`tAlt+]"
      kMenu("PVview", "Add", "Increase image gamma" keyu, "MenuChangeIncGamma",,, 1)
      keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1) ? "" : "`tAlt+["
      kMenu("PVview", "Add", "Decrease image gamma" keyu, "MenuChangeDecGamma",,, 1)
      keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1) ? "" : "`t]"
      kMenu("PVview", "Add", "Increase image brightness" keyu, "MenuChangeIncBright",,, 1)
      keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1) ? "" : "`t["
      kMenu("PVview", "Add", "Decrease image brightness" keyu, "MenuChangeDecBright",,, 1)
   }

   If (thumbsDisplaying!=1)
   {
      kMenu("PVview", "Add/Uncheck", "Show viewport &grid", "toggleViewPortGridu", keyword)
      If (showViewPortGrid=1)
         kMenu("PVview", "Check", "Show viewport &grid")
   
      If ((imgEditPanelOpened=1 || mustPreventMenus=1) && showViewPortGrid=1)
      {
         kMenu("PVview", "Add/Uncheck", "Fi&xed grid size", "toggleGridFixedSize")
         If (vpGridFixedSize=1)
            kMenu("PVview", "Check", "Fi&xed grid size")
      }

      If (!AnyWindowOpen || isNowAlphaPainting()!=1 && imgEditPanelOpened=1 && AnyWindowOpen!=24 && AnyWindowOpen!=31)
         kMenu("PVview", "Add", "Configure viewport &grid", "PanelConfigVPgrid")

      If !AnyWindowOpen
      {
         Menu, PVview, Add
         kMenu("PVview", "Add/Uncheck", "Reset adjustments on image change", "ToggleAutoResetImageView")
         If (resetImageViewOnChange=1)
            kMenu("PVview", "Check", "Reset adjustments on image change")
      }
   } Else
   {
      Menu, PVview, Add
      friendly := (markedSelectFile>1) ? "Refresh selected thumbnails on scroll" : "Refresh all thumbnails on scroll"
      If (thumbsDisplaying=1 && thumbsListViewMode=1)
      {
         kMenu("PVview", "Add", friendly "`tAlt+F5", "DeepRefreshThumbsNow")
         If (enableThumbsCaching=1)
            kMenu("PVview", "Add", "Generate all thumbnails no&w", "generateAllThumbsNow")
      }
   }
}

createMenuCopyFile(mena) {
   kMenu(mena, "Add", "Copy folder path(s) as text", "CopyImageFolderPaths", "text clipboard")
   kMenu(mena, "Add", "Cop&y file name(s) as text", "CopyImageFileNames", "clipboard")
   kMenu(mena, "Add", "&Copy complete path(s) as text`tShift+C", "CopyImagePath", "clipboard")

   Menu, % mena, Add
   infoKbd := (thumbsDisplaying=1) ? "`tCtrl+C" : ""
   kMenu(mena, "Add", "Copy file(s) (for E&xplorer)" infoKbd, "MenuExplorerCopyFiles", "clipboard")
   infoKbd := (thumbsDisplaying=1) ? "`tCtrl+X" : ""
   kMenu(mena, "Add", "C&ut file(s) (for Explorer)" infoKbd, "MenuExplorerCutFiles", "clipboard")
   kMenu(mena, "Add", "Copy con&taining folder(s) (for Explorer)", "MenuExplorerCopyContainFolder", "clipboard")
   kMenu(mena, "Add", "Cut containin&g folder(s) (for Explorer)", "MenuExplorerCutContainFolder", "clipboard")
}

createMenuOpenFileOptions(modus:=0) {
   If !markedSelectFile
      kMenu("PVtFileOpen", "Add", "&Open with external app`tO", "OpenThisFileMenu")

   If markedSelectFile
      kMenu("PVtFileOpen", "Add", "Open files in new &QPV instances`tCtrl+Enter", "OpenWithNewQPVinstance")
   Else
      kMenu("PVtFileOpen", "Add", "Open file in a new &QPV instance`tCtrl+Enter", "SoloNewQPVinstance")

   zPlitPath(resultedFilesList[currentFileIndex, 1], 0, OutFileName, OutDir)
   kbdu := (thumbsDisplaying=1) ? "`tAlt+E" : ""
   kMenu("PVtFileOpen", "Add", "&Open in QPV the containing folder" kbdu, "OpenQPVfileFolder")
   If (StrReplace(CurrentSLD, "|")=OutDir)
      kMenu("PVtFileOpen", "Disable", "&Open in QPV the containing folder" kbdu)

   If !markedSelectFile
   {
      kMenu("PVtFileOpen", "Add", "&Open containing folder in Explorer`tCtrl+E", "OpenThisFileFolder", "external")
      If (modus!="simple")
         kMenu("PVtFileOpen", "Add", "&Containing folder properties (Explorer)", "OpenThisFilePropFolder", "external")
   }
}

createMenuImageFileActions(whichMenu) {
   imgPath := getIDimage(currentFileIndex)
   kMenu(whichMenu, "Add", "&Auto-crop image(s)`tAlt+Y", "PanelImgAutoCrop")
   kMenu(whichMenu, "Add", "&JPEG lossless operations`tShift+J", "PanelJpegPerformOperation")
   If (!RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && !markedSelectFile)
      kMenu(whichMenu, "Disable", "&JPEG lossless operations`tShift+J")

   keyu := (thumbsDisplaying=1) ? "`tCtrl+R" : ""
   kMenu(whichMenu, "Add", "Resi&ze/rotate/crop image(s)" keyu, "PanelSimpleResizeRotate", "process advanced")
   If markedSelectFile
      kMenu(whichMenu, "Add", "&Auto-crop image(s)`tAlt+Y", "PanelImgAutoCrop")

   If (thumbsDisplaying=1 || markedSelectFile)
   {
      pk := (markedSelectFile>1) ? "s" : ""
      Menu, % whichMenu, Add
      infoKbd := (thumbsDisplaying=1) ? "`tShift+U" : ""
      kMenu(whichMenu, "Add", "Apply vie&wport color adjustments" infoKbd, "filesListApplyColors", "image")
      kMenu(whichMenu, "Add", "Apply advanced color adjustments", "PanelAdjustColorsSimpleWindow", "image")
      kMenu(whichMenu, "Add", "A&utomatic contrast / levels", "PanelAutoColors", "image")
      infoKbd := (thumbsDisplaying=1) ? "`tShift+H" : ""
      kMenu(whichMenu, "Add", "Flip image" pk " &horizontally" infoKbd, "filesListFlipHimage")
      infoKbd := (thumbsDisplaying=1) ? "`tShift+V" : ""
      kMenu(whichMenu, "Add", "Flip image" pk " &vertically" infoKbd, "filesListFlipVimage")
      infoKbd := (thumbsDisplaying=1) ? "`tShift+0" : ""
      kMenu(whichMenu, "Add", "Rotate image" pk " by &90°" infoKbd, "filesListFlipRotatePlus")
      infoKbd := (thumbsDisplaying=1) ? "`tShift+9" : ""
      kMenu(whichMenu, "Add", "Rotate image" pk " by -90°" infoKbd, "filesListFlipRotateMinus")
      kMenu(whichMenu, "Add", "Crop image" pk " to viewport selection", "filesListCropImgVPsel", "crop cut")
      If (editingSelectionNow!=1 || !validBMP(useGdiBitmap()))
         kMenu(whichMenu, "Disable", "Crop image" pk " to viewport selection")
   }
   Menu, % whichMenu, Add
   kMenu(whichMenu, "Add", "&Remove all metadata", "batchRemoveMetaData", "delete exif comments")
}

createMenuCurrentFilesActs(dummy:=0) {
   If (dummy="rclick" && markedSelectFile>0)
   {
      createMenuSoloFile()
      kMenu("PVfilesActs", "Add", "Active / focused file", ":PVtActFile")
      kMenu("PVfilesActs", "AddSeparator", 0)
   }

   Try Menu, PVcopy, Delete
   createMenuCopyFile("PVcopy")
   If hasFileIndexUndo(currentFileIndex)
      kMenu("PVfilesActs", "Add", "&Undo file action`tCtrl+Z", "ImgUndoAction", "history restore actions records")

   If (fileActsHistoryArray.Count()>0)
      kMenu("PVfilesActs", "Add", "Undo last actions(s) (chronologically)`tCtrl+Shift+Z", "doUndoFileActsChronos", "records actions files rename move copy history restore")

   kMenu("PVfilesActs", "AddSeparator", 0)
   kMenu("PVfilesActs", "Add", "&Copy", ":PVcopy")
   kMenu("PVfilesActs", "AddSeparator", 0)
   If !markedSelectFile
   {
      createMenuOpenFileOptions()
      kMenu("PVfilesActs", "Add", "&Open...", ":PVtFileOpen")
      If (dummy!="rclick")
      {
         kMenu("PVfilesActs", "Add", "Set as &wallpaper", "PanelSetWallpaper", "desktop image")
         kMenu("PVfilesActs", "Add", "&Reload file`tF5", "RefreshImageFileAction", "purge revert")
      }
   } Else
      kMenu("PVtFileOpen", "Add", "Open files in new &QPV instances`tCtrl+Enter", "OpenWithNewQPVinstance")

   Menu, PVfilesActs, Add, 
   kMenu("PVfilesActs", "Add", "Con&vert file format(s) to...`tCtrl+K", "PanelFileFormatConverter", "image conversion")
   kMenu("PVfilesActs", "Add", "Extract frames/pa&ges", "PanelExtractFrames", "animated gifs webp tiffs")
   If (markedSelectFile || dummy!="rclick")
   {
      kMenu("PVfilesActs", "Add", "Join images into...", "PanelCombineImagesMultipage", "pdf create document")
      kMenu("PVfilesActs", "Add", "&Create a thumbnails sheet", "PanelCreateIMGthumbsSheet")
   }

   If (currIMGdetails.Frames<2 && !markedSelectFile)
      kMenu("PVfilesActs", "Disable", "Extract frames/pa&ges")

   If (!markedSelectFile && FileRexists(resultedFilesList[currentFileIndex, 1]) && thumbsDisplaying=1)
   {
      Menu, PVfilesActs, Add
      kMenu("PVfilesActs", "Add", "&Import into currently loaded image", "importEditGivenImageFile")
      kMenu("PVfilesActs", "Add", "&Import as alpha mask bitmap", "importAlphaMaskGivenImageFile")
      Menu, PVfilesActs, Add
   }

   createMenuImageFileActions("PVtFileImgAct")
   kMenu("PVfilesActs", "Add", "Modify image(s)", ":PVtFileImgAct")
   Menu, PVfilesActs, Add
   If markedSelectFile
      kMenu("PVfilesActs", "Add", "Remove file inde&x entries", "InListMultiEntriesRemover", "erase")

   keyu := (thumbsDisplaying!=1 && editingSelectionNow=1) ? "" : "`tDelete"
   kMenu("PVfilesActs", "Add", "&Delete file(s)" keyu, "DeletePicture", "erase")
   kMenu("PVfilesActs", "Add", "&Rename file(s)`tF2", "PanelRenameThisFile")
   If (markedSelectFile>1)
      kMenu("PVfilesActs", "Add", "Structured file operations", "PanelStructuredCopyMoveWindow", "hierarchy backup copy move folders directories dirs")

   keyu := (thumbsDisplaying!=1 && editingSelectionNow=1) ? "" : "`tM"
   kMenu("PVfilesActs", "Add", "&Move file(s) to..." keyu, "PanelMoveCopyFiles")
   kMenu("PVfilesActs", "Add", "&Copy file(s) to...`tC", "InvokeCopyFiles")
   Menu, PVfilesActs, Add
   If markedSelectFile
   {
      kMenu("PVfilesActs", "Add", "Re&group dispersed files", "regroupSelectedFiles")
      keyu := (thumbsDisplaying=1) ? "`tShift+L" : ""
      kMenu("PVfilesActs", "Add", "&Calculate total files size" keyu, "CalculateSelectedFilesSizes", "file details")
      keyu := (thumbsDisplaying=1) ? "`tR" : ""
      kMenu("PVfilesActs", "Add", "Revie&w selected files" keyu, "PanelReviewSelectedFiles")
   } Else kMenu("PVfilesActs", "Add", "&File information`tAlt+Enter", "PanelImageInfos", "properties image details")

   If !markedSelectFile
   {
      friendly := resultedFilesList[currentFileIndex, 2] ? "De&select" : "&Select"
      kMenu("PVfilesActs", "Add", friendly " file`tTab", "markThisFileNow")
      If (dummy="rclick")
      {
         friendly := resultedFilesList[currentFileIndex, 5] ? "Remove from" : "Add to"
         kMenu("PVfilesActs", "Add", friendly " f&avourites list`tB", "ToggleImgFavourites")
         kMenu("PVfilesActs", "Add", "Remove inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
         kMenu("PVfilesActs", "Add", "Delete file and inde&x entry`tShift+Delete", "DeleteActiveImgFileAndEntry")
         kMenu("PVfilesActs", "Add", "&Modify index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
      }
   }

   If (mustRecordSeenImgs=1 && thumbsDisplaying=1)
      kMenu("PVfilesActs", "Add", "&Toggle Image(s) Seen status`tShift+S", "ToggleSeenIMGstatus")
}

createMenuFilesSort() {
   kMenu("PVsort", "Add", "File details", "dummy")
   kMenu("PVsort", "Disable", "File details")
   kMenu("PVsort", "Add", "&Path and name`tCtrl+1", "ActSortName",, "Sort by " sillySeparator)
   kMenu("PVsort", "Add", "&Folder path`tCtrl+2", "ActSortPath",, "Sort by " sillySeparator)
   kMenu("PVsort", "Add", "&File name`tCtrl+3", "ActSortFileName",, "Sort by " sillySeparator)
   kMenu("PVsort", "Add", "File si&ze`tCtrl+4", "ActSortSize",, "Sort by " sillySeparator)
   kMenu("PVsort", "Add", "&Modified date`tCtrl+5", "ActSortModified",, "Sort by " sillySeparator)
   kMenu("PVsort", "Add", "&Created date`tCtrl+6", "ActSortCreated",, "Sort by " sillySeparator)
   If testIsDupesList()
   {
      Menu, PVsort, Add
      kMenu("PVsort", "Add", "&Duplicates ID group", "ActSortDupeGroups",, "Sort by " sillySeparator)
   }

   Menu, PVsort, Add
   kMenu("PVsort", "Add/Uncheck", "&Reversed order on sort", "TglRvrSort")
   If (reverseOrderOnSort=1)
      kMenu("PVsort", "Check", "&Reversed order on sort")

   kMenu("PVsort", "Add/Uncheck", "&Remove inexistent files on sort", "TglCheckDeadFilesSort")
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      kMenu("PVsort", "Disable", "&Remove inexistent files on sort")
   Else If (OnSortdoFilesCheck=1)
      kMenu("PVsort", "Check", "&Remove inexistent files on sort")

   If (SLDtypeLoaded=3)
   {
      kMenu("PVsort", "Add", "&Purge cached data", "PanelPurgeCachedSQLdata")
      kMenu("PVsort", "Add/Uncheck", "&Use cached data", "TglUseCacheSLDinfo")
      If (useCachedSLDdata=1)
         kMenu("PVsort", "Check", "&Use cached data")

      defaultSort := defineSQLdbSort()
      StringUpper, defaultSort, defaultSort
      Menu, PVsort, Add
      kMenu("PVsort", "Add", "Default sorting:", "ToggleDBdefaultSQLsort")
      kMenu("PVsort", "Add", "[" defaultSort "]", "dummy")
      kMenu("PVsort", "Disable", "[" defaultSort "]")
   }

   Menu, PVsort, Add
   kMenu("PVsort", "Add", "Image information", "dummy")
   kMenu("PVsort", "Disable", "Image information")
   kMenu("PVsort", "Add", "&Resolution`tCtrl+7", "PanelResolutionSorting",, "Sort by " sillySeparator)
   kMenu("PVsort", "Add", "&Histogram data points`tCtrl+8", "PanelHistogramSorting",, "Sort by " sillySeparator)
   If (mustPreventMenus=1)
   {
      kMenu("PVsort", "Add", "Resolution (MPx)", "MenuSortImageResolutionMGPX",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Image width", "MenuSortImageWdithRes",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Image height", "MenuSortImageHeightRes",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Aspect ratio (W/H)", "MenuSortImageAspectRatioRes",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Image DPI", "MenuSortImageDPIres",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Pages / frames", "MenuSortImageFrameRes",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Histogram average", "MenuActSortHisto1",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Histogram median", "MenuActSortHisto2",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Histogram peak range", "MenuActSortHisto3",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Histogram minimum range", "MenuActSortHisto4",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Histogram range", "MenuActSortHisto5",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Histogram mode", "MenuActSortHisto6",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Histogram minimum", "MenuActSortHisto7",, "Sort by " sillySeparator)
      kMenu("PVsort", "Add", "Histogram root-mean square", "MenuActSortHisto8",, "Sort by " sillySeparator)
   }

   Menu, PVsort, Add, 
   kMenu("PVsort", "Add", "R&everse list`tCtrl+0", "ReverseListNow", "files")
   kMenu("PVsort", "Add", "R&andomize list", "RandomizeListNow", "files")
}

MenuSortImageResolutionMGPX() {
   ActSortImageProperties(1)
}

MenuSortImageWdithRes() {
   ActSortImageProperties(2)
}

MenuSortImageHeightRes() {
   ActSortImageProperties(3)
}

MenuSortImageAspectRatioRes() {
   ActSortImageProperties(4)
}

MenuSortImageDPIres() {
   ActSortImageProperties(5)
}

MenuSortImageFrameRes() {
   ActSortImageProperties(6)
}

MenuActSortHisto1() {
   ActSortHistogram(1)
}

MenuActSortHisto2() {
   ActSortHistogram(2)
}

MenuActSortHisto3() {
   ActSortHistogram(3)
}

MenuActSortHisto4() {
   ActSortHistogram(4)
}

MenuActSortHisto5() {
   ActSortHistogram(5)
}

MenuActSortHisto6() {
   ActSortHistogram(6)
}

MenuActSortHisto7() {
   ActSortHistogram(7)
}

MenuActSortHisto8() {
   ActSortHistogram(8)
}

createMenuSlideshows() {
   sliSpeed := Round(slideShowDelay/1000, 2) " sec."
   keyu := (thumbsDisplaying=1 || markedSelectFile>0) ? "" : "`tSpace"
   If !AnyWindowOpen
      kMenu("PVslide", "Add", "&Start slideshow" keyu, "MenuGoPlaySlidesNow", "play")

   kMenu("PVslide", "Add/Uncheck", "Smoot&h transitions", "ToggleSlidesTransitions", "fade", " (slideshows)")
   If (doSlidesTransitions=1)
      kMenu("PVslide", "Check", "Smoot&h transitions",,, " (slideshows)")
   If (minimizeMemUsage=1)
      kMenu("PVslide", "Disable", "Smoot&h transitions",,, " (slideshows)")

   kMenu("PVslide", "Add/Uncheck", "&Easy to stop slideshows", "ToggleEasySlideStop")
   kMenu("PVslide", "Add/Uncheck", "&Randomize colour effects", "ToggleSlidesFXmode", "slideshow", " during slideshows")
   kMenu("PVslide", "Add/Uncheck", "&Wait for GIFs to play once", "ToggleGIFsPlayEntirely", "animations")
   If (animGIFsSupport!=1 || alwaysOpenwithFIM=1)
      kMenu("PVslide", "Disable", "&Wait for GIFs to play once")
   If (slidesFXrandomize=1)
      kMenu("PVslide", "Check", "&Randomize colour effects",,, " during slideshows")

   kMenu("PVslide", "Add/Uncheck", "S&kip already seen images", "ToggleSkipSeenIMGs")
   If (mustRecordSeenImgs!=1)
      kMenu("PVslide", "Disable", "S&kip already seen images")
   Else If (skipSeenImageSlides=1)
      kMenu("PVslide", "Check", "S&kip already seen images")
   Menu, PVslide, Add
   keyu := (thumbsDisplaying=1 || AnyWindowOpen) ? "" : "`tShift+/"
   kMenu("PVslide", "Add", "De&fine slideshow duration" keyu, "PanelDefineEntireSlideshowLength")
   kMenu("PVslide", "Add", EstimateSlideShowLength(1), "dummy")
   kMenu("PVslide", "Disable", EstimateSlideShowLength(1))
   Menu, PVslide, Add
   Try Menu, PVhowSlide, Delete
   
   keyu := (thumbsDisplaying=1 || AnyWindowOpen) ? "" : "`tS"
   kMenu("PVhowSlide", "Add", "C&ycle slideshow directions" keyu, "ToggleSlideshowModes",,,1)
   Menu, PVhowSlide, Add
   kMenu("PVhowSlide", "Add/UnCheck", "&Forward", "MenuSlideshowModeNext",, " (slideshow modes)")
   kMenu("PVhowSlide", "Add/UnCheck", "&Backward", "MenuSlideshowModePrev",, " (slideshow modes)")
   kMenu("PVhowSlide", "Add/UnCheck", "&Random", "MenuSlideshowModeRando",, " (slideshow modes)")
   Menu, PVhowSlide, Add
   kMenu("PVhowSlide", "Add/UnCheck", "Random [&1st half bias]", "MenuSlideshowModeRandyFirst",, " (slideshow modes)")
   kMenu("PVhowSlide", "Add/UnCheck", "Random [&2nd half bias]", "MenuSlideshowModeRandySecond",, " (slideshow modes)")
   If (SlideHowMode=2)
      kMenu("PVhowSlide", "Check", "&Backward",,, " (slideshow modes)")
   Else If (SlideHowMode=3)
      kMenu("PVhowSlide", "Check", "&Forward",,, " (slideshow modes)")
   Else If (SlideHowMode=1 && slidesRandoMode=2)
      kMenu("PVhowSlide", "Check", "Random [&1st half bias]",,, " (slideshow modes)")
   Else If (SlideHowMode=1 && slidesRandoMode=3)
      kMenu("PVhowSlide", "Check", "Random [&2nd half bias]",,, " (slideshow modes)")
   Else If (SlideHowMode=1)
      kMenu("PVhowSlide", "Check", "&Random",,, " (slideshow modes)")

   kMenu("PVslide", "Add", "Slideshow direc&tions", ":PVhowSlide")
   ; kMenu("PVslide", "Add", DefineSlideShowType(), "dummy")
   ; kMenu("PVslide", "Disable", DefineSlideShowType())
   Menu, PVslide, Add
   thisMusic := StrLen(SlidesMusicSong)>3 ? PathCompact(SlidesMusicSong, 30) : "NONE"
   kMenu("PVslide", "Add/Uncheck", "Auto&matically play music", "ToggleAutoPlaySlidesMusic",, " (slideshows)")
   kMenu("PVslide", "Add", "Set back&ground music", "PanelSetSlidesMusic",, " (slideshows)")
   kMenu("PVslide", "Add", thisMusic, "dummy")
   kMenu("PVslide", "Disable", thisMusic)
   If (autoPlaySlidesAudio=1)
      kMenu("PVslide", "Check", "Auto&matically play music",,, " (slideshows)")
   Menu, PVslide, Add
   keyuA := (thumbsDisplaying=1 || AnyWindowOpen) ? "" : "`t."
   keyuB := (thumbsDisplaying=1 || AnyWindowOpen) ? "" : "`t,"
   kMenu("PVslide", "Add", "&Increase speed" keyuA, "IncreaseSlideSpeed",, " (slideshows)", 1)
   kMenu("PVslide", "Add", "&Decrease speed" keyuB, "DecreaseSlideSpeed",, " (slideshows)", 1)
   kMenu("PVslide", "Add", "Current speed: " sliSpeed, "dummy")
   kMenu("PVslide", "Disable", "Current speed: " sliSpeed)
   If (allowGIFsPlayEntirely=1)
      kMenu("PVslide", "Check", "&Wait for GIFs to play once")
   If (easySlideStoppage=1)
      kMenu("PVslide", "Check", "&Easy to stop slideshows")
}

createMenuAnnotations() {
   kMenu("PVsounds", "Add", "&Edit image captions`tShift+N", "PanelEditImgCaption", "modify")
   keywords := (showImgAnnotations=1) ? "hide viewport" : "display viewport"
   kMenu("PVsounds", "Add/Uncheck", "&Show image captions`tN", "ToggleImgCaptions", keywords)
   If (showImgAnnotations=1)
      kMenu("PVsounds", "Check", "&Show image captions`tN")
   Menu, PVsounds, Add, 
   If (SLDtypeLoaded=3)
      kMenu("PVsounds", "Add", "&Choose audio file", "PanelBrowseAudioAnnotation")
   kMenu("PVsounds", "Add", "&Play associated sound file`tX", "PlayAudioFileAssociatedNow")
   kMenu("PVsounds", "Add", "&Stop playing audio`tShift+X", "StopMediaPlaying")
   If !hSNDmedia
      kMenu("PVsounds", "Disable", "&Stop playing audio`tShift+X")
   Menu, PVsounds, Add, 
   kMenu("PVsounds", "Add/Uncheck", "&Auto-play sound files", "ToggleAutoPlaySND")
   If (autoPlaySNDs=1)
      kMenu("PVsounds", "Check", "&Auto-play sound files")
   kMenu("PVsounds", "Add/Uncheck", "Slidesho&w speed based on audio length", "ToggleSyncSlide2sndDuration")
   If (syncSlideShow2Audios=1)
      kMenu("PVsounds", "Check", "Slidesho&w speed based on audio length")
   If (autoPlaySNDs!=1)
      kMenu("PVsounds", "Disable", "Slidesho&w speed based on audio length")
   Menu, PVsounds, Add, 
   kMenu("PVsounds", "Add", "&Increase audio volume`tShift+.", "MenuSetVolumeUp",,,1)
   kMenu("PVsounds", "Add", "&Decrease audio volume`tShift+,", "MenuSetVolumeDown",,,1)
   kMenu("PVsounds", "Add", "Audio volume: " mediaSNDvolume "%", "dummy")
   kMenu("PVsounds", "Disable", "Audio volume: " mediaSNDvolume "%")
}

createMenuVPhudHisto() {
   kMenu("PVimgHistos", "Add", "C&ycle histogram modes`tG", "ToggleImgHistogram",,,1)
   Menu, PVimgHistos, Add 
   kMenu("PVimgHistos", "Add/Uncheck", "&None", "MenuSetVPhistoNone", "histogram", "Histogram panel: " sillySeparator)
   kMenu("PVimgHistos", "Add/Uncheck", "&Luminance", "MenuSetVPhistoLuminance", "histogram", "Histogram channel: " sillySeparator)
   kMenu("PVimgHistos", "Add/Uncheck", "&Red", "MenuSetVPhistoRed", "histogram", "Histogram channel: " sillySeparator)
   kMenu("PVimgHistos", "Add/Uncheck", "&Green", "MenuSetVPhistoGreen", "histogram", "Histogram channel: " sillySeparator)
   kMenu("PVimgHistos", "Add/Uncheck", "&Blue", "MenuSetVPhistoBlue", "histogram", "Histogram channel: " sillySeparator)
   kMenu("PVimgHistos", "Add/Uncheck", "&All mixed", "MenuSetVPhistoAll", "histogram", "Histogram channel: " sillySeparator)
   If (mustPreventMenus!=1 && showHistogram>1)
   {
      Menu, PVimgHistos, Add
      kMenu("PVimgHistos", "Add", "Graph emphasis", "dummy")
      kMenu("PVimgHistos", "Disable", "Graph emphasis")
      kMenu("PVimgHistos", "Add/Uncheck", "&Lows", "MenuSetVPgraphHistoLows", "graph histogram", "Histogram graph focus: " sillySeparator)
      kMenu("PVimgHistos", "Add/Uncheck", "&Balanced", "MenuSetVPgraphHistoMids", "graph histogram", "Histogram graph focus: " sillySeparator)
      kMenu("PVimgHistos", "Add/Uncheck", "&Peaks", "MenuSetVPgraphHistoPeaks", "graph histogram", "Histogram graph focus: " sillySeparator)
      If (histogramMode=1)
         kMenu("PVimgHistos", "Check", "&Lows",,, "Histogram graph focus: " sillySeparator)
      Else If (histogramMode=2)
         kMenu("PVimgHistos", "Check", "&Balanced",,, "Histogram graph focus: " sillySeparator)
      Else If (histogramMode=3)
         kMenu("PVimgHistos", "Check", "&Peaks",,, "Histogram graph focus: " sillySeparator)
   }

   Menu, PVimgHistos, Add
   kMenu("PVimgHistos", "Add", "Cycle graph emphasis modes`tAlt+G", "ToggleHistogramMode",, " (histogram)", 1)
   If (showHistogram=1)
      kMenu("PVimgHistos", "Disable", "Cycle graph emphasis modes`tAlt+G",,, " (histogram)")

   If (showHistogram=1)
      kMenu("PVimgHistos", "Check", "&None",,, "Histogram panel: " sillySeparator)
   Else If (showHistogram=2)
      kMenu("PVimgHistos", "Check", "&Luminance",,, "Histogram channel: " sillySeparator)
   Else If (showHistogram=3)
      kMenu("PVimgHistos", "Check", "&Red",,, "Histogram channel: " sillySeparator)
   Else If (showHistogram=4)
      kMenu("PVimgHistos", "Check", "&Green",,, "Histogram channel: " sillySeparator)
   Else If (showHistogram=5)
      kMenu("PVimgHistos", "Check", "&Blue",,, "Histogram channel: " sillySeparator)
   Else If (showHistogram=6)
      kMenu("PVimgHistos", "Check", "&All mixed",,, "Histogram channel: " sillySeparator)
}

createMenuColorDepth() {
   infoColorDepth := (usrColorDepth>1) ? "Original / reset" : defineColorDepth()
   keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1 || AnyWindowOpen=64) ? "" : "`tQ"
   kMenu("PVimgSdepth", "Add", "C&ycle simulate color depths" keyu, "ToggleImgColorDepth",,,1)
   Menu, PVimgSdepth, Add
   kMenu("PVimgSdepth", "Add/Uncheck", infoColorDepth, "MenuResetImageColorDepth")
   kMenu("PVimgSdepth", "Add/Uncheck", "2 bits (4 colors)", "MenuSetImageDepth2bits",, "Color depth: " sillySeparator)
   kMenu("PVimgSdepth", "Add/Uncheck", "3 bits (8 colors)", "MenuSetImageDepth3bits",, "Color depth: " sillySeparator)
   kMenu("PVimgSdepth", "Add/Uncheck", "4 bits (16 colors)", "MenuSetImageDepth4bits",, "Color depth: " sillySeparator)
   kMenu("PVimgSdepth", "Add/Uncheck", "5 bits (32 colors)", "MenuSetImageDepth5bits",, "Color depth: " sillySeparator)
   kMenu("PVimgSdepth", "Add/Uncheck", "6 bits (64 colors)", "MenuSetImageDepth6bits",, "Color depth: " sillySeparator)
   kMenu("PVimgSdepth", "Add/Uncheck", "7 bits (128 colors)", "MenuSetImageDepth7bits",, "Color depth: " sillySeparator)
   kMenu("PVimgSdepth", "Add/Uncheck", "8 bits (256 colors)", "MenuSetImageDepth8bits",, "Color depth: " sillySeparator)
   kMenu("PVimgSdepth", "Add/Uncheck", "16 bits (65536 colors)", "MenuSetImageDepth16bits",, "Color depth: " sillySeparator)
   If (usrColorDepth<2)
   {
      kMenu("PVimgSdepth", "Check", infoColorDepth)
      kMenu("PVimgSdepth", "Disable", infoColorDepth)
   } Else If (usrColorDepth=2)
      kMenu("PVimgSdepth", "Check", "2 bits (4 colors)",,, "Color depth: " sillySeparator)
   Else If (usrColorDepth=3)
      kMenu("PVimgSdepth", "Check", "3 bits (8 colors)",,, "Color depth: " sillySeparator)
   Else If (usrColorDepth=4)
      kMenu("PVimgSdepth", "Check", "4 bits (16 colors)",,, "Color depth: " sillySeparator)
   Else If (usrColorDepth=5)
      kMenu("PVimgSdepth", "Check", "5 bits (32 colors)",,, "Color depth: " sillySeparator)
   Else If (usrColorDepth=6)
      kMenu("PVimgSdepth", "Check", "6 bits (64 colors)",,, "Color depth: " sillySeparator)
   Else If (usrColorDepth=7)
      kMenu("PVimgSdepth", "Check", "7 bits (128 colors)",,, "Color depth: " sillySeparator)
   Else If (usrColorDepth=8)
      kMenu("PVimgSdepth", "Check", "8 bits (256 colors)",,, "Color depth: " sillySeparator)
   Else If (usrColorDepth=9)
      kMenu("PVimgSdepth", "Check", "16 bits (65536 colors)",,, "Color depth: " sillySeparator)

   Menu, PVimgSdepth, Add
   kMenu("PVimgSdepth", "Add/Uncheck", "&Perform dithering", "ToggleImgColorDepthDithering", "settings performance quality", " on color depth changes")
   If (ColorDepthDithering=1)
      kMenu("PVimgSdepth", "Check", "&Perform dithering",,, " on color depth changes")
}

createMenuImgColorsFX() {
   infolumosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(lumosAdjust, 2) : Round(lumosGrayAdjust, 2)
   infoGammosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(GammosAdjust, 2) : Round(GammosGrayAdjust, 2)
   infoSatAdjust := (imgFxMode=4) ? zatAdjust : Round(satAdjust*100)
   kMenu("PVimgColorsFX", "Add", "C&ycle colors display modes`tF", "ToggleImgFX",,,1)
   kMenu("PVimgColorsFX", "Add", DefineFXmodes(), "dummy")
   kMenu("PVimgColorsFX", "Disable", DefineFXmodes())
   If (imgFxMode=2 || imgFxMode=3 || imgFxMode=4)
   {
      kMenu("PVimgColorsFX", "Add", "Br: " infolumosAdjust " / Ctr: "infoGammosAdjust " / dS: " infoSatAdjust, "dummy")
      kMenu("PVimgColorsFX", "Disable", "Br: " infolumosAdjust " / Ctr: "infoGammosAdjust " / dS: " infoSatAdjust)
   }

   Menu, PVimgColorsFX, Add
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Original colors", "MenuSetColorModeOriginal",, "Viewport colors: " sillySeparator)
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Personalized colors", "MenuSetColorModePersonalized",, "Viewport colors: " sillySeparator)
   kMenu("PVimgColorsFX", "Add/Uncheck", "Grays&cale", "MenuSetColorModeGrayscale",, "Viewport colors: " sillySeparator)
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Red channel", "MenuSetColorModeRedC",, "Viewport colors: " sillySeparator)
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Green channel", "MenuSetColorModeGreenC",, "Viewport colors: " sillySeparator)
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Blue channel", "MenuSetColorModeBlueC",, "Viewport colors: " sillySeparator)
   kMenu("PVimgColorsFX", "Add/Uncheck", "Alp&ha channel", "MenuSetColorModeAlphaC",, "Viewport colors: " sillySeparator)
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Inverted colors", "MenuSetColorModeInverted",, "Viewport colors: " sillySeparator)
   kMenu("PVimgColorsFX", "Add/Uncheck", "&Sepia", "MenuSetColorModeSepia",, "Viewport colors: " sillySeparator)
   If (thumbsDisplaying=1)
      kMenu("PVimgColorsFX", "Disable", "Alp&ha channel",,,"Viewport colors: " sillySeparator)

   If (imgFxMode=1)
      kMenu("PVimgColorsFX", "Check", "&Original colors",,,"Viewport colors: " sillySeparator)
   Else If (imgFxMode=2)
      kMenu("PVimgColorsFX", "Check", "&Personalized colors",,,"Viewport colors: " sillySeparator)
   Else If (imgFxMode=4)
      kMenu("PVimgColorsFX", "Check", "Grays&cale",,,"Viewport colors: " sillySeparator)
   Else If (imgFxMode=5)
      kMenu("PVimgColorsFX", "Check", "&Red channel",,,"Viewport colors: " sillySeparator)
   If (imgFxMode=6)
      kMenu("PVimgColorsFX", "Check", "&Green channel",,,"Viewport colors: " sillySeparator)
   Else If (imgFxMode=7)
      kMenu("PVimgColorsFX", "Check", "&Blue channel",,,"Viewport colors: " sillySeparator)
   Else If (imgFxMode=8)
      kMenu("PVimgColorsFX", "Check", "Alp&ha channel",,,"Viewport colors: " sillySeparator)
   Else If (imgFxMode=9)
      kMenu("PVimgColorsFX", "Check", "&Inverted colors",,,"Viewport colors: " sillySeparator)
   Else If (imgFxMode=10)
      kMenu("PVimgColorsFX", "Check", "&Sepia",,,"Viewport colors: " sillySeparator)

   If (thumbsDisplaying!=1 && imgFxMode>1)
   {
      Menu, PVimgColorsFX, Add
      kMenu("PVimgColorsFX", "Add", "Toggle colors for 2 seconds`tShift+\", "MenuToggleColorAdjustments",, " (viewport)")
   }
}

MenuDoOpenStartFolder() {
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()

   dummyTimerDelayiedImageDisplay(50)
   RemoveTooltip()
}

MenuStartDrawingSelectionArea() {
   startDrawingShape("selection")
}

MenuStartDrawingShapes() {
   modus := (isVarEqualTo(AnyWindowOpen, 23, 68) && FillAreaShape=7) ? "resume" : 0
   startDrawingShape("shape", modus, "draw", AnyWindowOpen)
}

MenuResumeDrawingShapes() {
   If (AnyWindowOpen=65 && FillAreaShape=7)
      MenuStartDrawingLines()
   Else If ((AnyWindowOpen=23 || AnyWindowOpen=68) && FillAreaShape=7)
      MenuStartDrawingShapes()
   Else
      startDrawingShape("selection", "resume")
}

MenuRealStartDrawingLines() {
   BtnCloseWindow()
   startDrawingShape("line", 0, "draw", 65, 1)
}

MenuRealStartDrawingShapes() {
   BtnCloseWindow()
   startDrawingShape("shape", 0, "draw", 23, 1)
}

MenuStartDrawingLines() {
   modus := (AnyWindowOpen=65 && FillAreaShape=7) ? "resume" : 0
   startDrawingShape("line", modus, "draw", AnyWindowOpen)
}

createMenuLiveTools(dummy:=0) {
   If (dummy!="mbr")
   {
      kMenu("PVlTools", "Add", "Live tools", "dummy")
      kMenu("PVlTools", "Disable", "Live tools")
   }

   kMenu("PVlTools", "Add", "Define f&reeform filled shape`tShift+P", "MenuRealStartDrawingShapes", "curve polygonal")
   kMenu("PVlTools", "Add", "Define freeform &outline`tAlt+P", "MenuRealStartDrawingLines", "curve polygonal lines")
   Menu, PVlTools, Add
   kMenu("PVlTools", "Add", "&Paint brushes`tP", "PanelBrushTool", "pinch bulge effects draw deformer smudge cloner effects eraser")
   kMenu("PVlTools", "Add", "&Erase or fade area`tDelete", "PanelEraseSelectedArea")
   kMenu("PVlTools", "Add", "F&lood fill / color bucket`tK", "PanelFloodFillTool", "colorize similarity")
   kMenu("PVlTools", "Add", "&Fill shapes`tAlt+Backspace", "tlbrFillShape", "curve polygonal glass effects blur pie ellipse triangle rhombus gradients rectangle")
   kMenu("PVlTools", "Add", "Fill be&hind image", "PanelFillBehindBgrImage", "background")
   kMenu("PVlTools", "Add", "Draw s&hape contours`tCtrl+L", "tlbrDrawShapesContour", "lines curve polygonal pie ellipse triangle rhombus rectangle arcs")
   kMenu("PVlTools", "Add", "&Draw parametric lines", "PanelDrawLines", "lines arcs diagonals spiral rays spokes grids")
   kMenu("PVlTools", "Add", "Define alpha mas&k", "PanelSoloAlphaMasker")
   kMenu("PVlTools", "Add", "&Insert te&xt`tShift+T", "PanelInsertTextArea")
   kMenu("PVlTools", "Add", "Create image s&ymmetry or patterns", "PanelSymmetricaImage")
   kMenu("PVlTools", "Add", "&Adjust image colors`tU", "PanelAdjustColorsSimpleWindow")
   kMenu("PVlTools", "Add", "Adjust vie&wport colors and effects`tShift+U", "PanelColorsAdjusterWindow")
   kMenu("PVlTools", "Add", "Desaturate color&s`tCtrl+G", "PanelDesatureSelectedArea")
   If (AnyWindowOpen=10)
      kMenu("PVlTools", "Check/Disable", "Adjust vie&wport colors and effects`tShift+U")
   Else If (AnyWindowOpen=23)
      kMenu("PVlTools", "Check/Disable", "&Fill shapes`tAlt+Backspace")
   Else If (AnyWindowOpen=25)
      kMenu("PVlTools", "Check/Disable", "&Erase or fade area`tDelete")
   Else If (AnyWindowOpen=30)
      kMenu("PVlTools", "Check/Disable", "&Draw parametric lines")
   Else If (AnyWindowOpen=32)
      kMenu("PVlTools", "Check/Disable", "&Insert te&xt`tShift+T")
   Else If (AnyWindowOpen=55)
      kMenu("PVlTools", "Check/Disable", "Desaturate color&s`tCtrl+G")
   Else If (AnyWindowOpen=64)
      kMenu("PVlTools", "Check/Disable", "&Paint brushes`tP")
   Else If (AnyWindowOpen=65)
      kMenu("PVlTools", "Check/Disable", "Draw s&hape contours`tCtrl+L")
   Else If (AnyWindowOpen=66)
      kMenu("PVlTools", "Check/Disable", "F&lood fill / color bucket`tK")
   Else If (AnyWindowOpen=68)
      kMenu("PVlTools", "Check/Disable", "Fill be&hind image")
   Else If (AnyWindowOpen=70)
      kMenu("PVlTools", "Check/Disable", "Define alpha mas&k")
   Else If (AnyWindowOpen=74)
      kMenu("PVlTools", "Check/Disable", "&Adjust image colors`tU")
   Else If (AnyWindowOpen=81)
      kMenu("PVlTools", "Check/Disable", "Create image s&ymmetry or patterns")

   If (editingSelectionNow=1 && dummy!="mbr")
   {
      Menu, PVlTools, Add
      kMenu("PVlTools", "Add", "Other operations", "dummy")
      kMenu("PVlTools", "Disable", "Other operations")
      keyu := (AnyWindowOpen) ? "" : "`tShift+H"
      kMenu("PVlTools", "Add", "Flip selected &horizontally" keyu, "FlipSelectedAreaH")
      keyu := (AnyWindowOpen) ? "" : "`tShift+V"
      kMenu("PVlTools", "Add", "Flip selected &vertically" keyu, "FlipSelectedAreaV")
      kMenu("PVlTools", "Add", "&Invert colors`tShift+I", "InvertSelectedArea")
   }
}

toggleAlphaGradientCenterReposition() {
   userAllowClrGradientRecenter := 0
   userAllowsGradientRecentering := !userAllowsGradientRecentering
   friendly := (userAllowsGradientRecentering=1) ? "ACTIVATED" : "DEACTIVATED"
   friendly2 := (userAllowsGradientRecentering=1) ? "`nClick and drag inside the selection area to adjust the center" : ""
   showTOOLtip("Alpha mask gradient center repositioning: " friendly friendly2, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleSpiralRaysCenterReposition() {
   userAllowClrGradientRecenter := 0
   userAllowsGradientRecentering := !userAllowsGradientRecentering
   friendly := (userAllowsGradientRecentering=1) ? "ACTIVATED" : "DEACTIVATED"
   f := (DrawLineAreaBorderCenter=4) ? "Rays" : "Spiral"
   If (DrawLineAreaBorderCenter=5)
      f := "Grid"

   friendly2 := (userAllowsGradientRecentering=1) ? "`nClick and drag inside the selection area to adjust the center" : ""
   showTOOLtip(f " center repositioning: " friendly friendly2, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleClrGradientCenterRepose() {
   userAllowsGradientRecentering := 0
   userAllowClrGradientRecenter := !userAllowClrGradientRecenter
   friendly := (userAllowClrGradientRecenter=1) ? "ACTIVATED" : "DEACTIVATED"
   friendly2 := (userAllowClrGradientRecenter=1) ? "`nClick and drag inside the selection area to adjust the center" : ""
   showTOOLtip("Color gradient center repositioning: " friendly friendly2, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

isVarEqualTo(value, vals*) {
   yay := 0
   for index, param in vals
   {
       If (value=param)
       {
          yay := 1
          Break
       }
   }
   Return yay
}

varContains(value, vals*) {
   yay := 0
   for index, param in vals
   {
       If InStr(value, param)
       {
          yay := 1
          Break
       }
   }
   Return yay
}

createMenuLiveEditSelectionArea(isToolGood, isWinCustomShapeFriendly) {
   If (AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      Gui, SettingsGUIA: Default
      GuiControlGet, hwnd, hwnd, PasteInPlaceCropSel
      ControlGetText, labelu,, ahk_id %hwnd%
      kMenu("PVselv", "Add", "Cycle image crop shapes`tShift+C", "togglePasteInPlaceCropShapes",,, 1)
      If labelu
      {
         kMenu("PVselv", "Add", labelu, "dummy")
         kMenu("PVselv", "Disable", labelu)
      }

      kMenu("PVselv", "Add/UnCheck", "Crop the image object", "togglePasteInPlaceCropNone")
      If (PasteInPlaceCropDo=1)
         kMenu("PVselv", "Check", "Crop the image object")
      Menu, PVselv, Add
   }

   kMenu("PVselv", "Add", "&Reset selection area", "newImgSelection")
   If testUndoImgSelections()
   {
      Menu, PVselv, Add
      kMenu("PVselv", "Add", "&Undo selection`tCtrl+Shift+Z", "ImgSelUndoAct")
      kMenu("PVselv", "Add", "&Redo selection`tCtrl+Shift+Y", "ImgSelRedoAct")
   }

   If (isToolGood=1 && isWinCustomShapeFriendly=1 && editingSelectionNow=1)
      kMenu("PVselv", "Add", "&Load custom shapes", "PanelManageVectorShapes", "freeform presets premade forms triangle moon cloud crescent heart water droplet rhombus star christian cross callout")

   Menu, PVselv, Add
   kMenu("PVselv", "Add", "&Select all`tCtrl+A", "selectEntireImage",, " (image canvas)")
   If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
      kMenu("PVselv", "Add", "R&eset exclude area`tShift+\", "resetSelectionAreaCavity")

   If isSelEntireOutside()
      kMenu("PVselv", "Add", "Focus selection area", "focusImgSelArea", "find viewport", " (selection area)")

   kMenu("PVselv", "Add", "&Flip selection area W/H`tW", "flipSelectionWH")
   kMenu("PVselv", "Add/Uncheck", "&Limit selection to image area`tL", "toggleLimitSelection")
   If (LimitSelectBoundsImg=1)
      kMenu("PVselv", "Check", "&Limit selection to image area`tL")

   kMenu("PVselv", "Add/Uncheck", "Sho&w grid", "ToggleSelectGrid",, " (selection area)")
   If (showSelectionGrid=1)
      kMenu("PVselv", "Check", "Sho&w grid",,, " (selection area)")

   addMenuBonusesSelectionArea()
   If (isToolGood=1)
   {
      infoSelShape := DefineVPselAreaMode()
      kMenu("PVselv", "Add", "C&ycle selection types`tShift+E", "MenuCycleSelectionShapes")
      kMenu("PVselv", "Add", infoSelShape, "dummy")
      kMenu("PVselv", "Disable", infoSelShape)
   }
}

addMenuBonusesBrushTools() {
   If (mustPreventMenus=1 && liveDrawingBrushTool=1)
   {
      kMenu("PVmenu", "Add", "Increase brush size`t]", "MenuIncBrushSize",,, 1)
      kMenu("PVmenu", "Add", "Decrease brush size`t[", "MenuDecBrushSize",,, 1)
      kMenu("PVmenu", "Add", "Increase brush softness`tShift+]", "MenuIncBrushSoftness",,, 1)
      kMenu("PVmenu", "Add", "Decrease brush softness`tShift+[", "MenuDecBrushSoftness",,, 1)
      kMenu("PVmenu", "Add", "Increase brush angle`tCtrl+]", "MenuIncBrushAngle",,, 1)
      kMenu("PVmenu", "Add", "Decrease brush angle`tCtrl+[", "MenuDecBrushAngle",,, 1)
      kMenu("PVmenu", "Add", "Increase brush aspect ratio`tAlt+]", "MenuIncBrushAspectRatio",,, 1)
      kMenu("PVmenu", "Add", "Decrease brush aspect ratio`tAlt+[", "MenuDecBrushAspectRatio",,, 1)
      kMenu("PVmenu", "Add", "Increase brush wetness`tShift+.", "MenuIncBrushWetness",,, 1)
      kMenu("PVmenu", "Add", "Decrease brush wetness`tShift+,", "MenuDecBrushWetness",,, 1)
      kMenu("PVmenu", "Add", "Increase brush opacity`t.", "MenuIncBrushOpacity",,, 1)
      kMenu("PVmenu", "Add", "Decrease brush opacity`t,", "MenuDecBrushOpacity",,, 1)
      kMenu("PVmenu", "Add", "Toggle simple/soft brush types`tB", "toggleBrushTypes")
      kMenu("PVmenu", "Add", "Toggle brush double size`tShift+S", "toggleBrushDoubleSize")
      kMenu("PVmenu", "Add", "Toggle airbrush mode`tT", "toggleBrushAirMode")
      kMenu("PVmenu", "Add", "Reset colors to black and white`tD", "ResetColorsToBW")
      kMenu("PVmenu", "Add", "Reset brush aspect ratio and rotation", "MenuResetBrushAsRatio")
      If (AnyWindowOpen=64)
      {
         kMenu("PVmenu", "Add", "Color Effects brush`tQ", "toggleBrushTypeFX")
         kMenu("PVmenu", "Add", "Eraser brush`tR", "toggleBrushTypeEraser")
         kMenu("PVmenu", "Add", "Cloner brush`tJ", "toggleBrushTypeCloner")
         kMenu("PVmenu", "Add", "Deformer brushes`tP", "toggleBrushDeformers")
      }
   }
}

BuildImgLiveEditMenu() {
   If (editingSelectionNow!=1 && !AnyWindowOpen) || (thumbsDisplaying=1)
      Return

   deleteMenus()
   isWinCustomShapeFriendly := isVarEqualTo(AnyWindowOpen, 81, 74, 68, 66, 65, 64, 55, 25, 23, 10)
   kMenu("PVmenu", "Add/Uncheck", "&Collapse tool panel`tF11", "toggleImgEditPanelWindow")
   If (panelWinCollapsed=1)
      kMenu("PVmenu", "Check", "&Collapse tool panel`tF11")

   drawing := isNowAlphaPainting()
   If (drawing!=1)
      kMenu("PVmenu", "Add", "&Cancel / close panel`tEscape", "BtnCloseWindow")
   If (!isVarEqualTo(AnyWindowOpen, 10  64, 66) && imgEditPanelOpened=1)
      kMenu("PVmenu", "Add", "Appl&y tool`tEnter", "applyIMGeditFunction")

   Menu, PVmenu, Add
   If ((AnyWindowOpen!=24 && AnyWindowOpen!=31) && (drawing!=1 && (showMainMenuBar!=1 || mustPreventMenus=1)))
   {
      createMenuLiveTools()
      kMenu("PVmenu", "Add", "S&witch live tool", ":PVlTools")
   }

   If (AnyWindowOpen=10)
   {
      Menu, PVmenu, Add
      If (editingSelectionNow=1)
      {
         kMenu("PVmenu", "Add", "Appl&y color effects inside selection`tCtrl+Shift+U", "ApplyVPcolorAdjustSelectedArea")
         kMenu("PVmenu", "Add", "&... outside the selection", "ApplyVPcolorAdjustSelectedArea")
      }

      kMenu("PVmenu", "Add/Uncheck", "&Activate viewport color adjustments`t\", "BtnToggleNoColorsFX")
      If (ForceNoColorMatrix!=1)
         kMenu("PVmenu", "Check", "&Activate viewport color adjustments`t\")
      kMenu("PVmenu", "Add", "&Reset all adjustments to defaults`tCtrl+\", "BtnResetImageView")
   }

   If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
   {
      Menu, PVmenu, Add
      kMenu("PVmenu", "Add", "&Undo`tCtrl+Z", "ImgUndoAction")
      kMenu("PVmenu", "Add", "&Redo`tCtrl+Y", "ImgRedoAction")
      If (undoLevelsRecorded>5 && mustPreventMenus=1)
      {
         kMenu("PVmenu", "Add", "&Undo image (4 steps)`tCtrl+Alt+Z", "MenuUndoImgJumpy")
         kMenu("PVmenu", "Add", "&Redo image (4 steps)`tCtrl+Alt+Y", "MenuRedoImgJumpy")
      }
   } Else If (currentImgModified=1 && viewportQPVimage.imgHandle)
      kMenu("PVmenu", "Add", "&Undo`tCtrl+Z", "ImgUndoAction")

   If (isVarEqualTo(AnyWindowOpen, 10, 12, 64, 66) && imgEditPanelOpened=1)
   {
      kMenu("PVmenu", "Add/Uncheck", "&Show selection`tE", "ToggleEditImgSelection")
      If (editingSelectionNow=1)
         kMenu("PVmenu", "Check", "&Show selection`tE")
      Else
         kMenu("PVmenu", "Add", "&Select all`tCtrl+A", "selectEntireImage",, " (image canvas)")
   }

   decideLiveSelectionBasedOnWindow(angleu, isToolGood)
   If isVarEqualTo(AnyWindowOpen, 81, 65, 23)
      isToolGood := 1

   Menu, PVmenu, Add
   If (mustPreventMenus=1)
      kMenu("PVmenu", "Add", "Swap tool colors: A / B`tX", "ToggleBrushColors")

   If (editingSelectionNow=1)
   {
      additions := 1
      If (AnyWindowOpen=30 && isVarEqualTo(DrawLineAreaBorderCenter, 4, 5, 6))
      {
         ; Draw parametric lines / PanelDrawLines()
         f := (DrawLineAreaBorderCenter=4) ? "rays" : "spiral"
         If (DrawLineAreaBorderCenter=5)
            f := "grid"

         kMenu("PVmenu", "Add/Uncheck", "&Allow " f " center repositioning", "toggleSpiralRaysCenterReposition")
         kMenu("PVmenu", "Add", "&Reset " f " center", "BtnResetSpiralRayCenter")
         If (userAllowsGradientRecentering=1)
            kMenu("PVmenu", "Check", "&Allow " f " center repositioning")
      }

      If (isAlphaMaskWindow()=1)
      {
         If (AnyWindowOpen=23)
         {
            ; fill area panel ; PanelFillSelectedArea()
            If (isInRange(FillAreaColorMode, 2, 4) && liveDrawingBrushTool!=1)
            {
               kMenu("PVmenu", "Add", "&Reset gradient offset", "BtnSetTextureSource")
               kMenu("PVmenu", "Add/Uncheck", "&Allow gradient repositioning", "toggleClrGradientCenterRepose")
               If (userAllowClrGradientRecenter=1)
                  kMenu("PVmenu", "Check", "&Allow gradient repositioning")
            } Else If (FillAreaColorMode=6 && liveDrawingBrushTool!=1)
               kMenu("PVmenu", "Add", "&Set texture fill source`tS", "BtnSetTextureSource")
         }

         ; paste in place / transform tools ; PanelPasteInPlace()
         additions := !liveDrawingBrushTool
         givenMenu := (liveDrawingBrushTool=1) ? "PVmenu" : "PValpha"
         createMenuAlphaMask(givenMenu)
         If !liveDrawingBrushTool
            kMenu("PVmenu", "Add", "Alpha mas&k", ":PValpha")
         Else
            addMenuBonusesBrushTools()
      } Else If isVarEqualTo(AnyWindowOpen, 64, 66)
      {
         additions := FloodFillSelectionAdj
         labelu := (AnyWindowOpen=64) ? "Painting" : "Bucket"
         kMenu("PVmenu", "Add/Uncheck", "&" labelu " mode`tCtrl+K", "toggleAlphaPaintingMode")
         kMenu("PVmenu", "Add", "&Cycle " labelu " modes`tShift+K", "toggleBrushDrawInOutModes")
         If (liveDrawingBrushTool=1 && AnyWindowOpen=64) || (FloodFillSelectionAdj!=1 && AnyWindowOpen=66)
            kMenu("PVmenu", "Check", "&" labelu " mode`tCtrl+K")
      }

      If (additions=1)
      {
         createMenuSelectionAlign()
         createMenuSelectionRotationAspectRatio()
         createMenuLiveEditSelectionArea(isToolGood, isWinCustomShapeFriendly) 
         kMenu("PVmenu", "Add", "Ali&gnment", ":PVselAlign")
         kMenu("PVmenu", "Add", "&Selection area", ":PVselv")
         kMenu("PVmenu", "Add", "&Rotation and aspect ratio", ":PVselRatio")
      }
   }

   If (AnyWindowOpen=64)
   {
      addMenuBonusesBrushTools()
      If (BrushToolType=3)
      {
         kMenu("PVmenu", "Add", "Define cloner &source`tS", "BtnSetClonerBrushSource")
      } Else If (BrushToolType<4)
      {
         kMenu("PVmenu", "Add", "&Cycle symmetry modes`tY", "toggleBrushSymmetryModes")
         kMenu("PVmenu", "Add", "&Define symmetry point`tShift+Y", "BtnSetBrushSymmetryCoords")
      }
   } Else If isVarEqualTo(AnyWindowOpen, 31, 24)
   {
      kMenu("PVmenu", "Add", "Cycle adapt to selection modes`tS", "togglePasteInPlaceAdaptModes")
      kMenu("PVmenu", "Add/Uncheck", "Color adjustments on object`tU", "togglePasteInPlaceColorsFX")
      If (PasteInPlaceApplyColorFX=1)
         kMenu("PVmenu", "Check", "Color adjustments on object`tU")

      If (PasteInPlaceToolMode=1)
      {
         kMenu("PVmenu", "Add/Uncheck", "Erase &initial area`tBackspace", "toggleErasePasteInPlace")
         If (PasteInPlaceEraseInitial=1)
            kMenu("PVmenu", "Check", "Erase &initial area`tBackspace")

         If (PasteInPlaceToolMode=1 && (prevEllipseSelectMode>0 || prevVPselRotation!=0 || previnnerSelectionCavityX!=0 || previnnerSelectionCavityY!=0))
         {
            kMenu("PVmenu", "Add/Uncheck", "Re&veal initial rect", "toggleRevealRectPasteInPlace")
            If (PasteInPlaceRevealOriginal=1)
               kMenu("PVmenu", "Check", "Re&veal initial rect")
         }
 
         kMenu("PVmenu", "Add", "Reset to &initial position", "MenuResetTransformToolPos")
      }

      If (shearImgX!=0 || shearImgY!=0)
         kMenu("PVmenu", "Add", "&Reset image skew offsets", "resetImgSkewOffsets")
   }

   If isAlphaMaskPartialWin()
   {
      kMenu("PValpha", "Add", "Previe&w the alpha mask`tM", "ViewAlphaMaskNow")
      kMenu("PValpha", "Add", "&Define alpha mask`tM", "PanelSoloAlphaMasker")
      kMenu("PValpha", "Add/Uncheck", "&Invert alpha mask`tN", "toggleInvertAlphaMask")
      If (editingSelectionNow=1)
         kMenu("PValpha", "Add", "&Capture selected area as alpha mask", "SetImageAsAlphaMask")
      If (alphaMaskColorReversed=1)
         kMenu("PValpha", "Check", "&Invert alpha mask`tN")
      kMenu("PVmenu", "Add", "Alpha mas&k", ":PValpha")
   }

   If (isWinCustomShapeFriendly=1 && EllipseSelectMode=2 && editingSelectionNow=1 && additions=1)
   {
      createMenuSelectSizeShapes("simple")
      kMenu("PVmenu", "Add", "&Custom shape options", ":PVselSize")
   }

   If !AnyWindowOpen
      kMenu("PVmenu", "Add", "Selection &properties`tAlt+E", "PanelIMGselProperties")

   Menu, PVmenu, Add
   If (showMainMenuBar!=1 || mustPreventMenus=1)
   {
      createMenuMainView()
      kMenu("PVmenu", "Add", "Image vie&w", ":PVview")
      createMenuInterfaceOptions()
      kMenu("PVmenu", "Add", "Inter&face", ":PvUIprefs")
   }

   If (imgEditPanelOpened=1 && !isVarEqualTo(AnyWindowOpen, 10, 64, 66, 12) && drawing!=1)
      kMenu("PVmenu", "Add", "&Hide dynamic object`tD", "toggleLiveEditObject", "preview")

   showThisMenu("PVmenu")
}

MenuSelectEndFiles() {
   ThumbsNavigator("End", "+End")
}

MenuSelectHomeFiles() {
   ThumbsNavigator("Home", "+Home")
}

MenuChangeOSDZoomMinus() {
   changeOSDfontSize(-1)
}

MenuChangeOSDZoomPlus() {
   changeOSDfontSize(1)
}

MenuChangeImgZoomMinus() {
   VPchangeZoom(-1)
}

MenuChangeImgZoomPlus() {
   VPchangeZoom(1)
}

BuildSecondMenu(givenCoords:=0) {
   ; main menu
   DestroyGIFuWin()
   If (thumbsDisplaying=1)
   {
      Sleep, -1
   } Else If (editingSelectionNow=1 && validBMP(useGdiBitmap()) && StrLen(getIDimage(currentFileIndex))>4 && imgEditPanelOpened!=1)
   {
      invokeSelectionAreaMenu("DoubleClick")
      Return
   }

   deleteMenus()
   If (imgEditPanelOpened=1)
   {
      kMenu("PVmenu", "Add", "Collapse panel`tF11", "toggleImgEditPanelWindow")
      Menu, PVmenu, Add
      If (AnyWindowOpen=10)
      {
         kMenu("PVmenu", "Add", "Apply vie&wport effects inside selection`tCtrl+Shift+U", "ApplyVPcolorAdjustSelectedArea")
         kMenu("PVmenu", "Add", "&... outside the selection", "ApplyVPcolorAdjustSelectedArea")
      } Else kMenu("PVmenu", "Add", "&Apply tool`tEnter", "applyIMGeditFunction")

      labelu := (AnyWindowOpen=10) ? "Close panel" : "Cancel tool"
      kMenu("PVmenu", "Add", labelu "`tEscape", "CloseWindow")
      If (undoLevelsRecorded>1 || currentImgModified=1 && viewportQPVimage.imgHandle)
      {
         Menu, PVmenu, Add
         kMenu("PVmenu", "Add", "Undo`tCtrl+Z", "ImgUndoAction", "image editing")
         kMenu("PVmenu", "Add", "Redo`tCtrl+Y", "ImgRedoAction", "image editing")
      }

      Menu, PVmenu, Add
      If (AnyWindowOpen=10)
         kMenu("PVmenu", "Add", "Selection area`tE", "ToggleEditImgSelection", "image editing")
      Else If (thumbsDisplaying=1)
         kMenu("PVmenu", "Add", "Select all`tCtrl+A", "selectAllFiles",, " (files)")
      Else
         kMenu("PVmenu", "Add", "Select all`tCtrl+A", "selectEntireImage",, " (image canvas)")

      If (editingSelectionNow=1 && drawingShapeNow!=1)
      {
         keyu := (liveDrawingBrushTool=1 && thumbsDisplaying!=1 || AnyWindowOpen=64) ? "" : "`tR"
         kMenu("PVmenu", "Add", "Square (1:1)" keyu, "makeSquareSelection", "image editing selection", "Selection area: " sillySeparator)
         kMenu("PVmenu", "Add", "Flip selection area W/H`tW", "flipSelectionWH", "image editing selection")
         kMenu("PVmenu", "Add/Uncheck", "Limit selection to image area`tL", "toggleLimitSelection", "constrain")
         If (LimitSelectBoundsImg=1)
            kMenu("PVmenu", "Check", "Limit selection to image area`tL")

         Menu, PVmenu, Add
         kMenu("PVmenu", "Add", "&Rotate selection by 45°`tShift+R", "MenuSelRotation",,,1)

         If (VPselRotation>0)
            kMenu("PVmenu", "Add", "&Reset selection rotation`tShift+\", "resetSelectionRotation")
   
         If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
            kMenu("PVmenu", "Add", "R&eset exclusion area`tShift+\", "resetSelectionAreaCavity",, " (selection area)")
      }

      If (AnyWindowOpen=10)
         kMenu("PVmenu", "Add", "Reset image vie&w", "BtnResetImageView", "viewport")
      Else If (imgFxMode>1)
         kMenu("PVmenu", "Add", "Reset image vie&w", "ResetImageView", "viewport")

      Menu, PVmenu, Add 
      kMenu("PVmenu", "Add", "Adapt image to viewport`t/", "MenuSetImageAdaptAll")
      If (AnyWindowOpen=10 || AnyWindowOpen=74)
         kMenu("PVmenu", "Add", "Toggle colour &effects", "BtnToggleNoColorsFX",, " (viewport)")

      showThisMenu("PVmenu")
      Return
   }

   isWelcomeScreenu := (isImgEditingNow()=1 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
   ; zt := (thumbsDisplaying=1) ? "file(s) to" : ""
   zt2 := (thumbsDisplaying=1) ? "list" : "image"
   kMenu("PVmenu", "Add", "Main menu`tAppsKey", "InitGuiContextForcedMenu")
   Menu, PVmenu, Add,
   kMenu("PVmenu", "Add", "&Open image`tCtrl+O", "OpenDialogFiles")
   If isWelcomeScreenu
      kMenu("PVmenu", "Add", "Open &folder`tShift+O", "OpenFolders")

   If (thumbsDisplaying!=1)
   {
      kMenu("PVmenu", "Add", "&New image`tCtrl+N", "PanelNewImage", "editing")
      kMenu("PVmenu", "Add", "&Acquire image", "AcquireWIAimage", "editing")
   }

   If !isWelcomeScreenu
   {
      kMenu("PVmenu", "Add", "&Save " zt2 "`tCtrl+S", "PanelSaveImg")
      kMenu("PVmenu", "Add", "&Refresh " zt2 "`tF5", "RefreshImageFileAction", "reload revert image")
      Menu, PVmenu, Add 

      If (thumbsDisplaying=1)
         kMenu("PVmenu", "Add", "S&elect file`tSpace", "markThisFileNow")
      Else
         kMenu("PVmenu", "Add", "S&election area`tE", "ToggleEditImgSelection", "create")

      ; kMenu("PVmenu", "Add", "&All / none`tCtrl+A", "selectEntireImage")
      Menu, PVmenu, Add,
      If (thumbsDisplaying!=1)
      {
         kMenu("PVmenu", "Add", "&Copy image`tCtrl+C", "CopyImage2clip")
         If (editingSelectionNow=1)
         {
            kMenu("PVmenu", "Add", "Cut area`tCtrl+X", "CutSelectedArea", "create image editing selection")
            kMenu("PVmenu", "Add", "&Paste image into`tCtrl+Shift+V", "PanelPasteInPlace")
         } Else
            kMenu("PVmenu", "Add", "&Paste image`tCtrl+V", "PasteClipboardIMG")
      } Else
      {
         kMenu("PVmenu", "Add", "Cut file(s) (for E&xplorer)`tCtrl+X", "MenuExplorerCutFiles")
         kMenu("PVmenu", "Add", "&Copy file(s) to...`tC", "InvokeCopyFiles")
         kMenu("PVmenu", "Add", "&Move file(s) to...`tM", "PanelMoveCopyFiles")
         kMenu("PVmenu", "Add", "Pas&te file(s)`tCtrl+V", "MenuPasteHDropFiles")
      }

      isTransPanel := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
      If (editingSelectionNow=1 && thumbsDisplaying!=1 && (!AnyWindowOpen || imgEditPanelOpened=1) && isTransPanel!=1)
         kMenu("PVmenu", "Add", "Er&ase selected area`tDelete", "PanelEraseSelectedArea")
      Else If (thumbsDisplaying!=1 && StrLen(getIDimage(currentFileIndex))>2)
         kMenu("PVmenu", "Add", "Er&ase file`tDelete", "DeleteActivePicture")

      Menu, PVmenu, Add
      If (maxFilesIndex>1)
      {
         kMenu("PVmenu", "Add", "Searc&h index`tF3", "PanelSearchIndex")
         kMenu("PVmenu", "Add", "&Jump to`tJ", "PanelJump2index")
      }

      kMenu("PVmenu", "Add", "Reset " zt2 " vie&w`t\", "ResetImageView")
      If (thumbsDisplaying=1)
      {
         Menu, PVmenu, Add
         kMenu("PVmenu", "Add", "&Toggle list modes`tL", "toggleListViewModeThumbs")
         If (thumbsListViewMode>1)
         {
            kMenu("PVmenu", "Add", "Increase text size`t=", "MenuChangeOSDZoomPlus",,,1)
            kMenu("PVmenu", "Add", "Decrease text size`t-", "MenuChangeOSDZoomMinus",,,1)
         } Else
         {
            kMenu("PVmenu", "Add", "More thumbnails columns`t=", "MenuChangeImgZoomPlus")
            kMenu("PVmenu", "Add", "Fewer thumbnails columns`t-", "MenuChangeImgZoomMinus")
         }
      } Else
      {
         Menu, PVmenu, Add
         If (maxFilesIndex>1)
         {
            infoThumbsMode := (thumbsDisplaying=1) ? "Image view" : "List view"
            kMenu("PVmenu", "Add", infoThumbsMode "`tEnter", "MenuDummyToggleThumbsMode", "full view list")
         }
         keyu := (thumbsDisplaying=1 || markedSelectFile>0) ? "" : "`tSpace"
         If !AnyWindowOpen
         {
            kMenu("PVmenu", "Add", "Start slideshow" keyu, "MenuGoPlaySlidesNow", "play")
            kMenu("PVmenu", "Add", "Open previous panel`tF8", "openPreviousPanel", "last opened")
         }
         kMenu("PVmenu", "Add", "Image information and histogram HUD`tI", "ToggleHistoInfoBoxu", "viewport")
      }
   } Else
   {
      createMenuFavourites()
      createMenuHelpQPV()
      kMenu("PVmenu", "Add", "Fa&vourites", ":PVfaves")
      kMenu("PVmenu", "Add", "&Help", ":PVhelp")
   }

   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVmenu") : givenCoords
   showThisMenu("PVmenu")
}

StopCaptureClickStuff(dummy:=0) {
   Global lastOtherWinClose := A_TickCount
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
   endCaptureCloneBrush()
   showTOOLtip("Operation abandoned: define source point")
   SoundBeep , 300, 100
   If (dummy!="escape" && panelWinCollapsed=1 && imgEditPanelOpened=1 && AnyWindowOpen)
      toggleImgEditPanelWindow()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   interfaceThread.ahkPostFunction("setMenuBarState", "Enable", "PVmenu")
}

BuildMainMenu(dummy:=0, givenCoords:=0) {
   Static lastInvoked := 1
   If (toolTipGuiCreated=2)
      RemoveTooltip()

   If givenCoords
      globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVmenu") : givenCoords

   If (drawingShapeNow=1)
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      createContextMenuCustomShapeDrawing(mX, mY, 0, 0, 0)
      Return
   } Else If (mustCaptureCloneBrush=1)
   {
      StopCaptureClickStuff(dummy)
      Return
   } Else If (imgEditPanelOpened=1)
   {
      deleteMenus()
      BuildImgLiveEditMenu()
      Return
   }

   If (AnyWindowOpen>0 && dummy!="forced")
   {
      If ((A_TickCount - lastInvoked < 650) && !MsgBox2hwnd)
         CloseWindow()
      Else If (panelWinCollapsed!=1)
         WinActivate, ahk_id %hSetWinGui%
      lastInvoked := A_TickCount
      Return
   }

   SetTimer, drawWelcomeImg, Off
   deleteMenus()
   ResetImgLoadStatus()
   Global lastWinDrag := A_TickCount
   infoImgEditingNow := isImgEditingNow()
   If (thumbsDisplaying!=1)
   {
      kMenu("PVedit", "Add", "New image`tCtrl+N", "PanelNewImage", "image editing")
      If (infoImgEditingNow=1)
      {
         kMenu("PVedit", "Add", "&Save image as...`tCtrl+S", "PanelSaveImg", "image editing")
         kMenu("PVedit", "Add", "C&ut selected area`tCtrl+X", "CutSelectedArea", "image editing")
         If (editingSelectionNow!=1)
            kMenu("PVedit", "Disable", "C&ut selected area`tCtrl+X", "image editing")
         kMenu("PVedit", "Add", "&Copy to clipboard`tCtrl+C", "CopyImage2clip", "image")
         kMenu("PVedit", "Add", "Close ima&ge and files list`tCtrl+F4", "closeDocuments", "reset")
      }

      kMenu("PVedit", "Add", "P&aste clipboard`tCtrl+V", "PasteClipboardIMG", "image")
      If (infoImgEditingNow=1)
      {
         createMenuAlphaMask()
         kMenu("PVedit", "Add", "&Paste in place`tCtrl+Shift+V", "PanelPasteInPlace")
         If (editingSelectionNow!=1)
            kMenu("PVedit", "Disable", "&Paste in place`tCtrl+Shift+V")

         Menu, PVedit, Add,
         kMenu("PVedit", "Add", "Print image(s)`tCtrl+P", "PanelPrintImage")
      }

      kMenu("PVedit", "Add", "Ac&quire image (WIA)", "AcquireWIAimage", "capture devices scanner")
      Menu, PVedit, Add, 
      If (editingSelectionNow!=1 && infoImgEditingNow=1)
         kMenu("PVedit", "Add", "&Load freeform shape", "PanelManageVectorShapes", "freeform presets premade forms triangle moon cloud crescent heart water droplet rhombus star christian cross callout")

      If (editingSelectionNow!=1 && imgSelX2=-1 && imgSelY2=-1 && (CurrentSLD || validBMP(UserMemBMP)))
         kMenu("PVedit", "Add", "Create &selection area`tE", "newImgSelection", "image editing")
      Else If (editingSelectionNow!=1 && infoImgEditingNow=1)
         kMenu("PVedit", "Add", "Sho&w selection area`tE", "ToggleEditImgSelection", "image editing")

      createMenuImageEditSubMenus()
      ; Try kMenu("PVedit", ""Add", &Create", ":PVimgCreate"
      Try kMenu("PVedit", "Add", "Alpha mas&k", ":PValpha")
      Try kMenu("PVedit", "Add", "&Filters", ":PVimgFilters")
      Try kMenu("PVedit", "Add", "&Draw", ":PVimgDraw")
      Try kMenu("PVedit", "Add", "&Transform", ":PVimgTransform")
      Try kMenu("PVedit", "Add", "&Convert color depth", ":PVimgClrDepths")
   }

   createMenuFavourites()
   createMenuOpenRecents()

; main menu
   kMenu("PVmenu", "Add", "&Open...", ":PVopenF")
   kMenu("PVmenu", "Add", "Fa&vourites", ":PVfaves")
   If StrLen(mustOpenStartFolder)>3
      kMenu("PVmenu", "Add", "&Scan files in folder`tSpace/Wheel", "MenuDoOpenStartFolder", "open index")
   If (thumbsDisplaying=1)
   {
      kMenu("PVmenu", "Add", "&Paste file(s)`tCtrl+V", "MenuPasteHDropFiles", "index list clipboard")
      If hasFileIndexUndo(currentFileIndex)
         kMenu("PVmenu", "Add", "&Undo file action`tCtrl+Z", "ImgUndoAction", "history restore actions records")

      If (fileActsHistoryArray.Count()>0)
         kMenu("PVmenu", "Add", "Undo last actions(s)`tCtrl+Shift+Z", "doUndoFileActsChronos", "records actions files rename move copy history restore")
   }

   If ((validBMP(UserMemBMP) || currentImgModified=1 && viewportQPVimage.imgHandle) && thumbsDisplaying!=1 && (showMainMenuBar!=1 || mustPreventMenus=1))
   {
      Menu, PVmenu, Add,
      If (undoLevelsRecorded>1 && undoLevelsRecorded!="" || currentImgModified=1 && viewportQPVimage.imgHandle)
      {
         kMenu("PVmenu", "Add", "&Undo`tCtrl+Z", "ImgUndoAction", "image edit")
         kMenu("PVmenu", "Add", "&Redo`tCtrl+Y", "ImgRedoAction", "image edit")
         If (undoLevelsRecorded>5 && mustPreventMenus=1)
         {
            kMenu("PVmenu", "Add", "&Undo image (4 steps)`tCtrl+Alt+Z", "MenuUndoImgJumpy")
            kMenu("PVmenu", "Add", "&Redo image (4 steps)`tCtrl+Alt+Y", "MenuRedoImgJumpy")
         }
      }
      kMenu("PVmenu", "Add", "&Save image`tCtrl+S", "PanelSaveImg", "image edit")
      If FileExist(resultedFilesList[currentFileIndex, 1])
         kMenu("PVmenu", "Add", "&Revert changes...`tF5", "RefreshImageFileAction", "reload refresh")
   } Else If (validBMP(UserMemBMP) && thumbsDisplaying=1)
      kMenu("PVmenu", "Add", "&Return to image editing", "MenuReturnIMGedit", "back")

   Menu, PVmenu, Add,
   If (thumbsDisplaying!=1)
      kMenu("PVmenu", "Add", "&Edit image", ":PVedit")

   friendlyImgView := (thumbsDisplaying=1) ? "&Thumbnails view" : "Image vie&w"
   If (thumbsDisplaying=1 && thumbsListViewMode>1)
      friendlyImgView := "List vie&w"

   If (maxFilesIndex>0 && CurrentSLD)
   {
      infoThisFile := markedSelectFile ? "S&elected files" : "C&urrent file"
      If (thumbsDisplaying!=1 && editingSelectionNow=1)
      {
         createMenuSelectionArea()
         kMenu("PVmenu", "Add", "Selec&tion area", ":PVselv")
      }

      createMenuCurrentFilesActs()
      kMenu("PVmenu", "Add", infoThisFile, ":PVfilesActs")
      If markedSelectFile
      {
         createMenuSoloFile()
         kMenu("PVmenu", "Add", "&Active / focused file", ":PVtActFile")
      }

      If (thumbsDisplaying=1) || (thumbsDisplaying!=1 && (editingSelectionNow!=1 || mustPreventMenus=1 && showMainMenuBar=1))
      {
         createMenuFilesIndexOptions()
         kMenu("PVmenu", "Add", "Files inde&x/list", ":PVfList")
      }

      If (thumbsDisplaying=1 && maxFilesIndex>1)
      {
         okay := (testIsDupesList() && InStr(resultedFilesList[currentFileIndex, 23], "_")) ? 0 : 1
         If okay
         {
            createMenuFilesSort()
            kMenu("PVmenu", "Add", "Sort images list b&y", ":PVsort", "images files")
         }
      }

      createMenuMainView()
      kMenu("PVmenu", "Add", friendlyImgView, ":PVview")
      If (thumbsDisplaying!=1 && (editingSelectionNow!=1 || mustPreventMenus=1 && showMainMenuBar=1))
      {
         createMenuAnnotations()
         kMenu("PVmenu", "Add", "&Annotation", ":PVsounds")
      }

      If (maxFilesIndex>2 || mustOpenStartFolder)
      {
         createMenuNavigation()
         kMenu("PVmenu", "Add", "Navi&gation", ":PVnav")
         If (thumbsDisplaying!=1 && (editingSelectionNow!=1 || mustPreventMenus=1 && showMainMenuBar=1))
         {
            createMenuSlideshows()
            kMenu("PVmenu", "Add", "Slides&how", ":PVslide")
         }
      }
      Menu, PVmenu, Add
   } Else If validBMP(UserMemBMP)
   {
      If (editingSelectionNow=1 && thumbsDisplaying!=1)
      {
         createMenuSelectionArea()
         kMenu("PVmenu", "Add", "Selec&tion", ":PVselv")
         kMenu("PVmenu", "Add", "&Edit image", ":PVedit")
      }

      createMenuMainView()
      kMenu("PVmenu", "Add", friendlyImgView, ":PVview")
   }

   If (markedSelectFile && thumbsDisplaying!=1)
      kMenu("PVmenu", "Add", "Dro&p files selection`tShift+Tab", "dropFilesSelection")

   If (thumbsDisplaying=1)
   {
      createMenuFilesSelections("PVfileSel")
      kMenu("PVmenu", "Add", "F&iles selection", ":PVfileSel")
   }

   If StrLen(filesFilter)>1
   {
      Menu, PVmenu, Add
      kMenu("PVmenu", "Add", "Remove files list filter`tCtrl+Space", "MenuRemFilesListFilter")
      If testIsDupesList()
      {
         kMenu("PVmenu", "Add", "Auto-select &duplicates", "PanelAutoSelectDupes")
         If InStr(resultedFilesList[currentFileIndex, 23], "_")
            kMenu("PVmenu", "Add", "Change filter threshold`tCtrl+F", "PanelChangeHamDistThreshold")
      }
      Menu, PVmenu, Add
   } Else If (SLDtypeLoaded=2 && currentFilesListModified=1 && CurrentSLD && maxFilesIndex>1)
   {
      Menu, PVmenu, Add
      thisKey := (thumbsDisplaying=1) ? "Ctrl+S" : "Ctrl+Shift+S"
      kMenu("PVmenu", "Add", "Save files list now`t" thisKey, "BTNsaveCurrentSlideshow")
      Menu, PVmenu, Add
   }

   createMenuInterfaceOptions()
   createMenuMainPreferences()
   If (mustRecordSeenImgs=1 && mustPreventMenus=1 && !AnyWindowOpen)
      createMenuSeenImages()

   createMenuHelpQPV()
   kMenu("PVmenu", "Add", "Inter&face", ":PvUIprefs")
   kMenu("PVmenu", "Add", "Prefe&rences", ":PVprefs")
   kMenu("PVmenu", "Add", "Help", ":PVhelp")
   Menu, PVmenu, Add,
   kMenu("PVmenu", "Add", "Restart`tShift+Esc", "restartAppu", "close renew")
   kMenu("PVmenu", "Add", "Exit`tEscape", "exitAppu", "close")
   If thisCoords
      globalMenuOptions := thisCoords

   showThisMenu("PVmenu")
}

createMenuSeenImages() {
   If (maxFilesIndex>2 && CurrentSLD)
   {
      kMenu("PVmenu", "Add", "&Identify already seen images in the list", "quickFindSeenImages", "saw")
      kMenu("PVmenu", "Add", "&Identify never seen images in the list", "quickFindUnseenImages", "unseen")
   }

   If (userSeenSessionImagesArray.Count()>1)
      kMenu("PVmenu", "Add", "&Images seen in this session", "BtnViewedImages2List", "retrieve saw")

   kMenu("PVmenu", "Add", "&Retrieve list of all recorded seen images", "BtnALLviewedImages2List")
   ; kMenu("PVseenImgs", "Add", "&Purge records of inexistent files (seen images)", "CleanDeadFilesSeenImagesDB", "erase")
   kMenu("PVmenu", "Add", "&Erase the entire list of recorded seen images", "eraseSeenIMGsDB", "purge saw")
   kMenu("PVmenu", "Add", "&Already seen images statistics", "PanelSeenStats", "stats")
}

kMenu(mena, actu, labelu, funcu:=0, keywords:="", altLabel:="", keepUp:=0) {
   ; mena = menu name to add to
   ; actu = menu actions to perform, eg. add, disable, check
   ; labelu = menu item label
   ; funcu = the function to perform on menu click
   ; keywords for the menu when searched

   Static objuA := [], indexu := 0
        , objuB := new hashtable()
        , objuC := [], funcListu := []
        , separators := []

   If (actu="AddSeparator")
   {
      If (separators[mena]!=1)
         Menu, % mena, Add

      separators[mena] := 1
      Return
   } Else
      separators[mena] := 0

   If (actu="Reset" && !mena)
   {
      indexu := 0
      menuCustomNames := []
      funcListu := []
      objuA := [] ; menu items by index with properties objuA[menuIndex] := [prop1, prop2,... etc]
      objuC := [] ; menu names and their properties objuC[mena] := [menu-name, container-menu, accelatorkey]
      objuB := "" ; maps menu/menu items pairs to indexexes of objuA; objuB[mena "-" labelu] := menuIndex
      objuB := new hashtable()
      Return
   } Else If (actu="Give" && !mena)
      Return [objuA, objuB, objuC]
   Else If (actu="FuncGive" && !mena)
      Return funcListu

   If (mustPreventMenus=1)
   {
      If InStr(altLabel, sillySeparator)
         labelu := StrReplace(altLabel, sillySeparator) labelu
      Else If InStr(labelu, "`t")
         labelu := StrReplace(labelu, "`t", altLabel "`t")
      Else
         labelu := labelu altLabel 
   }

   ; mustPreventMenus is used to generate a searchable list of the menus, used by PanelQuickSearchMenuOptions() via buildQuickSearchMenus()
   ; when this is used, some menu items are hidden, while others are added, and the menus themselves are not invoked. showThisMenu() obeys this

   ; simulateMenusMode is used when a user presses a keyboard key, and it is a custom defined one
   ; funcListu is used to determine if the function is allowed to execute or not, in KeyboardResponder()
   If (!InStr(funcu, ":") && simulateMenusMode!=1)
   {
      ; rename the menus to reflect the custom shortcut[s]
      ckbd := testCustomKBDcontexts("." funcu)
      If ckbd
         thisu := ckbd

      If (thisu && InStr(actu, "Add") && funcu && labelu)
      {
         ; fnOutputDebug(funcu "() " userCustomKeysDefined["." funcu, 6])
         oLabelu := labelu
         If InStr(labelu, "`t")
         {
            defu := A_Space sillySeparator  processHumanKkbdName(SubStr(labelu, InStr(labelu, "`t") + 1))
            labelu := SubStr(labelu, 1, InStr(labelu, "`t") - 1)
         }
         If (userCustomKeysDefined[thisu, 6]!="" && SubStr(userCustomKeysDefined[thisu, 1], 1, 1)!="?")
            labelu .= "`t" userCustomKeysDefined[thisu, 6]

         menuCustomNames[mena "." oLabelu] := labelu
      } Else If (InStr(labelu, "`t") && InStr(actu, "Add"))
      {
         ; when the added menu item has a default keyboard shorcut but the functions are not the same
         ; assume this default keyboard shortcut is disabled

         c := defineKBDcontexts(0)
         skeyu := processHumanKkbdName(SubStr(labelu, InStr(labelu, "`t") + 1))
         shu := c . skeyu
         If (StrLen(userCustomKeysDefined[shu, 1])>0 && userCustomKeysDefined[shu, 1]!=funcu)
         {
            oLabelu := labelu
            defu := A_Space sillySeparator skeyu
            labelu := SubStr(labelu, 1, InStr(labelu, "`t") - 1)
            menuCustomNames[mena "." oLabelu] := labelu
         }
      }

      If (RegExMatch(actu, "i)(disable|check)") && labelu && menuCustomNames[mena "." labelu] && !InStr(actu, "Add"))
         labelu := menuCustomNames[mena "." labelu]
   }

   If (simulateMenusMode!=1)
   {
      zLabelu := StrReplace(labelu, "%", "`%")
      zLabelu := StrReplace(zlabelu, ",", "`,")
   }

   If (InStr(actu, "Add") && funcu && labelu)
   {
      If !InStr(funcu, ":")
      {
         kLabelu := StrReplace(labelu, "&")
         If (mustPreventMenus=1 && simulateMenusMode!=1)
         {
            accel :=  InStr(labelu, "&") ? Format("{:U}", SubStr(labelu, InStr(labelu, "&") + 1, 1)) : ""
            gup := StrSplit(kLabelu, "`t")
            flabel := Trimmer(fuzzifyString(gup[1]))
            testu := gup[1] A_Space funcu
            If (RegExMatch(testu, "i)(image|bitmap)") && !InStr(keywords, "img"))
               keywords .= " img"
            If (InStr(testu, "duplicate") && !InStr(keywords, "dupes"))
               keywords .= " dupes"
            If (InStr(testu, "image") && !InStr(keywords, "bitmap"))
               keywords .= " bitmap"
            If (InStr(testu, "img") && !InStr(keywords, "image"))
               keywords .= " image"
            If (InStr(testu, "create") && !InStr(keywords, "new"))
               keywords .= " new"
            If (InStr(testu, "insert") && !InStr(keywords, "add"))
               keywords .= " add"
            If (InStr(testu, "favo") && !InStr(keywords, "faves"))
               keywords .= " faves"
            If (InStr(testu, "save") && !InStr(keywords, "write"))
               keywords .= " write"
            If (InStr(testu, "statistic") && !InStr(keywords, "stats"))
               keywords .= " stats"
            If (InStr(testu, "folder") && !InStr(keywords, "directory"))
               keywords .= " directory"
            If (InStr(testu, "delete") && !InStr(keywords, "remove"))
               keywords .= " remove"
            If (InStr(testu, "remove") && !InStr(keywords, "delete"))
               keywords .= " delete"
            If (InStr(testu, "erase") && !InStr(keywords, "delete"))
               keywords .= " delete"
            If (InStr(testu, "purge") && !InStr(keywords, "delete"))
               keywords .= " delete"
            If ((InStr(testu, "preference") || InStr(testu, "settings")) && !InStr(keywords, "prefs"))
               keywords .= " prefs config"
            fkwds := keywords ? fuzzifyString(keywords) : ""
            ffuncu := fuzzifyString(StrReplace(funcu, "menu"))
         }

         indexu++
         objuA[indexu] := [gup[1], funcu, keywords defu, 1, 0, mena, gup[2], accel, flabel, fkwds, ffuncu, keepUp]
         objuB[mena "-" klabelu] := indexu
         funcListu[funcu] := [indexu, gup[2], keepUp]
      } Else If (mustPreventMenus=1 && simulateMenusMode!=1)
      {
         kLabelu := StrReplace(labelu, "&")
         gLabelu := kLabelu ? kLabelu : "Q" mena
         kfuncu := StrReplace(funcu, ":")
         objuC[kfuncu, 1] := gLabelu
         objuC[kfuncu, 2] := mena
         objuC[kfuncu, 3] := Trimmer(fuzzifyString(gLabelu))
         objuC[kfuncu, 4] := InStr(labelu, "&") ? SubStr(labelu, InStr(labelu, "&") + 1, 1) : ""
      }

      ; fnOutputDebug(mustPreventMenus "=" zLabelu " | " funcu "() | menu=" mena)
      If (mustPreventMenus!=1 && simulateMenusMode!=1)
         Menu, % mena, Add, % zLabelu, % funcu

      If (!InStr(funcu, ":") && InStr(actu, "Uncheck"))
      {
         objuA[indexu, 5] := -1
         If (mustPreventMenus!=1 && simulateMenusMode!=1)
            Try Menu, % mena, Icon, % zLabelu, %mainCompiledPath%\resources\menu-checkable.ico
      }
   } Else If (RegExMatch(actu, "i)(disable|check)") && labelu)
   {
      kLabelu := StrReplace(labelu, "&")
      thisindexu := objuB[mena "-" klabelu]
      If (actu="Disable" || actu="Check/Disable")
      {
         pkFunc := objuA[thisIndexu, 2]
         objuA[thisindexu, 4] := 0
         funcListu[pkFunc] := 0
      } Else If (actu="Check" || actu="Check/Disable")
      {
         objuA[thisindexu, 5] := 1
      } Else If (mustPreventMenus!=1 && simulateMenusMode!=1)
      {
         If InStr(actu, "Check")
            Menu, % mena, Icon, % zLabelu
      }

      If (simulateMenusMode!=1 && mustPreventMenus!=1)
      {
         If (actu="Check/Disable")
         {
            Menu, % mena, Check, % zLabelu
            Menu, % mena, Disable, % zLabelu
         } Else 
            Menu, % mena, % actu, % zLabelu
      }
   }
}

showThisMenu(menarg, forceIT:=0, manubarMode:=0, manuID:=0) {
   Static prevMenu, prevItems
   If (VisibleQuickMenuSearchWin=1 && mustPreventMenus!=1 && forceIT!=1 && omniBoxMode=0)
      closeQuickSearch()

   If (soloSliderWinVisible=1)
      destroySoloSliderWidget()

   SetTimer, drawWelcomeImg, Off
   items := DllCall("GetMenuItemCount", "uptr", MenuGetHandle(menarg))
   If (manubarMode!=1)
   {
      If ((A_TickCount - lastOtherWinClose<100) && prevMenu=menarg && prevItems=items) || (mustPreventMenus=1)
         Return

      GetPhysicalCursorPos(mX, mY)
      If InStr(globalMenuOptions, "|")
      {
         klop := StrSplit(globalMenuOptions, "|")
         If (klop[1]=menarg)
         {
            mX := klop[2]
            mY := klop[3]
         }
      }
     ; ToolTip, % items "==" prevItems "|" menarg "==" prevMenu, , , 2
   } Else
   {
      SetTimer, setWinCloseZeit, Off
      hMenuBar := DllCall("GetMenu", "UPtr", PVhwnd, "UPtr")
      If !hMenuBar
         addJournalEntry("ERROR: Failed to get menu bar handle, from the main window.")

      hMenuBar := "0x" Format("{:x}", hMenuBar)
      rect := GetMenuItemRect(PVhwnd, hMenuBar, manuID - 1)
      mX := Trim(rect.left)
      mY := Trim(rect.bottom)
      mYz := Trim(rect.top)
      mH := max(rect.bottom, rect.top) - min(rect.bottom, rect.top)
      mW := max(rect.left, rect.right) - min(rect.left, rect.right)
      interfaceThread.ahkFunction("ShowClickHalo", mX, mYz, mW, mH, 1, menarg, 1)
   }

   mouseTurnOFFtooltip()
   addJournalEntry("Invoked UI menu: " menarg)
   Global lastOtherWinClose := A_TickCount
   prevItems := items
   prevMenu := menarg
   globalMenuOptions := 0
   okay := (!AnyWindowOpen || imgEditPanelOpened=1) && (drawingShapeNow!=1) ? 1 : 0
   idu := (manubarMode=1) ? klop[2] : "reset"
   darkMode := (uiUseDarkMode=1) ? "yes" : "no"
   interfaceThread.ahkFunction("menuFlyoutDisplay", "yes", mX, mY, okay, darkMode, A_ScriptHwnd, idu)
   Sleep, 0
   ; SetMenuInfo(MenuGetHandle(menarg), 0, 1)
   Global lastMenuZeit := A_TickCount
   Menu, % menarg, Show, % mX, % mY
   Global lastMenuZeit := A_TickCount
   ; showDelayedTooltip("Menu item selected:`n" A_ThisMenuItem " [" A_ThisMenu "]")

   isFakeWin := (isNowFakeWinOpen=1 && AnyWindowOpen>0) ? 1 : 0
   ; If (isFakeWin=0)
      ; SetTimer, setWinCloseZeit, -185, 900
   setWinCloseZeit()
   If (manubarMode!=1)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   Global lastWinDrag := A_TickCount
   Global lastOtherWinClose := A_TickCount + 100
   interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
}

setWinCloseZeit() {
   darkMode := (uiUseDarkMode=1) ? "yes" : "no"
   interfaceThread.ahkPostFunction("menuFlyoutDisplay", "no", 1, 1, 0, darkMode, A_ScriptHwnd, "reset")
   ; doSuspendu(0)
}

deleteMenus() {
    If (mustPreventMenus=1)
       Return

    ; fnOutputDebug("menus deleted")
    Static menusList := "PVmenu|PValpha|PVtFileOpen|PVtFileImgAct|PVselSize|PVselRatio|PVimgTransform|PVimgCreate|PVimgFilters|PVimgDraw|PVperfs|PVfileSel|PVslide|PVnav|PVview|PVfList|PVtActFile|PVfilesActs|PVprefs|PvUIprefs|PVfaves|PVopenF|PVsort|PVedit|PVselv|PVsounds|PvImgAdapt|PVimgColorsFX|PVimgSdepth|PVimgVProt|PVimgHistos|PVlTools|PVstats|PVhelp|PvUItoolbarMenu|PVshapeTension|PVselAlign"
    menuCustomNames := []
    kMenu(0, "Reset", 0)
    Loop, Parse, menusList, |
        Try Menu, % A_LoopField, Delete
}

MenuSetImageAdaptAll() {
   ToggleImgSizeViewModes()
   ; IMGresizingMode := 0
   ; ToggleImageSizingMode("z")
}

MenuSetImageAdaptLarge() {
   IMGresizingMode := 1
   ToggleImageSizingMode("z")
}

MenuSetImageCustomZoom() {
   IMGresizingMode := 3
   ToggleImageSizingMode("z")
}

MenuSetImageStretchedWin() {
   IMGresizingMode := 4
   ToggleImageSizingMode("z")
}

MenuSetLockSelRatioUnlocked() {
   lockSelectionAspectRatio := 0
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioSelu() {
   lockSelectionAspectRatio := 1
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioWindow() {
   lockSelectionAspectRatio := 2
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioImage() {
   lockSelectionAspectRatio := 3
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioSquare() {
   lockSelectionAspectRatio := 4
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioSDTV() {
   lockSelectionAspectRatio := 5
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatio35mmFilm() {
   lockSelectionAspectRatio := 6
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioHDTV() {
   lockSelectionAspectRatio := 7
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioWide() {
   lockSelectionAspectRatio := 8
   toggleImgSelectionAspectRatio()
}

MenuSetLockSelRatioPhone() {
   lockSelectionAspectRatio := 9
   toggleImgSelectionAspectRatio()
}

MenuSetColorModeOriginal() {
   imgFxMode := 0
   ToggleImgFX(1)
}

MenuSetColorModePersonalized() {
   imgFxMode := 1
   ToggleImgFX(1)
}

MenuSetColorModeGrayscale() {
   imgFxMode := 3
   ToggleImgFX(1)
}

MenuSetColorModeRedC() {
   imgFxMode := 4
   ToggleImgFX(1)
}

MenuSetColorModeGreenC() {
   imgFxMode := 5
   ToggleImgFX(1)
}

MenuSetColorModeBlueC() {
   imgFxMode := 6
   ToggleImgFX(1)
}

MenuSetColorModeAlphaC() {
   imgFxMode := 7
   ToggleImgFX(1)
}

MenuSetColorModeInverted() {
   imgFxMode := 8
   ToggleImgFX(1)
}

MenuSetColorModeSepia() {
   imgFxMode := 9
   ToggleImgFX(1)
}

MenuSetVPhistoNone() {
   showHistogram := 0
   ToggleImgHistogram(1)
}

MenuSetVPhistoLuminance() {
   showHistogram := 1
   ToggleImgHistogram(1)
}

MenuSetVPhistoRed() {
   showHistogram := 2
   ToggleImgHistogram(1)
}

MenuSetVPhistoGreen() {
   showHistogram := 3
   ToggleImgHistogram(1)
}

MenuSetVPhistoBlue() {
   showHistogram := 4
   ToggleImgHistogram(1)
}

MenuSetVPhistoAll() {
   showHistogram := 5
   ToggleImgHistogram(1)
}

MenuSetVPgraphHistoPeaks() {
   histogramMode := 2
   ToggleHistogramMode()
}

MenuSetVPgraphHistoMids() {
   histogramMode := 1
   ToggleHistogramMode()
}

MenuSetVPgraphHistoLows() {
   histogramMode := 0
   ToggleHistogramMode()
}

MenuSetSelectionShapeRect() {
   toggleEllipseSelection(0)
}

MenuSetSelectionShapeEllipse() {
   toggleEllipseSelection(1)
}

MenuSetSelectionShapeFreeform() {
   toggleEllipseSelection(2)
}

MenuIncVPgridSize() {
   VPchangeGridSize(1)
}

MenuDecVPgridSize() {
   VPchangeGridSize(-1)
}

MenuResetImageColorDepth() {
   usrColorDepth := 0
   ToggleImgColorDepth(1)
}

MenuSetImageDepth2bits() {
   usrColorDepth := 1
   ToggleImgColorDepth(1)
}

MenuSetImageDepth3bits() {
   usrColorDepth := 2
   ToggleImgColorDepth(1)
}

MenuSetImageDepth4bits() {
   usrColorDepth := 3
   ToggleImgColorDepth(1)
}

MenuSetImageDepth5bits() {
   usrColorDepth := 4
   ToggleImgColorDepth(1)
}

MenuSetImageDepth6bits() {
   usrColorDepth := 5
   ToggleImgColorDepth(1)
}

MenuSetImageDepth7bits() {
   usrColorDepth := 6
   ToggleImgColorDepth(1)
}

MenuSetImageDepth8bits() {
   usrColorDepth := 7
   ToggleImgColorDepth(1)
}

MenuSetImageDepth16bits() {
   usrColorDepth := 8
   ToggleImgColorDepth(1)
}

MenuSelectionFlipH() {
   flipWHcustomShape("h")
}

MenuSelectionFlipV() {
   flipWHcustomShape("v")
}

MenuSelIncRotation() {
   VPchangeSelRotation(1)
}

MenuSelDecRotation() {
   VPchangeSelRotation(-1)
}

MenuSetVolumeDown() {
   ChangeSoundVolume(-1)
}

MenuSetVolumeUp() {
   ChangeSoundVolume(1)
}

MenuSetImgZoom(a, b) {
   zoomLevel := SubStr(a, 1, InStr(a, "%") - 1)/100
   IMGresizingMode := 4
   customZoomAdaptMode := 0
   interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
   zoomLevel := clampInRange(zoomLevel, 0.01, 20)
   INIaction(1, "IMGresizingMode", "General")
   INIaction(1, "zoomLevel", "General")
   updateUIctrl()
   dummyTimerDelayiedImageDisplay(150)
}

MenuSetVProt(a, b) {
   vpIMGrotation := StrReplace(a, "°")
   interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
   INIaction(1, "vpIMGrotation", "General")
   updateUIctrl()
   dummyTimerDelayiedImageDisplay(150)
}

ToggleDBdefaultSQLsort() {
   prevFilesSortMode := 0
   IniSLDBWrite("prevFilesSortMode", prevFilesSortMode)
   INIaction(1, "prevOpenFolderPath", "General")
   showTOOLtip("Default sorting of the files is now set to none.`nTo set it otherwise,please choose a sorting mode in the Sort menu.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createMenuFilesSelections(whichMenu) {
   If (markedSelectFile>1)
   {
      kMenu(whichMenu, "Add", "&First`tCtrl+Home", "jumpToFilesSelBorderFirst")
      kMenu(whichMenu, "Add", "&Previous`tCtrl+Left", "navSelectedFilesPrev")
      kMenu(whichMenu, "Add", "&Next`tCtrl+Right", "navSelectedFilesNext")
      kMenu(whichMenu, "Add", "&Last`tCtrl+End", "jumpToFilesSelBorderLast")
      Menu, % whichMenu, Add
      kMenu(whichMenu, "Add", "Invert selection`tShift+I", "invertFilesSelection", "files list")
   }

   If (markedSelectFile>1 || EntryMarkedMoveIndex)
      kMenu(whichMenu, "Add", "Select none`tCtrl+D", "dropFilesSelection", "files list")
   kMenu(whichMenu, "Add", "Select all`tCtrl+A", "selectAllFiles", "files list")
   keyu := (thumbsDisplaying=1 || markedSelectFile>1) ? "Space" : "Tab"
   kMenu(whichMenu, "Add", "Select / deselect file`t" keyu, "markThisFileNow")
   kMenu(whichMenu, "Add", "Select &random", "PanelSelectRandomFiles")
   kMenu(whichMenu, "Add", "Select all in same folder`tE", "QuickSelectFilesSameFolder")
   kMenu(whichMenu, "Add", "Select ine&xistent files", "SelectFilesDead", "missing dead")
   kMenu(whichMenu, "Add", "Select by &given string", "SelectFilesSearchIndex", "text matching")
   kMenu(whichMenu, "Add", "Select fa&vourited", "SelectFilesFavourited")
   kMenu(whichMenu, "Add", "Select &already seen images", "SelectFilesAlreadySeen")
   If (testIsDupesList()=1)
      kMenu(whichMenu, "Add", "Select the other images in &dupes group`tS", "keepSelectedDupeInGroup")

   If (markedSelectFile>1)
   {
      Menu, % whichMenu, Add
      keyu := (thumbsDisplaying=1) ? "`tR" : ""
      kMenu(whichMenu, "Add", "Revie&w selected files" keyu, "PanelReviewSelectedFiles")
      keyu := (thumbsDisplaying=1) ? "`tShift+L" : ""
      kMenu(whichMenu, "Add", "&Calculate total files size" keyu, "CalculateSelectedFilesSizes", "file details")
      kMenu(whichMenu, "Add", "Filter files list to selection`tCtrl+Tab", "filterToFilesSelection")
   }
}

InvokeRecentMenu(givenCoords:=0) {
   deleteMenus()
   createMenuOpenRecents("simple")
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVopenF") : givenCoords
   showThisMenu("PVopenF")
}

InvokeFavesMenu(givenCoords:=0) {
   deleteMenus()
   createMenuFavourites()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVfaves") : givenCoords
   showThisMenu("PVfaves")
}

createMenuOpenRecents(modus:=0) {
   countItemz := 0
   If (modus!="simple")
   {
      kMenu("PVopenF", "Add", "&Image or slideshow`tCtrl+O", "OpenDialogFiles", "open image files", "Open " sillySeparator)
      kMenu("PVopenF", "Add", "&Folder recursively`tShift+O", "OpenFolders", "open image folder files", "Open a " sillySeparator)
      kMenu("PVopenF", "Add", "&New QPV instance`tCtrl+Shift+N", "OpenNewQPVinstance")
      If (maxFilesIndex<1 || !CurrentSLD)
      {
         kMenu("PVopenF", "Add", "Insert file(s)`tInsert", "addNewFile2list", "images list")
         kMenu("PVopenF", "Add", "&Manage folders list`tAlt+U", "PanelDynamicFolderzWindow")
      }
   }

   If (allowRecordHistory=1 && mustPreventMenus!=1)
   {
      Menu, PVopenF, Add,
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      friendlyLabel := (userPrivateMode=1) ? "*:\*******\******.***" : PathCompact(Trimmer(LastOpenedImg), 30)
      If (RegExMatch(Trimmer(LastOpenedImg), RegExFilesPattern) && FileRexists(Trimmer(LastOpenedImg)))
         kMenu("PVopenF", "Add", "&0. " friendlyLabel, "MenuOpenLastImg")

      historyList := readRecentEntries(0, 0)
      Loop, Parse, historyList, `n
      {
         If (A_Index>maxRecentOpenedFolders)
            Break

         countItemz++
         testThis := StrReplace(A_LoopField, "|")
         If (StrLen(A_LoopField)<4 || !FileExist(testThis))
            Continue

         entryu := (userPrivateMode=1) ? "*:\*******\******.***" : PathCompact(testThis, 30)
         If InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= "\" ; entryu
         If !InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= " (*)"
         If RegExMatch(A_LoopField, sldsPattern)
            entryu := "# " entryu

         kMenu("PVopenF", "Add", "&" countItemz ". " entryu, "OpenRecentEntry")
      }

      Menu, PVopenF, Add, 
      If FolderExist(prevFileSavePath)
         aListu := (userPrivateMode=1) ? "O1. *:\*******\******.***`n" : "O1. " PathCompact(prevFileSavePath, 30) "`n"
      If (FolderExist(prevFileMovePath) && !InStr(aListu, prevFileMovePath "`n"))
         aListu .= (userPrivateMode=1) ? "O2. *:\*******\******.***`n" : "O2. " PathCompact(prevFileMovePath, 30) "`n"
      If (FolderExist(prevOpenFolderPath) && !InStr(aListu, prevOpenFolderPath "`n"))
         aListu .= (userPrivateMode=1) ? "O3. *:\*******\******.***`n" : "O3. " PathCompact(prevOpenFolderPath, 30) "`n"

      Loop, Parse, aListu, `n
      {
         If !A_LoopField
            Continue

         kMenu("PVopenF", "Add", A_LoopField, "OpenRecentEntry")
         ; kMenu("PVopenF", "Add", "% "O" A_Index ". " SubStr(A_LoopField, -30)", "OpenRecentEntry")
      }
   }

   Menu, PVopenF, Add, 
   If (countItemz>0 || mustPreventMenus=1)
      kMenu("PVopenF", "Add", "&Erase history list", "EraseOpenedHistory", "files")

   kMenu("PVopenF", "Add/Uncheck", "&Record recently opened", "ToggleRecordOpenHistory", "files")
   If (allowRecordHistory=1)
      kMenu("PVopenF", "Check", "&Record recently opened")
}

invokeFavedDirsMenu() {
   deleteMenus()
   createMenuDirsFaved(100, 15)
   showThisMenu("PVdirsFaved")
}

createMenuDirsFaved(howMany, extendedMode) {
   Try Menu, PVdirsFaved, Delete
   If (mustPreventMenus!=1)
      favesFoldersList := readFoldersFavedList()

   counter := favesFoldersList.Count()
   maxu := (counter>howMany) ? howMany : counter
   Loop, % maxu
   {
      entryu := (userPrivateMode=1) ? "*:\*******\******.***" : PathCompact(favesFoldersList[A_Index], 30)
      If (A_Index>=extendedMode)
         kMenu("PVdirsFaved", "Add", "&" A_Index ". " entryu, "OpenDirsFavedEntry")
   }

   If (counter<1)
   {
      kMenu("PVdirsFaved", "Add", "No folders or files lists", "dummy")
      kMenu("PVdirsFaved", "Disable", "No folders or files lists")
   } Else If (counter>howMany)
   {
      kMenu("PVdirsFaved", "Add", "... and " counter - howMany " more items", "invokeFavedDirsMenu")
      ; kMenu("PVdirsFaved", "Disable", "... and " counter - 15 " more items")
   }

   Menu, PVdirsFaved, Add
   kMenu("PVdirsFaved", "Add", "&Add/remove current files list to favourites", "MenuAddThisListAtFaves")
   If (counter>0)
      kMenu("PVdirsFaved", "Add", "&Remove inexistent entries", "removeDeadFavedFolders")
   If !(maxFilesIndex>0 && CurrentSLD)
      kMenu("PVdirsFaved", "Disable", "&Add/remove current files list to favourites")

   kMenu("PVdirsFaved", "Add", "&Remove all these from favourites", "clearAllFavedFolders")
}

createMenuFavourites() {

   createMenuDirsFaved(15, 0)
   kMenu("PVfaves", "Add", "Files lists and folders", ":PVdirsFaved")

   If (mustPreventMenus!=1)
      favesList := readMiniFavesEntries()

   Menu, PVfaves, Add
   Loop, Parse, favesList, `n,`r
   {
      If (A_Index>15)
         Break

      countItemz++
      If !Trimmer(A_LoopField)
         Continue

      entryu := (userPrivateMode=1) ? "*:\*******\******.***" : PathCompact(A_LoopField, 30)
      If StrLen(entryu)>3
      {
         countFaved++
         kMenu("PVfaves", "Add", "&" countItemz ". " entryu, "OpenFavesEntry")
      }
   }
   If !userAddedFavesCount
      IniAction(0, "userAddedFavesCount", "General", 2, 0, 987654321)

   If !countFaved
   {
      kMenu("PVfaves", "Add", "No image added to favourites", "dummy")
      kMenu("PVfaves", "Disable", "No image added to favourites")
   } Else If (userAddedFavesCount>15)
   {
      moru := userAddedFavesCount - 15
      kMenu("PVfaves", "Add", "... and " groupDigits(moru) " more images", "retrieveFavesAsList")
      ; kMenu("PVfaves", "Disable", "... and " groupDigits(moru) " more images")
   }

   Menu, PVfaves, Add
   kMenu("PVfaves", "Add/Uncheck", "&Cycle favourites list on open", "ToggleCycleFavesOpen")
   If (cycleFavesOpenIMG=1)
      kMenu("PVfaves", "Check", "&Cycle favourites list on open")

   kMenu("PVfaves", "Add", "&Add/remove current image to favourites`tB", "ToggleImgFavourites")
   If !(maxFilesIndex>0 && CurrentSLD)
      kMenu("PVfaves", "Disable", "&Add/remove current image to favourites`tB")

   If !countFaved
      IniAction(0, "userAddedFavesCount", "General", 4)

   If (countFaved>1 || userAddedFavesCount>1)
   {
      kMenu("PVfaves", "Add", "&Manage the favourites list", "retrieveFavesAsList", "open faves favorites")
      kMenu("PVfaves", "Add", "&Remove all from favourites", "eraseAllFavedIMGs")
   }
}

createMenuStatistics() {
   If (mustPreventMenus!=1)
      kMenu("PVstats", "Add", "Open main panel", "PanelWrapperFilesStats")
   kMenu("PVstats", "Add", "&Files stats panel", "PanelIndexedFilesStats")
   kMenu("PVstats", "Add", "&Image properties stats panel", "PanelIndexedImagesStats")
   If (mustRecordSeenImgs=1)
      kMenu("PVstats", "Add", "&Seen images stats panel", "PanelSeenStats", "stats")

   If (mustPreventMenus=1)
      kMenu("PVstats", "Add", "&Remove all from favourites", "eraseAllFavedIMGs")

   Menu, PVstats, Add
   kMenu("PVstats", "Add", "&Collect file details", "BtnCollectFileInfos")
   kMenu("PVstats", "Add", "Collect image &properties", "BtnCollectImageInfos")
   kMenu("PVstats", "Add", "Collect image &histogram data", "BtnCollectHistoInfos")
   If (mustPreventMenus=1)
      kMenu("PVstats", "Add", "C&reate custom files list filter`tCtrl+F", "PanelEnableFilesFilter")
}

createMenuFilesIndexOptions() {
   infoMenuRefresh := RegExMatch(CurrentSLD, sldsPattern) ? "Reload .SLD file" : "Refresh opened folder(s)"
   pathu := PathCompact(CurrentSLD, 40)
   If pathu
   {
      kMenu("PVfList", "Add", infoMenuRefresh "`tShift+F5", "RefreshFilesList", "reload refresh list files")
      If RegExMatch(CurrentSLD, sldsPattern)
      {
         kMenu("PVfList", "Add", pathu, "RefreshFilesList")
         kMenu("PVfList", "Disable", pathu)
      }
   }

   Menu, PVfList, Add,
   kMenu("PVfList", "Add", "Import list / insert file(s)`tInsert", "addNewFile2list")
   kMenu("PVfList", "Add", "&Add folder(s)`tShift+Insert", "addNewFolder2list")
   kMenu("PVfList", "Add", "Mana&ge folder(s) list`tAlt+U", "PanelDynamicFolderzWindow")
   If (maxFilesIndex>1)
   {
      kMenu("PVfList", "Add", "Save files list as &.SLD`tCtrl+Shift+S", "PanelSaveSlideShowu")
      Menu, PVfList, Add,
      If (thumbsDisplaying=1 && !markedSelectFile)
      {
         If !EntryMarkedMoveIndex
            kMenu("PVfList", "Add", "Mar&k entry to reorder`tX", "moveMarkedEntryNow")
         Else
            kMenu("PVfList", "Add", "Move mar&ked entry to focused index`tX", "moveMarkedEntryNow")
      } Else If (thumbsDisplaying=1 && markedSelectFile>1)
            kMenu("PVfList", "Add", "Move/regroup entries to focused index`tShift+X", "MenuMoveMarkedEntries")

      If !markedSelectFile
      {
         kMenu("PVfList", "Add", "&Modify focused index entry`tCtrl+F2", "PanelUpdateThisFileIndex")
         kMenu("PVfList", "Add", "Remove focused inde&x entry`tAlt+Delete", "singleInListEntriesRemover")
      }

      kMenu("PVfList", "Add/Uncheck", "Auto-remove entries of dead files", "ToggleAutoRemEntries")
      If (autoRemDeadEntry=1)
         kMenu("PVfList", "Check", "Auto-remove entries of dead files")

      Menu, PVfList, Add,
      ; If RegExMatch(CurrentSLD, sldsPattern)
      labelu := (SLDtypeLoaded=3) ? "Clean inexistent files entries" : "Clean &duplicate and inexistent entries"
      kMenu("PVfList", "Add", labelu, "cleanDeadFilesList", "remove dead files erase")
      If StrLen(DynamicFoldersList)>6
         kMenu("PVfList", "Add", "&Regenerate the entire list", "RegenerateEntireList")

      labelu := (FileExist(CurrentSLD) && RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? "&Update files list selectively`tCtrl+U" : "Folders containin&g indexed files`tCtrl+U"
      kMenu("PVfList", "Add", labelu, "PanelStaticFolderzManager", "folders manage")
      If (mustRecordSeenImgs=1)
         kMenu("PVfList", "Add", "Remove alread&y seen images", "removeFilesListSeenImages", "eliminate")
      If !InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
         kMenu("PVfList", "Add", "Remove fa&vourited images from list", "removeFilesListFavouritedImages", "eliminate")

      Menu, PVfList, Add, 
      kMenu("PVfList", "Add", "&Find duplicate images", "PanelFindDupes")
      If (mustPreventMenus=1)
      {
         createMenuStatistics()
         kMenu("PVfList", "Add", "&Statistics main panel", "PanelWrapperFilesStats")
         kMenu("PVfList", "Add", "&Statistics", ":PVstats")
      } Else
         kMenu("PVfList", "Add", "&Statistics", "PanelWrapperFilesStats", "files index list")

      kMenu("PVfList", "Add", "&Keywords indexer", "PanelKeywordsDetector")
      kMenu("PVfList", "Add", "Searc&h index`tCtrl+F3", "PanelSearchIndex", "files list")
      If (mustPreventMenus=1 && userSearchString)
      {
         kMenu("PVfList", "Add", "S&earch next`tF3", "MenuSearchNextIndex")
         kMenu("PVfList", "Add", "Search p&revious`tShift+F3", "MenuSearchPrevIndex")
         kMenu("PVfList", "Add", "Erase search &criteria", "EraseSearchEdit")
      }

      kMenu("PVfList", "Add", "Search and re&place`tCtrl+H", "PanelSearchAndReplaceIndex", "files index list")
      kMenu("PVfList", "Add", "&Index filters`tCtrl+F", "PanelEnableFilesFilter", "files list")
      If (StrLen(filesFilter)>1 && !testIsDupesList())
         kMenu("PVfList", "Check", "&Index filters`tCtrl+F")
   }
}

createMenuInterfaceOptions() {
   If (AnyWindowOpen && imgEditPanelOpened=1)
   {
      kMenu("PvUIprefs", "Add/Uncheck", "&Collapse tool panel`tF11", "toggleImgEditPanelWindow")
      If (panelWinCollapsed=1)
         kMenu("PvUIprefs", "Check", "&Collapse tool panel`tF11")
      Menu, PvUIprefs, Add
      If (showMainMenuBar=1 || mustPreventMenus=1)
      {
         kMenu("PvUIprefs", "Add", "&Search menu options`t;", "PanelQuickSearchMenuOptions", "keyboard")
         Menu, PvUIprefs, Add
      }
   }

   If (drawingShapeNow!=1)
   {
      infoThumbsList := defineListViewModes()
      infoThumbsMode := (thumbsDisplaying=1) ? "Switch to image view" : "Switch to " infoThumbsList " list view"
      If (thumbsDisplaying=1 && (showMainMenuBar!=1 || mustPreventMenus=1))
         kMenu("PvUIprefs", "Add", "C&ycle view modes`tL", "toggleListViewModeThumbs")

      If (maxFilesIndex>0 && !AnyWindowOpen)
         kMenu("PvUIprefs", "Add", infoThumbsMode "`tEnter", "MenuDummyToggleThumbsMode")
      If (!AnyWindowOpen && prevOpenedWindow[2])
         kMenu("PvUIprefs", "Add", "Open pre&vious panel`tF8", "openPreviousPanel", "show")

      If (thumbsDisplaying!=1 && !AnyWindowOpen)
         kMenu("PvUIprefs", "Add", "&Toggle full-screen mode`tF11", "ToggleFullScreenMode")

      If (thumbsDisplaying!=1)
      {
         kMenu("PvUIprefs", "Add/Uncheck", "&Touch screen mode (viewport)", "ToggleTouchMode")
         If (TouchScreenMode=1)
            kMenu("PvUIprefs", "Check", "&Touch screen mode (viewport)")
      }

      Menu, PvUIprefs, Add
   } Else
      kMenu("PvUIprefs", "Add", "&Search menu options`t;", "PanelQuickSearchMenuOptions")

   If (isNowAlphaPainting()!=1)
   {
      kMenu("PvUIprefs", "Add/Uncheck", "Dar&k mode UI", "ToggleDarkModus", "disability handicap eyes eyesight black display")
      If (uiUseDarkMode=1)
         kMenu("PvUIprefs", "Check", "Dar&k mode UI")

      kMenu("PvUIprefs", "Add/Uncheck", "&Large UI fonts", "ToggleLargeUIfonts", "disability handicap eyes eyesight large display")
      If (PrefsLargeFonts=1)
         kMenu("PvUIprefs", "Check", "&Large UI fonts")
   }

   If (AnyWindowOpen!=14)
   {
      kMenu("PvUIprefs", "Add", "Increase viewport text size`tCtrl+=", "MenuChangeOSDZoomPlus", "disability handicap eyes eyesight large",,1)
      kMenu("PvUIprefs", "Add", "Decrease viewport text size`tCtrl+-", "MenuChangeOSDZoomMinus", "disability  handicap eyes eyesight large",,1)
   }

   Menu, PvUIprefs, Add
   kMenu("PvUIprefs", "Add/Uncheck", "&Always on top", "ToggleAllonTop", "window")
   If (getTopMopStyle(PVhwnd)=1)
      kMenu("PvUIprefs", "Check", "&Always on top")

   If (thumbsDisplaying!=1 && drawingShapeNow!=1 && !AnyWindowOpen)
   {
      kMenu("PvUIprefs", "Add/Uncheck", "&Hide title bar", "ToggleTitleBaru", "window")
      If (getCaptionStyle(PVhwnd)=1)
         kMenu("PvUIprefs", "Check", "&Hide title bar")
   }

   Menu, PvUIprefs, Add
   If (AnyWindowOpen!=14 && imgEditPanelOpened!=1 && drawingShapeNow!=1)
   {
      keyword := (folderTreeWinOpen=1) ? " hide" : " display"
      kMenu("PvUIprefs", "Add/Uncheck", "Show &folders tree panel`tF4", "MenuPanelFoldersTree", "window treeview directories explore" keyword)
      If (folderTreeWinOpen=1)
         kMenu("PvUIprefs", "Check", "Show &folders tree panel`tF4")
   }

   If (isImgEditingNow() && thumbsDisplaying!=1 && drawingShapeNow!=1)
   {
      createMenuVPhudHisto()
      kMenu("PvUIprefs", "Add", "Show histogram", ":PVimgHistos")
   }

   If (drawingShapeNow!=1)
   {
      keyword := (showMainMenuBar=1) ? " hide" : " display"
      kMenu("PvUIprefs", "Add/Uncheck", "Show &menu bar`tF10", "ToggleMenuBaru", "toolbar" keyword)
      If (showMainMenuBar=1)
         kMenu("PvUIprefs", "Check", "Show &menu bar`tF10")
   } Else
   {
      kMenu("PvUIprefs", "Add/Uncheck", "Show status &bar`tI", "ToggleContextStatusBar", "help")
      If (showContextualStatusBar=1)
         kMenu("PvUIprefs", "Check", "Show status &bar`tI")
   }

   keyword := (ShowAdvToolbar=1) ? "hide" : "display"
   kMenu("PvUIprefs", "Add/Uncheck", "Show &toolbar`tShift+F10", "toggleAppToolbar", keyword)
   If (ShowAdvToolbar=1)
   {
      createTlbrContextMenu()
      kMenu("PvUIprefs", "Check", "Show &toolbar`tShift+F10")
      kMenu("PvUIprefs", "Add", "&Toolbar options", ":PvUItoolbarMenu")
   }

   If (maxFilesIndex>0 && CurrentSLD && drawingShapeNow!=1)
   {
      keyword := (showInfoBoxHUD=1) ? "hide" : "show display"
      If (AnyWindowOpen!=14)
      {
         kMenu("PvUIprefs", "Add/Uncheck", "&Show viewport info-box`tI", "ToggleInfoBoxu", "files details information properties " keyword)
         If (showInfoBoxHUD>=1)
            kMenu("PvUIprefs", "Check", "&Show viewport info-box`tI")
      }
   }

   If (maxFilesIndex>0 && CurrentSLD)
   {
      keyword := (showHUDnavIMG=1) ? " hide" : " show display"
      friendly := (thumbsDisplaying=1) ? "Image previe&w box`tZ" : "Auto-display image navi&gator`tZ"
      kMenu("PvUIprefs", "Add/Uncheck", friendly, "ToggleImgNavBox", "map" keyword)
      If (showHUDnavIMG=1)
      {
         kMenu("PvUIprefs", "Check", friendly)
         kMenu("PvUIprefs", "Add/Uncheck", "&Large preview size", "ToggleImgNavSizeBox")
         If (HUDnavBoxSize>=125)
            kMenu("PvUIprefs", "Check", "&Large preview size")
      }
   }

   If (thumbsDisplaying=1)
   {
      keywords := (showImgAnnotations=1) ? "hide viewport" : "display viewport"
      kMenu("PvUIprefs", "Add/Uncheck", "&Show image captions`tN", "ToggleImgCaptions", keywords)
      If (showImgAnnotations=1)
         kMenu("PvUIprefs", "Check", "&Show image captions`tN")
   }

   If (maxFilesIndex>0 && CurrentSLD && thumbsDisplaying!=1)
   {
      Menu, PvUIprefs, Add
      kMenu("PvUIprefs", "Add/Uncheck", "&Ambiental textured background", "ToggleTexyBGR", "viewport image performance")
      If (usrTextureBGR=1)
         kMenu("PvUIprefs", "Check", "&Ambiental textured background")
   }

   If (!AnyWindowOpen && drawingShapeNow!=1)
   {
      Menu, PvUIprefs, Add
      kMenu("PvUIprefs", "Add", "Additional settings`tF12", "PanelPrefsWindow",, " (interface)")
   }
}

EraseOpenedHistory() {
   Loop, 15
       IniWrite, 0, % mainRecentsFile, RecentOpen, E%A_Index%
   IniWrite, 0, % mainSettingsFile, General, LastOpenedImg
}

OpenRecentEntry(menuItem) {
  testOs := SubStr(menuItem, 1, 3)
  initQPVmainDLL()
  If askAboutFileSave(" and another image will be loaded")
     Return

  If askAboutSlidesListSave()
     Return

  If askAboutFilesSelect("discard it")
     Return

  startZeit := A_TickCount
  If (testOs="O1.")
     openThisu := prevFileSavePath
  Else If (testOs="O2.")
     openThisu := prevFileMovePath
  Else If (testOs="O3.")
     openThisu := prevOpenFolderPath

  If openThisu
     newEntry := openThisu

  If !newEntry
  {
     openThisu := SubStr(menuItem, 2, InStr(menuItem, ". ")-2)
     IniRead, newEntry, % mainRecentsFile, RecentOpen, E%openThisu%, @
  }
  ; MsgBox, %openthisu% -- %newentry%
  newEntry := Trimmer(newEntry)
  If StrLen(newEntry)>4
  {
     If (SLDtypeLoaded=3)
     {
        SLDtypeLoaded := 0
        activeSQLdb.CloseDB()
     }

     If RegExMatch(newEntry, sldsPattern)
     {
        OpenSLD(newEntry)
     } Else
     {
        PopulateIndexFilesStatsInfos("kill")
        prevOpenFolderPath := StrReplace(newEntry, "|")
        If FolderExist(prevOpenFolderPath)
           INIaction(1, "prevOpenFolderPath", "General")

        coreOpenFolder(newEntry, 1, 0, 1)
        currentFilesListModified := 0
        SlidesMusicSong := ""
        interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
        If (maxFilesIndex>0)
           SLDtypeLoaded := 1

        SetTimer, createGUItoolbar, -100
        SetTimer, TriggerMenuBarUpdate, -90
        ; Else resetMainWin2Welcome()
     }
  }
  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

OpenFavesEntry(menuItem) {
  testOs := menuItem
  openThisu := SubStr(testOs, 2, InStr(testOs, ". ")-2)
  If (InStr(CurrentSLD, "\QPV\favourite-images-list.SLD") && maxFilesIndex>500)
  {
     currentFileIndex := openThisu
     dummyTimerDelayiedImageDisplay(50)
     Return
  }

  If askAboutFileSave(" and the selected image from favourites will be loaded")
     Return

  If askAboutSlidesListSave()
     Return

  If askAboutFilesSelect("discard it")
     Return

  startZeit := A_TickCount
  contentu := readMiniFavesEntries()
  Loop, Parse, contentu, `n, `r
  {
      If (openThisu=A_Index)
      {
         newEntry := Trimmer(A_LoopField)
         Break
      }
  }

  ; IniRead, newEntry, % mainRecentsFile, favourites, E%openThisu%, @
  If !FileRexists(newEntry)
  {
     msgResult := msgBoxWrapper(appTitle ": ERROR", "The file you are trying to open seems to no longer exist. Would you like to remove it from the favourites list?", 4, 0, "question")
     If InStr(msgResult, "yes")
        ToggleImgFavourites(newEntry, "rem")
  } Else If (cycleFavesOpenIMG=1 && newEntry!="@" && StrLen(newEntry)>2)
  {
     retrieveFavesAsList(openThisu)
     Return
  } Else If (newEntry!="@" && StrLen(newEntry)>2)
  {
     MenuOpenLastImg(newEntry)
     resultedFilesList[currentFileIndex, 5] := 1
     currentImgModified := 0
     SlidesMusicSong := ""
     interfaceThread.ahkassign("currentFilesListModified", currentFilesListModified)
  }

  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

RegAction(act, var, section:="PanelOptions", type:=0, mini:=0, maxy:=0, forcedDef:="") {
    INIaction(act, var, section, type, mini, maxy, forcedDef,, 1)
}

INIaction(act, var, section, type:=0, mini:=0, maxy:=0, forcedDef:="", iniFile:="", storeReg:=0) {
   thisIniFile := iniFile ? iniFile : mainSettingsFile
   varValue := %var%
   If (act=1)
   {
      If (var="FillAreaCustomShape")
      {
         If (StrLen(FillAreaCustomShape)>65300)
            saveCurrentVectorShape("_previous_huge_path", 0)

         varValue := SubStr(varValue, 1, 65300)
      }

      If (storeReg=1)
         RegWrite, REG_SZ, % QPVregEntry "\" section, %var%, %varValue%
      Else
         IniWrite, %varValue%, % thisIniFile, %section%, %var%
      If (ErrorLevel && (A_TickCount - scriptStartTime<2500))
         addJournalEntry("Error saving INI settings (" var ") in " thisIniFile " | " section)
   } Else
   {
      defaultu := (forcedDef!="") ? forcedDef : %var%
      If (storeReg=1)
         RegRead, %var%, % QPVregEntry "\" section, %var%
      Else
         IniRead, %var%, % thisIniFile, %section%, %var%, %varValue%

      loadedValue := %var%
      If ((ErrorLevel && loadedValue="") || (ErrorLevel && storeReg=1) || (storeReg=1 && type=1 && loadedValue=""))
         loadedValue := defaultu

      If (ErrorLevel && (A_TickCount - scriptStartTime<2500) && var!="userAddedFavesCount")
         addJournalEntry("Error loading INI settings (" var ") in " thisIniFile " | " section)

      If (type=1) ; binary
      {
         loadedValue := (Round(loadedValue)=0 || Round(loadedValue)=1) ? Round(loadedValue) : defaultu
         %var% := loadedValue
      } Else If (type=2)  ; range min/max
      {
         If !isNumber(loadedValue)
         {
            %var% := defaultu
         } Else
         {
            loadedValue := clampInRange(loadedValue, mini, maxy)
            %var% := loadedValue
         }
      } Else If (type=3)  ; HEX colour
      {
         loadedValue := Trimmer(loadedValue)
         If (loadedValue ~= "[^[:xdigit:]]") || (StrLen(loadedValue)!=6)
            loadedValue := defaultu
         %var% := loadedValue
      } Else If (type=4)  ; isNumber
      {
         If !isNumber(loadedValue)
            %var% := defaultu
         Else
            %var% := loadedValue
      } Else If (!(loadedValue ~= "i)^(.\:\\.)") && type=6)
      {
         %var% := defaultu
      } Else If (loadedValue="error" && type=5)
         %var% := defaultu
   }
}

ToggleFullScreenMode() {
   Static prevState := 1, o_TouchScreenMode := "a", o_ShowAdvToolbar := "a"
   If (drawingShapeNow=1 && isImgEditingNow())
      Return

   If (thumbsDisplaying=1)
   {
      ; o_TouchScreenMode := TouchScreenMode
      ToggleThumbsMode()
      Return
   }

  ; If (tempBtnVisible!="null")
     ; DestroyTempBtnGui("now")

  prevState := !prevState
  ot := ShowAdvToolbar
  If (prevState=0)
  {
     o_ShowAdvToolbar := ShowAdvToolbar
     If (showMainMenuBar=1)
     {
        showMainMenuBar := 0
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        Win_SetMenu(PVhwnd, 0)
        TriggerMenuBarUpdate()
     }
     ; o_TouchScreenMode := TouchScreenMode
     If (ShowAdvToolbar=1)
        toggleAppToolbar()

     isTitleBarVisible := 0
     If (editingSelectionNow=1)
       ToggleEditImgSelection()

     WinSet, Style, -0xC00000, ahk_id %PVhwnd%
     WinMaximize, ahk_id %PVhwnd%
     ; ToolbarWinW := ToolbarWinH := 1
     ; If (ShowAdvToolbar=1 && TouchToolbarGUIcreated=1)
        ; SetWindowRegion(hQPVtoolbar, 1, 1, 1, 1)
  } Else
  {
     ; If (o_TouchScreenMode!="a")
     ;    TouchScreenMode := o_TouchScreenMode
     isTitleBarVisible := 1
     WinGetPos, thisX, thisY, ToolbarWinW, ToolbarWinH, ahk_id %hQPVtoolbar%
     WinSet, Style, +0xC00000, ahk_id %PVhwnd%
     WinRestore, ahk_id %PVhwnd%
     INIaction(0, "showMainMenuBar", "General", 1)
     INIaction(0, "TouchScreenMode", "General", 1)
     If (showMainMenuBar=1)
     {
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        TriggerMenuBarUpdate()
     }

     If (o_ShowAdvToolbar=1 && ot!=1)
        SetTimer, toggleAppToolbar, -300
  }

  interfaceThread.ahkassign("isTitleBarVisible", isTitleBarVisible)
  interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
  ; ToolTip, % "l=" isTitleBarVisible " kl=" kl , , , 2
  SetTimer, dummyFullScreenButtons, -250
}

dummyFullScreenButtons() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  If (editingSelectionNow=1 || showHistogram>1 || showInfoBoxHUD>=1)
     2ndLabel := "||Hide viewport elements,,turnOffViewportStuff"

  showTOOLtip(friendly)
  CreateTempGuiButton("Interface options,,OpenUImenu" 2ndLabel, "force", msgDisplayTime + 500)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

turnOffViewportStuff() {
   If (showHistogram>1 || showInfoBoxHUD>=1)
      ToggleHistoInfoBoxu()
   If (editingSelectionNow=1)
      ToggleEditImgSelection()
   DestroyTempBtnGui("now")
}

ToggleAllonTop() {
   isAlwaysOnTop := !isAlwaysOnTop
   WinSet, AlwaysOnTop, % isAlwaysOnTop, ahk_id %PVhwnd%
   INIaction(1, "isAlwaysOnTop", "General")
   interfaceThread.ahkassign("isAlwaysOnTop", isAlwaysOnTop)
   friendly := (isAlwaysOnTop=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Window always on top: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleEasySlideStop() {
   easySlideStoppage := !easySlideStoppage
   INIaction(1, "easySlideStoppage", "General")
}

ToggleSlidesFXmode() {
   slidesFXrandomize := !slidesFXrandomize
   INIaction(1, "slidesFXrandomize", "General")
   interfaceThread.ahkassign("slidesFXrandomize", slidesFXrandomize)
   friendly := (slidesFXrandomize=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Randomize colour FX during slideshows:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSelKeepRatioRotation() {
   rotateSelBoundsKeepRatio := !rotateSelBoundsKeepRatio
   INIaction(1, "rotateSelBoundsKeepRatio", "General")
   friendly := (rotateSelBoundsKeepRatio!=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Distort selection on rotation:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (editingSelectionNow=1 && thumbsDisplaying!=1)
      SetTimer, dummyRefreshImgSelectionWindow, -10
}

ToggleGIFsPlayEntirely() {
   allowGIFsPlayEntirely := !allowGIFsPlayEntirely
   INIaction(1, "allowGIFsPlayEntirely", "General")
   friendly := (allowGIFsPlayEntirely=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Allow GIFs play entirely during slideshows:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleRecordSeenImages() {
   mustRecordSeenImgs := !mustRecordSeenImgs
   If (sqlFailedInit=1 && mustRecordSeenImgs=1)
   {
      mustRecordSeenImgs := 0
      msgBoxWrapper(appTitle ": ERROR", "An unknown error occured when attempting to initialize SqlLite Database.`n`nFeature not available.", 0, 0, "error")
   }

   INIaction(1, "mustRecordSeenImgs", "General")
   friendly := (mustRecordSeenImgs=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Record images seen through QPV: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSkipSeenIMGs() {
   skipSeenImageSlides := !skipSeenImageSlides
   INIaction(1, "skipSeenImageSlides", "General")
   friendly := (skipSeenImageSlides=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Skip already seen images: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAutoResetImageView() {
   If (AnyWindowOpen=10)
      GuiControlGet, resetImageViewOnChange, SettingsGUIA:, resetImageViewOnChange
   Else
      resetImageViewOnChange := !resetImageViewOnChange

   INIaction(1, "resetImageViewOnChange", "General")
   If !AnyWindowOpen
   {
      friendly := (resetImageViewOnChange=1) ? "ACTIVATED" : "DEACTIVATED"
      showTOOLtip("Reset viewing options on image change: " friendly)
      SetTimer, RemoveTooltip, % -msgDisplayTime 
   }
}

toggleListViewModeThumbs() {
   If (thumbsDisplaying!=1)
      Return

   thumbsListViewMode++
   If (thumbsListViewMode>4)
      thumbsListViewMode := 1

   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   If (thumbsListViewMode=1)
      initAHKhThumbThreads()

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
   friendly := defineListViewModes()
   If StrLen(userSearchString)>1
      friendly .= "`nFiles matching search criteria are highlighted:`n" userSearchString

   If (ShowAdvToolbar=1)
      decideIconBTNthumbsList()
   showTOOLtip("List view: " friendly, A_ThisFunc, 1, thumbsListViewMode/4)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

defineListViewModes() {
   ; infoThumbsSize := (thumbsDisplaying=1) ? " (" thumbsW " x " thumbsH " px )" : ""
   If (thumbsListViewMode=1)
      friendly := "THUMBNAILS"
   Else If (thumbsListViewMode=2)
      friendly := "COMPACT"
   Else If (thumbsListViewMode=3)
      friendly := "FILE DETAILS"
   Else If (thumbsListViewMode=4)
      friendly := "IMAGE DETAILS"

   Return friendly
}

ToggleAutoPlaySND() {
   autoPlaySNDs := !autoPlaySNDs
   INIaction(1, "autoPlaySNDs", "General")
   friendly := (autoPlaySNDs=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Auto-play associated sound file: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSyncSlide2sndDuration() {
   syncSlideShow2Audios := !syncSlideShow2Audios
   INIaction(1, "syncSlideShow2Audios", "General")
   friendly := (syncSlideShow2Audios=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Wait for complete playback of audio files during slideshows:`n" friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSlidesTransitions() {
   doSlidesTransitions := !doSlidesTransitions
   INIaction(1, "doSlidesTransitions", "General")
   friendly := (doSlidesTransitions=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Smooth slideshow transitions: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMarkSeenIMGs() {
   highlightAlreadySeenImages := !highlightAlreadySeenImages
   INIaction(1, "highlightAlreadySeenImages", "General")
   friendly := (highlightAlreadySeenImages=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Highlight already seen images: " friendly, A_ThisFunc, 1)
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      dummyTimerDelayiedImageDisplay(50)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TglUseCacheSLDinfo() {
   useCachedSLDdata := !useCachedSLDdata
   INIaction(1, "useCachedSLDdata", "General")
   If (useCachedSLDdata=1)
      showTOOLtip("SQL database cached data will be used to sort the files list", A_ThisFunc, 1)
   Else
      showTOOLtip("SQL database cached data will NOT be used to sort the files list", A_ThisFunc, 1)

   SetTimer, RemoveTooltip, % -msgDisplayTime + 1500
}

TglRvrSort() {
   reverseOrderOnSort := !reverseOrderOnSort
   INIaction(1, "reverseOrderOnSort", "General")
   friendly := (reverseOrderOnSort=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Reverse order on files list sort: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TglCheckDeadFilesSort() {
   OnSortdoFilesCheck := !OnSortdoFilesCheck
   INIaction(1, "OnSortdoFilesCheck", "General")
   friendly := (OnSortdoFilesCheck=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Auto-remove inexistent files on files list sort: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleHistoInfoBoxu() {
   prevState := (showHistogram>1 || showInfoBoxHUD>=1) ? 1 : 0
   imgPath := getIDimage(currentFileIndex)
   If (prevState!=1)
   {
      If ((thumbsDisplaying=1) || (!validBMP(useGdiBitmap()) && !CurrentSLD) || !imgPath)
         Return
   }

   showHistogram := (prevState=0) ? 1 : 0
   showInfoBoxHUD := (prevState=0) ? 1 : 2
   ToggleImgHistogram(1)
   ToggleInfoBoxu()
   RemoveTooltip()
}

ToggleContextStatusBar() {
   showContextualStatusBar := !showContextualStatusBar
   RegAction(1, "showContextualStatusBar",,1)
   SetTimer, dummyRefreshImgSelectionWindow, -50
}

ToggleInfoBoxu() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 85) ; || (thumbsDisplaying=1)
       Return

    showInfoBoxHUD++
    lastInvoked := A_TickCount
    lastInfoBoxZeitToggle := A_TickCount
    showInfoBoxHUD := clampInRange(showInfoBoxHUD, 0, 2, 1)
    INIaction(1, "showInfoBoxHUD", "General")
    If (thumbsDisplaying=1)
       SetTimer, mainGdipWinThumbsGrid, -50
    Else
       SetTimer, dummyRefreshImgSelectionWindow, -50
    ; dummyTimerDelayiedImageDisplay(50)
}

ToggleImgCaptions() {
    Static lastInvoked := 1
    If (slideShowRunning=1)
       ToggleSlideShowu()

    showImgAnnotations := !showImgAnnotations
    INIaction(1, "showImgAnnotations", "General")
    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
    Else
       dummyTimerDelayiedImageDisplay(25)

    If (showImgAnnotations=1)
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       textFile := OutDir "\" OutNameNoExt ".txt"
       If (SLDtypeLoaded=3)
          textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

       If (!FileExist(textFile) && SLDtypeLoaded!=3) || (!textFileContent && SLDtypeLoaded=3)
          showTOOLtip("Display image captions: ACTIVATED`n" OutNameNoExt ".txt (NOT FOUND)`nNo image caption / annotation file associated`nPress Shift+N to create/edit one.", A_ThisFunc, 1)
       Else
          showTOOLtip("Display image captions: ACTIVATED", A_ThisFunc, 1)
    } Else showTOOLtip("Display image captions: DEACTIVATED", A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMultiLineStatus() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 55)
       Return

    lastInvoked := A_TickCount
    multilineStatusBar := !multilineStatusBar
    INIaction(1, "multilineStatusBar", "General")
    dummyTimerDelayiedImageDisplay(50)
    CreateTempGuiButton("File options,,invokeFileOptionsMenu", 0, msgDisplayTime//1.5 + 500)
}

invokeFileOptionsMenu(givenCoords:=0) {
   deleteMenus()
   createMenuCurrentFilesActs("rclick")
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVfilesActs") : givenCoords
   showThisMenu("PVfilesActs")
}

invokeSelectionAreaMenu(modus:=0, givenCoords:=0) {
   deleteMenus()
   createMenuSelectionArea(modus)
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVselv") : givenCoords
   showThisMenu("PVselv")
}

invokeNavigationMenu(givenCoords:=0) {
   deleteMenus()
   createMenuNavigation()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVnav") : givenCoords
   showThisMenu("PVnav")
}

folderzNavLoadAllSiblings() {
   initialFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
   If (SLDtypeLoaded!=1)
      baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

   baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)
   baseFolder := StrReplace(baseFolder, "|")
   If FolderExist(baseFolder)
      OpenFolders(baseFolder)
}

invokeFoldersListerMenu() {
    Static menusList := "PVmFsibs|PVmFsubs|PVmFparents|PVmFexplorer"
    Loop, Parse, menusList, |
        Try Menu, % A_LoopField, Delete

    If (userPrivateMode=1)
    {
       showTOOLtip("WARNING: Private mode is activated. Access to this feature is denied,`nbecause it would be a breach of privacy.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
    If (SLDtypeLoaded!=1)
       baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

    If !InStr(baseFolder, ":\")
       Return "err"

    showTOOLtip("Identifing sibling and parent folders for`n" baseFolder)
    sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
    parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
    If (sibsObj.Count()>1)
    {
       Try Menu, PVmFsibs, Add, &See all, folderzNavLoadAllSiblings
       Try Menu, PVmFsibs, Add,
    }

    Loop, % sibsObj.Count()
    {
       If (A_Index>200)
       {
          Try Menu, PVmFsibs, Add, % "and " sibsObj.Count()  - A_Index " more folders", PanelFoldersTree
          Break
       }

       Try Menu, PVmFsibs, Add, % A_Index ". " sibsObj[A_Index], folderzNavInvokeSib
       If (A_Index=currentSib)
          Try Menu, PVmFsibs, Check, % A_Index ". " sibsObj[A_Index]
    }

    Loop, % parentsObj.Count()
    {
       If (A_Index>200)
       {
          Try Menu, PVmFsibs, Add, % "and " parentsObj.Count()  - A_Index " more folders", PanelFoldersTree
          Break
       }

       Try Menu, PVmFparents, Add, % A_Index ". " parentsObj[A_Index], folderzNavInvokeParents
       If (A_Index=1)
          Try Menu, PVmFparents, Disable, % A_Index ". " parentsObj[A_Index]

       If (A_Index=currentParent)
          Try Menu, PVmFparents, Check, % A_Index ". " parentsObj[A_Index]
    }

    thisFolder := StrReplace(Trimmer(baseFolder), "|")
    If (SLDtypeLoaded=1)
    {
       Menu, PVmFsubs, Add, &See all`tCtrl+F5, invertCurrentFolderRecursiveness
       If !InStr(CurrentSLD, "|")
          Menu, PVmFsubs, Check, &See all`tCtrl+F5
       Menu, PVmFsubs, Add,
    }

    hasAddedSubs := 0
    doStartLongOpDance()
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", DF
       {
          If (determineTerminateOperation()=1)
             Break

          If (A_LoopFileName!="" && InStr(A_LoopFileAttrib, "D"))
          {
             Try Menu, PVmFsubs, Add, % A_Index ". " A_LoopFileName, folderzNavInvokeSubs
             hasAddedSubs++
             If (hasAddedSubs>200)
             {
                Try Menu, PVmFsibs, Add, ... more folders can be listed, PanelFoldersTree
                Break
             }
          }
       }
    }

    ResetImgLoadStatus()
    friendly := (SLDtypeLoaded=1) ? "Currently opened" : "Selected file"
    kMenu("PVmFexplorer", "Add", friendly " folder:", "dummy")
    kMenu("PVmFexplorer", "Disable", friendly " folder:")
    kl := PathCompact(baseFolder, 40)
    Try kMenu("PVmFexplorer", "Add", kl, "OpenQPVfileFolder")
    If (SLDtypeLoaded=1)
       Try kMenu("PVmFexplorer", "Disable", kl)

    Menu, PVmFexplorer, Add
    If (FolderExist(thisFolder) && hasAddedSubs>0)
    {
       Try kMenu("PVmFexplorer", "Add", "Sub-folders", ":PVmFsubs")
    } Else
    {
       kMenu("PVmFexplorer", "Add", "No sub-folders", "dummy")
       kMenu("PVmFexplorer", "Disable", "No sub-folders")
    }

    If (parentsObj.Count()>0)
    {
       Menu, PVmFexplorer, Add
       Try kMenu("PVmFexplorer", "Add", "Breadcrumb folders &hierarchy", ":PVmFparents")
       If (parentsObj.Count()>1 && SLDtypeLoaded=1)
       {
          kMenu("PVmFexplorer", "Add", "Breadcrumb deeper level`tCtrl+Page Down", "MenuFolderExplorerBreadDeeper")
          kMenu("PVmFexplorer", "Add", "Breadcrumb higher level`tCtrl+Page Up", "MenuFolderExplorerBreadHigher")
       }
    }

    If (sibsObj.Count()>0)
    {
       Menu, PVmFexplorer, Add
       Try kMenu("PVmFexplorer", "Add", "Sibling folders", ":PVmFsibs")
       If (SLDtypeLoaded=1)
       {
          kMenu("PVmFexplorer", "Add", "Open next sibling`tAlt+Page Down", "MenuFolderExplorerNextSiblings")
          kMenu("PVmFexplorer", "Add", "Open previous sibling`tAlt+Page Up", "MenuFolderExplorerPrevSiblings")
       }
    } Else
    {
       kMenu("PVmFexplorer", "Add", "No sibling folders", "dummy")
       kMenu("PVmFexplorer", "Disable", "No sibling folders")
    }

    Menu, PVmFexplorer, Add
    If (folderTreeWinOpen!=1)
    {
       kMenu("PVmFexplorer", "Add/UnCheck", "Folders tree view`tF4", "MenuPanelFoldersTree", "window treeview directories explore")
       kMenu("PVmFexplorer", "Add", "Open omnibox at file location`tShift+;", "invokeOmniBoxCurrentFile")
    } Else
    {
       kMenu("PVmFexplorer", "Add/UnCheck", "&Large UI fonts", "folderTreeToggleLargeUIfonts")
       If (PrefsLargeFonts=1)
          kMenu("PVmFexplorer", "Check", "&Large UI fonts")
       kMenu("PVmFexplorer", "Add", "Open omnibox from folder tree item", "fromFolderTreeToOmniBox")
       kMenu("PVmFexplorer", "Add/UnCheck", "Sho&w folder details", "toggleFDtreeInfos")
       If (showFolderTreeDetails=1)
          kMenu("PVmFexplorer", "Check", "Sho&w folder details")
       kMenu("PVmFexplorer", "Add", "Copy folder tree path", "folderTreeCopyPath")
       kMenu("PVmFexplorer", "Add", "Collapse/expand entire folder tree", "folderTreeExpandCollapseAll")
    }

    RemoveTooltip()
    showThisMenu("PVmFexplorer")
    Return "m"
}

MenuFolderExplorerBreadHigher() {
      FileExploreUpDownLevel(-1)
}

MenuFolderExplorerBreadDeeper() {
      FileExploreUpDownLevel(1)
}

MenuFolderExplorerNextSiblings() {
      FileExploreSiblingsNav(1)
}

MenuFolderExplorerPrevSiblings() {
      FileExploreSiblingsNav(-1)
}

folderzNavInvokeSubs(menuItem) {
    baseFolder := (SLDtypeLoaded=1) ? CurrentSLD : resultedFilesList[currentFileIndex, 1]
    If (SLDtypeLoaded!=1)
       baseFolder := SubStr(baseFolder, 1, InStr(baseFolder, "\", 0, -1) - 1)

    oldFolder := baseFolder
    openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
    thisFolder := StrReplace(Trimmer(baseFolder), "|")
    If FolderExist(thisFolder)
    {
       Loop, Files, % thisFolder "\*", DF
       {
          If (A_Index=openThisu && InStr(A_LoopFileAttrib, "D"))
          {
             hasFound := 1
             thisFolder .= "\" A_LoopFileName
             Break
          }
       }
    }
    If (hasFound!=1)
       Return

    tryOpenGivenFolder(thisFolder, oldFolder)
}

tryOpenGivenFolder(thisFolder, oldFolder) {
   oldFolderu := StrReplace(oldFolder, "|")
   thisFolder := StrReplace(thisFolder, "|")
   thisFolder := StrReplace(Trimmer(thisFolder, "\"), "\\", "\")
   If !FolderExist(thisFolder)
   {
      showTOOLtip("ERROR: Folder not found or access denied:`n" thisFolder)
      SoundBeep , 300, 100
      TriggerMenuBarUpdate()
      Return
   }

   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   initially := thisFolder
   newStaticFoldersListCache := []
   maxFilesIndex := 0
   SLDtypeLoaded := 1
   coreOpenFolder("|" thisFolder, 0, 0, 0, 1)
   If (maxFilesIndex<1)
   {
      addJournalEntry("Failed to find image files in: |" thisFolder)
      If !FolderExist(oldFolderu)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have attempted to open: " thisFolder "\. QPV found no supported image files in the folder.`n`nWould you like to recursively scan the given folder for supported image files?", 4, 0, "question")
      Else msgResult := "Yes"

      If (msgResult="Yes" || !FolderExist(oldFolderu))
      {
         coreOpenFolder(thisFolder, 0, 0, 0, 1)
         CurrentSLD := thisFolder
      }
   } Else CurrentSLD := "|" thisFolder

   hasFailed := 0
   If (maxFilesIndex<1 && FolderExist(oldFolderu))
   {
      addJournalEntry("Failed to recursively find image files in: " thisFolder "\`nReopening initial folder: " oldFolder)
      coreOpenFolder(oldFolder, 0, 0, 0, 1)
      CurrentSLD := oldFolder
      hasFailed := 1
   } Else If (maxFilesIndex<1)
      resetMainWin2Welcome()

   If (maxFilesIndex>1)
      prevOpenFolderPath := StrReplace(CurrentSLD, "|")

   currentFilesListModified := 0
   currentFileIndex := clampInRange(oldIndex, 1, maxFilesIndex)
   If maxFilesIndex
      dummyTimerDelayiedImageDisplay(50)

   SetTimer, TriggerMenuBarUpdate, -150
   If (ShowAdvToolbar=1)
      SetTimer, createGUItoolbar, -150

   If (hasFailed=1 || maxFilesIndex<1)
   {
      showDelayedTooltip("WARNING: No image files found in the folder:`n" initially)
      SoundBeep , 300, 100
   } Else RemoveTooltip()
   Return hasFailed
}

folderzNavInvokeSib(menuItem) {
   sibsObj := FileExploreSiblingsNav(1, 0, 1, currentSib)
   openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
   FileExploreSiblingsNav(1, 0, 0, iLevel, openThisu)
   ; ToolTip, % menuItem "-" openThisu "-" c , , , 2

}

folderzNavInvokeParents(menuItem) {
   parentsObj := FileExploreUpDownLevel(1, 1, currentParent)
   openThisu := SubStr(menuItem, 1, InStr(menuItem, ". ")-1)
   FileExploreUpDownLevel(1, 0, prevMaxLevels, openThisu)
   ; ToolTip, % menuItem "==" openThisu "==" c , , , 2
}

ToggleSelectGrid() {
   showSelectionGrid := !showSelectionGrid
   INIaction(1, "showSelectionGrid", "General")
   If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
}

toggleEllipseSelection(modus:=-1) {
   If (editingSelectionNow!=1 && thumbsDisplaying!=1)
   {
      ToggleEditImgSelection()
      Return
   }
   
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   If isNowAlphaPainting()
      Return

   liveDrawingBrushTool := 0
   FloodFillSelectionAdj := 1
   EllipseSelectMode := clampInRange(EllipseSelectMode + 1, 0, 2, 1)
   If isInRange(modus, 0, 2)
      EllipseSelectMode := modus

   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
   If (customShapePoints.Count()<3 && EllipseSelectMode=2)
   {
      RegAction(0, "FillAreaCustomShape",, 5)
      RegAction(0, "FillAreaCurveTension",, 2, 1, 5)
      RegAction(0, "closedLineCustomShape",, 1)
      customShapePoints := convertShapePointsStrToArray(FillAreaCustomShape)
      decideCustomShapeStyle()
      If (customShapePoints.Count()<3)
      {
         MenuStartDrawingSelectionArea()
         Return
      }
   }

   If (imgEditPanelOpened=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)

   ; INIaction(1, "EllipseSelectMode", "General")
   showTOOLtip("Selection area: " DefineVPselAreaMode(), 0, 0, (EllipseSelectMode+1)/3)
   If (EllipseSelectMode=2)
   {
     If (FillAreaCurveTension=1)
        ll := "Polygonal path"
     Else If (FillAreaCurveTension=5)
        ll := "Bézier path"
     Else
        ll := "Points tension: " tensionCurveCustomShape

      dummy := "||" ll ",,togglePathCurveTension"
   }

   If (ShowAdvToolbar=1)
      decideIconBTNselectShape()
   CreateTempGuiButton("Draw new form,,MenuStartDrawingSelectionArea" dummy, 0, msgDisplayTime//1.5 + 500)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleImgSelectionAspectRatio(dummy:=0) {
   If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
      Return

   If (dummy="simple")
      lockSelectionAspectRatio := (lockSelectionAspectRatio>=2) ? 1 : 2
   Else
      lockSelectionAspectRatio := clampInRange(lockSelectionAspectRatio + 1, 1, 10, 1)

   friendly := defineSelectionAspectRatios()
   If (LimitSelectBoundsImg=1)
      infou := "WARNING: The selection area is now no longer limited to the image boundaries"

   LimitSelectBoundsImg := 0
   INIaction(1, "LimitSelectBoundsImg", "General")
   showTOOLtip(infou "Selection area aspect ratio locked to:`n" friendly, 0, 0, lockSelectionAspectRatio/10)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyRefreshImgSelectionWindow()
}

toggleImgSelectLockedRatio() {
   toggleImgSelectionAspectRatio("simple")
}

defineSelectionAspectRatios(doFlipper:=0, modus:=0) {
   Static types := {0:"NONE", 1:"NONE", 2:"CURRENT RATIO", 3:"CURRENT WINDOW", 4:"CURRENT IMAGE", 5:"SQUARE [1:1]", 6:"SDTV [4:3]", 7:"35MM FILM [3:2]", 8:"HDTV [16:9]", 9:"WIDE SCREENS [16:10]", 10:"PHONE"}
        , flipper := 0

   If (doFlipper="yes" && isNumber(modus))
      flipper := modus

   If (!lockSelectionAspectRatio || !isNumber(lockSelectionAspectRatio))
      lockSelectionAspectRatio := 1

   imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   vpWinClientSize(mainWidth, mainHeight)
   If isImgEditingNow()
      trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)

   If (lockSelectionAspectRatio=2 && imgSelW>1 && imgSelH>1)
      desiredSelAspectRatio := imgSelW/imgSelH
   Else If (lockSelectionAspectRatio=3)
      desiredSelAspectRatio := (flipper=1) ? mainHeight/mainWidth : mainWidth/mainHeight
   Else If (lockSelectionAspectRatio=4 && imgW && imgH)
      desiredSelAspectRatio := (flipper=1) ? imgH/imgW : imgW/imgH
   Else If (lockSelectionAspectRatio=5)
      desiredSelAspectRatio := 1
   Else If (lockSelectionAspectRatio=6)
      desiredSelAspectRatio := (flipper=1) ? 3/4 : 4/3
   Else If (lockSelectionAspectRatio=7)
      desiredSelAspectRatio := (flipper=1) ? 2/3 : 3/2
   Else If (lockSelectionAspectRatio=8)
      desiredSelAspectRatio := (flipper=1) ? 9/16 : 16/9
   Else If (lockSelectionAspectRatio=9)
      desiredSelAspectRatio := (flipper=1) ? 10/16 : 16/10
   Else If (lockSelectionAspectRatio=10)
      desiredSelAspectRatio := (flipper=1) ? 2.14567 : 0.46543
   Else
      desiredSelAspectRatio := 0

   If (lockSelectionAspectRatio=10 || isInRange(lockSelectionAspectRatio, 2, 4))
      friendly := " [" Round(desiredSelAspectRatio, 2) "]"

   If (lockSelectionAspectRatio=3 || lockSelectionAspectRatio=4 || isInRange(lockSelectionAspectRatio, 6, 10))
      friendly .= " - flipped"

   Return types[lockSelectionAspectRatio] friendly
}

ToggleRecordOpenHistory() {
   allowRecordHistory := !allowRecordHistory
   INIaction(1, "allowRecordHistory", "General")
   friendly := (allowRecordHistory=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Record history of opened files and folders: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ; If !allowRecordHistory
   ;    EraseOpenedHistory()
}

focusVectorEndPoint() {
   zn := 0
   getVPcoordsVectorPoint(customShapePoints.Count(), kx, ky)
   p := focusImgSelArea(kx - prevDestPosX, ky - prevDestPosY, "yes", 1)
   If (!p && customShapeHasSelectedPoints=1)
   {
      Loop, % customShapePoints.Count()
      {
         If (customShapePropPoints[A_Index, 1]=1)
         {
            zn := A_Index
            Break
         }
      }

      If zn 
      {
         getVPcoordsVectorPoint(zn, kx, ky)
         focusImgSelArea(kx - prevDestPosX, ky - prevDestPosY, "yes", 1)
      }
   }
}

focusImgSelArea(zx:=0, zy:=0, isGiven:=0, doCenter:=0) {
   nImgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := min(imgSelY1, imgSelY2)
   gX := Round(nImgSelX1*zoomLevel)
   gY := Round(nImgSelY1*zoomLevel)

   zImgSelX1 := prevDestPosX + Round(nImgSelX1*zoomLevel)
   zImgSelY1 := prevDestPosY + Round(nImgSelY1*zoomLevel)
   If (isGiven="yes")
   {
      gX := zx
      gY := zy
      zImgSelX1 := prevDestPosX + zx
      zImgSelY1 := prevDestPosY + zy
   }

   vpWinClientSize(mainWidth, mainHeight)
   cX := (doCenter=1) ? mainWidth//2 : 150
   cY := (doCenter=1) ? mainHeight//2 : 150
   If (zImgSelX1<10 || zImgSelX1>mainWidth - 10)
   {
      hasu := 1
      IMGdecalageX := -(gX - cX)
   }

   If (zImgSelY1<10 || zImgSelY1>mainHeight)
   {
      hasu := 1
      IMGdecalageY := -(gY - cY)
   }

   If (forced=1)
   {
      IMGdecalageX := -(gX - cX)
      IMGdecalageY := -(gY - cY)
   }
   ; ToolTip, % gX "|" gY "|" zImgSelX1 "|" zImgSelY1 "|" imageAligned "|" tX "|" tY , , , 2
   ; ToolTip, % IMGdecalageX "|" IMGdecalageY "|" imageAligned "|" tX "|" tY "`n" prevDestPosX "|" prevDestPosY "|" prevResizedVPimgW "|" prevResizedVPimgH  , , , 2
   dummyTimerDelayiedImageDisplay(50)
   ; ToolTip, % selDotX "|" selDotY "`n" selDotAx "|" selDotAy "||`n" zImgSelX1 "|" zImgSelY1 "`n" zImgSelX2 "|" zImgSelY2 , , , 2
   Return hasu
}

toggleLimitSelection() {
   If (showViewPortGrid!=1 && editingSelectionNow!=1) || (thumbsDisplaying=1) || (liveDrawingBrushTool=1 && editingSelectionNow=1)
      Return

   LimitSelectBoundsImg := !LimitSelectBoundsImg
   If (lockSelectionAspectRatio>1)
      infou := "WARNING: The selection area aspect ratio is now no longer locked.`n"

   lockSelectionAspectRatio := 1
   INIaction(1, "LimitSelectBoundsImg", "General")
   friendly1 := (LimitSelectBoundsImg=1) ? "ACTIVATED" : "DEACTIVATED"
   friendly2 := (editingSelectionNow=1) ? "selection area" : "viewport grid"
   showTOOLtip(infou "Limit " friendly2 " to image boundaries: " friendly1, A_ThisFunc, 1)
   If (imgEditPanelOpened=1 && showViewPortGrid!=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAlwaysFIMus() {
   alwaysOpenwithFIM := !alwaysOpenwithFIM
   r := initFIMGmodule()
   If InStr(r, "err - 126")
      friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2015."
   Else If InStr(r, "err - 404")
      friendly := "`n`nThe FreeImage.dll file seems to be missing..."

   INIaction(1, "alwaysOpenwithFIM", "General")
   If (FIMfailed2init=1)
      msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Various image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
   Else If (thumbsDisplaying!=1 && CurrentSLD && maxFilesIndex>0 && !validBMP(UserMemBMP))
      RefreshImageFileAction()
}

ToggleAnimGIFsupport() {
   animGIFsSupport := !animGIFsSupport
   INIaction(1, "animGIFsSupport", "General")
   friendly := (animGIFsSupport=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Automatically play animated GIFs: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleWICloader() {
   initQPVmainDLL()
   allowWICloader := (WICmoduleHasInit=1) ? !allowWICloader : 0
   friendly := (allowWICloader=1) ? "ACTIVATED" : "DEACTIVATED"
   If (WICmoduleHasInit!=1)
      friendly := "`nFAILED TO INITIALIZE"
   showTOOLtip("Load images through WIC: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TogglePrivateMode() {
   userPrivateMode := !userPrivateMode
   friendly := (userPrivateMode=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Private mode: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying!=1 && isImgEditingNow() && FileExist(getIDimage(currentFileIndex)) && undoLevelsRecorded<2)
      RefreshImageFileAction()

   dummyTimerReloadThisPicture(100)
   ; dummyTimerDelayiedImageDisplay(100)
}

ToggleFIMloader() {
   initFIMGmodule()
   allowFIMloader := (wasInitFIMlib=1) ? !allowFIMloader : 0
   friendly := (allowFIMloader=1) ? "ACTIVATED" : "DEACTIVATED"
   If (wasInitFIMlib!=1)
      friendly := "`nFAILED TO INITIALIZE"
   showTOOLtip("Allow images to load through FreeImage: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAutoRemEntries() {
   autoRemDeadEntry := !autoRemDeadEntry
   INIaction(1, "autoRemDeadEntry", "General")
   friendly := (autoRemDeadEntry=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Automatically remove entries to inexistent files: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

TogglePromptDelete() {
   askDeleteFiles := !askDeleteFiles
   INIaction(1, "askDeleteFiles", "General")
   friendly := (askDeleteFiles=1) ? "ACTIVATED" : "DEACTIVATED"
   showTOOLtip("Prompt before deleting files: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleTitleBaruNow() {
   If (getCaptionStyle(PVhwnd)=0)
   {
      isTitleBarVisible := 0
      ; If (editingSelectionNow=1)
      ;    ToggleEditImgSelection()
      WinSet, Style, -0xC00000, ahk_id %PVhwnd%
   } Else
   {
      isTitleBarVisible := 1
      WinSet, Style, +0xC00000, ahk_id %PVhwnd%
   }
   interfaceThread.ahkassign("isTitleBarVisible", isTitleBarVisible)
   interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
   INIaction(1, "isTitleBarVisible", "General")
   ; INIaction(1, "TouchScreenMode", "General")
   ; If (isTitleBarVisible=0)
   If (drawingShapeNow!=1)
      SetTimer, dummyToggleTitleBarActionBtns, -350
}

dummyToggleTitleBarActionBtns() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  friendly := Trimmer(friendly)
  showTOOLtip(friendly)
  If (getCaptionStyle(PVhwnd)!=1)
     CreateTempGuiButton("Interface options,,OpenUImenu", "force", msgDisplayTime + 500)

  SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMenuBaru() {
   Critical, on
   Static lastInvoked := 1
   hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
   showMainMenuBar := !showMainMenuBar
   INIaction(1, "showMainMenuBar", "General")
   interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
   interfaceThread.ahkassign("ShowAdvToolbar", ShowAdvToolbar)
   interfaceThread.ahkassign("lockToolbar2Win", lockToolbar2Win)
   interfaceThread.ahkassign("hQPVtoolbar", hQPVtoolbar)
   If !showMainMenuBar
      Win_SetMenu(PVhwnd, 0)

   TriggerMenuBarUpdate("forced")
   If hasTrans
      SetTimer, tlbrResetPosition, -300, 100

   SetTimer, refreshEntireViewport, -400
   lastInvoked := A_TickCount
   If (panelWinCollapsed=1 && AnyWindowOpen)
      SetTimer, collapseWidgetGUIAGuiEscape, -25
}

ToggleTitleBaru() {
    SetTimer, ToggleTitleBaruNow, -150
}

ToggleLargeUIfonts() {
    If (AnyWindowOpen=31 || AnyWindowOpen=24)
    {
       showTOOLtip("WARNING: This option cannot be changed while the transform tool is activated.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If isNowAlphaPainting()
    {
       showTOOLtip("WARNING: This option cannot be changed while alpha mask painting mode is activated.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    PrefsLargeFonts := !PrefsLargeFonts
    calcHUDsize()
    INIaction(1, "PrefsLargeFonts", "General")
    interfaceThread.ahkassign("PrefsLargeFonts", PrefsLargeFonts)
    thisFunc := prevOpenedWindow[2]
    AddTooltip2Ctrl("reset")
    If (VisibleQuickMenuSearchWin=1)
    {
       closeQuickSearch()
       SetTimer, PanelQuickSearchMenuOptions, -150
    }

    If (AnyWindowOpen=16)
    {
       BtnCloseWindow()
       Sleep, 5
       PanelMultiFileDelete()
    } Else If (AnyWindowOpen && thisfunc)
    {
       BtnCloseWindow()
       Sleep, 5
       openPreviousPanel("forced")
    } Else
    {
       friendly := (PrefsLargeFonts=1) ? "ACTIVATED" : "DEACTIVATED"
       showTOOLtip("Large user interface fonts: " friendly, A_ThisFunc, 1)
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
}

ToggleTexyBGR() {
    usrTextureBGR := !usrTextureBGR
    INIaction(1, "usrTextureBGR", "General")
    friendly := (usrTextureBGR=1) ? ambiTexBrushSize " px" : "DEACTIVATED"
    SetTimer, RefreshImageFile, -5
    showDelayedTooltip("Viewport ambiental texture: " friendly, A_ThisFunc, 1)
}

ToggleCustomKBDsMode() {
    allowCustomKeys := !allowCustomKeys
    INIaction(1, "allowCustomKeys", "General")
    friendly := (allowCustomKeys=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("User customized keyboard shortcuts: " friendly, A_ThisFunc, 1)
    loadCustomUserKbds()
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleDarkModus() {
    If (AnyWindowOpen=31 || AnyWindowOpen=24)
    {
       showTOOLtip("WARNING: This option cannot be changed while the transform tool is activated.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If isNowAlphaPainting()
    {
       showTOOLtip("WARNING: This option cannot be changed while alpha mask painting mode is activated.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    uiUseDarkMode := !uiUseDarkMode
    If ((isWinXP=1 || A_OSVersion="WIN_7") && uiUseDarkMode=1)
       msgBoxWrapper(appTitle ": WARNING", "This option was not optimized for your operating system.", 0, 0, "exclamation")

    INIaction(1, "uiUseDarkMode", "General")
    friendly := (uiUseDarkMode=1) ? "ACTIVATED" : "DEACTIVATED"
    AddTooltip2Ctrl("reset")
    setMenusTheme(uiUseDarkMode)
    interfaceThread.ahkPostFunction("destroyMenuFlyout")
    showDelayedTooltip("Dark mode: " friendly)
    thisFunc := prevOpenedWindow[2]
    If (VisibleQuickMenuSearchWin=1)
    {
       closeQuickSearch()
       SetTimer, PanelQuickSearchMenuOptions, -200
    }

    ; tabzDarkModus := (uiUseDarkMode=1) ? "-Border +Buttons cFFFFaa" : ""
    If (AnyWindowOpen && thisfunc)
    {
       BtnCloseWindow()
       Sleep, 5
       openPreviousPanel("forced")
    }
}

ToggleToolbarLockPositionWin() {
    lockToolbar2Win := !lockToolbar2Win
    INIaction(1, "lockToolbar2Win", "General")
    friendly := (lockToolbar2Win=1) ? "ATTACHED to the main window" : "DETACHED from the main window"
    If (lockToolbar2Win=1)
       tlbrResetPosition()

    interfaceThread.ahkassign("lockToolbar2Win", lockToolbar2Win)
    showDelayedTooltip("Toolbar position: `n" friendly, A_ThisFunc, 1)
    SetTimer, refreshEntireViewport, -350
 }

ToggleImgNavBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50)
       Return

    showHUDnavIMG := !showHUDnavIMG
    INIaction(1, "showHUDnavIMG", "General")
    dummyTimerDelayiedImageDisplay(25)
    SetTimer, dummyNavBoxInfo, -150
    lastInvoked := A_TickCount
}

ToggleImgNavSizeBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (showHUDnavIMG!=1)
       Return

    HUDnavBoxSize := (HUDnavBoxSize=75) ? 125 : 75
    RegAction(1, "HUDnavBoxSize")
    If (thumbsDisplaying=1)
       mainGdipWinThumbsGrid()
    Else
       dummyTimerDelayiedImageDisplay(25)
    lastInvoked := A_TickCount
}

dummyNavBoxInfo() {
    friendly := (IMGlargerViewPort=1) ? "" : "`nThe navigator will be displayed`nwhen the image is larger than the viewport."
    If (thumbsDisplaying=1)
       friendly := ""

    labelu := (thumbsDisplaying=1) ? "preview" : "navigator"
    If (showHUDnavIMG=1)
       showTOOLtip("Image " labelu " display: AUTO" friendly, "ToggleImgNavBox", 1)
    Else
       showTOOLtip("Image " labelu ": OFF", "ToggleImgNavBox", 1)

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

tlbrVectorDrawingModeContextMenu() {
   createContextMenuCustomShapeDrawing(0, 0, 0, 0, 0, "tlbr")
}

invokeHistoMenu(givenCoords:=0) {
   deleteMenus()
   createMenuVPhudHisto()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVimgHistos") : givenCoords
   showThisMenu("PVimgHistos")
}

InvokeMenuImgSizeVP(givenCoords:=0) {
   deleteMenus()
   createMenuImgSizeAdapt()
   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PvImgAdapt") : givenCoords
   showThisMenu("PvImgAdapt")
}

invokeMenuNavBoxImgSizeVP(givenCoords:=0) {
   deleteMenus()
   If (thumbsDisplaying=1)
      createMenuNavBox()
   Else
      createMenuImgSizeAdapt("bonus")

   globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PvImgAdapt") : givenCoords
   showThisMenu("PvImgAdapt")
}

ToggleImgHistogram(direction:=1, dummy:=0) {
    Static lastInvoked := 1
    If ((A_TickCount - lastInvoked < 50) || thumbsDisplaying=1 || dummy="rClick" || !isImgEditingNow())
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    showHistogram := (direction=1) ? showHistogram + 1 : showHistogram - 1
    showHistogram := clampInRange(showHistogram, 1, 6, 1)
    If (dummy="normal" && showHistogram=1)
       showHistogram := 2

    msgu := (showHistogram>1) ? "Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode() : "Histogram: NONE"
    INIaction(1, "showHistogram", "General")
    If (showHistogram>1)
       showTOOLtip(msgu, A_ThisFunc, 2, (showHistogram - 0.999)/5)
    Else
       showTOOLtip("Histogram: NONE", A_ThisFunc, 2, 0.001/6)

    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, showHistogram, % showHistogram
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
    lastInvoked := A_TickCount
}

ToggleHistogramMode() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 || showHistogram<=1)
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    lastInvoked := A_TickCount
    histogramMode := clampInRange(histogramMode + 1, 1, 3, 1)
    INIaction(1, "histogramMode", "General")
    showTOOLtip("Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode(), 0, 0, histogramMode/3)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, histogramMode, % histogramMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

defineHistogramType() {
    If (showHistogram=1)
       friendly := "NONE"
    Else If (showHistogram=2)
       friendly := "LUMINANCE"
    Else If (showHistogram=3)
       friendly := "RED"
    Else If (showHistogram=4)
       friendly := "GREEN"
    Else If (showHistogram=5)
       friendly := "BLUE"
    Else If (showHistogram=6)
       friendly := "ALL MIXED"

    Return friendly
}

defineHistogramMode() {
    If (histogramMode=1)
       friendly := "LOWS"
    Else If (histogramMode=2)
       friendly := "BALANCED"
    Else If (histogramMode=3)
       friendly := "PEAKS"

    Return friendly
}

ToggleThumbsCaching() {
    enableThumbsCaching := !enableThumbsCaching
    INIaction(1, "enableThumbsCaching", "General")
    friendly := (enableThumbsCaching=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Image thumbnails caching on disk: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleKeepAlphMask() {
    keepUserPaintAlphaMask := !keepUserPaintAlphaMask
    friendly := (keepUserPaintAlphaMask=1) ? "ACTIVATED`nIt will be available between different tool sessions" : "DEACTIVATED`nIt will be discarded once the current tool session ends"
    showTOOLtip("Keep user painted alpha mask: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleSkipDeadFiles() {
    skipDeadFiles := !skipDeadFiles
    INIaction(1, "skipDeadFiles", "General")
    friendly := (skipDeadFiles=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Skip inexistent files in image view: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleFilesMap() {
    showFilesListMap := !showFilesListMap
    INIaction(1, "showFilesListMap", "General")
    friendly := (showFilesListMap=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Display selected files list map on scrollbar click: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleIgnoreSLDprefs() {
    MustLoadSLDprefs := !MustLoadSLDprefs
    INIaction(1, "MustLoadSLDprefs", "General")
}

toggleFDtreeInfos() {
    showFolderTreeDetails := !showFolderTreeDetails
    INIaction(1, "showFolderTreeDetails", "General")
    friendly := (showFolderTreeDetails=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Folder details in status bar: " friendly, A_ThisFunc, 1)
    If (folderTreeWinOpen=1)
       folderTreeInfoStatusLineUpdater()
}

ToggleCycleFavesOpen() {
    cycleFavesOpenIMG := !cycleFavesOpenIMG
    INIaction(1, "cycleFavesOpenIMG", "General")
    friendly := (cycleFavesOpenIMG=1) ? "The favourites list will be opened when one of the 15 entries is opened." : "The containing folder of the favourite image will be opened."
    showTOOLtip(friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgQuality(modus:=0) {
    userimgQuality := !userimgQuality
    If (modus="lowu")
       userimgQuality := 0
    Else If (modus="highu")
       userimgQuality := 1
    Else
       INIaction(1, "userimgQuality", "General")

    fnOutputDebug("Set viewport quality: " modus "--" forceIT "==" userimgQuality)
    imgQuality := (userimgQuality=1) ? 6 : 5
    PixelMode := (userimgQuality=1) ? 2 : 0
    smoothMode := (userimgQuality=1) ? 4 : 1
    compositingQuality := 1 ; (userimgGammaCorrect=1) ? 2 : 1

    Gdip_SetInterpolationMode(glPG, imgQuality)
    Gdip_SetPixelOffsetMode(glPG, 2)
    Gdip_SetSmoothingMode(glPG, smoothMode)
    Gdip_SetCompositingQuality(glPG, compositingQuality)

    Gdip_SetInterpolationMode(2NDglPG, imgQuality)
    Gdip_SetPixelOffsetMode(2NDglPG, 2)
    Gdip_SetSmoothingMode(2NDglPG, smoothMode)
    Gdip_SetCompositingQuality(2NDglPG, compositingQuality)
}

toggleImgEditGammaCorrect() {
    userimgGammaCorrect := !userimgGammaCorrect
    INIaction(1, "userimgGammaCorrect", "General")
    friendly := (userimgGammaCorrect=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Gamma correction for image editing: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    If isVarEqualTo(AnyWindowOpen, 23, 24, 31, 32)
       GuiControl, SettingsGUIA:, userimgGammaCorrect, % userimgGammaCorrect
    Else If (imgEditPanelOpened=1 && AnyWindowOpen>0)
       livePreviewsImageEditing()
}

toggleScreenSaverMode() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked<600)
       Return

    screenSaverMode := !screenSaverMode
    SoundBeep , % (screenSaverMode=1) ? 900 : 300, 100
    If (screenSaverMode=1)
       SetTimer, drawWelcomeImg, -50
    Else
       SetTimer, drawWelcomeImg, Off

    lastInvoked := A_TickCount
}

ToggleRAWquality() {
    userHQraw := !userHQraw
    INIaction(1, "userHQraw", "General")
    friendly := (userHQraw=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Load Camera RAW images at high quality: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleCustomaToolbara() {
    userCustomizedToolbar := !userCustomizedToolbar
    listuIcons := (thumbsDisplaying=1) ? Trim(userThumbsToolbarList, ",") : Trim(userImgViewToolbarList, ",")
    listu := StrSplit(listuIcons, ",")
    If (!InStr(listuIcons, ",") || listu.Count()<2)
    {
       f := "WARNING: No custom toolbar was defined.`n"
       userCustomizedToolbar := 0
    }

    INIaction(1, "userCustomizedToolbar", "General")
    friendly := (userCustomizedToolbar=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip(f "Custom defined toolbar: " friendly, A_ThisFunc, 1)
    If (ShowAdvToolbar=1)
       createGUItoolbar("forced")
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleFreePanning() {
    If (thumbsDisplaying=1)
       Return

    allowFreeIMGpanning := !allowFreeIMGpanning
    INIaction(1, "allowFreeIMGpanning", "General")
    friendly := (allowFreeIMGpanning=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Allow image panning exceed the viewport area: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    IMGdecalageX := IMGdecalageY := 1
    PrintPosX := "C"
    dummyTimerDelayiedImageDisplay(90)
}

ToggleAutoPlaySlidesMusic() {
    autoPlaySlidesAudio := !autoPlaySlidesAudio
    INIaction(1, "autoPlaySlidesAudio", "General")
    friendly := (autoPlaySlidesAudio=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Automatically play music during slideshows: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleLockZoom() {
    lockZoomLevel := !lockZoomLevel
    customZoomAdaptMode := 0
    ; INIaction(1, "lockZoomLevel", "General")
    friendly := (lockZoomLevel=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Lock to current zoom level: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleCustomZLadaptH() {
    ToggleImageSizingMode("cus-h")
}

toggleCustomZLadaptW() {
    ToggleImageSizingMode("cus-w")
}

toggleCustomZLmodes() {
   If (thumbsDisplaying=1)
      Return

   If (customZoomAdaptMode=2 || zoomLevel!=1 && customZoomAdaptMode=0)
      ToggleImageSizingMode("cus-tom")
   Else If (customZoomAdaptMode=1)
      ToggleImageSizingMode("cus-h")
   Else If (customZoomAdaptMode=0)
      ToggleImageSizingMode("cus-w")
}

ToggleLimitMemUsage() {
    minimizeMemUsage := !minimizeMemUsage
    INIaction(1, "minimizeMemUsage", "General")
    If (minimizeMemUsage=1)
    {
       msgBoxWrapper(appTitle ": WARNING", "By limiting memory usage, the performance of Quick Picto Viewer will likely be drastically reduced. Additionally, some features or functions might be disabled.", 0, 0, "exclamation")
       discardViewPortCaches()
    }
}

TogglePreventUndos() {
    preventUndoLevels := !preventUndoLevels
    maxMemUndoLevels := (preventUndoLevels=1) ? 100 : 979394
    friendly := (preventUndoLevels=1) ? "DEACTIVATED" : "ACTIVATED"
    showTOOLtip("Record image undo levels: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    IniAction(1, "preventUndoLevels", "General", 1)
}

ToggleImgColorDepthDithering() {
    ColorDepthDithering := !ColorDepthDithering
    INIaction(1, "ColorDepthDithering", "General")
    If (thumbsDisplaying!=1)
       RefreshImageFile()

    friendly := (ColorDepthDithering=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Color depth dithering: " friendly, A_ThisFunc, 1)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleAppToolbar() {
    ShowAdvToolbar := !ShowAdvToolbar
    INIaction(1, "ShowAdvToolbar", "General")
    interfaceThread.ahkassign("ShowAdvToolbar", ShowAdvToolbar)
    createGUItoolbar()
    If (ShowAdvToolbar=1)
    {
       WinGetPos, thisX, thisY, ToolbarWinW, ToolbarWinH, ahk_id %hQPVtoolbar%
       WinSet, Region,, ahk_id %hQPVtoolbar%
       redrawToolbarGUI()
       Loop, % tlbrIconzList["counter"]
           GuiControl, OSDguiToolbar: +Redraw, tlbrValueIcon%A_Index%
    }
    If (lockToolbar2Win=1 && ShowAdvToolbar=1)
       tlbrResetPosition()

    SetTimer, refreshEntireViewport, -400
    SetTimer, fromCurrentPanelToColorsSwatch, -150
    If (panelWinCollapsed=1 && AnyWindowOpen)
       SetTimer, collapseWidgetGUIAGuiEscape, -25
}

ToggleToolBarToolTips() {
    ShowToolTipsToolbar := !ShowToolTipsToolbar
    RegAction(1, "ShowToolTipsToolbar", "General")
    friendly := (ShowToolTipsToolbar=1) ? "ACTIVATED" : "DEACTIVATED"
    showTOOLtip("Toolbar tooltips: " friendly)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleToolBarViewModa() {
    toolbarViewerMode := !toolbarViewerMode
    IniAction(1, "toolbarViewerMode", "General")
    If (ShowAdvToolbar=1)
       createGUItoolbar()

    SetTimer, refreshEntireViewport, -350
}

ToggleTouchMode() {
    DestroyTempBtnGui("now")
    TouchScreenMode := !TouchScreenMode
    updateUIctrl()
    interfaceThread.ahkassign("isTitleBarVisible", isTitleBarVisible)
    interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
    INIaction(1, "TouchScreenMode", "General")
    INIaction(1, "isTitleBarVisible", "General")
    friendly := (TouchScreenMode=1) ? "ACTIVATED" : "DEACTIVATED"
    If (TouchScreenMode=1)
       friendly .= "`nThe viewport is now split into different responsive areas.`nSee the Help menu for more details."

    showTOOLtip("Touch screen mode: " friendly)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

defineWinTitlePrefix() {
   Static FXmodesLabels := {2:"cP", 3:"cAUTO", 4:"cGR", 5:"cR", 6:"cG", 7:"cB", 8:"cA", 9:"cI"}

   If (validBMP(UserMemBMP) && thumbsDisplaying!=1)
      winPrefix .= "IMAGE EDITING | "

   If StrLen(filesFilter)>1
      winPrefix .= "F "

   If hSNDmedia
      winPrefix .= "(A) "

   If (editingSelectionNow=1 && thumbsDisplaying!=1)
      winPrefix .= "SEL "

   If (slideShowRunning=1)
   {
      winPrefix .= "s"
      If (SlideHowMode=1)
         winPrefix .= "R "
      Else If (SlideHowMode=2)
         winPrefix .= "B "
      Else If (SlideHowMode=3)
         winPrefix .= "F "
   }

   If (usrColorDepth>1)
      winPrefix .= internalColorDepth  " bits "

   If (FlipImgV=1)
      winPrefix .= "V "
   If (FlipImgH=1)
      winPrefix .= "H "

   If FXmodesLabels.HasKey(imgFxMode)
      winPrefix .= FXmodesLabels[imgFxMode] A_Space

   If (IMGresizingMode=3 && thumbsDisplaying!=1)
      winPrefix .= "O "
   Else If (IMGresizingMode=4 && thumbsDisplaying!=1)
      winPrefix .= "Z "

   Return winPrefix
}

calculateTouchMargins(ByRef thisX, ByRef thisY, ByRef thisW, ByRef thisH) {
   vpWinClientSize(mainWidth, mainHeight)
   thisX := (editingSelectionNow=1) ? mainWidth//8 : mainWidth//7
   thisY := (editingSelectionNow=1) ? mainHeight//6 : mainHeight//5
   thisW := mainWidth - thisX*2
   thisH := mainHeight - thisY*2
}

drawWelcomeImg() {
    Critical, on
    ; SetTimer, detectTooltips, 200
    thisClippyIMG := isImgEditingNow()
    If (maxFilesIndex>0 || thisClippyIMG=1 || StrLen(CurrentSLD)>1 || AnyWindowOpen>0)
    {
       screenSaverMode := 0
       Return
    }

    If (A_TickCount - scriptStartTime>550)
    {
       If (identifyThisWin()!=1)
       {
          screenSaverMode := 0
          Return
       }
    }

    thisZeit := A_TickCount
    vpWinClientSize(mainWidth, mainHeight)
    Random, modelu, 1, 8
    If (modelu=8)
       Random, modelu, 1, 8

    Random, moduz, 1, 9
    Random, iterations, 10, 30
    Random, sweepRand, 1, 9

    ; pBr4 := Gdip_BrushCreateSolid("0x55030201")
    BMPcache := coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, mainWidth, mainHeight, 5, 5, 1)
    If !validBMP(BMPcache)
    {
       Gdip_DeleteBrush(pBr4)
       addJournalEntry("Welcome screen failed to render... mainBMP=" BMPcache " -- pG=" G)
       setWindowTitle(appTitle " v" appVersion, 1)
       SetTimer, drawWelcomeImg, Off
       Return
    }

    createGDIPcanvas()
    getColors := (imgFxMode=3 || imgFxMode=8) ? 0 : 1
    If (getColors=1)
       decideGDIPimageFX(matrix, imageAttribs, zEffect)

    If !isWinXP
       pEffect := Gdip_CreateEffect(1, 3, 0, 0)

    If pEffect
       Gdip_BitmapApplyEffect(BMPcache, pEffect)

    r1 := trGdip_DrawImage(A_ThisFunc, glPG, BMPcache, 0, 0, mainWidth, mainHeight, 0, 0, mainWidth, mainHeight,,, imageAttribs)
    Gdip_AddPathGradient(glPG, 0, 0, mainWidth, mainHeight, mainWidth//2, mainHeight//2, "0x00000000", "0x65010101", 1, 0, 0, 1)
    Gdip_DisposeImageAttributes(imageAttribs)
    If (TouchScreenMode=1 && screenSaverMode!=1)
    {
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//11
       Penuha := Gdip_CreatePen("0x34334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x05EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x10778877)
       Gdip_FillRectangle(glPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(glPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(glPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)

       Gdip_SetClipRect(glPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(glPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(glPG)
       Gdip_DrawRectangle(glPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(glPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)
    }

    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
    trGdip_DisposeImage(BMPcache, 1)
    Gdip_DeleteBrush(pBr4)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    ; updateUIctrl()
    runningLongOperation := 0
    mustAbandonCurrentOperations := imageLoading := 0
    changeMcursor("normal-extra")
    addJournalEntry("Welcome screen rendered in " A_TickCount - thisZeit " ms." r2 " - " r1)
    setWindowTitle(appTitle " v" appVersion, 1)
    If (A_TickCount - thisZeit<250) || (screenSaverMode=1)
       SetTimer, drawWelcomeImg, -3500
    Else
       SetTimer, drawWelcomeImg, Off
}

coredrawWelcomeImg(modelu, iterations, moduz, sweepRand, mainWidth, mainHeight, minX, minY, startMode, previewMode:=0, usePrevious:=0) {
    Static prevObj := [], prevBMPu, prevState

    If (modelu="kill")
    {
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       prevState := 0
       Return
    }

    ; ToolTip, % modelu "|" moduz "|" iterations , , , 2
    kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    thisState := "a" kimgSelW kimgSelH AnyWindowOpen VPselRotation FillAreaInverted FillAreaWelcomePattern modelu iterations moduz sweepRand minX minY startMode previewMode usePrevious
    If (thisState=prevState && previewMode=1 && validBMP(prevBMPu))
       Return trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
 
    prevState := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    BMPcache := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, coreDesiredPixFmt)
    If validBMP(BMPcache)
    {
       compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
       If (userimgQuality!=1 && previewMode=1) || (previewMode=1) || (startMode=1 && userimgQuality!=1)
          G := trGdip_GraphicsFromImage(A_ThisFunc, BMPcache, 1, 3,, compositingQuality)
       Else
          G := trGdip_GraphicsFromImage(A_ThisFunc, BMPcache, 7, 4,, compositingQuality)
    }

    If (!validBMP(BMPcache) || !G)
    {
       prevState := 0
       trGdip_DisposeImage(BMPcache, 1)
       Return
    }

    If (usePrevious=1 && prevObj.type!=modelu)
       usePrevious := 0

    If (usePrevious!=1)
    {
       scaleuX := scaleuY := 1
       prevObj.type := modelu
       prevObj.mW := mainWidth
       prevObj.mH := mainHeight
       Random, a, 22, 66
       Random, b, 22, 66
       Random, c, 22, 66
       Random, d, 66, 99
       Random, anglu, 0.0, 24.5
       If (startMode!=1)
          anglu := VPselRotation ; + anglu/12
       prevObj.a := a
       prevObj.b := b
       prevObj.c := c
       prevObj.d := d
       prevObj.anglu := anglu
    } Else
    {
       scaleuX := prevObj.mW/mainWidth
       scaleuY := prevObj.mH/mainHeight
    }

    pBr1 := Gdip_BrushCreateSolid("0x" prevObj.a "882211")
    pBr2 := Gdip_BrushCreateSolid("0x" prevObj.b "112288")
    pBr3 := Gdip_BrushCreateSolid("0x" prevObj.c "118822")
    pBr5 := Gdip_BrushCreateSolid("0x" prevObj.d "939291")
    ; MsgBox, % minX "--" minY "`n" mainWidth "--" mainHeight "`n" bgrBrush
    If (GetKeyState("CapsLock", "T") && startMode=1)
       Gdip_FillRectangle(G, pBr5, 0, 0, mainWidth, mainHeight)
    ; Else If (startMode!=1)
    ;    Gdip_FillRectangle(G, bgrBrush, 0, 0, mainWidth, mainHeight)

    If (startMode=1)
       trGdip_GraphicsClear(A_ThisFunc, G, "0xFF" WindowBgrColor)

    Gdip_SetClipRect(G, 0, 0, mainWidth, mainHeight)
    cX := 0 + (mainWidth / 2)
    cY := 0 + (mainHeight / 2)
    pMatrix := Gdip_CreateMatrix()
    Gdip_TranslateMatrix(pMatrix, -cX , -cY)
    Gdip_RotateMatrix(pMatrix, prevObj.anglu, 1)
    Gdip_TranslateMatrix(pMatrix, cX, cY, 1)
    Gdip_SetWorldTransform(G, pMatrix)
    Gdip_DeleteMatrix(pMatrix)
    If (modelu=1)
    {
       ; rects
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % minY, % mainHeight
             Random, w, % minX, % mainWidth
             Random, h, % minY, % mainHeight
             w += 10
             h += 10
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          ; MsgBox, % xPos "--" yPos "`n" w "--" h "`n" tBrsh
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=2)
    {
       ; ellipses
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % minY, % mainHeight
             Random, w, % minX, % mainWidth//2 + mainHeight//2
             w += 5
             h := w
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=3 || modelu=5)
    {
       ; ellipses attached to corners
       ; Random, moduz, 1, 9
       Loop, % iterations
       {  
          If (usePrevious!=1)
          {
             Random, w, 5, % mainWidth//1.5 + mainHeight//1.5
             w += 5
             h := w
             Random, deviation, -25, 25
             If (modelu=5)
                Random, moduz, 1, 9

             If (moduz=1)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else If (moduz=2)
             {
                xPos := 1 - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else If (moduz=3)
             {
                xPos := 1 - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=4)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=5)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := 1 - h//2 + deviation
             } Else If (moduz=6)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             } Else If (moduz=7)
             {
                xPos := mainWidth//2 - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             } Else If (moduz=8)
             {
                xPos := mainWidth - w//2 + deviation
                yPos := mainHeight//2 - h//2 + deviation
             } Else
             {
                xPos := 1 - w//2 + deviation
                yPos := mainHeight - h//2 + deviation
             }
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }

          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=6)
    {
       ; Maurer Rose; based on the implemention by Hellbent - found on AHK Forums
       If (startMode!=1)
          iterations := Ceil(iterations/10)
       Else
          Random, iterations, 2, 5

       o_sweepRand := sweepRand
       PetalPenA := Gdip_CreatePenFromBrush(pBr5, thickness)
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, thickness, 2.0, 3.5
             Random, tBrsh, 1, 3
             Random, ttBrsh, 1, 3
             If (startMode!=1)
                Random, sweepRand, 1, 9
             Else If (A_Index=1)
                sweepRand := o_sweepRand - 1
             Else If (A_Index=2)
                sweepRand := o_sweepRand + 1
             Else
                sweepRand := o_sweepRand

             Random, Petals, 2, 7
             If (startMode!=1)
                Petals := clampInRange(moduz + 1, 2, 9)

             prevObj[A_Index] := [thickness, Petals, sweepRand, ttBrsh, tBrsh]
          } Else
          {
             thickness := prevObj[A_Index, 1] / ((scaleuX + scaleuY)/2)
             Petals := prevObj[A_Index, 2]
             sweepRand := prevObj[A_Index, 3]
             ttBrsh := prevObj[A_Index, 4]
             tBrsh := prevObj[A_Index, 5]
          }

          PetalPen := Gdip_CreatePenFromBrush(pBr%ttBrsh%, thickness)
          SweepPen := Gdip_CreatePenFromBrush(pBr%tBrsh%, thickness)
          PetalList := SweepList := mainWidth//2 "," mainHeight//2 "|", Sweep := sweepRand
          Loop, 360
          {
              SweepList .= CalculateSweep(A_Index*Sweep, Petals, mainWidth//2, mainHeight//2)
              PetalList .= CalculateSweep(A_Index*3.14159/180, Petals, mainWidth//2, mainHeight//2)
          }
          PetalList .= mainWidth//2 "," mainHeight//2
          SweepList .= mainWidth//2 "," mainHeight//2
          Gdip_DrawLines(G, PetalPenA, PetalList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          ; Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, PetalPen, PetalList)
          Gdip_DeletePen(PetalPen)
          Gdip_DeletePen(SweepPen)
       }
       Gdip_DeletePen(PetalPenA)
    } Else If (modelu=4)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % minX, % mainWidth
             Random, yPos, % -mainHeight, % minY
             Random, w, % minX, % mainWidth//2
             w += 5
             h := mainHeight*3
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }

          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=8)
    {
       ; noise
       Random, z, 0.02, 0.09 ; scale
       Random, l, 0.1, 0.45 ; opacity
       Random, kl, 0, 10
       doGray := (kl<3) ? 1 : 0
       Gdip_SetInterpolationMode(G, 5)
       Gdip_SetPixelOffsetMode(G, 2)
       Gdip_ResetWorldTransform(G)
       noiseBMP := QPV_CreateBitmapNoise(Ceil(mainWidth*z), Ceil(mainHeight*z), 1, doGray, 1, 0)
       trGdip_DrawImage(A_ThisFunc, G, noiseBMP, 0, 0, mainWidth, mainHeight,,,,, l)
       trGdip_DisposeImage(noiseBMP, 1)
    } Else ; If (modelu=6)
    {
       Loop, % iterations
       {
          If (usePrevious!=1)
          {
             Random, xPos, % -mainWidth, % minY
             Random, yPos, % minY, % mainHeight
             w := mainWidth*3
             Random, h, % minY, % mainHeight//2
             h += 5
             Random, tBrsh, 1, 3
             prevObj[A_Index] := [xPos, yPos, w, h, tBrsh]
          } Else
          {
             xPos := prevObj[A_Index, 1]/scaleuX
             yPos := prevObj[A_Index, 2]/scaleuY
             w := prevObj[A_Index, 3]/scaleuX
             h := prevObj[A_Index, 4]/scaleuY
             tBrsh := prevObj[A_Index, 5]
          }
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    }
    
    Gdip_ResetWorldTransform(G)
    ; If (startMode!=1)
       ; Gdip_FillRectangle(G, overBrush, 0, 0, mainWidth, mainHeight)

    If (startMode!=1 && previewMode=1)
    {
       prevBMPu := (minimizeMemUsage=0) ? trGdip_CloneBitmap(A_ThisFunc, BMPcache) : 0
       prevState := (minimizeMemUsage=0) ? thisState : 0
    } Else prevState := 0

    Gdip_DeleteBrush(pBr1)
    Gdip_DeleteBrush(pBr2)
    Gdip_DeleteBrush(pBr3)
    Gdip_DeleteBrush(pBr5)
    Gdip_DeleteGraphics(G)
    Return BMPcache
}

CalculateSweep(InputValue, Petals, w, h) {
   r:=((w+h)//2)*Sin(Petals*InputValue)
   x:=r*cos(InputValue)+w
   y:=r*sin(InputValue)+h
   return x "," y "|"
}

addJournalEntry(msg) {
    Static currentEntry := 0, currentErrEntry := 0, maxEntries := 256, lastError, prevEntry
    If (slideShowRunning=1 && slideShowDelay<300)
       Return

    If (msg="get_last_err")
       Return lastError

    If (msg="WinTitle: " pVwinTitle) || InStr(msg, "WinTitle: <> ") || InStr(msg, "WinTitle: " appTitle " v" appVersion) || (msg="Loading") || (slideShowRunning=1 && slideShowDelay<600) || (animGIFplaying=1)
       Return

    If (hasInitSpecialMode=1 || prevEntry=msg)
       Return

    prevEntry := msg
    fnOutputDebug("User journal: " StrReplace(msg, "`n", " | "))
    If ((InStr(msg, "error") || InStr(msg, "fail")) && !InStr(msg, "dialog box:") && !InStr(msg, "ThumbsMode. Failed to generate."))
    {
       lastError := msg
       currentErrEntry++
       QPVerrJournal.InsertAt(1, getCurrentDate() ":`n" msg "`n")
       If (currentErrEntry>maxEntries)
       {
          currentErrEntry := maxEntries
          QPVerrJournal.Pop()
       }
       Return
    }

    currentEntry++
    QPVjournal.InsertAt(1, getCurrentDate() ":`n" msg "`n")
    If (currentEntry>maxEntries)
    {
       currentEntry := maxEntries
       QPVjournal.Pop()
    }
}

getCurrentDate() {
   FormatTime, CurrentTimeB,, H:mm:ss
   FormatTime, CurrentDateB,, ShortDate
   Return CurrentDateB ", " CurrentTimeB
}

destroyGDIPcanvas() {
    qpvCanvasHasInit := 0
    Gdi_SelectObject(glHDC, glOBM)
    If glHbitmap
       Gdi_DeleteObject(glHbitmap)
    If glOBM
       Gdi_DeleteObject(glOBM)
    If glHDC
       Gdi_DeleteDC(glHDC)
    If glPG
       Gdip_DeleteGraphics(glPG)

    glHbitmap := glHDC := glPG := ""
    Gdi_SelectObject(2NDglHDC, 2NDglOBM)
    If 2NDglHbitmap
       Gdi_DeleteObject(2NDglHbitmap)
    If 2NDglOBM
       Gdi_DeleteObject(2NDglOBM)
    If 2NDglHDC
       Gdi_DeleteDC(2NDglHDC)
    If 2NDglPG
       Gdip_DeleteGraphics(2NDglPG)

    2NDglHbitmap := 2NDglHDC := 2NDglPG := ""
}

createGDIPcanvas(W:=0, H:=0, forceIT:=0) {
   Critical, on
   Static prevDimensions, hasInit
   WinGet, p, MinMax, ahk_id %PVhwnd%
   z := DllCall("IsIconic", "UPtr", PVhwnd) ; detect if window is minimized
   If ((A_TickCount - lastMenuBarUpdated<500) && (forceIT=0) || z=1 || p=-1)
      Return

   If (!W || !H)
      vpWinClientSize(W, H)

   ; Gdi_GetImageDimensions(glHbitmap, pW, pH, bpp)
   ; Gdi_GetImageDimensions(2NDglHbitmap, ppW, ppH, bpp)
   ; If (pW!=W || pH!=H || ppW!=W || ppH!=H)
   ;    forceIT := 1

   azp := (ShowAdvToolbar=1 && lockToolbar2Win=1) ? 1 "|" TLBRverticalAlign : 0
   newDimensions := "w" W "-h" H "-mbar" showMainMenuBar azp
   doAgain := (prevDimensions!=newDimensions) ? 1 : 0
   If (!qpvCanvasHasInit || doAgain=1 || forceIT=1)
   {
      If (hasInit=1)
         destroyGDIPcanvas()

      ; gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
      imgQuality := (userimgQuality=1) ? 6 : 5
      If (minimizeMemUsage=1)
         imgQuality := ""    ; default interpolation mode

      PixelMode := (userimgQuality=1) ? 2 : 0
      smoothMode := (userimgQuality=1) ? 4 : 1
      compositingQuality := 1 ; (userimgGammaCorrect=1) ? 2 : 1
      glHDC := Gdi_CreateCompatibleDC()
      glHbitmap := Gdi_CreateDIBSection(W, H)
      glOBM := Gdi_SelectObject(glHDC, glHbitmap)
      glPG := Gdip_GraphicsFromHDC(glHDC, 0, imgQuality, smoothMode, 2, compositingQuality)
      Gdip_SetPixelOffsetMode(glPG, 2)
      ; ToolTip, % W "==" H "==" glHDC "==" glHbitmap "==" glOBM "==" glPG , , , 2

      2NDglHDC := Gdi_CreateCompatibleDC()
      2NDglHbitmap := Gdi_CreateDIBSection(W, H)
      2NDglOBM := Gdi_SelectObject(2NDglHDC, 2NDglHbitmap)
      2NDglPG := Gdip_GraphicsFromHDC(2NDglHDC, 0, imgQuality, smoothMode, 2, compositingQuality)
      Gdip_SetPixelOffsetMode(2NDglPG, 2)

      hasInit := 1
      prevDimensions := newDimensions
      addJournalEntry("Canvas infos: " prevDimensions " - glPG:" glPG " - glHDC:" glHDC " - glOBM:" glOBM " - glHbmp:" glHbitmap " - 2NDglPG:" 2NDglPG " - 2NDglHDC:" 2NDglHDC " - 2NDglOBM:" 2NDglOBM " - 2NDglHbmp:" 2NDglHbitmap)
      If (!glPG || !glHDC || !glHbitmap || !glOBM || !2NDglPG || !2NDglHDC || !2NDglOBM || !2NDglHbitmap)
      {
         qpvCanvasHasInit := 0
         prevDimensions := "r"
         ; MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+ window...`n`nThe program will probably malfunction or crash.
         handleFatalWinInitErrors()
      } Else
      {
         qpvCanvasHasInit := 1
         addJournalEntry("Main canvas created: " W " x " H " px.")
      }
   }
}

handleFatalWinInitErrors() {
   msgResult := msgBoxWrapper(appTitle ": FATAL ERROR", appTitle " was unable to initialize the GDI+ windows required to display images.`n`nWould you like to try initialize it again? By choosing to continue, the application may malfunction.", "&Try again|&Continue|&Exit", 1, "error")
   If InStr(msgResult, "again")
   {
      restartEntireGui()
   } Else If InStr(msgResult, "exit")
   {
      hasInitSpecialMode := 1
      ForceExitNow()
   }
}

restartEntireGui() {
   destroyGDIPcanvas()
   interfaceThread.ahkFunction("destroyAllGUIs")
   Sleep, 25
   externObj := WindowBgrColor "$" isAlwaysOnTop "$" mainCompiledPath "$" isTitleBarVisible "$" TouchScreenMode "$.$" mainWinPos "$" mainWinSize "$" mainWinMaximized
   initGUI := interfaceThread.ahkFunction("BuildGUI", externObj)
   fnOutputDebug("RESTARTED extern UI HWNDs: " initGUI)
   If InStr(initGui, "|")
      handleUIhwnd(InitGui)

   createGDIPcanvas()
}

disableWindowPenServices(hwnd) {
   If (isWinXP || (A_TickCount - scriptStartTime<500))
      Return

   If !qpvMainDll
      initQPVmainDLL(1)

   Return DllCall(whichMainDLL "\SetTabletPenServiceProperties", "uptr", hwnd)
}

handleUIhwnd(initGui) {
   externObj := StrSplit(initGUI, "|")
   PVhwnd := externObj[1]
   hGDIinfosWin := externObj[2]
   hGDIwin := externObj[3]
   hGDIthumbsWin := externObj[4]
   hGDIselectWin := externObj[5]
   hPicOnGui1 := externObj[6]
   winGDIcreated := externObj[7]
   ThumbsWinGDIcreated := externObj[8]
   If (!PVhwnd || !hGDIinfosWin || !hGDIwin || !hGDIthumbsWin || !hGDIselectWin || !hPicOnGui1)
   {
      handleFatalWinInitErrors()
   } Else
   {
      disableWindowPenServices(PVhwnd)
      GroupAdd, QPVwindows, ahk_id %PVhwnd%
      GroupAdd, QPVwindows, ahk_id %hGDIthumbsWin%
      GroupAdd, QPVwindows, ahk_id %hGDIwin%
      GroupAdd, QPVwindows, ahk_id %hGDIselectWin%
      GroupAdd, QPVwindows, ahk_id %hGDIinfosWin%
      updateUIctrl()
   }
}

InitGDIpStuff() {
   thisBMPdummy := trGdip_CreateBitmap(A_ThisFunc, 10, 10)
   dummyGu := Gdip_GraphicsFromImage(thisBMPdummy)

; create pens and brushes
   pPen1 := Gdip_CreatePen("0xCCbbccbb", 3)
   pPen1d := Gdip_CreatePen("0xCCbbccbb", 3)
   ; Gdip_SetPenAlignment(pPen1d, 1)
   Gdip_SetPenDashArray(pPen1d, "1.1|1.1")
   pPen2 := Gdip_CreatePen("0xBBffccbb", imgHUDbaseUnit//9)
   pPen3 := Gdip_CreatePen("0x66334433", imgHUDbaseUnit//8)
   pPen4 := Gdip_CreatePen("0x88998899", imgHUDbaseUnit//11)
   pPen5 := Gdip_CreatePen("0x880088FF", imgHUDbaseUnit//11.5)
   pPen6 := Gdip_CreatePen("0xDD998822", imgHUDbaseUnit//6)
   pPen7 := Gdip_CreatePen("0xDDFFeeFF", imgHUDbaseUnit//6)
   pPen8 := Gdip_CreatePen("0xAAaaAAaa", imgHUDbaseUnit//6)
   Gdip_SetPenDashArray(pPen4, "0.5|0.5")
   pBrushA := Gdip_BrushCreateSolid("0x90898898")
   pBrushB := Gdip_BrushCreateSolid("0xBB898898")
   pBrushC := Gdip_BrushCreateSolid("0x77898898")
   pBrushD := Gdip_BrushCreateSolid("0xDDbbccFF")
   pBrushE := Gdip_BrushCreateSolid("0x77333333")
   pBrushF := Gdip_BrushCreateSolid("0x33667766")
   pBrushZ := Gdip_BrushCreateSolid("0xFF000000")
   ; Loop, 6
      ; r := Gdip_SetPenAlignment(pPen%A_Index%, 1)
   ; ToolTip, % "0x" rgb2bgr(WindowBgrColor) "`n" WindowBgrColor , , , 2
   ; GDIbrushHatch := GDIcreateCheckersBrush(20, 0)
   ; GDIPbrushHatch := GDIcreateCheckersBrush(10, 1)
   Gdi_SetBgrColor(glHDC, "0x" rgb2bgr(WindowBgrColor))
   pBrushHatchLow := Gdip_BrushCreateHatch("0xffeeEEee", "0xff111111", 50)
   GDIPbrushHatch := Gdip_BrushCreateHatch("0xffeeEEee", "0xff111111", 50)
   GDIbrushHatch := convertGDIPbrushGDI(pBrushHatchLow, 8)
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
   GDIbrushWinBGR := Gdi_CreateSolidBrush("0x" rgb2bgr(WindowBgrColor))
   OSDwinFadedBrushBGR := Gdip_BrushCreateSolid("0xEE" OSDbgrColor)
}

convertGDIPbrushGDI(pBrush, size) {
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, size, size, coreDesiredPixFmt)
   If !validBMP(pBitmap)
      Return

   Gu := Gdip_GraphicsFromImage(pBitmap)
   Gdip_FillRectangle(Gu, pBrush, 0, 0, size, size)
   Gdip_DeleteGraphics(Gu)
   brushu := createGDIbrushPbitmap(pBitmap)
   trGdip_DisposeImage(pBitmap, 1)
   Return brushu
}

createGDIbrushPbitmap(pBitmap) {
    hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, pBitmap)
    If StrLen(hBitmap)>1
    {
       gdiBrushu := Gdi_CreatePatternBrush(hBitmap)
       Gdi_DeleteObject(hBitmap)
       Return gdiBrushu
    }
}

GDIcreateCheckersBrush(size, gdip, opacity:=255) {
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, size, size, coreDesiredPixFmt)
   If !validBMP(pBitmap)
      Return

   pBr1 := Gdip_BrushCreateSolid("0x99ffFFff")
   pBr2 := Gdip_BrushCreateSolid("0x99112111")
   pBr3 := Gdip_BrushCreateHatch("0xffeeEEee", "0xff010101", 50)

   G := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   Gdip_FillRectangle(G, pBr3, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr2, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr1, 0, 0, size//2, size//2)
   Gdip_FillRectangle(G, pBr1, size//2, size//2, size//2, size//2)
   Gdip_DeleteGraphics(G)
   Gdip_DeleteBrush(pBr1)
   Gdip_DeleteBrush(pBr2)
   Gdip_DeleteBrush(pBr3)
   If (gdip=1)
   {
      If (opacity!=255)
      {
         xBitmap := trGdip_CreateBitmap(A_ThisFunc, size, size)
         If validBMP(xBitmap)
         {
            zG := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
            Gdip_DrawImage(zG, pBitmap, , , , , , , , , opacity/255)
            Gdip_DeleteGraphics(zG)
            trGdip_DisposeImage(pBitmap)
            pBitmap := xBitmap
         }
      }
      brushu := Gdip_CreateTextureBrush(pBitmap, 3)
   } Else 
      brushu := createGDIbrushPbitmap(pBitmap)

   trGdip_DisposeImage(pBitmap, 1)
   Return brushu
}

refreshWinBGRbrush() {
   If pBrushWinBGR
      Gdip_DeleteBrush(pBrushWinBGR)
   If OSDwinFadedBrushBGR
      Gdip_DeleteBrush(OSDwinFadedBrushBGR)
   If GDIbrushWinBGR
      Gdi_DeleteObject(GDIbrushWinBGR)
   Sleep, 0
   ; ToolTip, % "0x" rgb2bgr(WindowBgrColor) , , , 2
   Gdi_SetBgrColor(glHDC, "0x" rgb2bgr(WindowBgrColor))
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
   GDIbrushWinBGR := Gdi_CreateSolidBrush("0x" rgb2bgr(WindowBgrColor))
   OSDwinFadedBrushBGR := Gdip_BrushCreateSolid("0xEE" OSDbgrColor)
}

useHatchedBrush(dummy:=0) {
   If (dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha!=1)
      Return
   Else If (coreDesiredPixFmt="0x21808" || dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha=1)
      Return pBrushZ
   Else 
      Return pBrushHatchLow
}

useGdiHatchedBrush(dummy:=0) {
   If (dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha!=1)
      Return Gdi_GetStockObject(0)
   Else If (coreDesiredPixFmt="0x21808" || dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha=1)
      Return Gdi_GetStockObject(4)
   Else 
      Return GDIbrushHatch
}

createGDIbitmap(w, h) {
   hDC := Gdi_CreateCompatibleDC()
   hbitmap := Gdi_CreateDIBSection(w, h)
   OBM := Gdi_SelectObject(hDC, Hbitmap)
   PG := Gdip_GraphicsFromHDC(hDC, 0, 5, 1, 2, 1)
   Return [hDC, hBitmap, OBM, PG]
}

discardGDIbitmap(objBMP) {
    If !IsObject(objBMP)
       Return

    Gdi_SelectObject(objBMP[1], objBMP[3])
    If objBMP[4]
       Gdip_DeleteGraphics(objBMP[4])
    If objBMP[2]
       Gdi_DeleteObject(objBMP[2])
    If objBMP[3]
       Gdi_DeleteObject(objBMP[3])
    If objBMP[1]
       Gdi_DeleteDC(objBMP[1])
}

ToggleSeenIMGstatus() {
   initSeenImagesListDB()
   If (thumbsDisplaying!=1 || sqlFailedInit=1)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   mustRem := 0 
   imgPath := getIDimage(currentFileIndex)
   cachedAllSessionsSeen[Format("{:L}", imgPath)] := "-"
   resultedFilesList[currentFileIndex, 3] := ""
   seenImagesDB.Exec("COMMIT TRANSACTION;")
   If retrieveSeenImageDBentry(imgPath, currentFileIndex)
      mustRem := 1 

   If markedSelectFile
   {
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      countFilez := 0
      getSelectedFiles(0, 1)
      friendly := (mustRem=1) ? "NOT SEEN" : "SEEN"
      showTOOLtip("Marking as " friendly A_Space groupDigits(markedSelectFile) " images, please wait")
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      doStartLongOpDance()
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
            Continue

         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(countFilez, markedSelectFile, startOperation)
            showTOOLtip("Marking as " friendly " images, please wait" etaTime, 0, 0, countFilez / markedSelectFile)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countFilez++
         resultedFilesList[A_Index, 3] := ""
         imgPath := resultedFilesList[A_Index, 1]
         cachedAllSessionsSeen[Format("{:L}", imgPath)] := "-"
         If (mustRem=1)
            deleteSQLseenEntry(imgPath, A_Index)
         Else
            recordSeenIMGdbEntry(imgPath, A_Index, 0)
      }

      If !seenImagesDB.Exec("COMMIT TRANSACTION;")
         someERR := "Failed to commit changes to the SQL database`n"

      If (abandonAll=1)
         showTOOLtip(someERR "Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected images were marked as " friendly ".")
      Else
         showTOOLtip(someERR "Finished marking " groupDigits(countFilez) " images as " friendly ".")

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % (abandonAll=1) ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      If (mustRem=1)
         deleteSQLseenEntry(imgPath, currentFileIndex)
      Else
         recordSeenIMGdbEntry(imgPath, currentFileIndex, 0)

      If !seenImagesDB.Exec("COMMIT TRANSACTION;")
      {
         throwSQLqueryDBerror(A_ThisFunc)
      } Else
      {
         friendly := (mustRem=1) ? "NOT SEEN" : "SEEN"
         showTOOLtip("Marked image as " friendly)
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   }

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
}

CleanDeadFilesSeenImagesDB(doPartial:=0, partu:=0) {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If AnyWindowOpen
     BtnCloseWindow()

   If (doPartial!="yesu")
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to purge no longer existent files from the list of seen images?`n`nThis action is irreversible and may take awhile...", "&Continue|C&ancel", 2, "question")
      If !InStr(msgResult, "continue")
         Return
   }

  startOperation := A_TickCount
  npartu := StrReplace(partu, "\viewed-images-history|")
  npartu := StrReplace(npartu, ".sld")
  tfr := (doPartial="yesu" && !InStr(partu, "viewed-images-history|current-session")) ? "`nLIKE '" npartu "'" : ""
  showTOOLtip("Gathering data from the seen images database, please wait" tfr)
  doStartLongOpDance()
  prevMSGdisplay := A_TickCount
  startOperation := A_TickCount
  abandonAll := entriesCount := entriesScanned := entriesRemCount := 0
  RecordSet := ""
  If (doPartial="yesu" && !InStr(partu, "viewed-images-history|current-session"))
     SQL := "SELECT imgfile FROM images WHERE imgViewDate LIKE '" npartu "%' ORDER BY imgfile;"
  Else
     SQL := "SELECT imgfile FROM images ORDER BY imgfile;"

  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  deadList := []
  entriesCount := RecordSet.RowCount
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      item := Trimmer(Rowu[1])
      If !FileExist(item)
      {
         entriesRemCount++
         deadList[entriesRemCount] := item ; imgPath
         ; deleteSQLseenEntry(item, 0)
      }

      entriesScanned++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(entriesScanned, entriesCount, startOperation)
         showTOOLtip("Identifying entries of inexistent files`nfrom the seen images database, please wait" etaTime "`n" groupDigits(entriesRemCount) " entries to be removed", 0, 0, entriesScanned / entriesCount)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
  }

  RecordSet.Free()
  kp := A_TickCount
  totalu := deadList.Count()
  If (abandonAll!=1)
  {
     seenImagesDB.Exec("BEGIN TRANSACTION;")
     Loop, % totalu
     {
         imgPath := deadList[A_Index]
         deleteSQLseenEntry(imgPath, 0)
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(A_Index, totalu, kp)
            showTOOLtip("Commiting changes to the seen images database, please wait" etaTime "`n" groupDigits(entriesRemCount) " entries removed", 0, 0, A_Index / totalu)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }

     If !seenImagesDB.Exec("COMMIT TRANSACTION;")
        throwSQLqueryDBerror(A_ThisFunc)

     If (doPartial!="yesu")
        seenImagesDB.Exec("VACUUM main;")
  }


  zeitOperation := A_TickCount - startOperation
  etaTime := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
  If (abandonAll=1)
  {
     etaTime .= "`nOperation aborted. " groupDigits(entriesScanned) " / " groupDigits(entriesCount) " entries were scanned until now"
     showTOOLtip("No entries were removed from the seen images database" etaTime)
  } Else
     showTOOLtip(groupDigits(entriesRemCount) " entries of inexistent files were removed from the database" etaTime)

  SetTimer, ResetImgLoadStatus, -50
  SoundBeep, 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return entries
}

retrieveEntireSeenImagesDB(ByRef entriesCount, doSorting, applyFilter:=0) {
  entriesCount := 0
  RecordSet := ""
  filteru := Strlen(applyFilter)>1 ? " WHERE imgViewDate LIKE '" applyFilter "%'" : ""
  orderu := (doSorting=1) ? " ORDER BY imgViewDate;" : ";"
  SQL := "SELECT imgfile FROM images" filteru orderu
  If !seenImagesDB.GetTable(SQL, RecordSet)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return 0
  }

  entries := new hashtable(RecordSet.RowCount)
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      ; entries[CalcStringHash(Row[1], 0x8003)] := Row[1]
      If RegExMatch(Rowu[1], RegExFilesPattern)
      {
         entriesCount++
         entries[Format("{:L}", Rowu[1])] := 1
      }
  }

  RecordSet.Free()
  addJournalEntry("Recorded seen images: " entriesCount "`nRetrieved entries: " entries.Count())
  Return entries
}

deleteSQLseenEntry(imgPath, thisIndex) {
  seenImagesDB.EscapeStr(imgPath)
  SQLstr := "DELETE FROM images WHERE imgfile=" imgPath " COLLATE NOCASE;"
  seenImagesDB.Exec(SQLStr)
  resultedFilesList[thisIndex, 3] := 0
}

retrieveSeenImageDBentry(imgPath, thisIndex) {
  Static lastInvoked := 1

  If (!imgPath || (A_TickCount - lastInvoked<350) && (slideShowRunning!=1))
     Return 0

  If (resultedFilesList[thisIndex, 3]=1)
     Return 1
  Else If (resultedFilesList[thisIndex, 3]=0 && thumbsDisplaying=1)
     Return 0

  zu := cachedAllSessionsSeen[Format("{:L}", imgPath)]
  If (zu=1 && imgPath)
  {
     resultedFilesList[thisIndex, 3] := 1
     Return 1
  } Else If (thumbsDisplaying=1 && zu=0)
     Return 0
 
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  RecordSet := ""
  stringA := imgPath
  seenImagesDB.EscapeStr(stringA)
  SQL := "SELECT imgfile, imgViewDate FROM images WHERE imgfile=" stringA " COLLATE NOCASE;"
  If !seenImagesDB.GetTable(SQL, RecordSet)
     Return 0

  entries := 0
  Loop, % RecordSet.RowCount
  {
     Rowu := RecordSet.Rows[A_Index]
     If (Trimmer(Rowu[1])=imgPath)
        entries := Rowu[2]
  }

  RecordSet.Free()
  If entries
  {
     cachedAllSessionsSeen[Format("{:L}", imgPath)] := 1
     resultedFilesList[thisIndex, 3] := 1
     resultedFilesList[thisIndex, 35] := StrReplace(entries, "@", ", ") "h"
     Return 1
  } Else
  {
     cachedAllSessionsSeen[Format("{:L}", imgPath)] := 0
     resultedFilesList[thisIndex, 35] := ""
     resultedFilesList[thisIndex, 3] := 0
     Return 0
  }

  lastInvoked := A_TickCount
}

recordSeenIMGdbEntry(imgPath, thisIndex, doCommits:=1) {
   Static invoked := 0
   If (resultedFilesList[thisIndex, 3]=1 || userPrivateMode=1 || InStr(ImgPath, SeenIMGprivateFolder) && StrLen(SeenIMGprivateFolder)>2)
      Return

   If (doCommits=1)
      initSeenImagesListDB()

   If (sqlFailedInit=1)
      Return

   FormatTime, currDate, , yyyy-MM-dd@HH
   ; MD5name := currDate
   resultedFilesList[thisIndex, 3] := 1
   resultedFilesList[thisIndex, 35] := currDate
   cachedAllSessionsSeen[Format("{:L}", imgPath)] := 1

   SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES ('" imgPath "', '" currDate "');"
   If !seenImagesDB.Exec(SQLStr)
   {
      stringA := imgPath
      seenImagesDB.EscapeStr(stringA)
      stringB := currDate
      seenImagesDB.EscapeStr(stringB)
      ; MsgBox, % stringA "--" stringB 
      SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES (" stringA ", " stringB ");"
      err := seenImagesDB.Exec(SQLStr)
      ; If !err
      ; addJournalEntry(seenImagesDB.ErrorMsg " == " seenImagesDB.ErrorCode)
   }

   If (invoked>14 && doCommits=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      invoked := 0
   }

   invoked++
}

eraseSeenIMGsDB() {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If !seenImagesDB
      Return

   msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete the list of seen images?`n`nThis action is irreversible. The actual files will be untouched, only the list of seen images is going to be erased.", "&Erase list|&Cancel", 2, "exclamation")
   If !InStr(msgResult, "erase list")
      Return

   If AnyWindowOpen
      BtnCloseWindow()

   seenImagesDB.CloseDB()
   FileDelete, % mainCompiledPath "\seenImagesList.db"
   Sleep, 5
   seenImagesDB := ""
   showTOOLtip("Already seen images list is now empty.`nEntries will be added only if the option`nto skip seen images is activated.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (mustRecordSeenImgs=1)
      initSeenImagesListDB()
}

initSeenImagesListDB() {
   If (sqlFailedInit=-1 || sqlFailedInit=1)
      Return

   If FileExist(mainCompiledPath "\seenImagesList.db")
      alreadyExisting := 1

   seenImagesDB := new SQLiteDB
   sqlFailedInit := seenImagesDB.hasFailedInit
   If !seenImagesDB.OpenDB(mainCompiledPath "\seenImagesList.db")
   {
      mustRecordSeenImgs := 0
      sqlFailedInit := 1
   } Else If (alreadyExisting!=1)
   {
      SQL := "CREATE TABLE images (imgfile TEXT COLLATE NOCASE UNIQUE ON CONFLICT IGNORE, imgViewDate TEXT, PRIMARY KEY(imgfile ASC)); CREATE INDEX imgsIndex ON images (imgfile COLLATE NOCASE);"
      If !seenImagesDB.Exec(SQL)
      {
         mustRecordSeenImgs := 0
         sqlFailedInit := 1
      } Else
      {
         sqlFailedInit := -1
         seenImagesDB.Exec("BEGIN TRANSACTION;")
      }
   } Else
   {
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      sqlFailedInit := -1
   }
}

SLDBinitSQLdb(fileNamu) {
   activeSQLdb.CloseDB()
   Sleep, 5
   activeSQLdb := new SQLiteDB
   activeSQLdb.OpenDB(fileNamu)
      ; Return -1

   SQL := "CREATE TABLE images (imgidu NUMERIC PRIMARY KEY NOT NULL, imgfile TEXT COLLATE NOCASE NOT NULL, imgfolder TEXT COLLATE NOCASE NOT NULL, fullPath TEXT AS (imgfolder||'\'||imgfile), fsize INT, kbfsize FLOAT AS (round(cast(fsize AS float)/1024,1)), fmodified INT, fcreated INT, imgwidth INT, imgheight INT, imgframes INT, imgdpi INT, imgpixfmt TEXT COLLATE NOCASE, imgwhratio FLOAT AS (round(cast(imgwidth AS float)/imgheight, 5)), imgmegapix FLOAT AS (round((cast(imgwidth AS float)*imgheight)/1000000, 5)), imgmedian FLOAT, imgavg FLOAT, imghpeak FLOAT, imghlow FLOAT, imghmode FLOAT, imghrms FLOAT, imghminu FLOAT, imghrange FLOAT, pixelzFsmall TEXT, HpixelzFsmall TEXT, pixelzFbig TEXT, HpixelzFbig TEXT, dHash TEXT, pHash TEXT, lHash TEXT, HdHash TEXT, HpHash TEXT, HlHash TEXT, isDeleted INT DEFAULT 0, UNIQUE (fullPath));"
   SQL .= "CREATE TABLE imagesData (imgfile TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, imgCaption TEXT, imgAudio TEXT COLLATE NOCASE, PRIMARY KEY(imgfile ASC));"
   SQL .= "CREATE TABLE dynamicfolders (imgfolder TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, fmodified INT, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE staticfolders (imgfolder TEXT COLLATE NOCASE NOT NULL ON CONFLICT IGNORE, fmodified INT, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE settings (paramz TEXT COLLATE NOCASE NOT NULL ON CONFLICT REPLACE, valuez TEXT COLLATE NOCASE, PRIMARY KEY(paramz ASC));"
   SQL .= "CREATE INDEX imgsIndex ON images(imgidu, imgfolder, imgfile);"
   If !activeSQLdb.Exec(SQL)
      Return activeSQLdb.ErrorMsg
}

dummy() {
  Sleep, 0
}

setImageLoading() {
  If (slideShowRunning=1 || animGIFplaying=1 || drawingShapeNow=1 || hasInitSpecialMode=1 || liveDrawingBrushTool=1)
     Return

  imageLoading := 1
  changeMcursor("busy-img")
}

ResetImgLoadStatus() {
  If (slideShowRunning=1 || animGIFplaying=1) && (imageLoading!=1 && runningLongOperation!=1)
  {
     If (imageLoading=1)
        SetTimer, ResetImgLoadStatus, -70
     Return
  }

  If !GetKeyState("LButton")
  {
     changeMcursor("normal-extra")
     runningLongOperation := 0
     mustAbandonCurrentOperations := imageLoading := 0
  } Else If (imageLoading=1)
     SetTimer, ResetImgLoadStatus, -70
}

ShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
  Static prevImgPath, prevNavKeysu := 0, lastInvoked := 1, lastSkippy := 1
  If (usePrevious=2)
     preventHUDelements := 0

  imgPath := StrReplace(imgPath, "||")
  If (slideShowRunning=1)
  {
     slideShowRunning := interfaceThread.ahkgetvar.slideShowRunning
     If (slideShowRunning!=1)
     {
        StopMediaPlaying(1)
        prevSlideShowStop := A_TickCount
     }
  }

  doIT := ((A_TickCount - lastInvoked<125) && (drawModeAzeit>180 && LastWasFastDisplay!=1 && prevDrawingMode=1)) || ((A_TickCount - lastInvoked<65) && (prevImgPath!=imgPath && drawModeAzeit>50)) || ((A_TickCount - lastInvoked<10) && prevDrawingMode=1) ? 1 : 0
  skippedKeys := navKeysCounter - prevNavKeysu
  delayu := (skippedKeys>1) ? 450 : 350
  If ((skippedKeys>5 || (A_TickCount - lastSkippy<delayu)) && thumbsDisplaying!=1)
  {
     doIT := 1
     lastSkippy := A_TickCount
  }

  If (A_TickCount - prevColorAdjustZeit<90) || (animGIFplaying=1 || slideShowRunning=1)
     doIT := 0

  ; ToolTip, % doIT "=S=" skippedKeys , , , 2
  prevNavKeysu := navKeysCounter
  thisModus := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? 1 : 0
  If (usePrevious=0 && ForceIMGload=0 && AnyWindowOpen!=10 && vpImgPanningNow=0
  && doIT=1 && !diffIMGdecX && !diffIMGdecY && thumbsDisplaying!=1 && thisModus!=1)
  {
     ; ToolTip, % Exception("", -1).Line "`n" Exception("", -1).What, , , 2
     zPlitPath(imgPath, 1, OutFileName, OutDir)
     If (vpIMGrotation>0)
        zoomu := " @ " vpIMGrotation "°"
     If (IMGresizingMode=4)
        zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"

     If (userPrivateMode=1)
        winTitle := currentFileIndex "/" maxFilesIndex zoomu
     Else
        winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"

     winPrefix := defineWinTitlePrefix()
     pVwinTitle := winPrefix winTitle
     setWindowTitle(pVwinTitle, 1)
     lastInvoked := A_TickCount
     dummyFastImageChangePlaceHolder(OutFileName, OutDir)
     ; SetTimer, dummyFastImageChangePlaceHolder, -15
     dummyTimerReloadThisPicture(550)
     prevImgPath := imgPath
  } Else
  {
     If (animGIFplaying=1)
        usePrevious := 0

     prevImgPath := imgPath
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount

     coreShowTheImage(imgPath, usePrevious, ForceIMGload)
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount
  }

  lastInvoked := A_TickCount
}

coreShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
   Critical, on
   Static prevImgPath, lastInvoked2 := 1, counteru
        , lastInvoked := 1, prevPicCtrl := 1

   WinGet, winStateu, MinMax, ahk_id %PVhwnd%
   If (winStateu=-1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()
      DestroyGIFuWin()
      Return
   }

   startZeitIMGload := A_TickCount
   SetTimer, ResetImgLoadStatus, Off
   ThisPrev := (ForceIMGload=1 || usePrevious=2) ? 1 : 0
   If (imgPath=prevImgPath && StrLen(prevImgPath)>3 && ThisPrev!=1)
      usePrevious := 1

   If (usePrevious=2 || ForceIMGload=1)  ; force no caching
   {
      If (ForceIMGload=1)
         prevImgPath := 1
      usePrevious := 0
   }

   If (vpIMGrotation>0)
      zoomu := " @ " vpIMGrotation "°"
   If (IMGresizingMode=4)
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"

   If (userPrivateMode!=1)
   {
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
   } Else
      winTitle := currentFileIndex "/" maxFilesIndex zoomu
 
   If (thumbsDisplaying=1)
   {
      filesSelInfo := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
      pVwinTitle := defineWinTitlePrefix() filesSelInfo currentFileIndex "/" maxFilesIndex " | List mode: " defineListViewModes()
      If (userPrivateMode!=1)
         pVwinTitle .= " | " CurrentSLD
      setWindowTitle(pVwinTitle, 1)
      SetTimer, UpdateThumbsScreen, -10
      If (imageLoading=1)
         SetTimer, ResetImgLoadStatus, -15
      Return
   }

   If !validBMP(gdiBitmap)
   {
      usePrevious := 0
      ForceIMGload := 1
   }
   ; ToolTip, % AprevImgCall "`n" BprevImgCall "`n" imgPath,,,2
   If ((InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath)) && (ForceIMGload=0) || validBMP(UserMemBMP))
      ignoreFileCheck := 1

   If (vpImgPanningNow=0 && usePrevious=0 && ignoreFileCheck!=1)
   {
      If !FileRexists(imgPath)
      {
         destroyGDIfileCache()
         DestroyGIFuWin()
         If (hSNDmedia && autoPlaySNDs!=1)
            StopMediaPlaying()
         If (slideShowRunning=1)
            invokeExternalSlideshowHandler()

         If (WinActive("A")=PVhwnd)
         {
            winTitle := "[*] " winTitle
            pVwinTitle := winTitle
            setWindowTitle(pVwinTitle, 1)
            clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIwin)
            showTOOLtip("ERROR: File not found or access denied`n" OutFileName "`n" OutDir "\")
            SetTimer, RemoveTooltip, % -msgDisplayTime
         }

         If (imgPath!=prevImgPath)
         {
            If (minimizeMemUsage=1)
               terminateIMGediting()

            If (A_TickCount - lastInvoked2>125) && (A_TickCount - lastInvoked>95)
            {
               SoundBeep, 300, 50
               lastInvoked2 := A_TickCount
            }

            thisu := (slideShowRunning=1 && SlideHowMode=1) ? 1 : 0
            If (autoRemDeadEntry=1 && thisu!=1)
               remCurrentEntry(1)

            lastInvoked := A_TickCount
            SetTimer, ResetImgLoadStatus, -15
            Return "fail"
         }
      }
   }

   thisModus := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? 1 : 0
   If (A_TickCount - lastInvoked>85) && (A_TickCount - lastInvoked2>85)
   || (slideShowRunning=1 || animGIFplaying=1 || usePrevious=1 || oldZoomLevel || ForceIMGload=1 || diffIMGdecX || diffIMGdecY || LastWasFastDisplay=1)
   {
       lastInvoked := A_TickCount
       r2 := ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload)
       ; msgbox, % r2
       If InStr(r2, "error")
       {
          DestroyGIFuWin()
          destroyGDIfileCache()
          If (hSNDmedia && autoPlaySNDs!=1)
             StopMediaPlaying()
          If (slideShowRunning=1)
             invokeExternalSlideshowHandler()

          friendly := (A_PtrSize=4) ? "`nOr, insufficient memory." : ""
          errMsg := "ERROR: Unable to display the image: " groupDigits(currentFileIndex) "`nPossibly malformed image file format or access denied." friendly "`n" r2 "`n" OutFileName "`n" OutDir "\"
          currIMGdetails := []
          mainLoadedIMGdetails := []
          If (editingSelectionNow=1)
             ToggleEditImgSelection()

          clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIwin)
          showTOOLtip(errMsg)
          SetTimer, RemoveTooltip, % -msgDisplayTime
          winTitle := "[*] " winTitle
          pVwinTitle := winTitle
          setWindowTitle(pVwinTitle, 1)
          SetTimer, ResetImgLoadStatus, -15
          If (slideShowRunning!=1)
             SoundBeep, 300, 100
          Return "fail"
       } Else prevImgPath := imgPath
       lastInvoked := A_TickCount
   } Else If (vpImgPanningNow=0 && thisModus!=1)
   {
      winPrefix := defineWinTitlePrefix()
      pVwinTitle := winPrefix winTitle
      setWindowTitle(pVwinTitle, 1)
      delayu := (A_TickCount - prevFastDisplay < 500) ? 110 : 325
      dummyFastImageChangePlaceHolder(OutFileName, OutDir)
      dummyTimerReloadThisPicture(delayu)
   }
   ; SetTimer, ResetImgLoadStatus, -15
   lastInvoked2 := A_TickCount
}

dummyFastImageChangePlaceHolder(OutFileName, OutDir) {
   Static prevImgPath
   If (A_TickCount - lastFastImgChangeHUDzeit<40)
      Return

   lastFastImgChangeHUDzeit := A_TickCount
   entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
   If (entireString=prevImgPath)
      Return

   prevImgPath := entireString
   CreateOSDinfoLine(entireString, 0, 0, currentFileIndex/maxFilesIndex)
   SetTimer, RemoveTooltip, -500
   lastFastImgChangeHUDzeit := A_TickCount
}

calcImgSizeForVP(modus, imgW, imgH, GuiW, GuiH, ByRef ResizedW, ByRef ResizedH) {
   If (imgW<=GuiW && imgH<=GuiH && modus=2)
   {
      ResizedW := imgW
      ResizedH := imgH
   } Else If (modus=5)
   {
      ResizedW := GuiW
      ResizedH := GuiH
   } Else calcIMGdimensions(imgW, imgH, GuiW, GuiH, ResizedW, ResizedH)
   ; ToolTip, % modus "|" ResizedW "|" ResizedH , , , 2
   ; ToolTip, % modus "=modusa" , , , 2
}

defineZoomLevel() {
   Return (zoomLevel<0.1) ? Round(zoomLevel*100, 1) : Round(zoomLevel*100)
}

ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload) {
    Critical, on
    Static prevImgPath, lastTitleChange := 1
         , IDprevImgPath, tinyW, tinyH, wscale, prevSize

    setImageLoading()
    If (editingSelectionNow=1 && IMGresizingMode=5)
    {
       IMGresizingMode := 1
       interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
    }

    imgPath := StrReplace(imgPath, "||")
    fldr := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
    filu := SubStr(imgPath, InStr(imgPath, "\", 0, -1) + 1)
    pfn := (userPrivateMode=1) ? "Loading file..." : "<> " filu " | " fldr "\"
    setWindowTitle(pfn)
    changeMcursor()
    calcScreenLimits()
    ; If (winGDIcreated!=1)
    ;   createGDIwin()
    ; o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    extraID := ColorDepthDithering vpIMGrotation usrTextureBGR usrColorDepth bwDithering ; UserMemBMP currentUndoLevel undoLevelsRecorded
    IDthisImgPath := imgPath "-" userHQraw extraID
    If (imgPath!=prevImgPath || IDthisImgPath!=IDprevImgPath || !validBMP(gdiBitmap) || ForceIMGload=1)
    {
       ; ToolTip, % IDthisImgPath "`n" IDprevImgPath "`n" ForceIMGload "|" validBMP(gdiBitmap) , , , 2
       gdiBMPchanged := 1
       If (imgPath!=prevImgPath && currentFileIndex!=0)
       {
          terminateIMGediting()
          desiredFrameIndex := 0
       }

       mustReloadIMG := (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath) || (ForceIMGload=1) ? 1 : 0
       If (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath)
       {
          usePrevious := 0
          mustReloadIMG := ForceIMGload := 1
          If (currentFileIndex!=0)
             GdipCleanMain(6)
       }

       disposeCacheIMGs()
       changeMcursor()
       r1 := CloneScreenMainBMP(imgPath, mustReloadIMG, hasFullReloaded)
       abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
       If (abortImgLoad>2)
       {
          o_ImgQuality := userimgQuality
          If (userimgQuality=1)
             ToggleImgQuality("lowu")

          If (desiredFrameIndex<1 && (usrColorDepth>1 || vpIMGrotation>0))
          {
             setWindowTitle("Image processing aborted")
             showTOOLtip("Image processing aborted")
             SetTimer, RemoveTooltip, % -msgDisplayTime//2
          }
       }
       If (lockSelectionAspectRatio=4)
          defineSelectionAspectRatios()
    }

    trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (!validBMP(gdiBitmap) || r1="error" || !oImgW || !oImgH)
    {
       If (o_ImgQuality=1)
          ToggleImgQuality("highu")

       prevImgPath := ""
       interfaceThread.ahkassign("canCancelImageLoad", 0)
       FadeMainWindow()
       SetTimer, ResetImgLoadStatus, -15
       ; r := (r1="error") ? r1 : 0
       Return "error"
    }

   prevImgPath := imgPath
   IDprevImgPath := imgPath "-" userHQraw extraID
   vpWinClientSize(GuiW, GuiH, PVhwnd, 0)
   If (IMGresizingMode=3) ; original [100%]
   {
      lGuiW := (GuiW>oImgW) ? oImgW : GuiW
      lGuiH := (GuiH>oImgH) ? oImgH : GuiH
      ws := Round(ResizedW / oImgW * 100, 1)
      If (ws<100)
      {
         ws := Round(((lGuiW*lGuiH) / (oImgW * oImgH)) * 100, 1)
         ws .= "% visible"
      } Else If (ws>100)
      {
         ws := "100%"
      } Else ws .= "%"

      zoomLevel := 1
      ResizedW := oImgW
      ResizedH := oImgH
   } Else If (IMGresizingMode=4) ; custom zoom level
   {
      prevVPsize := max(prevResizedVPimgW, prevResizedVPimgH)
      If (customZoomAdaptMode>0)
      {
         zoomLevel := (customZoomAdaptMode=1) ? GuiW/oImgW : GuiH/oImgH
         zoomLevel := clampInRange(Round(zoomLevel, 8), 0.01, 20)
         ResizedW := Round(oImgW * zoomLevel, 3)
         ResizedH := Round(oImgH * zoomLevel, 3)
         ws := defineZoomLevel() "%"
      } Else If (prevVPsize>2 && gdiBMPchanged=1 && lockZoomLevel=0 && animGIFplaying!=1 && allowFreeIMGpanning=0)
      {
         calcImgSizeForVP(1, oImgW, oImgH, prevVPsize, prevVPsize, ResizedW, ResizedH)
         zoomLevel := clampInRange(Round(ResizedW / oImgW, 3), 0.01, 20)
         ResizedW := Round(oImgW * zoomLevel, 3)
         ResizedH := Round(oImgH * zoomLevel, 3)
         ws := defineZoomLevel() "%"
      } Else
      {
         ResizedW := Round(oImgW * zoomLevel, 3)
         ResizedH := Round(oImgH * zoomLevel, 3)
         ws := defineZoomLevel() "%"
      }
      ; ToolTip, % modus "|" ResizedW "|" ResizedH , , , 2
   } Else
   {
      calcImgSizeForVP(IMGresizingMode, oImgW, oImgH, GuiW, GuiH, ResizedW, ResizedH)
      zoomLevel := Round(ResizedW / oImgW, 8)
      ws := Round(ResizedW / oImgW * 100, 1) "%"
   }

   IMGlargerViewPort := ((ResizedH - 5>GuiH + 1) || (ResizedW - 5>GuiW + 1)) ? 1 : 0
   IMGentirelylargerThanVP := ((ResizedH - 5>GuiH + 1) && (ResizedW - 5>GuiW + 1)) ? 1 : 0
   ; ToolTip, % imgW ", " oImgW ", " ResizedW ,,, 2
   If (vpIMGrotation>0)
   {
      zoomu := " @ " vpIMGrotation "°"
      fzoomu := ". " vpIMGrotation "°. "
   }

   winPrefix := defineWinTitlePrefix()
   If (userPrivateMode!=1)
   {
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      winTitle := winPrefix currentFileIndex "/" maxFilesIndex " [" ws zoomu "] | " OutFileName " | " OutDir "\"
   } Else
      winTitle := winPrefix currentFileIndex "/" maxFilesIndex " [" ws zoomu "]"

   If (A_TickCount - lastTitleChange>300)
      setWindowTitle("Adapting image to viewport")

   If (imageAligned=5 && (gdiBMPchanged=1 || isVarEqualTo(PrintPosX, "X", "W", "C")) && IMGresizingMode=4)
   {
      thisSize := "a" Round(GuiW/1.5 - ResizedW/1.5) . Round(GuiH/1.5 - ResizedH/1.5) maxFilesIndex ; currentFileIndex imgPath prevResizedVPimgW prevResizedVPimgH
      If (PrintPosX="W")
      {
         IMGdecalageX += Round((prevResizedVPimgW - ResizedW)/2)
         IMGdecalageY += Round((prevResizedVPimgH - ResizedH)/2)
         prevSize := thisSize
      } Else If (prevSize!=thisSize && undoLevelsRecorded<2 || PrintPosX="X")
      {
         ; ToolTip, % PrintPosX "=l`n" thisSize "`n" prevSize , , , 2
         PrintPosX := "C"
         prevSize := thisSize
         IMGdecalageX := Round(GuiW/2 - ResizedW/2)
         IMGdecalageY := Round(GuiH/2 - ResizedH/2)
      }
   } Else If (allowFreeIMGpanning!=1 || imageAligned!=5 || IMGresizingMode!=4 || gdiBMPchanged=1)
      prevSize := 0

   If (hSNDsong && StrLen(SlidesMusicSong)>3 && autoPlaySlidesAudio=1 && gdiBMPchanged=1)
   {
      If RegExMatch(MCI_Status(hSNDsong), "i)^(stop|pause)")
      {
         MCI_SendString("seek " hSNDsong " to 1 wait")
         If MCI_Play(hSNDsong)
            StopMediaPlaying(1)
      }
   }

   If (gdiBMPchanged=1)
   {
      itemInfos := "Image view. Zoom: " ws ". " fzoomu ". " OutFileName ". " OutDir ". Index " currentFileIndex " of " maxFilesIndex "."
      interfaceThread.ahkFunction("infosUIAbtns", itemInfos)
   }

   If (editingSelectionNow=1 && relativeImgSelCoords=1 && gdiBMPchanged=1)
      calcRelativeSelCoords(0, oImgW, oImgH)

   GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
   If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && (animGIFplaying!=1 || desiredFrameIndex=0) && slideShowDelay>950)
      GDIfadeVPcache := trGdip_CreateBitmapFromHBITMAP(A_ThisFunc, glHbitmap)

   changeMcursor()
   ResizedW := Round(ResizedW)
   ResizedH := Round(ResizedH)
   r := QPV_ShowImgonGui(ResizedW, ResizedH, GuiW, GuiH, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged)
   delayu := (A_TickCount - prevFastDisplay < 300) ? 90 : 550
   thisModus := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? 1 : 0
   If (wasPrevious=1 && animGIFplaying!=1 && vpImgPanningNow=0 && thisModus!=1)
      dummyTimerReloadThisPicture(delayu)

   infoFilesSel := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
   If (totalFramesIndex>0)
      infoFrames := "["  desiredFrameIndex "/" totalFramesIndex "] "
 
   pVwinTitle := (drawingShapeNow=1) ? "VECTOR EDITING: " winTitle : infoFilesSel infoFrames winTitle
   setWindowTitle(pVwinTitle, 1)
   lastTitleChange := A_TickCount
   If (o_ImgQuality=1)
      ToggleImgQuality("highu")

   SetTimer, ResetImgLoadStatus, -15
   Return r
} ; // ResizeImageGDIwin()

drawinfoBox(mainWidth, mainHeight, directRefresh, Gu, bonusInfo:=0) {
    Static prevMsg, prevOSDfnt
    zBitmap := useGdiBitmap()
    modus := (validBMP(zBitmap) || (maxFilesIndex>0 && CurrentSLD)) ? 0 : "welcome"
    If (modus="welcome")
       Return

    trGdip_GetImageDimensions(zBitmap, maxSelX, maxSelY)
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    infoFilesSel := (markedSelectFile>0) ? "`nFiles selected: " groupDigits(markedSelectFile) " ( " Round(markedSelectFile/maxFilesIndex*100, 2) "% )" : ""
    If (totalFramesIndex>0 || currIMGdetails.Frames>1) && (thumbsDisplaying!=1)
    {
       thisFramesInfo := (totalFramesIndex>0) ? totalFramesIndex : currIMGdetails.Frames
       infoFrames := "`nMultiple pages: " desiredFrameIndex " / " thisFramesInfo
    }

    zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
    If FileExist(imgPath)
    {
       QPV_FileGetSizeTime(imgPath, "R", currentFileIndex)
       fileSizu := fileSizeFriendly(resultedFilesList[currentFileIndex, 6])
       FileDateM := resultedFilesList[currentFileIndex, 7]
       Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
       fileMsg := "`n" fileSizu " | " FileDateM
    } Else If (currentFileIndex!=0)
    {
       notFound := 1
       fileMsg := "`nFile not found or access denied..."
    }

    fileIndexu := (maxFilesIndex>1) ? " | " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) " (" Round((currentFileIndex/maxFilesIndex)*100, 2) "%)" : ""
    If (userPrivateMode=1 && StrLen(folderu)>3)
    {
       fileRelatedInfos := "*****.***`n*:\******\*****\" fileMsg fileIndexu
    } Else
    {
       OutDir := PathCompact(folderu, "a", 1, OSDfontSize//1.1, 0, 45)
       fileRelatedInfos := (StrLen(folderu)>3) ? fileNamu "`n" OutDir "\" fileMsg fileIndexu : ""
    }

    If (thumbsDisplaying!=1)
    {
       If (vpIMGrotation>0)
          infoRotate := " @ " vpIMGrotation "°"

       infoSizing := "`nRescaling mode: " DefineImgSizing()
       If (IMGresizingMode!=5)
       {
          infoSizing .= infoRotate
          If (showInfoBoxHUD=2)
             infoSizing .= "`nViewport alignment: " defineImgAlign()
       }

       trGdip_GetImageDimensions(useGdiBitmap(), w, h)
       infoRes := "`nResolution: " groupDigits(w) " x " groupDigits(h) " px (" Round(w/h, 2) ") | " Round((w * h)/1000000,2) " MPx"
       If (currIMGdetails.TooLargeGDI=1)
          infoRes .= "`nOriginal resolution: " groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " px | " Round((currIMGdetails.Width * currIMGdetails.Height)/1000000,2) " MPx"
    } Else
    {
       thisFileIndex := currentFileIndex
       If (showInfoBoxHUD=2 && bonusInfo!="scroll")
       {
          infoSizing := "`nThumbnails alignment: " defineImgAlign() "`nThumbnails size: " thumbsW " x " thumbsH " px (" Round(thumbsW/thumbsH, 2) ") | Intended: " defineThumbsAratio()
          thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
          infoSizing .= "`nThumbnails grid: " maxItemsW " x " maxItemsH " = " maxItemsPage
       }

       If (!resultedFilesList[thisFileIndex, 9] && notFound!=1 && bonusInfo!="scroll")
       {
          isOkay := (thumbsDisplaying=1 && thumbsListViewMode>1) || (thumbsDisplaying=1 && thumbsListViewMode=1 && !resultedFilesList[thisFileIndex, 16]) ? 1 : 0
          If (!retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12]) && isOkay=1)
             GetCachableImgFileDetails(imgPath, thisFileIndex)
          If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
             updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
       }

       If (notFound!=1 && bonusInfo!="scroll")
       {
          asr := " px (" Round(resultedFilesList[thisFileIndex, 13] / resultedFilesList[thisFileIndex, 14], 2) ") | "
          infoRes := "`nResolution: " groupDigits(resultedFilesList[thisFileIndex, 13]) " x " groupDigits(resultedFilesList[thisFileIndex, 14]) asr resultedFilesList[thisFileIndex, 17] " MPx"
          ; infoRes .= " | " resultedFilesList[thisFileIndex, 22] " DPI"
          infoRes .= (resultedFilesList[thisFileIndex, 9]>1) ? "`nImage frames: " resultedFilesList[thisFileIndex, 9] : ""
          infoRes .= "`nPixel format: " resultedFilesList[thisFileIndex, 15]
       }
    }

    If (userPrivateMode=1)
       infoEditing := "PRIVATE MODE UI`n"

    If validBMP(UserMemBMP)
    {
       infoEditing .= "IMAGE EDITING MODE`n"
       If (showInfoBoxHUD=2 && thumbsDisplaying!=1)
          infoEditing .= "Undo levels recorded: " currentUndoLevel " / " undoLevelsRecorded "`n"
    }

    knobSize := getScrollWidth()
    scX := scY := 0
    If (showInfoBoxHUD=1 || showInfoBoxHUD=2 && bonusInfo="scroll")
    {
       hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
       If (thumbsDisplaying=1)
       {
          tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
          tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
       } Else
       {
          tlbrBonusX := (hasTrans=1 && FlipImgH=0) ? ToolbarWinW : 0
          If (FlipImgH=1 && scrollBarVx>1)
          {
             tlbrBonusX += knobSize
             scX := knobSize
          }

          tlbrBonusY := (hasTrans=2 && FlipImgV=0) ? ToolbarWinH : 0
          If (FlipImgV=1 && scrollBarHy>1)
          {
             tlbrBonusY += knobSize
             scY := knobSize
          }
       }

       entireString := infoEditing fileRelatedInfos infoRes infoSizing infoFrames
       thisOSDfnt := OSDFontName FlipImgH FlipImgV OSDfontSize OSDbgrColor OSDtextColor
       If (prevMsg!=entireString || prevOSDfnt!=thisOSDfnt || !validBMP(infoBoxGdiCached))
       {
          prevOSDfnt := thisOSDfnt
          infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
          infoBoxGdiCached := drawTextInBox(entireString, OSDFontName, OSDfontSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 1, !thumbsDisplaying)
          prevMsg := entireString
       }

       If validBMP(infoBoxGdiCached)
       {
          trGdip_GetImageDimensions(infoBoxGdiCached, imgW, imgH)
          trGdip_DrawImage(A_ThisFunc, Gu, infoBoxGdiCached, scX, scY)
          lastInfoBoxBMP[1] := [imgW, imgH]
       }
       interfaceThread.ahkPostFunction("uiAccessUpdateInfoBox", entireString, imgW, imgH, FlipImgV, FlipImgH, tlbrBonusX, tlbrBonusY, scX, scY)
       Return
    }

    memInfos := getMemUsage()
    memUsage := "`nMemory usage: " memInfos.appMem " / " memInfos.sysMem " (" memInfos.appPrcMem " %) | System load: " memInfos.prcSys " %"
    If (userPrivateMode!=1)
    {
       If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
          memUsage .= "`nFile matched search criteria: " thisSearchString
    }

    sliSpeed := Round(slideShowDelay/1000, 2) " sec."
    If (slideShowRunning=1)
       infoSlider := "`nSlideshow running: " DefineSlideShowType() " @ " sliSpeed

    infoMirroring := defineIMGmirroring()
    If (editingSelectionNow=1 && thumbsDisplaying!=1)
    {
       imgSelW := Round(max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2))
       imgSelH := Round(max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2))
       mpx := "`n  " Round(imgSelW * imgSelH/1000000, 1) " MPx"
       If (relativeImgSelCoords=1)
       {
          x1 := " | " Round(prcSelX1 * 100) "%, "
          y1 := Round(prcSelY1 * 100) "%"
          wP := " | " Round((prcSelX2 - prcSelX1) * 100) "%, "
          hP := Round((prcSelY2 - prcSelY1) * 100) "%"
          ; moreSelInfo := "`nCoordinates relative to image size"
       }

       infoLocked := (lockSelectionAspectRatio>1) ? "`n  Locked aspect ratio: " defineSelectionAspectRatios() : "`n  Aspect ratio: " Round(imgSelW/imgSelH, 2)
       infoLocked .= (LimitSelectBoundsImg=1) ? "`n  Selection area limited to image boundaries" : ""
       If (imgSelOutViewPort=1)
          infoLocked .= "`n  Selection area is out of current view"
       If isVPselLarger()
          infoLocked .= "`n  Selection area is larger than current view"
       imgSelW := groupDigits(imgSelW)
       imgSelH := groupDigits(imgSelH)
       infoSelection := "`n `n" DefineVPselAreaMode() " selection coordinates:`n  X / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) x1 y1 "`n  W / H: " imgSelW ", " imgSelH wP hP moreSelInfo mpx " | Rotation: " Round(VPselRotation, 2) "° " infoLocked 
       If (innerSelectionCavityX>01 && innerSelectionCavityY>0)
          infoSelection .= "`n  Exclusion area defined"
    } Else If (editingSelectionNow=1)
       infoSelection := "`nSelection area activated in image view"

    typeu :=  defineFilesListType()
    If (typeu && userPrivateMode!=1)
    {
       infoThisSLD := "`nFiles list opened: "
       If (SLDtypeLoaded>1)
          sldu := PathCompact(CurrentSLD, 40)
       If sldu
          infoThisSLD .= sldu
       Else
          infoThisSLD .= typeu
    }

    If (usrColorDepth>1)
       infoColorDepth := "`nSimulated color depth: " defineColorDepth()

    If (StrLen(filesFilter)>1)
    {
       modus := (userFilterInvertThis=1) ? ": (inverted)`n" : ":`n"
       infoFilteru := "`nFiles list filtered from " groupDigits(bckpMaxFilesIndex) " down to " groupDigits(maxFilesIndex) " ( " Round(maxFilesIndex/bckpMaxFilesIndex*100, 2) "% )."
       oldIndex := filteredMap2mainList[currentFileIndex]
       If oldIndex
          infoFilteru .= "`nIndex in main list: " groupDigits(oldIndex)
       If (userPrivateMode!=1)
          infoFilteru .= "`nFilter pattern used" modus SubStr(filesFilter, 1, 45)

       ; If (userFilterDoString=1 && UsrEditFilter!="")
       ;    infoFilteru .= UsrEditFilter
    }

    totalZeit := A_TickCount - startZeitIMGload + 2
    InfoLoadTime := "`nViewport size: " groupDigits(mainWidth) " x " groupDigits(mainHeight) " px (" Round(mainWidth/mainHeight, 2) ")"
    If (thumbsDisplaying!=1 && directRefresh=1)
    {
       InfoLoadTime .= "`nViewport refresh speed: ~" groupDigits(totalZeit) " milisec."
       If (currIMGdetails.HasAlpha=1)
          InfoLoadTime .= " (*)"
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If (userPrivateMode=1)
          OutFileName := "*******.***"

       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " | " sndMediaPos hSNDmediaDuration
       }
       infoAudio := "`nAudio file associated: " OutFileName mediaDuration statusMedia
    }

    If ((animGIFplaying=1 || CountGIFframes>1 && animGIFsSupport=1) && thumbsDisplaying=0)
       infoAnim := "`nGIF animation speed: " GIFspeedDelay + UserGIFsDelayu " ms / frame."

    If (imgFxMode>1 || usrColorDepth>1)
       infoColors := "`nColors display mode: " DefineFXmodes()

    If (thumbsDisplaying!=1)
       infoPixFmt := "`nPixel format: " currIMGdetails.PixelFormat " | " currIMGdetails.RawFormat A_Space SubStr(currIMGdetails.OpenedWith, InStr(currIMGdetails.OpenedWith, "["))

    If (resultedFilesList[currentFileIndex, 5]=1)
       infoFaved := "`nImage: FAVOURITED"

    If resultedFilesList[currentFileIndex, 35]
       dateSeen := " on " resultedFilesList[currentFileIndex, 35]

    If (resultedFilesList[currentFileIndex, 3]=1)
       infoFaved := infoFaved ? infoFaved " and ALREADY SEEN" dateSeen : "`nImage: ALREADY SEEN" dateSeen

    If (thumbsDisplaying=1)
    {
       maxLimitReached := (minimizeMemUsage=1) && (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
       mustDoMultiCore := (allowMultiCoreMode=1 && maxLimitReached!=1 && multiCoreThumbsInitGood=1) ? 1 : 0
       friendlyCoreInfo := (mustDoMultiCore=1) ? "ACTIVATED" : "DEACTIVATED"
       memUsage .= "`nMulti-threaded mode: " friendlyCoreInfo
    }

    ob := friendlyFileUndoInfos(imgPath)
    If IsObject(ob)
       undoInfos := "`nUndo file action: " ob.typu "`n  " ob.word " path: " PathCompact(ob.initialu, 40) "`n  Has overwritten: " ob.ovr "`n  Safe to undo: " ob.restora "`n  Date: " ob.date

    entireString := infoEditing fileRelatedInfos infoFaved infoRes infoPixFmt memUsage infoSizing infoMirroring infoColors infoColorDepth infoFrames infoAnim InfoLoadTime infoThisSLD infoFilesSel infoAudio infoSlider infoFilteru infoSelection undoInfos
    theFntSize := OSDfontSize//1.1
    borderSize := Floor(theFntSize*1.2)
    borderSize := borderu ? borderu : borderSize//3
    tlbrBonusX := tlbrBonusY := 0
    thisTxtAlignu := (thumbsDisplaying=1) ? "Left" : 0
    txtOptions := initInPlaceTextOptions(thisGu, OSDfontBolded, OSDfontItalica, 1, thisTxtAlignu, OSDFontName, theFntSize, "0xEE" OSDtextColor, borderSize)
    otherTxtObj := TextuToGraphics(thisGu, "initing", txtOptions, OSDFontName, "begin", 0, 0, 1)
    dims := TextuToGraphics(Gu, entireString, nul, OSDFontName, "measure", 0, otherTxtObj)
    dimsFw := clampInRange(dims.w + borderSize*2, 0, mainWidth)
    dimsFh := clampInRange(dims.h + borderSize*2, 0, mainHeight)
    txtOptions.w := mainWidth - borderSize
    txtOptions.h := mainHeight - borderSize
    lastInfoBoxBMP[1] := [dimsFw, dimsFh]

    hasTrans := adjustCanvas2Toolbar(Gu, 0)
    tlbrBonusX := (hasTrans=1 && (FlipImgH=0 || thumbsDisplaying=1)) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2 && (FlipImgV=0 || thumbsDisplaying=1)) ? ToolbarWinH : 0
    If (FlipImgH=1 && thumbsDisplaying=0 && scrollBarVx>1)
    {
       tlbrBonusX += knobSize
       scX := knobSize
    }

    If (FlipImgV=1 && thumbsDisplaying=0 && scrollBarHy>1)
    {
       tlbrBonusY += knobSize
       scY := knobSize
    }

    txtOptions.x := (FlipImgH=1 && thumbsDisplaying!=1) ? - scX : borderSize*1.1
    txtOptions.y := (FlipImgV=1 && thumbsDisplaying!=1) ? mainHeight - dimsFh + borderSize - scY : borderSize*1.1
    Gdip_FillRectangle(Gu, OSDwinFadedBrushBGR, scX, scY, dimsFw, dimsFh)
    interfaceThread.ahkPostFunction("uiAccessUpdateInfoBox", entireString, dimsFw, dimsFh, FlipImgV, FlipImgH, tlbrBonusX, tlbrBonusY, scX, scY)
    If (thumbsDisplaying!=1)
       Gdip_ResetWorldTransform(Gu)

    drawInPlaceTextInBox(Gu, entireString, txtOptions)
    If (thumbsDisplaying!=1)
       setMainCanvasTransform(mainWidth, mainHeight, Gu)
}

drawAnnotationBox(mainWidth, mainHeight, Gu) {
    imgPath := getIDimage(currentFileIndex)
    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " (" sndMediaPos hSNDmediaDuration  ")"
       }
       If mediaDuration
          infoAudio := "Audio file associated" mediaDuration statusMedia "`n"
    } ; Else If (autoPlaySNDs=1)
      ;  infoAudio := "No audio file associated.`n"

    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"
    If (SLDtypeLoaded=3)
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

    If !textFileContent
    {
       Try FileRead, textFileContent, % " *t " textFile
       If StrLen(textFileContent)<1
          textFileContent := ""
    }

    entireString := infoAudio textFileContent
    If !entireString
       entireString := "[CC]"

    tlbrBonusX := tlbrBonusY := 0
    textBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfontSize//1.1, mainWidth - tlbrBonusX, mainHeight, OSDtextColor, OSDbgrColor, 0, !thumbsDisplaying, usrTextAlign)
    If validBMP(textBoxBMP)
    {
       trGdip_GetImageDimensions(textBoxBMP, imgW, imgH)
       thisPosY := mainHeight - imgH
       If (thumbsDisplaying=1)
          thisPosY -= ThumbsStatusBarH
       Else If (FlipImgV=1)
          thisPosY -= tlbrBonusY

       thisPosX := mainWidth - imgW 
       If (FlipImgV=0 && scrollBarHy>1 && thumbsDisplaying=0)
          thisPosY -= scrollBarHy

       If (usrTextAlign="Left")
          thisPosX := 0 + tlbrBonusX
       Else If (usrTextAlign="Center")
          thisPosX := Round(tlbrBonusX/2 + mainWidth/2 - imgW/2)

       ERR := trGdip_DrawImage(A_ThisFunc, Gu, textBoxBMP, thisPosX, thisPosY)
       If !ERR
       {
          If (FlipImgH=1 && usrTextAlign="Left")
             thisPosX := mainWidth - imgW - scrollBarVx
          Else If (FlipImgH=1 && usrTextAlign="Right")
             thisPosX := 0

          If (FlipImgV=1 && thumbsDisplaying=0)
             thisPosY := 0

          hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
          tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
          tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
          thisPosX += tlbrBonusX
          thisPosY += tlbrBonusY
          hasDrawnAnnoBox := 1
          interfaceThread.ahkPostFunction("uiAccessUpdateAnnoBox", entireString, imgW, imgH, thisPosX, thisPosY)
       }
       textBoxBMP := trGdip_DisposeImage(textBoxBMP, 1)
    } Else
       hasDrawnAnnoBox := 0
}

clampInRange(value, min, max, reverse:=0) {
   If (reverse=1)
   {
      If (value>max)
         value := min
      Else If (value<min)
         value := max
   } Else
   {
      If (value>max)
         value := max
      Else If (value<min)
         value := min
   }

   Return value
}

changeOSDfontSize(direction) {
  stepu := (OSDfontSize>30) ? 5 : 2
  If (direction=1)
     OSDfontSize += stepu
  Else
     OSDfontSize -= stepu

  OSDfontSize := clampInRange(OSDfontSize, 10, 350)
  INIaction(1, "OSDfontSize", "General")
  showTOOLtip("OSD font size: " OSDfontSize, A_ThisFunc, 2, OSDfontSize/350)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  calcHUDsize()
  recalculateThumbsSizes()
  interfaceThread.ahkassign("OSDfontSize", OSDfontSize)
  updateUIctrl()
  If (thumbsListViewMode>1 && thumbsDisplaying=1)
  {
     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(25)
  } Else If (thumbsDisplaying=1)
     SetTimer, mainGdipWinThumbsGrid, -25
  Else If (CurrentSLD && maxFilesIndex>0)
     SetTimer, dummyRefreshImgSelectionWindow, -25

  If (ShowAdvToolbar=1)
     SetTimer, createGUItoolbar, -500
}

determineGDIsmallCacheSize(mainWidth, mainHeight) {
  Resized := []
  trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
  if (imgW*imgH>640000)
     size := 300
  Else
     size := 800

  calcIMGdimensions(imgW, imgH, size, size, ResizedW, ResizedH)

  Resized.Wsmall := ResizedW
  Resized.Hsmall := ResizedH
  Resized.Small := Round((ResizedW * ResizedH)/1000000, 2)
  Resized.Main := Round((imgW * imgH)/1000000, 2)
  Resized.Screen := Round((Floor(mainWidth*1.15) * Floor(mainHeight*1.15))/1000000, 2)
  Return Resized
}

RescaleBMPtiny(imgPath, mainWidth, mainHeight) {
  Critical, on
  Static prevImgPath
  trGdip_GetImageDimensions(useGdiBitmap(), fimgW, fimgH)
  thisID := "|==|" ColorDepthDithering vpIMGrotation desiredFrameIndex totalFramesIndex currentUndoLevel undoLevelsRecorded fimgW fimgH
  If (validBMP(gdiBitmapSmall) && prevImgPath=gdiBitmapIDentire && InStr(gdiBitmapIDentire, imgPath) && InStr(gdiBitmapIDentire, thisID))
     Return gdiBitmapSmall

  gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
  Resized := determineGDIsmallCacheSize(mainWidth, mainHeight)
  If validBMP(gdiBMPvPsize)
  {
     trGdip_GetImageDimensions(gdiBMPvPsize, otherW, otherH)
     vpIMGres := Round((otherW * otherH)/1000000)
  }

  thisImgQuality := (userimgQuality=1) ? 3 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  changeMcursor()
  whichBitmap := (validBMP(gdiBMPvPsize) && vpIMGres>Resized.Small*1.01) ? gdiBMPvPsize : gdiBitmap
  gdiBitmapSmall := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, Resized.Wsmall, Resized.Hsmall, 0, thisImgQuality, -1)
  ; gdiBitmapSmall := Gdi_ResizeBitmap(whichBitmap, Resized.W, Resized.H, 0, 4)
  gdiBitmapIDentire := SubStr(gdiBitmapIDentire, 1, InStr(gdiBitmapIDentire, "|==|") - 1) . thisID
  prevImgPath := gdiBitmapIDentire
  If validBMP(gdiBitmapSmall)
     Return gdiBitmapSmall
}

RescaleBMPtinyVPsize(imgPath, GuiW, GuiH) {
  Critical, on

  Static prevImgPath
  trGdip_GetImageDimensions(useGdiBitmap(), fimgW, fimgH)
  thisID := "|==|" ColorDepthDithering vpIMGrotation desiredFrameIndex totalFramesIndex currentUndoLevel undoLevelsRecorded fimgW fimgH
  If (validBMP(gdiBMPvPsize) && prevImgPath=gdiBitmapIDentire && InStr(gdiBitmapIDentire, imgPath) && InStr(gdiBitmapIDentire, thisID))
     Return gdiBMPvPsize

  gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
  thisImgQuality := (userimgQuality=1) ? 6 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  changeMcursor()
  gdiBMPvPsize := trGdip_ResizeBitmap(A_ThisFunc, gdiBitmap, Floor(GuiW*1.15), Floor(GuiH*1.15), 0, thisImgQuality, -1)
  gdiBitmapIDentire := SubStr(gdiBitmapIDentire, 1, InStr(gdiBitmapIDentire, "|==|") - 1) . thisID
  ; ToolTip, % gdiBitmapIDentire "`n" prevImgPath , , , 2
  prevImgPath := gdiBitmapIDentire
  If validBMP(gdiBMPvPsize)
     Return gdiBMPvPsize
}

setGIFframesDelay(oBitmap) {
   base := (totalFramesIndex>75) ? 35 : 45
   If (totalFramesIndex>195)
      base := 20
   Else If (totalFramesIndex<15)
      base := 60

   If (totalFramesIndex<8)
      base := 85

   rawFmt := Gdip_GetImageRawFormat(oBitmap)
   If (rawFmt="gif")
   {
      g := Gdip_GetFrameDelay(oBitmap, desiredFrameIndex)
      ; d := Gdip_GetPropertyItem(oBitmap, 0x5100)
      ; GIFspeedDelay := clampInRange(Round(SubStr(d.value, 1, InStr(d.value, A_Space) - 1)*10) + base, 15, 9500)
      GIFspeedDelay := clampInRange(g + base, 15, 9500)
      ; ToolTip, % GIFspeedDelay "==" g "==" d.value , , , 2
      ; ToolTip, % "d=" SubStr(d.value, 1, InStr(d.value, A_Space) - 1)*10 "|" GIFspeedDelay , , , 2
   } Else GIFspeedDelay := base
}

multiPageFileManaging(oBitmap, frameu) {
   rawFmt := Gdip_GetImageRawFormat(oBitmap)
   If RegExMatch(rawFmt, "i)(gif|tiff)$")
   {
      tFrames := Gdip_GetBitmapFramesCount(oBitmap) - 1
      If (tFrames<0 || !tFrames)
         tFrames := 0

      If (frameu>=tFrames)
         frameu := tFrames

      setGIFframesDelay(oBitmap)
      If (tFrames>0 && slideShowRunning=1 && SlideHowMode=1 && animGIFsSupport!=1)
         Random, frameu, 0, % tFrames

      Gdip_BitmapSelectActiveFrame(oBitmap, frameu)
      Return tFrames
   }
   Return 0
}

LoadFileWithWIA(imgPath, fastMode, noBMP:=0, sizesDesired:=0, ByRef newBitmap:=0) {
   oBitmap := 0
   thisZeit := A_TickCount
   Try wiaImg := WIA_LoadImage(imgPath)
   If IsObject(wiaImg)
   {
      mainLoadedIMGdetails.File := imgPath
      mainLoadedIMGdetails.dpi := Round((wiaImg.HorizontalResolution + wiaImg.VerticalResolution)/2)
      mainLoadedIMGdetails.Width := wiaImg.Width
      mainLoadedIMGdetails.Height := wiaImg.Height
      mainLoadedIMGdetails.Frames := wiaImg.FrameCount
      mainLoadedIMGdetails.HasAlpha := wiaImg.IsAlphaPixelFormat
      If (wiaImg.IsAlphaPixelFormat=1)
         extraPixelFormat := "A"
      If (wiaImg.IsIndexedPixelFormat)
         extraPixelFormat .= " [INDEXED-" wiaImg.IsIndexedPixelFormat "]"
      If (wiaImg.IsExtendedPixelFormat)
         extraPixelFormat .= " [EXTENDED-" wiaImg.IsExtendedPixelFormat "]"
      mainLoadedIMGdetails.PixelFormat := wiaImg.PixelDepth "-bit RGB" extraPixelFormat
      mainLoadedIMGdetails.RawFormat := WIA_GetImageFormatID(wiaImg)
      mainLoadedIMGdetails.OpenedWith := "Windows Image Acquisition [WIA]"
      mainLoadedIMGdetails.TooLargeGDI := isImgSizeTooLarge(wiaImg.Width, wiaImg.Height)
      If (noBMP=1)
         oBitmap := 1
   } Else
   {
      addJournalEntry("Failed to load image file using WIA`n" imgPath)
      Return
   }

   If (fastMode!=1 && IsObject(wiaImg) && noBMP=0)
   {
      forceW := sizesDesired[1, 1]
      forceH := sizesDesired[1, 2]
      keepAratio := sizesDesired[1, 3]
      ScaleAnySize := sizesDesired[1, 4]
      If (forceW && forceH)
      {
         If (wiaImg.Width>forceW || wiaImg.Height>forceH || ScaleAnySize=1)
            Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, forceW, forceH, keepAratio)
      } Else If isImgSizeTooLarge(wiaImg.width, wiaImg.height)
      {
         mainLoadedIMGdetails.TooLargeGDI := 1
         setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits")
         changeMcursor()
         newW := wiaImg.width,  newH := wiaImg.height
         capIMGdimensionsGDIPlimits(newW, newH)
         Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, newW, newH, 1)
      }
   }

   If (IsObject(wiaImg) && noBMP=0)
   {
      Try PicObj := ScaledWiaIMG.Height ? WIA_GetImageBitmap(ScaledWiaIMG) : WIA_GetImageBitmap(wiaImg)
      If (PicObj.Handle)
      {
         setWindowTitle("Converting WIA image format to GDI+ bitmap")
         changeMcursor()
         If wiaImg.IsAlphaPixelFormat
            oBitmap := trGdip_CreateARGBBitmapFromHBITMAP(PicObj.Handle)
         Else
            oBitmap := trGdip_CreateBitmapFromHBITMAP(A_ThisFunc, PicObj.Handle)
         Gdi_DeleteObject(PicObj.Handle)
      }
   }

   If (IsObject(sizesDesired[2]) && IsObject(wiaImg))
   {
      forceW := sizesDesired[2, 1]
      forceH := sizesDesired[2, 2]
      keepAratio := sizesDesired[2, 3]
      ScaleAnySize := sizesDesired[2, 4]
      If (wiaImg.Width>forceW || wiaImg.Height>forceH || ScaleAnySize=1)
         Try ScaledWiaIMGb := WIA_ScaleImage(wiaImg, forceW, forceH, keepAratio)

      If (ScaledWiaIMGb.Height)
      {
         Try PicObju := WIA_GetImageBitmap(ScaledWiaIMGb)
         If wiaImg.IsAlphaPixelFormat
            newBitmap := trGdip_CreateARGBBitmapFromHBITMAP(PicObju.Handle)
         Else
            newBitmap := trGdip_CreateBitmapFromHBITMAP(A_ThisFunc, PicObju.Handle)
         Gdi_DeleteObject(PicObju.Handle)
      }
      ScaledWiaIMGb := ""
   }

   wiaImg := ""
   ScaledWiaIMG := ""
   PicObj := ""
   Return oBitmap
}

LoadBitmapForScreen(imgPath, allowCaching, frameu, forceGDIp:=0) {
  Static prevMD5nameA, prevMD5nameB

  initQPVmainDLL()
  If (alwaysOpenwithFIM=1)
     initFIMGmodule()

  coreIMGzeitLoad := A_TickCount
  If validBMP(UserMemBMP)
  {
     totalFramesIndex := 0
     currIMGdetails.PixelFormat := Gdip_GetImagePixelFormat(UserMemBMP, 2)
     If (currIMGdetails.HasAlpha!=1)
        currIMGdetails.PixelFormat := StrReplace(currIMGdetails.PixelFormat, "A")

     currIMGdetails.RawFormat := Gdip_GetImageRawFormat(UserMemBMP)
     trGdip_GetImageDimensions(UserMemBMP, w, h)
     currIMGdetails.Width := w
     currIMGdetails.Height := h
     ; currIMGdetails.HasAlpha := InStr(currIMGdetails.PixelFormat, "argb") ? 1 : 0
     currIMGdetails.Frames := 0
     prevMD5nameA := prevMD5nameB := ""
     ; If (minimizeMemUsage=1)
     discardSRCfileCaches()
     destroyGDIfileCache()
     Return trGdip_CloneBitmap(A_ThisFunc, UserMemBMP)
  }

  GDIbmpFileConnected := 1
  If (allowCaching=1)
  {
     MD5name := generateThumbName(imgPath, 1)
     ; fimStuff := (alwaysOpenwithFIM=1) ? 1 desiredFrameIndex totalFramesIndex : 0
     thisMD5name := MD5name imgPath userHQraw cmrRAWtoneMapAlgo cmrRAWtoneMapParamA cmrRAWtoneMapParamB allowToneMappingImg
     tFramesA := Gdip_GetBitmapFramesCount(GDIcacheSRCfileA) - 1
     tFramesB := Gdip_GetBitmapFramesCount(GDIcacheSRCfileB) - 1
     isFramesA := (tFramesA = AbackupIMGdetails.Frames) ? 1 : 0
     isFramesB := (tFramesB = BbackupIMGdetails.Frames) ? 1 : 0
     ; ToolTip, % thisMD5name "`n" prevMD5nameA "`n" prevMD5nameB "`n" isFramesA "=" isFramesB "`n" tFramesA "=" tFramesB "`n" AbackupIMGdetails.Frames "=" BbackupIMGdetails.Frames "`n" AbackupIMGdetails.FIle "=" BbackupIMGdetails.File , , , 2
     If (thisMD5name=prevMD5nameA && validBMP(GDIcacheSRCfileA) && StrLen(prevMD5nameA)>2 && isFramesA=1)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileA "`n" imgPath)
        totalFramesIndex := multiPageFileManaging(GDIcacheSRCfileA, desiredFrameIndex)
        currIMGdetails := AbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileA)
     } Else If (thisMD5name=prevMD5nameB && validBMP(GDIcacheSRCfileB) && StrLen(prevMD5nameB)>2 && isFramesB=1)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileB "`n" imgPath)
        totalFramesIndex := multiPageFileManaging(GDIcacheSRCfileB, desiredFrameIndex)
        currIMGdetails := BbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileB)
     } Else
     {
        prevMD5nameB := idGDIcacheSRCfileB := ""
        GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
     }
  }

  viewportQPVimage.DiscardImage()
  recordUndoLevelHugeImagesNow("kill", 0, 0, 0)
  If ((RegExMatch(imgPath, RegExFIMformPtrn) || (alwaysOpenwithFIM=1 && forceGDIp=0)) && allowFIMloader=1)
  {
     If (thumbsDisplaying!=1 && runningLongOperation!=1 && slideShowRunning!=1)
        setWindowTitle("Loading file using the FreeImage library")
     totalFramesIndex := 0
     oBitmap := LoadFimFile(imgPath, 0, 0, frameu, 0, n, 0, 1)
     totalFramesIndex := mainLoadedIMGdetails.Frames
     desiredFrameIndex := clampInRange(frameu, 0, totalFramesIndex)
     GDIbmpFileConnected := 0
  } Else If (RegExMatch(imgPath, RegExWICfmtPtrn) && WICmoduleHasInit=1 && allowWICloader=1)
  {
     totalFramesIndex := 0
     thisImgQuality := (userimgQuality=1) ? 6 : 5
     oBitmap := LoadWICscreenImage(imgPath, 0, frameu)
     If (!validBMP(oBitmap) && wasInitFIMlib=1 && allowFIMloader=1 && oBitmap!="very-large")
        oBitmap := LoadFimFile(imgPath, 0, 0, frameu, 0, n, 1, 1)
     totalFramesIndex := mainLoadedIMGdetails.Frames
     desiredFrameIndex := clampInRange(frameu, 0, totalFramesIndex)
     GDIbmpFileConnected := 0
  } Else
  {
     totalFramesIndex := 0
     oBitmap := LoadFileWithGDIp(imgPath, 0, frameu)
     If (!validBMP(oBitmap) && wasInitFIMlib=1 && allowFIMloader=1)
        oBitmap := LoadFimFile(imgPath, 0, 0, frameu, 0, n, 1, 1)

     If (mainLoadedIMGdetails.TooLargeGDI=1 || InStr(Gdip_GetImageRawFormat(oBitmap), "MEMORYBMP"))
        GDIbmpFileConnected := 0

     totalFramesIndex := mainLoadedIMGdetails.Frames
     desiredFrameIndex := clampInRange(frameu, 0, totalFramesIndex)
  }

  ; viewportQPVimage.LoadImage(imgPath, frameu)
  ; calcIMGdimensions(viewportQPVimage.imgW, viewportQPVimage.imgH, 500, 500, newW, newH)
  ; oBitmap := trGdip_CreateBitmap(A_ThisFunc, newW, newH)
  If (oBitmap="very-large")
  {
     ; r := viewportQPVimage.LoadImage(imgPath, frameu)
     w := viewportQPVimage.Width, h := viewportQPVimage.Height
     calcIMGdimensions(w, h, 300, 300, newW, newH)
     ; ToolTip, % w "|" h , , , 2
     oBitmap := trGdip_CreateBitmap(A_ThisFunc, newW, newH)
     currIMGdetails := []
     currIMGdetails.ImgFile := viewportQPVimage.ImgFile
     currIMGdetails.imgHandle := viewportQPVimage.imgHandle
     currIMGdetails.HasAlpha := viewportQPVimage.HasAlpha
     currIMGdetails.RawFormat := viewportQPVimage.RawFormat
     currIMGdetails.PixelFormat := viewportQPVimage.PixelFormat
     currIMGdetails.OpenedWith := viewportQPVimage.OpenedWith
     currIMGdetails.LoadedWith := viewportQPVimage.LoadedWith
     currIMGdetails.TooLargeGDI := viewportQPVimage.TooLargeGDI
     currIMGdetails.Width := viewportQPVimage.Width
     currIMGdetails.Height := viewportQPVimage.Height
     currIMGdetails.dpiX := viewportQPVimage.dpiX
     currIMGdetails.dpiY := viewportQPVimage.dpiY
     currIMGdetails.DPI := viewportQPVimage.DPI
     currIMGdetails.FIMcolors := viewportQPVimage.FIMcolors
     currIMGdetails.FIMtype := viewportQPVimage.FIMtype
     currIMGdetails.FIMbpp := viewportQPVimage.FIMbpp
     currIMGdetails.Frames := viewportQPVimage.Frames
     currIMGdetails.ActiveFrame := viewportQPVimage.ActiveFrame
     totalFramesIndex := viewportQPVimage.Frames
     desiredFrameIndex := viewportQPVimage.ActiveFrame
  } Else
  {
     If (allowCaching=1 && validBMP(oBitmap))
     {
        If (slideShowRunning!=1) || (slideShowRunning=1 && slideShowDelay>600)
        {
           zu := Format("{:L}", imgPath)
           If !userSeenSessionImagesArray[zu]
           {
              userSeenSessionImagesIndex++
              userSeenSessionImagesArray[zu] := userSeenSessionImagesIndex
           }
        }

        prevMD5nameB := prevMD5nameA
        prevMD5nameA := thisMD5name
        idGDIcacheSRCfileB := idGDIcacheSRCfileA
        idGDIcacheSRCfileA := GDIbmpFileConnected MD5name imgPath
        GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
        GDIcacheSRCfileB := GDIcacheSRCfileA
        GDIcacheSRCfileA := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
        BbackupIMGdetails := AbackupIMGdetails.Clone()
        AbackupIMGdetails := mainLoadedIMGdetails.Clone()
     }

     currIMGdetails := mainLoadedIMGdetails.Clone()
  }

  UpdateFilesListImgIDinfos(currentFileIndex)
  Return oBitmap
}

LoadFileWithGDIp(imgPath, noBPPconv:=0, frameu:=0, sizesDesired:=0, ByRef newBitmap:=0) {
  changeMcursor()
  mustOpenWithWIC := 0
  oBitmap := trGdip_CreateBitmapFromFile(A_ThisFunc, imgPath)
  If validBMP(oBitmap)
  {
     pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
     trGdip_GetImageDimensions(oBitmap, imgW, imgH)
     Gdip_BitmapGetDPIResolution(oBitmap, dpix, dpiy)
     mainLoadedIMGdetails.File := imgPath
     mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
     mainLoadedIMGdetails.Width := imgW
     mainLoadedIMGdetails.Height := imgH
     mainLoadedIMGdetails.Frames := Gdip_GetBitmapFramesCount(oBitmap) - 1
     mainLoadedIMGdetails.HasAlpha := InStr(pixFmt, "argb") ? 1 : 0
     mainLoadedIMGdetails.PixelFormat := pixFmt
     mainLoadedIMGdetails.RawFormat := Gdip_GetImageRawFormat(oBitmap)
     mainLoadedIMGdetails.OpenedWith := "[GDI+]"
     mainLoadedIMGdetails.TooLargeGDI := 0
     If (RegExMatch(mainLoadedIMGdetails.RawFormat, "i)(gif|tiff)$") && mainLoadedIMGdetails.Frames>0 && frameu>0)
     {
        frameu := clampInRange(frameu, 0, mainLoadedIMGdetails.Frames)
        Gdip_BitmapSelectActiveFrame(oBitmap, frameu)
     }

     ; ToolTip, % imgW "-" imgH "-" pixFmt , , , 2
     If (InStr(pixFmt, "CMYK") || InStr(pixFmt, "48-") || InStr(pixFmt, "64-"))
        ER := Gdip_BitmapSetColorDepth(oBitmap, 32, 1)

     forceW := sizesDesired[1, 1]
     forceH := sizesDesired[1, 2]
     mustRsize := (forceW>1 && forceH>1 && noBPPconv=0) ? 1 : 0
     If (!imgW || !imgH || ER || InStr(pixFmt, "0x"))
     {
        mustOpenWithWIC := 1
     } Else If (isImgSizeTooLarge(imgW, imgH) && mustRsize=0 && noBPPconv=0)
     {
        addJournalEntry("Rescaling image to GDI+ maximum image dimensions limits")
        newW := imgW, newH := imgH
        capIMGdimensionsGDIPlimits(newW, newH)
        nBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, newW, newH, 1, 3, -1)
        If validBMP(nBitmap)
        {
           mainLoadedIMGdetails.TooLargeGDI := 1
           oBitmap := trGdip_DisposeImage(oBitmap, 1)
           oBitmap := nBitmap
        } Else mustOpenWithWIC := 1
     }
  } Else mustOpenWithWIC := 1

   If (mustOpenWithWIC=1 && noBPPconv=0 && WICmoduleHasInit=1 && allowWICloader=1) ; || (allowCaching=1)
   {
      oBitmap := trGdip_DisposeImage(oBitmap, 1)
      oBitmap := LoadWICimage(imgPath, noBPPconv, frameu, sizesDesired, newSizedImage)
      newBitmap := newSizedImage
      Return oBitmap
   } Else If (mustOpenWithWIC=1 && noBPPconv=0) ; || (allowCaching=1)
   {
      oBitmap := trGdip_DisposeImage(oBitmap, 1)
      oBitmap := LoadFileWithWIA(imgPath, noBPPconv, 0, sizesDesired, newSizedImage)
      newBitmap := newSizedImage
      Return oBitmap
   }

   If (sizesDesired.Count()>1 && validBMP(oBitmap) && noBPPconv=0 && mustOpenWithWIC!=1)
   {
      hasFlipped := 0
      newBitmap := []
      Loop, % sizesDesired.Count()
      {
         ; ToolTip, % mainLoadedIMGdetails.width "==" mainLoadedIMGdetails.height "|" z "==" W "=f" frameu "==s" ScaleAnySize "==k" keepAratio , , , 2
         forceW := sizesDesired[A_Index + 1, 1]
         forceH := sizesDesired[A_Index + 1, 2]
         If (forceW>1 && forceH>1)
         {
            keepAratio := sizesDesired[A_Index + 1, 3]
            ScaleAnySize := sizesDesired[A_Index + 1, 4]
            thisImgQuality := sizesDesired[A_Index + 1, 5]
            doFlipu := sizesDesired[A_Index + 1, 6]
            If (imgW>forceW || imgH>forceH || ScaleAnySize=1)
            {
               If (doFlipu>0 && hasFlipped=0)
               {
                  hasFlipped := 1
                  Gdip_ImageRotateFlip(oBitmap, doFlipu)
               }

               zbmp := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, forceW, forceH, keepAratio, thisImgQuality, -1)
               If !validBMP(zbmp)
               {
                  mustOpenWithWIC := 1
                  Break
               }

               newBitmap[A_Index] := zbmp
               NextDoFlipu := sizesDesired[A_Index + 2, 6]
               If (doFlipu>0 && !NextDoFlipu)
               {
                  hasFlipped := 0
                  Gdip_ImageRotateFlip(oBitmap, doFlipu)
               }
            }
         }
      }
   }

   If (mustOpenWithWIC!=1)
   {
      forceW := sizesDesired[1, 1]
      forceH := sizesDesired[1, 2]
   }

   If (forceW>1 && forceH>1 && noBPPconv=0 && mustOpenWithWIC!=1)
   {
      keepAratio := sizesDesired[1, 3]
      ScaleAnySize := sizesDesired[1, 4]
      thisImgQuality := sizesDesired[1, 5]
      If (imgW>forceW || imgH>forceH || ScaleAnySize=1)
         zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, forceW, forceH, keepAratio, thisImgQuality, -1)

      If validBMP(zBitmap)
      {
         trGdip_DisposeImage(oBitmap)
         oBitmap := zBitmap
      } Else mustOpenWithWIC := 1
   }

   If (mustOpenWithWIC=1 && noBPPconv=0 && WICmoduleHasInit=1 && allowWICloader=1)
   {
      oBitmap := trGdip_DisposeImage(oBitmap, 1)
      oBitmap := LoadWICimage(imgPath, noBPPconv, frameu, sizesDesired, newSizedImage)
      newBitmap := newSizedImage
      Return oBitmap
   } Else If (mustOpenWithWIC=1 && noBPPconv=0) ; || (allowCaching=1)
   {
      oBitmap := trGdip_DisposeImage(oBitmap, 1)
      oBitmap := LoadFileWithWIA(imgPath, noBPPconv, 0, sizesDesired, newSizedImage)
      newBitmap := newSizedImage
      Return oBitmap
   }

   Return oBitmap
}

LoadBitmapFromFileu(imgPath, noBPPconv:=0, forceGDIp:=0, frameu:=0, sizesDesired:=0, ByRef newSizedImage:=0) {
; LoadFimFile() on fail, fallsback to LoadWICimage()
; LoadWICimage() on fail, fallsback to LoadFimFile()
; LoadFileWithGDIp() on fail, fallsback to LoadWICimage(), and if needed to LoadFimFile()

  mainLoadedIMGdetails := []
  If ((RegExMatch(imgPath, RegExFIMformPtrn) || (alwaysOpenwithFIM=1 && forceGDIp=0)) && allowFIMloader=1)
  {
     ; oBitmap := LoadFimFile(imgPath, noBPPconv, noBPPconv, frameu, sizesDesired, newBitmap)
     oBitmap := LoadFimFile(imgPath, noBPPconv, noBPPconv, frameu, sizesDesired, newBitmap)
     newSizedImage := newBitmap
     ; fnOutputDebug(A_ThisFunc "(): " imgPath)
  } Else If (RegExMatch(imgPath, RegExWICfmtPtrn) && WICmoduleHasInit=1 && allowWICloader=1)
  {
     oBitmap := LoadWICimage(imgPath, noBPPconv, frameu, sizesDesired, newBitmap)
     If (!validBMP(oBitmap) && allowFIMloader=1 && wasInitFIMlib=1)
        oBitmap := LoadFimFile(imgPath, noBPPconv, noBPPconv, frameu, sizesDesired, newBitmap, 1)
     newSizedImage := newBitmap
  } Else 
  {
     oBitmap := LoadFileWithGDIp(imgPath, noBPPconv, frameu, sizesDesired, newBitmap)
     If (!validBMP(oBitmap) && allowFIMloader=1 && wasInitFIMlib=1)
        oBitmap := LoadFimFile(imgPath, noBPPconv, noBPPconv, frameu, sizesDesired, newBitmap, 1)

     newSizedImage := newBitmap
  }

  Return oBitmap
}

Gdip_CloneBmpPargbArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:=0, KeepPixelFormat:=0, ignoreBounds:=0, addBgr:=0) {
   thisPixFmt := !PixelFormat ? coreDesiredPixFmt : PixelFormat
   ; If (thisPixFmt="0xE200B" && userimgQuality=0)
   ;    thisPixFmt := "0x26200A"

   If (ignoreBounds=1 && w>0 && h>0)
   {
       trGdip_GetImageDimensions(pBitmap, imgW, imgH)
       If (isDotInRect(x, y, 0, imgW, 0, imgH) && isDotInRect(x + w, y + h, 0, imgW, 0, imgH))
       {
          simpleMode := 1
          newBitmap := trGdip_CloneBitmapArea(A_ThisFunc "<-" funcu, pBitmap, x, y, w, h, thisPixFmt, KeepPixelFormat)
       } Else newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, w, h, thisPixFmt)

       If (validBMP(newBitmap) && simpleMode!=1)
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc "() initially invoked by " funcu, newBitmap, 3)
          If G2
          {
             r1 := trGdip_DrawImage(A_ThisFunc "() initially invoked by " funcu, G2, pBitmap, 0, 0, w, h, x, y, w, h)
             If (addBgr=1)
             {
                x1 := (x<0) ? Abs(x) : 0
                y1 := (y<0) ? Abs(y) : 0
                x2 := (x + w > imgW) ? x1 + w - ((x + w) - imgW) : x1 + w
                y2 := (y + h > imgH) ? y1 + h - ((y + h) - imgH) : y1 + h
                Gdip_SetClipRect(G2, x1, y1, w, h, 4)
                ; r1 := trGdip_DrawImage(A_ThisFunc "() initially invoked by " funcu, G2, pBitmap, 0, 0, w, h, x3, y3, w2, h2)
                ; ToolTip, % x1 "=" y1 "=" x2 "=" y2 "`n" w "=" h , , , 2
                trGdip_GraphicsClear(A_ThisFunc "() initially invoked by " funcu, G2, "0x01828282")
             }
          }

          Gdip_DeleteGraphics(G2)
          If (r1="fail" || !G2)
          {
             trGdip_DisposeImage(newBitmap, 1)
             newBitmap := ""
          }
       }
   } Else
     newBitmap := trGdip_CloneBitmapArea(A_ThisFunc "<-" funcu, pBitmap, x, y, w, h, thisPixFmt, KeepPixelFormat)

   If !validBMP(newBitmap)
   {
      baseMsg := "Unable to create internal PARGB bitmap clone to apply operations on image... Error occured in " A_ThisFunc "() invoked by " funcu  "() for pBMP=" pBitmap ". w,h=" w " | " h ". x,y=" x " | " y
      generalInternalErrorMsgBox(gdipLastError, baseMsg)
      newBitmap := ""
   }

   Return newBitmap
}

generalInternalErrorMsgBox(err, baseMsg, silentMode:=0) {
   Static forceSilent := 0

   If err
      message := "`n`n" Gdip_ErrorHandler(err, 0)

   friendly := (A_PtrSize=4) ? "`n`nPossible cause: memory limit reached." : ""
   friendly .= (A_PtrSize=4 && A_is64BitOS) ? " Please use the 64-bits edition of this application." : ""
   If (InStr(message, "out_of_memory") && maxMemUndoLevels>12012)
      maxMemUndoLevels -= 100000

   addJournalEntry(baseMsg message friendly)
   If (runningLongOperation!=1 && hasInitSpecialMode!=1 && silentMode=0 && forceSilent=0)
   {
      If (imgEditPanelOpened=1)
         doImgEditLivePreview := 0
      ; SoundBeep, 300, 100
      simpleMsgBoxWrapper(appTitle ": ERROR", baseMsg message friendly, 0, 0, "error")
      If (InStr(baseMsg, glPG) || InStr(baseMsg, 2NDglPG)) && (forceSilent=0)
      {
         info := (debugModa=1) ? "" : "You can start QPV with /qpv-debug to view all error messages in a debug viewer."
         msgResult := msgBoxWrapper(appTitle, "It seems you are receving errors related to core viewport components. Choose Yes to no longer receive GDI+ error messages.`n`nAnyhow, the application will likely continue to malfunction, but at least in silence.", 4, 0, "question")
         If (msgResult="yes")
            forceSilent := 1
      }
   }
}

highlightActiveArrowsCtrl() {
    highlightActiveCtrl("arrows")
}

highlightActiveCtrl(modus:=0, givenHwnd:=0) {
   Static prevCtrl

   If (modus="RButton")
   {
      ActiveHwnd := WinActive("A")
      If (isVarEqualTo(ActiveHwnd, hfdTreeWinGui, hQuickMenuSearchWin, MsgBox2hwnd, hSetWinGui) && isNowFakeWinOpen=1)
         Return

      MouseGetPos, , , id, hwnd, 2
      ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
      ControlGet, ctrlActiveState, Enabled,,, ahk_id %hwnd%
      ControlGetText, info, , ahk_id %hwnd%
      If (posuk := InStr(info, "&"))
         hotkeyu := "`nAlt+" SubStr(info, posuk + 1, 1)

      info := StrReplace(info, "&")
      WinGetClass, OutputVar, ahk_id %hwnd%
      If InStr(OutputVar, "_trackbar")
      {
         SendMessage, 0x0400,,,, ahk_id %hwnd%   ; TBM_GETPOS
         curr := ErrorLevel
         SendMessage, 0x0401,,,, ahk_id %hwnd%   ; TBM_GETRANGEMIN
         minu := ErrorLevel
         SendMessage, 0x0402,,,, ahk_id %hwnd%   ; TBM_GETRANGEMAX
         maxu := ErrorLevel
         OutputVar := "Slider: " curr " | " minu "; " maxu
      } Else If InStr(OutputVar, "combol") 
      {
         ; VarSetCapacity(varu, 34521, 0)
         SendMessage, 0x018B,,,, ahk_id %hwnd%   ; LB_GETCOUNT
         maxu := ErrorLevel
         SendMessage, 0x0188,,,, ahk_id %hwnd%   ; LB_GETCURSEL
         curr := ErrorLevel
         ; SendMessage, 0x0140, % curr, &varu,, ahk_id %hwnd%   ; CB_GETEDITSEL
         ; curr .= ErrorLevel
         OutputVar := "List box: " curr " / " maxu
         ; varu := ""
      } Else If InStr(OutputVar, "ComboBox") 
      {
         ; ControlGet, userChoice, Choice,,, ahk_id %hwnd%
         SendMessage, 0x0147,,,, ahk_id %hwnd%   ; CB_GETCURSEL
         curr := ErrorLevel + 1
         info := curr " = " info
      } Else If (OutputVar="button") 
      {
         ControlGet, userChoice, Checked,,, ahk_id %hwnd%
         ControlGet, stylu, Style,,, ahk_id %hwnd%
         r := (stylu & 0x00000002) ? 1 : 0
         If r
            OutputVar := "Checkbox: " userChoice
      } Else If InStr(OutputVar, "_updown")
      {
         SendMessage, 0x0400+102,,,, ahk_id %hwnd%   ; UDM_GETRANGE
         UDM_GETRANGE := ErrorLevel
         minu := UDM_GETRANGE >> 16
         maxu := UDM_GETRANGE & 0xFFFF
         OutputVar := "Up/Down number range: " minu "; " maxu
      } Else If InStr(OutputVar, "edit")
      {
         OutputVar := "Edit field"
      } Else If (InStr(OutputVar, "static") && value && ctrlu)
      {
         OutputVar := "Maybe clickable" ; value  " - " ctrlu
      }

      msg2show := Trimmer(info "`n[" OutputVar "] " hotkeyu)
      If StrLen(listBoxOptions)>3
      {
         countListBoxOptions := ST_Count(listBoxOptions, "`n") + 1
         If (countListBoxOptions>10)
            listBoxOptions := "[too many to list]"
         msg2show .= "`n`nLIST OPTIONS: " countListBoxOptions "`n" listBoxOptions
      }

      thisSize := (PrefsLargeFonts=1) ? Round(LargeUIfontValue*1.55) : LargeUIfontValue
      mouseCreateOSDinfoLine(msg2show, thisSize)
      Sleep, 500
      Return
   } Else If (modus="click")
   {
      GuiControlGet, whichHwnd, hwnd, %A_GuiControl%
      WinGetClass, ctrlClassNN, ahk_id %whichHwnd%
      ; MouseGetPos, , , WhichWindow, whichHwnd
      If InStr(ctrlClassNN, "static" && whichHwnd!=hCropCornersPic)
      {
         prevCtrl := 0
         ControlFocus, , ahk_id %whichHwnd%
         highlightActiveCtrl()
      }
      Return
   }

   thisHwnd := (modus="given" && givenHwnd) ? givenHwnd : WinActive("A")
   ControlGetFocus, ctrlClassNN, ahk_id %thisHwnd%
   ControlGet, ctrlHwnd, Hwnd,, % ctrlClassNN, ahk_id %thisHwnd%
   ControlGetPos, x, y, w, h, % ctrlClassNN, ahk_id %thisHwnd%
   thisCtrl := ctrlClassNN ctrlHwnd x y w h modus
   If (thisCtrl=prevCtrl) || (InStr(ctrlClassNN, "edit") && InStr(modus, "space"))
      Return

   prevCtrl := thisCtrl
   JEE_ClientToScreen(thisHwnd, 1, 1, aX, aY)
   WinGetPos, zX, zY, ,, ahk_id %thisHwnd%
   kX := aX - zX
   kY := aY - zY

   JEE_ClientToScreen(thisHwnd, x, y, X2, Y2)
   x2 -= kX,   y2 -= kY
   x2 += 3,    y2 += 3

   interfaceThread.ahkPostFunction("ShowClickHalo", x2, y2, w, h, 1)
   If (InStr(modus, "space") && (ctrlClassNN ~= "i)(static|combobox|syslistview32)"))
   {
      If (thisHwnd=hSetWinGui)
      {
         GuiControlGet, vLabel, SettingsGUIA: FocusV
         If (!InStr(vLabel, "color") && InStr(ctrlClassNN, "syslistview32"))
            Return
      }

      prevCtrl := 0
      doSetCursorPos(x2, y2)
      Sleep, 1
      Click
   }
   ; ToolTip, % vLabel "=" x "--" y "--" w "--" h "`n" ctrlClassNN "||" ctrlHwnd , , , 2
}

CloneScreenMainBMP(imgPath, mustReloadIMG, ByRef hasFullReloaded) {
  Critical, on
  Static prevFrame := -1, lastInvoked := 1

  GDIbmpFileConnected := 1
  hasFullReloaded := CountGIFframes := totalFramesIndex := 0
  MD5name := generateThumbName(imgPath, 1)
  o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
  thisImgCall := MD5name imgPath o_bwDithering ColorDepthDithering vpIMGrotation
  If !FileRexists(imgPath) && (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath))
     thisImgCall := InStr(AprevImgCall, imgPath) ? SubStr(AprevImgCall, 2) : SubStr(BprevImgCall, 2)

  prevLastImg[2] := prevLastImg[1]
  prevLastImg[1] := [currentFileIndex, resultedFilesList[currentFileIndex, 1]]
  gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
  backupGdiBMP := trGdip_DisposeImage(backupGdiBMP, 1)
  ignoreCache := (prevFrame!=desiredFrameIndex || minimizeMemUsage=1 || validBMP(UserMemBMP)) ? 1 : mustReloadIMG
  ; MsgBox, % imgPath "`n" AbackupIMGdetails.File "`n" BbackupIMGdetails.File "`n" CbackupIMGdetails.File
  If (SubStr(AprevImgCall, 2)=thisImgCall && validBMP(AprevGdiBitmap) && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     trGdip_GetImageDimensions(AprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, AprevGdiBitmap)
     addJournalEntry("Used cached GDI bitmap ID: " AprevGdiBitmap "`n" imgPath)
     gdiBitmapIDcall := AprevImgCall
     gdiBitmapIDentire := AprevImgCall gdiBitmap
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     extractAmbientalTexture()
     totalFramesIndex := currIMGdetails.Frames
     Return
  } Else If (SubStr(BprevImgCall, 2)=thisImgCall && validBMP(BprevGdiBitmap) && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     trGdip_GetImageDimensions(BprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, BprevGdiBitmap)
     gdiBitmapIDcall := BprevImgCall
     gdiBitmapIDentire := BprevImgCall gdiBitmap
     addJournalEntry("Used cached GDI bitmap ID: " BprevGdiBitmap "`n" imgPath)
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     totalFramesIndex := currIMGdetails.Frames
     extractAmbientalTexture()
     Return
  }

  pargbPixFmt := (coreDesiredPixFmt="0xE200B") ? -1 : 0
  If (slideShowRunning!=1 && desiredFrameIndex<1) && (A_TickCount - lastInvoked>250)
     GdipCleanMain(6)

  interfaceThread.ahkassign("canCancelImageLoad", 1)
  changeMcursor()
  thisImgPath := imgPath
  allowCaching := !minimizeMemUsage
  If validBMP(UserMemBMP)
     allowCaching := 0

  If (slideShowRunning!=1 && (A_TickCount - lastInvoked>2000))
     interfaceThread.ahkPostFunction("uiAccessImgViewSetUIlabels")

  oBitmap := LoadBitmapForScreen(thisImgPath, allowCaching, desiredFrameIndex)
  ; ToolTip, % currIMGdetails.OpenedWith , , , 2
  If !validBMP(oBitmap)
     Return "error"

  killQPVscreenImgSection()
  lastInvoked := A_TickCount
  slowFileLoad := (A_TickCount - coreIMGzeitLoad > 450) ? 1 : 0
  hasFullReloaded := 1
  rawFmt := Gdip_GetImageRawFormat(oBitmap)
  rawFmt := (rawFmt="MEMORYBMP" && fimMultiPage) ? fimMultiPage : rawFmt
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad

  ; If (RegExMatch(rawFmt, "i)(gif|tiff)$") && totalFramesIndex>0)
  If (currIMGdetails.frames>0)
  {
     totalFramesIndex := currIMGdetails.Frames
     multiFrameImg := 1
  } Else If (rawFmt="MEMORYBMP")
     GDIbmpFileConnected := 0

  If ((InStr(currIMGdetails.RawFormat, "webp") || InStr(currIMGdetails.RawFormat, "gif")) && totalFramesIndex>0)
  {
     gifLoaded := 1
     CountGIFframes := (animGIFsSupport=1) ? totalFramesIndex : 0
     setGIFframesDelay(oBitmap)
  }

  If (viewportQPVimage.imgHandle)
  {
     imgW := viewportQPVimage.Width
     imgH := viewportQPVimage.Height
  } Else
     trGdip_GetImageDimensions(oBitmap, imgW, imgH)

  totalIMGres := imgW + imgH
  defineRelativeSelCoords(imgW, imgH)
  totalScreenRes := ResolutionWidth + ResolutionHeight
  thisImgQuality := (userimgQuality=1) ? 6 : 5
  If (minimizeMemUsage=1 && rawFmt!="MEMORYBMP")
     thisImgQuality := ""

  changeMcursor()
  newW := imgW,  newH := imgH
  isGIFgdip := ((animGIFplaying=1 || gifLoaded=1) && currIMGdetails.OpenedWith="[GDI+]") ? 1 : 0
  If (userPrivateMode=1 || isGIFgdip=1 || minimizeMemUsage!=1 && rawFmt!="MEMORYBMP")
  {
     If (userPrivateMode=1)
     {
        rBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 800, 800, 1, 5, pargbPixFmt)
        blurEffect := Gdip_CreateEffect(1, 150, 0, 0)
        Gdip_BitmapApplyEffect(rBitmap, blurEffect)
        Gdip_DisposeEffect(blurEffect)
        klBitmap := trGdip_ResizeBitmap(A_ThisFunc, rBitmap, imgW, imgH, 1, 5, pargbPixFmt)
        If validBMP(klBitmap)
        {
           trGdip_DisposeImage(rBitmap)
           rBitmap := klBitmap
        }
    } Else ; If (isGIFgdip=1)
        rBitmap := cloneGDItoMem(A_ThisFunc, oBitmap)

    If validBMP(rBitmap)
    {
       GDIbmpFileConnected := 0
       trGdip_DisposeImage(oBitmap, 1)
    } Else rBitmap := oBitmap
  } Else
  {
     If (currIMGdetails.HasAlpha=1 && rawFmt!="MEMORYBMP")
        rBitmap := cloneGDItoMem(A_ThisFunc, oBitmap)

     If validBMP(rBitmap)
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
     } Else rBitmap := oBitmap
  }

  If (vpIMGrotation!=0)
  {
     trGdip_GetImageDimensions(rBitmap, imgW, imgH)
     Gdip_GetRotatedDimensions(imgW, imgH, 45, ResizedW, ResizedH)
     If isImgSizeTooLarge(ResizedW, ResizedH)
     {
        vpIMGrotation := 0
        INIaction(1, "vpIMGrotation", "General")
     }
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && vpIMGrotation>0)
  {
     setWindowTitle("Rotating image at " vpIMGrotation "°")
     brushu := (currIMGdetails.HasAlpha!=1 || gifLoaded=1) ? pBrushWinBGR : ""
     changeMcursor()
     nBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, rBitmap, vpIMGrotation, "", imgQuality, pargbPixFmt)
     If validBMP(nBitmap)
     {
        trGdip_GetImageDimensions(nBitmap, imgW, imgH)
        newW := imgW, newH := imgH
        currIMGdetails.HasAlpha := 1
        trGdip_DisposeImage(rBitmap, 1)
        rBitmap := nBitmap
     } Else 
     {
        vpIMGrotation := 0
        INIaction(1, "vpIMGrotation", "General")
     }
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && bwDithering=1 && imgFxMode=4)
  {
     GDIbmpFileConnected := 0
     setWindowTitle("Converting image to black and white with dithering")
     If (currIMGdetails.HasAlpha=1)
        E := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)

     zBitmap := trGdip_BitmapConvertGray(A_ThisFunc, rBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
     If validBMP(zBitmap)
     {
        trGdip_DisposeImage(rBitmap, 1)
        rBitmap := zBitmap
        zE := Gdip_BitmapSetColorDepth(rBitmap, "BW", 1)
        If !zE
        {
           zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, rBitmap)
           If validBMP(zBitmap)
           {
              trGdip_DisposeImage(rBitmap)
              rBitmap := zBitmap
           }
        }
        currIMGdetails.HasAlpha := 0
     }
  } Else If (usrColorDepth>1)
  {
     infoColorDepth := defineColorDepth()
     setWindowTitle("Converting image to " infoColorDepth)
     If (currIMGdetails.HasAlpha=1)
        zE := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)
     If !zE
        zE := Gdip_BitmapSetColorDepth(rBitmap, internalColorDepth, ColorDepthDithering)
     If !zE
     {
        zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, rBitmap)
        If validBMP(zBitmap)
        {
           trGdip_DisposeImage(rBitmap)
           rBitmap := zBitmap
        }
     }
     currIMGdetails.HasAlpha := 0
  }

  trGdip_GetImageDimensions(rBitmap, fimgW, fimgH)
  BprevImgCall := AprevImgCall
  AprevImgCall := "a" GDIbmpFileConnected MD5name imgPath o_bwDithering "|==|" ColorDepthDithering vpIMGrotation desiredFrameIndex totalFramesIndex currentUndoLevel undoLevelsRecorded fimgW fimgH
  gdiBitmapIDcall := AprevImgCall
  gdiBitmapIDentire := AprevImgCall rBitmap
  gdiBitmap := rBitmap
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  extractAmbientalTexture(abortImgLoad)
  BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
  prevFrame := desiredFrameIndex
  If (allowCaching=1)
  {
     BprevGdiBitmap := AprevGdiBitmap
     AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
  }
  imgW := newW, imgH := newH
  ; msgbox, % a_thisfunc "=" totalFramesIndex
}

extractAmbientalTexture(abortImgLoad:=0) {
    confirmTexBGR := isVarEqualTo(vpIMGrotation, 0, 90, 180, 270)
    If (abortImgLoad<3 && usrTextureBGR=1 && IMGresizingMode!=5 && confirmTexBGR=1)
    {
       setWindowTitle("Extracting image texture for the window background")
       If gdiAmbientalTexBrush
          Gdi_DeleteObject(gdiAmbientalTexBrush)

       decideGDIPimageFX(matrix, imageAttribs, pEffect)
       TexBrush := Gdip_CreateTextureBrush(useGdiBitmap(), 3, 3, 3, ambiTexBrushSize, ambiTexBrushSize, matrix, 0, 0, 0, imageAttribs)
       If TexBrush
       {
          klBMP := trGdip_CreateBitmap(A_ThisFunc, ambiTexBrushSize*2, ambiTexBrushSize*2)
          If validBMP(klBMP)
          {
             Gup := Gdip_GraphicsFromImage(klBMP)
             Gdip_FillRectangle(Gup, TexBrush, 0, 0, ambiTexBrushSize*2, ambiTexBrushSize*2)
             gdiAmbientalTexBrush := createGDIbrushPbitmap(klBMP)
             Gdip_DeleteGraphics(Gup)
             trGdip_DisposeImage(klBMP)
          }
          Gdip_DeleteBrush(TexBrush)
       }
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
    }

    preventScreenOff()
    OnImgFileChangeActions(0)
    If (autoPlaySNDs=1)
    {
       AutoPlayAudioFileAssociated()
       identifyAudioMediaLength()
    }
}

OnImgFileChangeActions(forceThis) {
  Static prevImgPath := ""
  imgPath := currentFileIndex "=" getIDimage(currentFileIndex)
  If (imgPath=prevImgPath && forceThis=0)
  {
     Return
  } Else
  {
     SetTimer, RemoveTooltip, -200
     If (LimitSelectBoundsImg!=1 && editingSelectionNow=1)
        correctActiveSelectionAreaViewPort()

     GIFframesPlayied := 0
     allowNextSlide := 1
     If (A_TickCount - lastGIFdestroy > 950)
        prevAnimGIFwas := ""
     If (hSNDmedia && autoPlaySNDs!=1)
        StopMediaPlaying()
     If (slideShowRunning=1) ;  && (animGIFplaying!=1 || totalFramesIndex<2))
        invokeExternalSlideshowHandler()
  }

  prevImgPath := imgPath
}

invokeExternalSlideshowHandler() {
   allowNextSlide := 1
   interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
   interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
   interfaceThread.ahkPostFunction("dummySlideshow")
}

identifyAudioMediaLength() {
   If hSNDmedia
   {
      milisec := MCI_Length(hSNDmedia)
      hSNDmediaDuration := MCI_ToHHMMSS(milisec)
      If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(1)
   } Else If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(1)
}

IdentifyAudioFileAssociated() {
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3)
    {
       AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
       If StrLen(AudioFileu)>3 && FileExist(AudioFileu)
          Return AudioFileu
    }

    audioFile1 := OutDir "\" OutNameNoExt ".WAv"
    audioFile2 := OutDir "\" OutNameNoExt ".WMA"
    audioFile3 := OutDir "\" OutNameNoExt ".MP3"

    If FileRexists(audioFile1)
       thisSNDfile := audioFile1
    Else If FileRexists(audioFile2)
       thisSNDfile := audioFile2
    Else If FileRexists(audioFile3)
       thisSNDfile := audioFile3
    Else
       thisSNDfile := 0
    Return thisSNDfile
}

PlayAudioFileAssociatedNow() {
    If (thumbsDisplaying=1)
       Return

    restartGIFplayback()
    ohSNDmediaFile := hSNDmediaFile
    ohSNDmedia := hSNDmedia
    StopMediaPlaying()
    If (ohSNDmediaFile && ohSNDmedia)
    {
       zPlitPath(ohSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("Media file stopped: `n" OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       dummyTimerDelayiedImageDisplay(50)
       Return
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       identifyAudioMediaLength()
       zPlitPath(hSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       thisMsg := (E || !hSNDmedia) ? "ERROR: " E " - " hSNDmedia ". Unable to play media file: `n" : "Media file now playing: `n(" hSNDmediaDuration ") " 
       showTOOLtip(thisMsg OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime

       If (E || !hSNDmedia)
          StopMediaPlaying()
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("WARNING: No media file found to play`n" OutNameNoExt " (.WAV / .WMA / .MP3)`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
}

AutoPlayAudioFileAssociated() {
    Static prevAudioFile
    thisSNDfile := IdentifyAudioFileAssociated()
    If (thisSNDfile=prevAudioFile && StrLen(thisSNDfile)>3)
       Return

    StopMediaPlaying()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       milisec := MCI_Length(hSNDmedia)
       If (E || !hSNDmedia || milisec<350)
          StopMediaPlaying()
       Else
          prevAudioFile := hSNDmediaFile
    } Else prevAudioFile := ""
}

startSlidesMusicNow() {
    StopMediaPlaying(1)
    If StrLen(SlidesMusicSong)>3
    {
       hSNDsong := MCI_Open(SlidesMusicSong,,,0)
       E := MCI_Play(hSNDsong)
       milisec := MCI_Length(hSNDsong)
       ; lenghtu := MCI_ToHHMMSS(milisec)
       If (E || !hSNDsong || milisec<900)
          StopMediaPlaying(1)
    }
}

StopMediaPlaying(modus:=0) {
    If (modus=1)
    {
       If (StrLen(SlidesMusicSong)>3 && hSNDsong)
       {
          MCI_Stop(hSNDsong)
          hSNDsong := ""
       }
    } Else
    {
       If hSNDmedia
       {
          MCI_Stop(hSNDmedia)
          hSNDmediaDuration := hSNDmedia := hSNDmediaFile := ""
       }
    }
}

createHistogramBMP(whichBitmap) {
   trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
   mpxu := Round((imgW * imgH)/1000000,2)
   If (mpxu>7.5 && validBMP(whichBitmap))
      whichBMP := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, 520, 520, 1, 3, -1)
   Else
      whichBMP := whichBitmap

   If !validBMP(whichBMP)
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram - no bitmap given")
      Return
   }

   If (showHistogram=2)
   {
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
   } Else If (showHistogram=3)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlArray, 0, 0)
   } Else If (showHistogram=4)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlArray, 0)
   } Else If (showHistogram=5)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlArray)
   } Else If (showHistogram=6)
   {
      setWindowTitle("Calculating histogram")
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlR, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlG, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlB)
      brLvlFakeArray := []
      Loop, 257
      {
          thisIndex := A_Index - 1
          thisMax := max(brLvlR[thisIndex], brLvlG[thisIndex], brLvlB[thisIndex])
          brLvlFakeArray[thisIndex] := Round(thisMax/1.25)
          ; MsgBox, % thisMax
      }
   }

   If ERR
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram... " Gdip_ErrorHandler(err, 0))
      Return
   }

   trGdip_GetImageDimensions(whichBMP, imgW, imgH)
   zr2ndMaxV := r2ndMaxV := 0
   minBrLvlV := TotalPixelz := imgW * imgH
   Loop, 256
   {
       thisIndex := A_Index - 1
       nrPixelz := brLvlArray[thisIndex]
       If (nrPixelz="")
          Continue

       stringArray .= nrPixelz "." (thisIndex + 1) "`n"
       If (nrPixelz>0)
       {
          thisSum += nrPixelz
          If (thisSum>TotalPixelz//2 && medianValue="")
             medianValue := thisIndex
       }

       If (nrPixelz>1)
          stringArray3 .= (thisIndex + 1) "." nrPixelz "`n"

       sumTotalBr += nrPixelz * (thisIndex + 1)
       SimpleSumTotalBr += nrPixelz
       If (nrPixelz>modePointV)
       {
          modePointV := nrPixelz
          modePointK := thisIndex
       }

       If (nrPixelz<modePointV && nrPixelz>r2ndMaxV)
          r2ndMaxV := nrPixelz
       If (nrPixelz>zr2ndMaxV)
          zr2ndMaxV := nrPixelz

       If (nrPixelz<minBrLvlV && nrPixelz>1)
       {
          minBrLvlV := nrPixelz
          minBrLvlK := thisIndex
       }
   }
   
   RstringArray := stringArray
   stringArray := Trim(stringArray, "`n")
   Sort, stringArray, ND`n
   stringArray := StrSplit(stringArray, "`n")
   
   stringArray3 := Trim(stringArray3, "`n")
   stringArray3 := StrSplit(stringArray3, "`n")

   Sort, RstringArray, RND`n
   RstringArray := Trim(RstringArray, "`n")
   RstringArray := StrSplit(RstringArray, "`n")

   vpWinClientSize(mainWidth, mainHeight)
   avgBrLvlK := Round(sumTotalBr/TotalPixelz - 1, 1)
   thisVal := minu := maxu := 0
   Loop, 256
   {
      thisVal := brLvlArray[Round(avgBrLvlK) - A_Index]
      If (thisVal>0 && !minu)
      {
         minu := thisVal
         Break
      }
   }

   Loop, 256
   {
      thisVal := brLvlArray[A_Index + Round(avgBrLvlK)]
      If (thisVal>0 && !maxu)
      {
         maxu := thisVal
         Break
      }
   }

   avgBrLvlV := (minu + maxu)//2 ;  brLvlArray[Round(avgBrLvlK)]
   modePointK3 := RstringArray[2]
   modePointK3 := StrSplit(modePointK3, ".")
   rangeA := stringArray3[1]
   rangeA := StrSplit(rangeA, ".")
   tl := stringArray3.Count()
   rangeB := stringArray3[tl]
   rangeB := StrSplit(rangeB, ".")
   Loop, 256
   {
       minBrLvlK2 := stringArray[A_Index]
       minBrLvlK2 := StrSplit(minBrLvlK2, ".")
       If (minBrLvlK2[1]=0)
          Continue
       If (minBrLvlK2[2]>0)
          Break
   }

   rangeC := rangeB[1] - rangeA[1] + 1
   meanValue := SimpleSumTotalBr/rangeC
   meanValuePrc := Round(meanValue/TotalPixelz * 100)
   meanValuePrc := (meanValuePrc>0) ? " (" meanValuePrc "%) " : ""
   2ndMaxVa := (modePointK3[1] + avgBrLvlV)//2 + minBrLvlV
   2ndMaxVb := (r2ndMaxV + meanValue)//2 + minBrLvlV
   Loop, 256
   {
       lookMean := stringArray[A_Index]
       lookMean := StrSplit(lookMean, ".")
       thisMean := lookMean[1]
       If (thisMean>meanValue)
       {
          meanValueK := Round((prevMean + lookMean[2] - 1)/2, 1)
          Break
       } prevMean := lookMean[2]
   }

   ; ToolTip, % avgBrLvlV "--" minBrLvlK2[1] "--" r2ndMaxV , , , 2
   meanValueK := !meanValueK ? "" : " | Mean: " meanValueK meanValuePrc
   peakPrc := Round(modePointV/TotalPixelz * 100)
   peakPrc := (peakPrc>0) ? " (" peakPrc "%)" : ""
   minPrc := Round(minBrLvlK2[1]/TotalPixelz * 100)
   minPrc := (minPrc>0) ? " (" minPrc "%)" : ""
   medianPrc := Round(lookValue[2]/TotalPixelz * 100)
   medianPrc := (medianPrc>0) ? " (" medianPrc "%)" : ""
   avgPrc := Round(avgBrLvlV/TotalPixelz * 100)
   avgPrc := (avgPrc>0) ? " (" avgPrc "%)" : ""
   trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
   TotalPixelzSpaced := groupDigits(imgW*imgH)

   infoPeak := "`nMode: " modePointK peakPrc
   infoAvg := " | Avg: " avgBrLvlK avgPrc " | Min: " minBrLvlK2[2] - 1 minPrc
   infoMin := "`nMedian: " medianValue medianPrc meanValueK

   avgsMax := (2ndMaxVa + r2ndMaxV + 2ndMaxVb + avgBrLvlV + meanValue)/5
   If (histogramMode=2)
      graphFocus := clampInRange(Round(avgsMax/modePointV, 2), 0.20, 0.60)
   Else If (histogramMode=1)
      graphFocus := clampInRange(Round((avgsMax*0.3)/modePointV, 2), 0.03, 0.10)
   Else
      graphFocus := clampInRange(Round(modePointK3[1] / modePointV, 2), 0.85, 0.99) ; 0.98

   infoRange := defineHistogramMode() ": " graphFocus " | " defineHistogramType() " | Range: " rangeA[1] - 1 " - " rangeB[1] - 1 " (" rangeC ")"
   entireString := infoRange infoPeak infoAvg infoMin "`nTotal pixels: " TotalPixelzSpaced
   If (slideShowRunning=1)
      infoBoxBMP := trGdip_CreateBitmap(A_ThisFunc, 5, 5)
   Else
      infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfontSize//1.5, mainWidth//1.3, mainHeight//1.3, OSDtextColor, OSDbgrColor, 1, 0)
   ; tooltip, % "|" TotalPixelz "|" modePointV ", " 2ndMaxV ", " avgBrLvlV " || "  maxW "," maxH  ;  `n" PointsList
   Scale := (slideShowRunning=1) ? imgHUDbaseUnit/100 : imgHUDbaseUnit/80
   thisData := (showHistogram=6) ? brLvlFakeArray : brLvlArray
   thisOpacity := (showHistogram=6) ? "CC" : "FF"
   If (showHistogram=3)
      thisGraphColor := "FEFF3300"
   Else If (showHistogram=4)
      thisGraphColor := "FE33FF33"
   Else If (showHistogram=5)
      thisGraphColor := "FE3366FF"
   Else If (showHistogram=6)
      thisGraphColor := "FFaaAAaa"
   Else
      thisGraphColor := thisOpacity OSDtextColor

   ; TulTip(0, "|  ", modePointK3[1], modePointV, r2ndMaxV, graphFocus, lookValue[2], avgBrLvlV, meanValue)
   HistogramBMP := drawHistogram(thisData, graphFocus, Scale, thisGraphColor, OSDbgrColor, imgHUDbaseUnit//2.5, infoBoxBMP)
   prevHistoBoxString := entireString
   trGdip_DisposeImage(infoBoxBMP, 1)
   If (whichBMP!=whichBitmap && validBMP(whichBMP))
      trGdip_DisposeImage(whichBMP, 1)
}

groupDigits(nrIn) {
   delim := (isWinXP || A_OSVersion="WIN_7") ? " " : " "
   If StrLen(nrin)>3
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 2)
   If StrLen(nrin)>7
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 6)
   If StrLen(nrin)>11
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 10)
   If StrLen(nrin)>15
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 14)
   Return nrIn
}

defineRelativeSelCoords(maxSelX, maxSelY) {
   If (imgSelX2="C" || imgSelY2="C" || imgSelX2=-1 && imgSelY2=-1)
      Return

   prcSelX1 := imgSelX1/maxSelX
   prcSelY1 := imgSelY1/maxSelY
   prcSelX2 := imgSelX2/maxSelX
   prcSelY2 := imgSelY2/maxSelY
}

capSelectionRelativeCoords() {
   If (LimitSelectBoundsImg!=1)
      Return

   prcSelX1 := clampInRange(prcSelX1, 0, 0.99)
   prcSelY1 := clampInRange(prcSelY1, 0, 0.99)
   prcSelX2 := clampInRange(prcSelX2, 0.01, 1)
   prcSelY2 := clampInRange(prcSelY2, 0.01, 1)
}

calcRelativeSelCoords(whichBitmap, imgW:=0, imgH:=0) {
   If (imgSelX1=0 && imgSelY1=0 && imgSelX2=-1 && imgSelY2=-1)
      Return

   If (!imgW || !imgH)
      trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
   If (!imgW || !imgH)
      Return -1

   imgSelX1 := Round(prcSelX1*imgW)
   imgSelY1 := Round(prcSelY1*imgH)
   imgSelX2 := Round(prcSelX2*imgW)
   imgSelY2 := Round(prcSelY2*imgH)
   nImgSelX1 := imgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := imgSelY1 := min(imgSelY1, imgSelY2)
   nimgSelX2 := max(imgSelX1, imgSelX2)
   nimgSelY2 := max(imgSelY1, imgSelY2)
 
   Static maxul := 199000
   If !(viewportQPVimage.imgHandle)
   {
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      If (kimgSelW>maxul)
         nImgSelX2 := nImgSelX1 + maxul
      If (kimgSelH>maxul)
         nImgSelY2 := nImgSelY1 + maxul

      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      p := capIMGdimensionsFormatlimits("gdip", 0, kimgSelW, kimgSelH)
      nImgSelX2 := nImgSelX1 + kimgSelW
      nImgSelY2 := nImgSelY1 + kimgSelH
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      If (kimgSelW>maxul)
         nImgSelX2 := nImgSelX1 + maxul

      If (kimgSelH>maxul)
         nImgSelY2 := nImgSelY1 + maxul

      ImgSelX2 := nImgSelX2
      ImgSelY2 := nImgSelY2
   }
}

VPnavBoxWrapper(mainWidth, mainHeight, Gu) {
    Critical, on

    createVPnavBox(navBoxu, imgW, imgH, diffX, diffY, zImgW, zImgH, entireString)
    hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
    scrbH := (thumbsDisplaying=1 && FlipImgV=0) ? 0 : scrollBarHy
    scrbV := (thumbsDisplaying=1 && FlipImgH=1) ? 0 : scrollBarVx
    tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2 && thumbsDisplaying=0) ? ToolbarWinH : 0
    thisPosX := (FlipImgH=1 && scrbV>0) ? scrbV : 0
    thisPosY := (FlipImgV=0 && scrbH>0 && thumbsDisplaying!=1) ? mainHeight - scrbH - imgH : mainHeight - imgH 
    If navBoxu
       ERR := trGdip_DrawImage(A_ThisFunc, Gu, navBoxu, thisPosX, thisPosY)

    hasDrawnImageMap := (navBoxu && !ERR && IMGlargerViewPort=1) ? 1 : 0
    thisPosX := (FlipImgH=1 && scrbV>0) ? tlbrBonusX + scrbV : tlbrBonusX
    thisPosY := (FlipImgV=0 && scrbH>0 && thumbsDisplaying!=1) ? mainHeight - scrbH - imgH - tlbrBonusY : mainHeight - imgH - tlbrBonusY
    If (thumbsDisplaying=0)
    {
       thisPosX := tlbrBonusX
       thisPosY := (scrbH>0) ? mainHeight - scrbH - imgH + tlbrBonusY : mainHeight - imgH + tlbrBonusY
       If (FlipImgH=1)
          thisPosX := mainWidth - imgW - scrbV + tlbrBonusX
       If (FlipImgV=1)
          thisPosY := tlbrBonusY
    } Else 
       thisPosY += tlbrBonusY*2

    ; ToolTip, % scrollBarVx "==" scrollBarHy "/" tlbrBonusX "|" tlbrBonusY , , , 2
    If navBoxu
       HUDobjNavBoxu := [zImgW, zImgH, thisPosX + diffX - tlbrBonusX, thisPosY + diffY - tlbrBonusY, imgW, imgH, thisPosX - tlbrBonusX, thisPosY - tlbrBonusY]

    thisString := hasDrawnImageMap ? entireString : "hide"
    interfaceThread.ahkPostFunction("uiAccessUpdateNavBox", thisString, imgW, imgH, thisPosX, thisPosY)
    trGdip_DisposeImage(navBoxu, 1)
}

createVPnavBox(ByRef pBitmap, ByRef imgW, ByRef imgH, ByRef posX, ByRef posY, ByRef fImgW, ByRef fImgH, ByRef entireString) {
   Static lastState := 1
   pBitmap := ""
   navBoxu := coreCreateVPnavBox()
   If !validBMP(navBoxu)
   {
      If (thumbsDisplaying=1)
      {
         navBoxu := trGdip_CreateBitmap(A_ThisFunc, 50, 50)
         If validBMP(navBoxu)
            missing := 1 ; wrong variable name
         Else
            Return
      } Else Return
   }

   trGdip_GetImageDimensions(navBoxu, fImgW, fImgH)
   trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   imgW := imgH := calculateNavBoxSize()
   posX := Round(imgW/2 - fImgW/2)
   posY := Round(imgH/2 - fImgH/2)

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)
   If !validBMP(pBitmap)
   {
      trGdip_DisposeImage(navBoxu, 1)
      pBitmap := ""
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      pBitmap := ""
      Return
   }

   entireString := (thumbsDisplaying=1) ? "Image preview area: " : "Image navigator box: "
   entireString .= (HUDnavBoxSize<76) ? "small size." : "large size."
   If (usrColorDepth>1 || imgFxMode>1) 
      entireString .= "`nViewport color effects are applied."

   If (thumbsDisplaying=1)
   {
      If (resultedFilesList[currentFileIndex, 3]=1)
         entireString .= "`nImage already seen. "

      If (resultedFilesList[currentFileIndex, 5]=1)
         entireString .= "`nAdded to favourites. "

      If (resultedFilesList[currentFileIndex, 2]=1)
         entireString .= "`nFile selected."
   } Else
   {
      entireString .= "`nZoom level: " defineZoomLevel() "%."
      If (allowFreeIMGpanning=1)
         entireString .= "`nThe image can be panned outside the viewport. "

      If (vpIMGrotation>0)
         entireString .= "`nImage rotation: " vpIMGrotation "°. "

      If (editingSelectionNow=1)
         entireString .= "`nImage " DefineVPselAreaMode() " selection area. " 

      If (imgSelLargerViewPort=1)
         entireString .= "`nIt covers the entire viewport area. "
      Else If (imgSelOutViewPort=1)
         entireString .= "`nIt is situated outside the viewport area, but a handle to retrieve it is available in the viewport. "

      trGdip_GetImageDimensions(zBitmap, W, H)
      entireString .= "`nResolution: " groupDigits(W) " x " groupDigits(H) " pixels. " Round((W * H)/1000000,2) " megapixels. "
      If (currIMGdetails.TooLargeGDI=1)
         entireString .= "`nOriginal resolution: " groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " pixels. " Round((currIMGdetails.Width * currIMGdetails.Height)/1000000,2) " megapixels."

      entireString .= "`nAlt+Left click to toggle size. Ctrl+Left-click and drag to adjust zoom level."
   }

   entireString .= "`nRight-click for more options."
   If !missing
      Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)

   If (resultedFilesList[currentFileIndex, 2]=1 && thumbsDisplaying=0)
   {
      pBrush3 := Gdip_BrushCreateSolid("0x400188FF")
      Gdip_FillRectangle(Gu, pBrush3, 0, 0, imgW, imgH)
      Gdip_DeleteBrush(pBrush3)
   } Else
      Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)

   If !missing
   {
      kBitmap := trGdip_CloneBitmap(A_ThisFunc, navBoxu)
      If (thumbsDisplaying!=1)
         kBitmap := applyVPeffectsOnBMP(kBitmap, 1)
      E := trGdip_DrawImage(A_ThisFunc, Gu, kBitmap, posX, posY, fImgW, fImgH)
      trGdip_DisposeImage(kBitmap, 1)
   } Else
      trGdip_DisposeImage(navBoxu, 1)

   If (E="fail")
   {
      Gdip_DeleteGraphics(Gu)
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      pBitmap := ""
      Return
   }

   ; Gdip_SetClipRect(Gu, posX, posY, fImgW, fImgH, 4)
   borderu := Round(imgW*0.0099)
   ; Gdip_FillRectangle(Gu, pBrushE, posX - borderu, posY - borderu, fImgW + borderu*2, fImgH + borderu*2)
   ; Gdip_ResetClip(Gu)
   If (resultedFilesList[currentFileIndex, 3]=1 && highlightAlreadySeenImages=1 && thumbsDisplaying=1)
      Gdip_DrawRectangle(Gu, pPen5, 2, 2, imgW - 5, imgH - 5)

   If (resultedFilesList[currentFileIndex, 5]=1) ; is bookmarked
      Gdip_DrawRectangle(Gu, pPen1d, 2, 2, imgW - 5, imgH - 5)

   If (editingSelectionNow=1 && thumbsDisplaying!=1 && drawingShapeNow!=1)
   {
      calcImgSelection2bmp(1, oImgW, oImgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      If (zImgSelW<borderu*2 || zImgSelH<borderu*2)
         Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

      If (zImgSelW<borderu*2)
         zImgSelW := borderu*2
      If (zImgSelH<borderu*2)
         zImgSelH := borderu*2

      pPath := createImgSelPath(posX + zimgSelPx, posY + zimgSelPy, zimgSelW, zimgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
      Gdip_SetClipPath(Gu, pPath, 0)
      If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
         thisBrush := lastState ? pBrushA : pBrushD
      Else
         thisBrush := pBrushA

      Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      Gdip_DeletePath(pPath)
      Gdip_ResetClip(Gu)
   }

   If (thumbsDisplaying!=1)
   {
      vpWinClientSize(mainWidth, mainHeight)
      obju := createImgSelection2Win(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, oImgW, oImgH, mainWidth, mainHeight, 1, 0)
      coords := obju.x1 "|" obju.y1 "|" obju.x2 "|" obju.y2
      calcImgSelection2bmp(1, oImgW, oImgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, coords)
      If (zImgSelW<borderu*2)
         zImgSelW := borderu*2
      If (zImgSelH<borderu*2)
         zImgSelH := borderu*2

      If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
         thisBrush := lastState ? pBrushC : pBrushD
      Else
         thisBrush := pBrushC

      Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      Gdip_DrawRectangle(Gu, pPen4, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      ; Gdip_SetClipRect(Gu, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH, 4)
      ; borderu := Round(imgW*0.006)
      ; Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

      Gdip_ResetClip(Gu)
      ; Gdip_SetClipRect(Gu, borderu, borderu, imgW - borderu*2, imgH - borderu*2, 4)
      ; Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)
   }

   lastState := !lastState
   Gdip_DeleteGraphics(Gu)
   Return pBitmap
}

calculateNavBoxSize() {
   minSizeu := (thumbsDisplaying=1 && thumbsListViewMode=1) ? (thumbsW + thumbsH)//2 : 10
   imgW := Ceil(HUDnavBoxSize * imgHUDbaseUnit/20)
   fs := (HUDnavBoxSize=125) ? 1.95 : 1.35
   If (imgW<minSizeu*fs) ; avoid having the preview smaller than the thumbnails in the list
      imgW := Round(minSizeu*fs)
   
   vpWinClientSize(mainWidth, mainHeight)
   maxu := Round(min(mainWidth, mainHeight)*0.75)
   If (imgW>maxu)
      imgW := maxu

   Return imgW
}

coreCreateVPnavBox(modus:=0) {
   Static lastCall, prevBMP
   If (modus="kill")
   {
      prevBMP := trGdip_DisposeImage(prevBMP, 1)
      prevBMP := lastCall := ""
      Return
   }

   whichBitmap := useGdiBitmap()
   If (thumbsDisplaying=1)
   {
      whichBitmap := ""
      imgPath := StrReplace(getIDimage(currentFileIndex), "||")
      If !FileRexists(imgPath)
         Return

      MD5name := generateThumbName(imgPath, 1)
      file2save := thumbsCacheFolder "\500-" MD5name ".jpg"
      If FileExist(file2save)
      {
         whichBitmap := LoadCachableBitmapFromFile(file2save)
      } Else
      {
         sizesDesired := []
         sizesDesired[1] := [500, 500, 1, 0, 6]
         changeMcursor()
         whichBitmap := LoadBitmapFromFileu(imgPath, 0, 0, 0, sizesDesired)
         If validBMP(whichBitmap)
         {
            ; whichBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 500, 500, 1, 7)
            ; trGdip_DisposeImage(oBitmap, 1)
            saveImageThumbnail(whichBitmap, file2save)
         }
         ResetImgLoadStatus()
      }
      If validBMP(whichBitmap)
         whichBitmap := flipBitmapAccordingToViewPort(applyVPeffectsOnBMP(whichBitmap, 1, 1, "y"))
   }

   thisCall := "a" whichBitmap MD5name imgPath thumbsDisplaying gdiBitmapIDcall currentFileIndex getIDimage(currentFileIndex) currentUndoLevel undoLevelsRecorded UserMemBMP imgHUDbaseUnit OSDfontSize HUDnavBoxSize FlipImgH FlipImgV imgFxMode thumbsW thumbsH
   If (thisCall=lastCall && validBMP(prevBMP))
      Return prevBMP

   If !validBMP(whichBitmap)
   {
      prevBMP := trGdip_DisposeImage(prevBMP, 1)
      prevBMP := lastCall := ""
      Return
   }

   prevBMP := trGdip_DisposeImage(prevBMP, 1)
   imgW := imgH := calculateNavBoxSize()
   trGdip_GetImageDimensions(whichBitmap, rImgW, rImgH)
   calcIMGdimensions(rImgW, rImgH, imgW, imgH, ResizedW, ResizedH)
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, coreDesiredPixFmt)
   If !validBMP(pBitmap)
   {
      If (thumbsDisplaying=1)
         trGdip_DisposeImage(whichBitmap, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      If (thumbsDisplaying=1)
         trGdip_DisposeImage(whichBitmap, 1)
      Return
   }

   thisBrush2 := createHatchBrush(128)
   Gdip_FillRectangle(Gu, thisBrush2, 0, 0, ResizedW, ResizedH)
   Gdip_DeleteBrush(thisBrush2)

   ; Gdip_FillRectangle(Gu, pBrushE, 0, 0, ResizedW, ResizedH)
   posX := posY := 0
   If (viewportQPVimage.imgHandle)
   {
      thisBitmap := retrieveQPVscreenImgSection("last-entire", 0, 0, 0, 0, 0)
      If validBMP(thisBitmap)
      {
         E := trGdip_DrawImage(A_ThisFunc, Gu, thisBitmap, posX, posY, ResizedW, ResizedH)
      } Else
      {
         thisBitmap := viewportQPVimage.ImageGetResizedRect(0, 0, rImgW, rImgH, ResizedW, ResizedH, userimgQuality)
         If validBMP(thisBitmap)
         {
            E := trGdip_DrawImage(A_ThisFunc, Gu, thisBitmap, posX, posY, ResizedW, ResizedH)
            trGdip_DisposeImage(thisBitmap, 1)
         } Else E := "fail"
      }
   } Else E := trGdip_DrawImage(A_ThisFunc, Gu, whichBitmap, posX, posY, ResizedW, ResizedH)

   Gdip_DeleteGraphics(Gu)
   prevBMP := (E!="fail") ? pBitmap : ""
   lastCall := (E!="fail") ? thisCall : ""
   If (E="fail")
   {
      pBitmap := trGdip_DisposeImage(pBitmap, 1)
   } Else If (userPrivateMode=1)
   {
      pBlurEffect := Gdip_CreateEffect(1, 190, 0)
      Gdip_BitmapApplyEffect(pBitmap, pblurEffect)
      Gdip_DisposeEffect(pBlurEffect)
   }

   If (thumbsDisplaying=1)
      trGdip_DisposeImage(whichBitmap, 1)

   Return pBitmap
}

ImageNavBoxClickResponder() {
   Static prevState := "a"
   If GetKeyState("Alt", "P")
   {
      ToggleImgNavSizeBox()
      Return
   }

   trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If ((!imgW || !imgH) && (thumbsDisplaying!=1))
      Return

   If (thumbsDisplaying!=1 && IMGresizingMode!=4)
   {
      IMGresizingMode := 3
      ToggleImageSizingMode()
   }

   If (GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P")) && (thumbsDisplaying!=1)
   {
      tlbrZoomINout("navBox")
      Return
   }

   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := clampInRange(mX - HUDobjNavBoxu[3], 0, HUDobjNavBoxu[1])
   mY := clampInRange(mY - HUDobjNavBoxu[4], 0, HUDobjNavBoxu[2])
   navWidth := HUDobjNavBoxu[1]
   navHeight := HUDobjNavBoxu[2]
   diffIMGdecX := diffIMGdecY := 0
   prevImgDecaX := prevImgDecaY := 0
   vpWinClientSize(mainWidth, mainHeight)
   obju := createImgSelection2Win(1, 1, prevResizedVPimgW, prevResizedVPimgH, ImgW, ImgH, mainWidth, mainHeight, 1, 0)
   coords := obju.x1 "|" obju.y1 "|" obju.x2 "|" obju.y2
   calcImgSelection2bmp(0, ImgW, ImgH, navWidth, navHeight, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, coords)
   offX := (FlipImgH=1) ? - Round(zImgSelW/2) : Round(zImgSelW/2)
   offY := (FlipImgV=1) ? - Round(zImgSelH/2) : Round(zImgSelH/2)
   minTopCornerX := (allowFreeIMGpanning=1) ? mainWidth : 0
   minTopCornerY := (allowFreeIMGpanning=1) ? mainHeight : 0
   vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
   imgPath := getIDimage(currentFileIndex)
   thisZeit := A_TickCount - 100
   Random, randomFactor, -950, 950
   minX := (allowFreeIMGpanning=1) ? - HUDobjNavBoxu[1] : 0
   minY := (allowFreeIMGpanning=1) ? - HUDobjNavBoxu[2] : 0
   thisIndex := f := 0
   setWhileLoopExec(1)
   While, (determineLClickState()=1 || A_Index<2)
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := clampInRange(mX - offX - HUDobjNavBoxu[3], minX, HUDobjNavBoxu[1]*2)
      mY := clampInRange(mY - offY - HUDobjNavBoxu[4], minY, HUDobjNavBoxu[2]*2)
      If (FlipImgV=1)
         mY := navHeight - mY
      If (FlipImgH=1)
         mX := navWidth - mX

      prcW := mX/navWidth
      prcH := mY/navHeight
      ; ToolTip, % mX "==" mY "==" navWidth "==" navHeight "==" prcW "==" prcH , , , 2
      decX := - Round((imgW*prcW) * zoomLevel)
      decY := - Round((imgH*prcH) * zoomLevel)
      prcW := mX/navWidth
      prcH := mY/navHeight
      If (decX>0 && imageAligned=1 && FlipImgH=0 && allowFreeIMGpanning=0)
         decX := 0

      If (decY>0 && imageAligned=1 && FlipImgV=0 && allowFreeIMGpanning=0)
         decY := 0

      limitPanningDist(decX, decY, minTopCornerX, minTopCornerY)
      diffIMGdecX := -1*(prevImgDecaX - decX) + 2
      diffIMGdecY := -1*(prevImgDecaY - decY) + 2
      thisState := "a" randomFactor decX decY diffIMGdecX diffIMGdecY currentFileIndex getIDimage(currentFileIndex) currentUndoLevel zoomLevel gdiBitmap
      If (prevState!=thisState) && (A_TickCount - thisZeit>25)
      {
         ; ToolTip, % diffIMGdecX "==" diffIMGdecY , , , 2
         thisIndex++
         zeitSillyPrevent := A_TickCount
         IMGdecalageX := decX
         IMGdecalageY := decY
         prevImgDecaX := decX
         prevImgDecaY := decY
         thisZeit := A_TickCount
         prevState := thisState
         dummyResizeImageGDIwin()
      }
      Sleep, 15
   }

   setWhileLoopExec(0)
   vpImgPanningNow := diffIMGdecX := diffIMGdecY := 0
   If (thisIndex>10 || lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
}

wrapResizeImageGDIwin() {
   If (currIMGdetails.Width && currIMGdetails.Height)
   {
      startZeitIMGload := A_TickCount
      imgPath := StrReplace(getIDimage(currentFileIndex), "||")
      r := ResizeImageGDIwin(imgPath, 2, 0)
      Return r
   }
}

getPixelColorAvg(pBitmap, kX, kY, startToolColor) {
   If !validBMP(pBitmap)
      Return

   coloruA := Gdip_GetPixelColor(pBitmap, kX, kY, 1)
   coloruB := Gdip_GetPixelColor(pBitmap, kX + 2, kY + 2, 1)
   coloruD := Gdip_GetPixelColor(pBitmap, kX - 2, kY - 2, 1)
   coloruC := Gdip_GetPixelColor(pBitmap, kX + 2, kY - 2, 1)
   If (coloruA && coloruB)
      coloruZ := MixARGB(coloruA, coloruB, 0.5)
   If (coloruC && coloruD)
      coloruX := MixARGB(coloruC, coloruD, 0.5)
   If (coloruZ && coloruX)
      coloruY := MixARGB(coloruZ, coloruX, 0.5)
   Else If coloruZ
      coloruY := coloruZ
   Else If coloruX
      coloruY := coloruX
   Else
      coloruY := startToolColor

   Return coloruY
}

toggleBrushDoubleSize() {
   BrushToolDoubleSize := !BrushToolDoubleSize
   friendly := (BrushToolDoubleSize=1) ? "RADIUS" : "DIAMETER"
   showTOOLtip("Brush " friendly " size: " brushToolSize " px", A_ThisFunc, 1, brushToolSize/950)
   If isVarEqualTo(AnyWindowOpen, 64, 24, 31)
   {
      GuiControl, SettingsGUIA:, BrushToolDoubleSize, % BrushToolDoubleSize
      theSizeLabel := (BrushToolDoubleSize!=1) ? "Diameter: $€ px" : "Radius: $€ px"
      uiSlidersArray["BrushToolSize", 5] := theSizeLabel
      GuiUpdateSliders("brushToolSize")
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushAirMode() {
   If (BrushToolType=2 || BrushToolType=3)
   {
      showTOOLtip("WARNING: Airbrush mode is not available for the current brush type.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BrushToolOverDraw := !BrushToolOverDraw
   friendly := (BrushToolOverDraw=1) ? "ACTIVATED" : "DEACTIVATED"
   labelu := (BrushToolType>=6) ? "Auto-scale brush deformer: " : "Airbrush mode: "
   If isVarEqualTo(AnyWindowOpen, 64, 24, 31)
      GuiControl, SettingsGUIA:, BrushToolOverDraw, % BrushToolOverDraw

   showTOOLtip(labelu friendly moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

MenuSetVectAutoSymmetryX() {
   totalz := customShapePoints.Count()
   If (totalz/2=totalz//2)
   {
      If (bezierSplineCustomShape=1 && totalz=2)
      {
         pp := 1
      } Else
      {
         showTOOLtip("WARNING: The vector path has an even number of points: " groupDigits(totalz) ".`nPlease add one additional point.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return 0
      }
   }

   pp := pp ? pp : totalz//2 + 1
   configVectorShapeSymmetryPoint("x", 0, pp, 1)
   Return isNowSymmetricVectorShape()
}

MenuSetVectAutoSymmetryY() {
   totalz := customShapePoints.Count()
   If (totalz/2=totalz//2)
   {
      If (bezierSplineCustomShape=1 && totalz=2)
      {
         pp := 1
      } Else
      {
         showTOOLtip("WARNING: The vector path has an even number of points: " groupDigits(totalz) ".`nPlease add one additional point.")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return 0
      }
   }

   pp := pp ? pp : totalz//2 + 1
   configVectorShapeSymmetryPoint("y", 0, pp, 1)
   Return isNowSymmetricVectorShape()
}

toggleBrushSymmetryModes() {
   Static hasRan := 0
   If (drawingShapeNow=1)
   {
      handleOpenCloseBezier("kill")
      CustomShapeSymmetry := clampInRange(CustomShapeSymmetry + 1, 0, 2, 1)
      If (customShapePoints.Count()>1 && CustomShapeSymmetry>0)
      {
         If (CustomShapeSymmetry=1)
            r := MenuSetVectAutoSymmetryX()
         Else If (CustomShapeSymmetry=2)
            r := MenuSetVectAutoSymmetryY()

         If !r
         {
            CustomShapeLockedSymmetry := CustomShapeSymmetry := 0
            Return
         }
      } Else r := 1
      If !r
         CustomShapeSymmetry := 0

      CustomShapeLockedSymmetry := CustomShapeSymmetry
      If (CustomShapeSymmetry=1)
         friendly := "X"
      Else If (CustomShapeSymmetry=2)
         friendly := "Y"
      Else
         friendly := "NONE"

      If ((CustomShapeSymmetry=1 || CustomShapeSymmetry=2) && customShapeHasSelectedPoints)
      {
         Loop, % customShapePropPoints.Count()
             customShapePropPoints[A_Index, 1] := 0
      }
      ; ToolTip, % CustomShapeSymmetry "==" CustomShapeLockedSymmetry , , , 2
      showTOOLtip("Shape symmetry: " friendly moreInfo, A_ThisFunc, 1, CustomShapeSymmetry/3)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, dummyRefreshImgSelectionWindow, -125
      SetTimer, showQuickActionButtonsDrawingShape, -200
      Return
   }

   If (BrushToolType>5)
   {
      showTOOLtip("WARNING: Symmetry painting not available for the current brush type")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (BrushToolSymmetryX=0 && BrushToolSymmetryY=0)
   {
      levelu := 3
      BrushToolSymmetryX := BrushToolSymmetryY := 1
   } Else If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
   {
      levelu := 2
      BrushToolSymmetryX := 0
      BrushToolSymmetryY := 1
   } Else If (BrushToolSymmetryX=0 && BrushToolSymmetryY=1)
   {
      levelu := 1
      BrushToolSymmetryX := 1
      BrushToolSymmetryY := 0
   } Else If (BrushToolSymmetryX=1 && BrushToolSymmetryY=0)
   {
      levelu := 0.0001
      BrushToolSymmetryX := BrushToolSymmetryY := 0
   }

   friendly := (BrushToolSymmetryX=1) ? "X" : ""
   friendly2 := friendly ? friendly ", " : ""
   friendly3 := (BrushToolSymmetryY=1) ?  friendly2 "Y" : friendly
   If !friendly3
      friendly3 := "NONE"

   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA:, BrushToolSymmetryX, % BrushToolSymmetryX
      GuiControl, SettingsGUIA:, BrushToolSymmetryY, % BrushToolSymmetryY
   }

   If (hasRan<4)
      moreInfos := "`nPress Shift + Y to define the symmetry coordinates"

   hasRan++
   showTOOLtip("Painting symmetry: " friendly3 moreInfos, A_ThisFunc, 1, levelu/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, dummyRefreshImgSelectionWindow, -200
}

discardUserPaintedAlpha() {
   If isNowAlphaPainting()
      Return

   okay := (validBMP(userAlphaMaskBmpPainted) || validBMP(userPrevAlphaMaskBmpPainted)) ? 1 : 0
   If (okay=1)
   {
      userAlphaMaskBmpPainted := trGdip_DisposeImage(userAlphaMaskBmpPainted, 1)
      userPrevAlphaMaskBmpPainted := trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
      If (alphaMaskingMode=5 && isAlphaMaskWindow()=1)
      {
         GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 1
         GuiControl, SettingsGUIA:, alphaMaskGradientScale, 100
         UItriggerBrushUpdate(1)
         showDelayedTooltip("User painted alpha mask discarded")
      } Else showTOOLtip("User painted alpha mask discarded")
   } Else If (alphaMaskingMode>1)
   {
      alphaMaskingMode := 1
      If (isAlphaMaskWindow()=1)
      {
         GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 1
         GuiControl, SettingsGUIA:, alphaMaskGradientScale, 100
         UItriggerBrushUpdate(1)
         showDelayedTooltip("The alpha mask is now undefined")
      } Else 
      {
         livePreviewsImageEditing()
         showTOOLtip("The alpha mask is now undefined")
      }
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastPaintEventID := ""
}

toggleInvertAlphaMask() {
   alphaMaskColorReversed := !alphaMaskColorReversed
   GuiControl, SettingsGUIA:, alphaMaskColorReversed, % alphaMaskColorReversed
   livePreviewsImageEditing()
   friendly := (alphaMaskColorReversed=1) ? "ACTIVATED" : "DEACTIVATED" 
   showTOOLtip("Inverted alpha mask: " friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleAlphaPaintingMode() {
   Critical, on
   ; alpha mask painting, transform tool
   If !isImgEditingNow()
      Return

   forceLiveAlphaPreviewMode := userAllowsGradientRecentering := userAllowClrGradientRecenter := 0
   If (AnyWindowOpen=66 || AnyWindowOpen=64)
   {
      ; flood fill / paint brushes tool
      If !editingSelectionNow
      {
         showTOOLtip("WARNING: No selection area is activated.")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
      labelu := (AnyWindowOpen=66) ? "Flood fill" : "Paint brush"
      friendly := (BrushToolOutsideSelection=1) ? "ANYWHERE" : "INSIDE SELECTION"
      If (BrushToolOutsideSelection=3)
         friendly := "OUTSIDE SELECTION"

      If (AnyWindowOpen=64)
      {
         liveDrawingBrushTool := !liveDrawingBrushTool
         FloodFillSelectionAdj := !liveDrawingBrushTool
      } Else
      {
         FloodFillSelectionAdj := !FloodFillSelectionAdj
         liveDrawingBrushTool := !FloodFillSelectionAdj
      }

      interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
      interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
      If (FloodFillSelectionAdj=1)
         showTOOLtip(labelu " tool: DEACTIVATED`nSelection area can be adjusted.", A_ThisFunc, 1)
      Else
         showTOOLtip(labelu " tool: ACTIVATED`nFill mode: " Friendly, A_ThisFunc, 1)

      SetTimer, dummyRefreshImgSelectionWindow, -100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (mustCaptureCloneBrush=1)
   {
      StopCaptureClickStuff(dummy)
      Return
   }

   If throwWarningHugeImagesFeatureNotAvailable()
      Return

   FloodFillSelectionAdj := 0
   liveDrawingBrushTool := !liveDrawingBrushTool
   interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
   Random, OutputVar, 1, 950
   Random, OutputaVar, 1, 950
   randomu := OutputVar / OutputaVar
   If (isAlphaMaskWindow()=1 && liveDrawingBrushTool=1)
   {
      allGood := 1
      infoMask := defineCurrentAlphaMask()
      If validBMP(userAlphaMaskBmpPainted) && !InStr(infoMask, "user painted")
      {
         allGood := 0
         liveDrawingBrushTool := 0
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "There is an already user painted bitmap created, but the alpha mask is currently set to a parametric / generated one. Would you like to rasterize this or return to the already created bitmap?`n`nPlease note, you can blend the current alpha mask with the user painted bitmap by using the «Rasterize» option from the main menu.", "&Rasterize this|Return to &bitmap|&Cancel", 1, "question")
         If InStr(msgResult, "rasterize")
         {
            allGood := 1
            RasterizeAlphaMaskNow("no-ask")
         } Else If InStr(msgResult, "return")
            allGood := 1
      }

      If !allGood
      {
         liveDrawingBrushTool := 0
         If AnyWindowOpen
            GuiControl, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode, 0
         Return
      }

      liveDrawingBrushTool := 1
      imgSelW := Round( max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2) )
      imgSelH := Round( max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2) )
      showTOOLtip("Please wait, activating painting mode")
      If !validBMP(userAlphaMaskBmpPainted)
      {
         freshMode := 1
         If (isVarEqualTo(AnyWindowOpen, 89, 74, 70, 32, 23) && alphaMaskingMode>1)
         {
            ; tools with no object as reference
            alphaMaskGray := generateAlphaMaskBitmap(0, 0, imgSelW//2, imgSelH//2, 0, 0, 0, 1)
         } Else If (alphaMaskingMode>1)
         {
            transformTool := (AnyWindowOpen=31 || AnyWindowOpen=24) ? 1 : 0
            alphaMaskGray := generateAlphaMaskBitmap(0, 0, imgSelW, imgSelH, 0, 0, 0, 1, transformTool)
            ; alphaMaskGray := generateAlphaMaskBitmap(userClipBMPpaste, 0, 0, 0, 0, 0, 0, 1)
         }

         If validBMP(alphaMaskGray)
            generated := 1
      }

      RegAction(0, "brushAclrAlpha",, 3)
      RegAction(0, "brushBclrAlpha",, 3)
      BrushToolAcolor := (brushAclrAlpha!="") ? brushAclrAlpha : convertColorToGrayscale(BrushToolAcolor)
      BrushToolBcolor := (brushBclrAlpha!="") ? brushBclrAlpha : convertColorToGrayscale(BrushToolBcolor)
      updateColoredRectCtrl(BrushToolAcolor, "BrushToolAcolor")
      updateColoredRectCtrl(BrushToolBcolor, "BrushToolBcolor")
      BrushToolType := (BrushToolType=1) ? 1 : 2
      alphaMaskingMode := 5
      alphaMaskBMPchannel := maybeColors ? 5 : 1
      GuiControl, SettingsGUIA: Choose, alphaMaskBMPchannel, % alphaMaskBMPchannel
      GuiControl, SettingsGUIA: Choose, alphaMaskingMode, 5
      GuiControl, SettingsGUIA: Choose, alphaMaskRefBMP, 1
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      doImgEditLivePreview := 1
      GuiControl, SettingsGUIA:, doImgEditLivePreview, 1
      GuiControl, SettingsGUIA: Disable, doImgEditLivePreview
      If isVarEqualTo(AnyWindowOpen, 24, 31, 74, 89)
         GuiControl, SettingsGUIA: Disable, btnReset

      GuiControl, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode, 1
      mustReset := (alphaMaskBMPbright<-250 && alphaMaskBMPcontrast>250) || (alphaMaskBMPbright<-250) ? 1 : 0
      If (!validBMP(userAlphaMaskBmpPainted) || freshMode=1 || mustReset=1)
      {
         alphaMaskGradientScale := 1
         alphaMaskBMPcontrast := alphaMaskBMPbright := alphaMaskGradientAngle := alphaMaskReplaceMode := 0
         GuiUpdateSliders("alphaMaskBMPbright")
         GuiUpdateSliders("alphaMaskBMPcontrast")
         GuiUpdateSliders("alphaMaskGradientScale")
         GuiUpdateSliders("alphaMaskGradientAngle")
         GuiControl, SettingsGUIA:, alphaMaskReplaceMode, 0
      }

      If (!validBMP(userAlphaMaskBmpPainted) || freshMode=1)
      {
         If (PasteInPlaceOpacity<20 && (AnyWindowOpen=24 || AnyWindowOpen=31))
         {
            PasteInPlaceOpacity := 20
            GuiUpdateSliders("PasteInPlaceOpacity")
         }

         If !generated
         {
            alphaMaskColorReversed := 0
            GuiControl, SettingsGUIA:, alphaMaskColorReversed, 0
         }

         If validBMP(alphaMaskGray)
         {
            userAlphaMaskBmpPainted := alphaMaskGray
            keepUserPaintAlphaMask := 1
         } Else
         {
            keepUserPaintAlphaMask := 1
            If validBMP(userClipBMPpaste)
               trGdip_GetImageDimensions(userClipBMPpaste, rImgW, rImgH)
   
            If isVarEqualTo(AnyWindowOpen, 89, 74, 70, 32, 23) ; create new bitmap for these tools
               userAlphaMaskBmpPainted := trGdip_CreateBitmap(A_ThisFunc, ImgSelW//2, imgSelH//2, "0xE200B")
            Else
               userAlphaMaskBmpPainted := trGdip_CreateBitmap(A_ThisFunc, rImgW, rimgH, "0xE200B")
            G := Gdip_GraphicsFromImage(userAlphaMaskBmpPainted)
            Gdip_GraphicsClear(G, "0xFFffFFff")
            Gdip_DeleteGraphics(G)
         }
      }

      If !validBMP(userAlphaMaskBmpPainted)
      {
         showTOOLtip("ERROR: User alpha mask bitmap could not be created.")
         SoundBeep 300, 100
         liveDrawingBrushTool := 0
         If AnyWindowOpen
            GuiControl, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode, 0
         If isVarEqualTo(AnyWindowOpen, 24, 31, 74, 89)
            GuiControl, SettingsGUIA: Enable, btnReset
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      lastPaintEventID := "a" A_TickCount userAlphaMaskBmpPainted randomu
      SetTimer, showLEDprimaryColor, -200
      If (ShowAdvToolbar=1)
         updateTlbrColorsSwatch()
   } Else If (isAlphaMaskWindow()=1)
   {
      showTOOLtip("Please wait, deactivating painting mode")
      RegAction(1, "brushAclrAlpha",, 3)
      RegAction(1, "brushBclrAlpha",, 3)
      brushAclrAlpha := convertColorToGrayscale(BrushToolAcolor)
      brushBclrAlpha := convertColorToGrayscale(BrushToolBcolor)
      lastPaintEventID := "a" A_TickCount userAlphaMaskBmpPainted randomu
      GuiControl, SettingsGUIA:, uiPasteInPlaceAlphaDrawMode, 0
      GuiControl, SettingsGUIA: Enable, doImgEditLivePreview
      If isVarEqualTo(AnyWindowOpen, 24, 31, 74, 89)
         GuiControl, SettingsGUIA: Enable, btnReset

      If (ShowAdvToolbar=1 && (AnyWindowOpen=23 || AnyWindowOpen=32))
         fromCurrentPanelToColorsSwatch()

      realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
   }

   createGUItoolbar()
   interfaceThread.ahkPostFunction("uiAlphaMaskTrigger", AnyWindowOpen, liveDrawingBrushTool, editingSelectionNow, UserMemBMP, showMainMenuBar)
   interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
   BrushToolTexture := 1
   dummyRefreshImgSelectionWindow()
   BtnTabsInfoUpdate("ignore-panel")
   SetTimer, MouseMoveResponder, -50
   SetTimer, corelivePreviewsImageEditing, -150
   SetTimer, RemoveTooltip, -200
}

toggleBrushTypes(modus:=0) {
   If (liveDrawingBrushTool=1)
      BrushToolType := (BrushToolType=1) ? 2 : 1

   endCaptureCloneBrush()
   liveDrawingBrushTool := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   friendly := (BrushToolType=1) ? "Simple color brush" : "Soft edges color brush"
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   If (BrushToolSoftness<5)
      BrushToolSoftness := 6

   If (BrushToolType=2)
      moreInfos .= "`nSoftness: " BrushToolSoftness "%"

   If (AnyWindowOpen=64 && modus="tlbr")
   {
      BrushToolWetness := 0
      GuiUpdateSliders("BrushToolWetness")
   }

   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
   {
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      updateUIbrushTool()
   }

   showTOOLtip(friendly ":" moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushDeformers() {
   If (isNowAlphaPainting()=1) || (A_TickCount - lastZeitOpenWin<650)
      Return

   endCaptureCloneBrush()
   If (liveDrawingBrushTool=1)
      BrushToolType := (BrushToolType=7) ? 8 : 7

   liveDrawingBrushTool := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   friendly := (BrushToolType=7) ? "Pinch brush" : "Bulge brush"
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      updateUIbrushTool()
   }

   showTOOLtip(friendly ":" moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushTypeEraser() {
   If (isNowAlphaPainting()=1)
      Return

   BrushToolType := 4
   liveDrawingBrushTool := 1
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "Eraser brush:`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   BrushToolEraserRestore := 0
   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA:, BrushToolEraserRestore, % BrushToolEraserRestore
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      updateUIbrushTool()
   }

   showTOOLtip(moreinfos)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushTypeFX(modus:=0) {
   If (isNowAlphaPainting()=1)
      Return

   BrushToolType := 5
   liveDrawingBrushTool := 1
   endCaptureCloneBrush()
   BrushToolUseSecondaryColor := 0
   BrushToolApplyColorFX := 1
   BrushToolBlurStrength := 0
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   moreInfos .= "`nHSL: " PasteInPlaceHue "° / " PasteInPlaceSaturation "% / " PasteInPlaceLight "%"
   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      GuiControl, SettingsGUIA:, BrushToolApplyColorFX, 1
      GuiUpdateSliders("BrushToolBlurStrength")
      updateUIbrushTool()
   }

   showTOOLtip("Color effects brush:" moreinfos)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (modus="tlbr")
      tlbrBrushSlidersInvoker(8)
}

togglePresetsBrushes(modus, dir:=1) {
   If (isNowAlphaPainting()=1)
      Return

   BrushToolType := 5
   liveDrawingBrushTool := 1
   endCaptureCloneBrush()
   BrushToolUseSecondaryColor := 0
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   level := 0, maxu := 0
   If (modus=1)
   {
      BrushToolApplyColorFX := 0
      BrushToolBlurStrength := clampInRange(BrushToolBlurStrength, 3, 99)
      friendly := "Effects brush:`nBlur strength: " BrushToolBlurStrength "%"
      level := BrushToolBlurStrength
      maxu := 99
   } Else If (modus=2)
   {
      BrushToolApplyColorFX := 1
      BrushToolBlurStrength := 0
      friendly := "Effects brush: color adjustments"
   } Else If (modus=3)
   {
      BrushToolType := 2
      BrushToolWetness := clampInRange(BrushToolWetness, 1, 22)
      friendly := "Soft edges brush:`nWetness: " Round(BrushToolWetness/22 * 100) "%"
      level := BrushToolWetness
      maxu := 22
   } Else If (modus=4)
   {
      BrushToolWetness := 0
      BrushToolType := 2
      friendly := "Soft edges brush:"
   } Else If (modus=5)
   {
      BrushToolType := 1
      friendly := "Hard brush:"
   }

   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (AnyWindowOpen=64)
   {
      GuiUpdateSliders("BrushToolBlurStrength")
      GuiUpdateSliders("BrushToolWetness")
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      GuiControl, SettingsGUIA:, BrushToolApplyColorFX, % BrushToolApplyColorFX
      SetTimer, updateUIbrushTool, -150
   }

   showTOOLtip(friendly moreinfos, 0, 0, level/maxu)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleBrushDrawInOutModes() {
   If (isNowAlphaPainting()=1)
      Return

   endCaptureCloneBrush()
   FloodFillSelectionAdj := 0
   If (AnyWindowOpen!=66)
      liveDrawingBrushTool := 1

   interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   BrushToolOutsideSelection := clampInRange(BrushToolOutsideSelection + 1, 1, 3, 1)
   friendly := (BrushToolOutsideSelection=1) ? "ANYWHERE" : "INSIDE"
   If (BrushToolOutsideSelection=3)
      friendly := "OUTSIDE"

   If (BrushToolOutsideSelection>1 && AnyWindowOpen=66)
      friendly .= " SELECTION"
   If (AnyWindowOpen=64 || AnyWindowOpen=66)
      GuiControl, SettingsGUIA: Choose, BrushToolOutsideSelection, % BrushToolOutsideSelection

   If (editingSelectionNow!=1)
      msgu := "WARNING: The image selection area is currently not created.`nPress E to create or display it.`n"

   If (ShowAdvToolbar=1)
      decideIconBTNpaintBrushSelect()

   labelu := (AnyWindowOpen=66) ? "Flood fill selection mode:`n" friendly : "Paint " Friendly " image selection area"
   showTOOLtip(msgu labelu, A_ThisFunc, 1, BrushToolOutsideSelection/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, dummyRefreshImgSelectionWindow, -100
}

toggleBrushTypeCloner() {
   If (isNowAlphaPainting()=1)
      Return

   If (BrushToolType=3 && liveDrawingBrushTool=1)
      BrushToolDynamicCloner := !BrushToolDynamicCloner

   BrushToolType := 3
   liveDrawingBrushTool := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   friendly := "Cloner brush"
   If (BrushToolDynamicCloner=1)
      friendly .= " (dynamic coords mode)"

   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   moreInfos := "`nOpacity: " Round(thisOpacity/255*100) "%"
   moreInfos .= "`nSoftness: " BrushToolSoftness "%"
   If (BrushToolApplyColorFX=1 || BrushToolBlurStrength>2)
      moreInfos .= "`nBrush effects are enabled"

   If (AnyWindowOpen=64)
   {
      GuiControl, SettingsGUIA:, BrushToolDynamicCloner, % BrushToolDynamicCloner
      GuiControl, SettingsGUIA: Choose, BrushToolType, % BrushToolType
      updateUIbrushTool()
   }

   showTOOLtip(friendly ":" moreinfos, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyChangeBrushOpacity(dir) {
    If (dir=1)
       changeBrushOpacity(-1)
    Else
       changeBrushOpacity(1)
}

changeBrushOpacity(keyu, isKeyu:=0) {
    If (isKeyu=1)
    {
       thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       keyu := StrReplace(keyu, "+")
       factoru := (keyu>0.2) ? "0." keyu : 1
       If (keyu=1 && isInRange(thisOpacity, 22, 27))
          factoru := 0.05

       newOpacity := clampInRange(Round(255 * factoru), 1, 255)
       If (BrushToolUseSecondaryColor=1)
          BrushToolBopacity := newOpacity 
       Else
          BrushToolAopacity := newOpacity

       showTOOLtip("Brush opacity: " Round(factoru*100) "%", "dummyChangeBrushOpacity", 2, newOpacity/255)
    } Else
    {
       newOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
       If (keyu=-1)
          newOpacity += 10
       Else
          newOpacity -= 10

       newOpacity := clampInRange(newOpacity, 1, 255)
       If (BrushToolUseSecondaryColor=1)
          BrushToolBopacity := newOpacity 
       Else
          BrushToolAopacity := newOpacity

       showTOOLtip("Brush opacity: " Round((newOpacity / 255) * 100) "%", "dummyChangeBrushOpacity", 2, newOpacity/255)
    }

    If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
    {
       If (isKeyu=1)
          showLEDprimaryColor()
       GuiUpdateSliders("BrushToolAopacity")
       GuiUpdateSliders("BrushToolBopacity")
    }

    liveDrawingBrushTool := 1
    interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, MouseMoveResponder, -25
}

preventColorChange() {
    If (AnyWindowOpen=64 && BrushToolType>2)
    {
       If (mustCaptureCloneBrush=1)
          Return

       If (BrushToolType=3)
          showTOOLtip("WARNING: You are currently using the cloner brush tool`nTo define the source pattern, press D.")
       Else
          showTOOLtip("WARNING: You are currently using a brush that does not rely on a given color")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return 1
    }
}

changeBrushColorPicker() {
    If preventColorChange() 
       Return

    endCaptureCloneBrush()
    thisColor := (BrushToolUseSecondaryColor=1) ? "PickuBrushToolBcolor" : "PickuBrushToolAcolor"
    oldClrName := (BrushToolUseSecondaryColor=1) ? "BrushToolBcolor" : "BrushToolAcolor"
    ; showTOOLtip("Pick brush color")
    ; SetTimer, RemoveTooltip, % -msgDisplayTime
    obju := StartPickingColor("isGiven", "SettingsGUIA", thisColor, "leave-it")
    If (ShowAdvToolbar=1)
    {
       newColor := obju[1] , oldColor := obju[2]
       updateToolColorsBasedToolbar(newColor, oldColor, oldClrName)
       updateTlbrColorsSwatch()
    }

    SetTimer, MouseMoveResponder, -25
    If (imgEditPanelOpened=1 && AnyWindowOpen)
       livePreviewsImageEditing()
}

changeBrushSize(dir) {
   liveDrawingBrushTool := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   factoru := (brushToolSize>50) ? 10 : 5
   If (dir=1)
      brushToolSize += factoru
   Else
      brushToolSize -= factoru

   endCaptureCloneBrush()
   BrushToolSize := clampInRange(brushToolSize, 1, 950)
   friendly := (BrushToolDoubleSize=1) ? "RADIUS" : "DIAMETER"
   showTOOLtip("Brush " friendly " size: " groupDigits(brushToolSize) " px", A_ThisFunc, 2, brushToolSize/950)
   If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
   {
      theSize := (BrushToolDoubleSize!=1) ? "Diameter: $€ px." : "Radius: $€ px."
      uiSlidersArray["BrushToolSize", 5] := theSize
      GuiUpdateSliders("BrushToolSize")
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

changeBrushShapeRatio(dir) {
   changeBrushRatioAngle(dir, 1)
}

changeBrushAnglu(dir) {
   changeBrushRatioAngle(dir, 2)
}

changeBrushRatioAngle(dir, what) {
   liveDrawingBrushTool := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   endCaptureCloneBrush()
   If (what=1)
   {
      BrushToolAspectRatio := clampInRange(BrushToolAspectRatio + 5*dir, -100, 100, 0)
      If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
         GuiUpdateSliders("BrushToolAspectRatio")

      showTOOLtip("Brush aspect ratio: " BrushToolAspectRatio, 0, 0, (BrushToolAspectRatio + 100)/201)
   } Else
   {
      BrushToolAutoAngle := 0
      BrushToolAngle := clampInRange(BrushToolAngle + 10*dir, -180, 180, 0)
      If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
         GuiUpdateSliders("BrushToolAngle")

      showTOOLtip("Brush angle: " BrushToolAngle "° ", 0, 0, (BrushToolAngle + 180)/361)
   }

   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

MenuResetBrushAsRatio() {
   liveDrawingBrushTool := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   endCaptureCloneBrush()
   BrushToolAspectRatio := BrushToolAngle := 0
   If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
   {
      GuiUpdateSliders("BrushToolAspectRatio")
      GuiUpdateSliders("BrushToolAngle")
   }

   showTOOLtip("Brush aspect ratio: RESET")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

toggleBrushMouseAngle() {
   endCaptureCloneBrush()
   liveDrawingBrushTool := 1
   BrushToolAutoAngle  := !BrushToolAutoAngle
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   If (AnyWindowOpen=64 || isAlphaMaskWindow()=1)
   {
      GuiControl, SettingsGUIA:, BrushToolAutoAngle, % BrushToolAutoAngle
      uiSlidersArray["BrushToolAngle", 10] := !BrushToolAutoAngle
      GuiUpdateSliders("BrushToolAngle")
   }

   friendly := (BrushToolAutoAngle=1) ? "Alter brush angle based on mouse movements" : "Fixed brush angle: " BrushToolAngle "° "
   showTOOLtip(friendly, A_ThisFunc, 1)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

changeBrushSoftness(dir) {
   If (BrushToolType=1)
      Return

   If (dir=1)
      BrushToolSoftness += 2
   Else
      BrushToolSoftness -= 2

   endCaptureCloneBrush()
   liveDrawingBrushTool := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   BrushToolSoftness := clampInRange(BrushToolSoftness, 1, 99)
   showTOOLtip("Brush softness: " BrushToolSoftness "%", A_ThisFunc, 2, BrushToolSoftness/100)
   If (AnyWindowOpen=64 || AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiUpdateSliders("BrushToolSoftness")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

changeBrushWetness(dir) {
   isOkay := (BrushToolType=2 || BrushToolType=7 || BrushToolType=8) ? 1 :0
   If (isOkay!=1)
      Return

   If (dir=1)
      BrushToolWetness++
   Else
      BrushToolWetness--

   liveDrawingBrushTool := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   BrushToolWetness := clampInRange(BrushToolWetness, 0, 22)
   friendly := (BrushToolType>6) ? "deform intensity" : "wetness"
   showTOOLtip("Brush " friendly ": " BrushToolWetness, A_ThisFunc, 2, BrushToolWetness/22)
   If (AnyWindowOpen=64)
      GuiUpdateSliders("BrushToolWetness")

   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, MouseMoveResponder, -25
}

createGradientBrushBitmap(brushColor, grPosA, brushSize, grAngle, bAR, opacity:=0, bgr:=0) {
    Critical, on
    Static offsetX := 0, offsetY := 0, grPosB := 99.9, prevState, prevBrushu
    If (brushColor="kill")
    {
       prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
       prevState := ""
       Return
    }

    isAlphaPainting := isNowAlphaPainting()
    offsetX := (isAlphaPainting=1) ? 0 : alphaMaskOffsetX
    offsetY := (isAlphaPainting=1) ? 0 : alphaMaskOffsetY
    thisColorA := opacity ? opacity brushColor : "0xFF" brushColor
    thisColorB := "0x00" brushColor
    rImgW := rImgH :=  brushSize
    ; ToolTip, % thisColorA "`n" thisColorB, , , 2
    thisAR := 1 - Abs(bAR)/105
    brImgSelW := (bAR>0) ? brushSize * thisAR : brushSize
    brImgSelH := (bAR<0) ? brushSize * thisAR : brushSize
    brimgSelPx := 0 - (brImgSelW - rImgW)//2
    brimgSelPy := 0 - (brImgSelH - rImgH)//2
    thisState := "a" bgr brImgSelW brImgSelH brimgSelPx brimgSelPy thisAR bAR brushSize thisColorA thisColorB grPosA grAngle offsetX offsetY BrushToolTexture
    If (thisState!=prevState || !validBMP(prevBrushu))
    {
       brushBitmap := trGdip_CreateBitmap(A_ThisFunc, brushSize, brushSize, "0xE200B")
       If !validBMP(brushBitmap)
          Return

       prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
       Ga := trGdip_GraphicsFromImage(A_ThisFunc, brushBitmap, 3)
       Gdip_SetPixelOffsetMode(Ga, 2)
       If (BrushToolTexture=1)
       {
          grpPath := Gdip_CreatePath()
          If grpPath
          {
             Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
             gradBrush := Gdip_PathGradientCreateFromPath(grpPath)
             If gradBrush
             {
                Gdip_PathGradientSetCenterPoint(gradBrush, 0 + rImgW//2 + Round(rImgW*offsetX), 0 + rImgH//2 + Round(rImgH*offsetY))
                Gdip_SetLinearGrBrushPresetBlend(gradBrush, [grPosA/100, grPosB/100], [thisColorA, thisColorB])
                Gdip_RotatePathGradientAtCenter(gradBrush, grAngle, 1)
                ; Gdip_PathGradientSetWrapMode(gradBrush, gradientWrapMode)
             }

             Gdip_DeletePath(grpPath)
          }

          If (bgr!="")
             Gdip_GraphicsClear(Ga, bgr)
          Gdip_FillEllipse(Ga, gradBrush, 0, 0, rImgW, rImgH)
          Gdip_DeleteBrush(gradBrush)
       } Else
       {
          pBitmap := LoadCachableBitmapFromFile(mainExecPath "\resources\brush-texture-" BrushToolTexture - 1 ".png")
          If validBMP(pBitmap)
          {
             If (grAngle>0)
             {
                pBitmap3 := trGdip_RotateBitmapAtCenter(A_ThisFunc, pBitmap, grAngle, 0, 3)
                If validBMP(pBitmap3)
                {
                   trGdip_DisposeImage(pBitmap, 1)
                   pBitmap := pBitmap3
                }
             }

             If !bgr
             {
                Gdip_GraphicsClear(Ga, thisColorA)
                pBitmap2 := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, rImgW, rImgH, 0, 3)
                trGdip_DisposeImage(pBitmap, 1)
                ; QPV_BlendBitmaps(brushBitmap, pBitmap2, 2, 0)
                QPV_SetBitmapAsAlphaChannel(brushBitmap, pBitmap2, 0, 1, 1)
                trGdip_DisposeImage(pBitmap2, 1)
             } Else
             {
                tzGdip_DrawImage(Ga, pBitmap, 0, 0, rImgW, rImgH)
                trGdip_DisposeImage(pBitmap, 1)
             }
          }
          ; tzGdip_DrawImage(Ga, pBitmap, 0, 0, rImgW, rImgH)
       }
       If Ga
          Gdip_DeleteGraphics(Ga)
       prevState := thisState
       prevBrushu := trGdip_CloneBitmap(A_ThisFunc, brushBitmap)
    } Else If validBMP(prevBrushu)
       brushBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBrushu)

    Return brushBitmap
}

createClonedBrushBitmap(brushSize, brushSofty, brushAngle, thisAR, whichBitmap, offsetX:=0, offsetY:=0, doBlur:=0, noAlphaMask:=0, previewMode:=0) {
   Static noPrompting := 0, brushAlpha, prevState, prevBrushu, hasEverDefineSource := 0
   endCaptureCloneBrush()
   If (brushSize="kill")
   {
      prevState := ""
      prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
      Return
   }

   If (!isNumber(tinyPrevAreaCoordX) || !isNumber(tinyPrevAreaCoordY))
   {
      prevState := ""
      hasEverDefineSource := 1
      If (brushAngle="mouse")
      {
         mX := brushSize
         mY := brushSofty
      } Else GetMouseCoord2wind(PVhwnd, mX, mY)

      vpWinClientSize(mainWidth, mainHeight)
      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
      tinyPrevAreaCoordX := kX, tinyPrevAreaCoordY := kY
      showTOOLtip("Cloner brush source set to`n" kX " / " kY)
      SoundBeep , 900, 100
      If (BrushToolApplyColorFX=1 || BrushToolBlurStrength>1) && (noPrompting=0)
      {
         msgResult := msgBoxWrapper(appTitle ": Cloner effects", "The cloner tool has color effects activated. Do you want to deactivate the brush cloner effects?", 4, 0, "question", "&Do not prompt me again in this session")
         noPrompting := msgResult.check
         If (msgResult.btn="Yes")
         {
            BrushToolApplyColorFX := BrushToolBlurStrength := 0
            If (AnyWindowOpen=64)
            {
               GuiControl, SettingsGUIA:, BrushToolApplyColorFX, 0
               GuiUpdateSliders("BrushToolBlurStrength")
               updateUIbrushTool()
            }
         }
      }

      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      SetTimer, dummyRefreshImgSelectionWindow, -150
      Return
   }

   If (!hasEverDefineSource && previewMode=0)
   {
      msgBoxWrapper(appTitle ": WARNING", "Please define the source for the clone tool.", 0, 0, "exclamation")
      BtnSetClonerBrushSource()
      Return
   }

   tkX := tinyPrevAreaCoordX
   tkY := tinyPrevAreaCoordY
   If (BrushToolDynamicCloner=1)
   {
      tkX := tkX - offsetX
      tkY := tkY - offsetY
   }

   thisState := "a" brushSofty brushSize BrushToolSize brushAngle BrushToolDynamicCloner thisAR offsetX offsetY tkX tkY BrushToolBlurStrength doBlur BrushToolApplyColorFX PasteInPlaceLight PasteInPlaceGamma PasteInPlaceHue PasteInPlaceSaturation noAlphaMask BrushToolTexture
   If (thisState!=prevState || !validBMP(prevBrushu))
   {
      prevBrushu := trGdip_DisposeImage(prevBrushu, 1)
      brushu := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, 1)
      If (noAlphaMask=0)
      {
         applyPersonalizedColorsBMP(brushu, 1, BrushToolBlurStrength, BrushToolApplyColorFX)
         brushuAlpha := createGradientBrushBitmap("ffFFff", brushSofty, brushSize, brushAngle, thisAR, 0, "0xFF000000")
         QPV_SetBitmapAsAlphaChannel(brushu, brushuAlpha)
         trGdip_DisposeImage(brushuAlpha, 1)
      }
      prevState := thisState
      prevBrushu := trGdip_CloneBitmap(A_ThisFunc, brushu)
   } Else If validBMP(prevBrushu)
      brushu := trGdip_CloneBitmap(A_ThisFunc, prevBrushu)

   Return brushu
}

somewhatAccurateBrightnessShift(hex, lum=0.5, mode=1) {
   ; from tidbit ; thanks 
   for k, val in [substr(hex, 3, 2), substr(hex, 5, 2), substr(hex, 7, 2)] ; split the hex into an array of [##,##,##]
      val:=format("{1:d}", "0x" val) ; convert from hex, to decimal values
      , val:=round((mode=1) ? val*lum : val+lum) ; do the math
      , val:=(val<0) ? 0 : (val>255) ? 255 : val ; clamp the values between 0 and 255
      , out.=format("{1:02}", format("{1:x}", val)) ; build it again, make sure each hex thing is 2 chars long
   return out ; we're done!
}

RandomizeBrushColor(startToolColor) {
   o_startToolColor := startToolColor
   If (BrushToolRandomLight>0 && BrushToolRandomDark<1)
      zR := 1
   Else If (BrushToolRandomLight<1 && BrushToolRandomDark>0)
      zR := 6
   Else
      zR := Randomizer(1, 10, 1, 14)

   If (BrushToolRandomLight>0 && isInRange(zR, 1, 5))
   {
      gR := BrushToolRandomLight
      gR := Randomizer(0, gR, 8, 8)
      gRz := (100 - gR)/101
      startToolColor := SubStr(MixARGB("0xFFfffFff", "0xFF" startToolColor, gRz), 5)
      ; ToolTip, % gR "===" gRz "`n" startToolColor "`n" o_startToolColor , , , 2
   }

   If (BrushToolRandomDark>0 && isInRange(zR, 5, 10))
   {
      gR := BrushToolRandomDark
      gR := Randomizer(0, gR, 8, 9)
      gRz := (100 - gR)/101
      startToolColor := SubStr(MixARGB("0xFF000000", "0xFF" startToolColor, gRz), 5)
   }

   If (BrushToolRandomHue<1 && BrushToolRandomSat<1)
      Return startToolColor

   H := HSL_Hue("0x" startToolColor)
   S := HSL_Sat("0x" startToolColor)
   L := HSL_Lum("0x" startToolColor)
   If (BrushToolRandomHue>0)
   {
      gR := BrushToolRandomHue
      gR := Randomizer(-gR, gR, 2, 10)
      H := clampInRange(H + gR, 0, 360)
   }

   If (BrushToolRandomSat>0)
   {
      gR := BrushToolRandomSat
      gR := Randomizer(-gR, gR, 2, 11)
      S := clampInRange(S*100 + gR, 0, 100)/100
   }

   startToolColor := HSL_ToRGB(H, S, L)
   startToolColor := SubStr(startToolColor, 3)
   ; ToolTip, % H "=" S "=" L "`n" R "=" G "=" B , , , 2
   Return startToolColor
}

HSL_ToRGB(hue, sat:=1, lum:=0.5 ) {
; Function by [VxE]. See > http://www.wikipedia.org/wiki/HSV_color_space
; HSL to/from RGB conversion functions by [VxE]. Freely avalable @ http://www.autohotkey.com/community/viewtopic.php?f=2&t=88707
; Converts a hue/sat/lum into a 24-bit RGB color code. Input: 0 <= hue <= 360, 0 <= sat <= 1, 0 <= lum <= 1. 

   Static i24 := 0xFFFFFF, i40 := 0xFFFFFF0000, hx := "0123456789ABCDEF"

; Transform the decimal inputs into 24-bit integers. Integer arithmetic is nice..
   sat := ( sat * i24 ) & i24
   lum := ( lum * i24 ) & i24
   hue := ( hue * 0xB60B60 >> 8 ) & i24 ; conveniently, 360 * 0xB60B60 = 0xFFFFFF00

; Determine the chroma value and put it in the 'sat' var since the saturation value is not used after this.
   sat := lum + Round( sat * ( i24 - Abs( i24 - lum - lum ) ) / 0x1FFFFFE )

; Calculate the base values for red and blue (green's base value is the hue)
   red := hue < 0xAAAAAA ? hue + 0x555555 : hue - 0xAAAAAA
   blu := hue < 0x555555 ? hue + 0xAAAAAA : hue - 0x555555

; Run the blue value through the cases
   If ( blu < 0x2AAAAB )
      blu := sat + 2 * ( i24 - 6 * blu ) * ( lum - sat ) / i24 >> 16
   Else If ( blu < 0x800000 )
      blu := sat >> 16
   Else If ( blu < 0xAAAAAA )
      blu := sat + 2 * ( i24 - 6 * ( 0xAAAAAA - blu ) ) * ( lum - sat ) / i24 >> 16
   Else
      blu := 2 * lum - sat >> 16

; Run the red value through the cases
   If ( red < 0x2AAAAB )
      red := sat + 2 * ( i24 - 6 * red ) * ( lum - sat ) / i24 >> 16
   Else If ( red < 0x800000 )
      red := sat >> 16
   Else If ( red < 0xAAAAAA )
      red := sat + 2 * ( i24 - 6 * ( 0xAAAAAA - red ) ) * ( lum - sat ) / i24 >> 16
   Else
      red := 2 * lum - sat >> 16

; Run the green value through the cases
   If ( hue < 0x2AAAAB )
      hue := sat + 2 * ( i24 - 6 * hue ) * ( lum - sat ) / i24 >> 16
   Else If ( hue < 0x800000 )
      hue := sat >> 16
   Else If ( hue < 0xAAAAAA )
      hue := sat + 2 * ( i24 - 6 * ( 0xAAAAAA - hue ) ) * ( lum - sat ) / i24 >> 16
    Else
      hue := 2 * lum - sat >> 16

; Return the values in RGB as a hex integer
   Return "0x" SubStr( hx, ( red >> 4 ) + 1, 1 ) SubStr( hx, ( red & 15 ) + 1, 1 )
         . SubStr( hx, ( hue >> 4 ) + 1, 1 ) SubStr( hx, ( hue & 15 ) + 1, 1 )
         . SubStr( hx, ( blu >> 4 ) + 1, 1 ) SubStr( hx, ( blu & 15 ) + 1, 1 )
} ; END - HSL_ToRGB( hue, sat, lum )

HSL_Hue( RGB ) {
; Function by [VxE]. Returns the HSL hue of the input 24-bit RGB code.
; Returns a floating point value less than 360 but not less than 0.

   blu := 255 & ( RGB )
   grn := 255 & ( RGB >> 8 )
   red := 255 & ( RGB >> 16 )

   If ( blu = grn ) && ( blu = red )
   {
      Return 0 + 0.0
   } Else If ( blu < grn )
   {
      If ( red < blu )
         Return 60 * ( blu - red ) / ( grn - red ) + 120
      Else If ( grn < red )
         Return 60 * ( grn - blu ) / ( red - blu )
      Else
         Return 60 * ( blu - red ) / ( grn - blu ) + 120
   } Else
   {
      If ( red < grn )
         Return 60 * ( red - grn ) / ( blu - red ) + 240
      Else If ( blu < red )
         Return 60 * ( grn - blu ) / ( red - grn ) + ( blu = grn ? 0 : 360 )
      Else
         Return 60 * ( red - grn ) / ( blu - grn ) + 240
   }
} ; END - HSL_Hue( RGB )

HSL_Sat( RGB ) {
; Function by [VxE]. Returns the HSL saturation of the input 24-bit RGB code.
; Returns a floating point value between 0 and 1, inclusive.

   blu := 255 & ( RGB )
   grn := 255 & ( RGB >> 8 )
   red := 255 & ( RGB >> 16 )

   If ( blu = grn ) && ( blu = red )
   {
      Return 0 + 0.0
   } Else If ( blu < grn )
   {
      If ( red < blu )
         return ( grn - red ) / ( 255 - Abs( 255 - grn - red ) )
      Else If ( grn < red )
         return ( red - blu ) / ( 255 - Abs( 255 - red - blu ) )
      Else
         return ( grn - blu ) / ( 255 - Abs( 255 - grn - blu ) )
   } Else
   {
      If ( red < grn )
         return ( blu - red ) / ( 255 - Abs( 255 - blu - red ) )
      Else If ( blu < red )
         return ( red - grn ) / ( 255 - Abs( 255 - red - grn ) )
      Else
         return ( blu - grn ) / ( 255 - Abs( 255 - blu - grn ) )
   }
} ; END - HSL_Sat( RGB )

HSL_Lum( RGB ) {
; Function by [VxE]. Returns the HSL lightness of the input 24 bit color.
; Returns a floating point value between 0 and 1, inclusive.

   blu := 255 & ( RGB )
   grn := 255 & ( RGB >> 8 )
   red := 255 & ( RGB >> 16 )

   If ( blu < grn )
   {
      If ( red < blu )
         Return ( red + grn ) / 510
      Else If ( grn < red )
         Return ( blu + red ) / 510
      Else
         Return ( blu + grn ) / 510
   } Else
   {
      If ( red < grn )
         Return ( red + blu ) / 510
      Else If ( blu < red )
         Return ( grn + red ) / 510
      Else
         Return ( grn + blu ) / 510
   }
} ; END - HSL_Lum( RGB )

Randomizer(minu, maxu, errMargin, idu) {
   Static prevIDs := []
   Random, OutputVar, % minu, % maxu
   ; If isInRange(OutputVar, prevIDs[idu] + errMargin, prevIDs[idu] - errMargin)
   ; {
   ;    Random, OutputVar, % minu, % maxu
   ;    If (prevIDs[idu]=OutputVar)
   ;       Random, OutputVar, % minu, % maxu
   ; }

   prevIDs[idu] := OutputVar
   Return OutputVar
}

decideAlphaMaskingFeaseable(userBias, doLimits:=0) {
   allowAlphaMasking := userBias
   If (userBias=1)
      infoMask := defineCurrentAlphaMask()
   If (InStr(infoMask, "inexistent") || InStr(infoMask, "none"))
      allowAlphaMasking := 0

   If (allowAlphaMasking=1 && doLimits=1)
      innerSelectionCavityX := innerSelectionCavityX := VPselRotation := EllipseSelectMode := 0
   Return allowAlphaMasking
}

mergeViewPortRotationImgEditing() {
   If ((usrColorDepth>1 || vpIMGrotation>0) && !viewportQPVimage.imgHandle && validBMP(useGdiBitmap()))
   {
      wrapRecordUndoLevelNow(trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap()))
      usrColorDepth := 1
      vpIMGrotation := 0
      INIaction(1, "usrColorDepth", "General")
      INIaction(1, "vpIMGrotation", "General")
      defineColorDepth()
      Return 1
   }
}

ActFloodFillNow() {
   Critical, on
   Static lastInvoked := 1, prevMX, prevMY, countClicks, HasTested
   If (A_TickCount - lastOtherWinClose<450) || (A_TickCount - lastInvoked<250)
      Return

   If !(viewportQPVimage.imgHandle)
      mergeViewPortEffectsImgEditing(A_ThisFunc)
   whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
   trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
   If (!imgW || !imgH || !validBMP(whichBitmap))
   {
      SetTimer, ResetImgLoadStatus, -25
      addJournalEntry(A_ThisFunc "(): Main bitmap malformed or missing.")
      Return
   }

   If (toolTipGuiCreated=2)
   {
      SetTimer, ResetImgLoadStatus, -25
      RemoveTooltip()
      Return
   }

   vpWinClientSize(mainWidth, mainHeight)
   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := (FlipImgH=1) ? mainWidth - mX : mX
   mY := (FlipImgV=1) ? mainHeight - mY : mY
   MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
   If (kX>=imgW || kY>=imgH || kX<1 || kY<1)
   {
      showTOOLtip("Please click inside the image to perform flood fill")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -25
      Return
   }

   If (viewportQPVimage.imgHandle)
   {
      HugeImagesApplyGenericFilters("flood fill", 1, [kX, kY])
      Return
   }

   hasCloned := 0
   allowAlphaMasking := decideAlphaMaskingFeaseable(FloodFillUseAlpha)
   allowSelectionCrop := (BrushToolOutsideSelection>1 && editingSelectionNow=1 && allowAlphaMasking=0) ? 1 : 0
   If (allowSelectionCrop=1 || allowAlphaMasking=1)
   {
      hasCloned := 1
      thisBMP := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
      If validBMP(thisBMP)
         G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)

      calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      If (editingSelectionNow=1 && BrushToolOutsideSelection>1)
         pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)

      If (!validBMP(thisBMP) || G2="" || (pPath="" && editingSelectionNow=1 && BrushToolOutsideSelection>1))
      {
         showTOOLtip("Failed to apply flood fill in the image selected area")
         SoundBeep , 300, 100
         If (G2!="")
            Gdip_DeleteGraphics(G2)
         If (pPath!="")
            Gdip_DeletePath(pPath)

         trGdip_DisposeImage(thisBMP, 1)
         SetTimer, ResetImgLoadStatus, -250
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   } Else thisBMP := whichBitmap

   If (FloodFillAltToler=3)
      showTOOLtip("Applying flood fill at the coordinates:`n" groupDigits(kX) ", " groupDigits(kY))

   If (undoLevelsRecorded<2 && preventUndoLevels!=1)
      recordUndoLevelNow("init", 0)

   ; newColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor 
   r := QPV_FloodFill(thisBMP, kX, kY, "0x" Format("{:X}", FloodFillClrOpacity) FloodFillColor, FloodFillOpacity)
   If (r>0 && (pPath!="" && G2!="" && allowSelectionCrop=1 && hasCloned=1) || (validBMP(thisBMP) && allowAlphaMasking=1))
   {
      If (allowAlphaMasking=1)
      {
         If (editingSelectionNow=1 && BrushToolOutsideSelection=2)
            gBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1, 0)

         fBitmap := validBMP(gBitmap) ? gBitmap : thisBMP
         thisIDu := "a" imgSelPx imgSelPy imgSelW imgSelH
         realtimePasteInPlaceAlphaMasker(0, fBitmap, thisIDu, newBitmap, 0, 0, 0, 0)
         If validBMP(newBitmap)
         {
            If validBMP(gBitmap)
            {
               G3 := trGdip_GraphicsFromImage(A_ThisFunc, thisBMP)
               Gdip_SetClipRect(G3, imgSelPx, imgSelPy, imgSelW, imgSelH)
               r0 := trGdip_GraphicsClear(A_ThisFunc, G3)
               r1 := trGdip_DrawImage(A_ThisFunc, G3, newBitmap, imgSelPx, imgSelPy)
               Gdip_DeleteGraphics(G3)
               trGdip_DisposeImage(newBitmap, 1)
            } Else
            {
               trGdip_DisposeImage(thisBMP, 1)
               thisBMP := newBitmap
            }
         }
         trGdip_DisposeImage(gBitmap, 1)
         ; realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
      }

      thisMode := (BrushToolOutsideSelection=3) ? 4 : 0
      If (pPath!="" && (allowSelectionCrop=1 || allowAlphaMasking=1))
      {
         Gdip_SetClipPath(G2, pPath, thisMode)
         If (userimgGammaCorrect=1 && allowAlphaMasking=1)
            Gdip_SetCompositingQuality(G2, 2)
         If (allowAlphaMasking!=1)
            r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
      }
      r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, 0, 0)
      trGdip_DisposeImage(thisBMP, 1)
      Gdip_DeleteGraphics(G2)
   }

   If (pPath!="")
      Gdip_DeletePath(pPath)
   If (FloodFillClrOpacity<254 && r>1)
      currIMGdetails.HasAlpha := 1

   lastInvoked := A_TickCount
   whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
   If (r>1 && validBMP(whichBitmap))
      wrapRecordUndoLevelNow(whichBitmap)

   dummyTimerDelayiedImageDisplay(10)
   SetTimer, MouseMoveResponder, -25
   SetTimer, wrapResizeImageGDIwin, -30
   SetTimer, RemoveTooltip, -10
   SetTimer, ResetImgLoadStatus, -20
}

calcBrushSymmetryCoords(tkX, tkY, imgW, imgH, ByRef skX, ByRef skY) {
   ccX := Round(imgW * BrushToolSymmetryPointX)
   ccY := Round(imgH * BrushToolSymmetryPointY)
   skX := (tkX<ccX) ? ccX - tkX + ccX : ccX - (tkX - ccX)
   skY := (tkY<ccY) ? ccY - tkY + ccY : ccY - (tkY - ccY)
   If (BrushToolSymmetryX!=1)
      skX := tkX
   If (BrushToolSymmetryY!=1)
      skY := tkY
}

performClrEffectsBrush(whichBitmap, clonescu, tkX, tkY, brushSize, brushu, thisFloatOpacity, Gu) {
   thisBMP := (BrushToolOverDraw=0 && clonescu) ? clonescu : whichBitmap
   brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, 1)
   applyPersonalizedColorsBMP(brushImg, 1, BrushToolBlurStrength, BrushToolApplyColorFX)
   QPV_SetBitmapAsAlphaChannel(brushImg, brushu, 0)
   tzGdip_DrawImage(Gu, brushImg, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
   trGdip_DisposeImage(brushImg, 1)
}

performEraserBrush(tkX, tkY, brushSize, brushu, thisEraseOpacity, thisEraserMode, whichBitmap, Gu, thisSelectionConstrain, ImgSelPath, clonescu) {
   If thisSelectionConstrain
   {
      ; ToolTip, % testuz "=" otestPos , , , 2
      brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, 1)
      QPV_EraserBrush(brushImg, brushu, 0, thisEraserMode, thisEraseOpacity, 0, 0, 0)
      ; redraw erased area
      Gdip_SetClipRect(Gu, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 1)
      Gdip_GraphicsClear(Gu)
      tzGdip_DrawImage(Gu, brushImg, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, brushSize, brushSize)
      brushImg := trGdip_DisposeImage(brushImg, 1)
      Gdip_ResetClip(Gu)
      modus := (thisSelectionConstrain=1) ? 0 : 4
      If ImgSelPath
         Gdip_SetClipPath(Gu, ImgSelPath, modus)
   } Else
      QPV_EraserBrush(whichBitmap, brushu, 0, thisEraserMode, thisEraseOpacity, tkX - brushSize/2, tkY - brushSize/2, clonescu)

   currIMGdetails.HasAlpha := 1
}

ActPaintBrushNow() {
   Critical, on
   Static lastInvoked := 1, prevMX, prevMY, countClicks, HasTested

   If mergeViewPortRotationImgEditing()
   {
      dummyTimerDelayiedImageDisplay(10)
      SoundBeep 900, 100
      Return
   }

   mergeViewPortEffectsImgEditing(A_ThisFunc)
   whichBitmap := validBMP(UserMemBMP) ? UserMemBMP : gdiBitmap
   trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
   If (!imgW || !imgH)
   {
      addJournalEntry("ERROR: Main bitmap seems to be inexistent. Failure occured in " A_ThisFunc "()")
      Return
   }

   If (A_TickCount - lastOtherWinClose<450)
      Return

   canApplyFXa := (PasteInPlaceHue!=0 || PasteInPlaceSaturation!=0) && (BrushToolApplyColorFX=1) ? 1 : 0
   canApplyFXb := (PasteInPlaceLight!=0 || PasteInPlaceGamma!=0) && (BrushToolApplyColorFX=1) ? 1 : 0
   If (BrushToolBlurStrength<3 && canApplyFXa=0 && canApplyFXb=0 && BrushToolType=5)
      Return

   interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   vpWinClientSize(mainWidth, mainHeight)
   createGDIPcanvas(mainWidth, mainHeight)
   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := (FlipImgH=1) ? mainWidth - mX : mX
   mY := (FlipImgV=1) ? mainHeight - mY : mY
   imgPath := getIDimage(currentFileIndex)
   thisZeit := A_TickCount - 100
   thisIndex := 0
   Random, randomFactor, -950, 950
   randomFactor := Randomizer(-950, 950, 2, 1)
   prevState := "a"
   liveDrawingBrushTool := 1
   whichBitmap := useGdiBitmap()
   If (whichBitmap=UserMemBMP)
   {
      ; it has to be gdiBitmap... otherwise no live preview
      If (UserMemBMP=gdiBitmap)
         addJournalEntry(A_ThisFunc "(): ERROR. Illegal inequality. UserMemBMP=gdiBitmap" )

      If validBMP(gdiBitmap)
      {
         addJournalEntry(A_ThisFunc "(): ERROR. Illogical context. useGdiBitmap() returns UserMemBMP when gdiBitmap is valid!?" )
         trGdip_DisposeImage(gdiBitmap)
      }

      gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
      UserMemBMP := trGdip_DisposeImage(UserMemBMP)
      whichBitmap := gdiBitmap
   }

   trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
   kpi := (BrushToolType < 3) ? 1 : 0
   thisUseSecondaryColor := (kpi=1) ? BrushToolUseSecondaryColor : 0
   If (GetKeyState("Ctrl", "P") && kpi=1)
      thisUseSecondaryColor := !BrushToolUseSecondaryColor

   o_startToolColor := startToolColor := (thisUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   o_startToolColor := startToolColor := RandomizeBrushColor(startToolColor)
   thisMainOpacity := (thisUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisHexOpacity := Format("{1:#x}", thisMainOpacity)
   MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
   If (BrushToolWetness=21)
   {
      coloruA := Gdip_GetPixelColor(whichBitmap, kX, kY, 1)
      startToolColor := SubStr(MixARGB(coloruA, "0xFF" startToolColor, 0.5), 5)
      thisWetness := 20
   } Else If (BrushToolWetness=22)
   {
      coloruA := Gdip_GetPixelColor(whichBitmap, kX, kY, 1)
      startToolColor := SubStr(MixARGB(coloruA, "0xFF" startToolColor, 0.2), 5)
      thisWetness := 20
   } Else thisWetness := BrushToolWetness

   oMx := kX, oMy := kY
   thisSelectionConstrain := (editingSelectionNow=1) ? BrushToolOutsideSelection - 1 : 0
   o_brushSize := brushSize := (BrushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
   If (BrushToolType>=6 && brushSize<5)
      brushSize := 5

   If (BrushToolRandomSize>0)
   {
      gR := Ceil(brushSize * (BrushToolRandomSize/100)) + 1
      gR := Randomizer(-gR, gR, 2, 2)
      brushSize := clampInRange(brushSize + gR, brushSize//3 + 2, brushSize + Abs(gR))
   }

   thisBulgePinchFactor := (BrushToolType=6) ? BrushToolWetness*2 + 1 :  BrushToolWetness + 1
   If (BrushToolType=7)
      thisBulgePinchFactor := -BrushToolWetness - 1

   thisToolSoftness := BrushToolSoftness
   If (BrushToolRandomSoftness>0)
   {
      gR := BrushToolRandomSoftness
      gR := Randomizer(-gR, gR, 2, 3)
      thisToolSoftness := clampInRange(BrushToolSoftness + gR, 1, 100)
   }

   thisToolAngle := BrushToolAngle + 180
   If (BrushToolRandomAngle>0)
   {
      gR := BrushToolRandomAngle
      gR := Randomizer(-gR, gR, 2, 4)
      thisToolAngle := clampInRange(thisToolAngle + gR, 0, 180)
   }

   thisToolAspectRatio := BrushToolAspectRatio
   If (BrushToolRandomAspectRatio>0)
   {
      gR := BrushToolRandomAspectRatio
      gR := Randomizer(-gR, gR, 2, 5)
      thisToolAspectRatio := clampInRange(BrushToolAspectRatio + gR, -100, 100)
   }

   advancedSoftBrush := (BrushToolType=2 && (BrushToolOverDraw=0 || BrushToolBlendMode>1)) ? 1 : 0
   thisOpacity := (thisUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisFloatOpacity := thisOpacity/255
   ppiu := isVarEqualTo(BrushToolType, 1, 4, 5)
   If (ppiu=1 && BrushToolOverDraw=1 || ppiu!=1) && (advancedSoftBrush!=1)
   {
      thisMainOpacity := clampInRange(Round(thisMainOpacity/2.5 + 1 + BrushToolDryingRate*1.5), 1, 255)
      thisOpacity := clampInRange(Round(thisOpacity/2.5 + 1 + BrushToolDryingRate*1.5), 1, 255)
   }

   ; create base brush element / bitmap
   hmzu := (BrushToolType=5) ? Format("{1:#x}", Round(thisOpacity)) : 0
   If (BrushToolType=3) ; cloner
      brushu := createClonedBrushBitmap(brushSize, 100 - thisToolSoftness, thisToolAngle, thisToolAspectRatio, whichBitmap, 0, 0, 1)
   Else If (advancedSoftBrush=1 || isVarEqualTo(BrushToolType, 4, 5, 7, 8)) ; eraser, effects, pinch and bulge brushes
      brushu := createGradientBrushBitmap("ffFFff", 100 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio, hmzu, "0xff000000")
   Else If (BrushToolType=6) ; smudge/pinch/bulge
      brushu := createGradientBrushBitmap("ffFFff", 100 - thisToolSoftness, brushSize + thisBulgePinchFactor, thisToolAngle, thisToolAspectRatio, 0, "0xff000000")
   Else If (BrushToolType>1) ; soft edges
      brushu := createGradientBrushBitmap(startToolColor, 100 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio)
   Else ; simple solid
      gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)

   If (!validBMP(brushu) && BrushToolType>1)
   {
      ; liveDrawingBrushTool := 0
      addJournalEntry("ERROR: no brush image. Failure occured in " A_ThisFunc "()")
      Return
   }

   If ((BrushToolType=4 && !thisSelectionConstrain) || (BrushToolType=5 && BrushToolOverDraw=0) || (BrushToolType=3 && BrushToolDynamicCloner=1) || (advancedSoftBrush=1))
      clonescu := trGdip_CloneBitmap(A_ThisFunc, whichBitmap)

   imgIndexEditing := currentFileIndex
   thisQuality := (BrushToolType>5) ? 7 : 5
   compositingQuality := (userimgGammaCorrect=1) ? 2 : 1
   ; we need a live view in the viewport of the bitmap; so we work with it directly [ useGdiBitmap == whichBitmap ]
   metaBitmap := whichBitmap ; trGdip_CloneBitmap(A_ThisFunc, whichBitmap)
   If validBMP(metaBitmap)
      Gu := trGdip_GraphicsFromImage(A_ThisFunc, metaBitmap, thisQuality,,, compositingQuality)

   If !Gu
   {
      ; liveDrawingBrushTool := 0
      trGdip_DisposeImage(brushu, 1)
      trGdip_DisposeImage(brushImg, 1)
      trGdip_DisposeImage(clonescu, 1)
      If gdipbrushu
         Gdip_DeleteBrush(gdipbrushu)

      addJournalEntry(A_ThisFunc "(). ERROR. Failed to create graphics object on bmp=" whichBitmap)
      Return
   }

   If ((A_TickCount - lastInvoked>350) && undoLevelsRecorded<2 && preventUndoLevels!=1)
      recordUndoLevelNow("init", 0)

   Gdip_SetPixelOffsetMode(Gu, 2)
   If thisSelectionConstrain
   {
      calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY)
      modus := (thisSelectionConstrain=1) ? 0 : 4
      Gdip_SetClipPath(Gu, ImgSelPath, modus)
   } 

   If (advancedSoftBrush=1)
   {
      opacityBMPmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
      pgu := Gdip_GraphicsFromImage(opacityBMPmap)
      Gdip_GraphicsClear(pgu, "0xFF000000")
      If thisSelectionConstrain
      {
         modus := (thisSelectionConstrain=1) ? 4 : 0
         Gdip_SetClipPath(pgu, ImgSelPath, modus)
         Gdip_GraphicsClear(pgu, "0x00000000")
         Gdip_ResetClip(pgu)
         Gdip_DeletePath(ImgSelPath)
         thisSelectionConstrain := 0
      }
      Gdip_DeleteGraphics(pgu)
   }

   thisEraserMode := (BrushToolOverDraw=1) ? 2 : 1
   If (BrushToolEraserRestore=1)
      thisEraserMode := 3

   thisEraseOpacity := (thisEraserMode=1) ? 255 - thisEraseOpacity : thisOpacity
   thisWet := 0.79 + (21 - thisWetness)/100
   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   dryZeit := A_TickCount
   dryRateZeit := 50 + BrushToolDryingRate*4
   thisDryRate := clampInRange(BrushToolDryingRate/4, 0.5, 20)
   isUserStepu := (brushToolStepping=1 || brushToolStepping=2 || brushToolStepping=251) ? 0 : 1
   If (brushSize<2)
      isUserStepu := 0

   stepu := (isUserStepu=0 || brushSize<2) ? Ceil(brushSize * 0.2)**1.09 : brushToolStepping
   If (BrushToolType>6 || BrushToolType=5) && (isUserStepu=1 && stepu<brushSize/4 && isInRange(BrushToolAspectRatio, -5, 5) && isInRange(thisToolAngle, 0, 5))
      stepu := brushSize//4 + 1

   If (!stepu || BrushToolType>=7 || brushToolStepping=0 && brushSize>1)
      stepu := 1

   ; ToolTip, % stepu "|" isUserStepu "|" brushSize , , , 2
   If !GetKeyState("Shift", "P")
      prevMX := prevMY := 0

   offX := offY := 0
   setWhileLoopExec(1)
   Static plopa := 0
   While, (determineLClickState()=1 || A_Index<2)
   {
      If (thisOpacity<0.005 || brushSize<1)
         Break
      
      GetMouseCoord2wind(PVhwnd, mX, mY)
      If (BrushToolRandomPosX>0)
      {
         gR := Ceil(brushSize*(BrushToolRandomPosX/100))
         gR := Randomizer(-gR, gR, 3, 6)
         mX += gR
      }

      If (BrushToolRandomPosY>0)
      {
         gR := Ceil(brushSize*(BrushToolRandomPosY/100))
         gR := Randomizer(-gR, gR, 3, 7)
         mY += gR
      }

      If (BrushToolType<3 && BrushToolWetness>0) || (BrushToolType=3 && BrushToolDynamicCloner=1)
      {
         If (BrushToolRandomSize>0)
         {
            gR := Ceil(o_brushSize * (BrushToolRandomSize/100)) + 1
            gR := Randomizer(-gR, gR, 2, 2)
            brushSize := clampInRange(o_brushSize + gR, o_brushSize//3 + 2, o_brushSize + Abs(gR))
         }

         If (BrushToolRandomSoftness>0)
         {
            gR := BrushToolRandomSoftness
            gR := Randomizer(-gR, gR, 2, 3)
            thisToolSoftness := clampInRange(BrushToolSoftness + gR, 1, 100)
         }

         If (BrushToolRandomAngle>0)
         {
            gR := BrushToolRandomAngle
            gR := Randomizer(-gR, gR, 2, 4)
            thisToolAngle := clampInRange(BrushToolAngle + 180 + gR, 0, 180)
         }

         If (BrushToolRandomAspectRatio>0)
         {
            gR := BrushToolRandomAspectRatio
            gR := Randomizer(-gR, gR, 2, 5)
            thisToolAspectRatio := clampInRange(BrushToolAspectRatio + gR, -100, 100)
         }
      }

      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY, metaBitmap, 1, imgW, imgH)
      ; ToolTip, % offX "-" offY "`n" kX "-" kY "`n" oMx "-" oMy , , , 2
      ; fnOutputDebug("size=" brushSize "|img coords: " kX "/" kY "|" plopa "|" mX "/" mY)
      If (brushSize>1)
      {
         If isDotInRect(kX, kY, prevMX - stepu, prevMX + stepu, prevMY - stepu, prevMY + stepu)
         || !isDotInRect(kX, kY, 0 - brushSize//2, imgW + brushSize//2, 0 - brushSize//2, imgH + brushSize//2)
            Continue
      }

      thisState := "a" mX mY kX kY randomFactor
      ; ToolTip, % thisState , , , 2
      If (prevState!=thisState && (A_TickCount - thisZeit>5))
      {
         ; calculate coords for the brush
         If !prevMX
            prevMX := kX 
         If !prevMY
            prevMY := kY
         distX := Abs(kX - prevMX) ; max(kX, prevMX) - min(kX, prevMX)
         distY := Abs(kY - prevMY) ; max(kY, prevMY) - min(kX, prevMY)
         If (distX<1)
            distX := 1
         If (distY<1)
            distY := 1

         maxDistuK := (distX>=distY) ? 1 : 2
         maxDistuV := (distX>=distY) ? distX : distY
         steps2cover := maxDistuV/stepu
         otherStepu := min(distX, distY)/steps2cover
         dirX := (kX>=prevMX) ? 1 : -1
         dirY := (kY>=prevMY) ? 1 : -1
         distStepX := (maxDistuK=1) ? stepu : otherStepu
         distStepY := (maxDistuK=2) ? stepu : otherStepu
         tkX := prevMX
         tkY := prevMY
         thisIndex++
         avgDistX := (distX + distStepX)//2
         avgDistY := (distY + distStepY)//2
         ; ToolTip, % "l=" distX "=" distY "||" dirX "=" dirY "||" distStepX "=" distStepY "||" steps2cover , , , 2
         Loop ; , % loops2do
         {
            ; loop interim brush steps
            Xgood := Ygood := 0
            zeitSillyPrevent := A_TickCount
            If (dirX=1)
            {
               smudgeX := clampInRange(avgDistX//2, 0, thisBulgePinchFactor)
               ; smudgeX := Ceil(thisBulgePinchFactor/2)
               tkX := clampInRange(tkX + distStepX, prevMX, kX)
               If (tkX>=kX)
                  Xgood := 1
            } Else
            {
               smudgeX := - clampInRange(avgDistX//2, 0, thisBulgePinchFactor)
               ; smudgeX := - Ceil(thisBulgePinchFactor/2)
               tkX := clampInRange(tkX - distStepX, kX, prevMX)
               If (tkX<=kX)
                  Xgood := 1
            }

            If (dirY=1)
            {
               smudgeY := clampInRange(avgDistY//2, 0, thisBulgePinchFactor)
               ; smudgeY := Ceil(thisBulgePinchFactor/2)
               tkY := clampInRange(tkY + distStepY, prevMY, kY)
               If (tkY>=kY)
                  Ygood := 1
            } Else
            {
               smudgeY := - clampInRange(avgDistY//2, 0, thisBulgePinchFactor)
               ; smudgeY := - Ceil(thisBulgePinchFactor/2)
               tkY := clampInRange(tkY - distStepY, kY, prevMY)
               If (tkY<=kY)
                  Ygood := 1
            }

            offX := oMx - tkX, offY := oMy - tkY
            ; [re]create dynamic brushes
            If (BrushToolType=6)
            {
               ; smudge brush
               brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, Round(tkX - brushSize/2 - smudgeX/2), Round(tkY - brushSize/2 - smudgeY/2), brushSize + thisBulgePinchFactor, brushSize + thisBulgePinchFactor, 0, 0, 1)
               QPV_SetBitmapAsAlphaChannel(brushImg, brushu, 0)
            } Else If (BrushToolType>=7)
            {
               ; pinch/bulge brush
               brushImg := Gdip_CloneBmpPargbArea(A_ThisFunc, metaBitmap, Round(tkX - brushSize/2), Round(tkY - brushSize/2), brushSize, brushSize, 0, 0, 1)
               QPV_SetBitmapAsAlphaChannel(brushImg, brushu, 0)
            } Else If (BrushToolType=5)
            {
               ; effects brush
               performClrEffectsBrush(metaBitmap, clonescu, tkX, tkY, brushSize, brushu, thisFloatOpacity, Gu)
               If (BrushToolSymmetryX=1 || BrushToolSymmetryY=1)
               {
                  calcBrushSymmetryCoords(tkX, tkY, imgW, imgH, skX, skY)
                  performClrEffectsBrush(metaBitmap, clonescu, skX, skY, brushSize, brushu, thisFloatOpacity, Gu)
                  If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
                  {
                     performClrEffectsBrush(metaBitmap, clonescu, tkX, skY, brushSize, brushu, thisFloatOpacity, Gu)
                     performClrEffectsBrush(metaBitmap, clonescu, skX, tkY, brushSize, brushu, thisFloatOpacity, Gu)
                  }
               }
            } Else If (BrushToolType=4)
            {
               ; eraser brush
               performEraserBrush(tkX, tkY, brushSize, brushu, thisEraseOpacity, thisEraserMode, metaBitmap, Gu, thisSelectionConstrain, ImgSelPath, clonescu)
               If (BrushToolSymmetryX=1 || BrushToolSymmetryY=1)
               {
                  calcBrushSymmetryCoords(tkX, tkY, imgW, imgH, skX, skY)
                  performEraserBrush(skX, skY, brushSize, brushu, thisEraseOpacity, thisEraserMode, metaBitmap, Gu, thisSelectionConstrain, ImgSelPath, clonescu)
                  If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
                  {
                     performEraserBrush(tkX, skY, brushSize, brushu, thisEraseOpacity, thisEraserMode, metaBitmap, Gu, thisSelectionConstrain, ImgSelPath, clonescu)
                     performEraserBrush(skX, tkY, brushSize, brushu, thisEraseOpacity, thisEraserMode, metaBitmap, Gu, thisSelectionConstrain, ImgSelPath, clonescu)
                  }
               }
            } Else If (advancedSoftBrush=1) ; BrushToolType=2
            {
               ; soft color brush with blending modes or air-brush off
               ofpx := tkX - brushSize/2
               ofpy := tkY - brushSize/2
               If (BrushToolWetness>0)
               {
                  coloruY := getPixelColorAvg(metaBitmap, tkX, tkY, "0xFF" o_startToolColor)
                  startToolColor := SubStr(MixARGB(coloruY, "0xFF" startToolColor, thisWet), 5)
                  g_startToolColor := RandomizeBrushColor(startToolColor)
                  overDraw := 1
               } Else
               {
                  g_startToolColor := RandomizeBrushColor(o_startToolColor)
                  overDraw := (BrushToolRandomDark>0 || BrushToolRandomLight>0 || BrushToolRandomSat>0 || BrushToolRandomHue>0) ? 1 : BrushToolOverDraw
               }

               QPV_ColourBrush(metaBitmap, brushu, 0, "0xFF" g_startToolColor, 0, thisMainOpacity, BrushToolBlendMode - 1, ofpx, ofpy, clonescu, opacityBMPmap, overDraw, BlendModesFlipped)
               If (BrushToolSymmetryX=1 || BrushToolSymmetryY=1)
               {
                  calcBrushSymmetryCoords(tkX, tkY, imgW, imgH, skX, skY)
                  sofpx := skX - brushSize/2
                  sofpy := skY - brushSize/2
                  QPV_ColourBrush(metaBitmap, brushu, 0, "0xFF" g_startToolColor, 0, thisMainOpacity, BrushToolBlendMode - 1, sofpx, sofpy, clonescu, opacityBMPmap, overDraw, BlendModesFlipped)
                  If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
                  {
                     QPV_ColourBrush(metaBitmap, brushu, 0, "0xFF" g_startToolColor, 0, thisMainOpacity, BrushToolBlendMode - 1, ofpx, sofpy, clonescu, opacityBMPmap, overDraw, BlendModesFlipped)
                     QPV_ColourBrush(metaBitmap, brushu, 0, "0xFF" g_startToolColor, 0, thisMainOpacity, BrushToolBlendMode - 1, sofpx, ofpy, clonescu, opacityBMPmap, overDraw, BlendModesFlipped)
                  }
               }
            } Else If (BrushToolDynamicCloner=1 && BrushToolType=3) ; dynamic cloner mode
            {
               brushu := trGdip_DisposeImage(brushu, 1)
               brushu := createClonedBrushBitmap(brushSize, 100.1 - thisToolSoftness, thisToolAngle, thisToolAspectRatio, clonescu, offX, offY, 1)
            } Else If (BrushToolWetness>0 && BrushToolType=2)
            {
               ; wet soft edges brush
               brushu := trGdip_DisposeImage(brushu, 1)
               coloruY := getPixelColorAvg(metaBitmap, kX, kY, "0xFF" o_startToolColor)
               startToolColor := SubStr(MixARGB(coloruY, "0xFF" startToolColor, thisWet), 5)
               g_startToolColor := RandomizeBrushColor(startToolColor)
               brushu := createGradientBrushBitmap(g_startToolColor, 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio)
            } Else If (BrushToolWetness>0 && BrushToolType=1)
            {
               ; wet simple brush
               Gdip_DeleteBrush(gdipbrushu)
               coloruY := getPixelColorAvg(metaBitmap, kX, kY, "0xFF" o_startToolColor)
               startToolColor := SubStr(MixARGB(coloruY, "0xFF" startToolColor, thisWet), 5)
               thisHexOpacity := Format("{1:#x}", thisOpacity)
               g_startToolColor := RandomizeBrushColor(startToolColor)
               gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity g_startToolColor)
            }

            ; draw the brushes into main image [ metaBitmap - Gu ]
            If (BrushToolType=1)
            {
               ; draw simple brush
               allowBrushOverDraw := (BrushToolSymmetryX=1 && BrushToolSymmetryY=1) ? 1 : BrushToolOverDraw
               tmpPath := createBrushShapePath(brushSize, tkX, tkY, thisToolAspectRatio, thisToolAngle)
               Gdip_FillPath(Gu, gdipbrushu, tmpPath)
               If (allowBrushOverDraw=0)
                  Gdip_SetClipPath(Gu, tmpPath, 4)

               Gdip_DeletePath(tmpPath)
               If (BrushToolSymmetryX=1 || BrushToolSymmetryY=1)
               {
                  calcBrushSymmetryCoords(tkX, tkY, imgW, imgH, skX, skY)
                  tmpPath := createBrushShapePath(brushSize, skX, skY, thisToolAspectRatio, thisToolAngle)
                  Gdip_FillPath(Gu, gdipbrushu, tmpPath)
                  If (allowBrushOverDraw=0)
                      Gdip_SetClipPath(Gu, tmpPath, 4)

                  Gdip_DeletePath(tmpPath)
                  If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
                  {
                     tmpPath := createBrushShapePath(brushSize, tkX, skY, thisToolAspectRatio, thisToolAngle)
                     Gdip_FillPath(Gu, gdipbrushu, tmpPath)
                     Gdip_DeletePath(tmpPath)
                     tmpPath := createBrushShapePath(brushSize, skX, tkY, thisToolAspectRatio, thisToolAngle)
                     Gdip_FillPath(Gu, gdipbrushu, tmpPath)
                     Gdip_DeletePath(tmpPath)
                  }
               }
            } Else If (BrushToolType=4)
            {
               Sleep, -1
            } Else
            {
               ; draw any «generic» brush
               thisBrushu := (BrushToolType>5) ? brushImg : brushu
               thisFloatOpacity := thisOpacity/255
               If (BrushToolType>=7)
               {
                  ; pinch/bulge brushes
                  tzGdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2 - thisBulgePinchFactor, tkY - brushSize//2 - thisBulgePinchFactor, brushSize + thisBulgePinchFactor*2, brushSize + thisBulgePinchFactor*2, 0, 0, brushSize, brushSize, thisFloatOpacity)
                  If (thisBulgePinchFactor>3 && BrushToolType=8 && BrushToolDynamicCloner=1)
                     tzGdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2 - thisBulgePinchFactor//2, tkY - brushSize/2 - thisBulgePinchFactor/2, brushSize + thisBulgePinchFactor, brushSize + thisBulgePinchFactor, 0, 0, brushSize, brushSize, thisFloatOpacity)
               } Else If (advancedSoftBrush!=1 && BrushToolType!=5)
                  tzGdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)

               If ((BrushToolSymmetryX=1 || BrushToolSymmetryY=1) && (BrushToolType=2 && advancedSoftBrush!=1 || BrushToolType=3))
               {
                  calcBrushSymmetryCoords(tkX, tkY, imgW, imgH, skX, skY)
                  imgOp := (BrushToolSymmetryX=1) ? 4 : 0
                  If (BrushToolSymmetryX=0 && BrushToolSymmetryY=1)
                     imgOp := 6
                  If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
                     imgOp := 2
                  If (BrushToolDynamicCloner=1 && BrushToolType=3)
                     Gdip_ImageRotateFlip(thisBrushu, imgOp)

                  tzGdip_DrawImage(Gu, thisBrushu, skX - brushSize//2, skY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
                  If (BrushToolSymmetryX=1 && BrushToolSymmetryY=1)
                  {
                     If (BrushToolDynamicCloner=1 && BrushToolType=3)
                        Gdip_ImageRotateFlip(thisBrushu, 4)

                     tzGdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2, skY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
                     If (BrushToolDynamicCloner=1 && BrushToolType=3)
                        Gdip_ImageRotateFlip(thisBrushu, 2)
                     tzGdip_DrawImage(Gu, thisBrushu, skX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
                  }
               }

               If (BrushToolType>5)
                  brushImg := trGdip_DisposeImage(brushImg, 1)

               If (BrushToolType>=6 && BrushToolOverDraw=1)
               {
                  ; smudge/pinch/bulge brushes
                  f := (BrushToolType=7) ? BrushToolWetness*2 + 2 : BrushToolWetness + 2
                  If (BrushToolType=6)
                     f := BrushToolWetness//2 + 2
                  brushSize -= f
                  If (brushSize>2)
                  {
                     If (BrushToolType=6)
                        brusha := trGdip_ResizeBitmap(A_ThisFunc, brushu, brushSize + thisBulgePinchFactor, brushSize + thisBulgePinchFactor, 0, 3)
                     Else
                        brusha := trGdip_ResizeBitmap(A_ThisFunc, brushu, brushSize, brushSize, 0, 3)
                     brushu := trGdip_DisposeImage(brushu, 1)
                     brushu := brusha
                  }
               }
            }

            ; tzGdip_DrawImageFast(Gu, brushu[1], tkX - brushToolSize//2, tkY - brushToolSize//2)
            If (BrushToolDryingRate>0) && (A_TickCount - dryZeit>dryRateZeit)
            {
               dryZeit := A_TickCount
               thisOpacity -= thisDryRate
               If (BrushToolType=1)
               {
                  Gdip_DeleteBrush(gdipbrushu)
                  thisHexOpacity := Format("{1:#x}", Round(thisOpacity))
                  gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)
               } Else If (advancedSoftBrush=1 || BrushToolType=4 || BrushToolType=5)
               {
                  brushu := trGdip_DisposeImage(brushu, 1)
                  thisHexOpacity := Format("{1:#x}", Round(thisOpacity))
                  brushu := createGradientBrushBitmap("ffFFff", 101 - thisToolSoftness, brushSize, thisToolAngle, thisToolAspectRatio, thisHexOpacity, "0xff000000")
               }
            }
            thisZeit := A_TickCount
            ; ToolTip, % A_TickCount - thisZeit , , , 2
            If (Xgood=1 && Ygood=1 && A_index>1 || stepu<=1 && BrushToolType>5 || brushToolStepping=0 && brushSize>1 || BrushToolType>=7 || brushSize<1 || thisOpacity<0.005)
               Break
         }
         prevState := thisState
         prevMX := kX, prevMY := kY
         zeitSillyPrevent := A_TickCount
         If (thisIndex=1)
            oMx := tkX, oMy := tkY

         dummyResizeImageGDIwin()
      }
   }

   If (advancedSoftBrush=1 && opacityBMPmap)
   {
      ; tzGdip_DrawImageFast(2NDglPG, opacityBMPmap, 20, 20)
      ; r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
      ; Sleep, 2000
      trGdip_DisposeImage(opacityBMPmap)
   }

   setWhileLoopExec(0)
   Gdip_DeleteGraphics(Gu)
   If validBMP(brushu)
      trGdip_DisposeImage(brushu, 1)
   If validBMP(brushImg)
      trGdip_DisposeImage(brushImg, 1)
   If validBMP(clonescu)
      trGdip_DisposeImage(clonescu, 1)
   If gdipbrushu
      Gdip_DeleteBrush(gdipbrushu)

   MouseMoveResponder()
   If (((A_TickCount - lastInvoked>350) || preventUndoLevels=1) && validBMP(metaBitmap))
   {
      UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
      UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, metaBitmap)
      recordUndoLevelNow(0, metaBitmap)
   }

   ; liveDrawingBrushTool := 0
   If (thisIndex>10 || lastWasLowQuality=1)
      SetTimer, wrapResizeImageGDIwin, -60
   SetTimer, ResetImgLoadStatus, -100
   lastInvoked := A_TickCount
} ; // ActPaintBrushNow()

ActDrawAlphaMaskBrushNow() {
   Critical, on
   Static lastInvoked := 1, prevMX, prevMY, countClicks

   trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (!imgW || !imgH)
   {
      addJournalEntry("ERROR: main bitmap seems inexistent. Failure occured in " A_ThisFunc "()")
      Return
   }

   If (A_TickCount - lastOtherWinClose<450)
      Return

   vpWinClientSize(mainWidth, mainHeight)
   GetMouseCoord2wind(PVhwnd, mX, mY)
   mX := (FlipImgH=1) ? mainWidth - mX : mX
   mY := (FlipImgV=1) ? mainHeight - mY : mY
   imgPath := getIDimage(currentFileIndex)
   thisZeit := A_TickCount - 100
   thisIndex := 0
   Random, randomFactor, -950, 950
   prevState := "a"
   liveDrawingBrushTool := 1
   whichBitmap := userAlphaMaskBmpPainted
   If !validBMP(whichBitmap)
   {
      addJournalEntry("ERROR: no alpha mask bitmap. Failure occured in " A_ThisFunc "()")
      Return
   }

   trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
   o_startToolColor := startToolColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   thisMainOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisHexOpacity := Format("{1:#x}", thisMainOpacity)
   pDPX := viewportDynamicOBJcoords.x,     pDPY := viewportDynamicOBJcoords.y
   pVPimgW := viewportDynamicOBJcoords.w,  pVPimgH := viewportDynamicOBJcoords.h
   MouseCoords2Image(mX, mY, 0, pDPX, pDPY, pVPimgW, pVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
   oMx := kX, oMy := kY
   brushSize := (BrushToolDoubleSize=1) ? brushToolSize*2 : brushToolSize
   arVP := Round(pVPimgW / pVPimgH, 2)
   arImg := Round(imgW / imgH, 2)

   ; create base brush element / bitmap
   If (BrushToolType>1) ; soft edges
   {
      brushu := createGradientBrushBitmap(startToolColor, 101 - BrushToolSoftness, brushSize, BrushToolAngle + 180, BrushToolAspectRatio)
      If (arVP!=arImg)
      {
         scfX := Round(brushSize * (imgW / pVPimgW))
         scfY := Round(brushSize * (imgH / pVPimgH))
         brushu := resizeBitmapToGivenRef(brushu, 0, scfX, scfY, 5, 0)
         brushSize := max(scfX, scfY)
         abrush := trGdip_CreateBitmap(A_ThisFunc, brushSize, brushSize)
         If validBMP(abrush)
         {
            pGU := Gdip_GraphicsFromImage(abrush)
            Gdip_GraphicsClear(pGU, "0xFF" Gdip_GetPixelColor(brushu, 1, 1, 4))
            ppx := Round(brushSize/2 - scfX/2)
            ppy := Round(brushSize/2 - scfY/2)
            Gdip_DrawImage(pGU, brushu, ppx, ppy, scfX, scfY)
            Gdip_DeleteGraphics(pGU)
            trGdip_DisposeImage(brushu)
            brushu := abrush
         }
         ; ToolTip, % arVP "|" arImg "`n" scfX "|" scfY "|" brushSize , , , 2
      }
   } Else
   {
      ; simple solid
      gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)
      objuAR := []
      objuAR.arVP := arVP
      objuAR.arImg := arImg
      objuAR.imgW := imgW
      objuAR.imgH := imgH
      objuAR.pVPimgW := pVPimgW
      objuAR.pVPimgH := pVPimgH
   }

   If (!validBMP(brushu) && BrushToolType>1)
   {
      addJournalEntry("ERROR: no brush image. Failure occured in " A_ThisFunc "()")
      Return
   }

   imgIndexEditing := currentFileIndex
   thisQuality := (BrushToolType>5) ? 7 : 5
   Gu := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, thisQuality)
   If !Gu
   {
      trGdip_DisposeImage(brushu, 1)
      If gdipbrushu
         Gdip_DeleteBrush(gdipbrushu)
      addJournalEntry("ERROR: failed to create graphics object on " whichBitmap ". Failure occured in " A_ThisFunc "()")
      Return
   }

   Gdip_SetPixelOffsetMode(Gu, 2)
   thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
   thisEraseOpacity := thisOpacity
   thisEraserMode := (BrushToolOverDraw=1) ? 2 : 1
   If (BrushToolEraserRestore=1)
      thisEraserMode := 3

   thisEraseOpacity := (thisEraserMode=1) ? 255 - thisEraseOpacity : thisEraseOpacity
   thisWet := 0.79 + (21 - thisWetness)/100
   Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
   r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
   If ((A_TickCount - lastInvoked>250) && preventUndoLevels!=1)
   {
      trGdip_DisposeImage(userPrevAlphaMaskBmpPainted, 1)
      userPrevAlphaMaskBmpPainted := trGdip_CloneBitmap(A_ThisFunc, userAlphaMaskBmpPainted)
   }

   dryZeit := A_TickCount
   dryRateZeit := 300 - BrushToolDryingRate**2
   thisDryRate := clampInRange(BrushToolDryingRate/4, 1, 20)
   isUserStepu := (brushToolStepping=1 || brushToolStepping=2 || brushToolStepping=251) ? 0 : 1
   stepu := (isUserStepu=0) ? Ceil(brushSize * 0.2)**1.09 : brushToolStepping
   If (BrushToolType>6 || BrushToolType=5) && (isUserStepu=1 && stepu<brushSize/4 && isInRange(BrushToolAspectRatio, -5, 5) && isInRange(BrushToolAngle + 180, 0, 5))
      stepu := brushSize//4 + 1

   If (!stepu || BrushToolType>=7 || brushToolStepping=0)
      stepu := 1

   If !GetKeyState("Shift", "P")
      prevMX := prevMY := 0

   offX := offY := 0
   setWhileLoopExec(1)
   While, (determineLClickState()=1 || A_Index<2)
   {
      If (thisOpacity<0.005 || brushSize<2)
         Break
      
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := (FlipImgH=1) ? mainWidth - mX : mX
      mY := (FlipImgV=1) ? mainHeight - mY : mY
      MouseCoords2Image(mX, mY, 0, pDPX, pDPY, pVPimgW, pVPimgH, kX, kY, whichBitmap, 1, imgW, imgH)
      ; ToolTip, % offX "-" offY "`n" kX "-" kY "`n" oMx "-" oMy , , , 2
      If isDotInRect(kX, kY, prevMX - stepu, prevMX + stepu, prevMY - stepu, prevMY + stepu)
      || !isDotInRect(kX, kY, 0 - brushSize//2, imgW + brushSize//2, 0 - brushSize//2, imgH + brushSize//2)
         Continue

      thisState := "a" mX mY kX kY randomFactor
      ; ToolTip, % thisState , , , 2
      Sleep, 2
      If (prevState!=thisState && (A_TickCount - thisZeit>5))
      {
         ; calculate coords for the brush
         If !prevMX
            prevMX := kX 
         If !prevMY
            prevMY := kY
         distX := Abs(kX - prevMX) ; max(kX, prevMX) - min(kX, prevMX)
         distY := Abs(kY - prevMY) ; max(kY, prevMY) - min(kX, prevMY)
         maxDistuK := (distX>=distY) ? 1 : 2
         maxDistuV := (distX>=distY) ? distX : distY
         steps2cover := maxDistuV/stepu
         otherStepu := min(distX, distY)/steps2cover
         dirX := (kX>=prevMX) ? 1 : -1
         dirY := (kY>=prevMY) ? 1 : -1
         distStepX := (maxDistuK=1) ? stepu : otherStepu
         distStepY := (maxDistuK=2) ? stepu : otherStepu
         tkX := prevMX
         tkY := prevMY
         thisIndex++
         avgDistX := (distX + distStepX)//2
         avgDistY := (distY + distStepY)//2
         ; ToolTip, % "l=" distX "=" distY "||" dirX "=" dirY "||" distStepX "=" distStepY "||" steps2cover , , , 2
         Loop ; , % loops2do
         {
            ; loop interim brush steps
            Xgood := Ygood := 0
            zeitSillyPrevent := A_TickCount
            If (dirX=1)
            {
               tkX := clampInRange(tkX + distStepX, prevMX, kX)
               If (tkX>=kX)
                  Xgood := 1
            } Else
            {
               tkX := clampInRange(tkX - distStepX, kX, prevMX)
               If (tkX<=kX)
                  Xgood := 1
            }

            If (dirY=1)
            {
               tkY := clampInRange(tkY + distStepY, prevMY, kY)
               If (tkY>=kY)
                  Ygood := 1
            } Else
            {
               tkY := clampInRange(tkY - distStepY, kY, prevMY)
               If (tkY<=kY)
                  Ygood := 1
            }

            offX := oMx - tkX, offY := oMy - tkY
            ; draw the brushes into main image [ whichBitmap - Gu ]
            If (BrushToolType=1)
            {
               ; draw simple brush
               tmpPath := createBrushShapePath(brushSize, tkX, tkY, BrushToolAspectRatio, BrushToolAngle + 180, objuAR)
               Gdip_FillPath(Gu, gdipbrushu, tmpPath)
               If (BrushToolOverDraw=0)
                  Gdip_SetClipPath(Gu, tmpPath, 4)
               Gdip_DeletePath(tmpPath)
            } Else
            {
               ; draw any «generic» brush
               thisBrushu := (BrushToolType>=5) ? brushImg : brushu
               thisFloatOpacity := thisOpacity/255
               tzGdip_DrawImage(Gu, thisBrushu, tkX - brushSize//2, tkY - brushSize//2, brushSize, brushSize, 0, 0, brushSize, brushSize, thisFloatOpacity)
            }

            ; tzGdip_DrawImageFast(Gu, brushu[1], tkX - brushToolSize//2, tkY - brushToolSize//2)
            If (BrushToolDryingRate>0) && (A_TickCount - dryZeit>dryRateZeit)
            {
               dryZeit := A_TickCount
               thisOpacity -= thisDryRate
               If (BrushToolType=1)
               {
                  Gdip_DeleteBrush(gdipbrushu)
                  thisHexOpacity := Format("{1:#x}", thisOpacity)
                  gdipbrushu := Gdip_BrushCreateSolid(thisHexOpacity startToolColor)
               }
            }
            thisZeit := A_TickCount
            ; ToolTip, % A_TickCount - thisZeit , , , 2
            If (Xgood=1 && Ygood=1 && A_index>1 || brushToolStepping=0 || brushSize<2 || thisOpacity<0.005)
               Break
         }
         prevState := thisState
         prevMX := kX, prevMY := kY
         zeitSillyPrevent := A_TickCount
         brushZeitung := A_TickCount randomFactor kX kY
         If (thisIndex=1)
            oMx := tkX, oMy := tkY

         corelivePreviewsImageEditing()
      }
   }

   setWhileLoopExec(0)
   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(brushu, 1)
   If gdipbrushu
      Gdip_DeleteBrush(gdipbrushu)

   MouseMoveResponder()
   ; liveDrawingBrushTool := 0
   SetTimer, ResetImgLoadStatus, -100
   lastInvoked := A_TickCount
}

drawVPgridsNow(mW, mH, Gu) {
   Static penGrid, penGridL, lastPenState, miniPath, maxiPath, prevPathsState
   thisGridThickness := vpGridThickness + imgHUDbaseUnit//30
   thisPen := thisGridThickness vpGridColor vpGridAlpha
   If (thisPen!=lastPenState)
   {
      If penGrid
         Gdip_DeletePen(penGrid)
      If penGridL
         Gdip_DeletePen(penGridL)

      thisColor := makeRGBAcolor(vpGridColor, vpGridAlpha)
      penGrid := Gdip_CreatePen(thisColor , thisGridThickness)

      thisColor := SubStr(MixARGB("0xFF998899", "0xFF" vpGridColor, 0.85), 5)
      thisColor := makeRGBAcolor(thisColor, clampInRange(vpGridAlpha + 25, 1, 255))
      penGridL := Gdip_CreatePen(thisColor, Round(thisGridThickness*1.65))
   }

   dS := (vpGridFixedSize=1) ? vpGridSize : Ceil(vpGridSize/1.5 + (vpGridSize/5)*zoomLevel + (imgHUDbaseUnit/25)*zoomLevel)
   If (zoomLevel<0.5 && vpGridSize<15 && vpGridFixedSize=0)
      dS := dS*2
   Else If (zoomLevel>10 && vpGridFixedSize=0)
      dS := dS//2
   Else If (zoomLevel>5 && vpGridFixedSize=0)
      dS := dS//1.5

   loops := 0
   prevDPx := clampInRange(prevDestPosX, 0, mW)
   prevDPy := clampInRange(prevDestPosY, 0, mH)
   MaxLimX := (LimitSelectBoundsImg=1) ? prevDestPosX + prevResizedVPimgW : mW
   MaxLimY := (LimitSelectBoundsImg=1) ? prevDestPosY + prevResizedVPimgH : mH
   MinLimX := (LimitSelectBoundsImg=1) ? prevDPx : 0
   MinLimY := (LimitSelectBoundsImg=1) ? prevDPy : 0
   dX := (LimitSelectBoundsImg=1) ? prevDPx : 0
   dY := (LimitSelectBoundsImg=1) ? prevDPy : 0
   mW := clampInRange(dX + mW, MinLimX, MaxLimX)
   mH := clampInRange(dY + mH, MinLimY, MaxLimY)
   thisPathsState := "a" dS vpGridStepu imageAligned vpGridFixedSize mW mH prevDPx prevDPy LimitSelectBoundsImg
   If (prevPathsState!=thisPathsState)
   {
      If miniPath
         Gdip_DeletePath(miniPath)
      If maxiPath
         Gdip_DeletePath(maxiPath)

      prevPathsState := thisPathsState
      miniPath := Gdip_CreatePath()
      maxiPath := Gdip_CreatePath()
      Loop
      {
         dX += dS
         If (dX>mW)
            Break
     
         loops++
         If (loops=vpGridStepu)
         {
            Gdip_StartPathFigure(maxiPath)
            Gdip_AddPathLine(maxiPath, dX, dY, dX, mH)
            loops := 0
         } Else
         {
            Gdip_StartPathFigure(miniPath)
            Gdip_AddPathLine(miniPath, dX, dY, dX, mH)
         }
      }

      ; ToolTip, % mW "==" dS "==" thisThick "==" loops    , , , 2
      dX := (LimitSelectBoundsImg=1) ? prevDPx : 0
      loops := prevu := 0
      Loop
      {
         dY += dS
         If (dY>mH)
            Break
     
         loops++
         If (loops=vpGridStepu)
         {
            Gdip_StartPathFigure(maxiPath)
            Gdip_AddPathLine(maxiPath, dX, dY, mW, dY)
            loops := 0
         } Else
         {
            Gdip_StartPathFigure(miniPath)
            Gdip_AddPathLine(miniPath, dX, dY, mW, dY)
         }
      }
      Gdip_ClosePathFigures(miniPath)
      Gdip_ClosePathFigures(maxiPath)
   }

   Gdip_DrawPath(Gu, penGrid, miniPath)
   Gdip_DrawPath(Gu, penGridL, maxiPath)
}

drawHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath) {
    Static prevImgPath, lastInvoked := 1
    If (preventHUDelements=1)
    {
       preventHUDelements := 0
       Return
    }

    pBrush := (mode=2) ? pBrushB : pBrushA
    indicWidth := 150
    lineThickns := imgHUDbaseUnit
    lineThickns2 := lineThickns//4
    If (showHistogram>1 && drawingShapeNow!=1 && mode!=2)
    {
       thisImgCall := imgPath currentFileIndex zoomLevel IMGresizingMode imgFxMode showHistogram gdiBitmap undoLevelsRecorded currentUndoLevel UserMemBMP OSDfontSize histogramMode
       thisSizingModes := isVarEqualTo(IMGresizingMode, 1, 2, 5) || (IMGresizingMode=4 && IMGlargerViewPort!=1) ? 1 : 0
       If (imgFxMode!=1 || thisSizingModes!=1 || animGIFplaying=1 || desiredFrameIndex>0 || viewportQPVimage.imgHandle)
       {
          prevImgPath := 0
          thisPosX := (DestPosX<0) ? 0 : DestPosX
          thisPosY := (DestPosY<0) ? 0 : DestPosY
          thisW := (newW>mainWidth) ? mainWidth : newW
          thisH := (newH>mainHeight) ? mainHeight : newH
          If (thisPosX + thisW>mainWidth)
             thisW := mainWidth - thisPosX
          If (thisPosY + thisH>mainHeight)
             thisH := mainHeight - thisPosY

          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          If (thisW>4 && thisH>4)
             tempBMP := trGdip_CreateBitmapFromHBITMAP(A_ThisFunc, glHbitmap)

          ; ToolTip, % thisPosX "==" thisPosY "`n" thisW "==" thisH , , , 2
          If validBMP(tempBMP)
          {
             thisVPimg := Gdip_CloneBmpPargbArea(A_ThisFunc, tempBMP, thisPosX + 1, thisPosY + 1, thisW - 2, thisH - 2)
             createHistogramBMP(thisVPimg)
             trGdip_DisposeImage(thisVPimg, 1)
             trGdip_DisposeImage(tempBMP, 1)
          }
       } Else If (prevImgPath!=thisImgCall) && (A_TickCount - lastInvoked>50)
       {
          lastInvoked := A_TickCount
          prevImgPath := thisImgCall
          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          If validBMP(gdiBitmap)
             createHistogramBMP(gdiBitmap)
       }
    } Else 
    {
       prevImgCall := 0
       interfaceThread.ahkPostFunction("uiAccessUpdateHistoBox", "hide", 1, 1, 0, 0)
    }

    Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
    If (showViewPortGrid=1 && slideShowRunning!=1 && imgEditPanelOpened!=1)
       drawVPgridsNow(mainWidth, mainHeight, glPG)

    If (mode=2 && IMGresizingMode=4 && IMGlargerViewPort=1 && slideShowRunning!=1)
    {
       ; highlight action areas
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//10
       Gdip_SetPenWidth(pPen1d, thisThick)
       Gdip_DrawRectangle(glPG, pPen1d, thisX, thisY, thisW, thisH)
    } Else If (mode=1 && slideShowRunning!=1)
    {
       ; highlight action areas
       thisThick := imgHUDbaseUnit//11
       If (showSelectionGrid=1 || imgSelLargerViewPort=1 || IMGlargerViewPort=1) && (editingSelectionNow=1)
       {
          Gdip_SetPenWidth(pPen4, thisThick)
          thisu := clampValuesToWindow(DestPosX, DestPosY, newW//2, newH, mainWidth, mainHeight)
          Gdip_DrawRectangle(glPG, pPen4, thisu.X, thisu.Y, thisu.W, thisu.H)
          thisu := clampValuesToWindow(DestPosX, DestPosY + newH//2, newW, newH//2 + thisThick*2, mainWidth, mainHeight)
          Gdip_DrawRectangle(glPG, pPen4, thisu.X, thisu.Y, thisu.W, thisu.H)
          thisu := clampValuesToWindow(DestPosX, DestPosY, newW, newH + thisThick*2, mainWidth, mainHeight)
          Gdip_DrawRectangle(glPG, pPen4, thisu.X, thisu.Y, thisu.W, thisu.H)
       }

       If (IMGentirelylargerThanVP=0)
       {
          If (borderAroundImage=1) || (editingSelectionNow=1 && LimitSelectBoundsImg=1)
             Gdip_DrawRectangle(glPG, pPen4, DestPosX - thisThick//2, DestPosY - thisThick//2, newW + thisThick, newH + thisThick)
       }
    }

; visual markers for image viewing conditions

    If (markedSelectFile || FlipImgV=1 || FlipImgH=1 || IMGlargerViewPort=1 || imgFxMode>1) && (slideShowRunning!=1)
    {
       If (FlipImgH=1 && mode=2)
          Gdip_FillRoundedRectanglePath(glPG, pBrush, mainWidth//2 - indicWidth//2, mainHeight//2 - lineThickns2//2, indicWidth, lineThickns2, lineThickns2//2)
       If (FlipImgV=1 && mode=2)
          Gdip_FillRoundedRectanglePath(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//2, lineThickns2, indicWidth, lineThickns2//2)

       If (imgFxMode>1 && mode=2)
       {
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//4, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2, 0, 180)
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//8, mainHeight//2 - indicWidth//8, indicWidth//4, indicWidth//4, 180, 360)
       }

       If (markedSelectFile && imgEditPanelOpened!=1)
       {
          sqSize := lineThickns ; (mode=2) ? lineThickns + lineThickns2 : lineThickns
          sqPosX := mainWidth - sqSize
          Gdip_FillRectangle(glPG, pBrush, sqPosX, 0, sqSize, sqSize)
          thisThick := lineThickns//9
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen1d, sqPosX, 0, sqSize, sqSize)
       }

       If resultedFilesList[currentFileIndex, 2] ; file is selected
       {
          thisThick := lineThickns//4.2 ; (mode=2) ? lineThickns//2.5 : lineThickns//4.2
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen3, 0, 0, mainWidth, mainHeight)
          Gdip_DrawRectangle(glPG, pPen1d, 0, 0, mainWidth, mainHeight)
       }
    }

; highlight usePrevious=1 mode

    lineThickns := (mode=2) ? imgHUDbaseUnit//10 : imgHUDbaseUnit//9
    If (mode=2 && imgFxMode=1)
    {
       indicWidth := (zoomLevel<1) ? Round(120 * zoomLevel) : 110
       If (indicWidth<50)
          indicWidth := 50
       Gdip_SetPenWidth(pPen2, lineThickns)
       Gdip_FillRectangle(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
       Gdip_DrawRectangle(glPG, pPen2, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
    }

; draw the scrollbar indicators
    calculateScrollBars(newW, newH, DestPosX, DestPosY, mainWidth, mainHeight, knobW, knobH, knobX, knobY)
    knobSize := getScrollWidth()
    If (knobW<mainWidth - 5) && (IMGresizingMode=4 && slideShowRunning!=1)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, knobX, 0, knobW, knobSize)
       scrollBarHy := (FlipImgV=1) ? 0 : mainHeight - knobSize
       Gdip_FillRectangle(glPG, pBrushE, 0, scrollBarHy, mainWidth, knobSize)
       Gdip_FillRectangle(glPG, pBrushD, knobX, scrollBarHy + 1, knobW, knobSize)
       If (vpImgPanningNow>0)
          Gdip_FillRectangle(glPG, pBrushE, knobX, scrollBarHy + 1, knobW, knobSize)
       scrollBarHy := knobSize
    } Else scrollBarHy := 0

    If (knobH<mainHeight - 5) && (IMGresizingMode=4 && slideShowRunning!=1)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, 0, knobY, knobSize, knobH)
       scrollBarVx := (FlipImgH=1) ? 0 : mainWidth - knobSize
       Gdip_FillRectangle(glPG, pBrushE, scrollBarVx, 0, knobSize, mainHeight)
       Gdip_FillRectangle(glPG, pBrushD, scrollBarVx + 1, knobY, knobSize, knobH)
       If (vpImgPanningNow>0)
          Gdip_FillRectangle(glPG, pBrushE, scrollBarVx + 1, knobY, knobSize, knobH)
       scrollBarVx := knobSize
    } Else scrollBarVx := 0

; highlight number of frames and the current frame in multi-frame images [tiff and gif]
    If (totalFramesIndex>0)
    {
       bulletSize := imgHUDbaseUnit//3
       totalBulletsWidth := bulletSize * totalFramesIndex
       If (totalBulletsWidth>mainWidth)
          bulletsPerc := Round(desiredFrameIndex/totalFramesIndex, 3)
       maxBullets := Round(mainWidth/bulletSize)
       centerPos := bulletsPerc ? 0 : mainWidth//2 - totalBulletsWidth//2
       If (centerPos<0)
          centerPos := 0

       Loop, % totalFramesIndex + 1
       {
           If bulletsPerc
              whichBrush := (A_Index/maxBullets<bulletsPerc) || (desiredFrameIndex=totalFramesIndex) ? pBrushA : pBrushE
           Else
              whichBrush := (A_Index - 1 <= desiredFrameIndex) ? pBrushA : pBrushE

           Gdip_FillEllipse(glPG, whichBrush, centerPos + bulletSize * (A_Index - 1), mainHeight - bulletSize - Round(scrollBarHy) - 2, bulletSize, bulletSize)
           If (A_index>maxBullets)
              Break
       }
    }

    If (adjustNowSel=1)
       Return

    If (showHistogram>1 && validBMP(HistogramBMP) && mode!=2)
    { 
       tlbrBonusX := tlbrBonusY := 0
       trGdip_GetImageDimensions(HistogramBMP, imgW, imgH)
       thisPosX := (FlipImgH=0 && scrollBarVx>0) ? mainWidth - scrollBarVx - imgW - tlbrBonusX : mainWidth - imgW - tlbrBonusX
       thisPosY := (FlipImgV=0 && scrollBarHy>0) ? mainHeight - scrollBarHy - imgH - tlbrBonusY : mainHeight - imgH - tlbrBonusY
       If (FlipImgH=1 || FlipImgV=1)
       {
          tempBMP := trGdip_CloneBitmap(A_ThisFunc, HistogramBMP)
          flipBitmapAccordingToViewPort(tempBMP, 1)
          E := trGdip_DrawImage(A_ThisFunc, glPG, tempBMP, thisPosX, thisPosY)
          trGdip_DisposeImage(tempBMP, 1)
       } Else E := trGdip_DrawImage(A_ThisFunc, glPG, HistogramBMP, thisPosX, thisPosY,,,,,,, 0.9)

       hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
       tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
       tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
       If (FlipImgH=1)
          thisPosX := tlbrBonusX
       Else
          thisPosX += tlbrBonusX

       If (FlipImgV=1)
          thisPosY := tlbrBonusY
       Else
          thisPosY += tlbrBonusY

       HUDobjHistoBoxu[1] := imgW, HUDobjHistoBoxu[2] := imgH
       HUDobjHistoBoxu[3] := thisPosX - tlbrBonusX
       HUDobjHistoBoxu[4] := thisPosY - tlbrBonusY
       hasDrawnHistoMap := (E="fail") ? 0 : 1
       thisString := (prevHistoBoxString && hasDrawnHistoMap=1) ? prevHistoBoxString : "hide"
       interfaceThread.ahkPostFunction("uiAccessUpdateHistoBox", thisString, imgW, imgH, thisPosX, thisPosY)
    } Else 
    {
       hasDrawnHistoMap := 0
       interfaceThread.ahkPostFunction("uiAccessUpdateHistoBox", "hide", 0, 0, 0, 0)
    }

    additionalHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, 1)
}

calculateScrollBars(newW, newH, DestPosX, DestPosY, mainWidth, mainHeight, ByRef knobW, ByRef knobH, ByRef knobX, ByRef knobY) {
   If (allowFreeIMGpanning=1 && IMGresizingMode=4)
   {
       totalW := (newW>mainWidth) ? newW*3 : newW + mainWidth
       totalH := (newH>mainHeight) ? newH*3 : newH + mainHeight
       ; ToolTip, % totalW "|" newW "|" mainWidth , , , 2
       prcVisX := mainWidth/totalW
       prcVisY := mainHeight/totalH
       knobW := mainWidth*prcVisX
       knobH := mainHeight*prcVisY
       Ax := 1 - (DestPosX + newW) / (newW + mainWidth)
       Ay := 1 - (DestPosY + newH) / (newH + mainHeight)
       ; Ax := 1 - (DestPosX + newW) / (newW + mainWidth)
       ; Ay := 1 - (DestPosY + newH) / (newH + mainHeight)
       knobX := Round(Ax*(mainWidth - knobW))
       knobY := Round(Ay*(mainHeight - knobH)) 
       knobW := Round(knobW)
       knobH := Round(knobH)
       ; ToolTip, % Ay "`n" knobY "`n" totalH "`n" DestPosY "`n" newH  , , , 2
   } Else
   {
       prcVisX := mainWidth/newW
       prcVisY := mainHeight/newH
       knobW := Round(mainWidth*prcVisX)
       knobH := Round(mainHeight*prcVisY)
       Ax := (DestPosX<0) ? Abs(DestPosX)/newW : 0
       Ax := Round(Ax*newW)
       Ay := (DestPosY<0) ? Abs(DestPosY)/newH : 0
       Ay := Round(Ay*newH)
       knobX := Round((Ax/newW)*mainWidth)
       knobY := Round((Ay/newH)*mainHeight) 
   }

   If (knobH<15)
      knobH := 15
   If (knobW<15)
      knobW := 15
}

snapPointsAtAngles(gmX, gmY, dulaX, dulaY, ByRef guX, ByRef guY) {
; dulaX, dulaY     = coords of the fixed point [P1]
; gmX, gmY         = coords of the 2nd point [P2], the point to be placed at 90/45/0°

    guY  := gmY,          guX := gmX
    zY   := Abs(gmY),      zX := Abs(gmX)
    wY   := Abs(dulaY),    wX := Abs(dulaX)
    maxX := max(zX, wX), maxY := max(zY, wY)
    minX := min(zX, wX), minY := min(zY, wY)
    lenX := maxX - minX
    lenY := maxY - minY
    lenAvg := (lenX + lenY)//2
    thisAngle := getAngleBetweenTwoPoints(gmX, gmY, dulaX, dulaY, 2)
    ; ToolTip, % thisAngle , , , 2
    If isInRange(thisAngle, 30, 60)
    {
       guX := dulaX + lenAvg
       guY := dulaY - lenAvg
    } Else If isInRange(thisAngle, 120, 150)
    {
       guX := dulaX - lenAvg
       guY := dulaY - lenAvg
    } Else If isInRange(thisAngle, 210, 240)
    {
       guX := dulaX - lenAvg
       guY := dulaY + lenAvg
    } Else If isInRange(thisAngle, 300, 330)
    {
       guX := dulaX + lenAvg
       guY := dulaY + lenAvg
    } Else If (lenX>lenY)
       guY := dulaY
    Else
       guX := dulaX
}


fAddPathLines(pPath, inPoints) {
   PointsCount := inPoints.Length()
   If !PointsCount
      Return 1

   VarSetCapacity(PointsF, 4 * PointsCount, 0)
   Loop, % PointsCount
       NumPut(inPoints[A_Index], &PointsF, 4 * (A_Index-1), "float")

   iCount := PointsCount//2
   return DllCall("gdiplus\GdipAddPathLine2", "UPtr", pPath, "UPtr", &PointsF, "int", iCount)
}

fAddPathLine(pPath, x1, y1, x2, y2, err) {
   If (x1=x2 && y1=y2)
      Return 2

   If (isInRange(x1, x2 - err, x2 + err) && isInRange(y1, y2 - err, y2 + err))
      Return 2

   Return DllCall("gdiplus\GdipAddPathLine", "UPtr", pPath, "float", x1, "float", y1, "float", x2, "float", y2)
}

generateVPbezierAnchorPaths(mainWidth, mainHeight, ByRef PointsListArray, ByRef kOnes, ByRef bezierLinesPath) {
   If (bezierLinesPath!="")
   {
      Gdip_DeletePath(bezierLinesPath)
      bezierLinesPath := ""
   }

   bezierLinesPath := Gdip_CreatePath()
   If !bezierLinesPath
   {
      addJournalEntry(A_ThisFunc "(): ERROR: Failed to generate Bezier path viewport anchors lines path.")
      Return
   }

   slz := SelDotsSize//2 + 1
   slp := slz//2 + 1
   totalz := customShapePoints.Count()
   For Keyu, Cords in kOnes
   {
     If (Keyu>1 && Keyu<totalz)
     {
        ; prepare the list of lines to draw formed by anchors connected to the main/key points
        j := 0
        xu := Cords[1], yu := Cords[2]
        xA := PointsListArray[(Keyu + 1)*2 - 1], yA := PointsListArray[(Keyu + 1)*2]
        xB := PointsListArray[(Keyu + 3)*2 - 1], yB := PointsListArray[(Keyu + 3)*2]
        xC := PointsListArray[(Keyu - 1)*2 - 1], yC := PointsListArray[(Keyu - 1)*2]
        If (!isLineOutsideVP(xC, yC, xu, yu, mainWidth, mainHeight) && isDotInRect(xA, yA, slz, slz, xB, yB, 1))
           j := fAddPathLine(bezierLinesPath, xC, yC, xu, yu, slp)
        Else If (!isLineOutsideVP(xA, yA, xu, yu, mainWidth, mainHeight) && isDotInRect(xC, yC, slz, slz, xu, yu, 1))
           j := fAddPathLine(bezierLinesPath, xu, yu, xA, yA, slp)
        Else If !isTriangleEntirelyOutsideVP(xC, yC, xu, yu, xA, yA, mainWidth, mainHeight)
           j := fAddPathLines(bezierLinesPath, [xC, yC, xu, yu, xA, yA])
        ; Else
        ;    skippedLines++
        If !j
           Gdip_StartPathFigure(bezierLinesPath)
        ; If (j=2)
        ;    skippedLines++
        ; fnOutputDebug(A_ThisFunc "(): " keyu "|" j " A=" xA " | " ya " B=" xB " | " yB " C=" xC " | " yC "| U=" xu " | " yu)
     }
   }

   Gdip_StartPathFigure(bezierLinesPath)
   Gdip_AddPathLine(bezierLinesPath, PointsListArray[1], PointsListArray[2], PointsListArray[3], PointsListArray[4]) ; first anchor
   Gdip_StartPathFigure(bezierLinesPath)
   Gdip_AddPathLine(bezierLinesPath, PointsListArray[totalz * 2 - 3], PointsListArray[totalz * 2 - 2], PointsListArray[totalz * 2 - 1], PointsListArray[totalz * 2]) ; last anchor
   Return bezierLinesPath
}

defineVectorEditorStatusBar(ByRef mousePoint, ByRef dontAddPoint, canDoSymmetry, altState, ctrlState, shiftState) {
   dontAddPoint := mousePoint[1]
   If (dontAddPoint=1)
      dontAddPoint := mousePoint[1] " | Path start point"
   Else If (dontAddPoint=customShapePoints.Count())
      dontAddPoint := mousePoint[1] " | Path end point"
   Else If (dontAddPoint=symPoint && canDoSymmetry)
      dontAddPoint := mousePoint[1] " | Symmetry reference point"

   If (vectorToolModus<3 || vectorToolModus=5)
   {
      If (mousePoint[4]!=1 && bezierSplineCustomShape=1)
         pk := "anchor "

      selu := customShapePropPoints[dontAddPoint, 1]
      If (vectorToolModus=5)
      {
         If (customShapeHasSelectedPoints=1)
         {
            msgu := "Click and drag to rescale selected points."
            If (dontAddPoint!=0 && selu=1)
               msgu := "Click and drag to move selected points. Shift + L-Click to deselect " pk "P[" dontAddPoint "]." 
            Else If (dontAddPoint!=0)
               msgu :=  "Move " pk "point P[" dontAddPoint "]" 
         } Else
            msgu := (dontAddPoint!=0) ? "Move " pk "point P[" dontAddPoint "]" : "Click and drag points to adjust the path."
      } Else
      {
         msgu := (dontAddPoint!=0) ? "Move existing " pk "point P[" dontAddPoint "]. Double click to divide in two." : "Click to add new point and extend path. Hold Alt, Ctrl or Shift for other modes."
         If (dontAddPoint!=0 && customShapeHasSelectedPoints=1)
            msgu := "Click and drag to move selected points. Shift + L-Click to deselect " pk "P[" dontAddPoint "]."
      }

      If (altState && vectorToolModus!=5)
         msgu := (dontAddPoint=0 || !canDoSymmetry) ? "ALT: Add new point on existing edge" : "ALT: Move point ignoring symmetry " pk "P[" dontAddPoint "]"
      Else If (ctrlState && vectorToolModus!=5)
         msgu := (dontAddPoint=0) ? "CTRL: Remove point(s)" : "CTRL: Remove " pk "point P[" dontAddPoint "]"
      Else If shiftState
      {
         If (dontAddPoint!=0 && vectorToolModus!=2)
            msgu := (selu=1) ? "SHIFT: Deselect " pk "point P[" dontAddPoint "]" : "SHIFT: Select " pk "point P[" dontAddPoint "]"
         Else If (dontAddPoint=0 && vectorToolModus!=5)
            msgu := "SHIFT: Click to add new point snapped every 45° degrees and extend path"
         Else If (dontAddPoint=0 && vectorToolModus=5 && customShapeHasSelectedPoints=1)
            msgu := "SHIFT: Click and drag to uniformly rescale the selected points."
         Else
            msgu := (dontAddPoint=0) ? "SHIFT: No action" : "SHIFT: P[" dontAddPoint "]. No action."
      }

      If (customShapePoints.Count()<1)
      {
         msgu := "Path type: " Format("{:U}", defineVectorPathType()) ". Click to add the start point of the new vector shape. Press Escape to cancel."
      } Else If (mousePoint[4]!=1 && bezierSplineCustomShape=1)
      {
         If InStr(msgu, "remove anchor")
            msgu := StrReplace(msgu, "Remove", "Collapse")
         If (InStr(msgu, "move existing anchor") && InStr(msgu, "double click to"))
            msgu := SubStr(msgu, 1, InStr(msgu, ".") + 1) "Double click to collapse it."
      }
      If (vectorToolModus>1)
         msgu := "Tool mode: " Format("{:U}", defineVectToolMode()) ". " msgu
   } Else If (vectorToolModus=3)
   {
      msgu := (dontAddPoint=0) ? "Tool mode: REMOVE. Click on any point to remove it." : "Tool mode: REMOVE. Remove point P[" dontAddPoint "]"
      If (bezierSplineCustomShape=1 && dontAddPoint=0)
         msgu .= " Click anchor points to collapse them."
      Else If (mousePoint[4]!=1 && bezierSplineCustomShape=1 && dontAddPoint!=0)
         msgu := "Tool mode: REMOVE. Collapse anchor point P[" dontAddPoint "]"
   } Else If (vectorToolModus=4)
   {
      selu := customShapePropPoints[dontAddPoint, 1]
      If (shiftState && dontAddPoint=0)
         msgu := "Tool mode: SELECT. SHIFT: Click and drag to create a rectangular selection of points. Hold Ctrl additionally to deselect points."
      Else If ctrlState
         msgu := (dontAddPoint=0) ? "CTRL: Remove point(s)" : "CTRL: Remove " pk "point P[" dontAddPoint "]"
      Else If (dontAddPoint!=0 && vectorToolModus!=2)
         msgu := (selu=1) ? "Tool mode: SELECT. Deselect " pk "point P[" dontAddPoint "]" : "Tool mode: SELECT. Select " pk "point P[" dontAddPoint "]"
      Else
         msgu := "Tool mode: SELECT. Click on any point to select it. Double click elsewhere to deselect all points. Use Shift to select multiple points."
   }

   Return msgu
}

drawVisibleVectorPoints(gmx, gmy, mx, my, pWhite, totalz, Gu, mainWidth, mainHeight, ByRef vectorVisiblePoints, bezierLinesPath, rect:=0) {
   Static prevMsg, prevBMP, lastSnap := []
   If (gmx="snap")
      Return lastSnap

   If (vpImgPanningNow)
      Return

   If (pWhite!="clicky" && !IsObject(rect))
   {
      dontAddPoint := (mX<0 || mY<0) ? -1 : 0
      If (dontAddPoint!=-1 && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1))
      {
         ; handle H/V scrollbars for images larger than the viewport
         knobSize := getScrollWidth()
         If ( (scrollBarHy>1 && mY>(mainHeight - knobSize))
         || (scrollBarVx>1 && mX>(mainWidth - knobSize)) )
            dontAddPoint := -1
      }

      If (dontAddPoint!=-1)
      {
         MouseGetPos, , , OutputVarWin
         If ( GetKeyState("Space", "P") || (showHUDnavIMG=1 && IMGlargerViewPort=1 && hasDrawnImageMap=1 && isDotInRect(mX, mY, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7], HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
         || (OutputVarWin!=PVhwnd) || (A_TickCount - zeitSillyPrevent<100) )
            dontAddPoint := -1
      }

      If (dontAddPoint=-1)
      {
         doNormalCursor := (dontAddPoint!=0 || vpImgPanningNow=1) ? 1 : 0
         interfaceThread.ahkassign("doNormalCursor", doNormalCursor)
         Return
      }
   }

   If (Gu)
   {
      Gdip_SetPenWidth(pPen6, imgHUDbaseUnit/12.5)
      Gdip_SetPenWidth(pPen7, SelDotsSize/2.5 + 1)
      Gdip_SetPenWidth(pPen1d, SelDotsSize/5 + 1)
      pzx := (FlipImgH=1) ? scrollBarVx : 0
      pzy := (FlipImgV=1) ? scrollBarHy : 0
      pzw := (FlipImgH=1) ? mainWidth : mainWidth - scrollBarVx
      pzh := (FlipImgV=1) ? mainHeight : mainHeight - scrollBarHy
      Gdip_SetClipRect(Gu, pzx, pzy, pzw, pzh)
   }

   mousePoint := [0, 0]
   canDoSymmetry := isNowSymmetricVectorShape()
   symPoint := prevVectorShapeSymmetryMode[1, 1]
   If (canDoSymmetry && Gu && totalz>1)
      coreSetVPsymmetryPoint(totalz//2 + 1)

   For KeyPoint, vObj in vectorVisiblePoints
   {
       If !IsObject(vObj)
          Continue

       ; ppz := 0
       sl := floor(vObj[6])
       slx := vObj[6] / 1.5
       If (isInRangeF(gmX, vObj[3] - slx, vObj[3] + slx) && isInRangeF(gmY, vObj[4] - slx, vObj[4] + slx))
       ; If (isInRangeF(gmX, vObj[3] - SelDotsSize, vObj[3] + SelDotsSize) && isInRangeF(gmY, vObj[4] - SelDotsSize, vObj[4] + SelDotsSize))
       {
          ; ppz := 1
          mousePoint := [KeyPoint, vObj[3], vObj[4], vObj[5]]
          ; mousePoint := [indexu, xu, yu, k]
          ; Gdip_FillRectangle(Gu, pBrushE, vObj[3] - sl, vObj[4] - sl, sl*2, sl*2)
       }
 
       tx := floor(vObj[1]),       ty := floor(vObj[2])
       ; bz := tx//vObj[7] "|" ty//vObj[7]
       ; If (overDrawFilter[bz]!=1 && Gu)
       selu := customShapePropPoints[KeyPoint, 1]
       If selu 
          customShapeHasSelectedPoints := 1

       If (Gu)
       {
          whichBrush := (selu=1) ? pBrushA : pBrushD ; selected dot 
          Gdip_FillRectangle(Gu, whichBrush, tx, ty, sl, sl) 
          If selu ; selected dot
             Gdip_DrawRectangle(Gu, pPen7, tx, ty, sl, sl)
          ; overDrawFilter[bz] := 1
          If (KeyPoint=1)
             Gdip_FillEllipse(Gu, pBrushZ, vObj[3] - SelDotsSize//4, vObj[4] - SelDotsSize//4, SelDotsSize//2, SelDotsSize//2)
          Else If (KeyPoint=totalz)
          {
             Gdip_FillEllipse(Gu, pBrushE, vObj[3] - SelDotsSize//4, vObj[4] - SelDotsSize//4, SelDotsSize//2, SelDotsSize//2)
             Gdip_DrawEllipse(Gu, pPen6, tx, ty, sl, sl) 
          } Else If (KeyPoint=symPoint && canDoSymmetry)
             Gdip_DrawEllipse(Gu, pPen3, vObj[3] - SelDotsSize//4, vObj[4] - SelDotsSize//4, SelDotsSize//2, SelDotsSize//2)
       }
   }

   If (mousePoint[1]!=0 && Gu)
   {
      ; draw the mouse hovered point
      vObj := vectorVisiblePoints[mousePoint[1]]
      sl := floor(vObj[6])
      slx := vObj[6] / 1.25
      Gdip_FillRectangle(Gu, pBrushE, vObj[3] - slx, vObj[4] - slx, slx*2, slx*2)
      Gdip_FillRectangle(Gu, pWhite, floor(vObj[1]), floor(vObj[2]), sl, sl)
   } Else If (Gu && vectorToolModus=3)
   {
      Gdip_DrawLine(Gu, pPen6, gmx - SelDotsSize, gmy - SelDotsSize//2, gmx + SelDotsSize, gmy + SelDotsSize)
      Gdip_DrawLine(Gu, pPen6, gmx + SelDotsSize, gmy - SelDotsSize//2, gmx - SelDotsSize, gmy + SelDotsSize)
   } Else If (Gu && vectorToolModus=4)
   {
      Gdip_DrawRectangle(Gu, pPen1d, gmx - SelDotsSize//2, gmy - SelDotsSize//2, SelDotsSize, SelDotsSize)
   }

   ctrlState := GetKeyState("Ctrl", "P")
   altState := GetKeyState("Alt", "P")
   shiftState := GetKeyState("Shift", "P")
   If (mousePoint[1]=0 && totalz>0 && vpImgPanningNow=0 && ctrlState=0 && altState=0 && vectorToolModus<3)
   {
      ; draw the new line and handle snapping new points to angles
      tx := gmx, ty := gmy
      getVPcoordsVectorPoint(totalz, xub, yub)
      If (shiftState=1)
      {
         sz := SelDotsSize * 4
         snapPointsAtAngles(gmX, gmY, xub, yub, tX, tY)
         lastSnap := [tx, ty]
      } Else
         lastSnap := []

      If (Gu && (showNewVectorPointPreview=1 || shiftState=1 || vectorToolModus=2))
      {
         getVPcoordsVectorPoint(1, xua, yua)
         If (shiftState=1)
         {
            Gdip_SetPenWidth(pPen1d, imgHUDbaseUnit/14)
            Gdip_DrawLine(Gu, pPen1d, xub - sz, yub, xub + sz, yub)
            Gdip_DrawLine(Gu, pPen1d, xub, yub - sz, xub, yub + sz)
         }

         Gdip_DrawLine(Gu, pPen4, xub, yub, tx, ty)
         If (closedLineCustomShape=1)
         {
            Gdip_DrawLine(Gu, pPen4, xub + 1, yub + 1, tx + 1, ty + 1)
            Gdip_DrawLine(Gu, pPen4, xua, yua, tx, ty)
         }
         Gdip_FillRectangle(Gu, pBrushA, tx - SelDotsSize//2, ty - SelDotsSize//2, SelDotsSize, SelDotsSize)
      }
   }

    If (bezierLinesPath!="" && bezierSplineCustomShape=1)
    {
       ; draw the lines formed by anchors and the main/key points
       Gdip_DrawPath(Gu, pPen1d, bezierLinesPath)
    }

    If (Gu && IsObject(rect))
    {
       doRedraw := 1
       Gdip_FillRectangle(Gu, pBrushC, rect[1], rect[2], rect[3], rect[4])
       Gdip_DrawRectangle(Gu, pPen4, rect[1], rect[2], rect[3], rect[4])
    } 

    If (vpImgPanningNow!=1 && showContextualStatusBar=1 && Gu)
    {
       ; draw the status bar
       msgu := defineVectorEditorStatusBar(mousePoint, dontAddPoint, canDoSymmetry, altState, ctrlState, shiftState)
       thisIDu := msgu "a" altState ctrlState shiftState canDoSymmetry FlipImgH FlipImgV scrollBarVx hasDrawnImageMap scrollBarHy
       If (thisIDu=prevMsg && validBMP(prevBMP))
       {
          BoxBMP := trGdip_CloneBitmap(A_ThisFunc, prevBMP)
       } Else
       {
          BoxBMP := drawTextInBox(msgu, OSDFontName, Round(OSDfontSize*0.7), mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0, 1)
          prevBMP := trGdip_DisposeImage(prevBMP)
          prevBMP := trGdip_CloneBitmap(A_ThisFunc, BoxBMP)
       }

       If validBMP(BoxBMP)
       {
          trGdip_GetImageDimensions(BoxBMP, w, h)
          posXu := (FlipImgH=1) ? scrollBarVx : 0
          If (FlipImgH=0 && hasDrawnImageMap=1 && IMGlargerViewPort=1)
             posXu := Round(HUDobjNavBoxu[1])

          posYu := (FlipImgV=1) ? scrollBarHy : mainHeight - h - scrollBarHy
          If (tempBtnVisible=hGuiBtn && showMainMenuBar!=1 && FlipImgV=0)
          {
             ; lastSize := RepositionTempBtnGui("getLast")
             ; MouseCoords2Image(lastSize[5], lastSize[6], 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, kX, kY)
             posYu := 0
             ; ToolTip, % kY " kl=" lastSize[2] "|" h "|" posYu , , , 2
          }
          tzGdip_DrawImage(Gu, BoxBMP, posXu, posYu, w, h)
          trGdip_DisposeImage(BoxBMP)
          prevMsg := thisIDu
       }
    }

    If (doRedraw=1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectwin, 2NDglHDC)

    doNormalCursor := (dontAddPoint!=0 || vpImgPanningNow=1) ? 1 : 0
    interfaceThread.ahkassign("doNormalCursor", doNormalCursor)
    ; fnOutputDebug(A_ThisFunc "(): x/y=" gmx "|" gmy "|" mousePoint[1])
    Return mousePoint
}

updateCachedLiveDrawPathGivenPoint(whichPoint, ByRef vectorVisiblePoints, ByRef PointsListArray, ByRef kOnes) {
   If (whichPoint<1 || whichPoint>customShapePoints.Count())
      Return

   vObj := vectorVisiblePoints[whichPoint]
   If !IsObject(vObj)
   {
      k := 0
      slp := SelDotsSize//2 + 1
      ; fnOutputDebug(A_ThisFunc "() find = " whichPoint)
      Loop, % customShapePoints.Count()
      {
         k := (bezierSplineCustomShape=1) ? clampInRange(k + 1, 1, 3, 1) : 1
         If (A_Index=whichPoint || bezierSplineCustomShape!=1)
         {
            sl := (k=1) ? SelDotsSize : slp 
            getVPcoordsVectorPoint(whichPoint, xu, yu)
            tx := xu - sl/2,    ty := yu - sl/2
            ; fnOutputDebug(A_ThisFunc "()" A_Index "|" whichPoint)
            vectorVisiblePoints[whichPoint] := [tx, ty, xu, yu, k, sl, slp]
            Break
         }
      }

      vObj := vectorVisiblePoints[whichPoint]
      If !IsObject(vObj)
         Return
   }

   ; fnOutputDebug(A_ThisFunc "() update = " whichPoint)
   getVPcoordsVectorPoint(whichPoint, xu, yu)
   PointsListArray[whichPoint*2 - 1] := xu
   PointsListArray[whichPoint*2] := yu

   sl := floor(vObj[6])
   tx := xu - sl/2,    ty := yu - sl/2
   vectorVisiblePoints[whichPoint] := [tx, ty, xu, yu, vObj[5], sl, vObj[7]]
   If IsObject(kOnes[whichPoint])
      kOnes[whichPoint] := [xu, yu]
}

drawLiveCreateCustomShape(mainWidth, mainHeight, Gu, actu:=0, whichPoint:=0, kpp:=0) {
    ; Related functions: PerformVectorShapeActions()
    Static pWhite, prevBMP, prevCstate, prevpx, prevpy, prevMousePoint , prevPartialState
         , vectorVisiblePoints := [], PointsListArray := [], kOnes := [], bezierLinesPath
         , bezierAnchorsLinesUpdated := 0

    If (mainWidth="kill")
    {
       If pWhite
          Gdip_DeleteBrush(pWhite)

       pWhite := prevCstate := prevPartialState := ""
       prevBMP := trGdip_DisposeImage(prevBMP)
       vectorVisiblePoints := []
       PointsListArray := []
       kOnes := []
       Gdip_DeletePath(bezierLinesPath)
       bezierLinesPath := ""
       Return
    } Else If (mainWidth="setData")
    {
       bezierAnchorsLinesUpdated := 0
       bzr := (bezierSplineCustomShape=1) ? closedLineCustomShape : 0
       prevCstate := "a" mainWidth mainHeight FillAreaCurveTension closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel currentVectorUndoLevel prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       prevPartialState := "a" mainWidth mainHeight bzr customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel currentVectorUndoLevel prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       PointsListArray := mainHeight
       vectorVisiblePoints := Gu
       kOnes := actu
       Return
    } Else If (mainWidth="getPoints")
       Return vectorVisiblePoints
    Else If (mainWidth="getAllPoints")
       Return PointsListArray
    Else If (mainWidth="ko")
       Return kOnes

    If !pWhite
       pWhite := Gdip_BrushCreateSolid("0xDDeeFFaa")

    If validBMP(HistogramBMP)
       HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)

    startZeit := A_TickCount
    GetMouseCoord2wind(PVhwnd, mX, mY)
    gmX := (FlipImgH=1) ? mainWidth - mX : mX
    gmY := (FlipImgV=1) ? mainHeight - mY : mY
    canDoSymmetry := isNowSymmetricVectorShape()
    totalz := customShapePoints.Count()
    bzr := (bezierSplineCustomShape=1) ? closedLineCustomShape : 0
    If (PointsListArray.Count()<6)
       prevPartialState := prevCstate := actu := ""

    If (actu="point-new-end" && whichPoint>0 && prevCstate)
    {
       If (canDoSymmetry)
          Return

       pp := totalz
       If (bezierSplineCustomShape=1)
       {
          k := 1
          Loop, 3
          {
             k := clampInRange(k + 1, 1, 3, 1)
             If (k=1)
             {
                getVPcoordsVectorPoint(pp - 3 + A_Index, zkx, zky)
                kOnes[pp - 3 + A_Index] := [zkx, zky]
             }

             sl := (k=1) ? SelDotsSize : SelDotsSize//2 + 1   ; keys or anchors
             vectorVisiblePoints[pp - 3 + A_Index] := vectorVisiblePoints[pp - 4 + A_Index].Clone()
             vectorVisiblePoints[pp - 3 + A_Index, 5] := k
             vectorVisiblePoints[pp - 3 + A_Index, 6] := sl
             updateCachedLiveDrawPathGivenPoint(pp - 3 + A_Index, vectorVisiblePoints, PointsListArray, kOnes)
          }
       } Else
       {
          vectorVisiblePoints[pp] := vectorVisiblePoints[pp - 1].Clone()
          updateCachedLiveDrawPathGivenPoint(pp, vectorVisiblePoints, PointsListArray, kOnes)
       }
       ; ToolTip, % pp "|" whichPoint "|" pp + A_Index - whichPoint , , , 2
       prevCstate := "a" mainWidth mainHeight FillAreaCurveTension closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel (currentVectorUndoLevel + 1) prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       thisPartialState := "a" mainWidth mainHeight bzr customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel (currentVectorUndoLevel + 1) prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       cacheRefresh := 1
    } Else If (actu="point-rem-last" && whichPoint>0 && prevCstate)
    {
       If (canDoSymmetry)
          Return

       pp := totalz + whichPoint
       Loop, % whichPoint
       {
          vectorVisiblePoints[pp] := 0
          PointsListArray.Pop()
          PointsListArray.Pop()
          pp--
          totalz--
       }

       updateCachedLiveDrawPathGivenPoint(totalz, vectorVisiblePoints, PointsListArray, kOnes)
       updateCachedLiveDrawPathGivenPoint(totalz - 1, vectorVisiblePoints, PointsListArray, kOnes)
       updateCachedLiveDrawPathGivenPoint(1, vectorVisiblePoints, PointsListArray, kOnes)
       prevCstate := "a" mainWidth mainHeight FillAreaCurveTension closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel (currentVectorUndoLevel + 1) prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       thisPartialState := "a" mainWidth mainHeight bzr customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel (currentVectorUndoLevel + 1) prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       cacheRefresh := 1
    } Else If (actu="point-update" && whichPoint>0 && prevCstate)
    {
       owPoint := whichPoint
       If (whichPoint<3 || whichPoint>totalz - 2)
       {
          updateCachedLiveDrawPathGivenPoint(1, vectorVisiblePoints, PointsListArray, kOnes)
          updateCachedLiveDrawPathGivenPoint(2, vectorVisiblePoints, PointsListArray, kOnes)
          updateCachedLiveDrawPathGivenPoint(totalz, vectorVisiblePoints, PointsListArray, kOnes)
          updateCachedLiveDrawPathGivenPoint(totalz - 1, vectorVisiblePoints, PointsListArray, kOnes)
       } Else
       {
          oppoIndex := (canDoSymmetry=1) ? totalz - whichPoint + 1 : 0
          whichPoint -= 3
          Loop, 7
          {
             updateCachedLiveDrawPathGivenPoint(whichPoint, vectorVisiblePoints, PointsListArray, kOnes)
             oppoIndex := (canDoSymmetry=1) ? totalz - whichPoint + 1 : 0
             If oppoIndex
                updateCachedLiveDrawPathGivenPoint(oppoIndex, vectorVisiblePoints, PointsListArray, kOnes)
             whichPoint++
          }
       }

       prevCstate := "a" mainWidth mainHeight FillAreaCurveTension closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel (currentVectorUndoLevel + 1) prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       thisPartialState := "a" mainWidth mainHeight bzr customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel (currentVectorUndoLevel + 1) prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       cacheRefresh := 1
    } Else If (actu="sel-rect" && IsObject(whichPoint) && prevCstate)
    {
       Gdip_GraphicsClear(Gu)
       setMainCanvasTransform(mainWidth, mainHeight, Gu)
       prevCstate := "a" mainWidth mainHeight FillAreaCurveTension closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel (currentVectorUndoLevel + 1) prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       thisPartialState := "a" mainWidth mainHeight bzr customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel (currentVectorUndoLevel + 1) prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
       cacheRefresh := 0
    }

    ptz := k := firstPx := firstPy := 0
    SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
    thisState := (cacheRefresh=1) ? prevCstate : "a" mainWidth mainHeight FillAreaCurveTension closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel currentVectorUndoLevel prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
    If (thisState=prevCstate && validBMP(prevBMP) && !cacheRefresh && vectorVisiblePoints.Count()>3 || actu="sel-rect")
    {
       Gdip_DrawImageFast(Gu, prevBMP)
       If (bezierAnchorsLinesUpdated=0 && bezierSplineCustomShape=1)
       {
          ; fnOutputDebug("updated generateVPbezierAnchorPaths")
          bezierLinesPath := generateVPbezierAnchorPaths(mainWidth, mainHeight, PointsListArray, kOnes, bezierLinesPath)
          bezierAnchorsLinesUpdated := 1
       }

       drawVisibleVectorPoints(gmx, gmy, mx, my, pWhite, totalz, Gu, mainWidth, mainHeight, vectorVisiblePoints, bezierLinesPath, whichPoint)
       If (actu="sel-rect")
          Gdip_ResetWorldTransform(Gu)
       fnOutputDebug(A_ThisFunc "(): redraw cached in " A_TickCount - startZeit "ms | " vectorVisiblePoints.Count())
       Return
    }

    thisPartialState := "a" mainWidth mainHeight bzr customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 bezierSplineCustomShape zoomLevel currentVectorUndoLevel prevDestPosX prevDestPosY getIDimage(currentFileIndex) currentFileIndex
    doCompleteRefresh := (thisPartialState=prevPartialState) ? 0 : 1
    prevBMP := trGdip_DisposeImage(prevBMP)
    If (!cacheRefresh && doCompleteRefresh=1)
    {
       If bezierLinesPath
       {
          Gdip_DeletePath(bezierLinesPath)
          bezierLinesPath := ""
       }

       ; fnOutputDebug(thisState "|" prevCstate)
       PointsListArray := [] ; flatten
       customShapeHasSelectedPoints := 0
       skipped := skippedLines := 1
       k := (bezierSplineCustomShape=1) ? 0 : 1
       sl := SelDotsSize
       slz := sl//2 + 1
       vectorVisiblePoints := []
       overDrawFilter := new hashtable()
       kOnes := []
       Loop, % totalz
       {
           ; convert and normalize points coordinates to current viewport conditions
           xu := PointsListArray[A_Index*2 - 1] := customShapePoints[A_Index, 1]*prevResizedVPimgW + prevDestPosX
           yu := PointsListArray[A_Index*2] := customShapePoints[A_Index, 2]*prevResizedVPimgH + prevDestPosY
           ; fnOutputDebug("loop=" A_Index "|" xu "|" yu)
           If (bezierSplineCustomShape=1)
           {
              k := clampInRange(k + 1, 1, 3, 1)
              sl := (k=1) ? SelDotsSize : slz   ; keys or anchors
           }
 
           ; NumPut(xu, &PointsList, 4 * ((A_Index - 1) * 2), "Float")
           ; NumPut(yu, &PointsList, 4 * ((A_Index - 1) * 2 + 1), "Float")
           If (customShapePropPoints[A_Index, 1])
              customShapeHasSelectedPoints := 1
 
           thizState := "a" xu yu
           If (thizState!=prevState || A_Index=totalz)
           {
              ; populate the vectorVisiblePoints[] array with the points visible in the viewport
              prevState := thizState
              tx := xu - sl/2,    ty := yu - sl/2
              If (tx>=0 && tx<=mainWidth && ty>=0 && ty<=mainHeight || A_Index=totalz)
              {
                 bz := tx//slz "|" ty//slz
                 If (!overDrawFilter[bz] || A_Index=totalz)
                 {
                    vectorVisiblePoints[A_Index] := [tx, ty, xu, yu, k, sl, slz]
                    overDrawFilter[bz] := k
                 }
              }
              ; overDrawFilter[thizState] := k
           }
       }

       ; fnOutputDebug(A_ThisFunc " interim A: " A_TickCount - startZeit " ms")
       If (bezierSplineCustomShape=1)
       {
          ; generate the list of key points, to be used by generateVPbezierAnchorPaths() to draw the anchors
          For KeyPoint, vObj in vectorVisiblePoints
          {
              ; fnOutputDebug(KeyPoint "|" vObj[3] " / " vObj[4] " / " vObj[5])
              If (vObj[5]=1)
              {
                 kOnes[KeyPoint] := [ PointsListArray[(KeyPoint)*2 - 1], PointsListArray[(KeyPoint)*2] ]
                 Continue
              }

              If IsObject(kOnes[KeyPoint])
                 Continue

              If (vObj[5]=3)
              {
                 xu := PointsListArray[(KeyPoint + 1)*2 - 1],    yu := PointsListArray[(KeyPoint + 1)*2]
              } Else
              {
                 xu := PointsListArray[(KeyPoint - 1)*2 - 1],    yu := PointsListArray[(KeyPoint - 1)*2]
              }

              tx := xu - slz/2,    ty := yu - slz/2
              bz := tx//slz "|" ty//slz
              ; tzz := "a" xu yu
              If (overDrawFilter[bz]!=1 && overDrawFilter[bz]>1) ; || (overDrawFilter[tzz]!=1 && overDrawFilter[tzz]>1)
              {
                 ; fnOutputDebug(A_ThisFunc "(): " KeyPoint "|" vObj[5])
                 If IsObject(vectorVisiblePoints[KeyPoint]) && !IsObject(vectorVisiblePoints[KeyPoint + 1])
                 {
                    ; fix drawing of collapsed anchors
                    ; fnOutputDebug(A_ThisFunc "(): doooone " KeyPoint "|" vObj[5])
                    vectorVisiblePoints[KeyPoint] := 0
                    vectorVisiblePoints[KeyPoint + 1] := [tx, ty, xu, yu, 1, SelDotsSize, slz]
                    overDrawFilter[bz] := 1
                 }
              }

              If (vObj[5]=3)
                 kOnes[KeyPoint + 1] := [ xu, yu ]
              Else
                 kOnes[KeyPoint - 1] := [ xu, yu ]
          }

          bezierLinesPath := generateVPbezierAnchorPaths(mainWidth, mainHeight, PointsListArray, kOnes, bezierLinesPath)
          ; fnOutputDebug(A_ThisFunc " interim B: " A_TickCount - startZeit " ms")
          bezierAnchorsLinesUpdated := 1
       }

       overDrawFilter := ""
       prevCstate := thisState
    }

    If CustomShapeSymmetry
    {
       If ( (!vpSymmetryPointXdp && !vpSymmetryPointYdp && totalz=1 && bezierSplineCustomShape=0)
       || (!vpSymmetryPointXdp && !vpSymmetryPointYdp && totalz=2 && bezierSplineCustomShape=1) )
          coreSetVPsymmetryPoint(1)
    }

    If (totalz<=2 && bezierSplineCustomShape=0 || totalz=3 && bezierSplineCustomShape=1)
    {
       vpFreeformShapeOffset[1] := 0, vpFreeformShapeOffset[2] := 0, vpFreeformShapeOffset[3] := 0
       CustomShapeLockedSymmetry := CustomShapeSymmetry
    }

    If (bezierSplineCustomShape=1 && cacheRefresh=1)
    {
       If (actu="point-update")
       {
          bezierAnchorsLinesUpdated := 0
       } Else
       {
          bezierLinesPath := generateVPbezierAnchorPaths(mainWidth, mainHeight, PointsListArray, kOnes, bezierLinesPath)
          bezierAnchorsLinesUpdated := 1
          ; fnOutputDebug("lolz")
       }
    } Else
    {
       If (bezierSplineCustomShape=1 && bezierAnchorsLinesUpdated!=1)
          bezierLinesPath := generateVPbezierAnchorPaths(mainWidth, mainHeight, PointsListArray, kOnes, bezierLinesPath)
       bezierAnchorsLinesUpdated := 1
    }

    prevCstate := thisState
    prevPartialState := thisPartialState
    thisThick := SelDotsSize//5 + 1
    sz := SelDotsSize * 5

    pzx := (FlipImgH=1) ? scrollBarVx : 0
    pzy := (FlipImgV=1) ? scrollBarHy : 0
    pzw := (FlipImgH=1) ? mainWidth : mainWidth - scrollBarVx
    pzh := (FlipImgV=1) ? mainHeight : mainHeight - scrollBarHy
    prevBMP := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight)
    zGu := Gdip_GraphicsFromImage(prevBMP, 5, 3)

    Gdip_SetClipRect(zGu, pzx, pzy, pzw, pzh)
    thisThick := InStr(postVectorWinOpen, "c") ? imgHUDbaseUnit//10 : DrawLineAreaContourThickness * zoomLevel
    If (drawingVectorLiveMode=1)
       Gdip_SetPenWidth(PenuDrawLive, thisThick)

    If (PenuDrawLive && isInRange(PointsListArray.Count(), 3, 4))
    {
       Gdip_SetPenWidth(pPen4, imgHUDbaseUnit//11)
       Gdip_DrawLines(zGu, pPen4, PointsListArray)
    } Else If (PenuDrawLive)
    {
       thisPath := Gdip_CreatePath()
       If (FillAreaCurveTension=4)
          tensionCurveCustomShape := 0.95
       Else If (FillAreaCurveTension=3)
          tensionCurveCustomShape := 0.5
       Else If (FillAreaCurveTension=2)
          tensionCurveCustomShape := 0.2
       Else
          tensionCurveCustomShape := 0.1

       ; ToolTip, % FillAreaCurveTension "|" closedLineCustomShape , , , 2
       iCount := CreatePointsF(PointsList, PointsListArray)
       If (bezierSplineCustomShape=1)
          DllCall("gdiplus\GdipAddPathBeziers", "UPtr", thisPath, "UPtr", &PointsList, "int", iCount)
       Else If (FillAreaCurveTension=1 && closedLineCustomShape=1)
          DllCall("gdiplus\GdipAddPathPolygon", "UPtr", thisPath, "UPtr", &PointsList, "int", iCount)
       Else If (FillAreaCurveTension=1 && closedLineCustomShape=0)
          DllCall("gdiplus\GdipAddPathLine2", "UPtr", thisPath, "UPtr", &PointsList, "int", iCount)
       Else If (closedLineCustomShape=1)
          DllCall("gdiplus\GdipAddPathClosedCurve2", "UPtr", thisPath, "UPtr", &PointsList, "int", iCount, "float", tensionCurveCustomShape)
       Else
          DllCall("gdiplus\GdipAddPathCurve2", "UPtr", thisPath, "UPtr", &PointsList, "int", iCount, "float", tensionCurveCustomShape)

       ; createPathVectorCustomShape(thisPath, PointsListArray, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, 0, 0, 0)
       If (drawingVectorLiveMode=1 || drawingVectorLiveMode=3)
          Gdip_DrawPath(zGu, PenuDrawLive, thisPath)
       Else
          Gdip_FillPath(zGu, PenuDrawLive, thisPath)

       Gdip_DeletePath(thisPath)
       thisPath := ""
    }

    ; fnOutputDebug(A_ThisFunc " interim B: " A_TickCount - startZeit " ms")
    If (cacheRefresh=1 && actu="point-update" || doRedraw=1)
    {
       Gdip_GraphicsClear(Gu, "0x00" WindowBGRcolor)
       setMainCanvasTransform(mainWidth, mainHeight, Gu)
    }
    ; ToolTip, % cacheRefresh "|" doRedraw "|" actu "|" totalz , , , 2
    Gdip_DeleteGraphics(zGu)
    r := Gdip_DrawImageFast(Gu, prevBMP)
    If !cacheRefresh
       drawVisibleVectorPoints(gmx, gmy, mx, my, pWhite, totalz, Gu, mainWidth, mainHeight, vectorVisiblePoints, bezierLinesPath)

    If (cacheRefresh=1 && actu="point-update" || doRedraw=1)
    {
       If (bezierSplineCustomShape=1 && doRedraw!=1)
       {
          ; draw the bezier anchors being manipulated by user
          pzPath := Gdip_CreatePath()
          kZ := vectorVisiblePoints[owPoint, 5]
          getAssociatedBezierPoints(kZ, customShapePoints.Count(), owPoint, zA, zB)
          If (zB="")
             zB := zA
          Else If (zA="")
             zA := owPoint

          If areEndsConnectedBezierPath(owPoint, customShapePoints.Count())
          {
             If (kZ=3)
                zA := 1, zB := 2, owPoint := customShapePoints.Count() - 1
             Else If (kZ=2)
                zA := 1, zB := customShapePoints.Count() - 1, owPoint := 2
             Else If (kZ=1)
                zA := 2
          }

          xA := PointsListArray[zA*2 - 1],      yA := PointsListArray[zA*2]
          xB := PointsListArray[zB*2 - 1],      yB := PointsListArray[zB*2]
          xC := PointsListArray[owPoint*2 - 1], yC := PointsListArray[owPoint*2]
          If (kZ=1)
             fAddPathLines(pzPath, [xB, yB, xC, yC, xA, yA])
          Else If (kZ=2)
             fAddPathLines(pzPath, [xB, yB, xA, yA, xC, yC])
          Else If (kZ=3)
             fAddPathLines(pzPath, [xC, yC, xA, yA, xB, yB])

          Gdip_SetPenWidth(pPen1d, SelDotsSize//5 + 1)
          Gdip_DrawPath(Gu, pPen1d, pzPath)
          Gdip_DeletePath(pzPath)
       }
       Gdip_ResetWorldTransform(Gu)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectwin, 2NDglHDC)
    }
    ; ToolTip, % r "|" pp "|" iCount "|" zGu "|" Gu "|" prevBMP "|" gmx "|" gmy  , , , 2
    fnOutputDebug(doCompleteRefresh "|" cacheRefresh " | " A_ThisFunc "(): redraw in " A_TickCount - startZeit "ms ")
} ; // drawLiveCreateCustomShape()

getVPcustomShapePath(PointsListArray) {
    newArrayu := []
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       If (c[1]="" || c[2]="")
          Continue

        newArrayu[A_Index*2 - 1] := customShapePoints[A_Index, 1]*prevResizedVPimgW + prevDestPosX
        newArrayu[A_Index*2] := customShapePoints[A_Index, 2]*prevResizedVPimgH + prevDestPosY
    }

    pPath := Gdip_CreatePath()
    createPathVectorCustomShape(pPath, newArrayu, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, 0, 0, 0)
    Return [pPath, newArrayu]
}

convertEditorCustomShape2viewerCoords(PointsListArray, editorMode:=0) {
    ; this function is executed when user exits vector path editing mode
    ; called from stopDrawingShape()
    If (PointsListArray.Count()<3)
       Return

    obju := getVPcustomShapePath(PointsListArray)
    pPath := obju[1]
    newArrayu := obju[2]
    Rect := getAccuratePathBounds(pPath)
    minXu := Rect.X,  minYu := Rect.Y
    maxXu := Rect.X + Rect.W, maxYu := Rect.Y + Rect.H

    MouseCoords2Image(minXu, minYu, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX1, imgSelY1)
    MouseCoords2Image(maxXu, maxYu, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX2, imgSelY2)

    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    defineRelativeSelCoords(imgW, imgH)
    initialCustomShapeCoords := imgSelX1 "|" imgSelY1 ; i forgot what this is for ^_^ 
    RegAction(1, "initialCustomShapeCoords")
    mW := Rect.W
    mH := maxYu - minYu

    ; pp := Gdip_GetPathPointsCount(pPath)
    ; ToolTip, % "l=" pp "|" PointsListArray.Count() , , , 2
    ; Gdip_GraphicsClear(2NDglPG)
    ; Gdip_DrawPath(2NDglPG, pPen5, pPath)
    ; doLayeredWinUpdate(A_ThisFunc, hGDIselectwin, 2NDglHDC)
    ; Sleep, 800
    newShape := []
    Gdip_DeletePath(pPath)
    Loop, % PointsListArray.Count()
    {
       xu := (newArrayu[A_Index*2 - 1] - minXu) / Rect.W
       yu := (newArrayu[A_Index*2]     - minYu) / Rect.H
       newShape[A_Index] := [xu, yu]
    }

    Return newShape
}

adjustCustomShapePositionLive(dir:=0) {
    Static lastInvoked := 1
    If (customShapePoints.Count()<3)
       Return

    stepuX := stepuY := 0
    If (Abs(dir)=1)
       stepuX := (dir=1) ? 2 : -2

    If (Abs(dir)=2)
       stepuY := (dir=2) ? 2 : -2

    If (A_TickCount - lastInvoked<400)
    {
       stepuX *= 2
       stepuY *= 2
    }

    stepuX := stepuX/prevResizedVPimgW
    stepuY := stepuY/prevResizedVPimgH
    canDoSymmetry := isNowSymmetricVectorShape()
    symPoint := canDoSymmetry ? ( customShapePoints.Count() ) // 2 + 1 : -1
    totalCount := customShapePoints.Count()
    pp := new hashtable()
    Loop, % totalCount
    {
       If (pp[A_Index]=1 || symPoint=A_Index && customShapeHasSelectedPoints=1)
          Continue
 
       c := customShapePoints[A_Index]
       If (c[1]="" || c[2]="" || customShapePropPoints[A_Index, 1]!=1 && customShapeHasSelectedPoints=1)
          Continue

       customShapePoints[A_Index] := [c[1] + stepuX, c[2] + stepuY]
       If canDoSymmetry
       {
          oppoIndex := totalCount - A_Index + 1
          If (oppoIndex && A_Index!=oppoIndex && pp[A_Index]!=1)
          {
             getVPcoordsVectorPoint(A_Index, gmX, gmY)
             calculateSymmetricVectorPoint(gmX, gmY, nX, nY)
             getVectorCoordsFromVPpoint(nX, nY, nX, nY)
             customShapePoints[oppoIndex] := [nX, nY]
             pp[oppoIndex] := 1
          }
       }
    }

    pp := ""
    If isNowSymmetricVectorShape()
       coreSetVPsymmetryPoint(symPoint)

    lastZeitFileSelect := A_TickCount
    lastInvoked := A_TickCount
    SetTimer, recordVectorUndoLevels, -500
    SetTimer, dummyRefreshImgSelectionWindow, -10
}

convertCustomShape2givenArea(PointsListArray, refX, refY, refW, refH, returnArray:=1, filterPointDupes:=0, isBezier:=0) {
    ; this assumes drawingShapeNow=0
    ; values must be in the range of 0 to 1 for the coord entries in PointsListArray
    If (PointsListArray.Count()<3)
       Return

    If (returnArray=1)
       newArrayu := []
    Else
       newShape := ""

    k := thisIndex := 0
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       If (c[1]="" || c[2]="")
       {
          ; fnOutputDebug(A_Index "|"  c[1] "|" c[2] "| excluded: " puf)
          Continue
       }

       thisIndex++
       xu := refW * c[1] + refX
       yu := refH * c[2] + refY
       If (returnArray=1)
       {
          newArrayu[thisIndex*2 - 1] := xu
          newArrayu[thisIndex*2 + 1 - 1] := yu
       } Else newShape .= xu "," yu "|"
       ; newShape .= Round(xu) "," Round(yu) "|"
    }
    customShapeCountPoints := thisIndex
    ; fnOutputDebug(A_ThisFunc ": " k)
    ; ToolTip, % "l=" newShape , , , 2
    If (returnArray=1)
       Return newArrayu
    Else
       Return Trimmer(newShape, "|")
}

convertShapePointsArrayToStr(PointsListArray, limited:=0) {
    If (PointsListArray.Count()<3)
       Return

    newShape := ""
    Loop, % PointsListArray.Count()
    {
       c := PointsListArray[A_Index]
       If (c[1]="" || c[2]="")
          Continue

       newShape .= clampInRange(c[1], 0, 1) "," clampInRange(c[2], 0, 1) "|"
       If (limited>0)
       {
          If (StrLen(newShape)>limited)
             Break
       }
    }

    Return Trimmer(newShape, "|")
}

convertShapePointsStrToArray(PointsList, offX:=0, offY:=0) {
    If !InStr(PointsList, "|")
       Return

    newShape := []
    ; newArrayu := new hashtable()
    ogmX := ogmY := 0
    Loop, Parse, PointsList, |
    {
       c := StrSplit(A_LoopField, ",")
       ogmX := c[1]
       ogmY := c[2]
       If (ogmX="" || ogmY="") ; || newArrayu[ogmX ogmY]=1)
          Continue

       thisIndex++
       ; newArrayu[ogmX ogmY] := 1
       newShape[thisIndex] := [ogmX + offX, ogmY + offY]
    }

    customShapeCountPoints := thisIndex
    ; fnOutputDebug(A_ThisFunc "=" thisIndex "=" ogmX "=" ogmY "n" FillAreaCurveTension "=" tensionCurveCustomShape)
    If (newShape.Count()<3)
       Return

    Return newShape
}

convertShapePointsViewerToEditPoints(PointsList, totalz) {
    newShape := []
    If IsObject(PointsList)
    {
       Loop, % totalz
       {
          getVectorCoordsFromVPpoint(PointsList[A_Index*2 - 1], PointsList[A_Index*2], gmX, gmY)
          newShape[A_Index] := [gmX, gmY]
       }
    } Else 
    {
       Loop, Parse, PointsList, |
       {
          c := StrSplit(A_LoopField, ",")
          If (c[1]="" || c[2]="") ; || newArrayu[ogmX ogmY]=1)
             Continue

          thisIndex++
          getVectorCoordsFromVPpoint(c[1], c[2], gmX, gmY)
          newShape[thisIndex] := [gmX, gmY]
       }

    }

    customShapeCountPoints := newShape.Count()
    ; fnOutputDebug(A_ThisFunc "=" thisIndex "=" ogmX "=" ogmY "n" FillAreaCurveTension "=" tensionCurveCustomShape)
    If (newShape.Count()<3)
       Return

    Return newShape
}

additionalHUDelements(mode, mainWidth, mainHeight, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0, directRefresh:=0) {
    Critical, on
    If (imgEditPanelOpened=1 && AnyWindowOpen!=10 && drawingShapeNow!=1)
    {
       If (vpImgPanningNow>0)
       {
          Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
          r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, 2NDglHDC)
          r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
       } Else livePreviewsImageEditing("coords")
    }
    ; fnOutputDebug(A_ThisFunc "(" mode ") sel y1=" imgSelY1 "// y2=" imgSelY2 " | " prcSelY1 " // " prcSelY2)
    Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
    If (dynamicLiveObjVisible=0)
       toggleLiveEditObject()

    setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
    ; If (showViewPortGrid=1)
    ;    drawVPgridsNow(mainWidth, mainHeight, 2NDglPG)
    If (drawingShapeNow=1)
       drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG)
    Else If (editingSelectionNow=1 && mode=2)
       drawImgSelectionOnWindow("prev", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=1)
       drawImgSelectionOnWindow("active", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=3)
       drawImgSelectionOnWindow("return", "-", "-", "-", mainWidth, mainHeight, prevResizedVPimgW, prevResizedVPimgH, prevDestPosX, prevDestPosY)

    If (AnyWindowOpen=64 && BrushToolType=3) || (AnyWindowOpen=23 && FillAreaColorMode=6) 
    || isVarEqualTo(AnyWindowOpen, 69, 44, 43, 26, 78, 81)
    {
       ImageCoords2Window(tinyPrevAreaCoordX, tinyPrevAreaCoordY, prevDestPosX, prevDestPosY, SelDotsSize, outX, outY)
       Gdip_FillRectangle(2NDglPG, pBrushE, outX, outY, SelDotsSize, SelDotsSize)
       Gdip_DrawRectangle(2NDglPG, pPen1d, outX, outY, SelDotsSize, SelDotsSize)
    }

    If (showImgAnnotations=1 && !AnyWindowOpen && drawingShapeNow!=1 && currentUndoLevel<3)
    {
       drawAnnotationBox(mainWidth, mainHeight, 2NDglPG)
    } Else
    {
       interfaceThread.ahkPostFunction("uiAccessUpdateAnnoBox", "hide", 1, 1, 0, 0)
       hasDrawnAnnoBox := 0
    }

    If (showInfoBoxHUD>=1 && drawingShapeNow!=1)
       drawinfoBox(mainWidth, mainHeight, directRefresh, 2NDglPG)
    Else
       interfaceThread.ahkPostFunction("uiAccessUpdateInfoBox", "hide", 1, 1, 0, 0)

    If (showHUDnavIMG=1 && IMGlargerViewPort=1 && slideShowRunning!=1)
    {
       VPnavBoxWrapper(mainWidth, mainHeight, 2NDglPG)
    } Else
    {
       interfaceThread.ahkPostFunction("uiAccessUpdateNavBox", "hide", 1, 1, 0, 0)
       hasDrawnImageMap := 0
    }

    thisThick := imgHUDbaseUnit//11
    Gdip_SetPenWidth(pPen4, thisThick)
    isSymmetryAllowed := (AnyWindowOpen=64 && BrushToolType<4 && liveDrawingBrushTool=1) || (drawingShapeNow=1 && !AnyWindowOpen) ? 1 : 0
    ccX := (drawingShapeNow=1) ? Round(vpSymmetryPointXdp) : prevDestPosX + Round(prevResizedVPimgW * BrushToolSymmetryPointX)
    ccY := (drawingShapeNow=1) ? Round(vpSymmetryPointYdp) : prevDestPosY + Round(prevResizedVPimgH * BrushToolSymmetryPointY)
    If ((BrushToolSymmetryX=1 || CustomShapeSymmetry=1) && isSymmetryAllowed=1)
       Gdip_DrawLine(2NDglPG, pPen4, ccX - thisThick/4, 0, ccX - thisThick/4, mainHeight)
    If ((BrushToolSymmetryY=1 || CustomShapeSymmetry=2) && isSymmetryAllowed=1)
       Gdip_DrawLine(2NDglPG, pPen4, 0, ccY - thisThick/4, mainWidth, ccY - thisThick/4)

    Gdip_ResetWorldTransform(2NDglPG)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectwin, 2NDglHDC)
}

toggleLiveEditObject(dummy:=0) {
   dynamicLiveObjVisible := !dynamicLiveObjVisible
   If (dummy="hide")
      dynamicLiveObjVisible := 1

   ;  TOOLTIP, % "l= " dynamicLiveObjVisible , , , 2
   actu := (dynamicLiveObjVisible!=1) ? "hide" : "show"
   ToggleVisibilityWindow(actu, hGDIselectwin)
   ToggleVisibilityWindow(actu, hGDIwin)
   If (actu="hide")
   {
      trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
      r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectwin, 2NDglHDC)
   }
}

getColorMatrix() {
    Static prevMatrix, prevState

    thisState := "a" ForceNoColorMatrix AnyWindowOpen imgFxMode bwDithering lumosGrayAdjust GammosGrayAdjust lumosAdjust GammosAdjust satAdjust IntensityAlphaChannel chnRdecalage chnGdecalage chnBdecalage
    If (thisState=prevState)
       Return prevMatrix

    matrix := ""
    fraction := (isWinXP=1) ? 0.0001 : 0
    If (ForceNoColorMatrix=1 && AnyWindowOpen=10) || (imgFxMode=1)
       Return matrix

    If (imgFxMode=4 && !bwDithering)       ; grayscale
       matrix := GenerateColorMatrix(2, lumosGrayAdjust, GammosGrayAdjust + fraction, , IntensityAlphaChannel)
    Else If (imgFxMode=5)  ; grayscale R
       matrix := GenerateColorMatrix(3, , , , IntensityAlphaChannel)
    Else If (imgFxMode=6)  ; grayscale G
       matrix := GenerateColorMatrix(4, , , , IntensityAlphaChannel)
    Else If (imgFxMode=7)  ; grayscale B
       matrix := GenerateColorMatrix(5, , , , IntensityAlphaChannel)
    Else If (imgFxMode=8)  ; alpha channel
       matrix := GenerateColorMatrix(7)
    Else If (imgFxMode=9)  ; negative / invert
       matrix := GenerateColorMatrix(6, , , , IntensityAlphaChannel)
    Else If (imgFxMode=10)  ; sepia
       matrix := GenerateColorMatrix(8, , , , IntensityAlphaChannel)
    Else If (imgFxMode=2 || imgFxMode=3) ; personalized
       matrix := GenerateColorMatrix(1, lumosAdjust, GammosAdjust + fraction, satAdjust, IntensityAlphaChannel, chnRdecalage, chnGdecalage, chnBdecalage)

    prevMatrix := matrix
    prevState := thisState
    Return matrix
}

decideGDIPimageFX(ByRef matrix, ByRef imageAttribs, ByRef pEffect) {
    Static colorzFX := {1:0, 2:5, 3:6, 4:7, 5:8, 6:9, 7:11}
    infos := matrix := imageAttribs := pEffect := ""
    matrix := getColorMatrix()
    If (thumbsDisplaying=1 && (imgFxMode=3 || imgFxMode=8))
       matrix := ""
    ; ToolTip, % matrix , , , 2
    thisFXapplies := isVarEqualTo(imgFxMode, 2, 3, 4, 9, 10)
    mustCreateAttribs := (realGammos!=1 && imgThreshold=0 && !matrix) ? 0 : 1
    If (mustCreateAttribs=1 && ForceNoColorMatrix!=1 && imgFxMode>1)
    {
       imageAttribs := Gdip_CreateImageAttributes()
       Gdip_SetImageAttributesColorMatrix(matrix, imageAttribs)
       ; Gdip_SetImageAttributesWrapMode(imageAttribs, 3)
       If (imgThreshold>0 && thisFXapplies=1)
       {
          infos := "moreThanClrMatrix"
          Gdip_SetImageAttributesThreshold(imageAttribs, imgThreshold)
       }

       If (realGammos!=1 && thisFXapplies=1)
       {
          infos := "moreThanClrMatrix"
          Gdip_SetImageAttributesGamma(imageAttribs, realGammos)
       }
    }

    If (isWinXP=1)
       Return "a" thisFXapplies lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold thisZatAdjust mustCreateAttribs imgFxMode ForceNoColorMatrix matrix zatAdjust infos

    o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    thisZatAdjust := (imgFxMode=4 && !bwDithering && zatAdjust=0) ? -40 : zatAdjust
    If ((thisZatAdjust=0 && hueAdjust=0 && lummyAdjust=0) || !colorzFX[specialColorFXmode] || ForceNoColorMatrix=1)
       applyAdjusts := 0

    If (thisFXapplies=1 && applyAdjusts!=0 && o_bwDithering=0 && specialColorFXmode>1)
    {
       paramA := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXmode : hueAdjust
       paramB := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXchannel : thisZatAdjust
       If (colorzFX[specialColorFXmode]=1)
          paramB := 0

       pEffect := Gdip_CreateEffect(colorzFX[specialColorFXmode], paramA, paramB, lummyAdjust)
    }

    Return "a" paramA paramB infos thisFXapplies thisZatAdjust applyAdjusts o_bwDithering mustCreateAttribs getIDvpFX()
}

getIDvpFX() {
    Return "a" specialColorFXmode uiColorCurveFXchannel uiColorCurveFXmode lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold imgFxMode ForceNoColorMatrix zatAdjust satAdjust hueAdjust chnRdecalage chnGdecalage chnBdecalage IntensityAlphaChannel
}

testSelectOutsideImgEntirely(pBitmap) {
     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nimgSelX2 := max(imgSelX1, imgSelX2)
     nimgSelY2 := max(imgSelY1, imgSelY2)

     trGdip_GetImageDimensions(pBitmap, imgW, imgH)
     If (nimgSelX1<0)
        nimgSelX1 := 0
     If (nimgSelY1<0)
        nimgSelY1 := 0

     If (nimgSelX2<3)
        nimgSelX2 := 1
     If (nimgSelY2<3)
        nimgSelY2 := 1

     If (nimgSelX1>imgW - 3)
        nimgSelX1 := ImgW - 1
     If (nimgSelY1>ImgH - 3)
        nimgSelY1 := imgH - 1

     If (nimgSelX2>imgW)
        nimgSelX2 := imgW
     If (nimgSelY2>imgH)
        nimgSelY2 := imgH

     isOutside := 0
     imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     If (imgSelW<3 || imgSelH<3)
        isOutside := 1

     ; If (nimgSelX1<2 && nimgSelY1<2 && nimgSelX2<5 && nimgSelY2<5)
     ;    isOutside := 1

     ; If (nimgSelX1>ImgW-5 && nimgSelY1>imgH-5 && nimgSelX2>imgW && nimgSelY2>imgH)
     ;    isOutside := 1
     Return isOutside
}

ViewPortSelectionManageCoords(mainWidth, mainHeight, dpX, dpY, maxSelX, maxSelY, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, ByRef zImgSelX1, ByRef zImgSelY1, ByRef zImgSelX2, ByRef zImgSelY2, ByRef vPimgSelW, ByRef vPimgSelH, ByRef vPimgSelPx, ByRef vPimgSelPy) {
     If (LimitSelectBoundsImg=1)
     {
        capSelectionRelativeCoords()
        If (imgSelX1<0)
           imgSelX1 := 0
        If (imgSelY1<0)
           imgSelY1 := 0
 
        If (imgSelX2<2)
           imgSelX2 := 2
        If (imgSelY2<2)
           imgSelY2 := 2
     }

     objSel := []
     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nImgSelX2 := max(imgSelX1, imgSelX2)
     nImgSelY2 := max(imgSelY1, imgSelY2)
     If (LimitSelectBoundsImg=-1)
     {
        nImgSelX1 := clampInRange(nImgSelX1, -4, maxSelX + 2)
        nImgSelY1 := clampInRange(nImgSelY1, -4, maxSelY + 2)
        nImgSelX2 := clampInRange(nImgSelX2, -2, maxSelX + 4)
        nImgSelY2 := clampInRange(nImgSelY2, -2, maxSelY + 4)
     } Else If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     kimgSelRatio := Round(kimgSelW/kimgSelH, 2)
     If (LimitSelectBoundsImg!=1 && lockSelectionAspectRatio>1 && kimgSelRatio!=Round(desiredSelAspectRatio, 2) && desiredSelAspectRatio && !adjustingSelDotNow)
     {
        avgWH := min(kimgSelW, kimgSelH)
        nimgSelX2 := nimgSelX1 + Round(avgWH*desiredSelAspectRatio)
        nimgSelY2 := nimgSelY1 + avgWH
     }

     If !(viewportQPVimage.imgHandle)
     {
        Static maxul := 199000
        If (kimgSelW>maxul)
           nImgSelX2 := nImgSelX1 + maxul
        If (kimgSelH>maxul)
           nImgSelY2 := nImgSelY1 + maxul

        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        p := capIMGdimensionsFormatlimits("gdip", 0, kimgSelW, kimgSelH)
        nImgSelX2 := nImgSelX1 + kimgSelW
        nImgSelY2 := nImgSelY1 + kimgSelH
        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        If (kimgSelW>maxul)
           nImgSelX2 := nImgSelX1 + maxul
        If (kimgSelH>maxul)
           nImgSelY2 := nImgSelY1 + maxul
     }

     ; If (editingSelectionNow=1)
     ;    defineRelativeSelCoords(maxSelX, maxSelY)
     zImgSelX1 := nImgSelX1*zoomLevel
     zImgSelX2 := nImgSelX2*zoomLevel
     zImgSelY1 := nImgSelY1*zoomLevel
     zImgSelY2 := nImgSelY2*zoomLevel

     minSelSizu := SelDotsSize//2 
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<minSelSizu)
        vPimgSelW := minSelSizu

     If (vPimgSelH<minSelSizu)
        vPimgSelH := minSelSizu

     objSel.oSelW := Round(vPimgSelW)
     objSel.oSelH := Round(vPimgSelH)
     minSizu := SelDotsSize*2
     objSel.selSmall := (vPimgSelW<minSizu*1.55 || vPimgSelH<minSizu*1.55) ? 1 : 0
     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)
     objSel.oSelX := Round(vPimgSelPx)
     objSel.oSelY := Round(vPimgSelPy)
     objSel.mainW := mainWidth
     objSel.mainH := mainHeight
     ; fnOutputDebug(A_ThisFunc ": " vPimgSelPx "|" vPimgSelPy "=" dpX "|" dpY "=" vPimgSelW "|" vPimgSelH)
     If (LimitSelectBoundsImg!=-1)
     {
        imgSelLargerViewPort := (vPimgSelPx<2 && vPimgSelPy<2) && (vPimgSelPx + vPimgSelW>mainWidth - 2) && (vPimgSelPy + vPimgSelH>mainHeight - 2) ? 1 : 0
        imgSelOutViewPort := 0
     } Else ozpl := imgSelOutViewPort

     If (vPimgSelPx>mainWidth - minSizu)
     {
        vPimgSelPx := mainWidth - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy>mainHeight - minSizu)
     {
        vPimgSelPy := mainHeight - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPx + vPimgSelW<minSizu)
     {
        vPimgSelW := minSizu*2
        vPimgSelPx := -minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy + vPimgSelH<minSizu)
     {
        vPimgSelH := minSizu*2
        vPimgSelPy := -minSizu
        imgSelOutViewPort := 1
     }
     
     If (LimitSelectBoundsImg=-1)
        imgSelOutViewPort := ozpl

     vPimgSelPx := Round(vPimgSelPx)
     vPimgSelW := Round(vPimgSelW)
     vPimgSelPy := Round(vPimgSelPy)
     vPimgSelH := Round(vPimgSelH)
     zImgSelX1 := Round(zImgSelX1)
     zImgSelX2 := Round(zImgSelX2)
     zImgSelY1 := Round(zImgSelY1)
     zImgSelY2 := Round(zImgSelY2)

     If (LimitSelectBoundsImg!=-1)
     {
        dotsSize := SelDotsSize//2
        selDotX := vPimgSelPx - dotsSize
        selDotY := vPimgSelPy - dotsSize
        selDotX := vPimgSelPx - dotsSize
        selDotY := vPimgSelPy - dotsSize
        selDotAx := vPimgSelPx + vPimgSelW - dotsSize
        selDotAy := vPimgSelPy + vPimgSelH - dotsSize
        ; ToolTip, % "l=" vPimgSelPx "||" vPimgSelW "`n" selDotX "||" selDotAx , , , 2
        selDotBx := vPimgSelPx + vPimgSelW - dotsSize
        selDotBy := vPimgSelPy - dotsSize
        selDotCx := vPimgSelPx - dotsSize
        selDotCy := vPimgSelPy + vPimgSelH - dotsSize
        selDotDx := vPimgSelPx + vPimgSelW//2 - dotsSize
        selDotDy := vPimgSelPy + vPimgSelH//2 - dotsSize
        selDotMaX := vPimgSelPx + vPimgSelW//2 - dotsSize
        selDotMaY := vPimgSelPy - dotsSize
        selDotMbX := vPimgSelPx + vPimgSelW - dotsSize
        selDotMbY := vPimgSelPy + vPimgSelH//2 - dotsSize
        selDotMcX := vPimgSelPx + vPimgSelW//2 - dotsSize
        selDotMcY := vPimgSelPy + vPimgSelH - dotsSize
        selDotMdX := vPimgSelPx - dotsSize
        selDotMdY := vPimgSelPy + vPimgSelH//2 - dotsSize
        ; fnOutputDebug(A_ThisFunc ": " selDotAx + dotsSize "|" selDotAy + dotsSize "|" dpX "|" dpY)
        If (objSel.selSmall=1)
           selDotDx := selDotDy := selDotMaX := selDotMaY := selDotMbX := selDotMbY := selDotMcX := selDotMcY := selDotMdX := selDotMdY := -dotsSize*5

        objSel.ow := maxSelX,      objSel.oh := maxSelY
        objSel.sw := vPimgSelW,    objSel.sh := vPimgSelH
        objSel.sx := vPimgSelPx,   objSel.sy := vPimgSelPy
        If ((AnyWindowOpen=31 || AnyWindowOpen=24) && imgEditPanelOpened=1)
           prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY)
     }
     Return objSel
}

prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY) {
     If (LimitSelectBoundsImg=1)
     {
        If (previmgSelX1<0)
           previmgSelX1 := 0
        If (previmgSelY1<0)
           previmgSelY1 := 0
 
        If (previmgSelX2<2)
           previmgSelX2 := 2
        If (previmgSelY2<2)
           previmgSelY2 := 2
     }

     nImgSelX1 := min(previmgSelX1, previmgSelX2)
     nImgSelY1 := min(previmgSelY1, previmgSelY2)
     nimgSelX2 := max(previmgSelX1, previmgSelX2)
     nimgSelY2 := max(previmgSelY1, previmgSelY2)

     If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     zImgSelX1 := Round(nImgSelX1*zoomLevel)
     zImgSelX2 := Round(nImgSelX2*zoomLevel)
     zImgSelY1 := Round(nImgSelY1*zoomLevel)
     zImgSelY2 := Round(nImgSelY2*zoomLevel)
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<2)
        vPimgSelW := 2
     If (vPimgSelH<2)
        vPimgSelH := 2

     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)
     dotsSize := SelDotsSize
     prevSelDotX := vPimgSelPx - dotsSize//2
     prevSelDotY := vPimgSelPy - dotsSize//2
     prevSelDotAx := vPimgSelPx + vPimgSelW - dotsSize//2
     prevSelDotAy := vPimgSelPy + vPimgSelH - dotsSize//2
}

simpleFixBrokenBezierPath(ByRef PointsList, doa:=0) {
   ; auto-fix uneven paths
   PointsCount := PointsList.Count()
   r := mod(PointsCount//2, 3)
   xu := PointsList[PointsCount - 1], yu := PointsList[PointsCount]
   loops := (r=2) ? 2 : 1
   If (r=1 && doa=0)
      loops := 0

   Loop, % loops
      PointsList.Push(xu, yu)

   Return r
}

viewerAutoCloseOpenPath(ByRef PointsList, isClosed, bb:=0) {
   r := testIsBezierViewPathClosed(PointsList)
   ; ToolTip, % isClosed "|" r "||" bb , , , 2
   If (isClosed=1 && r=0)
   {
      thisIndex := PointsList.Count()//2 - 1
      xA := PointsList[1]
      yA := PointsList[2]
      PointsList.Push(xA, yA)
      loops := (PointsList.Count()//2 > 4) ? 2 : 1
      Loop, % loops
         PointsList.Push(xA, yA)

      ; ToolTip, %  thisIndex "=l=" PointsList.Count()//2 "`n" xA "==" yA , , , 2
      reflectGivenAnchorInAltPath(PointsList, 2, PointsList.Count()//2 - 1, 1)
      reflectGivenAnchorInAltPath(PointsList, thisIndex, thisIndex + 2, thisIndex + 1)
   } Else If (isClosed=0 && r=1)
   {
      loops := ((PointsList.Count()//2 - 2) >= 4) ? 3 : 2
      Loop, % loops * 2
         PointsList.Pop()

      While, (testIsBezierViewPathClosed(PointsList)=1)
      {
         loops := ((PointsList.Count()//2 - 2) >= 4) ? 3 : 2
         Loop, % loops * 2
            PointsList.Pop()

         If (A_Index>10)
            Break
      }
   }
}

createPathVectorCustomShape(ImgSelPath, ByRef PointsList, tension, isClosed, isBezier, zeroTension:=0, allowAutoFix:=1, allowCloseOpenAuto:=1) {
   If (allowAutoFix=1 && isBezier=1)
      r := simpleFixBrokenBezierPath(PointsList)

   If (allowCloseOpenAuto=1 && isBezier=1)
      viewerAutoCloseOpenPath(PointsList, isClosed)

   If (FillAreaCurveTension=4)
      tensionCurveCustomShape := 0.95
   Else If (FillAreaCurveTension=3)
      tensionCurveCustomShape := 0.5
   Else If (FillAreaCurveTension=2)
      tensionCurveCustomShape := 0.2
   Else
      tensionCurveCustomShape := 0.1
   ; ToolTip, % PointsList.Count() "==R" , , , 2
   If (isBezier=1)
      Gdip_AddPathBeziers(ImgSelPath, PointsList)
   Else If ((tension=1 || zeroTension=1) && isClosed=1)
      Gdip_AddPathPolygon(ImgSelPath, PointsList)
   Else If ((tension=1 || zeroTension=1) && isClosed=0)
      Gdip_AddPathLines(ImgSelPath, PointsList)
   Else If isClosed
      Gdip_AddPathClosedCurve(ImgSelPath, PointsList, tensionCurveCustomShape)
   Else
      Gdip_AddPathCurve(ImgSelPath, PointsList, tensionCurveCustomShape)
   Return 
}

InitHugeImgSelPath(advancedMode, imgW, imgH, shapeu:=0, angle:=0, keepBounds:=0) {
; this function should probably be deleted, it is the husk of createBitmapSelPath()
; to-do ; delete this ; check dependencies

   obju := []
   If !(editingSelectionNow=1 && testAllowSelInvert())
   {
      obju.x1 := 0,          obju.y1 := 0
      obju.x2 := imgW,       obju.y2 := imgH
      obju.imgSelW := imgW,  obju.imgSelH := imgH
      obju.imgZelW := imgW,  obju.imgZelH := imgH
      obju.bImgSelPx := 0,   obju.bImgSelPy := 0
      obju.bX1 := 0,         obju.bY1 := 0
      obju.bX2 := imgW,      obju.bY2 := imgH
      obju.bImgSelW := imgW, obju.bImgSelH := imgH
      Return obju
   }

   zW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   zH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   szW := (ImgSelX2>imgW) ? imgSelX2 - imgW : 0
   szH := (ImgSelY2>imgH) ? imgSelY2 - imgH : 0
   aX1 := (ImgSelX1<0) ? abs(ImgSelX1) : 0
   aY1 := (ImgSelY1<0) ? abs(ImgSelY1) : 0
   bmpW := zW - aX1 - szW
   bmpH := zH - aY1 - szH
   ; fnOutputDebug(A_ThisFunc ": bmpW=" bmpW "|" zW "|" aX1 "|" szW "|img=" imgW)
   ; fnOutputDebug(A_ThisFunc ": bmpH=" bmpH "|" zH "|" aY1 "|" szH "|img=" imgH)
   obju.imgZelW := bmpW
   obju.imgZelH := bmpH

   boundLess := validBMP(pBitmap) ? 0 : 1
   calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
   Y1 := imgH - imgSelPy
   Y2 := Y1 - imgSelH
   flipVars(Y1, Y2)
   obju.X1 := X1,   obju.Y1 := Y1
   obju.X2 := X2,   obju.Y2 := Y2
   obju.imgSelW := imgSelW,   obju.imgSelH := imgSelH

   calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
   Y1 := imgH - imgSelPy
   Y2 := Y1 - imgSelH
   flipVars(Y1, Y2)
   obju.bImgSelPx := imgSelPx
   obju.bImgSelPy := imgSelPy
   obju.bX1 := X1,   obju.bY1 := Y1
   obju.bX2 := X2,   obju.bY2 := Y2
   obju.bImgSelW := imgSelW,   obju.bImgSelH := imgSelH

   Return obju
}

createBitmapSelPath(advancedMode, imgW, imgH, shapeu:=0, angle:=0, keepBounds:=0) {
; function no longer used; it was rendered by InitHugeImgSelPath() and QPV_PrepareHugeImgSelectionArea()

   obju := []
   If !(editingSelectionNow=1 && testAllowSelInvert())
   {
      obju.x1 := 0,          obju.y1 := 0
      obju.x2 := imgW,       obju.y2 := imgH
      obju.imgSelW := imgW,  obju.imgSelH := imgH
      obju.imgZelW := imgW,  obju.imgZelH := imgH
      obju.bImgSelPx := 0,   obju.bImgSelPy := 0
      obju.bX1 := 0,         obju.bY1 := 0
      obju.bX2 := imgW,      obju.bY2 := imgH
      obju.bImgSelW := imgW, obju.bImgSelH := imgH
      Return obju
   }

   zW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
   zH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
   szW := (ImgSelX2>imgW) ? imgSelX2 - imgW : 0
   szH := (ImgSelY2>imgH) ? imgSelY2 - imgH : 0
   aX1 := (ImgSelX1<0) ? abs(ImgSelX1) : 0
   aY1 := (ImgSelY1<0) ? abs(ImgSelY1) : 0
   bmpW := zW - aX1 - szW
   bmpH := zH - aY1 - szH
   ; fnOutputDebug(A_ThisFunc ": bmpW=" bmpW "|" zW "|" aX1 "|" szW "|img=" imgW)
   ; fnOutputDebug(A_ThisFunc ": bmpH=" bmpH "|" zH "|" aY1 "|" szH "|img=" imgH)
   obju.imgZelW := bmpW
   obju.imgZelH := bmpH
   If (isImgSizeTooLarge(bmpW, bmpH) || EllipseSelectMode!=2 && advancedMode=0 || isVarEqualTo(shapeu, 0, 1, 3) && advancedMode=1)
      abandoned := 1

   If !abandoned
      pBitmap := trGdip_CreateBitmap(A_ThisFunc, bmpW, bmpH, "0x21808")
   ; ToolTip, % shapeu "|" abandoned "|" pBitmape , , , 2
   boundLess := validBMP(pBitmap) ? 0 : 1
   calcImgSelection2bmp(boundLess, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
   Y1 := imgH - imgSelPy
   Y2 := Y1 - imgSelH
   flipVars(Y1, Y2)
   obju.X1 := X1,   obju.Y1 := Y1
   obju.X2 := X2,   obju.Y2 := Y2
   obju.imgSelW := imgSelW,   obju.imgSelH := imgSelH

   calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
   Y1 := imgH - imgSelPy
   Y2 := Y1 - imgSelH
   flipVars(Y1, Y2)
   obju.bImgSelPx := imgSelPx
   obju.bImgSelPy := imgSelPy
   obju.bX1 := X1,   obju.bY1 := Y1
   obju.bX2 := X2,   obju.bY2 := Y2
   obju.bImgSelW := imgSelW,   obju.bImgSelH := imgSelH
   If !validBMP(pBitmap)
   {
      If !abandoned
         addJournalEntry(A_ThisFunc ": failed to create selection clip mask bitmap")
      Return obju
   }

   If (advancedMode=1)
      pPath := coreCreateFillAreaShape(-aX1, -aY1, zW, zH, shapeu, angle, keepBounds)
   Else
      pPath := createImgSelPath(-aX1, -aY1, zW, zH, EllipseSelectMode, VPselRotation, rotateSelBoundsKeepRatio, 0, 1, 1, innerSelectionCavityX, innerSelectionCavityY, 0)

   If (pPath!="")
   {
      Gz := Gdip_GraphicsFromImage(pBitmap)
      Gdip_GraphicsClear(Gz, "0xFF000000")
      brushu := Gdip_BrushCreateSolid("0xFFffFFff")
      r := Gdip_FillPath(Gz, brushu, pPath)
      Gdip_DeleteBrush(brushu)
      Gdip_DeleteGraphics(Gz)
      If r
      {
         addJournalEntry(A_ThisFunc ": failed to draw selection path for the clip mask")
         pBitmap := trGdip_DisposeImage(pBitmap, 1)
      } Else
      {
         Gdip_ImageRotateFlip(pBitmap, 6)  ; FreeImage bitmaps are bottom-up stored
         obju.alphaMaskGray := pBitmap
      }
   } Else
      addJournalEntry(A_ThisFunc ": failed to create selection path for the clip mask")

   Return obju
}

createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, ellipse, angleu:=0, keepBounds:=0, zeroTension:=0, allowSelectionCenter:=1, allowCavity:=1, selCavityX:=0, selCavityY:=0, allowErrMargin:=1) {
   ImgSelPath := Gdip_CreatePath()
   If (ImgSelPath="")
      Return

   tempPath := 0
   startZeit := A_TickCount
   If (ellipse=2)
   {
      PointsList := convertCustomShape2givenArea(customShapePoints, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, !bezierSplineCustomShape, bezierSplineCustomShape)
      If (!(FillAreaCurveTension=1 || zeroTension=1) || bezierSplineCustomShape=1 || allowErrMargin=2)
      {
         alreadySorted := 1
         tempPath := Gdip_CreatePath()
         Gdip_AddPathPolygon(tempPath, PointsList)
         If (angleu!=0)
            trGdip_RotatePathAtCenter(tempPath, angleu, 1, 1, keepBounds, 1)
         If (allowSelectionCenter>=1)
            vpFreeformShapeOffset := centerPath2bounds(tempPath, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 1, allowSelectionCenter)

         PointsList := Gdip_GetPathPoints(tempPath, 1)
         pp := Gdip_GetPathPointsCount(tempPath)
         zpp := (pp=customShapePoints.Count()) ? 0 : 1
         If (bezierSplineCustomShape=1 && testIsBezierAltViewPathClosed()=1 && closedLineCustomShape=1 && zpp=1)
            PointsList.Push(PointsList[1], PointsList[2])
      }

      createPathVectorCustomShape(ImgSelPath, PointsList, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape, 0, 1, 1)
      ; xp := Gdip_GetPathPointsCount(ImgSelPath)
      ; ToolTip, %  "l=" pp "|" xp "|" customShapePoints.Count() "|" apz , , , 2
   } Else If (ellipse=1)
   {
      Gdip_AddPathEllipse(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
   } Else
   {
      If (isVarEqualTo(angleu, 0, 90, 180, 270, 360) && allowErrMargin=1)
      {
         If (imgSelPx=0)
         {
            imgSelPx := -2
            imgSelW += 2
         }

         If (imgSelPy=0)
         {
            imgSelPy := -2
            imgSelH += 2
         }

         p := testEntireImgSelected()
         If (p=1)
         {
            imgSelW += 2
            imgSelH += 2
         }
      }

      Gdip_AddPathRectangle(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
   }

   If (viewportQPVimage.imgHandle && ellipse=2)
      allowCavity := 0

   If (angleu!=0 && alreadySorted!=1)
      trGdip_RotatePathAtCenter(ImgSelPath, angleu, 1, 1, keepBounds, 1)

   thisPath := (allowErrMargin=2) ? tempPath : 0
   If (ellipse=2)
      vpFreeformShapeOffset := centerPath2bounds(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH, thisPath, 1, allowSelectionCenter)

   If (selCavityX>0 && selCavityY>0 && allowCavity=1 && allowErrMargin!=2)
   {
      clonedPath := Gdip_ClonePath(ImgSelPath)
      Gdip_ScalePathAtCenter(clonedPath, selCavityX, selCavityY)
      Gdip_AddPathToPath(ImgSelPath, clonedPath, 0)
      Gdip_DeletePath(clonedPath)
   }
   ; Sleep, -1
   ; fnOutputDebug(A_ThisFunc "(): " A_TickCount - startZeit)
   If (allowErrMargin=2)
   {
      Gdip_DeletePath(ImgSelPath)
      Return tempPath
   } Else
   {
      Gdip_DeletePath(tempPath)
      Return ImgSelPath
   }
}

centerPath2bounds(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH, destinationPath:=0, scaleUniform:=1, doPrecise:=2) {
   ; resize to bounding box
   startZeit := A_TickCount
   Rect := getAccuratePathBounds(ImgSelPath, 0, doPrecise)
   pMatrix := Gdip_CreateMatrix()
   If (scaleUniform=1)
   {
      scaleu := min(imgSelW/Rect.w, imgSelH/Rect.h)
      Gdip_ScaleMatrix(pMatrix, scaleu, scaleu)
   } Else Gdip_ScaleMatrix(pMatrix, imgSelW/Rect.w, imgSelH/Rect.h)

   E := Gdip_TransformPath(ImgSelPath, pMatrix)
   If destinationPath
      E := Gdip_TransformPath(destinationPath, pMatrix)
   Gdip_DeleteMatrix(pMatrix)

   ; center to bounding box
   Rect := getAccuratePathBounds(ImgSelPath, 0, doPrecise)
   cX := imgSelPx + imgSelW/2
   cY := imgSelPy + imgSelH/2
   rX := Rect.x + Rect.w/2
   rY := Rect.y + Rect.h/2
   nX := max(cX, rX) - min(cX, rX)
   nY := max(cY, rY) - min(cY, rY)
   nX := (rX>cX) ? -nX : nX
   nY := (rY>cY) ? -nY : nY
   ; ToolTip, % nX "=" nY "|" scaleu , , , 2
   obju := []
   pMatrix := Gdip_CreateMatrix()
   obju := [nX, nY, scaleu, VPselRotation, innerSelectionCavityX, innerSelectionCavityY, EllipseSelectMode, FillAreaCurveTension, closedLineCustomShape, bezierSplineCustomShape]
   Gdip_TranslateMatrix(pMatrix, nX, nY)
   E := Gdip_TransformPath(ImgSelPath, pMatrix)
   If destinationPath
      E := Gdip_TransformPath(destinationPath, pMatrix)

   Gdip_DeleteMatrix(pMatrix)
   ; fnOutputDebug(A_ThisFunc "(): " A_TickCount - startZeit)
   ; RectE := getAccuratePathBounds(ImgSelPath)
   ; Gdip_GetPathLastPoint(ImgSelPath, zX, zY)
   ; obju := [nX, nY, scaleu, VPselRotation, RectE.x, RectE.y, RectE.w, RectE.h, zX, zY]
   Return obju
}

getAccuratePathBounds(pPath, doRound:=0, doPrecise:=0) {
   startZeit := A_TickCount
   If (doPrecise=21)
   {
      Gdip_ResetClip(dummyGu)
      Gdip_SetClipPath(dummyGu, pPath)
      Rect := Gdip_GetClipBounds(dummyGu)
      If (!Rect.w || !Rect.h)
         Rect := Gdip_GetPathWorldBounds(pPath)
   } Else
      Rect := Gdip_GetPathWorldBounds(pPath)

   If (doRound=1)
   {
      Rect.x := Round(Rect.x)
      Rect.y := Round(Rect.y)
      Rect.w := Round(Rect.w)
      Rect.h := Round(Rect.h)
   }
   ; fnOutputDebug(A_ThisFunc "( " doPrecise " ): " A_TickCount - startZeit)
   Return Rect
}

decideLiveSelectionBasedOnWindow(ByRef angleu, ByRef okay) {
   okay := (imgEditPanelOpened!=1 || isVarEqualTo(AnyWindowOpen, 10, 25, 55, 64, 66, 68, 74, 81, 89) || AnyWindowOpen=65 && EllipseSelectMode || AnyWindowOpen=23 && EllipseSelectMode) ? 1 : 0
   angleu := (okay=1) ? VPselRotation : 0
   If vpImgPanningNow
   {
      angleu := VPselRotation
      okay := 1
   }
}

drawImgSelectionOnWindow(operation, theMsg:="", colorBox:="", dotActive:="", mainWidth:=0, mainHeight:=0, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0, snappyX:=0, snappyY:=0) {
     Static prevMsg, infoBoxBMP, lineThickns, infoW, infoH
          , infoPosX, infoPosY, prevuDPx, prevuDPy, prevNewW, prevNewH

     SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
     If !identifyThisWin()
        SelDotsSize := dotsSize := dotsSize//2 + 1

     trGdip_GetImageDimensions(useGdiBitmap(), maxSelX, maxSelY)
     allowControls := (isNowAlphaPainting() || (liveDrawingBrushTool=1 && AnyWindowOpen=64) || (FloodFillSelectionAdj!=1 && AnyWindowOpen=66)) ? 0 : 1
     decideLiveSelectionBasedOnWindow(angleu, isAngleu)
     ; ForceRefreshNowThumbsList()
     If (operation="return" || operation="faker")
     {
        o_operation := operation
        operation := "active"
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        newW := prevNewW, newH := prevNewH
        ; DestPosX := prevuDPx, DestPosY := prevuDPy
        DestPosX := prevDestPosX, DestPosY := prevDestPosY
        ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
     }

     opacity := (operation="live") ? "0xAA" : "0x77"
     wPen := Gdip_CreatePen(opacity "CCccCC", imgHUDbaseUnit//14)
     dPen := Gdip_CreatePen(opacity "223322", imgHUDbaseUnit//6)
     zPen := Gdip_CreatePen(opacity "456345", imgHUDbaseUnit//9)
     redPen := Gdip_CreatePen("0xAAFF6600", imgHUDbaseUnit//7)
     If (operation="init")
     {
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
        If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
           clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIselectWin)

        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        ; Gdip_ResetWorldTransform(2NDglPG)
        setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
        InfoW := InfoH := ""
     } Else If (operation="prev")
     {
        ; i doubt this mode is ever called/invoked; too lazy to inspect and remove this
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)
        clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        objSel := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        If (objSel.selSmall=1)
           dotSize := dotSize/2

        ImgSelPath := VPcreateSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, angleu, isAngleu, mainWidth, mainHeight, 1)
        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
        Gdip_DrawPath(2NDglPG, wPen, ImgSelPath)
        Gdip_DrawPath(2NDglPG, dPen, ImgSelPath)
        Gdip_ResetClip(2NDglPG)
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)
     } Else If (operation="active")
     {
        startZeit := A_TickCount
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        Gdip_SetPenWidth(pPen1d, imgHUDbaseUnit//9)
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)
        objSel.selSmall := ViewPortSelectionManageCoords(mainWidth, mainHeight, DestPosX, DestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 
        If (objSel.selSmall=1)
           dotSize := dotSize/2

        tooBig := (imgSelW>mainWidth*1.5 && imgSelH>mainHeight*1.5 || imgSelW>mainWidth*2.5 || imgSelH>mainHeight*2.5) ? 1 : 0
        If (o_operation!="faker")
        {
           ImgSelPath := VPcreateSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, angleu, isAngleu, mainWidth, mainHeight, 1)
           If (showSelectionGrid=1 && imgSelLargerViewPort!=1 && tooBig!=1)
           {
              Sleep, 1
              Gdip_SetClipPath(2NDglPG, ImgSelPath, 0)
              pathBounds := Gdip_GetClipBounds(2NDglPG)
              Gdip_ResetClip(2NDglPG)
           }

           Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
           If !AnyWindowOpen
              Gdip_FillPath(2NDglPG, pBrushF, ImgSelPath)
           Gdip_DrawPath(2NDglPG, dPen, ImgSelPath)
           Gdip_DrawPath(2NDglPG, wPen, ImgSelPath)
           If (allowControls=1)
           {
              thisu := clampValuesToWindow(imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight)
              Gdip_DrawRectangle(2NDglPG, zPen, thisu.X, thisu.Y, thisu.W, thisu.H)
           }

           If (imgEditPanelOpened!=1 && showSelectionGrid=1 && allowControls=1 && imgSelLargerViewPort!=1 && tooBig!=1)
              Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)
        }

        If ((showSelectionGrid=1) || (imgSelLargerViewPort=1 && allowControls=1)) && (o_operation!="faker")
        {
           If (imgSelLargerViewPort=1)
           {
              ; Gdip_DrawRectangle(2NDglPG, whichPen, 1, 1, mainWidth - 1, mainHeight - 1)
              Gdip_DrawRectangle(2NDglPG, dPen, mainWidth*0.15, mainHeight*0.15, mainWidth - mainWidth*0.3, mainHeight - mainHeight*0.3)
              Gdip_DrawRectangle(2NDglPG, pPen1d, mainWidth*0.15, mainHeight*0.15, mainWidth - mainWidth*0.3, mainHeight - mainHeight*0.3)
           }

           thisu := clampValuesToWindow(imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight)
           Gdip_SetClipRect(2NDglPG, thisu.X, thisu.Y, thisu.W, thisu.H)
           thisu := clampValuesToWindow(imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000, mainWidth, mainHeight)
           Gdip_DrawRectangle(2NDglPG, zPen, thisu.X, thisu.Y, thisu.W, thisu.H)
           thisu := clampValuesToWindow(imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2, mainWidth, mainHeight)
           Gdip_DrawRectangle(2NDglPG, zPen, thisu.X, thisu.Y, thisu.W, thisu.H)
        }

        Gdip_ResetClip(2NDglPG)
        If (FlipImgV=1)
           imgSelPy := mainHeight - imgSelPy - imgSelH
        If (FlipImgH=1)
           imgSelPx := mainWidth - imgSelPx - imgSelW

        partialCtrls := isFreeHandModus(0)
        If (imgSelLargerViewPort!=1 && allowControls=1 && o_operation!="faker")
        {
           whichFunc := (VPselRotation!=0) ? "Ellipse" : "Rectangle"
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
           If (partialCtrls!=1)
           {
              Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
              Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
           }

           If ((AnyWindowOpen=31 || AnyWindowOpen=24) && objSel.selSmall!=1 && !viewportQPVimage.imgHandle)
           {
              Gdip_FillEllipse(2NDglPG, pBrushD, selDotMdX, selDotMdY, dotsSize, dotsSize)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotMaX, SelDotMaY, dotsSize, dotsSize)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotMbX, SelDotMbY, dotsSize, dotsSize)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotMcX, SelDotMcY, dotsSize, dotsSize)
           }

           Gdip_Draw%whichFunc%C(2NDglPG, zPen, selDotX + dotsSize//2, selDotY + dotsSize//2, dotsSize//2 + 1)
           Gdip_Draw%whichFunc%C(2NDglPG, zPen, SelDotAx + dotsSize//2, SelDotAy + dotsSize//2, dotsSize//2 + 1)
           If (partialCtrls!=1)
           {
              Gdip_Draw%whichFunc%C(2NDglPG, zPen, SelDotBx + dotsSize//2, SelDotBy + dotsSize//2, dotsSize//2 + 1)
              Gdip_Draw%whichFunc%C(2NDglPG, zPen, SelDotCx + dotsSize//2, SelDotCy + dotsSize//2, dotsSize//2 + 1)
           }
        }

        If (allowControls=1 && o_operation!="faker" && objSel.selSmall!=1)
        {
           If (VPselRotation!=0)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)
           Gdip_FillEllipse(2NDglPG, pBrushE, SelDotDx, SelDotDy, dotsSize, dotsSize)
        }
        If ImgSelPath
           Gdip_DeletePath(ImgSelPath)
        ; ToolTip, % "a=" A_TickCount - startZeit , , , 2
     } Else If (operation="live")
     {
        Sleep, 1
        startZeit := A_TickCount
        Gdip_SetPenWidth(pPen1d, imgHUDbaseUnit//9)
        Gdip_GraphicsClear(2NDglPG, "0x00" WindowBGRcolor)
        objSel.selSmall := ViewPortSelectionManageCoords(mainWidth, mainHeight, prevuDPx, prevuDPy, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 
        If (objSel.selSmall=1)
           dotSize := dotSize/2

        ImgSelPath := VPcreateSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, angleu, isAngleu, mainWidth, mainHeight, 1)
        tooBig := (imgSelW>mainWidth*1.5 && imgSelH>mainHeight*1.5 || imgSelW>mainWidth*2.5 || imgSelH>mainHeight*2.5) ? 1 : 0
        If (imgSelLargerViewPort!=1 && tooBig!=1)
        {
           Gdip_SetClipPath(2NDglPG, ImgSelPath, 0)
           pathBounds := Gdip_GetClipBounds(2NDglPG)
        }

        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
        Gdip_DrawPath(2NDglPG, dPen, ImgSelPath)
        Gdip_DrawPath(2NDglPG, wPen, ImgSelPath)
        If (imgSelLargerViewPort!=1 && tooBig!=1)
        {
           ; ToolTip, lol , , , 2
           Gdip_DrawLine(2NDglPG, zPen, zImgSelX1 + prevDestPosX, 0, zImgSelX1 + prevDestPosX, mainHeight)
           Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY1 + prevDestPosY, mainWidth, zImgSelY1 + prevDestPosY)
           Gdip_DrawLine(2NDglPG, zPen, zImgSelX2 + prevDestPosX, 0, zImgSelX2 + prevDestPosX, mainHeight)
           Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY2 + prevDestPosY, mainWidth, zImgSelY2 + prevDestPosY)
        }
        ; ToolTip, % pathBounds.x "=" pathBounds.y "`n" pathBounds.w "=" pathBounds.h , , , 2
        If (imgSelLargerViewPort!=1 && tooBig!=1)
        {
           Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)
        } Else
        {
           thisu := clampValuesToWindow(imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight)
           Gdip_DrawRectangle(2NDglPG, pPen1d, thisu.X, thisu.Y, thisu.W, thisu.H)
        }

        thisu := clampValuesToWindow(prevuDPx, prevuDPy, prevResizedVPimgW, prevResizedVPimgH, mainWidth, mainHeight)
        Gdip_DrawRectangle(2NDglPG, pPen4, thisu.X, thisu.Y, thisu.W, thisu.H) ; image boundaries
        partialCtrls := isFreeHandModus(0)
        If (imgSelW>175 && imgSelH>175 && imgSelLargerViewPort!=1 && minimizeMemUsage!=1 && dotActive<9 && !InStr(theMsg, "offset") && !viewportQPVimage.imgHandle && partialCtrls!=1)
        {
           cornersPreview := coreCaptureImgCorners(useGdiBitmap(), 6, 100)
           trGdip_GetImageDimensions(cornersPreview, cImgW, cImgH)
           cX := imgSelPx + imgSelW//2 - cImgW//2
           cY := imgSelPy + imgSelH//2 - cImgH//2
           cX := clampInRange(cX, 0, mainWidth - cImgW)
           cY := clampInRange(cY, 0, mainHeight - cImgH)
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, cornersPreview, cX, cY)
           trGdip_DisposeImage(cornersPreview, 1)
        } Else If (objSel.selSmall!=1)
        {
           Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)
           Gdip_FillEllipse(2NDglPG, pBrushE, SelDotDx, SelDotDy, dotsSize, dotsSize)
        }

        If (minimizeMemUsage!=1)
        {
            If (dotActive=10)
            {
               theMsg := SubStr(theMsg, InStr(theMsg, "rotation"))
               fScale := 0.9
            } Else fScale := 1.3

           infoBoxBMP := drawTextInBox(theMsg, OSDFontName, OSDfontSize//fScale, mainWidth//2, mainHeight//2, OSDtextColor, OSDbgrColor, 1, 1)
           colorBoxH := colorBox ? imgHUDbaseUnit//7 : 1
           trGdip_GetImageDimensions(infoBoxBMP, infoW, infoH)
           If (imgSelLargerViewPort!=1 && dotActive!=9)
           {
              If (imgSelPy + imgSelH + 5 < mainHeight - infoH)
              {
                 infoPosY := (imgSelPy + imgSelH<5) ? 5 : imgSelPy + imgSelH + 20
                 If (infoPosY + infoH + colorBoxH>mainHeight)
                    infoPosY := mainHeight - infoH - colorBoxH
              } Else
              {
                 otherPos := 1
                 infoPosY := (imgSelPy - infoH - colorBoxH <20) ? 5 : imgSelPy - infoH - colorBoxH - 20
                 If (infoPosY + infoH + colorBoxH>mainHeight)
                    infoPosY := mainHeight - infoH - colorBoxH
              }
    
              If (dotActive=4 || otherPos=1) && (dotActive!=3)
              {
                 infoPosX := imgSelPx  + imgSelW - infoW - 25
                 If (infoPosX + infoW>mainWidth)
                    infoPosX := mainWidth - infoW
              } Else
              { 
                 infoPosX := (imgSelPx<5) ? 5 : imgSelPx + 25
                 If (infoPosX + infoW>mainWidth)
                    infoPosX := mainWidth - infoW
              }
           } Else 
           {
              mouseu := 1
              GetMouseCoord2wind(PVhwnd, oinfoPosX, oinfoPosY)
              infoPosX := (FlipImgH=1) ? oinfoPosX - imgHUDbaseUnit//3 : oinfoPosX + imgHUDbaseUnit//3
              infoPosY := (FlipImgV=1) ? oinfoPosY - imgHUDbaseUnit//3 : oinfoPosY + imgHUDbaseUnit//3
              If (FlipImgV=1)
                 infoPosY := mainHeight - infoPosY
              If (FlipImgH=1)
                 infoPosX := mainWidth - infoPosX
           }

           If colorBox
           {
              pBr0 := Gdip_BrushCreateSolid(colorBox)
              Gdip_FillRectangle(2NDglPG, pBr0, infoPosX, infoPosY + infoH, infoW, colorBoxH)
              Gdip_DeleteBrush(pBr0)
           }
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, infoPosX, infoPosY,,,,,,, 0.97)
           infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        }

        If (dotActive=10)
        {
           ; draw line tracking mouse when in rotation mode
           If !mouseu
           {
              GetMouseCoord2wind(PVhwnd, infoPosX, infoPosY)
              If (FlipImgV=1)
                 infoPosY := mainHeight - infoPosY
              If (FlipImgH=1)
                 infoPosX := mainWidth - infoPosX
           }

           Gdip_DrawLine(2NDglPG, pPen3, imgSelPx + imgSelW//2, imgSelPy + imgSelH//2, infoPosX, infoPosY)
           Gdip_DrawLine(2NDglPG, pPen4, imgSelPx + imgSelW//2, imgSelPy + imgSelH//2, infoPosX, infoPosY)
        }
 
        If (showSelectionGrid=1 || imgSelLargerViewPort=1)
        {
           thisu := clampValuesToWindow(imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight)
           Gdip_SetClipRect(2NDglPG, thisu.X, thisu.Y, thisu.W, thisu.H)
           thisu := clampValuesToWindow(imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000, mainWidth, mainHeight)
           Gdip_DrawRectangle(2NDglPG, zPen, thisu.X, thisu.Y, thisu.W, thisu.H)
           thisu := clampValuesToWindow(imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2, mainWidth, mainHeight)
           Gdip_DrawRectangle(2NDglPG, zPen, thisu.X, thisu.Y, thisu.W, thisu.H)
           Gdip_ResetClip(2NDglPG)
        }

        If (imgSelLargerViewPort!=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushC, selDotX, selDotY, dotsSize, dotsSize)
           Gdip_FillRectangle(2NDglPG, pBrushC, SelDotAx, SelDotAy, dotsSize, dotsSize)
           If (partialCtrls!=1)
           {
              Gdip_FillRectangle(2NDglPG, pBrushC, SelDotBx, SelDotBy, dotsSize, dotsSize)
              Gdip_FillRectangle(2NDglPG, pBrushC, SelDotCx, SelDotCy, dotsSize, dotsSize)
           }
        }

        If (dotActive=9 && snappyX && snappyY)
        {
           thisThick := SelDotsSize//5 + 1
           sz := SelDotsSize * 5
           Gdip_SetPenWidth(pPen1d, thisThick)
           Gdip_DrawLine(2NDglPG, pPen1d, snappyX - sz, snappyY, snappyX + sz, snappyY)
           Gdip_DrawLine(2NDglPG, pPen1d, snappyX, snappyY - sz, snappyX, snappyY + sz)
        }

        If (dotActive=10)
           Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)

        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)
        ; ToolTip, % "br=" A_TickCount - startZeit , , , 2
        If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
        {
           r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
           livePreviewsImageEditing("live-selection")
        } Else r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
     } Else If (operation="end")
     {
        trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
        defineRelativeSelCoords(imgW, imgH)
        InfoW := InfoH := ""
        ; Gdip_ResetWorldTransform(2NDglPG)
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        Gdip_ResetWorldTransform(2NDglPG)
        SetTimer, dummyRefreshImgSelectionWindow, -25
     }

     Gdip_DeletePen(zPen)
     Gdip_DeletePen(wPen)
     Gdip_DeletePen(dPen)
     Gdip_DeletePen(redPen)
} ; // drawImgSelectionOnWindow()

dummyRefreshImgSelectionWindow(mm:=0) {
     Static prevStatus, loopsOccured := 0
     If (thumbsDisplaying=1)
        Return

     If (editingSelectionNow=1 && IMGresizingMode=5)
     {
        thisu := 1
        IMGresizingMode := 1
        interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
     }

     ; ToolTip, % "l=" drawingShapeNow "==" editingSelectionNow "==" drawingVectorLiveMode , , , 2
     If (drawingShapeNow!=1 && imgSelX2=-1 && imgSelY2=-1 && editingSelectionNow=1) || (thisu=1)
     {
        dummyTimerDelayiedImageDisplay(25)
        Return
     }

     vpWinClientSize(mainWidth, mainHeight)
     If (drawingShapeNow=1)
        GetMouseCoord2wind(PVhwnd, mX, mY)

     thisState := "a" mX mY mainWidth mainHeight closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape customShapePoints.Count() lastZeitFileSelect imgSelX1 imgSelY1 imgSelX2 imgSelY2 BrushToolSymmetryX BrushToolSymmetryY BrushToolSymmetryPointX BrushToolSymmetryPointY customShapeHasSelectedPoints showNewVectorPointPreview vpGridSize showViewPortGrid bezierSplineCustomShape showContextualStatusBar CustomShapeSymmetry CustomShapeLockedSymmetry FillAreaCurveTension
     If (thisState!=prevStatus || drawingShapeNow!=1 || mm="forced")
     {
        loopsOccured++
        ; ToolTip, % loopsOccured "==" thisState " -- " A_TickCount , , , 2
        additionalHUDelements(3, mainWidth, mainHeight)
        prevStatus := thisState
     }
}

drawVPpartialIMGsection(brickVPx, brickVPy, brickVPw, brickVPh, DestPosX, DestPosY, newW, newH, whichBitmap, Gu, dpX, dpY, kW, kH, imageAttribs, clrMatrix, pEffect, rImgW, rImgH, thisUSRimgQuality, simpleMode:=0) {
    MouseCoords2Image(brickVPx, brickVPy, 1, DestPosX, DestPosY, newW, newH, brickIMGx, brickIMGy, whichBitmap, 0, rimgW, rimgH)
    MouseCoords2Image(brickVPx + brickVPw, brickVPy + brickVPh, 1, DestPosX, DestPosY, newW, newH, brickIMGxz, brickIMGyz, whichBitmap, 0, rimgW, rimgH)
    brickIMGw := brickIMGxz - brickIMGx
    brickIMGh := brickIMGyz - brickIMGy
    If (simpleMode=1)
       Return trGdip_DrawImage(A_ThisFunc, Gu, whichBitmap, brickVPx, brickVPy, brickVPw, brickVPh, brickIMGx, brickIMGy, brickIMGw, brickIMGh, clrMatrix, 2, imageAttribs)

    ; kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, brickIMGx, brickIMGy, brickIMGw, brickIMGh, 0, 0, 1, 0)
    If (brickVPx<dpX)
    {
       brickVPw -= dpX - brickVPx
       brickVPx := dpX
    }

    If (brickVPy<dpY)
    {
       brickVPh -= dpY - brickVPy
       brickVPy := dpY
    }

    If (brickVPw + brickVPx>kW + dpX)
       brickVPw -= brickVPw + brickVPx - (kW + dpX)
    If (brickVPh + brickVPy>kH + dpY)
       brickVPh -= brickVPh + brickVPy - (kH + dpY)

    totalVPsize := Round((brickVPw * brickVPh)/1000000)
    totalIMGsize := Round((brickIMGw * brickIMGh)/1000000)
    If (brickVPw>0 && brickVPh>0) && (brickIMGw>0 && brickIMGh>0)
    {
       thisQuality := (thisUSRimgQuality=1) ? 7 : 5
       kBitmap := trGdip_CloneBitmapArea(A_ThisFunc, whichBitmap, brickIMGx, brickIMGy, brickIMGw, brickIMGh, "0xE200B")
       If (validBMP(kBitmap) && (totalIMGsize + 2>totalVPsize) && imageAttribs)
       {
          zBitmap := trGdip_ResizeBitmap(A_ThisFunc, kBitmap, brickVPw, brickVPh, 0, thisQuality, -1)
          If validBMP(zBitmap)
             kBitmap := trGdip_DisposeImage(kBitmap)
       }
       aBmp := validBMP(zBitmap) ? zBitmap : kBitmap
       If (pEffect && validBMP(aBmp))
          Gdip_BitmapApplyEffect(aBmp, pEffect)
    }

    If (validBMP(zBitmap) || validBMP(kBitmap))
    {
       If validBMP(zBitmap)
       {
          r1 := trGdip_DrawImage(A_ThisFunc, Gu, zBitmap, brickVPx, brickVPy, brickVPw, brickVPh, 0, 0, brickVPw, brickVPh, clrMatrix, 2, imageAttribs)
          trGdip_DisposeImage(zBitmap)
       } Else
       {
          r1 := trGdip_DrawImage(A_ThisFunc, Gu, kBitmap, brickVPx, brickVPy, brickVPw, brickVPh, 0, 0, brickIMGw, brickIMGh, clrMatrix, 2, imageAttribs)
          trGdip_DisposeImage(kBitmap)
       }
    }
    ; ToolTip, % brickVPx "=" brickVPy "`n" brickVPw "==" brickVPh , , , 2
}

QPV_ShowImgonGui(newW, newH, mainWidth, mainHeight, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged) {
    Critical, on
    Static IDviewPortCache, PREVtestIDvPcache, prevImgAlphaChn, prevVPcacheIMGid, lastZeitLowQuality, prevDelayu
         , prevVPcachePos, prevVPcacheZoom :=[], prevVPcacheHadpartialFX, prevVPcacheIDfx, prevNewW, prevNewH

    prevLoadedImageIndex := currentFileIndex
    createGDIPcanvas(mainWidth, mainHeight)
    If (CountGIFframes>1 && !AnyWindowOpen && animGIFsSupport=1 && prevAnimGIFwas!=imgPath)
       mustPlayAnim := 1

    If (mustPlayAnim=1) || (IMGresizingMode=4 && allowFreeIMGpanning=1)
    {
       prevVPcacheZoom[1] := 0
       allowVPcacheOptimizations := 0
    } Else
    {
       DestroyGIFuWin()
       gdiSmallSize := determineGDIsmallCacheSize(mainWidth, mainHeight)
       totalNewSize := Round((newW * newH)/1000000, 2)
       If (IMGresizingMode=3 || zoomLevel=1)
          mustGenerate := 0
       Else If isInRange(totalNewSize, 0, gdiSmallSize.Small + 0.09)
          mustGenerate := 2
       Else If isInRange(totalNewSize, gdiSmallSize.Small + 0.08, gdiSmallSize.Screen + 2.1)
          mustGenerate := 1
       Else
          mustGenerate := 0

       If (mustGenerate=1) ; do not resize to screen size if it is already at screen size
          mustGenerate := (gdiSmallSize.Screen + 2.1<gdiSmallSize.Main + 1) || (gdiSmallSize.Screen//3>gdiSmallSize.Main) ? 1 : 0

       If (mustGenerate=1 && minimizeMemUsage=1 && usePrevious=1)
          mustGenerate := 2

       allowVPcacheOptimizations := (userimgQuality=1) ? 1 : 0
    }

    If (minimizeMemUsage=1 && usePrevious!=1 || mustPlayAnim=1 || allowVPcacheOptimizations=0)
       mustGenerate := 0

    mustGoIntoLowQuality := 0
    thisDelayu := (vpImgPanningNow=2 || sizeChanged=1) ? 950 : 400
    If (((A_TickCount - lastZeitLowQuality<thisDelayu + prevDelayu) || (drawModeAzeit>70 && mustPlayAnim=1 && desiredFrameIndex>1) || (usePrevious=1)) && (userimgQuality=1 && usePrevious!=2 && zoomLevel!=1) || (zoomLevel>5))
       mustGoIntoLowQuality := 1

    If ((mustPlayAnim=1 || imgEditPanelOpened=1 || drawingShapeNow=1 || paintBrushToolActive=1) && (userimgQuality=1))
       mustGoIntoLowQuality := 2

    If (mustGoIntoLowQuality=1 && minimizeMemUsage!=1 && mustGenerate=0 && usePrevious!=2 && mustPlayAnim!=1 && imgFxMode>1 && vpImgPanningNow!=2)
       forcedSmallSize := mustGenerate := 1

    ; allowVPcacheOptimizations := 0, mustGoIntoLowQuality := 1
    If !(viewportQPVimage.imgHandle)
    {
       If (liveDrawingBrushTool=1)
          whichBitmap := gdiBitmap
       Else If (mustGenerate=1) ; window size
          whichBitmap := RescaleBMPtinyVPsize(imgPath, mainWidth, mainHeight)
       Else If (mustGenerate=2) ; very small
          whichBitmap := RescaleBMPtiny(imgPath, mainWidth, mainHeight)
       Else ; original image
          whichBitmap := gdiBitmap
    } Else whichBitmap := gdiBitmap

    If !validBMP(whichBitmap)
       Return "invalid screen bitmap"

    sizeChanged := (prevNewW!=newW || prevNewH!=newH) ? 1 : 0
    prevNewW := newW, prevNewH := newH
    ; ToolTip, % "resized cache = " mustGenerate , , , 2
    interfaceThread.ahkassign("canCancelImageLoad", 0)
    startZeit := A_TickCount
    ; ToolTip, % oldZoomLevel "==" zoomLevel , , , 2
    oldZoomLevel := matrix := ""
    prevDrawingMode := 1
    thisVPpanningNow := (vpImgPanningNow=2) ? 1 : 0
    trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcIMGcoordsInVP(mainWidth, mainHeight, newW, newH, zoomLevel, IMGdecalageX, IMGdecalageY, DestPosX, DestPosY, IMGdecalageX, IMGdecalageY)
    If (!validBMP(ViewPortBMPcache) || mustPlayAnim=1)
    {
       thisVPpanningNow := diffuDestPosX := diffuDestPosY := 0
    } Else If (allowVPcacheOptimizations=1)
    {
       diffuDestPosX := diffIMGdecX ? DestPosX - prevDestPosX : 0   ; has panned on X
       diffuDestPosY := diffIMGdecY ? DestPosY - prevDestPosY : 0   ; has panned on Y
       If (Abs(diffuDestPosY)>mainHeight - 1) || (Abs(diffuDestPosX)>mainWidth - 1)
       {
          thisVPpanningNow := 0
          diffuDestPosX := diffuDestPosY := 0
          ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
       }
    }

    prevDestPosX := DestPosX
    prevDestPosY := DestPosY
    diffIMGdecX := diffIMGdecY := 0


    If (r := retrieveQPVscreenImgSection(DestPosX, DestPosY, mainWidth, mainHeight, newW, newH))
    {
       IDviewPortCache := PREVtestIDvPcache := prevVPcacheIMGid := ""
       prevVPcacheHadpartialFX := prevVPcacheIDfx := prevNewW := prevNewH := ""
       prevVPcachePos := "", prevVPcacheZoom := []
       Return r
    }

    ; calculate in viewport coords
    errMargin := (mustPlayAnim=1) ? 0 : 5
    dpX := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? DestPosX`: clampInRange(DestPosX, 0 - errMargin, mainWidth + errMargin*2)
    dpY := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? DestPosY`: clampInRange(DestPosY, 0 - errMargin, mainHeight + errMargin*2)
    kW := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? newW`: clampInRange(newW, 0 - errMargin, mainWidth + errMargin*2)
    kH := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? newH`: clampInRange(newH, 0 - errMargin, mainHeight + errMargin*4)
    ; If (kH<mainHeight)
       ; ToolTip, % "kWH = mWH = newWH`nW=" kW "=" mainWidth "=" newW "`nH=" kH "=" mainHeight "=" newH , , , 2
    errMargin := Ceil(zoomLevel + 1)
    If diffuDestPosX
    {
       ; calculate the new visible rect
       AdpX := (diffuDestPosX<0) ? diffuDestPosX + mainWidth - errMargin : -errMargin*1.5
       AdpX := clampInRange(AdpX, -errMargin*1.5, mainWidth)
       AkW := Abs(diffuDestPosX) + errMargin*2
       AkW := clampInRange(AkW, 0, mainWidth + errMargin*2)
    }

    If diffuDestPosY
    {
       ; calculate the new visible rect
       AdpY := (diffuDestPosY<0) ? diffuDestPosY + mainHeight - errMargin : -errMargin
       AdpY := clampInRange(AdpY, -errMargin, mainHeight)
       AkH := Abs(diffuDestPosY) + errMargin*2
       AkH := clampInRange(AkH, 0, mainHeight + errMargin*2)
    }

    thisUSRimgQuality := userimgQuality
    allowForceIMGload := (thisVPpanningNow=1) ? ForceIMGload : 0
    thisVPcacheIMGid := "a" gdiBitmap currentFileIndex imgPath allowForceIMGload whichBitmap desiredFrameIndex currentUndoLevel UserMemBMP undoLevelsRecorded
    thisVPcachePos := "a" newW newH zoomLevel allowForceIMGload DestPosX DestPosY thisVPcacheIMGid
    prevVPcacheIDfx := (AnyWindowOpen=74) ? "-" : decideGDIPimageFX(matrix, imageAttribs, pEffect)
    forceNoFXcaching := (thisVPcachePos=prevVPcachePos && prevVPcacheHadpartialFX=2 && thisVPpanningNow=0) ? 1 : 0
    thisThingMatrix := (IntensityAlphaChannel>1 && imgFxMode>=2 && imgFxMode!=8 && currIMGdetails.HasAlpha=1) ? 1 : 0
    isAlphaMaskMode := (currIMGdetails.HasAlpha=1 && imgFxMode=8 && ForceNoColorMatrix=0) ? 1 :0 
    thisImgAlphaChn := "a" IntensityAlphaChannel thisThingMatrix isAlphaMaskMode
    trGdip_GetImageDimensions(whichBitmap, rImgW, rImgH)
    ; ToolTip, % forceNoFXcaching "==" vpImgPanningNow "|" allowVPcacheOptimizations "`n" thisVPcachePos "`n" prevVPcachePos , , , 2
    If (thisVPcachePos!=prevVPcachePos || forceNoFXcaching=1 || !validBMP(ViewPortBMPcache) || thisImgAlphaChn!=prevImgAlphaChn || liveDrawingBrushTool=1)
    {
       If (mustGoIntoLowQuality>0)
       {
          lastZeitLowQuality := A_TickCount
          lastWasLowQuality := 1
          thisUSRimgQuality := 0
          Gdip_SetInterpolationMode(glPG, 5)
       }
 
       If (thisVPcacheIMGid!=prevVPcacheIMGid && thisVPpanningNow=0 || thisImgAlphaChn!=prevImgAlphaChn)
       {
          ; if the image has changed, no cached section must be used
          forceNoFXcaching := prevVPcacheHadpartialFX := AdpX := AdpY := diffuDestPosX := diffuDestPosY := 0
          ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
          prevVPcacheZoom[1] := 0
       }

       windowScreenMGPX := Ceil((mainWidth * mainHeight)/1000000)
       azW := prevVPcacheZoom[8] , azH := prevVPcacheZoom[9]
       prevIMGrectMGPX := Round((azW * azH)/1000000) - 1
       If (prevIMGrectMGPX<windowScreenMGPX//4.5 || liveDrawingBrushTool=1)        ; no need to slice and dice images when the rect we need is much smaller than the viewport
          hasPanned := thisVPpanningNow := AdpX := AdpY := diffuDestPosX := diffuDestPosY := 0

       Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
       ; ToolTip, % mainWidth "|" gdiBMPchanged , , , 2
       If (mustPlayAnim!=1 || gdiBMPchanged=1)
       {
          Gdip_SetClipRect(glPG, dpX + errMargin, dpY + errMargin, kW - errMargin*2, kH - errMargin*2, 4)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
          If (isAlphaMaskMode=1 || gdiBMPchanged=1)
          {
             Gdip_SetClipRect(glPG, dpX + errMargin, dpY + errMargin, kW - errMargin*2, kH - errMargin*2)
             Gdip_GraphicsClear(glPG, "0xFF000000")
          }
       } Else If (desiredFrameIndex=0 || gdiBMPchanged=1)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
       Gdip_ResetClip(glPG)

       ; errMargin := Ceil(zoomLevel*70) + 2
       If (currIMGdetails.HasAlpha=1 && imgFxMode!=8 && mustPlayAnim!=1)
       {
          ; draw image background - if it has an alpha channel
          hRgnB := Gdi_CreateRectRegion(dpX, dpY, dpX + kW, dpY + kH)
          Gdi_FillRegion(glHDC, hRgnB, useGdiHatchedBrush("vp"))
          Gdi_DeleteObject(hRgnB)
       }
       ; Gdip_GraphicsClear(glPG, "0xFf" WindowBgrColor)
       ; gp := Gdip_GetImagePixelFormat(ViewPortBMPcache, 2) 
       ; ToolTip, % gp , , , 2
       thisAllowed := (allowVPcacheOptimizations=1 || diffuDestPosX || diffuDestPosY) ? 1 : 0
       thisImageAttribs := (imageAttribs && ((forceNoFXcaching=0 && thisAllowed=1 && currIMGdetails.HasAlpha!=1) || (isAlphaMaskMode=1))) ? imageAttribs : 0
       clrMatrix := (thisImageAttribs=0 && IntensityAlphaChannel>1 && imgFxMode>1 && imgFxMode!=8 && currIMGdetails.HasAlpha=1) ? IntensityAlphaChannel : 1
       thisPeffect := (pEffect && forceNoFXcaching=0 && thisAllowed=1 && isAlphaMaskMode!=1) ? pEffect : 0
       If diffuDestPosX
       {
          ; resize and draw the new visible rect if panned on the X axis
          errMargin := (diffuDestPosX<0) ? Ceil(zoomLevel) : zoomLevel//2
          errMargin := errMargin//4
          drawVPpartialIMGsection(AdpX - errMargin, dpY, AkW + errMargin, kH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin*2, kH, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)
          prevVPcacheZoom[1] := 0
       }

       If diffuDestPosY
       {
          ; resize and draw the new visible rect if panned on the Y axis
          If !AdpX
             AdpX := 0

          tdpX := (diffuDestPosX<0) ? 0 : Round(AkW) + 1
          tdpW := (diffuDestPosX<0) ? tdpX - 2 : Round(AkW) + 2
          drawVPpartialIMGsection(dpX + tdpX, AdpY, kW - tdpW, AkH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW, kH, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)
          ; ToolTip, % tdpX "=" tdpW "`n" AkW "=" AkH "`n" AdpX "=" AdpY "`n" diffuDestPosX "=" diffuDestPosY, , , 2
          prevVPcacheZoom[1] := 0
       }
       ; ToolTip, % diffuDestPosX "==" diffuDestPosY "|" thisVPpanningNow , , , 2
       If ((diffuDestPosX || diffuDestPosY || thisVPpanningNow=1 && allowVPcacheOptimizations=1) && validBMP(ViewPortBMPcache))
       {
          ; draw the cached section on image panning

          ; Gdip_SetClipRect(glPG, diffuDestPosX - errX, diffuDestPosY - errY, mainWidth, mainHeight)
          hasPanned := 1
          thisuAttribs := (!diffuDestPosX && !diffuDestPosY) || (isAlphaMaskMode=1) ? 0 : thisImageAttribs
          thisuAttribs := (prevVPcacheHadpartialFX!=2 && (thisuAttribs || clrMatrix>1) && forceNoFXcaching=0) ? thisuAttribs : 0
          thisuClrMatrix := (prevVPcacheHadpartialFX!=2 && (thisuAttribs || clrMatrix>1) && forceNoFXcaching=0) ? clrMatrix : 1
          thisuEffectu := (!diffuDestPosX && !diffuDestPosY) || (isAlphaMaskMode=1) ? 0 : thisPeffect
          thisuEffectu := (prevVPcacheHadpartialFX!=2 && thisuEffectu && forceNoFXcaching=0) ? thisuEffectu : 0
          ; If (prevVPcacheHadpartialFX!=2 && (thisuAttribs || clrMatrix>1) && forceNoFXcaching=0)
          ; {
             brickIMGx := (diffuDestPosX<0) ? Abs(diffuDestPosX) : 0
             brickIMGy := (diffuDestPosY<0) ? Abs(diffuDestPosY) : 0
             brickVPx := (diffuDestPosX<0) ? 0 : Abs(diffuDestPosX)
             brickVPy := (diffuDestPosY<0) ? 0 : Abs(diffuDestPosY)
             brickIMGw := mainWidth - Abs(diffuDestPosX)
             brickIMGh := mainHeight - Abs(diffuDestPosY)
             If (brickIMGw && brickIMGh)
                kBitmap := trGdip_CloneBitmapArea(A_ThisFunc, ViewPortBMPcache, brickIMGx, brickIMGy, brickIMGw, brickIMGh, "0xE200B")

             If validBMP(kBitmap)
             {
                If thisuEffectu
                   Gdip_BitmapApplyEffect(kBitmap, thisuEffectu)

                r2 := trGdip_DrawImage(A_ThisFunc, glPG, kBitmap, brickVPx, brickVPy, brickIMGw, brickIMGh, 0, 0, brickIMGw, brickIMGh, thisuClrMatrix, 2, thisuAttribs)
                kBitmap := trGdip_DisposeImage(kBitmap, 1)
             }

             ; r2 := trGdip_DrawImage(A_ThisFunc, glPG, ViewPortBMPcache, diffuDestPosX, diffuDestPosY, mainWidth, mainHeight,,,,, thisuClrMatrix, 2, thisuAttribs)

          If (!diffuDestPosX && !diffuDestPosY)
          {
             Gdip_DisposeEffect(thisPeffect)
             Gdip_DisposeImageAttributes(thisImageAttribs)
             thisImageAttribs := thisPeffect := pEffect := imageAttribs := ""
          }
          ; ToolTip, % r2 "==" diffuDestPosX "==" diffuDestPosY "`n"  brickIMGx "=" brickIMGy "`n" brickIMGw "==" brickIMGh , , , 2
       }

       If (!diffuDestPosX && !diffuDestPosY && hasPanned!=1)
       {
          ; draw and calculate the image visible rect if image was not panned
          zX := prevVPcacheZoom[2] , zY := prevVPcacheZoom[3]
          zW := prevVPcacheZoom[4] , zH := prevVPcacheZoom[5]
          sameNess := (dpX=zX && dpY=zY && zW=kW && zH=kH && prevVPcacheZoom[11]=DestPosX && prevVPcacheZoom[12]=DestPosY) ? 1 : 0
          ; ToolTip, % "l=" sameNess "`n" DestPosX "==" DestPosY "`n" prevVPcacheZoom[11] "==" prevVPcacheZoom[12] , , , 2
          If ((sameNess=1 || prevVPcacheZoom[1]>zoomLevel) && (prevIMGrectMGPX>windowScreenMGPX//2) && IMGresizingMode=4 && validBMP(ViewPortBMPcache) && whichBitmap=gdiBitmap && allowVPcacheOptimizations=1)
          {
             ; on zoom out, reuse viewport cached image
             azX := prevVPcacheZoom[6] , azY := prevVPcacheZoom[7]
             ImageCoords2Window(azX, azY, DestPosX, DestPosY, 0, outXa, outYa, 0, 1)
             ImageCoords2Window(azX + azW, azY + azH, DestPosX, DestPosY, 0, outXb, outYb, 0, 1)
             errMargin := 0 ; Ceil(zoomLevel)
             If (thisUSRimgQuality=1)
                Gdip_SetInterpolationMode(glPG, 3)

             thisuAttribs := (prevVPcacheHadpartialFX!=2 && thisImageAttribs && forceNoFXcaching=0 && isAlphaMaskMode=0) ? thisImageAttribs : 0
             thisuEffectu := (prevVPcacheHadpartialFX!=2 && thisPeffect && forceNoFXcaching=0 && isAlphaMaskMode=0) ? thisPeffect : 0
             If thisuEffectu
             {
                thisBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
                If validBMP(thisBMP)
                   Gdip_BitmapApplyEffect(thisBMP, thisuEffectu)
             }
             aBmp := validBMP(thisBMP) ? thisBMP : ViewPortBMPcache
             r2 := trGdip_DrawImage(A_ThisFunc, glPG, aBmp, outXa - errMargin, outYa - errMargin, outXb - outXa + errMargin*2, outYb - outYa + errMargin*2, zX, zY, zW, zH, clrMatrix, 2, thisuAttribs)
             thisBMP := trGdip_DisposeImage(thisBMP)
             If (thisUSRimgQuality=1)
                Gdip_SetInterpolationMode(glPG, 7)

             If (prevVPcacheZoom[10]=1)
             {
                ; if the image is larger than the viewport, and user zooms out
                ; resize and draw only the newly visible image sections
                mX := 0, mY := 0
                mW := mainWidth, mH := mainHeight

                ; left side
                errMargin := (outXa>0) ? Ceil(zoomLevel) + 4 : 0
                drawVPpartialIMGsection(mX, mY, outXa + errMargin, mH + errMargin*2, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin*2, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)

                ; right side
                errMargin := Ceil(zoomLevel) + 4
                tW := mW - outXb, tH := mH
                tX := mW - tW, tY := mY
                tW := (tW>0) ? tW + errMargin*2 : 0
                tH := (tH>0) ? tH + errMargin*2 : 0
                If (tW>0)
                   tX -= errMargin
                drawVPpartialIMGsection(tX, tY, tW, tH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin*2, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)

                ; top side
                tW := mW - outXa - (mW - outXb), tH := outYa
                tX := outXa, tY := mY
                tH := (tH>0) ? tH + errMargin*2 : 0
                If (tH>0)
                   tY -= errMargin
                drawVPpartialIMGsection(tX, tY, tW, tH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)

                ; bottom side
                tW := mW - outXa - (mW - outXb)
                tH := mH - outYb
                tX := outXa, tY := outYb
                tH := (tH>0) ? tH + errMargin*2 : 0
                If (tH>0)
                   tY -= errMargin
                drawVPpartialIMGsection(tX, tY, tW, tH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW + errMargin, kH + errMargin, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality)
             } 

             ; ToolTip,  % zX "==" zY "`n" zW "==" zH "`n" azX "=" azY "`n" azW "=" azH "`n" outXa "==" outYa "`n" outXb "=" outYb , , , 2
          } Else If (thisVPpanningNow=0 || allowVPcacheOptimizations=0)
          {
             ; no cached sections reused
             If (thisUSRimgQuality=1 && whichBitmap!=gdiBitmap)
                Gdip_SetInterpolationMode(glPG, 3)

             thisModus := (thisPeffect || thisImageAttribs || thisUSRimgQuality=1 || allowFreeIMGpanning=1 && IMGresizingMode=4) ? 0 : 1
             ; ToolTip, % " not cached  = " thisModus "`n" dpX "=" dpY "`n" kW "=" kH , , , 2
             drawVPpartialIMGsection(dpX, dpY, kW, kH, DestPosX, DestPosY, newW, newH, whichBitmap, glPG, dpX, dpY, kW, kH, thisImageAttribs, clrMatrix, thisPeffect, rImgW, rImgH, thisUSRimgQuality, thisModus)
             If (thisUSRimgQuality=1 && whichBitmap!=gdiBitmap)
                Gdip_SetInterpolationMode(glPG, 7)
          }
       }

       dpX := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? DestPosX`: clampInRange(DestPosX, 0, mainWidth)
       dpY := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? DestPosY`: clampInRange(DestPosY, 0, mainHeight)
       kW := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? newW`: clampInRange(newW, 0, mainWidth)
       kH := (allowFreeIMGpanning=1 && IMGresizingMode=4) ? newH`: clampInRange(newH, 0, mainHeight)
       MouseCoords2Image(dpX, dpY, 0, DestPosX, DestPosY, newW, newH, sfPosX1, sfPosY1, whichBitmap, 0, rImgW, rImgH)
       MouseCoords2Image(dpX + kW, dpY + kH, 0, DestPosX, DestPosY, newW, newH, sfPosX2, sfPosY2, whichBitmap, 0, rImgW, rImgH)
       sfW := sfPosX2 - sfPosX1
       sfH := sfPosY2 - sfPosY1

       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
       ViewPortBMPcache := trGdip_CreateBitmapFromHBITMAP(A_ThisFunc, glHbitmap)
       prevVPcachePos := thisVPcachePos
       prevVPcacheIMGid := thisVPcacheIMGid
       zl := (IMGresizingMode=4 && !AdpX && !AdpY && whichBitmap=gdiBitmap) ? zoomLevel : 0
       prevVPcacheIDfx := thisVPcacheIDfx
       prevVPcacheHadpartialFX := thisImageAttribs ? 2 : 0
       prevImgAlphaChn := thisImgAlphaChn
       prevVPcacheZoom := [zl, dpX, dpY, kW, kH, sfPosX1, sfPosY1, sfW, sfH, IMGlargerViewPort, DestPosX, DestPosY]
       If (thisPeffect && pEffect)
       {
          Gdip_DisposeEffect(pEffect)
          pEffect := ""
       }

       If (thisImageAttribs && imageAttribs)
       {
          Gdip_DisposeImageAttributes(imageAttribs)
          imageAttribs := ""
       }

       wasVPcached := 0
    } Else
    {
       ; the entire image visible area is cached, recalculate colour effects if needed
       wasVPcached := 1
    }

    ; ToolTip, % "l=" r2 "=" kBitmap "=" ViewPortBMPcache "=" gdipLastError "=" glHbitmap , , , 2
    confirmTexBGR := isVarEqualTo(vpIMGrotation, 0, 90, 180, 270) && (usrTextureBGR=1 && gdiAmbientalTexBrush && (IMGentirelylargerThanVP!=1 || allowFreeIMGpanning=1 && IMGresizingMode=4)) ? 1 : 0
    If (FlipImgV=1 || FlipImgH=1 || pEffect || imageAttribs || wasVPcached=1)
    {
       ; redraw viewport with the activated FX
       If (prevVPcacheHadpartialFX=2 || isAlphaMaskMode=1)
       {
          ; ToolTip, llllllol , , , 2
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeImageAttributes(imageAttribs)
          imageAttribs := ""
          pEffect := ""
       }

       if (imageAttribs || pEffect)
       {
          ; ToolTip, nooooooooo , , , 2
          prevVPcacheHadpartialFX := 0
       }

       If ((imageAligned=1 || allowFreeIMGpanning=1 && imageAligned=5) && wasVPcached=0 && (FlipImgV=1 || FlipImgH=1))
       {
          If (allowFreeIMGpanning=0)
             Gdip_SetClipRect(glPG, dpX, dpY, kW, kH)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
          Gdip_ResetClip(glPG)
       }

       ; flipBitmapAccordingToViewPort(kBitmap, 1)
       setMainCanvasTransform(mainWidth, mainHeight)
       If (wasVPcached=1 && confirmTexBGR=0)
       {
          Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
          Gdip_SetClipRect(glPG, dpX, dpY, kW, kH, 4)
          Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
          Gdip_ResetClip(glPG)
       }

       If (pEffect && validBMP(ViewPortBMPcache))
       {
          thisBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          If validBMP(thisBMP)
             Gdip_BitmapApplyEffect(thisBMP, pEffect, dpX, dpY, kW, kH)

          Gdip_DisposeEffect(pEffect)
       }
       aBmp := validBMP(thisBMP) ? thisBMP : ViewPortBMPcache
       r2 := trGdip_DrawImage(A_ThisFunc, glPG, aBmp, dpX, dpY, kW, kH, dpX, dpY, kW, kH,,, imageAttribs)
       Gdip_DisposeImageAttributes(imageAttribs)
       thisBMP := trGdip_DisposeImage(thisBMP, 1)
    } Else Gdip_ResetClip(glPG)

    If (confirmTexBGR=1)
    {
       Gdip_ResetClip(glPG)
       hRgnA := Gdi_CreateRectRegion(0, 0, mainWidth, mainHeight)
       dpX := (FlipImgH=1 && imageAligned=1) ? mainWidth - kW : dpX
       dpY := (FlipImgV=1 && imageAligned=1) ? mainHeight - kH : dpY
       hRgnB := Gdi_CreateRectRegion(dpX, dpY, dpX + kW, dpY + kH)
       Gdi_CombineRegion(hRgnA, hRgnA, hRgnB, 3)
       Gdi_FillRegion(glHDC, hRgnA, gdiAmbientalTexBrush)
       Gdi_DeleteObject(hRgnA)
       Gdi_DeleteObject(hRgnB)
    }

    ; ToolTip, % confirmTexBGR "=" z "=" hRgnA "==" gdiAmbientalTexBrush , , , 2
    thisModus := (mustPlayAnim=0 && thisUSRimgQuality=0 && userimgQuality=1 && mustGoIntoLowQuality!=2) ? 2 : 1
    drawHUDelements(thisModus, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath)
    Gdip_ResetWorldTransform(glPG)
    If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && slideShowDelay>950 && validBMP(GDIfadeVPcache))
       imageHasFaded := performFadeTransition(imgPath, mustPlayAnim)

    whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
    r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC)
    If (imageHasFaded=1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, 2NDglHDC)

    If (mustPlayAnim=1 && !AnyWindowOpen)
    {
       ; setGIFframesDelay()
       autoChangeDesiredFrame("start", imgPath)
       SetTimer, autoChangeDesiredFrame, % GIFspeedDelay + UserGIFsDelayu
       If (mustRecordSeenImgs=1 && desiredFrameIndex=2 && gdiBMPchanged=1 && !InStr(r, "error"))
          recordSeenIMGdbEntry(imgPath, currentFileIndex)
    } Else
    {
       autoChangeDesiredFrame("stop")
       If (mustRecordSeenImgs=1 && gdiBMPchanged=1 && !InStr(r, "error"))
          recordSeenIMGdbEntry(imgPath, currentFileIndex)
    }

    totalZeit := A_TickCount - startZeitIMGload
    If (thisUSRimgQuality=0 && userimgQuality=1 && mustGoIntoLowQuality!=2)
    {
       lastWasLowQuality := 1
       If (usePrevious=0)
          lastZeitLowQuality := A_TickCount
       Gdip_SetInterpolationMode(glPG, 7)
       prevDelayu := (vpImgPanningNow=2 || hasPanned=1 || totalZeit>100 && hasPanned=1 || sizeChanged=1 || forcedSmallSize=1) ? 850 : 65
       SetTimer, wrapResizeImageGDIwin, % -prevDelayu
    } Else
    {
       prevDelayu := 50
       lastWasLowQuality := (mustGoIntoLowQuality=2) ? 1 : 0
    }

    ; Gdip_ResetClip(glPG)
    thisZeit := A_TickCount - startZeit
    If (totalZeit<155)
       prevFastDisplay := A_TickCount
    Else If (usePrevious!=2)
       lastZeitLowQuality := A_TickCount

    ; prevFullIMGload := A_TickCount
    LastWasFastDisplay := (totalZeit<150 && usePrevious<2) ? 1 : 0
    drawModeAzeit := A_TickCount - startZeit
    If (hasFullReloaded=1 && imageHasFaded!=1)
    {
       fullLoadZeit := A_TickCount - startZeitIMGload
       fullLoadZeit2 := (fullLoadZeit + drawModeCzeit)//2
       drawModeCzeit := max(fullLoadZeit, fullLoadZeit2)
    }
    ; ToolTip, % fullLoadZeit ", "  thisZeit ", " totalZeit ", " drawModeCzeit ,,,2
    Return r2 ? r2 : "error"
} ; // QPV_ShowImgonGui

performFadeTransition(imgPath, gifAnim) {
    Static prevImgPath
    If (gifAnim=1 && prevImgPath=imgPath)
       Return 0

    setWindowTitle(pVwinTitle, 1)
    ForceRefreshNowThumbsList()
    tempBMP := trGdip_CreateBitmapFromHBITMAP(A_ThisFunc, glHbitmap)
    trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
    ToggleVisibilityWindow("show", hGDIthumbsWin)
    trGdip_DrawImage(A_ThisFunc, glPG, GDIfadeVPcache)
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
    Loop, 255
    {
        opacity := 255 - A_Index*12
        If (opacity<2)
           Break

        dummyPos := (A_OSVersion!="WIN_7") ? 0 : ""
        r2 := UpdateLayeredWindow(hGDIwin, glHDC, dummyPos, dummyPos, mainWidth, mainHeight, opacity)
        If !r2
           Break
        Sleep, 1
    }

    trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
    trGdip_DisposeImage(tempBMP, 1)
    trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xFF" WindowBGRcolor)
    prevImgPath := imgPath
    Return 1
}

killQPVscreenImgSection() {
    coreCreateVPnavBox("kill")
    retrieveQPVscreenImgSection("kill", 0, 0, 0, 0, 0)
}

retrieveQPVscreenImgSection(DestPosX, DestPosY, mainWidth, mainHeight, newW, newH) {
   Static vpCacheBmp, prevState, wasEntireX := 0, wasEntireY := 0, prevZoom := 0, prevImgIDu := "", entireVpCacheBmp, entireVpCacheIDu
        , tdpX, tdpY, timgW, timgH

   If (DestPosX="kill")
   {
      vpCacheBmp := trGdip_DisposeImage(vpCacheBmp, 1)
      entireVpCacheBmp := trGdip_DisposeImage(entireVpCacheBmp, 1)
      entireVpCacheIDu := ""
      prevState := ""
      Return
   }

   If (DestPosX="last")
   {
      If validBMP(vpCacheBmp)
         Return [trGdip_CloneBitmap(A_ThisFunc, vpCacheBmp), tdpX, tdpY, timgW, timgH, wasEntireX, wasEntireY]
      Else
         prevState := vpCacheBmp := ""
      Return vpCacheBmp
   } Else If (DestPosX="last-entire")
   {
      If validBMP(entireVpCacheBmp)
         Return entireVpCacheBmp
      Else
         entireVpCacheIDu := entireVpCacheBmp := ""
      Return
   }

   If !(viewportQPVimage.imgHandle)
       Return 0

   Gdip_ResetClip(glPG)
   whichBitmap := useGdiBitmap()
   trGdip_GetImageDimensions(whichBitmap, rImgW, rImgH)
   dpX := clampInRange(DestPosX, 0, mainWidth)
   dpY := clampInRange(DestPosY, 0, mainHeight)
   kW := clampInRange(newW, 1, clampInRange(mainWidth - dpX, 1, mainWidth))
   kH := clampInRange(newH, 1, clampInRange(mainHeight - dpY, 1, mainHeight))

   MouseCoords2Image(dpX, dpY, 1, DestPosX, DestPosY, newW, newH, sfPosX1, sfPosY1, whichBitmap, 1, rImgW, rImgH)
   MouseCoords2Image(dpX + kW, dpY + kH, 1, DestPosX, DestPosY, newW, newH, sfPosX2, sfPosY2, whichBitmap, 1, rImgW, rImgH)
   If (newW<=mainWidth)
   {
      sfPosX1 := 0
      sfPosX2 := viewportQPVimage.Width
   } Else
   {
      sfPosX1 := snapToValues(sfPosX1, 0, viewportQPVimage.Width, 5, 0)
      sfPosX2 := snapToValues(sfPosX2, 0, viewportQPVimage.Width, 5, 0)
   }

   If (newH<=mainHeight)
   {
      sfPosY1 := 0
      sfPosY2 := viewportQPVimage.Height
   } Else
   {
      sfPosY1 := snapToValues(sfPosY1, 0, viewportQPVimage.Height, 5, 0)
      sfPosY2 := snapToValues(sfPosY2, 0, viewportQPVimage.Height, 5, 0)
   }

   ImageCoords2Window(sfPosX1, sfPosY1, DestPosX, DestPosY, 0.1, outX1, outY1, 1)
   ImageCoords2Window(sfPosX2, sfPosY2, DestPosX, DestPosY, 0.1, outX2, outY2, 1)
   kW := Round(outX2 - outX1)
   kH := Round(outY2 - outY1)
   sfW := sfPosX2 - sfPosX1
   sfH := sfPosY2 - sfPosY1
   If (sfW<10)
      sfW := 10
   If (sfH<10)
      sfH := 10

   If (kW<10)
      kW := 10
   If (kH<10)
      kH := 10

   If (newW>mainWidth)
      sfPosX1 := clampInRange(sfPosX1, 0, viewportQPVimage.Width - sfW - 1)
   If (newH>mainHeight)
      sfPosY1 := clampInRange(sfPosY1, 0, viewportQPVimage.Height - sfH - 1)

   sizeuX := (newW>mainWidth || wasEntireX!=1) ? "ax." sfPosX1 sfPosX2 kW sfW : "ax."
   sizeuY := (newH>mainHeight || wasEntireY!=1) ? "ay." sfPosY1 sfPosY2 kH sfH : "ay."
   imgIDu := viewportQPVimage.ImgFile "|" viewportQPVimage.imgHandle
   If (wasEntireX=1 && wasEntireY=1 && newW<=mainWidth && newH<=mainHeight && zoomLevel<=prevZoom && imgIDu=prevImgIDu)
   {
      sizeuX := "ax."
      sizeuY := "ay."
      prevState := "a" sizeuX "|" sizeuY "|" imgIDu "|" zoomLevel
      ; ToolTip, % wasEntireX "&" sizeu "`n" thisState "`nQ" prevState , , , 2
   }

   thisState := "a" sizeuX "|" sizeuY "|" imgIDu "|" zoomLevel
   If (thisState!=prevState || !validBMP(vpCacheBmp))
   {
      prevZoom := zoomLevel
      apx1 := (sfPosX1<5) ? 1 : 0
      apy1 := (sfPosY1<5) ? 1 : 0
      apx2 := (sfPosX2>viewportQPVimage.Width - 5) ? 1 : 0
      apy2 := (sfPosY2>viewportQPVimage.Height - 5) ? 1 : 0
      wasEntireX := (apx1=1 && apx2=1) ? 1 : 0
      wasEntireY := (apy1=1 && apy2=1) ? 1 : 0
      vpCacheBmp := trGdip_DisposeImage(vpCacheBmp, 1)
      otherIDu := imgIDu "|" mainWidth "|" mainHeight
      If (otherIDu=entireVpCacheIDu && wasEntireX=1 && wasEntireY=1 && (kW>mainWidth*0.85 || kH>mainHeight*0.85))
      {
         ; SoundBeep , 900, 100
         vpCacheBmp := trGdip_CloneBitmap(A_ThisFunc, entireVpCacheBmp)
      } Else 
      {
         vpCacheBmp := viewportQPVimage.ImageGetResizedRect(sfPosX1, sfPosY1, sfW, sfH, kW, kH, userimgQuality)
         If (wasEntireX=1 && wasEntireY=1 && (kW>mainWidth*0.85 || kH>mainHeight*0.85))
         {
            entireVpCacheBmp := trGdip_DisposeImage(entireVpCacheBmp, 1)
            entireVpCacheBmp := trGdip_CloneBitmap(A_ThisFunc, vpCacheBmp)
            entireVpCacheIDu := imgIDu "|" mainWidth "|" mainHeight
         }
      }
      ; ToolTip, % sfPosX1 "|" sfPosY1 "`n" sfW "|" sfH "`n" kW "|" kH , , , 2
      lolBMP := trGdip_CloneBitmap(A_ThisFunc, vpCacheBmp)
      sizeuX := (wasEntireX=1) ? "ax." : "ax." sfPosX1 sfPosX2 kW sfW
      sizeuY := (wasEntireY=1) ? "ay." : "ay." sfPosY1 sfPosY2 kH sfH
      prevState := "a" sizeuX "|" sizeuY "|" imgIDu "|" zoomLevel
      prevImgIDu := imgIDu
   } Else If validBMP(vpCacheBmp) 
      lolBMP := trGdip_CloneBitmap(A_ThisFunc, vpCacheBmp)

   If !validBMP(lolBMP)
      Return "error"

   Gdip_GraphicsClear(glPG)
   trGdip_GetImageDimensions(lolBMP, imgW, imgH)
   ; ToolTip, % sfPosX1 "/" sfPosY1 "`n" sfPosX2 "/" sfPosY2 "`n" imgW "/" imgH "`n" kW "/" kH "`n" sfW "/" sfH , , , 2

   lolBMP := applyVPeffectsOnBMP(lolBMP, 1)
   setMainCanvasTransform(mainWidth, mainHeight)
   ; ToolTip, % dpX "|" dpY "`n" DestPosX "|" DestPosY , , , 2
   tdpX := (DestPosX<=0 && newW<=mainWidth) ? DestPosX : dpX
   tdpY := (DestPosY<=0 && newH<=mainHeight) ? DestPosY : dpY
   ; timgW := (newW<=mainWidth) ? newW : imgW
   ; timgH := (newH<=mainHeight) ? newH : imgH
   timgW := min(newW, imgW)
   timgH := min(newH, imgH)
   ; ToolTip, % timgW "|" newW "|" imgW "|" mainWidth , , , 2
   If (currIMGdetails.HasAlpha=1 && imgFxMode!=8)
      Gdip_FillRectangle(glPG, GDIPbrushHatch, tdpX, tdpY, timgW, timgH)

   ; fnOutputDebug(A_ThisFunc ": " tdpX "|" tdpY "|" timgW "|" timgH)
   ; fnOutputDebug(A_ThisFunc ": " newH "|" mainHeight "|" dpY "|" DestPosY)
   tzGdip_DrawImage(glPG, lolBMP, tdpX, tdpY, timgW, timgH)
   trGdip_DisposeImage(lolBMP)

   ; thisModus := (mustPlayAnim=0 && thisUSRimgQuality=0 && userimgQuality=1 && mustGoIntoLowQuality!=2) ? 2 : 1
   drawHUDelements(1, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, viewportQPVimage.ImgFile)
   Gdip_ResetWorldTransform(glPG)
   whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
   r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC)
   If (imageHasFaded=1)
      r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, 2NDglHDC)

   ; ToolTip, % Round(sfW) "|" Round(sfH) "|" imgW "|" imgH  "=" rimgW "|" rimgH "??" kW "|" kH , , , 2
   ; ToolTip, yay , , , 2
   Return r2 ? r2 : "error"
}

getTabStopStyle(hwnd) {
  WinGet, Stylu, Style, ahk_id %hwnd%
  r := (Stylu & 0x10000) ? 0 : 1
  Return r
}

getCaptionStyle(hwnd) {
  WinGet, Stylu, Style, ahk_id %hwnd%
  r := (Stylu & 0xC00000) ? 0 : 1
  Return r
}

getTopMopStyle(hwnd) {
  WinGet, Stylu, ExStyle, ahk_id %hwnd%
  r := (Stylu & 0x8) ? 1 : 0
  Return r
}

updateUIctrl() {
   modus := (validBMP(UserMemBMP) || (maxFilesIndex>0 && CurrentSLD)) ? modus : "welcome"
   If (modus="welcome")
      interfaceThread.ahkPostFunction("uiAccessWelcomeView")
   Else
      interfaceThread.ahkPostFunction("updateUIctrlFromOutside", editingSelectionNow "|" isAlwaysOnTop "|" drawingShapeNow "|" IMGresizingMode)
}

coreSelectRandomFiles(howMany, a, b) {
   newArrayu := []
   a := clampInRange(a, 1, maxFilesIndex)
   b := clampInRange(b, 1, maxFilesIndex)
   maxu := max(a, b) - min(a, b)
   If (maxu<3)
      Return

   thisHowMany := clampInRange(howMany, 1, maxu)
   Loop
   {
      Random, Randy, %a%, %b%
      newArrayu[Randy] := 1
      If (newArrayu.Count()=thisHowMany)
         Break
   }

   For Key, Value in newArrayu
      resultedFilesList[Key, 2] := 1
}

selectRandomFiles(howMany, replaceAll, modus) {
   If (replaceAll=1)
      dropFilesSelection(1)

   If (modus=1)
   {
      coreSelectRandomFiles(howMany, 1, maxFilesIndex)
   } Else
   {
      thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
      Loop, % Ceil(maxFilesIndex / maxItemsPage)
         coreSelectRandomFiles(howMany, (A_Index - 1) * maxItemsPage, A_Index * maxItemsPage)
   }

   updateFilesSelectionInfos()
   dummyTimerReloadThisPicture(50)
}

updateFilesSelectionInfos(this:=-1) {
   lastZeitFileSelect := A_TickCount
   If (this=-1 || !isNumber(this))
      getSelectedFiles(0, 1)
   Else
      markedSelectFile := this

   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
}

PanelSelectRandomFiles() {
   Static a := 1, b := 5, dropListu := "Entire files list`f`fOn every page of thumbnails"

   fakeWinCreator(54, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Select random files: " appTitle, "Please specify how many files to select.", "&Apply|&Cancel", 1, "modify-entry", "Replace pre-existing selection", a, dropListu, "limit6 number", b)

   If InStr(msgResult.btn, "apply")
   {
      a := msgResult.check
      c := msgResult.list
      b := Trimmer(msgResult.edit)
      b := clampInRange(b, 2, maxFilesIndex - 2)
      selectRandomFiles(b, a, c)
      ; dummyTimerDelayiedImageDisplay(50)
   }
}

regroupSelectedFiles() {
   MenuMoveMarkedEntries() 
}

selectAllFiles() {
    ; Static selMode := 0
    If (maxFilesIndex<3)
       Return

    selMode := (markedSelectFile < maxFilesIndex || !markedSelectFile) ? 1 : 0
    Loop, % maxFilesIndex
        resultedFilesList[A_Index, 2] := selMode

    thid := (selMode=1) ? maxFilesIndex : 0
    updateFilesSelectionInfos(this)
    SetTimer, mainGdipWinThumbsGrid, -10
}

ToggleEditImgSelection(modus:=0) {
  Critical, on
  imgPath := getIDimage(currentFileIndex)
  If ((thumbsDisplaying=1) || (!validBMP(useGdiBitmap()) && !CurrentSLD) || !imgPath)
     Return

  If throwWarningAlphaPaintMode()
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  ; fnOutputDebug(A_ThisFunc "(A=" modus ") sel y1=" imgSelY1 "// y2=" imgSelY2 " | " prcSelY1 " // " prcSelY2)
  DestroyGIFuWin()
  If (editingSelectionNow!=1)
  {
     r := correctActiveSelectionAreaViewPort()
  } Else
  {
     trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
     If (!imgW || !imgH)
        r := -1
  }
  ; fnOutputDebug(A_ThisFunc "(B=" modus ") sel y1=" imgSelY1 "// y2=" imgSelY2 " | " prcSelY1 " // " prcSelY2)
  If (r=-1 && editingSelectionNow!=1)
     Return

  If (r!=-1)
     z = calcRelativeSelCoords(useGdiBitmap(), 0, 0)
  If (z=-1)
     Return

  ; If (getCaptionStyle(PVhwnd)=1)
  ;    ToggleTitleBaruNow()

  If (r!=-1 && editingSelectionNow=1)
     recordSelUndoLevelNow()

  ojk := editingSelectionNow
  editingSelectionNow := (modus="show-edit" && r!=-1) ? 1 : !editingSelectionNow
  If (AnyWindowOpen=12 || r=-1)
     EllipseSelectMode := 0

  liveDrawingBrushTool := (AnyWindowOpen=64 && editingSelectionNow=0) ? 1 : 0
  FloodFillSelectionAdj := (AnyWindowOpen=66 && editingSelectionNow=0) ? 0 : 1
  interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
  interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
  If (ShowAdvToolbar=1 && lockToolbar2Win=1 && editingSelectionNow=1)
     DelayiedImageDisplay()

  vpWinClientSize(mainWidth, mainHeight)
  If ((imgSelX2=-1 || ImgSelX2="C") && editingSelectionNow=1)
  {
     trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
     createDefaultSizedSelectionArea(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgW, imgH, mainWidth, mainHeight)
     ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, imgW, imgH, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
  }

  updateUIctrl()
  If (ShowAdvToolbar=1)
     decideIconBTNselectShape()

  clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
  If (modus="key" && editingSelectionNow=1)
     CreateTempGuiButton("Selection options,,invokeSelectionAreaMenu", 0, msgDisplayTime//1.5 + 500)

  If (modus="key" && !ojk && editingSelectionNow=1 && isSelEntireOutside())
     SetTimer, focusImgSelArea, -100
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(25)
}

throwWarningAlphaPaintMode() {
   If isNowAlphaPainting()
   {
      showTOOLtip("WARNING: You are currently in alpha mask painting mode.`nThe selection area cannot be altered.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }
}

selectEntireImage(act:=0) {
   imgPath := getIDimage(currentFileIndex)
   If ((thumbsDisplaying=1) || (!validBMP(useGdiBitmap()) && !CurrentSLD) || !imgPath)
      Return

   If throwWarningAlphaPaintMode()
      Return

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   pBitmap := useGdiBitmap()
   If !validBMP(pBitmap)
      Return -1

   trGdip_GetImageDimensions(pBitmap, imgW, imgH)
   If (!imgW || !imgH)
      Return -1

   If (editingSelectionNow=1)
      recordSelUndoLevelNow()

   vpts := (act="r") ? 0 : EllipseSelectMode
   vpr := (act="r") ? 0 : VPselRotation
   vpx := (act="r") ? 0 : innerSelectionCavityX
   vpy := (act="r") ? 0 : innerSelectionCavityY
   If (act="r")
      EllipseSelectMode := 0

   If (ShowAdvToolbar=1 && lockToolbar2Win=1)
      DelayiedImageDisplay()

   If (ImgSelX2=imgW && imgSelY2=imgH && imgSelX1=0
   && imgSelY1=0 && editingSelectionNow=1)
   {
      resetImgSelection()
      If (act="rm" && imgEditPanelOpened!=1)
         Return
   } Else
   {
      imgSelX1 := imgSelY1 := 0
      ImgSelX2 := imgW, imgSelY2 := imgH
      defineRelativeSelCoords(imgW, imgH)
   }

   VPselRotation := vpr
   EllipseSelectMode := vpts
   innerSelectionCavityX := vpx
   innerSelectionCavityY := vpy
   editingSelectionNow := 1
   interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
   updateUIctrl()
   clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   If (ShowAdvToolbar=1)
      decideIconBTNselectShape()
   ; SetTimer, MouseMoveResponder, -50
   SetTimer, dummyRefreshImgSelectionWindow, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

changeSelectZoom(direction, silent:=0) {
    If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
       Return

    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    If (direction=-1)
    {
       imgSelW -= Round(imgSelW*0.02)
       imgSelH -= Round(imgSelH*0.02)
       imgSelX1 += Round(imgSelW*0.01)
       imgSelY1 += Round(imgSelH*0.01)
    } Else
    {
       imgSelW += Round(imgSelW*0.02)
       imgSelH += Round(imgSelH*0.02)
       imgSelX1 -= Round(imgSelW*0.01)
       imgSelY1 -= Round(imgSelH*0.01)
    }

    imgSelX2 := Round(imgSelX1 + imgSelW)
    imgSelY2 := Round(imgSelY1 + imgSelH)

    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    defineRelativeSelCoords(imgW, imgH)
    If (silent=1)
    {
       dummyRefreshImgSelectionWindow()
    } Else
    {
       userFriendlyPrevImgSelAction:= (direction=-1) ? "SHRINK SELECTION AREA" : "ENLARGE SELECTION AREA"
       SetTimer, dummyRefreshImgSelectionWindow, -10
       SetTimer, dummyShowSelCoordsInfos, -25
    }
}

alignImgSelectCentered() {
   alignImgSelection(0)
   alignImgSelection(5)
}

alignImgSelectCenterV() {
   alignImgSelection(0)
}

alignImgSelectCenterH() {
   alignImgSelection(5)
}

alignImgSelectTop() {
   alignImgSelection(8)
}

alignImgSelectBottom() {
   alignImgSelection(2)
}

alignImgSelectLeft() {
   alignImgSelection(4)
}


alignImgSelectRight() {
   alignImgSelection(6)
}

alignImgSelectOutTop() {
   alignImgSelection(8, 1)
}

alignImgSelectOutBottom() {
   alignImgSelection(2, 1)
}

alignImgSelectOutLeft() {
   alignImgSelection(4, 1)
}

alignImgSelectOutRight() {
   alignImgSelection(6, 1)
}

MenuResetSelAreaCavityRotation() {
    If (thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If (innerSelectionCavityX>0 && innerSelectionCavityY>0)
       resetSelectionAreaCavity()
    Else
       resetSelectionRotation()
    SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

alignImgSelection(keyu, outside:=0) {
    static K := 0, listu := {0:"Center V.", 1:"Bottom-left", 2:"Bottom", 3:"Bottom-right", 4:"Left", 5:"Center H.", 6:"Right", 7:"Top-left", 8:"Top", 9:"Top-right"}
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
       Return

    If throwWarningAlphaPaintMode()
       Return

    IF (keyu="^NumpadAdd")
    {
       changeSelectZoom(1)
       Return
    } Else IF (keyu="^NumpadSub")
    {
       changeSelectZoom(-1)
       Return
    } Else IF (keyu="^NumpadDiv")
    {
       changeSelectionAreaCavity(-1)
       Return
    } Else IF (keyu="^NumpadMult")
    {
       changeSelectionAreaCavity(1)
       Return
    } Else IF (keyu="^NumpadDot")
    {
       MenuResetSelAreaCavityRotation()
       Return
    }

    k := StrReplace(keyu, "^Numpad")
    If isInRange(k, 0, 9)
       userFriendlyPrevImgSelAction := "ALIGNMENT: " Format("{:U}", listu[k])
    Else
       userFriendlyPrevImgSelAction := Format("{:U}", listu[k])

    If (k=5)
    {
       k := 4
       cX := 1
    } Else If (k=0)
    {
       k := 8
       cY := 1
    }

    If (outside=1)
    {
       PasteInPlaceAutoExpandIMG := 1
       LimitSelectBoundsImg := 0
       GuiControl, SettingsGUIA:, PasteInPlaceAutoExpandIMG, 1
       If (AnyWindowOpen=31 || AnyWindowOpen=24)
       {
          PasteInPlaceBlendMode := 1
          GuiControl, SettingsGUIA: Choose, PasteInPlaceBlendMode, 1
       }
    }

    timgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    timgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    wX := (k=3 || k=6 || k=9 || k="right") ? imgW - imgSelX2 : imgSelX1
    wY := (k=3 || k=2 || k=1 || k="down") ? ImgH - imgSelY2 : imgSelY1
    If (k=8 || k="up")
    {
       imgSelY1 -= wY
       imgSelY2 -= wY
       if (outside=1)
       {
          imgSelY1 -= timgSelH
          imgSelY2 -= timgSelH
       }
    } Else If (k=9)
    {
       imgSelX1 += wX
       imgSelX2 += wX
       imgSelY1 -= wY
       imgSelY2 -= wY
    } Else If (k=1)
    {
       imgSelX1 -= wX
       imgSelX2 -= wX
       imgSelY1 += wY
       imgSelY2 += wY
    } Else If (k=2 || K="down")
    {
       imgSelY1 += wY
       imgSelY2 += wY
       if (outside=1)
       {
          imgSelY1 += timgSelH
          imgSelY2 += timgSelH
       }
    } Else If (k=3)
    {
       imgSelX1 += wX
       imgSelX2 += wX
       imgSelY1 += wY
       imgSelY2 += wY
    } Else If (k=4 || k="left")
    {
       imgSelX1 -= wX
       imgSelX2 -= wX
       if (outside=1)
       {
          imgSelX1 -= timgSelW
          imgSelX2 -= timgSelW
       }
    } Else If (k=6 || k="right")
    {
       imgSelX1 += wX
       imgSelX2 += wX
       if (outside=1)
       {
          imgSelX1 += timgSelW
          imgSelX2 += timgSelW
       }
    } Else If (k=7)
    {
       imgSelY1 -= wY
       imgSelY2 -= wY
       imgSelX1 -= wX
       imgSelX2 -= wX
    }
    If (cX=1)
    {
       imgSelX1 += imgW//2 - timgSelW//2
       imgSelX2 += imgW//2 - timgSelW//2
    }

    If (cY=1)
    {
       imgSelY1 += imgH//2 - timgSelH//2
       imgSelY2 += imgH//2 - timgSelH//2
    }

    SetTimer, dummyRefreshImgSelectionWindow, -10
    SetTimer, dummyShowSelCoordsInfos, -25
}

arrowKeysAdjustSelectionArea(direction, modus, extraUmphf:=1, silent:=0) {
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || slideShowRunning=1 || !isImgEditingNow())
       Return

    If throwWarningAlphaPaintMode()
       Return

    factoru := (zoomLevel>2) ? 1 : 2 - zoomLevel
    stepu := Round(2 * (factoru + 0.1))
    If (stepu<2)
       stepu := 2

    stepu := stepu * extraUmphf
    If (FlipImgH=1 && InStr(direction, "1"))
       direction := (direction=1) ? -1 : 1

    If (FlipImgV=1 && InStr(direction, "2"))
       direction := (direction=2) ? -2 : 2

    If (modus=1) ; reposition selection
    {
       If (direction=1)
          imgSelX1 += stepu
       Else If (direction=-1)
          imgSelX1 -= stepu
       Else If (direction=2)
          imgSelY1 += stepu
       Else If (direction=-2)
          imgSelY1 -= stepu
    } Else If (modus=2)
    {
       If (direction=1)
          imgSelX2 += stepu
       Else If (direction=-1)
          imgSelX2 -= stepu
       Else If (direction=2)
          imgSelY2 += stepu
       Else If (direction=-2)
          imgSelY2 -= stepu
    }

    If (silent=1)
    {
       dummyRefreshImgSelectionWindow()
    } Else
    {
       userFriendlyPrevImgSelAction := (modus=1) ? "ADJUST SELECTION POSITION" : "ADJUST SELECTION SIZE"
       SetTimer, dummyRefreshImgSelectionWindow, -10
       SetTimer, dummyShowSelCoordsInfos, -25
    }
}

arrowKeysAdjustPrevPointPath(direction, modus) {
    Static lastInvoked := 1
    If (drawingShapeNow!=1)
       Return
    stepu := (A_TickCount - lastInvoked<400) ? 1 : 3
    stepuX := stepu/prevResizedVPimgW
    stepuY := stepu/prevResizedVPimgH

    maxu := (modus=1) ? 1 : customShapePoints.Count()
    cX1 := customShapePoints[maxu, 1]
    cY1 := customShapePoints[maxu, 2]
    If (direction=1)
       cX1 += stepuX
    Else If (direction=-1)
       cX1 -= stepuX
    Else If (direction=2)
       cY1 += stepuY
    Else If (direction=-2)
       cY1 -= stepuY

    customShapePoints[maxu] := [cX1, cY1]
    If isNowSymmetricVectorShape()
    {
       getVPcoordsVectorPoint(maxu, gmX, gmY)
       calculateSymmetricVectorPoint(gmX, gmY, nX, nY)
       getVectorCoordsFromVPpoint(nX, nY, nX, nY)
       maxu := (modus!=1) ? 1 : customShapePoints.Count()
       customShapePoints[maxu] := [nX, nY]
    }

    vpWinClientSize(mainWidth, mainHeight)
    drawLiveCreateCustomShape(mainWidth, mainHeight, 2NDglPG, "point-update", maxu)
    SetTimer, recordVectorUndoLevels, -500
    ; lastZeitFileSelect := A_TickCount
    dummyRefreshImgSelectionWindow()
    lastInvoked := A_TickCount
}

dummyShowSelCoordsInfos() {
    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    theRatio := "`nRatio: " Round(imgSelW/imgSelH, 2)
    theRatio .= "`nRotation: " Round(VPselRotation, 2) "° "
    theMsg := userFriendlyPrevImgSelAction "`nX / Y: " Round(ImgSelX1) ", " Round(ImgSelY1) "`nW / H: " Round(imgSelW) ", " Round(imgSelH) theRatio "`nCavity: " Round((innerSelectionCavityX + innerSelectionCavityX)/2 * 100, 2) " %"
    showTOOLtip(theMsg, 0, 0, VPselRotation/360)
    SetTimer, RemoveTooltip, -500
}

resetImgSelection(modus:=0) {
  If (modus!="forced" && (thumbsDisplaying=1 || drawingShapeNow=1 || editingSelectionNow!=1 || slideShowRunning=1 || !isImgEditingNow()))
     Return

  If throwWarningAlphaPaintMode()
     Return

  imgSelX1 := imgSelY1 := VPselRotation := innerSelectionCavityX := innerSelectionCavityY := 0
  imgSelX2 := imgSelY2 := -1
  lockSelectionAspectRatio := 1
  prcSelX1 := prcSelY1 := 0
  prcSelX2 := prcSelY2 := 0.5
  defineSelectionAspectRatios()
  EllipseSelectMode := editingSelectionNow := 0
  If (modus="forced")
     Return

  liveDrawingBrushTool := (AnyWindowOpen=64 && editingSelectionNow=0) ? 1 : 0
  FloodFillSelectionAdj := (AnyWindowOpen=66 && editingSelectionNow=0) ? 0 : 1
  interfaceThread.ahkassign("liveDrawingBrushTool", liveDrawingBrushTool)
  interfaceThread.ahkassign("FloodFillSelectionAdj", FloodFillSelectionAdj)
  updateUIctrl()
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(50)
}

resetSelectionAreaCavity() {
  If (thumbsDisplaying=1 || drawingShapeNow=1 || editingSelectionNow!=1 || slideShowRunning=1 || !isImgEditingNow())
     Return

  userUIshapeCavity := innerSelectionCavityX := innerSelectionCavityY := 0
  SetTimer, dummyRefreshImgSelectionWindow, -25
  userFriendlyPrevImgSelAction := "RESET SELECTION CAVITY"
  SetTimer, dummyShowSelCoordsInfos, -50
  If isVarEqualTo(AnyWindowOpen, 23, 24, 31, 34, 65, 68)
     GuiUpdateSliders("userUIshapeCavity")
}

changeSelectionAreaCavity(dir:=1) {
  If (thumbsDisplaying=1 || drawingShapeNow=1 || editingSelectionNow!=1 || slideShowRunning=1 || !isImgEditingNow())
     Return

  thisValue := (dir=1) ? innerSelectionCavityX + 0.01 : innerSelectionCavityX - 0.01
  innerSelectionCavityX := innerSelectionCavityY := clampInRange(thisValue, 0, 0.99)
  SetTimer, dummyRefreshImgSelectionWindow, -15
  userFriendlyPrevImgSelAction := (dir=1) ? "INCREASE SELECTION CAVITY" : "DECREASE SELECTION CAVITY"
  SetTimer, dummyShowSelCoordsInfos, -25
  ; dummyTimerDelayiedImageDisplay(50)
}

newImgSelection() {
  IMGdecalageX := IMGdecalageY := VPselRotation := innerSelectionCavityX := innerSelectionCavityY := 0
  resetImgSelection()
  Sleep, -1
  ToggleEditImgSelection()
}

createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight) {
    pBitmap := useGdiBitmap()
    If !validBMP(pBitmap)
       Return -1

    trGdip_GetImageDimensions(pBitmap, rImgW, rImgH)
    If (!rImgW || !rImgH)
       Return -1

    If (imgSelX2="C" || imgSelY2="C")
    {
       ; this never seems to be the case anymore
       GetMouseCoord2wind(PVhwnd, mX, mY)
       MouseCoords2Image(mX - 200, mY - 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
       MouseCoords2Image(mX + 200, mY + 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
    } Else If (imgSelX2=-1 && imgSelY2=-1)
    {
       obju := createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, 2, 1)
       imgSelX1 := obju.x1, imgSelY1 := obju.y1
       imgSelX2 := obju.x2, imgSelY2 := obju.y2
       If (imgSelX2>maxSelX/2 && newW<mainWidth)
          imgSelX2 := maxSelX//2
       If (imgSelY2>maxSelY/factor && newH<mainHeight)
          imgSelY2 := maxSelY//2
    }

    defineRelativeSelCoords(rImgW, rImgH)
}

createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, factor, applyLimits) {
    obju := []
    x1 := (DestPosX<0) ? Abs(DestPosX)/newW : 0
    SelX1 := Round(x1*maxSelX)
    y1 := (DestPosY<0) ? Abs(DestPosY)/newH : 0
    SelY1 := Round(y1*maxSelY)
    If (applyLimits!=1)
    {
       x1 := Abs(DestPosX)/newW
       If (DestPosX>0)
          SelX1 -= Round(x1*maxSelX)

       y1 := Abs(DestPosY)/newH
       If (DestPosY>0)
          SelY1 -= Round(y1*maxSelY)
    }
    ;  ToolTip, % selx1 "=" sely1 , , , 2
    SelX2 := Round(SelX1 + (mainWidth/factor)/zoomLevel) + 5
    SelY2 := Round(SelY1 + (mainHeight/factor)/zoomLevel) + 5
    If (applyLimits=1)
    {
       If (SelX2>maxSelX/factor && newW<mainWidth && allowFreeIMGpanning=0)
          SelX2 := maxSelX//factor
       If (SelY2>maxSelY/factor && newH<mainHeight && allowFreeIMGpanning=0)
          SelY2 := maxSelY//factor
    }

    obju.x1 := SelX1, obju.y1 := SelY1
    obju.x2 := SelX2, obju.y2 := SelY2
    Return obju  
}

correctActiveSelectionAreaViewPort() {
    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    If (!imgW || !imgH)
       Return -1

    capSelectionRelativeCoords()
    calcImgSelection2bmp(!LimitSelectBoundsImg, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
    ; fnOutputDebug(A_ThisFunc "(): " x1 "--" x2 "--" y1 "--" y2 " ||| " prcSelX2 "|" prcSelY2 )
    imgSelX1 := X1, imgSelY1 := Y1
    imgSelX2 := X2, imgSelY2 := Y2
}

coreMakeSquareSelection(imgW, imgH) {
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    avg := Round( (imgSelW + imgSelH)/2 )
    avg := clampInRange(avg, 5, min(imgW, imgH))
    imgSelX2 := X1 + avg
    imgSelY2 := Y1 + avg
    prcSelX2 := imgSelX2 / imgW
    If (prcSelX2>1)
       prcSelX2 := 1

    prcSelY2 := imgSelY2 / imgH
    If (prcSelY2>1)
       prcSelY2 := 1

    Sleep, 1
    If (LimitSelectBoundsImg=1)
       dummyRefreshImgSelectionWindow()
}

makeSquareSelection() {
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || liveDrawingBrushTool=1)
       Return

    If (lockSelectionAspectRatio>1)
    {
       lockSelectionAspectRatio := 1
       toggleImgSelectionAspectRatio()
       Return
    }

    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    doLoops := (LimitSelectBoundsImg=1) ? 20 : 1
    Loop, % doLoops
       coreMakeSquareSelection(imgW, imgH)

    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

resetSelectionRotation() {
   If (thumbsDisplaying=1)
      Return

   VPselRotation := 0
   SetTimer, dummyRefreshImgSelectionWindow, -10
   userFriendlyPrevImgSelAction := "RESET SELECTION ROTATION"
   SetTimer, dummyShowSelCoordsInfos, -20
}

resetImgSkewOffsets() {
   If (thumbsDisplaying=1)
      Return

   shearImgX := shearImgY := 0
   dummyTimerDelayiedImageDisplay(50)
}

MenuSelRotation() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
      Return

   VPselRotation := Round(VPselRotation) + 45
   If (VPselRotation>350)
      VPselRotation := 0

   SetTimer, dummyRefreshImgSelectionWindow, -10
   userFriendlyPrevImgSelAction := "SELECTION ROTATION +45°"
   SetTimer, dummyShowSelCoordsInfos, -20
}

flipSelectionWH() {
    Static lastState := 0
    If (editingSelectionNow!=1 || thumbsDisplaying=1 || liveDrawingBrushTool=1)
       Return

    trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    If (!imgW || !imgH)
       Return

    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    Gdip_GetRotatedDimensions(imgSelW, imgSelH, 90, rimgSelW, rimgSelH)
    imgSelX2 := X1 + Floor(rimgSelW)
    imgSelY2 := Y1 + Floor(rimgSelH)
    If (lockSelectionAspectRatio>1)
    {
       lastState := !lastState
       defineSelectionAspectRatios("yes", lastState)
    } 
    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

ImageCoords2Window(inputX, inputY, DestPosX, DestPosY, dotSize, ByRef outX, ByRef outY, rounding:=1, limitBounds:=0, givenZL:=99) {
   thisZL := (givenZL!=99) ? givenZL : zoomLevel
   If (rounding=1)
   {
      outX := Round(inputX*thisZL) + DestPosX - dotSize//2
      outY := Round(inputY*thisZL) + DestPosY - dotSize//2
   } Else
   {
      outX := inputX*thisZL + DestPosX - dotSize/2
      outY := inputY*thisZL + DestPosY - dotSize/2
   }

   If (limitBounds=1)
   {
      vpWinClientSize(mW, mH, PVhwnd, 0)
      outX := clampInRange(outX, 0, mW)
      outY := clampInRange(outY, 0, mH)
   }
}

MouseCoords2Image(mX, mY, limitBounds, dPosX, dPosY, newW, newH, ByRef x, ByRef y, whichBitmap:=0, rounding:=1, imgW:=0, imgH:=0) {
    x1 := (dPosX<0) ? mX + Abs(dPosX) : mX - Abs(dPosX)
    y1 := (dPosY<0) ? mY + Abs(dPosY) : mY - Abs(dPosY)
    If (limitBounds=1)
    {
       x1 := clampInRange(x1, 0, newW)
       y1 := clampInRange(y1, 0, newH)
    }

    If (!imgW || !imgH)
    {
       whichBitmap := whichBitmap ? whichBitmap : useGdiBitmap()
       trGdip_GetImageDimensions(whichBitmap, imgW, imgH)
    }

    prcx1 := x1/newW
    prcy1 := y1/newH
    x := (rounding=1) ? Round(imgW * prcx1) : imgW * prcx1
    y := (rounding=1) ? Round(imgH * prcy1) : imgH * prcy1
    If (limitBounds=1)
    {
       x := clampInRange(x, 0, imgW)
       y := clampInRange(y, 0, imgH)
    }
    ; ToolTip, % mX " -- " mY "`n" x " -- " y "`n" DestPosX " -- " DestPosY "`n" newW " -- " newH "`n" prcx1 " -- " prcy1, , , 2
}

coreUpdateLiveTinyPreviewsWindow() {
    If (AnyWindowOpen=26 || AnyWindowOpen=78)
       livePreviewBlurPanel()
    Else If (AnyWindowOpen=43 || AnyWindowOpen=79)
       livePreviewIDedgesPanel()
    Else If (AnyWindowOpen=44)
       livePreviewAddNoiser()
    Else If (AnyWindowOpen=64)
       createLivePreviewBrush()
    Else If (AnyWindowOpen=69)
       livePreviewZoomBlurPanel()
}

updateLiveTinyPreviewsWindow(hwnd:=0, eventu:=0) {
   ; function meant to filter out repeated calls
   WinGetClass, WinClass, ahk_id %hwnd%
   If (InStr(WinClass, "_trackbar"))
   {
      ; fnOutputDebug("slider:" hwnd)
      If (eventu!="normal")
         SetTimer, coreUpdateLiveTinyPreviewsWindow, -25
   } Else
      coreUpdateLiveTinyPreviewsWindow()
}

updateTinyPreviewArea(DestPosX, DestPosY, newW, newH, urgent:=0) {
    Static lastInvoked := 1
    If (tinyPrevAreaCoordX="C" || tinyPrevAreaCoordY="C" || urgent=1)
    {
       GetMouseCoord2wind(PVhwnd, mX, mY)
       vpWinClientSize(mainWidth, mainHeight)
       mX := (FlipImgH=1) ? mainWidth - mX : mX
       mY := (FlipImgV=1) ? mainHeight - mY : mY
       MouseCoords2Image(mX, mY, 1, DestPosX, DestPosY, newW, newH, x, y)
       tinyPrevAreaCoordX := x, tinyPrevAreaCoordY := y
       If (panelWinCollapsed!=1)
          WinActivate, ahk_id %hSetWinGui%

       If (urgent=1)
       {
          If (A_TickCount - lastInvoked<90)
             Return

          coreUpdateLiveTinyPreviewsWindow()
          lastInvoked := A_TickCount
       } Else
       {
          SetTimer, coreUpdateLiveTinyPreviewsWindow, -100
       }
    } 
}

destroyBlacked() {
  If (imageLoading=1)
  {
     SetTimer, destroyBlacked, -50
     Return
  }
  BlackedCreator(1, 1)
}

ToggleVisibilityWindow(actu, winIDu) {
   Static prevState
   thisState := actu "-" winIDu
   If (thisState=prevState)
      Return

   globalWinStates["a" winIDu] := (actu="show") ? 1 : 0
   If (actu="show")
      WinSet, Region,, ahk_id %winIDu%
   Else
      WinSet, Region, 0-0 w1 h1, ahk_id %winIDu%

   prevState := thisState
}

FadeMainWindow() {
   If (A_TickCount - scriptStartTime<5000)
      Return

   whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
   r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC, 125)
}

GdipCleanMain(modus:=0) {
    If (modus=2)
    {
       ; BlackedCreator(128)
       ; SetTimer, destroyBlacked, -100
       vpWinClientSize(mainWidth, mainHeight)
       Gdi_FillShape(glHDC, 0, 0, mainWidth, mainHeight, WindowBgrColor, 1)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC, 200)
       Return
    }

    vpWinClientSize(mainWidth, mainHeight)
    opacity := (modus=1) ? "0xFF" : "0x50"
    If (modus=4 || modus=5 || modus=6)
    {
       ; BMPcache := trGdip_CreateBitmapFromHBITMAP(A_ThisFunc, glHbitmap)
       If (modus=4)
       {
          graphPath := Gdip_CreatePath()
          x1 := mainWidth//2 - 45 , x2 := mainWidth//2 + 45
          x3 := mainWidth//2,       y1 := mainHeight//2
          y2 := mainHeight//2,      y3 := mainHeight//2 - 200
          Gdip_AddPathPolygon(graphPath, [x1, y1, x2, y2, x3, y3])
          trGdip_RotatePathAtCenter(graphPath, vpIMGrotation)
       }

       ; trGdip_DrawImage(A_ThisFunc, glPG, BMPcache)
       If (modus=5 || modus=6)
       {
          If (vpIMGrotation>0)
             zoomu := " @ " vpIMGrotation "°"
          zoomu := Round(zoomLevel * 100) "%" zoomu
          thisInfo := max(oldZoomLevel, zoomLevel) - min(oldZoomLevel, zoomLevel)
          If (modus=6)
             thisInfo := zoomu := "( - )"

          If thisInfo
          {
             thisFntSize := (modus!=6) ? OSDfontSize*1.25 : OSDfontSize*0.75
             infoBoxBMP := drawTextInBox(zoomu, OSDFontName, thisFntSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             trGdip_GetImageDimensions(infoBoxBMP, Wi, He)
             If (modus=5)
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2)
             Else
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2,,,,,,, 0.45)
             trGdip_DisposeImage(infoBoxBMP, 1)
          } Else
          {
             imgPath := getIDimage(currentFileIndex)
             zPlitPath(imgPath, 0, OutFileName, OutDir)
             entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
             infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfontSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP)
             trGdip_DisposeImage(infoBoxBMP, 1)
             oldZoomLevel := zoomLevel
          }
       }

       If (modus=4)
       {
          thisW := thisH := 250
          Gdip_FillEllipse(glPG, pBrushE, mainWidth//2 - thisW//2, mainHeight//2 - thisH + 30, thisW, thisH)
          Gdip_FillPath(glPG, pBrushD, graphPath)
          Gdip_DeletePath(graphPath)
       }

       thisOpacity := (modus!=6) ? "0x22" : "0x33"
       Random, hu, 6, 8
       Random, ha, 6, 8
       clr := thisOpacity . ha . hu . ha . hu . ha . hu
       widthu := imgHUDbaseUnit//3
       yPen := Gdip_CreatePen(clr, widthu)
       Gdip_DrawRectangle(glPG, yPen, 0, 0, mainWidth, mainHeight)
       Gdip_DeletePen(yPen)
       whichWin := (imgEditPanelOpened=1 && AnyWindowOpen!=10) ? hGDIthumbsWin : hGDIwin
       r2 := doLayeredWinUpdate(A_ThisFunc, whichWin, glHDC, 225)
       ; trGdip_DisposeImage(BMPcache)
    } Else 
    {
       trGdip_GraphicsClear(A_ThisFunc, glPG, opacity WindowBgrColor)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
    }
}

clearGivenGDIwin(funcu, Gu, DCu, hwnd) {
    trGdip_GraphicsClear(funcu "<-" A_ThisFunc, Gu, "0x00" WindowBgrColor, 1)
    Return doLayeredWinUpdate(funcu "<-" A_ThisFunc, hwnd, DCu)
}

GetCachableImgFileDetails(imgPath, imgIndex, thumbBMP:=0, returnObj:=0, isFilter:=0) {
     If (!imgPath || !imgIndex)
     {
        addJournalEntry(A_ThisFunc "() - incorrect params error: " imgIndex " = " imgPath)
        Return
     }

     r := 0
     ; fnOutputDebug(A_ThisFunc "() - no cache: " imgIndex " = " imgPath)
     If !validBMP(thumbBMP)
     {
        r := LoadBitmapFromFileu(imgPath, 1)
        If (mainLoadedIMGdetails.OpenedWith="[GDI+]")
           trGdip_DisposeImage(r, 1)
     } else r := 1

     r := (mainLoadedIMGdetails.Width>1 && mainLoadedIMGdetails.Height>1) ? 1 : 0
     If r
     {
        If (returnObj=1)
        {
           obju := []
           obju.w := mainLoadedIMGdetails.Width
           obju.h := mainLoadedIMGdetails.Height
           obju.pixFmt := mainLoadedIMGdetails.PixelFormat
           obju.frames := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames +1 : 1
           obju.ratio := Round(mainLoadedIMGdetails.Width / mainLoadedIMGdetails.Height, 2)
           obju.mgpx := Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2)
           obju.dpi := mainLoadedIMGdetails.dpi
        } Else
           UpdateFilesListImgIDinfos(imgIndex, isFilter)
     } Else obju := r := 0

     If (returnObj=1)
        Return obju
     Else
        Return r
}

UpdateFilesListImgIDinfos(imgIndex, isFilter:=0) {
   updateFilesListByID(imgIndex, 9, (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1, isFilter)
   updateFilesListByID(imgIndex, 13, mainLoadedIMGdetails.Width, isFilter)
   updateFilesListByID(imgIndex, 14, mainLoadedIMGdetails.Height, isFilter)
   updateFilesListByID(imgIndex, 15, mainLoadedIMGdetails.PixelFormat, isFilter)
   updateFilesListByID(imgIndex, 16, Round(mainLoadedIMGdetails.Width / mainLoadedIMGdetails.Height, 2), isFilter)
   updateFilesListByID(imgIndex, 17, Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2), isFilter)
   updateFilesListByID(imgIndex, 22, mainLoadedIMGdetails.dpi, isFilter)

   fileInfos := GetFileAttributesEx(getIDimage(imgIndex))
   updateFilesListByID(imgIndex, 6, fileInfos.size, isFilter)
   updateFilesListByID(imgIndex, 7, fileInfos.wTime, isFilter)
   updateFilesListByID(imgIndex, 8, fileInfos.cTime, isFilter)
}

MixRGBcolrs(clrA, clrB, t) {
   t := 1 - t
   Ra := Format("{1:d}", "0x" SubStr(clrA, 1, 2))
   Ga := Format("{1:d}", "0x" SubStr(clrA, 3, 2))
   Ba := Format("{1:d}", "0x" SubStr(clrA, 5, 2))

   Rb := Format("{1:d}", "0x" SubStr(clrB, 1, 2))
   Gb := Format("{1:d}", "0x" SubStr(clrB, 3, 2))
   Bb := Format("{1:d}", "0x" SubStr(clrB, 5, 2))
  
   r := clampInRange(Round(Ra * (1-t) + Rb * t), 0, 255)
   g := clampInRange(Round(Ga * (1-t) + Gb * t), 0, 255)
   b := clampInRange(Round(Ba * (1-t) + Bb * t), 0, 255)
   Return Format("{1:02x}", R) Format("{1:02x}", G) Format("{1:02x}", B)
}

MixARGB(color1, color2, t := 0.5) {
   Static gamma := 2.2
   rgamma := 1/gamma
   a1 := (color1 >> 24) & 0xff,  r1 := (color1 >> 16) & 0xff,  g1 := (color1 >>  8) & 0xff,  b1 := (color1 >>  0) & 0xff
   a2 := (color2 >> 24) & 0xff,  r2 := (color2 >> 16) & 0xff,  g2 := (color2 >>  8) & 0xff,  b2 := (color2 >>  0) & 0xff
   
   ga1 := (a1 / 255) ** gamma,   gr1 := (r1 / 255) ** gamma,   gg1 := (g1 / 255) ** gamma,   gb1 := (b1 / 255) ** gamma
   ga2 := (a2 / 255) ** gamma,   gr2 := (r2 / 255) ** gamma,   gg2 := (g2 / 255) ** gamma,   gb2 := (b2 / 255) ** gamma
   
   ma := ga1 * (1-t) + ga2 * t,  mr := gr1 * (1-t) + gr2 * t,  mg := gg1 * (1-t) + gg2 * t,  mb := gb1 * (1-t) + gb2 * t
   mga := 255 * (ma ** rgamma),  mgr := 255 * (mr ** rgamma),  mgg := 255 * (mg ** rgamma),  mgb := 255 * (mb ** rgamma)

   thisColor := Gdip_ToARGB(mga, mgr, mgg, mgb)
   Return thisColor := Format("{1:#x}", thisColor)
}

initInPlaceTextOptions(Gu, boldu, italicu, NoWrap, thisTextAlign, face, theFntSize, txtColor, borderu) {
    txtStyle := ""
    If (boldu=1)
       txtStyle .= " Bold"

    If (italicu=1 && NoWrap=0)
       txtStyle .= " Italic"

    If !thisTextAlign
       thisTextAlign := (FlipImgH=1) ? "Right" : "Left"
    Else
       thisTextAlign := Trimmer(thisTextAlign)

    txtOptions := []
    txtOptions.Styles := txtStyle
    txtOptions.Align := thisTextAlign
    txtOptions.Color := txtColor
    txtOptions.Size := theFntSize
    txtOptions.Fontu := face
    txtOptions.borderSize := borderu
    txtOptions.wrapu := NoWrap
    fontQuality := (theFntSize>90) ? 2 : 3
    If (theFntSize<20)
       fontQuality := 4

    Gdip_SetTextRenderingHint(Gu, fontQuality)
    Return txtOptions
}

QPV_listThumbnailsGridMode(forceMode, thisGu, thisHDC, thisHwnd) {
    Static zBru := 0
    If !zBru
       zBru := Gdip_BrushCreateSolid("0x66994433")

    If (forceMode!=1)
       setImageLoading()

    startZeit := A_TickCount
    trGdip_GraphicsClear(A_ThisFunc, thisGu, "0xFF" WindowBgrColor)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    rowIndex := 0
    columnIndex := -1
    prevMSGdisplay := A_TickCount
    If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1 && forceMode!=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    If (SLDtypeLoaded=3 && thumbsListViewMode=4 && forceMode!=1)
       activeSQLdb.Exec("BEGIN TRANSACTION;")

    borderSize := imgHUDbaseUnit//5
    txtOptions := initInPlaceTextOptions(thisGu, OSDFontBolded, OSDfontItalica, 1, 0, OSDFontName, OSDfontSize//1.25, "0xEE" OSDtextColor, borderSize)
    otherTxtObj := TextuToGraphics(thisGu, "initing", txtOptions, OSDFontName, "begin", 0, 0, 1)
    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := StrReplace(resultedFilesList[thisFileIndex, 1], "||")
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        zPlitPath(imgPath, 1, fileNamu, folderu)
        If (userPrivateMode!=1)
           sfolderu := PathCompact(folderu, "a", 1, OSDfontSize//1.25, thumbsW - borderSize)

        ; Gdip_FillRectangle(thisGu, pBrushWinBGR, DestPosX, DestPosY, thumbsW, thumbsH)
        If (StrLen(imgPath)>2 && (thumbsListViewMode=2 || forceMode=1))
        {
           ; no details mode
           entireString := (userPrivateMode=1) ? "******.***`n*:\***\******\`n" : fileNamu "`n" sfolderu "\"
           If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(thisGu, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=3)
        {
           ; file details mode
           ofileSizu := QPV_FileGetSizeTime(imgPath, "S", thisFileIndex)
           fileSizu := fileSizeFriendly(ofileSizu)
           FileDateM := QPV_FileGetSizeTime(imgPath, "M", thisFileIndex)
           FileDateC := QPV_FileGetSizeTime(imgPath, "C", thisFileIndex)
           Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
           Try FormatTime, FileDateC, % FileDateC, dd/MM/yyyy, HH:mm
           fileMsg := FileExist(imgPath) ? FileDateC " | " FileDateM " | " fileSizu : "Error gathering data..."
           entireString := (userPrivateMode=1) ?  mgpx "******.***`n*:\***\******\`n" fileMsg : mgpx fileNamu "`n" sfolderu "\`n" fileMsg
           If (ofileSizu<50 && !InStr(fileMsg, "error"))
           {
              Gdip_FillRectangle(thisGu, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           } Else If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(thisGu, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=4)
        {
           ; image details mode
           If FileExist(imgPath)
           {
              If !resultedFilesList[thisFileIndex, 9]
              {
                 If !retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12])
                    GetCachableImgFileDetails(imgPath, thisFileIndex)

                 If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
                    updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
              }

              Width := resultedFilesList[thisFileIndex, 13]
              Height := resultedFilesList[thisFileIndex, 14]
              CountFrames := (resultedFilesList[thisFileIndex, 9]>1) ? " | " resultedFilesList[thisFileIndex, 9] " f" : ""
              mgpx := " | " resultedFilesList[thisFileIndex, 17] " MPx | " Round(Width/Height, 2)
              ofileSizu := QPV_FileGetSizeTime(imgPath, "S", thisFileIndex)
              fileSizu := " | " fileSizeFriendly(ofileSizu)
              fileMsg := groupDigits(Width) " x " groupDigits(Height) CountFrames mgpx fileSizu
           } Else fileMsg := "Error gathering data"

           entireString := (userPrivateMode=1) ? "******.***`n*:\***\******\`n" fileMsg : fileNamu "`n" sfolderu "\`n" fileMsg
           If ((Width<2 || Height<2 || ofileSizu<50) && !InStr(fileMsg, "error"))
           {
              Gdip_FillRectangle(thisGu, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           } Else If (userSearchString && markSearchMatches=1)
           {
              If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                 Gdip_FillRectangle(thisGu, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        }

        If StrLen(entireString)>2
        {
           txtOptions.x := (FlipImgH=1) ? DestPosX : DestPosX + borderSize
           txtOptions.y := DestPosY + borderSize
           txtOptions.w := thumbsW - borderSize
           txtOptions.h := thumbsH - borderSize
           drawInPlaceTextInBox(thisGu, entireString, txtOptions)
           ; Gdip_ResetClip(thisGu)
           ; trGdip_DrawImage(A_ThisFunc, thisGu, infoBoxBMP2, DestPosX, DestPosY)
           ; infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
           entireString := ""
        } 

        If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1 && forceMode!=1)
        {
           If retrieveSeenImageDBentry(imgPath, thisFileIndex)
              Gdip_DrawRectangle(thisGu, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (A_TickCount - prevMSGdisplay > 450)
        {
           prevMSGdisplay := A_TickCount
           r2 := doLayeredWinUpdate(A_ThisFunc, thisHwnd, thisHDC)
        } Else If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }
    }

    If (SLDtypeLoaded=3 && thumbsListViewMode=4 && forceMode!=1)
       activeSQLdb.Exec("COMMIT TRANSACTION;")

    ; Gdip_DeleteBrush(zBru)
    r2 := doLayeredWinUpdate(A_ThisFunc, thisHwnd, thisHDC)
    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    ; ToolTip, % mainEndZeit - startZeit , , , 2
    If (forceMode!=1)
    {
       prevFullIndexThumbsUpdate := startIndex
       SetTimer, ResetImgLoadStatus, -15
       prevFullThumbsUpdate := A_TickCount
    } Else prevTryThumbsUpdate := A_TickCount
}

mainGdipWinThumbsGrid(mustDestroyBrushes:=0, simpleMode:=0, listMap:=0, actu:="", mapOffset:=0) {
    Critical, on
    Static pBrush1, pBrush2, pBrush3, pBrush4, pBrush5
         , brushesCreated, prevIndexu

    If (mustDestroyBrushes=1 && brushesCreated=1)
    {
       Gdip_DeleteBrush(pBrush1)
       Gdip_DeleteBrush(pBrush2)
       Gdip_DeleteBrush(pBrush3)
       Gdip_DeleteBrush(pBrush4)
       Gdip_DeleteBrush(pBrush5)
       brushesCreated := 0
       Return
    } Else If (mustDestroyBrushes=1)
       Return

    If (thumbsDisplaying!=1)
       Return

    If (brushesCreated!=1)
    {
       pBrush1 := Gdip_BrushCreateSolid("0x88999999")
       pBrush2 := Gdip_BrushCreateSolid("0x55999999")
       pBrush3 := Gdip_BrushCreateSolid("0x400188FF")
       pBrush4 := Gdip_BrushCreateSolid("0x55404040")
       pBrush5 := Gdip_BrushCreateSolid("0x66334433")
       brushesCreated := 1
    }

    selectorWidth := imgHUDbaseUnit//6
    If (selectorWidth>min(thumbsW, thumbsH)*0.3)
       selectorWidth := Round(min(thumbsW, thumbsH)*0.3)

    If (simpleMode=0)
    {
       Gdip_SetPenWidth(pPen6, selectorWidth)
       Gdip_SetPenWidth(pPen1d, selectorWidth//2)
       Gdip_SetPenWidth(pPen5, selectorWidth//2)
    }

    Gdip_GraphicsClear(2NDglPG, "0x00" WindowBgrColor)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    thisThumb := rowIndex := 0, cbox := []
    currentDupeID := columnIndex := -1
    If (simpleMode=0)
    {
       If testIsDupesList()
       {
          isDupesList := 1
          Gdip_SetPenWidth(pPen2, imgHUDbaseUnit//9 + 1)
          currentDupeID := resultedFilesList[currentFileIndex, 23]
          currentDupeDetails := "." resultedFilesList[currentFileIndex, 33] "." resultedFilesList[currentFileIndex, 34]
       }
    }

    If (startIndex=prevIndexu)
       prevIndexu := ""

    If (showImgAnnotations=1 && actu!="scroll")
       drawAnnotationBox(mainWidth, mainHeight, 2NDglPG)

    If (showInfoBoxHUD>0)
    {
       drawinfoBox(mainWidth, mainHeight, 0, 2NDglPG, actu)
       If (A_TickCount - lastInfoBoxZeitToggle<800 || thumbsListViewMode>1 || actu="scroll")
          Gdip_SetClipRect(2NDglPG, 0, 0, lastInfoBoxBMP[1, 1], lastInfoBoxBMP[1, 2], 4)
    } Else
       interfaceThread.ahkPostFunction("uiAccessUpdateInfoBox", "hide", 1, 1, 0, 0)

    listedItems := ""
    theMsg := theMsg2 := itemInfos := ""
    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := resultedFilesList[thisFileIndex, 1]
        imgPathSelected := resultedFilesList[thisFileIndex, 2]
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        If (simpleMode=0)
        {
           tPath := (thumbsListViewMode>1) ? imgPath : SubStr(imgPath, InStr(imgPath, "\", 0, -1) + 1)
           listedItems .= (imgPathSelected=1) ? tPath " (selected).`n" : tPath ".`n"
        }

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        isStringLen := StrLen(imgPath)>5 ? 1 : 0
        If (simpleMode=1) ; && thumbsListViewMode>1)
        {
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           ; Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
           If (isStringLen=0)
              Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        isFile := 1
        If (isStringLen=1 && (simpleMode=0 || thisFileIndex=currentFileIndex))
           isFile := FileRexists(imgPath)

        If (simpleMode=1 && isStringLen=1 && thumbsListViewMode=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX + 1, DestPosY + 1, thumbsW - 2, thumbsH - 2)
        } Else If (thumbsListViewMode=1 && isFile=0 && simpleMode=0)
        {
           infoBoxBMP2 := drawTextInBox("! " thisFileIndex, OSDFontName, OSDfontSize//1.5, thumbsW, thumbsH, OSDtextColor, OSDbgrColor, 0, 0)
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP2, DestPosX, DestPosY)
           infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
        }

        If (isFile=0 && simpleMode=0)
           Gdip_FillRectangle(2NDglPG, pBrush4, DestPosX, DestPosY, thumbsW, thumbsH)

        If (thisFileIndex=currentFileIndex)
        {
           ; Gdip_FillRectangle(2NDglPG, pBrush1, DestPosX, DestPosY, thumbsW, thumbsH)
           If (thumbsListViewMode=1 && userPrivateMode=0 && simpleMode=0 && showInfoBoxHUD>0)
           {
              MD5name := generateThumbName(imgPath, 1)
              If StrLen(imgThumbsCacheIDsArray[MD5name])>0
                 thisThumb := imgThumbsCacheArray[imgThumbsCacheIDsArray[MD5name], 1]

              If thisThumb
              {
                 trGdip_GetImageDimensions(thisThumb, imgW, imgH)
                 thisThumb := trGdip_CloneBitmap(A_ThisFunc, thisThumb)
                 calcIMGdimensions(imgW, imgH, thumbsW, thumbsH, fW, fH)
                 dpX := DestPosX + thumbsW/2
                 dpX -= (imageAligned!=5) ? thumbsW/2 : fW/2
                 dpY := DestPosY + thumbsH/2
                 dpY -= (imageAligned!=5) ? thumbsH/2 : fH/2
                 flipBitmapAccordingToViewPort(thisThumb)
                 If (usrColorDepth>1)
                    Gdip_BitmapSetColorDepth(thisThumb, internalColorDepth, ColorDepthDithering)

                 thisThumb := applyVPeffectsOnBMP(thisThumb)
                 tzGdip_DrawImage(2NDglPG, thisThumb, dpX, dpY, fW, fH,,,,, 0.3)
                 trGdip_DisposeImage(thisThumb, 1)
              }
           }

           If (isStringLen=1)
           {
              zPlitPath(imgPath, 1, fileNamu, folderu)
              If isFile
              {
                 fileSizu := FileDateM :=fileMsg := fileMsg2 := ""
                 QPV_FileGetSizeTime(imgPath, "R", thisFileIndex)
                 fileSizu := fileSizeFriendly(resultedFilesList[thisFileIndex, 6])
                 FileDateM := resultedFilesList[thisFileIndex, 7]
                 Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
                 fileMsg := fileSizu " | " FileDateM
                 fileMsg2 := "File size: " fileSizu " | Modified date: " FileDateM
              } Else 
              {
                 fileMsg := (isStringLen=1 && simpleMode=0) ? "File access error" : "-"
                 fileMsg2 := (isStringLen=1 && simpleMode=0) ? "File access error" : ""
              }

              delim := (multilineStatusBar=1 || simpleMode>=1) ? "`n" : " | "
              If (multilineStatusBar=1 && userPrivateMode!=1)
                 folderuz := PathCompact(folderu, "a", 1, Ceil(OSDfontSize*0.9), mainWidth - OSDfontSize//2)
              Else
                 folderuz := folderu

              namu := (userPrivateMode=1) ? "******.***" delim "*:\***\******\" : fileNamu delim folderuz "\"
              namu2 := (userPrivateMode=1) ? "" : "File: " fileNamu delim "Location: " folderu "\"
              fileIndexu := (multilineStatusBar=1) ? groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) : groupDigits(currentFileIndex) 
              fileIndexu2 := "Current index: " groupDigits(currentFileIndex) ". " groupDigits(maxFilesIndex)
              theMsg := fileIndexu " | " fileMsg " | " namu
              theMsg2 := fileIndexu2 " files listed | " fileMsg2 " | " namu2
              missingu := !isFile ? "Missing file. " : ""
              selu := imgPathSelected ? "File selected. " : ""
              itemInfos := fileNamu ". " selu missingu folderu "." currentFileIndex " of " maxFilesIndex ". List view mode."
           }
        }

        If (imgPathSelected=1)
        {
           countSel++
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_FillRectangle(2NDglPG, pBrush3, DestPosX, DestPosY, thumbsW, thumbsH)
           If (editingSelectionNow=1 && thumbsListViewMode=1)
           {
              ww := resultedFilesList[thisFileIndex, 13]
              hh := resultedFilesList[thisFileIndex, 14]
              If (ww && hh)
              {
                 calcIMGdimensions(ww, hh, thumbsW, thumbsH, fW, fH)
                 dpX := DestPosX + thumbsW/2
                 dpX -= (imageAligned!=5) ? thumbsW/2 : fW/2
                 dpY := DestPosY + thumbsH/2
                 dpY -= (imageAligned!=5) ? thumbsH/2 : fH/2

                 calcImgSelection2bmp(0, ww, hh, fW, fH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, "a")
                 Gdip_FillRectangle(2NDglPG, pBrushF, dpX + zimgSelPx, dpY + zimgSelPy, zimgSelW, zimgSelH)
                 Gdip_DrawRectangle(2NDglPG, pPen5, dpX + zimgSelPx, dpY + zimgSelPy, zimgSelW, zimgSelH)
                 Gdip_DrawRectangle(2NDglPG, pPen1d, dpX + zimgSelPx, dpY + zimgSelPy, zimgSelW, zimgSelH)
                 ; fnOutputDebug(thisFileIndex "=SIZE=" fW "|" fH "=" imgSelW "|" imgSelH)
                 ; fnOutputDebug(thisFileIndex "=POS=" dpX "|" dpY "=" imgSelPx "|" imgSelPy)
              }
           }
        }

        If (resultedFilesList[thisFileIndex, 3]=1 && highlightAlreadySeenImages=1)
           Gdip_DrawRectangle(2NDglPG, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)

        If (currentDupeID=resultedFilesList[thisFileIndex, 23] && simpleMode=0 && isDupesList=1 && fadeOtherDupeGroups!=1)
        {
           thisu := imgHUDbaseUnit//3.5
           Gdip_DrawLine(2NDglPG, pPen2, DestPosX, DestPosY, DestPosX + thumbsW, DestPosY)
           Gdip_DrawLine(2NDglPG, pPen2, DestPosX, DestPosY + thumbsH, DestPosX + thumbsW, DestPosY + thumbsH)
           Gdip_FillEllipse(2NDglPG, pBrushA, DestPosX + thumbsW//2 - thisu//2, DestPosY + thumbsH//2 - thisu//2, thisu, thisu)
           Gdip_FillEllipse(2NDglPG, pBrushA, DestPosX + thumbsW//2 - thisu//2 + 2, DestPosY + thumbsH//2 - thisu//2 + 2, thisu, thisu)
        } Else If (isDupesList=1 && fadeOtherDupeGroups=1 && currentDupeID!=resultedFilesList[thisFileIndex, 23])
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)

        If (thisFileIndex=EntryMarkedMoveIndex)
           Gdip_FillRectangle(2NDglPG, pBrushC, DestPosX, DestPosY, thumbsW, thumbsH)

        If (thisFileIndex=currentFileIndex)
        {
           If (thumbsModeItemHighlight=1)
              Gdip_FillRectangle(2NDglPG, pBrushF, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_DrawRectangle(2NDglPG, pPen6, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (resultedFilesList[thisFileIndex, 5]=1) ; is bookmarked
           Gdip_DrawRectangle(2NDglPG, pPen1d, DestPosX, DestPosY, thumbsW, thumbsH)
    }

    If (countSel>markedSelectFile && countSel>1 && markedSelectFile>1)
       SetTimer, dummyRecountSelectedFiles, -100

    filesSelInfo := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
    pVwinTitle := defineWinTitlePrefix() filesSelInfo currentFileIndex "/" maxFilesIndex " | List mode: " defineListViewModes()
    If (userPrivateMode!=1)
       pVwinTitle .= " | " CurrentSLD

    setWindowTitle(pVwinTitle)
    If StrLen(filesFilter)>1
       theMsg := "[F] " theMsg

    prevIndexu := startIndex
    If markedSelectFile
    {
       Gdip_FillRectangle(2NDglPG, pBrush1, 0, 0, mainWidth, imgHUDbaseUnit//5)
       theMsg := groupDigits(markedSelectFile) " selected | " theMsg
       theMsg2 := groupDigits(markedSelectFile) " files selected | " theMsg2
    }

    If (StrLen(theMsg)>1)
    {
       ; draw the status bar
       If (simpleMode=0 && actu!="scroll")
          interfaceThread.ahkFunction("infosUIAbtns", itemInfos)

       bgrTXT := (resultedFilesList[currentFileIndex, 2]=1) ? SubStr(MixARGB("0xFF0188FF", "0xFF" OSDbgrColor, 0.65), 5) : OSDbgrColor
       If isDupesList
       {
          theMSG := "DUPE ID: " currentDupeID StrReplace(currentDupeDetails, ".2500") " | " theMSG
          theMSG2 := "DUPE ID: " currentDupeID StrReplace(currentDupeDetails, ".2500") " | " theMSG2
          mpxu := " | " Round(resultedFilesList[currentFileIndex, 17], 2) " MPx"
          mpxu2 := " | " Round(resultedFilesList[currentFileIndex, 17], 2) " Megapixels"
          theMSG := StrReplace(theMSG, " MB |", " MB" mpxu " |")
          theMSG := StrReplace(theMSG, " KB |", " KB" mpxu " |")
          theMSG2 := StrReplace(theMSG2, " MB |", " MB" mpxu2 " |")
          theMSG2 := StrReplace(theMSG2, " KB |", " KB" mpxu2 " |")
       } Else If (SLDtypeLoaded=3 && resultedFilesList[currentFileIndex, 36]!="")
       {
          thisu := resultedFilesList[currentFileIndex, 36]
          labelu2 := defineSQLdbSort()
          labelu := StrReplace(labelu2, "histogram", "Histo")
          If (InStr(labelu, "histo") && !InStr(labelu, "rms"))
             thisu := thisu * 256
          If InStr(thisu, ".")
             thisu := Round(thisu, 2)
          theMSG := labelu ": " thisu " | " theMSG
          theMSG2 := labelu2 ": " thisu " | " theMSG2
       }

       ; hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
       tlbrBonusX := (hasTrans=1 && (ToolbarWinH - 3 > mainHeight - ThumbsStatusBarH)) ? ToolbarWinW + 5 : 0
       tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
       infoBoxBMP := drawTextInBox(theMsg, OSDFontName, Round(OSDfontSize*0.9), mainWidth, mainHeight//3, OSDtextColor, bgrTXT, 1)
       trGdip_GetImageDimensions(infoBoxBMP, ThumbsStatusBarW, ThumbsStatusBarH)
       statusPosX := -1 + tlbrBonusX
       ThumbsStatusBarW := clampInRange(ThumbsStatusBarW, 1, mainWidth - imgHUDbaseUnit//3.3)
       If tlbrBonusX
          Gdip_FillRectangle(2NDglPG, OSDwinFadedBrushBGR, 0, mainHeight - ThumbsStatusBarH, tlbrBonusX, ThumbsStatusBarH)

       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, statusPosX, mainHeight - ThumbsStatusBarH)
       If (simpleMode=0)
       {
          ; theMSG2 := theMSG
          If (markSearchMatches=1 && userSearchString && modus!="all")
          {
             If coreSearchIndex(getIDimage(currentFileIndex), thisSearchString, userSearchWhat)
             {
                Gdip_FillRectangle(2NDglPG, pBrushD, statusPosX, mainHeight - ThumbsStatusBarH, OSDfontSize//2.5+1, ThumbsStatusBarH)
                theMSG2 .= " | File matches search criteria" 
             }
          }

          If (resultedFilesList[currentFileIndex, 3]=1)
          {
             Gdip_DrawRectangle(2NDglPG, pPen5, statusPosX, mainHeight - ThumbsStatusBarH, ThumbsStatusBarW, ThumbsStatusBarH)
             theMSG2 .= " | Image already seen"
             If resultedFilesList[currentFileIndex, 35]
               theMsg2 .= " on " resultedFilesList[currentFileIndex, 35]
          }

          If (resultedFilesList[currentFileIndex, 5]=1)
          {
             Gdip_DrawRectangle(2NDglPG, pPen1d, statusPosX, mainHeight - ThumbsStatusBarH, ThumbsStatusBarW, ThumbsStatusBarH)
             theMSG2 .= " | Added to favourites"
          }

          If (bgrTXT!=OSDbgrColor)
             theMSG2 .= " | File selected"

          If StrLen(filesFilter)>1
             theMSG2 .= " | Files list filtered"

          listInfos := "Files list container: " maxItemsPage " elements in view. Listing mode: " defineListViewModes() ". Tap and hold, or Control+Left-Click, on any listed item to select it. Items listed:`n" listedItems
          If (actu!="scroll")
             interfaceThread.ahkPostFunction("uiAccessUpdateUiStatusBar", theMSG2, ThumbsStatusBarH, 0, listInfos, OSDfontSize, maxFilesIndex)

          trGdip_DisposeImage(infoBoxBMP, 1)
          If (showHUDnavIMG=1 && actu!="scroll") ;  && (thumbsListViewMode>1 || isDupesList=1))
          {
             VPnavBoxWrapper(mainWidth, mainHeight - ThumbsStatusBarH, 2NDglPG)
          } Else If (actu!="scroll")
          {
             interfaceThread.ahkPostFunction("uiAccessUpdateNavBox", "hide", 1, 1, 0, 0)
             hasDrawnImageMap := 0
          }
       }
    }

    ; calculate the scrollbar region
    knobSize := getScrollWidth()
    knobBtn := Round(knobSize*1.5)
    ScrollRegionH := mainHeight - knobBtn*2 - 4
    scrollYpos := (startIndex - 1)/maxFilesIndex
    scrollYpos := Round(ScrollRegionH*scrollYpos + knobBtn + 2)
    scrollHeight := getScrollThumbsHeight(ScrollRegionH, maxItemsPage, maxItemsH, maxPages)
    scrollYpos := clampInRange(scrollYpos, knobBtn, ScrollRegionH + knobBtn - scrollHeight + 1)
    If validBMP(listMap)
    {
       trGdip_GetImageDimensions(listMap, lW, lH)
       If mapOffset
       {
          mapOffset := knobBtn - Round((lH + knobBtn*4) * (currentFileIndex / maxFilesIndex))//2
          tzGdip_DrawImage(2NDglPG, listMap, mainWidth - knobSize - imgHUDbaseUnit//2, mapOffset)
       } Else
       {
          Gdip_FillRectangle(2NDglPG, pBrushWinBGR, mainWidth - knobSize - imgHUDbaseUnit//2, 0, lW, mainHeight)
          tzGdip_DrawImage(2NDglPG, listMap, mainWidth - knobSize - imgHUDbaseUnit//2, knobBtn, lW, ScrollRegionH)
       }
    }

    If (mustDrawBoxNow=1 || simpleMode>=1)
    {
       ; draw top line progress bar
       tSize := (imgHUDbaseUnit//3.5)//2
       Gdip_FillRectangle(2NDglPG, pBrushE, 0, 0, mainWidth - knobSize, tSize)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, Round((mainWidth - knobSize)*(currentFileIndex/maxFilesIndex)), tSize)
    }

    Gdip_ResetClip(2NDglPG)
    If (scrollHeight<ScrollRegionH || startIndex>1 && scrollHeight>ScrollRegionH && maxItemsPage>maxFilesIndex)
    {
       ; draw the scrollbar
       whichBrush := (actu="scroll") ? pBrushWinBGR : pBrushC
       Gdip_FillRectangle(2NDglPG, whichBrush, mainWidth - knobSize, 0, knobSize, mainHeight)
       Gdip_FillRectangle(2NDglPG, pBrushE, mainWidth - knobSize - 2, 0, knobSize + 4, mainHeight)
       Gdip_FillRectangle(2NDglPG, pBrushD, mainWidth - knobSize, scrollYpos, knobSize, scrollHeight)
       Gdip_FillRectangle(2NDglPG, pBrushD, mainWidth - knobSize, 0, knobSize, knobBtn)
       Gdip_FillRectangle(2NDglPG, pBrushD, mainWidth - knobSize, mainHeight - knobBtn, knobSize, knobBtn)
       If (actu!="scroll")
       {
          Gdip_FillEllipseC(2NDglPG, pBrushE, mainWidth - knobSize/2, knobBtn/2, knobSize/4)
          Gdip_FillEllipseC(2NDglPG, pBrushE, mainWidth - knobSize/2, mainHeight - knobBtn/2, knobSize/4)
       }
    }

    SetTimer, ResetImgLoadStatus, -25
    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIselectWin, 2NDglHDC)
    If (toolTipGuiCreated=2)
    {
       clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       toolTipGuiCreated := 0
    }
}

getScrollThumbsHeight(ScrollRegionH, maxItemsPage, maxItemsH:=0, maxPages:=0) {
    scrollHeight := (maxItemsPage/maxFilesIndex)*100
    scrollHeight := Round((ScrollRegionH/100)*scrollHeight)
    If (scrollHeight<imgHUDbaseUnit//4.5)
       scrollHeight := imgHUDbaseUnit//4.5
    Return scrollHeight
}

getScrollWidth() {
   Return imgHUDbaseUnit//3
}

generateFilesListMap(dummy:=0) {
   Static lastVal := 0
   thisVal := 0
   If (!markedSelectFile && dummy="auto")
      thisVal := lastVal ? 5 : 3
   Else
      thisVal := 2

   lastVal := !lastVal
   vpWinClientSize(mainWidth, mainHeight)
   mainBMP := trGdip_CreateBitmap(A_ThisFunc, 2, maxFilesIndex)
   G1 := trGdip_GraphicsFromImage(A_ThisFunc, mainBMP)
   Gdip_GraphicsClear(G1, "0xFF" WindowBgrColor)
   thisColor := (thisVal=2) ? "33EEFF" : "FF9922"
   thisThick := (maxFilesIndex - 10<mainHeight) ? 1 : 2
   If (thisVal=2 && markedSelectFile/maxFilesIndex<3 && maxFilesIndex>mainHeight*2)
      thisThick := 3

   countThese := 0
   selPen := Gdip_CreatePen("0xFF" thisColor, thisThick)
   Loop, % maxFilesIndex
   {
        If resultedFilesList[A_Index, thisVal]
        {
           Gdip_DrawLine(G1, selPen, -1, A_Index, 3, A_Index)
           countThese++
        }
   }

   Gdip_DeleteGraphics(G1)
   Gdip_DeletePen(selPen)
   If !countThese
   {
      trGdip_DisposeImage(mainBMP)
      Return
   }

   If (thisVal=2)
      markedSelectFile := countThese

   knobSize := getScrollWidth()
   knobBtn := Round(knobSize*1.5)
   ScrollRegionH := mainHeight - knobBtn*2 - 4
   doubled := 0
   If (maxFilesIndex//3>mainHeight && dummy!="auto")
   {
      doubled := 1
      fH := mainHeight * 2
   } Else fH := ScrollRegionH

   knobSize := imgHUDbaseUnit//2
   finalBMP := trGdip_ResizeBitmap(A_ThisFunc, mainBMP, knobSize, fH, 0, 7)
   trGdip_DisposeImage(mainBMP)

   sFinal := trGdip_CreateBitmap(A_ThisFunc, knobSize, fH, "0x21808")
   G1 := trGdip_GraphicsFromImage(A_ThisFunc, sFinal)
   tzGdip_DrawImageFast(G1, finalBMP)
   tzGdip_DrawImageFast(G1, finalBMP)
   Gdip_DeleteGraphics(G1)
   trGdip_DisposeImage(finalBMP)
   Return [sFinal, thisVal, doubled]
}

dummyRecountSelectedFiles() {
   getSelectedFiles(0, 1)
}

EraseThumbsCache(dummy:=0, remCacheOldDays:=0) {
   startZeit := A_TickCount
   showTOOLtip("Emptying thumbnails cache, please wait")
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   countTFilez := countFilez := 0
   Loop, Files, %thumbsCacheFolder%\*.*
   {
      If !isVarEqualTo(A_LoopFileExt, "tiff", "png", "jpg")
         Continue

      changeMcursor()
      timeNow := %A_Now%
      EnvSub, timeNow, %A_LoopFileTimeCreated%, Days
      mustRem := (timeNow>remCacheOldDays && dummy="daysITis") ? 1 : 0
      countTFilez++
      If (mustRem=1 || dummy!="daysITis")
      {
         FileDelete, % A_LoopFileFullPath
         If !ErrorLevel
            countFilez++
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         showTOOLtip("Emptying thumbnails cache, please wait`n" countFilez " removed until now.")
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   If (dummy="daysITis")
   {
      moreInfo := " out of " countTFilez
      friendly := " older than " remCacheOldDays " days"
   }


   If (abandonAll=1)
      showTOOLtip("Operation aborted. Removed " countFilez " cached thumbnails until now")
   Else If (A_TickCount - startZeit>1500) || (dummy="daysITis")
      showTOOLtip("Finished removing " countFilez moreInfo " cached thumbnails" friendly)
   
   remCacheOldDays := 0
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createThumbsFolder() {
    If !FolderExist(thumbsCacheFolder)
    {
       FileCreateDir, %thumbsCacheFolder%
       If ErrorLevel
          Return "error"
    }
}

ObjToString(obj) {
  if (!IsObject(obj))
    return obj
  str := "`n{"
  for key, value in obj
    str .= "`n" key ": " ObjToString(value) ","
  return str "`n}"
}

CustomObjToString(obj) {
  if (!IsObject(obj))
    return obj
;  str := "|&|"
  for key, value in obj
    str .= "?" key "|" CustomaObjToString(value)
  return str ; "|&|"
}

CustomaObjToString(obj) {
  if (!IsObject(obj))
    return obj
 ; str := "/&/"
  for key, value in obj
    str .= "<" ObjToString(value) "@"
  return str ; "/&/"
}

StrToObject(stringu) {
  newArrayu := []
  Loop, Parse, stringu, ?
  {
      If !A_LoopField
         Continue
      lineArrayu := StrSplit(A_LoopField, "|<")
      thisIndex := lineArrayu[1]
      preparedOther := StrReplace(lineArrayu[2], "@")
      otherLineArrayu := StrSplit(preparedOther, "<")
      ; MsgBox, % A_LoopField "`n" thisIndex "`n" preparedOther "`n" otherLineArrayu[1] "`n" lineArrayu[2] "`n" A_Index
      Loop, % otherLineArrayu.Count()
          newArrayu[thisIndex, A_Index] := otherLineArrayu[A_Index]
  }
  ; MsgBox, % CustomObjToString(newArrayu)
  Sleep, 50
  Return newArrayu
}

generateAllThumbsNow() {
   Static chunkSize := 1500
   If (thumbsDisplaying!=1 || maxFilesIndex<3 || !CurrentSLD)
      Return

   currentFileIndex := 1
   thumbsListViewMode := 1
   ; If (thumbnailsListMode!=1)
   ;    initAHKhThumbThreads()

   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   loopTimes := Ceil(maxFilesIndex/chunkSize)
   startZeit := A_TickCount
   Loop, % loopTimes
   {
      currentFileIndex := (A_Index - 1) * chunkSize
      If !currentFileIndex
         currentFileIndex := 1

      r := QPV_ShowThumbnails("all", A_Index * chunkSize, startZeit)
      If r
         Break
   }
 
   currentFileIndex := 1
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(90)
   SoundBeep , 900, 100
   SetTimer, ResetImgLoadStatus, -25
   RemoveTooltip()
}

ScreenCaptureListView() {
   ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIselectwin)
   ; clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
   r := Gdip_BitmapFromHWND(PVhwnd, 1)
   If StrLen(r)>2
      recordGdipBitmaps(r, A_ThisFunc)

   pBitmap := r
   If validBMP(pBitmap)
   {
      r := Gdip_SetBitmapToClipboard(pBitmap)
      trGdip_DisposeImage(pBitmap, 1)
      If !r
      {
         showDelayedTooltip("List view captured as image. It is now in the Clipboard.`nYou can paste the image in the image view.")
      } Else
      {
         SoundBeep 300, 100
         showDelayedTooltip("ERROR: Failed to set image to clipoard")
      }
   } Else
   {
      SoundBeep 300, 100
      showDelayedTooltip("ERROR: Failed to capture image of the list view")
   }
   dummyTimerDelayiedImageDisplay(50)
}

saveImageThumbnail(oBitmap, file2save) {
    Gdip_GetImageDimensions(oBitmap, zww, zhh)
    kBitmap := trGdip_CreateBitmap(A_ThisFunc, zww, zhh)
    If validBMP(kBitmap)
       Guzz := Gdip_GraphicsFromImage(kBitmap)

    If Guzz
    {
       thisBrush2 := createHatchBrush(128)
       Gdip_FillRectangle(Guzz, thisBrush2, 0, 0, zww, zhh)
       Gdip_DeleteBrush(thisBrush2)
       Gdip_DrawImageFast(Guzz, oBitmap)
       Gdip_DeleteGraphics(Guzz)
       zr := Gdip_SaveBitmapToFile(kBitmap, file2save, 94)
       trGdip_DisposeImage(kBitmap, 1)
       If zr
          addJournalEntry("Failed to save thumbnail to file: " file2save)
    } Else
    {
       trGdip_DisposeImage(kBitmap, 1)
       zr := Gdip_SaveBitmapToFile(oBitmap, file2save, 94)
       If zr
          addJournalEntry("Failed to save thumbnail to file: " file2save)
    }
}

QPV_ShowThumbnails(modus:=0, allStarter:=0, allStartZeit:=0) {
    Critical, on
    prevFullThumbsUpdate := A_TickCount
    mainStartZeit := A_TickCount
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    If (modus="all")
    {
       maxItemsW := maxItemsH := allStarter//2 + 1
       maxItemsPage := allStarter + 1
       ; MsgBox, % maxItemsPage
    }

    If (thumbsListViewMode>1)
    {
       QPV_listThumbnailsGridMode(0, glPG, glHDC, hGDIthumbsWin)
       Return
    }

    setImageLoading()
    If (minimizeMemUsage!=1)
    {
       thumbsBitmap := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, coreDesiredPixFmt)
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbsBitmap, 5, 1)
       If !G2
       {
          trGdip_DisposeImage(thumbsBitmap, 1)
          thumbsBitmap := ""
          G2 := glPG
       }
    } Else G2 := glPG

    hasUpdated := rowIndex := imgsListed := 0
    maxImgSize := maxZeit := columnIndex := -1
    fnOutputDebug("Begin show " maxItemsPage " thumbs from index " startIndex)
    setPriorityThread(-2)
    DestroyGIFuWin()
    createThumbsFolder()
    Gdip_GraphicsClear(glPG, "0xFF" WindowBgrColor)
    If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, mainWidth + 5, mainHeight + 5)
    prevGUIupdate := A_TickCount
    imgsListArrayThumbs := []
    lastMsg := imgsMustPaint := imgsNotCached := 0
    doStartLongOpDance()
    Loop, % maxItemsW*maxItemsH*2
    {
        ; identify what needs to be done; are thumbs cached in memory? load files or...?
        If (modus="all" && maxFilesIndex>100)
        {
           If (determineTerminateOperation()=1)
           {
              fnOutputDebug("ThumbsMode. User abandoned the operation during preparations phase of generate all thumbs.")
              abandonAll := 1
              hasUpdated := 0
              Break
           }
        }

        thisFileIndex := startIndex + A_Index - 1
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH || thisFileIndex>maxFilesIndex) || (modus="all" && thisFileIndex>allStarter)
        {
           ; If (thisFileIndex>maxFilesIndex)
           ;    SoundBeep , 300, 100
           Break
        }

        If (modus="all") && (A_TickCount - lastMsg > 450)
        {
           lastMsg := A_TickCount
           showTOOLtip("Preparing to generate all thumbnails: " thisFileIndex "/" maxFilesIndex, 0, 0, thisFileIndex / maxFilesIndex)
        }

        imgPath := StrReplace(getIDimage(thisFileIndex), "||")
        thisFileDead := !FileRexists(imgPath)
        DestPosX := thumbsW//2 + thumbsW*columnIndex
        DestPosY := thumbsH//2 + thumbsH*rowIndex
        memCached := wasThumbCached := 0
        MD5name := generateThumbName(imgPath, 1)
        isForceRefresh := resultedFilesList[thisFileIndex, 4]
        If (thisFileDead=1)
        {
           imgsListArrayThumbs[thisFileIndex] := ["x", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else If validBMP(imgThumbsCacheArray[imgThumbsCacheIDsArray[MD5name], 1])
        {
           memCached := 1
           imgsListArrayThumbs[thisFileIndex] := ["m", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else
        {
           wasThumbCached := (isForceRefresh=1) ? 0 : checkThumbExists(MD5name, imgPath, file2load)
           fnOutputDebug("Thumb = " thisFileIndex  " cached=" wasThumbCached " original file: " imgPath " thumb file: " file2load)
           If (wasThumbCached=1)
              imgsListArrayThumbs[thisFileIndex] := ["f", 0, imgPath, file2load, DestPosX, DestPosY, MD5name]
        }

        If (currentFileIndex=thisFileIndex)
        {
           sizeSquare := thumbsSizeQuality//10
           Gdip_FillRectangle(glPG, pBrushA, DestPosX - sizeSquare//2, DestPosY - sizeSquare//2, sizeSquare, sizeSquare)
        }

        imgsMustPaint++
        If (memCached=1 || wasThumbCached=1 || thisFileDead=1) && (isForceRefresh!=1)
           Continue

        imgsNotCached++
        ; Gdip_FillRectangle(glPG, pBrushE, DestPosX - 10, DestPosY - 10, 20, 20)
        file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
        If (isForceRefresh=1)
        {
           FileDelete, % file2save
           resultedFilesList[thisFileIndex, 4] := 0
        }

        thisType := imgPath ? "w" : "x"
        imgsListArrayThumbs[thisFileIndex] := [thisType, 0, imgPath, file2save, DestPosX, DestPosY, MD5name]
        ; fnoutputdebug("thumbs prepare " imgPath "|" thisFileIndex "|" MD5name)
    }

   limitCores := realSystemCores + 1
   filesPerCore := imgsNotCached//limitCores
   If (filesPerCore<2 && limitCores>1)
   {
      systemCores := imgsNotCached//2
      filesPerCore := imgsNotCached//systemCores
   } Else systemCores := limitCores

   maxLimitReached := (minimizeMemUsage=1) && (maxFilesIndex>654321 || bckpMaxFilesIndex>654321) ? 1 : 0
   mustDoMultiCore := (allowMultiCoreMode=1 && maxLimitReached!=1 && systemCores>1 && filesPerCore>1 && multiCoreThumbsInitGood=1) ? 1 : 0
   fnOutputDebug("ThumbsMode. Init. doMultiCore:" mustDoMultiCore ", cores:" systemCores ", filesPerCore:" filesPerCore ", imgsNotCached:" imgsNotCached ", imgsMustPaint:" imgsMustPaint)
   If !isWinXP
      memInfos := getMemUsage()

   fnOutputDebug("ThumbsMode. Memory usage: " thisMemoryLoad "%")
   If (memInfos.appPrcMem>70 || memInfos.prcSys>90 || isWinXP=1 || A_PtrSize=4)
   {
      fnOutputDebug("ThumbsMode. Memory usage above 70%. Multi-threaded thumbnails generation deactivated.")
      mustDoMultiCore := 0
   }

   ; how much time in miliseconds can an image take to load and not be cached
   timePerImg := 1550//imgsNotCached
   If (timePerImg<25 || modus="all")
      timePerImg := 25
   Else If (timePerImg>300)
      timePerImg := 300

   timePerImgMultiCore := (modus="all") ? 25 : timePerImg*2 + limitCores*2
   If (timePerImgMultiCore>350)
      timePerImgMultiCore := 350

   If (mustDoMultiCore=1)
   {
      fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. Cores: " limitCores)
      Loop, % limitCores
          thumbThread%A_Index%.ahkFunction("cleanMess", "c" A_Index)
      ; fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. DONE")
   } Else limitCores := 1

   thisImgQuality := (userimgQuality=1) ? 6 : 5
   sizesDesired := []
   sizesDesired[1] := [thumbsSizeQuality, thumbsSizeQuality, 1, 0, thisImgQuality]
   thisFileIndex := MD5name := Bindex := hasUpdated := rowIndex := imgsListed := lastMsg := 0
   imgsHavePainted := thisNonCachedImg := coreIndex := threadIndex := memCached := lapsOccured := totalLoops := 0
   lowestGiven := maxIndexu := maxImgSize := maxZeit := columnIndex := -1
   prevCoreEventZeit := A_TickCount - 2
    ; MsgBox, % filesPerCore "--" imgsMustPaint "--" imgsNotCached "--" imgsListArrayThumbs.Length()
   interfaceThread.ahkassign("alterFilesIndex", 0)
   If (userPrivateMode=1)
      blurEffect := Gdip_CreateEffect(1, clampInRange(thumbsSizeQuality//2, 30, thumbsSizeQuality*2), 0, 0)

   If (abandonAll!=1)
   {
      Loop
      {
          alterFilesIndex := interfaceThread.ahkgetvar.alterFilesIndex
          If (alterFilesIndex>1 && lapsOccured>3)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation by scrolling.")
             userScrolled := 1
             Break
          }

          totalLoops++
          If (determineTerminateOperation()=1)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation.")
             abandonAll := 1
             hasUpdated := 0
             Break
          }

          ; Sleep, 0
          Bindex++
          If (Bindex>imgsMustPaint)
          {
             lapsOccured++
             Bindex := 1
          }

          thisFileIndex := startIndex + Bindex - 1
          If (mustEndLoop=1)
          {
             ; fnOutputDebug("ThumbsMode. Must end loop = 1. laps " lapsOccured "  -- loops " totalLoops "  -- inner " innerLoops " ")
             hasUpdated := 0
             Break
          }

          If (imgsHavePainted>=imgsMustPaint)
             mustEndLoop := 1

          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          If (cacheType="d")
             Continue

          If (cacheType="x")
          {
             addJournalEntry("ThumbsMode. Failed to generate. " thisFileIndex " = " imgsListArrayThumbs[thisFileIndex, 3])
             imgsListArrayThumbs[thisFileIndex, 1] := "d"
             thumbsFailures++
             imgsHavePainted++
             Continue
          }

          If (modus="all") && (A_TickCount - lastMsg > 750)
          {
             allStuffPerc := (startIndex + imgsHavePainted) / maxFilesIndex
             etaTime := ETAinfos(startIndex + imgsHavePainted, maxFilesIndex, allStartZeit)
             If (mustDoMultiCore=1)
                etaTime .= "`nUsing multi-threaded processing"

             showTOOLtip("Generating all thumbnails at " thumbsSizeQuality "px: " etaTime, 0, 0, allStuffPerc)
             lastMsg := A_TickCount
          }

          innerLoops++
          If (cacheType="w" && mustDoMultiCore=1)
          {
             ; Sleep, -1
             thisCoreDoneLine := ""
             thisCoreDoneArr := ""
             whichCoreBusy := imgsListArrayThumbs[thisFileIndex, 8]
             mamUsage := GetProcessMemoryUsage(QPVpid)
             systemMemInfo := GlobalMemoryStatusEx()
             thisMemoryLoad := Round((max(mamUsage[1], mamUsage[8])/Round(systemMemInfo.TotalPhys*0.9))*100, 1)
             If (A_TickCount - prevCoreEventZeit>69500 && innerLoops>2 && lapsOccured>2 && totalLoops>2)
             {
                fnOutputDebug("ThumbsMode. Wait time since last new core started ... exceeded.  " thisFileIndex " . Loop. Break. Now. :-) ")
                Break
             }

             If (whichCoreBusy>0)
             {
                hasThumbFailed := thumbThread%whichCoreBusy%.AHKgetvar.operationFailed
                thisCoreDoneLine := thumbThread%whichCoreBusy%.AHKgetvar.resultsList
                thisCoreDoneArr := StrSplit(thisCoreDoneLine, "|")
                waitDataCollect := thumbThread%whichCoreBusy%.AHKgetvar.waitDataCollect
                If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && thisCoreDoneArr[5]=Bindex && waitDataCollect=1)
                {
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   If StrLen(thisPBitmap)>2
                      thisPBitmap := trGdip_CloneBitmap(A_ThisFunc "<-FIM_ExternThread", thisPBitmap, 1)
                   imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "fim"
                   imgsListArrayThumbs[thisCoreDoneArr[3], 2] := validBMP(thisPBitmap) ? thisPBitmap : 0
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      addJournalEntry("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "x"
                   }
                } Else If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && waitDataCollect=1)
                {
                   ; SoundBeep 
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisFileIndex := thisCoreDoneArr[3]
                   Bindex := thisCoreDoneArr[5]
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   If StrLen(thisPBitmap)>2
                      thisPBitmap := trGdip_CloneBitmap(A_ThisFunc "<-FIM_ExternThread", thisPBitmap, 1)
                   imgsListArrayThumbs[thisFileIndex, 1] := "fim"
                   imgsListArrayThumbs[thisFileIndex, 2] := validBMP(thisPBitmap) ? thisPBitmap : 0
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      addJournalEntry("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisFileIndex, 1] := "x"
                   }
                } Else Continue
             } Else
             {
                coreIndex++
                If (coreIndex>limitCores)
                   coreIndex := 1

                thisCoreDone := thumbThread%coreIndex%.AHKgetvar.operationDone
                waitDataCollect := thumbThread%coreIndex%.AHKgetvar.waitDataCollect
                hasThumbFailed := thumbThread%coreIndex%.AHKgetvar.operationFailed
                If (thisMemoryLoad<90 && thisCoreDone=1 && waitDataCollect<1 && hasThumbFailed=0)
                {
                   prevCoreEventZeit := A_TickCount
                   ; thumbThread%coreIndex%.ahkassign("operationDone", 0)
                   ; thumbThread%coreIndex%.ahkassign("waitDataCollect", 0)
                   thisPath := imgsListArrayThumbs[thisFileIndex, 3]
                   thisSavePath := imgsListArrayThumbs[thisFileIndex, 4]
                   thumbThread%coreIndex%.ahkPostFunction("MonoGenerateThumb", thisPath, thisSavePath, enableThumbsCaching "|" thumbsSizeQuality "|" userHQraw "|" allowToneMappingImg "|" timePerImgMultiCore "|" coreIndex "|" thisFileIndex "|" allowWICloader, Bindex)
                   imgsListArrayThumbs[thisFileIndex, 8] := coreIndex
                   ; fnOutputDebug("ThumbsMode. Work assigned to thread. IMG #" thisFileIndex ". Core " coreindex " ")
                   Sleep, 1
                }
                Continue
             }
          }

          ; Sleep, 1
          changeMcursor()
          startZeit := A_TickCount
          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          ; fnOutputDebug("thumbs inner " thisCoreDoneLine " -- cT" cacheType " --cB" whichCoreBusy  " -- " reallyThreadsDone " -- loops infos " A_Index " -- " innerLoops " -- " lapsOccured " -- " totalLoops " -- " imgsHavePainted " -- " imgsMustPaint)
          fimCached := mustDisposeImgNow := 0
          wasCacheFile := thumbCachable := WasMemCached := hasNowMemCached := 0
          If (cacheType="w")
          {
             ; when the original file must be loaded
             If (mustDoMultiCore=1)
                Continue

             ; mustDisposeImgNow := 1
             thumbCachable := 1
             imgsListArrayThumbs[thisFileIndex, 1] := "f"
             oBitmap := 0
             file2load := imgsListArrayThumbs[thisFileIndex, 3]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 0, 0, sizesDesired)
             GetCachableImgFileDetails(file2load, thisFileIndex, oBitmap, 0, 0)
          } Else If (cacheType="m")
          {
             WasMemCached := 1
             MD5name := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := imgThumbsCacheArray[imgThumbsCacheIDsArray[MD5name], 1]
          } Else If (cacheType="f")
          {
             wasCacheFile := 1
             file2load := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 1)
          } Else If (cacheType="fim")
          {
             fimCached := 1
             oBitmap := imgsListArrayThumbs[thisFileIndex, 2]
             If !validBMP(oBitmap)
             {
                ; mustDisposeImgNow := 1
                cacheType := "f"
                wasCacheFile := 1
                fimCached := 0
                file2load := imgsListArrayThumbs[thisFileIndex, 4]
                fnOutputDebug("missing thumb cached with a FIM thread " thisFileIndex ". Trying to load file... " file2load)
                If !FileRexists(file2load)
                {
                   wasCacheFile := fimCached := 0
                   thumbCachable := 1
                   file2load := imgsListArrayThumbs[thisFileIndex, 3]
                   oBitmap := LoadBitmapFromFileu(file2load, 0, 0, 0, sizesDesired)
                } Else
                   oBitmap := LoadBitmapFromFileu(file2load, 0, 1)
             }
          }

          extendedLoops++
          imgsListArrayThumbs[thisFileIndex, 1] := "d"
          imgPath := imgsListArrayThumbs[thisFileIndex, 3]
          MD5name := imgsListArrayThumbs[thisFileIndex, 7]
          file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
          trGdip_GetImageDimensions(oBitmap, imgW, imgH)

          If (!validBMP(oBitmap) || !FileExist(imgPath) || !imgW || !imgH)
          {
             If (WasMemCached=1)
             {
                wasThumbCached := checkThumbExists(MD5name, imgPath, file2load)
                imgsListArrayThumbs[thisFileIndex, 1] := FileExist(file2load) ? "fim" : "w"
                imgsListArrayThumbs[thisFileIndex, 2] := 0
                imgsListArrayThumbs[thisFileIndex, 4] := file2load
             } Else imgsHavePainted++

             DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
             DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
             r1 := Gdip_DrawRectangle(G2, pPen4, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
             fnOutputDebug("broken thumb: mem" WasMemCached " -- w" imgW "-- h" imgH "-- obj bmp id" oBitmap)
             Continue
          } Else imgsHavePainted++

          If (thumbCachable=1)
          {
             ; fnOutputDebug("must resize GDI object thumbCachable=1. " oBitmap)
             zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, thumbsW, thumbsH, 1, thisImgQuality, -1)
             If validBMP(zBitmap)
             {
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. " oBitmap)
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. DONE")
                oBitmap := zBitmap
             }
          } Else If (WasMemCached!=1 && modus!="all")
          {
             ; fnOutputDebug("must clone GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
             zBitmap := cloneGDItoMem(A_ThisFunc, oBitmap, imgW, imgH)
             If (fimCached!=1)
             {
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
                ; fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. DONE")
             }
             If validBMP(zBitmap)
                oBitmap := zBitmap
          }

          thisZeit := A_TickCount - startZeit
          ; fnOutputDebug("MEM cached thumbs infos: " memCached " -- " hasMemThumbsCached " -- " imgThumbsCacheIDsArray[MD5name] " = " file2save)
          trGdip_GetImageDimensions(oBitmap, newW, newH)
          If (!newW || !newH)
          {
             addJournalEntry("Faulty GDI thumbnail. File index: " thisFileIndex ". GDI bmp: " oBitmap "." imgsListArrayThumbs[thisFileIndex, 3])
             oBitmap := trGdip_DisposeImage(oBitmap, 1)
             DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
             DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
             r1 := Gdip_DrawRectangle(G2, pPen4, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
             ; fnOutputDebug("ThumbsMode. Faulty GDI thumbnail object disposed.")
             Continue
          }

          If (WasMemCached!=1 && minimizeMemUsage!=1 && modus!="all")
          {
             hasNowMemCached := 1
             hasMemThumbsCached++ 
             ; fnOutputDebug("ThumbsMode. Memory cached GDI thumb to be disposed: " imgThumbsCacheArray[hasMemThumbsCached, 1] )
             ; fnOutputDebug("ThumbsMode. A memory cached GDI thumb to be disposed... DONE")
             trGdip_DisposeImage(imgThumbsCacheArray[hasMemThumbsCached, 1], 1)
             imgThumbsCacheIDsArray[imgThumbsCacheArray[hasMemThumbsCached, 2]] := ""

             imgThumbsCacheArray[hasMemThumbsCached] := [oBitmap, MD5name]
             imgThumbsCacheIDsArray[MD5name] := hasMemThumbsCached
             If (hasMemThumbsCached>maxMemThumbsCache)
                hasMemThumbsCached := 0
          }

          calcIMGdimensions(newW, newH, thumbsW, thumbsH, fW, fH)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
          DestPosX -= (imageAligned!=5) ? thumbsW//2 : fW//2
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
          DestPosY -= (imageAligned!=5) ? thumbsH//2 : fH//2
          If (fimCached!=1 && thumbCachable=1 && thisZeit>timePerImg && file2save!=file2load && enableThumbsCaching=1 && WasMemCached!=1)
          && ((newW<imgW//2) || (newH<imgH//2))
          {
             ; fnOutputDebug("Saving thumb for: " file2load " -- " file2save) 
             saveImageThumbnail(oBitmap, file2save)
          }

          If (WasMemCached=1 || hasNowMemCached=1)
          {
             zBitmap := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
             oBitmap := zBitmap
          }

          If (bwDithering=1 && imgFxMode=4) || (modus="all")
          {
             nullu := ""
          } Else If (usrColorDepth>1)
          {
             ; fnOutputDebug("ThumbsMode. Changing thumb color depth... " oBitmap)
             E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
          }

          If (modus!="all")
          {
             ; fnOutputDebug("ThumbsMode. (maybe) flipping thumb... " oBitmap)
             flipBitmapAccordingToViewPort(oBitmap)
             ; changeMcursor()
             hasUpdated := 0
             ; fnOutputDebug("ThumbsMode. Drawing image thumb: " oBitmap)
             If (userPrivateMode=1 && blurEffect)
                Gdip_BitmapApplyEffect(oBitmap, blurEffect)
             r1 := Gdip_FillRectangle(G2, pBrushHatchLow, DestPosX, DestPosY, fW - 1, fH - 1)
             r1 := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, DestPosX, DestPosY, fW - 1, fH - 1)
          }

          ; fnOutputDebug("ThumbsMode. Disposing GDI thumb after drawing: " oBitmap)
          oBitmap := trGdip_DisposeImage(oBitmap, 1)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
          If (highlightAlreadySeenImages=1 && mustRecordSeenImgs=1 && modus!="all")
          {
             If retrieveSeenImageDBentry(imgPath, thisFileIndex)
             {
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
             }
          }

          If (markSearchMatches=1 && userSearchString && modus!="all")
          {
             If coreSearchIndex(imgPath, thisSearchString, userSearchWhat)
                Gdip_FillRectangle(G2, pBrushD, DestPosX - thumbsW//2, DestPosY - thumbsH//2, Ceil(thumbsW*0.05), thumbsH - 8)
          }

          If ((A_TickCount - prevGUIupdate>350) && modus!="all")
          {
             ; fnOutputDebug("ThumbsMode. Redraw the whole window.")
             If (minimizeMemUsage!=1 && validBMP(thumbsBitmap))
                r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)
             r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
             prevGUIupdate := A_TickCount
             If (minimizeMemUsage!=1)
                hasUpdated := 1
          }
      }
   }

    Gdip_DisposeEffect(blurEffect)
    If (alterFilesIndex>1 && mustEndLoop!=1 && lapsOccured>3 && modus!="all")
    {
       mustReloadThumbsList := 1
       ; mainGdipWinThumbsGrid()
       SetTimer, ForceRefreshNowThumbsList, -350
       ; Return
    } Else If (mustDoMultiCore=1 && mustEndLoop=1 && abandonAll!=1 && modus!="all")
    {
       ; fnOutputDebug("ThumbsMode after. Clean GDIs mess. Cores: " limitCores)
       Loop, % limitCores
           thumbThread%A_Index%.ahkFunction("cleanMess", "c" A_Index)
       ; fnOutputDebug("Thumbnails generator after. Clean GDIs mess. DONE.")
    }

    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    setPriorityThread(0)
    If (modus!="all" && (minimizeMemUsage=1 || !validBMP(thumbsBitmap)))
    {
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
    } Else If (modus!="all" && validBMP(thumbsBitmap))
    {
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(A_ThisFunc, thumbsBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If validBMP(zBitmap)
          {
             trGdip_DisposeImage(thumbsBitmap, 1)
             thumbsBitmap := zBitmap
          }
          E := Gdip_BitmapSetColorDepth(thumbsBitmap, "BW", 1)
       }
       If !isWinXP
          decideGDIPimageFX(matrix, imageAttribs, pEffect)

       ; fnOutputDebug("ThumbsMode end. Redraw the whole window.")
       If (pEffect || imageAttribs)
          r1 := trGdip_DrawImageFX(A_ThisFunc, glPG, thumbsBitmap, 0, 0, 0, 0, mainWidth, mainHeight, matrix, pEffect, imageAttribs)
       Else If (hasUpdated=0)
          r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)

       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, glHDC)
    }

    If (minimizeMemUsage!=1)
       Gdip_DeleteGraphics(G2)

    trGdip_DisposeImage(thumbsBitmap, 1)
    Gdip_DisposeImageAttributes(imageAttribs)
    Gdip_DisposeEffect(pEffect)
    ; ToolTip, %imgW% -- %imgH% == %newW% -- %newH%
    prevFullThumbsUpdate := A_TickCount
    If (!userScrolled && !abandonAll && alterFilesIndex!=1)
    {
       mustReloadThumbsList := 0
       prevFullIndexThumbsUpdate := startPageIndex
    }

    If (abandonAll=1)
       lastLongOperationAbort := A_TickCount

    executingCanceableOperation := 0
    If (modus!="all")
       SetTimer, ResetImgLoadStatus, -25

    prevFullThumbsUpdate := A_TickCount
    addJournalEntry(maxItemsPage " thumbnails listed in " SecToHHMMSS((A_TickCount - mainStartZeit)/1000) ".")
    ; ToolTip, % lapsOccured "|"  totalLoops " | " innerLoops " | " extendedLoops " | " imgsNotCached "`nZeit: " A_TickCount - mainStartZeit , , , 2
    r := (r1!=0 || !r2 || abandonAll=1) ? 0 : 1
    If (modus="all")
       Return abandonAll
    Return r
}

cloneGDItoMem(funcu, pBitmap, W:=0, H:=0) {
    If !validBMP(pBitmap)
    {
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: no bitmap given")
       Return
    }

    If (!W || !H)
       trGdip_GetImageDimensions(pBitmap, W, H)

    newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, W, H, coreDesiredPixFmt)
    If validBMP(newBitmap)
    {
       ; thisImgQuality := 5 ; (userimgQuality=1) ? 3 : 5
       G := trGdip_GraphicsFromImage(A_ThisFunc "() invoked by " funcu, newBitmap, 5)
       If G
       {
          E := trGdip_DrawImage(A_ThisFunc "() invoked by " funcu, G, pBitmap, 0, 0, W, H)
          Gdip_DeleteGraphics(G)
       }

       If (E="fail" || !G)
       {
          newBitmap := trGdip_DisposeImage(newBitmap, 1)
          addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create GDI+ graphics object")
       }
    } Else addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create bitmap")

    Return newBitmap
}

calcIMGcoordsInVP(mainWidth, mainHeight, newW, newH, zL, oIMGdecX, oIMGdecY, ByRef DestPosX, ByRef DestPosY, ByRef IMGdecX, ByRef IMGdecY) {
    Static orderu := {1:7, 2:8, 3:9, 4:4, 5:5, 6:6, 7:1, 8:2, 9:3}
         , prevZoom := "-", prevCX, prevCY

    If (mainWidth="setCenter")
    {
       prevCX := newW 
       prevCY := newH
       Return
    }

    o_mW := mainWidth
    o_mH := mainHeight
    If (allowFreeIMGpanning=1 && IMGresizingMode=4)
       mainWidth := mainHeight := 1

    imgDecLX := LX := mainWidth - newW
    imgDecLY := LY := mainHeight - newH
    ; vpCenterX := 1, vpCenterY := 1
    CX := mainWidth/2 - newW/2
    CY := mainHeight/2 - newH/2
    If ((imageAligned=1) || (allowFreeIMGpanning=1 && IMGresizingMode=4) && thumbsDisplaying=0)
    {
       DestPosX := DestPosY := 0
    } Else If (imageAligned=5)
    {
       DestPosX := DestPosY := 0
       If (newW<o_mW)
          DestPosX := CX
       If (newH<o_mH)
          DestPosY := CY
    } 

    If ((IMGlargerViewPort!=1 && allowFreeIMGpanning=0) || (IMGresizingMode!=4 && allowFreeIMGpanning=1) || (PrintPosX="X" && allowFreeIMGpanning=1))
    {
       IMGdecX := IMGdecY := 1
       ; SoundBeep 900, 1000
    } Else If (IMGresizingMode=4 && thumbsDisplaying!=1)
    {
       If (allowFreeIMGpanning=1 && imageAligned=5 && PrintPosX="C")
          prevCX := prevCY := 0.5

       If (prevZoom!=zL)
       {
          If prevCX
             IMGdecX := -1 * (newW * prevCX) + o_mW//2
          Else
             IMGdecX := oIMGdecX

          If prevCY
             IMGdecY := -1 * (newH * prevCY) + o_mH//2
          Else
             IMGdecY := oIMGdecY

          If (isInRange(prevDestPosX, -10, 10) && allowFreeIMGpanning=1 && imageAligned=1)
          || (IMGdecX>0 && oIMGdecX<0 && allowFreeIMGpanning=1 && imageAligned=1)
             IMGdecX := 0

          If (isInRange(prevDestPosY, -10, 10) && allowFreeIMGpanning=1 && imageAligned=1)
          || (IMGdecY>0 && oIMGdecY<0 && allowFreeIMGpanning=1 && imageAligned=1)
             IMGdecY := 0

          prevZoom := zL
       } Else
       {
          IMGdecX := oIMGdecX
          IMGdecY := oIMGdecY
       }

       If (IMGdecalageX<LX && newW>mainWidth)
          IMGdecX := LX
       If (IMGdecalageY<LY && newH>mainHeight)
          IMGdecY := LY

       minTopCornerX := (allowFreeIMGpanning=1) ? o_mW : 0
       minTopCornerY := (allowFreeIMGpanning=1) ? o_mH : 0
       If (newW - 2 > mainWidth)
          DestPosX := DestPosX + IMGdecX
       Else
          IMGdecX := minTopCornerX

       If (newH - 2 > mainHeight)
          DestPosY := DestPosY + IMGdecY
       Else
          IMGdecY := minTopCornerY

       If (DestPosX>minTopCornerX && newW>mainWidth)
          IMGdecX := DestPosX := minTopCornerX

       If (DestPosY>minTopCornerY && newH>mainHeight)
          IMGdecY := DestPosY := minTopCornerY

       ; ToolTip, % IMGdecX "|" IMGdecY "`n" LX//2 "|" LY//2 , , , 2
    }

    DestPosX := Round(DestPosX)
    IMGdecX := Round(IMGdecX)
    DestPosY := Round(DestPosY)
    IMGdecY := Round(IMGdecY)

    prevCX := (DestPosX<0) ? abs(DestPosX) + o_mW/2 : -1*(DestPosX - o_mW/2)
    prevCY := (DestPosY<0) ? abs(DestPosY) + o_mH/2 : -1*(DestPosY - o_mH/2)
    prevCX := Round(prevCX/newW, 8)
    prevCY := Round(prevCY/newH, 8)
    If (newW<o_mW && imageAligned=1 && allowFreeIMGpanning=0)
       prevCX := 0.01
    If (newH<o_mH && imageAligned=1 && allowFreeIMGpanning=0)
       prevCY := 0.01

    ; ToolTip, % oIMGdecX "|" oIMGdecY "`n" IMGdecX "|" IMGdecY "`n" prevCX "|" prevCY "`n" prevZoom "|" zL , , , 2
    ; ToolTip, % DestPosX "=" DestPosY "`n" IMGdecalageX "=" IMGdecalageY , , , 2
    prevResizedVPimgW := newW
    prevResizedVPimgH := newH
    PrintPosX := ""
}

simulateCalcImageCoordsInVP(mainWidth, mainHeight, newW, newH, zL, oIMGdecX, oIMGdecY) {
    Static orderu := {1:7, 2:8, 3:9, 4:4, 5:5, 6:6, 7:1, 8:2, 9:3}
         , prevZoom := "-", prevCX, prevCY
    o_mW := mainWidth
    o_mH := mainHeight
    If (allowFreeIMGpanning=1 && IMGresizingMode=4)
       mainWidth := mainHeight := 1

    imgDecLX := LX := mainWidth - newW
    imgDecLY := LY := mainHeight - newH
    ; vpCenterX := 1, vpCenterY := 1
    CX := mainWidth/2 - newW/2
    CY := mainHeight/2 - newH/2
    If ((imageAligned=1) || (allowFreeIMGpanning=1 && IMGresizingMode=4) && thumbsDisplaying=0)
    {
       DestPosX := DestPosY := 0
    } Else If (imageAligned=5)
    {
       DestPosX := DestPosY := 0
       If (newW<o_mW)
          DestPosX := CX
       If (newH<o_mH)
          DestPosY := CY
    } 

    If ((IMGlargerViewPort!=1 && allowFreeIMGpanning=0) || (IMGresizingMode!=4 && allowFreeIMGpanning=1) || (PrintPosX="X" && allowFreeIMGpanning=1))
    {
       IMGdecX := IMGdecY := 1
       ; SoundBeep 900, 1000
    } Else If (IMGresizingMode=4 && thumbsDisplaying!=1)
    {
       If (allowFreeIMGpanning=1 && imageAligned=5 && PrintPosX="C")
          prevCX := prevCY := 0.5

       If (prevZoom!=zL)
       {
          If prevCX
             IMGdecX := -1 * (newW * prevCX) + o_mW//2
          Else
             IMGdecX := oIMGdecX

          If prevCY
             IMGdecY := -1 * (newH * prevCY) + o_mH//2
          Else
             IMGdecY := oIMGdecY

          If (isInRange(prevDestPosX, -10, 10) && allowFreeIMGpanning=1 && imageAligned=1)
          || (IMGdecX>0 && oIMGdecX<0 && allowFreeIMGpanning=1 && imageAligned=1)
             IMGdecX := 0

          If (isInRange(prevDestPosY, -10, 10) && allowFreeIMGpanning=1 && imageAligned=1)
          || (IMGdecY>0 && oIMGdecY<0 && allowFreeIMGpanning=1 && imageAligned=1)
             IMGdecY := 0

          prevZoom := zL
       } Else
       {
          IMGdecX := oIMGdecX
          IMGdecY := oIMGdecY
       }

       If (IMGdecalageX<LX && newW>mainWidth)
          IMGdecX := LX
       If (IMGdecalageY<LY && newH>mainHeight)
          IMGdecY := LY

       minTopCornerX := (allowFreeIMGpanning=1) ? o_mW : 0
       minTopCornerY := (allowFreeIMGpanning=1) ? o_mH : 0
       If (newW - 2 > mainWidth)
          DestPosX := DestPosX + IMGdecX
       Else
          IMGdecX := minTopCornerX

       If (newH - 2 > mainHeight)
          DestPosY := DestPosY + IMGdecY
       Else
          IMGdecY := minTopCornerY

       If (DestPosX>minTopCornerX && newW>mainWidth)
          IMGdecX := DestPosX := minTopCornerX

       If (DestPosY>minTopCornerY && newH>mainHeight)
          IMGdecY := DestPosY := minTopCornerY

       ; ToolTip, % IMGdecX "|" IMGdecY "`n" LX//2 "|" LY//2 , , , 2
    }

    DestPosX := Round(DestPosX)
    IMGdecX := Round(IMGdecX)
    DestPosY := Round(DestPosY)
    IMGdecY := Round(IMGdecY)

    prevCX := (DestPosX<0) ? abs(DestPosX) + o_mW/2 : -1*(DestPosX - o_mW/2)
    prevCY := (DestPosY<0) ? abs(DestPosY) + o_mH/2 : -1*(DestPosY - o_mH/2)
    prevCX := Round(prevCX/newW, 8)
    prevCY := Round(prevCY/newH, 8)
    If (newW<o_mW && imageAligned=1 && allowFreeIMGpanning=0)
       prevCX := 0.01
    If (newH<o_mH && imageAligned=1 && allowFreeIMGpanning=0)
       prevCY := 0.01

    ; ToolTip, % oIMGdecX "|" oIMGdecY "`n" IMGdecX "|" IMGdecY "`n" prevCX "|" prevCY "`n" prevZoom "|" zL , , , 2
    ; ToolTip, % DestPosX "=" DestPosY "`n" IMGdecalageX "=" IMGdecalageY , , , 2
    prevResizedVPimgW := newW
    prevResizedVPimgH := newH
    PrintPosX := ""
}

saveMainWinPos() {
   WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
   mainWinPos := winX "|" winY
   RegAction(1, "mainWinPos")
   mainWinSize := winWidth "|" winHeight
   RegAction(1, "mainWinSize")
}

writeMainWindowPos() {
   Static prevInfos
   If determineLClickState()
   {
      SetTimer, writeMainWindowPos, -300
      Return
   }

   thisWinHwnd := (thumbsDisplaying=1) ? hGDIthumbsWin : hGDIwin
   WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
   ; WinGetPos,,, winWidth, winHeight, ahk_id %thisWinHwnd%
   ; WinGetPos,,, win2Width, win2Height, ahk_id %PVhwnd%
   If (winX && winY && winWidth && winHeight)
   {
      mainWinPos := winX "|" winY
      mainWinSize := winWidth "|" winHeight
      WinGet, Stylu, Style, ahk_id %PVhwnd%
      mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
      ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
      thisInfos := winWidth "z" winHeight "z" mainWinSize "z" mainWinPos "z" mainWinMaximized
      If (prevInfos!=thisInfos)
      {
         prevInfos := thisInfos
         RegAction(1, "mainWinPos")
         RegAction(1, "mainWinSize")
         RegAction(1, "mainWinMaximized")
         SetTimer, writeMainWindowPos, -300
      }
   }
}

GuiGDIupdaterResize(eventu:=0) {
   If (A_TickCount - scriptStartTime<1950)
      Return

   If (toolTipGuiCreated=1)
      RemoveTooltip()
   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   If (eventu=2)
   {
      WinGet, Stylu, Style, ahk_id %PVhwnd%
      mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
      RegAction(1, "mainWinMaximized")
      ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
   } Else If (eventu!=1)
      SetTimer, writeMainWindowPos, -350

   SetTimer, dummyTimerReloadThisPicture, Off
   SetTimer, dummyTimerDelayiedImageDisplay, Off
   DestroyGIFuWin()
   resetSlideshowTimer()
   imgPath := getIDimage(currentFileIndex)
   thisClippyIMG := isImgEditingNow()

   If (!imgPath || !maxFilesIndex || PrevGuiSizeEvent=1 || !CurrentSLD) && (thisClippyIMG!=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      If (A_OSVersion="WIN_7" || isWinXP=1)
         GDIwindowsPosCorrections()

      ForceRefreshNowThumbsList()
      If (A_TickCount - lastWinDrag<350)
         Return

      isWelcomeScreenu := (thisClippyIMG=1 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
      If (thumbsDisplaying=1) && (!maxFilesIndex || !CurrentSLD)
         ToggleVisibilityWindow("hide", hGDIthumbsWin)
      Else if !isWelcomeScreenu
         FadeMainWindow()
      Return
   }

   If (lockSelectionAspectRatio=3)
      defineSelectionAspectRatios()

   If (maxFilesIndex>0 && PrevGuiSizeEvent!=1 && thumbsDisplaying!=1) && (A_TickCount - scriptStartTime>500) || (thisClippyIMG=1)
   {
      preventHUDelements := 1
      fnOutputDebug("Resize window event - image view mode. ")
      delayu := (A_TickCount - lastWinDrag<450) ? 450 : 15
      filterDelayiedImageDisplay()
      ; dummyTimerDelayiedImageDisplay(delayu)
      dummyTimerReloadThisPicture(150)
      ForceRefreshNowThumbsList()
   } Else If (thumbsDisplaying=1 && maxFilesIndex>1)
   {
      fnOutputDebug("Resize window event - thumbs mode.")
      ; recalculateThumbsSizes()
      ; vpWinClientSize(mainWidth, mainHeight)
      ; WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight% , ahk_id %hGDIthumbsWin%
      delayu := (A_TickCount - lastWinDrag<450) ? 550 : 325
      SetTimer, RefreshThumbsList, % -delayu
   }

   If (A_OSVersion="WIN_7" || isWinXP=1)
      GDIwindowsPosCorrections()
}

ToggleImgSizeViewModes() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked > 350)
   {
      zoomLevel := IMGdecalageY := IMGdecalageX := 1
      ToggleImageSizingMode("flip-flop")
      lastInvoked := A_TickCount
   }
}

ReloadDynamicFolderz(fileNamu) {
    showTOOLtip("Refreshing files list, please wait")
    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    listu := coreLoadDynaFolders(fileNamu)
    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue
       Else
          r := GetFilesList(line "\*")
       If (r="abandoned")
          Break
    }
}

coreLoadDynaFolders(fileNamu) {
    If (SLDtypeLoaded=3 && fileNamu=CurrentSLD)
    {
       listu := DynamicFoldersList "`n"
       SQL := "SELECT imgfolder FROM dynamicfolders;"
       activeSQLdb.GetTable(SQL, RecordSet)
       Loop, % RecordSet.RowCount
       {
           Rowu := RecordSet.Rows[A_Index]
           If Rowu[1]
              listu .= Rowu[1] "`n"
       }

       Sort, listu, UD`n
       listu := cleanDynamicFoldersList(listu)
       DynamicFoldersList := listu
       RecordSet.Free()
       Return listu
    }

    FileRead, tehFileVar, %fileNamu%
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(DF[0-9].*\=[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
          listu .= SubStr(line, InStr(line, "=")+1) "`n"
    }
 
    DynamicFoldersList := StrReplace(DynamicFoldersList, "|hexists|")
    listu .= "`n" Trimmer(DynamicFoldersList) "`n"
    changeMcursor()
    Sort, listu, UD`n
    listu := cleanDynamicFoldersList(listu)
    DynamicFoldersList := listu
    Return listu
}

cleanDynamicFoldersList(listu) {
    newArrayu := new hashtable()
    listuArray := StrSplit(listu, "`n", "`r")
    Loop, % listuArray.Count()
    {
       lineu := Format("{:L}", listuArray[A_Index])
       If lineu
          newArrayu[lineu] := 1
    }

    Loop, % listuArray.Count()
    {
       lineu := Format("{:L}", listuArray[A_Index])
       isPipe := InStr(lineu, "|")
       linea := StrReplace(lineu, "|")
       If (newArrayu[linea]=1 && newArrayu[lineu]=1 && isPipe)
          newArrayu[lineu] := 0
    }

    For Key, Value in newArrayu
    {
       If (Value=1 && !InStr(Key, "|"))
       {
          Loop, % listuArray.Count()
          {
              lineu := Format("{:L}", listuArray[A_Index])
              ; MsgBox, % lineu "`n" Key
              If (InStr(lineu "\", Key "\") && lineu!=Key)
                 newArrayu[lineu] := 0
          }
       }
    }

    newListu := ""
    For Key, Value in newArrayu
    {
        If Value
           newListu .= key "`n"
    }
    newArrayu := ""
    Return newListu
}

compareFoldersList(mainFoldersListu, foldersListu) {
   obju := []
   stuffAdded := 0
   Loop, Parse, foldersListu,`n
   {
       linea := Trimmer(A_LoopField)
       If StrLen(linea)<4
          Continue

       skipThis := 0
       Loop, Parse, mainFoldersListu, `n
       {
           line := Trimmer(A_LoopField)
           If StrLen(line)<4
              Continue

           If (line=linea)
              skipThis := 1
       }

       If (skipThis=1)
          Continue

       obju.newEntries .= linea "`n"
   }

   mainFoldersListu .= "`n" obju.newEntries
   Sort, mainFoldersListu, UD`n
   obju.newListu := mainFoldersListu

   Return obju
}

RegenerateEntireList() {
    If (AnyWindowOpen>0)
       BtnCloseWindow()

    If InStr(CurrentSLD, "\QPV\favourite-images-list.SLD")
    {
       retrieveFavesAsList()
       Return
    } Else If InStr(CurrentSLD, "\QPV\file-acts-history.SLD")
    {
       BTNhistoFileActsList()
       Return
    } Else If InStr(CurrentSLD, "\viewed-images-history-")
       Return

    If askAboutFileSave(" and the files list will be reloaded")
       Return

    thisIndex := currentFileIndex
    newStaticFoldersListCache := []
    startOperation := A_TickCount
    showTOOLtip("Preparing to refresh the files list, please wait")
    listu := getDynamicFoldersList()
    If StrLen(listu)<4
    {
       showTOOLtip("WARNING: No list of dynamic folders found")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    mustOpenStartFolder := ""
    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    renewCurrentFilesList()
    mustGenerateStaticFolders := (SLDtypeLoaded=3) ? 0 : 1
    If (SLDtypeLoaded=3)
    {
       getMaxRowIDsqlDB()
       activeSQLdb.Exec("BEGIN TRANSACTION;")
    }

    countFolders := ST_Count(listu, "`n") + 1
    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       isPipe := InStr(line, "|") ? 1 : 0
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue

       If (SLDtypeLoaded=3)
       {
          getMaxRowIDsqlDB()
          thisR := SQLescapeStr(fileTest, 1)
          thisR := (isPipe=1) ? thisR : thisR "%"
          SQLstr := "UPDATE images SET isDeleted=1 WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          activeSQLdb.Exec(SQLstr)
       }

       r := GetFilesList(line "\*", A_Index / countFolders, 0, 0)
       If (SLDtypeLoaded=3)
          maxFilesIndex := getTotalIMGsSQLdb("WHERE isDeleted=0")

       If (r="abandoned")
          Break
    }

    If (SLDtypeLoaded=3 && RegExMatch(CurrentSLD, "i)(.\.sldb)$"))
    {
       If (r="abandoned")
       {
          showTOOLtip("Operation aborted: regenerate files list. The files list is unchanged.`nReopening now the database, please wait")
          activeSQLdb.Exec("ROLLBACK TRANSACTION;")
          Sleep, 250
       } Else
       {
          showTOOLtip("Finalising database operations, please wait", 0, 0, 1/5)
          SQLdeleteEntriesMarked()
          showTOOLtip("Finalising database operations, please wait", 0, 0, 2/5)
          If !activeSQLdb.Exec("COMMIT TRANSACTION;")
             throwSQLqueryDBerror(A_ThisFunc)

          showTOOLtip("Regenerating main folders list, please wait", 0, 0, 3/5)
          recreateDynaFoldersSQLdbList(listu)
          showTOOLtip("Regenerating secondary folders list, please wait", 0, 0, 4/5)
          SQLdbGenerateStaticFolders()
          saveSlideSettingsInDB()
          etaTime := "Elapsed time to regenerate files list, database mode: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3))
          addJournalEntry(etaTime)
       }

       OpenSLD(CurrentSLD, 1)
       Return
    }

    thisFolder := StrReplace(CurrentSLD, "|")
    If (SLDtypeLoaded=1 && FolderExist(thisFolder))
       watchFolderDetails := getFolderDetails(thisFolder)

    GenerateRandyList()
    SoundBeep, % (r="abandoned" && SLDtypeLoaded!=3) ? 300 : 900, 100
    currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
    If (maxFilesIndex<1)
    {
       friendly := (SLDtypeLoaded=1 && FolderExist(thisFolder)) ? "No image files found in the folder:`n" thisFolder "\`n`n" : "Error refreshing files list... found nothing.`n`n"
       FadeMainWindow()
       msgBoxWrapper(appTitle ": WARNING", friendly "No indexed files found, please open a file or folder.", 0, 0, "info")
       resetMainWin2Welcome()
    } Else
    {
       If (SLDtypeLoaded=1 && FolderExist(thisFolder) && prevFolderSortMode)
       {
          ; ToolTip, % "l=" thisIndex , , , 2
          SortFilesList(prevFolderSortMode)
          currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
       }

       dummyTimerDelayiedImageDisplay(50)
    }

    etaTime := "Elapsed time to regenerate files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " groupDigits(maxFilesIndex)
    addJournalEntry(etaTime)
}

throwSQLqueryDBerror(funcu) {
   SetTimer, ResetImgLoadStatus, -150
   showDelayedTooltip("ERROR: " funcu "() failed to query or commit changes the SQL database`n" activeSQLdb.ErrorMsg)
   SoundBeep, 300, 100
   ; SetTimer, RemoveTooltip, % -msgDisplayTime
}

getMaxRowIDsqlDB() {
  SQL := "SELECT max(imgidu) FROM images;"
  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "() " activeSQLdb.ErrorMsg)
     Return
  }

  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If IsNumber(Rowu[1])
         sqlDBrowID := Rowu[1] + 1 ; Rowu[2] Rowu[3]
  }

  RecordSet.Free()
  Return sqlDBrowID
}

getTotalIMGsSQLdb(morus:="") {
  SQL := "SELECT COUNT(*) FROM images " morus ";"
  If !activeSQLdb.GetTable(SQL, RecordSet)
  {
     addJournalEntry(A_ThisFunc "() " activeSQLdb.ErrorMsg)
     Return
  }

  value := 0
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If IsNumber(Rowu[1])
         value := Rowu[1]
  }

  RecordSet.Free()
  Return value
}

OpenSLDBdataBase(fileNamu, importMode:=0) {
  activeSQLdb.CloseDB()
  activeSQLdb := new SQLiteDB
  If !activeSQLdb.OpenDB(fileNamu)
  {
     throwSQLqueryDBerror(A_ThisFunc)
     Return -1
  }

  startOperation := A_TickCount
  If (MustLoadSLDprefs=1 && importMode!=1)
  {
     SlidesMusicSong := ""
     IniSLDBreadAll() ; read slideshow settings
  } Else If (importMode!=1)
  {
     SlidesMusicSong := ""
     IniSLDBreadAll("prevFilesSortMode")
     IniSLDBreadAll("reverseOrderOnSort")
     IniSLDBreadAll("autoPlaySlidesAudio")
     IniSLDBreadAll("SlidesMusicSong")
     IniSLDBreadAll("hamDistInterpolation")
     IniSLDBreadAll("userpHashMode")
     IniSLDBreadAll("dbVersion")
  }

  RecordSet := ""
  sortMode := (reverseOrderOnSort=1) ? " DESC" : ""
  reorder := StrLen(prevFilesSortMode)>3 ? " ORDER BY " prevFilesSortMode sortMode ";" : " ORDER BY imgidu;"
  If !RegExMatch(prevFilesSortMode, "i)(fsize|fmodified|fcreated|imgfile|imgfolder)")
     moreCol := StrLen(prevFilesSortMode)>3 ? ", " prevFilesSortMode : ""
  ; ToolTip, % prevFilesSortMode "=" reverseOrderOnSort , , , 2
  startOperation := A_TickCount
  SQL := "SELECT imgidu, imgfolder||'\'||imgfile " moreCol " FROM images" reorder
  If !InitSQLgetTable(SQL, activeSQLdb._Handle, errMsg, Rows, Cols, hTable)
  {
      showTOOLtip("ERROR: Failed to open the SQL database:`n" errMsg)
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return -1
  } Else
  {
      ; ToolTip, % "prev=" prevFilesSortMode " cols = " cols " rows=" rows , , , 2
      If Rows
      {
         If (importMode!=1)
         {
            newStaticFoldersListCache := []
            SLDcacheFilesList := 1
            resultedFilesList := []
            maxFilesIndex := 0
         }
         performSQLgetTable(Rows, Cols, hTable)
         disposeSQLgetTableHandle(hTable)
      } Else
      {
         disposeSQLgetTableHandle(hTable)
         showTOOLtip("ERROR: No images indexed in the SQL database")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return -1
      }
  }

  getMaxRowIDsqlDB()
  If (importMode!=1)
     DynamicFoldersList := ""

  SQL := "SELECT imgfolder FROM dynamicfolders;"
  activeSQLdb.GetTable(SQL, RecordSet)
  Loop, % RecordSet.RowCount
  {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[1]
         DynamicFoldersList .= Rowu[1] "`n"
  }

  RecordSet.Free()
  etaTime := "Elapsed time to open SQL database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
  addJournalEntry(etaTime)
  If (A_TickCount - startOperation>7000) && (maxFilesIndex>2)
     SoundBeep , 900, 100

  If (dbVersion!=dbExpectedVersion && importMode!=1)
     msgResult := msgBoxWrapper(appTitle ": WARNING", "This database was saved by an older version of " appTitle ". Some features in the application will likely malfunction, because this version of the application expects a database with a different structure.`n`nPlease use the «Rebuild» option in the save panel to recreate this database with the new structure. Resaving this database will not restructure the database.", "&OK", 1, "exclamation")

  If (importMode=1)
     activeSQLdb.CloseDB()

  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}

performSQLgetTable(Rows, Cols, hTable) {
   Offset := A_PtrSize * Cols
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   thisIndex := 0
   Loop, %Rows%
   {
      thisIndex++
      maxFilesIndex++
      Loop, %Cols%
      {
         If (A_Index=1) ; database index
            resultedFilesList[maxFilesIndex, 12] := StrGet(NumGet(hTable+0, Offset, "UPtr"), "UTF-8")
         Else If (A_Index=3) ; sort key value
            resultedFilesList[maxFilesIndex, 36] := StrGet(NumGet(hTable+0, Offset, "UPtr"), "UTF-8")
         Else ; full path
            resultedFilesList[maxFilesIndex, 1] := StrGet(NumGet(hTable+0, Offset, "UPtr"), "UTF-8")
         Offset += A_PtrSize
      }

      If (A_TickCount - prevMSGdisplay>2100)
      {
         etaTime := ETAinfos(thisIndex, Rows, startOperation)
         showTOOLtip("Generating files list index" etaTime, 0, 0, thisIndex/Rows)
         prevMSGdisplay := A_TickCount
      }
   }
}

InitSQLgetTable(SQL, dbHandle, ByRef errMsg, ByRef Rows, ByRef Cols, ByRef hTable) {
   Err := 0, RC := 0
   Rows := Cols := 0
   errMsg := hTable := 0 ; the sql output
   activeSQLdb._StrToUTF8(SQL, UTF8)
   RC := DllCall("SQlite3.dll\sqlite3_get_table", "Ptr", dbHandle, "Ptr", &UTF8, "PtrP", hTable
               , "Int*", Rows, "Int*", Cols, "PtrP", Err, "Cdecl Int")
   If ErrorLevel
   {
      errMsg := "DLLCall sqlite3_get_table failed! Code: " ErrorLevel
      Return False
   }

   If (RC)
   {
      errMsg := StrGet(Err, "UTF-8") "`n" SQL " | Code: " RC
      DllCall("SQLite3.dll\sqlite3_free", "Ptr", Err, "Cdecl")
      Return False
   }
   Return True
}

disposeSQLgetTableHandle(hTable) {
   DllCall("SQLite3.dll\sqlite3_free_table", "Ptr", hTable, "Cdecl")
   Return ErrorLevel
}

SQLdbRetrieveGivenFolder(pathu, isRecursive) {
   rec := (isRecursive=1) ? "%" : ""
   pathu := SQLescapeStr(pathu, 1)
   SQL := "SELECT imgidu, fullPath FROM images WHERE imgfolder LIKE '%" pathu rec "' ESCAPE '>'" ; reorder
   If !InitSQLgetTable(SQL, activeSQLdb._Handle, errMsg, Rows, Cols, hTable)
   {
      showTOOLtip("ERROR: Failed to open the SQL database:`n" errMsg)
      SoundBeep, 300, 100
      Return -1
   }

   If Rows
      performSQLgetTable(Rows, Cols, hTable)
   disposeSQLgetTableHandle(hTable)
}

filterDupeResultsByHdist(threshold) {
   doStartLongOpDance()
   showTOOLtip("Preparing list for Hamming distance calculations, please wait")
   groupies := []
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1000)
       {
          etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
          showTOOLtip("Preparing list for Hamming distance calculations, please wait" etaTime, 0, 0, A_index/maxFilesIndex)
          prevMSGdisplay := A_TickCount
       }

       grpIDu := resultedFilesList[A_Index, 23]
       If grpIDu
       {
          grpIDv%grpIDu%++
          resultedFilesList[A_Index, 33] := 100
          resultedFilesList[A_Index, 34] := 2500
          groupies[grpIDu, grpIDv%grpIDu%] := A_Index
       }
   }

   If (abandonAll=1)
   {
      groupies := ""
      Return 2
   }

   ; prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalLoops := groupies.Count()
   rtotalLoops := 0
   For Key, Value in groupies
       rtotalLoops += Value.Count()

   ; MsgBox, % "groups=" totalLoops "= l=" rtotalLoops
   prevMSGdisplay := A_TickCount
   ; startOperation := A_TickCount
   resultsDupesArray := []
   thisLoop := 0
   For Key, arrayGroup in groupies
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       ; If (A_TickCount - prevMSGdisplay>1000)
       ; {
       ;    etaTime := ETAinfos(thisLoop, rtotalLoops, startOperation)
       ;    showTOOLtip("Calculating Hamming distance between image pairs`nImage groups: " groupDigits(A_Index) " / " groupDigits(totalLoops) etaTime, 0, 0, thisLoop/rtotalLoops)
       ;    prevMSGdisplay := A_TickCount
       ; }

       thisLoop += arrayGroup.Count()
       thisCounter := resultsDupesArray.Count()
       ; fnOutputDebug("tL=" arrayGroup.Count() )
       If corefilterDupeResultsByHdist(arrayGroup, threshold, thisLoop, rtotalLoops, thisCounter, startOperation)
       {
          abandonAll := 1
          Break
       }
   }

   err := DllCall(whichMainDLL "\clearHammingDistanceResults")
   groupies := ""
   If (abandonAll=1)
      Return 2

   changeHdistLevelCached("kill")
   hamUppLim := mseLowLim := 0
   mseUppLim := userFindDupesMSElvl
   hamUppLim := threshold
   UserHamDistStringFilter := ""
   UserHamDistCacheFilterMonoGroups := 0
   showTOOLtip("Finishing the duplicate images filtered list, please wait")
   r := changeHdistLevelCached(0, 0, threshold, 0, userFindDupesMSElvl)
   ResetImgLoadStatus()
   If (r<1)
      Return 1

   ; finalArray := sortDupeGroups(resultedFilesList.Clone())
   ; maxFilesIndex := finalArray.Count()
   ; resultedFilesList := []
   ; resultedFilesList := finalArray.Clone()
}

sortDupeGroups(givenArray, oldMap:=0, remSingles:=1) {
   groupies := []
   looseGroupies := []
   listuGroupies := "|"
   Loop, % givenArray.Count()
   {
       grpIDu := givenArray[A_Index, 23]
       If (grpIDu && InStr(grpIDu, "_"))
       {
          tgrpIDu := SubStr(grpIDu, 1, InStr(grpIDu,"_") - 1)
          grpIDv%tgrpIDu%++
          If (grpIDv%tgrpIDu%>remSingles)
             groupies[grpIDu] := 1
 
          ; lgrpIDv%grpIDu%++
          ; If (InStr(givenArray[A_Index, 28], "_"))
          ;    looseGroupies[grpIDu] := (lgrpIDv%grpIDu%=1) ? A_Index : 0
          listuGroupies .= grpIDu "z" A_Index "|"
       }
   }

   ; For key, value in looseGroupies
   ; {
   ;    If value
   ;    {
   ;       givenArray[value, 23] := givenArray[value, 28]
   ;       listuGroupies .= value "z" A_Index "|"
   ;    }
   ; }

   listuGroupies := Trimmer(listuGroupies, "|")
   Sort, listuGroupies, D|
   newIndex := 0
   newArrayu := []
   newMappingList := []
   ; ToolTip, % listuGroupies , , , 2
   Loop, Parse, listuGroupies, |
   {
       If A_LoopField
       {
          zu := StrSplit(A_LoopField, "z")
          If groupies[zu[1]]
          {
             newIndex++
             newArrayu[newIndex] := givenArray[zu[2]]
             newArrayu[newIndex, 28] := ""
             If (PerformMSDonDupes=1)
             {
                newArrayu[newIndex, 29] := ""
                newArrayu[newIndex, 31] := ""
             }

             If (hasHamDistCached=1 && IsObject(oldMap))
                newMappingList[newIndex] := oldMap[zu[2]]
          }
       }
   }

   If (hasHamDistCached=1 && IsObject(oldMap) && newIndex>1)
   {
      filteredMap2mainList := []
      filteredMap2mainList := newMappingList.Clone()
   }
 
   Return newArrayu
}

testWasMSEdupes() {
   MSEna := resultsDupesArray[1, 4]
   MSEnb := resultsDupesArray[2, 4]
   MSEa := isNumber(Trim(MSEna))
   MSEb := isNumber(Trim(MSEnb))
   allowMSE := (MSEa=1 && MSEb=1 && MSEna<2500 && MSEnb<2500) ? 1 : 0
   Return allowMSE
}

changeHdistLevelCached(modus, newLvlA:=0, newLvlB:=0, newLvlMSEa:=0, newLvlMSEb:=0) {
   ; Static cachedListu := []
   If (modus="kill")
   {
      hasHamDistCached := 0
      bckpResultedFilesList := []
      filteredMap2mainList := []
      Return -1
   }

   ; mustRenew := (newLvl=userFindDupesHamDistLvl && resultedFilesList.Count() != cachedListu.Count()) ? 1 : 0
   If (bckpResultedFilesList.Count()<3) ; || mustRenew=1)
   {
      hasHamDistCached := 1
      If markedSelectFile
         dropFilesSelection()

      bckpResultedFilesList := []
      bckpResultedFilesList := resultedFilesList.Clone()
      bckpMaxFilesIndex := maxFilesIndex
   }
   ; ToolTip, % MSEa "=" MSEb "=" allowMSE , , , 2
   thisString := StrReplace(Trimmer(UserHamDistStringFilter), "||", "|")
   thisString := Trimmer(thisString, "|")
   If thisString
   {
      If InStr(thisString, "/")
         n := 2
      Else If InStr(thisString, ">")
         n := 3

      If (userHamDistStringStringPos=2 && !n)
         thisString .= "/"
      Else If (userHamDistStringStringPos=3 && !n)
         thisString .= ">"
      Else If (userHamDistStringStringPos=4)
         thisString := "\>" thisString
      givenRegEx := processSearchIndexString(thisString)
      If n
         userHamDistStringStringPos := n
   }

   allowMSE := testWasMSEdupes()
   isStrFilter := StrLen(thisString)>1 ? 1 : 0
   newArrayu := []
   dupesIDs := []
   Loop, % resultsDupesArray.Count()
   {
        idRa := resultsDupesArray[A_Index, 1]
        idRb := resultsDupesArray[A_Index, 2]
        hamDist := resultsDupesArray[A_Index, 3]
        MSE := resultsDupesArray[A_Index, 4]
        If isInRange(hamDist, newLvlA, newLvlB)
        {
           If (allowMSE=1)
           {
              If !isInRange(MSE, newLvlMSEa, newLvlMSEb)
                 Continue
           }

           If (isStrFilter=1)
           {
              If !coreSearchIndex(imgPath, givenRegEx, userHamDistStringFilterWhat, UserHamDistStringInvert)
                 Continue
           }
       } Else Continue

       If (dupesIDs[idRa]!="" && dupesIDs[idRb]!="")
       {
          If (BreakDupesGroups=1)
          {
             thisDupeID := newArrayu[idRa, 23]
             thisDupeID := SubStr(thisDupeID, 1, InStr(thisDupeID, "_") - 1)  "_" hamDist
             newArrayu[idRa, 23] := thisDupeID
             newArrayu[idRa, 33] := hamDist
             newArrayu[idRa, 34] := MSE

             thisDupeID := newArrayu[idRb, 23]
             thisDupeID := SubStr(thisDupeID, 1, InStr(thisDupeID, "_") - 1)  "_" hamDist
             newArrayu[idRb, 23] := thisDupeID
             newArrayu[idRb, 33] := hamDist
             newArrayu[idRb, 34] := MSE
          }

          ; y := i := ""
          ; i .= newArrayu[idRa, 23]
          ; i .= "h" newArrayu[idRa, 33]
          ; i .= "m" newArrayu[idRa, 34]
          ; y .= newArrayu[idRb, 23]
          ; y .= "h" newArrayu[idRb, 33]
          ; y .= "m" newArrayu[idRb, 34]
          ; fnOutputDebug(hamDist "|" idRa "=" i "|" idRb "=" y "wow")
          ; Sleep, -1
          ; SoundBeep 950, 900
          Continue
       } Else If (dupesIDs[idRa]="" && dupesIDs[idRb]="")
       {
          ; thisDupeID := idRc "_" min(idRa, idRb)
          thisDupeID := min(idRa, idRb) "_" hamDist
          dupesIDs[idRa] := thisDupeID
          dupesIDs[idRb] := thisDupeID
          newArrayu[idRa] := bckpResultedFilesList[idRa]
          newArrayu[idRa, 2] := 0
          newArrayu[idRa, 23] := thisDupeID
          newArrayu[idRa, 33] := hamDist
          newArrayu[idRa, 34] := MSE

          newArrayu[idRb] := bckpResultedFilesList[idRb]
          newArrayu[idRb, 2] := 0
          newArrayu[idRb, 23] := thisDupeID
          newArrayu[idRb, 33] := hamDist
          newArrayu[idRb, 34] := MSE
       } Else
       {
          thisDupeID := (dupesIDs[idRa]="") ? dupesIDs[idRb] : dupesIDs[idRa]
          If (BreakDupesGroups=1)
             thisDupeID := SubStr(thisDupeID, 1, InStr(thisDupeID, "_") - 1)  "_" hamDist
          dupesIDs[idRa] := thisDupeID
          dupesIDs[idRb] := thisDupeID
          If (newArrayu[idRa, 1]="")
          {
             newArrayu[idRa] := bckpResultedFilesList[idRa]
             newArrayu[idRa, 2] := 0
          } Else If (newArrayu[idRb, 1]="")
          {
             newArrayu[idRb] := bckpResultedFilesList[idRb]
             newArrayu[idRb, 2] := 0
          }

          newArrayu[idRa, 23] := thisDupeID
          newArrayu[idRa, 33] := min(hamDist, newArrayu[idRa, 33], newArrayu[idRb, 33])
          newArrayu[idRa, 34] := min(MSE, newArrayu[idRa, 34], newArrayu[idRb, 34])

          newArrayu[idRb, 23] := thisDupeID
          newArrayu[idRb, 33] := (BreakDupesGroups=1) ? hamDist : min(hamDist, newArrayu[idRa, 33], newArrayu[idRb, 33])
          newArrayu[idRb, 34] := (BreakDupesGroups=1) ? MSE : min(MSE, newArrayu[idRa, 34], newArrayu[idRb, 34])
       }
   }

   newIndex := 0
   fnewArrayu := []
   newMappingList := []
   For Key, Value in newArrayu
   {
       grpIDu := Value[23]
       imgPath := Value[1]
       If (grpIDu && imgPath && !InStr(imgPath, "||"))
       {
          newIndex++
          fnewArrayu[newIndex] := Value
          newMappingList[newIndex] := Key
       }
   }

   If (newIndex>1)
   {
      hasThis := 1
      finalArray := sortDupeGroups(fnewArrayu, newMappingList, UserHamDistCacheFilterMonoGroups)
      newIndex := finalArray.Count()
   }

   ; ToolTip, % lvl "=" newLvlA "=" newLvlB "=" newIndex , , , 2
   If (newIndex>1)
   {
      If !hasThis
      {
         maxFilesIndex := newIndex
         filteredMap2mainList := []
         filteredMap2mainList := newMappingList.Clone()
         resultedFilesList := []
         resultedFilesList := fnewArrayu.Clone()
      } Else
      {
         maxFilesIndex := finalArray.Count()
         resultedFilesList := []
         resultedFilesList := finalArray.Clone()
      }

      hasHamDistCached := 1
      ForceRefreshNowThumbsList()
      lastZeitFileSelect := A_TickCount
      ; dropFilesSelection(1)
      ; SetTimer, RandomPicture, -350
      Return 1
   } Else Return 0
}

calcMSDvalues(arrayA, arrayB, size, asStr:=0) {
    Static squaredCache := []
    ; [avg/ ] mean square difference [/ error] also known as standard deviation
    ; https://stackoverflow.com/questions/20271479/what-does-it-mean-to-get-the-mse-mean-error-squared-for-2-images
    ; https://stackoverflow.com/questions/25493010/c-difference-between-the-sum-of-the-squares-of-the-first-ten-natural-numbers-a
    ; https://www.introspective-mode.org/means-squared-variance-standard-deviation-error/
    ; https://stats.stackexchange.com/questions/239379/what-is-the-difference-between-mean-squared-deviation-and-variance
    ; https://www.mygreatlearning.com/blog/mean-square-error-explained/

    If (asStr=1)
    {
       arrayA := StrSplit(arrayA, "|")
       arrayB := StrSplit(arrayB, "|")
    }

    sumB := 0
    Loop, % size
    {
       f := (A_Index<33 || A_Index>991) ? 1 : 1
       sumB += (arrayA[A_Index] - arrayB[A_Index])**2 // f
       ; sumB += Abs(arrayA[A_Index] - arrayB[A_Index]) // f
    }

    If (squaredCache[sumB]!="")
       Return squaredCache[sumB]

    ; squaredCache[sumB] := Round(sqrt(sumB)/2)
    squaredCache[sumB] := Round(sqrt(sumB/(size/2)))
    ; fnOutputDebug("sum=" sumB "|" squaredCache[sumB])
    Return squaredCache[sumB]
}

corefilterDupeResultsByHdist(dupeIDsArray, threshold, grupu, totalgroups, thisCounter, mainZeit) {
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   totalLoops := dupeIDsArray.Count()
   VarSetCapacity(IDsbigArray, 8 * totalLoops + 1, 0)
   VarSetCapacity(HbigArray, 8 * totalLoops + 1, 0)
   If (findFlippedDupes=1)
      VarSetCapacity(flipHbigArray, 8 * totalLoops + 1, 0)
   Else
      VarSetCapacity(flipHbigArray, 8, 0)

   pxk := Round(grupu / totalgroups * 100, 1)
   generalDetails := "`nImage group: " groupDigits(grupu) " / " groupDigits(totalgroups) " ( " pxk "% )`nImages in current group: " groupDigits(totalLoops)
   etaTime := ""
   Loop, % totalLoops
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalLoops, startOperation)
          showTOOLtip("Hamming distance image duplicates preparations" etaTime generalDetails, 0, 0, A_Index/totalLoops)
          prevMSGdisplay := A_TickCount
       }

       idu := dupeIDsArray[A_Index]
       hIDu :=  resultedFilesList[idu, 12]
       If (InStr(dupesHashesData[hIDu], "|") && findFlippedDupes=1)
       {
          ash := StrSplit(dupesHashesData[hIDu], "|")
          hashA := "0x" ash[1],   hashB := "0x" ash[2]
          NumPut(hashA, HbigArray, (A_Index - 1) * 8, "uint64")
          NumPut(hashB, flipHbigArray, (A_Index - 1) * 8, "uint64")
       } Else
       {
          hashA := "0x" dupesHashesData[hIDu]
          NumPut(hashA, HbigArray, (A_Index - 1) * 8, "uint64")

       }

       NumPut(idu, IDsbigArray, (A_Index - 1) * 4, "uint")
       ; fnOutputDebug("tL=" totalLoops " g=" grupu " imgID[" A_Index "]=" idu)
       ; stringu .= A_Index "|" idu "=" hash "`n"
       ; msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have. " stringu, 4, 0, "question")
       ; If (msgResult="Yes")
       ;    Break
   }

   If (abandonAll=1)
   {
      flipHbigArray := ""
      IDsbigArray := ""
      HbigArray := ""
      Return "abandon"
   }

   ; If (A_TickCount - prevMSGdisplay>1000)
   ; {
      showTOOLtip("Calculating Hamming distance between the images in the current group: " generalDetails "`nPlease wait", 0, 0, grupu/totalgroups)
      prevMSGdisplay := A_TickCount
   ; }

   ; initQPVmainDLL()
   callOffset := totalResults := 0
   stepping := 100
   startuZ := A_TickCount
   lastStep := A_TickCount
   doStartLongOpDance()
   Loop
   {
      hoffset := 0
      rzs := DllCall(whichMainDLL "\hammingDistanceOverArray", "UPtr", &HbigArray, "UPtr", &flipHbigArray, "UPtr", &IDsbigArray, "uint", totalLoops, "Int", threshold + 1, "uint", hamDistLBorderCrop, "uint", hamDistRBorderCrop, "int", findInvertedDupes, "int", findFlippedDupes, "int", stepping, "int", callOffset, "int*", hoffset)
      callOffset += hoffset
      If (rzs>0)
         totalResults += rzs

      If (rzs="" || hOffset=0)
         Break

      If (A_TickCount - lastStep<1520)
         stepping += stepping//2

      If (A_TickCount - prevMSGdisplay>1000)
      {
         etaTime := SubStr(ETAinfos(callOffset, totalLoops, startuZ), 2)
         etaTime := SubStr(etaTime, InStr(etaTime, "`n"))
         etaTime .= "`nTotal elapsed time: " SecToHHMMSS(Round((A_TickCount - mainZeit)/1000, 3))
         pxk := Round(callOffset/totalLoops * 100, 1) 
         showTOOLtip("Calculating Hamming distance between the images" generalDetails " ( " pxk "% )" etatime, 0, 0, callOffset/totalLoops)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
      lastStep := A_TickCount
   }
   ; fnOutputDebug(A_ThisFunc ": hamDist g=" grupu " results=" totalResults)   
   IDsbigArray := ""
   flipHbigArray := ""
   HbigArray := ""
   If (abandonAll=1)
      Return "abandon"

   If (A_TickCount - prevMSGdisplay>1500)
   {
      showTOOLtip("Preparing to retrieve the similarity results for the images compared" generalDetails "`nPlease wait", 0, 0, grupu/totalgroups)
      prevMSGdisplay := A_TickCount
   }

   VarSetCapacity(resultsArrayA, 4 * totalResults + 1, 0) ; Lpair
   err := DllCall(whichMainDLL "\retrieveHammingDistanceResults", "UPtr", &resultsArrayA, "Int", 1, "uInt", totalResults)
   VarSetCapacity(resultsArrayB, 4 * totalResults + 1, 0) ; Rpair
   err := DllCall(whichMainDLL "\retrieveHammingDistanceResults", "UPtr", &resultsArrayB, "Int", 2, "uInt", totalResults)
   VarSetCapacity(resultsArrayC, 4 * totalResults + 1, 0) ; hamming distance
   err := DllCall(whichMainDLL "\retrieveHammingDistanceResults", "UPtr", &resultsArrayC, "Int", 3, "uInt", totalResults)
   ; msgbox, % "r=" totalResults

   MSE := 2500
   startOperation := A_TickCount
   thisindex := 0
   Loop, % totalResults + 2
   {
       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalResults, startOperation)
          If (PerformMSDonDupes=1)
             showTOOLtip("Calculating Mean-Squared Difference for image duplicates pairs" etaTime generalDetails, 0, 0, A_Index/totalResults)
          Else
             showTOOLtip("Integrating Hamming distance results" etaTime generalDetails, 0, 0, A_Index/totalResults)
          prevMSGdisplay := A_TickCount
       }

       idRa := NumGet(resultsArrayA, 4 * (A_Index - 1), "uInt")
       If (idRa<0)
          idRa := Abs(idRa)

       idRb := NumGet(resultsArrayB, 4 * (A_Index - 1), "uInt")
       If (idRb<0)
          idRb := Abs(idRb)

       If (idRa && idRb)
       {
          thisIndex++
          If (PerformMSDonDupes=1)
          {
             pixIDa := resultedFilesList[idRa, 12]
             pixIDb := resultedFilesList[idRb, 12]
             MSE := calcMSDvalues(dupesPixelData[pixIDa], dupesPixelData[pixIDb], 1024, 1)
          }

          idRc := NumGet(resultsArrayC, 4 * (A_Index - 1), "uInt")
          If !idRc
             idRc := 1

          resultsDupesArray[thisCounter + thisIndex] := [idRa, idRb, idRc, MSE]
          ; fnOutputDebug("res=" totalResults " tL=" totalLoops " g=" grupu " tC=" thisCounter " (" resultsDupesArray.Count() ") aI=" thisIndex " MSE=" MSE " hD=" idRc " A=" idRa " B=" idRb)
       }
   }

   IDsbigArray := ""
   HbigArray := ""
   resultsArrayA := ""
   resultsArrayB := ""
   resultsArrayC := ""
   If (abandonAll=1)
      Return "abandon"
}

retrieveDupesByProperties(theseCols, SortCriterion:=0, mustForceHashes:=0) {
   Static prevMode, notFloatsRegEX := "i)(fcreated|fmodified|fsize|imgfile|dHash|lHash|pHash|imgwidth|imgheight|imgframes|imgdpi|imgpixfmt)"
   If SortCriterion
      mode := prevMode

   wasDupesList := (testIsDupesList() && dupesHashesData.Count()>2) ? 1 : 0
   If (RegExMatch(theseCols, "i)(dHash)") || userFindDupesFilterHamDist=2)
      thisNOTnullCol := "dHash"
   Else If (RegExMatch(theseCols, "i)(pHash)") || userFindDupesFilterHamDist=3)
      thisNOTnullCol := "pHash"
   Else If (RegExMatch(theseCols, "i)(lHash)") || userFindDupesFilterHamDist=4)
      thisNOTnullCol := "lHash"
   Else If RegExMatch(theseCols, "i)(imgmedian|imgavg|imghpeak|imghlow|imghmode|imghminu|imghrange|imghrms)")
      thisNOTnullCol := "imgmedian"
   Else If RegExMatch(theseCols, "i)(imgmegapix|imgdpi|imgwidth|imgframes|imgpixfmt|imgheight|imgwhratio)")
      thisNOTnullCol := "imgwidth"
   Else If RegExMatch(theseCols, "i)(fcreated|fmodified|fsize)")
      thisNOTnullCol := "fsize"
   Else
      thisNOTnullCol := "imgfile"

   ; ToolTip, % theseCols "==" thisNOTnullCol "==" mustForceHashes , , , 2
   showTOOLtip("Identifying image duplicates, please wait")
   If (InStr(thisNOTnullCol, "hash") || mustForceHashes=1 || userFindDupesFilterHamDist>1)
   {
      scu :=  (findFlippedDupes=1) ? "HpixelzFsmall" : "pixelzFsmall"
      collectSQLFileInfosNow(scu, 0, 1, 2, 0, dupesStringFilter, userFilterStringIsNot)
   }

   If (InStr(thisNOTnullCol, "hash") || userFindDupesFilterHamDist>1 || mustForceHashes>1)
   {
      generateSQLimageFingerPrintHash(userFindDupesFilterHamDist, 0, dupesStringFilter, userFilterStringIsNot, userFilterStringPos, userFilterWhat)
      If (findFlippedDupes=1)
         generateSQLimageFingerPrintHash(userFindDupesFilterHamDist, 1, dupesStringFilter, userFilterStringIsNot, userFilterStringPos, userFilterWhat)
   }

   If (InStr(theseCols, "hash") && userFindDupesFilterHamDist>1)
   {
      theseCols := StrReplace(theseCols, "hdHash")
      theseCols := StrReplace(theseCols, "hpHash")
      theseCols := StrReplace(theseCols, "hlHash")
      theseCols := StrReplace(theseCols, "dHash")
      theseCols := StrReplace(theseCols, "pHash")
      theseCols := StrReplace(theseCols, "lHash")
      theseCols := StrReplace(theseCols, ",,", ",")
      theseCols := StrReplace(theseCols, ", ,", ",")
   }

   prevMode := theseCols
   innerTrimL := hamDistLBorderCrop + 1
   innerTrimR := 64 - hamDistLBorderCrop - hamDistRBorderCrop
   mustDoSubStr := 0

   orderCol := "a.imgmegapix,a.fsize"
   ONlist := "ON ("
   Loop, Parse, % theseCols, CSV
   {
      If !A_LoopField
         Continue

       ONlist .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " AND Round(a." A_LoopField "," findDupesPrecision ") = b." A_LoopField : " AND a." A_LoopField " = b." A_LoopField
   }

   Loop, Parse, % theseCols, CSV
   {
      If !A_LoopField
         Continue

      newCols .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " Round(" A_LoopField "," findDupesPrecision ")," : A_LoopField ","
      selectuCols .= !RegExMatch(A_LoopField, notFloatsRegEX) ? " Round(" A_LoopField "," findDupesPrecision ") AS " A_LoopField "," : A_LoopField ","
   }

   theseCols := Trimmer(newCols, ",")
   selectuCols := Trimmer(selectuCols, ",")
   includeHash := (userFindDupesFilterHamDist=2) ? ", dHash" : ""
   If (userFindDupesFilterHamDist=3)
      includeHash := ", pHash"
   Else If (userFindDupesFilterHamDist=4)
      includeHash := ", lHash"

   If (findFlippedDupes=1)
   {
      hashA := thisNOTnullCol
      hashB := thisNOTnullCol := StrReplace(includeHash, ", ", "h")
      includeHash .= StrReplace(includeHash, ", ", ", h")
   } Else if includeHash
      hashA := thisNOTnullCol

   If (PerformMSDonDupes=1 && includeHash)
   {
      pixelzA := (hashA) ? 7 : 6
      If (findFlippedDupes=1)
         pixelzA++

      ; If (findFlippedDupes=1)
      ;    pixelzB := pixelzA + 1
      ; includePixels := (findFlippedDupes=1) ? ", pixelzFbig, HpixelzFbig" : ", pixelzFbig"
      includePixels := ", pixelzFbig"
   }

   doStartLongOpDance()
   startOperation := A_TickCount
   SQLstr := "SELECT imgidu, fullPath, a.imgmegapix, a.fsize, b.groupID" includeHash includePixels " FROM images AS a`n"
   SQLstr .= " JOIN (SELECT " selectuCols ", ROWID AS groupID`n"
   ; SQLstr .= " FROM images WHERE " thisNOTnullCol " IS NOT NULL`n"
   SQLstr .= " FROM images WHERE ifnull(" thisNOTnullCol ", '')!=''`n"
   SQLstr .= " GROUP BY " theseCols " HAVING count(*)>1) AS b`n"
   SQLstr .= StrReplace(ONlist, "ON ( AND ", "ON (") ") "
   SQLstr .= StrLen(SortCriterion)>1 ? "ORDER BY a." SortCriterion ";" : "ORDER BY b.groupID," orderCol ";"
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      userFindDupesFilterHamDist := 1
      throwSQLqueryDBerror(A_ThisFunc)
      Return -1
   }

   addJournalEntry("SQL query used to identify the dupes:`n" SQLstr)
   If (determineTerminateOperation()=1)
      abandonAll := 1

   If (RecordSet.RowCount<2 || abandonAll=1)
   {
      RecordSet.Free()
      If (abandonAll=1)
         showTOOLtip("Operation aborted by user")
      Else
         showTOOLtip("Found no image duplicates")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -150
      If !SortCriterion
         SetTimer, PanelFindDupes, -250
      Return
   }

   showTOOLtip("Found " groupDigits(RecordSet.RowCount) " duplicate images`nGenerating the files list, please wait")
   If !filesFilter
      bckpMaxFilesIndex := maxFilesIndex   

   backupArray := resultedFilesList.Clone()
   backupFilter := filesFilter
   backupIndexu := currentFileIndex
   renewCurrentFilesList()
   thisString := StrReplace(dupesStringFilter, "||", "|")
   thisString := Trimmer(Trimmer(thisString), "|")
   If thisString
   {
      thisString := StrReplace(thisString, "/")
      thisString := StrReplace(thisString, ">")
      If (userFilterStringPos=2)
         thisString .= "/"
      Else If (userFilterStringPos=3)
         thisString .= ">"
      givenRegEx := processSearchIndexString(thisString)
   }

   abandonAll := 0
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   groupies := []
   totalFiles := RecordSet.RowCount
   arrHashesData := new hashtable(totalFiles)
   arrPixelData := new hashtable(totalFiles)
   Loop, % RecordSet.RowCount
   {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[2]
      {
         If (toBeExcludedIndexes[Rowu["imgidu"]]=1)
            Continue

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         If givenRegEx
         {
            okay := 0
            If coreSearchIndex(Rowu[2], givenRegEx, userFilterWhat, userFilterStringIsNot)
               okay := 1
         } Else okay := 1

         If (okay!=1)
            Continue

         groupies[Rowu[5]] := 1
         maxFilesIndex++
         resultedFilesList[maxFilesIndex, 1]  := Rowu[2]
         resultedFilesList[maxFilesIndex, 12] := Rowu[1]  ; sqlDBrowID
         resultedFilesList[maxFilesIndex, 17] := Rowu[3]
         resultedFilesList[maxFilesIndex, 6]  := Rowu[4]
         resultedFilesList[maxFilesIndex, 23] := Rowu[5]  ; initial dupe group ID
         If includeHash
         {
            If (hashA && hashB)
               arrHashesData[ Rowu[1] ] := Rowu[6] "|" Rowu[7]
            Else
               arrHashesData[ Rowu[1] ] := Rowu[6]
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(maxFilesIndex, totalFiles, startOperation)
            showTOOLtip("Retrieving image duplicates files list, please wait" etaTime, 0, 0, A_Index/totalFiles)
            prevMSGdisplay := A_TickCount
         }

         If includePixels
         {
            arrPixelData[ Rowu[1] ] := processPixArrayCharsAsSTR(Rowu[pixelzA])
            ; resultedFilesList[maxFilesIndex, 29] := processPixArrayChars(Rowu[pixelzA])
            ; If pixelzB
            ;    resultedFilesList[maxFilesIndex, 31] := processPixArrayChars(Rowu[pixelzB])
         }
      }
   }

   If (maxFilesIndex<2 || abandonAll=1)
   {
      arrHashesData := ""
      arrPixelData := ""
   } Else
   {
      dupesHashesData := arrHashesData
      dupesPixelData := arrPixelData
   }

   RecordSet.Free()
   ; MsgBox, % "g=" groupies.Count() " | i = " resultedFilesList.Count()
   If (userFindDupesFilterHamDist>1 && maxFilesIndex>2 && includeHash && abandonAll!=1)
      r := filterDupeResultsByHdist(userFindDupesHamDistLvl)

   userFilterInvertThis := userFilterDoString := 0
   currentFileIndex := userFilterProperty := 1
   filesFilter := "SQL:query:" StrReplace(SubStr(SQLstr, Round(InStr(SQLstr, "JOIN (")), InStr(SQLstr, " ORDER BY") - InStr(SQLstr, "JOIN (")), "`n", A_Space)
   ; ToolTip, % filesFilter , , , 2
   CurrentSLD := backCurrentSLD
   etaTime := "Elapsed time to identify possible image duplicates: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   SetTimer, ResetImgLoadStatus, -100
   If (maxFilesIndex<2 || abandonAll=1 || r>0)
   {
      If (r>0)
      {
         arrHashesData := ""
         arrPixelData := ""
         dupesHashesData := arrHashesData
         dupesPixelData := arrPixelData
      }

      maxFilesIndex := backupArray.Count()
      filesFilter := backupFilter
      currentFileIndex := backupIndexu
      resultedFilesList := []
      resultedFilesList := backupArray.Clone()
      backupArray := ""
      If (abandonAll=1 || r=2)
         showTOOLtip("User abandoned image duplicates identification")
      Else
         showTOOLtip("Found no image duplicates after filtering the duplicates list")

      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If !SortCriterion
         SetTimer, PanelFindDupes, -350
      Return
   } Else
      SoundBeep , 900, 100

   ; SetTimer, RemoveTooltip, % -msgDisplayTime
   backupArray := ""
   showDelayedTooltip("Found " groupDigits(groupies.Count()) " groups of duplicate images`nTotal images: " groupDigits(maxFilesIndex))
   ; ToolTip, % "x=" x , , , 2
   dummyTimerDelayiedImageDisplay(90)

   ; RandomPicture()
}

keepSelectedDupeInGroup() {
   thisGrpID := resultedFilesList[currentFileIndex, 23]
   If !thisGrpID
      Return

   desiredImgID := currentFileIndex
   Loop, % maxFilesIndex
   {
      grpID := resultedFilesList[A_Index, 23]
      If (grpID=thisGrpID)
      {
         osel := resultedFilesList[A_Index, 2] ? 1 : 0
         nsel := (desiredImgID!=A_Index) ? 1 : 0
         resultedFilesList[A_Index, 2] := nsel
         If (nsel!=osel && nsel=1)
            markedSelectFile++
         Else If (nsel!=osel && nsel=0)
            markedSelectFile--
      }
   }

   lastZeitFileSelect := A_TickCount
   dummyTimerDelayiedImageDisplay(90)
}

autoSelectDupesInGroups(mode, givenRegEx:=0) {
   ; dropFilesSelection(1)
   theArray := []
   megaCheck := new hashtable()
   ; ToolTip, % mode "==" givenRegEx , , , 2
   Loop, % maxFilesIndex
   {
      If (grpID := resultedFilesList[A_Index, 23])
      {
         p := Format("{:L}", resultedFilesList[A_Index, 1])
         If !megaCheck[p]
            countPerGroup%grpID%++
         megaCheck[p] := Round(megaCheck[p]) + 1
         fs := resultedFilesList[A_Index, 6]
         mgpx := Round(resultedFilesList[A_Index, 17], 4)
         If (fs>theArray[grpID, 1, 1])
            theArray[grpID, 1] := [fs, A_Index]
         If (fs<theArray[grpID, 3, 1] || !theArray[grpID, 3, 1])
            theArray[grpID, 3] := [fs, A_Index]

         If (mgpx>theArray[grpID, 2, 1])
            theArray[grpID, 2] := [mgpx, A_Index]
         If (mgpx<theArray[grpID, 4, 1] || !theArray[grpID, 4, 1])
            theArray[grpID, 4] := [mgpx, A_Index]
      }
   }

   indexu := 0
   rescanIDs := []
   Loop, % maxFilesIndex
   {
      grpID := resultedFilesList[A_Index, 23]
      If (mode=1) ; Automatic
      {
         If (grpID && countPerGroup%grpID%>1)
         {
            mgpxMax := theArray[grpID, 2, 1]
            mgpxMin := theArray[grpID, 4, 1]
            mgpxMin := snapToValues(mgpxMin, mgpxMax, mgpxMax, 0.01, 0)

            ; Sleep, 100
            ; ToolTip, % mgpxMin "==" mgpxMax , , , 2
            If (mgpxMin=mgpxMax)
            {
               fsMax := Round(theArray[grpID, 1, 1]/1024, 2)
               fsMin := Round(theArray[grpID, 3, 1]/1024, 2)
               If (fsMin=fsMax && givenRegEx)
               {
                  imgPath := resultedFilesList[A_Index, 1]
                  r := coreSearchIndex(imgPath, givenRegEx, 2)
                  resultedFilesList[A_Index, 2] := r ? 0 : 1
                  If !rescanIDs[grpID, 1]
                  {
                     indexu++
                     rescanIDs[grpID, 1] := r ? 0 : 1
                  }

                  If (rescanIDs[grpID, 2]!=0)
                     rescanIDs[grpID, 2] := r ? 0 : 1

                  If !r
                     countSel%grpID%++
               } Else If (fsMax=fsMin && countSel%grpID%<countPerGroup%grpID%)
               {
                  ; SoundBeep , 300, 100
                  countSel%grpID%++
                  If (countSel%grpID%<countPerGroup%grpID%)
                     resultedFilesList[A_Index, 2] := 1
               } Else If (fsMax!=fsMin)
               {
                  thisIndex := theArray[grpID, 1, 2] ; max file size
                  resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
                  If (thisIndex!=A_Index)
                     countSel%grpID%++
               }
            } Else
            {
               thisIndex := theArray[grpID, 2, 2] ; max res
               resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
               If (thisIndex!=A_Index)
                  countSel%grpID%++
            }
         } Else resultedFilesList[A_Index, 2] := 0
      } Else
      {
         ; mode=3 - megapixels
         ; mode=2 - fsize
         If (grpID && countPerGroup%grpID%>1)
         {
            fsMax := (mode=2) ? Round(theArray[grpID, 1, 1]/1024, 2) : theArray[grpID, 2, 1]
            fsMin := (mode=2) ? Round(theArray[grpID, 3, 1]/1024, 2) : theArray[grpID, 4, 1]
            If (fsMin=fsMax && givenRegEx)
            {
               imgPath := resultedFilesList[A_Index, 1]
               r := coreSearchIndex(imgPath, givenRegEx, 2)
               resultedFilesList[A_Index, 2] := r ? 0 : 1
               If !rescanIDs[grpID, 1]
               {
                  indexu++
                  rescanIDs[grpID, 1] := r ? 0 : 1
               }

               If (rescanIDs[grpID, 2]!=0)
                  rescanIDs[grpID, 2] := r ? 0 : 1

               If !r
                  countSel%grpID%++
            } Else If (fsMax=fsMin && countSel%grpID%!=1)
            {
               countSel%grpID% := 1
               resultedFilesList[A_Index, 2] := 1
            } Else If (fsMax!=fsMin)
            {
               thisIndex := (mode=2) ? theArray[grpID, 1, 2] : theArray[grpID, 2, 2]
               resultedFilesList[A_Index, 2] := (thisIndex=A_Index) ? 0 : 1
               If (thisIndex!=A_Index)
                  countSel%grpID%++
            }
         } Else resultedFilesList[A_Index, 2] := 0
      }
   }

   If (indexu>0 && givenRegEx)
   {
      ; ensure that all or none are selected within a group after regex
      Loop, % maxFilesIndex
      {
         grpID := resultedFilesList[A_Index, 23]
         If (grpID && countPerGroup%grpID%>1)
         {
            If (rescanIDs[grpID, 1]=0)
            {
               rescanIDs[grpID, 1] := 1
               resultedFilesList[A_Index, 2] := 1
            }

            If (rescanIDs[grpID, 2]=1)
            {
               rescanIDs[grpID, 2] := 0
               resultedFilesList[A_Index, 2] := 0
            }
         }
      }
   }

   megaCheck := ""
   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)
}

sldGenerateFilesList(readThisFile, doFilesCheck, mustRemQuotes, doOptionals:=1) {
    startZeit := A_TickCount
    FileRead, tehFileVar, %readThisFile%
    If (mustRemQuotes=1)
    {
       tehFileVar := StrReplace(tehFileVar, """-")
       tehFileVar := StrReplace(tehFileVar, """")
    }

    doStartLongOpDance()
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If InStr(line, "|")
       {
          RecursiveFlag := "|"
          line := StrReplace(line, "|")
       } Else RecursiveFlag := ""

       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       ; changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          If (doFilesCheck=1)
          {
             If !FileRexists(line)
                Continue
          }

          maxFilesIndex++
          resultedFilesList[maxFilesIndex] := [line]
          ; tempu .= Chr(34) line Chr(34) "`n"
       } Else If RegExMatch(line, "i)^(.\:\\.)") ; RegExMatch(line, "i)^(.\:\\.).*(\\)$")
       {
          line := Trimmer(line, "\")
          If FolderExist(line)
          {
             DynamicFoldersList .= "`n" RecursiveFlag line "`n"
             GetFilesList(RecursiveFlag line "\*")
          }
       }
    }

    ; Clipboard := tempu
    etaTime := "Elapsed time to open TXT files list: " SecToHHMMSS(Round((A_TickCount - startZeit)/1000, 3)) ". Files: " maxFilesIndex
    addJournalEntry(etaTime)
    If (A_TickCount - startZeit>7000) && (maxFilesIndex>2 && abandonAll!=1)
       SoundBeep, 900, 100

    executingCanceableOperation := 0
    SetTimer, ResetImgLoadStatus, -50
    If (doOptionals=1)
    {
       If (abandonAll=1)
          showDelayedTooltip("Operation aborted. The files list is now empty.")
       Else If (maxFilesIndex<1)
          showDelayedTooltip("Found no files or folders in the SLD`nThe files list is now empty.")

       If (abandonAll=1 || maxFilesIndex<1)
       {
          lastLongOperationAbort := A_TickCount
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SoundBeep, 300, 100
          Return "abandoned"
       }
    }
}

GetFilesList(strDir, progressInfo:=0, doCommits:=1, factCheck:=1) {
/*
  QPV internally relies on resultedFilesList[] array. 
  Each file entry is defined by various properties:

  resultedFilesList[index_number] :=
  [ 1_filePath, 2_isSelected, 3_isSeen, 4_forceThumbRefresh
  , 5_isFavourite, 6_fileSize, 7_fileDateModified
  , 8_fileDateCreated, 9_imgFrames, 10_mustDoSort, 11_IsImgHisto
  , 12_dbRowIndex, 13_imgW, 14_imgH, 15_imgPixFmt, 16_imgWHratio
  , 17_imgMGPX, 18_imgHAvg, 19_imgHmedian, 20_imgHpeak, 21_imgHlow
  , 22_imgDPI, 23_dupeID, 24_imghRMS, 25_imghRange, 26_imghMode
  , 27_imghMin, 28_imgHASH, 29_pixelzFsmall, 30_pixelzFbig
  , 31_HpixelzFsmall, 32_HpixelzFbig, 33_HammingDist, 34_MSEscore
  , 35_dateSeenDB, 36_sortModeDB]

  All these properties are optional and are filled based on the
  application context. 1_filePath is the only property that is not
  optional, because it specifies the file path and image file at
  the given index entry.

  resultedFilesList[] array is populated by, GetFilesList(),
  OpenSLD(), sldGenerateFilesList(),  OpenSLDBdataBase(),
  performSQLgetTable(), dbSortingCached(), SortFilesList() and others.
*/

  OutDir := PathCompact(Trim(StrReplace(strDir, "*"), "\"), "a", 1, OSDfontSize)
  friendly := (userPrivateMode=1) ? "*:\********\****" : OutDir
  showTOOLtip("Loading files from`n" friendly "`n", 0, 0, progressInfo)
  If InStr(strDir, "|")
  {
     doRecursive := ""
     strDir := StrReplace(strDir, "|")
  } Else doRecursive := "R"

  abandonAll := thisCounter := addedNow := 0
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  prevDisplay := A_TickCount
  doStartLongOpDance()
  If (SLDtypeLoaded=3)
  {
     newArrayu := []
     If (doCommits=1)
        activeSQLdb.Exec("BEGIN TRANSACTION;")

     Loop, Files, %strDir%, %doRecursive%
     {
         fullPath := Trimmer(A_LoopFileFullPath)
         If (RegExMatch(fullPath, RegExFilesPattern) && A_LoopFileSize>120)
         {
            thisCounter++
            newArrayu[thisCounter] := [A_LoopFileName, A_LoopFileDir, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated]
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            showTOOLtip("Loading files from`n" friendly "`nFound " groupDigits(thisCounter) " files...`nTotal indexed files: " groupDigits(maxFilesIndex), 0, 0, progressInfo)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }

     Loop, % thisCounter
     {
         If (determineTerminateOperation()=1 || abandonAll=1)
         {
            abandonAll := 1
            Break
         }

         erru := addSQLdbEntry(newArrayu[A_Index, 1], newArrayu[A_Index, 2], newArrayu[A_Index, 3], newArrayu[A_Index, 4], newArrayu[A_Index, 5], 0, factCheck)
         If !erru
         {
            addedNow++
            If (factCheck!=0)
            {
               maxFilesIndex++
               fullPath := newArrayu[A_Index, 2] "\" newArrayu[A_Index, 1]
               If (A_PtrSize=8 && minimizeMemUsage!=1)
                  resultedFilesList[maxFilesIndex] := [fullPath,,,,, newArrayu[A_Index, 3], newArrayu[A_Index, 4], newArrayu[A_Index, 5]]
               Else
                  resultedFilesList[maxFilesIndex] := [fullPath]

               resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
            }
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(A_Index, thisCounter, startOperation)
            showTOOLtip("Inserting records into the database for`n" friendly etaTime, 0, 0, A_Index / thisCounter)
            prevMSGdisplay := A_TickCount
         }

     }

     If (doCommits=1)
     {
        If !activeSQLdb.Exec("COMMIT TRANSACTION;")
           throwSQLqueryDBerror(A_ThisFunc)
     }
  } Else
  {
     Loop, Files, %strDir%, %doRecursive%
     {
         fullPath := Trimmer(A_LoopFileFullPath)
         If (RegExMatch(fullPath, RegExFilesPattern) && A_LoopFileSize>120)
         {
            If (SLDtypeLoaded=3) ; SQLite database 
               erru := addSQLdbEntry(A_LoopFileName, A_LoopFileDir, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated)

            If !erru
            {
               addedNow++
               maxFilesIndex++
               If (A_PtrSize=8 && minimizeMemUsage!=1)
                  resultedFilesList[maxFilesIndex] := [fullPath,,,,, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated]
               Else
                  resultedFilesList[maxFilesIndex] := [fullPath]

               If (SLDtypeLoaded=3)
                  resultedFilesList[maxFilesIndex, 12] := sqlDBrowID
            }
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            showTOOLtip("Loading files from`n" friendly "`nFound " groupDigits(addedNow) " files...`nTotal indexed files: " groupDigits(maxFilesIndex), 0, 0, progressInfo)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }
  }

  currentFilesListModified := 1
  executingCanceableOperation := 0
  SetTimer, ResetImgLoadStatus, -50
  If (abandonAll=1)
  {
     showTOOLtip("Files list loading aborted")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "abandoned"
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return loadedFirst
}

getIDimage(imgID) {
    Return resultedFilesList[imgID, 1]
}

IDshowImage(imgID, opentehFile:=0) {
    Static prevIMGid, prevImgPath, lastInvoked := 1
    imgPath := getIDimage(imgID)
    If StrLen(imgPath)<4
    {
       addJournalEntry("Index entry error: incorrect file path:`n" imgPath " [ " imgID " ]")
       If (A_TickCount - lastInvoked>1050)
          SoundBeep, 300, 90
       lastInvoked := A_TickCount
       Return 0
    }

    isPipe := InStr(imgPath, "||")
    imgPath := StrReplace(imgPath, "||")
    If (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath) || validBMP(UserMemBMP) || thumbsDisplaying=1)
       ignoreFileCheck := 1

    If (ignoreFileCheck!=1 && skipDeadFiles=1 && (A_TickCount - lastFastImgChangeHUDzeit>400))
    {
       If (!FileRexists(imgPath) && opentehFile!=250 && imgPath!=prevImgPath)
       {
          If (autoRemDeadEntry=1 && imgID=currentFileIndex)
             remCurrentEntry(1)
          Return 0
       }
    }

    If (AnyWindowOpen!=10 && resetImageViewOnChange=1 && thumbsDisplaying!=1)
    {
       newIMGid := generateThumbName(imgPath, 1)
       If (prevIMGid!=newIMGid)
       {
          prevIMGid := newIMGid
          usrColorDepth := imgFxMode := 1
          vpIMGrotation := FlipImgH := FlipImgV := 0
       }
    }

    prevImgPath := (opentehFile=0 || opentehFile=2) ? imgPath : 0
    If (opentehFile=2)
       ShowTheImage(imgPath, 2)  ; prevent down-scaled display
    Else If (opentehFile=3)
       ShowTheImage(imgPath, 2, 1)  ; force image reload
    Else
       ShowTheImage(imgPath)
    Return 1
}

PreventKeyPressBeep() {
   IfEqual,A_Gui,1,Return 0 ; prevent keystrokes for GUI 1 only
}

trimArray(arr) {
; Hash O(n) - function by errorseven from:
; https://stackoverflow.com/questions/46432447/how-do-i-remove-duplicates-from-an-autohotkey-array
    hash := {}
    newArr := []
    thisCounter := 0
    For k, v in arr
    {
        z := "z" StringToASC(v)
        If (hash[z]!=1)
        {
           thisCounter++
           hash[z] := 1
           newArr[thisCounter] := v
        }
    }
    Return newArr
}

ReverseListNow() {
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (maxFilesIndex<3)
       Return

    If askAboutFileSave(" and the files list will be reversed")
       Return

    showTOOLtip("Reversing files list order")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := reverseArray(resultedFilesList)
    If StrLen(filesFilter)>1
       filteredMap2mainList := reverseArray(filteredMap2mainList)

    currentFilesListModified := 1
    ForceRefreshNowThumbsList()
    CurrentSLD := backCurrentSLD
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

RandomizeListNow() {
    If StrLen(filesFilter)>1
    {
       msgResult := msgBoxWrapper(appTitle ": Randomize files list", "You currently have a files list filter applied. To randomize the list, it will be deactivated.", 4, 0, "question")
       If InStr(msgResult, "yes")
       {
          markedSelectFile := 0
          showTOOLtip("Deactivating the files list filter, please wait")
          remFilesListFilter("simple")
          Sleep, 10
          RemoveTooltip()
       } Else Return
    }

    If askAboutFileSave(" and the files list will be randomized")
       Return

    showTOOLtip("Randomizing files list order")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := Random_ShuffleArray(resultedFilesList)
    CurrentSLD := backCurrentSLD
    currentFilesListModified := 1
    ForceRefreshNowThumbsList()
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

Random_ShuffleArray(Array) {
; function from "Facade Functional Programming Suite"
; by Shambles, from https://github.com/Shambles-Dev/AutoHotkey-Facade
; modified by Marius Șucan
; This is the Durstenfeld's in-place version of the Fisher–Yates shuffle algorithm.

    Result := Array.Clone()
    maxArray := Array.Count()
    Loop, % maxArray - 1
    {
        Random, J, % A_Index, % maxArray
        Temp            := Result[A_Index]
        Result[A_Index] := Result[J]
        Result[J]       := Temp
    }

    Return Result
}

reverseArray(a) {
; function inspired by RHCP from https://autohotkey.com/board/topic/97722-some-array-functions/
    aStorage := []
    maxIndexu := a.Count()
    Loop, % maxIndexu
        aStorage[A_Index] := a[maxIndexu - A_Index + 1]

    Return aStorage
}

coreResizeIMG(imgPath, newW, newH, file2save, goFX, toClippy, rotateAngle, soloMode:=1, imgW:=0, imgH:=0) {
    If (soloMode=1)
    {
       oBitmap := LoadBitmapFromFileu(imgPath)
       If validBMP(oBitmap)
       {
          trGdip_GetImageDimensions(oBitmap, imgW, imgH)
          rawFmt := Gdip_GetImageRawFormat(oBitmap)
          If (!newW || !newH)
             mustDoRotateCoord := 1

          If !newW
             newW := imgW
          If !newH
             newH := imgH
          If (rotateAngle>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1 && mustDoRotateCoord=1)
             Gdip_GetRotatedDimensions(newW, newH, rotateAngle, newW, newH)
       } Else Return "error"
    } Else oBitmap := soloMode

    If !validBMP(oBitmap)
       Return "error"

    If (ResizeApplyEffects=1 || goFX=1)
    {
       mustDoBw := (bwDithering=1 && imgFxMode=4) ? 1 : 0
       decideGDIPimageFX(matrix, imageAttribs, pEffect)
    }

    ; to-do - if pargb - always??
    oPixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    If (toClippy=1)
       oPixFmt := (currIMGdetails.HasAlpha=1) ? "32-PARGB" : "24-RGB"

    brushRequired := !InStr(oPixFmt, "argb") ? 1 : 0
    pixFmt := (must24bits=1) ? "0x21808" : "0x26200A"     ; 24-RGB  //  32-ARGB
    thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
    If (editingSelectionNow=1 && ResizeCropAfterRotation=1 && ResizeWithCrop=1 && rotateAngle>0)
    {
       oBitmap := coreRotateBMP(oBitmap, rotateAngle, thisImgQuality, pixFmt, brushRequired)
       trGdip_GetImageDimensions(oBitmap, imgW, imgH)
    }

    If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1 && soloMode=1)
       calcRelativeSelCoords(oBitmap, imgW, imgH)

    If (editingSelectionNow=1 && (goFX=1 || ResizeWithCrop=1))
    {
       calcImgSelection2bmp(0, imgW, imgH, newW, newH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       imgSelW := Round(imgW), imgSelH := Round(imgH)
       imgSelPx := 0, imgSelPy := 0

       zImgSelW := Round(newW), zImgSelH := Round(newH)
       zImgSelPx := 0, zImgSelPy := 0
    }

    thumbBMP := trGdip_CreateBitmap(A_ThisFunc, zImgSelW, zImgSelH, pixFmt)
    If warnUserFatalBitmapError(thumbBMP, A_ThisFunc)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return "error"
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbBMP, thisImgQuality, 4, 2)
    If !G2
    {
       trGdip_DisposeImage(oBitmap, 1)
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return "error"
    }

    If (brushRequired=1) || (!RegExMatch(file2save, saveAlphaTypesRegEX) && toClippy!=1)
       trGdip_GraphicsClear(A_ThisFunc, G2, "0xFf" WindowBgrColor)
       ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, imgW + 4, imgH + 4)

    If (goFX=1 || ResizeApplyEffects=1)
    {
       setMainCanvasTransform(zImgSelW, zImgSelH, G2)
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(A_ThisFunc, oBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If validBMP(zBitmap)
          {
             trGdip_DisposeImage(oBitmap, 1)
             oBitmap := zBitmap
          }

          E := Gdip_BitmapSetColorDepth(oBitmap, "BW", 1)
       } Else If (usrColorDepth>1)
          E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
 
       If pEffect
          Gdip_BitmapApplyEffect(oBitmap, pEffect)
    }

    changeMcursor()
    E := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, 0, 0, zImgSelW, zImgSelH, imgSelPx, imgSelPy, imgSelW, imgSelH,, 2, imageAttribs)
    trGdip_DisposeImage(oBitmap, 1)
    If (E="fail")
    {
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DeleteGraphics(G2)
       Gdip_DisposeImageAttributes(imageAttribs)
       Gdip_DisposeEffect(pEffect)
       Return "error"
    }

    Sleep, 0
    If (editingSelectionNow=1 && ResizeCropAfterRotation=0 && ResizeWithCrop=1 && rotateAngle>0) || (rotateAngle>0 && editingSelectionNow!=1) || (rotateAngle>0 && ResizeWithCrop!=1)
       thumbBMP := coreRotateBMP(thumbBMP, rotateAngle, thisImgQuality, pixFmt, brushRequired)

    If (toClippy!=1 && FileExist(file2save))
       Try FileSetAttrib, -R, %file2save%

    Sleep, 0
    changeMcursor()
    If validBMP(thumbBMP)
    {
       If (toClippy=1)
       {
          hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, thumbBMP)
          r := hBitmap ? Gdip_SetBitmapToClipboard(thumbBMP, hBitmap) : addJournalEntry("get_last_err")
       } Else
          r := Gdip_SaveBitmapToFile(thumbBMP, file2save, userJpegQuality)

       If (toClippy!=1) && (r=-2 || r=-1)
          r := SaveFIMfile(file2save, thumbBMP)
    } Else r := "err"

    Gdip_DeleteGraphics(G2)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeImageAttributes(imageAttribs)
    trGdip_DisposeImage(thumbBMP, 1)
    Return r
}

coreRotateBMP(whichBitmap, rotateAngle, thisImgQuality, pixFmt, brushRequired) {
    Static imgOrientOpt := {"i000":0, "i100":1, "i200":2, "i300":3, "i010":4, "i110":5, "i210":6, "i310":7, "i001":6, "i101":7, "i201":4, "i301":5, "i011":2, "i111":3, "i211":0, "i311":1}

    confirmSimpleRotation := isVarEqualTo(rotateAngle, 0, 90, 180, 270)
    If (confirmSimpleRotation=1)
    {
       imgFoperation := (rotateAngle=90) ? 1 : 0
       imgFoperation := (rotateAngle=180) ? 2 : imgFoperation
       imgFoperation := (rotateAngle=270) ? 3 : imgFoperation
       If (imgFoperation>0)
          Gdip_ImageRotateFlip(whichBitmap, imgFoperation)
       thumbBMP := whichBitmap
    } Else
    {
       whichBrush := (brushRequired=1) ? pBrushWinBGR : ""
       zBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, rotateAngle, whichBrush, thisImgQuality, pixFmt)
       If validBMP(zBitmap)
       {
          trGdip_DisposeImage(whichBitmap, 1)
          thumbBMP := zBitmap
       } Else thumbBMP := zBitmap
    }
    Return thumbBMP
}

flipBitmapAccordingToViewPort(whichBitmap, ignoreThis:=0) {
   If !validBMP(whichBitmap)
      Return whichBitmap

   imgOp := (FlipImgH=1) ? 4 : 0
   imgOp := (FlipImgV=1) ? 6 : imgOp
   imgOp := (FlipImgV=1 && FlipImgH=1) || (vpIMGrotation=180 && ignoreThis=0) ? 2 : imgOp
   If (imgOp>0)
      Gdip_ImageRotateFlip(whichBitmap, imgOp)
   Return whichBitmap
}

calcImgSelection2bmp(boundLess, imgW, imgH, newW, newH, ByRef imgSelPx, ByRef imgSelPy, ByRef imgSelW, ByRef imgSelH, ByRef zImgSelPx, ByRef zImgSelPy, ByRef zImgSelW, ByRef zImgSelH, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, usePrevious:=0, givenRotation:=0, givenCoords:=0) {
   If (usePrevious=1)
   {
      nImgSelX1 := min(prevImgSelX1, prevImgSelX2)
      nImgSelY1 := min(prevImgSelY1, prevImgSelY2)
      nImgSelX2 := max(prevImgSelX1, prevImgSelX2)
      nImgSelY2 := max(prevImgSelY1, prevImgSelY2)
   } Else
   {
      nImgSelX1 := min(imgSelX1, imgSelX2)
      nImgSelY1 := min(imgSelY1, imgSelY2)
      nImgSelX2 := max(imgSelX1, imgSelX2)
      nImgSelY2 := max(imgSelY1, imgSelY2)
   }

   If (givenCoords="a")
   {
      nImgSelX1 := Round(prcSelX1*imgW)
      nImgSelY1 := Round(prcSelY1*imgH)
      nImgSelX2 := Round(prcSelX2*imgW)
      nImgSelY2 := Round(prcSelY2*imgH)
   } Else If InStr(givenCoords, "|")
   {
      givenCoordsObj := StrSplit(givenCoords, "|")
      nImgSelX1 := min(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY1 := min(givenCoordsObj[2], givenCoordsObj[4])
      nImgSelX2 := max(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY2 := max(givenCoordsObj[2], givenCoordsObj[4])
   }

   If (boundLess=-1)
   {
      initialboundLess := boundLess
      boundLess := (A_PtrSize=4) ? 0 : 1
   }

   If (boundLess!=1)
   {
      If (nImgSelX1<0)
         nImgSelX1 := 0
      If (nImgSelY1<0)
         nImgSelY1 := 0

      If (nImgSelX2>imgW)
         nImgSelX2 := imgW
      If (nImgSelY2>imgH)
         nImgSelY2 := imgH
   }

   imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
   imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
   imgSelPx := min(nImgSelX1, nImgSelX2)
   imgSelPy := min(nImgSelY1, nImgSelY2)
   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(imgSelW, imgSelH, givenRotation, rimgSelW, rimgSelH)
      imgSelPx := imgSelPx - (rimgSelW - imgSelW)//2
      imgSelPy := imgSelPy - (rimgSelH - imgSelH)//2
      imgSelW := rimgSelW
      imgSelH := rimgSelH
      If (imgSelPx<1)
         imgSelPx := 0
      If (imgSelPy<1)
         imgSelPy := 0
      If (imgSelPx + imgSelW>imgW)
         imgSelW := imgW - imgSelPx
      If (imgSelPy + imgSelH>imgH)
         imgSelH := imgH - imgSelPy
   }

   If (imgSelW<2)
   {
      imgSelW := 2
      imgSelPx := (imgSelPx>=2) ? imgSelPx - 2 : 0
      nImgSelX2 := imgSelPx + imgSelW
   }

   If (imgSelH<2)
   {
      imgSelH := 2
      imgSelPy := (imgSelPy>=2) ? imgSelPy - 2 : 0
      nImgSelY2 := imgSelPy + imgSelH
   }

   nImgSelX1 := imgSelPx
   nImgSelY1 := imgSelPy

   zLv := newH/imgH
   zLh := newW/imgW
   zImgSelX1 := Floor(nImgSelX1*zLh)
   zImgSelY1 := Floor(nImgSelY1*zLv)
   zImgSelX2 := Floor(nImgSelX2*zLh)
   zImgSelY2 := Floor(nImgSelY2*zLv)
   If (boundLess!=1)
   {
      If (zImgSelX2>newW)
         zImgSelX2 := newW
      If (zImgSelY2>newH)
         zImgSelY2 := newH
   }

   zImgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   zImgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
   zImgSelPx := min(zImgSelX1, zImgSelX2)
   zImgSelPy := min(zImgSelY1, zImgSelY2)
   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(zimgSelW, zimgSelH, givenRotation, zrimgSelW, zrimgSelH)
      zimgSelPx := zimgSelPx - (zrimgSelW - zimgSelW)//2
      zimgSelPy := zimgSelPy - (zrimgSelH - zimgSelH)//2
      zimgSelW := zrimgSelW
      zimgSelH := zrimgSelH
      If (zimgSelPx<1)
         zimgSelPx := 0
      If (zimgSelPy<1)
         zimgSelPy := 0
      If (zimgSelPx + zimgSelW>newW)
         zimgSelW := newW - zimgSelPx
      If (zimgSelPy + zimgSelH>newH)
         zimgSelH := newH - zimgSelPy
   }

   If (zImgSelW<2)
   {
      zImgSelW := 2
      zImgSelPx := (zImgSelPx>=2) ? zImgSelPx - 2 : 0
   }

   If (zImgSelH<2)
   {
      zImgSelH := 2
      zImgSelPy := (zImgSelPy>=2) ? zImgSelPy - 2 : 0
   }

   If (initialboundLess=-1 && boundLess=0 && !givenRotation)
   {
      capSelectionRelativeCoords()
      imgSelX1 := X1, imgSelY1 := Y1
      imgSelX2 := X2, imgSelY2 := Y2
      SetTimer, dummyRefreshImgSelectionWindow, -100
   }
}

BtnHelpResizePanel() {
    msgBoxWrapper(appTitle ": HELP", "In «Advanced mode» the support for color depths other than 24 and 32 bits is very limited. All images are converted to 24 bits per pixel, or to 32 bits, if an alpha channel is present. When saving images in formats that do not support an alpha channel, the window background color is used.`n`nUse «Simple mode» to better preserve color depths or work with images larger than 536 MPx or larger than 199000 px width or height [if the given file format allows it]. This mode supports 1-, 8-, 24-, 32-, 16- (UINT16), 48- (RGB16), 64- (RGBA16), 32- (FLOAT), 96- (RGBF) and 128- (RGBAF) bits images. High-dynamic range formats supported: .EXR, .HDR, .JXR, .HDP, .PFM and .TIFF.`n`nPlease also note, while there is full support for multi-frames/paged images [for WEBP, GIFs and TIFFs] in the viewport... on file (re)save, resize or format conversions, only the first frame will be preserved.`n`nSome file formats have image dimensions limited by design. WebP file format is limited to 16350 px in width or height. JPEG, TGA, and GIF formats are limited to 65530 px in width or height and 4294 MPx. When this panel is used to resize images, the resulted image dimensions maybe be capped to the format specific limits. For any format, including TIFF, PNG and JPEG, the limit is 8250 megapixels, even when the «Simple mode» is used.", -1, 0, 0)
}

OpenGitHub() {
  Static thisURL := "https://github.com/marius-sucan/Quick-Picto-Viewer"
  Try Run, % thisURL
  Catch wasError
        msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the URL:`n" %thisURL%, 0, 0, "error")
}

MenuDrawViewportHelpMap() {
   SetTimer, RemoveTooltip, Off
   lastOSDtooltipInvoked := A_TickCount
   SetTimer, drawViewportHelpMap, -100
}

drawViewportHelpMap() {
    vpWinClientSize(mainWidth, mainHeight)
    If (editingSelectionNow=1)
    {
       lastOSDtooltipInvoked := A_TickCount
       SetTimer, RemoveTooltip, Off
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xEE121212")
       thisThick := imgHUDbaseUnit//9
       Penuha := Gdip_CreatePen("0xEE445544", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x15EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x20778877)
       dotsSize := SelDotsSize
       thisW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
       thisH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
       thisX := min(selDotX, selDotAx) + dotsSize//2
       thisY := min(selDotY, selDotAy) + dotsSize//2
       thisu := (EllipseSelectMode=1) ? "Ellipse" : "Rectangle"
       Gdip_Fill%thisu%(2NDglPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_Draw%thisu%(2NDglPG, Penuha, thisX, thisY, thisW, thisH)
       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfontSize*0.77)
       thisStylu := " x" thisX " y" thisY
       ; hasTrans := adjustCanvas2Toolbar(2NDglPG, 0)
       tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
       tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
       thisString := (EllipseSelectMode=2) ? "Image selected area`nFreeform shape" : "Image selected area"
       ERR := Gdip_TextToGraphics(2NDglPG, thisString, thisFntSize thisStylu , "Arial", thisW, thisH)
       thisFntSize := "Bold cFFeeEEee s" Round(OSDfontSize*0.77)
       thisStylu := " x" OSDfontSize*2 + tlbrBonusX " y" OSDfontSize*2 + tlbrBonusY
       ERR := Gdip_TextToGraphics(2NDglPG, "Current selection type: " DefineVPselAreaMode() ".`n `nDouble click on it to open a menu.`n `nDouble click outside to drop the selection.`n `nHold Space and click to pan image.`n `nCtrl + Wheel Up/Down to zoom in/out anywhere.", thisFntSize thisStylu , "Arial", mainWidth - OSDfontSize*2, mainHeight - OSDfontSize*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
       lastOSDtooltipInvoked := A_TickCount
       toolTipGuiCreated := 2
    } Else If (TouchScreenMode=1)
    {
       SetTimer, RemoveTooltip, Off
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xEE121212")
       thisThick := imgHUDbaseUnit//10
       Penuha := Gdip_CreatePen("0x99334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x15EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x20778877)

       calculateTouchMargins(thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(2NDglPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(2NDglPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(2NDglPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_SetClipRect(2NDglPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(2NDglPG)

       If (totalFramesIndex>1)
       {
          mwh := Round(mainHeight * 0.7)
          Gdip_DrawLine(2NDglPG, Penuha, 0, mwh, thisX, mwh)
          Gdip_DrawLine(2NDglPG, Penuha, thisX + thisW, mwh, mainWidth, mwh)
       } Else mwh := mainHeight

       Gdip_DrawRectangle(2NDglPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfontSize*0.77)
       thisStylu := " x" thisX " y" thisY
       ERR := Gdip_TextToGraphics(2NDglPG, "Image panning area.`n`nDouble click in this area to change how the image is adapted to the viewport.`n`nShift + Left-click to create a new selection area.`n`nOne-finger swipe gestures allowed when nothing to pan - outside this rectangle they are always allowed.`n`nCtrl + Wheel Up/Down to zoom in/out anywhere", thisFntSize thisStylu , "Arial", thisW, thisH)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfontSize*0.9)
       thisStylu := " x" thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom in", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x" thisX " y" thisY + thisH
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom out", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x1 y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Previous`nimage", thisFntSize thisStylu, "Arial", thisX, mwh)
       thisStylu := " x1 y" mwh
       If (totalFramesIndex>1)
          ERR := Gdip_TextToGraphics(2NDglPG, "Previous`nframe", thisFntSize thisStylu, "Arial", thisX, mainHeight - mwh)
       thisStylu := " x" thisW + thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Next`nimage", thisFntSize thisStylu, "Arial", thisX, mwh)
       thisStylu := " x" thisW + thisX " y" mwh
       If (totalFramesIndex>1)
          ERR := Gdip_TextToGraphics(2NDglPG, "Next`nframe", thisFntSize thisStylu, "Arial", thisX, mainHeight - mwh)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
       lastOSDtooltipInvoked := A_TickCount
       toolTipGuiCreated := 2
    }
}

ShowContextualHelp() {
   Static blushTypes := {1:"Simple solid color", 2:"Soft edges brush", 3:"Cloner", 4:"Eraser", 5:"Effects", 6:"Smudge", 7:"Pinch", 8:"Bulge"}

   infoThumbsList := defineListViewModes()
   If (thumbsDisplaying=1)
   {
      If testIsDupesList()
         info := "`nDisplaying a list of identified image duplicates"
      msgu := "Current context: " infoThumbsList " list view" info "`nF4 - Open folders tree explorer`nEscape / Enter - Return to image view"
   } Else If (drawingShapeNow=1)
   {
      msgu := "Current context: drawing a freeform shape`nEscape - Abandon`nEnter - Finish drawing`nR-Click - Options"
   } Else If (AnyWindowOpen>0)
   {
      If (AnyWindowOpen=24 || AnyWindowOpen=31)
         SetTimer, BtnHelpTransform, -100
      Else If (AnyWindowOpen=64)
         SetTimer, BtnHelpBrushes, -100

      WinGetTitle, OutputVar , ahk_id %hSetWinGui%
      If (imgEditPanelOpened=1)
      {
         if isNowAlphaPainting()
            thisu := "`nContext: painting alpha mask"
         Else If (AnyWindowOpen=64)
            thisu := "`nCurrent brush: " blushTypes[BrushToolType]

         moreInfo := "`nLive image editing tool" thisu "`nF8 - Toggle panel visibility`nEscape - Abandon`nEnter - Apply"
      }

      OutputVar := StrReplace(OutputVar, ": " appTitle)
      If (imgEditPanelOpened=1 && IMGlargerViewPort=1)
         moreInfo .= "`nHold the Space key and left-click to pan the image"
      msgu := "Current tool: " OutputVar moreInfo
   }
   
   If msgu
      showTOOLtip(msgu)
   SetTimer, RemoveTooltip, % -msgDisplayTime*3
}

showQuickHelp() {
    Static lastInvoked := 1
    If ((A_TickCount - lastInvoked<650) && !AnyWindowOpen && drawingShapeNow!=1)
       PanelHelpWindow()
    Else If (AnyWindowOpen || drawingShapeNow=1 || thumbsDisplaying=1)
       ShowContextualHelp()
    Else
       drawViewportHelpMap()

    lastInvoked := A_TickCount
    ; listu := ""
    ; Loop, 256
    ;    listu .= Chr(A_Index + 161)
    ; MsgBox, % listu
}

PanelAboutWindow() {
    Global LViewOthers, listViewFilteru
    thisBtnHeight := createSettingsGUI(1, A_ThisFunc)
    Gui, Add, Button, x15 y15 h1 w1 Default Section gBtnCloseWindow, Close
    ml := (isWinXP=1 || A_OSVersion="WIN_7") ? 85 : 145
    Gui, -DPIScale
    Gui, Font, s19 Bold, Arial, -wrap
    Gui, Add, Picture, x+2 y+2 w%ml%  h-1 +0x3 gOpenGitHub, qpv-icon.ico
    Gui, Add, Text, x+20 yp, %appTitle% v%appVersion% %verType%
    Gui, Font, s10 Bold, Arial, -wrap
    Gui, Add, Link, y+10 wp +0x200, Developed by: <a href="https://marius.sucan.ro/">Marius Șucan</a>.
    Gui, Add, Text, y+20 wp +0x200, Release date: %vReleaseDate%.
    Gui, Font
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%
    lstWid := 450
    btnWid := 60
    txtWid := 440
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 250
       btnWid := btnWid + 30
       txtWid := txtWid + 190
       Gui, Font, s%LargeUIfontValue%
    }

    IniAction(1, "appVersion", "General")
    If wasInitFIMlib
       thisVersion := " v" FreeImage_GetVersion()

    compiled := (A_IsCompiled=1) ? "Compiled. " : "Uncompiled. "
    compiled .= (A_PtrSize=8) ? "x64. " : "x32. "
    Gui, +DPIScale
    Gui, Font, Bold

    Gui, Add, Text, xs y+25 w%txtWid% BackgroundTrans, Internal AHK-H version: %A_AhkVersion%. %compiled%OS: %A_OSVersion%.
    If isWinStore()
       Gui, Add, Link, y+10 wp, This open source application was downloaded through <a href="ms-windows-store://pdp/?productid=9N07RF144FV1">Windows Store</a>, published by <a href="https://tabletpro.com">Tablet Pro</a>. Source code available on <a href="https://github.com/marius-sucan/Quick-Picto-Viewer">GitHub</a>.
    Else
       Gui, Add, Link, y+10 wp, New and previous versions are available on <a href="https://github.com/marius-sucan/Quick-Picto-Viewer">GitHub</a>.

    Gui, Font, Normal
    If (uiUseDarkMode=1)
       Gui, Font, c%darkControlColor%

    Gui, Add, Text, y+10 wp h2 +0x1007, lol
    Gui, Add, Text, y+10 wp, Dedicated to people with really large image collections and slideshow needs.
    Gui, Add, Text, y+10 wp, This application contains code from various entities. You can find more details in the source code.
    Gui, Add, Text, y+10 wp, QPV uses GDI+ [Windows APIs] to display images and FreeImage%thisVersion% to load exotic file formats. FreeImage is an open source library licensed under the GNU GPL v2.0 or v3.0`, and the FreeImage Public License (FIPL). For image processing`, some functions also rely on the cImg library, an open-source library distributed under the CeCILL-C license, by David Tschumperlé. 

    Gui, Add, Link, y+10 wp, To keep the development going, <a href="https://www.paypal.me/MariusSucan/10">please donate</a> or <a href="mailto:marius.sucan@gmail.com?subject=%appTitle% v%appVersion%">send me feedback</a>.
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% gBtnOpenHelpWin, &Help
    Gui, Add, Button, x+5 hp wp gPanelJournalWindow, &Journal
    Gui, Add, Button, x+5 hp wp Default gBtnCloseWindow, &Close
    Gui, Add, Button, x+5 hp gcheckForUpdatesNow, &Check for updates
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "About " appTitle " v" appVersion A_Space verType)
    PopulateAboutKbdShortcutsList()
    checkDLLfiles()
    ; ToolTip, % "l=" A_ScriptFullPath , , , 2
}

BtnOpenHelpWin() {
   BtnCloseWindow()
   PanelHelpWindow()
}

PanelHelpWindow(dummy:=0) {
    Global LViewOthers, listViewFilteru

    thisBtnHeight := createSettingsGUI(61, A_ThisFunc)
    Gui, Add, Button, x1 y1 h1 w1 Default gBtnCloseWindow, Close
    lstWid := 490
    btnWid := 60
    txtWid := 440
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 210
       btnWid := btnWid + 30
       txtWid := txtWid + 190
       Gui, Font, s%LargeUIfontValue%
    }

    drawViewportHelpMap()
    tabu := (dummy="cmdu") ? 3 : 2
    rz := (PrefsLargeFonts=1) ? 15 : 17
    rx := rz - 5
    Gui, Add, Tab3, %tabzDarkModus% x15 y15 Choose%tabu%, Philosophy|Shortcuts|Command line|Change log|Features
    Gui, Tab, 1 ; general

    FileRead, cmdHelp, % mainExecPath "\resources\general-help.txt"
    GuiAddEdit("x+15 y+15 w" lstWid " r" rz " ReadOnly", cmdHelp, "General QPV overview")

    Gui, Tab, 2 ; keyboard 
    GuiAddListView("x+15 y+15 w" lstWid " r" rx " Grid +LV0x10000 vLViewOthers", "Keys|Action|Context|Opens", "Default keyboard shortcuts")
    Gui, Add, Text, xp y+10 wp h1 Hide, Shortcuts list string filter
    Gui, Add, Combobox, xp yp wp gUIgenericComboAction hwndhEditField vlistViewFilteru, \Files list|\Image view|\Image selection area|\Live editing|\Folder tree|\Painting mode|\Vector drawing|\Anywhere|\Panel|\Menu
    Gui, Add, Text, xp y+5 wp, The listed keyboard shortcuts are the defaults. This list does not reflect user customized shortcuts.

    cmdHelp := "QPV can be invoked with command line arguments. Examples:`n`n1. Open a folder:`nqpv.exe ""fd=C:\example folder\tempus""`n`nAdd a pipe ""|"" after equal ""="" to NOT have images loaded recursively."
    cmdHelp .= "`n`n2. Call an internal function:`nqpv.exe call_ToggleThumbsMode() ""fd=C:\folder\tempus""`n`nThis will index all the images in the given folder and switch to thumbnails mode.`n`nOnly functions that need no parameters can be invoked. If multiple call_ are used, only the last valid one will be considered."
    cmdHelp .= "`n`nTo learn what functions you can call, check the Journal window in QPV. It names functions when opening panels or when errors occur. You can also enable debug mode, to gather more intel, or study the source code."
    cmdHelp .= "`n`n3. Specify user settings:`n`nqpv.exe set_IMGresizingMode=3 set_vpIMGrotation=45 ""C:\folder\this-image.png""`n"
    cmdHelp .= "`nYou can find available user settings in the quick-picto-viewer.ini file or by right-clicking on controls in the panels.`n`nYou can pass up to 950 arguments`n`nPass /qpv-debug argument to have QPV send debug information to a Win32 Debug Viewer.`n`nIf one .SLD file or one folder is passed as argument, any other image file passed as argument is ignored."

    Gui, Tab, 3 
    GuiAddEdit("x+15 y+15 w" lstWid " r" rz " ReadOnly", cmdHelp, "Command line options for QPV")

    Gui, Tab, 4
    FileRead, cmdHelp, % mainExecPath "\resources\qpv-change-log.txt"
    ; cmdHelp := SubStr(cmdHelp, 1, 65200)
    GuiAddEdit("x+15 y+15 w" lstWid " r" rz " ReadOnly vtxtLine1", a, "QPV version history") ; cmdHelp
    GuiControl, SettingsGUIA:, txtLine1, % StrReplace(cmdHelp, "Â")

    Gui, Tab, 5
    FileRead, cmdHelp, % mainExecPath "\resources\features-list.txt"
    GuiAddEdit("x+15 y+15 w" lstWid " r" rz " ReadOnly", StrReplace(cmdHelp, "Â"), "QPV features list")

    Gui, Tab
    Gui, Add, Button, xs+15 y+8 h%thisBtnHeight% w%btnWid% gBtnAboutWin, &About
    Gui, Add, Button, x+5 hp wp gMenuOpenVideoDemos, &Videos
    Gui, Add, Button, x+5 hp wp gPanelJournalWindow, &Journal
    Gui, Add, Button, x+5 hp wp gPanelQuickSearchMenuOptions, &Search
    Gui, Add, Button, x+5 hp wp Default gBtnCloseWindow, &Close
    Gui, Add, Text, x+5 hp +0x200, QPV v%appVersion%

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Help " appTitle " v" appVersion)
    PopulateAboutKbdShortcutsList()
    checkDLLfiles()
}

BtnAboutWin() {
   BtnCloseWindow()
   PanelAboutWindow()
}

PopulateAboutKbdShortcutsList(useFilter:=0) {
    Static fileData := 0
    EM_SETCUEBANNER(hEditField, "Filter keyboard shortcuts list", 1)
    startOperation := A_TickCount
    setImageLoading()
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    GuiControlGet, listViewFilteru
    GuiControl, -Redraw, LViewOthers
    LV_Delete()
    startZeit := A_TickCount
 
    If !fileData
       FileRead, fileData, % mainExecPath "\resources\help-keyboard-shortcuts.txt"

    listFilter := (useFilter=1) ? listViewFilteru : ""
    If (SubStr(listFilter, 1, 1)="\" && StrLen(listFilter)>3) 
       listFilter := StrReplace(listFilter, "\", "|")

    startOperation := A_TickCount
    Loop, Parse, fileData, `n, `r
    {
        If (StrLen(A_LoopField)<5) || (listFilter && !InStr(A_LoopField, listFilter))
           Continue

        countThese++
        lineArru := StrSplit(A_LoopField, "|")
        LV_Add(A_Index, lineArru[1], lineArru[2], lineArru[3], lineArru[4])
    }

    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")
    GuiControl, +Redraw, LViewOthers
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

UIfilterListViewKbdsAbout() {
   GuiControlGet, listViewFilteru
   If (SubStr(listViewFilteru, 1, 1)="\" && StrLen(listViewFilteru)>3) 
      listViewFilteru := StrReplace(listViewFilteru, "\", "|")

   PopulateAboutKbdShortcutsList(listViewFilteru)
}

PanelsCheckFileExists() {
   If (currentFileIndex=0)
      Return 0

   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, fileNamu, OutDir)
   If !FileRexists(imgPath)
   {
      OutDir := PathCompact(OutDir, "a", 1, OSDfontSize)
      showTOOLtip("ERROR: File not found or access denied`n" fileNamu "`n" OutDir "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 0
   } Else Return 1
}

PanelResolutionSorting() {
   If AnyWindowOpen
   {
      addJournalEntry(A_ThisFunc "(): ERROR: cannot open panel. Another panel is opened: " AnyWindowOpen "=" prevOpenedWindow[2])
      Return
   }

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(20, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Choose resolution sort mode: " appTitle, "Each file will be read to identify the image resolution, in pixels.`n`nThis operation can take a lot of time with many files.", "&Sort list|&Histogram|&Cancel", 1, "image-file", "&Reverse order", 0, "Resolution (MPx)`f`fImage width`fImage height`fAspect ratio (W/H)`fImage DPI`fPages / frames", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "sort")
   {
      reverseOrderOnSort := msgResult.check
      IniAction(1, "reverseOrderOnSort", "General")
      ActSortImageProperties(msgResult.list)
   } Else If InStr(msgResult.btn, "histogram")
      PanelHistogramSorting()
}

PanelHistogramSorting() {
   Static hasAskedSort := 0
   If AnyWindowOpen
      Return

   If warnXPhistoSort()
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(45, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Choose image histogram sort mode: " appTitle, "Each image file will be read to extract its histogram data.`n`nThis operation can take a lot of time with many files.", "&Sort list|&Resolution|&Cancel", 1, "image-file", "&Reverse order", 0, "Average`f`fMedian`fPeak range`fMinimum range`f`Range`fMode`fMinimum`fRoot-mean square", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "sort")
   {
      good2go := 0
      If !hasAskedSort
      {
         msgResultu := msgBoxWrapper(appTitle ": Sort list", "Each file will be read to determine its histogram main points.`n`nAre you sure you want to sort the list in this mode? It can take a lot of time...", 4, 0, "question")
         If InStr(msgResultu, "yes")
            hasAskedSort := 1
      } Else good2go := 1
      If (good2go!=1 && hasAskedSort=0)
         Return

      reverseOrderOnSort := msgResult.check
      IniAction(1, "reverseOrderOnSort", "General")
      ActSortHistogram(msgResult.list)
   } Else If InStr(msgResult.btn, "resolution")
      PanelResolutionSorting()
}

testIsDupesList() {
   If (InStr(filesFilter, "SQL:query:JOIN") && resultedFilesList[currentFileIndex, 23] && SLDtypeLoaded=3)
      Return 1
   Else
      Return 0
}

PanelFindDupes(dummy:=0) {
    Global userFindDupesSelectAllDummy := 0, hasOpened, txtLine1, editFc, editFd, txtline2, editFr
    Static userWasWarned := 0

    userFindDupesSelectAllDummy := 0
    If !hasOpened
    {
       Global UIcheckimgfile := 0, UIcheckfcreated := 0, UIcheckfmodified := 0, UIcheckfsize := 0, UIcheckkbfsize := 0, UIcheckimgpixfmt := 0, UIcheckimgwidth := 0, UIcheckimgheight := 0, UIcheckimgmegapix := 0, UIcheckimgwhratio := 0, UIcheckimgframes := 0, UIcheckimghpeak := 0, UIcheckimghlow := 0
            , UIcheckimghrange := 0, UIcheckimgavg := 0, UIcheckimgmedian := 0, UIcheckimghrms := 0, UIcheckimghmode := 0, UIcheckimghminu := 0, editFE
       hasOpened := 1
    }

    If (maxFilesIndex<3 && !filesFilter)
    {
       showTOOLtip("WARNING: Insufficient indexed files to activate the list view mode")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (SLDtypeLoaded!=3)
    {
       msgResult := msgBoxWrapper(appTitle ": Confirmation", "The files list is currently not saved as an SQLite database. This format is required to store the collected image details and hashes needed for identifying similar or identical images.`n`nWould you like to save it in the specified format?", "&Yes|&Remove duplicate entries|&Cancel", 2, "question")
       If (msgResult="Yes")
          PanelSaveSlideShowu()
       Else If InStr(msgResult, "remove")
          cleanDeadFilesList("noFilesCheck")
       Return
    }

    IniAction(0, "fadeOtherDupeGroups", "General", 1)
    initFIMGmodule()
    initQPVmainDLL()
    If (dupesDCTcoeffsInit!=1 && userWasWarned=0)
    {
       userWasWarned := 1
       msgBoxWrapper(appTitle ": WARNING", appTitle " has failed to properly initialize the main DLL file: qpvmain.dll. Options within this panel and others will likely malfunction.", 0, 0, "error")
    }

    thisBtnHeight := createSettingsGUI(49, A_ThisFunc, 1)
    btnWid := 100
    txtWid := 350
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 175
       Gui, Font, s%LargeUIfontValue%
    }

    If StrLen(filesFilter)<3
       excludePreviousDupesFromList := 0

    If (A_PtrSize!=8)
       userFindDupesFilterHamDist := 1

    If (dummy>0 && isNumber(dummy) && isInRange(dummy, 1, 3))
       CurrentPanelTab := dummy

    col := (PrefsLargeFonts=1) ? 285 : 190
    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Image hashes|Collect data|Filtering
    Gui, Tab, 1 ; general
    GuiAddDropDownList("x+15 y+15 Section w" txtWid " gupdateUIdupesPanel AltSubmit Choose" userFindDupePresets " vuserFindDupePresets", "Image content fingerprint (dHash 8x8)|Image histogram data|Image resolution and file size|Image histogram, resolution and file size|Identical file names|Identical file names and file sizes|Custom mode", "Duplicates detection presets")
    Gui, Add, Checkbox, xs y+7 w%col% -wrap gUIfindDupesChecksu Checked%UIcheckimgfile% vUIcheckimgfile, File name and its extension
    Gui, Add, Checkbox, x+7 gBTNselectAllFindDupesProperties Checked%userFindDupesSelectAllDummy% vuserFindDupesSelectAllDummy, &Select all
    Gui, Add, Text, x+3 vbtnFldr, Precision:
    GuiAddEdit("x+2 w50 number -multi limit1 veditF5", findDupesPrecision)
    Gui, Add, UpDown, vfindDupesPrecision Range1-5, % findDupesPrecision
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckfcreated% vUIcheckfcreated, Date created
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckfmodified% vUIcheckfmodified, Date modified
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckfsize% vUIcheckfsize, Size (bytes)
    Gui, Add, Checkbox, X+7 gUIfindDupesChecksu Checked%UIcheckkbfsize% vUIcheckkbfsize, Size (kilobytes)
    Gui, Add, Checkbox, xs y+17 w%col% gUIfindDupesChecksu Checked%UIcheckimgpixfmt% vUIcheckimgpixfmt, Image pixel format
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgframes% vUIcheckimgframes, Frames / pages
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgwidth% vUIcheckimgwidth, Width
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgheight% vUIcheckimgheight, Height
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgmegapix% vUIcheckimgmegapix, Megapixels
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgwhratio% vUIcheckimgwhratio, Aspect ratio (W/H)
    Gui, Add, Checkbox, xs y+17 w%col% gUIfindDupesChecksu Checked%UIcheckimghpeak% vUIcheckimghpeak, Histogram max. range
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghlow% vUIcheckimghlow, Histogram min. range
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimghrange% vUIcheckimghrange, Histogram total range
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimgavg% vUIcheckimgavg, Histogram average
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimgmedian% vUIcheckimgmedian, Histogram median
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghrms% vUIcheckimghrms, Histogram root-mean square
    Gui, Add, Checkbox, xs y+7 w%col% gUIfindDupesChecksu Checked%UIcheckimghmode% vUIcheckimghmode, Histogram mode
    Gui, Add, Checkbox, x+7 gUIfindDupesChecksu Checked%UIcheckimghminu% vUIcheckimghminu, Histogram minimum

    fingWid := (PrefsLargeFonts=1) ? 170 : 100
    fingEdt := (PrefsLargeFonts=1) ? 70 : 50
    thumbu := (PrefsLargeFonts=1) ? 90 : 70
    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 w%txtWid% Section vbtnFldr6, Below you can choose what image hashing algorithm to use to compare images and configure what sections of the hashes to compare. The blue dots in the preview area highlight the areas of the images that will be compared. Higher threshold may yield more false-positives listed.
    GuiAddDropDownList("xs y+10 w" fingWid " AltSubmit Section gupdateUIdupesPanel Choose" userFindDupesFilterHamDist " vuserFindDupesFilterHamDist", "Ignore|dHash 8x8|pHash DCT 32x32|lHash 8x8", "Image hash type")
    GuiAddEdit("x+5 w" fingEdt " gupdateUIdupesPanel number -multi limit1 veditF11", hamDistLBorderCrop, "Image hash crop left.")
    Gui, Add, UpDown, vhamDistLBorderCrop gupdateUIdupesPanel Range0-9, % hamDistLBorderCrop
    GuiAddEdit("x+5 w" fingEdt " gupdateUIdupesPanel number -multi limit1 veditF6", hamDistLBorderCrop, "Image hash crop right.")
    Gui, Add, UpDown, vhamDistRBorderCrop gupdateUIdupesPanel Range0-9, % hamDistLBorderCrop
    Gui, Add, Text, x+20 yp w%thumbu% h%thumbu% -Border +0xE +hwndhCropCornersPic, Image hashing preview
    dp := (PrefsLargeFonts=1) ? 35 : 28

    Gui, Add, Text, xs ys+%dp% w%fingWid% vtxtLine1, Threshold:
    GuiAddEdit("x+5 w" fingEdt " gupdateUIdupesPanel number -multi limit2 veditF7", userFindDupesHamDistLvl, "Image hash difference threshold")
    Gui, Add, UpDown, vuserFindDupesHamDistLvl gupdateUIdupesPanel Range1-15, % userFindDupesHamDistLvl
    Gui, Add, Checkbox, xs y+15 Checked%findFlippedDupes% vfindFlippedDupes, Identify images horizontally flipped
    Gui, Add, Checkbox, xp y+15 Checked%findInvertedDupes% vfindInvertedDupes, Attempt to identify color inverted images
    Gui, Add, Checkbox, xs y+15 Checked%BreakDupesGroups%  vBreakDupesGroups, Break the groups based on hamming distance [similarity]
    Gui, Add, Checkbox, xp y+15 Checked%PerformMSDonDupes% gupdateUIdupesPanel vPerformMSDonDupes, Filter results using Mean-Squared Difference [32x32]
    GuiAddEdit("x+5 w" fingEdt " gupdateUIdupesPanel number -multi limit3 veditFr", userFindDupesMSElvl, "MSD hash threshold")
    Gui, Add, UpDown, vuserFindDupesMSElvl gupdateUIdupesPanel Range1-950, % userFindDupesMSElvl

    Gui, Tab, 3
    Gui, Add, Text, x+15 y+15 w%txtWid% Section, These options allow altering how image data is collected. For best results, these settings should be altered only once, before any data is collected. All processes can be interrupted and resumed at any time.
    
    Gui, Add, Text, xs y+15, For these to take effect, refresh image histogram and fingerprints data:
    Gui, Add, Checkbox, xs+15 y+15 Checked%hamDistInterpolation% vhamDistInterpolation gUIeditHammingInterpolation, High-quality resampling (slower)
    Gui, Add, Checkbox, xp y+15 Checked%dupesApplyBlur% vdupesApplyBlur, Blur images by 4x4 to weed out artefacts

    Gui, Add, Text, xs y+15, For these to take effect, refresh only the image hashes:
    Gui, Add, Checkbox, xs+15 y+15 Checked%userpHashMode% vuserpHashMode, pHashes based on averages, instead of the median values
    Gui, Add, Text, xp y+20 hp +0x200, Compress gray levels by a factor of
    GuiAddEdit("x+5 w" fingEdt " gupdateUIdupesPanel number -multi limit2 veditFc", graylevelCompressor)
    Gui, Add, UpDown, vgraylevelCompressor gupdateUIdupesPanel Range1-9, % graylevelCompressor
    Gui, Add, Button, xs y+15 h%thisBtnHeight% gBtnPurgeCachedSQLdata, Pur&ge cached data
    Gui, Add, Button, x+5 hp gBtnCollectDupesData, Collect image pi&xels data
    Gui, Add, Button, x+5 hp gPanelStateOFsqlNation, &Overview

    Gui, Tab, 4
    Gui, Add, Text, x+15 y+15 Section, Filter the results and data collection with a given string:
    GuiAddEdit("xp+15 y+7 wp-30 -multi limit12345 gUIeditsGenericAllowCtrlBksp vdupesStringFilter", dupesStringFilter, "String filter")
    GuiAddButton("x+1 hp w40 gUIstringEditFilterErase", "X", "Clear edit field")
    If (StrLen(UsrEditFilter)>0 && userFilterDoString=1 && StrLen(filesFilter)>1)
       GuiAddButton("x+1 hp wp gBtnUIsetDupesCilterCurrentFilter", "+", "Use the current files list filter")

    GuiAddDropDownList("xs+15 y+7 w" btnWid " gupdateUIFiltersPanel AltSubmit Choose" userFilterStringPos " vuserFilterStringPos", "Anywhere|Begins with|Ends with", "String filter matching mode")
    GuiAddDropDownList("x+2 w" btnWid " gupdateUIFiltersPanel AltSubmit Choose" userFilterWhat " vuserFilterWhat", "Full path|Folder path|File name", "Apply filter based on")
    Gui, Add, Checkbox, xs+15 y+7 Checked%userFilterStringIsNot% vuserFilterStringIsNot, &Must not contain the given string
    Gui, Add, Checkbox, xs y+20 Checked%excludePreviousDupesFromList% vexcludePreviousDupesFromList, E&xclude the current list of results
    Gui, Add, Text, xs+15 y+30, The data will be collected only for the matching image files.

    Gui, Tab
    Gui, Add, Button, xm+15 y+20 h%thisBtnHeight% w%btnWid% Default gBTNfindDupesNow, &Find duplicates
    If testIsDupesList()
       Gui, Add, Button, x+5 hp wp gBTNautoselectDupes, &Auto-select dupes
    ; Else
    ;    Gui, Add, Button, x+5 hp wp gBtnCollectDupesData, Collect files &data
    btnWid2 := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNhelpFindDupes, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Find image duplicates: " appTitle)
    SetTimer, updateUIdupesPanel, -300
}

BtnCollectDupesData() {
    If (AnyWindowOpen!=49)
       Return

   Gui, SettingsGUIA: Default
   GuiControlGet, findDupesPrecision
   GuiControlGet, dupesStringFilter
   GuiControlGet, userFilterStringIsNot
   GuiControlGet, userFilterStringPos
   GuiControlGet, userFilterWhat
   GuiControlGet, graylevelCompressor
   GuiControlGet, findInvertedDupes
   GuiControlGet, findFlippedDupes
   GuiControlGet, userpHashMode
   GuiControlGet, hamDistInterpolation
   GuiControlGet, dupesApplyBlur
   GuiControlGet, findDupesPrecision

   scu :=  (findFlippedDupes=1) ? "HpixelzFsmall" : "pixelzFsmall"
   BtnCloseWindow()
   collectSQLFileInfosNow(scu, 0, 0, 2, 0, dupesStringFilter, userFilterStringIsNot, userFilterStringPos, userFilterWhat)
   PopulateImagesIndexStatsInfos("kill")
   openPreviousPanel()
}

updateUIimageHashPreview() {
    Static uiboxSize := 122, dotu := 12
    If (AnyWindowOpen!=49)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, userFindDupePresets
    GuiControlGet, userFindDupesHamDistLvl
    GuiControlGet, userFindDupesFilterHamDist
    GuiControlGet, hamDistLBorderCrop
    GuiControlGet, hamDistRBorderCrop
    GuiControlGet, graylevelCompressor

    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, coreDesiredPixFmt)
    If !validBMP(cornersBMP)
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    trGdip_GetImageDimensions(cornersBMP, imgW, imgH)
    Gdip_FillRectangle(G, pBrushA, 0, 0, imgW, imgH)
    Gdip_FillRectangle(G, pBrushA, 0, 0, imgW, imgH)

    Loop, 8
    {
       If (userFindDupePresets!=7)
          Continue

       pY := A_Index - 1
       Loop, 8
       {
          pX := A_Index - 1
          allLoops++
          If (isInRange(allLoops, hamDistLBorderCrop + 1, 64 - hamDistRBorderCrop) && userFindDupesFilterHamDist>1)
             Gdip_FillRectangle(G, pBrushD, pX*(dotu + 3) + 2, pY*(dotu + 3) + 2, dotu, dotu)
       }
    }

    Gdip_DeleteGraphics(G)
    Gdip_SetPbitmapCtrl(hCropCornersPic, cornersBMP)
    trGdip_DisposeImage(cornersBMP, 1)
    er := r1 ? r1 : r0
    UIfindDupesChecksu()
    ; updateUIdupesPanel()
    Return er
}

BTNautoselectDupes() {
   BtnCloseWindow()
   PanelAutoSelectDupes()
}

UIfindDupesChecksu() {
   GuiControl, SettingsGUIA:, userFindDupesSelectAllDummy, 0
}

updateUIdupesPanel() {
   If (AnyWindowOpen!=49)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, userFindDupePresets
   actu := (userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   actu2 := (userFindDupePresets=5 || userFindDupePresets=6) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   GuiControl, SettingsGUIA:, userFindDupesSelectAllDummy, 0
   GuiControl, % actu, userFindDupesSelectAllDummy
   GuiControl, % actu, btnFldr6
   GuiControl, % actu2, findDupesPrecision
   GuiControl, % actu2, editF5
   GuiControl, % actu2, btnFldr
   UIfindDupesCheckboxes(actu)
}

BTNselectAllFindDupesProperties() {
   GuiControlGet, userFindDupesSelectAllDummy
   UIfindDupesCheckboxes("SettingsGUIA:", userFindDupesSelectAllDummy)
}

UIfindDupesCheckboxes(hactu, v:="") {
   If (AnyWindowOpen!=49)
      Return

   Gui, SettingsGUIA: Default
   GuiControl, % hactu, UIcheckimgfile, %v%
   GuiControl, % hactu, UIcheckfcreated, %v%
   GuiControl, % hactu, UIcheckfmodified, %v%
   GuiControl, % hactu, UIcheckfsize, %v%
   GuiControl, % hactu, UIcheckkbfsize, %v%
   GuiControl, % hactu, UIcheckimgpixfmt, %v%
   GuiControl, % hactu, UIcheckimgwidth, %v%
   GuiControl, % hactu, UIcheckimgheight, %v%
   GuiControl, % hactu, UIcheckimgmegapix, %v%
   GuiControl, % hactu, UIcheckimgwhratio, %v%
   GuiControl, % hactu, UIcheckimgframes, %v%
   GuiControl, % hactu, UIcheckimghpeak, %v%
   GuiControl, % hactu, UIcheckimghlow, %v%
   GuiControl, % hactu, UIcheckimghrange, %v%
   GuiControl, % hactu, UIcheckimgavg, %v%
   GuiControl, % hactu, UIcheckimgmedian, %v%
   GuiControl, % hactu, UIcheckimghrms, %v%
   GuiControl, % hactu, UIcheckimghmode, %v%
   GuiControl, % hactu, UIcheckimghminu, %v%
   GuiControl, % hactu, userFindDupesFilterHamDist, %v%

   GuiControlGet, userFindDupePresets
   GuiControlGet, PerformMSDonDupes
   GuiControlGet, userFindDupesFilterHamDist
   If InStr(hactu, "able")
      updateUIimageHashPreview()

   actu := (userFindDupesFilterHamDist>1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, userFindDupesHamDistLvl
   GuiControl, % actu, editF11
   GuiControl, % actu, editF6
   GuiControl, % actu, hamDistLBorderCrop
   GuiControl, % actu, hamDistRBorderCrop
   GuiControl, % actu, editF7
   GuiControl, % actu, txtLine1
   GuiControl, % actu, PerformMSDonDupes
   GuiControl, % actu, BreakDupesGroups
   actu := (userFindDupesFilterHamDist>1 && userFindDupesFilterHamDist!=2 && PerformMSDonDupes!=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, findInvertedDupes
   ; actu := (userFindDupesFilterHamDist>1 && PerformMSDonDupes!=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   ; GuiControl, % actu, findFlippedDupes
   actu := (userFindDupesFilterHamDist>1 && PerformMSDonDupes=1 && userFindDupePresets=7) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, editFr
   GuiControl, % actu, userFindDupesMSElvl
}

BTNfindDupesNow() {
   If (AnyWindowOpen!=49)
      Return

   columnus := ""
   Gui, SettingsGUIA: Default
   GuiControlGet, findDupesPrecision
   GuiControlGet, dupesStringFilter
   GuiControlGet, userFilterStringIsNot
   GuiControlGet, userFilterStringPos
   GuiControlGet, userFilterWhat
   GuiControlGet, excludePreviousDupesFromList
   GuiControlGet, userFindDupesHamDistLvl
   GuiControlGet, userFindDupesFilterHamDist
   GuiControlGet, hamDistLBorderCrop
   GuiControlGet, hamDistRBorderCrop
   GuiControlGet, graylevelCompressor
   GuiControlGet, findInvertedDupes
   GuiControlGet, findFlippedDupes
   GuiControlGet, userpHashMode
   GuiControlGet, PerformMSDonDupes
   GuiControlGet, userFindDupesMSElvl
   GuiControlGet, dupesApplyBlur
   GuiControlGet, BreakDupesGroups
   If (PerformMSDonDupes=1)
      findFlippedDupes := findInvertedDupes := 0

   If GuiCtrlGet("UIcheckimgfile")
      columnus .= "imgfile,"

   If GuiCtrlGet("UIcheckfcreated")
      columnus .= "fcreated,"

   If GuiCtrlGet("UIcheckfmodified")
      columnus .= "fmodified,"

   If GuiCtrlGet("UIcheckfsize")
   {
      columnus .= "fsize,"
   } Else 
   {
      If GuiCtrlGet("UIcheckkbfsize")
         columnus .= "kbfsize,"
   }

   If GuiCtrlGet("UIcheckimgpixfmt")
      columnus .= "imgpixfmt,"

   If GuiCtrlGet("UIcheckimgwidth")
      columnus .= "imgwidth,"

   If GuiCtrlGet("UIcheckimgheight")
      columnus .= "imgheight,"

   If GuiCtrlGet("UIcheckimgmegapix")
      columnus .= "imgmegapix,"

   If GuiCtrlGet("UIcheckimgwhratio")
      columnus .= "imgwhratio,"

   If GuiCtrlGet("UIcheckimgframes")
      columnus .= "imgframes,"

   If GuiCtrlGet("UIcheckimghpeak")
      columnus .= "imghpeak,"

   If GuiCtrlGet("UIcheckimghlow")
      columnus .= "imghlow,"

   If GuiCtrlGet("UIcheckimghrange")
      columnus .= "imghrange,"

   If GuiCtrlGet("UIcheckimgavg")
      columnus .= "imgavg,"

   If GuiCtrlGet("UIcheckimgmedian")
      columnus .= "imgmedian,"

   If GuiCtrlGet("UIcheckimghrms")
      columnus .= "imghrms,"

   If GuiCtrlGet("UIcheckimghmode")
      columnus .= "imghmode,"

   If GuiCtrlGet("UIcheckimghminu")
      columnus .= "imghminu,"

   GuiControlGet, userFindDupePresets
   If (userFindDupePresets=1)
   {
      userFindDupesFilterHamDist := 2
      hamDistLBorderCrop := hamDistRBorderCrop := 1
      columnus := "imgframes,imgwhratio"
   } Else If (userFindDupePresets=2)
      columnus := "imgavg,imghpeak,imgmedian,imghlow,imghrange,imghmode,imgframes,imgwhratio"
   Else If (userFindDupePresets=3)
      columnus := "fsize,imgmegapix,imgwhratio,imgframes"
   Else If (userFindDupePresets=4)
      columnus := "kbfsize,imgframes,imgmegapix,imgwhratio,imgavg,imghpeak,imgmedian,imghlow"
   Else If (userFindDupePresets=5)
      columnus := "imgfile,imgframes"
   Else If (userFindDupePresets=6)
      columnus := "fsize,imgfile,imgframes"

   ; Gui, SettingsGUIA: Submit, NoHide
   ; ToolTip, % userFindDupePresets "==" columnus , , , 2
   columnus := Trimmer(columnus, ",")
   If (StrLen(columnus)<3 && userFindDupesFilterHamDist>1)
   {
      findDupesPrecision := 1
      columnus := theseCols := "imgwhratio,imgframes"
   } Else If (userFindDupesFilterHamDist>1)
   {
      theseCols := StrReplace(columnus, "dHash")
      theseCols := StrReplace(theseCols, "pHash")
      theseCols := StrReplace(theseCols, "lHash")
      theseCols := StrReplace(theseCols, ",,", ",")
      theseCols := StrReplace(theseCols, ", ,", ",")
      If StrLen(theseCols)<3
         columnus := theseCols := "imgwhratio,imgframes"
   } Else theseCols := columnus

   If StrLen(theseCols)<3
   {
      showTOOLtip("WARNING: Insufficient properties selected by which to identify duplicates.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   BtnCloseWindow()
   MSEgroupiesScores := []
   toBeExcludedIndexes := []
   If (excludePreviousDupesFromList=1)
   {
      Loop, % maxFilesIndex
         toBeExcludedIndexes[resultedFilesList[A_Index, 12]] := 1
   }

   retrieveDupesByProperties(columnus, 0, userFindDupesFilterHamDist)
}

BTNhelpFindDupes() {
   friendly := 
   msgBoxWrapper(appTitle ": HELP", "This panel offers you the possibility to identify duplicate images based on the collected file and image properties, fingerprints and histogram data points.`n`nThe precision factor does not apply for file names, size in bytes, file dates and image width, height, frames and pixel format properties.`n`nThe functionality provided in this panel relies on collected data, please ensure you allow " appTitle " to scan the image files.`n`nFor optimal results activate aspect ratio, precision 2 and dHash threshold 3 in the fingerprints tab.`n`nA low threshold for the hashes means stricter matching. Increase it for looser matches. The same applies for MSD.`n`nBefore hashing, images are normalized to 8x8 and 32x32 sizes, grayscale. Optionally, a 4x4 blurring filter can be applied as well, but it may lead to an increase in false positives.", -1, 0, 0)
}

GuiCtrlGet(varu) {
   GuiControlGet, %varu%
   x := %varu%
   Return x
}

PanelPurgeCachedSQLdata() {
   If (AnyWindowOpen=49)
   {
      reOpenIT := 1
      BtnCloseWindow()
   }

   If (AnyWindowOpen || SLDtypeLoaded!=3)
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(46, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Purge cached data: " appTitle, "Please choose what kind of cached data to erase from the files list database.", "&Purge|C&ancel", 1, "trash", 0, 0, "File details`f`fImage properties`fImage histograms and hashes`fImage hashes`fAll`fAll (selected files only)`fAll (modified files only)", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "purge")
   {
      extraFilter := extractSQLqueryFromFilter()
      If extraFilter
         msgInfos := "`n`nThe purge will occur only for the files matching the current files list filter. To purge all the cached data, deactivate current filter."
 
      msgResultu := msgBoxWrapper(appTitle ": Purge cached data", "Please confirm you want to purge selected cached data from the database.`n`nThis data is used for sorting the files list much faster, identify image duplicates or to generate files list statistics." msgInfos, 4, 0, "question")
      If !InStr(msgResultu, "yes")
         Return

      If (msgResult.list=1)
         corePurgeCachedSQLdata("attributes")
      Else If (msgResult.list=2)
         corePurgeCachedSQLdata("resolution")
      Else If (msgResult.list=3)
         corePurgeCachedSQLdata("histogram")
      Else If (msgResult.list=4)
         corePurgeCachedSQLdata("hashes")
      Else If (msgResult.list=5)
         corePurgeCachedSQLdata("all")
      Else If (msgResult.list=6)
         PurgeCachedDataSelectedFiles()
      Else If (msgResult.list=7)
         PurgeCachedDataModifiedFiles()

      If (SLDtypeLoaded=3)
         PopulateIndexSQLFilesStatsInfos("kill")
      Else
         PopulateIndexFilesStatsInfos("kill")

      PopulateImagesIndexStatsInfos("kill")
   }

   If (reOpenIT=1)
      PanelWrapperFilesStats()
}

corePurgeCachedSQLdata(mode) {
   Static fAtribs := {1:"fsize", 2:"fmodified", 3:"fcreated"}
        , imgResu := {1:"imgdpi", 2:"imgwidth", 3:"imgheight", 4:"imgframes", 5:"imgpixfmt"}
        , hashTypes := {1:"pHash", 2:"dHash", 3:"lHash", 4:"HpHash", 5:"HdHash", 6:"HlHash"}
        , histoStuff := {1:"imgavg", 2:"imgmedian", 3:"imghpeak", 4:"imghlow", 5:"imghminu", 6:"imghmode", 7:"imghrms", 8:"imghrange", 9:"pixelzFsmall", 10:"pixelzFbig", 11:"HpixelzFsmall", 12:"HpixelzFbig"}
        , mantra := "UPDATE images SET "

   setImageLoading()
   extraFilter := extractSQLqueryFromFilter()
   wherePart := extraFilter ? A_Space extraFilter " AND " : " WHERE"
   friendly := extraFilter ? "`nCurrent files list filter:`n" extraFilter : ""
   showTOOLtip("Purging cached data from the database, please wait" friendly)
   thisu := ""
   If (mode="attributes" || mode="all")
   {
      Loop, 3
            thisu .= fAtribs[A_Index] "=NULL,"
      SQLstr .= mantra Trim(thisu, ",") wherePart " fsize IS NOT NULL; "
   }

   thisu := ""
   If (mode="resolution" || mode="all")
   {
      Loop, 5
            thisu .= imgResu[A_Index] "=NULL,"
      SQLstr .= mantra Trim(thisu, ",") wherePart " imgwidth IS NOT NULL; "
   }

   thisu := ""
   If (mode="hashes" || mode="all" || mode="histogram")
   {
      Loop, 6
            thisu .= hashTypes[A_Index] "=NULL,"
      SQLstr .= mantra Trim(thisu, ",") extraFilter "; "
   }

   thisu := ""
   If (mode="histogram" || mode="all")
   {
      Loop, 12
            thisu .= histoStuff[A_Index] "=NULL,"
      SQLstr .= mantra Trim(thisu, ",") wherePart " imgavg IS NOT NULL; "
   }

   addJournalEntry("Query used to purge data:`n" SQLstr)
   If !activeSQLdb.Exec(SQLStr)
   {
      showTOOLtip("Failed to purge the cached data from the database:`n" activeSQLdb.ErrorMsg)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep 300, 100
   } Else
   {
      If (mode="all" || mode="histogram" || mode="resolution")
         activeSQLdb.Exec("UPDATE images SET isDeleted=0 WHERE isDeleted=1;")
      SoundBeep 900, 100
   }

   SetTimer, RemoveTooltip, -350
   SetTimer, ResetImgLoadStatus, -250
}

PurgeCachedDataModifiedFiles() {
   SQLstr := "SELECT imgidu, imgfolder||'\'||imgfile, fsize, fmodified, fcreated FROM images WHERE ifnull(fsize, '')!='' ORDER BY fullPath;"
   If !activeSQLdb.GetTable(SQLstr, RecordSet)
   {
      throwSQLqueryDBerror(A_ThisFunc)
      Return -1
   }

   totalFiles := RecordSet.RowCount
   totalImages := getTotalIMGsSQLdb()
   If (totalFiles<1)
   {
      showTOOLtip("No modified files identified. The file details must be collected first.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   setImageLoading()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   doStartLongOpDance()
   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   prevSaveData := A_TickCount
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   remFiles := countFiles := failedFiles := countTFiles := 0
   Loop, % totalFiles
   {
      Rowu := RecordSet.Rows[A_Index]
      If Rowu[2]
      {
         obj := GetFileAttributesEx(Rowu[2])
         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countTFiles++
         If (!obj.size || obj.size<3)
         {
            deleteSQLdbEntry(Rowu[2], Rowu[1])
            remFiles++
         } Else If (obj.size!=Rowu[3] || SubStr(obj.wTime, 1, 12)!=Rowu[4] || SubStr(obj.cTime, 1, 12)!=Rowu[5])
         {
            r := selectivePurgeCachedSQLdata(Rowu[1])
            If r
               failedFiles++

            countFiles++
         }

         If (A_TickCount - prevSaveData>300100)
         {
            prevSaveData := A_TickCount
            If !activeSQLdb.Exec("COMMIT TRANSACTION;")
            {
               SoundBeep 300, 100
               ErrorMsgS := "ERROR: Failed to commit the changes to the SQL database`n" activeSQLdb.ErrorMsg "`n"
            } Else
               activeSQLdb.Exec("BEGIN TRANSACTION;")
         }

         If (A_TickCount - prevMSGdisplay>2000)
         {
            etaTime := ETAinfos(countTFiles, totalFiles, startOperation)
            If failedFiles
               etaTime .= "`nFailed to remove cached data for " groupDigits(failedFiles) " files"
            If countFiles
               etaTime .= "`nModified files identified: " groupDigits(countFiles)
            If remFiles
               etaTime .= "`nMissing files: " groupDigits(remFiles)

            etaTime .= "`nFiles data available for: " groupDigits(totalImages) " ( " Round(totalFiles/totalImages, 1) "% )"
            showTOOLtip(ErrorMsgS "Purging cached data for modified image files, please wait" etaTime, 0, 0, A_Index/totalFiles)
            prevMSGdisplay := A_TickCount
         }

         If (A_TickCount - prevSaveData>9000)
            ErrorMsgS := ""
      }
   }

   activeSQLdb.Exec("COMMIT TRANSACTION;")
   etaTime := "`nScanned files: " groupDigits(countTFiles)
   If countFiles
      etaTime .= "`nModified files identified: " groupDigits(countFiles)
   If remFiles
      etaTime .= "`nMissing files: " groupDigits(remFiles)
   If failedFiles
      etaTime .= "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

   If (abandonAll=1)
   {
      showTOOLtip("Operation abandoned: purge cached data for modified files. " etaTime)
      SoundBeep, 300, 100
   } Else
   {
      showTOOLtip("Finished purging cached data for modified image files" etaTime)
      SoundBeep, 900, 100
   }

   RecordSet.Free()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -150
}

PurgeCachedDataSelectedFiles() {
   getSelectedFiles(0, 1)
   If !markedSelectFile
   {
      showTOOLtip("WARNING: No files are currently selected to perform given operation")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   doStartLongOpDance()
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   If markedSelectFile
   {
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
            Continue

         executingCanceableOperation := A_TickCount
         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countTFiles++
         r := selectivePurgeCachedSQLdata(resultedFilesList[A_Index,12])
         If r
            failedFiles++
         Else
            countFiles++

         If (A_TickCount - prevMSGdisplay>1000)
         {
            etaTime := ETAinfos(countTFiles, markedSelectFile, startOperation)
            If failedFiles
               etaTime .= "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

            showTOOLtip("Purging cached data for selected image files, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
            prevMSGdisplay := A_TickCount
         }
      }
   }

   activeSQLdb.Exec("COMMIT TRANSACTION;")
   CurrentSLD := backCurrentSLD
   If failedFiles
      someErrors := "`nFailed to remove cached data for " groupDigits(failedFiles) " files"

   If (abandonAll=1)
   {
      showTOOLtip("Operation abandoned. Files processed: " groupDigits(countFiles) " out of " groupDigits(markedSelectFile) someErrors)
      SoundBeep, 300, 100
   } Else
   {
      showTOOLtip("Finished purging cached data for the selected files: " groupDigits(markedSelectFile) someErrors)
      SoundBeep, 900, 100
   }
  
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SetTimer, ResetImgLoadStatus, -150
}

markSQLdbEntryDeleted(dbIndex, batchMode:=0) {
   SQLstr := "UPDATE images SET isDeleted=1 WHERE imgidu=" dbIndex ";"
   If !activeSQLdb.Exec(SQLStr)
   {
      If (batchMode=0)
         addJournalEntry("ERROR: " A_ThisFunc "(" dbIndex "). Failed to query or commit changes to the SQL database`n" activeSQLdb.ErrorMsg)
      Return 0
   } Else Return 1
}

selectivePurgeCachedSQLdata(dbIndex, batchMode:=0) {
   SQLstr := "UPDATE images SET dHash=NULL, lHash=NULL, pHash=NULL, HdHash=NULL, HlHash=NULL, HpHash=NULL, pixelzFbig=NULL, pixelzFsmall=NULL, HpixelzFbig=NULL, HpixelzFsmall=NULL, imgavg=NULL, imgmedian=NULL, imghmode=NULL, imghrms=NULL, imghminu=NULL, imghrange=NULL, imghpeak=NULL, imghlow=NULL, imgwidth=NULL, imgheight=NULL, imgframes=NULL, imgpixfmt=NULL, imgdpi=NULL, fsize=NULL, fmodified=NULL, fcreated=NULL, isDeleted=0 WHERE imgidu=" dbIndex ";"
   If !activeSQLdb.Exec(SQLStr)
   {
      If (batchMode=1)
         Return "fail"
      Else
         addJournalEntry("Failed to purge the cached data in the database for given index: " dbIndex "`n" activeSQLdb.ErrorMsg)
   }
}

CheckGivenFileTypesSelected(toMatch) {
   countThese := 0
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      imgPath := resultedFilesList[A_Index, 1]
      If (RegExMatch(imgPath, "i)(.\.(" toMatch "))$") && imgPath)
         countThese++
      If (countThese>1)
         Break
   }

   Return countThese
}

PanelJpegPerformOperation() {
    Global mainBtnACT

    If !PanelsCheckFileExists()
       Return

    If askAboutFileSave()
       Return

    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       If !CheckGivenFileTypesSelected("jpg|jpeg")
       {
          showTOOLtip("WARNING: No JPEG files are selected.")
          SoundBeep 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    }

    initFIMGmodule()
    panelMode := (filesElected<2 && thumbsDisplaying!=1) ? 1 : 0
    If !(thisBtnHeight := createSettingsGUI(12, A_ThisFunc, 1, panelMode))
       Return

    terminateIMGediting()
    If (thumbsDisplaying!=1)
    {
       If (vpIMGrotation>0)
       {
          FlipImgV := FlipImgH := vpIMGrotation := 0
          showTOOLtip("Image rotation set to 0°")
          INIaction(1, "FlipImgH", "General")
          INIaction(1, "FlipImgV", "General")
          INIaction(1, "vpIMGrotation", "General")
          RefreshImageFile()
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Sleep, 250
       } Else If (FlipImgH=1 || FlipImgV=1)
       {
          FlipImgV := FlipImgH := 0
          dummyTimerDelayiedImageDisplay(50)
       } 
    }

    btnWid := 110
    txtWid := slideWid := 280
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 100
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    If (editingSelectionNow!=1 && jpegDesiredOperation=9)
       jpegDesiredOperation := 1
    Else
       EllipseSelectMode := 0

    Gui, Add, Text, x15 y15 Section, Please choose a JPEG lossless operation to perform:
    GuiAddDropDownList("wp y+10 Section AltSubmit Choose" jpegDesiredOperation " vjpegDesiredOperation", "None|Flip Horizontally|Flip Vertically|Transpose|Transverse|Rotate 90°|Rotate 180°|Rotate -90° [270°]|Crop image to selection", "Lossless JPEG action")
    ; Gui, Add, Checkbox, y+10 Checked%jpegDoCrop% gdummyRefreshImgSelectionWindow vjpegDoCrop, Crop image(s) to selected area (irreversible)
    If (filesElected>1)
    {
       RegAction(0, "convertFormatUseMultiThreads",, 1)
       Gui, Add, Text, y+20, % groupDigits(filesElected) " files are selected for processing."
       Gui, Add, Checkbox, y+15 Checked%convertFormatUseMultiThreads% vconvertFormatUseMultiThreads, &Use multiple threads (experimental)
    }

    If (filesElected<2)
    {
       If (thumbsDisplaying!=1)
       {
          Gui, Add, Button, xs y+10 h%thisBtnHeight% w%btnWid% gJpegBTNautoCropRealtime, &Auto-crop selection
          Gui, Add, Button, x+5 hp w%btnWid% gPanelImgAutoCrop, &Configure auto-crop
       }

       ml := (PrefsLargeFonts=1) ? 35 : 25
       GuiAddButton("xs y+20 h" thisBtnHeight " w" ml " gPreviousPicture", "<<", "Previous image")
       GuiAddButton("x+5 hp wp gNextPicture", ">>", "Next image")
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnPerformJpegOp vmainBtnACT, &Perform operation
    } Else 
    {
       Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gBtnPerformJpegOp, &Perform operation
       Gui, Add, Button, x+5 hp wp-20 gBtnPerformSoloJpegOp, &Active file only
    }
    sml := (PrefsLargeFonts=1) ? 80 : 60
    Gui, Add, Button, x+5 hp w%sml% gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "JPEG lossless operations: " appTitle)
    If (editingSelectionNow=1 && thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -150
}

JpegBTNautoCropRealtime() {
   Static hasRan := 0
   If !hasRan
      ReadSettingsAutoCropPanel()
   If (editingSelectionNow!=1)
      ToggleEditImgSelection()
   BTNautoCropRealtime()
   hasRan := 1
}

BtnPerformSoloJpegOp() {
   BtnPerformJpegOp("single")
}

BtnPerformJpegOp(modus:=0) {
    Static lastInvoked := 1
    If (modus!="extern")
    {
       Gui, SettingsGUIA: Default
       GuiControlGet, jpegDesiredOperation
       If (markedSelectFile && modus!="single")
       {
          GuiControlGet, convertFormatUseMultiThreads
          RegAction(1, "convertFormatUseMultiThreads",, 1)
       }
       GuiControlGet, mainBtnACT
    }

    If ((A_TickCount - lastInvoked < 150) || (jpegDesiredOperation=1))
    {
       showTOOLtip("WARNING: No JPEG operation selected to perform")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (jpegDesiredOperation=9 && editingSelectionNow!=1)
    {
       showTOOLtip("WARNING: No selection area is defined in the viewport.`nThe image cannot be cropped.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    initFIMGmodule()
    If !wasInitFIMlib
    {
       msgBoxWrapper(appTitle ": ERROR", "Unable to initialize the FreeImage library module.`n`nThis functionality is currently unavailable.", 0, 0, "error")
       Return
    }

    lastInvoked := A_TickCount
    ForceRefreshNowThumbsList()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1 && modus!="single")
    {
       batchJpegLLoperations()
       Return
    } Else If (currIMGdetails.HasAlpha!=1)
    {
       destroyGDIfileCache()
       r := coreJpegLossLessAction(imgPath, jpegDesiredOperation)
       ForceRefreshNowThumbsList()
    }

    If (modus!="extern")
    {
       GuiControl, SettingsGUIA: Disable, mainBtnACT
       SetTimer, reactivateMainBtnACT, -800
    }

    If r
    {
       resultedFilesList[currentFileIndex, 4] := 1
       FlipImgV := FlipImgH := vpIMGrotation := 0
       If (SLDtypeLoaded=3)
          selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

       showTOOLtip("JPEG operation completed succesfully")
       RefreshImageFile()
    } Else
    {
       SoundBeep, 300, 100
       If (modus!="extern")
          msgBoxWrapper(appTitle ": ERROR", "The JPEG operation has failed. The file might not be a JPEG as the file extension suggests.", 0, 0, "error")
       Else
          showTOOLtip("ERROR: The JPEG operation has failed. The file might not be a JPEG as the file extension suggests.")
    }

    lastInvoked := A_TickCount
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

reactivatemainBtnACT() {
    If isVarEqualTo(AnyWindowOpen, 12, 18, 17)
    {
       If (imageLoading=1)
          SetTimer, reactivatemainBtnACT, -600
       Else
          GuiControl, SettingsGUIA: Enable, mainBtnACT
    }
}

batchJpegLLoperations() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && jpegDesiredOperation=9) || (filesElected>150)
   {
      msgInfos := (jpegDesiredOperation=9) ? "`n`nThe crop operation IS irreversible!" : ""
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to perform the JPEG transformations on the selected files? There are currently " groupdigits(filesElected) " selected files. " msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
 
   BtnCloseWindow()
   Sleep, 25
   showTOOLtip("Performing JPEG lossless operations on " groupDigits(filesElected) " files, please wait")
   prevMSGdisplay := A_TickCount
   failedFiles := countFilez := countTFilez := 0
   filesPerCore := calculateCoresRequired(filesElected)
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (convertFormatUseMultiThreads=1 && systemCores>1 && filesPerCore>=2) ? 1 : 0
   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      addJournalEntry("Preparing " systemCores " threads to start. " filesPerCore " files per thread.")
      infoResult := WorkLoadMultiCoresJpegLL(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("JPEG operations error: failed to initialize multi-threaded processing")

   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   CurrentSLD := ""
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      If (InStr(file2rem, "||") || !file2rem)
         Continue
 
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFor " groupDigits(failedFiles) " files, the operations failed"
         If (skippedFiles>0)
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip("Performing JPEG lossless operations, please wait" etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      If !RegExMatch(file2rem, "i)(.\.(jpeg|jpg|jpe))$")
      {
         skippedFiles++
         Continue
      }

      r := coreJpegLossLessAction(file2rem, jpegDesiredOperation)
      If r
      {
         resultedFilesList[thisFileIndex, 4] := 1
         countFilez++
      } Else failedFiles++
   }

   CurrentSLD := backCurrentSLD
   If (failedFiles>0)
      someErrors := "`nFor " groupDigits(failedFiles) " files, the operations failed"
   If (skippedFiles>0)
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip(groupDigits(countFilez) " out of " groupDigits(countTFilez) " selected JPEG files were processed" someErrors)

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return
}

coreJpegLossLessAction(imgPath, jpegOperation) {
    FileGetTime, originalMtime, % imgPath, M
    FileGetTime, originalCtime, % imgPath, C
    FileSetAttrib, -R, %imgPath%
    Sleep, 1
    changeMcursor()
    If (jpegOperation=9 && (editingSelectionNow=1 || hasInitSpecialMode=1))
    {
       r1 := GetImgFileDimension(imgPath, imgW, imgH)
       If (imgW && imgH)
       {
          If (relativeImgSelCoords=1)
             calcRelativeSelCoords("--", imgW, imgH)

          calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
          x1 := Round(X1), y1 := Round(Y1)
          x2 := Round(X2), y2 := Round(Y2)
          changeMcursor()
          r := FreeImage_JPEGTransformCombined(imgPath, imgPath, 0, X1, Y1, X2, Y2)
      }
    } Else
    {
       Sleep, -1
       r := FreeImage_JPEGTransform(imgPath, imgPath, jpegOperation - 1)
    }

    If originalMtime
    {
       Sleep, 0
       FileSetTime, % originalMtime, % imgPath, M
       FileSetTime, % originalCtime, % imgPath, C
    }
    Return r
}

toggleImgEditPanelWindow(modus:="") {
   Static lastInvoked := A_TickCount
   If (AnyWindowOpen!=10 && imgEditPanelOpened!=1 && modus!="forced") || (A_TickCount - lastInvoked<350)
      Return

   WinGet, winStateu, MinMax, ahk_id %hSetWinGui%
   If (winStateu=-1)
   {
      WinRestore, ahk_id %hSetWinGui%
   } Else If (panelWinCollapsed=0)
   {
      WinGetPos, x, y,,, ahk_id %hSetWinGui%
      CreateCollapsedPanelWidget()
      Gui, SettingsGUIA: Hide
      Gui, collapseWidgetGUIA: Show, NoActivate x%x% y%y% AutoSize
      WinActivate, ahk_id %PVhwnd%
      disableWindowPenServices(hCollapseWidget)
      panelWinCollapsed := 1
   } Else 
   {
      endCaptureCloneBrush()
      Gui, SettingsGUIA: Show
      Gui, collapseWidgetGUIA: Hide
      WinActivate, ahk_id %hSetWinGui%
      panelWinCollapsed := 0
   }

   lastInvoked := A_TickCount
   interfaceThread.ahkassign("panelWinCollapsed", panelWinCollapsed)
}

selectGivenPanelTab(ot) {
   CurrentPanelTab := ot
   GuiControl, SettingsGUIA: Choose, CurrentPanelTab, % CurrentPanelTab
   TabsPerWindow[AnyWindowOpen] := ot
   UItriggerBrushUpdate("noPreview", 5)
}

PanelColorsAdjusterImage() {
   coreColorsAdjusterWindow("img")
}

PanelColorsAdjusterWindow() {
   coreColorsAdjusterWindow("vp")
}

BtnOpenPanelAdjustToneMapping() {
   BtnCloseWindow()
   Sleep, 5
   PanelAdjustToneMapping()
}

coreColorsAdjusterWindow(modus:=0) {
    Global realTimePreview, uiIMGresizingMode, UIvpImgAlignCenter

    openingPanelNow := 1
    idu := (modus="img") ? 74 : 10
    thisFuncu := (idu=10) ? A_ThisFunc : "PanelColorsAdjusterImage"
    If !(thisBtnHeight := createSettingsGUI(idu, thisFuncu, 1, 1))
       Return

    wasVPfxBefore := (imgFxMode>1) ? 1 : 0
    If (idu=74 && editingSelectionNow!=1)
       ToggleEditImgSelection()

    setImageLoading()
    showTOOLtip("Opening colors adjustments panel, please wait")
    RegAction(0, "imgColorsFXopacity",, 2, 3, 255)
    ForceNoColorMatrix := 0
    If !usrColorDepth
       usrColorDepth := 1

    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 180
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       slide2Wid := slide2Wid + 65
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    ml := (PrefsLargeFonts=1) ? 85 : 60
    zml := ml//2
    Global UIimgFxMode
    UIimgFxMode := (imgFxMode>3) ? imgFxMode - 1 : imgFxMode
    If (idu=74)
    {
       userImgChannelAlvl := 1
       DesaturateAreaLevels := usrColorDepth
       DesaturateAreaDither := ColorDepthDithering
       If (usrColorDepth>1)
          wasVPfxBefore := 1

       usrColorDepth := 1
       defineColorDepth()
       If (DesaturateAreaLevels>1 && UIimgFxMode=1)
          UIimgFxMode := 2
    }

    userImgChannelRlvl := Round(chnRdecalage*100)
    userImgChannelGlvl := Round(chnGdecalage*100)
    userImgChannelBlvl := Round(chnBdecalage*100)
    userImgChannelAlvl := Round(IntensityAlphaChannel)
    userImgVPthreshold := Round(imgThreshold*200)
    UIvpImgAlignCenter := (imageAligned=5) ? 1 : 0
    moru := (idu=10) ? "|Other options" : "|Alpha mask|Paint mask"
    slide3wid := slide2wid - 40
    thisW := (idu=10) ? txtWid : slide3wid
    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, Color matrix|More adjustments%moru%
    Gui, Tab, 1 ; general
    GuiAddDropDownList("x+15 y+15 Section w" thisW " gUpdateUIadjustVPcolors AltSubmit Choose" UIimgFxMode " vUIimgFxMode", "Original image colors|Personalized colors|Grayscale|Red channel|Green channel|Blue channel|Alpha channel|Inverted colors|Sepia", "Colors mode")
    If (idu!=10)
       Gui, Add, Button, x+5 hp wp gPanelAutoColors vbtn1, A&uto-adjust panel

    GuiAddSlider("userImgClrMtrxBrightness", -0.999,1.000, "0f", "Brightness", "UpdateUIadjustVPcolors", 2, "xs y+5 w" slideWid " hp")
    GuiAddSlider("userImgClrMtrxContrast", -0.999, 1.000, "0f", "Contrast", "UpdateUIadjustVPcolors", 2, "xs y+5 w" slideWid " hp")
    GuiAddSlider("userImgClrMtrxSaturation", -0.999,1.000, "0f", "Saturation", "UpdateUIadjustVPcolors", 2, "xs y+5 w" slideWid " hp")
    thisWS := (PrefsLargeFonts=1) ? slide3wid : slide3wid - 3
    GuiAddSlider("userImgVPgammaLevel", -0.999,1.000, "0f", "Gamma", "UpdateUIadjustVPcolors", 2, "xs y+5 w" thisWS " hp")
    GuiAddSlider("userImgVPthreshold", 0,200, "0f", "Threshold", "UpdateUIadjustVPcolors", 1, "x+5 wp hp")
    thisW := (PrefsLargeFonts=1) ? txtWid//3 - 3 : txtWid//3 - 4
    GuiAddSlider("userImgChannelRlvl", -300,300, 0, "Red", "UpdateUIadjustVPcolors", 2, "xs y+5 w" thisW " hp")
    GuiAddSlider("userImgChannelGlvl", -300,300, 0, "Green", "UpdateUIadjustVPcolors", 2, "x+5 wp hp")
    GuiAddSlider("userImgChannelBlvl", -300,300, 0, "Blue", "UpdateUIadjustVPcolors", 2, "x+5 wp hp")
    tml := zml + 15
    If (idu=10)
    {
       Gui, Add, Checkbox, xs y+10 w%thisWS% h%thisBtnHeight% gUpdateUIadjustVPcolors Checked%bwDithering% vbwDithering, Black/white
       If InStr(currIMGdetails.PixelFormat, "TONE-MAPP")
          Gui, Add, Button, x+5 wp hp gBtnOpenPanelAdjustToneMapping, &HDR tone-mapping
    } Else
    {
       GuiAddSlider("imgColorsFXopacity", 3,255, 255, "Effects opacity", "UpdateUIadjustVPcolors", 1, "xs y+10 w" slide3wid " hp")
       Gui, Add, Checkbox, x+5 wp+5 hp -wrap Checked%EraseAreaInvert% vEraseAreaInvert gUpdateUIadjustVPcolors, &Invert selection area
    }

    Gui, Tab, 2 ; more
    GuiAddDropDownList("x+15 y+15 Section w" slide3Wid " gUpdateUIadjustVPcolors AltSubmit Choose" specialColorFXmode " vspecialColorFXmode", "None|Brightness / Contrast|Hue / Saturation / Lightness|Levels adjust|Color tint|Colors balance|Color curve per channel", "Additional colors adjustments")
    If (idu=10)
       GuiAddSlider("userImgChannelAlvl", 1.0,30.0, "1.0f", "Alpha multiplier: $€x", "UpdateUIadjustVPcolors", 1, "x+5 wp hp")
    Else
       GuiAddSlider("userImgChannelAlphaAdd", 0,255, 0, "Alpha channel: +$€", "UpdateUIadjustVPcolors", 1, "x+5 wp hp")

    GuiAddDropDownList("xs y+2 wp gUpdateUIadjustVPcolors AltSubmit Choose" uiColorCurveFXmode " vuiColorCurveFXmode", "Brightness (density)|Contrast|Highlights|Shadows|Mid-tones|White saturation|Black saturation", "Color curve mode")
    GuiAddDropDownList("x+5 wp gUpdateUIadjustVPcolors AltSubmit Choose" uiColorCurveFXchannel " vuiColorCurveFXchannel", "Red|Green|Blue|All", "Color channel")

    sml := (PrefsLargeFonts=1) ? 1 : 5
    GuiAddSlider("hueAdjust", -300,300, 0, "Param A", "UpdateUIadjustVPcolors", 2, "xs y+10 w" slideWid " hp")
    GuiAddSlider("zatAdjust", -300,300, 0, "Param B", "UpdateUIadjustVPcolors", 2, "xs y+5 wp hp")
    GuiAddSlider("lummyAdjust", -300,300, 0, "Param C", "UpdateUIadjustVPcolors", 2, "xs y+5 wp hp")
    If (idu=10)
    {
       GuiAddDropDownList("xs y+10 w" slide3Wid " gUpdateUIadjustVPcolors AltSubmit Choose" usrColorDepth " vusrColorDepth", "Default color depth: 32 bits|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]", "Color depth to simulate")
       Gui, Add, Checkbox, x+10 hp gUpdateUIadjustVPcolors Checked%ColorDepthDithering% vColorDepthDithering, Dithering
    } Else
    {
       GuiAddDropDownList("xs y+10 w" slide3Wid " gUpdateUIadjustVPcolors AltSubmit Choose" DesaturateAreaLevels " vDesaturateAreaLevels", "Default color depth: 32 bits|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]", "Color depth to simulate")
       Gui, Add, Checkbox, x+10 hp gUpdateUIadjustVPcolors Checked%DesaturateAreaDither% vDesaturateAreaDither, Dithering
    }

    uiIMGresizingMode := (customZoomAdaptMode>0 && IMGresizingMode=4) ? 5 + customZoomAdaptMode : IMGresizingMode
    If (idu=10)
    {
       Gui, Tab, 3 ; others
       GuiAddDropDownList("x+15 y+15 Section w" txtWid " gUpdateUIadjustVPcolors AltSubmit Choose" uiIMGresizingMode " vuiIMGresizingMode", "Adapt all images to fit window|Adapt only large images into view|Original resolution (100%)|Custom zoom level|Stretched to window dimensions|Adapt to window width|Adapt to window height", "Image to window adapt mode")
       GuiAddSlider("vpIMGrotation", 0,359, 0, "Image rotation: $€°", "UpdateUIadjustVPcolors", 1, "xs y+10 w" slide2Wid " hp")
       Gui, Add, Checkbox, x+6 hp gUpdateUIadjustVPcolors Checked%UIvpImgAlignCenter% vUIvpImgAlignCenter, Align to center
       Gui, Add, Checkbox, xs y+10 +0x1000 hp gUpdateUIadjustVPcolors Checked%FlipImgV% vFlipImgV, Flip vertical
       Gui, Add, Checkbox, x+5 +0x1000 hp gUpdateUIadjustVPcolors Checked%FlipImgH% vFlipImgH, Flip horizontal
       Gui, Add, Text, xs y+10 hp +0x200, Display histogram:
       thisW := (PrefsLargeFonts=1) ? btnWid - 55 : btnWid - 35
       GuiAddDropDownList("x+10 w" thisW " gUpdateUIadjustVPcolors AltSubmit Choose" showHistogram " vshowHistogram", "None|Luminance|Red|Green|Blue|All mixed")
       GuiAddDropDownList("x+6 wp gUpdateUIadjustVPcolors AltSubmit Choose" histogramMode " vhistogramMode", "Lows|Balanced|Peaks", "Graph focus")
       Gui, Add, Checkbox, xs y+10 gUpdateUIadjustVPcolors Checked%userimgQuality% vuserimgQuality, High quality image resampling
       Gui, Add, Checkbox, xs y+10 gUpdateUIadjustVPcolors Checked%usrTextureBGR% vusrTextureBGR, Auto-generate viewport background texture
       Gui, Add, Checkbox, xs y+10 gToggleAutoResetImageView Checked%resetImageViewOnChange% vresetImageViewOnChange, Reset all adjustments on image file change
       ; Gui, Add, Checkbox, xs y+10 gUpdateUIadjustVPcolors Checked%showHistogram% vshowHistogram, Display the image luminance histogram
       Gui, Add, Text, xs y+10, TIP: right click on the viewport for more options.
    } Else
    {
       ; Gui, Add, Checkbox, xs y+5 w%slide3Wid% h%thisBtnHeight% Checked%EraseAreaUseAlpha% vEraseAreaUseAlpha gUpdateUIadjustVPcolors, Apply alpha mas&k
       If InStr(currIMGdetails.PixelFormat, "TONE-MAPP")
          Gui, Add, Button, xs y+5 w%slide3Wid% h%thisBtnHeight% gBtnOpenPanelAdjustToneMapping, &HDR tone-mapping
       uiADDalphaMaskTabs(3, 4, "UpdateUIadjustVPcolors")
    }

    Gui, Tab
    jk := (PrefsLargeFonts=1) ? 82 : 50
    ml := (PrefsLargeFonts=1) ? 35 : 25
    If (idu=10)
    {
       GuiAddButton("xs-10 y+15 h" thisBtnHeight " w" ml " gBtnPrevImg", "<<", "Previous image")
       GuiAddButton("x+5 hp wp gBtnNextImg", ">>", "Next image")
       GuiAddCollapseBtn("x+5 hp wp")
       GuiAddToggleLivePreview("x+5 yp hp wp gUpdateUIadjustVPcolors")
       Gui, Add, Button, x+5 hp w%jk% Default gBtnCloseWindow, &Close
    } Else
    {
       GuiAddCollapseBtn("xs-10 y+15 h" thisBtnHeight " w" ml)
       GuiAddCloseOnApply("x+5 yp hp wp")
       GuiAddToggleLivePreview("x+5 yp hp wp gUpdateUIadjustVPcolors")
       Gui, Add, Button, x+5 hp w%jk% Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
       Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
       dummyTimerDelayiedImageDisplay(150)
    }

    ; Gui, Add, Button, x+5 hp w%btnWid% gCopyImage2clip, &Copy to clipboard
    ; Gui, Add, Button, x+5 hp wp gBtnSaveIMGadjustPanel, &Save or copy
    Gui, Add, Button, x+5 hp wp+15 gBtnResetImageView vbtnReset, &Reset all
    titlu := (idu=10) ? "Adjust viewport image view: " : "Adjust image colors (legacy): "
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, titlu appTitle, winPos)
    Sleep, 1
    updatePanelColorSliderz()
    UpdateUIadjustVPcolors()
    SetTimer, resetOpeningPanel, -300
    SetTimer, RemoveTooltip, -100
    SetTimer, ResetImgLoadStatus, -50
} ; coreColorsAdjusterWindow()

WriteSettingsSimpleColorAdjustsPanel() {
   ReadSettingsSimpleColorAdjustsPanel(1)
}

ReadSettingsSimpleColorAdjustsPanel(act:=0) {
   RegAction(act, "imgColorsFXopacity",, 2, 2, 255)
   RegAction(act, "userimgGammaCorrect",, 1)
   RegAction(act, "userImgAdjustInvertArea",, 1)
   RegAction(act, "userImgAdjustAltBright",, 1)
   RegAction(act, "userImgAdjustAltContra",, 1)
   RegAction(act, "userImgAdjustAltHiLows",, 1)
   RegAction(act, "userImgAdjustAltSat",, 1)
   RegAction(act, "userImgAdjustAltTint",, 1)
   RegAction(act, "userImgAdjustBright",, 2, -65535, 65535)
   RegAction(act, "userImgAdjustContra",, 2, -65530, 65530)
   RegAction(act, "userImgAdjustGamma",, 2, 0, 900)
   RegAction(act, "userImgAdjustHighs",, 2, -65535, 65535)
   RegAction(act, "userImgAdjustHiPrecision",, 1)
   RegAction(act, "userImgAdjustNoClamp",, 1)
   RegAction(act, "userImgAdjustInvertColors",, 1)
   RegAction(act, "userImgAdjustLinkThresholds",, 1)
   RegAction(act, "userImgAdjustNoisePoints",, 1)
   RegAction(act, "userImgAdjustHue",, 2, -180, 180)
   RegAction(act, "userImgAdjustOffA",, 2, -65535, 65535)
   RegAction(act, "userImgAdjustOffB",, 2, -65535, 65535)
   RegAction(act, "userImgAdjustOffG",, 2, -65535, 65535)
   RegAction(act, "userImgAdjustOffR",, 2, -65535, 65535)
   RegAction(act, "userImgAdjustSat",, 2, -65535, 65535)
   RegAction(act, "userImgAdjustSeeThrough",, 2, 1, 3)
   RegAction(act, "userImgAdjustShadows",, 2, -65535, 65535)
   RegAction(act, "userImgAdjustThreA",, 2, -1, 65535)
   RegAction(act, "userImgAdjustThreB",, 2, -1, 65535)
   RegAction(act, "userImgAdjustThreG",, 2, -1, 65535)
   RegAction(act, "userImgAdjustThreR",, 2, -1, 65535)
   RegAction(act, "userImgAdjustWhitePoint",, 2, 0, 65535)
   RegAction(act, "userImgAdjustBlackPoint",, 2, 0, 65535)
   RegAction(act, "userImgAdjustTintAmount",, 2, 0, 65535)
   RegAction(act, "userImgAdjustTintDeg",, 2, -180, 180)
   RegAction(act, "alphaMaskClrAintensity",, 2, 0, 255)
   RegAction(act, "alphaMaskClrBintensity",, 2, 0, 255)
}

PanelAdjustColorsSimpleWindow() {
    If (thumbsDisplaying=1)
    {
       Tooltip, Please wait...
       lastOtherWinClose := 1
       ToggleThumbsMode()
       SetTimer, PanelAdjustColorsSimpleWindow, -150
       Tooltip
       Return
    }

    openingPanelNow := 1
    If !(thisBtnHeight := createSettingsGUI(89, A_ThisFunc, 1, 1))
       Return

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    setImageLoading()
    ReadSettingsSimpleColorAdjustsPanel()
    ReadSettingsBrushPanel()
    ReadSettingsAlphaMaskPanel()

    filesElected := getSelectedFiles(0, 1)
    btnWid := 100
    txtWid := slideWid := 290
    slide2Wid := 180
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       slide2Wid := slide2Wid + 65
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    ml := (PrefsLargeFonts=1) ? 85 : 60
    zml := ml//2
    Global UIimgFxMode
    slide3wid := slide2wid - 35
    thisW := slide3wid
    sml := (PrefsLargeFonts=1) ? 30 : 20
    bonusTabs := (!viewportQPVimage.imgHandle) ? "|Alpha mask|Paint mask" : ""
    If (filesElected>1)
    {
       alphaMaskingMode := 1
       bonusTabs := "|Batch options"
       RegAction(0, "ResizeDestFolder",, 6)
       RegAction(0, "ResizeUseDestDir",, 1)
       RegAction(0, "userImgAdjustConvertDepth",, 1)
    }

    Gui, Add, Tab3, %tabzDarkModus% gBtnTabsInfoUpdate hwndhCurrTab AltSubmit vCurrentPanelTab Choose%thisPanelTab%, General|Colors|Threshold%bonusTabs%
    Gui, Tab, 1 ; general
    If InStr(currIMGdetails.PixelFormat, "TONE-MAPP")
       Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% w%thisW% gBtnOpenPanelAdjustToneMapping, &HDR tone-mapping
    Else
       Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% w%thisW% gPanelAutoColors, A&uto-adjust panel

    If (viewportQPVimage.imgHandle)
    {
       alphaMaskingMode := 1
       bpp := FreeImage_GetBPP(viewportQPVimage.imgHandle)
    } Else
       bpp := (currIMGdetails.HasAlpha) ? 32 : 24

    If (bpp!=32)
       userImgAdjustOffA := userImgAdjustAltContra := 0

    Gui, Add, Checkbox, x+5 hp gUpdateUIsimpleAdjustColors Checked%userimgGammaCorrect% vuserimgGammaCorrect, &Apply gamma correction
    thisWS := (PrefsLargeFonts=1) ? slide3wid : slide3wid - 3
    GuiAddSlider("userImgAdjustBright", -65535, 65535, 0, "Brightness", "UpdateUIsimpleAdjustColors", 2, "xs y+5 w" slideWid " hp")
    GuiAddCheckbox("x+1 hp+1 w" sml " gUpdateUIsimpleAdjustColors Checked" userImgAdjustAltBright " vuserImgAdjustAltBright", "Alternate brightness adjustment mode", "A")
    GuiAddSlider("userImgAdjustShadows", -65535, 65535, 0, "Shadows", "UpdateUIsimpleAdjustColors", 2, "xs y+5 w" thisWS " hp")
    GuiAddSlider("userImgAdjustHighs", -65535, 65535, 0, "Highlights", "UpdateUIsimpleAdjustColors", 2, "x+5 wp hp")
    GuiAddCheckbox("x+1 hp+1 w" sml " gUpdateUIsimpleAdjustColors Checked" userImgAdjustAltHiLows " vuserImgAdjustAltHiLows", "Use wider histogram bands for shadows and highlights", "W")
    GuiAddSlider("userImgAdjustContra", -65530, 65530, 0, "Contrast", "UpdateUIsimpleAdjustColors", 2, "xs y+5 w" slideWid " hp")
    GuiAddCheckbox("x+1 hp+1 w" sml " gUpdateUIsimpleAdjustColors Checked" userImgAdjustAltContra " vuserImgAdjustAltContra", "Apply contrast only on the alpha channel", "A", "SettingsGUIA", "Apply contrast only on the alpha channel.`nIf no alpha channel is present or if the image is entirely opaque,`nthe slider will not affect the image.")
    GuiAddSlider("userImgAdjustGamma", 0,900, 300, ".updateLabelColorGammaLevel", "UpdateUIsimpleAdjustColors", 3, "xs y+5 w" slideWid " hp")
    GuiAddSlider("userImgAdjustBlackPoint", 0, 45535, 0, "Black point", "UpdateUIsimpleAdjustColors", 1, "xs y+5 w" thisWS " hp")
    GuiAddSlider("userImgAdjustWhitePoint", 20100, 65535, 65535, "White point", "UpdateUIsimpleAdjustColors", 1, "x+5 wp hp")
    GuiAddCheckbox("x+1 hp+1 w" sml " gUpdateUIsimpleAdjustColors Checked" userImgAdjustNoisePoints " vuserImgAdjustNoisePoints", "Generate noise", "N")
    GuiAddSlider("imgColorsFXopacity", 3,255, 255, "Effects opacity", "UpdateUIsimpleAdjustColors", 1, "xs y+10 w" slide3wid " hp")
    Gui, Add, Checkbox, x+5 hp -wrap gUpdateUIsimpleAdjustColors Checked%userImgAdjustInvertArea% vuserImgAdjustInvertArea, &Invert selection area
    Gui, Add, Checkbox, xs y+5 hp w%slide3Wid% -wrap gUpdateUIsimpleAdjustColors Checked%userImgAdjustHiPrecision% vuserImgAdjustHiPrecision +hwndhTemp, &Higher precision
    ToolTip2ctrl(hTemp, "The color filters will be calculated based on values ranging from`n0 to 65535, instead of 0 to 255, for greater precision.")
    Gui, Add, Checkbox, x+5 hp -wrap gUpdateUIsimpleAdjustColors Checked%userImgAdjustNoClamp% vuserImgAdjustNoClamp +hwndhTemp, &Avoid clamping (slower)
    ToolTip2ctrl(hTemp, "When possible, the pixel values will not be clamped internally when calculating the different`ncolor filters. The final output will still be an RGB image with values between 0 to 255.`nThis mode is much more computationally intense.")

    Gui, Tab, 2 ; colors
    Gui, Add, Text, x+15 y+15 Section h%thisBtnHeight%, Transform the colors of the image.
    GuiAddSlider("userImgAdjustHue", -180,180, 0, "Hue: $€°", "UpdateUIsimpleAdjustColors", 2, "xs y+5 w" slideWid " hp")
    GuiAddSlider("userImgAdjustSat", -65535, 65535, 0, "Saturation", "UpdateUIsimpleAdjustColors", 2, "xs y+5 w" slideWid " hp")
    GuiAddCheckbox("x+1 hp+1 w" sml " gUpdateUIsimpleAdjustColors Checked" userImgAdjustAltSat " vuserImgAdjustAltSat", "Alternate saturation adjustment mode", "A")
    GuiAddSlider("userImgAdjustTintAmount", 0, 65535, 0, "Tint amount", "UpdateUIsimpleAdjustColors", 1, "xs y+5 w" thisWS " hp")
    GuiAddSlider("userImgAdjustTintDeg", -180,180, 0, "Tint angle: $€°", "UpdateUIsimpleAdjustColors", 2, "x+5 wp hp")
    GuiAddCheckbox("x+1 hp+1 w" sml " gUpdateUIsimpleAdjustColors Checked" userImgAdjustAltTint " vuserImgAdjustAltTint", "Preserve light on tinting", "L")
    thisW := (PrefsLargeFonts=1) ? txtWid//3 - 3 : txtWid//3 - 3
    GuiAddSlider("userImgAdjustOffR", -65535,65535, 0, "R offset", "UpdateUIsimpleAdjustColors", 2, "xs y+5 w" thisWS " hp")
    GuiAddSlider("userImgAdjustOffG", -65535,65535, 0, "G offset", "UpdateUIsimpleAdjustColors", 2, "x+5 wp hp")
    GuiAddSlider("userImgAdjustOffB", -65535,65535, 0, "B offset", "UpdateUIsimpleAdjustColors", 2, "xs y+5 wp hp")
    GuiAddSlider("userImgAdjustOffA", -65535,65535, 0, "A offset", "UpdateUIsimpleAdjustColors", 2, "x+5 wp hp")
    Gui, Add, Checkbox, xs y+5 wp+5 hp -wrap gUpdateUIsimpleAdjustColors Checked%userImgAdjustInvertColors% vuserImgAdjustInvertColors, &Invert colors
    Gui, Tab, 3 ; threshold
    Gui, Add, Text, x+15 y+15 Section w%slideWid%, Transform any image channel into two-tones based on the defined intensity thresholds.
    GuiAddSlider("userImgAdjustThreR", -1,65535, -1, "Red", "UpdateUIsimpleAdjustColors", 1, "xs y+10 w" slideWid " h" thisBtnHeight)
    GuiAddSlider("userImgAdjustThreG", -1,65535, -1, "Green", "UpdateUIsimpleAdjustColors", 1, "xs y+5 wp hp")
    GuiAddSlider("userImgAdjustThreB", -1,65535, -1, "Blue", "UpdateUIsimpleAdjustColors", 1, "xs y+5 wp hp")
    GuiAddSlider("userImgAdjustThreA", -1,65535, -1, "Alpha", "UpdateUIsimpleAdjustColors", 1, "xs y+5 wp hp")
    Gui, Add, Checkbox, xs y+5 wp+5 hp -wrap gUpdateUIsimpleAdjustColors Checked%userImgAdjustLinkThresholds% vuserImgAdjustLinkThresholds, &Link RGB threshold levels
    Gui, Add, Text, xs y+5 w%thisWS% hp +0x200 +hwndhTemp, See through:
    GuiAddDropDownList("x+2 wp gUpdateUIsimpleAdjustColors AltSubmit Choose" userImgAdjustSeeThrough " vuserImgAdjustSeeThrough", "None|Brightness|Darkness", [hTemp])
    If (!viewportQPVimage.imgHandle && !filesElected)
    {
       uiADDalphaMaskTabs(4, 5, "UpdateUIsimpleAdjustColors")
    } Else If (filesElected>1)
    {
       Gui, Tab, 4 ; threshold
       msgFriendly := groupDigits(filesElected) " files are selected for processing. The entirety of the canvas of the selected images will be processed, without an alpha mask."
       Gui, Font, Bold
       Gui, Add, Text, x+15 y+15 w%slideWid%, % msgFriendly
       Gui, Font, Normal
       Gui, Add, Text, xs y+10 w%txtWid%, Files in unsupported write formats will be skipped.

       Gui, Add, Checkbox, xs y+10 Checked%userImgAdjustConvertDepth% vuserImgAdjustConvertDepth +hwndhTemp, &Convert unsupported color depths to 24- or 32-bits
       ToolTip2ctrl(hTemp, "This tool works only with 24 or 32 bits image color formats.")
       Gui, Add, Checkbox, xs y+10 Checked%SimpleOperationsFlipV% vSimpleOperationsFlipV, Flip vertical
       Gui, Add, Checkbox, x+10 hp Checked%SimpleOperationsFlipH% vSimpleOperationsFlipH, Horizontal

       Gui, Add, Checkbox, xs y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the specified destination folder:
       GuiAddEdit("xp+15 y+5 wp-10 r1 +0x0800 -wrap vResizeDestFolder", ResizeDestFolder, "Destination folder")
       ml := (PrefsLargeFonts=1) ? 90 : 50
       Gui, Add, Button, x+5 hp w%ml% gBTNchangeResizeDestFolder vbtnFldr, C&hoose
       ml := (PrefsLargeFonts=1) ? 152 : 93
       Gui, Add, Text, xs y+10 hp +0x200 +hwndhTemp, Action on file name conflicts:
       GuiAddDropDownList("x+5 w" ml " gTglOverwriteFiles AltSubmit Choose" userActionConflictingFile " vuserActionConflictingFile", "Skip files|Auto-rename|Overwrite|Ask", [hTemp])
       thisWid := (PrefsLargeFonts=1) ? 235 : 150
       GuiAddSlider("userJpegQuality", 2,100, 95, "Image quality on save", "iniSaveJPGquality", 1, "xs y+5 w" thisWid " hp", "This only applies to the JPEG and WEBP file formats")
       If !ResizeUseDestDir
       {
          GuiControl, Disable, btnFldr
          GuiControl, Disable, ResizeDestFolder
       }
    }

    Gui, Tab
    jk := (PrefsLargeFonts=1) ? 82 : 50
    mjk := (PrefsLargeFonts=1) ? 135 : 90
    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddCollapseBtn("xs-10 y+15 h" thisBtnHeight " w" ml)
    GuiAddCloseOnApply("x+5 yp hp wp")
    GuiAddToggleLivePreview("x+5 yp hp wp gUpdateUIsimpleAdjustColors")
    If (filesElected>1)
       Gui, Add, Button, x+5 hp w%mjk% Default gBtnBatchSimpleColorAdjuster vbtnLiveApplyTool, &Process files
    Else
       Gui, Add, Button, x+5 hp w%jk% Default gapplyIMGeditFunction vbtnLiveApplyTool, &Apply
    Gui, Add, Button, x+5 hp w%jk% gBtnCloseWindow, &Cancel
    Gui, Add, Button, x+5 hp wp+15 gBtnResetAllSimpleAdjustColors vbtnReset, &Reset
    If (!viewportQPVimage.imgHandle && !filesElected)
       Gui, Add, Button, x+5 hp wp gPanelColorsAdjusterImage, &Legacy

    dummyTimerDelayiedImageDisplay(150)
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Adjust image colors: " appTitle, winPos)
    SetTimer, resetOpeningPanel, -100
    GuiRefreshSliders()
    SetTimer, RemoveTooltip, -100
    SetTimer, ResetImgLoadStatus, -50
    SetTimer, UpdateUIsimpleAdjustColors, -100
}

ToolTip2ctrl(hwnd, msg) {
    Return AddTooltip2Ctrl(hwnd, msg,, uiUseDarkMode, PrefsLargeFonts)
}

BtnBatchSimpleColorAdjuster() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    initFIMGmodule()
    If !wasInitFIMlib
    {
       msgBoxWrapper(appTitle ": ERROR", "Unable to initialize the FreeImage library module.`n`nThis functionality is currently unavailable.", 0, 0, "error")
       Return
    }

   threB := (userImgAdjustLinkThresholds=1) ? userImgAdjustThreR : userImgAdjustThreB
   threG := (userImgAdjustLinkThresholds=1) ? userImgAdjustThreR : userImgAdjustThreG
   thisIDu := "a" userImgAdjustInvertColors userImgAdjustSat  userImgAdjustBright userImgAdjustContra userImgAdjustShadows userImgAdjustHighs userImgAdjustHue userImgAdjustTintAmount userImgAdjustGamma userImgAdjustOffR userImgAdjustOffG userImgAdjustOffB userImgAdjustOffA userImgAdjustThreR ThreG ThreB userImgAdjustThreA userImgAdjustWhitePoint userImgAdjustBlackPoint
   If (thisIDu="a000000003000000-1-1-1-1655350")
   {
      showTOOLtip("WARNING: No color filters to apply.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   filesElected := getSelectedFiles(0, 1)
   If (filesElected<3)
   {
      showTOOLtip("WARNING: Insufficient files selected to batch process.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   RegAction(1, "ResizeDestFolder",, 6)
   RegAction(1, "ResizeUseDestDir",, 1)
   RegAction(1, "userImgAdjustConvertDepth",, 1)
   WriteSettingsSimpleColorAdjustsPanel()
   BtnCloseWindow()
   batchSimpleColorsAdjusts()
}

BtnToggleNoColorsFX() {
   ; Gui, SettingsGUIA: Default
   ; SoundBeep 
   ForceNoColorMatrix := !ForceNoColorMatrix
   doImgEditLivePreview := !ForceNoColorMatrix
   GuiControl, SettingsGUIA:, doImgEditLivePreview, % doImgEditLivePreview
   dummyTimerDelayiedImageDisplay(50)
}

resetOpeningPanel() {
    openingPanelNow := 0
}

BtnSaveIMGadjustPanel() {
   ForceNoColorMatrix := 0
   CloseWindow()
   dummyTimerDelayiedImageDisplay(50)
   PanelSaveImg()
}

BtnNextImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  NextPicture()
}

BtnPrevImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  PreviousPicture()
}

updatePanelColorSliderz(modus:=0) {
   If (AnyWindowOpen!=10 && AnyWindowOpen!=74)
      Return

   ; GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   If isInRange(imgFxMode, 1, 3)
   {
      userImgClrMtrxBrightness := (lumosAdjust>1) ? lumosAdjust**(1/3.9) - 1 :  lumosAdjust - 1
      userImgClrMtrxContrast := (GammosAdjust<0) ? abs(GammosAdjust - 1)**(1/3.8) - 1 :  -1*GammosAdjust
   } Else If (imgFxMode=4)
   {
      userImgClrMtrxBrightness := (lumosGrayAdjust>1) ? lumosGrayAdjust**(1/3.9) - 1 :  lumosGrayAdjust - 1
      userImgClrMtrxContrast := (GammosGrayAdjust<0) ? abs(GammosGrayAdjust - 1)**(1/3.8) - 1 :  -1*GammosGrayAdjust
   }

   userImgClrMtrxSaturation :=  (satAdjust>1) ? satAdjust**(1/2.32) - 1 :  satAdjust - 1
   userImgVPgammaLevel := (realGammos>1) ? realGammos**(1/3.32) - 1 :  realGammos - 1
   If (modus!="insider")
   {
      Gui, SettingsGUIA: Default
      uiSlidersArray["userImgClrMtrxBrightness", 14] := -1
      uiSlidersArray["userImgClrMtrxContrast", 14] := -1
      uiSlidersArray["userImgClrMtrxSaturation", 14] := -1
      uiSlidersArray["userImgVPgammaLevel", 14] := -1
      If (AnyWindowOpen=10)
         GuiControl, SettingsGUIA:, UIvpImgAlignCenter, % (imageAligned=5) ? 1 : 0
      GuiRefreshSliders()
   }
}

updatePanelColorsInfo() {
   Static colorzFXinfoz := 0, colorzFXminz := 0, colorzFXmaxz := 0, lastInvoked := 1
   If (AnyWindowOpen!=10 && AnyWindowOpen!=74)
      Return

   If (A_TickCount - lastInvoked < 100)
   {
      SetTimer, updatePanelColorsInfo, -110
      Return
   }

   Gui, SettingsGUIA: Default
   If !IsObject(colorzFXinfoz)
   {
      colorzFXinfoz := []
      colorzFXinfoz[1] := ["Param A", "Param B", "Param C"]
      colorzFXinfoz[2] := ["Brightness", "Contrast", "Param C"]
      colorzFXinfoz[3] := ["Hue", "Saturation", "Lightness"]
      colorzFXinfoz[4] := ["|Highlights", "Midtones", "|Shadows"]
      colorzFXinfoz[5] := ["Hue", "|Amount", "Param C"]
      colorzFXinfoz[6] := ["Cyan / Red", "Magenta / Green", "Yellow / Blue"]
      colorzFXinfoz[7] := ["Param A", "Param B", "Amount"]
      colorzFXminz := []
      colorzFXminz[1] := [-300, -300, -300]
      colorzFXminz[2] := [-255, -100, -300]
      colorzFXminz[3] := [-180, -100, -100]
      colorzFXminz[4] := [0, -100, 0]
      colorzFXminz[5] := [-180, 0, -300]
      colorzFXminz[6] := [-100, -100, -100]
      colorzFXminz[7] := [-300, -300, -100]
      colorzFXmaxz := []
      colorzFXmaxz[1] := [300, 300, 300]
      colorzFXmaxz[2] := [255, 100, 300]
      colorzFXmaxz[3] := [180, 100, 100]
      colorzFXmaxz[4] := [100, 100, 100]
      colorzFXmaxz[5] := [180, 100, 300]
      colorzFXmaxz[6] := [100, 100, 100]
      colorzFXmaxz[7] := [300, 300, 100]
   }

   GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   GuiControlGet, UIimgFxMode, SettingsGUIA:, UIimgFxMode
   GuiControlGet, bwDithering, SettingsGUIA:, bwDithering
   imgFxMode := (UIimgFxMode>2) ? UIimgFxMode + 1 : UIimgFxMode
   If (AnyWindowOpen=10)
      GuiControlGet, uiIMGresizingMode, SettingsGUIA:, uiIMGresizingMode

   thisMinA := colorzFXminz[specialColorFXmode, 1],   thisMaxA := colorzFXmaxz[specialColorFXmode, 1]
   thisMinB := colorzFXminz[specialColorFXmode, 2],   thisMaxB := colorzFXmaxz[specialColorFXmode, 2]
   thisMinC := colorzFXminz[specialColorFXmode, 3],   thisMaxC := colorzFXmaxz[specialColorFXmode, 3]
   If (specialColorFXmode=7 && uiColorCurveFXmode=1)
   {
      thisMaxC := 255
      thisMinC := -255
   } Else If (specialColorFXmode=7 && uiColorCurveFXmode>=6)
   {
      thisMaxC := 255
      thisMinC := 1
   }

   defA := (specialColorFXmode=4) ? 100 : 0
   defC := (uiColorCurveFXmode=6 && specialColorFXmode=7) ? 255 : 0
   labulA := colorzFXinfoz[specialColorFXmode, 1], fillA := InStr(labulA, "|") ? 1 : 2
   labulB := colorzFXinfoz[specialColorFXmode, 2], fillB := InStr(labulB, "|") ? 1 : 2
   labulC := colorzFXinfoz[specialColorFXmode, 3], fillC := InStr(labulC, "|") ? 1 : 2
   If (uiColorCurveFXmode>=6 && specialColorFXmode=7)
      fillC := 1
   If (specialColorFXmode=7)
   {
      GuiControlGet, hwnd, hwnd, uiColorCurveFXmode
      ControlGetText, info,, ahk_id %hwnd%
      If info
         labulC := info
   }

   GuiSetSliderProperties("hueAdjust", thisMinA, thisMaxA, defA, StrReplace(labulA, "|") ": $€", fillA)
   GuiSetSliderProperties("zatAdjust", thisMinB, thisMaxB, 0, StrReplace(labulB, "|") ": $€", fillB)
   GuiSetSliderProperties("lummyAdjust", thisMinC, thisMaxC, defC, StrReplace(labulC, "|") ": $€", fillC)
   If (AnyWindowOpen=10)
   {
      act := isVarEqualTo(vpIMGrotation, 0, 90, 180, 270) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % act, usrTextureBGR

      act :=  (IMGresizingMode=5) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % act, usrTextureBGR
      GuiControl, % act, UIvpImgAlignCenter
   }

   act := (usrColorDepth>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, ColorDepthDithering

   act := (IMGresizingMode=4) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   act := isVarEqualTo(imgFxMode, 2, 9, 10) || (imgFxMode=4 && o_bwDithering=0) ? 1 : 0
   uiSlidersArray["userImgVPgammaLevel", 10] := act

   act := (imgFxMode=2) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   actx := (imgFxMode=2) ? 1 : 0
   If (imgFxMode=4 && o_bwDithering=0)
   {
      uiSlidersArray["userImgClrMtrxSaturation", 10] := 0
      uiSlidersArray["userImgClrMtrxBrightness", 10] := 1
      uiSlidersArray["userImgClrMtrxContrast", 10] := 1
   } Else
   {
      uiSlidersArray["userImgClrMtrxSaturation", 10] := actx
      uiSlidersArray["userImgClrMtrxBrightness", 10] := actx
      uiSlidersArray["userImgClrMtrxContrast", 10] := actx
   }

   uiSlidersArray["userImgChannelRlvl", 10] := actx
   uiSlidersArray["userImgChannelGlvl", 10] := actx
   uiSlidersArray["userImgChannelBlvl", 10] := actx
   uiSlidersArray["userImgChannelAlvl", 10] := actx
   act := (imgFxMode=4) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
   GuiControl, % act, bwDithering

   act := isVarEqualTo(imgFxMode, 2, 3, 4, 9, 10) && (o_bwDithering=0) ? 1 : 0
   uiSlidersArray["userImgVPthreshold", 10] := act

   canEnableThese := act
   act := (act=1 && liveDrawingBrushTool!=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, specialColorFXmode

   act := (specialColorFXmode=7 && canEnableThese=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % act, uiColorCurveFXmode
   GuiControl, % act, uiColorCurveFXchannel

   If (AnyWindowOpen=74)
   {
      act := (imgFxMode>1 && liveDrawingBrushTool!=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % act, EraseAreaInvert

      act := (imgFxMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % act, DesaturateAreaLevels
      act := (imgFxMode>1 && DesaturateAreaLevels>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % act, DesaturateAreaDither
   }

   uiSlidersArray["hueAdjust", 10] := (canEnableThese!=1 || InStr(colorzFXinfoz[specialColorFXmode, 1], "param")) ? 0 : 1
   uiSlidersArray["zatAdjust", 10] := (canEnableThese!=1 || InStr(colorzFXinfoz[specialColorFXmode, 2], "param")) ? 0 : 1
   uiSlidersArray["lummyAdjust", 10] := (canEnableThese!=1 || InStr(colorzFXinfoz[specialColorFXmode, 3], "param")) ? 0 : 1
   lastInvoked := A_TickCount
}

btnResetImageView() {
  ; GuiControlGet, realTimePreview
  If (AnyWindowOpen!=10 && AnyWindowOpen!=74)
     Return

  Gui, SettingsGUIA: Default
  ForceNoColorMatrix := 0
  GuiControl, SettingsGUIA: , doImgEditLivePreview, 1
  GuiControl, SettingsGUIA: Choose, UIimgFxMode, 1
  chnRdecalage := chnGdecalage := chnBdecalage := imgThreshold := 0
  realGammos := IntensityAlphaChannel := 1
  UIimgFxMode := satAdjust := lumosAdjust := lumosGrayAdjust := 1
  lummyAdjust := zatAdjust := hueAdjust := GammosAdjust := GammosGrayAdjust := 0

  userImgChannelRlvl := Round(chnRdecalage*100)
  userImgChannelGlvl := Round(chnGdecalage*100)
  userImgChannelBlvl := Round(chnBdecalage*100)
  userImgChannelAlvl := Round(IntensityAlphaChannel)
  userImgVPthreshold := Round(imgThreshold*200)
  uiSlidersArray["userImgVPthreshold", 14] := -1
  uiSlidersArray["userImgChannelRlvl", 14] := -1
  uiSlidersArray["userImgChannelGlvl", 14] := -1
  uiSlidersArray["userImgChannelBlvl", 14] := -1
  uiSlidersArray["userImgChannelAlvl", 14] := -1
  uiSlidersArray["hueAdjust", 14] := -1
  uiSlidersArray["lummyAdjust", 14] := -1
  uiSlidersArray["zatAdjust", 14] := -1
  GuiControl, SettingsGUIA: Choose, specialColorFXmode, 1
  If (AnyWindowOpen=10)
  {
     vpIMGrotation := 0
     usrColorDepth := IMGresizingMode := ColorDepthDithering := 1
     FlipImgV := FlipImgH := usrTextureBGR := vpIMGrotation := bwDithering := 0
     GuiControl, SettingsGUIA: Choose, usrColorDepth, 1
     GuiControl, SettingsGUIA: Choose, uiIMGresizingMode, 1
     GuiControl, SettingsGUIA:, bwDithering, 0
     GuiControl, SettingsGUIA:, ColorDepthDithering, 1
     GuiControl, SettingsGUIA:, usrTextureBGR, 0
     GuiControl, SettingsGUIA:, FlipImgV, 0
     GuiControl, SettingsGUIA:, FlipImgH, 0
     uiSlidersArray["vpIMGrotation", 14] := -1
  } Else If (AnyWindowOpen=74)
  {
     imgColorsFXopacity := 255
     DesaturateAreaLevels := 1
     GuiControl, SettingsGUIA: Choose, DesaturateAreaLevels, 1
     uiSlidersArray["imgColorsFXopacity", 14] := -1
  }

  interfaceThread.ahkassign("IMGresizingMode", IMGresizingMode)
  updatePanelColorSliderz()
  defineColorDepth()
  UpdateUIadjustVPcolors()
  SetTimer, WriteSettingsColorAdjustments, -90
  dummyTimerDelayiedImageDisplay(50)
}

UpdateUIadjustVPcolors(dummy:=0) {
   Critical, On
   If (AnyWindowOpen!=10 && AnyWindowOpen!=74)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, UIimgFxMode
   GuiControlGet, CurrentPanelTab
   GuiControlGet, uiColorCurveFXchannel
   GuiControlGet, uiColorCurveFXmode
   GuiControlGet, specialColorFXmode
   GuiControlGet, doImgEditLivePreview
   If (AnyWindowOpen=10)
   {
      GuiControlGet, bwDithering
      GuiControlGet, usrColorDepth
      GuiControlGet, ColorDepthDithering
      GuiControlGet, UIvpImgAlignCenter
      GuiControlGet, FlipImgV
      GuiControlGet, FlipImgH
      GuiControlGet, userimgQuality
      GuiControlGet, usrTextureBGR
      GuiControlGet, histogramMode
      GuiControlGet, showHistogram
   } Else
   {
      GuiControlGet, alphaMaskingMode
      GuiControlGet, alphaMaskRefBMP
      GuiControlGet, alphaMaskGradientWrapped
      GuiControlGet, alphaMaskColorReversed
      GuiControlGet, alphaMaskReplaceMode
      GuiControlGet, alphaMaskBMPchannel
      GuiControlGet, uiPasteInPlaceAlphaDrawMode
      GuiControlGet, BrushToolOverDraw
      GuiControlGet, BrushToolType
      GuiControlGet, BrushToolAutoAngle
      GuiControlGet, BrushToolDoubleSize
      GuiControlGet, EraseAreaInvert
      GuiControlGet, DesaturateAreaLevels
      GuiControlGet, DesaturateAreaDither
      ; ToolTip, % "l=" CurrentPanelTab , , , 2
      If (CurrentPanelTab=3)
         updateUIalphaMaskStuff(1)
      Else If (CurrentPanelTab=4)
         updateUIalphaMaskStuff(2)
   }

   imgFxMode := (UIimgFxMode>2) ? UIimgFxMode + 1 : UIimgFxMode
   ForceNoColorMatrix := !doImgEditLivePreview
   ; GuiControlGet, realTimePreview
   If (dummy!="ignore-zoom" && AnyWindowOpen=10)
   {
      GuiControlGet, uiIMGresizingMode, SettingsGUIA:, uiIMGresizingMode
      If (uiIMGresizingMode=3)
      {
         lockZoomLevel := 0
         customZoomAdaptMode := 0
         IMGresizingMode := 4
         zoomLevel := 1
      } Else If (uiIMGresizingMode=6)
      {
         lockZoomLevel := 0
         customZoomAdaptMode := 1
         IMGresizingMode := 4
      } Else If (uiIMGresizingMode=7)
      {
         lockZoomLevel := 0
         customZoomAdaptMode := 2
         IMGresizingMode := 4
      } Else IMGresizingMode := uiIMGresizingMode

      imageAligned := (UIvpImgAlignCenter=1) ? 5 : 1
   }

   If (AnyWindowOpen=74)
   {
      actu := (imgFxMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
      GuiControl, % actu, btnLiveApplyTool
      GuiControl, % actu, alphaMaskingMode
      GuiControl, % actu, uiPasteInPlaceAlphaDrawMode
      uiSlidersArray["imgColorsFXopacity", 10] := (imgFxMode>1) ? 1 : 0

      actu := (liveDrawingBrushTool=1 && isNowAlphaPainting()=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
      GuiControl, % actu, btn1
      GuiControl, % actu, UIimgFxMode
   }

   defineColorDepth()
   If (vpIMGrotation=1 || vpIMGrotation>358)
      vpIMGrotation := 0

   trGdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   Gdip_GetRotatedDimensions(imgW, imgH, 45, ResizedW, ResizedH)
   If (isImgSizeTooLarge(ResizedW, ResizedH) && vpIMGrotation=0)
   {
      vpIMGrotation := 0
      uiSlidersArray["vpIMGrotation", 10] := 0
   } Else
      uiSlidersArray["vpIMGrotation", 10] := 1

   imgThreshold := Round(userImgVPthreshold/200, 3)
   realGammos := (userImgVPgammaLevel>0) ? (userImgVPgammaLevel + 1)**3.32 : userImgVPgammaLevel + 1
   If isInRange(imgFxMode, 1, 3)
   {
      lumosAdjust := (userImgClrMtrxBrightness>0) ? (userImgClrMtrxBrightness + 1)**3.9 : userImgClrMtrxBrightness + 1
      GammosAdjust := (userImgClrMtrxContrast>0) ? -1*((userImgClrMtrxContrast + 1)**3.8 - 1) : -1*userImgClrMtrxContrast
   } Else If (imgFxMode=4)
   {
      lumosGrayAdjust := (userImgClrMtrxBrightness>0) ? (userImgClrMtrxBrightness + 1)**3.9 : userImgClrMtrxBrightness + 1
      GammosGrayAdjust := (userImgClrMtrxContrast>0) ? -1*((userImgClrMtrxContrast + 1)**3.8 - 1) : -1*userImgClrMtrxContrast
   }

   satAdjust := (userImgClrMtrxSaturation>0) ? (userImgClrMtrxSaturation + 1)**2.32 : userImgClrMtrxSaturation + 1
   chnRdecalage := Round(userImgChannelRlvl/100, 3)
   chnGdecalage := Round(userImgChannelGlvl/100, 3)
   chnBdecalage := Round(userImgChannelBlvl/100, 3)
   ; ToolTip, % chnRdecalage "|" chnGdecalage "|"  chnBdecalage "`n" userImgChannelRlvl "|" userImgChannelGlvl "|" userImgChannelBlvl , , , 2
   IntensityAlphaChannel := userImgChannelAlvl
   updatePanelColorsInfo()
   GuiRefreshSliders()
   If (imgFxMode!=4 && AnyWindowOpen=10)
   {
      bwDithering := 0
      GuiControl, SettingsGUIA:, bwDithering, 0
   }

   If (AnyWindowOpen=10)
      filterDelayiedImageDisplay()
   Else
      livePreviewsImageEditing(0, A_ThisFunc, actionu, b)

   If (AnyWindowOpen=74)
      RegAction(1, "imgColorsFXopacity")
   SetTimer, WriteSettingsColorAdjustments, -150
}

livePreviewColorsAdjustVP() {
   imgThreshold := Round(userImgVPthreshold/200, 3)
   realGammos := (userImgVPgammaLevel>0) ? (userImgVPgammaLevel + 1)**3.32 : userImgVPgammaLevel + 1
   If isInRange(imgFxMode, 1, 3)
   {
      lumosAdjust := (userImgClrMtrxBrightness>0) ? (userImgClrMtrxBrightness + 1)**3.9 : userImgClrMtrxBrightness + 1
      GammosAdjust := (userImgClrMtrxContrast>0) ? -1*((userImgClrMtrxContrast + 1)**3.8 - 1) : -1*userImgClrMtrxContrast
   } Else If (imgFxMode=4)
   {
      lumosGrayAdjust := (userImgClrMtrxBrightness>0) ? (userImgClrMtrxBrightness + 1)**3.9 : userImgClrMtrxBrightness + 1
      GammosGrayAdjust := (userImgClrMtrxContrast>0) ? -1*((userImgClrMtrxContrast + 1)**3.8 - 1) : -1*userImgClrMtrxContrast
   }

   satAdjust := (userImgClrMtrxSaturation>0) ? (userImgClrMtrxSaturation + 1)**2.32 : userImgClrMtrxSaturation + 1
   chnRdecalage := Round(userImgChannelRlvl/100, 3)
   chnGdecalage := Round(userImgChannelGlvl/100, 3)
   chnBdecalage := Round(userImgChannelBlvl/100, 3)
   ; ToolTip, % chnRdecalage "|" chnGdecalage "|"  chnBdecalage "`n" userImgChannelRlvl "|" userImgChannelGlvl "|" userImgChannelBlvl , , , 2
   IntensityAlphaChannel := userImgChannelAlvl
   dummyResizeImageGDIwin()
}

PanelFileFormatConverter() {
    Global btnFldr, IDbtnConvert, editF5
    filesElected := getSelectedFiles(0, 1)
    initFIMGmodule()
    If !wasInitFIMlib
    {
       msgBoxWrapper(appTitle ": ERROR", "Unable to initialize the FreeImage library module.`n`nThis functionality is currently unavailable.", 0, 0, "error")
       Return
    }

    thisBtnHeight := createSettingsGUI(15, A_ThisFunc)
    btnWid := 110
    txtWid := 280
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    sml := (PrefsLargeFonts=1) ? 250 : 140
    thisW := (PrefsLargeFonts=1) ? 85 : 75
    ReadSettingsFormatConvert()
    convertFormatAutoSkip := 1
    Gui, Add, Text, x15 y15 w%sml% Section +0x200 +hwndhTemp, Destination format:
    GuiAddDropDownList("x+5 w" thisW " gTglDesiredSaveFormat AltSubmit Choose" userDesireWriteFMT " vuserDesireWriteFMT", userPossibleWriteFMTs, [hTemp])
    Gui, Add, Checkbox, x+5 Checked%convertFormatAutoSkip% vconvertFormatAutoSkip +hwndhTemp, Auto-skip format
    ToolTip2ctrl(hTemp, "The files with the selected file destination extension format will be skipped when this option is selected.")
    Gui, Add, Text, xs y+10 w%sml% hp +0x200 +hwndhTemp, On file name conflicts:
    GuiAddDropDownList("x+5 w150 AltSubmit gTglOverwriteFiles Choose" userActionConflictingFile " vuserActionConflictingFile", "Skip files|Auto-rename|Overwrite", [hTemp])
    Gui, Add, Text, xs y+10 w%sml% hp +0x200, Image quality (1`% - 100`%):
    GuiAddEdit("x+5 w" thisW " hp number -multi limit3 veditF5", userJpegQuality)
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    Gui, Add, Checkbox, xs y+10 Checked%convertFormatUseMultiThreads% vconvertFormatUseMultiThreads, &Use multiple threads (experimental)
    If !(filesElected>1)
       GuiControl, SettingsGUIA: Disable, convertFormatUseMultiThreads

    Gui, Add, Checkbox, y+10 gTglKeepOriginals Checked%OnConvertKeepOriginals% vOnConvertKeepOriginals, &Keep original file[s]
    Gui, Add, Checkbox, y+10 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder:
    GuiAddEdit("xp+10 y+5 wp r1 +0x0800 -wrap vResizeDestFolder", ResizeDestFolder, "Destination folder")
    thisW := (PrefsLargeFonts=1) ? 90 : 70
    Gui, Add, Button, x+5 hp w%thisW% gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    If (filesElected>1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, % "Files selected to convert: " groupDigits(filesElected) "."
       Gui, Font, Normal
    } 

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    thisV := (PrefsLargeFonts=1) ? 135 : 90
    ml := (filesElected>1) ? 30 : 5
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%thisW% gBTNconvertImgFmtNow Default vIDbtnConvert, &Convert
    If (filesElected>1)
       Gui, Add, Button, x+5 hp w%thisV% gBTNconvertImgFmtSoloNow, &Active file only

    sml := (PrefsLargeFonts=1) ? 85 : 60
    Gui, Add, Button, x+%ml% hp w%sml% gBTNhelpConvertImgFmt, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file format conversion: " appTitle)
}

BTNhelpConvertImgFmt() {
    msgBoxWrapper(appTitle ": HELP", "On file format conversion, QPV will attempt to preserve the color depth of the images. If it is not possible, the images will be converted to 24 bits or 32 bits or to the color depth supported by the destination format.`n`nFailures can occur if there is insufficient system memory or... if file access is denied when attempting to write files.`n`nThe image quality option applies only for the JPG, JP2, J2K, JXR and WEBP file formats.`n`nSome file formats have image dimensions limited by design. WebP file format is limited to 16350 px in width or height. JPEG, TGA, and GIF formats are limited to 65530 px in width or height and 4294 MPx. Therefore, on format conversions, the resulted image dimensions may reflect the format specific limits.`n`nThis feature relies on the FreeImage library.", -1, 0, 0)
}

TglKeepOriginals() {
    GuiControlGet, OnConvertKeepOriginals
    RegAction(1, "OnConvertKeepOriginals")
}

TglOverwriteFiles() {
    GuiControlGet, userActionConflictingFile
    RegAction(1, "userActionConflictingFile")
}

TglDesiredSaveFormat() {
    GuiControlGet, userDesireWriteFMT
    RegAction(1, "userDesireWriteFMT")
}

BTNconvertImgFmtSoloNow() {
   BTNconvertImgFmtNow("single")
}

BTNconvertImgFmtNow(modus:=0) {
   If (AnyWindowOpen!=15)
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: Submit, NoHide
   If (wasInitFIMlib!=1 || FIMfailed2init=1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "File format conversion is currently unsupported. The FreeImage library failed to properly initialize. Please make sure the FreeImage.dll is in the QPV folder.", 0, 0, "error")
      Return
   }

   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   RegAction(1, "OnConvertKeepOriginals")
   RegAction(1, "PreserveDateTimeOnSave")
   RegAction(1, "ResizeDestFolder")
   RegAction(1, "userActionConflictingFile")
   RegAction(1, "convertFormatUseMultiThreads")
   RegAction(1, "convertFormatAutoSkip")
   RegAction(1, "userDesireWriteFMT")
   RegAction(1, "userJpegQuality")
   performImgFmtConvert(modus)
}

performImgFmtConvert(modus:=0) {
   If (markedSelectFile>1 && modus!="single")
   {
      BtnCloseWindow()
      batchConvert2format()
   } Else
      convert2format(currentFileIndex)
}

WriteSettingsAdjustCanvasPanel() {
    ReadSettingsAdjustCanvasPanel(1)
}

ReadSettingsAdjustCanvasPanel(act:=0) {
    RegAction(act, "ResizeKeepAratio",, 1)
    RegAction(act, "ResizeInPercentage",, 1)
    RegAction(act, "adjustCanvasCentered",, 1)
    RegAction(act, "adjustCanvasMode",, 1)
    RegAction(act, "adjustCanvasDoBgr",, 1)
    RegAction(act, "OutlierFillColor",, 3)
    RegAction(act, "OutlierFillOpacity",, 2, 1, 255)
}

PanelAdjustImageCanvasSize() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight
         , userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter

    If (thumbsDisplaying=1 || AnyWindowOpen)
       Return

    r1 := trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (!oImgH || !oImgH)
    {
       showTOOLtip("ERROR: No image seems to be loaded or it is malformed")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (viewportQPVimage.imgHandle)
    {
       mgpx := Round((oImgW * oImgH)/1000000, 1)
       If (mgpx>536.7)
       {
          If (editingSelectionNow=1)
             msgResult := msgBoxWrapper(appTitle ": WARNING", "The image currently opened has " mgpx " megapixels. Image editing is limited to 536 megapixels. The image can be cropped based on the selection area.`n`nDo you want to crop the image to the selected area?", "&Crop to selection|&No", 1, "exclamation")
          Else
             msgResult := msgBoxWrapper(appTitle ": WARNING", "The image currently opened has " mgpx " megapixels. Image editing is limited to 536 megapixels. The image can be resized or cropped to a selection area.`n`nDo you want to create a selection area?", "&Create selection|&No", 1, "exclamation")

          If InStr(msgResult, "crop")
          {
             CropImageInViewPortToSelection()
          } Else If InStr(msgResult, "create")
          {
             EllipseSelectMode := 0
             ToggleEditImgSelection()
          }
          Return
       }
    }

    thisBtnHeight := createSettingsGUI(28, A_ThisFunc)
    ReadSettingsAdjustCanvasPanel()
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 Section, Original image size: %oImgW% x %oImgH% px.
    ; GuiAddEdit("x15 y15 w1 r1 limit7 -multi -wrap", "-")
    Gui, Add, Text, xs y+10 vtxtLine1, Set new canvas dimensions (W x H):
    GuiAddEdit("xs+15 y+5 w" editWid " r1 limit5 -multi number -wrap gEditResizeWidth vuserEditWidth", (ResizeInPercentage=1) ? 100 : oImgW, "Width")
    GuiAddEdit("x+5 w" editWid " r1 limit5 -multi number -wrap gEditResizeHeight vuserEditHeight", (ResizeInPercentage=1) ? 100 : oImgH, "Height")
    Gui, Add, Checkbox, x+5 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, Use `% percentages
    Gui, Add, Checkbox, xs+15 y+5 hp gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp Checked%adjustCanvasCentered% vadjustCanvasCentered, Centered image

    Gui, Add, Text, xs y+15, Resulted dimensions and background color:
    GuiAddEdit("xs+15 y+5 w" editWid " r1 Disabled -wrap vResultEditWidth", oImgW, "Calculated width")
    GuiAddEdit("x+5 wp r1 Disabled -wrap vResultEditHeight", oImgH, "Calculated height")
    Gui, Add, Text, x+5 hp wp+45 +0x200 vinfoLine -wrap, -

    sml := (PrefsLargeFonts=1) ? 140 : 80
    Gui, Add, Checkbox, xs y+10 hp Checked%adjustCanvasDoBgr% vadjustCanvasDoBgr gupdateUIadjustCanvasPanel, Fill with a background color
    ha := (PrefsLargeFonts=1) ? 28 : 19
    clrW := (PrefsLargeFonts=1) ? 65 : 45
    GuiAddPickerColor("xs+15 y+10 w26 h" ha, "OutlierFillColor")
    GuiAddColor("x+2 hp w" clrW, "OutlierFillColor", "Background color")
    txtWid -= 95
    GuiAddSlider("OutlierFillOpacity", 3,255, 255, "Opacity", "iniSaveOutlierClrOpaciy", 1, "x+5 w" clrW*2 + 20 " hp")

    Gui, Add, Checkbox, xs y+10 Section hp Checked%adjustCanvasMode% vadjustCanvasMode gupdateUIadjustCanvasPanel, Add margins to current image dimensions
    GuiAddEdit("xs+15 y+5 w" editWid " h1 Disabled +0x0800", "-")
    GuiAddEdit("x+5 wp r1 limit5 -multi number -wrap gUIeditCanvasMargins vuserAddTop", "", "Top")
    GuiAddEdit("xs+15 y+5 w" editWid " r1 limit5 -multi number -wrap gUIeditCanvasMargins vuserAddLeft", "", "Left")
    GuiAddEdit("x+5 wp r1 limit5 -multi number -wrap gUIeditCanvasMargins vuserAddCenter", "", "Edges margin")
    GuiAddEdit("x+5 wp r1 limit5 -multi number -wrap gUIeditCanvasMargins vuserAddRight", "", "Right")
    GuiAddEdit("xs+15 y+5 w" editWid " h1 Disabled +0x0800", "-")
    GuiAddEdit("x+5 w" editWid " r1 limit5 -multi number -wrap gUIeditCanvasMargins vuserAddBottom", "", "Bottom")

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% gBTNadjustCanvasAction Default, &Adjust canvas
    sml := (PrefsLargeFonts=1) ? 85 : 60
    Gui, Add, Button, x+5 hp w%sml% gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Adjust image canvas size: " appTitle)
    updateUIadjustCanvasPanel()
}

UIeditCanvasMargins() {
   If (AnyWindowOpen!=28)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, userAddTop
   GuiControlGet, userAddBottom
   GuiControlGet, userAddCenter
   GuiControlGet, userAddLeft
   GuiControlGet, userAddRight
   If (!userAddTop || userAddTop<0)
      userAddTop := 0
   If (!userAddBottom || userAddBottom<0)
      userAddBottom := 0
   If (!userAddCenter || userAddCenter<0)
      userAddCenter := 0
   If (!userAddLeft || userAddLeft<0)
      userAddLeft := 0
   If (!userAddRight || userAddRight<0)
      userAddRight := 0

   trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   thisWidth := oImgW + userAddLeft + userAddRight + userAddCenter
   thisHeight := oImgH + userAddTop + userAddBottom + userAddCenter
   GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
   GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   mpx := Round((Round(thisWidth) * Round(thisHeight))/1000000, 1)
   f := isImgSizeTooLarge(Round(thisWidth), Round(thisHeight)) ? "(!) " : ""
   GuiControl, SettingsGUIA: , infoline, %f%%mpx% MPx
}

updateUIadjustCanvasPanel() {
    If (AnyWindowOpen!=28)
       Return

    Gui, SettingsGUIA: Default
    GuiControlGet, adjustCanvasDoBgr
    GuiControlGet, adjustCanvasMode
    GuiControlGet, adjustCanvasCentered

    actu1 := (adjustCanvasMode=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    actu2 := (adjustCanvasMode!=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu2, ResizeKeepAratio
    GuiControl, % actu2, ResizeInPercentage
    GuiControl, % actu2, adjustCanvasCentered
    GuiControl, % actu2, userEditHeight
    GuiControl, % actu2, userEditWidth
    GuiControl, % actu2, txtLine1
    GuiControl, % actu1, userAddCenter
    GuiControl, % actu1, userAddTop
    GuiControl, % actu1, userAddBottom
    GuiControl, % actu1, userAddLeft
    GuiControl, % actu1, userAddRight
    If (adjustCanvasMode=1)
       UIeditCanvasMargins()
    Else
       EditResizeWidth()

    uiSlidersArray["OutlierFillOpacity", 10] := adjustCanvasDoBgr
    actu := (adjustCanvasDoBgr=1) ? "SettingsGUIA: Show" : "SettingsGUIA: Hide"
    GuiControl, % actu, PickuOutlierFillColor
    GuiControl, % actu, OutlierFillColor

    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := OutlierFillOpacity
    GuiRefreshSliders()
    SetTimer, WriteSettingsAdjustCanvasPanel, -300
}

BTNadjustCanvasAction() {
    Gui, SettingsGUIA: Default
    GuiControlGet, adjustCanvasCentered
    GuiControlGet, adjustCanvasDoBgr
    GuiControlGet, adjustCanvasMode
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, userAddTop
    GuiControlGet, userAddBottom
    GuiControlGet, userAddCenter
    GuiControlGet, userAddLeft
    GuiControlGet, userAddRight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResultEditWidth

    If (!userAddTop || userAddTop<0)
       userAddTop := 0
    If (!userAddBottom || userAddBottom<0)
       userAddBottom := 0
    If (!userAddCenter || userAddCenter<0)
       userAddCenter := 0
    If (!userAddLeft || userAddLeft<0)
       userAddLeft := 0
    If (!userAddRight || userAddRight<0)
       userAddRight := 0

    trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (ResultEditWidth=oImgW && ResultEditHeight=oImgH)
    {
       SoundBeep , 300, 100
       msgBoxWrapper(appTitle ": WARNING", "The provided image dimensions are equal with the initial ones. No operation to perform.", 0, 0, "exclamation")
       Return
    }

    If isImgSizeTooLarge(ResultEditWidth, ResultEditHeight)
    {
       SoundBeep, 300, 100
       msgResult := msgBoxWrapper(appTitle ": WARNING", "The image dimensions exceed the maximum limits. Width and height cannot exceed 199000 pixels, and total image size cannnot exceed 536 MPx.`n`nWould you like to adapt the dimensions and continue?", "&Yes|&No", 1, "exclamation")
       If (msgResult="Yes")
          capIMGdimensionsGDIPlimits(ResultEditWidth, ResultEditHeight)
       Else
          Return
    }

    WriteSettingsAdjustCanvasPanel()
    thisOpa := (BrushToolUseSecondaryColor=1) ? "BrushToolBopacity" : "BrushToolAopacity"
    %thisOpa% := OutlierFillOpacity
    BtnCloseWindow()
    r1 := trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (viewportQPVimage.imgHandle)
    {
       mgpx := Round((oImgW * oImgH)/1000000, 1)
       If (mgpx<=536.7)
          r := downscaleHugeImagesForEditing()
       Else
          r := -1

       If (r<0)
       {
          showTOOLtip("Failed to adjust image canvas")
          SoundBeep 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    }

    ToggleEditImgSelection("show-edit")
    ChangeImageCanvasSize(ResultEditWidth, ResultEditHeight, userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter)
}

PanelResizeImageWindow() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight, btnFldr, editF5

    ToolTip, Please wait...
    filesElected := getSelectedFiles(0, 1)
    multipleFilesMode := (filesElected>1) ? 1 : 0
    If (multipleFilesMode=0 && !PanelsCheckFileExists())
    {
       ToolTip
       Return
    }

    thisBtnHeight := createSettingsGUI(4, A_ThisFunc)
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsImageProcessing()
    img2resizePath := getIDimage(currentFileIndex)
    If (multipleFilesMode=0)
    {
       r1 := 1
       zPlitPath(img2resizePath, 0, fileNamu, folderu)
       If (thumbsDisplaying!=1)
          trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
       Else If (img2resizePath=getIDimage(currentFileIndex))
          r1 := GetImgFileDimension(getIDimage(currentFileIndex), oImgW, oImgH, 1, currentFileIndex)
       Else
          r1 := GetImgFileDimension(img2resizePath, oImgW, oImgH)

       FileGetSize, fileSizu, % img2resizePath, K
       If !r1
       {
          BtnCloseWindow()
          showTOOLtip("ERROR: Incorrect image dimensions or the file is malformed.`n" fileNamu "`n" folderu "\")
          SoundBeep, 300, 100
          img2resizePath := ""
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    } Else
    {
       oImgW := ResolutionWidth
       oImgH := ResolutionHeight
    }

    initFIMGmodule()
    If (editingSelectionNow!=1)
       ResizeWithCrop := 0

    If (resetImageViewOnChange=1)
       ResizeApplyEffects := 0

    Gui, Add, Tab3, %tabzDarkModus% , General|File(s) destination
    Gui, Tab, 1
    If (multipleFilesMode=1)
    {
       Gui, Add, Text, x+15 y+15 Section, Resize image to (W x H)
    } Else
    {
       Gui, Add, Text, x+15 y+15 Section, Original image dimensions:
       Gui, Add, Text, xs+15 y+5, %oImgW% x %oImgH% pixels. %fileSizu% kilobytes.
       Gui, Add, Text, xs y+10, Resize image to (W x H)
    }

    GuiAddEdit("xs+15 y+5 w" editWid " r1 limit5 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeWidth vuserEditWidth", (ResizeInPercentage=1) ? 100 : oImgW, "Width")
    GuiAddEdit("x+5 w" editWid " r1 limit5 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeHeight vuserEditHeight", (ResizeInPercentage=1) ? 100 : oImgH, "Height")
    Gui, Add, Checkbox, x+5 wp+40 hp +0x1000 gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `%
    If (multipleFilesMode!=1)
       Gui, Add, Text, xs y+15, Result (W x H) in pixels

    GuiAddEdit("xs+15 y+5 w" editWid " r1 Disabled -wrap vResultEditWidth", (multipleFilesMode=1) ? "--" : oImgW, "Calculated width")
    GuiAddEdit("x+5 wp r1 Disabled -wrap vResultEditHeight", (multipleFilesMode=1) ? "--" : oImgH, "Calculated height")
    If (multipleFilesMode=1)
    {
       GuiControl, SettingsGUIA: Hide, ResultEditHeight
       GuiControl, SettingsGUIA: Hide, ResultEditWidth
    }

    GuiAddSlider("ResizeRotationUser", -180,180, 0, "Rotation: $€°", "TglRszRotation", 2, "x+5 wp+40 hp")
    Gui, Add, Checkbox, xs+15 y+10 hp+5 gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp gTglRszQualityHigh Checked%ResizeQualityHigh% vResizeQualityHigh, High quality resampling
    Gui, Add, Checkbox, xs y+10 gTglRszCropping Checked%ResizeWithCrop% vResizeWithCrop, Crop image(s) to the viewport selection
    Gui, Add, Checkbox, xp+15 y+10 gTglRszCropping Checked%ResizeCropAfterRotation% vResizeCropAfterRotation, Perform image crop after image rotation (as in the viewport)
    Gui, Add, Checkbox, xs y+10 gTglRszApplyEffects Checked%ResizeApplyEffects% vResizeApplyEffects, Apply color adjustments and image mirroring`nactivated in the main window

    Gui, Tab, 2
    thisW := (PrefsLargeFonts=1) ? 90 : 50
    Gui, Add, Text, x+15 y+15, If no destination folder is chosen,`nthe original files may be overwritten.
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the following folder
    GuiAddEdit("xp+15 y+5 wp r1 +0x0800 -wrap vResizeDestFolder", ResizeDestFolder, "Destination folder")
    Gui, Add, Button, x+5 hp w%thisW% gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs y+10 hp +0x200 +hwndhTemp, Action on file name conflicts:
    GuiAddDropDownList("xp+15 y+7 wp AltSubmit Choose" userActionAdvImgProcConflictingFile " vuserActionAdvImgProcConflictingFile", "Skip files|Auto-rename|Overwrite|Ask user", [hTemp])
    thisW := (PrefsLargeFonts=1) ? 150 : 80
    thisWid := (PrefsLargeFonts=1) ? 145 : 115
    GuiAddSlider("userJpegQuality", 2,100, 95, "Quality on save", "iniSaveJPGquality", 1, "xs y+10 wp hp", "This only applies to the JPEG and WEBP file formats")
    thisW := (PrefsLargeFonts=1) ? 85 : 55
    If (multipleFilesMode=1)
    {
       GuiAddDropDownList("xs y+10 w" txtWid " gTglRszUnsprtFrmt AltSubmit Choose" userUnsprtWriteFMT " vuserUnsprtWriteFMT", "Skip files in unsupported write formats|Try to preserve file formats, convert unsupported to...|Convert all the files to...", "Image file formats treatment mode")
       GuiAddDropDownList("xs y+5 w" thisW " AltSubmit Choose" userDesireWriteFMT " vuserDesireWriteFMT", userPossibleWriteFMTs, "File format on save")
       Gui, Add, Button, x+5 hp wp gBtnHelpResizePanel, Help
    }

    If (resetImageViewOnChange=1)
       GuiControl, Disable, ResizeApplyEffects

    If (editingSelectionNow!=1)
    {
       GuiControl, Disable, ResizeWithCrop
       GuiControl, Disable, ResizeCropAfterRotation
    }

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Tab
    If (multipleFilesMode=1)
    {
       pkl := (allowMultiCoreMode=1) ? "`nMulti-threaded processing not yet implemented." : ""
       zp := groupDigits(filesElected)
       Gui, Font, Bold
       Gui, Add, Text, xs-15 y+10, %zp% files are selected for processing.%pkl%
       Gui, Font, Normal
       Gui, Add, Button, xp y+10 h%thisBtnHeight% w%btnWid% Default gBTNsaveResizedIMG, &Process images
       Gui, Add, Button, x+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       If (userUnsprtWriteFMT=1)
          GuiControl, SettingsGUIA: Disable, userDesireWriteFMT
    } Else
    {
       Gui, Add, Button, xs-15 y+20 h%thisBtnHeight% w%btnWid% gBtnCopy2ClipResizedIMG vBtn1, &Copy to clipboard
       Gui, Add, Button, x+5 hp wp Default gBTNsaveResizedIMG vbtn2, &Save image as...
       Gui, Add, Button, xs-15 y+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       Gui, Add, Button, x+5 hp w%thisW% gBtnHelpResizePanel, Help
    }
    ToolTip
    Gui, Add, Button, x+5 hp w%thisW% gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / rotate / crop image(s): " appTitle)
    GuiRefreshSliders()
}

BtnInvokePanelSimpleResizeRotate() {
   BtnCloseWindow()
   Sleep, 25
   PanelSimpleResizeRotate("forced")
}

BTNchangeResizeDestFolder() {
   If (AnyWindowOpen=4)
      EditResizeWidth()

   SelectImg := openFoldersDialogWrapper(ResizeDestFolder)
   OutDir := Trimmer(SelectImg)
   If !FolderExist(OutDir)
   {
      WinActivate, ahk_id %hSetWinGui%
   } Else
   {
      GuiControl, SettingsGUIA:, ResizeDestFolder, % OutDir
      ResizeDestFolder := OutDir
      RegAction(1, "ResizeDestFolder")
   }
}

setForceRefreshThumbsFilesIndex(onlySelected) {
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1 && onlySelected=1)
         Continue

      resultedFilesList[A_Index, 4] := 1
   }
   ForceRefreshNowThumbsList()
}

batchAdvIMGresizer(desiredW, desiredH, isPercntg, dontAsk:=0) {
   cleanResizeUserOptionsVars()
   If (!desiredH || !desiredW
   || desiredW<1 || desiredH<1)
   || ((desiredW<5 || desiredH<5) && (isPercntg!=1))
   {
      showTOOLtip("WARNING: Incorrect dimensions given. Please increase the values.")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   filesElected := getSelectedFiles(0, 1)
   If (dontAsk!="yes")
   {
      If (filesElected>100)
      {
         overwriteWarning := (ResizeUseDestDir!=1) ? "`n`nWARNING: All the original files will be overwritten!" : "`n`nThe image files will be saved in " ResizeDestFolder "\"
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to process multiple images in one go. There are " groupDigits(filesElected) " selected files for this operation. " overwriteWarning, 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }
   }

   BtnCloseWindow()
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   startOperation := A_TickCount
   CurrentSLD := ""
   thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
   If (ResizeKeepAratio=1 && isPercntg=1)
      desiredW := desiredH

   showTOOLtip("Processing " groupDigits(filesElected) " images, please wait")
   prevMSGdisplay := A_TickCount
   countTFilez := countFilez := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   failedFiles := countFilez := skippedFiles := 0
   destroyGDIfileCache()
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      countTFilez++
      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (!FileExist(imgPath) || !imgPath) || (!RegExMatch(imgPath, saveTypesRegEX) && userUnsprtWriteFMT=1)
      {
         skippedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If (failedFiles>0)
            etaTime .= "`nFailed to process " groupDigits(failedFiles) " files"
         If (skippedFiles>0)
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip("Processing images, please wait" etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      fOutDir := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      If (userUnsprtWriteFMT=3)
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else If (userUnsprtWriteFMT=2 && !RegExMatch(imgPath, saveTypesRegEX))
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else
         destImgPath := fOutDir "\" OutFileName

      If (userUnsprtWriteFMT!=1 || ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionAdvImgProcConflictingFile, performOverwrite, 0)
      }

      If !destImgPath
      {
         skippedFiles++
         Continue
      } Else if (destImgPath="abort")
      {
         abandonAll := 1
         Break
      }

      oBitmap := LoadBitmapFromFileu(imgPath)
      If !validBMP(oBitmap)
      {
         failedFiles++
         Continue
      }

      trGdip_GetImageDimensions(oBitmap, imgW, imgH)
      If (!imgW || !imgH)
      {
         failedFiles++
         Continue
      }

      givenAngle := (ResizeRotationUser>0) ? ResizeRotationUser : 360 + ResizeRotationUser
      If (givenAngle!=0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
         Gdip_GetRotatedDimensions(imgW, imgH, givenAngle, imgW, imgH)

      If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      z := calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, ResizeKeepAratio, newW, newH)
      If (z=-1)
      {
         failedFiles++
         trGdip_DisposeImage(oBitmap, 1)
         Continue
      }

      capIMGdimensionsFormatlimits(rDesireWriteFMT, ResizeKeepAratio, newW, newH)
      r := coreResizeIMG(imgPath, newW, newH, destImgPath, 0, 0, givenAngle, oBitmap, imgW, imgH)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If (failedFiles>0)
      someErrors := "`nFailed to process " groupDigits(failedFiles) " files"
   If (skippedFiles>0)
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   If (editingSelectionNow=1 && relativeImgSelCoords=1)
   {
      zBitmap := useGdiBitmap()
      If validBMP(zBitmap)
      {
         trGdip_GetImageDimensions(zBitmap, lW, lH)
         calcRelativeSelCoords(0, lW, lH)
      }
   }

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip("Finished processing " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

WriteSettingsResizePanel() {
   coreReadSettingsImageProcessing(1)
}

WriteSettingsResizeSimplePanel() {
   coreReadSettingsImageProcessing(1)
}

calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, isKeepRatio, ByRef newW, ByRef newH) {
   r := 0
   If (isPercntg=1)
   {
      newW := Round((imgW/100)*desiredW)
      newH := Round((imgH/100)*desiredH)
      If (newW<5 && newH<5)
         r := -1
   } Else If (isKeepRatio=1)
   {
      calcIMGdimensions(imgW, imgH, desiredW, desiredH, newW, newH)
      If (newW<5 && newH<5)
         r := -1
   } Else
   {
      newW := desiredW
      newH := desiredH
   }

   If isImgSizeTooLarge(newW, newH)
   {
      capIMGdimensionsFormatlimits("gdip", isKeepRatio, newW, newH)
      ; capIMGdimensionsGDIPlimits(newW, newH)
      r := 1
   }
   Return r
}

filesListApplyColors() {
    Static prevFXmode := "n"

    o_imgFxMode := imgFxMode
    If (imgFxMode>1)
       prevFXmode := imgFxMode
    Else If (prevFXmode!="n")
       imgFxMode := prevFXmode

    If (imgFxMode=1)
    {
       showTOOLtip("No viewport color adjustments to be applied on image`n`nPress F to cycle through mode")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && imgFxMode>1)
   {
      If (filesElected>200)
      {
         msgResult := msgBoxWrapper(appTitle ": Apply colors", "All the images in supported writing formats will be processed accordingly to the color adjustments of the viewport. The original files will be overwritten. Do you want to continue?", 4, 0, "question")
         If !InStr(msgResult, "yes")
            Return
      }

      ResizeMustPerform := ResizeUseDestDir := 0
      ResizeInPercentage := ResizeApplyEffects := 1
      userActionConflictingFile := userUnsprtWriteFMT := 1
      ResizeWithCrop := ResizeRotationUser := simpleOpRotationAngle := 0
      ResultEditWidth := ResultEditHeight := 100
      WriteSettingsResizePanel()
      batchAdvIMGresizer(100, 100, ResizeInPercentage, "yes")
   } Else
   {
      imgPath := resultedFilesList[currentFileIndex, 1]
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      If !RegExMatch(imgPath, saveTypesRegEX)
      {
         showTOOLtip("ERROR: The image file is in an unsupported write format. Cannot perform the operation.`n" OutFileName)
         SoundBeep, 300, 100
      } Else
      {
         destroyGDIfileCache()
         ResizeMustPerform := ResizeUseDestDir := 0
         ResizeInPercentage := ResizeApplyEffects := 1
         userActionConflictingFile := userUnsprtWriteFMT := 1
         ResizeWithCrop := ResizeRotationUser := simpleOpRotationAngle := 0
         ResultEditWidth := ResultEditHeight := 100
         ; WriteSettingsResizePanel()
         GetImgFileDimension(imgPath, imgW, imgH, 1, currentFileIndex)
         r := coreResizeIMG(imgPath, imgW, imgH, imgPath, 1, 0, 0, 1, imgW, imgH)
         If r
         {
            SoundBeep, 300, 100
            showTOOLtip("ERROR: Unable to save image file - unknown error:`n" OutFileName "`n" OutDir "\")
         } Else
         {
            resultedFilesList[currentFileIndex, 4] := 1
            If (SLDtypeLoaded=3)
               selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

            showTOOLtip("Viewport colour effects applied on the image:`n" OutFileName "`n" OutDir "\")
         }
      }
   }

   imgFxMode := 1
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
}

filesListFlipHimage() {
   coreQuickImageFilesListActions(2)
}

filesListFlipVimage() {
   coreQuickImageFilesListActions(3)
}

filesListFlipRotatePlus() {
   coreQuickImageFilesListActions(6)
}

filesListFlipRotateMinus() {
   coreQuickImageFilesListActions(8)
}

filesListCropImgVPsel() {
   If (editingSelectionNow=1)
      coreQuickImageFilesListActions(9)
}

coreQuickImageFilesListActions(actu) {
   initFIMGmodule()
   countNotJpegs := firstu := 0
   filesElected := getSelectedFiles(0, 1)
   RegAction(0, "convertFormatUseMultiThreads",, 1)
   If (filesElected>1)
   {
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
            Continue

         imgPath := resultedFilesList[A_Index, 1]
         If (!RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && imgPath)
         {
            countNotJpegs++
            If !firstu
               firstu := A_Index
         }
         If (countNotJpegs>3)
            Break
      }
   }

   imgPath := resultedFilesList[currentFileIndex, 1]
   If (RegExMatch(imgPath, "i)(.\.(jpg|jpeg))$") && countNotJpegs<2)
   {
      hasExec := 1
      jpegDesiredOperation := actu
      BtnPerformJpegOp("extern")
   }

   If (countNotJpegs=1 && firstu)
   {
      hasExec := 0
      currentFileIndex := firstu
   }

   If (hasExec!=1)
   {
      ResizeMustPerform := 0 
      SimpleOperationsFlipV := (actu=3) ? 1 : 0
      SimpleOperationsFlipH := (actu=2) ? 1 : 0
      SimpleOperationsDoCrop := (actu=9) ? 1 : 0
      SimpleOperationsRotateAngle := 1
      If (actu=6)  ; 90 degrees rotation
         SimpleOperationsRotateAngle := 2
      Else If (actu=8) ; -90 degrees rotation 
         SimpleOperationsRotateAngle := 4

      SimpleOperationsScaleXimgFactor := 100
      SimpleOperationsScaleYimgFactor := 100
      ResizeQualityHigh := ResizeInPercentage := 1
      ResizeUseDestDir := 0
      cleanResizeUserOptionsVars()
      BtnPerformSimpleProcessing("no-prompt", "extern")
   }
}

BTNsaveResizedIMG() {
    Gui, SettingsGUIA: Default
    GuiControlGet, ResultEditWidth
    GuiControlGet, ResultEditHeight
    GuiControlGet, userEditWidth
    GuiControlGet, userEditHeight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResizeApplyEffects
    GuiControlGet, ResizeCropAfterRotation
    GuiControlGet, ResizeDestFolder
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, ResizeQualityHigh
    GuiControlGet, ResizeUseDestDir
    GuiControlGet, ResizeWithCrop
    GuiControlGet, userActionAdvImgProcConflictingFile

    EditResizeWidth()
    cleanResizeUserOptionsVars()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       GuiControlGet, userDesireWriteFMT
       GuiControlGet, userUnsprtWriteFMT
       rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
       If (!RegExMatch(rDesireWriteFMT, "i)(bmp|png|tiff|tif|gif|jpg|jpeg)$") && wasInitFIMlib!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The ." rDesireWriteFMT " format is currently unsupported. The FreeImage library failed to properly initialize.", 0, 0, "error")
          Return
       }

       WriteSettingsResizePanel()
       If (ResizeUseDestDir=1)
          RegAction(1, "ResizeDestFolder")

       batchAdvIMGresizer(userEditWidth, userEditHeight, ResizeInPercentage)
       Return
    }

   If (!ResultEditHeight || !ResultEditWidth || ResultEditWidth<5 || ResultEditHeight<5)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. The values must be increased.", 0, 0, "error")
      Return
   }

   zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutFileNameNoExt, fileEXT)
   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileNameNoExt : OutDir "\" OutFileNameNoExt
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   getSaveDialogIndexForFile(img2resizePath, defFMTindex)
   file2save := openFileDialogWrapper("S", "PathMustExist", startPath, "Save processed image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)
   If file2save
   {
      zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
      {
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]
         nExt := dialogSaveIndexes[dialogFmtIndex]
      }

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      zPlitPath(file2save, 0, OutFileName, OutDir)
      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      z := advImgResizerCalcIMGsize(img2resizePath, file2save, userEditWidth, userEditHeight, newW, newH, imgW, imgH, givenAngle)
      If z
         Return

      If FileExist(file2save)
      {
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      showTOOLtip("Processing and saving image file...`n" newW " x " newH " pixels`n" OutFileName)
      destroyGDIfileCache()
      SetTimer, WriteSettingsResizePanel, -90
      GuiControl, SettingsGUIA: Disable, btn1
      GuiControl, SettingsGUIA: Disable, btn2
      r := coreResizeIMG(img2resizePath, newW, newH, file2save, 0, 0, givenAngle, 1, imgW, imgH)
      If r
      {
         SetTimer, ResetImgLoadStatus, -300
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Unable to save file... Unknown error.`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      GuiControl, SettingsGUIA: Enable, btn1
      GuiControl, SettingsGUIA: Enable, btn2
      resultedFilesList[currentFileIndex, 4] := 1
      If (SLDtypeLoaded=3)
         selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

      SoundBeep, 900, 100
      showTOOLtip("Processed image saved`n" OutFileName "`n`n" OutDir "\")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -300
   }
}

BtnCopy2ClipResizedIMG() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResultEditWidth
   GuiControlGet, ResultEditHeight
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeQualityHigh
   GuiControlGet, ResizeApplyEffects
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation
   GuiControlGet, userActionAdvImgProcConflictingFile

   EditResizeWidth()
   cleanResizeUserOptionsVars()
   z := advImgResizerCalcIMGsize(img2resizePath, "clipboard", userEditWidth, userEditHeight, newW, newH, imgW, imgH, givenAngle)
   If z
      Return

   showTOOLtip("Processing image, please wait")
   r := coreResizeIMG(img2resizePath, newW, newH, "--", 0, 1, givenAngle, 1, imgW, imgH)
   SoundBeep, % r ? 300 : 900, 100
   ToolTip
   If !r
      showTOOLtip("Processed image copied to clipboard")
   Else 
      msgBoxWrapper(appTitle ": ERROR", "Unable to copy the processed image to the clipboard.`nError code: " r, 0, 0, "error")

   SetTimer, RemoveTooltip, % -msgDisplayTime//3
   ResetImgLoadStatus()
   SetTimer, ResetImgLoadStatus, -250
}

advImgResizerCalcIMGsize(imgPath, file2save, w, h, ByRef newW, ByRef newH, ByRef imgW, ByRef imgH, ByRef givenAngle) {
   If (img2resizePath=getIDimage(currentFileIndex))
      r1 := GetImgFileDimension(getIDimage(currentFileIndex), imgW, imgH, 1, currentFileIndex)
   Else
      GetImgFileDimension(imgPath, imgW, imgH, 0)

   If (!imgW || !imgH)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Failed to retrieve file and image information for:`n`n" imgPath, 0, 0, "error")
      Return 1
   }

   givenAngle := (ResizeRotationUser>0) ? ResizeRotationUser : 360 + ResizeRotationUser
   If (givenAngle!=0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
      Gdip_GetRotatedDimensions(imgW, imgH, givenAngle, imgW, imgH)

   zPlitPath(file2save, 1, OutFileName, OutDir, OutFileNameNoExt, OutFileExt)
   z := calcNewImgDimensions(imgW, imgH, w, h, ResizeInPercentage, ResizeKeepAratio, newW, newH)
   ; pw := newW, ph := newH
   pw := newW, ph := newH
   If (z=-1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. The values must be increased.", 0, 0, "error")
      Return 1
   } Else If isImgSizeTooLarge(newW, newH, OutFileExt)
   {
      SoundBeep, 300, 100
      capIMGdimensionsFormatlimits(OutFileExt, ResizeKeepAratio, pw, ph)
      msgResult := msgBoxWrapper(appTitle ": WARNING", "The image dimensions exceed the limits of the " OutFileExt " image file format. They will be adjusted within the accepted limits.`n`nNew image dimensions: " pw " x " ph " pixels.", "&Continue|C&ancel", 1, "exclamation")
      If (msgResult!="Continue")
         Return 1
   } Else If (z=1)
   {
      SoundBeep, 300, 100
      capIMGdimensionsFormatlimits("gdip", ResizeKeepAratio, pw, ph)
      pfm := (file2save!="clipboard") ? "`n`nYou can try «Simple mode» for larger dimensions." : ""
      msgResult := msgBoxWrapper(appTitle ": WARNING", "The image dimensions exceed the limits of this tool. They will be adjusted within the accepted limits: 536 MPx, width and height less than 199000 pixels." pfm "`n`nNew image dimensions: " pw " x " ph " pixels.", "&Continue|C&ancel", 1, "exclamation")
      If (msgResult!="Continue")
         Return 1
   }

   newW := pw, newH := ph
}

EditResizeWidth() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   
   If (A_TickCount - lastEditRHChange < 200)
      Return

   If (AnyWindowOpen=4)
      cleanResizeUserOptionsVars()

   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRWChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditHeight, % Round(userEditWidth)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditWidth<1 || !userEditWidth)
      userEditWidth := 1

   If (AnyWindowOpen=73 || AnyWindowOpen=28)
      trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   Else If (img2resizePath=getIDimage(currentFileIndex))
      GetImgFileDimension(getIDimage(currentFileIndex), oImgW, oImgH, 1, currentFileIndex)
   Else
      GetImgFileDimension(img2resizePath, oImgW, oImgH)

   Global lastEditRWChange := A_TickCount
   Sleep, 5
   givenAngle := (ResizeRotationUser>0) ? ResizeRotationUser : 360 + ResizeRotationUser
   If (ResizeKeepAratio=1)
   {
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      calcIMGdimensions(oImgW, oImgH, thisWidth, 90000*oImgH, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newH/oimgH)*100) : newH
      GuiControl, SettingsGUIA:, userEditHeight, % Round(newValue)

      Gdip_GetRotatedDimensions(newW, newH, givenAngle, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, givenAngle, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }

   mpx := Round((Round(thisWidth) * Round(thisHeight))/1000000, 1)
   f := isImgSizeTooLarge(Round(thisWidth), Round(thisHeight)) ? "(!) " : ""
   GuiControl, SettingsGUIA: , infoline, %f%%mpx% MPx
}

EditResizeHeight() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage

   If (A_TickCount - lastEditRWChange < 200)
      Return

   If (AnyWindowOpen=4)
      cleanResizeUserOptionsVars()

   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRHChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditWidth, % Round(userEditHeight)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditHeight<1 || !userEditHeight)
      userEditHeight := 1

   If (AnyWindowOpen=28 || AnyWindowOpen=73)
      trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   Else If (img2resizePath=getIDimage(currentFileIndex))
      GetImgFileDimension(getIDimage(currentFileIndex), oImgW, oImgH, 1, currentFileIndex)
   Else
      GetImgFileDimension(img2resizePath, oImgW, oImgH)

   Global lastEditRHChange := A_TickCount
   Sleep, 5
   givenAngle := (ResizeRotationUser>0) ? ResizeRotationUser : 360 + ResizeRotationUser
   If (ResizeKeepAratio=1)
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      calcIMGdimensions(oImgW, oImgH, 90000*oImgW, thisHeight, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newW/oimgW)*100) : newW
      GuiControl, SettingsGUIA:, userEditWidth, % Round(newValue)
      Gdip_GetRotatedDimensions(newW, newH, givenAngle, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, givenAngle, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }
   mpx := Round((Round(thisWidth) * Round(thisHeight))/1000000, 1)
   f := isImgSizeTooLarge(Round(thisWidth), Round(thisHeight)) ? "(!) " : ""
   GuiControl, SettingsGUIA: , infoline, %f%%mpx% MPx
}

TglRszInPercentage() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<50)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
   If (AnyWindowOpen!=18)
   {
      filesElected := getSelectedFiles()
      If (filesElected>1)
      {
         oImgW := ResolutionWidth
         oImgH := ResolutionHeight
      } Else If (AnyWindowOpen=28 || AnyWindowOpen=73)
         trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
      Else
         GetImgFileDimension(getIDimage(currentFileIndex), oImgW, oImgH, 1, currentFileIndex)

      GuiControl, SettingsGUIA:, userEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
      GuiControl, SettingsGUIA:, userEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
      If (AnyWindowOpen=73)
         updateUIresizeImgEditPanel()
      Else If (filesElected<2)
         EditResizeWidth()
   } Else
   {
      If (thumbsDisplaying=1)
         GetImgFileDimension(getIDimage(currentFileIndex), oImgW, oImgH, 1, currentFileIndex)
      Else
         trGdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)

      GuiControl, SettingsGUIA:, SimpleOperationsScaleXimgFactor, % (ResizeInPercentage=1) ? 100 : oImgW
      GuiControl, SettingsGUIA:, SimpleOperationsScaleYimgFactor, % (ResizeInPercentage=1) ? 100 : oImgH
   }

   RegAction(1, "ResizeInPercentage")
   lastInvoked := A_TickCount
}

TglRszKeepAratio() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userEditWidth
   GuiControlGet, ResizeKeepAratio
   If (AnyWindowOpen=73)
      updateUIresizeImgEditPanel()
   Else If (!markedSelectFile || ResizeKeepAratio=1 && ResizeInPercentage=1)
      EditResizeWidth()

   RegAction(1, "ResizeKeepAratio")
}

TglRszUnsprtFrmt() {
   Gui, SettingsGUIA: Default
   GuiControlGet, userUnsprtWriteFMT
   GuiControlGet, userDesireWriteFMT
   actu := (userUnsprtWriteFMT>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, userDesireWriteFMT
   RegAction(1, "userDesireWriteFMT")
}

cleanResizeUserOptionsVars() {
    If (SimpleOperationsRotateAngle=2)
       simpleOpRotationAngle := 90
    Else If (SimpleOperationsRotateAngle=3)
       simpleOpRotationAngle := 180
    Else If (SimpleOperationsRotateAngle=4)
       simpleOpRotationAngle := 270
    Else
       simpleOpRotationAngle := 0
}

TglRszRotation() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeWithCrop
   cleanResizeUserOptionsVars()
   If (ResizeRotationUser!=0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation

   EditResizeWidth()
   RegAction(1, "ResizeWithCrop")
   RegAction(1, "ResizeRotationUser")
}

TglRszCropping() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation
   If (ResizeRotationUser!=0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation
   EditResizeWidth()
   RegAction(1, "ResizeWithCrop")
   RegAction(1, "ResizeCropAfterRotation")
}

TglRszDestFoldr() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeUseDestDir

   actu := ResizeUseDestDir ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   GuiControl, % actu, btnFldr
   GuiControl, % actu, ResizeDestFolder
   RegAction(1, "ResizeUseDestDir")
}

TglRszQualityHigh() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeQualityHigh
   RegAction(1, "ResizeQualityHigh")
}

TglRszApplyEffects() {
   Gui, SettingsGUIA: Default
   GuiControlGet, ResizeApplyEffects
   RegAction(1, "ResizeApplyEffects")
   If (ResizeApplyEffects=1)
   {
      infoMirroring := defineIMGmirroring()
      If (usrColorDepth>1)
         infoColorDepth := "`nSimulated color depth: " defineColorDepth()
      If (imgFxMode>1)
         infoColors := "`nColors display mode: " DefineFXmodes() " [" currIMGdetails.PixelFormat "]"
 
      entireString := infoMirroring infoColors infoColorDepth infoRenderOpaque
      entireString := (entireString) ?  "Effects currently activated: " entireString : "No effects currently activated."
      msgBoxWrapper(appTitle, entireString, 0, 0, "info")
   }
}

invokePanelStaticFoldersContextMenu() {
   isUpdateList := (RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? 1 : 0
   Try Menu, PanelStaticMenu, Delete
   Sleep, 2
   Try Menu, PVopenF, Delete

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetNext(0, "F")

   totalSelected := LV_GetCount("S")
   total := LV_GetCount()
   LV_GetText(indexu, RowNumber, 1)
   LV_GetText(changeState, RowNumber, 3)
   folderPath := newStaticFoldersListCache[indexu, 1]

   kMenu("PVopenF", "Add", "Open folder now", "BtnPanelManageFoldersActus")
   kMenu("PVopenF", "Add", "In Explorer`tF6", "BtnPanelManageFoldersExplorer")
   kMenu("PVopenF", "Add", "With a new QPV instance", "BtnPanelManageFoldersNewInstance")
   kMenu("PVopenF", "Add", "Folder properties (Explorer)", "BtnPanelManageFoldersProperties")
   If (folderPath && totalSelected)
   {
      kMenu("PanelStaticMenu", "Add", "&Jump to first indexed file in folder`tEnter", "BtnPanelStaticJumpFirst")
      kMenu("PanelStaticMenu", "Add", "&Rescan folder(s)`tF5", "BTNupdateSelectedStaticFolder")
      kMenu("PanelStaticMenu", "Add", "&Open folder", ":PVopenF")
      kMenu("PanelStaticMenu", "Add", "&Select files`tAlt+L-Click", "BTNselFilesStaticFolder")
      kMenu("PanelStaticMenu", "Add", "&Deselect files`tAlt+R-Click", "BTNunselFilesStaticFolder")
      kMenu("PanelStaticMenu", "Add", "&Erase files from the index`tDelete", "BTNremFilesStaticFolder")
      kMenu("PanelStaticMenu", "Add", "C&ut folder (Explorer mode)", "BTNcutCopyStaticFolders")
      kMenu("PanelStaticMenu", "Add", "C&opy folder (Explorer mode)", "BTNcutCopyStaticFolders")
      kMenu("PanelStaticMenu", "Add", "&Copy folder path(s) as text", "BTNcopyStaticFolderPath")
      kMenu("PanelStaticMenu", "Add/UnCheck", "&Set as the protected folder", "BtnPanelManageFoldersProtect")
      If (protectedFolderPath=folderPath && preventDeleteFromProtectedPath=1)
         kMenu("PanelStaticMenu", "Check", "&Set as the protected folder")

      If (isUpdateList=1 && InStr(changeState, "*"))
         kMenu("PanelStaticMenu", "Add", "&Ignore date change", "BTNignoreDateStaticFolder")
      If (SLDtypeLoaded!=3 && isUpdateList=1 && FileExist(CurrentSLD))
         kMenu("PanelStaticMenu", "Add", "Rename inde&x entry`tF2", "PanelRenameStaticFolder")

      kMenu("PanelStaticMenu", "Add", "&Filter files list to selected folder(s)`tF3", "MenuFilterListSelectedFolder")
   }

   Menu, PanelStaticMenu, Add,
   kMenu("PanelStaticMenu", "Add", "Re&generate this folders list", "regenerateStaticFoldersList")
   If (SLDtypeLoaded=3)
      kMenu("PanelStaticMenu", "Add", "&Count selected files", "SqlWrapPopulateStaticFolderzList")
   Else
      kMenu("PanelStaticMenu", "Add", "&Count files per folders", "countAllFilesPerStaticFolders")
   kMenu("PanelStaticMenu", "Add", "&Count files in folders found on disk", "countFilesDiskPerStaticFolders")
   kMenu("PanelStaticMenu", "Add", "&Copy entire list as text", "BTNcopyAllStaticFolderPaths")
   If markedSelectFile
      kMenu("PanelStaticMenu", "Add", "Deselect all (files &list)", "dropFilesSelection")

   If (total!=totalSelected)
      kMenu("PanelStaticMenu", "Add", "Select entire &table`tCtrl+A", "BTNreviewLVselAll")
   kMenu("PanelStaticMenu", "Add", "&View list as a folders tree", "BTNshowStaticFoldersInTreeView")
   Menu, PanelStaticMenu, Add
   kMenu("PanelStaticMenu", "Add", "Help`tF1", "BtnHelpStaticFoldersPanel")
   showThisMenu("PanelStaticMenu")
}

SqlWrapPopulateStaticFolderzList() {
   countAllFilesPerStaticFolders("start")
   PopulateStaticFolderzList()
}

invokePanelDynaFoldersContextMenu() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetNext()
   LV_GetText(folderPath, RowNumber, 3)
   LV_GetText(r, RowNumber, 2)
   totalSelected := LV_GetCount("S")
   Try Menu, PanelDynaMenu, Delete
   Sleep, 2
   Try Menu, PVopenF, Delete
   kMenu("PVopenF", "Add", "Open folder now", "BtnPanelManageFoldersActus")
   kMenu("PVopenF", "Add", "In Explorer`tF6", "BtnPanelManageFoldersExplorer")
   kMenu("PVopenF", "Add", "With a new QPV instance", "BtnPanelManageFoldersNewInstance")
   kMenu("PVopenF", "Add", "Folder properties (Explorer)", "BtnPanelManageFoldersProperties")

   If (folderPath && totalSelected)
   {
      kMenu("PanelDynaMenu", "Add", "&Jump to first indexed file in folder`tEnter", "BtnPanelStaticJumpFirst")
      kMenu("PanelDynaMenu", "Add", "&Rescan folder`tF5", "BTNrescanDynaFolder")
      kMenu("PanelDynaMenu", "Add/UnCheck", "&Recursive folder scan", "BtnToggleRecurseDynaFolder")
      If InStr(r, "R")
         kMenu("PanelDynaMenu", "Check", "&Recursive folder scan")

      Menu, PanelDynaMenu, Add
      kMenu("PanelDynaMenu", "Add", "&Open folder", ":PVopenF")
      kMenu("PanelDynaMenu", "Add", "&Select files`tAlt+L-Click", "BTNselFilesStaticFolder")
      kMenu("PanelDynaMenu", "Add", "&Deselect files`tAlt+R-Click", "BTNunselFilesStaticFolder")
      kMenu("PanelDynaMenu", "Add", "&Remove folder from this list`tDelete", "BTNremDynaSelFolder")
      kMenu("PanelDynaMenu", "Add", "Rename inde&x entry`tF2", "PanelRenameStaticFolder")
      kMenu("PanelDynaMenu", "Add/UnCheck", "Set as the &protected folder", "BtnPanelManageFoldersProtect")
      If (protectedFolderPath=folderPath && preventDeleteFromProtectedPath=1)
         kMenu("PanelDynaMenu", "Check", "Set as the &protected folder")

      kMenu("PanelDynaMenu", "Add", "&Copy this folder path as text", "BTNcopyStaticFolderPath")
      kMenu("PanelDynaMenu", "Add", "&Count indexed files in folder`tF11", "BTNcountFilesDynaFolders")
      kMenu("PanelDynaMenu", "Add", "&Count files in folder found on disk`tF10", "BTNcountFilesDiskDynaFolder")
      Menu, PanelDynaMenu, Add
      kMenu("PanelDynaMenu", "Add", "&Filter list to selected folder`tF3", "MenuFilterListSelectedFolder")
      If markedSelectFile
         kMenu("PanelDynaMenu", "Add/UnCheck", "Deselect all (files &list)", "dropFilesSelection")
   }

   kMenu("PanelDynaMenu", "Add", "&View list as a folders tree", "BTNshowDynamicFoldersInTreeView")
   showThisMenu("PanelDynaMenu")
}

invokePanelReviewSelContextMenu() {
   Try Menu, MenuRevSelFiles, Delete
   Sleep, 2
   Try Menu, PVopenF, Delete
   If (RegExMatch(CurrentSLD, sldsPattern) || InStr(CurrentSLD, "\qpv\favourite-images-list") || InStr(CurrentSLD, "\qpv\viewed-images-history"))
      kMenu("PVopenF", "Add", "Open folder now", "BtnReviewPaneOpenActs")

   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   GuiControlGet, editu, SettingsGUIA:, listViewReviewFilteru

   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderPath, RowNumber, 3)
   Gui, SettingsGUIA: ListView, % whichLV
   totalSelected := LV_GetCount("S")
   total := LV_GetCount()

   kMenu("PVopenF", "Add", "Open folder in &Explorer`tF6", "BtnReviewPaneOpenActs")
   kMenu("PVopenF", "Add", "Open image with a new &QPV instance", "BtnReviewPaneOpenActs")
   kMenu("PVopenF", "Add", "Open image with an e&xternal app", "BtnReviewPaneOpenActs")
   kMenu("PVopenF", "Add", "Folder &properties (Explorer)", "BtnReviewPaneOpenActs")

   Try Menu, PVcopy, Delete
   kMenu("PVcopy", "Add", "Copy f&older path(s) as text", "BTNreviewCopyDirs")
   kMenu("PVcopy", "Add", "Copy &file name(s) as text", "BTNreviewCopyNames")
   kMenu("PVcopy", "Add", "Copy &complete path(s) as text", "BTNreviewCopyPanel")
   Menu, PVcopy, Add, 
   kMenu("PVcopy", "Add", "Cop&y files (Explorer)", "BTNreviewCopyExplorer")
   kMenu("PVcopy", "Add", "Cu&t files (Explorer)", "BTNreviewCutExplorer")
   kMenu("PVcopy", "Add", "Co&py containing folders (Explorer)", "BTNreviewCopyFoldersExplorer")
   kMenu("PVcopy", "Add", "C&ut containing folders (Explorer)", "BTNreviewCutFoldersExplorer")


   If totalSelected
   {
      UIupdateReviewLVinView()
      kMenu("MenuRevSelFiles", "Add", "&Open", ":PVopenF")
      kMenu("MenuRevSelFiles", "Add", "&Copy", ":PVcopy")
      kMenu("MenuRevSelFiles", "Add", "&Select file(s) in index", "BTNreviewApplySelection")
      kMenu("MenuRevSelFiles", "Add", "&Deselect file(s) in index", "BTNreviewRemSelection")
      kMenu("MenuRevSelFiles", "Add", "Select files in &index in same folder", "BTNreviewSelFilesInPath")
      If markedSelectFile
      {
         kMenu("MenuRevSelFiles", "Add", "Deselect &listed items in index", "BTNreviewDropFilesSelection")
         kMenu("MenuRevSelFiles", "Add", "Deselect &all in index", "dropFilesSelection")
      }

      If (total!=totalSelected)
         kMenu("MenuRevSelFiles", "Add", "Select entire &table`tCtrl+A", "BTNreviewLVselAll")

      kMenu("MenuRevSelFiles", "Add/UnCheck", "&Filter table to selected path", "BTNreviewFilterLVSelPath")
      If (InStr(folderPath, editu) && OutputVar=1 && editu)
         kMenu("MenuRevSelFiles", "Check", "&Filter table to selected path")

      kMenu("MenuRevSelFiles", "Add", "Filter files &list to selected path`tF3", "BTNreviewFilterListSelPath")
      kMenu("MenuRevSelFiles", "Add", "Modify inde&x entry`tF2", "BtnReviewPaneOpenActs")
   } Else
   {
      kMenu("MenuRevSelFiles", "Add", "No files are selected in the list view", "dummy")
      kMenu("MenuRevSelFiles", "Disable", "No files are selected in the list view")
   }

   Menu, MenuRevSelFiles, Add
   kMenu("MenuRevSelFiles", "Add", "Help`tF1", "BtnHelpReviewPanel")
   showThisMenu("MenuRevSelFiles")
}

BtnHelpStaticFoldersPanel() {
   msgBoxWrapper(appTitle ": HELP", "This panel lists the folders where the indexed files are located; selected and total files are counted per folder. It is useful to:`n `n- update / rescan folders selectively, in order to avoid entire rescans`n `n- facilitate management of large amounts of files`n `n- identify folders with few or many files`n `n- identify per folder missing files, already seen images or favourited images [if these were selected using the appropiate tools before opening this panel]`n `nFolders marked with (*) are changed since the last scan, based on folder modified date. Right-click on listed entries for more options.`n `nWhen you choose to «Erase files from the index»», the files indexed pertaining to the selected folder will be removed ONLY from the index, NOT from the disk.`n`nThe folders can be filtered by selected files (:), percentage (*), files on disk (!), folder size ($), diff (#) or files indexed (?) by typing something like: *>200 or ?<300.", -1, 0, 0)
}

BtnHelpReviewPanel() {
   msgBoxWrapper(appTitle ": HELP", "This panel is meant to help in scenarios where automatically selected files must be filtered out, eg., select already seen images or favourited images. It offers options to help users manage and filter the selected files.", -1, 0, 0)
}

UIlvFilterEraseStaticPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, SettingsGUIA:, StaticListViewFilteru
   If (!OutputVar && !lastFilterEditSearch)
      Return

   lastFilterEditSearch := StaticListViewFilteru := ""
   GuiControl, SettingsGUIA:, StaticListViewFilteru, 
   SetTimer, UIfilterListViewStaticFolderzList, -50
}

PanelKeywordsDetector() {
    Global LViewOthers, listViewFilteru

    thisBtnHeight := createSettingsGUI(71, A_ThisFunc)
    btnWid := 115
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 95
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    totals := newStaticFoldersListCache.Count()
    btnWid2 := (PrefsLargeFonts=1) ? 160 : 95
    btnWid3 := (PrefsLargeFonts=1) ? btnWid + 40 : btnWid + 30
    btnWid4 := (PrefsLargeFonts=1) ? 70 : 60
    sml := (PrefsLargeFonts=1) ? 120 : 90
    CountFilesFolderzList := 0
    Gui, Add, Text, x15 y15 Section, This panel can help identify most used keywords in the indexed files list.
    hLVmainu := GuiAddListView("xs y+5 w" lstWid " +LV0x10000 +LV0x400 r" uLVr " Grid AltSubmit +multi guiLVkeywordsListResponder vLViewOthers", "Keywords|Files|`%|#", "Identified keywords")
    hEditField := GuiAddEdit("xs y+10 wp -multi -wantTab vkeywrdLVfilter", keywrdLVfilter, "Keywords string filter")

    sml := (PrefsLargeFonts=1) ? 70 : 55
    Gui, Add, Text, xs y+7 hp +0x200, Min. length:
    GuiAddEdit("x+5 w" sml " number -multi limit2 veditF5", minKeywordLength, "Minimum keyword length")
    Gui, Add, UpDown, vminKeywordLength Range3-25, % minKeywordLength

    Gui, Add, Text, x+10 hp +0x200, Min. files:
    GuiAddEdit("x+5 w" sml " number -multi limit3 veditF6", thresholdKeywords, "Minimum files per keyword")
    Gui, Add, UpDown, vthresholdKeywords Range2-987, % thresholdKeywords
    Gui, Add, Checkbox, x+10 hp Checked%LangKeywordsFilter% vLangKeywordsFilter, Dictionary filter (English)
    Gui, Add, Button, x+1 hp w%sml% Default gUIfilterListKeywords, &Apply
    GuiAddButton("x+1 hp w50 gUIremKeywordsFilter", "X", "Clear edit field")
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% gBtnUiKeywordsLister w%btnWid2% , &Generate list
    Gui, Add, Button, x+5 hp w80 gBtnCloseWindow, &Close
    Gui, Add, Text, x+7 hp +0x200 vtxtLine1, Keywords omitted: 987 129 millions gazillions

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Keywords list: " appTitle)
    PopulateKeywordsListPanel(keywrdLVfilter)
}

uiLVkeywordsListResponder(a,m_event,keyu) {
   If (m_event="RightClick")
   {
      Gui, SettingsGUIA: Default
      Gui, SettingsGUIA: ListView, LViewOthers
      If (LV_GetCount("S")>1 || keyu="enter")
         filterListByKeywords()
      Else
         invokePrefsPanelsContextMenu()
   } Else If (m_event="DoubleClick")
      filterListByKeywords()
}

filterListByKeywords() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetFirstSelected(hLVmainu)
   If !RowNumber
      RowNumber := LV_GetNext(0, "F")

   LV_GetText(keyword, RowNumber, 1)
   ; ToolTip, % folderu "=" colNum "=" RowNumber "=" whichLV , , , 2
   If StrLen(keyword)<3
      Return

   setImageLoading()
   listu := ""
   RowNumber := 0
   total := LV_GetCount()
   Loop, % total
   {
       RowNumber := LV_GetNext(RowNumber)
       If !RowNumber
          Break

       LV_GetText(keyword, RowNumber, 1)
       If !keyword
          Continue

       listu .= StrReplace(Trim(keyword), A_Space, "|") "|"
   }

   listu := StrReplace(Trim(listu, "|"), "||", "|")
   If !listu
      Return

   BtnCloseWindow()
   userFilterStringPos := userFilterWhat := 1
   UsrEditFilter := listu
   userFilterProperty := userFilterDoString := 1
   userFilterInvertThis := userFilterStringIsNot := 0
   thisFilter := updateUIFiltersPanel("external")
   coreEnableFiltru(thisFilter)
   dummyTimerDelayiedImageDisplay(50)
   ; ToolTip, % listu  , , , 2
}

UIremKeywordsFilter() {
   Gui, SettingsGUIA: Default
   keywrdLVfilter := ""
   minKeywordLength := 3
   thresholdKeywords := 2
   LangKeywordsFilter := 0
   GuiControl, SettingsGUIA:, keywrdLVfilter,  % keywrdLVfilter
   GuiControl, SettingsGUIA:, thresholdKeywords,  % thresholdKeywords
   GuiControl, SettingsGUIA:, minKeywordLength,  % minKeywordLength
   GuiControl, SettingsGUIA:, LangKeywordsFilter,  % LangKeywordsFilter
   PopulateKeywordsListPanel(0)
}

UIfilterListKeywords() {
   If (AnyWindowOpen!=71)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, keywrdLVfilter
   If (imageLoading=1)
      Return

   PopulateKeywordsListPanel(keywrdLVfilter)
}

BtnUiKeywordsLister() {
   EM_SETCUEBANNER(hEditField, "Generating keywords list - please wait", 1)
   GenerateKeywordsListNow()
   PopulateKeywordsListPanel()
}

PopulateKeywordsListPanel(listFilter:=0) {
  Static dictionary := [], prevLang := 0

  Gui, SettingsGUIA: Default
  Gui, SettingsGUIA: ListView, LViewOthers
  GuiControlGet, thresholdKeywords
  GuiControlGet, minKeywordLength
  GuiControlGet, LangKeywordsFilter
  GuiControl, -Redraw, LViewOthers
  setImageLoading()
  showTOOLtip("Preparing the dictionary, please wait")
  If (LangKeywordsFilter=1 && prevLang!=LangKeywordsFilter)
  {
     ; i intended to add more languages/dictionaries
     dictionary := new hashtable()
     prevLang := LangKeywordsFilter
     FileRead, dictum, % mainExecPath "\resources\dict-eng.txt"
     Loop, Parse, dictum, `n,`r
     {
        If A_LoopField
           dictionary[A_LoopField] := 1
     }
  }

  showTOOLtip("Populating the list view, please wait")
  EM_SETCUEBANNER(hEditField, "Preparing keywords list - please wait", 1)
  LV_Delete()
  LV_ModifyCol(2, "Integer")
  LV_ModifyCol(3, "Integer")
  LV_ModifyCol(4, "Integer")

  thisString := StrReplace(Trimmer(listFilter), "||", "|")
  thisString := Trimmer(thisString, "|")
  thisFilter := "i)(" JEE_StrRegExLiteral(thisString) ")"
  isStrFilter := StrLen(thisString)>1 ? 1 : 0
  FilterSimple := (InStr(thisString, "|") || InStr(thisString, "*") || InStr(thisString, "?")) ? 0 : 1
  rowsCounter := counter := skippedFiles := wordSkipped := 0
  maxu := StrLen(filesFilter)>1 ? bckpMaxFilesIndex : maxFilesIndex
  newArrayu := []
  doStartLongOpDance()
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  thisMaxCount := keywordsListArray.Count()
  For Key, Value in keywordsListArray
  {
     executingCanceableOperation := A_TickCount
     If (determineTerminateOperation()=1)
     {
        abandonAll := 1
        Break
     }
 
     If (A_TickCount - prevMSGdisplay>1000)
     {
        etaTime := ETAinfos(A_Index, thisMaxCount, startOperation)
        showTOOLtip("Filtering the keywords list, please wait" etaTime, 0, 0, A_Index/thisMaxCount)
        prevMSGdisplay := A_TickCount
     }
 
     If (Value>=thresholdKeywords && !isInRange(Value, maxFilesIndex - 1, maxFilesIndex) && StrLen(Key)>=minKeywordLength)
     {
        If (isStrFilter=1 && FilterSimple=1)
        {
           If !inStr(Key, thisString)
           {
              wordSkipped++
              skippedFiles += Value
              Continue
           }
        } Else If (isStrFilter=1)
        {
           If !RegExMatch(Key, thisFilter)
           {
              wordSkipped++
              skippedFiles += Value
              Continue
           }
        }

        If (LangKeywordsFilter=1)
        {
           doXtra := StrLen(key)
           If !dictionary[Key]
           {
              If (doXtra>4)
              {
                 isOkay := 1
                 a := SubStr(key, 1, doXtra - 1)
                 b := SubStr(key, 2, doXtra - 1)
                 c := SubStr(key, 2)
                 If (!dictionary[a] && !dictionary[b] && !dictionary[c])
                    isOkay := 0

                 If (doXtra>7 && isOkay=1)
                 {
                    a := SubStr(key, doXtra//2)
                    b := SubStr(key, 1, doXtra//2)
                    If (!dictionary[a] && !dictionary[b])
                       isOkay := 0
                 } Else isOkay := 0
              } Else isOkay := 0

              If !isOkay
              {
                 wordSkipped++
                 skippedFiles += Value
                 Continue
              }
           }
        }

        counter++
        thisKey := (userPrivateMode=1) ? "*****" : Key
        perc := Value ? Round((Round(Value)/maxu)*100, 1) : 0
        If (!newArrayu[Value, 1] || newArrayu[Value, 3]>5 || mergeKeywordRows!=1)
        {
           rowsCounter++
           newArrayu[Value] := [rowsCounter, thisKey, 1]
           LV_Add(A_Index, thisKey, Value, perc, A_Index)
        } Else
        {
           newArrayu[Value, 2] := newArrayu[Value, 2] A_Space thisKey
           newArrayu[Value, 3] := newArrayu[Value, 3] + 1
           LV_Modify(newArrayu[Value, 1], "Col1", newArrayu[Value, 2])
        }
     } Else
     {
        wordSkipped++
        skippedFiles += Value
     }
  }

  Loop, 4
      LV_ModifyCol(A_Index, "AutoHdr Left")

  fperc := Round((skippedFiles/maxu)*100, 1)
  wperc := Round((wordSkipped/keywordsListArray.Count())*100, 1)
  GuiControl, SettingsGUIA:, txtLine1, % "Keywords omitted: " groupDigits(wordSkipped) " ( " wperc "% )"
  LV_ModifyCol(2, "SortDesc")
  EM_SETCUEBANNER(hEditField, "Type a string here to filter the keywords list. " groupDigits(counter) " keywords are listed", 1)
  GuiControl, +Redraw, LViewOthers
  ResetImgLoadStatus()
  RemoveTooltip()
}

GenerateKeywordsListNow() {
   ; keywordsListArray := ""
   keywordsListArray := new hashtable()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   Loop, % maxFilesIndex + 1
   {
        thisIndexu := A_Index
        imgPath := resultedFilesList[A_Index, 1]
        If (InStr(imgPath, "||") || !imgPath)
           Continue

        changeMcursor()
        OutDir := Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, ".", 0, -1) - 1))
        OutDir := RegExReplace(OutDir, "[[:digit:]]", A_Space)
        OutDir := RegExReplace(OutDir, "[[:punct:]]", A_Space)
        OutDir := RegExReplace(OutDir, "[[:blank:]]", A_Space)
        OutDir := StrReplace(OutDir, "  ", A_Space)
        thisArray := StrSplit(OutDir, A_Space)
        Loop, % thisArray.Count()
        {
           thisu := thisArray[A_Index]
           If (StrLen(thisu)<3)
              Continue

           keywordsListArray[thisu] := Round(keywordsListArray[thisu]) + 1
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
           showTOOLtip("Generating folders list based on the indexed files" etaTime, 0, 0, A_Index/maxFilesIndex)
           prevMSGdisplay := A_TickCount
        }
   }

   ResetImgLoadStatus()
   RemoveTooltip()
}

PanelStaticFolderzManager() {
    Global LViewOthers, listViewFilteru
    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    isUpdateList := (FileExist(CurrentSLD) && RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? 1 : 0
    thisBtnHeight := createSettingsGUI(2, A_ThisFunc)
    btnWid := 115
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 95
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    totals := newStaticFoldersListCache.Count()
    btnWid2 := (PrefsLargeFonts=1) ? 160 : 95
    btnWid3 := (PrefsLargeFonts=1) ? btnWid + 40 : btnWid + 30
    btnWid4 := (PrefsLargeFonts=1) ? 70 : 60
    sml := (PrefsLargeFonts=1) ? 120 : 90
    CountFilesFolderzList := 0
    Gui, Add, Text, x15 y15, This folders list was generated based on the indexed files. Multiple items can be selected.
    hLVmainu := GuiAddListView("+LV0x10000 +LV0x400 r" uLVr " Grid xp y+10 w" lstWid " +multi AltSubmit Count" totals " guiLVfolderzFilterListBTN vLViewOthers", "#|Date|(?)|Folder path|Files|Selected|`%|Files on disk|Difference|Size (MB)", "Referenced folders")
    hEditField := GuiAddEdit("xs y+10 wp-" sml " -multi -wantTab gUIeditsGenericAllowCtrlBksp vStaticListViewFilteru", staticListViewFilteru, "Folders string filter")

    sml := (PrefsLargeFonts=1) ? 90 : 60
    Gui, Add, Button, x+1 hp w%sml% gUIeditApplyStaticFolderFilter Default, &Apply
    GuiAddButton("x+1 hp w45 gUIlvFilterEraseStaticPanel", "X", "Clear edit field")
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid2% gBTNupdateSelectedStaticFolder, &Rescan folder(s)

    If isUpdateList
       Gui, Add, Button, x+5 hp w%btnWid% gBTNignoreDateStaticFolder, I&gnore all changes
    Gui, Add, Button, x+5 hp w%btnWid3% gRegenerateEntireList, R&egenerate entire index
    Gui, Add, Button, x+5 hp w%btnWid4% ginvokePanelStaticFoldersContextMenu, &More
    labelu := isUpdateList ? "Cached folders list: " : "Static folders list: "
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, labelu appTitle)
    Sleep, 25
    thisList := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
    If (newStaticFoldersListCache.Count()>0 && markedSelectFile>1 && thisList!=iduStaticFoldersListCache)
       countAllFilesPerStaticFolders("start")
    PopulateStaticFolderzList(staticListViewFilteru, "init")
}

identifyLastUndoFileAct(ByRef filesListArray, simpleMode) {
   typu := "None"
   thisIndex := zeitung := 0
   totalu := fileActsHistoryArray.Count()
   filesListArray := []
   deduper := new hashtable()
   Loop, % totalu + 2
   {
      zIndex := totalu - A_Index + 1
      Value := fileActsHistoryArray[zIndex]
      If !Value
         Continue

      kp := StrSplit(Value, "|")
      imgPath := kp[1]
      If !zeitung
      {
         zeitung := kp[2]
         initialu := StrReplace(kp[3], "?")
         initialu := StrReplace(initialu, "*")
         If (initialu!=imgPath)
         {
            If (kp[3]="recycle-bin")
            {
               typu := "Delete"
            } Else If InStr(kp[3], "?")
            {
               typu := "Copy"
            } Else
            {
               fi := SubStr(initialu, 1, InStr(initialu, "\", 0, -1) - 1)
               fd := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
               typu := (fi=fd) ? "Rename" : "Move"
            }
         } Else typu := "None"
      }

      If (zeitung=kp[2])
      {
         zs := Format("{:L}", imgPath)
         If (deduper[zs]>0)
            Continue

         thisIndex++
         If (simpleMode=0)
            filesListArray[thisIndex] := [imgPath, 0]
         deduper[zs] := thisIndex
      }
   }

   If !thisIndex
   {
      fileActsHistoryArray := ""
      fileActsHistoryArray := new hashtable()
   }

   If (simpleMode=0 && thisIndex>1)
   {
      Loop, % maxFilesIndex
      {
          If (!resultedFilesList[A_Index, 2] || !resultedFilesList[A_Index, 1])
             Continue ; if file not selected, skip

          imgPath := Format("{:L}", StrReplace(resultedFilesList[A_Index, 1], "|"))
          If (iu := deduper[imgPath])
             filesListArray[iu, 2] := A_Index
             ; fnOutputDebug(A_ThisFunc ": " iu " = " A_Index)
      }
   }

   deduper := ""
   Return [typu, thisIndex, zeitung]
}

PanelMultiUndoFileActs() {
    Global mainBtnACT
    filesElected := getSelectedFiles(0, 1)
    If !(thisBtnHeight := createSettingsGUI(88, A_ThisFunc, 1))
       Return

    btnWid := 110
    txtWid := slideWid := 280
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 100
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    blah := []
    obj := identifyLastUndoFileAct(blah, 1)
    friendly := Format("{:U}", obj[1]) ". " groupDigits(obj[2]) " files."
    RegAction(0, "userUndoMustDoOverwrite",, 2, 1, 4)
    RegAction(0, "userUndoDeleteNonIdenticalCopy",, 1)
    RegAction(0, "userUndoRecoverOverwritten",, 1)

    thisW := (PrefsLargeFonts=1) ? 190 : 120
    Gui, Add, Text, x15 y15 Section, Please choose what operations to perform and set the auxiliary conditions:
    GuiAddDropDownList("wp+20 y+10 Section AltSubmit Choose" UserUndoMultiDesiredOperation " vUserUndoMultiDesiredOperation", "Undo last action(s) (chronologically): " friendly " |Undo actions for the selection: " groupDigits(filesElected) " files")
    ; Gui, Add, Checkbox, xs y+15 Checked%userUndoMustDoOverwrite% vuserUndoMustDoOverwrite, Overwrite files on conflicts
    Gui, Add, Checkbox, xs y+15 Checked%userUndoRecoverOverwritten% vuserUndoRecoverOverwritten, Attempt to recover previously overwritten files
    Gui, Add, Checkbox, xs y+15 Checked%userUndoDeleteNonIdenticalCopy% vuserUndoDeleteNonIdenticalCopy, Delete non-identical copies (undo copy action)
    Gui, Add, Text, xs y+15 +hwndhTempu +0x200 +BackgroundTrans, On file name conflicts:
    zh := GuiAddDropDownList("x+10 w" thisW " AltSubmit Choose" userUndoMustDoOverwrite " vuserUndoMustDoOverwrite", "Skip files|Auto-rename|Overwrite|Ask user", [hTempu])

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gBtnDoMultiUndoFileActs, &Perform operation
    Gui, Add, Button, x+5 hp wp+15 gBtnUndoSingleFileAct, &Undo for active file only

    sml := (PrefsLargeFonts=1) ? 80 : 60
    Gui, Add, Button, x+5 hp w%sml% gBtnHelpMultiUndoFiles, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Undo multiple file actions: " appTitle)
}

BtnUndoSingleFileAct() {
   If AnyWindowOpen
   {
      BtnCloseWindow()
      Sleep, 100
   }
   corefileUndoAction(currentFileIndex)
}

BtnDoMultiUndoFileActs() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: Submit, NoHide
    isOkay := (markedSelectFile>1) ? 1 : 0
    If (UserUndoMultiDesiredOperation=2 && isOkay=0)
    {
       showTOOLtip("WARNING: There are no files selected. Use the other drop-down option`nor the «Undo for active file» button option.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    RegAction(1, "userUndoMustDoOverwrite")
    RegAction(1, "userUndoDeleteNonIdenticalCopy")
    RegAction(1, "userUndoRecoverOverwritten")
    BtnCloseWindow()
    modus := (UserUndoMultiDesiredOperation=2) ? "sel" : "last"
    batchUndoFileActs(modus)
}

doUndoFileActsChronos() {
    If AnyWindowOpen
       Return

    blah := []
    obj := identifyLastUndoFileAct(blah, 1)
    If (!obj[2] || obj[2]=1)
    {
       batchUndoFileActs("last")
    } Else
    {
       UserUndoMultiDesiredOperation := 1
       PanelMultiUndoFileActs()
    }
}

PanelFileUndoHistory() {
    thisBtnHeight := createSettingsGUI(87, A_ThisFunc)
    Global listViewUndoActsFilteru
    btnWid := 65
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 30
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    listViewUndoActsFilteru := ""
    edithu := lstWid - btnWid - 35
    Gui, Add, Text, x15 y15 w%lstWid%, This panel lists the history of rename, move and/or copy file actions.
    hLVmainu := GuiAddListView("+LV0x10000 +LV0x400 +ReadOnly -Multi -WantF2 y+10 w" lstWid " AltSubmit Count" p " guiLVundoFileActsResponder r" uLVr " Grid vLViewOthers", "Type|Initial full path|Resulted path|Date and time|File overwritten|Safe to undo|#", "File actions history")
    hEditField := GuiAddEdit("xs y+10 w" edithu " -multi gUIeditsGenericAllowCtrlBksp vlistViewUndoActsFilteru", listViewUndoActsFilteru, "String filter")
    Gui, Add, Button, x+1 hp w%btnWid% gPopulateFileActsHistory, &Apply
    btnWid2 := (PrefsLargeFonts=1) ? 45 : 35
    GuiAddButton("x+1 hp w" btnWid2 " gUIstringEditFilterErase", "X", "Clear edit field")
    btnWid2 := (PrefsLargeFonts=1) ? 205 : 115
    Gui, Add, Button, xs+0 y+15 h%thisBtnHeight% w%btnWid2% gBTNundoFileActu, &Undo selected action
    Gui, Add, Button, x+5 hp wp gBTNhistoFileActsList, &See all as files list
    Gui, Add, Button, x+5 hp wp-20 gBTNclearFilesUndoHisto, &Clear history
    Gui, Add, Button, x+5 hp w%btnWid% gBtnHelpUndoFiles, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&lose
    Gui, Add, Text, xs y+10 vinfoLine w%lstWid% +0x200, Listing items`, please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Files actions history: " appTitle)
    Sleep, 5
    SetTimer, PopulateFileActsHistory, -100
}

undoFileActUpdateIMGindex(givenPath) {
   givenPath := Format("{:L}", givenPath)
   z := fileActsHistoryArray[givenPath]
   fileActsHistoryArray[givenPath] := ""
   fileActsHistoryArray[z] := ""
   totalu := fileActsHistoryArray.Count()
   Loop, % totalu + 2
   {
      thisIndex := totalu - A_Index + 1
      Value := fileActsHistoryArray[thisIndex]
      If !Value
         Continue

      imgPath := SubStr(Value, 1, InStr(Value, "|") - 1)
      If (imgPath!=givenPath)
         Continue

      fileActsHistoryArray[givenPath] := thisIndex
   }
}

BTNhistoFileActsList() {
   thisIndex := 0
   tempus := new hashtable()
   newFilesList := []
   For Key, Value in fileActsHistoryArray
   {
      If (!Value || !isNumber(Key))
         Continue

      Val := fileActsHistoryArray[Key]
      imgPath := SubStr(Val, 1, InStr(Val, "|") - 1)
      If (tempus[imgPath]=1)
         Continue

      thisIndex++
      newFilesList[thisIndex] := [imgPath]
      tempus[imgPath] := 1
   }

   tempus := ""
   If (thisIndex<2)
   {
      showTOOLtip("WARNING: Insufficient undo entries recorded.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
 
   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   If askAboutSlidesListSave()
      Return

   If askAboutFilesSelect("discard it")
      Return

   BtnCloseWindow()
   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := "\QPV\file-acts-history.SLD"
   resultedFilesList := newFilesList.Clone()
   newFilesList := ""
   SLDtypeLoaded := 2
   currentFilesListModified := 0
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   RandomPicture()
}

BTNundoFileActu() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetFirstSelected(hLVmainu)
   If !RowNumber
      RowNumber := LV_GetNext(0, "F")

   LV_GetText(indexu, RowNumber, 7)
   If indexu
      Value := fileActsHistoryArray[indexu]

   If !Value
   {
      If indexu
         showTOOLtip("WARNING: This action is already undone.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }
   ; ToolTip, % indexu "|" value , , , 2
   corefileUndoAction(0, 0, indexu)
   SetTimer, PopulateFileActsHistory, -50
}

BtnHelpUndoFiles() {
   msgBoxWrapper(appTitle ": HELP", "In this panel, users can see at a glance the history of file actions performed in QPV and what can be undone.`n`nFile overwritten column indicates if the action lead to a file being overwritten. For example, the user moved the file X.jpg from A to B. In folder B, a file with the same name already existed and it was overwritten. These files can be recovered upon undo by QPV.`n`nSafe to restore column indicates if the undo action can be performed and if it will somehow lead to file conflicts.`n`nThrough this panel only one action at a time can be performed. To undo in batch select the files in the main window and/or use «See all as a files list».", -1, 0, 0)
}

BtnHelpMultiUndoFiles() {
   msgBoxWrapper(appTitle ": HELP", "When the option «Attempt to recover previously overwritten files» is activated, QPV will attempt to restore the original file from Recycle Bin. For example, the user moved the file X.jpg from A to B. In folder B, a file with the same name already existed and it was overwritten. This is the file that will be recovered if it is still available in the Recycle Bin.`n`nWhen QPV performs undo for copy, the copies are deleted. However, if the copies are no longer identical in size and/or modified date with the original files, QPV will not delete these. To ensure the copies are deleted even if they are not identical, activate «Delete non-identical copies».", -1, 0, 0)
}

BTNclearFilesUndoHisto() {
   fileActsHistoryArray := ""
   fileActsHistoryArray := new hashtable()
   SetTimer, PopulateFileActsHistory, -50
}

uiLVundoFileActsResponder(a:=0, b:=0, c:=0) {
   If (b="K" && c=112) ; F1
   {
      BtnHelpUndoFiles()
      Return
   } Else If (b="K" && c=116) ; F5
   {
      SetTimer, PopulateFileActsHistory, -100
      Return
   } Else If (b!="DoubleClick")
      Return

   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_GetFirstSelected(hLVmainu)
   If !RowNumber
      RowNumber := LV_GetNext(0, "F")

   LV_GetText(imgPath, RowNumber, 2)
   LV_GetText(indexu, RowNumber, 7)
   If !RegExMatch(imgPath, "^(.\:\\.)")
      Return

   If GetKeyState("Ctrl", "P")
   {
      If indexu
         Value := fileActsHistoryArray[indexu]
      If Value
         corefileUndoAction(0, 0, indexu)
      Return
   }

   imgPath := Format("{:L}", imgPath)
   ob := friendlyFileUndoInfos(0, 1, indexu)
   If IsObject(ob)
      undoInfos := "Undo file action: " ob.typu "`n" ob.word " path: " PathCompact(ob.initialu, 40) "`nHas overwritten: " ob.ovr "`nSafe to undo: " ob.restora "`nDate: " ob.date

   thisSize := (PrefsLargeFonts=1) ? LargeUIfontValue : Round(LargeUIfontValue*0.7)
   mouseCreateOSDinfoLine(undoInfos, thisSize)
}

PopulateFileActsHistory() {
    Static initTotals := 0, lastSearch := 0, listedEntries := 0
    If (AnyWindowOpen!=87)
       Return

    Tooltip
    Gui, SettingsGUIA: Default
    GuiControlGet, listViewUndoActsFilteru
    thisString := StrReplace(Trimmer(listViewUndoActsFilteru), "||", "|")
    thisString := Trimmer(thisString, "|")
    thisFilter := processSearchIndexString(thisString)
    isStrFilter := StrLen(thisString)>1 ? 1 : 0
    FilterSimple := (InStr(thisString, "|") || InStr(thisString, "/") || InStr(thisString, ">") || InStr(thisString, "?")) ? 0 : 1

    whichLV := "LViewOthers"
    Gui, SettingsGUIA: ListView, % whichLV
    doStartLongOpDance()
    LV_Delete()
    LV_ModifyCol(3, "Integer")
    LV_ModifyCol(6, "Integer")
    GuiControl, SettingsGUIA:, infoLine, Listing items`, please wait...
    GuiControl, -Redraw, % whichLV
    EM_SETCUEBANNER(hEditField, "Populating the list view - please wait", 1)
    prevMSGdisplay := A_TickCount
    startOperation := A_TickCount
    totalSelected := fileActsHistoryArray.Count()
    realTotal := 0
    Loop, % totalSelected + 2
    {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }
        
        thisIndex := totalSelected - A_Index + 1
        Value := fileActsHistoryArray[thisIndex]
        If !Value
           Continue

        stringItem := Value
        realTotal++
        ; stringItem := keyu "®" value
        If (isStrFilter=1 && FilterSimple=1)
        {
           If !InStr(stringItem, thisString)
              Continue
        } Else If (isStrFilter=1)
        {
           If !coreSearchIndex(stringItem, thisFilter, 1, 0)
              Continue
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, totalSelected, startOperation)
           showTOOLtip("Populating list view, please wait" etaTime, 0, 0, A_Index/totalSelected)
           prevMSGdisplay := A_TickCount
        }

        o := friendlyFileUndoInfos(0, 1, thisIndex)
        za := o.initialu, zb := o.keyu
        If (za="recycle-bin" || o.typu="copy")
           flipVars(za, zb)
    
        LV_Add(A_Index, o.typu, za, zb, o.date, o.ovr, o.restora, thisIndex)
        If (A_Index=5 || A_Index=10)
        {
           Loop, 7
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }

    Loop, 7
        LV_ModifyCol(A_Index, "AutoHdr Left")

    GuiControl, +Redraw, % whichLV
    If !isStrFilter
       GuiControl, SettingsGUIA:, infoLine, % "Entries listed: " groupDigits(LV_GetCount())
    Else
       GuiControl, SettingsGUIA:, infoLine, % "Filtered table: " groupDigits(LV_GetCount()) " / " groupDigits(realTotal)

    RemoveTooltip()
    SetTimer, ResetImgLoadStatus, -100
    EM_SETCUEBANNER(hEditField, "Filter files list", 1)
}

fileUndoAction(indexu, givenPath:="", undoHistoIndex:="") {
   If !markedSelectFile
   {
      r := corefileUndoAction(indexu, givenPath, undoHistoIndex)
   } Else
   {
      UserUndoMultiDesiredOperation := 2
      PanelMultiUndoFileActs()
   }
}

corefileUndoAction(indexu, givenPath:="", undoHistoIndex:="") {
   Critical, on
   If (undoHistoIndex>0)
   {
      obj := friendlyFileUndoInfos(0, 0, undoHistoIndex)
      Value := fileActsHistoryArray[undoHistoIndex]
      imgPath := Trim(SubStr(Value, 1, InStr(Value, "|") - 1))
   } Else
   {
      imgPath := givenPath ? StrReplace(givenPath, "|") : StrReplace(getIDimage(indexu), "|")
      If imgPath
         obj := friendlyFileUndoInfos(imgPath, 0)
   }

   If (!imgPath || !IsObject(obj) || obj.typu="none")
   {
      ; SoundBeep 300, 100
      Return
   }

   If askAboutFileSave(" and the undo " obj.typu " action for the selected file will be performed")
      Return

   If (givenPath && !indexu)
   {
      indexu := detectFileID(givenPath, 1)
   } Else If !indexu
   {
      zp := (obj.typu="delete") ? "||" imgPath : imgPath
      indexu := detectFileID(zp, 1)
   }

   If (obj.typu="delete")
   {
      setImageLoading()
      zPlitPath(imgPath, 1, OutFileName, OutDir, extname)
      showTOOLtip("Searching for the selected file in Recycle Bin, please wait...`n" OutFileName "`n" OutDir "\`nFile size: " fileSizeFriendly(obj.fsize))
      r := restoreFileFromRecycleBin(imgPath, obj.fsize)
      ResetImgLoadStatus()
      If (r=1)
         showTOOLtip("Undo DELETE file action. File succesfully recovered:`n" OutFileName "`n" OutDir "\")
      Else If (r=0)
         showTOOLtip("ERROR: Undo DELETE action failed. File not found in Recycle Bin.`nUnable to recover:`n" OutFileName "`n" OutDir "\")
      Else If (r=-1)
         showTOOLtip("ERROR: Undo DELETE action failed. File found in Recycle Bin, but unable to restore.`n" OutFileName "`n" OutDir "\")
      Else If (r=-1)
         showTOOLtip("ERROR: Undo DELETE action failed. Unable to probe the Recycle Bin contents.")
      Else
         showTOOLtip("ERROR: Undo DELETE action failed. An undefined error occured.")

      If (r=1)
      {
         undoFileActUpdateIMGindex(imgPath)
         If (indexu>0)
         {
            resultedFilesList[indexu, 1] := imgPath
            resultedFilesList[indexu, 4] := 1
         }
         ForceRefreshNowThumbsList()
         If (maxFilesIndex>0)
            dummyTimerDelayiedImageDisplay(50)
      }

      SoundBeep, (r=1) ? 900 : 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   otherFile := obj.initialu
   If (!FileExist(imgPath) && FileRexists(otherFile, 0))
   {
      zPlitPath(otherFile, 1, OutFileName, OutDir, extname)
      zPlitPath(imgPath, 1, sOutFileName, sOutDir, extname)
      msgResult := msgBoxWrapper(appTitle ": Undo confirmation", "The selected file was not found, but a possible copy seems to be found at:`n`n" OutFileName "`n" OutDir "\`n`nDo you want to restore it from there? It might not be the file you want. If you choose yes, a copy of the file will be made at:`n`n" sOutFileName "`n" sOutDir "\", 4, 0, "question")
      If (msgResult="Yes")
      {
         FileCopy, % otherFile, % imgPath
         If !ErrorLevel
         {
            showTOOLtip("The selected file was restored as:`n" sOutFileName "`n" sOutDir "\" b)
            undoFileActUpdateIMGindex(imgPath)
            SetTimer, RemoveTooltip, % -msgDisplayTime
         } Else
         {
            zPlitPath(imgPath, 0, OutFileName, OutDir, extname)
            showTOOLtip("ERROR: Failed to restore the selected file:`n" sOutFileName "`n" sOutDir "\")
            SoundBeep 300, 100
            SetTimer, RemoveTooltip, % -msgDisplayTime
         }
         ForceRefreshNowThumbsList()
         dummyTimerDelayiedImageDisplay(50)
         Return
      } Else Return
   }

   If (obj.typu="copy")
   {
      zPlitPath(otherFile, 1, OutFileName, OutDir, extname)
      If (imgPath!=otherFile && FileRexists(otherFile))
      {
         ksA := GetFileAttributesEx(otherFile)
         ksB := GetFileAttributesEx(imgPath)
         isSame := (ksA.size!=ksB.size || ksA.wtime!=ksB.wtime) ? 0 : 1
         If !isSame
         {
            msgResult := msgBoxWrapper(appTitle ": Undo confirmation", "The copy of the selected file is not identical with its source.`n`nAre you sure you want to undo the copy operation for the selected file? If you choose yes, the non-identical copy of the selected file will be deleted.`n`nFile to be deleted:`n" OutFileName "`n" OutDir "\", 4, 0, "question")
            If (msgResult!="Yes")
               Return
         }

         If isSame
            FileDelete, % otherFile
         Else
            FileRecycle, % otherFile
         If !ErrorLevel
         {
            If (obj.ovr="yes")
            {
               Sleep, 1
               If (obj.fsize>0)
                  rsz := restoreFileFromRecycleBin(otherFile, obj.fsize)
               w := (rsz=1) ? "`nThe original file was restored succesfully." : "`nFailed to restore the original file."
            }
            showTOOLtip("Undo COPY succeded. The copy of the selected file was deleted." w "`n" OutFileName "`n" OutDir "\")
            undoFileActUpdateIMGindex(imgPath)
            SetTimer, RemoveTooltip, % -msgDisplayTime
         } Else
         {
            showTOOLtip("ERROR: Undo COPY failed. Unable to delete the copy of the selected file.`n" OutFileName "`n" OutDir "\")
            SoundBeep 300, 100
            SetTimer, RemoveTooltip, % -msgDisplayTime
         }
         Sleep, 25   
      } Else If (imgPath!=otherFile)
      {
         showTOOLtip("WARNING: Undo COPY failed. The copy of the selected file is missing or access denied.`n" OutFileName "`n" OutDir "\")
         SoundBeep 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   } Else If (obj.typu="move" || obj.typu="rename")
   {
      If (imgPath!=otherFile)
      {
         FileGetTime, originalMtime, % imgPath, M
         FileGetTime, originalCtime, % imgPath, C
         If FileRexists(otherFile, 0)
         {
            otherFile := askAboutFileCollision(imgPath, otherFile, 0, 1, 0, performOverwrite, 1, "Undo " obj.typu " operation. ")
            If (otherFile="abort" || !otherFile)
               Return

            z := FileRexists(otherFile, 0)
            If (performOverwrite=1 && z=1)
            {
               FileSetAttrib, -R, % otherFile
               Sleep, 2
               FileDelete, % otherFile
               Sleep, 2
            } Else If (z=1)
               Return
         }

         Sleep, 5
         FileMove, % imgPath, % otherFile, 1
         If !ErrorLevel
         {
            If (originalMtime)
            {
               FileSetTime, % originalMtime, % otherFile, M
               FileSetTime, % originalCtime, % otherFile, C
            }

            If (obj.ovr="yes")
            {
               Sleep, 1
               rsz := restoreFileFromRecycleBin(imgPath, obj.fsize)
               w := (rsz=1) ? "The original file was restored succesfully." : "Failed to restore the original file."
            }

            zPlitPath(otherFile, 1, OutFileName, OutDir, extname)
            showTOOLtip("Undo " Format("{:U}", obj.typu) " succeded for the selected file:`n" OutFileName "`n" OutDir "\" b)
            undoFileActUpdateIMGindex(imgPath)
            currentFilesListModified := 1
            If (indexu>0)
            {
               resultedFilesList[indexu, 1] := otherFile
               resultedFilesList[indexu, 4] := 1
               If (SLDtypeLoaded=3)
                  updateSQLdbEntry(imgPath, otherFile, 0, resultedFilesList[indexu, 12])

               updateMainUnfilteredList(indexu, 1, otherFile)
            }
            SetTimer, RemoveTooltip, % -msgDisplayTime
         } Else
         {
            zPlitPath(imgPath, 1, OutFileName, OutDir, extname)
            showTOOLtip("ERROR: Undo " Format("{:U}", obj.typu) " failed for the selected file:`n" OutFileName "`n" OutDir "\")
            SoundBeep 300, 100
            SetTimer, RemoveTooltip, % -msgDisplayTime
         }
      } 
   }

   ForceRefreshNowThumbsList()
   If (maxFilesIndex>0)
      dummyTimerDelayiedImageDisplay(50)
}

batchUndoFileActs(modus) {
   thisIndex := 0
   filesListArray := []
   If (modus="sel" && markedSelectFile>0)
   {
      deduper := new hashtable()
      Loop, % maxFilesIndex
      {
          imgPath := StrReplace(resultedFilesList[A_Index, 1], "|")
          If (!resultedFilesList[A_Index, 2] || !imgPath)
             Continue ; if file not selected, skip

          zs := Format("{:L}", imgPath)
          If (deduper[zs]=1)
             Continue

          k := fileActsHistoryArray[zs]
          Value := k ? fileActsHistoryArray[k] : ""
          oimgPath := Value ? SubStr(Value, 1, InStr(Value, "|") - 1) : ""
          If (oimgPath!=imgPath)
             Continue

          thisIndex++
          filesListArray[thisIndex] := [imgPath, A_Index]
          deduper[zs] := 1
      }
      deduper := ""
   } Else If (modus="last")
   {
      zrobj := identifyLastUndoFileAct(filesListArray, 0)
      thisuType := Format("{:L}", zrobj[1]) A_Space
   } Else
   {
      addJournalEntry("ERROR: " A_ThisFunc "() - needs a parameter: <sel> or <last>.")
      Return
   }

   totalu := filesListArray.Count()
   If (totalu<1 || !totalu)
   {
      If (modus="sel")
         showTOOLtip("WARNING: No recorded actions for the selected files. Nothing to undo.")
      Else
         showTOOLtip("WARNING: No file actions are recorded. Nothing to undo.")
      Return
   } Else If (totalu=1)
   {
      imgPath := filesListArray[1, 1]
      akl := InStr(thisuType, "delete") ? "||" : ""
      indexu := (modus="last") ? detectFileID(akl imgPath, 1) : filesListArray[1, 2]
      ; ToolTip, % "l=" indexu "|" imgPath , , , 2
      If indexu
      {
         currentFileIndex := indexu
         corefileUndoAction(indexu)
      } Else
         corefileUndoAction(0, imgPath)

      Return
   }

   prcIndex := 0
   processedFilesArray := new hashtable()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   destroyGDIfileCache()
   doStartLongOpDance()
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   failedFiles := failedRecoverFiles := overwrittenFiles := skippedFiles := 0
   showTOOLtip("Performing UNDO " thisuType "on " groupDigits(totalu) " files, please wait")
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   setWhileLoopExec(1)
   Loop, % totalu
   {
      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(A_Index, totalu, startOperation)
         If failedFiles
            etaTime .= "`nFailed to perform UNDO for " groupDigits(failedFiles) " files"
         If failedRecoverFiles
            etaTime .= "`nFailed to recover " groupDigits(failedRecoverFiles) " overwritten files"
         If overwrittenFiles
            etaTime .= "`nFiles overwritten: " groupDigits(overwrittenFiles)
         If skippedFiles
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip("Performing UNDO " thisuType "on " groupDigits(totalu) " files, please wait" etaTime, 0, 0, A_Index/totalu)
         prevMSGdisplay := A_TickCount
      }

      imgPath := filesListArray[A_Index, 1]
      obj := friendlyFileUndoInfos(imgPath, 0)
      If (!imgPath || !IsObject(obj) || obj.typu="none")
         Continue

      deleteFileConflictDest := ""
      If (obj.restora="impossible")
      {
         failedFiles++
         Continue
      } Else If (obj.restora="maybe")
      {
         skippedFiles++
         Continue
      } Else If (obj.restora="conflict")
      {
         If (obj.typu="delete" && (performOverwrite=3 || userUndoMustDoOverwrite=1))
         {
            skippedFiles++
            Continue
         } Else If (obj.typu="delete")
         {
            zPlitPath(imgPath, 1, zOutFileName, zOutDir)
            deleteFileConflictDest := zOutDir "\tmp_QPV_" zOutFileName 
            FileMove, % imgPath, % deleteFileConflictDest
            If ErrorLevel
            {
               failedFiles++
               deleteFileConflictDest := ""
               Continue
            }
            Sleep, 2
         }
      }

      originalMtime := ""
      If (obj.typu="rename" || obj.typu="move")
      {
         otherFile := obj.initialu
         If (FileExist(otherFile) && !FolderExist(otherFile))
            otherFile := askAboutFileCollision(imgPath, otherFile, 1, 0, userUndoMustDoOverwrite, performOverwrite)

         If !otherFile
         {
            skippedFiles++
            Continue
         } Else If (otherFile="abort")
         {
            abandonAll := 1
            Break
         }

         thisFileExists := FileRexists(otherFile, 0)
         If (performOverwrite=1 && thisFileExists=1)
         {
            FileSetAttrib, -R, % otherFile
            Sleep, 1
            FileRecycle, % otherFile
            Sleep, 1
         } Else If (thisFileExists=1)
         {
            skippedFiles++
            Continue
         }

         FileGetTime, originalMtime, % imgPath, M
         FileGetTime, originalCtime, % imgPath, C
         FileMove, % imgPath, % otherFile, 1
         If !ErrorLevel
         {
            If (performOverwrite=1 && thisFileExists=1)
               overwrittenFiles++

            Sleep, 1
            processedFilesArray[imgPath] := 1
            If (originalMtime)
            {
               FileSetTime, % originalMtime, % otherFile, M
               FileSetTime, % originalCtime, % otherFile, C
            }

            If (obj.ovr="yes" && userUndoRecoverOverwritten=1)
            {
               Sleep, 1
               r := 0
               If (obj.fsize>0)
                  r := restoreFileFromRecycleBin(imgPath, obj.fsize)
               If (r!=1)
                  failedRecoverFiles++
            }

            indexu := filesListArray[A_Index, 2]
            If !indexu
               indexu := detectFileID(imgPath, 1)

            If (indexu>0)
            {
               currentFilesListModified := 1
               resultedFilesList[indexu, 1] := otherFile
               resultedFilesList[indexu, 4] := 1
               If (SLDtypeLoaded=3)
                  updateSQLdbEntry(imgPath, otherFile, 0, resultedFilesList[indexu, 12])

               updateMainUnfilteredList(indexu, 1, otherFile)
            }
         } Else failedFiles++
      } Else If (obj.typu="copy")
      {
         otherFile := obj.initialu
         If FileRexists(otherFile, 0)
         {
            ksA := GetFileAttributesEx(otherFile)
            ksB := GetFileAttributesEx(imgPath)
            isSame := (ksA.size!=ksB.size || ksA.wtime!=ksB.wtime) ? 0 : 1
            If isSame
               FileDelete, % otherFile
            Else If (userUndoDeleteNonIdenticalCopy=1)
               FileRecycle, % otherFile

            If ErrorLevel
            {
               failedFiles++
            } Else
            {
               processedFilesArray[imgPath] := 1
               If (obj.ovr="yes" && userUndoRecoverOverwritten=1)
               {
                  Sleep, 1
                  r := 0
                  If (obj.fsize>0)
                     r := restoreFileFromRecycleBin(otherFile, obj.fsize)
                  If (r!=1)
                     failedRecoverFiles++
               }
            }
         }
      } Else If (obj.typu="delete")
      {
         ; must optimize this; pool the recycle bin only once
         r := restoreFileFromRecycleBin(imgPath, obj.fsize)
         If (r=1)
         {
            otherFile := deleteFileConflictDest
            If (obj.restora="conflict" && FileRexists(otherFile, 0))
            {
               If !FolderExist(otherFile)
                  otherFile := askAboutFileCollision(imgPath, otherFile, 1, 0, userUndoMustDoOverwrite, performOverwrite, 1, "Undo delete: source file is the file from Recycle Bin, to be restored.`n")

               thisFileExists := FileRexists(otherFile, 0)
               pzo := (performOverwrite=1 && thisFileExists=1) ? 1 : 0
               If (performOverwrite=2) ; auto-rename
                  lolz++
               Else If (!otherFile || pzo=0)
                  skippedFiles++
               Else If (otherFile="abort")
                  abandonAll := 1

               If (performOverwrite=2)
               {
                  zPlitPath(otherFile, 1, zOutFileName, zOutDir)
                  otherFile := zOutDir "\" SubStr(zOutFileName, 9)
                  FileMove, % imgPath, % otherFile, 1
                  Sleep, 2
                  FileMove, % deleteFileConflictDest, % imgPath, 1
                  ; fnOutputDebug("i=" imgPath)
                  ; fnOutputDebug("o=" otherFile)
                  ; fnOutputDebug("d=" deleteFileConflictDest)
               } Else If (!otherFile || otherFile="abort" || pzo=0)
               {
                  FileRecycle, % imgPath
                  Sleep, 2
                  FileMove, % deleteFileConflictDest, % imgPath, 1
                  If (otherFile="abort")
                     Break
                  Else
                     Continue
               } Else If (performOverwrite=1 && thisFileExists=1)
               {
                  overwrittenFiles++
                  FileSetAttrib, -R, % deleteFileConflictDest
                  Sleep, 1
                  FileRecycle, % deleteFileConflictDest
                  Sleep, -1
               }
            }

            currentFilesListModified := 1
            processedFilesArray[imgPath] := 1
            indexu := filesListArray[A_Index, 2]
            If !indexu
               indexu := detectFileID(imgPath, 1)

            If (indexu>0)
            {
               zp := (performOverwrite=2) ? otherFile : imgPath
               currentFilesListModified := 1
               resultedFilesList[indexu, 1] := zp
               resultedFilesList[indexu, 4] := 1
               If (SLDtypeLoaded=3)
                  updateSQLdbEntry(imgPath, zp, 0, resultedFilesList[indexu, 12])

               updateMainUnfilteredList(indexu, 1, zp)
            }
         } Else
         {
            failedFiles++
            If (obj.restora="conflict" && FileRexists(deleteFileConflictDest, 0))
               FileMove, % deleteFileConflictDest, % imgPath
         }
      }
   }

   If (SLDtypeLoaded=3)
   {
      If !activeSQLdb.Exec("COMMIT TRANSACTION;")
         someErrors .= "`nFailed to commit changes to the SQL database"
   }

   thisIndex := 0
   For Keyu, Value in processedFilesArray
   {
      thisIndex++
      imgPath := Keyu
      undoFileActUpdateIMGindex(imgPath)
   }

   setWhileLoopExec(0)
   CurrentSLD := backCurrentSLD
   currentFilesListModified := 1
   ForceRefreshNowThumbsList()
   SetTimer, ResetImgLoadStatus, -100
   dummyTimerDelayiedImageDisplay(100)

   msgu := (abandonAll=1) ? "Undo file operations aborted. " groupDigits(thisIndex) " files processed until now." : "Finished performing undo on " groupDigits(totalu) " files."
   If failedFiles
      msgu .= "`nFailed to perform UNDO for " groupDigits(failedFiles) " files"
   If failedRecoverFiles
      msgu .= "`nFailed to recover " groupDigits(failedRecoverFiles) " overwritten files"
   If overwrittenFiles
      msgu .= "`nFiles overwritten: " groupDigits(overwrittenFiles)
   If skippedFiles
      msgu .= "`nSkipped files: " groupDigits(skippedFiles)

   showTOOLtip(msgu)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
} ; //batchUndoFileActs()

recordUndoFileActs(onewPath, oldPath, extraMarker, actu, zeit, originalFileInfos:=0) {
   ; actu options: 3 / copy ; 2 / move / rename ; 1 / delete
   If (actu=3)
      flipVars(onewPath, oldPath)

   z := fileActsHistoryArray.Count()
   If !z
      z := 1

   newPath := Format("{:L}", onewPath)
   fileActsHistoryArray[newPath] := z
   If (actu=1)
      fileActsHistoryArray[z] := onewPath "|" zeit "|Recycle-Bin|" extraMarker "|" originalFileInfos
   Else
      fileActsHistoryArray[z] := (actu=2) ? onewPath "|" zeit "|" oldPath extraMarker : onewPath "|" zeit "|?" oldPath extraMarker "|" originalFileInfos
}

hasFileIndexUndo(indexu, imgPath:=0) {
   z := imgPath ? StrReplace(imgPath, "|") : StrReplace(getIDimage(indexu), "|")
   z := Format("{:L}", z)
   x := fileActsHistoryArray[z]
   If x
      k := fileActsHistoryArray[x]
   Else
      Return x

   If !k
      fileActsHistoryArray[z] := ""

   Return k
}

friendlyFileUndoInfos(imgPath, uiMode:=1, indexu:=0) {
  If !indexu
  {
     imgPath := Format("{:L}", imgPath)
     k := fileActsHistoryArray[imgPath]
     Value := fileActsHistoryArray[k]
  } Else If (indexu>0)
     Value := fileActsHistoryArray[indexu]

  If !Value
     Return

  o := []
  imgPath := SubStr(Value, 1, InStr(Value, "|") - 1)
  Value := SubStr(Value, InStr(Value, "|") + 1)
  ju := StrSplit(Value, "|")
  o.initialu := StrReplace(ju[2], "?")
  o.initialu := StrReplace(o.initialu, "*")
  If (o.initialu!=imgPath)
  {
     If (ju[2]="recycle-bin")
     {
        o.typu := "Delete"
     } Else If InStr(ju[2], "?")
     {
        o.typu := "Copy"
     } Else
     {
        fi := SubStr(o.initialu, 1, InStr(o.initialu, "\", 0, -1) - 1)
        fd := SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)
        o.typu := (fi=fd) ? "Rename" : "Move"
     }
  } Else o.typu := "None"

  datu := ju[1]
  o.ovr := InStr(ju[2], "*") ? "Yes" : "No"
  Try FormatTime, datu, % datu, dd/MM/yyyy, HH:mm
  o.date := datu
  If (o.typu="none")
     o.restora := "No idea"
  Else If (o.typu="copy")
     o.restora := "Yes"
  Else If (o.typu="delete")
     o.restora := FileExist(imgPath) ? "Conflict" : "Yes"
  Else If !FileExist(imgPath)
     o.restora := FileExist(o.initialu) ? "Maybe" : "Impossible"
  Else If FileExist(o.initialu)
     o.restora := "Conflict"
  Else
     o.restora := "Yes"

  o.keyu := (userPrivateMode=1 && uiMode=1) ? "*:\****\***\" : imgPath
  o.initialu := (userPrivateMode=1 && uiMode=1) ? "*:\****\***\" : o.initialu
  o.word := (o.typu="copy" || o.typu="delete") ? "Destination" : "Initial"
  o.fsize := ju[3]
  o.mfdate := ju[4]
  o.cfdate := ju[5]
  Return o
}

PanelReviewSelectedFiles() {
    Global LViewOthers

    getSelectedFiles(0, 1)
    If !markedSelectFile
    {
       showTOOLtip("WARNING: There are no selected files to review.")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(60, A_ThisFunc)
    Global LViewFiltered
    btnWid := 65
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 30
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    listViewReviewFilteru := ""
    edithu := lstWid - btnWid - 35
    addCol := testIsDupesList() ? "|Dupe ID" : ""
    Gui, Add, Text, x15 y15 w%lstWid%, This list allows multiple items to be selected. The actions available in the context menu or below will be applied on the selected items.
    hLVmainu := GuiAddListView("+LV0x10000 +LV0x400 +ReadOnly -WantF2 y+10 w" lstWid " AltSubmit Count" markedSelectFile " guiLVreviewSelFilesResponder r" uLVr " Grid vLViewOthers", "S|File name|Folder path|#" addCol, "Files to review")
    GuiAddListView("+LV0x10000 +LV0x400 +ReadOnly -WantF2 xp yp w" lstWid " AltSubmit Count" markedSelectFile " guiLVreviewSelFilesResponder r" uLVr " Grid vLViewFiltered", "S|*File name|*Folder path|#" addCol, "Filtered files to review")
    hEditField := GuiAddEdit("xs y+10 w" edithu " -multi gUIeditsGenericAllowCtrlBksp vlistViewReviewFilteru", listViewReviewFilteru, "String filter")
    Gui, Add, Button, x+1 hp w%btnWid% gUIeditApplyFilterReviewPanel Default, &Apply
    GuiAddButton("x+1 hp w45 gUIstringEditFilterErase", "X", "Clear edit field")
    Gui, Add, Button, xs+0 y+15 h%thisBtnHeight% w%btnWid% gBTNreviewApplySelection, &Select
    Gui, Add, Button, x+5 hp wp gBTNreviewRemSelection , &Deselect
    Gui, Add, Button, x+5 hp wp gBTNreviewDropFilesSelection, &None
    Gui, Add, Button, x+5 hp wp gBTNrefreshReviewPanel , &Refresh
    Gui, Add, Button, x+5 hp wp ginvokePanelReviewSelContextMenu , &More
    Gui, Add, Button, x+5 hp wp gBtnReviewSelClose, C&lose
    Gui, Add, Text, xs y+10 vinfoLine w%lstWid% +0x200, Listing items`, please wait . . .
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Review selected files: " appTitle)
    Sleep, 5
    reviewSelectedIndexes := []
    Loop, % maxFilesIndex
    {
        If resultedFilesList[A_Index, 2]
        {
           thisCounter++
           reviewSelectedIndexes[thisCounter] := [A_Index, 0]
        }
    }

    PopulateReviewSelectedFiles("init")
}

BtnReviewSelClose() {
   reviewSelectedIndexes := []
   BtnCloseWindow()
}

BTNreviewDropFilesSelection() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   RowNumber := 0
   GuiControlGet, listViewReviewFilteru
   modus := markedSelectFile ? 0 : 1
   If listViewReviewFilteru
   {
      LV_GetText(thisFileIndex, RowNumber + 1, 3)
      modus := resultedFilesList[thisFileIndex, 2] ? 0 : 1
      ; ToolTip, % thisFileIndex "===" isSelected "===" modus , , , 2
   }

   modusa := !modus ? "_" : "S"
   Loop
   {
       RowNumber++
       LV_GetText(thisFileIndex, RowNumber, 4)
       If !thisFileIndex
          Break

       resultedFilesList[thisFileIndex, 2] := modus
       LV_Modify(RowNumber, , modusa)
   }

   lastZeitFileSelect := A_TickCount
   getSelectedFiles(0, 1)
   dummyTimerDelayiedImageDisplay(50)
}

BTNreviewApplySelection() {
   BTNreviewToggleSelection(1)
}

BTNreviewRemSelection() {
   BTNreviewToggleSelection(0)
}

BTNreviewCopyNames() {
   BTNreviewCopyPanel("files")
}

BTNreviewCopyDirs() {
   BTNreviewCopyPanel("dirs")
}

BTNreviewCopyExplorer() {
   BTNreviewCopyPanel(0, "copy")
}

BTNreviewCutExplorer() {
   BTNreviewCopyPanel(0, "cut")
}

BTNreviewCopyFoldersExplorer() {
   BTNreviewCopyPanel("dirs", "copy")
}

BTNreviewCutFoldersExplorer() {
   BTNreviewCopyPanel("dirs", "cut")
}

BTNreviewFilterListSelPath() {
   dropFilesSelection()
   BTNreviewSelFilesInPath()
   If (markedSelectFile>1)
   {
      BtnCloseWindow()
      filterToFilesSelection()
   }
}

BTNreviewSelFilesInPath() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   RowNumber := 0
   RowNumber := LV_GetNext(RowNumber, "F")
   LV_GetText(thisFileIndex, RowNumber, 4)
   QuickSelectFilesSameFolder(resultedFilesList[thisFileIndex, 1], "aye")
}

BtnReviewPaneOpenActs(a:=0, b:=0, c:=0) {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV

   RowNumber := 0
   RowNumber := LV_GetNext(RowNumber, "F")
   LV_GetText(thisFileIndex, RowNumber, 4)
   currentFileIndex := thisFileIndex
   imgPath := resultedFilesList[thisFileIndex, 1]
   zPlitPath(imgPath, 1, OutFileName, OutDir)
   ; TulTip(0, "=", a, b, c, thisFileIndex)
   dummyTimerDelayiedImageDisplay(25)
   a := StrReplace(a, "&")
   If InStr(a, "folder now")
   {
      BtnCloseWindow()
      OpenQPVfileFolder()
   } Else If InStr(a, "external app")
   {
      lastOtherWinClose := 1
      InvokeOpenWithMenu(imgPath)
   } Else If InStr(a, "modify")
   {
      BtnCloseWindow()
      PanelUpdateThisFileIndex("reviewer")
   } Else If InStr(a, "new QPV instance")
      SoloNewQPVinstance()
   Else If InStr(a, "in explorer")
      OpenThisFileFolder()
   Else If InStr(a, "properties")
      invokeStandardFolderProperties(OutDir)
}

BTNreviewFilterLVSelPath() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   RowNumber := 0
   RowNumber := LV_GetNext(RowNumber, "F")
   LV_GetText(thisFileIndex, RowNumber, 4)
   imgPath := resultedFilesList[thisFileIndex, 1]
   zPlitPath(imgPath, 1, OutFileName, OutDir)
   GuiControl, SettingsGUIA:, listViewReviewFilteru, % OutDir
   UIeditApplyFilterReviewPanel()
}

BTNreviewCopyPanel(modus:=0, extras:=0) {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   counter := RowNumber := 0
   listu := ""
   newArrayu := []
   useArray := (extras="cut" || extras="copy") ? 1 : 0

   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   totalSelected := LV_GetCount("Selected") + 1
   itemsList := new hashtable()
   Loop, % totalSelected
   {
       RowNumber := LV_GetNext(RowNumber)
       If (determineTerminateOperation()=1 || !RowNumber)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalSelected, startOperation)
          showTOOLtip("Processing the list to copy selected items" etaTime, 0, 0, A_Index/totalSelected)
          prevMSGdisplay := A_TickCount
       }

       LV_GetText(thisFileIndex, RowNumber, 4)
       If !thisFileIndex
          Continue

       imgPath := StrReplace(resultedFilesList[thisFileIndex, 1], "||")
       If imgPath
       {
          If (modus="dirs")
             zPlitPath(imgPath, 1, OutFileName, imgPath)
          Else If (modus="files")
             zPlitPath(imgPath, 1, imgPath, OutDir)

          If (modus="dirs" || modus="files")
          {
             t := Format("{:L}", imgPath)
             If itemsList[t]
                Continue

             itemsList[t] := 1
          }

          counter++
          If (useArray=1)
             newArrayu[counter] := imgPath
          Else
             listu .= imgPath "`n"
       }
   }

   itemsList := ""
   If (useArray=1 && counter>0)
   {
      destroyGDIfileCache()
      folderMode := (modus="dirs") ? 1 : 0
      dataHandle := ClipboardSetFiles(newArrayu, extras, folderMode)
      Sleep, 5
      testClipType := IsClipboardFormatAvailable(15)
      If (testClipType!=1 || !dataHandle)
      {
         showTOOLtip("ERROR: Failed to set the clipboard")
         SoundBeep 300, 100
      } Else
      {
         showTOOLtip(Format("{:U}", extras) " action: " groupDigits(counter) " items can now be pasted in any file manager or in QPV")
         SoundBeep 900, 100
      }
      SetTimer, RemoveTooltip, % -msgDisplayTime
      ResetImgLoadStatus()
      Return
   }

    If !listu
       Return

    Try Clipboard := listu
    Catch wasError
          Sleep, 1

    thisu := (modus="dirs") ? "containing folders" : "complete paths"
    If (modus="files")
       thisu := "file names"

    If wasError
    {
       showTOOLtip("Failed to copy to clipboard as text the selected " thisu)
       SoundBeep , 300, 100
    } Else
       showTOOLtip(groupDigits(counter) " selected " thisu " copied to clipboard as text")

    ResetImgLoadStatus()
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

UIupdateReviewLVinView() {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   If OutputVar
      Return

   Gui, SettingsGUIA: ListView, LViewOthers
   RowNumber := LV_EX_GetTopIndex(hLVmainu)
   If (RowNumber<1 || !RowNumber)
      RowNumber := 1

   Loop, 18
   {
       RowNumber++
       LV_GetText(thisFileIndex, RowNumber, 4)
       sel := resultedFilesList[thisFileIndex, 2] ? "S" : "_"
       LV_Modify(RowNumber, "Col1" , sel)
   }
}

BTNreviewToggleSelection(modus:=0) {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   RowNumber := 0
   totalSelected := LV_GetCount("Selected") + 1
   Loop, % totalSelected
   {
       RowNumber := LV_GetNext(RowNumber)
       If (determineTerminateOperation()=1 || !RowNumber)
       {
          abandonAll := 1
          Break
       }

       If (A_TickCount - prevMSGdisplay>1500)
       {
          etaTime := ETAinfos(A_Index, totalSelected, startOperation)
          showTOOLtip("Updating files selection, please wait" etaTime, 0, 0, A_Index/totalSelected)
          prevMSGdisplay := A_TickCount
       }

       LV_GetText(thisFileIndex, RowNumber, 4)
       oSel := resultedFilesList[thisFileIndex, 2]
       sel := (modus>1) ? !oSel : modus
       resultedFilesList[thisFileIndex, 2] := sel
       ; sel := (oSel && !sel) ? 0 : 1
       If (oSel=sel)
          Continue
 
       If sel
       {
          LV_Modify(RowNumber, , "S")
          markedSelectFile++
       } Else
       {
          LV_Modify(RowNumber, , "_")
          markedSelectFile--
       }
   }

   RemoveTooltip()
   lastZeitFileSelect := A_TickCount
   dummyTimerDelayiedImageDisplay(50)
   ResetImgLoadStatus()
}

BTNreviewLVselAll() {
   Gui, SettingsGUIA: Default
   If (AnyWindowOpen=2)
   {
      Gui, SettingsGUIA: ListView, LViewOthers
   } Else
   {
      GuiControlGet, OutputVar, Visible, LViewFiltered
      whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
      Gui, SettingsGUIA: ListView, % whichLV
   }
   ToolTip, Selecting all the items in list
   loopsOccured := RowNumber := 0
   LV_Modify(0, "+Select")
   ToolTip
}

BtnUIsetDupesCilterCurrentFilter() {
   dupesStringFilter := UsrEditFilter
   GuiControl, SettingsGUIA:, dupesStringFilter, % dupesStringFilter
}

UIstringEditFilterErase() {
   If (AnyWindowOpen=49)
   {
      dupesStringFilter := ""
      GuiControl, SettingsGUIA:, dupesStringFilter, 
   } Else If (AnyWindowOpen=62)
   {
      UserHamDistStringFilter := ""
      GuiControl, SettingsGUIA:, UserHamDistStringFilter, 
   } Else If (AnyWindowOpen=60)
   {
      listViewReviewFilteru := ""
      GuiControl, SettingsGUIA:, listViewReviewFilteru, 
      fn := Func("PopulateReviewSelectedFiles").Bind("back")
      SetTimer, % fn, -250
   } Else If (AnyWindowOpen=87)
   {
      listViewUndoActsFilteru := ""
      GuiControl, SettingsGUIA:, listViewUndoActsFilteru, 
      SetTimer, PopulateFileActsHistory, -100
   }
}

uiLVreviewSelFilesResponder(a:=0, b:=0, c:=0) {
   Gui, SettingsGUIA: Default
   GuiControlGet, OutputVar, Visible, LViewFiltered
   whichLV := (OutputVar=1) ? "LViewFiltered" : "LViewOthers"
   Gui, SettingsGUIA: ListView, % whichLV

   totalListed := LV_GetCount()
   topIndex := LV_EX_GetTopIndex(hLVmainu)
   totalIndex := reviewSelectedIndexes.Count()
   isInputOkay := (b="s" || b="k" && (c=40 || c=35 || c=34)) ? 1 : 0
   If (whichLV="LViewOthers" && (topIndex>totalListed - 25) && totalIndex>LVitemsPerPage && isInputOkay=1 && reviewSelectedIndexes[1, 2]!=2)
   {
      SetTimer, dummyPopulateReviewSelectedFiles, -250
      ToolTip, List view will further be populated
      Return
   }
   ; If (b="k")
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(indexu, RowNumber, 4)
   ;    TulTip(0, "=", a, b, c, indexu, RowNumber)

   If (b="K" && c=112) ; F1
   {
      BtnHelpReviewPanel()
      Return
   } Else If (b="K" && c=113) ; F2
   {
      BtnCloseWindow()
      currentFileIndex := indexu
      PanelUpdateThisFileIndex("reviewer")
      Return
   } Else If (b="K" && c=114) ; F3
   {
      BTNreviewFilterListSelPath()
      Return
   } Else If (b="K" && c=116) ; F5
   {
      BTNrefreshReviewPanel()
      Return
   } Else If (b="K" && c=117) ; F6
   {
      BtnReviewPaneOpenActs()
      Return
   } Else If (b!="DoubleClick")
      Return

   BtnCloseWindow()
   currentFileIndex := indexu
   dummyTimerDelayiedImageDisplay(50)
}

BTNrefreshReviewPanel() {
   BtnCloseWindow()
   PanelReviewSelectedFiles()
}

UIeditApplyFilterReviewPanel() {
   Gui, SettingsGUIA: Default
   GuiControlGet, listViewReviewFilteru
   Tooltip
   If StrLen(Trimmer(listViewReviewFilteru))<2
   {
      UIstringEditFilterErase()
   } Else
   {
      lastFilterEditSearch := Trimmer(listViewReviewFilteru)
      SetTimer, PopulateReviewSelectedFiles, -50
   }
}

dummyPopulateReviewSelectedFiles() {
    If determineLClickState()
       SetTimer, % A_ThisFunc, -350
    Else
       SetTimer, PopulateReviewSelectedFiles, -350
}

PopulateReviewSelectedFiles(modus:="") {
    Static initTotals := 0, lastSearch := 0, listedEntries := 0
    If (AnyWindowOpen!=60)
       Return

    Tooltip
    Gui, SettingsGUIA: Default
    GuiControlGet, listViewReviewFilteru
    thisString := StrReplace(Trimmer(listViewReviewFilteru), "||", "|")
    thisString := Trimmer(thisString, "|")
    thisFilter := processSearchIndexString(thisString)
    isStrFilter := StrLen(thisString)>1 ? 1 : 0
    FilterSimple := (InStr(thisString, "|") || InStr(thisString, "/") || InStr(thisString, ">") || InStr(thisString, "?")) ? 0 : 1

    whichLV := (isStrFilter=1) ? "LViewFiltered" : "LViewOthers"
    Gui, SettingsGUIA: ListView, % whichLV
    If (whichLV="LViewFiltered")
    {
       listedEntries := LV_GetCount()
       GuiControl, SettingsGUIA: Hide, LViewOthers
       GuiControl, SettingsGUIA: Show, LViewFiltered
       thisSearch := thisFilter thisString initTotals maxFilesIndex CurrentSLD
       If (thisSearch=lastSearch && listedEntries)
       {
          GuiControl, SettingsGUIA:, infoLine, % "Filtered table: " groupDigits(listedEntries) " / " groupDigits(initTotals) " (" Round(listedEntries/initTotals*100, 2) "%)"
          Return
       }
    } Else
    {
       GuiControl, SettingsGUIA: Hide, LViewFiltered
       GuiControl, SettingsGUIA: Show, LViewOthers
       If (modus="back")
       {
          UIupdateReviewLVinView()
          totalSelected := reviewSelectedIndexes.Count()
          percu := Round(LV_GetCount()/totalSelected*100, 2)
          if (percu=100)
             GuiControl, SettingsGUIA:, infoLine, % "Entries listed: " groupDigits(LV_GetCount())
          Else
             GuiControl, SettingsGUIA:, infoLine, % "Entries listed: " groupDigits(LV_GetCount()) " / " groupDigits(totalSelected) " (" percu "%)"
          Return
       }
    }

    doStartLongOpDance()
    If (whichLV="LViewFiltered")
       LV_Delete()

    LV_ModifyCol(4, "Integer")
    LV_ModifyCol(5, "Integer")
    GuiControl, SettingsGUIA:, infoLine, Listing items`, please wait...
    GuiControl, -Redraw, % whichLV
    EM_SETCUEBANNER(hEditField, "Populating the list view - please wait", 1)
    thisCounter :=  hasAutoSized := 0
    prevMSGdisplay := A_TickCount
    startOperation := A_TickCount
    isDupesList := testIsDupesList()
    totalSelected := reviewSelectedIndexes.Count()
    preventAutoSize := 0
    Loop, % totalSelected
    {
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (reviewSelectedIndexes[A_Index, 2] && whichLV="LViewOthers")
        {
           preventAutoSize := 1
           Continue
        }

        thisIndex := reviewSelectedIndexes[A_Index, 1]
        If (whichLV="LViewOthers")
           reviewSelectedIndexes[A_Index, 2] := 1

        If (isStrFilter=1 && FilterSimple=1)
        {
           If !inStr(resultedFilesList[thisIndex, 1], thisString)
              Continue
        } Else If (isStrFilter=1)
        {
           If !coreSearchIndex(resultedFilesList[thisIndex, 1], thisFilter, 1, 0)
              Continue
        }

        If (A_TickCount - prevMSGdisplay>1500)
        {
           etaTime := ETAinfos(A_Index, totalSelected, startOperation)
           showTOOLtip("Populating list view, please wait" etaTime, 0, 0, A_Index/totalSelected)
           prevMSGdisplay := A_TickCount
        }

        If (whichLV!="LViewOthers")
           listedEntries++
        thisCounter++
        isSelected := resultedFilesList[thisIndex, 2] ? "S" : "_"
        zPlitPath(resultedFilesList[thisIndex, 1], 1, OutFileName, OutDir)
        OutDir := (userPrivateMode=1) ? "*:\****\***\" : OutDir
        OutFileName := (userPrivateMode=1) ? "*****.***" : OutFileName
        If (A_Index=totalSelected && whichLV="LViewOthers")
           reviewSelectedIndexes[1, 2] := 2

        If isDupesList
           LV_Add(A_Index, isSelected, OutFileName, OutDir, thisIndex, resultedFilesList[thisIndex, 23])
        Else
           LV_Add(A_Index, isSelected, OutFileName, OutDir, thisIndex)

        If ((A_Index=5 || A_Index=10) && preventAutoSize!=1)
        {
           hasAutoSized := 1
           Loop, 5
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }

        If ((A_TickCount - startOperation)>3500 && thisCounter>=LVitemsPerPage && whichLV="LViewOthers")
        {
           LVitemsPerPage := thisCounter
           Break
        }
    }

    If (!hasAutoSized && !preventAutoSize)
    {
       Loop, 5
           LV_ModifyCol(A_Index, "AutoHdr Left")
    }

    GuiControl, +Redraw, % whichLV
    If (whichLV="LViewOthers")
    {
       initTotals := reviewSelectedIndexes.Count()
       If (modus="init")
          lastSearch := listedEntries := 0
       Else
          UIupdateReviewLVinView()

       percu := Round(LV_GetCount()/totalSelected*100, 2)
       if (percu=100)
          GuiControl, SettingsGUIA:, infoLine, % "Entries listed: " groupDigits(LV_GetCount())
       Else
          GuiControl, SettingsGUIA:, infoLine, % "Entries listed: " groupDigits(LV_GetCount()) " / " groupDigits(totalSelected) " (" percu "%)"
    } Else
    {
       listedEntries := LV_GetCount()
       lastSearch := thisFilter thisString initTotals maxFilesIndex CurrentSLD
       GuiControl, SettingsGUIA:, infoLine, % "Filtered table: " groupDigits(listedEntries) " / " groupDigits(initTotals) " (" Round(listedEntries/initTotals*100, 2) "%)"
    }

    RemoveTooltip()
    SetTimer, ResetImgLoadStatus, -100
    EM_SETCUEBANNER(hEditField, "Filter files list", 1)
}

PanelDynamicFolderzWindow(dummy:=0) {
    Static LViewDynas, hasWarned := 0
    If AnyWindowOpen
       Return

    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    If (userPrivateMode=1 && hasWarned!=1)
    {
       msgBoxWrapper(appTitle ": WARNING", "QPV is currently in private mode, hiding all file paths and images, for privacy.`n `nWARNING: This panel MALFUNCTIONS in private mode. Proceed with care.", 0, 0, "exclamation")
       hasWarned := 1
    }

    thisBtnHeight := createSettingsGUI(3, A_ThisFunc)
    btnWid := 120
    txtWid := 360
    lstWid := 535
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 175
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15, This folders list is used to generate the files list index.
    hLVmainu := GuiAddListView("y+10 w" lstWid " +LV0x10000 r" uLVr " Grid +LV0x400 guiLVfolderzFilterListBTN +ReadOnly -multi AltSubmit vLViewDynas", "#|(?)|Folder path|Files|Selected|`%|Files on disk|Difference|Size (MB)", "Folders to scan")
    btnWid2 := (PrefsLargeFonts=1) ? 95 : 60
    btnWid3 := (PrefsLargeFonts=1) ? 120 : 90
    If (dummy="reopen")
    {
       Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w60 gPanelSaveSlideShowu, &Back
       Gui, Add, Button, x+5 hp wp gBTNaddNewFolder2list, &Add
    } Else
       Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w60 gBTNaddNewFolder2list, &Add

    Gui, Add, Button, x+5 hp w%btnWid2% gBTNremDynaSelFolder, &Remove
    Gui, Add, Button, x+5 hp wp+30 gRegenerateEntireList, R&escan all
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNcopyDynaFoldersList, &Copy list
    Gui, Add, Button, x+5 hp wp+5 gBTNpasteDynaFoldersList, &Paste list
    Gui, Add, Button, x+5 hp wp+5 ginvokePanelDynaFoldersContextMenu, &More
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Manage folders list: " appTitle)
    PopulateDynamicFolderzList()
}

ToggleCountFilesFoldersList() {
  GuiControlGet, CountFilesFolderzList
  If (AnyWindowOpen=3)
     PanelDynamicFolderzWindow()
  Else If (AnyWindowOpen=2)
     PanelStaticFolderzManager()
}

BTNaddNewFolder2list() {
    BtnCloseWindow()
    Sleep, 10
    r := addNewFolder2list()
    Sleep, 10
    SetTimer, PanelDynamicFolderzWindow, -50
}

BTNignoreDateStaticFolder(dummy:=0) {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, 1)
    folderu := newStaticFoldersListCache[indexu, 1]
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded!=3)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
          Return
       }
    }

    setImageLoading()
    total := LV_GetCount()
    totalSelected := LV_GetCount("S")
    doAll := (totalSelected>=total || dummy="update-all") ? 1 : 0
    iF (doAll!=1)
    {
       indexu := RowNumber := 0
       Loop, % total
       {
          RowNumber := LV_GetNext(RowNumber)
          If !RowNumber
             Break

          LV_GetText(indexu, RowNumber, 1)
          If !indexu
             Continue

          folderu := newStaticFoldersListCache[indexu, 1]
          If FolderExist(folderu)
          {
             FileGetTime, dirDateO, % folderu, M
             newStaticFoldersListCache[indexu, 2] := dirDateO
             FormatTime, dirDate, % dirDateO, yyyy/MM/dd
             LV_Modify(RowNumber, "Col3", "")
             LV_Modify(RowNumber, "Col2", dirDate)
          }
       }
    } Else 
    {
       BtnCloseWindow()
       Loop, % newStaticFoldersListCache.MaxIndex()
       {
          folderu := newStaticFoldersListCache[A_Index, 1]
          If FolderExist(folderu)
          {
             FileGetTime, dirDateO, % folderu, M
             newStaticFoldersListCache[A_Index, 2] := dirDateO
          }
       }
    }
    If (SLDtypeLoaded=3)
       SQLDBdumpStaticFoldersList()

    ResetImgLoadStatus()
    showTOOLtip("Folders list information updated")
    If !AnyWindowOpen
    {
       SoundBeep 900, 100
       SetTimer, PanelStaticFolderzManager, -350
    }
    SetTimer, RemoveTooltip, % -msgDisplayTime
    Sleep, 1
}

BTNcopyStaticFolderPath() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    colNum := (AnyWindowOpen=3) ? 3 : 1
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(folderu, RowNumber, colNum)
    If (AnyWindowOpen=2)
       folderu := newStaticFoldersListCache[folderu, 1]

    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (AnyWindowOpen=2)
    {
       counter := indexu := RowNumber := 0
       total := LV_GetCount()
       foldersListArray := ""
       Loop, % total
       {
          RowNumber := LV_GetNext(RowNumber)
          If !RowNumber
             Break

          LV_GetText(indexu, RowNumber, colNum)
          If !indexu
             Continue

          folderu := newStaticFoldersListCache[indexu, 1]
          If folderu
          {
             counter++
             foldersListArray .= folderu "`n"
          }
       }

       If (counter<1)
          Return
    } Else counter := 1

    Try Clipboard := (AnyWindowOpen=2) ? foldersListArray : folderu
    Catch wasError
          Sleep, 1

    If wasError
    {
       showTOOLtip("Failed to copy the folder path(s) to clipboard as text")
       SoundBeep , 300, 100
    } Else
       showTOOLtip(groupDigits(counter) " folder path(s) copied to clipboard as text")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNcutCopyStaticFolders(a) {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    colNum := (AnyWindowOpen=3) ? 3 : 1
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(folderu, RowNumber, colNum)
    If (AnyWindowOpen=2)
       folderu := newStaticFoldersListCache[folderu, 1]

    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    counter := indexu := RowNumber := 0
    total := LV_GetCount()
    foldersListArray := []
    Loop, % total
    {
       RowNumber := LV_GetNext(RowNumber)
       If !RowNumber
          Break

       LV_GetText(indexu, RowNumber, colNum)
       If !indexu
          Continue

       folderu := newStaticFoldersListCache[indexu, 1]
       If FolderExist(folderu)
       {
          counter++
          foldersListArray[counter] := folderu "\"
       }
    }

    If (counter<1)
       Return

    userOption := InStr(StrReplace(a, "&"), "cut") ? "CUT" : "COPY"
    destroyGDIfileCache()
    dataHandle := ClipboardSetFiles(foldersListArray, userOption, 1)
    Sleep, 5
    testClipType := IsClipboardFormatAvailable(15)
    infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to set the clipboard" : userOption " action: " counter " folders can now be pasted in any file manager or in QPV"
    showTOOLtip(infoText)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNcopyAllStaticFolderPaths() {
    counter := 0
    Loop, % newStaticFoldersListCache.MaxIndex()
    {
       counter++
       finalListu .= newStaticFoldersListCache[A_Index, 1] "`n"
    }

    If !counter
       Return

    Try Clipboard := finalListu
    Catch wasError
          Sleep, 1

    If wasError
    {
       showTOOLtip("Failed to copy the folder paths to clipboard as text")
       SoundBeep , 300, 100
    } Else
       showTOOLtip(groupDigits(counter) " folder paths are copied to clipboard as text")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNshowStaticFoldersInTreeView() {
    Loop, % newStaticFoldersListCache.MaxIndex()
          finalListu .= newStaticFoldersListCache[A_Index, 1] "`n"

    BtnCloseWindow()
    ; PanelFoldersTree()
    FolderTreeRepopulate("given", finalListu)
}

BTNshowDynamicFoldersInTreeView() {
    foldersListu := getDynamicFoldersList()
    Loop, Parse, foldersListu, `n
    {
        fileTest := StrReplace(Trimmer(A_LoopField), "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= fileTest "`n"
    }
    If !newFoldersList
       Return

    BtnCloseWindow()
    ; PanelFoldersTree()
    FolderTreeRepopulate("given", newFoldersList)
}

BTNremFilesStaticFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, 1)
    folderu := newStaticFoldersListCache[indexu, 1]
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    msgResult := msgBoxWrapper(appTitle ": Remove files by folder", "Please confirm that you want to remove the files from the index pertaining to the selected folder(s).", 4, 0, "question")
    If (msgResult="yes")
    {
       Sleep, 10
       Gui, SettingsGUIA: Default
       Gui, SettingsGUIA: ListView, LViewOthers
       indexu := RowNumber := 0
       total := LV_GetCount()
       foldersListArray := new hashtable()
       ; ToolTip, % indexu "=" RowNumber "=" total , , , 2
       Loop, % total
       {
          RowNumber := LV_GetNext(RowNumber)
          If !RowNumber
             Break

          LV_GetText(indexu, RowNumber, 1)
          If !indexu
             Continue

          folderu := Format("{:L}", newStaticFoldersListCache[indexu, 1])
          If folderu
             foldersListArray[folderu] := indexu
       }

       r := 0
       If (foldersListArray.Count()>0)
       {
          r := 1
          BtnCloseWindow()
          For foldar, Value in foldersListArray
          {
             If (maxFilesIndex>1)
             {
                r := coreRemFilesStaticFolder(foldar, "|")
                newStaticFoldersListCache[Value, 4] := 0
                newStaticFoldersListCache[Value, 3] := 0
             }
          }
       }

       foldersListArray := ""
       Sleep, 10
       If r
          PanelStaticFolderzManager()
    } Else Return
}

BTNunselFilesStaticFolder() {
   BTNselFilesStaticFolder("desel")
}

BTNselFilesStaticFolder(modus:=0) {
   whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, % whichLV
   colNum := (AnyWindowOpen=3) ? 3 : 1
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderu, RowNumber, colNum)
   If (AnyWindowOpen=2)
      folderu := newStaticFoldersListCache[folderu, 1]

   ; ToolTip, % folderu "=" colNum "=" RowNumber "=" whichLV , , , 2
   If (StrLen(folderu)<3 || folderu="folder path")
      Return

   ToolTip, Selecting matching files
   setImageLoading()
   If (AnyWindowOpen=2)
   {
      ; static folders panel
      indexu := RowNumber := 0
      total := LV_GetCount()
      foldersListArray := new hashtable()
      foldersSelListArray := new hashtable()
      foldersLVs := new hashtable()
      ; ToolTip, % "l=" total , , , 2
      Loop, % total
      {
          RowNumber := LV_GetNext(RowNumber)
          If !RowNumber
             Break

          LV_GetText(indexu, RowNumber, colNum)
          If !indexu
             Continue

          folderu :=  Format("{:L}", newStaticFoldersListCache[indexu, 1])
          If folderu
          {
             foldersListArray[folderu] := indexu
             foldersSelListArray[indexu] := 0
             foldersLVs[indexu] := RowNumber
          }
       }
    }

   thisIndex := 0
   folderu := StrReplace(folderu, "|")
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
         showTOOLtip("Updating files selection, please wait" etaTime, 0, 0, A_Index/maxFilesIndex)
         prevMSGdisplay := A_TickCount
      }

      imgPath := StrReplace(resultedFilesList[A_Index, 1], "|")
      If !imgPath
         Continue

      OutDir := (AnyWindowOpen=2) ? Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1)) : imgPath
      If (AnyWindowOpen=2 && foldersListArray[OutDir])
      || (AnyWindowOpen=3 && InStr(OutDir "\", folderu "\"))
      {
         thisIndex++
         osel := resultedFilesList[A_Index, 2]
         If (AnyWindowOpen=2)
            foldersSelListArray[foldersListArray[OutDir]] := 1 + foldersSelListArray[foldersListArray[OutDir]]
         resultedFilesList[A_Index, 2] := (modus="desel") ? 0 : 1
         If (modus="desel" && osel=1)
            markedSelectFile--
         Else If (modus!="desel" && !osel)
            markedSelectFile++
      }
   }

   ToolTip
   lastZeitFileSelect := A_TickCount
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   interfaceThread.ahkassign("markedSelectFile", markedSelectFile)
   If (AnyWindowOpen=2)
   {
      iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
      For Key, Value in foldersListArray
      {
         indexu := Value
         selected := foldersSelListArray[indexu]
         RowNumber := foldersLVs[indexu]
         thisIndex :=  (modus="desel") ? 0 : selected
         LV_GetText(countFiles, RowNumber, 5)
         perc := countFiles ? Round((Round(thisIndex)/countFiles)*100, 1) : 0
         LV_Modify(RowNumber, "Col6", thisIndex)
         LV_Modify(RowNumber, "Col7", perc)
         newStaticFoldersListCache[indexu, 4] := (modus="desel") ? 0 : thisIndex
      }
   }

   ResetImgLoadStatus()
   RemoveTooltip()
   foldersListArray := ""
   foldersSelListArray := ""
   foldersLVs := ""
   dummyTimerDelayiedImageDisplay(50)
}

BTNcountFilesDynaFolders() {
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, LViewDynas
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderu, RowNumber, 3)
   LV_GetText(onDisk, RowNumber, 7)
   ; ToolTip, % folderu "=" colNum "=" RowNumber "=" whichLV , , , 2
   If (StrLen(folderu)<3 || folderu="folder path")
      Return

   ToolTip, Identifying matching files
   setImageLoading()
   thisSelIndex := thisIndex := 0
   folderu := StrReplace(folderu, "|")
   doStartLongOpDance()
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := StrReplace(resultedFilesList[A_Index, 1], "|")
      If !imgPath
         Continue

      If (InStr(imgPath "\", folderu "\"))
      {
         thisIndex++
         If resultedFilesList[A_Index, 2]
            thisSelIndex++
      }
   }

   ToolTip
   LV_Modify(RowNumber, "Col4", thisIndex)
   LV_Modify(RowNumber, "Col5", thisSelIndex)

   diffu := (onDisk!="" && thisIndex!="") ? onDisk - thisIndex : 0
   perc := countFiles ? Round((Round(thisSelIndex)/thisIndex)*100, 1) : 0
   LV_Modify(RowNumber, "Col6", perc)
   LV_Modify(RowNumber, "Col8", diffu)
   ResetImgLoadStatus()
   Return thisIndex
}

coreRemFilesStaticFolder(folderu, recursive) {
    remFilesFromList(recursive folderu)
    If (maxFilesIndex>0)
    {
       GenerateRandyList()
       SoundBeep, 900, 100
       RandomPicture()
       Return 1
    } Else
    {
       r := handleEmptyFilesList(CurrentSLD, "", 2)
       z := r ? 1 : 0
       Return z
    }
}

BTNcopyDynaFoldersList() {
    foldersListu := getDynamicFoldersList()
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    ResetImgLoadStatus()
    If !newFoldersList
       Return

    Try Clipboard := newFoldersList
    Catch wasError
          Sleep, 1

    If !wasError
    {
       showTOOLtip("Dynamic folders list copied to clipboard")
    } Else
    {
       showTOOLtip("Failed to copy to clipboard the dynamic folders list")
       SoundBeep , 300, 100
    }

    SetTimer, RemoveTooltip, % msgDisplayTime
}

BTNpasteDynaFoldersList() {
    BtnCloseWindow()
    Sleep, 50
    foldersListu := getDynamicFoldersList()
    foldersListu .= SubStr(Clipboard, 1, 50432)
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    mustOpenStartFolder := ""
    Sort, newFoldersList, UD`n
    DynamicFoldersList := cleanDynamicFoldersList(newFoldersList)
    If (InStr(DynamicFoldersList, ":\") && !CurrentSLD)
    {
       CurrentSLD := prevOpenFolderPath "\NewFilesList.SLD"
       SLDtypeLoaded := 2
    }

    If (SLDtypeLoaded=3 && RegExMatch(CurrentSLD, sldsPattern))
       recreateDynaFoldersSQLdbList(DynamicFoldersList)

    currentFilesListModified := 1
    Sleep, 50
    ResetImgLoadStatus()
    PanelDynamicFolderzWindow()
}

BTNremDynaSelFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_GetNext()
    LV_GetText(folderu, RowNumber, 3)
    LV_GetText(isR, RowNumber, 2)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If !InStr(isR, "R")
       folderu := "|" folderu

    BtnCloseWindow()
    Sleep, 50
    mustOpenStartFolder := ""
    foldersListu := getDynamicFoldersList()
    currentFilesListModified := 1
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!RegExMatch(fileTest, "i)^(.\:\\.)") || folderu=line)
           Continue

        newFoldersList .= line "`n"
    }

    DynamicFoldersList := newFoldersList
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    If (maxFilesIndex>1)
       msgResult := msgBoxWrapper(appTitle ": Remove dynamic folder", "Would you like to remove the files from the index/list pertaining to the removed dynamic folder as well ?`n`n" folderu "\", 4, 0, "question")

    If (msgResult="yes")
    {
       remFilesFromList(StrReplace(folderu, "|"))
       If (maxFilesIndex>0)
       {
          GenerateRandyList()
          SoundBeep, 900, 100
          RandomPicture()
       } Else 
       {
          If !handleEmptyFilesList(CurrentSLD, "", 2)
             Return
       }
    }

    Sleep, 50
    ResetImgLoadStatus()
    SetTimer, PanelDynamicFolderzWindow, -150
}

BtnPanelManageFoldersExplorer() {
   BtnPanelManageFoldersActus("explorer", "yo")
}

BtnPanelManageFoldersNewInstance() {
   BtnPanelManageFoldersActus("anew", "yo")
}

BtnPanelManageFoldersProperties() {
   BtnPanelManageFoldersActus("properties", "yo")
}

BtnPanelManageFoldersProtect() {
   BtnPanelManageFoldersActus("protect", "yo")
}

BtnPanelStaticJumpFirst() {
   whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, % whichLV
   colNum := (AnyWindowOpen=3) ? 3 : 1
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderu, RowNumber, colNum)
   If (AnyWindowOpen=2)
      folderu := newStaticFoldersListCache[folderu, 1]

   ; ToolTip, % RowNumber "==" A_GuiEventInfo "`n" folderu , , , 2
   If (StrLen(folderu)<3 || folderu="folder path")
      Return

   winOpen := AnyWindowOpen
   folderPath := StrReplace(folderu, "|")
   BtnCloseWindow()
   thisIndex := 0
   doStartLongOpDance()
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
         showTOOLtip("Searching for the first file in index in`n:" folderPath "\" etaTime, 0, 0, A_Index/maxFilesIndex)
         prevMSGdisplay := A_TickCount
      }

      imgPath := StrReplace(resultedFilesList[A_Index, 1], "|")
      If !imgPath
         Continue

      OutDir := (winOpen=2) ? SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1) : imgPath
      If (winOpen=2 && OutDir=folderPath) || (winOpen=3 && InStr(OutDir "\", folderPath "\"))
      {
         thisIndex := A_Index
         Break
      }
   }

   ResetImgLoadStatus()
   RemoveTooltip()
   If thisIndex
   {
      currentFileIndex := thisIndex
      dummyTimerDelayiedImageDisplay(100)
   } Else
   {
      showTOOLtip("WARNING: No file found to be indexed from the selected folder:`n" folderPath "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BtnPanelManageFoldersActus(modus:=0, g:=0) {
   z := 0
   If (modus="protect" && g="yo")
      z := 4
   Else If (modus="properties" && g="yo")
      z := 3
   Else If GetKeyState("Shift", "P") || (modus="anew" && g="yo") 
      z := 2
   Else If GetKeyState("Ctrl", "P") || (modus="explorer" && g="yo")
      z := 1

   whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
   Gui, SettingsGUIA: Default
   Gui, SettingsGUIA: ListView, % whichLV
   colNum := (AnyWindowOpen=3) ? 3 : 1
   RowNumber := LV_GetNext(0, "F")
   LV_GetText(folderu, RowNumber, colNum)
   If (AnyWindowOpen=2)
      folderu := newStaticFoldersListCache[folderu, 1]

   ; ToolTip, % RowNumber "==" A_GuiEventInfo "`n" folderu , , , 2
   If (StrLen(folderu)<3 || folderu="folder path")
      Return

   folderPath := StrReplace(folderu, "|")
   If (z=1 && folderPath)
   {
      Try Run, "%folderPath%"
      Catch wasError
      {
         If !AnyWindowOpen
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder:`n" folderu, 0, 0, "error")
      }
   } Else If (z=2 && folderPath)
   {
      OpenNewQPVinstance(folderPath)
   } Else If (z=3 && folderPath)
   {
      invokeStandardFolderProperties(folderPath)
   } Else If (z=4 && folderPath)
   {
      setContaintFolderAsProtected(folderPath)
   } Else If FolderExist(folderPath)
   {
      BtnCloseWindow()
      If askAboutFileSave(" and the selected folder will be opened")
         Return

      If askAboutSlidesListSave()
         Return

      If askAboutFilesSelect("discard it")
         Return

      tryOpenGivenFolder(folderPath, CurrentSLD)
      FileExploreSiblingsNav("reset")
   }
}

invokeStandardFolderProperties(thisFolder) {
   If FolderExist(thisFolder)
   {
      Try Run, Properties "%thisFolder%"
      Catch wasError
            msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the system file properties.", 0, 0, "error")
   } Else
   {
      showTOOLtip("WARNING: The folder seems to no longer exist`n" thisFolder "\")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

uiLVfolderzFilterListBTN(a:=0, b:=0, c:=0) {
    If (!AnyWindowOpen || b="s")
       Return

    whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, % whichLV
    colNum := (AnyWindowOpen=3) ? 3 : 1
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, colNum)
    folderu := (AnyWindowOpen=2) ? newStaticFoldersListCache[indexu, 1] : indexu
    LV_GetText(files, RowNumber, 5)
    totalSelected := LV_GetCount("S")

    ; TulTip(0,"|  ", indexu, folderu, files)
    If (StrLen(folderu)<3 || !totalSelected || folderu="folder path")
       Return

    If (b="k" && c=112) ; F1
    {
       If (AnyWindowOpen=2)
          BtnHelpStaticFoldersPanel()
       Return
    } Else If (b="k" && c=113) ; F2
    {
       isUpdateList := (FileExist(CurrentSLD) && RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? 1 : 0
       If (isUpdateList || whichLV="LViewDynas")
          PanelRenameStaticFolder()
       Return
    } Else If (b="k" && c=45 && whichLV="LViewDynas") ; Insert
    {
       BTNaddNewFolder2list()
       Return
    } Else If (b="k" && c=114) ; F3
    {
       MenuFilterListSelectedFolder()
       Return
    } Else If (b="k" && c=32 && whichLV="LViewDynas") ; Space
    {
       invokePanelDynaFoldersContextMenu()
       Return
    } Else If (b="k" && c=116) ; F5
    {
       If (whichLV="LViewDynas")
          BTNrescanDynaFolder()
       Else
          BTNupdateSelectedStaticFolder()
       Return
    } Else If (b="k" && c=117) ; F6
    {
       BtnPanelManageFoldersExplorer()
       Return
    } Else If (b="k" && c=121 && whichLV="LViewDynas") ; F10
    {
       BTNcountFilesDiskDynaFolder()
       Return
    } Else If (b="k" && c=122 && whichLV="LViewDynas") ; F11
    {
       BTNcountFilesDynaFolders()
       Return
    } Else If (b="K" && (c=119 || c=46)) ; F8
    {
       If (whichLV="LViewDynas")
          BTNremDynaSelFolder()
       Else
          BTNremFilesStaticFolder()
       Return
    }

    If (A_GuiEvent="Normal" && GetKeyState("Alt", "P"))
    {
       BTNselFilesStaticFolder()
       Return
    } Else If (A_GuiEvent="RightClick" && GetKeyState("Alt", "P"))
    {
       BTNunselFilesStaticFolder()
       Return
    } Else If ((A_GuiEvent="Normal" || A_GuiEvent="K") && files="" && whichLV="LViewOthers")
    {
       countedFiles := 0
       countedSelFiles := 0
       ; startZeit := A_TickCount
       Loop, % maxFilesIndex
       {
          imgPath := resultedFilesList[A_Index, 1]
          If InStr(imgPath, folderu)
             zPlitPath(imgPath, 1, OutFileName, OutDir)
          Else
             OutDir := ""

          If (OutDir=folderu)
          {
             countedFiles++
             If resultedFilesList[A_Index, 2]
                countedSelFiles++
          }
       }
       ; ToolTip, % A_TickCount - startZeit , , , 2
       newStaticFoldersListCache[indexu, 3] := countedFiles
       newStaticFoldersListCache[indexu, 4] := countedSelFiles
       LV_Modify(RowNumber, "Col5", countedFiles)
       LV_Modify(RowNumber, "Col6", countedSelFiles)
       perc := countedFiles ? Round((Round(countedSelFiles)/countedFiles)*100, 1) : 0
       LV_Modify(RowNumber, "Col7", perc)
       ; LV_ModifyCol(colNum, "AutoHdr Left")
       Return
    }

    If (b="DoubleClick")
    {
       BtnPanelStaticJumpFirst()
    } Else If (a="menu-mode")
    {
       selu := LV_GetCount("S")
       If (a="menu-mode" && AnyWindowOpen=2 && selu>1)
          UIfilterListToSelectStaticFolders()
       Else
          uiFilterListDynaFolder(folderu, AnyWindowOpen)
    }
}

UIfilterListToSelectStaticFolders() {
   showTOOLtip("Filtering list to selected folders, please wait")
   Gui, SettingsGUIA: Hide
   dropFilesSelection(1)
   BTNselFilesStaticFolder()
   BtnCloseWindow()
   filterToFilesSelection()
   dropFilesSelection(1)
}

countAllFilesPerStaticFolders(dummy:=0) {
    If (dummy!="start")
    {
       BtnCloseWindow()
    } Else
    {
       EM_SETCUEBANNER(hEditField, "Preparing folders list - please wait", 1)
       Tooltip, Preparing folders list - please wait
    }

    setImageLoading()
    getSelectedFiles(0, 1)
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    doStartLongOpDance()
    startOperation := A_TickCount
    prevMSGdisplay := A_TickCount
    totalLoops := newStaticFoldersListCache.MaxIndex()
    folderMapArray := new hashtable()
    thisIndex := 0
    Loop, % totalLoops
    {
        If (SLDtypeLoaded!=3)
           newStaticFoldersListCache[A_Index, 3] := 0
        newStaticFoldersListCache[A_Index, 4] := 0
        OutDir := Format("{:L}", newStaticFoldersListCache[A_Index, 1])
        folderMapArray[OutDir] := A_Index
    }

    foldersListArray := new hashtable()
    foldersSelListArray := new hashtable()
    Loop, % maxFilesIndex
    {
        imgPath := resultedFilesList[A_Index, 1]
        executingCanceableOperation := A_TickCount
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        If (A_TickCount - prevMSGdisplay>2000)
        {
           etaTime := ETAinfos(A_Index, maxFilesIndex, startOperation)
           showTOOLtip("Counting files per folders, please wait`nTotal folders: " groupDigits(totalLoops) etaTime, 0, 0, A_Index/maxFilesIndex)
           prevMSGdisplay := A_TickCount
        }

        OutDir := Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1))
        foldersListArray[OutDir] := (SLDtypeLoaded=3) ? 1 : Round(foldersListArray[OutDir]) + 1
        If markedSelectFile
        {
           If resultedFilesList[A_Index, 2]
              foldersSelListArray[OutDir] := Round(foldersSelListArray[OutDir]) + 1
        }
    }
 
    totalLoops := foldersListArray.Count()
    For folderu, Value in foldersListArray
    {
        If !folderu
           Continue

        If (A_TickCount - prevMSGdisplay>1000)
        {
           etaTime := ETAinfos(A_Index, totalLoops, startOperation)
           showTOOLtip("Consolidating data: count files per folders" etaTime, 0, 0, A_Index/totalLoops)
           prevMSGdisplay := A_TickCount
        }

        executingCanceableOperation := A_TickCount
        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }

        thisIndex := folderMapArray[folderu]
        If (SLDtypeLoaded!=3)
           newStaticFoldersListCache[thisIndex, 3] := Value

        If markedSelectFile
           newStaticFoldersListCache[thisIndex, 4] := foldersSelListArray[folderu]
    }

    iduStaticFoldersListCache := "a" maxFilesIndex markedSelectFile newStaticFoldersListCache.Count()
    foldersListArray := ""
    foldersSelListArray := ""
    folderMapArray := ""
    zeitOperation := A_TickCount - startOperation
    addJournalEntry(A_ThisFunc "() operation elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    CurrentSLD := backCurrentSLD
    ResetImgLoadStatus()
    RemoveTooltip()
    If (AnyWindowOpen!=2)
       PanelStaticFolderzManager()
}

uiFilterListDynaFolder(folderu, modus) {
    ; doExactMatch := (AnyWindowOpen=3) ? 0 : 1
    BtnCloseWindow()
    folderu := Trimmer(StrReplace(folderu, "|"))
    If (modus=3) ; full path recursive
    {
       userFilterStringPos := 2
       userFilterWhat := 1
       UsrEditFilter := folderu "\"
    } Else
    {
       userFilterStringPos := 3
       userFilterWhat := 2
       UsrEditFilter := folderu
    }

    userFilterProperty := userFilterDoString := 1
    userFilterInvertThis := userFilterStringIsNot := 0
    thisFilter := updateUIFiltersPanel("external")
    coreEnableFiltru(thisFilter)
    dummyTimerDelayiedImageDisplay(50)
}

MenuFilterListSelectedFolder() {
   uiLVfolderzFilterListBTN("menu-mode")
}

BtnToggleRecurseDynaFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_GetNext()
    LV_GetText(folderu, RowNumber, 3)
    LV_GetText(isPipe, RowNumber, 2)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    ; BtnCloseWindow()
    Sleep, 25
    foldersListu := "`n" getDynamicFoldersList() "`n"

    isPipe := InStr(isPipe, "R") ? 0 : 1
    If isPipe
       folderu := "|" folderu

    folderuz := StrReplace(folderu, "|")
    newfolderu := (isPipe!=1) ? "`n|" folderuz "`n" : "`n" folderuz "`n"
    newFoldersList := StrReplace(foldersListu, "`n" folderu "`n", newFolderu)
    Sort, newFoldersList, UD`n
    ; ToolTip, % folderu "`n" folderuz "`n" newFolderu "Z`n" DynamicFoldersList "`n Z `n" newFoldersList , , , 2
    DynamicFoldersList := newFoldersList
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    ; ToolTip, % newFoldersList , , , 2
    showTOOLtip("You need to rescan the folder for the effect to take place")
    PopulateDynamicFolderzList()
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNrescanDynaFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_GetNext()
    LV_GetText(folderu, RowNumber, 3)
    LV_GetText(recu, RowNumber, 2)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    BtnCloseWindow()
    Sleep, 25
    ; msgbox, % folderu
    mustOpenStartFolder := ""
    recu := InStr(recu, "R") ? "" : "|"
    z := wrapperAddNewFolderToList(recu folderu, 1)
    modus := InStr(recu, "|") ? 1 : 0
    If (z!="null" && RegExMatch(CurrentSLD, sldsPattern))
       updateCachedStaticFolders(folderu, modus)

    Sleep, 15
    PanelDynamicFolderzWindow()
}

updateCachedStaticFolders(mainFolderu, onlyMainFolder, updateAllDates:=0, allowDump:=1) {
   thisIndex := 0
   showTOOLtip("Updating static folders list")
   LoadStaticFoldersCached(CurrentSLD, countStaticFolders, "f")

   If !IsObject(mainFolderu)
   {
      foldersListArray := new hashtable()
      FileGetTime, dirDate, % mainFolderu, M
      foldersListArray[Format("{:L}", mainFolderu)] := dirDate
      If (onlyMainFolder!=1)
      {
         Loop, Files, %mainFolderu%\*, RD
         {
             FileGetTime, dirDate, %A_LoopFileFullPath%, M
             foldersListArray[Format("{:L}", A_LoopFileFullPath)] := dirDate
             ; Tooltip, % MoreNewFileFolders
         }
      }
   }

   counter++
   newArray := []
   hash := new hashtable()
   Loop, % newStaticFoldersListCache.MaxIndex()
   {
       ; update pre-existing folder dates
       folderu := newStaticFoldersListCache[A_Index, 1]
       oldDateu := newStaticFoldersListCache[A_Index, 2]
       z := Format("{:L}", folderu)
       If (!FolderExist(folderu) || hash[z]=1 || StrLen(folderu)<5)
          Continue

       counter++
       newArray[counter] := newStaticFoldersListCache[A_Index]
       hash[z] := 1
       If foldersListArray[z]
       {
          newArray[counter, 2] := foldersListArray[z]
          foldersListArray[z] := "-"
       } Else If (updateAllDates=1)
       {
          FileGetTime, newDateu, % folderu, M
          newArray[counter, 2] := newDateu
       }
   }

   For folderu, newDateu in foldersListArray
   {
       ; add new folder to main array: newStaticFoldersListCache[]
       If (hash[folderu]=1 || StrLen(folderu)<5 || newDateu="-")
          Continue

       counter++
       newArray[counter] := [folderu, newDateu]
   }

   newStaticFoldersListCache := []
   newStaticFoldersListCache := newArray.Clone()
   hash := ""
   foldersListArray := ""
   If (SLDtypeLoaded=3 && allowDump=1)
      SQLDBdumpStaticFoldersList()
}

SQLDBdumpStaticFoldersList() {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM staticfolders;")
   Loop, % newStaticFoldersListCache.MaxIndex()
       addStaticFolderSQLdb(newStaticFoldersListCache[A_Index, 1], newStaticFoldersListCache[A_Index, 2], 0)

   If !activeSQLdb.Exec("COMMIT TRANSACTION;")
      throwSQLqueryDBerror(A_ThisFunc)
}

remFilesFromList(SelectedDir, silentus:=0, forReal:=1) {
    If (silentus=0)
       showTOOLtip("Removing files from the list pertaining to`n" SelectedDir "\")

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    selectedFiles := markedSelectFile := 0
    If StrLen(filesFilter)>1
       remFilesListFilter("simple")

    oldMaxy := maxFilesIndex
    isPipe := InStr(SelectedDir, "|") ? 1 : 0
    SelectedDir := StrReplace(SelectedDir, "|")
    newArrayu := []
    Loop, % maxFilesIndex + 1
    {
        r := getIDimage(A_Index)
        If (InStr(r, "||") || !r)
           Continue

        If !isPipe
        {
           If InStr(r, SelectedDir "\")
              Continue
        } Else If (isPipe=1)
        {
           rT := StrReplace(r, SelectedDir "\")
           If !InStr(rT, "\")
              Continue
        }

        countFiles++
        newArrayu[countFiles] := resultedFilesList[A_Index]
        If (resultedFilesList[A_Index, 2]=1)
           selectedFiles++
    }

    If (SLDtypeLoaded=3)
    {
       thisR := Format("{:L}", SQLescapeStr(SelectedDir, 1))
       thisR := (isPipe=1) ? thisR : thisR "%"
       If (forReal=1)
       {
          activeSQLdb.Exec("BEGIN TRANSACTION;")
          SQLstr := "DELETE FROM images WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          If !activeSQLdb.Exec(SQLStr)
          {
             stringA:= thisR
             activeSQLdb.EscapeStr(stringA)
             SQLstr := "DELETE FROM images WHERE imgfolder LIKE " stringA " ESCAPE '>';"
             activeSQLdb.Exec(SQLStr)
          }

          If !activeSQLdb.Exec("COMMIT TRANSACTION;")
             throwSQLqueryDBerror(A_ThisFunc)
       } Else
       {
          SQLstr := "UPDATE images SET isDeleted=1 WHERE imgfolder LIKE '" thisR "' ESCAPE '>';"
          If !activeSQLdb.Exec(SQLstr)
             throwSQLqueryDBerror(A_ThisFunc)
       }
    }

    renewCurrentFilesList()
    maxFilesIndex := countFiles
    resultedFilesList := newArrayu.Clone()
    markedSelectFile := selectedFiles
    ForceRefreshNowThumbsList()
    filesRemoved := oldMaxy - maxFilesIndex
    If (SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    If (filesRemoved<1)
       filesRemoved := 0
    Else
       currentFilesListModified := 1

    CurrentSLD := backCurrentSLD
    If (silentus=0)
       showTOOLtip("Finished removing " filesRemoved " files from the list")

    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

PanelRenameStaticFolder() {
    ; Global newFileName, idFolder, remFilesFromFolder, doRemRecursively
    winOpen := AnyWindowOpen
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    colNum := (AnyWindowOpen=3) ? 3 : 1
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, colNum)
    folderu := (AnyWindowOpen=2) ? newStaticFoldersListCache[indexu, 1] : indexu
    If (StrLen(folderu)<3 || folderu="folder path")
        Return

    If (SLDtypeLoaded=2 && AnyWindowOpen=2)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
          Return
       }
   }

   Sleep, 15
   folderu := StrReplace(folderu, "|")
   msgResult := msgBoxWrapper("Rename static folder entry: " appTitle, "Please type the new folder path.", "&Rename folder entry|C&ancel", 1, "modify-entry", "Propagate the change to subfolders", 1, 0, "limit9050 w850", folderu)
   If InStr(msgResult.btn, "Rename")
   {
      doPropagate := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      newFileName := StrReplace(newFileName, "/", "\")
      newFileName := StrReplace(newFileName, "|")
      newFileName := Trimmer(newFileName, "\")
      newFileName := RegExReplace(newFileName, "\\{2,}", "\")
      If (newFileName=folderu)
      {
         SetTimer, PanelRenameStaticFolder, -300
         Return
      }

      If (!RegExMatch(newFileName, "i)^(.\:\\.)") || !newFileName)
      {
         showTOOLtip("WARNING: Incorrect folder path provided")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelRenameStaticFolder, -300
         Return
      }

      If !FolderExist(newFileName)
      {
         showTOOLtip("WARNING: Inexistent folder path provided")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelRenameStaticFolder, -300
         Return
      }

      BtnCloseWindow()
      newName := newFileName
      If (winOpen=2)
      {
         showTOOLtip("Updating static folders list")
         If (SLDtypeLoaded=3)
         {
            Sleep, 25
         } Else
         {
            Loop, % newStaticFoldersListCache.MaxIndex()
            {
               If (newStaticFoldersListCache[A_Index, 1]=folderu)
               {
                  newStaticFoldersListCache[A_Index, 1] := newName
               } Else If (doPropagate=1)
               {
                  If InStr(newStaticFoldersListCache[A_Index, 1], folderu "\")
                     newStaticFoldersListCache[A_Index, 1] := StrReplace(newStaticFoldersListCache[A_Index, 1], folderu "\", newName "\")
               }
            }
         }
      } Else
      {
         finalListu := ""
         foldersListu := getDynamicFoldersList()
         Loop, Parse, foldersListu,`n,`r
         {
            line := StrReplace(A_LoopField, "|")
            If (line=folderu)
               finalListu .= StrReplace(A_LoopField, folderu, newName) "`n"
            Else
               finalListu .= (doPropagate=1) ? StrReplace(A_LoopField, folderu "\", newName "\") "`n" : A_LoopField "`n"
         }

         DynamicFoldersList := cleanDynamicFoldersList(finalListu)
         If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=3)
            recreateDynaFoldersSQLdbList(DynamicFoldersList)
      }

      currentFilesListModified := 1
      msgResult := msgBoxWrapper(appTitle ": Update files list", "You have renamed a folder entry. Would you like to perform a search and replace in the files list to update the corresponding records?", 4, 0, "question")
      If (msgResult="Yes")
         SearchAndReplaceThroughIndex(folderu "\", newName "\", 0, 1)

      SetTimer, RemoveTooltip, % -msgDisplayTime
      ; MsgBox, % firstPart "`n" newName "`n" indexSelected
      If (winOpen=2)
         PanelStaticFolderzManager()
      Else
         PanelDynamicFolderzWindow()
    }
}

SearchAndReplaceThroughIndex(what, replacer, silentus:=0, folderMode:=0) {
    If (silentus=0)
       showTOOLtip("Performing search and replace in the files list index:`n" what "`n" replacer)

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    changeMcursor()
    getSelectedFiles(0, 1)
    If (StrLen(filesFilter)>1 && SLDtypeLoaded=3)
       remFilesListFilter("simple")

    selectedFiles := totalAffected := 0
    If (SLDtypeLoaded=3)
    {
       whatESC := SQLescapeStr(what)
       replacerESC := SQLescapeStr(replacer)
       ; activeSQLdb.EscapeStr(what)
       ; activeSQLdb.EscapeStr(replacer)
       activeSQLdb.Exec("BEGIN TRANSACTION;")
       If (folderMode=1)
          SQLstr := "UPDATE images SET imgfolder='" Trimmer(replacerESC, "\") "' WHERE imgfolder='" Trimmer(whatESC, "\") "' COLLATE NOCASE;"

       startOperation := A_TickCount
       prevMSGdisplay := A_TickCount
       If (activeSQLdb.Exec(SQLStr) || folderMode!=1)
       {
          If (folderMode=1)
             SQLstr := "SELECT imgidu, imgfolder FROM images WHERE imgfolder LIKE '" Trimmer(SQLescapeStr(what, 1), "\") "\%' ESCAPE '>';"
          Else
             SQLstr := "SELECT imgidu, imgfolder FROM images WHERE imgfolder LIKE '%" SQLescapeStr(what, 1) "%' ESCAPE '>';"

          If !activeSQLdb.GetTable(SQLstr, RecordSet)
             errorOccured := activeSQLdb.ErrorMsg

          changeMcursor()
          totalFiles := RecordSet.RowCount
          Loop, % RecordSet.RowCount
          {
              changeMcursor()
              Row := RecordSet.Rows[A_Index]
              If (A_TickCount - prevMSGdisplay>1500)
              {
                 etaTime := ETAinfos(A_Index, totalFiles, startOperation)
                 showTOOLtip("Performing search and replace in the files list index" etaTime, 0, 0, A_Index/totalFiles)
                 prevMSGdisplay := A_TickCount
              }

              If Row[2]
              {
                 newFolderName := StrReplace(Row[2], what, replacer)
                 SQLstr := "UPDATE images SET imgfolder='" SQLescapeStr(newFolderName) "' WHERE imgidu='" Row[1] "';"
                 If !activeSQLdb.Exec(SQLstr)
                    failedFiles++
              }
          }
          RecordSet.Free()
       } Else errorOccured := activeSQLdb.ErrorMsg

       showTOOLtip("Finishing search and replace in the files list, please wait")
       activeSQLdb.Exec("COMMIT TRANSACTION;")
    }

    If !errorOccured
    {
       Loop, % maxFilesIndex + 1
       {
           imgPath := getIDimage(A_Index)
           If !imgPath
              Continue

           If (!resultedFilesList[A_Index, 2] && limitSearchReplaceSelected=1 && SLDtypeLoaded!=3)
              Continue

           value := StrReplace(imgPath, what, replacer, affected)
           value := StrReplace(value, "\\", "\")
           resultedFilesList[A_Index, 1] := value
           If StrLen(filesFilter)>1
              updateMainUnfilteredList(A_Index, 1, value)

           totalAffected += affected
           If (resultedFilesList[A_Index, 2]=1)
              selectedFiles++
       }
    }

    If totalAffected
       currentFilesListModified := 1

    markedSelectFile := selectedFiles
    ForceRefreshNowThumbsList()
    dummyTimerDelayiedImageDisplay(50)
    If (SLDtypeLoaded=3)
       getMaxRowIDsqlDB()

    If errorOccured
    {
       showTOOLtip("Failed to update the files list database`n" errorOccured)
       SoundBeep , 300, 100
    } Else
    {
       If failedFiles
          someErrors := "Failed to modify " groupDigits(failedFiles) " entries in the files list`n"
       showTOOLtip(someErrors "Finished updating the files list`n" groupDigits(totalAffected) " records were modified")
       SoundBeep , 900, 100
    }

    CurrentSLD := backCurrentSLD
    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -100
}

SearchAndReplaceSeenDB(what, replacer) {
    initSeenImagesListDB()
    If (sqlFailedInit=1)
    {
       showTOOLtip("Failed to initialize database of seen images")
       SoundBeep 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    startOperation := A_TickCount
    showTOOLtip("Performing search and replace in the seen database list:`n" what "`n" replacer)
    changeMcursor()
    whatESC := what
    replacerESC := replacer
    seenImagesDB.EscapeStr(whatESC)
    seenImagesDB.EscapeStr(replacerESC)
    seenImagesDB.Exec("BEGIN TRANSACTION;")
    SQLstr := "SELECT ROWID, imgfile FROM images WHERE imgfile LIKE '%" Trimmer(SQLescapeStr(what, 1)) "%' ESCAPE '>';"
    If !seenImagesDB.GetTable(SQLstr, RecordSet)
       errorOccured := seenImagesDB.ErrorMsg

    totalAffected := failedFiles := 0
    totalFiles := RecordSet.RowCount
    If !errorOccured
    {
       Loop, % RecordSet.RowCount
       {
           changeMcursor()
           Row := RecordSet.Rows[A_Index]
           If (A_TickCount - prevMSGdisplay>1500)
           {
              etaTime := ETAinfos(A_Index, totalFiles, startOperation)
              showTOOLtip("Performing search and replace in the seen database list" etaTime, 0, 0, A_Index/totalFiles)
              prevMSGdisplay := A_TickCount
           }

           If Row[2]
           {
              newFolderName := StrReplace(Row[2], what, replacer)
              SQLstr := "UPDATE images SET imgfile='" SQLescapeStr(newFolderName) "' WHERE ROWID='" Row[1] "';"
              If !seenImagesDB.Exec(SQLstr)
                 failedFiles++
              Else
                 totalAffected++
           }
       }
       RecordSet.Free()
    }

    k := seenImagesDB.Exec("COMMIT TRANSACTION;")
    If (errorOccured || !k)
    {
       showTOOLtip("Failed to update the seen images database`n" errorOccured)
       SoundBeep , 300, 100
    } Else
    {
       If failedFiles
          someErrors := "Failed to modify " groupDigits(failedFiles) " entries in the seen images database`n"
       showTOOLtip(someErrors "Finished updating the seen images database`n" groupDigits(totalAffected) " records were modified")
       SoundBeep , 900, 100
    }

    CurrentSLD := backCurrentSLD
    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -200
}

BTNupdateSelectedStaticFolder() {
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_GetNext(0, "F")
    LV_GetText(indexu, RowNumber, 1)
    folderu := newStaticFoldersListCache[indexu, 1]
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded=2 && FileExist(CurrentSLD))
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
          Return
       } Else allGood := 1
    }

   indexu := RowNumber := 0
   total := LV_GetCount()
   foldersListArray := new hashtable()
   Loop, % total
   {
       RowNumber := LV_GetNext(RowNumber)
       If !RowNumber
          Break

       LV_GetText(indexu, RowNumber, 1)
       If !indexu
          Continue

       folderu := Format("{:L}", newStaticFoldersListCache[indexu, 1])
       If folderu
          foldersListArray[folderu] := indexu
    }

    If (foldersListArray.Count()<1)
    {
       foldersListArray := ""
       Return
    }

    BtnCloseWindow()
    Sleep, 5
    currentFilesListModified := 1
    For foldar, indexu in foldersListArray
    {
       newStaticFoldersListCache[indexu, 3] := ""
       newStaticFoldersListCache[indexu, 4] := ""
       wrapperAddNewFolderToList("|" foldar, 0, 1)
    }

    setImageLoading()
    If (SLDtypeLoaded=3 || SLDtypeLoaded=2 && allGood=1)
    {
       showTOOLtip("Updating static folders list")
       setWhileLoopExec(1)
       For foldar, indexu in foldersListArray
       {
           FileGetTime, dirDate, % foldar, M
           foldersListArray[foldar] := dirDate
       }
       updateCachedStaticFolders(foldersListArray, 1)
       setWhileLoopExec(0)
    }

    ResetImgLoadStatus()
    Sleep, 5
    SetTimer, RemoveTooltip, % -msgDisplayTime
    foldersListArray := ""
    PanelStaticFolderzManager()
}

UIeditApplyStaticFolderFilter() {
   If (imageLoading=1)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, StaticListViewFilteru
   If StrLen(Trimmer(StaticListViewFilteru))<2
   {
      UIlvFilterEraseStaticPanel()
      Return
   }

   If (lastFilterEditSearch=StaticListViewFilteru)
      Return

   lastFilterEditSearch := Trimmer(StaticListViewFilteru)
   SetTimer, UIfilterListViewStaticFolderzList, -50
}

UIfilterListViewStaticFolderzList() {
   If (AnyWindowOpen!=2)
      Return

   Gui, SettingsGUIA: Default
   GuiControlGet, StaticListViewFilteru
   If (imageLoading=1)
      Return

   PopulateStaticFolderzList(staticListViewFilteru)
}

retrieveListFoldersIndexed() {
   foldersListArray := new hashtable()

   If (SLDtypeLoaded=3 && RegExMatch(CurrentSLD, sldsPattern))
   {
      SQL := "SELECT imgfolder, COUNT(*) FROM images GROUP BY imgfolder;"
      If !activeSQLdb.GetTable(SQL, RecordSet)
      {
         throwSQLqueryDBerror(A_ThisFunc)
         Return
      }

      Loop, % RecordSet.RowCount
      {
          Rowu := RecordSet.Rows[A_Index]
          If Rowu[1]
          {
             OutDir := Rowu[1]
             foldersListArray[OutDir] := 1
          }
      }

      RecordSet.Free()
   } Else
   {
      Loop, % maxFilesIndex + 1
      {
           imgPath := resultedFilesList[A_Index, 1]
           If (InStr(imgPath, "||") || !imgPath)
              Continue

           OutDir := Format("{:L}", SubStr(imgPath, 1, InStr(imgPath, "\", 0, -1) - 1))
           foldersListArray[OutDir] := 1
      }
   }
   Return foldersListArray
}

PopulateStaticSQLfolderzList(modus:=0) {

    If (StrLen(newStaticFoldersListCache[1, 1])>4 && modus!="forced")
       Return newStaticFoldersListCache.MaxIndex()

    RecordSet := ""
    Tooltip, Gathering folders list - please wait
    SQL := "SELECT imgfolder, COUNT(*) FROM images GROUP BY imgfolder;"
    If !activeSQLdb.GetTable(SQL, RecordSet)
    {
       Tooltip
       throwSQLqueryDBerror(A_ThisFunc)
       SetTimer, ResetImgLoadStatus, -200
       Return 0
    }

    arrayList := []
    fCountThese := 0
    Loop, % RecordSet.RowCount
    {
        Rowu := RecordSet.Rows[A_Index]
        If Rowu[1]
        {
           fCountThese++
           arrayList[fCountThese] := [Rowu[1], Rowu[2]]
        }
    }

    RecordSet.Free()
    SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
    If !activeSQLdb.GetTable(SQL, RecordSet)
    {
       throwSQLqueryDBerror(A_ThisFunc)
       SetTimer, ResetImgLoadStatus, -200
       Return 0
    }

    foldersDatesArray := new hashtable()
    Loop, % RecordSet.RowCount
    {
        Rowu := RecordSet.Rows[A_Index]
        If Rowu[1]
           foldersDatesArray[Format("{:L}", Rowu[1])] := Rowu[2]
    }

    countThese := 0
    RecordSet.Free()
    newStaticFoldersListCache := []
    Loop, % fCountThese
    {
        folderu := Trimmer(arrayList[A_Index, 1])
        If (StrLen(folderu)<5)
           Continue

        countThese++
        oldDateu := foldersDatesArray[Format("{:L}", folderu)]
        countFiles := arrayList[A_Index, 2]
        newStaticFoldersListCache[countThese] := [folderu, oldDateu, countFiles]
    }

    foldersDatesArray := ""
    Return countThese
}

PopulateStaticFolderzList(listFilter:=0, modus:=0) {

    EM_SETCUEBANNER(hEditField, "Preparing folders list - please wait", 1)
    startOperation := A_TickCount
    setImageLoading()
    Tooltip, Preparing folders list - please wait
    If (SLDtypeLoaded=3)
       PopulateStaticSQLfolderzList()
    Else 
       LoadStaticFoldersCached(CurrentSLD, hmmm, 1)

    countStaticFolders := newStaticFoldersListCache.MaxIndex()
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewOthers
    setImageLoading()
    LV_Delete()
    GuiControl, -Redraw, LViewOthers
    Tooltip, Listing folders now - please wait...
    startZeit := A_TickCount
    Loop, 10
    {
       If !isInRange(A_Index, 2, 4)
          LV_ModifyCol(A_Index, "Integer")
    }

    doStartLongOpDance()
    startOperation := A_TickCount
    hasAutoSized := thisIndex := foldersCount := 0
    isUpdateList := (RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1) ? 1 : 0
    prevMSGdisplay := A_TickCount
    k := SubStr(listFilter, 1, 2)
    givenLimit := SubStr(listFilter, 3)
    If StrLen(listFilter)<2
       listFilter := ""

    If (k=":>" || k=":<" || k="?>" || k="?<" || k="*>" || k="*<")
    || (k="!>" || k="!<" || k="#>" || k="#<" || k="$>" || k="$<")
    {
       listFilter := ""
       If (isNumber(givenLimit) && givenLimit>0)
       {
          filterWhat := SubStr(k, 1, 1)
          limitMode := InStr(k, ">") ? 2 : 1
       }
       ; TulTip(0, "|  ", k, givenLimit, limitMode, filterWhat)
    } Else If listFilter
    {
       thisString := StrReplace(Trimmer(listFilter), "||", "|")
       thisString := Trimmer(thisString, "|")
       thisFilter := "i)(" JEE_StrRegExLiteral(thisString) ")"
       isStrFilter := StrLen(thisString)>1 ? 1 : 0
       FilterSimple := (InStr(thisString, "|") || InStr(thisString, "*") || InStr(thisString, "?")) ? 0 : 1
    }

    Loop, % countStaticFolders
    {
        folderu := newStaticFoldersListCache[A_Index, 1]
        If (StrLen(folderu)<2)
           Continue

        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           CountFilesFolderzList := 0
           Break
        }

        If (isStrFilter=1 && FilterSimple=1)
        {
           If !inStr(folderu, thisString)
              Continue
        } Else If (isStrFilter=1)
        {
           If !RegExMatch(folderu, thisFilter)
              Continue
        }

        If (A_TickCount - prevMSGdisplay>1000)
        {
           prevMSGdisplay := A_TickCount
           showTOOLtip("Populating the list, please wait`n" groupDigits(countStaticFolders) " folders", 0, 0, A_Index/countStaticFolders)
        }

        If (userPrivateMode=1)
           folderu := "*:\********\******\"

        oldDateu := newStaticFoldersListCache[A_Index, 2]
        If (oldDateu="-")
        {
           statusu := dirDate := "-"
        } Else 
        {
           FileGetTime, dirDateO, % folderu, M
           statusu := (dirDateO!=oldDateu && isUpdateList=1) ? "*" : ""
           dirDate := SubStr(dirDateO, 1, StrLen(dirDate) - 2)
           FormatTime, dirDate, % dirDate, yyyy/MM/dd ; -HH:mm
        }
        countedSelFiles := markedSelectFile ? Round(newStaticFoldersListCache[A_Index, 4]) : 0
        countFiles := newStaticFoldersListCache[A_Index, 3]
        countTFiles := newStaticFoldersListCache[A_Index, 5]
        countSize := Round(Round(newStaticFoldersListCache[A_Index, 6]/1024, 1)/1024, 1)
        diffu := (ountTFiles!="" && countFiles!="") ? countTFiles - countFiles : 0
        perc := countFiles ? Round((Round(countedSelFiles)/countFiles)*100, 1) : 0
        If filterWhat
        {
           thisValue := (filterWhat="?") ? countFiles : countedSelFiles
           If (filterWhat="*")
              thisValue := perc
           Else If (filterWhat="!")
              thisValue := countTFiles
           Else If (filterWhat="#")
              thisValue := diffu
           Else If (filterWhat="$")
              thisValue := countSize
        }

        If ((thisValue>=givenLimit && limitMode=1) || (thisValue<=givenLimit && limitMode=2) && countFiles && thisValue)
           Continue

        ; ToolTip, % "v=" countFiles "=" countedSelFiles , , , 2
        LV_Add(A_Index, A_Index, dirDate, statusu, folderu, countFiles, countedSelFiles, perc, countTFiles, diffu, countSize)
        If ((A_Index=5 || A_Index=10) && (modus="init"))
        {
           hasAutoSized := 1
           Loop, 10
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }
    ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 
    EM_SETCUEBANNER(hEditField, "Filter folders list: " groupDigits(LV_GetCount()) " entries", 1)
    executingCanceableOperation := 0
    If (!hasAutoSized && modus="init")
    {
       Loop, 10
           LV_ModifyCol(A_Index, "AutoHdr Left")
    }

    If (modus="init")
       LV_ModifyCol(3, "SortDesc")
    GuiControl, +Redraw, LViewOthers
    RemoveTooltip()
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

StrPutVar(string, ByRef var, encoding) {
    ; Ensure capacity.
    ; StrPut returns char count, but VarSetCapacity needs bytes.
    VarSetCapacity(var, StrPut(string, encoding) * ((encoding="utf-16"||encoding="cp1200") ? 2 : 1))
    ; Copy or convert the string.
    return StrPut(string, &var, encoding)
}

PopulateDynamicFolderzList() {
    listu := getDynamicFoldersList()
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: ListView, LViewDynas
    LV_Delete()

    Loop, 9
    {
       If !isInRange(A_Index, 2, 3)
          LV_ModifyCol(A_Index, "Integer")
    }

    Loop, Parse, listu, `n
    {
        statusu := InStr(A_LoopField, "|") ? "" : "R"
        line := (userPrivateMode=1) ? "*:\*****\********\" :  Trimmer(A_LoopField)
        If (StrLen(line)<3)
           Continue

        counteru++
        LV_Add(A_Index, counteru, statusu, StrReplace(line, "|"))
    }

    Loop, 3
        LV_ModifyCol(A_Index, "AutoHdr Left")

    LV_ModifyCol(3, "Sort")
    ResetImgLoadStatus()
}

uiPanelOpenCloseEvent(modus:=0) {
    b := (modus=1) ? "|" 0 "|" 0 "|" 0 "|" : "|" imgEditPanelOpened "|" AnyWindowOpen "|" hSetWinGui "|"
    a := panelWinCollapsed "|" liveDrawingBrushTool b editingSelectionNow "|" maxFilesIndex "|" UserMemBMP "|" undoLevelsRecorded "|" currentFilesListModified "|" lastOtherWinClose "|" IMGresizingMode "|" thumbsDisplaying
    interfaceThread.ahkPostFunction("PanelOpenCloseEvent", a)
}

CloseWindow(forceIT:=0, cleanCaches:=1) {
    Critical, on
    If (toolTipGuiCreated=2)
       SetTimer, RemoveTooltip, -3500

    If isNowAlphaPainting()
    {
       BTNtoggleAlphaPainting()
       Return 1
    }

    createGUItoolbar("state")
    BalloonTip_Kill()
    endCaptureCloneBrush()
    ; tabzDarkModus := (uiUseDarkMode=1) ? "-Border +Buttons cFFFFaa" : ""
    fnOutputDebug("Close window: " prevOpenedWindow[1] "---" prevOpenedWindow[2])
    If (isNowFakeWinOpen=1 && AnyWindowOpen)
    {
       isNowFakeWinOpen := AnyWindowOpen := 0
       uiPanelOpenCloseEvent()
       SetTimer, CloseMsgBox2Win, Delete
       SetTimer, WatchMsgBox2Win, Delete
       MsgBox2Result := "win_closed"
       MsgBox2InputHook.Stop()
       Gui, WinMsgBox: Destroy
       MsgBox2hwnd := ""
       Sleep, 25
       Return 1
    }

    If (forceIT!="yes")
    {
       If (A_TickCount - lastLongOperationAbort < 1000)
          Return 1
    }

    If (panelWinCollapsed=1)
       Gui, collapseWidgetGUIA: Hide

    Sleep, 5
    If (imgEditPanelOpened!=1)
       ResetImgLoadStatus()

    If (AnyWindowOpen>0 && repositionedWindow=1)
       Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%

    uiSlidersArray := []
    lastSlidersPainted := []
    If (uiUseDarkMode=1)
       CtlColors.Free()

    If (ShowAdvToolbar!=1)
       trackImageListButtons("kill")

    Global lastOtherWinClose := A_TickCount
    panelWinCollapsed := forceLiveAlphaPreviewMode := FloodFillSelectionAdj := liveDrawingBrushTool := isNowFakeWinOpen := ForceNoColorMatrix := 0
    uiPanelOpenCloseEvent(1)
    DestroyGIFuWin()

    Gui, SettingsGUIA: Destroy
    WinActivate, ahk_id %PVhwnd%
    postVectorWinOpen := 0
    killToneMapImageCacheObj()
    If (imgEditPanelOpened=1)
    {
       If (viewportQPVimage.imgHandle)
          imgFxMode := 1

       If (VisibleQuickMenuSearchWin=1)
          closeQuickSearch()
       ; coreDesiredPixFmt := validBMP(UserMemBMP) ? "0x26200A" : "0xE200B" ; 32-ARGB // 32-PARGB
       If (AnyWindowOpen=74)
       {
          usrColorDepth := imgFxMode := 1
          ; If (wasVPfxBefore=0)
          ;    usrColorDepth := imgFxMode := 1
          ; Else 
          ;    usrColorDepth := (imgFxMode>1) ? DesaturateAreaLevels : 1

          ColorDepthDithering := DesaturateAreaDither
          INIaction(1, "ColorDepthDithering", "General")
          INIaction(1, "usrColorDepth", "General")
          INIaction(1, "imgFxMode", "General")
          defineColorDepth()
       } Else If (AnyWindowOpen=64)
       {
          clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       } Else If ((AnyWindowOpen=23 || AnyWindowOpen=68) && editingSelectionNow=1)
       {
          If (FillAreaShape=3)
             EllipseSelectMode := 1
          Else If (FillAreaShape=7)
             EllipseSelectMode := 2
          Else
             EllipseSelectMode := 0
       }

       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIwin, glHDC)
       ToggleVisibilityWindow("hide", hGDIthumbsWin)
       Gdip_GraphicsClear(2NDglPG, "0xff" WindowBGRcolor)
       r2 := doLayeredWinUpdate(A_ThisFunc, hGDIthumbsWin, 2NDglHDC)
       editingSelectionNow := prevOpenedWindow[4]
       dummyTimerDelayiedImageDisplay(90)
       getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
       livePreviewInsertTextinArea("kill")
       livePreviewSymmetricaImgArea("kill")
       livePreviewSimpleColorsAdjustImage("kill")
       realtimePasteInPlaceAlphaMasker("kill", 2, 1, lol)
       getImgOriginalSelectedAreaEdit("kill", 0, 0, 0, 0, 0, 0, 0)
       If (cleanCaches!=0)
       {
          drawFillSelGradient("kill", 0, 0, 0, 0, 0, 0)
          corePasteInPlaceActNow("kill")
          coreFillSelectedArea("kill")
          If oldSelectionArea[11]
             FreeImage_UnLoad(oldSelectionArea[11])
          oldSelectionArea := []
       }
       ; If (AnyWindowOpen=64)
       ; SetTimer, dummyRefreshImgSelectionWindow, -200
    }

    If !testIsDupesList()
       toBeExcludedIndexes := []

    If (AnyWindowOpen=6)
       InitialFilterSettingsPanel(0)

    hSetWinGui := imgEditPanelOpened := AnyWindowOpen := 0
    updateUIctrl()
    TriggerMenuBarUpdate()
    createGUItoolbar()
}

adjustCanvas2Toolbar(Gu, applyTransform) {
    Static lastX := 0, lastY := 0
    If (ShowAdvToolbar!=1 || lockToolbar2Win!=1 || slideShowRunning=1)
       Return 0

    hasTrans := 0
    WinGetPos, thisX, thisY, , , ahk_id %hQPVtoolbar%
    If (thisX="" && ToolbarWinW && ToolbarWinH)
       thisX := lastX
    If (thisY="" && ToolbarWinW && ToolbarWinH)
       thisY := lastY

    JEE_ScreenToClient(PVhwnd, thisX, thisY, thisX, thisY)
    positionOk := (isInRange(thisX, -5, 5) && isInRange(thisY, -5, 5)) ? 1 : 0
    ; ToolTip, % "p=" positionOk "||" UserToolbarX "|" UserToolbarY "||" thisX "|" thisY , , , 2
    If (positionOk=1 && (TLBRverticalAlign=1 || TLBRtwoColumns=1))
    {
       hasTrans := 1
       If (applyTransform=1)
          Gdip_TranslateWorldTransform(Gu, ToolbarWinW, 0)
    } Else If (positionOk=1 && TLBRverticalAlign=0)
    {
       hasTrans := 2
       If (applyTransform=1)
          Gdip_TranslateWorldTransform(Gu, 0, ToolbarWinH)
    }

    If hasTrans
    {
       lastX := thisX
       lastY := thisY
    }

    Return hasTrans
}

CreateOSDinfoLine(msg:=0, killWin:=0, forceDarker:=0, perc:=0, funcu:=0, typeFuncu:=0) {
    Critical, On
    Static prevMsg, preventKill, lastInvoked := 1

    If (TouchScreenMode=1 && typeFuncu=1)
    {
       hudBTNfuncu := funcu
       hudBTNtypeFuncu := 1 ; typeFuncu
    } Else hudBTNtypeFuncu := hudBTNfuncu := 0

    If (killWin=1 || killWin=2 || StrLen(msg)<3)
    {
       If (A_TickCount - lastInvoked<msgDisplayTime + 900) && (preventKill=1)
       || (A_TickCount - lastInvoked<350) && (killWin=1 && slideShowRunning!=1)
       {
          If (killWin!=2)
          {
             SetTimer, RemoveTooltip, -400
             Return
          }
       }

       toolTipGuiCreated := 0
       interfaceThread.ahkPostFunction("uiAccessUpdateOSDmsg", "-", 0, 0)
       interfaceThread.ahkassign("toolTipGuiCreated", 0)
       clearGivenGDIwin(A_ThisFunc, 2NDglPG, 2NDglHDC, hGDIinfosWin)
       hudBTNtypeFuncu := hudBTNfuncu := 0
       preventKill := 0
       Return
    }

    If (A_TickCount - lastInvoked<95) && (forceDarker!=1)
    {
       SetTimer, dummyPrevShowToolTip, -200
       Return
    }

    If (A_TickCount - lastInvoked<msgDisplayTime - 300) && (preventKill=1 && prevMsg!=msg && runningLongOperation!=1)
       msgBoxWrapper(appTitle ": ERROR", prevMsg, 0, 0, "error")

    If perc
       mp .= ". Range: " Round(perc*100) "%."

    interfaceThread.ahkFunction("infosUIAbtns", msg mp)
    addJournalEntry("OSD: " msg)
    If (!CurrentSLD && currentFileIndex!=0) || (forceDarker=1)
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x66" WindowBgrColor, 1)
    Else
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)

    preventKill := 0
    If RegExMatch(msg, "i)^(error|failed)")
    {
       preventKill := 1
       uBrushA := Gdip_BrushCreateSolid("0xEEFF2200")
    } Else If RegExMatch(msg, "i)^(WARNING|operation aborted)")
       uBrushA := Gdip_BrushCreateSolid("0xEEFFDE21")

    knobSize := imgHUDbaseUnit//3.5
    posXu := uBrushA ? knobSize : 0
    vpWinClientSize(mainWidth, mainHeight)
    BoxBMP := drawTextInBox(msg, OSDFontName, OSDfontSize, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0)
    If !validBMP(BoxBMP)
    {
       Gdip_DeleteBrush(uBrushA)
       Return
    }

    ; hasTrans := adjustCanvas2Toolbar(2NDglPG, 1)
    tlbrBonusX := (hasTrans=1) ? ToolbarWinW : 0
    tlbrBonusY := (hasTrans=2) ? ToolbarWinH : 0
    posYu := perc ? knobSize//2 : 0
    trGdip_GetImageDimensions(BoxBMP, imgW, imgH)
    If (showInfoBoxHUD>0 && FlipImgH=0 && FlipImgV=0 && drawingShapeNow!=1)
    {
       thisBrush := Gdip_BrushCreateSolid("0x20" OSDbgrColor)
       unitu := lastInfoBoxBMP[1, 2] // 5
       Loop, 4
          Gdip_FillRectangle(2NDglPG, thisBrush, 0, knobSize, lastInfoBoxBMP[1,1], unitu)
       Loop, 3
          Gdip_FillRectangle(2NDglPG, thisBrush, 0, knobSize + unitu, lastInfoBoxBMP[1,1], unitu)
       Loop, 2
          Gdip_FillRectangle(2NDglPG, thisBrush, 0, knobSize + unitu *2, lastInfoBoxBMP[1,1], unitu)

       Gdip_FillRectangle(2NDglPG, thisBrush, 0, knobSize + unitu *3, lastInfoBoxBMP[1,1], unitu)
       Gdip_DeleteBrush(thisBrush)
    }

    If (typeFuncu="swipe-mode" && TouchScreenMode=1)
    {
       ; draw the viewport sections
       thisThick := imgHUDbaseUnit//11
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       Gdip_SetClipRect(2NDglPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(2NDglPG, pPen4, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(2NDglPG)
       If (editingSelectionNow!=1)
       {
          Gdip_DrawRectangle(2NDglPG, pPen4, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
          Gdip_DrawRectangle(2NDglPG, pPen4, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
          If (totalFramesIndex>1)
          {
             mwh := Round(mainHeight * 0.7)
             Gdip_DrawLine(2NDglPG, pPen4, 0, mwh, thisX, mwh)
             Gdip_DrawLine(2NDglPG, pPen4, thisX + thisW, mwh, mainWidth, mwh)
          }
       } Else
       {
          Gdip_DrawLine(2NDglPG, pPen4, thisX, 0, thisX, thisY)
          Gdip_DrawLine(2NDglPG, pPen4, thisX + thisW, 0, thisX + thisW, thisY)
          Gdip_DrawLine(2NDglPG, pPen4, thisX, thisH + thisY, thisX, mainHeight)
          Gdip_DrawLine(2NDglPG, pPen4, thisX + thisW, thisH + thisY, thisX + thisW, mainHeight)
       }
       Sleep, 1
    }

    tzGdip_DrawImage(2NDglPG, BoxBMP, posXu, posYu, imgW, imgH)
    hudBTNheightFuncu := imgH + posYu + tlbrBonusY
    hudBTNwidthFuncu := imgW + posXu + tlbrBonusX
    If uBrushA
    {
       Gdip_FillRectangle(2NDglPG, uBrushA, 0, posYu, knobSize, imgH)
       Gdip_FillRectangle(2NDglPG, uBrushA, imgW + posXu, posYu, knobSize, imgH)
    }

    omsg := msg "."
    If perc
    {
       percW := Round(mainWidth*perc)
       Gdip_FillRectangle(2NDglPG, pBrushE, percW, 0, mainWidth - percW + 1, knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushB, 0, knobSize//2, mainWidth, 3)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, percW, knobSize//2)
       omsg .= "`nProgress bar at " Round(perc*100) "%."
    }

    If hudBTNfuncu
       omsg .= "`nTemporarily clickable area."

    interfaceThread.ahkPostFunction("uiAccessUpdateOSDmsg", omsg, mainWidth, imgH)
    If (hudBTNfuncu && hudBTNtypeFuncu=1)
       Gdip_FillRectangle(2NDglPG, pBrushD, posXu, posYu, knobSize//2, imgH)

    If hasTrans
       Gdip_ResetWorldTransform(2NDglPG)

    r2 := doLayeredWinUpdate(A_ThisFunc, hGDIinfosWin, 2NDglHDC)
    trGdip_DisposeImage(BoxBMP, 1)
    Gdip_DeleteBrush(uBrushA)
    toolTipGuiCreated := 1
    prevMsg := msg
    If (prevMsg!=msg)
       lastInvoked := A_TickCount

    If ((perc || hudBTNfuncu) && InStr(mainCompiledPath, "\sucan twins") && !InStr(msg, "zoom level"))
    && runningLongOperation!=1 && (A_TickCount - lastOSDtooltipInvoked > 325)
       interfaceThread.ahkPostFunction("sndBeep", 1654, 100)

    lastOSDtooltipInvoked := A_TickCount
    If (forceDarker!=1)
       interfaceThread.ahkassign("toolTipGuiCreated", 1)
}

BlackedCreator(thisOpacity, killWin:=0) {
    Critical, On
    Static lastInvoked := 1
    If (killWin=1)
    {
       Gui, BlackGuia: Destroy
       Return
    }

    If (A_TickCount - lastInvoked<250)
       Return

    lastInvoked := A_TickCount
    Gui, BlackGuia: Destroy
    Sleep, 5
    vpWinClientSize(mainWidth, mainHeight)
    Gui, BlackGuia: -DPIScale -Caption +Owner%PVhwnd% +ToolWindow +E0x80000 +E0x20 +hwndhGuiBlack
    Gui, BlackGuia: Color, c%OSDbgrColor%
    Gui, BlackGuia: Margin, 0, 0
    Gui, BlackGuia: Add, Text,+0x80 c%OSDtextColor% w%mainWidth% h%mainHeight% gRemoveTooltip, %msg%
    JEE_ClientToScreen(hPicOnGui1, 0, 0, GuiX, GuiY)
    WinSet, Transparent, %thisOpacity%, ahk_id %hGuiBlack%
    WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight%, ahk_id %hGuiBlack%
    ; GuiX := GuiY := 0
    Gui, BlackGuia: Show, NoActivate AutoSize x%GuiX% y%GuiY%, GuiBlackedWin
    ; SetParentID(PVhwnd, hGuiBlack)
}

Fnt_GetListOfFontsSimplified() {
; function stripped down from Font Library 3.0 by jballi
; from https://autohotkey.com/boards/viewtopic.php?t=4379

    Static Dummy65612414
          ,HWND_DESKTOP := 0   ;-- Device constants
          ,LF_FACESIZE  := 32  ;-- In TCHARS - LOGFONT constants

    ;-- Initialize and populate LOGFONT structure
    Fnt_EnumFontFamExProc_List := ""
    p_CharSet := 1
    p_Flags := 0x800
    VarSetCapacity(LOGFONT,A_IsUnicode ? 92:60,0)
    NumPut(p_CharSet,LOGFONT,23,"UChar")                ;-- lfCharSet

    ;-- Enumerate fonts
    EFFEP := RegisterCallback("CallBack_EnumFontFamExProc","F")
    hDC := Gdi_GetDC(HWND_DESKTOP)
    DllCall("gdi32\EnumFontFamiliesExW"
       ,"UPtr", hDC                                      ;-- hdc
       ,"UPtr", &LOGFONT                                 ;-- lpLogfont
       ,"UPtr", EFFEP                                    ;-- lpEnumFontFamExProc
       ,"UPtr", p_Flags                                  ;-- lParam
       ,"UInt", 0)                                      ;-- dwFlags (must be 0)

    Gdi_ReleaseDC(HWND_DESKTOP, hDC)
    DllCall("GlobalFree", "UPtr", EFFEP)
    LOGFONT := ""
    Return Fnt_EnumFontFamExProc_List
}

CallBack_EnumFontFamExProc(lpelfe,lpntme,FontType,p_Flags) {
    Fnt_EnumFontFamExProc_List := 0
    Static Dummy62479817
          ,LF_FACESIZE := 32     ;-- In TCHARS - LOGFONT constants

    l_FaceName := StrGet(lpelfe+28,LF_FACESIZE)
    FontList.Push(l_FaceName)    ;-- Append the font name to the list
    Return 1                     ;-- Continue enumeration
}

ST_Insert(insert,input,pos=1) {
  Length := StrLen(input)
  ((pos > 0) ? (pos2 := pos - 1) : (((pos = 0) ? (pos2 := StrLen(input),Length := 0) : (pos2 := pos))))
  output := SubStr(input, 1, pos2) . insert . SubStr(input, pos, Length)
  If (StrLen(output) > StrLen(input) + StrLen(insert))
     ((Abs(pos) <= StrLen(input)/2) ? (output := SubStr(output, 1, pos2 - 1) . SubStr(output, pos + 1, StrLen(input)))
     : (output := SubStr(output, 1, pos2 - StrLen(insert) - 2) . SubStr(output, pos - StrLen(insert), StrLen(input))))
  Return output
}

isWinStore() {
   p := (A_IsCompiled && FileExist(mainExecPath "\win-store-mode.ini") && InStr(fullPath2exe, "13644TabletPro.QuickPictoViewer")) ? 1 : 0
   ; ToolTip, % "l=" FileExist(mainExecPath "\win-store-mode.ini") "`n" fullPath2exe "`n" A_ScriptFullPath "`n" A_ScriptDir "`n" mainExecPath , , , 2
   ; p := (!A_IsCompiled && FileExist("win-store-mode.ini") && InStr(fullPath2exe, "Quick-Picto-Viewer.exe")) ? 1 : 0
   Return p
}

initCompiled(mode) {
   fullPath2exe := GetModuleFileNameEx(QPVpid)
   zPlitPath(fullPath2exe, 0, OutFileName, OutDir)
   mainExecPath := OutDir
   If (mode=1 || isWinStore())
   {
      If isWinStore()
      {
         SetWorkingDir, %A_AppData%
         x := A_AppData "\QuickPictoViewer"
         WinStoreDataPath := "\Local\Packages\13644TabletPro.QuickPictoViewer_3wyk1bs4amrq4\AppData"
         WinStorePath := StrReplace(x, "\Roaming\QuickPictoViewer", WinStoreDataPath)
         If !FileExist(WinStorePath "\resources")
            FileCreateDir, % WinStorePath "\resources"

         If !FileExist(WinStorePath "\resources\vector-shapes")
         {
            FileCreateDir, % WinStorePath "\resources\vector-shapes"
            FileCopy, % mainExecPath "\resources\vector-shapes\*.vqpv", % WinStorePath "\resources\vector-shapes\*.vqpv"
         }

         OutDir := WinStorePath
      }

      SetWorkingDir, %mainExecPath%
      mainCompiledPath := OutDir
      thumbsCacheFolder := OutDir "\thumbs-cache"
      mainSettingsFile := OutDir "\" mainSettingsFile
      mainRecentsFile := OutDir "\" mainRecentsFile
      mainFavesFile := OutDir "\" mainFavesFile
      customKbdFile := OutDir "\" customKbdFile
      folderFavesFile := OutDir "\" folderFavesFile
      miniFavesFile := OutDir "\" miniFavesFile
      ; ToolTip, % A_ScriptDir " `n " OutDir "`n " fullPath2exe  , , , 2
   } Else
   {
      mainExecPath := A_ScriptDir
      mainCompiledPath := A_ScriptDir
   }

   unCompiledExePath := Chr(34) fullPath2exe Chr(34) A_Space Chr(34) A_ScriptFullPath Chr(34)
}

MenuInvokeSHopenWith() {
   imgPath := StrReplace(getIDimage(currentFileIndex), "||")
   invokeSHopenWith(imgPath)
}

ReadSettingsAutoCropPanel(act:=0) {
    RegAction(act, "AutoCropAdaptiveMode",, 1)
    RegAction(act, "AutoCropStrongAdaptiveMode",, 1)
    RegAction(act, "userDesireWriteFMT",, 2, 1, 16)
    RegAction(act, "ResizeDestFolder",, 6)
    RegAction(act, "ResizeUseDestDir",, 1)
    RegAction(act, "PreserveDateTimeOnSave",, 1)
    RegAction(act, "usrAutoCropErrThreshold",, 2, 0, 99)
    RegAction(act, "userActionConflictingFile",, 2, 1, 3)
    RegAction(act, "userJpegQuality",, 2, 1, 100)
    RegAction(act, "usrAutoCropColorTolerance",, 2, 0, 255)
    RegAction(act, "usrAutoCropDeviation",, 2, -50, 50)
    RegAction(act, "usrAutoCropDeviationPixels",, 1)
    RegAction(act, "usrAutoCropDeviationSnap",, 1)
}

PanelImgAutoCrop() {
    Global btnFldr, mainBtnACT, editF5, btn3, btn4, btn5
    If (thumbsDisplaying=1)
    {
       Tooltip, Please wait...
       getSelectedFiles(0, 1)
       If !markedSelectFile
       {
          lastOtherWinClose := 1
          ToggleThumbsMode()
          SetTimer, PanelImgAutoCrop, -150
          Tooltip
          Return
       }
    }

    If (downscaleHugeImagesForEditing()<0)
       Return

    If (vpIMGrotation>0)
    {
       vpIMGrotation := 0
       INIaction(1, "vpIMGrotation", "General")
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    }

    thisBtnHeight := createSettingsGUI(17, A_ThisFunc)
    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 220
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       slide2Wid := slide2Wid + 75
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsAutoCropPanel()
    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    filesElected := getSelectedFiles(0, 1)

    gW := (PrefsLargeFonts=1) ? 145 : 125
    gH := (PrefsLargeFonts=1) ? 145 : 125
    Gui, Add, Text, x15 y15 Section, Please adjust the following parameters for best results.
    ha := (PrefsLargeFonts=1) ? 27 : 18
    GuiAddSlider("usrAutoCropColorTolerance", 0,254, 10, "Color variation tolerance", "UpdateUIautoCropParams", 1, "xs y+10 w" slide2Wid " h" ha)
    Gui, Add, Checkbox, x+10 hp gUpdateUIautoCropParams Checked%AutoCropAdaptiveMode% vAutoCropAdaptiveMode, Adaptive mode
    Gui, Add, Checkbox, x+2 hp gUpdateUIautoCropParams Checked%AutoCropStrongAdaptiveMode% vAutoCropStrongAdaptiveMode, strong

    GuiAddSlider("usrAutoCropErrThreshold", 0,99, 2, "Tolerance error threshold", "UpdateUIautoCropParams", 1, "xs y+10 w" slide2Wid " h" ha)
    Gui, Add, Checkbox, x+10 hp gUpdateUIautoCropParams Checked%usrAutoCropDeviationSnap% vusrAutoCropDeviationSnap, Snap to image edges
    GuiAddSlider("usrAutoCropDeviation", -50,50, 0, "Cropped area alteration", "UpdateUIautoCropParams", 2, "xs y+10 w" slide2Wid " h" ha)
    Gui, Add, Checkbox, x+10 hp gUpdateUIautoCropParams Checked%usrAutoCropDeviationPixels% vusrAutoCropDeviationPixels, Alteration in pixels

    thisBW := (PrefsLargeFonts=1) ? 145 : 90
    thisCW := (PrefsLargeFonts=1) ? 65 : 35
    thisAW := (PrefsLargeFonts=1) ? 85 : 75
    thisAW := (filesElected>1) ? "w" thisAW : "w1"
    thisW := (filesElected>1) ? "" : "w1"
    thisH := (filesElected>1) ? "" : "h1"
    thisH2 := (filesElected>1) ? "hp" : "h1"
    ty:= (filesElected>1) ? 10 : 0

    Gui, Add, Checkbox, xs y+%ty% gTglRszDestFoldr %thisW% %thisH% Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder: 
    GuiAddEdit("xp+15 y+5 wp " thisH " r1 +0x0800 -wrap vResizeDestFolder", ResizeDestFolder, "Destination folder")
    ml := (PrefsLargeFonts=1) ? 90 : 70
    Gui, Add, Button, x+5 hp w%ml% %thisW% %thisH% gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    If (filesElected>1)
    {
       Gui, Add, Text, xs y+%ty% hp +0x200 +hwndhTemp, Action on file name conflicts:
       GuiAddDropDownList("x+5 w" thisBW A_Space thisW A_Space thisH " AltSubmit Choose" userActionAutoCropConflictingFile " vuserActionAutoCropConflictingFile", "Skip files|Auto-rename|Overwrite|Ask user", [hTemp])
       Gui, Add, Checkbox, xs y+%ty% %thisW% %thisH2% Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve files date/time
       Gui, Add, Checkbox, xs y+%ty% %thisW% %thisH2% Checked%convertOnAutoCrop% vconvertOnAutoCrop, &Convert on save to:
       GuiAddDropDownList("x+5 " thisAW A_Space thisH " gTglDesiredSaveFormat AltSubmit Choose" userDesireWriteFMT " vuserDesireWriteFMT", userPossibleWriteFMTs, "Image file format")
    }

    thisWid := (PrefsLargeFonts=1) ? 145 : 115
    If (filesElected>1)
    {
       GuiAddSlider("userJpegQuality", 2,100, 95, "Quality", "iniSaveJPGquality", 1, "x+5 w" thisWid + 20 " hp", "This only applies to the JPEG and WEBP file formats")
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, Files selected to process: %filesElected%.`nFiles in unsupported write formats will be skipped.
       Gui, Font, Normal
    } Else
    {
       GuiControl, Disable, PreserveDateTimeOnSave
       GuiControl, Disable, convertOnAutoCrop
       GuiControl, Disable, userActionAutoCropConflictingFile
       GuiControl, Disable, editF5
       GuiControl, Disable, userDesireWriteFMT
       GuiControl, Disable, ResizeUseDestDir
       GuiControl, Disable, ResizeDestFolder
       GuiControl, Disable, btnFldr
    }

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    ml := (PrefsLargeFonts=1) ? 35 : 25
    GuiAddButton("xs y+20 h" thisBtnHeight " w" ml " gBtnPrevImg vbtn1", "<<", "Previous image")
    GuiAddButton("x+5 hp wp gBtnNextImg vbtn2", ">>", "Next image")
    If (validBMP(UserMemBMP) && !markedSelectFile)
    {
       GuiControl, Disable, btn1
       GuiControl, Disable, btn2
    }

    sml := (PrefsLargeFonts=1) ? 90 : 55
    If (filesElected>1)
    {
       Gui, Add, Button, x+5 hp w%btnWid% Default gBTNautoCropRealtime vmainBtnACT, &Viewport preview
       Gui, Add, Button, x+5 hp wp gBTNsaveAutoCroppedFile vbtn3, &Process files
    } Else
    {
       btnWid -= 10
       Gui, Add, Button, x+5 hp w%sml% gBTNautoCropVP vmainBtnACT, &Apply
       Gui, Add, Button, x+5 hp wp Default gBTNautoCropRealtime vbtn3, &Preview
       Gui, Add, Button, x+5 hp w%btnWid% gBTNsaveAutoCroppedFile vbtn4, &Save image
    }
    Gui, Add, Button, x+5 hp w%sml% gBtnCloseWindow vbtn5, &Cancel

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : 1
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Automatic image crop: " appTitle, winPos)
    Sleep, 1
    Tooltip
    UpdateUIautoCropParams()
    ResetImgLoadStatus()
}

partialUpdateUIautoCropParams() {
    Static prevp := 0
    If (AnyWindowOpen!=17)
       Return 1

    GuiControlGet, usrAutoCropDeviationSnap
    GuiControlGet, usrAutoCropDeviationPixels
    GuiControlGet, AutoCropAdaptiveMode
    GuiControlGet, AutoCropStrongAdaptiveMode
    p := "a" usrAutoCropErrThreshold usrAutoCropColorTolerance usrAutoCropDeviation usrAutoCropDeviationSnap usrAutoCropDeviationPixels AutoCropAdaptiveMode AutoCropStrongAdaptiveMode
    r := (prevp=p) ? 1 : 0
    prevp := p
    Return r
 }

UpdateUIautoCropParams() {
    If (AnyWindowOpen!=17)
       Return

    GuiControlGet, usrAutoCropDeviationSnap
    GuiControlGet, usrAutoCropDeviationPixels
    GuiControlGet, AutoCropAdaptiveMode
    GuiControlGet, AutoCropStrongAdaptiveMode
    actu := (AutoCropAdaptiveMode=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, AutoCropStrongAdaptiveMode

    If markedSelectFile
    {
       GuiControlGet, userActionAutoCropConflictingFile
       GuiControlGet, ResizeUseDestDir
       GuiControlGet, ResizeDestFolder
       GuiControlGet, PreserveDateTimeOnSave
       GuiControlGet, userDesireWriteFMT
       GuiControlGet, convertOnAutoCrop
    }

    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    uiSlidersArray["usrAutoCropDeviation", 5] := "Cropped area alteration: $€" measureUnit
    GuiRefreshSliders()
    SetTimer, WriteSettingsAutoCropPanel, -350
}

WriteSettingsAutoCropPanel() {
   ReadSettingsAutoCropPanel(1)
}

coreCaptureImgCorners(whichBmp, thisSize:=0, thisBoxSize:=0) {
    If !validBMP(whichBmp)
       Return

    boxSize := (thisBoxSize=0) ? 220 : thisBoxSize
    realSize := (thisSize=0) ? AutoCropBordersSize : thisSize
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, boxSize, boxSize, coreDesiredPixFmt)
    If !validBMP(cornersBMP)
       Return

    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    trGdip_GetImageDimensions(whichBmp, imgW, imgH)
    If (editingSelectionNow=1)
    {
       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       X1 := Y1 := 0
       X2 := ImgSelW := imgW
       Y2 := ImgSelH := imgH
    }

    Loop, 3
    {
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, boxSize//2, boxSize//2, X1, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, 0, boxSize//2, boxSize//2, X2 - realSize, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, boxSize//2, boxSize//2, boxSize//2, X1, Y2 - realSize, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, boxSize//2, boxSize//2, boxSize//2, X2 - realSize, Y2 - realSize, realSize, realSize)
    }

    Static borderSize := 8
    Gdip_DeleteGraphics(G)
    cornersBMP2 := trGdip_CreateBitmap(A_ThisFunc, boxSize+borderSize, boxSize+borderSize, coreDesiredPixFmt)
    If validBMP(cornersBMP2)
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP2, 3)
       If G2
       {
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, cornersBMP, borderSize//2, borderSize//2)
       }
    }

    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(cornersBMP, 1)
    Return cornersBMP2
}

AutoCropAction(zBitmap, varTolerance, threshold, silentMode, selMode) {
   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 0", 0, 0, 0.001)

   startu := A_TickCount
   trGdip_GetImageDimensions(zBitmap, Width, Height)
   If (Width>900 && Height>900)
   {
      doubleSize := 1
      pBitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, Width//2, Height//2, 1, 2)
   } Else
   {
      pBitmap := trGdip_CloneBitmap(A_ThisFunc, zBitmap)
      doubleSize := 0
   }

   ; trGdip_DisposeImage(zBitmap, 1)   ; the function caller must dispose it
   If !validBMP(pBitmap)
   {
      If (silentMode=0)
      {
         showTOOLtip("Failed to process image for auto-cropping")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   selCoords := CoreAutoCropAlgo(pBitmap, varTolerance, threshold, silentMode, doubleSize)
   trGdip_DisposeImage(pBitmap, 1)
   If (selCoords="error")
   { 
      If (silentMode!=1)
      {
         showTOOLtip("Auto-crop processing aborted by user")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
      Return
   } Else If (selCoords="change")
   { 
      Return
   }

   ; selCoords := StrSplit(selCoords, ",")
   X1 := min(selCoords[1], selCoords[3])
   Y1 := min(selCoords[2], selCoords[4])
   X2 := max(selCoords[1], selCoords[3])
   Y2 := max(selCoords[2], selCoords[4])
   xa := clampInRange(X1, 0, Width - 1)
   ya := clampInRange(Y1, 0, Height - 1)
   xb := clampInRange(X2, xa + 1, Width)
   yb := clampInRange(Y2, ya + 1, Height)

   If (silentMode=0)
   {
      If (A_TickCount - startu > 3000)
         SoundBeep, 900, 100
      SetTimer, RemoveTooltip, -500
   }

   If (selMode=0)
   {
      newW := xb - xa
      newH := yb - ya
      kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, zBitmap, xa, ya, newW, newH)
      return kBitmap
   } Else
   {
      VPselRotation := innerSelectionCavityX := innerSelectionCavityY := EllipseSelectMode := 0
      ImgSelX1 := xa, ImgSelY1 := ya
      ImgSelX2 := xb, ImgSelY2 := yb
      defineRelativeSelCoords(Width, Height)
   }
}

CoreAutoCropAlgo(pBitmap, varTolerance, threshold, silentMode:=0, doubleSize:=0) {
   If !validBMP(pBitmap)
   {
      addJournalEntry(A_ThisFunc "(): no bitmap given for auto-cropping")
      Return "error"
   }

   trGdip_GetImageDimensions(pBitmap, Width, Height)
   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride, iScan, BitmapData1)
   If E1
      Return "error"

   partialUpdateUIautoCropParams()
   adaptLevel := (AutoCropStrongAdaptiveMode=1) ? 6 : 3
   fnOutputDebug(Width "=" Height "|" stride "|" threshold "/" varTolerance "|" AutoCropAdaptiveMode)
   X1 := Y1 := X2 := Y2 := -1
   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 1 - Y1", 0, 0, 0.1)

   r := DllCall(whichMainDLL "\autoCropAider", "UPtr", iScan, "Int", Width, "Int", Height, "Int", adaptLevel, "double", threshold, "double", varTolerance, "Int", 1, "Int", AutoCropAdaptiveMode, "int*", Y1)
   If !r
   {
      Gdip_UnlockBits(pBitmap, BitmapData1)
      Return "error"
   }

   If !partialUpdateUIautoCropParams()
      Return "change"

   If (AutoCropAdaptiveMode=1 && Y1=-1)
      r := DllCall(whichMainDLL "\autoCropAider", "UPtr", iScan, "Int", Width, "Int", Height, "Int", adaptLevel, "double", threshold, "double", varTolerance, "Int", 1, "Int", 0, "int*", Y1)

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 2 - X1", 0, 0, 0.3)

   If !partialUpdateUIautoCropParams()
      Return "change"

   r := DllCall(whichMainDLL "\autoCropAider", "UPtr", iScan, "Int", Width, "Int", Height, "Int", adaptLevel, "double", threshold, "double", varTolerance, "Int", 2, "Int", AutoCropAdaptiveMode, "int*", X1)
   If !partialUpdateUIautoCropParams()
      Return "change"

   If (AutoCropAdaptiveMode=1 && X1=-1)
      r := DllCall(whichMainDLL "\autoCropAider", "UPtr", iScan, "Int", Width, "Int", Height, "Int", adaptLevel, "double", threshold, "double", varTolerance, "Int", 2, "Int", 9, "int*", X1)

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 3 - Y2", 0, 0, 0.5)

   If !partialUpdateUIautoCropParams()
      Return "change"

   Gdip_UnlockBits(pBitmap, BitmapData1)
   Gdip_ImageRotateFlip(pBitmap, 2)
   E2 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride, iScan, BitmapData1)
   If E2
      Return "error"

   r := DllCall(whichMainDLL "\autoCropAider", "UPtr", iScan, "Int", Width, "Int", Height, "Int", adaptLevel, "double", threshold, "double", varTolerance, "Int", 1, "Int", AutoCropAdaptiveMode, "int*", Y2)
   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nStep 4 - X2", 0, 0, 0.8)

   If !partialUpdateUIautoCropParams()
      Return "change"

   If (AutoCropAdaptiveMode=1 && Y2=-1)
      r := DllCall(whichMainDLL "\autoCropAider", "UPtr", iScan, "Int", Width, "Int", Height, "Int", adaptLevel, "double", threshold, "double", varTolerance, "Int", 1, "Int", 0, "int*", Y2)

   If !partialUpdateUIautoCropParams()
      Return "change"

   r := DllCall(whichMainDLL "\autoCropAider", "UPtr", iScan, "Int", Width, "Int", Height, "Int", adaptLevel, "double", threshold, "double", varTolerance, "Int", 2, "Int", AutoCropAdaptiveMode, "int*", X2)
   If !partialUpdateUIautoCropParams()
      Return "change"

   If (AutoCropAdaptiveMode=1 && X2=-1)
      r := DllCall(whichMainDLL "\autoCropAider", "UPtr", iScan, "Int", Width, "Int", Height, "Int", adaptLevel, "double", threshold, "double", varTolerance, "Int", 2, "Int", 0, "int*", X2)

   ; fnOutputDebug(X1 "=" Y1 "|" X2 "=" Y2)
   if (X1=-1 && Y1=-1 && X2=-1 && Y2=-1)
   {
      X1 := Y1 := X2 := Y2 := 2
      deviationW := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Width/100)*usrAutoCropDeviation)
      deviationH := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Height/100)*usrAutoCropDeviation)
      If (usrAutoCropDeviationSnap=1 && X1>2) || (usrAutoCropDeviationSnap=0)
         X1 -= deviationW
      If (usrAutoCropDeviationSnap=1 && Y1>2) || (usrAutoCropDeviationSnap=0)
         Y1 -= deviationH
      If (usrAutoCropDeviationSnap=1 && X2<Width-3) || (usrAutoCropDeviationSnap=0)
         X2 += deviationW
      If (usrAutoCropDeviationSnap=1 && Y2<Height-3) || (usrAutoCropDeviationSnap=0)
         Y2 += deviationH
   } Else
   {
      X2 := Width - X2
      Y2 := Height - Y2
   }

   ; ToolTip, % X1 "," Y1 "--" X2 "," Y2 "`n" maxThresholdHitsW "--" maxThresholdHitsH "--" firstR1, , , 2
   If (X1="" || X1>Width - 2)
      X1 := Width - 3
   If (Y1="" || Y1>Height - 2)
      Y1 := Height - 3
   If (X2="" || X2<3)
      X2 := 3
   If (Y2="" || Y2<3)
      Y2 := 3

   If (doubleSize=1)
   {
      X2 := X2*2, Y2 := Y2*2
      X1 := X1*2, Y1 := Y1*2
   }

   If (X2 < X1 - 2)
      X2 := X1 + 2
   If (Y2 < Y1 - 2)
      Y2 := Y1 + 2

   selCoords := [x1, y1, x2,y2]
   Gdip_UnlockBits(pBitmap, BitmapData1)
   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region`nDONE", 0, 0, 0.99)

   Return selCoords
}

BTNsaveAutoCroppedFile() {
    UpdateUIautoCropParams()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       batchAutoCropFiles()
       Return
    }

    If (AnyWindowOpen=17)
       UpdateUIautoCropParams()

    If (editingSelectionNow!=1)
       ToggleEditImgSelection()

    PerformAutoCropViewportMode()
    BtnCloseWindow()
    PanelSaveImg()
}

coreAutoColorsFileProcessing(imgPath, file2save) {
    If (PreserveDateTimeOnSave=1)
    {
       FileGetTime, originalMtime, % imgPath, M
       FileGetTime, originalCtime, % imgPath, C
    }

    oBitmap := LoadBitmapFromFileu(imgPath)
    If !validBMP(oBitmap)
       Return -3

    trGdip_GetImageDimensions(oBitmap, oImgW, oImgH)
    pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    If (userAutoColorAdjustMode=3)
    {
       rz := QPV_autoContrastBitmap(oBitmap, 1)
       If (rz=1)
          QPV_autoContrastBitmap(oBitmap, 2)
    } Else
       rz := QPV_autoContrastBitmap(oBitmap, userAutoColorAdjustMode)

    If !rz
    {
       trGdip_DisposeImage(oBitmap)
       Return -1
    }

    kBitmap := oBitmap
    If InStr(pixFmt, "argb")
    {
       isUniform := Gdip_TestBitmapUniformity(kBitmap, 7, maxLevelIndex)
       If (isUniform=1 && (isInRange(maxLevelIndex, 0, 5) || isInRange(maxLevelIndex, 250, 255)))
          Gdip_BitmapSetColorDepth(kBitmap, 24)
    } Else Gdip_BitmapSetColorDepth(kBitmap, 24)

    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 1
    }

    r := Gdip_SaveBitmapToFile(kBitmap, file2save, userJpegQuality)
    If (r=-2 || r=-1)
       r := SaveFIMfile(file2save, kBitmap)

    trGdip_DisposeImage(kBitmap, 1)
    If (PreserveDateTimeOnSave=1 && !r && originalMtime)
    {
       FileSetTime, % originalMtime, % file2save, M
       FileSetTime, % originalCtime, % file2save, C
    }

    Return r
}

coreAutoCropFileProcessing(imgPath, file2save, silentMode) {
    If (PreserveDateTimeOnSave=1)
    {
       FileGetTime, originalMtime, % imgPath, M
       FileGetTime, originalCtime, % imgPath, C
    }

    oBitmap := LoadBitmapFromFileu(imgPath)
    If !validBMP(oBitmap)
       Return -3

    trGdip_GetImageDimensions(oBitmap, oImgW, oImgH)
    pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    kBitmap := AutoCropAction(oBitmap, usrAutoCropColorTolerance, usrAutoCropErrThreshold/100, silentMode, 0)
    trGdip_DisposeImage(oBitmap, 1)
    If !validBMP(kBitmap)
       Return -1

    trGdip_GetImageDimensions(kBitmap, imgW, imgH)
    If (imgW>oImgW - 1) && (imgH>oImgH - 1)
       Return -2

    If InStr(pixFmt, "argb")
    {
       isUniform := Gdip_TestBitmapUniformity(kBitmap, 7, maxLevelIndex)
       If (isUniform=1 && (isInRange(maxLevelIndex, 0, 5) || isInRange(maxLevelIndex, 250, 255)))
          Gdip_BitmapSetColorDepth(kBitmap, 24)
    } Else Gdip_BitmapSetColorDepth(kBitmap, 24)

    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 1
    }

    r := Gdip_SaveBitmapToFile(kBitmap, file2save, userJpegQuality)
    If (r=-2 || r=-1)
       r := SaveFIMfile(file2save, kBitmap)

    trGdip_DisposeImage(kBitmap, 1)
    If (PreserveDateTimeOnSave=1 && !r && originalMtime)
    {
       FileSetTime, % originalMtime, % file2save, M
       FileSetTime, % originalCtime, % file2save, C
    }

    Return r
}

batchAutoCropFiles() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to crop " groupDigits(filesElected) " files? This may take some time to finish. If needed, press Escape to abandon it."
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"

      If (userActionAutoCropConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."

      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   Sleep, 25
   If (editingSelectionNow!=1)
      ToggleEditImgSelection()

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   showTOOLtip("Performing image auto-crop on " groupDigits(filesElected) " files, please wait")
   doStartLongOpDance()
   countFilez := countTFilez := skippedFiles := failedFiles := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   thisWriteFMT := (convertOnAutoCrop=1) ? saveImgFormatsList[userDesireWriteFMT] : ""
   nullvara := askAboutFileCollision(0, 0, 1, 3, 0, nullvar)
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If failedFiles
            etaTime .= "`nErrors occured for " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip("Performing image auto-crop on the selected files" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      countTFilez++
      If ((!thisWriteFMT && !RegExMatch(imgPath, saveTypesRegEX)) || StrLen(imgPath)<2)
      {
         skippedFiles++
         Continue
      }

      If (ResizeUseDestDir=1)
      {
         zPlitPath(imgPath, 0, OutFileName, OutDir, fileNamuNoEXT)
         fname := thisWriteFMT ? fileNamuNoEXT "." thisWriteFMT : OutFileName
         destImgPath := ResizeDestFolder "\" fname
      } Else If thisWriteFMT
      {
         zPlitPath(imgPath, 0, OutFileName, OutDir, fileNamuNoEXT)
         destImgPath := OutDir "\" fileNamuNoEXT "." thisWriteFMT
      } Else destImgPath := imgPath

      If (ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionAutoCropConflictingFile, performOverwrite)
      }

      If !destImgPath
      {
         skippedFiles++
         Continue
      } Else If (destImgPath="abort")
      {
         abandonAll := 1
         Break
      }

      changeMcursor()
      r := coreAutoCropFileProcessing(imgPath, destImgPath, 1)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If failedFiles
      someErrors := "`nErrors occured for " groupDigits(failedFiles) " files"
   If skippedFiles
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip(groupDigits(countFilez) " out of " groupDigits(countTFilez) " selected images were automatically cropped" someErrors)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

batchAutoColorsFiles() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to auto-adjust colors for " groupDigits(filesElected) " files? This may take some time to finish. If needed, press Escape to abandon it."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   Sleep, 25

   startOperation := A_TickCount
   prevMSGdisplay := A_TickCount
   showTOOLtip("Performing auto-adjust colors for " groupDigits(filesElected) " files, please wait")
   doStartLongOpDance()
   countFilez := countTFilez := skippedFiles := failedFiles := 0

   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, filesElected, startOperation)
         If failedFiles
            etaTime .= "`nErrors occured for " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip("Performing automatic color adjustments on the selected images" etaTime, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      countTFilez++
      If (!RegExMatch(imgPath, saveTypesRegEX) || StrLen(imgPath)<2)
      {
         skippedFiles++
         Continue
      }

      destImgPath := imgPath
      changeMcursor()
      r := coreAutoColorsFileProcessing(imgPath, destImgPath)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If failedFiles
      someErrors := "`nErrors occured for " groupDigits(failedFiles) " files"
   If skippedFiles
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(countFilez) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip(groupDigits(countFilez) " out of " groupDigits(countTFilez) " selected images were processed" someErrors)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNautoCropVP() {
  GuiControl, SettingsGUIA: Disable, mainBtnACT
  UpdateUIautoCropParams()
  If (downscaleHugeImagesForEditing()<0)
     Return

  BtnCloseWindow()
  If (editingSelectionNow!=1)
     ToggleEditImgSelection()

  PerformAutoCropViewportMode()
}

BTNautoCropRealtime(modus:=0) {
  lockSelectionAspectRatio := 1
  defineSelectionAspectRatios()
  GuiControl, SettingsGUIA: Disable, mainBtnACT

  If (AnyWindowOpen=17 && modus!="timer")
  {
     UpdateUIautoCropParams()
     Loop, 5
       GuiControl, SettingsGUIA: Disable, btn%A_Index%
  }

  If (editingSelectionNow!=1)
     ToggleEditImgSelection()

  If (downscaleHugeImagesForEditing()<0)
     Return

  thumbBMP := applyVPeffectsOnBMP(trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap()))
  If validBMP(thumbBMP)
  {
     AutoCropAction(thumbBMP, usrAutoCropColorTolerance, usrAutoCropErrThreshold/100, 0, 1)
     trGdip_DisposeImage(thumbBMP, 1)
  }

  dummyRefreshImgSelectionWindow()
  SetTimer, reactivateMainBtnACT, -150
  If (editingSelectionNow=1 && AnyWindowOpen=12)
  {
     GuiControl, SettingsGUIA: Choose, jpegDesiredOperation, 9
  } Else If (AnyWindowOpen=17)
  {
     Loop, 5
         GuiControl, SettingsGUIA: Enable, btn%A_Index%
  }
}

coreWIAsimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   Try wiaImg := WIA_LoadImage(imgPath)
   imgW := wiaImg.Width, imgH := wiaImg.Height
   If (!IsObject(wiaImg) || !imgW || !imgH)
   {
      addJournalEntry("Failed to load and process image file using WIA`n" imgPath)
      Return 0
   }

   If (SimpleOperationsDoCrop=1 && editingSelectionNow=1 && imgW && imgH)
   {
      If (relativeImgSelCoords=1 && editingSelectionNow=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      wiaImg := WIA_CropImage(wiaImg, X1, Y1, X2, Y2)
   }

   If (rotateAngle!=0 && isNumber(rotateAngle))
      wiaImg := WIA_RotateImage(wiaImg, rotateAngle)

   If (SimpleOperationsFlipH=1)
      wiaImg := Wia_FlipImage(wiaImg, "Horizontal")
   If (SimpleOperationsFlipV=1)
      wiaImg := Wia_FlipImage(wiaImg, "Vertical")

   imgW := wiaImg.Width, imgH := wiaImg.Height
   thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
   thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
   changeMcursor()
   If (IsObject(wiaImg) && ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
      Try wiaImg := WIA_ScaleImage(wiaImg, thisW, thisH, 0)

    If (FileExist(file2save) && IsObject(wiaImg))
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    If IsObject(wiaImg)
       r := WIA_SaveImage(wiaImg, file2save)
    Else r := 0

    If (!r && tempFileExists=1) || (!FileRexists(file2save, 0) && tempFileExists=1)
    {
       r := 0
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

   wiaImg := ""
   Return !r
}

coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor, doConversion:=0) {
  If RegExMatch(imgPath, "i)(.\.(ico))$")
     r := "err"
  Else
     r := coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor, doConversion)
  Return r
}

coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor, doConversion:=0) {
    Sleep, 0
    hFIFimgA := LoadBitmapAsFreeImage(imgPath, 1, imgW, imgH, bpp)
    If (!hFIFimgA || !imgW || !imgH)
       Return "err"

    If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
    {
       If (relativeImgSelCoords=1 && editingSelectionNow=1)
          calcRelativeSelCoords("--", imgW, imgH)

       hFIFimgB := 0
       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       x1 := Round(X1), y1 := Round(Y1)
       x2 := Round(X2), y2 := Round(Y2)
       changeMcursor()
       If (imgSelW>4 && imgSelH>4)
          hFIFimgB := FreeImage_Copy(hFIFimgA, X1, Y1, X2, Y2)

       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    If (rotateAngle>0)
    {
       hFIFimgB := 0
       changeMcursor()
       hFIFimgB := FreeImage_Rotate(hFIFimgA, rotateAngle)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    changeMcursor()
    If (SimpleOperationsFlipH=1)
       FreeImage_FlipHorizontal(hFIFimgA)
    If (SimpleOperationsFlipV=1)
       FreeImage_FlipVertical(hFIFimgA)

    If (ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
    {
       typu := FreeImage_GetFileType(file2save, 1)
       resizeFilter := (ResizeQualityHigh=1) ? 4 : 0
       FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
       obju := calcIMGuserResizer(imgW, imgH, XscaleImgFactor, YscaleImgFactor, ResizeInPercentage, ResizeKeepAratio)
       thisW := obju[1, 1], thisH := obju[1, 2]
       pz := capIMGdimensionsFormatlimits(typu, ResizeKeepAratio, thisW, thisH)
       capIMGdimensionsFormatlimits("fim", ResizeKeepAratio, thisW, thisH)
       ; ToolTip, % thisW "|" thisH "|||" pz , , , 2
       hFIFimgB := 0
       changeMcursor()
       If (thisW>4 && thisH>4)
          hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, resizeFilter)

       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    tempFileExists := "r"
    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    changeMcursor()
    saveArg := getFIMsaveArgs(file2save)
    If (doConversion=1)
    {
       r := coreConvertImgFormat(imgPath, file2save, hFIFimgA)
       r := (r=1) ? 0 : 1
       ; object discarded by coreConvertImgFormat()
    } Else 
    {
       r := FreeImage_Save(hFIFimgA, file2save, saveArg)
       FreeImage_UnLoad(hFIFimgA)
    }

    If (!r && tempFileExists=1) || (!FileRexists(file2save, 0) && tempFileExists=1)
    {
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

    Return !r
}

coreFreeImageSimpleColorsAdjust(imgPath, file2save) {
    Sleep, 0
    hFIFimgA := LoadBitmapAsFreeImage(imgPath, 1, imgW, imgH, bpp)
    If (!hFIFimgA || !imgW || !imgH)
       Return "err"

    changeMcursor()
    bpp := FreeImage_GetBPP(hFIFimgA)
    If (bpp!=24 && bpp!=32)
    {
       If (userImgAdjustConvertDepth!=1)
       {
          FreeImage_UnLoad(hFIFimgA)
          Return "skip"
       }

       imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
       ColorsType := FreeImage_GetColorType(hFIFimgA)
       imgType := FreeImage_GetImageType(hFIFimgA, 1)
       imgIDtype := FreeImage_GetImageType(hFIFimgA)
       GFT := FreeImage_GetFileType(imgPath)
       hFIFimgA := FIMapplyToneMapper(hFIFimgA, GFT, imgBPP, ColorsType, 1, hasAppliedToneMap)
       bpp := FreeImage_GetBPP(hFIFimgA)
       If (bpp!=24 && bpp!=32)
       {
          If InStr(ColorsType, "rgba")
             hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "32Bits")
          Else
             hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")

          If hFIFimgB
          {
             FreeImage_UnLoad(hFIFimgA)
             hFIFimgA := hFIFimgB
          }

          bpp := FreeImage_GetBPP(hFIFimgA)
          If (bpp!=24 && bpp!=32)
          {
             FreeImage_UnLoad(hFIFimgA)
             Return "err"
          }
       }
    }

    If (SimpleOperationsFlipH=1)
       FreeImage_FlipHorizontal(hFIFimgA)
    If (SimpleOperationsFlipV=1)
       FreeImage_FlipVertical(hFIFimgA)

    pBitsAll := FreeImage_GetBits(hFIFimgA)
    Stride := FreeImage_GetStride(hFIFimgA)
    this := (userImgAdjustHiPrecision=1) ? "Precise" : ""
    QPV_PrepareHugeImgSelectionArea(0, 0, imgW, imgH, imgW, imgH, 0, 0, 0, 0)
    r := DllCall(whichMainDLL "\AdjustImageColors" this, "UPtr", pBitsAll, "Int", imgW, "Int", imgH, "int", stride, "int", bpp, "int", imgColorsFXopacity, "int", userImgAdjustInvertColors, "int", userImgAdjustAltSat, "int", userImgAdjustSat, "int", userImgAdjustAltBright, "int", userImgAdjustBright, "int", userImgAdjustAltContra, "int", userImgAdjustContra, "int", userImgAdjustAltHiLows, "int", userImgAdjustShadows, "int", userImgAdjustHighs, "int", userImgAdjustHue, "int", userImgAdjustTintDeg, "int", userImgAdjustTintAmount, "int", userImgAdjustAltTint, "int", userImgAdjustGamma, "int", userImgAdjustOffR, "int", userImgAdjustOffG, "int", userImgAdjustOffB, "int", userImgAdjustOffA, "int", userImgAdjustThreR, "int", userImgAdjustThreG, "int", userImgAdjustThreB, "int", userImgAdjustThreA, "int", userImgAdjustSeeThrough, "int", userimgGammaCorrect, "int", userImgAdjustNoClamp, "int", userImgAdjustWhitePoint, "int", userImgAdjustBlackPoint, "int", userImgAdjustNoisePoints, "UPtr", 0, "int", 0)
    If (r!=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    tempFileExists := "r"
    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    changeMcursor()
    saveArg := getFIMsaveArgs(file2save)
    r := FreeImage_Save(hFIFimgA, file2save, saveArg)
    FreeImage_UnLoad(hFIFimgA)
    If (!r && tempFileExists=1) || (!FileRexists(file2save, 0) && tempFileExists=1)
    {
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

    Return !r
}

PanelSimpleResizeRotate(modus:="") {
    Global mainBtnACT, btnFldr, editF5
    If !PanelsCheckFileExists()
       Return

    If (vpIMGrotation>0)
    {
       FlipImgV := FlipImgH := vpIMGrotation := 0
       INIaction(1, "FlipImgH", "General")
       INIaction(1, "FlipImgV", "General")
       INIaction(1, "vpIMGrotation", "General")
       showTOOLtip("Image rotation set to 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    } Else If (FlipImgH=1 || FlipImgV=1)
    {
       FlipImgV := FlipImgH := 0
       dummyTimerDelayiedImageDisplay(50)
    } 

    imgPath := getIDimage(currentFileIndex)
    filesElected := getSelectedFiles(0, 1)
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    If (!filesElected && !RegExMatch(imgPath, thisRegEX) && modus!="forced")
    {
       CloseWindow()
       Sleep, 5
       PanelResizeImageWindow()
       Return
    }

    initFIMGmodule()
    If !wasInitFIMlib
    {
       msgBoxWrapper(appTitle ": ERROR", "Unable to initialize the FreeImage library module.`n`nThe tool mode is currently unavailable. The fallback tool mode is going to be invoked now.", 0, 0, "error")
       Sleep, 5
       PanelResizeImageWindow()
       Return
    }

    If !markedSelectFile
    {
       showTOOLtip("Retrieving file information, please wait")
       GetImgFileDimension(getIDimage(currentFileIndex), oImgW, oImgH, 1, currentFileIndex)
    }

    thisBtnHeight := createSettingsGUI(18, A_ThisFunc)
    ReadSettingsImageProcessing()
    btnWid := 100
    txtWid := slideWid := 280
    If (editingSelectionNow!=1)
       SimpleOperationsDoCrop := 0

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 Section hwndhTemp, Rotate / flip:
    ml := (PrefsLargeFonts=1) ? 105 : 60
    GuiAddDropDownList("x+5 w" ml " AltSubmit Choose" SimpleOperationsRotateAngle " vSimpleOperationsRotateAngle", "0°|90°|180°|-90° [270°]", [hTemp])
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipV% vSimpleOperationsFlipV, Vertical
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipH% vSimpleOperationsFlipH, Horizontal
    Gui, Add, Checkbox, xs y+10 gTglRszMustPerformResize Checked%ResizeMustPerform% vResizeMustPerform, Perform image resizing (W x H):
    thisW := (PrefsLargeFonts=1) ? 85 : 40
    GuiAddEdit("xs+15 y+5 w" thisW " r1 limit6 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleXimgFactor", (ResizeInPercentage=1) ? 100 : oImgW, "Width")
    GuiAddEdit("x+5 wp r1 limit6 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleYimgFactor", (ResizeInPercentage=1) ? 100 : oImgH, "Height")
    Gui, Add, Checkbox, x+5 wp+30 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `%
    Gui, Add, Checkbox, x+5 hp gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, &Keep aspect ratio
    Gui, Add, Checkbox, xs+15 y+7 Checked%ResizeQualityHigh% vResizeQualityHigh, High quality image resampling
    Gui, Add, Checkbox, xs y+10 Checked%SimpleOperationsDoCrop% vSimpleOperationsDoCrop, Crop image(s) to selected area in viewport
    Gui, Add, Checkbox, xs y+10 Checked%convertFormatUseMultiThreads% vconvertFormatUseMultiThreads, Use multiple threads for processing (experimental)
    Gui, Add, Checkbox, xs y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the specified destination folder:
    GuiAddEdit("xp+15 y+5 wp-10 r1 +0x0800 -wrap vResizeDestFolder", ResizeDestFolder, "Destination folder")
    ml := (PrefsLargeFonts=1) ? 90 : 50
    Gui, Add, Button, x+5 hp w%ml% gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    ml := (PrefsLargeFonts=1) ? 152 : 93
    Gui, Add, Text, xs y+10 hp +0x200 +hwndhTemp, Action on file name conflicts:
    GuiAddDropDownList("x+5 w" ml " gTglOverwriteFiles AltSubmit Choose" userActionConflictingFile " vuserActionConflictingFile", "Skip files|Auto-rename|Overwrite", [hTemp])
    thisWid := (PrefsLargeFonts=1) ? 235 : 150
    GuiAddSlider("userJpegQuality", 2,100, 95, "Image quality on save", "iniSaveJPGquality", 1, "xs y+5 w" thisWid " hp", "This only applies to the JPEG and WEBP file formats")
    If !(filesElected>1)
       GuiControl, SettingsGUIA: Disable, convertFormatUseMultiThreads

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    If (editingSelectionNow!=1)
       GuiControl, Disable, SimpleOperationsDoCrop

    If (filesElected>1)
    {
       msgFriendly := groupDigits(filesElected) " files are selected for processing."
       Gui, Font, Bold
       Gui, Add, Text, xs y+20 w%txtWid%, % msgFriendly
       Gui, Font, Normal
       Gui, Add, Text, xs y+10 w%txtWid%, Files in unsupported write formats will be skipped.
    }

    If (filesElected<2)
    {
       ml := (PrefsLargeFonts=1) ? 35 : 25
       GuiAddButton("xs y+25 h" thisBtnHeight " w" ml " gPreviousPicture", "<<", "Previous image")
       GuiAddButton("x+5 hp wp gNextPicture", ">>", "Next image")
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnSaveAsSimpleProcessing vmainBtnACT, &Save image as...
    } Else Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% wp-60 Default gBtnPerformSimpleProcessing, &Process selected image files now

    Gui, Add, Button, xs y+5 h%thisBtnHeight% w%btnWid% gBtnInvokePanelResizeImageWindow, &Advanced mode
    ml := (PrefsLargeFonts=1) ? 85 : 50
    Gui, Add, Button, x+5 hp w%ml% gBtnHelpResizePanel, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / crop / rotate image [simple mode]: " appTitle)
    ResetImgLoadStatus()
    GuiRefreshSliders()
    RemoveTooltip()
    SetTimer, TglRszMustPerformResize, -300
}

BtnInvokePanelResizeImageWindow() {
   BtnCloseWindow()
   Sleep, 10
   PanelResizeImageWindow()
}

BtnSaveAsSimpleProcessing() {
    BtnPerformSimpleProcessing()
}

BtnSaveNowSimpleProcessing() {
    BtnPerformSimpleProcessing("no-prompt")
}

TglRszMustPerformResize() {
    Gui, SettingsGUIA: Default
    GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform

    actu := (ResizeMustPerform=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, SimpleOperationsScaleXimgFactor
    GuiControl, % actu, SimpleOperationsScaleYimgFactor
    GuiControl, % actu, ResizeInPercentage
    GuiControl, % actu, ResizeKeepAratio
}

BtnPerformSimpleProcessing(dummy:=0, contextu:="") {
    If (contextu!="extern")
    {
       Gui, SettingsGUIA: Default
       GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform
       GuiControlGet, SimpleOperationsFlipV, SettingsGUIA:, SimpleOperationsFlipV
       GuiControlGet, SimpleOperationsFlipH, SettingsGUIA:, SimpleOperationsFlipH
       GuiControlGet, SimpleOperationsDoCrop, SettingsGUIA:, SimpleOperationsDoCrop
       GuiControlGet, SimpleOperationsRotateAngle, SettingsGUIA:, SimpleOperationsRotateAngle
       GuiControlGet, SimpleOperationsScaleXimgFactor, SettingsGUIA:, SimpleOperationsScaleXimgFactor
       GuiControlGet, SimpleOperationsScaleYimgFactor, SettingsGUIA:, SimpleOperationsScaleYimgFactor
       GuiControlGet, ResizeQualityHigh, SettingsGUIA:, ResizeQualityHigh
       GuiControlGet, ResizeDestFolder, SettingsGUIA:, ResizeDestFolder
       GuiControlGet, ResizeUseDestDir, SettingsGUIA:, ResizeUseDestDir
       GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
       GuiControlGet, userActionConflictingFile, SettingsGUIA:, userActionConflictingFile
       GuiControlGet, convertFormatUseMultiThreads, SettingsGUIA:, convertFormatUseMultiThreads

       userJpegQuality := clampInRange(userJpegQuality, 1, 100)
       RegAction(1, "userJpegQuality")
       RegAction(1, "convertFormatUseMultiThreads")
       cleanResizeUserOptionsVars()
       thisu := (ResizeMustPerform=1 && ResizeInPercentage=1 && SimpleOperationsScaleXimgFactor=100 && SimpleOperationsScaleYimgFactor=100) ? 1 : 0
       If ((thisu=1 || ResizeMustPerform=0) && SimpleOperationsRotateAngle=1 && SimpleOperationsFlipV=0 && SimpleOperationsFlipH=0 && SimpleOperationsDoCrop=0)
       {
          WriteSettingsResizePanel()
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": WARNING", "No image transformations selected or activated to perform.", 0, 0, "exclamation")
          Return
       }

       If ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
       || SimpleOperationsScaleXimgFactor<5 || SimpleOperationsScaleYimgFactor<5) && (ResizeMustPerform=1 && ResizeInPercentage=0))
       || ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
       || SimpleOperationsScaleXimgFactor<1 || SimpleOperationsScaleYimgFactor<1) && (ResizeMustPerform=1 && ResizeInPercentage=1))
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. The values must be increased.", 0, 0, "error")
          Return
       }
    }
 
    initFIMGmodule()
    If (wasInitFIMlib!=1 || FIMfailed2init=1)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "This tool is currently unsupported. The FreeImage library failed to properly initialize. Please make sure the FreeImage.dll is in the QPV folder.", 0, 0, "error")
       Return
    }

    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       If (ResizeMustPerform=1 && ResizeInPercentage=1 && (SimpleOperationsScaleXimgFactor>950 || SimpleOperationsScaleYimgFactor>950))
       {
          msgResult := msgBoxWrapper(appTitle ": WARNING", "You have selected to resize " groupDigits(filesElected) " images to " max(SimpleOperationsScaleXimgFactor, SimpleOperationsScaleYimgFactor) "%. This may cause QPV to crash or abnormal system behaviour, if the selected images are already large.`n`nAre you sure you want to proceed?", "&Yes|&Cancel", 2, "exclamation")
          If (msgResult!="Yes")
             Return
       }

       If (contextu!="extern")
          WriteSettingsResizeSimplePanel()
       batchSimpleProcessing(simpleOpRotationAngle, SimpleOperationsScaleXimgFactor, SimpleOperationsScaleYimgFactor)
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
    thisDialogSavePtrns := StrReplace(dialogSaveFptrn, "|Icon (*.ico)", "|Icon (*.ico)|High-Dynamic Range Image (*.hdr)|OpenEXR (*.exr)|Portable FloatMap (*.pfm)")
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    ; If (contextu!="extern")
    ; {
    ;    If (!filesElected && !RegExMatch(imgPath, thisRegEX))
    ;    {
    ;       SoundBeep, 300, 100
    ;       msgBoxWrapper(appTitle ": ERROR", "This file format (." oExt ") cannot be processed in «Simple mode». Please use the «Advanced mode» which allows file format conversions.", 0, 0, "exclamation")
    ;       Return
    ;    }
    ; }

   getSaveDialogIndexForFile(imgPath, defFMTindex, 1)
   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileName : imgPath
   If (dummy="no-prompt")
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save processed image as...", thisDialogSavePtrns, dialogFmtIndex, defFMTindex)

   If file2save
   {
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
      {
         nExt := dialogSaveIndexes[dialogFmtIndex]
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]
      }

      If !RegExMatch(file2save, thisRegEX)
      {
         SoundBeep, 300, 100
         If (dummy="no-prompt")
         {
            If (contextu="extern")
            {
               showTOOLtip("ERROR: Unsupported image file write format")
               SoundBeep , 300, 100
               SetTimer, RemoveTooltip, % -msgDisplayTime
            } Else msgBoxWrapper(appTitle ": ERROR", "Unsupported file write format. Please use one of the allowed image file formats: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         } Else msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      doConversion := 0
      If (nExt!=oExt && StrLen(nExt)>0)
      {
         doConversion := 1
         msgBoxWrapper(appTitle ": WARNING", "You chose to save the image file in a new format. Please note, this may lead to a color depth conversion.", 0, 0, "exclamation")
      }
      If (nExt="ico")
         doConversion := 1

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         msgu := "The image file format is currently unsupported, because the FreeImage library failed to properly initialize."
         SoundBeep, 300, 100
         If (contextu="extern")
         {
            showTOOLtip("ERROR: " msgu "`n" OutFileName)
            SetTimer, RemoveTooltip, % -msgDisplayTime
         } Else msgBoxWrapper(appTitle ": ERROR", msgu "`n`n" OutFileName, 0, 0, "error")
         Return
      }

      If (FileExist(file2save) && dummy!="no-prompt" && contextu!="extern")
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      destroyGDIfileCache()
      If (contextu!="extern")
      {
         GuiControl, SettingsGUIA: Disable, mainBtnACT
         SetTimer, reactivateMainBtnACT, -950
      }

      showTOOLtip("Processing image, please wait")
      r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor, SimpleOperationsScaleYimgFactor, doConversion)
      SetTimer, ResetImgLoadStatus, -250
      If r
      {
         SoundBeep, 300, 100
         If (contextu="extern")
            showTOOLtip("ERROR: Unable to save file. Code: " r "`n" OutFileName "`n" OutDir "\")
         Else
            msgBoxWrapper(appTitle ": ERROR", "Unable to save file, error code: " r ".`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      ForceRefreshNowThumbsList()
      resultedFilesList[currentFileIndex, 4] := 1
      If (SLDtypeLoaded=3)
         selectivePurgeCachedSQLdata(resultedFilesList[currentFileIndex, 12])

      If (contextu!="extern")
      {
         SetTimer, WriteSettingsResizeSimplePanel, -90
         SoundBeep, 900, 100
      }

      showTOOLtip("Processed image saved`n" OutFileName)
      If (dummy="no-prompt")
         SetTimer, RefreshImageFile, -150

      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

batchSimpleProcessing(rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to process " groupDigits(filesElected) " files?"
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      Else
         msgInfos .= "`n`nThe files will be will be OVERWRITTEN."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   backCurrentSLD := CurrentSLD
   setImageLoading()
   showTOOLtip("Processing " groupDigits(filesElected) " images, please wait")
   filesPerCore := calculateCoresRequired(filesElected)
   destroyGDIfileCache()
   mustDoMultiCore := (convertFormatUseMultiThreads=1 && systemCores>1 && filesPerCore>=2) ? 1 : 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      addJournalEntry("Preparing " systemCores " threads to start. " filesPerCore " files per thread.")
      infoResult := WorkLoadMultiCoresSimpleImgProcessing(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("Image processing in batch: failed to initialize multi-threaded processing")

   If (ResizeUseDestDir=1 && userPrivateMode!=1)
      destInfo := "`nDestination folder:`n" PathCompact(ResizeDestFolder, 50)

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
   countTFilez := failedFiles := filesConverted := skippedFiles := 0
   doStartLongOpDance()
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If !RegExMatch(imgPath, thisRegEX)
      {
         skippedFiles++
         Continue
      }

      countTFilez++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If failedFiles
            etaTime := "`nFailed to process " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip("Processing image files, please wait" destInfo etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := StrReplace(imgPath, "||")
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutFileName
      If (ResizeUseDestDir=1)
      {
         If (FileExist(file2save) && !FolderExist(file2save))
            file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite, !ResizeMustPerform)
      }

      If (file2save="abort")
      {
         abandonAll := 1
         Break
      } Else If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
      If r
         failedFiles++
      Else
         filesConverted++
   }

   If failedFiles
      someErrors := "`nFailed to process " groupDigits(failedFiles) " files"
   If skippedFiles
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   executingCanceableOperation := 0
   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip("Finished processing " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

batchSimpleColorsAdjusts() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to process " groupDigits(filesElected) " files?"
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      Else
         msgInfos .= "`n`nThe files will be will be OVERWRITTEN."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   BtnCloseWindow()
   backCurrentSLD := CurrentSLD
   setImageLoading()
   showTOOLtip("Processing " groupDigits(filesElected) " images, please wait")
   filesPerCore := calculateCoresRequired(filesElected)
   destroyGDIfileCache()
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (ResizeUseDestDir=1 && userPrivateMode!=1)
      destInfo := "`nDestination folder:`n" PathCompact(ResizeDestFolder, 50)

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   countTFilez := failedFiles := filesConverted := skippedFiles := 0
   doStartLongOpDance()
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      If (resultedFilesList[A_Index, 2]!=1)  ;  is not selected?
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If !RegExMatch(imgPath, saveTypesRegEX)
      {
         skippedFiles++
         Continue
      }

      countTFilez++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         etaTime := ETAinfos(countTFilez, markedSelectFile, startOperation)
         If failedFiles
            etaTime := "`nFailed to process " groupDigits(failedFiles) " files"
         If skippedFiles
            etaTime .= "`nSkipped files: " groupDigits(skippedFiles)

         showTOOLtip("Processing image files, please wait" destInfo etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := StrReplace(imgPath, "||")
      If (ResizeUseDestDir=1)
      {
         zPlitPath(imgPath, 0, OutFileName, OutDir)
         file2save := ResizeDestFolder "\" OutFileName
         If (FileExist(file2save) && !FolderExist(file2save))
            file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite, !ResizeMustPerform)
      } Else
         file2save := imgPath

      If (file2save="abort")
      {
         abandonAll := 1
         Break
      } Else If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreFreeImageSimpleColorsAdjust(imgPath, file2save)
      If (r="skip")
         skippedFiles++
      Else If r
         failedFiles++
      Else
         filesConverted++
   }

   If failedFiles
      someErrors := "`nFailed to process " groupDigits(failedFiles) " files"
   If skippedFiles
      someErrors .= "`nSkipped files: " groupDigits(skippedFiles)

   executingCanceableOperation := 0
   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files were processed until now" someErrors)
   Else
      showTOOLtip("Finished processing " groupDigits(filesConverted) " out of " groupDigits(filesElected) " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

printArrayStr(whichArray, delim:="|", forMode:=0) {
   listu := ""
   If (forMode=1)
   {
      For Key, Value in whichArray
          listu .= Key "," Value delim
   } Else
   {
      Loop, % whichArray.Count()
          listu .= whichArray[A_Index] delim
   }

   Return Trim(listu, delim)
}

printLargeStrArray(whichArray, maxList, delim) {
  Static trenchSize := 15000
  startZeit := A_TickCount
  filesListu := ""
  changeMcursor()
  If (maxList<trenchSize)
  {
     Loop, % maxList
     {
          rA := whichArray[A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu .= r delim
     }
     Return filesListu
  }

  doStartLongOpDance()
  splitParts := maxList//trenchSize
  Loop, % splitParts - 1
  {
      If (A_TickCount - startZeit>2500)
         executingCanceableOperation := A_TickCount

      changeMcursor()
      thisIndex := A_Index
      Loop, % trenchSize
      {
          rA := whichArray[trenchSize*(thisIndex-1) + A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu%thisIndex% .= r delim
      }

      If (determineTerminateOperation()=1) ; && (A_TickCount - startZeit>2500)
      {
         abandonAll := 1
         Break
      }
  }

  If (abandonAll=1)
  {
     SoundBeep, 300, 100
     lastLongOperationAbort := A_TickCount
     Return
  }

  Loop, % maxList - trenchSize*(splitParts - 1)
  {
      rA := whichArray[trenchSize*(splitParts - 1) + A_Index]
      r := rA[1]
      If (InStr(r, "||") || !r)
         Continue

      filesListu%splitParts% .= r delim
  }

  result := ""
  filesListu%splitParts% := Trimmer(filesListu%splitParts%)
  Loop, % splitParts
      result .= filesListu%A_Index%

  ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 
  Return result
}

dumpBMPpixels(miniBMP, w, h) {
    entireImgSmall := ""
    E1 := Gdip_LockBits(miniBMP, 0, 0, w, h, Stride1, Scan01, BitmapData1, 1, "0x21808")
    If !E1
    {
       Loop, % h
       {
          pY := A_Index - 1 ; y++
          Loop, % w ; x++
             entireImgSmall .= Chr(Gdip_BFromARGB(NumGet(Scan01+0, (A_Index - 1)*4+(pY*Stride1), "UInt")) + 161)
       }

       Gdip_UnlockBits(miniBMP, BitmapData1)
    } 
    Return entireImgSmall
}

calcHistoAvgFile(xBitmap, returnObj, isFilter, imgIndex, zEffect:=0, newBMPs:=0) {
    Static TotalPixelz := 122500, fmt := 3
    If !validBMP(xBitmap)
       Return 0

    ; Gdip_BitmapSetColorDepth(xBitmap, 24, 1)
    If zEffect
       Gdip_BitmapApplyEffect(xBitmap, zEffect)

    z := DllCall("gdiplus\GdipBitmapGetHistogramSize", "UInt", fmt, "UInt*", numEntries)
    VarSetCapacity(ch0, numEntries * 4, 0)
    R := DllCall("gdiplus\GdipBitmapGetHistogram", "UPtr", xBitmap, "UInt", fmt, "UInt", numEntries, "Ptr", &ch0, "Ptr", 0, "Ptr", 0, "Ptr", 0)
    If R
    {
       addJournalEntry(A_ThisFunc "() failed to retrieve histogram for " imgIndex)
       Return 0
    }

    medianValue := -1
    pixMinu := TotalPixelz
    modePointV := peakPointV := sumTotalBr := nrPixelz := thisSum := minBrLvlV := 0
    Loop, % numEntries
    {
        thisIndex := A_Index - 1
        nrPixelz := NumGet(&ch0+0, thisIndex * 4, "UInt")
        ; nrPixelz := brLvlArray[thisIndex]
        If (nrPixelz="")
           Continue

        If (nrPixelz>modePointV)
        {
           modePointV := nrPixelz
           modePointK := thisIndex
        }

        If (nrPixelz>0 && medianValue=-1)
        {
           thisSum += nrPixelz
           If (thisSum>TotalPixelz//2)
              medianValue := thisIndex
        }

        sumTotalBr += nrPixelz * A_Index
        If (nrPixelz>0)
        {
           peakPointK := thisIndex ; max range in histogram
           If !minBrLvlK
              minBrLvlK := thisIndex   ; min range in histogram
        }

        If (nrPixelz<pixMinu)
        {
           pixMinu := nrPixelz
           minPointK := thisIndex
        }
        pixRms += nrPixelz ** 2    ; root-mean square
    }

    ch0 := ""
    avgu := (sumTotalBr/TotalPixelz - 1)/2
    rmsu := Sqrt(pixRms / (peakPointK - minBrLvlK))

    entireImgSmall := entireImgBig := ""
    HentireImgSmall := HentireImgBig := ""
    If (SLDtypeLoaded=3) ; database 
    {
       If (dupesApplyBlur=1)
          Gdip_GaussianBlur(xBitmap, 4, 0)

       thisPolation := (hamDistInterpolation=1) ? 6 : 5
       x1 := trGdip_ResizeBitmap(A_ThisFunc, xBitmap, 9, 8, 0, thisPolation, -1)
       x2 := trGdip_ResizeBitmap(A_ThisFunc, xBitmap, 32, 32, 0, thisPolation, -1)
       entireImgSmall := dumpBMPpixels(x1, 9, 8)
       entireImgBig := dumpBMPpixels(x2, 32, 32)
       trGdip_DisposeImage(x1, 1)
       trGdip_DisposeImage(x2, 1)
       If (findFlippedDupes=1 && StrLen(newBMPs[1])>2)
       {
          Gdip_BitmapApplyEffect(newBMPs[1], zEffect)
          If (dupesApplyBlur=1)
             Gdip_GaussianBlur(xBitmap, newBMPs[1], 0)
          x1 := trGdip_ResizeBitmap(A_ThisFunc, newBMPs[1], 9, 8, 0, thisPolation, -1)
          x2 := trGdip_ResizeBitmap(A_ThisFunc, newBMPs[1], 32, 32, 0, thisPolation, -1)
          HentireImgSmall := dumpBMPpixels(x1, 9, 8)
          HentireImgBig := dumpBMPpixels(x2, 32, 32)
          trGdip_DisposeImage(x1, 1)
          trGdip_DisposeImage(x2, 1)
       }
    }
    ; fnOutputDebug("p = " entireImgSmall)
    If (returnObj=1)
    {
       r := []
       r.avg := Round((avgu + 1)/256, 5)
       r.median := Round((medianValue + 1)/256, 5)
       r.peak := Round((peakPointK + 1)/256, 5)
       r.low := Round((minBrLvlK + 1)/256, 5)
       r.rms := Round((rmsu + 1)/7000, 5)
       r.range := Round((peakPointK - minBrLvlK + 1)/256, 5)
       r.mode := Round((modePointK + 1)/256, 5)
       r.minu := Round((minPointK + 1)/256, 5)
       r.entireSmall := entireImgSmall
       r.entireBig := entireImgBig
       r.HentireSmall := HentireImgSmall
       r.HentireBig := HentireImgBig
       Return r
    } Else
    {
       updateFilesListByID(imgIndex, 11, 1, isFilter)
       updateFilesListByID(imgIndex, 18, Round((avgu + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 19, Round((medianValue + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 20, Round((peakPointK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 21, Round((minBrLvlK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 24, Round((rmsu + 1)/7000, 5), isFilter)
       updateFilesListByID(imgIndex, 25, Round((peakPointK - minBrLvlK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 26, Round((modePointK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 27, Round((minPointK + 1)/256, 5), isFilter)
       updateFilesListByID(imgIndex, 29, entireImgSmall, isFilter)
       updateFilesListByID(imgIndex, 30, entireImgBig, isFilter)
       updateFilesListByID(imgIndex, 31, hentireImgSmall, isFilter)
       updateFilesListByID(imgIndex, 32, hentireImgBig, isFilter)
    }
    ; ToolTip, % medianValue "=" r.avg "=" peakPointK "=" minBrLvlK , , , 2
    Return 1
}

GetCachableHistogramFile(imgPath, imgIndex, returnObj:=0, isFilter:=0, zEffect:=0) {
     If (!imgPath || !imgIndex)
     {
        addJournalEntry(A_ThisFunc "() - incorrect params error: " imgPath " | " imgIndex)
        Return
     }

     sizesDesired := []
     thisPolation := (hamDistInterpolation=1) ? 6 : 5
     sizesDesired[1] := [350, 350, 0, 1, thisPolation, 0, 0]
     If (SLDtypeLoaded=3)
     {
        If (findFlippedDupes=1)
           sizesDesired[2] := [350, 350, 0, 1, thisPolation, 4, 0]
     }

     thumbBMP := LoadBitmapFromFileu(imgPath, 0, 0, 0, sizesDesired, newBMPs)
     r := (mainLoadedIMGdetails.Width>1 && mainLoadedIMGdetails.Height>1) ? 1 : 0
     If (validBMP(thumbBMP) && r)
     {
        If (returnObj=1)
        {
           imgInfosObju := []
           imgInfosObju.dpi := mainLoadedIMGdetails.dpi
           imgInfosObju.w := mainLoadedIMGdetails.Width
           imgInfosObju.h := mainLoadedIMGdetails.Height
           imgInfosObju.pixFmt := mainLoadedIMGdetails.PixelFormat
           imgInfosObju.frames := (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1
        } Else
        {
           updateFilesListByID(imgIndex, 9, (mainLoadedIMGdetails.Frames) ? mainLoadedIMGdetails.Frames + 1 : 1, isFilter)
           updateFilesListByID(imgIndex, 13, mainLoadedIMGdetails.Width, isFilter)
           updateFilesListByID(imgIndex, 14, mainLoadedIMGdetails.Height, isFilter)
           updateFilesListByID(imgIndex, 15, mainLoadedIMGdetails.PixelFormat, isFilter)
           updateFilesListByID(imgIndex, 16, Round(mainLoadedIMGdetails.Width / mainLoadedIMGdetails.Height, 2), isFilter)
           updateFilesListByID(imgIndex, 17, Round((mainLoadedIMGdetails.Width * mainLoadedIMGdetails.Height)/1000000, 2), isFilter)
           updateFilesListByID(imgIndex, 22, mainLoadedIMGdetails.dpi, isFilter)
        }
     } Else imgInfosObju := 0

     If r
        histoObj := calcHistoAvgFile(thumbBMP, returnObj, isFilter, imgIndex, zEffect, newBMPs)
     Else
        histoObj := 0

     trGdip_DisposeImage(newBMPs[1], 1)
     trGdip_DisposeImage(thumbBMP, 1)

     If (IsObject(histoObj) && returnObj=1)
        Return [histoObj, imgInfosObju]
     Else
        Return histoObj
        ; fnOutputDebug(A_ThisFunc "() - no cache: " imgPath)
     ; } Else fnOutputDebug(A_ThisFunc "() - failed to generate histogram: " imgIndex " = " imgPath)
}

SaveFIMfile(file2save, pBitmap, userGivenDepth:=32, fileEXT:=0, gdipDepth:=32) {
  Static gifbitDp := "-8-",            ppmbitDp := "-24-"
       , jngbitDp := "-24-",           xpmbitDp := "-24-"
       , jpegbitDp := "-24-8-",        jp2bitDp := "-32-24-*8-"
       , pngbitDp := "-32-24-8-4-",    icobitDp := "-32-24-16-8-4-"
       , tiffbitDp := "-32-24-8-4-",   jxrbitDp := "-32-24-16-*8-"
       , bmpbitDp := "-32-24-16-8-4-", targabitDp := "-32-24-*16-8-"
       , webpbitDp := "-32-24-"      , j2kbitDp := "-32-24-*8-"

  initFIMGmodule()
  If !wasInitFIMlib
     Return 1

  bits := (gdipDepth=24) ? 1 : 0
  objDepth := (gdipDepth=24) ? 24 : 32
  hFIFimgA := ConvertPBITMAPtoFIM(pBitmap, bits)
  If !hFIFimgA
  {
     SoundBeep , 300, 100
     message := "Failed to convert GDI+ image object to FreeImage object..."
     addJournalEntry(message)
     Return message 
  }

  If FileExist(file2save)
  {
     Try FileSetAttrib, -R, % file2save
     Sleep, 0
     FileMove, % file2save, % file2save "-tmp"
     If !ErrorLevel
        tempFileExists := 1

     Sleep, 0
  }
  
  If !fileEXT
  {
     fileEXTpos := InStr(file2save, ".", 0, -1) ; RegExMatch(fileNamu, "\.[^\^.\\/:*?<>|\r\n]+$")
     If fileEXTpos
        fileEXT := SubStr(file2save, fileEXTpos + 1)
  }

  saveArg := 0
  If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
     saveArg :=  clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
  Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
     saveArg :=  clampInRange(Round(userJpegQuality), 1, 100)

  typu := FreeImage_GetFileType(file2save, 1)
  ; MsgBox, % objDepth "|" userGivenDepth "|" typu
  formatDepths := %typu%bitDp
  highestDepth := Trim(formatDepths, "-")
  highestDepth := SubStr(highestDepth, 1, InStr(highestDepth, "-") - 1)
  userDepthOkay := InStr(formatDepths, "-" userGivenDepth "-") ? 1 : 0
  ; MsgBox, % objDepth "|" userGivenDepth "|" userDepthOkay "|" typu "|" highestDepth
  If (objDepth=24)
  {
     If (userGivenDepth=8 && userDepthOkay=1 || typu="gif")
     {
        hFIFimgB := FreeImage_ColorQuantize(hFIFimgA, 1)
        r := FreeImage_Save(hFIFimgB, file2save, saveArg)
        FreeImage_UnLoad(hFIFimgB)
     } Else If (userGivenDepth=16 && userDepthOkay=1)
     {
        hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "16Bits")
        r := FreeImage_Save(hFIFimgB, file2save, saveArg)
        FreeImage_UnLoad(hFIFimgB)
     } Else If (InStr(formatDepths, "-" objDepth "-") || isVarEqualTo(typu, "jng", "ppm", "xpm"))
     {
        r := FreeImage_Save(hFIFimgA, file2save, saveArg)
     } Else unsaved := 1
  } Else If (objDepth=32)
  {
     If (userGivenDepth=8 && userDepthOkay=1 || typu="gif")
     {
        hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")
        hFIFimgC := FreeImage_ColorQuantize(hFIFimgB, 1)
        r := FreeImage_Save(hFIFimgC, file2save, saveArg)
        ; msgbox, % hFIFimgC "|"  hFIFimgB "|" r
        FreeImage_UnLoad(hFIFimgB)
        FreeImage_UnLoad(hFIFimgC)
     } Else If (userGivenDepth=16 && userDepthOkay=1)
     {
        hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "16Bits")
        r := FreeImage_Save(hFIFimgB, file2save, saveArg)
        FreeImage_UnLoad(hFIFimgB)
     } Else If (userGivenDepth=24 && userDepthOkay=1 || isVarEqualTo(typu, "jpeg", "jng", "ppm", "xpm"))
     {
        hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")
        r := FreeImage_Save(hFIFimgB, file2save, saveArg)
        FreeImage_UnLoad(hFIFimgB)
     } Else If InStr(formatDepths, "-" objDepth "-")
     {
        r := FreeImage_Save(hFIFimgA, file2save, saveArg)
     } Else unsaved := 1
  }

  If unsaved
  {
     SoundBeep 300, 100
     addJournalEntry("Failed to save image using FreeImage. No matching color depth for chosen format.")
  }

  FreeImage_UnLoad(hFIFimgA)
  If (!r && tempFileExists=1) || (!FileRexists(file2save, 0) && tempFileExists=1)
  {
     r := 0
     FileDelete, % file2save
     Sleep, 0
     FileMove, % file2save "-tmp", % file2save
  } Else If (tempFileExists=1)
     FileDelete, % file2save "-tmp"

  Return !r
}

initFIMGmodule() {
  Static firstTimer := 1
  If (wasInitFIMlib!=1)
  {
     bonusPath := mainExecPath
     Static srcDll := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\freeimage-r1909-custom\x64\Release\FreeImage.dll"
     ; Static srcDll := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\FreeImage-vold.dll"
     If (A_PtrSize=8 && InStr(A_ScriptDir, "sucan twins") && !A_IsCompiled && FileExist(srcDll))
        bonusPath := srcDll

     r := FreeImage_FoxInit(1, bonusPath) ; Load the FreeImage Dll
     wasInitFIMlib := (r && !InStr(r, "err")) ? 1 : 0
     If wasInitFIMlib
        addJournalEntry("FreeImage library initialized: v" FreeImage_GetVersion())
     Else
        addJournalEntry("ERROR: Failed to initialize the FreeImage library. Many image file formats are no longer supported.")
  }

  If InStr(r, "err - ")
  {
     alwaysOpenwithFIM := 0
     FIMfailed2init := 1
     If InStr(r, "err - 126")
        friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2013."
     Else If InStr(r, "err - 404")
        friendly := "`n`nThe FreeImage.dll file seems to be missing..."

     If (firstTimer=1 && hasInitSpecialMode!=1)
     {
        SoundBeep, 300, 100
        msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Some image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
     }
  } Else FIMfailed2init := 0

  firstTimer := 0
  Return r
}

LoadFimFile(imgPath, noBPPconv, noBMP:=0, frameu:=0, sizesDesired:=0, ByRef newBitmap:=0, nofall:=0, screenMode:=0) {
  Critical, on
  sTime := A_tickcount  
  initFIMGmodule()
  If !wasInitFIMlib
  {
     If (RegExMatch(imgPath, RegExWICfmtPtrn) && WICmoduleHasInit=1 && allowWICloader=1 && nofall=0)
     {
        If (screenMode=1)
           Return LoadWICscreenImage(imgPath, 0, frameu)

        oBitmap := LoadWICimage(imgPath, noBPPconv, frameu, sizesDesired, gBitmap)
        newBitmap := gBitmap
        Return oBitmap
     }
     Return
  }

  loadArgs := FIMdecideLoadArgs(imgPath, userHQraw, GFT)
  If (noBPPconv=1 || noBMP=1)
     loadArgs := -1  ; FIF_LOAD_NOPIXELS

  If (FreeImage_FIFSupportsNoPixels(GFT) && loadArgs!=-1 && screenMode=1)
  {
     hFIFimgA := FreeImage_Load(imgPath, GFT, -1)
     FreeImage_GetImageDimensions(hFIFimgA, zw, zh)
     bpp := FreeImage_GetBPP(hFIFimgA)
     If (bpp<24)
        bpp := 16
     FreeImage_UnLoad(hFIFimgA)
     If memoryUsageWarning(zw, zh, bpp, 1)
        Return
  }

  changeMcursor()
  If ((GFT=18 || GFT=25) && noBPPconv=0 && noBMP=0)
  {
     ; open multi-page GIF and TIFFs
     multiFlags := (GFT=25) ? 2 : 0
     hMultiBMP := FreeImage_OpenMultiBitmap(imgPath, GFT, 0, 1, 1, multiFlags)
  }

  tFrames := 0
  fimMultiPage := ""
  mainLoadedIMGdetails.Frames := 0
  If StrLen(hMultiBMP)>1
  {
     hasOpenedMulti := 1
     tFrames := FreeImage_GetPageCount(hMultiBMP)
     If (tFrames<0 || !tFrames)
        tFrames := 0

     If (tFrames>1)
     {
        fimMultiPage := (GFT=18) ? "tiff" : "gif"
        frameu := clampInRange(frameu, 0, tFrames - 1)
        mainLoadedIMGdetails.Frames := tFrames - 1
        ; msgbox, % a_thisfunc "=" totalFramesIndex "==" desiredFrameIndex
        hPage := FreeImage_LockPage(hMultiBMP, frameu)
        If (hPage!="")
        {
           ; fnOutputDebug("multipage FIM: " hMultiBMP "| h=" hpage "|" frameu "/" tFrames)
           hFIFimgA := FreeImage_Clone(hPage)
           If hFIFimgA
              hasMultiTrans := FreeImage_GetTransparencyCount(hFIFimgA)

           FreeImage_UnlockPage(hMultiBMP, hPage, 0)
        }
        ; ToolTip, % hasMultiTrans "==" frameu "==" frameu , , , 2
        FreeImage_CloseMultiBitmap(hMultiBMP, 0)
     } Else
     {
        FreeImage_CloseMultiBitmap(hMultiBMP, 0)
        hFIFimgA := FreeImage_Load(imgPath, GFT, loadArgs) ; load image
     }
  } Else hFIFimgA := FreeImage_Load(imgPath, GFT, loadArgs) ; load image

  If !hFIFimgA
  {
     ; ToolTip, % "lol " GFT "=" loadArgs , , , 2
     addJournalEntry("Failed to load image file using FreeImage library:`n" imgPath)
     If (RegExMatch(imgPath, RegExWICfmtPtrn) && WICmoduleHasInit=1 && allowWICloader=1 && nofall=0)
     {
        oBitmap := LoadWICimage(imgPath, noBPPconv, frameu, sizesDesired, gBitmap)
        newBitmap := gBitmap
        Return oBitmap
     }
     Return
  }

  FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
  If (isImgSizeTooLarge(imgW, imgH) && screenMode=1)
  {
     viewportQPVimage.LoadImage(imgPath, frameu, 0, 1, [hFIFimgA, tFrames], 1)
     Return "very-large"
  }

  FreeImage_GetDPIresolution(hFIFimgA, dpiX, dpiY)
  oimgBPP := FreeImage_GetBPP(hFIFimgA)
  imgBPP := Trimmer(StrReplace(oimgBPP, "-"))
  ColorsType := FreeImage_GetColorType(hFIFimgA)
  imgType := FreeImage_GetImageType(hFIFimgA, 1)
  ; msgbox, % GFT "=l=" mustApplyToneMapping
  ; fnOutputDebug(A_ThisFunc "(): " imgBPP "|" ColorsType "|" imgType "|" mustApplyToneMapping "|" GFT "|" imgPath)
  If (noBPPconv=0 && noBMP=0)
     hFIFimgA := FIMapplyToneMapper(hFIFimgA, GFT, imgBPP, ColorsType, 1, toneMapped)

  fileType := FreeImage_GetFileType(imgPath, 1)
  If (fileType="raw" && userHQraw!=1)
  {
     fileType .= " [LOW QUALITY]"
     If !toneMapped
        toneMapped := " (TONE-MAPPABLE)"
  }

  mainLoadedIMGdetails.File := imgPath
  mainLoadedIMGdetails.dpi := Round((dpix + dpiy)/2)
  mainLoadedIMGdetails.Width := imgW
  mainLoadedIMGdetails.Height := imgH
  mainLoadedIMGdetails.Frames := (hasOpenedMulti!=1) ? FreeImage_SimpleGetPageCount(hFIFimgA) - 1 : tFrames - 1
  mainLoadedIMGdetails.HasAlpha := (InStr(ColorsType, "rgba") || hasMultiTrans) ? 1 : 0
  mainLoadedIMGdetails.RawFormat := fileType " | " imgType
  mainLoadedIMGdetails.PixelFormat := StrReplace(oimgBPP, "-", "+") "-" ColorsType toneMapped
  mainLoadedIMGdetails.OpenedWith := "FreeImage library [FIM]"
  mainLoadedIMGdetails.TooLargeGDI := isImgSizeTooLarge(imgW, imgH)
  If (noBMP=1)
  {
     FreeImage_UnLoad(hFIFimgA)
     Return 1
  }

  hFIFimgZ := hFIFimgB ? hFIFimgB : hFIFimgA
  hFIFimgC := hFIFimgZ ? hFIFimgZ : hFIFimgA
  FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)
  If IsObject(sizesDesired[2] && noBPPconv=0 && noBMP=0)
  {
     hFIFimgX := FIMrescaleOBJbmp(hFIFimgC, imgW, imgH, 2, sizesDesired)
     If hFIFimgX
     {
        thisBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgX), "-"))
        If (thisBPPc!=32)
        {
           hFIFimgDE := FreeImage_ConvertTo(hFIFimgX, "32Bits")
           If hFIFimgDE
           {
              newBitmap := ConvertFIMtoPBITMAP(hFIFimgDE)
              FreeImage_UnLoad(hFIFimgDE)
           }
        } Else newBitmap := ConvertFIMtoPBITMAP(hFIFimgX)

        FreeImage_UnLoad(hFIFimgX)
        If StrLen(newBitmap)>2
           recordGdipBitmaps(newBitmap, A_ThisFunc)
     }
  }

  If (noBPPconv=0)
  {
     hFIFimgX := FIMrescaleOBJbmp(hFIFimgC, imgW, imgH, 1, sizesDesired)
     If hFIFimgX
     {
        hFIFimgC := hFIFimgX
        FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)
     } Else If isImgSizeTooLarge(imgW, imgH)
     {
        setWindowTitle("Rescaling image to fit the GDI+ maximum image dimensions limits")
        nImgW := imgW, nImgH:= imgH
        capIMGdimensionsGDIPlimits(nImgW, nImgH)
        changeMcursor()
        hFIFimgKO := FreeImage_Rescale(hFIFimgC, nimgW, nimgH, 0)
     }

     If StrLen(hFIFimgKO)>2
     {
        hFIFimgC := hFIFimgKO
        mainLoadedIMGdetails.TooLargeGDI := 1
        FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)
     }

     setWindowTitle("Converting FreeImage object to GDI+ image bitmap")
     If (noBPPconv=0 && noBMP=0 && GFT=0 && InStr(ColorsType, "rgba"))
        alphaBitmap := FreeImage_GetChannel(hFIFimgC, 4)

     imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgC), "-"))
     If (imgBPPc!=32)
        hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "32Bits")

     hFIFimgE := hFIFimgD ? hFIFimgD : hFIFimgC
     If (alphaBitmap!="")
        mainLoadedIMGdetails.HasAlpha := FIMalphaChannelFix(alphaBitmap, hFIFimgE)

     ; FreeImage_PreMultiplyWithAlpha(hFIFimgE)
     pBitmap := ConvertFIMtoPBITMAP(hFIFimgE)
     If StrLen(pBitmap)>2
        recordGdipBitmaps(pBitmap, A_ThisFunc)
  } Else pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, coreDesiredPixFmt)

  ; trGdip_GetImageDimensions(pBitmap, imgW2, imgH2)
  imgIDs := hFIFimgA "|" hFIFimgB "|" hFIFimgC "|" hFIFimgKO "|" hFIFimgD "|" hFIFimgE "|" hFIFimgZ
  Sort, imgIDs, UD|
  Loop, Parse, imgIDs, |
  {
      If A_LoopField
         FreeImage_UnLoad(A_LoopField)
  }

  eTime := A_TickCount - sTime
  Return pBitmap
} ;// LoadFimFile

changeMcursor(whichCursor:=0) {
  Static lastInvoked := 1, prevCursor := "none"
  If ((drawingShapeNow=1 || slideShowRunning=1 || animGIFplaying=1 || (A_TickCount - zeitSillyPrevent<300) || hasInitSpecialMode=1) && imageLoading!=1)
     Return

  If (whichCursor)
  {
     prevCursor := whichCursor
     interfaceThread.ahkPostFunction("changeMcursor", whichCursor)
  } Else If (A_TickCount - lastInvoked > 400) ; && (imageLoading!=1)
  {
     interfaceThread.ahkPostFunction("changeMcursor", "busy")
     ; interfaceThread.ahkassign("imageLoading", 1)
     ; Try DllCall("user32\SetCursor", "Ptr", hCursBusy)
     lastInvoked := A_TickCount
  }
}

GetImgFileDimension(imgPath, ByRef W, ByRef H, fastWay:=1, thisFileIndex:=0) {
   Static prevImgPath, prevW, prevH
   If !FileExist(imgPath)
      Return 0

   If (fastWay=1 && thisFileIndex)
   {
      If !resultedFilesList[thisFileIndex, 9]
      {
         If !retrieveSQLdbEntryImgInfos(imgPath, thisFileIndex, resultedFilesList[thisFileIndex, 12])
            GetCachableImgFileDetails(imgPath, thisFileIndex)
 
         If (SLDtypeLoaded=3 && resultedFilesList[thisFileIndex, 13])
            updateSQLdbEntryImgRes(imgPath, 1, 1, resultedFilesList[thisFileIndex, 12], thisFileIndex)
      }

      W := resultedFilesList[thisFileIndex, 13]
      H := resultedFilesList[thisFileIndex, 14]
      r := (w>1 && h>1) ? 1 : 0
      Return r
   }

   thisImgPath := generateThumbName(imgPath, 1) fastWay
   If (prevImgPath=thisImgPath && prevH>1 && prevW>1)
   {
      W := prevW
      H := prevH
      Return 1
   }
   If (allowWICloader=1 && WICmoduleHasInit=1)
      fastWay := 1

   changeMcursor()
   prevImgPath := thisImgPath
   pBitmap := LoadBitmapFromFileu(imgPath, fastWay)
   prevW := W := mainLoadedIMGdetails.Width
   prevH := H := mainLoadedIMGdetails.Height
   trGdip_DisposeImage(pBitmap, 1)

   changeMcursor("normal")
   r := (w>1 && h>1) ? 1 : 0
   Return r
}

isInRange(value, inputA, inputB) {
    If (value=inputA || value=inputB)
       Return 1

    Return (value>=min(inputA, inputB) && value<=max(inputA, inputB)) ? 1 : 0
}

isInRangeF(value, minu, maxu) {
    Return (value>=minu && value<=maxu) ? 1 : 0
}

checkThumbExists(MD5name, imgPath, ByRef file2load) {
   file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
   If FileExist(file2save)
   {
      FileGetSize, fileSizu, % file2save
      If (fileSizu<3)
         Return 0

      file2load := file2save
      Return 1
   } Else If (thumbsSizeQuality>755)
   {
      file2load := imgPath
      Return 0
   } Else If (thumbsSizeQuality>=500)
   {
      file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : imgPath
   } Else If (thumbsSizeQuality>=245)
   {
      file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : imgPath
      }
   } Else If (thumbsSizeQuality>124)
   {
      file2test := thumbsCacheFolder "\245-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : 0
         If !file2load
         {
            file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
            file2load := FileExist(file2test) ? file2test : imgPath
         }
      }
   }
   FileGetSize, fileSizu, % file2load
   r := (imgPath=file2load || fileSizu<3) ? 0 : 1
   Return r
}

generateThumbName(imgPath, forceThis:=0) {
   Static lastInvoked := 1, prevMD5name, prevImgPath := "null"

   If (A_TickCount - lastInvoked<150) && (imgPath=prevImgPath)
      Return prevMD5name

   If (enableThumbsCaching!=1 && forceThis=0)
      Return

   obju := GetFileAttributesEx(imgPath)
   MD5name := CalcStringHash(imgPath obj.size obju.wtime obju.ctime, 0x8003)
   lastInvoked := A_TickCount
   prevMD5name := MD5name
   Return MD5name
}

decideWinReactivation() {
    SetTimer, dummyDecideWinReactivation, -55
}

dummyDecideWinReactivation() {
    If (WinActive("A")!=hQPVtoolbar)
       Return

    btnID := tlbrIconzList[lastTlbrClicked, 10]
    If isVarEqualTo(btnID, "BTNundoImg", "BTNredoImg", "BTNpaintSelection")
    {
       WinActivate, ahk_id %PVhwnd%
    } Else ; If (WinActive("A")=hQPVtoolbar)
    {
       If (AnyWindowOpen && imgEditPanelOpened!=1) || (AnyWindowOpen && imgEditPanelOpened=1 && panelWinCollapsed!=1)
          WinActivate, ahk_id %hSetWinGui%
       Else
          WinActivate, ahk_id %PVhwnd%
    }
    Return 1
}

WM_LBUTTONup(wP, lP, msg, hwnd) {
    thisWin := WinActive("A")
    If (MsgBox2hwnd=thisWin && MsgBox2Result="wait-ask")
    {
       Gui, WinMsgBox: Default
       MouseGetPos, ,,, OutputVarControl, 2
       GuiControlGet, btnFocused, WinMsgBox: FocusV
       GuiControlGet, hwnd, hwnd, %btnFocused%
       ControlGetText, btnText, , ahk_id %hwnd%
       ; ToolTip, % A_GuiControl "|" btnFocused "|" btnText "|" hwnd "|" OutputVarControl , , , 3
       If (hwnd!=OutputVarControl || InStr(btnFocused, "checkbox") || InStr(A_GuiControl, "checkbox"))
          Return

       MsgBox2Result := btnFocused && btnText ? btnText : "close"
       MsgBox2InputHook.Stop()
       Return
    }

    colorPickerMustEnd := 1
    If (thisWin=hSetWinGui && AnyWindowOpen)
    {
       GuiUpdateFocusedSliders()
       highlightActiveCtrl("click")
    } Else If (ShowAdvToolbar=1 && thisWin=hQPVtoolbar)
       decideWinReactivation()
}

WM_LBUTTONdown(wP, lP, msg, hwnd) {
    Static lastInvoked := 1
    thisWin := WinActive("A")
    If (!isVarEqualTo(thisWin, hSliderWidget, hQPVtoolbar, PVhwnd) && soloSliderWinVisible=1)
       destroySoloSliderWidget()

    colorPickerMustEnd := 1
    If (ShowAdvToolbar=1)
    {
       MouseGetPos, ,, OutputVarWin, OutputVarControl, 2
       btnMode := tlbrIconzList[hwnd, 4]
       If (!btnMode && StrLen(OutputVarControl)>3)
          btnMode := tlbrIconzList[OutputVarControl, 4]
    }

    If (btnMode=1)
    {
       phwnd := Format("0x{1:x}", hwnd)
       If StrLen(OutputVarControl)>3
          phwnd := OutputVarControl

       btnName := tlbrIconzList[phwnd, 3]
       ; ToolTip, % btnName "|" phwnd "|" OutputVarControl  , , , 2
       If tlbrIconzList[phwnd, 4]
          tlbrInvokeFunction(phwnd, "n", "n")
    } If (imgEditPanelOpened=1 && thisWin=hSetWinGui && panelWinCollapsed=1)
    {
       SetTimer, toggleImgEditPanelWindow, -50
    } Else If (thisWin=hSetWinGui) ; && (A_TickCount - lastInvoked<650)
    {
       GuiControlGet, OutputVname, SettingsGUIA: FocusV
       GuiControlGet, OutputVar, SettingsGUIA: Focus
       GuiControlGet, OutputVal, SettingsGUIA:, % OutputVname
       GuiControlGet, OutputEnable, SettingsGUIA: Enabled, % OutputVname
       GuiControlGet, hVar, SettingsGUIA: hwnd, % OutputVname
       MouseGetPos, , , OutputVarWin, OutputVarControl, 2
       If (OutputVarWin=hSetWinGui && OutputEnable=1 && OutputVarControl=hVar && isNumber(OutputVal) && InStr(OutputVar, "edit"))
       {
          fn := Func("adjustNumbersEditFields").Bind(OutputVal, OutputVname)
          SetTimer, % fn , -50
       }
    }
}

adjustWheelNumbersEditFields(wParam, lParam, msg) {
   ; author: tidbit
   ; Created: Thu October 10, 2013
   If !AnyWindowOpen
      Return

   GuiControlGet, controlType, Focus
   GuiControlGet, OutputVname, SettingsGUIA: FocusV
   GuiControlGet, OutputEnable, SettingsGUIA: Enabled, % OutputVname
   If InStr(OutputVname, "customSliders")
   {
      result := (wParam >> 16)     ; return the HIWORD -  high-order word 
      givenKey := (result>0 && result<51234) ? "WheelUp" : "WheelDown"
      If ((wParam & 0xffff=4) || (wParam & 0xffff=8))
         givenKey := (result>0 && result<51234) ? "PgUp" : "PgDn"

      GuiControlGet, hVar, SettingsGUIA: hwnd, % OutputVname
      GuiSlidersResponder(hVar, "uiLabel", givenKey)
      Return
   }

   isOkay := (SubStr(OutputVname, 1, 5)!="editF" || StrLen(OutputVname)>6) ? 1 : 0
   if (!instr(controlType, "Edit") || !isOkay || !OutputEnable)
      return
      
   GuiControlGet, value,, %A_GuiControl%
   If value is not number
      Return

   If !A_GuiControl
      Return

   result := (wParam >> 16)     ; return the HIWORD -  high-order word 
   stepping := Round(Abs(result) / 120)
   direction := (result>0 && result<51234) ? 1 : -1
   mult := ((wParam & 0xffff=4) ? 5 : (wParam & 0xffff=8) ? 10 : 1)
   amt := (msg=526) ? 5 : 1 ; How much to increase the value
   value += direction*amt*mult
   GuiControl,, %A_GuiControl%, % RegExReplace(value, "(\.[1-9]+)0+$", "$1")
}

adjustNumbersEditFields(OutputVal, OutputVname) {
    Static delayu := -1
    GetPhysicalCursorPos(oX, oY)
    cX := cY := lastIndex := thisIndex := lastInvoked2 := 0
    While, (determineLClickState()=1 || A_Index=1)
    {
       GetPhysicalCursorPos(mX, mY)
       dir := (oY<mY) ? -1 : 1
       If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
       {
          If !isInRange(thisIndex, lastIndex - 2, lastIndex + 2)
          || (A_TickCount - lastInvoked2>100 + delayu)
          {
             lastIndex := thisIndex
             MouseMove, % oX, % oY, 1
          }
          cX := mX, cY := mY
          Continue
       }

       lastInvoked2 := A_TickCount
       cX := mX, cY := mY
       OutputVal := (dir=1) ? OutputVal + 1 : OutputVal - 1
       GuiControl, SettingsGUIA:, % OutputVname, % OutputVal
       Sleep, % delayu
       thisIndex++
    }
}

OpenNewExternalCoreThread(thisIndex, args, thisList) {
   pidThread := 0
   Try FileDelete, %thumbsCacheFolder%\tempList%thisIndex%.txt
   Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
   Sleep, 0
   Try FileAppend, % thisList, %thumbsCacheFolder%\tempFilesList.txt, utf-16
   Catch wasErrorA
         Sleep, 1

   If wasErrorA
      Return 0

   Sleep, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, threadParams, %thisIndex%||%args%

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath%,,, pidThread
   Catch wasErrorB
       Sleep, 0

   If (wasErrorB || !pidThread)
   {
      Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
      Return 0
   } Else
   {
      WinWait, ahk_pid %pidThread%,,2
      WinGet, hwndThread, ID, ahk_pid %pidThread%
      Sleep, 10
      Loop, 500
      {
          RegRead, thisThreadStarted, %QPVregEntry%\multicore, ThreadRunning%thisIndex%
          If (thisThreadStarted=1 || thisThreadStarted=2 || thisThreadStarted=-1)
             Break
          Else
             Sleep, 15
      }

      allGood := (thisThreadStarted=1 || thisThreadStarted=2) ? 1 : 0
      If (allGood!=1)
      {
         Process, Close, % pidThread
         RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
         Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
         Return 0
      }
      Return pidThread
   }
}

initExternalCoreMode() {
  Critical, on
  hasInitSpecialMode := 1
  RegRead, mainThreadHwnd, %QPVregEntry%\multicore, mainThreadHwnd
  If !WinExist("ahk_id" mainThreadHwnd)
  {
     RegWrite, REG_SZ, %QPVregEntry%, Running, 0
     fatalError := 1
  }

  RegRead, threadParams, %QPVregEntry%\multicore, threadParams
  If !threadParams
     fatalError := 1

  args := StrSplit(threadParams, "||")
  coreThread := args[1]

  Try FileRead, filesList, %thumbsCacheFolder%\tempFilesList.txt
  If !filesList
     fatalError := 1

  If (fatalError=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, -1
     ForceExitNow()
     Return
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 1
  initFIMGmodule()
  RegRead, hGDIwin, %QPVregEntry%\multicore, mainWindowID
     ; MsgBox, % args[1] "--" args[3]
  If (args[2]="batch-jpegll")
     multiCoresJpegLL(args[1], args[3], filesList)
  Else If (args[2]="batch-simpleimgproc")
     multiCoresSimpleImgProcessing(args[1], args[3], filesList)
  Else If (args[2]="batch-fmtconv")
     multiCoresFormatConvert(args[1], filesList)

  ; msgbox, killaaaa
  ForceExitNow()
  Return
}

printImageNow(mainBMP, PrintOptions, previewMode, inLoop:=0, OutFileName:=0) {
   If !validBMP(mainBMP)
   {
      addJournalEntry(A_ThisFunc "(). ERROR: invalid bitmap.")
      Return -1
   }

   pPrinterName := PrintOptions.pPrinterName
   adaptFit := PrintOptions.adaptFit
   userImgX := PrintOptions.userImgX
   userImgY := PrintOptions.userImgY
   userImgW := PrintOptions.userImgW
   userImgH := PrintOptions.userImgH
   colorsMode := PrintOptions.colorsMode
   imgOrient := PrintOptions.imgOrient
   imgOrient := (imgOrient>0) ? imgOrient : 360 + imgOrient
   paperOrient := PrintOptions.paperOrient
   copiez := PrintOptions.copiez
   flipuV := PrintOptions.flipuV
   flipuH := PrintOptions.flipuH
   applyFX := PrintOptions.applyFX

   ; pPrinterName := SGDIPrint_GetDefaultPrinter()
   ; hdcObj := SGDIPrint_GetHDCfromPrintDlg(PVhwnd)
   hdcObj := SGDIPrint_GetHDCfromPrinterName(pPrinterName, paperOrient, Round(colorsMode + 1), copiez, PVhwnd, printerDevModeOptions)
   If (previewMode=1)
   {
      calcIMGdimensions(hdcObj.HDC_Width, hdcObj.HDC_Height, 496, 702, ResizedW, ResizedH)
   } Else
   {
      ResizedW := hdcObj.HDC_Width
      ResizedH := hdcObj.HDC_Height
   }

   ; - "print" to bitmap -
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, coreDesiredPixFmt)
   If (previewMode!=1 && inLoop=0)
   {
      If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
         Return -2
   } Else If !validBMP(pBitmap)
   {
      addJournalEntry(A_ThisFunc "(): failed to create bitmap")
      Return -2
   }

   gPrint := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4, 2)
   If (previewMode=1)
      E := trGdip_GraphicsClear(A_ThisFunc, gPrint, "0xFFffFFff")
   If (!gPrint || E="fail")
   {
      addJournalEntry(A_ThisFunc "(): failed to create Graphics object")
      Return -3
   }

   If (applyFX=1)
      decideGDIPimageFX(matrix, imageAttribs, pEffect)

   trGdip_GetImageDimensions(pBitmap, pageW, pageH)
   oimgPosX := imgPosX := Round(pageW*(userImgX/100))
   oimgPosY := imgPosY := Round(pageH*(userImgY/100))
   oimgNewW := imgNewW := Round(pageW*(userImgW/100))
   oimgNewH := imgNewH := Round(pageH*(userImgH/100))
   If (adaptFit=1)
   {
      imgNewH := pageH
      imgNewW := pageW
      imgPosX := imgPosY := 0
   }

   ; mainBMP := useGdiBitmap()
   If isInRange(imgOrient, 1, 359)
   {
      If (previewMode=1)
         imgToPrint := trGdip_ResizeBitmap(A_ThisFunc, mainBMP, 600, 700, 1, 3, -1)

      whichBitmap := validBMP(imgToPrint) ? imgToPrint : mainBMP
      newBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, imgOrient, 1)
      If validBMP(imgToPrint)
         imgToPrint := trGdip_DisposeImage(imgToPrint, 1)

      If validBMP(newBitmap)
      {
         hasRotated := 1
         imgToPrint := newBitmap
      }
   } 

   whichBitmap := (hasRotated=1) ? imgToPrint : mainBMP
   trGdip_GetImageDimensions(whichBitmap, realImgW, realImgH)
   If (PrintAdaptToFit=1 || PrintAdaptToFit=0 && PrintStrechedSize=0)
      calcIMGdimensions(realImgW, realImgH, imgNewW, imgNewH, imgNewW, imgNewH)
   ; Gdip_GetRotatedDimensions(imgNewW, imgNewH, imgOrient, rotImgW, rotImgH)
   newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgNewW, imgNewH, 0)
   trGdip_DisposeImage(imgToPrint, 1)

   failedResize := 0
   If validBMP(newBitmap)
      imgToPrint := newBitmap
   Else
      failedResize := 1

   If pEffect
   {
      Gdip_BitmapApplyEffect(imgToPrint, pEffect)
      Gdip_DisposeEffect(pEffect)
   }

   If (colorsMode=0 && previewMode=1)
   {
      newBitmap := trGdip_BitmapConvertGray(A_ThisFunc, imgToPrint)
      If validBMP(newBitmap)
      {
         trGdip_DisposeImage(imgToPrint, 1)
         imgToPrint := newBitmap
      }
   }
   If (flipuV=1)
      Gdip_ImageRotateFlip(imgToPrint, 6)
   If (flipuH=1)
      Gdip_ImageRotateFlip(imgToPrint, 4)

   If (adaptFit=1)
   {
      trGdip_GetImageDimensions(imgToPrint, imgNewW, imgNewH)
      imgPosX := (pageW - imgNewW)//2
      imgPosY := (pageH - imgNewH)//2
   }

   r4 := trGdip_DrawImage(A_ThisFunc, gPrint, imgToPrint, imgPosX, imgPosY,,,,,,,,, imageAttribs)
   Gdip_DisposeImageAttributes(imageAttribs)
   previewScale := ResizedW / hdcObj.HDC_Width
   If (StrLen(PrintOptions.text)>0)
   {
      If (TextInAreaFontBold=1)
         thisStylu .= "Bold "
      If (TextInAreaFontItalic=1)
         thisStylu .= "Italic "
      If (TextInAreaFontUline=1)
         thisStylu .= "Underline "

      If (TextInAreaAlign=1)
         thisTxtAlignu := "Left "
      Else If (TextInAreaAlign=2)
         thisTxtAlignu := "Center "
      Else If (TextInAreaAlign=3)
         thisTxtAlignu := "Right "

      If (TextInAreaValign=1)
         thisTxtvAlignu := "Top "
      Else If (TextInAreaValign=2)
         thisTxtvAlignu := "vCenter "
      Else If (TextInAreaValign=3)
         thisTxtvAlignu := "Bottom "
      ; SoundBeep 
      textu := StrReplace(PrintOptions.text, "{fname}", OutFileName)
      thisColoru := " c" Format("{:x}", TextInAreaFontOpacity) . TextInAreaFontColor
      ; ToolTip, % thisColoru , , , 2
      ERR := Gdip_TextToGraphics(gPrint, textu, thisTxtAlignu thisTxtvAlignu thisStylu " s" Round(PrintTxtSize*previewScale) thisColoru, TextInAreaFontName, pageW, pageH)
      ; ToolTip, % ERR " == "  PrintOptions.text "`n" thisTxtAlignu thisTxtvAlignu " s" TextInAreaFontSize " c" TextInAreaFontColor " == " TextInAreaFontName " == " pageW " == " pageH , , , 2
   }

   If (previewMode=1 && PrintAdaptToFit=0)
   {
      Gdip_SetPenWidth(pPen1d, 2.5)
      Gdip_SetPenWidth(pPen1, 2.5)
      Gdip_DrawRectangle(gPrint, pPen1d, oimgPosX, oimgPosY, oimgNewW, oimgNewH)
      Gdip_DrawRectangle(gPrint, pPen1, oimgPosX + 2, oimgPosY + 2, oimgNewW, oimgNewH)
   }

   If (previewMode!=1 && r4!="fail" && failedResize!=1)
   {
      r := SGDIPrint_BeginDocument(hdcObj.HDC_ptr, appTitle " image file")
      If r
      {
         SGDIPrint_CopyBitmapToPrinterHDC(pBitmap, hdcObj.HDC_ptr, hdcObj.HDC_Width, hdcObj.HDC_Height)
         SGDIPrint_EndDocument(hdcObj.HDC_ptr) ; starts printing
      }
   } Else If (previewMode=1)
   {
      marginuX := hdcObj.HDC_PHYSICALOFFSETX/hdcObj.HDC_PHYSICALWIDTH
      marginuY := hdcObj.HDC_PHYSICALOFFSETY/hdcObj.HDC_PHYSICALHEIGHT
      marginuX := Ceil(ResizedW * marginuX)
      marginuY := Ceil(ResizedH * marginuY)
      newBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW + marginuX*2, ResizedH + marginuY*2)
      If validBMP(newBitmap)
      {
         Gu := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
         If Gu
         {
            Gdip_SetPageUnit(Gu, 2)
            Gdip_SetSmoothingMode(Gu, 4) 
            Gdip_GraphicsClear(Gu, "0xffFFffFF")
            r4 := trGdip_DrawImage(A_ThisFunc, Gu, pBitmap, marginuX, marginuY)
            Gdip_DeleteGraphics(gU)
            If (r4!="fail")
               Gdip_SetPbitmapCtrl(hCropCornersPic, newBitmap)
         }
         trGdip_DisposeImage(newBitmap, 1)
      } Else
      {
         addJournalEntry(A_ThisFunc "(): ERROR. Invalid print bitmap.")
      }
      pageDPI := Round((hdcObj.hdc_xdpi + hdcObj.hdc_ydpi)/2)
      pageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi, 1)
      pageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi, 1)
      MMpageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi * 25.4)
      MMpageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi * 25.4)
      GuiControl, SettingsGUIA:, PrinterPageInfos, % "Page details:`n" pageWr " x " pageHr " in`n" MMpageWr " x " MMpageHr " mm`n" pageDPI " DPI"
   }

   Gdip_DeleteGraphics(gPrint)
   trGdip_DisposeImage(pBitmap, 1)
   trGdip_DisposeImage(imgToPrint, 1)
}

AcquireWIAimage() {
    Static deviceu
    If (thumbsDisplaying=1)
       Return

    setImageLoading()
    prevOpenedWindow := []
    showTOOLtip("Acquiring image, please wait")
    prevOpenedWindow := [-1, A_ThisFunc, 1, editingSelectionNow, 0, userimgQuality]
    addJournalEntry("Window opened: " A_ThisFunc "() [ WIA standard dialogs ]")
    AnyWindowOpen := whileLoopExec := 1
    interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    interfaceThread.ahkassign("whileLoopExec", whileLoopExec)
    Try obju := WIA_AcquireImage(deviceu)
    Catch errMsg
       Sleep, 1

    AnyWindowOpen := whileLoopExec := 0
    interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    interfaceThread.ahkassign("whileLoopExec", whileLoopExec)
    WinSet, Enable,, ahk_id %PVhwnd%
    If IsObject(obju)
    {
       pBitmap := obju[1]
       If !deviceu
          deviceu := obju[2]
       ; ToolTip, % "l=" deviceu , , , 2
    }

    If (StrLen(pBitmap)<3 && (IsObject(obju) || StrLen(errMsg.message)>3))
    {
       ResetImgLoadStatus()
       ; showTOOLtip("Failed to acquire image`n" errMsg.message)
       RemoveTooltip()
       infos := SubStr(errMsg.message, 1, InStr(errMsg.message, "`nhelpfile:") - 1)
       infos := StrReplace(infos, "`t", A_Space)
       infos := StrReplace(infos, "  ", A_Space)
       msgBoxWrapper(appTitle ": ERROR", "An error has occured. Failed to acquire image from device.`n`nError details: " infos, 0, 0, "error")
       Return
    } Else If (obju<0 && !IsObject(obju))
    {
       RemoveTooltip()
       ResetImgLoadStatus()
    } Else
    {
       recordGdipBitmaps(pBitmap, A_ThisFunc)
       trGdip_GetImageDimensions(pBitmap, imgW, imgH)
       If (imgW<5 || imgH<5)
       {
          ResetImgLoadStatus()
          hbmp := trGdip_DisposeImage(pBitmap, 1)
          showTOOLtip("Failed to acquire the correct image data`nPossibly malformed image format.")
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
       SoundBeep , 900, 100
       PasteClipboardIMG("scanner", pBitmap)
    }
}

LoadWICscreenImage(imgPath, noBPPconv, frameu) {
   startZeit := A_TickCount
   VarSetCapacity(resultsArray, 8 * 6, 0)
   r := DllCall(whichMainDLL "\WICpreLoadImage", "Str", imgPath, "Int", frameu, "UPtr", &resultsArray, "UPtr")
   If r
   {
      Width := NumGet(resultsArray, 4 * 0, "uInt")
      Height := NumGet(resultsArray, 4 * 1, "uInt")
      Random, OutputVar, 1, 999999
      k := WicPixelFormats(NumGet(resultsArray, 4 * 3, "uInt"))
      mainLoadedIMGdetails := []
      mainLoadedIMGdetails.PixelFormat := k
      mainLoadedIMGdetails.Width := Width
      mainLoadedIMGdetails.Height := Height
      mainLoadedIMGdetails.ImgFile := imgPath
      mainLoadedIMGdetails.imgHandle := OutputVar
      mainLoadedIMGdetails.Frames := NumGet(resultsArray, 4 * 2, "uInt") - 1
      mainLoadedIMGdetails.ActiveFrame := NumGet(resultsArray, 4 * 6, "uInt")
      mainLoadedIMGdetails.DPI := NumGet(resultsArray, 4 * 4, "uInt")
      mainLoadedIMGdetails.RawFormat := WICcontainerFmts(NumGet(resultsArray, 4 * 5, "uInt"))
      mainLoadedIMGdetails.TooLargeGDI := 0
      mainLoadedIMGdetails.HasAlpha := varContains(k, "argb", "prgba", "bgra", "rgba", "alpha")
      mainLoadedIMGdetails.OpenedWith := "Windows Imaging Component [WIC]"
      mainLoadedIMGdetails.LoadedWith := "WIC"
      resultsArray := ""
      If isImgSizeTooLarge(Width, Height)
      {
         zx := mainLoadedIMGdetails.Clone()
         viewportQPVimage.LoadImage(imgPath, frameu, 0, 1, zx, 2)
         clrDepth := (mainLoadedIMGdetails.HasAlpha=1) ? 32 : 24
         teleportWICtoFIM(Width, Height, clrDepth)
         Return "very-large"
      }

      mustClip := 0
      newW := w := Width
      newH := h := Height
      mainLoadedIMGdetails.TooLargeGDI := isImgSizeTooLarge(Width, Height)
      pBitmap := DllCall(whichMainDLL "\WICgetRectImage", "Int", x, "Int", y, "Int", w, "Int", h, "Int", newW, "Int", newH, "Int", mustClip, "UPtr")
      If StrLen(pBitmap)>2
         recordGdipBitmaps(pBitmap, A_ThisFunc)

      ; ToolTip, % pBitmap "|" x "|" y "|" w "|" h "|" newW "|" newH , , , 2
      DllCall(whichMainDLL "\WICdestroyPreloadedImage", "Int", 12, "Int")
      zeitu := A_TickCount - startZeit
      Return pBitmap
   }
}

teleportWICtoFIM(imgW, imgH, bitsDepth) {
   If memoryUsageWarning(imgW, imgH, bitsDepth, 1)
      Return 0

   okay := 0
   ;  the stride is aligned to a multiple of 4 bytes (32 bits) for efficient memory access.
   Stride := (bitsDepth * imgW) / 8 ; (bitsDepth=32) ? imgW * 4 : imgW * 3
   bufferSize := Stride * imgH

   thisIndex := 0
   SliceHeight := imgH
   If (bufferSize>4010200100)
   {
      Loop
      {
         thisIndex := A_Index
         testBuffer := Stride * (imgH - thisIndex)
         If (testBuffer<4010200100)
            Break
      }
   }

   SliceHeight := imgH - thisIndex
   numberSlices := Ceil(imgH / SliceHeight)
   remainderHeight := mod(imgH, SliceHeight)
   ; ToolTip, % Stride "|" imgW "=" imgH "=buffer=" bufferSize "|" SliceHeight "|" numberSlices "|" remainderHeight  , , , 2
   If (numberSlices>1)
      buffer := DllCall(whichMainDLL "\WICgetLargeBufferImage", "Int", okay, "Int", bitsDepth, "int", Stride, "int", bufferSize, "Int", SliceHeight, "UPtr")
   Else
      buffer := DllCall(whichMainDLL "\WICgetBufferImage", "Int", okay, "Int", bitsDepth, "int", Stride, "int", bufferSize, "UPtr")

   If buffer
      hFIFimgA := FreeImage_ConvertFromRawBitsEx(0, buffer, 1, imgW, imgH, Stride, bitsDepth, "0x00FF0000", "0x0000FF00", "0x000000FF", 1)
   ; FreeImage_SetDPIresolution(hFIFimgA, dpiX, dpiY)
   If (hFIFimgA && buffer)
   {
      killQPVscreenImgSection()
      imgPath := viewportQPVimage.ImgFile
      frameu := viewportQPVimage.ActiveFrame
      tFrames := viewportQPVimage.Frames
      PixelFormat := viewportQPVimage.PixelFormat
      RawFormat := viewportQPVimage.RawFormat
      OpenedWith := viewportQPVimage.OpenedWith
      viewportQPVimage.DiscardImage()
      DllCall(whichMainDLL "\WICdestroyPreloadedImage", "Int", 1, "Int")
      viewportQPVimage.LoadImage(imgPath, frameu, 0, 1, [hFIFimgA, tFrames, buffer], 1)
      ; ToolTip, % "teleported=" hFIFimgA "|" zw "|" zh "|" bufferSize , , , 2
      viewportQPVimage.PixelFormat := PixelFormat
      viewportQPVimage.RawFormat := RawFormat
      viewportQPVimage.OpenedWith := OpenedWith
      Return 1
   }
   Return 0
}

LoadWICimage(imgPath, noBPPconv, frameu, sizesDesired:=0, ByRef newBitmap:=0) {
   startZeit := A_TickCount
   VarSetCapacity(resultsArray, 8 * 6, 0)
   If IsObject(sizesDesired[1])
   {
      w := sizesDesired[1, 1]
      h := sizesDesired[1, 2]
      keepAratio := sizesDesired[1, 3]
      ScaleAnySize := sizesDesired[1, 4]
      thisImgQuality := sizesDesired[1, 5]
      doFlipu := sizesDesired[1, 6]
      doGray := sizesDesired[1, 7]
      If (!w || !h)
         keepAratio := 2
   } else
   {
      doGray := doFlipu := w := h := ScaleAnySize := 0
      thisImgQuality := 5
      keepAratio := 2
   }

   ; fnOutputDebug("wic-load " imgPath)
   r := DllCall(whichMainDLL "\LoadWICimage", "Int", 0 ,"Int", noBPPconv, "Int", thisImgQuality, "Int", w, "Int", h, "int", keepAratio, "int", ScaleAnySize, "int", frameu, "int", doFlipu, "int", doGray, "Str", imgPath, "UPtr", &resultsArray, "Ptr")
   z := NumGet(resultsArray, 4 * 6, "uInt")
   If (r || z=1)
   {
      If StrLen(r)>2
         recordGdipBitmaps(r, A_ThisFunc)
      Else
         r := 1

      mainLoadedIMGdetails.Width := NumGet(resultsArray, 4 * 0, "uInt")
      mainLoadedIMGdetails.Height := NumGet(resultsArray, 4 * 1, "uInt")
      mainLoadedIMGdetails.Frames := NumGet(resultsArray, 4 * 2, "uInt") - 1
      k := mainLoadedIMGdetails.PixelFormat := WicPixelFormats(NumGet(resultsArray, 4 * 3, "uInt"))
      mainLoadedIMGdetails.DPI := NumGet(resultsArray, 4 * 4, "uInt")
      mainLoadedIMGdetails.RawFormat := WICcontainerFmts(NumGet(resultsArray, 4 * 5, "uInt"))
      mainLoadedIMGdetails.TooLargeGDI := isImgSizeTooLarge(mainLoadedIMGdetails.Width, mainLoadedIMGdetails.Height)
      mainLoadedIMGdetails.HasAlpha := varContains(k, "argb", "prgba", "bgra", "rgba", "alpha")
      mainLoadedIMGdetails.OpenedWith := "Windows Imaging Component [WIC]"

      ; fnOutputDebug("images desired = " sizesDesired.Count() " | f=" findFlippedDupes)
      If (sizesDesired.Count()>1 && r && noBPPconv=0)
      {
         newBitmap := []
         Loop, % sizesDesired.Count()
         {
            ; ToolTip, % mainLoadedIMGdetails.width "==" mainLoadedIMGdetails.height "|" z "==" W "=f" frameu "==s" ScaleAnySize "==k" keepAratio , , , 2
            w := sizesDesired[A_Index + 1, 1]
            h := sizesDesired[A_Index + 1, 2]
            keepAratio := sizesDesired[A_Index + 1, 3]
            ScaleAnySize := sizesDesired[A_Index + 1, 4]
            thisImgQuality := sizesDesired[A_Index + 1, 5]
            doFlipu := sizesDesired[A_Index + 1, 6]
            doGray := sizesDesired[A_Index + 1, 7]
            ; fnOutputDebug("loop image size=" A_Index " | " w "x" h " | " doFlipu)
            newBitmap[A_Index] := DllCall(whichMainDLL "\LoadWICimage", "Int", 0 ,"Int", noBPPconv, "Int", thisImgQuality, "Int", w, "Int", h, "int", keepAratio, "int", ScaleAnySize, "int", frameu, "int", doFlipu, "int", doGray, "Str", imgPath, "UPtr", &resultsArray, "Ptr")
         }
      }
   }

   resultsArray := ""
   zeitu := A_TickCount - startZeit
   ; msgbox, % r "==" zeitu " = " pixfmt "=" rawFmt
   ; ToolTip, % WICmoduleHasInit " | " r "==" zeitu " = " mainLoadedIMGdetails.pixfmt "=" mainGdipWinThumbsGrid.RawFormat , , , 3
   ; https://stackoverflow.com/questions/8101203/wicbitmapsource-copypixels-to-gdi-bitmap-scan0
   ; https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/Win7Samples/multimedia/wic/wicviewergdi/WicViewerGdi.cpp#L354
   Return r
}

WicPixelFormats(pixFmt) {
   Static wicPixFmts := {2:"1-bpp - Indexed", 3:"2-bpp - Indexed", 4:"4-bpp - Indexed", 5:"8-bpp - Indexed", 6:"BlackWhite", 7:"2-bpp - Gray", 8:"4-bpp - Gray", 9:"8-bpp - Gray", 10:"8-bpp - Alpha", 11:"16-bpp - BGR555", 12:"16-bpp - BGR565", 13:"16-bpp - BGRA5551", 14:"16-bpp - Gray", 15:"24-bpp - BGR", 16:"24-bpp - RGB", 17:"32-bpp - BGR", 18:"32-bpp - BGRA", 19:"32-bpp - PBGRA"
         , 20:"32-bpp - GrayFloat", 21:"32-bpp - RGB", 22:"32-bpp - RGBA", 23:"32-bpp - PRGBA", 24:"48-bpp - RGB", 25:"48-bpp - BGR", 26:"64-bpp - RGB", 27:"64-bpp - RGBA", 28:"64-bpp - BGRA", 29:"64-bpp - PRGBA", 30:"64-bpp - PBGRA", 31:"16-bpp - GrayFixedPoint", 32:"32-bpp - BGR101010", 33:"48-bpp - RGBFixedPoint", 34:"48-bpp - BGRFixedPoint", 35:"96-bpp - RGBFixedPoint"
         , 36:"96-bpp - RGBFloat", 37:"128-bpp - RGBAFloat", 38:"128-bpp - PRGBAFloat", 39:"128-bpp - RGBFloat", 40:"32-bpp - CMYK", 41:"64-bpp - RGBAFixedPoint", 42:"64-bpp - BGRAFixedPoint", 43:"64-bpp - RGBFixedPoint", 44:"128-bpp - RGBAFixedPoint", 45:"128-bpp - RGBFixedPoint", 46:"64-bpp - RGBAHalf", 47:"64-bpp - PRGBAHalf", 48:"64-bpp - RGBHalf", 49:"48-bpp - RGBHalf"
         , 50:"32-bpp - RGBE", 51:"16-bpp - GrayHalf", 52:"32-bpp - GrayFixedPoint", 53:"32-bpp - RGBA1010102", 54:"32-bpp - RGBA1010102XR", 55:"32-bpp - R10G10B10A2", 56:"32-bpp - R10G10B10A2HDR10", 57:"64-bpp - CMYK", 58:"24-bpp - 3 channels", 59:"32-bpp - 4 channels", 60:"40-bpp - 5 channels", 61:"48-bpp - 6 channels", 62:"56-bpp - 7 channels", 63:"64-bpp - 8 channels"
         , 64:"48-bpp - 3 channels", 65:"64-bpp - 4 channels", 66:"80-bpp - 5 channels", 67:"96-bpp - 6 channels", 68:"112-bpp - 7 channels", 69:"128-bpp - 8 channels", 70:"40-bpp - CMYKAlpha", 71:"80-bpp - CMYKAlpha", 72:"32-bpp - 3 channels alpha", 73:"40-bpp - 4 channels alpha", 74:"48-bpp - 5 channels alpha", 75:"56-bpp - 6 channels alpha", 76:"64-bpp - 7 channels alpha"
         , 77:"72-bpp - 8 channels alpha", 78:"64-bpp - 3 channels alpha", 79:"80-bpp - 4 channels alpha", 80:"96-bpp - 5 channels alpha", 81:"112-bpp - 6 channels alpha", 82:"128-bpp - 7 channels alpha", 83:"144-bpp - 8 channels alpha", 84:"8-bpp - Y", 85:"8-bpp - Cb", 86:"8-bpp - Cr", 87:"16-bpp - CbCr", 88:"16-bpp - Y-Quantized-DCT-Coeffs"
         , 89:"16-bpp - Cb-Quantized-DCT-Coeffs", 90:"16-bpp - Cr-Quantized-DCT-Coeffs"}

   r := wicPixFmts[pixFmt]
   If !r
      r := "UNKNOWN"
   Return r
}

WICcontainerFmts(containerID) {
   Static containerFmts := {1:"BMP",2:"PNG",3:"ICO",4:"JPEG",5:"TIFF",6:"GIF",7:"WMP",8:"DDS",9:"ADNG",10:"HEIF",11:"WEBP",12:"RAW"}
   r := containerFmts[containerID]
   If !r
      r := "UNKNOWN"
   Return r
}

xxtestwhatever() {

   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x2
ppIDecoder := "lodekl"
   destroyGDIfileCache()
   wzFileName := getIDimage(currentFileIndex)

   thisObj := ComObjCreate("{cacaf262-9370-4615-a13b-9f5539da4c0a}", "{ec5ec8a9-c395-4314-9c77-54d7a935ff70}")
      thisObj.ThrowHRerrors := 1

   ; hr := DllCall(NumGet(NumGet(thisObj+0)+14*A_PtrSize), "ptr", thisObj, "ptr*", ppIWICStream)
   ;    WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)


   ; hr := DllCall(NumGet(NumGet(thisObj+0)+15*A_PtrSize), "ptr", thisObj, "str", wzFileName, "uint", dwDesiredAccess)
   ; if hr or ErrorLevel
   ;    WIC_hr(hr, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)

/*
   hr := DllCall(vtable(thisObj, 3)
         ,"ptr", thisObj
         ,"str", wzFilename
         ,"ptr", NULL ; WIC_GUID(GUID,pguidVendor)
         ,"uint", dwDesiredAccess
         ,"uint", metadataOptions
         ,"ptr*", ppIDecoder)
      WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)
   MsgBox, % thisObj "`n" ppIDecoder "`n" vtable(thisObj, 3) ;  "`n" WIC_hr(HR, "init")
*/
}


gtestwhatever() {
; # dwDesiredAccess
; WIC_GENERIC_READ = 0x80000000
; WIC_GENERIC_WRITE = 0x40000000

; # WICBitmapCreateCacheOption
; WICBitmapNoCache = 0x0
; WICBitmapCacheOnDemand = 0x1
; WICBitmapCacheOnLoad = 0x2

; # WICDecodeOptions
; WICDecodeMetadataCacheOnDemand = 0x0
; WICDecodeMetadataCacheOnLoad = 0x1


   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x1

   destroyGDIfileCache()
   imgPath := getIDimage(currentFileIndex)
   DllCall("windowscodecs.dll\WICCreateImagingFactory_Proxy", "Uint", WinCodecSKDversion, "UPtr*", pWICimgFactory)

   HR := DllCall("windowscodecs.dll\IWICImagingFactory_CreateDecoderFromFilename_Proxy", "UPtr", pWICimgFactory, "Wstr", imgPath, "Ptr", GuidVendor, "Uint", dwDesiredAccess, "Uint", metadataOptions, "UPtr*", ppIDecoder)
   MsgBox, % pWICimgFactory "`n" ppIDecoder
}

recentOpenedFolders() {
   If (allowRecordHistory=1)
   {
      historyList := readRecentEntries()
      historyList .= readRecentFileDesties()
      Loop, Parse, historyList, `n
      {
         If (A_Index>30)
            Break

         entryu := StrReplace(A_LoopField, "|")
         If (!entryu || RegExMatch(entryu, sldsPattern))
            Continue

         If FolderExist(entryu)
            entriesList .= entryu "`n"
      }
      Sort, entriesList, UD`n
   }
   Return Trimmer(entriesList)
}

testeGDIspeed() {
   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(2)
   pa := A_TickCount - startZeit

   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(10)

   pb := A_TickCount - startZeit
   MsgBox, % pa "`n" pb
}

isFileLocked(imgPath) {
   If !FileRexists(imgPath, 0)
      Return -1

   myFile := fileOpen(imgPath, "a")
   If IsObject(myFile)
   {
      myFile.Close()
      Return 0
   } Else Return 1
}

trGdip_CreateBitmap(funcu, Width, Height, PixelFormat:=0, Stride:=0, Scan0:=0) {
    ; PixelFormat := (PixelFormat="0xE200B") ? coreDesiredPixFmt : PixelFormat
    r := Gdip_CreateBitmap(Width, Height, PixelFormat, Stride, Scan0)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() called by " funcu "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0))

    If StrLen(r)>2
       recordGdipBitmaps(r, A_ThisFunc "<-" funcu)
    Else
       addJournalEntry(A_ThisFunc "() called by " funcu "() using w" Width " - h" Height " - pixFmt" PixelFormat " failed: " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

recordGdipBitmaps(r, infoz, typu:="bmp") {
   If validBMP(r)
      addJournalEntry("ERROR: recorded a new bitmap ID that was not discarded. WTF? OLD=" createdGDIobjsArray["x" r, 4] ". NEW=" infoz)

   If StrLen(r)>2
      createdGDIobjsArray["x" r] := [r, typu, 1, infoz "|" AnyWindowOpen "|"]

   ; ppp := 0 ; useful to identify memory leaks related to bitmap objects
   ; For Key, Value in createdGDIobjsArray
   ; {
   ;    If Value[3]
   ;       ppp++
   ; }
   ; ToolTip, % "l=" ppp , , , 2
}

trGdip_CreateBitmapFromFile(funcu, sFile, useICM:=0) {
    r := Gdip_CreateBitmapFromFileSimplified(sFile, useICM)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If StrLen(r)>2
       recordGdipBitmaps(r, A_ThisFunc "<-" funcu)
    Else
       addJournalEntry(A_ThisFunc "() error: " Gdip_ErrorHandler(gdipLastError, 0) "`nFile to load:" sFile)

    Return r
}

trGdip_CreateBitmapFromHBITMAP(funcu, hBitmap, hPalette:=0) {
    r := Gdip_CreateBitmapFromHBITMAP(hBitmap, hPalette)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0) ". Function invoked by " funcu "().")

    If StrLen(r)>2
       recordGdipBitmaps(r, A_ThisFunc "<-" funcu)
    Else
       addJournalEntry(A_ThisFunc "() failed, hBitmap = " hBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateHBITMAPFromBitmap(funcu, pBitmap, bgr:=0) {
    r := Gdip_CreateHBITMAPFromBitmap(pBitmap, bgr)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If !r
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateARGBBitmapFromHBITMAP(hBitmap) {
    r := Gdip_CreateARGBBitmapFromHBITMAP(hBitmap)
    If StrLen(r)>2
       recordGdipBitmaps(r, A_ThisFunc)
    Else
       addJournalEntry(A_ThisFunc "() failed to create pBitmap from hBitmap = " hBitmap)

    Return r
}

trGdip_BitmapConvertGray(funcu, pBitmap, hue:=0, vibrance:=-40, brightness:=1, contrast:=0, KeepPixelFormat:=-1) {
    If !validBMP(pBitmap)
    {
       addJournalEntry(A_ThisFunc "(): ERROR. Invalid bitmap to process, function invoked by " funcu "(). pBitmap = " pBitmap)
       Return
    }

    r := Gdip_BitmapConvertGray(pBitmap, hue, vibrance, brightness, contrast, KeepPixelFormat)
    If StrLen(r)>2
       recordGdipBitmaps(r, A_ThisFunc "<-" funcu)
    Else
       addJournalEntry(A_ThisFunc "(): failed to process pBitmap=" pBitmap)
    Return r
}

trGdip_CloneBitmapArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:="0xE200B", KeepPixelFormat:=0) {
    If !validBMP(pBitmap)
    {
       addJournalEntry(A_ThisFunc "(): ERROR. Invalid bitmap to clone, function invoked by " funcu "(). pBitmap = " pBitmap)
       Return
    }

    k := createdGDIobjsArray["x" pBitmap, 4]
    fnOutputDebug("Clone BitmapArea: " k ". ID: " pBitmap ". Invoker: " funcu)
    ; If (PixelFormat="0xE200B" && userimgQuality=0)
    ;    PixelFormat := "0x26200A"

    r := Gdip_CloneBitmapArea(pBitmap, x, y, w, h, PixelFormat, KeepPixelFormat)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If StrLen(r)>2
       recordGdipBitmaps(r, A_ThisFunc "<-" funcu " {" k "}")
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CloneBitmap(funcu, pBitmap, forceIT:=0) {
    If (!validBMP(pBitmap) && forceIT=0)
    {
       addJournalEntry(A_ThisFunc "(): ERROR. Invalid bitmap to clone, function invoked by " funcu "(). pBitmap = " pBitmap)
       Return
    }

    k := createdGDIobjsArray["x" pBitmap, 4]
    fnOutputDebug("BMP to clone: " k ". ID: " pBitmap ". Cloner invoked by: " funcu)
    r := Gdip_CloneBitmap(pBitmap)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If StrLen(r)>2
       recordGdipBitmaps(r, A_ThisFunc "<-" funcu " {" k "}")
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_BlurBitmap(pBitmap, BlurAmount, usePARGB:=0, quality:=7) {
    If !validBMP(pBitmap)
    {
       addJournalEntry(A_ThisFunc "(). ERROR: invalid bitmap given to blur")
       Return
    }

    r := Gdip_BlurBitmap(pBitmap, BlurAmount, usePARGB, quality)
    If StrLen(r)>2
       recordGdipBitmaps(r, A_ThisFunc)
    Else
       addJournalEntry(A_ThisFunc "() failed, pBitmap = " pBitmap)
    Return r
}

QPV_ViewportResizeBitmap(pBitmap, givenW, givenH, InterpolationMode) {
   Static iScan, iData, iStride

    If !validBMP(pBitmap)
    {
       addJournalEntry(A_ThisFunc "(): ERROR. Invalid bitmap to resize, function invoked by " funcu "(). pBitmap = " pBitmap)
       Return
    }

    thisPixFmt := (KeepPixelFormat=-1) ? coreDesiredPixFmt : KeepPixelFormat
    ; fnOutputDebug(A_ThisFunc "(" pBitmap "):" givenW "|" givenH "|" funcu)
    k := createdGDIobjsArray["x" pBitmap, 4]


    If (!pBitmap || !givenW || !givenH)
       Return

    Gdip_GetImageDimensions(pBitmap, w, h)
    If (KeepRatio=1)
    {
       calcIMGdimensions(w, h, givenW, givenH, rw, rh)
    } Else
    {
       rw := givenW
       rh := givenH
    }
  initQPVmainDLL()
     startOperation := A_TickCount
  newBitmap := trGdip_CreateBitmap(A_ThisFunc, rw, rh)

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, iStride, iScan, iData, 1, "0xE200B")
  E2 := Gdip_LockBits(newBitmap, 0, 0, rw, rh, mStride, mScan, mData, 3, "0xE200B")
ToolTip, % A_TickCount - startOperation , , , 2
  If (!E1 && !E2)
     ; r := DllCall(whichMainDLL "\STBresizeBitmap", "UPtr", iScan, "Int", w, "Int", h, "Int", iStride, "UPtr", mScan, "int", rw, "Int", rh, "Int", mStride)
  r := FreeImage_RescaleRawBits(iScan, mScan, 1, w, h, iStride, mStride, 32, rw, rh, 1)



  ; fnOutputDebug(A_ThisFunc "() " A_LastError " r=" r "=" func2exec "=" A_TickCount - thisStartZeit "|" blendMode)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(newBitmap, mData)

    Return newBitmap
}

trGdip_ResizeBitmap(funcu, pBitmap, givenW, givenH, KeepRatio, InterpolationMode:="", KeepPixelFormat:=0, checkTooLarge:=0) {
    If !validBMP(pBitmap)
    {
       addJournalEntry(A_ThisFunc "(): ERROR. Invalid bitmap to resize, function invoked by " funcu "(). pBitmap = " pBitmap)
       Return
    }

    thisPixFmt := (KeepPixelFormat=-1) ? coreDesiredPixFmt : KeepPixelFormat
    ; fnOutputDebug(A_ThisFunc "(" pBitmap "):" givenW "|" givenH "|" funcu)
    k := createdGDIobjsArray["x" pBitmap, 4]
    r := Gdip_ResizeBitmap(pBitmap, givenW, givenH, KeepRatio, InterpolationMode, thisPixFmt, checkTooLarge)
    If StrLen(r)<3
    {
       If (checkTooLarge!=1)
       {
          baseMsg := "Unable to resize internal bitmap to given size: W" givenW " - H" givenH " for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error. Details: " k
          generalInternalErrorMsgBox(gdipLastError, baseMsg)
       } else
          addJournalEntry("ERROR: Unable to resize internal bitmap to given size: W" givenW " - H" givenH " for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error. Details: " k)
       Return
    } Else
       recordGdipBitmaps(r, A_ThisFunc "<-" funcu " {" k "}")

    Return r
}

trGdip_RotateBitmapAtCenter(funcu, pBitmap, Angle, pBrush:=0, InterpolationMode:=7, PixelFormat:=0,snapRotation:=0) {
    If !validBMP(pBitmap)
    {
       addJournalEntry(A_ThisFunc "(): ERROR. Invalid bitmap to rotate, function invoked by " funcu "(). pBitmap = " pBitmap)
       Return
    }

    If (snapRotation=1)
    {
       zrr := 0
       If isInRange(Angle, 89, 91)
       {
          zrr := 1
          Gdip_ImageRotateFlip(pBitmap, 1)
       } Else If isInRange(Angle, 179, 181)
       {
          zrr := 1
          Gdip_ImageRotateFlip(pBitmap, 2)
       } Else If isInRange(Angle, 269, 271)
       {
          zrr := 1
          Gdip_ImageRotateFlip(pBitmap, 3)
       } Else If (isInRange(Angle, 359, 361) || isInRange(Angle, -1, 1))
       {
          zrr := 1
          Sleep, 1
       }

       If (zrr=1)
          Return "ok"
    }

    If !Angle
    {
       newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc "() initially invoked by " funcu "()", pBitmap)
       Return newBitmap
    }

    thisPixFmt := (PixelFormat=-1) ? coreDesiredPixFmt : PixelFormat
    k := createdGDIobjsArray["x" pBitmap, 4]
    r := Gdip_RotateBitmapAtCenter(pBitmap, Angle, pBrush, InterpolationMode, thisPixFmt)
    If StrLen(r)<3
    {
       baseMsg := "Unable to rotate internal bitmap to given angle: " angle "° for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error. Details: " k
       generalInternalErrorMsgBox(gdipLastError, baseMsg)
       Return
    } Else
       recordGdipBitmaps(r, A_ThisFunc "<-" funcu " {" k "}")

    Return r
}

trGdip_GetImageDimensions(pBitmap, ByRef W, ByRef H) {
   If (viewportQPVimage.imgHandle && pBitmap=gdiBitmap)
   {
      w := viewportQPVimage.Width
      h := viewportQPVimage.Height
   } Else If validBMP(pBitmap)
      r := Gdip_GetImageDimensions(pBitmap, W, H)
   ; Else
   ;    addJournalEntry(A_ThisFunc "(): error - invalid bitmap")
   Return r
}

trGdip_DisposeImage(pBitmap, noErr:=1) {
    If StrLen(pBitmap)<2
       Return

    If !validBMP(pBitmap)
    {
       ; fnOutputDebug("ERROR: invalid bitmap handle to dispose: " createdGDIobjsArray["x" pBitmap, 4] ". ID: " pBitmap)
       Return
    }

    If (pBitmap=gdiBitmap)
       viewportQPVimage.DiscardImage()

    ; fnOutputDebug("BMP to dispose: " createdGDIobjsArray["x" pBitmap, 4] ". ID: " pBitmap)
    ; If (createdGDIobjsArray["x" pBitmap, 3]=1 && createdGDIobjsArray["x" pBitmap, 2]="bmp")
    r := Gdip_DisposeImage(pBitmap, 1)
    createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 0, 0]
    Return r
}

validBMP(pBitmap) {
    Return createdGDIobjsArray["x" pBitmap, 3]
}

gdipObjectsStats(filteru:=0) {
   Critical, on
   UnremovedBMPs := discarded := 0
   For Key, Value in createdGDIobjsArray
   {
      If (value[2]="bmp")
      {
         totalBMPs++
         If (value[3]=1)
         {
            If (!InStr(value[4], filteru) && filteru)
            {
               UnremovedBMPs++
               Continue
            }

            If (InStr(value[4], "tlbrSetImageIcon") || userAlphaMaskBmpPainted=value[1] || thisBMPdummy=value[1])
            {
               UnremovedBMPs++
               Continue
            }

            If (!filteru && !InStr(value[4], "QPV_ShowThumbnails"))
               addJournalEntry("ERROR: Possible memory leak: " value[4])

            trGdip_DisposeImage(value[1], 1)
            discarded++
         }
      }
   }

   If (!filteru || filteru="QPV_ShowThumbnails")
   {
      imgThumbsCacheArray := []
      imgThumbsCacheIDsArray := []
      imgsListArrayThumbs := []
   }

   ; If (killAll!=1)
   ;    msgbox, % totalBMPs " // " UnremovedBMPs
}

giveWarningX64() {
   SoundBeep, 300, 100
   msgResult := msgBoxWrapper(appTitle ": WARNING", "You are currently running a 64-bits operating system, but you are executing " appTitle " developed for 32-bits operating systems. Please exit and run the 64-bits edition of QPV, for an optimal experience. The 32-bits edition is severely limited and prone to crash at any moment.`n`nThank you for your inevitable cooperation.", "&Yes|&Exit|&Ask later|Continue...", 1, "error")
   If InStr(msgResult, "Continue")
   {
      SoundBeep , 300, 900
      msgResult := msgBoxWrapper(appTitle ": WARNING", "Some Pandas are weeping now... enjoy!", "&Whatever|&Exit", 1, "error")
      If InStr(msgResult, "exit")
      {
         exitAppu()
      } Else
      {
         showTOOLtip("Oh, you are so naughty!")
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }
   } Else If InStr(msgResult, "ask")
      SetTimer, giveWarningX64, -29100
   Else
      exitAppu()
}

checkDLLfiles() {
   Static lastInvoked := 0
   If (lastInvoked>1)
      Return

   lastInvoked++
   DllPathA := FreeImage_FoxGetDllPath("freeimage.dll", mainExecPath)
   If !FileExist(DllPathA)
      freeIMGmissin := 1
   
   DllPathB := FreeImage_FoxGetDllPath("sqlite3.dll", mainExecPath)
   If !FileExist(DllPathB)
      sqlMissin := 1

   If (sqlMissin=1 || freeIMGmissin=1)
      msgResult := msgBoxWrapper(appTitle ": ERROR", "It seems " appTitle " DLL files are missing. Some features of the application will not work. Please download the QPV portable ZIP package.", "&Download|&Cancel", 1, "ERROR")

   If (msgResult="Download")
      Try Run, https://github.com/marius-sucan/Quick-Picto-Viewer
}

tlbrAddNewIcon(obju, wi, he, IconSpacing, noSpacing, simpleRefresh) {
    Global
    Static indexBtn := 1, pickoBeat := 0
    If (obju[5]="BTNdisabled" && TLBRtwoColumns=0)
       Return

    indexBtn++
    icoFile := obju[1]
    btnType := obju[2]
    actu2 := obju[4]
    btnID := obju[5]
    paramu := obju[6]
    menuMode := obju[7]
    btnName := obju[3]
    If (TLBRtwoColumns=1 && !isWelcomeScreenu)
    {
       otherz := (pickoBeat=0) ? "xs y+" IconSpacing " " : "x+" IconSpacing " yp"
       If (indexBtn=1)
          otherz := "xm+" IconSpacing " y+" IconSpacing " Section"
    } Else otherz := (TLBRverticalAlign=1) ? "xm+" IconSpacing " y+" IconSpacing : "x+" IconSpacing " y" IconSpacing

    If (noSpacing=1)
    {
       indexBtn := 1
       pickoBeat := 1
       otherz := "x0 y0"
    }

    pickoBeat := !pickoBeat
    If (simpleRefresh=1)
    {
       hwndul := tlbrIconzList[indexBtn, 1]
       If (icoFile!=tlbrIconzList[indexBtn, 2])
          tlbrSetImageIcon(icoFile, hwndul, wi, he)
    } Else
    {
       Gui, OSDguiToolbar: Add, Button, w%wi% h%he% %otherz% vtlbrValueIcon%IndexBtn% +hwndhwndul gtlbrInvokeFunction +0x8000, % btnID ; Windows Narrator friendly buttons 
       ; Gui, OSDguiToolbar: Add, Text,  w%wi% h%he% %otherz% BackgroundTrans +0xE +0x200 vtlbrValueIcon%IndexBtn% +hwndhwndul gtlbrInvokeFunction, icon%IndexBtn% ; Windows Narrator friendly buttons 
       tlbrSetImageIcon(icoFile, hwndul, wi, he)
    }

    tlbrIconzList["counter"] := tlbrIconzList["counter"] + 1
    ; Gui, OSDguiToolbar: Add, Text,  h%he% w%wi% %otherz% BackgroundTrans +0x1000 +0xE, %btnName% ; Windows Narrator friendly buttons 
    ; Gui, OSDguiToolbar: Add, Picture, vtlbrValueIcon%IndexBtn% AltSubmit  +hwndhwndul xp yp hp wp gtlbrInvokeFunction, %mainCompiledPath%\resources\toolbar\%icoFile%.png
    tlbrIconzList[IndexBtn] := [hwndul, icoFile, btnName, btnType, indexBtn, actu2, wi, he, paramu, btnID, menuMode]
    tlbrIconzList[hwndul] := [hwndul, icoFile, btnName, btnType, indexBtn, actu2, wi, he, paramu, btnID, menuMode]
    tlbrIconzList[btnID] := [hwndul, icoFile, btnName, btnType, indexBtn, actu2, wi, he, paramu, btnID, menuMode]
}

tlbrSetImageIcon(icoFile, hwnd, W, H) {
    Static cachedIcos := []
    If (icoFile="kill" && hwnd="kill")
    {
       For Key, Value in cachedIcos
       {
          If (j := cachedIcos[Key, 1])
             trGdip_DisposeImage(j, 1)

          cachedIcos[Key] := [0, 0]
       }
       Return
    }
 
    If (icoFile="colorz-swatch")
    {
       zpBitmap := trGdip_CreateBitmap(A_ThisFunc, 512, 512)
       Gu := Gdip_GraphicsFromImage(zpBitmap)
       ; Gdip_GraphicsClear(Gu, "0xFF" ToolbarBgrColor)
       posYu := (TLBRverticalAlign!=1) ? 55 : 33
       If (thumbsDisplaying!=1)
       {
          BrushA := (BrushToolUseSecondaryColor=1) ? Gdip_BrushCreateSolid("0xFF" BrushToolBcolor) : Gdip_BrushCreateSolid("0xFF" BrushToolAcolor)
          BrushB := (BrushToolUseSecondaryColor=1) ? Gdip_BrushCreateSolid("0xFF" BrushToolAcolor) : Gdip_BrushCreateSolid("0xFF" BrushToolBcolor)
          pPenB := Gdip_CreatePen("0xFF101010", 25)
          pPenA := Gdip_CreatePen("0xFFffFFff", 10)
          Gdip_FillEllipse(Gu, BrushB, 412//2, posYu, 412//2, 400)
          Gdip_DrawEllipse(Gu, pPenB, 412//2, posYu, 412//2, 400)
          Gdip_FillEllipse(Gu, BrushA, 80, posYu, 412//2, 400)
          Gdip_DrawEllipse(Gu, pPenB, 80, posYu, 412//2, 400)
          Gdip_DrawEllipse(Gu, pPenA, 80, posYu, 412//2, 400)
          Gdip_DeleteBrush(BrushA)
          Gdip_DeleteBrush(BrushB)
          Gdip_DeletePen(pPenB)
       } Else
       {
          pPenA := Gdip_CreatePen("0xFF888888", 12)
          Gdip_DrawEllipse(Gu, pPenA, 412//2, posYu, 412//2, 400)
          Gdip_DrawEllipse(Gu, pPenA, 80, posYu, 412//2, 400)
       }

       Gdip_DeletePen(pPenA)
       Gdip_DeleteGraphics(Gu)
       icoBMP := trGdip_ResizeBitmap(A_ThisFunc, zpBitmap, w, h, 0, 3, -1, 0)
       trGdip_DisposeImage(zpBitmap, 1)
       z := "PBMP:" icoBMP
       mustDispose := 1
    } Else
    {
       k := "a" w h
       icoFile := Format("{:L}", icoFile)
       If (cachedIcos[icoFile, 2]=k && validBMP(cachedIcos[icoFile, 1]))
       {
          z := "PBMP:" cachedIcos[icoFile, 1]
       } Else
       {
          If (j := cachedIcos[icoFile, 1])
          {
             cachedIcos[icoFile] := [0, 0]
             trGdip_DisposeImage(j, 1)
          }
          ; ToolTip, % icofile , , , 2 
          pBitmap := trGdip_CreateBitmapFromFile(A_ThisFunc, mainExecPath "\resources\toolbar\" icoFile ".png")
          icoBMP := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, w, h, 0, 3, -1, 0)
          cachedIcos[icoFile] := [icoBMP, k]
          trGdip_DisposeImage(pBitmap, 1)
          z := "PBMP:" icoBMP
       }
    }

    Static lastClr := 0, b, c, d
    If (lastClr!=ToolbarBgrColor)
    {
       lastClr := ToolbarBgrColor
       b := MixRGBcolrs(ToolbarBgrColor, "FFffFF", 0.7)
       c := MixRGBcolrs(ToolbarBgrColor, "FFffFF", 0.6)
       d := MixRGBcolrs(ToolbarBgrColor, "000000", 0.7)
    }

    d1 := [0, "0xFF" ToolbarBgrColor,"0xFF" ToolbarBgrColor,,,,, 0, 1, z] ; normal
    d2 := [0, "0xFF" b,"0xFF" b,,,,, 0, 1, z] ; hover
    d3 := [0, "0xFF" d,"0xFF" d,,,,, 0, 1, z] ; clicked
    d4 := [0, "0xFF" ToolbarBgrColor,"0xFF" ToolbarBgrColor,,,,, 0, 1, z] ; disabled
    d5 := [0, "0xFF" c,"0xFF" c,,,,, 0, 1, z] ; active/focused
    r := ImageButton.Create(hwnd, d1, d2, d3, d4, d5)
    If (r!="")
       trackImageListButtons("record", r)

    If mustDispose
       trGdip_DisposeImage(icoBMP, 1)
}

tlbrInvokeFunction(a, b, c) {
   Static lastInvoked := 1

   mouseTurnOFFtooltip()
   If (AnyWindowOpen && imgEditPanelOpened!=1 || runningLongOperation=1 || imageLoading=1 || slideShowRunning=1 || openingPanelNow=1)
   || (A_TickCount - lastOtherWinClose<400) || (A_TickCount - lastZeitOpenWin<400) || (A_TickCount - lastInvoked<50)
      Return

   If (soloSliderWinVisible=1)
   {
      destroySoloSliderWidget()
      Return
   }

   lastInvoked := A_TickCount
   hwnd := (c="kbd" || b="n") ? a : Format("0x{1:x}", a)
   btnID := tlbrIconzList[hwnd, 10]
   ; ToolTip, % a "|" b "|" c "|" btnID , , , 2
   If (b="Normal" && c=0 && tlbrIconzList[hwnd, 4]=1)
      Return

   If (c!="kbd")
   {
      GetMouseCoord2wind(hQPVtoolbar, nX, nY)
      If (nX<2 || nY<2) ; prevent accidental clicks
         Return
   }

   SetTimer, drawWelcomeImg, Off
   If (c!="kbd")
      deactivateTlbrKbdMode()

   func2Call := processToolbarFunctions(btnID, b)
   ; ToolTip, % z "=" a "=" b "=" c "=" func2Call , , , 2
   WinGetPos, aX, aY,,, ahk_id %hwnd%
   ; interfaceThread.ahkFunction("ShowClickHalo", aX, aY, ToolBarBtnWidth, ToolBarBtnWidth, 1)
   globalMenuOptions := !tlbrIconzList[hwnd, 12] ? "tlbrMenu|" aX "|" aY + ToolBarBtnWidth : 0
   ; ToolTip, % globalMenuOptions , , , 2
   lastTlbrClicked := hwnd
   If IsFunc(func2Call[1])
   {
      fn := func2Call[1]
      addJournalEntry("Toolbar action executed: " tlbrIconzList[hwnd, 3] " | " fn "(). Parameters: " func2Call.Count() - 1)
      If (func2Call.Count()=1)
         z := %fn%()
      Else If (func2Call.Count()=2)
         z := %fn%(func2Call[2])
      Else If (func2Call.Count()=3)
         z := %fn%(func2Call[2], func2Call[3])
      Else If (func2Call.Count()=4)
         z := %fn%(func2Call[2], func2Call[3], func2Call[4])
      Else
         r := 1
   } Else If (StrLen(func2Call[1])>1)
      r := func2Call[1]

   If (r=1)
      simpleMsgBoxWrapper(appTitle ": ERROR", "An error occured calling " fn "() for " btnID ". Too many parameters.")
   Else If r
      simpleMsgBoxWrapper(appTitle ": ERROR", "An error occured calling " r "() function for " btnID ".")

   lastInvoked := A_TickCount
   MouseGetPos, OutputVarX, OutputVarY, OutputVarWin, OutputVarControl, 2
   If ((InStr(b, "right") || OutputVarWin!=hQPVtoolbar) && c!="kbd")
      decideWinReactivation()
}

Button_BM_SETSTATE(hwnd, mode) {
   DllCall("user32\SendMessage", "UPtr", hwnd, "UInt", 0x00F3, "UInt", mode, "Ptr", 0)    ; BM_SETSTATE
}

OnLButtonDblClk(wParam, lParam, msg, hwnd) {
; function by Lexikos; work-around for double-click on Gui Picture Controls
; from https://autohotkey.com/board/topic/94962-doubleclick-on-gui-pictures-puts-their-path-in-your-clipboard/
    Critical, On
    WinGetClass, WinClass, ahk_id %hwnd%
    ; ToolTip, % WinClass , , , 2
    If (WinClass="Static")
    {
       If !A_Gui
          Return 0  ; Just prevent Clipboard change.
       ; Send a WM_COMMAND message to the Gui to trigger the control's g-label.
       Gui, +LastFound
       gID := DllCall("GetDlgCtrlID", "ptr", hwnd) ; Requires AutoHotkey v1.1.
       Static STN_DBLCLK := 1
       PostMessage, 0x111, gID | (STN_DBLCLK << 16), hwnd
       ; Return a value to prevent the default handling of this message.
       Return 0
    } Else If (InStr(WinClass, "systabcontrol") && panelWinCollapsed!=1 && imgEditPanelOpened=1 && AnyWindowOpen) ; || (WinClass="autohotkeygui") || WinClass="#32770")
    {
       If (WinActive("A")=hSetWinGui)
          SetTimer, toggleImgEditPanelWindow, -50
       Return 0
    }
}

isImgEditingNow() {
   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   infoImgEditingNow := (validBMP(whichBitmap) && imgPath && thumbsDisplaying!=1) ? 1 : 0
   ; ToolTip, % whichBitmap "`n" imgPath "`n" thumbsDisplaying " | " maxFilesIndex "`n" CurrentSLD , , , 2
   Return infoImgEditingNow
}

OSDguiToolbarGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
   If isRightClick
      tlbrInvokeFunction(CtrlHwnd, "Right", 1)
}

MenuGoPlaySlidesNow() {
   lastOtherWinClose := 1
   If (thumbsDisplaying=1)
      ToggleThumbsMode()
 
   SetTimer, dummyInfoToggleSlideShowu, -250
}

tlbrActColorsSwatch() {
   If preventColorChange()
      Return

   hwnd := tlbrIconzList["BTNcolorsSwatch", 1]
   GetMouseCoord2wind(Format("0x{1:x}", hwnd), nX, nY)
   wi := tlbrIconzList["BTNcolorsSwatch", 7]
   ; ToolTip, % hwnd "|" nX "|" wi , , , 2
   If (nX>wi/1.7)
   {
      BtnToggleBrushColors("infoz", "no-leds")
      Return
   }

   oldColor := (BrushToolUseSecondaryColor=1) ? BrushToolBcolor : BrushToolAcolor
   oldClrName := (BrushToolUseSecondaryColor=1) ? "BrushToolBcolor" : "BrushToolAcolor"
   whichWin := (AnyWindowOpen && panelWinCollapsed!=1) ? hSetWinGui : PVhwnd
   newColor := createStandardColorzDialog(oldColor, whichWin, oldClrName)
   If (newColor="-")
      Return

   If (BrushToolUseSecondaryColor=1)
      BrushToolBcolor := newColor
   Else 
      BrushToolAcolor := newColor

   updateToolColorsBasedToolbar(newColor, oldColor, oldClrName)
   updateTlbrColorsSwatch()
   delayedWriteTlbrColors(1)
   If (imgEditPanelOpened=1 && AnyWindowOpen && isImgEditingNow()=1)
      livePreviewsImageEditing()
}

updateToolColorsBasedToolbar(newColor, oldColor, ctrlName) {
    If (imgEditPanelOpened!=1 || isImgEditingNow()!=1)
       Return

    If (isVarEqualTo(AnyWindowOpen, 64, 24, 31) || isNowAlphaPainting())
    {
       updateColoredRectCtrl(newColor, ctrlName)
    } Else If (AnyWindowOpen=66)
    {
       FloodFillColor := newColor
       updateColoredRectCtrl(newColor, "FloodFillColor")
    } Else If (AnyWindowOpen=68)
    {
       FillBehindColor := newColor
       updateColoredRectCtrl(newColor, "FillBehindColor")
    } Else If (AnyWindowOpen=23)
    {
       If (oldColor=FillArea2ndColor)
       {
          FillArea2ndColor := newColor
          updateColoredRectCtrl(newColor, "FillArea2ndColor")
       } Else
       {
          FillAreaColor := newColor
          updateColoredRectCtrl(newColor, "FillAreaColor")
       }
    } Else If (AnyWindowOpen=30 || AnyWindowOpen=65)
    {
       updateColoredRectCtrl(newColor, "DrawLineAreaColor")
       DrawLineAreaColor := newColor
    } Else If (AnyWindowOpen=32)
    {
       If (oldColor=TextInAreaBgrColor)
       {
          TextInAreaBgrColor := newColor
          updateColoredRectCtrl(newColor, "TextInAreaBgrColor")
       } Else
       {
          TextInAreaFontColor := newColor
          updateColoredRectCtrl(newColor, "TextInAreaFontColor")
       }
    }
}

tlbrChangeBrushWet(dir) {
   togglePresetsBrushes(3, dir)
}

coreTlbrSlider(thisFunc, delayu, invertDir) {
   GetPhysicalCursorPos(oX, oY)
   cX := cY := lastIndex := thisIndex := lastInvoked := 0
   setWhileLoopExec(1)
   lastInvoked := A_TickCount
   lastZeit := A_TickCount
   While, (determineLClickState()=1 || A_Index=1)
   {
      GetPhysicalCursorPos(mX, mY)
      dir := (oY<mY) ? -1 : 1
      If (delayu="brushSize")
      {
         delayu := (brushToolSize<100) ? 100 : 50
         If (brushToolSize<50)
            delayu := 150
         Else If (brushToolSize<25)
            delayu := 200
      }

      If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
      {
         If !isInRange(thisIndex, lastIndex - 2, lastIndex + 2)
         || (A_TickCount - lastInvoked>100 + delayu)
         {
            lastZeit := A_TickCount
            lastIndex := thisIndex
            MouseMove, % oX, % oY, 1
         }
         cX := mX, cY := mY
         Continue
      }

      Sleep, % delayu
      If (invertDir=1)
         dir *= -1

      lastInvoked := A_TickCount
      cX := mX, cY := mY
      If (A_TickCount - lastZeit>150 || A_Index=1)
         %thisFunc%(dir)
      thisIndex++
   }
   setWhileLoopExec(0)
}

tlbrChangeStuffRotation(modus) {
   oVPselRotation := VPselRotation
   ovpIMGrotation := vpIMGrotation
   If (GetKeyState("Ctrl", "P") && thumbsDisplaying!=1 && isImgEditingNow())
   {
      checku := (editingSelectionNow=1) ? "&Set the rotation angle for the selection area" : ""
      msgResult := msgBoxWrapper("Set rotation angle: " appTitle, "Please type the new angle for the rotation of the image in the viewport, from 0° to 360°.", "&Apply|C&ancel", 1, "settings", checku, 0, 0, "limit9050", Round(vpIMGrotation, 2))
      If InStr(msgResult.btn, "apply")
      {
         zl := Trimmer(msgResult.edit)
         If isNumber(zl)
         {
            If (msgResult.check && checku)
               VPselRotation := clampInRange(zl, 0, 360)
            Else
               vpIMGrotation := clampInRange(zl, 0, 360)
            dummyTimerDelayiedImageDisplay(50)
         } Else
         {
            showTOOLtip("WARNING: Incorrect angle provided")
            SoundBeep 300, 100
            SetTimer, RemoveTooltip, % -msgDisplayTime
         }
      }
      deactivateTlbrKbdMode(1)
      Return
   }

   GetPhysicalCursorPos(mXo, mYo)
   cX := cY := lastIndex := thisIndex := lastInvoked := 0
   setWhileLoopExec(1)
   lastInvoked := A_TickCount
   lastZeit := A_TickCount
   mouseMode := determineLClickState()
   Critical, off
   bonusMsg := (mouseMode=1) ? "°`nDrag the mouse around the toolbar icon`nHold Alt to deactivate snapping every 90°" : ""
   While, (determineLClickState()=1 || !mouseMode && GetKeyState("enter", "P"))
   {
      If (mouseMode=1)
      {
         GetPhysicalCursorPos(mX, mY)
         If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
            Continue
      }

      Sleep, 1
      cX := mX, cY := mY
      snap := GetKeyState("Alt", "P") ? 1 : 15
      If !mouseMode
      {
         If (modus="sel")
            VPselRotation := clampInRange(VPselRotation + 5, 0, 360, 1)
         Else If (modus="vp-img")
            vpIMGrotation := clampInRange(vpIMGrotation + 5, 0, 360, 1)
         Sleep, 70
      }

      If (modus="sel")
      {
         If (mouseMode && A_Index>1)
            VPselRotation := UIcalculateNewAngleOnMouseCoords(mXo, mYo, mX, mY, oVPselRotation, snap)
         dummyRefreshImgSelectionWindow()
         showTOOLtip("Selection rotation: " Round(VPselRotation, 1) bonusMsg)
      } Else If (modus="vp-img")
      {
         If (mouseMode && A_Index>1)
            vpIMGrotation := UIcalculateNewAngleOnMouseCoords(mXo, mYo, mX, mY, ovpIMGrotation, snap)
         GdipCleanMain(4)
         showTOOLtip("Image rotation: " Round(vpIMGrotation, 1) bonusMsg)
      }
   }

   setWhileLoopExec(0)
   RemoveTooltip()
   dummyTimerDelayiedImageDisplay(50)
}

updateUIbrushSoloSlidersTool(ctrlu:=0,m:=0) {
   Critical, off
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<50)
   {
      SetTimer, updateUIbrushSoloSlidersTool, -150
      Return
   }

   ; MouseMoveResponder()
   If (soloSliderWinVisible=1)
      GuiControlGet, OutputVar, SoloSliderWidgetGUIA: FocusV 

   If (m="given")
      OutputVar := ctrlu 

   OutputVar := SubStr(OutputVar, InStr(OutputVar, "@") + 1)
   ; ToolTip, % outputvar , , , 2
   If OutputVar
      GuiUpdateSliders(OutputVar)

   SetTimer, updateUIbrushTool, -50
   SetTimer, MouseMoveResponder, -50
   lastInvoked := A_TickCount
}

tlbrFloodFillSlidersInvoker(m) {
    If (m=2)
       CreateSoloSliderWidgetWin(lastTlbrClicked, "@FloodFillOpacity", 3,255, 255, "Flooding opacity", "dummy", 1)
    Else
       CreateSoloSliderWidgetWin(lastTlbrClicked, "@FloodFillTolerance", 0,255, 10, "Similarity", "dummy", 1)
}

tlbrBrushSlidersInvoker(m) {
   x := (BrushToolUseSecondaryColor=1) ? "B" : "A"
   If (m=1)
      CreateSoloSliderWidgetWin(lastTlbrClicked, "@BrushToolSoftness", 1,100, 3, "Softness", "updateUIbrushSoloSlidersTool", 1)
   Else If (m=2)
      CreateSoloSliderWidgetWin(lastTlbrClicked, "@BrushToolAspectRatio", -100,100, 0, "Aspect ratio", "updateUIbrushSoloSlidersTool", 2)
   Else If (m=3)
      CreateSoloSliderWidgetWin(lastTlbrClicked, "@BrushToolSize", 2,950, 25, "Brush size: $€", "updateUIbrushSoloSlidersTool", 1)
   Else If (m=4)
      CreateSoloSliderWidgetWin(lastTlbrClicked, "@BrushToolAngle", -180,180, 0, "Angle: $€°", "updateUIbrushSoloSlidersTool", 2)
   Else If (m=5)
      CreateSoloSliderWidgetWin(lastTlbrClicked, "@BrushTool" x "opacity", 2,255, 255, "Opacity", "updateUIbrushSoloSlidersTool", 1)
   Else If (m=8)
      CreateSoloSliderWidgetWin(lastTlbrClicked, "@BrushToolAopacity", 2,255, 255, "Intensity", "updateUIbrushSoloSlidersTool", 1)
   Else If (m=9)
      CreateSoloSliderWidgetWin(lastTlbrClicked, "@BrushToolDryingRate", 0,20, 0, "Dry-out rate", "updateUIbrushSoloSlidersTool", 1)
   Else If (m=6)
   {
      togglePresetsBrushes(1)
      CreateSoloSliderWidgetWin(lastTlbrClicked, "@BrushToolBlurStrength", 0,99, 10, "Blur strength", "updateUIbrushSoloSlidersTool", 1)
   } Else If (m=7)
   {
      togglePresetsBrushes(3)
      CreateSoloSliderWidgetWin(lastTlbrClicked, "@BrushToolWetness", 0,22, 0, "Wetness", "updateUIbrushSoloSlidersTool", 1)
   }
}

userChangeBrushSoft(modus, dir) {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
   {
      If (BrushToolType>1 && BrushToolTexture=1)
      {
         okayu := 1
         If (modus="tlbr")
            tlbrBrushSlidersInvoker(1)
         Else
            changeBrushSoftness(dir)
      } Else If (BrushToolType=1)
         showTOOLtip("WARNING: The current brush type does not have the softness property.")
      Else If (BrushToolTexture>1)
         showTOOLtip("WARNING: The current brush is based on a texture.`nSoftness does not apply for textures.")

      If !okayu
         SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

userChangeBrushRatio(modus, dir) {
   If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()) && (BrushToolTexture=1 || BrushToolType=1))
   {
      If (modus="tlbr")
         tlbrBrushSlidersInvoker(2)
      Else
         changeBrushRatioAngle(dir, 1)
   } Else If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()) && BrushToolType>1)
   {
      showTOOLtip("WARNING: The current brush is based on a texture.`nThe aspect ratio cannot be changed")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

SoloSliderWidgetGUIAGuiClose:
SoloSliderWidgetGUIAGuiEscape:
   destroySoloSliderWidget()
Return

destroySoloSliderWidget() {
   Gui, SoloSliderWidgetGUIA: Destroy
   WinActivate, ahk_id %PVhwnd%
   Loop, % tlbrIconzList["counter"]
   {
       h := tlbrIconzList[A_Index, 1]
       WinSet, Transparent, 255, ahk_id %h%
   }

   soloSliderWinVisible := 0
}

CreateSoloSliderWidgetWin(btnHwnd, givenVar, minu, maxu, varDefault, uiLabel, func2exec, fillMode) {
    Gui, SoloSliderWidgetGUIA: Destroy
    WinGetPos, mx, my, w, h, ahk_id %btnHwnd%
    my += h
    If (mx!="" && my!="")
       coords := " x" mx " y" my

    If (ShowAdvToolbar=1 && tlbrIconzList[btnHwnd, 1])
    {
       Loop, % tlbrIconzList["counter"]
       {
           th := tlbrIconzList[A_Index, 1]
           If (th!=btnHwnd)
              WinSet, Transparent, 150, ahk_id %th%
       }
    }
    w := (PrefsLargeFonts=1) ? 200 : 135
    h := (PrefsLargeFonts=1) ? 30 : 20

    Sleep, 5
    Gui, SoloSliderWidgetGUIA: Default
    Gui, SoloSliderWidgetGUIA: +Border -MaximizeBox -MinimizeBox -SysMenu +hwndhSliderWidget +Owner%PVhwnd% -Caption
    Gui, SoloSliderWidgetGUIA: Margin, 1, 1
    If (uiUseDarkMode=1)
    {
       Gui, Color, 303030,303030
       ; Gui, Color, % darkWindowColor, % darkWindowColor
       Gui, Font, c%darkControlColor%
       setDarkWinAttribs(hSliderWidget)
    }

    ; WinSet, Transparent, 215, ahk_id %hSliderWidget%
    h := (PrefsLargeFonts=1) ? 28 : 18
    soloSliderWinVisible := 1
    r := GuiAddSlider(givenVar, minu, maxu, varDefault, uiLabel, func2exec, fillMode, "x1 y1 w" w " h" h, 0, 1, "SoloSliderWidgetGUIA")
    ControlFocus, ahk_id %r%
    Gui, SoloSliderWidgetGUIA: Show, Hide Autosize %coords%, QPV slider
    If (coords)
    {
       adjustWin2MonLimits(hSliderWidget, mX, mY, rX, rY, Wid, Heig)
       coords := " x" rX " y" rY
    }

    Gui, SoloSliderWidgetGUIA: Show, Autosize %coords%, QPV slider
    GuiUpdateSliders(givenVar)
    UnregisterTouchWindow(hSliderWidget)
    disableWindowPenServices(hSliderWidget)
    SetTimer, mouseTurnOFFtooltip, -150
}

tlbrChangeBrushFXblur(dir) {
   togglePresetsBrushes(1, dir)
}

InvokeSelectAreaAlignMenu(givenCoords:=0) {
   ; If isImgEditingNow()
   If (isImgEditingNow() && editingSelectionNow=1)
   {
      deleteMenus()
      createMenuSelectionAlign()
      globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVselAlign") : givenCoords
      showThisMenu("PVselAlign")
   }
}

tlbrSelAllVectorPoints(a:=0) {
    If !customShapeHasSelectedPoints || InStr(a, "select")
       MenuSelAllVectorPoints()
    Else
       MenuSelNoVectorPoints()
}

tlbrViewPortGridu() {
   Static lastInvoked := 1
   If isImgEditingNow()
   {
      If (A_TickCount - lastInvoked<450)
         Return

      lastInvoked := A_TickCount
      If (GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P"))
      {
         toggleViewPortGridu("tlbr")
         Return
      }

      vpImgPanningNow := 0 ;(allowFreeIMGpanning=1) ? 1 : 2
      coreTlbrSlider("VPchangeGridSize", 10, 0)
   }
}

tlbrFillShape() {
   If (isImgEditingNow()=1 && AnyWindowOpen=23)
   {
      UIcycleFillShapes()
   } Else If isImgEditingNow()
   {
      If (EllipseSelectMode=2)
         FillAreaShape := 7
      Else If (EllipseSelectMode=1)
         FillAreaShape := 3
      Else If (EllipseSelectMode=0)
         FillAreaShape := 1

      PanelFillSelectedArea("tlbr", FillAreaShape)
   }
}

tlbrDrawShapesContour() {
   If (isImgEditingNow()=1 && AnyWindowOpen=65)
   {
      UIcycleFillShapes()
   } Else If (isImgEditingNow()=1)
   {
      If (editingSelectionNow!=1)
         ToggleEditImgSelection()

      If (EllipseSelectMode=2)
         FillAreaShape := 7
      Else If (EllipseSelectMode=1)
         FillAreaShape := 3
      Else If (EllipseSelectMode=0)
         FillAreaShape := 1

      PanelDrawShapesInArea("tlbr", FillAreaShape)
   }
}

tlbrZoomINout(dummy:=0) {
   If ((thumbsDisplaying=1 && maxFilesIndex>3 && CurrentSLD) || (isImgEditingNow()=1))
   {
      If (GetKeyState("Ctrl", "P") && thumbsDisplaying!=1)
      {
         msgResult := msgBoxWrapper("Set zoom level: " appTitle, "Please type the new zoom level for the image in the viewport, from 0% to 2000%.", "&Apply|C&ancel", 1, "search", "&Reset image panning position", 0, 0, "limit9050", Round(zoomLevel*100, 2))
         If InStr(msgResult.btn, "apply")
         {
            zl := Trimmer(msgResult.edit)
            zl := Trimmer(StrReplace(zl, "%"))
            If isNumber(zl)
            {
               IMGresizingMode := 4
               zoomLevel := clampInRange(zl/100, 0.001, 20)
               If (msgResult.check)
                  IMGdecalageX := IMGdecalageY := 1
               dummyTimerDelayiedImageDisplay(50)
            } Else
            {
               showTOOLtip("WARNING: Incorrect zoom level value provided")
               SoundBeep 300, 100
               SetTimer, RemoveTooltip, % -msgDisplayTime
            }
         }
         deactivateTlbrKbdMode(1)
         Return
      }

      If (GetKeyState("Shift", "P")) && (IMGresizingMode=4 && dummy!="navBox")
      {
         IMGdecalageX := IMGdecalageY := 0
         zoomLevel := 1
         dummyTimerDelayiedImageDisplay(50)
         Return
      }

      GetPhysicalCursorPos(oX, oY)
      cX := cY := lastIndex := thisIndex := lastInvoked := 0
      setWhileLoopExec(1)
      vpImgPanningNow := (allowFreeIMGpanning=1) ? 1 : 2
      While, (determineLClickState()=1 || A_Index=1)
      {
         GetPhysicalCursorPos(mX, mY)
         dir := (oY<mY) ? -1 : 1
         If (dummy="zin")
            dir := 1
         Else If (dummy="zout")
            dir := -1

         If InStr(dummy, "z")
         {
            Sleep, 25
         } Else If isDotInRect(mX, mY, 5, 5, cX, cY, 1)
         {
            If !isInRange(thisIndex, lastIndex - 2, lastIndex + 2)
            || (A_TickCount - lastInvoked>100)
            {
               lastIndex := thisIndex
               MouseMove, % oX, % oY, 1
            }
            Continue
         }
         lastInvoked := A_TickCount
         cX := mX, cY := mY
         VPChangeZoom(dir, 0, 1, 1) 
         Sleep, % (thumbsDisplaying=1 || InStr(dummy, "z")) ? 10 : -1
         thisIndex++
      }
      vpImgPanningNow := 0
      dummyTimerDelayiedImageDisplay(150)
      setWhileLoopExec(0)
   }
   Return "m"
}

invokeFilesSelectionMenu() {
   deleteMenus()
   createMenuFilesSelections("PVfileSel")
   showThisMenu("PVfileSel")
}

MenuCycleSelectionShapes() {
   If (isImgEditingNow()=1 && editingSelectionNow=1)
   {
      imgLiveEdit := (!AnyWindowOpen) || (HKifs("liveEdit") && isVarEqualTo(AnyWindowOpen, 10, 25, 55, 64, 66, 68, 74, 81, 89)) ? 1 : 0
      If isVarEqualTo(AnyWindowOpen, 31, 24)
         toggleLiveEditObject()
      Else If isVarEqualTo(AnyWindowOpen, 68, 65, 23)
         UIcycleFillShapes()
      Else If imgLiveEdit
         toggleEllipseSelection()
   } Else If (thumbsDisplaying=1 && currentFileIndex>0 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
   {
      markThisFileNow()
   } Else If (isImgEditingNow()=1)
      ToggleEditImgSelection()
   ; ToolTip, % EllipseSelectMode "=" hwnd "=" paramu , , , 2
}

decideIconBTNselectShape() {
   initialIcon := tlbrIconzList["BTNselectShape", 2]
   thisHwnd := tlbrIconzList["BTNselectShape", 1]
   If !thisHwnd
      Return

   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := (EllipseSelectMode=1) ? "select-ellipse" : "select-rect"
   If (thumbsDisplaying=1)
      icoFile := "select-rect"
   Else If (EllipseSelectMode=2)
      icoFile := "select-freeform"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNselectShape", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

decideIconBTNthumbsList() {
   initialIcon := tlbrIconzList["BTNthumbsList", 2]
   thisHwnd := tlbrIconzList["BTNthumbsList", 1]
   If !thisHwnd
      Return

   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   If (thumbsListViewMode=1)
      icoFile := "thumbs-list"
   Else If (thumbsListViewMode=2)
      icoFile := "files-list-simple"
   Else ; If (thumbsListViewMode>=3)
      icoFile := "files-list-details"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNthumbsList", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

decideIconBTNmainTooler() {
   thisHwnd := tlbrIconzList[2, 1]
   If !thisHwnd
      Return

   initialIcon := tlbrIconzList["BTNmainTooler", 2]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := (AnyWindowOpen && imgEditPanelOpened=1 || drawingShapeNow=1) ? "apply-tool" : "thumbs-mode"
   If isVarEqualTo(AnyWindowOpen, 10, 64, 66, 70)
      icoFile := "main-tool"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNmainTooler", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

decideIconBTNpaintBrushSelect() {
   thisHwnd := tlbrIconzList["BTNpaintSelection", 1]
   If !thisHwnd
      Return

   initialIcon := tlbrIconzList["BTNpaintSelection", 2]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := (BrushToolOutsideSelection=1) ? "paint-any" : "paint-inside"
   If (BrushToolOutsideSelection=3)
      icoFile := "paint-outside"

   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNpaintSelection", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

decideIconBTNvectToolModes() {
   thisHwnd := tlbrIconzList["BTNvectTmodes", 1]
   If !thisHwnd
      Return

   initialIcon := tlbrIconzList["BTNvectTmodes", 2]
   w := tlbrIconzList[thisHwnd, 7]
   h := tlbrIconzList[thisHwnd, 8]
   icoFile := "vector-mode-" defineVectToolMode()
   If (icoFile!=initialIcon)
   {
      tlbrIconzList["BTNvectTmodes", 2] := icoFile
      tlbrSetImageIcon(icoFile, thisHwnd, w, h)
   }
}

InvokeSelShapesMenu(givenCoords:=0) {
   If isImgEditingNow()
   {
      deleteMenus()
      createMenuSelectSizeShapes()
      globalMenuOptions := (givenCoords="tlbr") ? StrReplace(globalMenuOptions, "tlbrMenu", "PVselSize") : givenCoords
      showThisMenu("PVselSize")
   }
   Return "m"
}

tlbrUndoAction() {
   setWhileLoopExec(1)
   While, (determineLClickState()=1 || A_Index=1)
   {
      ImgUndoAction()
      Sleep, % (A_Index<10) ? 200 : 90
   }
   setWhileLoopExec(0)
   Return "m"
}

tlbrPanIMG() {
   Critical, on
   Static lastInvoked := 1
   If (isImgEditingNow()=1 && (IMGlargerViewPort=1 || allowFreeIMGpanning=1) && IMGresizingMode=4)
   {
      IMGresizingMode := 4
      If (A_TickCount - lastInvoked<550)
      {
         IMGdecalageX := IMGdecalageY := 0
         dummyTimerDelayiedImageDisplay(10)
         Return
      }

      vpWinClientSize(mainWidth, mainHeight)
      If (mainWidth && mainHeight)
      {
         MouseGetPos, oX, oY
         JEE_ClientToScreen(PVhwnd, mainWidth//2, mainHeight//2, pX, pY)
         doSetCursorPos(pX, pY)
      }
      Sleep, 2
      simplePanIMGonClick(0, 1, 1, oX, oY)
      lastInvoked := A_TickCount
      decideWinReactivation()
   }
   Return "m"
}

tlbrRedoAction() {
   setWhileLoopExec(1)
   While, (determineLClickState()=1 || A_Index=1)
   {
      ImgRedoAction()
      Sleep, % (A_Index<10) ? 200 : 90
   }
   setWhileLoopExec(0)
   Return "m"
}

invokeSortListMenu() {
   If (maxFilesIndex>1 && CurrentSLD && !AnyWindowOpen)
   {
      deleteMenus()
      createMenuFilesSort()
      globalMenuOptions := StrReplace(globalMenuOptions, "tlbrMenu", "PVsort")
      showThisMenu("PVsort")
      Return "m"
   } Else If StrLen(mustOpenStartFolder)>3
   {
      currentFileIndex := doOpenStartFolder()
      SetTimer, invokeSortListMenu, -200
   } Else If (maxFilesIndex<3)
   {
      showTOOLtip("WARNING: Insufficient files are currently indexed.")
      SoundBeep 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

isTlbrViewModus(p:=0) {
   If (p=1)
      r := (userCustomizedToolbar=1 && imgEditPanelOpened!=1) ? 1 : 0
   Else
      r := (toolbarViewerMode=1 && imgEditPanelOpened!=1) ? 1 : 0

   pk := isImgEditingNow()
   isVectorMode := (drawingShapeNow=1 && editingSelectionNow=1 && EllipseSelectMode=2) ? 1 : 0
   isWelcomeScreenu := (pk=1 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
   isTransPanel := (pk=1 && (AnyWindowOpen=31 || AnyWindowOpen=24)) ? 1 : 0
   addAlphaIcons := (isAlphaMaskPartialWin()=1 || isAlphaMaskWindow()=1) ? 1 : 0
   If (isVectorMode=1 || isWelcomeScreenu=1 || isTransPanel=1 || addAlphaIcons=1 || isNowAlphaPainting())
      r := 0

   Return r
}

processToolbarFunctions(btnID, actu, simulacrum:=0) {
   func2call := []
   If InStr(actu,"right")
   {
      If (btnID="BTNdragTlbr")
      {
         func2Call := ["invokeTlbrContextMenu", "tlbr"]
      } Else If (btnID="BTNsettings")
      {
         If (!AnyWindowOpen || imgEditPanelOpened=1)
         {
            If (drawingShapeNow=1)
               func2Call := ["invokeMenuNavBoxImgSizeVP", "tlbr"]
            Else
               func2Call := ["OpenUImenu", "tlbr"]
         }
      } Else If (btnID="BTNcopyImg")
      {
         func2Call := ["CopyImagePath"]
      } Else If (btnID="BTNnewImg")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["addNewFolder2list"]
         Else If !AnyWindowOpen
            func2Call := ["AcquireWIAimage"]
      } Else If (btnID="BTNpasteImg")
      {
         func2Call := ["PanelPasteInPlace"]
      } Else If (btnID="BTNundoImg")
      {
         If (drawingShapeNow!=1)
            func2Call := ["ImgSelUndoAct"]
      } Else If (btnID="BTNredoImg")
      {
         If (drawingShapeNow!=1)
            func2Call := ["ImgSelRedoAct"]
      } Else If (btnID="BTNtextTool")
      {
         imgPath := getIDimage(currentFileIndex)
         If (isImgEditingNow()=1 && FileExist(imgPath) && (!AnyWindowOpen || imgEditPanelOpened=1))
            func2Call := ["PanelEditImgCaption"]
      } Else If (btnID="BTNeraserBrush")
      {
         If (isImgEditingNow()=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
            func2Call := ["toggleErasePasteInPlace"]
         Else If (isImgEditingNow()=1 && editingSelectionNow=1)
            func2Call := ["PanelEraseSelectedArea"]
      } Else If (btnID="BTNdeleteTool")
      {
         If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["singleInListEntriesRemover"]
      } Else If (btnID="BTNblurTool")
      {
         If (isImgEditingNow()=1 && (!AnyWindowOpen || imgEditPanelOpened=1))
            func2Call := ["PanelBlurSelectedArea"]
      } Else If (btnID="BTNclonerTool")
      {
         If (AnyWindowOpen=64)
            func2Call := ["BtnSetClonerBrushSource"]
      } Else If (btnID="BTNwetbrush")
      {
         func2Call := ["MenuDecBrushWetness"]
      } Else If (btnID="BTNpenVector")
      {
         func2Call := ["MenuRealStartDrawingLines"]
      } Else If (btnID="BTNpipette" || btnID="BTNcolorsSwatch")
      {
         If ((!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen) && (thumbsDisplaying!=1))
            func2Call := ["ToggleBrushColors"]
      } Else If (btnID="BTNalphCapture")
      {
         func2Call := ["importAlphaMaskFromClipboard"]
      } Else If (btnID="BTNcrop")
      {
         If (isImgEditingNow()=1 && editingSelectionNow!=1)
            func2Call := ["PanelImgAutoCrop"]
         Else If (isImgEditingNow()=1 && editingSelectionNow=1)
            func2Call := ["ResizeIMGviewportSelection"]
      } Else If (btnID="BTNsave")
      {
         If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["PanelSaveSlideShowu"]
      } Else If (btnID="BTNopen")
      {
         If !AnyWindowOpen
            func2Call := ["InvokeOpenRecentMenu", "tlbr"]
      } Else If (btnID="BTNcutImg")
      {
         If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["PanelMoveCopyFiles"]
      } Else If (btnID="BTNadjustColors")
      {
         func2Call := ["ResetImageView"]
      } Else If (btnID="BTNtlbrflipH")
      {
         If (isImgEditingNow()=1 && editingSelectionNow=1 && drawingShapeNow!=1 && AnyWindowOpen && !isNowAlphaPainting())
            func2Call := ["FlipSelectedAreaH"]
         Else If ( (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         || (isImgEditingNow()=1 && editingSelectionNow=1 && drawingShapeNow!=1) )
            func2Call := ["VPflipImgH"]
      } Else If (btnID="BTNtlbrflipV")
      {
         If (isImgEditingNow()=1 && editingSelectionNow=1 && drawingShapeNow!=1 && AnyWindowOpen && !isNowAlphaPainting())
            func2Call := ["FlipSelectedAreaV"]
         Else If ( (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         || (isImgEditingNow()=1 && editingSelectionNow=1 && drawingShapeNow!=1) )
            func2Call := ["VPflipImgV"]
      } Else If (btnID="BTNtransformArea")
      {
         If (isImgEditingNow()=1 && !AnyWindowOpen)
            func2Call := ["PanelEditorImgResize"]
      } Else If (btnID="BTNrotateStuff")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["filesListFlipRotateMinus"]
         Else If (isImgEditingNow()=1 && editingSelectionNow=1 && VPselRotation!=0)
            func2Call := ["resetSelectionRotation"]
         Else If (isImgEditingNow()=1 && vpIMGrotation!=0)
            func2Call := ["MenuResetVProtation"]
      } Else If (btnID="BTNfillShape")
      {
         If isImgEditingNow()
            func2Call := ["PanelFillBehindBgrImage"]
      } Else If (btnID="BTNoutlineShape")
      {
         If isImgEditingNow()
            func2Call := ["PanelDrawLines"]
      } Else If (btnID="BTNselectShape")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) 
            func2Call := ["invokeFilesSelectionMenu"]
         Else If (isImgEditingNow()=1)
            func2Call := ["ToggleEditImgSelection"]
      } Else If (btnID="BTNselectFileu")
      {
         func2Call := ["dropFilesSelection"]
      } Else If (btnID="BTNselectFreeform")
      {
         func2Call := ["InvokeSelShapesMenu"]
      } Else If (btnID="BTNloupe")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD)
            func2Call := ["ToggleThumbsAratio"]
         Else If (isImgEditingNow()=1)
            func2Call := ["ToggleImageSizingMode"]
      } Else If (btnID="BTNpreviewBox")
      {
          isWelcomeScreenu := (isImgEditingNow()=1 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             func2Call := ["togglePreviewVectorNewPoint"]
          Else If !isWelcomeScreenu
             func2Call := ["ToggleImgNavSizeBox"]
      } Else If (btnID="BTNsearch")
         func2Call := ["PanelSearchAndReplaceIndex"]
      Else If (btnID="BTNmodifyEntry")
         func2Call := ["PanelUpdateThisFileIndex"]
      Else If (btnID="BTNfilterList")
         func2Call := ["MenuRemFilesListFilter"]
      Else If (btnID="BTNstatsList")
         func2Call := ["PanelFindDupes"]
      Else If (btnID="BTNrefreshList")
         func2Call := ["DeepRefreshThumbsNow"]
      Else If (btnID="BTNfolderTree")
         func2Call := ["invokeFoldersListerMenu"]
      Else If (btnID="BTNrecentOpened")
         func2Call := ["invokeFoldersListerMenu"]
      Else If (btnID="BTNinfozHud")
         func2Call := ["PanelImageInfos"]
      Else If (btnID="BTNmngFolderz")
         func2Call := ["PanelStaticFolderzManager"]
      Else If (btnID="BTNfntSize")
         func2Call := ["MenuChangeOSDZoomMinus"]
      Else If (btnID="BTNfaves")
         func2Call := ["InvokeFavesMenu"]
      Else If (btnID="BTNpanImg")
         func2Call := ["ToggleImgNavBox"]
      Else If (btnID="BTNplaySlides")
         func2Call := ["ToggleSlideshowModes"]
      Else If (btnID="BTNchangeBrushSoft")
         func2Call := (simulacrum=1) ? ["MenuDecBrushSoftness"] : ["userChangeBrushSoft", "tlbr", -1]
      Else If (btnID="BTNchangeBrushOpacity")
         func2Call := (simulacrum=1) ? ["MenuDecBrushOpacity"] : ["tlbrBrushSlidersInvoker", 5]
      Else If (btnID="BTNchangeBrushSize")
         func2Call := ["toggleBrushDoubleSize"]
      Else If (btnID="BTNchangeBrushAngle")
         func2Call := ["toggleBrushMouseAngle"]
      Else If (btnID="BTNchangeBrushRatio")
         func2Call := ["MenuResetBrushAsRatio"]
      Else If (btnID="BTNvectSelAll")
         func2Call := ["MenuSelNoVectorPoints"]
      Else If (btnID="BTNhelp")
         func2Call := ["MenuDrawViewportHelpMap"]
      Else If (btnID="BTNcalculate")
         func2Call := ["PanelReviewSelectedFiles"]
      Else If (btnID="BTNquickFileActs")
         func2Call := ["toggleQuickMoveActionKeys"]
      Else If (btnID="BTNvpGrid")
      {
         If (isImgEditingNow()=1 && drawingShapeNow=1)
            func2Call := ["toggleViewPortGridu"]
         Else If (isImgEditingNow()=1 && (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen!=24 && AnyWindowOpen!=31))
            func2Call := ["PanelConfigVPgrid"]
      } Else If (btnID="BTNthumbsList")
         func2Call := ["ToggleIMGalign"]
      Else If (btnID="BTNimgSizers")
         func2Call := ["InvokeMenuImgSizeVP", "tlbr"]
      Else If (btnID="BTNzoomInIMG")
         func2Call := ["MenuChangeOSDZoomPlus"]
      Else If (btnID="BTNzoomOutIMG")
         func2Call := ["MenuChangeOSDZoomMinus"]
      Else If (btnID="BTNnavFirstImgu")
         func2Call := ["PrevRandyPicture"]
      Else If (btnID="BTNnavLastImgu")
         func2Call := ["RandomPicture"]
      Else If (btnID="BTNnavPrevImgu")
         func2Call := ["jumpPreviousImage"]
      Else If (btnID="BTNalignVPimgu")
         func2Call := ["toggleFreePanning"]
      Else If (btnID="BTNhudHisto")
         func2Call := ["invokeHistoMenu", "tlbr"]
      Else If (btnID="BTNannotate")
         func2Call := ["ToggleImgCaptions"]
      Else If (btnID="BTNprivatModa")
         func2Call := ["ToggleRecordSeenImages"]
      Else If (btnID="BTNsoundPlay")
         func2Call := ["StopMediaPlaying"]
      Else If (btnID="BTNmainTooler" || btnID="BTNswitchThumbs")
      {
         If isNowAlphaPainting()
            func2Call := ["toggleAlphaPaintingMode"]
         Else If (isImgEditingNow()=1 && drawingShapeNow=1)
            func2Call := ["stopDrawingShape", "cancel"]
         Else If (isImgEditingNow()=1 && imgEditPanelOpened=1)
            func2Call := ["BtnCloseWindow"]
         Else If !AnyWindowOpen
            func2Call := ["openPreviousPanel"]
      } Else If (btnID="BTNprintAcquire")
         func2Call := ["AcquireWIAimage"]
      Else If (btnID="BtnReturnImgView")
         func2Call := ["openPreviousPanel"]
      Else If (btnID="BTNgoFileMaps")
         func2Call := ["ToggleFilesMap"]
   } Else
   {
      If (btnID="BTNdragTlbr")
         func2Call := ["tlbrDraggyNow"]
      Else If (btnID="BTNrotateTlbr")
         func2Call := ["ToggleToolBarValign"]
      Else If (btnID="BTNcloseTlbr")
         func2Call := ["toggleAppToolbar"]
      Else If (btnID="BTNcancelTool")
      {
         If isNowAlphaPainting()
            func2Call := ["toggleAlphaPaintingMode"]
         Else If (isImgEditingNow()=1 && drawingShapeNow=1)
            func2Call := ["stopDrawingShape", "cancel"]
         Else If (isImgEditingNow()=1 && imgEditPanelOpened=1)
            func2Call := ["BtnCloseWindow"]
         Else If !AnyWindowOpen
            func2Call := ["openPreviousPanel"]
      } Else If (btnID="BTNsettings")
      {
         If (!AnyWindowOpen || imgEditPanelOpened=1)
         {
            If (drawingShapeNow=1)
               func2Call := ["tlbrVectorDrawingModeContextMenu"]
            Else If (isNowAlphaPainting() || imgEditPanelOpened=1)
               func2Call := ["BuildMainMenu", 0, "tlbr"]
            Else If isImgEditingNow()
               func2Call := ["invokeSelectionAreaMenu", "DoubleClick", "tlbr"]
            Else
               func2Call := ["BuildSecondMenu", "tlbr"]
         }
      } Else If (btnID="BTNcopyImg")
      {
         If (thumbsDisplaying=1)
            func2Call := ["InvokeCopyFiles"]
         Else If isImgEditingNow()
            func2Call := ["CopyImage2clip"]
      } Else If (btnID="BTNnewImg")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["addNewFile2list"]
         Else If (!AnyWindowOpen || imgEditPanelOpened=1)
            func2Call := ["PanelNewImage"]
      } Else If (btnID="BTNpasteImg")
      {
         func2Call := (thumbsDisplaying=1) ? ["MenuPasteHDropFiles"] : ["PasteClipboardIMG"]
      } Else If (btnID="BTNundoImg")
      {
         If isImgEditingNow()
         {
            If (drawingShapeNow=1)
               func2Call := ["ImgVectorUndoAct"]
            Else
               func2Call := (simulacrum=1) ? ["ImgUndoAction"] : ["tlbrUndoAction"]
         }
      } Else If (btnID="BTNredoImg")
      {
         If isImgEditingNow()
         {
            If (drawingShapeNow=1)
               func2Call := ["ImgVectorRedoAct"]
            Else 
               func2Call := (simulacrum=1) ? ["ImgRedoAction"] : ["tlbrRedoAction"]
         }
      } Else If (btnID="BTNtextTool")
      {
         If isImgEditingNow()
            func2Call := ["PanelInsertTextArea"]
      } Else If (btnID="BTNdeleteTool")
      {
         If (maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := (thumbsDisplaying=1) ? ["DeletePicture"] : ["DeleteActivePicture"]
      } Else If (btnID="BTNeraserBrush")
      {
         If isImgEditingNow()
         {
            If (AnyWindowOpen=31 || AnyWindowOpen=24)
               func2Call := ["toggleErasePasteInPlace"]
            Else If (AnyWindowOpen!=64)
               func2Call := ["PanelBrushTool", 4, "e"]
            Else
               func2Call := ["toggleBrushTypeEraser"]
         }
      } Else If (btnID="BTNblurTool")
      {
         If isImgEditingNow()
         {
            If (AnyWindowOpen!=64)
               func2Call := ["PanelBrushTool", 5, "b"]
            Else
               func2Call := ["tlbrBrushSlidersInvoker", 6]
         }
      } Else If (btnID="BTNclonerTool")
      {
         If isImgEditingNow()
         {
            If (AnyWindowOpen!=64)
               func2Call := ["PanelBrushTool", 3, "e"]
            Else
               func2Call := ["toggleBrushTypeCloner"]
         }
      } Else If (btnID="BTNbrushMtool")
      {
         If isImgEditingNow()
         {
            If (AnyWindowOpen!=64)
               func2Call := ["PanelBrushTool", 2, "e"]
            Else
               func2Call := ["toggleBrushTypes", "tlbr"]
         }
      } Else If (btnID="BTNFXbrush")
      {
         If isImgEditingNow()
         {
            If (AnyWindowOpen!=64)
               func2Call := ["PanelBrushTool", 5, "fx"]
            Else
               func2Call := ["toggleBrushTypeFX", "tlbr"]
         }
      } Else If (btnID="BTNdryout")
      {
         If isImgEditingNow()
            func2Call := ["tlbrBrushSlidersInvoker", 9]
      } Else If (btnID="BTNwetbrush")
      {
         If isImgEditingNow()
         {
            If (AnyWindowOpen!=64)
               func2Call := ["PanelBrushTool", 2, "w"]
            Else If (simulacrum=1)
               func2Call := ["MenuIncBrushWetness"]
            Else
               func2Call := ["tlbrBrushSlidersInvoker", 7]
         }
      } Else If (btnID="BTNpenVector")
      {
         func2Call := ["MenuRealStartDrawingShapes"]
      } Else If (btnID="BTNpipette")
      {
         If (!AnyWindowOpen || imgEditPanelOpened=1 && AnyWindowOpen)
            func2Call := ["changeBrushColorPicker"]
      } Else If (btnID="BTNcolorsSwatch")
      {
         If (thumbsDisplaying=1)
            func2Call := ["TogglePrivateMode"]
         Else If (simulacrum=1)
            func2Call := ["ToggleBrushColors"]
         Else
            func2Call := ["tlbrActColorsSwatch"]
      } Else If (btnID="BTNalphInvert")
      {
         If isImgEditingNow()
            func2Call := ["toggleInvertAlphaMask"]
      } Else If (btnID="BTNalphRaster")
      {
         If isImgEditingNow()
            func2Call := ["RasterizeAlphaMaskNow"]
      } Else If (btnID="BTNalphPaint")
      {
         If (isImgEditingNow() && isAlphaMaskWindow() && editingSelectionNow=1)
            func2Call := ["toggleAlphaPaintingMode"]
      } Else If (btnID="BTNalphCapture")
      {
         If (isImgEditingNow() && editingSelectionNow=1)
            func2Call := ["SetImageAsAlphaMask"]
      } Else If (btnID="BTNalphPanel")
      {
         If isImgEditingNow()
            func2Call := ["PanelSoloAlphaMasker"]
      } Else If (btnID="BTNalphView")
      {
         If (isImgEditingNow() && editingSelectionNow=1)
            func2Call := ["ViewAlphaMaskNow"]
      } Else If (btnID="BTNalphDiscard")
      {
         If isImgEditingNow()
            func2Call := ["discardUserPaintedAlpha"]
      } Else If (btnID="BTNcrop")
      {
         If (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24))
         {
            func2Call := ["togglePasteInPlaceCropShapes"]
         } Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         {
            func2Call := ["PanelSimpleResizeRotate"]
         } Else If (isImgEditingNow()=1 && !AnyWindowOpen)
         {
            If (editingSelectionNow=1)
               func2Call := ["CropImageInViewPortToSelection"]
            Else If !AnyWindowOpen
               func2Call := ["PanelAdjustImageCanvasSize"]
         }
      } Else If (btnID="BTNsave")
      {
         If (isImgEditingNow()=1 && !AnyWindowOpen)
            func2Call := ["PanelSaveImg"]
         Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["PanelSaveSlideShowu"]
      } Else If (btnID="BTNopen")
      {
         If !AnyWindowOpen
            func2Call := ["OpenDialogFiles"]
      } Else If (btnID="BTNcutImg")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["MenuExplorerCutFiles"]
         Else If (isImgEditingNow()=1 && editingSelectionNow=1 && !AnyWindowOpen)
            func2Call := ["CutSelectedArea"]
      } Else If (btnID="BTNadjustColors")
      {
         If (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24))
            func2Call := ["togglePasteInPlaceColorsFX"]
         Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["PanelSetThumbColumnOptions"]
         Else If isImgEditingNow()
         {
            If isTlbrViewModus()
               func2Call := ["PanelColorsAdjusterWindow"]
            Else
               func2Call := ["PanelAdjustColorsSimpleWindow"]
         }
      } Else If (btnID="BTNtlbrflipH")
      {
         editing := isImgEditingNow()
         If (editing=1 && drawingShapeNow=1)
            func2Call := ["toggleBrushSymmetryModes"]
         Else If (editing=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
            func2Call := ["FlipHtransformedIMGpanel"]
         Else If (editing=1 && isNowAlphaPainting())
            func2Call := ["FlipHalphaMask"]
         Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["filesListFlipHimage"]
         Else If (editing=1 && editingSelectionNow=1 && !AnyWindowOpen)
            func2Call := ["FlipSelectedAreaH"]
         Else If (editing=1)
            func2Call := ["VPflipImgH"]
      } Else If (btnID="BTNtlbrflipV")
      {
         editing := isImgEditingNow()
         If (editing=1 && drawingShapeNow=1)
            func2Call := ["toggleBrushSymmetryModes"]
         Else If (editing=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
            func2Call := ["FlipVtransformedIMGpanel"]
         Else If (editing=1 && isNowAlphaPainting())
            func2Call := ["FlipValphaMask"]
         Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["filesListFlipVimage"]
         Else If (editing=1 && editingSelectionNow=1 && !AnyWindowOpen)
            func2Call := ["FlipSelectedAreaV"]
         Else If (editing=1)
            func2Call := ["VPflipImgV"]
      } Else If (btnID="BTNtransformArea")
      {
         If (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24))
            func2Call := ["togglePasteInPlaceAdaptModes"]
         Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["importEditGivenImageFile"]
         Else If (isImgEditingNow()=1 && editingSelectionNow=0 && !AnyWindowOpen)
            func2Call := ["PanelEditorImgResize"]
         Else If (isImgEditingNow()=1 && editingSelectionNow=1 && !AnyWindowOpen)
            func2Call := ["PanelTransformSelectedArea"]
      } Else If (btnID="BTNrotateStuff")
      {
         pp := isTlbrViewModus()
         editing := isImgEditingNow()
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         {
            func2Call := ["filesListFlipRotatePlus"]
         } Else If (editing=1 && editingSelectionNow=1 && VPselRotation!=0 && (GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P")))
         {
            func2Call := ["resetSelectionRotation"]
         } Else If (editing=1 && editingSelectionNow=1 && !pp)
         {
            func2Call :=  (simulacrum=1) ? ["MenuSelIncRotation"] : ["tlbrChangeStuffRotation", "sel"]
         } Else If (editing=1)
         {
            If pp
               func2Call := (simulacrum=1) ? ["MenuIncVProtation"] : ["changeImgRotationInVP", 1, 45]
            Else
               func2Call := (simulacrum=1) ? ["MenuIncVProtation"] : ["tlbrChangeStuffRotation", "vp-img"]
         }
      } Else If (btnID="BTNfillShape")
      {
         func2Call := ["tlbrFillShape"]
      } Else If (btnID="BTNoutlineShape")
      {
         func2Call := ["tlbrDrawShapesContour"]
      } Else If (btnID="BTNselectShape")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) 
            func2Call := ["markThisFileNow"]
         Else If (simulacrum=1 && editingSelectionNow!=1)
            func2Call := ["ToggleEditImgSelection"]
         Else
            func2Call := ["MenuCycleSelectionShapes"]
      } Else If (btnID="BTNselectFileu")
      {
         func2Call := ["markThisFileNow"]
      } Else If (btnID="BTNselectFreeform")
      {
         If isImgEditingNow()
         {
            If (editingSelectionNow!=1 || EllipseSelectMode!=2)
               func2Call := ["MenuStartDrawingSelectionArea"]
            Else
               func2Call := ["MenuResumeDrawingShapes"]
         }
      } Else If (btnID="BTNloupe")
      {
         If (isImgEditingNow() || (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD))
         {
            If (simulacrum=1)
               func2Call := ["MenuChangeImgZoomPlus"]
            Else
               func2Call := ["tlbrZoomINout"]
         }
      } Else If (btnID="BTNpreviewBox")
      {
          isWelcomeScreenu := (isImgEditingNow()=1 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
          If (isImgEditingNow()=1 && drawingShapeNow=1)
             func2Call := ["togglePreviewVectorNewPoint"]
          Else If !isWelcomeScreenu
             func2Call := ["ToggleImgNavBox"]
      } Else If (btnID="BTNsearch")
         func2Call := ["PanelSearchIndex"]
      Else If (btnID="BTNmodifyEntry")
         func2Call := ["PanelRenameThisFile"]
      Else If (btnID="BTNfilterList")
         func2Call := ["PanelEnableFilesFilter"]
      Else If (btnID="BTNstatsList")
         func2Call := ["PanelWrapperFilesStats"]
      Else If (btnID="BTNsortList")
         func2Call := ["invokeSortListMenu"]
      Else If (btnID="BTNrefreshList")
         func2Call := ["RefreshFilesList"]
      Else If (btnID="BTNfolderTree")
         func2Call := ["MenuPanelFoldersTree"]
      Else If (btnID="BTNrecentOpened")
         func2Call := ["InvokeOpenRecentMenu", "tlbr"]
      Else If (btnID="BTNinfozHud")
         func2Call := ["ToggleInfoBoxu"]
      Else If (btnID="BTNmngFolderz")
         func2Call := ["PanelDynamicFolderzWindow"]
      Else If (btnID="BTNfntSize")
         func2Call := ["MenuChangeOSDZoomPlus"]
      Else If (btnID="BTNfaves")
      {
         isWelcomeScreenu := (isImgEditingNow()=1 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
         If isWelcomeScreenu
            func2Call := ["InvokeFavesMenu", "tlbr"]
         Else If !AnyWindowOpen
            func2Call := ["ToggleImgFavourites"]
      } Else If (btnID="BTNpanImg")
      {
         func2Call := ["tlbrPanIMG"]
      } Else If (btnID="BTNswitchThumbs" || btnID="BTNmainTooler")
      {
         If (isImgEditingNow()=1 && drawingShapeNow=1)
            func2Call := ["stopDrawingShape"]
         Else If (isImgEditingNow()=1 && imgEditPanelOpened=1)
            func2Call := ["applyIMGeditFunction"]
         Else If !AnyWindowOpen
            func2Call := ["ToggleThumbsMode"]
      } Else If (btnID="BTNplaySlides")
      {
         func2Call := ["MenuGoPlaySlidesNow"]
      } Else If (btnID="BTNchangeBrushSoft")
      {
         func2Call := (simulacrum=1) ?  ["MenuIncBrushSoftness"] : ["userChangeBrushSoft", "tlbr", 1]
      } Else If (btnID="BTNchangeBrushOpacity")
      {
         editing := isImgEditingNow()
         If (editing=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
            func2Call := (simulacrum=1) ? ["MenuIncBrushOpacity"] : ["tlbrBrushSlidersInvoker", 5]
         If (editing=1 && AnyWindowOpen=66)
            func2Call := ["tlbrFloodFillSlidersInvoker", 2]
      } Else If (btnID="BTNchangeBrushSize")
      {
         If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
            func2Call := (simulacrum=1) ? ["MenuIncBrushSize"] : ["tlbrBrushSlidersInvoker", 3]
      } Else If (btnID="BTNchangeBrushAngle")
      {
         If (isImgEditingNow()=1 && (AnyWindowOpen=64 || isNowAlphaPainting()))
            func2Call := (simulacrum=1) ? ["MenuIncBrushAngle"] : ["tlbrBrushSlidersInvoker", 4]
      } Else If (btnID="BTNchangeBrushRatio")
         func2Call := (simulacrum=1) ? ["MenuIncBrushAspectRatio"] : ["userChangeBrushRatio", "tlbr", 1]
      Else If (btnID="BTNvectSmooth")
         func2Call := ["togglePathCurveTension"]
      Else If (btnID="BTNvectTmodes")
         func2Call := ["MenuCycleVectToolMode"]
      Else If (btnID="BTNvectSymAnchr")
         func2Call := ["toggleAutoReflectAnchors"]
      Else If (btnID="BTNvectRemLast")
         func2Call := ["reduceCustomShapeLength"]
      Else If (btnID="BTNvectRemPoints")
         func2Call := ["MenuRemSelVectorPoints"]
      Else If (btnID="BTNvectSelInvert")
         func2Call := ["MenuSelInvertVectorPoints"]
      Else If (btnID="BTNvectOpenPath")
         func2Call := ["toggleOpenClosedLineEditorCustomShape"]
      Else If (btnID="BTNvectSelAll")
         func2Call := ["tlbrSelAllVectorPoints"]
      Else If (btnID="BTNpaintSelection")
      {
         If (isImgEditingNow()=1 && (AnyWindowOpen=64 || AnyWindowOpen=66))
            func2Call := ["toggleBrushDrawInOutModes"]
      } Else If (btnID="BTNalignSel")
      {
         func2Call := ["InvokeSelectAreaAlignMenu", "tlbr"]
      } Else If (btnID="BTNhelp")
      {
         If !AnyWindowOpen
            func2Call := ["PanelAboutWindow"]
         Else
            func2Call := ["showQuickHelp"]
      } Else If (btnID="BTNfloodFill")
      {
         If isImgEditingNow()
         {
            If (AnyWindowOpen!=66)
               func2Call := ["PanelFloodFillTool"]
            Else
               func2Call := ["tlbrFloodFillSlidersInvoker", 1]
         }
      } Else If (btnID="BTNcalculate")
      {
         func2Call := ["CalculateSelectedFilesSizes"]
      } Else If (btnID="BTNinvertStuff")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen && markedSelectFile>0)
            func2Call := ["invertFilesSelection"]
         Else If isImgEditingNow()
            func2Call := ["InvertSelectedArea"]
      } Else If (btnID="BTNquickFileActs")
      {
         func2Call := ["PanelQuickMoveConfigure"]
      } Else If (btnID="BTNvpGrid")
      {
         If isImgEditingNow()
         {
            If (GetKeyState("Ctrl", "P") || GetKeyState("Shift", "P"))
               func2Call := ["toggleViewPortGridu", "tlbr"]
            Else
               func2Call := (simulacrum=1) ? ["MenuIncVPgridSize"] : ["coreTlbrSlider", "VPchangeGridSize", 10, 0]
         }
      } Else If (btnID="BTNthumbsList")
      {
         If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
            func2Call := ["toggleListViewModeThumbs"]
      } Else If (btnID="BTNimgSizers")
      {
         func2Call := ["ToggleImageSizingMode"]
      } Else If (btnID="BTNzoomInIMG")
      {
         If (simulacrum=1)
            func2Call := ["MenuChangeImgZoomPlus"]
         Else
            func2Call := ["tlbrZoomINout", "zin"]
      } Else If (btnID="BTNzoomOutIMG")
      {
         If (simulacrum=1)
            func2Call := ["MenuChangeImgZoomMinus"]
         Else
            func2Call := ["tlbrZoomINout", "zout"]
      } Else If (btnID="BTNnavFirstImgu")
         func2Call := ["FirstPicture"]
      Else If (btnID="BTNnavLastImgu")
         func2Call := ["LastPicture"]
      Else If (btnID="BTNnavNextImgu")
         func2Call := ["NextPicture"]
      Else If (btnID="BTNnavPrevImgu")
         func2Call := ["PreviousPicture"]
      Else If (btnID="BTNalignVPimgu")
         func2Call := ["ToggleIMGalign"]
      Else If (btnID="BTNhudHisto")
         func2Call := ["ToggleImgHistogram", 1]
      Else If (btnID="BTNannotate")
         func2Call := ["PanelEditImgCaption"]
      Else If (btnID="BTNprivatModa")
         func2Call := ["TogglePrivateMode"]
      Else If (btnID="BTNsoundPlay")
         func2Call := ["PlayAudioFileAssociatedNow"]
      Else If (btnID="BTNjumpAtIndex")
         func2Call := ["PanelJump2index"]
      Else If (btnID="BTNprintAcquire")
         func2Call := ["PanelPrintImage"]
      Else If (btnID="BTNgoPrevPanel")
         func2Call := ["openPreviousPanel"]
      Else If (btnID="BtnReturnImgView")
         func2Call := (simulacrum=1) ? ["MenuDummyToggleThumbsMode"] : ["MenuReturnIMGedit"]
      Else If (btnID="BTNgoFileMaps")
         func2Call := ["MenuDrawFilesListMap"]
      Else If (btnID="BTNspiralLinez")
         func2Call := ["PanelDrawLines"]
   }
   Return func2Call
} ; // processToolbarFunctions()

CoreGUItoolbar(scopul:=0, whichList:=0) {
    Static prevState := 0, hasRan := 0, btnzListArray := [], hasObjectifiedList := 0
       ; , localBtnID := [ico-file-name, 0, base-user-friendly-name, 0, button-ID, 0, menu-mode, modes-availability]
         , BTNdragTlbr := ["dragger", 1, "Reposition toolbar", 0, "BTNdragTlbr", 0, 1, 1]
         , BTNrotateTlbr := ["rotate-tlbr", 0, "Toggle toolbar orientation", 0, "BTNrotateTlbr", 0, 0, 1]
         , BTNdisabled := ["disabled", 0, "-", 0, "BTNdisabled", 0, 0, 1]
         , BTNcloseTlbr := ["close", 0, "Close toolbar", 0, "BTNcloseTlbr", 0, 0, 1]
         , BTNcancelTool := ["cancel-tool", 0, "Cancel active tool", 0, "BTNcancelTool"]
         , BTNsettings := ["menu", 0, "Quick settings menu", 0, "BTNsettings", 0, 1, 1]
         , BTNcopyImg := ["copy", 0, "Copy to clipboard", 0, "BTNcopyImg", 0, 0, 1]
         , BTNnewImg := ["new-image", 0, "New image", 0, "BTNnewImg", 0, 0, 1]
         , BTNpasteImg := ["paste-clip", 0, "Paste from clipboard", 0, "BTNpasteImg", 0, 0, 1]
         , BTNundoImg := ["undo", 1, "Undo image action", 0, "BTNundoImg"]
         , BTNredoImg := ["redo", 1, "Redo image action", 0, "BTNredoImg"]
         , BTNtextTool := ["add-text", 0, "Insert text into image", 0, "BTNtextTool"]
         , BTNeraserBrush := ["eraser", 0, "Eraser brush", 0, "BTNeraserBrush"]
         , BTNdeleteTool := ["delete-file", 0, "Delete file", 0, "BTNdeleteTool", 0, 0, 1]
         , BTNblurTool := ["brush-blur", 0, "Blur brush", 0, "BTNblurTool"]
         , BTNclonerTool := ["brush-cloner", 0, "Cloner brush", 0, "BTNclonerTool"]
         , BTNbrushMtool := ["brush-main", 0, "Brush tool", 0, "BTNbrushMtool"]
         , BTNFXbrush := ["brush-fx", 0, "Color effects soft brush", 0, "BTNFXbrush"]
         , BTNwetbrush := ["brush-wet", 0, "Soft wet brush", 0, "BTNwetbrush"]
         , BTNdryout := ["brush-dry", 0, "Fry-out brush", 0, "BTNdryout"]
         , BTNpenVector := ["pen-vector", 0, "Draw freeform shape", 0, "BTNpenVector"]
         , BTNpipette := ["pipette", 0, "Pick color from the viewport", 0, "BTNpipette"]
         , BTNcolorsSwatch := ["colorz-swatch", 0, "Primary / secondary colors", 0, "BTNcolorsSwatch"]
         , BTNalphCapture := ["alpha-mask-capture", 0, "Capture alpha mask", 0, "BTNalphCapture"]
         , BTNalphInvert := ["alpha-mask-invert", 0, "Invert alpha mask", 0, "BTNalphInvert"]
         , BTNalphRaster := ["alpha-mask-pixelize", 0, "Rasterize alpha mask", 0, "BTNalphRaster"]
         , BTNalphPaint := ["alpha-mask-paint", 0, "Paint alpha mask", 0, "BTNalphPaint"]
         , BTNalphPanel := ["alpha-mask-panel", 0, "Alpha mask options panel", 0, "BTNalphPanel"]
         , BTNalphView := ["alpha-mask-view", 0, "View alpha mask", 0, "BTNalphView"]
         , BTNalphDiscard := ["alpha-mask-discard", 0, "Discard alpha mask", 0, "BTNalphDiscard"]
         , BTNcrop := ["crop", 0, "Resize or crop image", 0, "BTNcrop", 0, 0, 1]
         , BTNsave := ["save-disk", 0, "Save image or files list", 0, "BTNsave", 0, 0, 1]
         , BTNopen := ["open", 0, "Open image or files list", 0, "BTNopen", 0, 1, 1]
         , BTNcutImg := ["cut", 0, "Cut image selection or file(s)", 0, "BTNcutImg", 0, 0, 1]
         , BTNadjustColors := ["adjust-colors", 0, "Adjust viewport colors", 0, "BTNadjustColors", 0, 0, 1]
         , BTNtlbrflipH := ["flip-h", 0, "Flip horizontally", 0, "BTNtlbrflipH", 0, 0, 1]
         , BTNtlbrflipV := ["flip-v", 0, "Flip vertically", 0, "BTNtlbrflipV", 0, 0, 1]
         , BTNtransformArea := ["transform-img", 0, "Import file or transform selected area", 0, "BTNtransformArea", 0, 0, 1]
         , BTNrotateStuff := ["rotation", 1, "Rotate image", 0, "BTNrotateStuff", 0, 0, 1]
         , BTNfillShape := ["fill-shape", 0, "Fill selection area", 0, "BTNfillShape"]
         , BTNoutlineShape := ["outline-shape", 0, "Draw shape contours", 0, "BTNoutlineShape"]
         , BTNselectShape := ["select-rect", 0, "Create or cycle selection area modes", 0, "BTNselectShape"]
         , BTNselectFileu := ["select-rect", 0, "Select / deseleect file", 0, "BTNselectFileu", 0, 0, 1]
         , BTNselectFreeform := ["create-freeform", 0, "Create freeform selection", 0, "BTNselectFreeform"]
         , BTNloupe := ["loupe", 1, "Zoom in / out", 0, "BTNloupe", 0, 0, 1]
         , BTNpreviewBox := ["view", 0, "Toggle image preview", 0, "BTNpreviewBox", 0, 0, 1]
         , BTNsearch := ["search", 0, "Search", 0, "BTNsearch"]
         , BTNmodifyEntry := ["modify-entry", 0, "Rename file(s)", 0, "BTNmodifyEntry", 0, 0, 1]
         , BTNfilterList := ["filter", 0, "Filter files list", 0, "BTNfilterList", 0, 0, 1]
         , BTNstatsList := ["statistics", 0, "Indexed files statistics", 0, "BTNstatsList", 0, 0, 1]
         , BTNsortList := ["sort-list", 0, "Sort files list", 0, "BTNsortList", 0, 1, 1]
         , BTNrefreshList := ["refresh", 0, "Refresh files list", 0, "BTNrefreshList", 0, 0, 1]
         , BTNfolderTree := ["folder-tree", 0, "Folder tree view", 0, "BTNfolderTree", 0, 0, 1]
         , BTNrecentOpened := ["recent", 0, "Recents menu", 0, "BTNrecentOpened", 0, 1, 1]
         , BTNinfozHud := ["infos", 0, "Show image information", 0, "BTNinfozHud", 0, 0, 1]
         , BTNmngFolderz := ["manage-folders", 0, "Manage folders", 0, "BTNmngFolderz", 0, 0, 1]
         , BTNfntSize := ["font-size", 0, "Change OSD font size", 0, "BTNfntSize", 0, 0, 1]
         , BTNfaves := ["star", 0, "Add / remove from favourites", 0, "BTNfaves", 0, 1, 1]
         , BTNpanImg := ["pan-img", 1, "Pan image in viewport", 0, "BTNpanImg"]
         , BTNmainTooler := ["apply-tool", 0, "Apply current tool", 0, "BTNmainTooler"]
         , BTNplaySlides := ["play", 0, "Play slideshow", 0, "BTNplaySlides", 0, 0, 1]
         , BTNchangeBrushSoft := ["brush-set-soft", 0, "Change brush softness", 0, "BTNchangeBrushSoft"]
         , BTNchangeBrushOpacity := ["brush-set-opacity", 0, "Change brush opacity", 0, "BTNchangeBrushOpacity"]
         , BTNchangeBrushSize := ["brush-set-size", 0, "Change brush size", 0, "BTNchangeBrushSize"]
         , BTNchangeBrushAngle := ["brush-set-angle", 0, "Set brush angle", 0, "BTNchangeBrushAngle"]
         , BTNchangeBrushRatio := ["brush-set-ratio", 0, "Set brush ratio", 0, "BTNchangeBrushRatio"]
         , BTNvectSmooth := ["vector-smooth", 0, "Cycle path smoothness", 0, "BTNvectSmooth"]
         , BTNvectRemLast := ["vector-rem-last", 0, "Remove last point in path", 0, "BTNvectRemLast"]
         , BTNvectRemPoints := ["vector-rem-points", 0, "Remove selected points in path", 0, "BTNvectRemPoints"]
         , BTNvectSelInvert := ["vector-select-invert", 0, "Invert selected points in path", 0, "BTNvectSelInvert"]
         , BTNvectOpenPath := ["vector-open-path", 0, "Toggle opened path", 0, "BTNvectOpenPath"]
         , BTNvectSymAnchr := ["vector-symmetrical-anchors", 0, "Toggle symmetrical anchors", 0, "BTNvectSymAnchr"]
         , BTNvectTmodes := ["vector-mode-mixed", 0, "Cycle vector tool modes", 0, "BTNvectTmodes"]
         , BTNfloodFill := ["flood-fill", 0, "Flood fill", 0, "BTNfloodFill"]
         , BTNvectSelAll := ["vector-select-all", 0, "Select all points in path", 0, "BTNvectSelAll"]
         , BTNalignSel := ["select-align", 0, "Align selection area", 0, "BTNalignSel", 0, 1]
         , BTNinvertStuff := ["invert", 0, "Invert image or file selection", 0, "BTNinvertStuff", 0, 0, 1]
         , BTNhelp := ["help", 0, "Help", 0, "BTNhelp", 0, 0, 1]
         , BTNpaintSelection := ["paint-outside", 0, "Toggle brush selection area mode", 0, "BTNpaintSelection"]
         , BTNcalculate := ["calculate", 0, "Calculate file sizes", 0, "BTNcalculate", 0, 0, 2]
         , BTNquickFileActs := ["quick-file-acts", 0, "Quick file actions", 0, "BTNquickFileActs", 0, 0, 1]
         , BTNvpGrid := ["vp-grid", 1, "Viewport grid", 0, "BTNvpGrid"]
         , BTNthumbsList := ["thumbs-list", 0, "Cycle list view modes", 0, "BTNthumbsList", 0, 0, 2]
         , BTNimgSizers := ["img-sizing", 0, "Cycle image adapt modes", 0, "BTNimgSizers", 0, 0, 1]
         , BTNzoomInIMG := ["zoom-in", 1, "Zoom in", 0, "BTNzoomInIMG", 0, 0, 1]
         , BTNzoomOutIMG := ["zoom-out", 1, "Zoom out", 0, "BTNzoomOutIMG", 0, 0, 1]
         , BTNnavFirstImgu := ["first", 0, "Jump to the first image in the list", 0, "BTNnavFirstImgu", 0, 0, 1]
         , BTNnavLastImgu := ["last", 0, "Jump to the last image in the list", 0, "BTNnavLastImgu", 0, 0, 1]
         , BTNnavNextImgu := ["next", 0, "Next image in the list", 0, "BTNnavNextImgu"]
         , BTNnavPrevImgu := ["previous", 0, "Previous image in the list", 0, "BTNnavPrevImgu"]
         , BTNalignVPimgu := ["vp-center-img", 0, "Toggle align image to center", 0, "BTNalignVPimgu", 0, 0, 1]
         , BTNhudHisto := ["histogram", 0, "Cycle histogram modes", 0, "BTNhudHisto"]
         , BTNannotate := ["annotate", 0, "Define image caption", 0, "BTNannotate", 0, 0, 1]
         , BTNprivatModa := ["private", 0, "Toggle private mode", 0, "BTNprivatModa", 0, 0, 1]
         , BTNsoundPlay := ["sound", 0, "Play associated sound file", 0, "BTNsoundPlay"]
         , BTNjumpAtIndex := ["jump-to", 0, "Jump at given index", 0, "BTNjumpAtIndex", 0, 0, 1]
         , BTNswitchThumbs := ["thumbs-mode", 0, "Toggle list / thumbnails mode", 0, "BTNswitchThumbs", 0, 0, 1]
         , BTNprintAcquire := ["print", 0, "Print/acquire image", 0, "BTNprintAcquire", 0, 0, 1]
         , BTNgoPrevPanel := ["go-back", 0, "Open previous panel", 0, "BTNgoPrevPanel", 0, 0, 1]
         , BtnReturnImgView := ["go-back", 0, "Return to image view", 0, "BtnReturnImgView", 0, 0, 2]
         , BTNgoFileMaps := ["files-map", 0, "Show files map", 0, "BTNgoFileMaps", 0, 0, 2]
         , BTNspiralLinez := ["spiral", 0, "Draw parametric lines", 0, "BTNspiralLinez"]
         , btnzList := "BTNrotateTlbr,BTNcloseTlbr,BTNsettings,BTNcopyImg,BTNnewImg,BTNpasteImg,BTNundoImg,BTNredoImg,BTNtextTool,BTNeraserBrush,BTNdeleteTool,BTNblurTool,BTNclonerTool,BTNbrushMtool,BTNFXbrush,BTNwetbrush,BTNpenVector,BTNpipette,BTNcolorsSwatch,BTNalphInvert,BTNalphRaster,BTNalphCapture,BTNalphPanel,BTNalphView,BTNalphDiscard,BTNcrop,BTNsave,BTNopen,BTNcutImg,BTNadjustColors,BTNtlbrflipH,BTNtlbrflipV,BTNtransformArea,BTNrotateStuff,BTNfillShape,BTNoutlineShape,BTNselectShape,BTNselectFreeform,BTNloupe,BTNpreviewBox,BTNsearch,BTNmodifyEntry,BTNfilterList,BTNstatsList,BTNsortList,BTNrefreshList,BTNfolderTree,BTNrecentOpened,BTNinfozHud,BTNmngFolderz,BTNfntSize,BTNfaves,BTNpanImg,BTNgoPrevPanel,BTNplaySlides,BTNvectSmooth,BTNalignSel,BTNhelp,BTNfloodFill,BTNcalculate,BTNinvertStuff,BTNquickFileActs,BTNvpGrid,BTNthumbsList,BTNimgSizers,BTNzoomInIMG,BTNzoomOutIMG,BTNnavFirstImgu,BTNnavLastImgu,BTNnavNextImgu,BTNnavPrevImgu,BTNalignVPimgu,BTNhudHisto,BTNannotate,BTNprivatModa,BTNsoundPlay,BTNjumpAtIndex,BTNswitchThumbs,BTNprintAcquire,BTNgoFileMaps,BTNspiralLinez,BTNselectFileu,BtnReturnImgView"

    If !hasObjectifiedList
    {
       hasObjectifiedList := 1
       Loop, Parse, btnzList,`,
       {
          pk := Trimmer(A_LoopField)
          If pk
          {
             btnzListArray[pk] := A_Index
             btnzListArray[A_Index] := pk
          }
       }
    }

    If (scopul="getListArray")
    {
       Return btnzListArray
    } Else If (scopul="getCustomList")
    {
       l := (whichList=1) ? userThumbsToolbarList : userImgViewToolbarList
       If !l
       {
          Loop, % tlbrIconzList["counter"]
             l .= tlbrIconzList[A_Index, 10] ","
       }

       listu := ""
       Loop, Parse, l,`,
       {
          pk := Trimmer(A_LoopField)
          If (pk && btnzListArray[pk]>0)
          {
             pka := %pk%
             listu .= pka[3] " [" btnzListArray[pk] "]|"
          }
       }
       Return listu
    } Else If (scopul="getBtnList")
    {
       ; modes-availability
       ; btnOobj[8]=1   //   for thumbs mode and img-view mode
       ; btnOobj[8]=2   //   for thumbs mode only
       ; btnOobj[8]=""  //   for img-view mode only

       listu := ""
       Loop, % btnzListArray.Count()
       {
             thisa := btnzListArray[A_Index]
             If !thisa
                Continue

             thisu := %thisa%
             ; fnOutputDebug(A_Index " p=" thisu[3] "==" thisu[8])
             If ((thumbsDisplaying=1 && (thisu[8]=1 || thisu[8]=2)) || (thumbsDisplaying!=1 && thisu[8]!=2))
                listu .= thisu[3] " [" A_Index "]|"
       }
       Return listu
    }

    tlbrIconzList["counter"] := 0
    BTNmainTooler[1] := (AnyWindowOpen && imgEditPanelOpened=1 || drawingShapeNow=1) ? "apply-tool" : "go-back"
    If isVarEqualTo(AnyWindowOpen, 10, 64, 66, 70)
       BTNmainTooler[1] := "main-tool"
    If (drawingShapeNow=1)
       BTNvectTmodes[1] := "vector-mode-" defineVectToolMode()

    icoFile := (BrushToolOutsideSelection=1) ? "paint-any" : "paint-inside"
    If (BrushToolOutsideSelection=3)
       icoFile := "paint-outside"
    BTNpaintSelection[1] := icoFile

    icoFile := (EllipseSelectMode=1) ? "select-ellipse" : "select-rect"
    If (thumbsDisplaying=1)
       icoFile := "select-rect"
    Else If (EllipseSelectMode=2)
       icoFile := "select-freeform"
    BTNselectShape[1] := icoFile

    If (thumbsListViewMode=1)
       friendly := "thumbs-list"
    Else If (thumbsListViewMode=2)
       friendly := "files-list-simple"
    Else If (thumbsListViewMode>=3)
      friendly := "files-list-details"
    BTNthumbsList[1] := friendly

    TlbrGuiMarginH := ToolBarBtnWidth//5
    TlbrGuiMarginV := TlbrGuiMarginH
    IconSpacing := (TLBRverticalAlign=1) ? TlbrGuiMarginH//3 : TlbrGuiMarginH//3
    handleWidth := (TLBRverticalAlign=1) ? ToolBarBtnWidth + IconSpacing*2 : ToolBarBtnWidth//2
    handleHeight := (TLBRverticalAlign=1) ? ToolBarBtnWidth//3 : ToolBarBtnWidth + IconSpacing*2
    handleClrW := (TLBRverticalAlign=1) ? ToolBarBtnWidth + IconSpacing*2 : ToolBarBtnWidth
    handleClrH := (TLBRverticalAlign=1) ? ToolBarBtnWidth : ToolBarBtnWidth + IconSpacing*2
    draggyHeight := handleHeight
    If (TLBRtwoColumns=1 && !isWelcomeScreenu)
    {
       handleWidth := handleWidth*2 - IconSpacing*2
       handleClrW := handleWidth - IconSpacing*2
       handleClrH += IconSpacing
       handleHeight := Round(handleHeight*1.5)
    } Else If (TLBRverticalAlign!=1)
    {
       handleClrW := handleClrW*2 + IconSpacing*3
    } Else If (TLBRverticalAlign=1)
       handleClrH := handleClrH - Ceil(IconSpacing*2.5)

    dksu := isImgEditingNow()
    isVectorMode := (drawingShapeNow=1 && editingSelectionNow=1 && EllipseSelectMode=2) ? 1 : 0
    ; ToolTip, % drawingShapeNow "|" editingSelectionNow "|" EllipseSelectMode "| v=" isVectorMode , , , 2
    isWelcomeScreenu := (dksu=1 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
    isTransPanel := (dksu=1 && (AnyWindowOpen=31 || AnyWindowOpen=24)) ? 1 : 0
    tlbrTotalIconz := (isTransPanel=1) ? 24 : 36
    If isWelcomeScreenu
       tlbrTotalIconz := 9
    Else If isTlbrViewModus()
       tlbrTotalIconz := 21 ; arbitrary number

    sjk := isTlbrViewModus(1)
    If sjk ; must go for user customized list
       listuIcons := (thumbsDisplaying=1) ? StrSplit(userThumbsToolbarList, ",") : StrSplit(userImgViewToolbarList, ",")

    TouchToolbarGUIcreated := 1
    thisState := "a" toolbarViewerMode userCustomizedToolbar Round(listuIcons.Count()) userThumbsToolbarList userImgViewToolbarList ToolBarBtnWidth tlbrTotalIconz TLBRverticalAlign ToolbarScaleFactor TLBRtwoColumns drawingShapeNow ToolbarBgrColor
    simpleRefresh := (thisState=prevState) ? 1 : 0
    If (scopul=1)
       simpleRefresh := 0

    If (simpleRefresh=0)
    {
       If !hasRan
       {
          ; hack required to fix window redraw issues
          Gui, dummyGuia: Default
          Gui, dummyGuia: -DPIScale -MaximizeBox -MinimizeBox +Owner%PVhwnd% +ToolWindow +E0x20 
          hasRan := 1
       }
       If !AnyWindowOpen
          trackImageListButtons("kill")

       Gui, OSDguiToolbar: Destroy
       Sleep, 15
       Gui, OSDguiToolbar: Default
       Gui, OSDguiToolbar: Margin, 0, 0
       Gui, OSDguiToolbar: -DPIScale -Caption -MinimizeBox -MaximizeBox +ToolWindow +hwndhQPVtoolbar +Owner%PVhwnd%
       Gui, OSDguiToolbar: Color, % ToolbarBgrColor, % ToolbarBgrColor
    }

    ; Gui, OSDguiToolbar: Font, s1
    tlbrAddNewIcon(BTNdragTlbr, handleWidth, draggyHeight, 0, 1, simpleRefresh)
    If (listuIcons.Count()>1 && sjk=1)
    {
       ; user customized list; only for thumbs list and image view modes
       Loop, % listuIcons.Count()
       {
           thisu := Trimmer(listuIcons[A_Index])
           thisu := %thisu%
           If IsObject(thisu)
           {
             If ((thumbsDisplaying=1 && (thisu[8]=1 || thisu[8]=2)) || (thumbsDisplaying!=1 && thisu[8]!=2))
                tlbrAddNewIcon(thisu, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
           }
       }
    } Else If (tlbrTotalIconz=21)
    {
       ; simple mode toolbar
       Static simpleThumbs := "BTNsettings|BtnReturnImgView|BTNopen|BTNsave|BTNcutImg|BTNcopyImg|BTNpasteImg|BTNnewImg|BTNfaves|BTNdeleteTool|BTNthumbsList|BTNselectShape|BTNsearch|BTNmodifyEntry|BTNsortList|BTNrefreshList|BTNfolderTree|BTNcalculate|BTNinfozHud|BTNpreviewBox"
       Static simpleView := "BTNsettings|BTNswitchThumbs|BTNopen|BTNcopyImg|BTNfaves|BTNplaySlides|BTNnavPrevImgu|BTNnavNextImgu|BTNnavFirstImgu|BTNnavLastImgu|BTNzoomOutIMG|BTNzoomInIMG|BTNrotateStuff|BTNalignVPimgu|BTNtlbrflipV|BTNtlbrflipH|BTNimgSizers|BTNadjustColors|BTNinfozHud|BTNdeleteTool"
       listu := (thumbsDisplaying=1) ? simpleThumbs : simpleView
       Loop, Parse, listu,|
       {
             If !A_LoopField
                Continue

             thisu := %A_loopField%
             If IsObject(thisu)
                tlbrAddNewIcon(thisu, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       }
    } Else
    {
       ; advanced toolbar mode [thumbs list, image view and live edit mode]
       tlbrAddNewIcon(BTNsettings, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       thisu := (thumbsDisplaying!=1 && !AnyWindowOpen) ? BTNswitchThumbs : BtnReturnImgView
       If (AnyWindowOpen || drawingShapeNow=1)
          thisu := BTNmainTooler

       tlbrAddNewIcon(thisu, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       If (thumbsDisplaying=1)
       {
          tlbrAddNewIcon(BTNplaySlides, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNthumbsList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       } Else If !isWelcomeScreenu
       {
          If (isVectorMode=1)
          {
             tlbrAddNewIcon(BTNpreviewBox, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNcancelTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }
          tlbrAddNewIcon(BTNundoImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNredoImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       }

       If (isVectorMode=1)
       {
          tlbrAddNewIcon(BTNvectSymAnchr, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNvectTmodes, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNvectSmooth, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNvectRemLast, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNvectRemPoints, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNvectSelInvert, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNvectOpenPath, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          tlbrAddNewIcon(BTNvectSelAll, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       } Else
       {
          addAlphaIcons := (isAlphaMaskPartialWin()=1 || isAlphaMaskWindow()=1) ? 1 : 0
          If (addAlphaIcons=1 && !isNowAlphaPainting())
          {
             tlbrAddNewIcon(BTNalphCapture, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNalphDiscard, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNalphInvert, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             If isAlphaMaskPartialWin()
                tlbrAddNewIcon(BTNalphPanel, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             Else
                tlbrAddNewIcon(BTNalphPaint, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)

             tlbrAddNewIcon(BTNalphView, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             If (AnyWindowOpen=66)
                tlbrAddNewIcon(BTNpaintSelection, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             Else
                tlbrAddNewIcon(BTNalphRaster, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          } Else If (AnyWindowOpen=64 || isNowAlphaPainting())
          {
             tlbrAddNewIcon(BTNchangeBrushSoft, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNchangeBrushOpacity, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNchangeBrushSize, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNchangeBrushAngle, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNchangeBrushRatio, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             If isNowAlphaPainting()
                tlbrAddNewIcon(BTNalphView, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             Else
                tlbrAddNewIcon(BTNpaintSelection, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          } Else
          {
             tlbrAddNewIcon(BTNopen, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             If !isWelcomeScreenu
             {
                tlbrAddNewIcon(BTNsave, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNcutImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNcopyImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             }
             tlbrAddNewIcon(BTNpasteImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNnewImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }
          If (AnyWindowOpen=66) ; flood fill opacity
             tlbrAddNewIcon(BTNchangeBrushOpacity, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          Else If (AnyWindowOpen=64 || isNowAlphaPainting())
             tlbrAddNewIcon(BTNdryout, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          Else If isVarEqualTo(AnyWindowOpen, 23, 25, 30, 32, 55, 65, 68, 74)
             tlbrAddNewIcon(BTNalignSel, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          Else If !isWelcomeScreenu
             tlbrAddNewIcon(BTNcrop, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)

          If !isWelcomeScreenu
             tlbrAddNewIcon(BTNselectShape, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)

          If (thumbsDisplaying!=1 && !isWelcomeScreenu)
          {
             If (isTransPanel!=1)
             {
                tlbrAddNewIcon(BTNselectFreeform, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNfillShape, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNoutlineShape, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNpipette, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNbrushMtool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNFXbrush, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNwetbrush, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNblurTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNclonerTool, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             }
          } Else
          {
             tlbrAddNewIcon(BTNfaves, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             If !isWelcomeScreenu
             {
                tlbrAddNewIcon(BTNmngFolderz, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNsearch, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNmodifyEntry, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNfilterList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNstatsList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNsortList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNrefreshList, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             }

             If isWelcomeScreenu
                tlbrAddNewIcon(BTNrecentOpened, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             Else
                tlbrAddNewIcon(BTNfolderTree, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }

          thisu := (thumbsDisplaying=1) ? BTNdeleteTool : BTNeraserBrush
          If !isWelcomeScreenu
             tlbrAddNewIcon(thisu, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)

          If (thumbsDisplaying=1)
          {
             tlbrAddNewIcon(BTNinfozHud, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNcalculate, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNquickFileActs, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          } Else If !isWelcomeScreenu
          {
             If (isTransPanel!=1)
             {
                tlbrAddNewIcon(BTNpenVector, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
                tlbrAddNewIcon(BTNfloodFill, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             }

             If isNowAlphaPainting()
                tlbrAddNewIcon(BTNalphInvert, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             Else If (isTransPanel=1)
                tlbrAddNewIcon(BTNalignSel, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             Else
                tlbrAddNewIcon(BTNinvertStuff, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }

          thisu:= (thumbsDisplaying=1) ? BTNannotate : BTNtextTool
          If (isTransPanel!=1 && !isWelcomeScreenu)
             tlbrAddNewIcon(thisu, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
       }

       If !isWelcomeScreenu
       {
          tlbrAddNewIcon(BTNtlbrflipV, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          If !isVectorMode
          {
             tlbrAddNewIcon(BTNtlbrflipH, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNtransformArea, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNrotateStuff, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNadjustColors, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }

          tlbrAddNewIcon(BTNloupe, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          If (thumbsDisplaying=1)
          {
             tlbrAddNewIcon(BTNfntSize, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNpreviewBox, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          } Else
          {
             tlbrAddNewIcon(BTNvpGrid, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
             tlbrAddNewIcon(BTNpanImg, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
          }
       }

       If (!isWelcomeScreenu && !isVectorMode)
          tlbrAddNewIcon(BTNcolorsSwatch, handleClrW, handleClrH, 0, 0, simpleRefresh)
       Else If !isVectorMode
          tlbrAddNewIcon(BtnHelp, ToolBarBtnWidth, ToolBarBtnWidth, IconSpacing, 0, simpleRefresh)
    }

    ; tlbrAddNewIcon(BTNrotateTlbr, handleWidth, handleHeight, 0)
    tX := Round(UserToolbarX),    tY := Round(UserToolbarY)
    todisplay := (ShowAdvToolbar=1) ? "" : "hide"
    prevState := thisState
    If (simpleRefresh=0)
       Gui, OSDguiToolbar: Show, x%tX% y%tY% AutoSize NoActivate, QPV toolbar
}

GuiSlidersResponder(a, m_event, keyu) {
   Static lastInvoked := 1

   hwnd := (m_event="uiLabel") ? a : "0x" Format("{:x}", a)
   GetMouseCoord2wind(hwnd, nX, nY)
   whichSlider := uiSlidersArray[hwnd]
   ; winHwnd := WinActive("A")
   ; whichCursor := uiSlidersArray[hwnd ":" winHwnd]

   givenVar := whichSlider
   If InStr(givenVar, "@")
      givenVar := StrReplace(givenVar, "@")

   funcu := uiSlidersArray[whichSlider, 6]
   maxV := uiSlidersArray[whichSlider, 3]
   minV := uiSlidersArray[whichSlider, 2]
   rangeu := maxV - minV
   guiu := uiSlidersArray[whichSlider, 11]
   w := uiSlidersArray[whichSlider, 12]
   h := uiSlidersArray[whichSlider, 13]
   If (!w || !h)
   {
      WinGetPos, , , w, h, ahk_id %hwnd%
      uiSlidersArray[whichSlider, 12] := w
      uiSlidersArray[whichSlider, 13] := h
   }

   GuiControl, %guiu%:Focus , % "customSliders" whichSlider
   ; ToolTip, % guiu "|" whichSlider , , , 2
   prevu := uiSlidersArray["focused"]
   newu := "customSliders" whichSlider
   updatePrevu := (InStr(prevu, "customSliders") && prevu!=newu) ? 1 : 0
   uiSlidersArray["focused"] := newu
   isActive := uiSlidersArray[whichSlider, 10]
   varValue := %givenVar%
   odefVal := uiSlidersArray[whichSlider, 4]  ; default value
   defVal := StrReplace(odefVal, "f")
   doFloat := InStr(odefVal, "f") ? 1 : 0
   ; fnOutputDebug(isActive "|" A_ThisFunc "(): a=" a "|" hwnd "|" m_event "|" givenVar "|" varValue "|" keyu)
   If (InStr(whichSlider, "angle") && defVal=0 && (varValue=0 || (A_TickCount - lastInvoked<850)))
      defVal := 90

   If (m_event="uiLabel" && isActive=1)
   {
      ; if m_event = "uiLabel" , it is a keyboard call
      frkA := (doFloat=1) ? 0.025 : 1
      frkB := (doFloat=1) ? 0.050 : 5
      If (rangeu>100)
      {
         frkA *= 2, frkB *= 2
      }

      If (varValue<21 && doFloat!=1)
      {
         frkA := 1, frkB := 2
      } Else If (varValue<51 && doFloat!=1)
      {
         frkA := 2, frkB := 4
      } Else If (rangeu>5000)
      {
         frkA *= 150, frkB *= 250
      } Else If (rangeu>500)
      {
         frkA *= 5, frkB *= 10
      }

      isGivenKey := 0
      If (keyu="WheelUp")
         %givenVar% := clampInRange(%givenVar% + frkA, minV, maxV, 1)
      Else If (keyu="WheelDown")
         %givenVar% := clampInRange(%givenVar% - frkA, minV, maxV, 1)
      Else If (keyu="end")
         %givenVar% := maxV
      Else If (keyu="home")
         %givenVar% := minV
      Else If (keyu="BackSpace" || keyu="Delete")
         %givenVar% := defVal
      Else 
         isGivenKey := 1

      Sleep, 1
   } Else If (m_event="DoubleClick" && isActive=1)
   {
      keyu := 0
      lastInvoked := A_TickCount
      %givenVar% := defVal
   } Else If (GetKeyState("Ctrl", "P")=1 && isActive=1)
   {
      keyu := 0
      m_event := "uiLabel"
      %givenVar% := PanelAskSliderValue(whichSlider, minV, maxV, varValue, defVal, uiSlidersArray[whichSlider, 5])
      If InStr(whichSlider, "@")
      {
         %funcu%(SubStr(whichSlider, 2), "given")
         Return
      }
   } Else keyu := 0

   setWhileLoopExec(1)
   obju := []
   fsizeu := (PrefsLargeFonts=1) ? LargeUIfontValue - 3 : LargeUIfontValue - 7
   txtColor := (uiUseDarkMode=1) ? "FFffFF" : "000000"
   thisOpacity := (isActive=1) ? "0xEF" : "0x99"
   hFontFamily := Gdip_FontFamilyCreateGeneric(1)
   obju.pBitmap := trGdip_CreateBitmap(A_ThisFunc, w, h)
   obju.hFont := Gdip_FontCreate(hFontFamily, fsizeu, PrefsLargeFonts, 3)
   obju.hStringFormat := Gdip_StringFormatGetGeneric(1)
   obju.pBrush := Gdip_BrushCreateSolid(thisOpacity txtColor)
   obju.G := Gdip_GraphicsFromImage(obju.pBitmap)
   Gdip_SetStringFormatAlign(obju.hStringFormat, 1, 1)     ; center
   If (updatePrevu=1)
      GuiUpdateSliders(StrReplace(prevu, "customSliders"), 0)

   lastu := 1
   zx := zy := skipped := 0
   mouseMode := determineLClickState()
   isGivenKey := (keyu && mouseMode!=1 && isGivenKey=1 && isActive=1) ? 1 : 0
   clickStarted := A_TickCount
   occ := A_IsCritical
   Critical, off
   tinyPreview := isVarEqualTo(AnyWindowOpen, 26, 43, 44, 64, 69, 78, 79)
   While, (determineLClickState()=1 || m_event="uiLabel" && A_Index=1 || GetKeyState(keyu, "P") && isGivenKey=1)
   {
      ; if m_event = "uiLabel" , it is a keyboard call
      GetPhysicalCursorPos(mX, mY)
      If (isGivenKey!=1 && mouseMode=1)
      {
         If (isInRange(mX, zX - 2, zX + 2) && isInRange(mY, zY - 2, zY + 2) && A_Index>1)
            Continue
      }

      GetMouseCoord2wind(hwnd, nX, nY)
      Sleep, -1
      zX := mX, zY := mY
      sk := (A_Index=1 && (m_event="DoubleClick" || m_event="uiLabel") || isActive!=1) ? 1 : 0
      If (isGivenKey=1)
      {
         If (A_TickCount - clickStarted>4000)
         {
            Sleep, 25
            If !InStr(uiSlidersArray[hwnd], "@")
               GuiControl, SettingsGUIA: Focus, customSliders%whichSlider%
         }
         Else
            Sleep, % (A_TickCount - clickStarted>2000) ? 50 : 100

         If (keyu="right" || keyu="WheelUp")
            %givenVar% := clampInRange(%givenVar% + frkA, minV, maxV, 1)
         Else If (keyu="left" || keyu="WheelDown")
            %givenVar% := clampInRange(%givenVar% - frkA, minV, maxV, 1)
         Else If (keyu="PgUp")
            %givenVar% := clampInRange(%givenVar% + frkB, minV, maxV, 1)
         Else If (keyu="PgDn")
            %givenVar% := clampInRange(%givenVar% - frkB, minV, maxV, 1)
      } Else If (doFloat=1)
         newValue := clampInRange( Round( (nX / w) * rangeu + minV, 3) , minV, maxV)
      Else
         newValue := clampInRange( Round( (nX / w) * rangeu + minV) , minV, maxV)

      If (!sk && !isGivenKey)
         %givenVar% := newValue
      ; ToolTip, % wx "|" w "|" rangeu "|" newValue , , , 2
      If (whichSlider="userUIshapeCavity")
      {
         If (newValue<2)
            innerSelectionCavityX := innerSelectionCavityY := 0
         Else
            innerSelectionCavityX := innerSelectionCavityY := clampInRange(newValue/400, 0, 0.99)
      }

      If (A_TickCount - lastu>50)
      {
         p := GuiUpdateSliders(whichSlider, 0, obju)
         If (AnyWindowOpen=10 || AnyWindowOpen=74)
            livePreviewColorsAdjustVP()
         Else If (imgEditPanelOpened=1)
            livePreviewsImageEditing()
         Else If (tinyPreview=1)
            coreUpdateLiveTinyPreviewsWindow()
         Else
            %funcu%()

         lastu := A_TickCount
         skipped := 0
      } Else skipped++

      If (sk && !isGivenKey)
         Break

      If (A_TickCount - clickStarted>9500)
      {
         SoundBeep 900, 100
         skipped := 1
         Break
      }
   }

   If (isGivenKey && !InStr(uiSlidersArray[hwnd], "@"))
   {
      Sleep, 100
      GuiControl, SettingsGUIA: Focus, customSliders%whichSlider%
   }

   Sleep, -1
   Critical, % occ
   GuiUpdateSliderCtrlHiddenLabel(hwnd, whichSlider)
   p := GuiUpdateSliders(whichSlider, 0, obju)
   %funcu%()
   If InStr(uiSlidersArray[hwnd], "@")
   {
      thisuv := uiSlidersArray[hwnd] ; StrReplace(whichSlider, "@")
      If (uiSlidersArray[whichSlider, 6]="dummy")
         GuiUpdateSliderCtrlHiddenLabel(hwnd, thisuv)
   }

   Gdip_DeleteGraphics(obju.G)
   Gdip_DeleteStringFormat(obju.hStringFormat)
   Gdip_DeleteFont(obju.hFont)
   Gdip_DeleteFontFamily(hFontFamily)
   Gdip_DeleteBrush(obju.pBrush)
   trGdip_DisposeImage(obju.pBitmap)
   setWhileLoopExec(0)
   If (isGivenKey && !InStr(uiSlidersArray[hwnd], "@"))
   {
      ; force refocus
      Sleep, 10
      GuiControl, SettingsGUIA: Focus, customSliders%whichSlider%
   }
   ; ToolTip, % b "==" a "\w=" w "/" givenVar "|nX=" nX "|r=" rangeu , , , 2
}

GuiSetSliderProperties(givenVar, varMin, varMax, varDefault, uiLabel, fillMode:=0) {
    uiSlidersArray[givenVar, 2] := varMin
    uiSlidersArray[givenVar, 3] := varMax
    uiSlidersArray[givenVar, 4] := varDefault
    If (uiSlidersArray[givenVar, 5]!=uiLabel)
       %givenVar% := varDefault

    uiSlidersArray[givenVar, 5] := uiLabel
    If fillMode
       uiSlidersArray[givenVar, 7] := fillMode
}

GuiAddSlider(givenVar, varMin, varMax, varDefault, uiLabel, func2exec, fillMode, coords, infoLine:=0, isActive:=1, guiu:=0) {
; a) uiLabel can take these types of labels:
;    1. "Simple label" -> "Simple label: x%" // x% is added
;    2. "Label with slider value: $€ unit" -> $€ is replaced with givenVar/slider value
;    3. "|Static label" -> No change. Only the pipe is removed
;    3. ".func2callLabel" -> The string or value returned by function() is displayed as the slider label
;    4. "!Label text|varName" -> varName is replaced with its value and the !| symbols removed

; b) fillMode
;    1. progress bar
;    2. centered progress bar around 0
;    3. simple knob
;    4. range slider, two knobs [ to-do todo ]

    Global
    If !guiu
    {
       guiu := "SettingsGUIA"
       hwndGuiu := hSetWinGui
    } Else
    {
       p := StrSplit(guiu, ":")
       guiu := p[1]
       hwndGuiu := p[2]
    }

    If (!givenVar || !uiLabel || !func2exec || !InStr(coords, " w") || !InStr(coords, " h"))
    {
       Msgbox, Error. GuiAddSlider(). Incorrect parameters.
       Return
    }

    vlbl := "customSliders" givenVar 
    nvlbl := "customLblSliders" givenVar  ; for windows narrator
    ha := (PrefsLargeFonts=1) ? 28 : 19
    ; Gui, %guiu%: Add, Text, %coords% h%ha% v%nvlbl% +BackgroundTrans, Slider: %uiLabel%. Min: %varMin%. Max: %varMax%.
    Gui, %guiu%: Add, Text, %coords% h%ha% v%nvlbl% +0x200 Center +BackgroundTrans -wrap, Slider: %uiLabel%. Min: %varMin%. Max: %varMax%.
    Gui, %guiu%: Add, Text, xp yp wp hp -Border +0xE +TabStop gGuiSlidersResponder v%vlbl% +hwndhSlideTemp, Slider: %uiLabel%. Min: %varMin%. Max: %varMax%.
    GuiControl, %guiu%: Hide, % nvlbl
    If infoLine
       ToolTip2ctrl(hSlideTemp, InfoLine)

    WinGetPos, , , zpw, zph, ahk_id %hSlideTemp%
    lastUIlabel := forceRefresh := 0
    uiSlidersArray[hSlideTemp] := givenVar
    uiSlidersArray[givenVar] := [hSlideTemp, varMin, varMax, varDefault, uiLabel, func2exec, fillMode, coords, infoLine, isActive, guiu, zpw, zph, forceRefresh, lastUIlabel, hwndGuiu]
    ; uiSlidersArray[hSlideTemp ":" hwndGuiu] := givenVar
    ; uiSlidersArray[givenVar ":" hwndGuiu] := [hSlideTemp, varMin, varMax, varDefault, uiLabel, func2exec, fillMode, coords, infoLine, isActive, guiu, zpw, zph, forceRefresh, lastUIlabel, hwndGuiu]
    ; GuiUpdateSliders(givenVar, 0)
    Return hSlideTemp
}

GuiRefreshSliders(forced:=0) {
   Critical, on
   If (forced=1)
   {
      For Key, thisValue in uiSlidersArray
      {
          If (InStr(Key, "0x") || !IsObject(thisValue))
             Continue

          uiSlidersArray[Key, 14] := -1
          GuiUpdateSliders(Key, 0)
      }
      Return
   }

   For Key, thisValue in uiSlidersArray
   {
       If (InStr(Key, "0x") || !IsObject(thisValue))
          Continue

       Loop, 14
       {
           If (uiSlidersArray[Key, A_Index]!=lastSlidersPainted[Key, A_Index])
           {
              GuiUpdateSliders(Key, 0)
              uiSlidersArray[Key, 14] := 0
              lastSlidersPainted[Key] := uiSlidersArray[Key].Clone()
              Break
           }
       }
   }
}

GuiUpdateVisibilitySliders(actu, whichSlider) {
    GuiControl, % actu, customSliders%whichSlider%
    ; GuiControl, % actu, customLblSliders%whichSlider%
}

GuiUpdateSliders(whichSlider, isHwnd:=0, obju:=0) {
   whichSlider := (isHwnd=1) ? uiSlidersArray[whichSlider, 1] : whichSlider
   givenVar := whichSlider
   If InStr(givenVar, "@")
   {
      givenVar := StrReplace(givenVar, "@")
      If (uiSlidersArray[whichSlider, 6]="dummy")
         updateSibling := 1
   }

   If (uiSlidersArray[whichSlider, 1]="")
      Return

   minV := uiSlidersArray[whichSlider, 2]
   maxV := uiSlidersArray[whichSlider, 3]
   rangeu := maxV - minV
   varValue := %givenVar%
   perc := (varValue - minV) / rangeu

   hwnd := (isHwnd=1) ? whichSlider : uiSlidersArray[whichSlider, 1]
   isActive := uiSlidersArray[whichSlider, 10]
   w := uiSlidersArray[whichSlider, 12]
   h := uiSlidersArray[whichSlider, 13]
   If (!w || !h)
   {
      WinGetPos, , , w, h, ahk_id %hwnd%
      uiSlidersArray[whichSlider, 12] := w
      uiSlidersArray[whichSlider, 13] := h
   }

   ; fnOutputDebug(isHwnd "|" whichSlider "||" givenVar "||" varValue "|w|" w "|h|" h)
   if !IsObject(obju)
   {
      fsizeu := (PrefsLargeFonts=1) ? LargeUIfontValue - 3 : LargeUIfontValue - 7
      hFontFamily := Gdip_FontFamilyCreateGeneric(1)
      hFont := Gdip_FontCreate(hFontFamily, fsizeu, PrefsLargeFonts, 3)
      hStringFormat := Gdip_StringFormatGetGeneric(1)
      Gdip_SetStringFormatAlign(hStringFormat, 1, 1)     ; center
      txtColor := (uiUseDarkMode=1) ? "FFffFF" : "000000"
      thisOpacity := (isActive=1) ? "0xEF" : "0x99"
      pBitmap := trGdip_CreateBitmap(A_ThisFunc, w, h)
      pBrush := Gdip_BrushCreateSolid(thisOpacity txtColor)
      G := Gdip_GraphicsFromImage(pBitmap)
   } Else
   {
      pBitmap := obju.pBitmap
      hFont := obju.hFont
      hStringFormat := obju.hStringFormat
      pBrush := obju.pBrush
      G := obju.G
   }

   bgrColor := (uiUseDarkMode=1) ? "0xFF04171A" : "0xFFD2E4F7"
   slideColor := (uiUseDarkMode=1) ? "0xFF1E98A6" : "0xFF83D2F1"
   If !isActive
   {
      bgrColor := (uiUseDarkMode=1) ? "0xFF353535" : "0xFFE1E1E1"
      slideColor := (uiUseDarkMode=1) ? "0xFF494949" : "0xFFC8C8C8"
   }

   Gdip_GraphicsClear(G, bgrColor)
   fillMode := uiSlidersArray[whichSlider, 7]
   If (fillMode=2)
   {
      ; a progress bar centered around zero
      brr := (abs(varValue - minV)>rangeu/2) ? 1 : 0
      mvarValue := (brr=1) ? abs(varValue - minV) - rangeu/2 : abs(varValue)
      xperc := mvarValue / (rangeu / 2)
      w2 := clampInRange(Round((w/2)*xperc), 3, w - 1)
      xpu := (brr=1) ? w/2 : w/2 - w2
      Gdip_SetClipRect(G, xpu, 0, w2, h)
      If (brr!=1)
         xperc := "-" xperc
   } Else If (fillMode=3)
   {
      ; a knob
      ; ToolTip, % w2 "|" perc "|" varValue  , , , 2
      w2 := clampInRange(Round(w*perc), 3, w - 1)
      phw := h/1.4
      Gdip_SetClipRect(G, w2 - phw/4, 0, phw/2, h)
      xperc := perc
   } Else
   {
      ; a progress bar
      ; ToolTip, % w2 "|" perc "|" varValue  , , , 2
      w2 := clampInRange(Round(w*perc), 3, w - 1)
      Gdip_SetClipRect(G, 0, 0, w2, h)
      xperc := perc
   }

   Gdip_GraphicsClear(G, slideColor)
   Gdip_ResetClip(G)
   uiLabel := uiSlidersArray[whichSlider, 5]
   kpl := SubStr(uiLabel, 1, 1)
   If (kpl="!")
   {
      str := SubStr(uiLabel, 2, InStr(uiLabel, "|") - 2)
      vala := SubStr(uiLabel, InStr(uiLabel, "|") + 1)
      str .= ": " %vala%
   } Else If (kpl="|")
   {
      str := SubStr(uiLabel, 2)
   } Else If (kpl=".")
   {
      kpl := SubStr(uiLabel, 2)
      str := %kpl%()
   } Else If InStr(uiLabel, "$€")
      str :=  StrReplace(uiLabel, "$€", varValue)
   Else
      str :=  uiLabel ": " Round(xperc*100) "%"

   CreateRectF(RectF, 0, -1, w, h)
    ; ToolTip, % hFont "|" hStringFormat "|" pBrush , , , 2
   Gdip_DrawString(G, str, hFont, hStringFormat, pBrush, RectF)
   factive := isActive ? "" : "Control disabled.`n"
   If (StrReplace(uiSlidersArray["focused"], "customSliders")=whichSlider) ; isFocused
   {
      penu := Gdip_CreatePenFromBrush(pBrush, 2)
      Gdip_DrawRectangle(G, penu, 0, 0, w, h)
      Gdip_DeletePen(penu)
      fkbd := "`nControl has keyboard focus."
   }

   uiSlidersArray[whichSlider, 15] := str ".`n" factive "Slider range: " minV " to " maxV "." fkbd
   If !IsObject(obju)
   {
      fn := Func("GuiUpdateSliderCtrlHiddenLabel").Bind(hwnd, whichSlider)
      SetTimer, % fn, -150
   }

   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, pBitmap)
   SetImage(hwnd, hBitmap)
   DeleteObject(hBitmap)
   if !IsObject(obju)
   {
      Gdip_DeleteGraphics(G)
      Gdip_DeleteStringFormat(hStringFormat)
      Gdip_DeleteFontFamily(hFontFamily)
      Gdip_DeleteFont(hFont)
      Gdip_DeleteBrush(pBrush)
      trGdip_DisposeImage(pBitmap)
   }

   If (updateSibling=1)
      GuiUpdateSliders(givenVar, 0, obju)
}

GuiUpdateSliderCtrlHiddenLabel(hwnd, whichSlider) {
   Critical, off
   Static lastInvoked := 1 , prevu := 0
   msgu := uiSlidersArray[whichSlider, 15]
   If (!msgu || !AnyWindowOpen)
   {
      prevu := 0
      Return
   }

   thisu := "a" hwnd whichSlider msgu
   If (thisu=prevu && (A_TickCount - lastInvoked<300))
      Return

   lastInvoked := A_TickCount
   WinSet, Style,-0x0E, ahk_id %hwnd%
   guiu := InStr(whichSlider, "@") ? "SoloSliderWidgetGUIA" : "SettingsGUIA"
   GuiControl, %guiu%:, customLblSliders%whichSlider%, % msgu
   GuiControl, %guiu%:, customSliders%whichSlider%, % msgu
   ; ControlSetText , , % msgu, ahk_id %hwnd%
   WinSet, Style,+0x0E, ahk_id %hwnd%
   prevu := thisu
   Sleep, 1
}

GuiUpdateFocusedSliders(modus:=0) {
   If !(uiSlidersArray.Count()>1 && AnyWindowOpen>0)
      Return

   GuiControlGet, WhatsFocused, SettingsGUIA: FocusV
   prevu := uiSlidersArray["focused"]
   newu := WhatsFocused
   updatePrevu := (InStr(prevu, "customSliders") && !InStr(newu, "customSliders") && prevu!=newu) ? 1 : 0
   If (modus="keys")
      updatePrevu := (InStr(prevu, "customSliders") && prevu!=newu) ? 1 : 0

   uiSlidersArray["focused"] := newu
   If (updatePrevu=1)
      GuiUpdateSliders(StrReplace(prevu, "customSliders"), 0)

   If (InStr(newu, "customSliders") && prevu!=newu && modus="keys")
      GuiUpdateSliders(StrReplace(newu, "customSliders"), 0)

   uiSlidersArray["focused"] := WhatsFocused
}

createGUItoolbar(dummy:=0) {
   Critical, on
   Static prevState, hasEverDisplayed := 0, mustDoRefresh := 1
   If (dummy="refresh-later")
   {
      mustDoRefresh := 1
      Return
   }

   If (ShowAdvToolbar=0)
   {
      ; prevState := ""
      interfaceThread.ahkPostFunction("tlbrInitPrefs", hQPVtoolbar "|" ShowAdvToolbar "|" lockToolbar2Win "|" TLBRverticalAlign "|" TLBRtwoColumns)
      If (TouchToolbarGUIcreated=1)
         Gui, OSDguiToolbar: Hide
      Return
   }

   If !hasEverDisplayed
   {
      hasEverDisplayed := 1
      JEE_ClientToScreen(PVhwnd, 0, 0, UserToolbarX, UserToolbarY)
      delayedWriteTlbrColors(0)
      RegAction(0, "ShowToolTipsToolbar", "General", 1)
      IniAction(0, "userCustomizedToolbar", "General", 1)
      IniAction(0, "userThumbsToolbarList", "General")
      IniAction(0, "userImgViewToolbarList", "General")
      IniAction(0, "toolbarViewerMode", "General", 1)
      IniAction(0, "ToolbarBgrColor", "General", 3)
      IniAction(0, "ToolbarScaleFactor", "General", 2, 0.2, 5)
      IniAction(0, "TLBRverticalAlign", "General", 1)
      IniAction(0, "TLBRtwoColumns", "General", 1)
      IniAction(0, "lockToolbar2Win", "General", 1)
   }

   pku := isImgEditingNow()
   isWelcomeScreenu := (pku=1 || (maxFilesIndex>0 && CurrentSLD)) ? 0 : 1
   isPaintPanel := (pku=1 && AnyWindowOpen=64) ? 1 : 0
   isTransPanel := (pku=1 && (AnyWindowOpen=31 || AnyWindowOpen=24)) ? 1 : 0
   isVectorMode := (drawingShapeNow=1 && editingSelectionNow=1 && EllipseSelectMode=2) ? 1 : 0
   addAlphaIcons := isAlphaMaskPartialWin()
   ToolBarBtnWidth := Round(OSDfontSize*1.5 * ToolbarScaleFactor)
   viewModus := (toolbarViewerMode=1) ? "a" toolbarViewerMode thumbsDisplaying : 1
   currState := "a" toolbarViewerMode userCustomizedToolbar userThumbsToolbarList userImgViewToolbarList isTransPanel isWelcomeScreenu addAlphaIcons viewModus isNowAlphaPainting() isAlphaMaskWindow() ToolBarBtnWidth TLBRverticalAlign TLBRtwoColumns isPaintPanel thumbsDisplaying drawingShapeNow ToolbarBgrColor ShowAdvToolbar isVectorMode imgEditPanelOpened
   ; fnOutputDebug("toolbar state prev=" prevState)
   ; fnOutputDebug("toolbar state curr=" currState)
   If (dummy="state")
   {
      ; fnOutputDebug("toolbar updated - forced")
      prevState := currState
      Return
   }

   ; ToolTip, % "a=" addAlphaIcons "|TP=" isTransPanel "|p=" isPaintPanel , , , 2
   ; msgbox, %currstateSimple%`n%prevStateSimple%
   If (prevState!=currState || dummy="forced" || mustDoRefresh=1)
   {
      ; ToolTip, % "l=" mustDoRefresh , , , 2
      startZeit := A_TickCount
      ; fnOutputDebug("toolbar updated")
      TouchToolbarGUIcreated := 0
      CoreGUItoolbar(mustDoRefresh)
      prevState := currState
      endZeit := A_TickCount
      SetTimer, refreshEntireViewport, -450
      ; ToolTip, % endZeit - startZeit , , , 2
   } 

   mustDoRefresh := 0
   interfaceThread.ahkPostFunction("tlbrInitPrefs", hQPVtoolbar "|" ShowAdvToolbar "|" lockToolbar2Win "|" TLBRverticalAlign "|" TLBRtwoColumns)
   If (TouchToolbarGUIcreated=1 && ShowAdvToolbar=1)
   {
      redrawToolbarGUI()
      ; WinMove, ahk_id %hQPVtoolbar%,, 100, 100
      WinSet, Transparent, % ToolbarOpacity, ahk_id %hQPVtoolbar%
      If (lockToolbar2Win=1)
         JEE_ClientToScreen(PVhwnd, 0, 0, UserToolbarX, UserToolbarY)

      ; fnOutputDebug(UserToolbarX "|" UserToolbarY)
      tX := Round(UserToolbarX),    tY := Round(UserToolbarY)
      Gui, OSDguiToolbar: Show, NoActivate x%UserToolbarX% y%UserToolbarY%, QPV toolbar
      whichWin := (AnyWindowOpen && panelWinCollapsed!=1) ? hSetWinGui : PVhwnd
      If (WinActive("A")=hQPVtoolbar)
         WinActivate, ahk_id %whichWin%
   } Else If (ShowAdvToolbar=0)
   {
      Gui, OSDguiToolbar: Hide
   }

   WinGetPos, , , ToolbarWinW, ToolbarWinH, ahk_id %hQPVtoolbar%
}

redrawToolbarGUI() {
   If (AnyWindowOpen && imgEditPanelOpened!=1 || mustCaptureCloneBrush=1 || slideShowRunning=1 || colorPickerModeNow=1)
   {
      Loop, % tlbrIconzList["counter"]
      {
          h := tlbrIconzList[A_Index, 1]
          WinSet, Transparent, 120, ahk_id %h%
          WinSet, ExStyle, +0x20, ahk_id %h%
      }
      WinSet, ExStyle, +0x20, ahk_id %hQPVtoolbar%
   } Else If (soloSliderWinVisible!=1)
   {
      Loop, % tlbrIconzList["counter"]
      {
          h := tlbrIconzList[A_Index, 1]
          WinSet, Transparent, 255, ahk_id %h%
          WinSet, ExStyle, -0x20, ahk_id %h%
      }
      WinSet, ExStyle, -0x20, ahk_id %hQPVtoolbar%
   }
   Sleep, 1
}

MenuTlbrResetPosition() {
   tlbrResetPosition()
}

tlbrResetPosition() {
  If (ShowAdvToolbar!=1)
     Return

  JEE_ClientToScreen(PVhwnd, 0, 0, UserToolbarX, UserToolbarY)
  tX := Round(UserToolbarX),    tY := Round(UserToolbarY)
  Gui, OSDguiToolbar: Show, NoActivate x%tX% y%tY%, QPV toolbar
  SetTimer, refreshEntireViewport, -350
  Return "m"
}

defineLastPanel() {
   winIDu := prevOpenedWindow[1]
   thisFunc := prevOpenedWindow[2]
   allowReopen := prevOpenedWindow[3]
   If (IsFunc(thisfunc) && thisFunc && allowReopen=1 && winIDu)
      keyu := ": " thisFunc "(" winIDU ") «F8»"
   Else
      keyu := " «F8»"
   Return keyu
}

tlbrDecideTooltips(hwnd) {
   icoFile := tlbrIconzList[hwnd, 2]
   btnID := tlbrIconzList[hwnd, 10]
   f := (markedSelectFile>1) ? "s" : ""
   If InStr(icoFile, "dragger")
   {
      msgu := "L: Reposition toolbar`nR: Toolbar options menu"
   } Else If InStr(icoFile, "menu")
   {
      msgu :=  (thumbsDisplaying=1) ? "L: Quick actions menu «Shift + AppsKey»`nR: Interface options menu" : "L: Edit image menu`nR: Interface options menu"
      If (drawingShapeNow=1)
         msgu := "L: Vector shape options`nR: Viewport options"
   } Else If (btnID="BTNnavNextImgu")
   {
      msgu := "Next image «Right»"
   } Else If (btnID="BTNdeleteTool")
   {
      msgu := "L: Move image file to recycle bin «Delete»`nR: Remove focused index entry «Alt + Delete»"
      If (askDeleteFiles!=1 && (!markedSelectFile || thumbsDisplaying!=1))
         msgu .= "`nWARNING: User will not be prompted before file operation"
   } Else If (btnID="BTNnavPrevImgu")
   {
      msgu := "L: Previous image «Left»`nR: Previously displayed image «Ctrl + Backspace»"
   } Else If (btnID="BTNnavFirstImgu")
   {
      msgu := "L: First image «Home»`nR: Previous random image «Backspace»"
   } Else If (btnID="BTNnavLastImgu")
   {
      msgu := "L: Last image «End»`nR: Next random image «Shift + Backspace»"
   } Else If (btnID="BTNalignVPimgu")
   {
      msgu := "L: Toggle centered image alignment «A»`nR: Toggle outside viewport image panning"
   } Else If (btnID="BTNimgSizers")
   {
      msgu := "L: Cycle adapt to window modes «T»`nR: Adapt modes options menu"
   } Else If (btnID="BTNprintAcquire")
   {
      msgu := (thumbsDisplaying=1) ? "Print image(s) «Ctrl + P»" : "L: Print image(s) «Ctrl + P»`nR: Acquire image (WIA)"
   } Else If (btnID="BTNhudHisto")
   {
      msgu := "L: Cycle histogram modes «G»`nR: Histogram options menu"
   } Else If (btnID="BTNgoPrevPanel")
   {
      msgu := "Open previous panel" defineLastPanel()
   } Else If (btnID="BtnReturnImgView")
   {
      msgu := "L: Return to image view «Enter»`nR: Open previous panel" defineLastPanel() "`nTo return to the last image in view, press Escape"
   } Else If (btnID="BTNannotate")
   {
      msgu := "L: Edit image caption «Shift + N»`nR: Toggle display image caption «N»"
   } Else If (btnID="BTNrotateTlbr")
   {
      msgu := "Toggle toolbar orientation"
   } Else If (btnID="BTNcloseTlbr")
   {
      msgu := "Close this toolbar"
   } Else If (btnID="BTNselectFileu")
   {
      msgu := "L: Select / deselect active file «Tab / Space»`nR: Drop files selection «Ctrl + D»"
   } Else If (btnID="BTNzoomOutIMG")
   {
      msgu := "Zoom out"
      If (thumbsDisplaying=1)
         msgu := (thumbsListViewMode=1) ? "Decrease the number of columns" : "Decrease font size"
   } Else If (btnID="BTNzoomInIMG")
   {
      msgu := "Zoom in"
      If (thumbsDisplaying=1)
         msgu := (thumbsListViewMode=1) ? "Increase the number of columns"  : "Increase font size"
   } Else If (btnID="BTNprivatModa")
   {
      msgu := "L: Toggle private mode`nR: Toggle record seen images"
   } Else If (btnID="BTNjumpAtIndex")
   {
      msgu := "Jump at user given file index"
   } Else If (btnID="BTNswitchThumbs")
   {
      friendly := (thumbsDisplaying=1) ? "image view" : defineListViewModes() " list mode"
      msgu := "L: Switch to " friendly " «Enter»`nR: Open previous panel" defineLastPanel()
   } Else If (btnID="BTNsoundPlay")
   {
      msgu := "L: Play associated audio file «X»`nR: Stop audio playback «Shift + X»"
   } Else If (btnID="BTNcopyImg")
   {
      friendly := (editingSelectionNow=1) ? "selection area " : ""
      msgu := (thumbsDisplaying=1) ? "L: Copy file" f " to... «C»`nR: Copy file" f " path" f " «Shift + C»" : "L: Copy image " friendly "to clipboard «Ctrl + C»`nR: Copy file" f " path" f " «Shift + C»"
   } Else If (btnID="BtnHelp")
   {
      msgu := "About Quick Picto Viewer v" appVersion
   } Else If (btnID="BTNquickFileActs")
   {
      ph := allowUserQuickFileActions=1 ? "(ACTIVATED)" : "(DEACTIVATED)"
      msgu := "L: Quick file actions settings`nR: Toggle quick file action shortcuts " ph A_Space
   } Else If InStr(icoFile, "alpha-mask-discard")
   {
      msgu := validBMP(userAlphaMaskBmpPainted) ? "Discard user painted alpha mask bitmap" : "Set alpha mask as undefined"
   } Else If InStr(icoFile, "alpha-mask-view")
   {
      msgu := "Preview alpha mask «M»"
   } Else If InStr(icoFile, "alpha-mask-panel")
   {
      msgu := "Define alpha mask panel «M»"
   } Else If InStr(icoFile, "alpha-mask-paint")
   {
      msgu := "Paint alpha mask «Ctrl + K»"
   } Else If InStr(icoFile, "alpha-mask-capture")
   {
      msgu := "L: Capture image selected area as alpha mask`nR: Import clipboard as alpha mask"
   } Else If InStr(icoFile, "alpha-mask-pixelize")
   {
      msgu := "Rasterize / pixelize the alpha mask"
   } Else If InStr(icoFile, "alpha-mask-invert")
   {
      msgu := "Invert alpha mask «N»"
   } Else If InStr(icoFile, "new-image")
   {
      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "L: Import list or insert file(s) into list «Insert»`nR: Add folder(s) into current list «Shift + Insert»"
      Else
         msgu :="L: Create new image «Ctrl + N»`nR: Acquire image from scanner"
   } Else If InStr(icoFile, "paste-clip")
   {
      msgu := (thumbsDisplaying=1) ? "Paste files from clipboard into current list «Ctrl + V»" : "L: Paste image from clipboard «Ctrl + V»`nR: Paste into selection area «Ctrl + Shift + V»"
   } Else If InStr(icoFile, "undo")
   {
      If (isImgEditingNow()=1)
      {
         If undoLevelsRecorded
            infosA := ": " currentUndoLevel "/" undoLevelsRecorded
         If (totalSelUndos := undoSelLevelsArray.Count()) && (editingSelectionNow=1)
            infosB := ": " currentSelUndoLevel " / " totalSelUndos " »"
      }

      msgu := "Undo image" infosA " «Ctrl + Z»"
      infosV := currentVectorUndoLevel " / "  Round(undoVectorShapesLevelsArray.Count())
      If (drawingShapeNow=1 && editingSelectionNow=1)
         msgu := "Undo vector editing: " infosV " «Ctrl + Z»"
      Else If (editingSelectionNow=1)
         msgu := "L: " msgu "`nR: Undo selection area" infosB " «Ctrl + Shift + Z»"
   } Else If InStr(icoFile, "redo")
   {
      If (isImgEditingNow()=1)
      {
         If undoLevelsRecorded
            infosA := ": " currentUndoLevel "/" undoLevelsRecorded
         If (totalSelUndos := undoSelLevelsArray.Count()) && (editingSelectionNow=1)
            infosB := ": " currentSelUndoLevel " / " totalSelUndos " »"
      }

      msgu := "Redo image" infosA " «Ctrl + Y»"
      infosV := currentVectorUndoLevel " / "  Round(undoVectorShapesLevelsArray.Count())
      If (drawingShapeNow=1 && editingSelectionNow=1)
         msgu := "Redo vector editing: " infosV " «Ctrl + Y»"
      Else If (editingSelectionNow=1)
         msgu := "L: " msgu "`nR: Redo selection area" infosB " «Ctrl + Shift + Y»"
   } Else If InStr(icoFile, "add-text")
   {
      msgu := (thumbsDisplaying=1) ? "Edit image caption «Shift + N»" : "L: Insert text into image «Shift + T»`nR: Edit image caption «Shift + N»"
   } Else If InStr(icoFile, "eraser")
   {
      keyu := (AnyWindowOpen=64) ? " «R»" : ""
      msgu := "L: Eraser - soft brush" keyu
      If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu .= "`nR: Erase or fade image selected area «Delete»"
      If (isImgEditingNow()=1 && editingSelectionNow=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Erase initially selected image area «Backspace»"
   } Else If InStr(icoFile, "brush-blur")
   {
      friendly := (AnyWindowOpen=64) ? "brush: " BrushToolBlurStrength "%" : "brush"
      msgu := "L: Blur - soft " friendly "`nR: Blur or pixelize selected area"
   } Else If InStr(icoFile, "brush-cloner")
   {
      keyu := (AnyWindowOpen=64) ? " «J»" : ""
      friendly := (AnyWindowOpen=64 && BrushToolType=3) ? "Toggle dynamic cloner source coordinates" : "Cloner - soft brush"
      keyus := (AnyWindowOpen=64 && BrushToolType=3) ? " «S»" : ""
      msgu := "L: " friendly keyu "`nR: Define cloner source" keyus
   } Else If InStr(icoFile, "brush-main")
   {
      keyu := (AnyWindowOpen=64) ? " «B»" : " «P»"
      msgu := "Soft/Hard paint brush" keyu
   } Else If InStr(icoFile, "brush-fx")
   {
      keyu := (AnyWindowOpen=64) ? " «Q»" : ""
      msgu := "Color effects - soft brush" keyu
   } Else If InStr(icoFile, "brush-wet")
   {
      msgu := (AnyWindowOpen=64 && BrushToolType<3) ? "Soft wet brush: " Round(BrushToolWetness/22 * 100) "%" : "Soft wet brush"
   } Else If InStr(icoFile, "flood-fill")
   {
      msgu := (AnyWindowOpen=66) ? "Set color similarity tolerance" : "Flood fill / color bucket «K»"
   } Else If InStr(icoFile, "brush-dry")
   {
      msgu := "Brush drying rate"
   } Else If InStr(icoFile, "calculate")
   {
      msgu := "L: Calculate total size of selected files «Shift + L»`nR: Review panel for selected files «R»"
   } Else If (btnID="BTNinvertStuff")
   {
      msgu := (thumbsDisplaying=1) ? "Invert files selection «Shift + I»" : "Invert image «Shift + I»"
   } Else If (btnID="BTNvectSelInvert")
   {
      msgu := "Invert selected points «Shift + I»"
   } Else If (btnID="BTNvectSymAnchr")
   {
      msgu := "Symmetrical anchors «R»"
      If (bezierSplineCustomShape!=1)
         msgu .= "`nThis option only applies for Bezier paths"
   } Else If (btnID="BTNvectTmodes")
   {
      msgu := "Cycle tool modes: " Format("{:U}", defineVectToolMode()) " «Q»"
   } Else If (btnID="BTNvectRemPoints")
   {
      msgu := "Delete selected points «Delete»"
   } Else If (btnID="BTNvectRemLast")
   {
      msgu := "Remove end point «Backspace»"
   } Else If (btnID="BTNvectSelAll")
   {
      msgu := "L: Select all points «Ctrl + A»`nR: Deselect all points «Ctrl + D»"
   } Else If (btnID="BTNvectSmooth")
   {
      msgu := "Cycle shape smoothness levels «T»"
   } Else If (btnID="BTNvectOpenPath")
   {
      msgu := "Toggle open/closed path «O»"
   } Else If InStr(icoFile, "pen-vector")
   {
      msgu := "L: Draw freeform filled shape «Shift + P»`nR: Draw freeform poly or curve line «Alt + P»"
   } Else If InStr(icoFile, "spiral")
   {
      msgu := "Draw parametric lines (spirals, rays, grids)"
   } Else If InStr(icoFile, "files-map")
   {
      msgu := "L: Show selected files map «W»`nR: Toggle show map on scrollbar click"
   } Else If InStr(icoFile, "pipette")
   {
      keyu := (imgEditPanelOpened=1 && AnyWindowOpen) ? " «C»" : ""
      keyu2 := (imgEditPanelOpened=1 && AnyWindowOpen) ? " «X»" : ""
      msgu := "L: Pick color (click and drag)" keyu "`nR: Switch primary / secondary color" keyu2
   } Else If InStr(icoFile, "colorz-swatch")
   {
      keyu2 := (imgEditPanelOpened=1 && AnyWindowOpen) ? " «X»" : ""
      msgu := "L: Choose color`nR: Switch primary / secondary color" keyu2
      If (thumbsDisplaying=1)
         msgu := "Toggle private mode"
   } Else If InStr(icoFile, "crop")
   {
      If (isImgEditingNow()=1 && editingSelectionNow=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Cycle through shapes to clip the image object «Shift + C»"
      Else If (isImgEditingNow()=1 && editingSelectionNow=1)
         msgu := "L: Crop image to selection area «Shift + Enter»`nR: Resize image to selection area «Alt + R»"
      Else
         msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "Resize / crop / rotate image" f " «Ctrl + R»" : "L: Adjust image canvas size «Alt + A»`nR: Auto-crop image «Alt + Y»"
   } Else If InStr(icoFile, "save-disk")
   {
      imgPath := getIDimage(currentFileIndex)
      If InStr(imgPath, "\temporary memory object\")
      {
         fileStatus := "`n `nImage bitmap UNSAVED to disk"
      } Else If isImgEditingNow()
      {
         oldTimes := lastZeitIMGsaved[1]
         FormatTime, timea, % oldTimes , HH:mm
         If oldTimes
            InfosPreviousSave := "`n `nLast time saved: " timea "`n" lastZeitIMGsaved[4] "`nUndo levels state: " lastZeitIMGsaved[2] "/" lastZeitIMGsaved[3]

         If !FileExist(imgPath)
            fileStatus := "`n `nImage bitmap UNSAVED to disk"
         Else If (currentImgModified=1)
            fileStatus := "`n `nThe image has been MODIFIED"
         Else If (currentImgModified=2)
            fileStatus := "`n `nThe image has just been SAVED"
      }
      If (currentFilesListModified=1 && maxFilesIndex>1 && thumbsDisplaying=1)
         fileStatus := "`n `nThe files list has been MODIFIED"

      msgu := (thumbsDisplaying=1) ? "Save files list «Ctrl + S»" fileStatus : "L: Save image to disk «Ctrl + S»`nR: Save files list «Ctrl + Shift + S»" fileStatus InfosPreviousSave
   } Else If InStr(icoFile, "open")
   {
      msgu := "L: Open image or folder dialog «Ctrl + O»`nR: Recents menu"
   } Else If InStr(icoFile, "cut")
   {
      msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "L: Cut file" f " (Explorer mode) «Ctrl + X»`nR: Move file" f " to.. «M»" : "L: Cut image selected area «Ctrl + X»`nR: Move file" f " to.. «M»"
   } Else If InStr(icoFile, "adjust-colors")
   {
      If (isImgEditingNow()=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Toggle color adjustments for the image object «U»"
      Else If (thumbsDisplaying=1)
         msgu := "L: Adjust viewport colors and more «U»`nR: Reset viewport adjustments « \ »"
      Else If isTlbrViewModus()
         msgu := "L: Adjust viewport colors and more «Shift + U»`nR: Reset viewport adjustments « \ »"
      Else
         msgu := "L: Adjust image colors «U»`nR: Reset viewport adjustments « \ »"
   } Else If InStr(icoFile, "transform-img")
   {
      msgu := (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen) ? "L: Import selected image into currently opened one" : "L: Transform image selected area «Ctrl + T»"
      If (isImgEditingNow()=1 && editingSelectionNow=0)
         msgu := "L: Resize image «Ctrl + R»"
      Else If (isImgEditingNow()=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "L: Cycle through image object dimensions adapt modes «S»"
      If (isImgEditingNow()=1 && !AnyWindowOpen && editingSelectionNow=1)
         msgu .= "`nR: Resize image «Ctrl + R»"
   } Else If InStr(icoFile, "flip-h")
   {
      editing := isImgEditingNow()
      alph := isNowAlphaPainting()
      If (editing=1 && alph=1)
         msgu := "Alpha mask bitmap - flip horizontally «Shift + H»"
      Else If (editing=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Image object - flip horizontally «Shift + H»"
      Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "Image file - flip horizontally «Shift + H»"
      Else If (editing=1 && editingSelectionNow=1 && !AnyWindowOpen)
         msgu := "Image selected area - flip horizontally «Shift + H»"
      Else If (editing=1)
         msgu := "Viewport - flip horizontally «H»"
      Else
         msgu := "Flip horizontally"

      If (editing=1 && editingSelectionNow=1 && AnyWindowOpen && !alph)
         msgu2 := "Image selected area - flip horizontally «Shift + H»"
      Else If ( (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      || (editing=1 && alph=1) )
         msgu2 := "Viewport - flip horizontally «H»"

      If msgu2
         msgu := "L: " msgu "`nR: " msgu2
   } Else If InStr(icoFile, "flip-v")
   {
      editing := isImgEditingNow()
      alph := isNowAlphaPainting()
      If (editing=1 && alph=1)
         msgu := "Alpha mask bitmap - flip vertically «Shift + V»"
      Else If (editing=1 && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Image object - flip vertically «Shift + V»"
      Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "Image file - flip vertically «Shift + V»"
      Else If (editing=1 && editingSelectionNow=1 && !AnyWindowOpen)
         msgu := "Image selected area - flip vertically «Shift + V»"
      Else If (editing=1)
         msgu := "Viewport - flip vertically «V»"
      Else
         msgu := "Flip vertically"

      If (editing=1 && editingSelectionNow=1 && AnyWindowOpen && !alph)
         msgu2 := "Image selected area - flip vertically «Shift + V»"
      Else If ( (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
      || (editing=1 && alph=1) )
         msgu2 := "Viewport - flip vertically «V»"

      If msgu2
         msgu := "L: " msgu "`nR: " msgu2 
      If (drawingShapeNow=1)
         msgu := "Cycle symmetry modes «Y»"
   } Else If InStr(icoFile, "rotation")
   {
      friendly := (editingSelectionNow=1) ? "L: Image selection area:" : "L: Viewport:"
      keyu := (editingSelectionNow=1) ? " «Shift + 0»" : " «0»"
      keyu2 := (editingSelectionNow=1) ? " «Shift + \»" : " « \ »"
      msgu := friendly " rotate by 5°" keyu "`nR: Reset rotation" keyu2
      msgu .= "`nHold Alt to change rotation by 1°"
      If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu := "L: Rotate image file by +90° «Shift + 0»`nR: Rotate image file by -90° «Shift + 9»"
      Else If isTlbrViewModus()
         msgu := "L: Rotate viewport image by 45° «0»`nR: Reset viewport rotation «\»"
   } Else If InStr(icoFile, "fill-shape")
   {
      msgu := (AnyWindowOpen=23) ? "L: Cycle through fill shapes «Alt + BackSpace»" : "L: Fill selection area «Alt + Backspace»"
      msgu .= "`nR: Fill behind image"
   } Else If InStr(icoFile, "outline-shape")
   {
      msgu := (AnyWindowOpen=65) ? "Cycle through shape contours" : "L: Draw shape contours «Ctrl + L»`nR: Draw parametric lines"
   } Else If (btnID="BTNselectShape")
   {
      friendly := (editingSelectionNow=1) ? "Cycle selection area types «Shift + E»" : "Create image selection area «E»"
      If (isImgEditingNow() && (AnyWindowOpen=31 || AnyWindowOpen=24))
         msgu := "Toggle image object visibility «D»"
      Else If (thumbsDisplaying=1 && maxFilesIndex>0 && CurrentSLD && !AnyWindowOpen)
         msgu :=  "L: Select / deselect focused index entry «Tab»`nR: Files selection options menu"
      Else
         msgu := (editingSelectionNow=1 && isImgEditingNow()=1) ? "L: " friendly "`nR: Toggle image selection area «E»" : friendly
   } Else If InStr(icoFile, "create-freeform")
   {
      friendly := (editingSelectionNow!=1 || EllipseSelectMode!=2) ? "Create new" : "Modify"
      msgu := "L: " friendly " freeform selection area «Shift + L»`nR: Selection area shapes options menu"
   } Else If InStr(icoFile, "loupe")
   {
      friendly := (thumbsDisplaying=1) ? "Cycle thumbnails aspect ratios" : "Cycle adapt image to window modes"
      friendly2 := (thumbsDisplaying=1) ? "thumbnails" : "image"
      msgu := "L: Zoom in / out " friendly2 " « = »`nR: " friendly " «T»"
   } Else If InStr(icoFile, "pan-img")
   {
      msgu := "L: Pan image in viewport`nR: Toggle image navigator «Z»"
   } Else If (btnID="BTNcancelTool")
   {
      msgu := "Cancel / exit current tool «Escape»"
   } Else If (btnID="BTNmainTooler")
   {
      friendly := (thumbsDisplaying=1) ? "image view «Enter»" : defineListViewModes() " list mode «Enter»"
      moreFriendly := isNowAlphaPainting() ? "Exit Alpha Painting mode «Enter / Escape»" : "L: Apply current tool «Enter»`nR: Abandon current tool «Escape»"
      msgu := !AnyWindowOpen ? "L: Open previous panel" defineLastPanel() "`nR: Switch to " friendly : moreFriendly
      If (isImgEditingNow()=1 && drawingShapeNow=1)
         msgu := "Apply changes to the vector shape and exit vector drawing mode «Enter»"
   } Else If InStr(icoFile, "brush-set-soft")
   {
      msgu := "Brush softness: " BrushToolSoftness "% «Shift + ]»"
   } Else If InStr(icoFile, "brush-set-opacity")
   {
      If (AnyWindowOpen=66 && !isNowAlphaPainting())
      {
         msgu := "Flood fill opacity: " Round((FloodFillOpacity / 255) * 100) "%"
      } Else
      {
         thisOpacity := (BrushToolUseSecondaryColor=1) ? BrushToolBopacity : BrushToolAopacity
         msgu := "Brush opacity: " Round((thisOpacity / 255) * 100) "% «0»"
      }
   } Else If InStr(icoFile, "brush-set-size")
   {
      friendly := (BrushToolDoubleSize=1) ? "RADIUS" : "DIAMETER"
      friendly2 := (BrushToolDoubleSize!=1) ? "RADIUS" : "DIAMETER"
      msgu := "L: Brush " friendly ": " brushToolSize " px « [ » `nR: Switch to " friendly2 " mode «Shift + S»"
   } Else If InStr(icoFile, "brush-set-angle")
   {
      If (BrushToolAutoAngle=1)
         msgu := "Deactivate mouse movements based angle for the brush"
      Else
         msgu := "L: Brush angle: " BrushToolAngle "° «Ctrl + ]»`nR: Activate mouse movements based angle"
   } Else If InStr(icoFile, "brush-set-ratio")
   {
      msgu := "L: Brush aspect ratio: " BrushToolAspectRatio "% «Alt + ]»`nR: Reset brush aspect ratio"
   } Else If (btnID="BTNpaintSelection")
   {
      friendly := (BrushToolOutsideSelection=1) ? "ANYWHERE" : "INSIDE"
      If (BrushToolOutsideSelection=3)
         friendly := "OUTSIDE"
      msgu := "Paint " Friendly " image selection area`nCycle through options «Shift + K»"
   } Else If InStr(icoFile, "vp-grid")
   {
      b := (drawingShapeNow=1) ? "Toggle" : "Configure"
      msgu := "L: Adjust viewport grid «Alt + =»`nR: " b " viewport grid"
      If (drawingShapeNow!=1)
         msgu .= "`nHold Ctrl and L-click to toggle the grid"
   } Else If (btnID="BTNthumbsList")
   {
      msgu := "Cycle through list view modes «L»"
      If (thumbsListViewMode=1)
         msgu := "L: " msgu "`nR: Toggle centered alignment for thumbnails «A»"
   } Else If InStr(icoFile, "view") 
   {
       msgu := "L: Toggle image preview «Z»`nR: Toggle preview area double-size"
       If (drawingShapeNow=1)
          msgu := "Toggle live preview for new points «P»"
   } Else If InStr(icoFile, "search") 
   {
      msgu := "L: Search indexed files «Ctrl + F3»`nR: Search and replace in the files list «Ctrl + H»"
   } Else If InStr(icoFile, "modify-entry") 
   {
      msgu := "L: Rename file" f " «F2»`nR: Modify focused index entry «Ctrl + F2»"
   } Else If InStr(icoFile, "filter") 
   {
      friendly := StrLen(filesFilter)>2 ? "L:" : ""
      msgu := friendly "Filter files list «Ctrl + F»"
      If StrLen(filesFilter)>2
         msgu .= "`nR: Deactivate active files list filter «Ctrl + Space»"
   } Else If InStr(icoFile, "statistics") 
   {
      msgu := "L: Files list statistics`nR: Find image duplicates"
   } Else If InStr(icoFile, "sort-list") 
   {
      msgu := "Sort files list menu"
   } Else If InStr(icoFile, "refresh") 
   {
      friendly := (markedSelectFile>1) ? "Refresh selected thumbnails on scroll" : "Refresh all thumbnails on scroll"
      msgu := "L: Refresh the files list «F5»`nR: " friendly " «Alt + F5»"
   } Else If InStr(icoFile, "folder-tree") 
   {
      msgu := "L: Folders tree view panel «F4»`nR: Explore file location menu «Shift + F4»"
   } Else If InStr(icoFile, "recent") 
   {
      msgu := "Recently opened folders"
   } Else If InStr(icoFile, "infos") 
   {
      msgu := "L: Image and viewport details «I»`nR: Files information panel «Alt + Enter»"
   } Else If InStr(icoFile, "star") 
   {
      friendly := resultedFilesList[currentFileIndex, 5] ? "Remove from" : "Add to"
      msgu := "L: " friendly " favourites «B»`nR: Favourites menu"
      If isWelcomeScreenu
         msgu := "Favourited images"
   } Else If InStr(icoFile, "manage-folders") 
   {
      If (RegExMatch(CurrentSLD, sldsPattern) && SLDcacheFilesList=1)
         friendly := "`nR: Update files list selectively «Ctrl + U»"
      msgu := "L: Manage folders list to be indexed «Alt + U»" friendly
   } Else If InStr(icoFile, "font-size") 
   {
      msgu := "Change viewport font size: " OSDfontSize " «Ctrl + =»"
   } Else If InStr(icoFile, "select-align") 
   {
      msgu := "Align selection menu"
   } Else If InStr(icoFile, "play") 
   {
      friendly := DefineSlideShowType()
      msgu := "L: Play " friendly " slideshow`nR: Cycle slideshow modes"
   } ; Else msgu := "N/A"

   If (allowCustomKeys=1)
      msgu := processTlbrTooltip(msgu, btnID)

   msgu := StrReplace(msgu, "«", "[")
   msgu := StrReplace(msgu, "»", "]")
   Return msgu
} ; // tlbrDecideTooltips

processTlbrTooltip(msgu, btnID) {
   Static lastInvoked := 1, lastState, lastMsg
   thisState := msgu "||" btnID
   If (A_TickCount - lastInvoked<950)
   {
      If (thisState=lastState || (A_TickCount - lastInvoked<50))
         Return lastMsg
   }

   lastState := thisState
   l := processToolbarFunctions(btnID, 0, 1)
   r := processToolbarFunctions(btnID, "right", 1)
   lf := l[1], rf := r[1]
   ; ToolTip, % msgu "|" lf , , , 2
   If (InStr(msgu, "L:")!=1)
   {
      lastMsg := coreprocessTlbrTooltip(msgu, lf)
   } Else
   {
      newMsgu := ""
      Loop, Parse, msgu, `n, `r
      {
         If (InStr(A_LoopField, "L:")=1)
            newMsgu .= coreprocessTlbrTooltip(A_LoopField, lf) "`n"
         Else If (InStr(A_LoopField, "R:")=1)
            newMsgu .= coreprocessTlbrTooltip(A_LoopField, rf) "`n"
         Else
            newMsgu .= A_LoopField "`n"
      }
      lastMsg := Trimmer(newMsgu)
   }

   lastInvoked := A_TickCount
   Return lastMsg ; "`n" btnID
}

coreprocessTlbrTooltip(msgu, lf) {
   ckbd := testCustomKBDcontexts("." lf)
   If ckbd
      lthisu := ckbd

   posu := InStr(msgu, "«")
   If (!lthisu && posu)
   {
      thisHumanKey := SubStr(msgu, posu + 1)
      thisHumanKey := SubStr(thisHumanKey, 1, InStr(thisHumanKey, "»") - 1)
      thisKey := processHumanKkbdName(thisHumanKey)
      ckbd := testCustomKBDcontexts(thisKey)
      If ckbd
         shu := ckbd

      remKey := (shu && StrLen(userCustomKeysDefined[shu, 1])>0 && userCustomKeysDefined[shu, 1]!=lf) ? 1 : 0
      If !shu
      {
         defaultu := processDefaultKbdCombos(thisKey, PVhwnd, 0, PVhwnd, 1)
         remKey := StrLen(defaultu[1])>2 ? 0 : 1
         ; fnOutputDebug("yay= " remKey "|" defaultu[1] "|" thiskey "|" lf)
      }
      ; ToolTip, % shu "|" thisKey "|" thisHumanKey "|" remKey  , , , 2
   } Else If (userCustomKeysDefined[lthisu, 6]!="" && SubStr(userCustomKeysDefined[lthisu, 1], 1, 1)!="?" && lthisu)
   {
      newKey := " [" userCustomKeysDefined[lthisu, 6] "]"
      remKey := 1
   } Else If (userCustomKeysDefined[lthisu, 6]!="" && SubStr(userCustomKeysDefined[lthisu, 1], 1, 1)="?" && lthisu)
   {
      newKey := ""
      remKey := 1
   }
   ; msgu .=  " | " lf " | " testFuncIsInMenus(lf)
   If (posu && remKey=1)
      msgu := SubStr(msgu, 1, posu - 1) newKey SubStr(msgu, InStr(msgu, "»") + 1)
   Else If newKey
      msgu .= newKey

   msgu := StrReplace(msgu, "  ", A_Space)
   Return msgu
}

ResetLbtn() {
  If GetKeyState("LButton", "P")
     SetTimer, ResetLbtn, -60
  Else
     LbtnDwn := 0
}

DelayedToolbarTooltips(msgu, idu) {
  zbb := (slideShowRunning=1 || imageLoading=1 || runningLongOperation=1) ? 1 : 0
  If ((LbtnDwn=1 || zbb=1 || soloSliderWinVisible=1) || (A_TickCount - lastZeitOpenWin<350) || (A_TickCount - lastOtherWinClose<350))
     Return

  MouseGetPos,,,, ctrlHover, 2
  IndexBtn := tlbrIconzList[ctrlHover, 5] - 1
  ; thisHwnd := tlbrIconzList[indexBtn, 1]
  thisu := "tlbrValueIcon" IndexBtn + 1
  thisSize := OSDfontSize//3 + 2
  ; ToolTip, % thisu "|" idu "|" msgu , , , 2
  If (thisu=idu && ShowAdvToolbar=1)
     mouseCreateOSDinfoLine(msgu, thisSize)
}

WM_MOUSEMOVE(wP, lP, msg, hwnd) {
  Critical, off
  Static lastInvoked := 1, prevCtrlHover, prevState, prevMsg
       , hCursBusy := DllCall("user32\LoadCursorW", "Ptr", NULL, "Int", 32514, "Ptr")  ; IDC_WAIT
       , hCursFinger := DllCall("user32\LoadCursorW", "Ptr", NULL, "Int", 32649, "Ptr")
       , hCursMove := DllCall("user32\LoadCursorW", "Ptr", NULL, "Int", 32646, "Ptr")

   If (A_TickCount - scriptStartTime < 900)
      Return

   If ((whileLoopExec=1 || runningLongOperation=1 || imageLoading=1 || slideShowRunning=1) && mustCaptureCloneBrush!=1 && colorPickerModeNow!=1)
   {
      If (MsgBox2hwnd!=WinActive("A"))
         DllCall("user32\SetCursor", "UPtr", hCursBusy)
      Return
   }

   If (drawingShapeNow!=1)
   {
      hwnd := Format("{1:#x}", hwnd)
      WinGetClass, ctrlClassNN, ahk_id %hwnd%
         ; ToolTip, % hwnd "|`n" whichHwnd "`n=" ctrlClassNN "`n=" ctrlClassNE , , , 2
      If (InStr(ctrlClassNN, "static") && !InStr(A_GuiControl, "tlbrValueIcon"))
      || (InStr(ctrlClassNN, "syslistview") && InStr(A_GuiControl, "color"))
      {
         If getTabStopStyle(A_GuiControl) ; I do not know why it works with A_GuiControl ; it should work with the hwnd
            DllCall("user32\SetCursor", "UPtr", hCursFinger)
      }
  }
  ; ToolTip, % ctrlClassNN "=" A_GuiControl "=" whichHwnd , , , 2
  If ((ShowAdvToolbar!=1) || (AnyWindowOpen && imgEditPanelOpened!=1))
     Return

  ; x := (lP >> 16) & 0xffff      ; returns the HIWORD
  ; y := lP & 0xffff              ; returns the LOWORD
  Az := WinActive("A")
  MouseGetPos, OutputVarX, OutputVarY, OutputVarWin, OutputVarControl, 2
  okay := (Az=hQPVtoolbar || identifyThisWin() || Az=hSetWinGui) ? 1 : 0
  thisState := "a" OutputVarWin OutputVarControl OutputVarX OutputVarY
  If (okay=1 && thisState!=prevState && OutputVarWin=hQPVtoolbar) && (A_TickCount - zeitSillyPrevent>150)
  {
     ctrlHover := OutputVarControl
     If (wP&0x1)
     {
        ; ToolTip, % A_TickCount , , ,
        LbtnDwn := 1
        SetTimer, ResetLbtn, -55
        Return
     }

     If (soloSliderWinVisible!=1)
        msgu := tlbrDecideTooltips(ctrlHover)

     If InStr(tlbrIconzList[ctrlHover, 2], "dragger")
        DllCall("user32\SetCursor", "UPtr", hCursMove)
     
     If (!msgu && ShowToolTipsToolbar=1)
        mouseTurnOFFtooltip()

     If ((A_TickCount - lastInvoked > 155) && msgu) ; && (thisPos!=prevPos)
     {
        ; Button_BM_SETCHECK(ctrlHover, 1)
        ; isThisWin :=(OutputVarWin=PVhwnd) ? 1 : 0
        If (imageLoading!=1 && runningLongOperation!=1)
        {
           IndexBtn := tlbrIconzList[ctrlHover, 5]
           If (A_Gui="OSDguiToolbar" && ctrlHover && IndexBtn>0 && k!=msgu)
           {
              ControlSetText , , % StrReplace(msgu, "`n", ".`n") ".", ahk_id %ctrlHover%
              tlbrIconzList[ctrlHover, 11] := msgu
           }
        }

        brr := ((openingPanelNow=1 || LbtnDwn=1 || soloSliderWinVisible=1) || (A_TickCount - lastZeitOpenWin<350) || (A_TickCount - lastOtherWinClose<350)) ? 1 : 0
        If (slideShowRunning!=1 && imageLoading!=1 && runningLongOperation!=1 && prevCtrlHover!=ctrlHover && prevMsg!=msgu && brr!=1)
        {
           prevCtrlHover := ctrlHover
           prevMsg := msgu
           prevState := thisState
           If (ShowToolTipsToolbar=1)
           {
              fn := Func("DelayedToolbarTooltips").Bind(msgu, "tlbrValueIcon" IndexBtn)
              SetTimer, % fn, -300
           }
        }
        ; prevPos := mX "-" mY
        lastInvoked := A_TickCount
     }
  }
}

externTooltiput(msg) {
   Static lastMsg := 0
   msg := Trimmer(Trim(msg))
   If !msg
      Return

   thisSize := OSDfontSize//3 + 2
   If (msg="-hide-")
   {
      lastMsg := ""
      mouseTurnOFFtooltip()
   } Else If (lastMsg=msg)
   {
      showOSDinfoLineNow(500)
   } Else
   {
      lastMsg := msg
      mouseCreateOSDinfoLine(msg, thisSize, 1)
   }
}

ToggleToolBarValign() {
   TLBRverticalAlign := !TLBRverticalAlign
   If (TLBRtwoColumns=1)
      TLBRverticalAlign := 0

   TLBRtwoColumns := 0
   ShowAdvToolbar := 1
   IniAction(1, "TLBRverticalAlign", "General")
   IniAction(1, "TLBRtwoColumns", "General")
   IniAction(1, "ShowAdvToolbar", "General")
   createGUItoolbar()
   SetTimer, refreshEntireViewport, -350
}

toggleToolbarTwoColumns() {
   TLBRverticalAlign := 1
   TLBRtwoColumns := !TLBRtwoColumns
   ShowAdvToolbar := 1
   IniAction(1, "TLBRverticalAlign", "General")
   IniAction(1, "TLBRtwoColumns", "General")
   IniAction(1, "ShowAdvToolbar", "General")
   createGUItoolbar()
   SetTimer, refreshEntireViewport, -350
}

tlbrDraggyNow() {
   GetPhysicalCursorPos(oX, oY)
   WinGetPos, winX, winY,,, ahk_id %hQPVtoolbar%
   Dx := Dy := 0
   lastInvoked := A_TickCount
   ; ToolTip, % "l=" thisZL , , , 2
   setWhileLoopExec(1)
   While, (determineLClickState()=1)
   {
      Global zeitSillyPrevent := A_TickCount
      GetPhysicalCursorPos(mX, mY)
      Dx := mX - oX
      Dy := mY - oY
      WinMove, ahk_id %hQPVtoolbar%, , % winX + Dx, % winY + Dy
      Sleep, -1
   }

   setWhileLoopExec(0)
   WinGetPos, winX, winY,,, ahk_id %hQPVtoolbar%
   UserToolbarY := winY
   UserToolbarX := winX
   If (isInRange(Dx, -2, 2) && isInRange(Dy, -2, 2) && (A_tickcount - lastInvoked<300))
   {
      invokeTlbrContextMenu("tlbr")
      Return "m"
   }
   SetTimer, refreshEntireViewport, -350
}

invokeKbdToolbarAct(direction) {
   If (isToolbarKBDnav!=1)
   {
       deactivateTlbrKbdMode(1)
       Return
   }

   GuiControlGet, ctrlu, OSDguiToolbar: FocusV
   indexBtn := StrReplace(ctrlu, "tlbrValueIcon")
   hwndu := tlbrIconzList[indexBtn, 1]
   If hwndu
   {
      tlbrInvokeFunction(hwndu, direction, "kbd")
   } Else
   {
      KeyboardMoveMouseToolbar(2)
      displayNowToolbarHelp(1)
   }
}

displayNowToolbarHelp(msgu) {
   calcScreenLimits()
   v := OSDfontSize//2
   If (msgu=1)
      msgu := "The toolbar can be navigated with the arrow keys.`nPress Enter to execute the main action.`nPress Shift + Enter for the secondary action."
   Else If (msgu=2)
      msgu := "The toolbar has keyboard focus. Press H for help."
   Else If (msgu=3)
      msgu := "The main window has keyboard focus now"

   mouseCreateOSDinfoLine(msgu, v)
}

KeyboardMoveMouseToolbar(thisu:=0, l:=0) {
   If (isToolbarKBDnav!=1)
   {
       deactivateTlbrKbdMode(1)
       Return
   }

   If isNumber(thisu)
   {
      GuiControl, OSDguiToolbar: Focus, % "tlbrValueIcon" thisu
      SendInput, {Left}
      SendInput, {Right}
      indexBtn := thisu
   } Else
   {
      If ((thisu="up" || thisu="down") && TLBRverticalAlign=1 && TLBRtwoColumns=1)
      {
         If (thisu="up")
            SendInput, {Left 2}
         Else If (thisu="down")
            SendInput, {Right 2}
      } Else
         SendInput, {%thisu%}
      GuiControlGet, ctrlu, OSDguiToolbar: FocusV
      indexBtn := StrReplace(ctrlu, "tlbrValueIcon")
   }

   hwndu := tlbrIconzList[indexBtn, 1]
   btnID := tlbrIconzList[hwndu, 10]
   funcu := processToolbarFunctions(btnID, "kbd")
   ; ToolTip, % hwndu "=" funcu , , , 2
   If (hwndu && funcu)
   {
      w := tlbrIconzList[hwndu, 7]
      h := tlbrIconzList[hwndu, 8]
      JEE_ClientToScreen(hwndu, h, h, aX, aY)
      posu := aX "|" aY
   } Else posu := 0

   msgu := tlbrDecideTooltips(hwndu)
   thisSize := OSDfontSize//3 + 2
   ; interfaceThread.ahkFunction("ShowClickHalo", aX, aY, ToolBarBtnWidth, ToolBarBtnWidth, 1)
   If msgu
      mouseCreateOSDinfoLine(msgu, thisSize, 0, posu)
}

testHistoDLL() {
   initQPVmainDLL()
   VarSetCapacity(resultsArray, 4*7, 0)
   trGdip_GetImageDimensions(useGdiBitmap(), w, h)
   err := DllCall(whichMainDLL "\getPBitmapistoInfos", "UPtr", useGdiBitmap(), "int", w, "int", h, "UPtr", &resultsArray)

   avgu := NumGet(resultsArray, 0 * 4, "uint")
   medianValue := NumGet(resultsArray, 1 * 4, "uint")
   peakPointK := NumGet(resultsArray, 2 * 4, "uint")
   minBrLvlK := NumGet(resultsArray, 3 * 4, "uint")
   rmsu := NumGet(resultsArray, 4 * 4, "uint")
   modePointK := NumGet(resultsArray, 5 * 4, "uint")
   minPointK := NumGet(resultsArray, 6 * 4, "uint")

   fnOutputDebug("avgu: " avgu)
   fnOutputDebug("medianValue: " medianValue)
   fnOutputDebug("peakPointK: " peakPointK)
   fnOutputDebug("minBrLvlK: " minBrLvlK)
   fnOutputDebug("rmsu: " rmsu)
   fnOutputDebug("modePointK: " modePointK)
   fnOutputDebug("minPointK: " minPointK)
   resultsArray := ""
}


ListGlobalVars() {
; found on https://www.autohotkey.com/boards/viewtopic.php?t=9610
; by Lexikos
    static hwndEdit, pSFW, pSW, bkpSFW, bkpSW
    
    if !hwndEdit
    {
        dhw := A_DetectHiddenWindows
        DetectHiddenWindows, On
        Process, Exist
        ControlGet, hwndEdit, Hwnd,, Edit1, ahk_class AutoHotkey ahk_pid %ErrorLevel%
        DetectHiddenWindows, %dhw%
        
        astr := A_IsUnicode ? "astr":"str"
        ptr := A_PtrSize=8 ? "ptr":"uint"
        hmod := DllCall("GetModuleHandle", "str", "user32.dll")
        pSFW := DllCall("GetProcAddress", ptr, hmod, astr, "SetForegroundWindow")
        pSW := DllCall("GetProcAddress", ptr, hmod, astr, "ShowWindow")
        DllCall("VirtualProtect", ptr, pSFW, ptr, 8, "uint", 0x40, "uint*", 0)
        DllCall("VirtualProtect", ptr, pSW, ptr, 8, "uint", 0x40, "uint*", 0)
        bkpSFW := NumGet(pSFW+0, 0, "int64")
        bkpSW := NumGet(pSW+0, 0, "int64")
    }

    if (A_PtrSize=8)
    {
        NumPut(0x0000C300000001B8, pSFW+0, 0, "int64")  ; return TRUE
        NumPut(0x0000C300000001B8, pSW+0, 0, "int64")   ; return TRUE
    } else
    {
        NumPut(0x0004C200000001B8, pSFW+0, 0, "int64")  ; return TRUE
        NumPut(0x0008C200000001B8, pSW+0, 0, "int64")   ; return TRUE
    }
    
    ListVars
    NumPut(bkpSFW, pSFW+0, 0, "int64")
    NumPut(bkpSW, pSW+0, 0, "int64")
    ControlGetText, text,, ahk_id %hwndEdit%
    RegExMatch(text, "sm)(?<=^Global Variables \(alphabetical\)`r`n-{5~1}`r`n).*", text)
    final := ""
    Loop, Parse, text, `n,`r
    {
       If StrLen(A_LoopField)>1
       {
          If (z := InStr(A_LoopField, "["))
             line := Trimmer(SubStr(A_LoopField, 1, z - 1))
          Else
             line := Trimmer(A_LoopField)

          If (z := InStr(line, "{"))
             line := SubStr(line, 1, z - 1)
          
          line := StrReplace(line, "object object", "object")
          If !InStr(line, "`n")
             final .= line "`n"
       }
    }
    ToolTip, % final , , , 2
    Sleep, 100
    SendInput, {Esc}
    return final
}

detectTooltips() {
   Static hfont
   ; todo to-do; finish this 

   MouseGetPos, x, y, OutputVarWin, OutputVarControl, 3
   OutputVarControl := TopMostWindow(x, y, "tooltip")
   WinGetClass, classu, ahk_id %OutputVarControl%
   If !hfont
      hFont := Gdi_CreateFontByName("MS Shell Dlg 2", 20, 400, 0, 0, 0, 4)

   If OutputVarControl
   {
      DllCall("uxtheme\SetWindowTheme", "ptr", OutputVarControl, "str", "DarkMode_Explorer", "ptr", 0)
      SendMessage, 0x30, hFont, 1,,ahk_id %OutputVarControl% ; WM_SETFONT
   }

   ToolTip, % OutputVarControl "`n" classu, % x+50, % y+50 , 2
}

TopMostWindow(x,y, givenFilter) {
    WinGet, myList, list                    ; Retrieves all window IDs starting from topmost to bottommost
    Loop % myList
    {
        WinGetPos, winX, winY, winW, winH, % "ahk_id " myList%A_Index% 
        WinGetClass, class, % "ahk_id " myList%A_Index% 
        If !InStr(class, givenFilter)
           Continue

        If (winX<=x && x<=(winX+winW)) 
        && (winY<=y && y<=(winY+winH)) 
           return myList%A_Index%           ; X/Y was within the window box, return this ID since we're going top to bottom through the list
    }
    return "" 
}

RGBtoHEXandBack(clr) {
   If (StrLen(clr)=9)
   {
      R := SubStr(clr, 1, 3)
      G := SubStr(clr, 4, 3)
      B := SubStr(clr, 7, 3)
      z := Format("{1:02x}", R) Format("{1:02x}", G) Format("{1:02x}", B)
  } Else
  {
      R := "0x" SubStr(clr, 1, 2)
      G := "0x" SubStr(clr, 3, 2)
      B := "0x" SubStr(clr, 5, 2)
      z := Format("{1:03d}", R) Format("{1:03d}", G) Format("{1:03d}", B)
  }

  Return z
}




; #If, GetKeyState("CapsLock", "T")
;    LButton::
;       SendInput, {LButton}
;       If GetKeyState("CapsLock", "T")
;       {
;          Sleep, 10
;          SendInput, {Left}
;       }
; #If

testus() {
; devart
   WinGetActiveTitle, titlu
   Sleep, 90
   SendInput, {LButton}
   Sleep, 350
   SendInput, {LButton}
   Sleep, 50

   SendInput, {RButton}
   Sleep, 90
   SendInput, s
   Sleep, 150
   allowa := 1
   Loop
   {
      p := GetKeyState("CapsLock", "T")
      If !p
         Break
      SoundBeep , 500, 100
      WinGetActiveTitle, OutputVar
      If InStr(outputvar, "confirmer")
      {
         SoundBeep , 950, 100
         allowa := 0
         SendInput, o
      } Else If (A_Index>150 || !InStr(outputvar, "enregistrer"))
         Break
      Else If (allowa=1)
         SendInput, {alt down}e{alt up}
   }
   Sleep, 150
   ; SendInput, ^{F4}
   ; SendInput, {Esc}
   Sleep, 50
   SendInput, {Right}
   ; Sleep, 50
   ; Sleep, 480
   ; WinGetActiveTitle, newTitle
   ; p := GetKeyState("CapsLock", "T")
   ; If (titlu!=newTitle && p)
   ;    SetTimer, testus, -150
   ; ToolTip, % P "||" titlu "||" newTitle , , , 2
}


testus2() {

   WinGetActiveTitle, titlu
   Sleep, 90
   SendInput, {RButton}
   Sleep, 90
   SendInput, s
   Sleep, 150
   allowa := 1
   Loop
   {
      p := GetKeyState("CapsLock", "T")
      If !p
         Break
      SoundBeep , 500, 100
      WinGetActiveTitle, OutputVar
      If InStr(outputvar, "confirmer")
      {
         SoundBeep , 950, 100
         allowa := 0
         SendInput, o
      } Else If (A_Index>150 || !InStr(outputvar, "enregistrer"))
         Break
      Else If (allowa=1)
         SendInput, {alt down}e{alt up}
   }
   Sleep, 150
   SendInput, ^{F4}
   Sleep, 50
}
/*

#If, GetKeyState("CapsLock", "T")
   \::
     SetTimer, testus2, -150
   Return

   ; LButton::
   ;    Sleep, 50
   ;    SoundBeep , 300, 100
   ;    SendInput, {LButton}
   ;    Sleep, 950
   ;    SendInput, ^{PgDn}
   ;    SoundBeep , 900, 100
   ; Return

   Tab::
      SendInput, ^{PgDn}
      SoundBeep , 900, 100
   Return
#If 
*/
; #If, GetKeyState("CapsLock", "T")

   ; \::
   ; SoundBeep 
   ; SendInput, {RButton}
   ; Sleep, 50
   ; SendInput, v
   ; Sleep, 590
   ; SendInput, {LButton}
   ; Sleep, 125
   ; SendInput, ^{f4}
   ; Sleep, 50

   ; Return

   ; #If

   ; LButton::
   ;    If GetKeyState("CapsLock", "T")
   ;    {
   ;       SendInput, {LButton}
   ;       Sleep, 550
   ;       SendInput, ^{F4}
   ;    }
   ; Return

; #If

; w::
; SendInput, e
; Return 



; F:\temp\torrents\Mrs.Davis.S01.COMPLETE.720p.PCOK.WEBRip.x264-GalaxyTV[TGx]\moar\1291-mgpx-thumbs-shepet3.jpg
preventCtrlA(keyu) {
   Static lastInvoked := 1, ticks := 0, prevKeyu := 0
   If (A_TickCount - lastInvoked<400)
      ticks++
   Else
      ticks := 0
   If (keyu!=prevKeyu)
      ticks := 0
   If (ticks>2)
      SendInput, %keyu%
   lastInvoked := A_TickCount
   prevKeyu := keyu
}

#If (A_PtrSize=8 && InStr(A_ScriptDir, "sucan twins") && !A_IsCompiled && wasInitFIMlib)
   ~F7::
      restartAppu()
   Return
#If



#If (A_PtrSize=8 && InStr(A_ScriptDir, "sucan twins") && WinActive("ahk_exe Sublime_Text.exe") && !A_IsCompiled)

^a::
   preventCtrlA("^a")
return

^q::
   preventCtrlA("^q")
return

#if
/*
LButton::
SetTimer, doClicku, -150
SoundBeep 900, 20
Return 
*/

doClicku() {
      SendEvent, {LButton}
/*
      SendEvent, {LButton down}
   While, GetKeyState("capslock", "T")
   {
      sleep, 1
   }
      Sleep, 2
   SendEvent, {LButton up}
      Sleep, 2
   SendEvent, {LButton up}
   */

}

