Table of contents:
   a) How Quick Picto Viewer initializes
   b) How a files list index is created
   c) Files index filtering
   d) How an image is loaded and displayed on screen
   e) General considerations
   f) How slideshows happen
   g) Windows, AHK GUIs
   h) Input responses
   i) Image live editing
   j) How to enable alpha masking for an image editing live tool
   k) How vector shapes drawing works [soon]
   l) How image duplicates identification works (soon)


Deniere mise à jour: mardi 19 décembre 2023
================================================

a) How Quick Picto Viewer initializes
=============================================

  QPV checks in the registry if another instance started before,
  if it did less than 600 miliseconds ago, it exits; this is meant
  to prevent excessive spawn of multiple instances.

  It first loads settings or stores default settings [if first start].
   - loadMainSettings() or writeMainSettings()
  These two functions load/write only the core settings.
  Each panel within Quick Picto Viewer loads and stores settings
  of its own only.

  If "Running" registry flag is set 2 by, supposedly, another
  QPV instance, it will start as an aid for batch processing
  image files. When it finishes, it exits. If it is not set to 2,
  it continues the auto-exec part.

  QPV initializes the external UI thread and various GDI+ objects
  related to it. If something fails, QPV will ask the user to
  attempt again to initialise or exit.

  intializeWithGivenArguments() function processes all the command
  line given arguments. The user can set global variables using
  set_GlobalVar and invoke functions that take no parameters with
  call_funcName(). Examples:

      qpv.exe "fd=C:\example folder\tempus"
      Add a pipe "|" after equal "=" to have images loaded recursively.

      qpv.exe call_ToggleThumbsMode() "fd=C:\folder\tempus"

      qpv.exe set_IMGresizingMode=3 set_vpIMGrotation=45 "C:\folder\this-image.png"
  
  If an image file is given as command line argument, it is
  opened with OpenArgFile(). If a .SLD or a .SLDB file is fed,
  OpenSLD() function is used to load the files index. Folders 
  are opened using OpenFolders().

  If no argument given, it draws a random pattern image using
  drawWelcomeImg(). This function can generate up to 10 distinct
  patterns, each randomized in its own way.

  On 32 bits, the following settings are in effect by default:
     allowMultiCoreMode := 0
     minimizeMemUsage := 1
     maxUndoLevels := 2
     coreDesiredPixFmt := "0x21808" ;  24-RGB
     These are meant to limit memory usage as much as possible.

     Side note: the 32 bits edition is no longer actively tested.


b) How a files list index is created
=============================================

  If a single file is loaded, QPV will set internally the variable
  "mustOpenStartFolder" to the folder path where the image is from.

  If the aforementioned variable is set, various user actions will
  trigger the indexation of the files found in the folder using
  doOpenStartFolder(). Examples of such actions: toggle thumbnails
  mode, search, attempt to go to the next or previous image, and so on.

  Once the folder is indexed, "mustOpenStartFolder" is set empty.

  Users can open a folder using the open file/folder dialogs:
  OpenDialogFiles() or OpenFolders(). Both functions, and 
  doOpenStartFolder(), rely internally on coreOpenFolder().

  coreOpenFolder() takes as argument the folder to index files
  from. If the folder string contains a pipe "|", the files will
  not be indexed recursively. The function renews / clears 
  previous files list with renewCurrentFilesList() and then
  it proceeds to scan for the files using GetFilesList().

  In essence, coreOpenFolder() is a wrapper for GetFilesList(),
  which uses a regular expression held in "RegExFilesPattern"
  to match supported file types.

  QPV internally relies on the resultedFilesList[] array object. 
  Each file entry is defined by various properties:

  The resultedFilesList[] array object is populated by, GetFilesList(),
  OpenSLD(), sldGenerateFilesList(), OpenSLDBdataBase(),
  performSQLgetTable(), dbSortingCached(), SortFilesList() and others.

  resultedFilesList[index_number] :=
  [ 1_filePath, 2_isSelected, 3_isSeen, 4_forceThumbRefresh
  , 5_isFavourite, 6_fileSize, 7_fileDateModified
  , 8_fileDateCreated, 9_imgFrames, 10_mustDoSort, 11_IsImgHisto
  , 12_dbRowIndex, 13_imgW, 14_imgH, 15_imgPixFmt, 16_imgWHratio
  , 17_imgMGPX, 18_imgHAvg, 19_imgHmedian, 20_imgHpeak, 21_imgHlow
  , 22_imgDPI, 23_dupeID, 24_imghRMS, 25_imghRange, 26_imghMode
  , 27_imghMin, 28_imgHASH, 29_pixelzFsmall, 30_pixelzFbig
  , 31_HpixelzFsmall, 32_HpixelzFbig, 33_HammingDist, 34_MSEscore
  , 35_dateSeenDB, 36_sortModeDB]

  All these properties are optional and are filled based on the
  application context. 1_filePath is the only property that is not
  optional, because it specifies the file path and image file at
  the given index entry.

  When [de]selecting a file, resultedFilesList[Index_number, 2]
  is set to 1 or 0.

  If "skipSeenImagesSlider" is set to 1, when an image is displayed
  resultedFilesList[Index_number, 3] is set to 1. By default,
  this feature is not enabled.

  When GetFilesList() and coreOpenFolder() finish, in most cases,
  a random image is chosen to be opened. However, when a file is
  already loaded, detectFileID(imgPath) is used to identify and
  set the initial file index to the image already loaded.

  If a slideshow database is already opened, GetFilesList() will
  automatically add the files into the database using addSQLdbEntry().
  In this context, the file names are converted to lower case.

  The file details related properties are optional, as previously indicated.
  They are filled by GetFilesList() or collectFileInfosNow() and are used
  as caches by SortFilesList(), files statistics panel and
  QPV_listThumbnailsGridMode(). The collectImageInfosNow() function fills
  the members of the object with details about images and their main 
  histogram points. These details, once cached are used for files sorting
  file statistics panel and finding image duplicates.

  GenerateRandyList() is called to generate a randomized array
  of file index numbers from 1 to "maxFilesIndex", non-repetitive.
  RandyIMGids[] array is used whenever the user navigates randomly
  through the indexed files.

  The current position within the index list is held by
  "currentFileIndex" and the total indexed files in "maxFilesIndex".
  The current «random» position is "RandyIMGnow".

  Internally, "CurrentSLD" holds what folder or slideshow file 
  the user has opened, while "SLDtypeLoaded" indicates the type:
    1 - folder
    2 - slideshow plain-text
    3 - SQLite slideshow database

  If the user opens a slideshow file [a cached index], OpenSLD()
  is invoked. This is a wrapper for sldGenerateFilesList() and
  sldDataBaseOpen().

  sldGenerateFilesList() parses plain-text files and it loads
  INI-like saved settings using readSlideSettings().

  sldDataBaseOpen() opens SQLlite3 databases and reads the 
  settings using IniSLDBreadAll().

c) Files index filtering
   Users can apply a filter on the indexed file list through
   PanelEnableFilesFilter(). It can be a RegEx or a string
   that allows "|" to act as the OR operator.

   coreEnableFiltru() processes the string given by the user in 
   "usrFilesFilteru". The internal filter is held in "filesFilter".

   FilterFilesIndex() is the core function that generates the
   filtered new list. A backup of the main list is created:
     bckpResultedFilesList := resultedFilesList.Clone()
     bkcpMaxFilesIndex := maxFilesIndex

   A map of the indexes between the two arrays is created:
   filteredMap2mainList[Index_number] := Index_number_main_list

   filteredMap2mainList[] array is used when the user performs
   actions that change the index and have to be propagated in 
   the main list [the backup]. For example: file rename, index
   entry removal and so on.

   When the new resultedFilesList[] array is created, all entry 
   properties are maintained.

   FilterFilesIndex() can take Regular Expressions or «queries».
   Strings that begin with: «SQL:query:» will be parsed and used
   to perform a SELECT in the currently loaded SQL database. For
   example: SQL:query:WHERE fmodified LIKE '20200607%' .

   If the user does not work with an SQL database, another type
   of queries can be used to filter the files list: «QPV:query:»
   These are structured as follows:
   QPV:query:what:minRange:maxRange:optionalString

   Example: QPV:query:fsize:100002:250001:string

   When such queries are performed, Quick Picto Viewer uses cached
   data when available, otherwise it will extract image or file
   details. The collected data is cached in memory for subsequent
   queries or index sort operations. If an SQL database is opened, 
   the data will be stored in the database as well.
   
   The function FilterFilesIndex() ends by invoking
   GenerateRandyList().


d) How an image is loaded and displayed on screen
==================================================================

   To display an image, one can invoke IDshowImage(given_file_index)
   or ShowTheImage(imgPath).

   IDshowImage() retrieves the image file path based on a given
   number from resultedFilesList[] array and can filter dead
   files, if "skipDeadFiles" is set to 1. It can also reset
   viewport viewing conditions if "resetImageViewOnChange" is
   set to 1.

   ShowTheImage() is called with the full file path by IDshowImage().
   This function is a wrapper for coreShowTheImage() to allow the user 
   quickly skim through indexed files without loading and displaying
   each of them. It takes into account how fast the user changes
   between images and fast they are rendered on screen. If the 
   system permits, all images will be displayed. If load times are 
   high then they will be skipped. To this end, there are additional
   functions and timers meant to delay image loading, to allow for 
   interruptions.

   IDshowImage(), ShowTheImage() and coreShowTheImage() are invoked
   even if the user is in list mode [thumbnails view].

   coreShowTheImage() ends abruptly by setting the window title
   and invoking UpdateThumbsScreen() if the user is in thumbnails
   mode. Otherwise, it continues by invoking ResizeImageGDIwin().

   coreShowTheImage() also checks for file existence and can throw
   message errors to users.

   ResizeImageGDIwin() and coreShowTheImage() keep track of the 
   currently loaded image file and previous one, to help decide 
   if cached GDI bitmaps must be used or not. They can discard
   all cached image data.

   Images are cached as GDI+ bitmap objects by Quick Picto Viewer.
   This occurs at different levels or stages. This enables users
   to delete an image file, go to the next one and, if they choose,
   return to the deleted one and find the cached image, and resave it.

   If no cached GDI bitmaps are available or a different image
   file is loaded, ResizeImageGDIwin() will call CloneMainBMP().

   CloneMainBMP() manages «original» image caching and pre-processes
   images for display: rotate, convert depth modes. It caches only
   two images at a time. This function can abort image processing
   if the user attempts to change image before it finishes. It
   communicates with the interface thread by retrieving
   "canCancelImageLoad". When it is set to 4, it means abort.

   CloneMainBMP() is called only by ResizeImageGDIwin().
   coreShowTheImage() is the only function that can invoke
   ResizeImageGDIwin().

   LoadBitmapForScreen() is called by CloneMainBMP(). This is
   the function that accesses files. It is a wrapper for three
   functions that return a GDI+ bitmap:
      - LoadWICscreenImage()- loads images through Windows Imaging Component
                              it is the prefered loader since v5.6.0
      - LoadFimFile()       - used to load additional file formats
                            - this function converts any image to 24 or
                              32 bits depth and then to a GDI+ bitmap object
      - LoadFileWithGDIp()  - loads GDI+ supported files
      - LoadFileWithWIA()   - the fallback function of LoadFileWithGDIp()
                              for very large images
                            - WIA stands for Windows Image Acquisition

   LoadWICscreenImage() calls DLL functions found in qpvmain.dll: 
   WICpreLoadImage(), WICgetRectImage() and WICdestroyPreloadedImage().
   WICpreLoadImage() returns the handle and properties of the image to
   be loaded. WICgetRectImage() return a GDI+ bitmap object. It is
   invoked only if the image does not exceed the GDI+ limit of 536 mgpx.
   When the image exceeds 536 megapixels, it is transfered to FreeImage
   using teleportWICtoFIM().

   LoadWICscreenImage() and LoadFimFile() can return to LoadBitmapForScreen()
   the string "very-large", when an image over 536 megapixels was loaded.
   In this context, the image is a FreeImage object and the "gdiBitmap"
   GDI+ bitmap is just a dummy. The object is "viewportQPVimage" and it is 
   created via the "screenQPVimage" class.

   LoadBitmapForScreen() returns a GDI+ bitmap handle on success.
   When it is invoked by CloneMainBMP(), it has as argument
   "allowCaching" set to 1 which allows this function to hold 
   in cache the previously opened file, unprocessed by CloneMainBMP().
   And it also fills-in properties for currIMGdetails[], which
   holds various details about the image about to be displayed.

   When CloneMainBMP() finishes loading and processing the image,
   in ResizeImageGDIwin() the GDI+ bitmap dimensions and user 
   viewing options are used to calculate the dimensions of the image
   in the viewport and the selection area, if present.

   QPV_ShowImgonGui() is then invoked with multiple parameters.
   This is the function that will render the image on screen.
   It can also generate new sets of viewport caches.
     - "gdiBMPvPsize"   - handle of a viewport sized image
     - "gdiBitmapSmall" - handle of a low-res sized image;
     - the dimensions are calculated in determineGDIsmallCacheSize()

   These are obtained by resizing "gdiBitmap", the bitmap returned 
   by CloneMainBMP().
   
   QPV_ShowImgonGui() reuses parts of the previously rendered image
   on screen when the user pans the image, or zoom level change, but
   only if "userImgQuality" is set to 1, for high-quality image
   resampling. The cached bitmap is held in variable named "ViewPortBMPcache".

   If the image loaded exceeds 536 megapixels, the aforementioned caches
   are not created: gdiBMPvPsize, gdiBitmapSmall. QPV_ShowImgonGui() no
   longer reuses parts of the previously rendered image. Instead, it
   calls retrieveQPVscreenImgSection(). This function renders / displays
   very large images. Internally, it caches a viewport sized image.

   decideGDIPimageFX() is used to obtain GDI+ objects that can alter 
   the display of colors: a color matrix and an Effects object.

   drawHUDelements() is the function that renders the scroll bars, 
   current frame index (visual indicator), the grid ( drawVPgridsNow() )
   and the histogram box ( createHistogramBMP() ) on the viewport.
   These UI elements are rendered on a different GDI window.
   drawHUDelements() also invokes additionalHUDelements(), a function
   that wraps additional HUD elements: drawImgSelectionOnWindow(),
   drawAnnotationBox(), VPnavBoxWrapper(), and drawinfoBox().
   additionalHUDelements() is often invoked in the code to update the
   selection area and/or other HUD elements.

   QPV_ShowImgonGui() tracks how fast the render on screen is and
   adaptively choose between the available caches. To draw the
   image on screen, Gdip_DrawImage() or Gdip_DrawImageFX() are used.

   Internally, QPV use the 32-PARGB pixel format, because
   Gdip_DrawImage() and other functions perform faster.

   There are four EX_LAYERED windows: "hGDIthumbsWin", "hGDIwin"
   "hGDIselectWin", "hGDIinfosWin". There are two global GDI+
   Graphics, with their own HDCs and GDI hBitmaps: glPG / glHDC
   and 2NDglPG / 2NDHDC. These are recreated upon window resize
   events. These windows are created by BuildGUI() found in
   "module-interface.ahk". The GDI+ canvases are created by
   createGDIPcanvas() found in the main QPV.ahk file. Auxiliary
   GDI+ are created in initGDIPstuff().

   See section g) for more details on what windows are created.


e) General considerations
=============================================

   When actions are performed or somehow the main core is about 
   to get busy, changeMcursor() and/or setImageLoading() are called.
   These set variables in the user interface thread, pertaining to
   the main thread. When it is busy, the interface thread changes
   the mouse cursor and sets the busy task bar progress animation.

   For operations that can be aborted, doStartLongOpDance()
   is called.

   The main thread regularly checks the other thread for specific
   variables to see if the user intentions changed, to abort
   the current operation[s] or continue.

   One cannot have the interface thread ping the main thread
   too often because it leads to «hangs». Therefore, in most 
   cases, I have the main thread ping the UI thread.

   In most cases, if not all, I use ahkPostFunction() to call 
   functions from the main thread, because I want to avoid locking
   the UI.

   For more details, please see section g).

   The code is poorly structured and organized. It relies on many 
   global variables... and is hard to follow. This is the result
   of me having no prior experience in coding such large projects.

   Many GDI+ functions are wrapped to keep track of the bitmaps 
   created and to avoid memory leaks. These are prefixed with 
   "trGdip_*".


f) How slideshows happen
=============================================

   When the user starts a slideshow, dummyInfoToggleSlideShowu()
   is called. It gives the user information about the slideshow.
   This is a wrapper for ToggleSlideShowu() which is responsible
   for toggling the slideshow.

   The whole slideshow «business» is convoluted. The purpose 
   was to obtain an easy to stop slideshow in any circumstance,
   even if it is running very fast or the user loads very large 
   images and applies all the possible real-time effects.

   To this end, it relies on the interfaceThread[] object,
   however not entirely. The main thread checks if the UI thread 
   is still game for slideshows, and if it is, it invokes a timer
   in the UI thread: invokeExternalSlideshowHandler().
   This happens after every image. In the UI thread, the script
   can decide the slideshow must end [based on user activity]
   and the timer never executes. When another image is loaded,
   the main thread learns it ended.

   On start, ToggleSlideShowu() calls slideshowsHandler() found
   in the interfaceThread[] object. For each slide, through
   invokeExternalSlideshowHandler() the function
   dummySlideshow() in the UI thread is called and a timer is set
   for theSlideShowCore(). This last function, when invoked, calls
   in the main thread one of these functions: RandomPicture(),
   PreviousPicture() or NextPicture() - based on user preference.

   [ side note: notice the ping-pongs between the threads ^_^ ]

   "SlideHowMode" is the variable desginating the slideshow mode
   and "slideShowDelay" is the delay used for the aforementioned
   timer, in miliseconds. "slideShowRunning" is a boolean. These 
   variables and additional ones are used in both threads and 
   often synchronized...

   Things get even uglier with GIF animations...
   autoChangeDesiredFrame() is used for animated GIFs and it is 
   run with the first parameter set to "start" only from 
   QPV_ShowImgonGuiPrev(). And it is also invoked as a timer.

   Because I wanted users to have the option to allow GIFs to 
   play entirely before going to the next slide, the main thread
   sets "allowNextSlide" to 0 while the GIF plays and when the 
   first loop is done, it is set to 1 and theSlideShowCore()
   function is called from the UI thread, and
   invokeExternalSlideshowHandler() to set there the timer
   for the next slide.


g) Windows, AHK GUIs
=============================================

   The application consists mainly of two threads. In the main
   thread, all the processing happens. The other thread is 
   dedicated to the user interface: "module-interface.ahk".
   In the main file, the interface thread is simply referenced
   as an object named "interfaceThread". This separation was made 
   to provide users an optimal experience when using QPV, to
   avoid unnecessary stalling or freezes of the application.

   The following is a list, a summary, of what functions, found
   in the main thread, draw what and on which window(s).
   All the windows are owned by the "PVhwnd" window.
   These are created in the interface thread, from BuildGUI().
   
   0. PVhwnd - main window frame of QPV
      various text controls are added

   1. hGDIthumbsWin - glPG         - layered window
      QPV_listThumbnailsGridMode() - thumbnails grid for the list mode
      QPV_ShowThumbnails()         - draws and generates thumbnails
      
      During live image editing
         QPV_ShowImgonGui() - image on screen
         drawHUDelements()  - histogram box [image view only]
                              various UI markers [frames counter, scrollbars]

   2. hGDIwin - glPG             - layered window
      livePreviewsImageEditing() - the live image editing tools
         corePasteInPlaceActNow()
         coreDrawLinesSelectionArea()
         coreFillSelectedArea()
         livePreviewInsertTextinArea()
         livePreviewEraseArea()
         livePreviewDesaturateArea()
         ... and others

      When NOT in live image editing
         QPV_ShowImgonGui() - image on screen
         drawVPgridsNow()   - viewport grid
         drawHUDelements()  - histogram box [image view only]
                              various UI markers [frames counter, scrollbars]

   3. hGDIselectWin - 2NDglPG - layered window
      mainGdipWinThumbsGrid() - thumbnails grid overlay, scrollbar and status bar
      additionalHUDelements() - wrapper for the following functions
         drawImgSelectionOnWindow() - selection area [image view only]
         drawinfoBox()              - infos box
         VPnavBoxWrapper()          - image navigation/preview box
         drawAnnotationBox()        - image captions box [image view only]
         drawLiveCreateShape()      - live shape drawing [image view only]

   4. hGDIinfosWin - 2NDglPG - layered window
      CreateOSDinfoLine()    - user OSD messages
      MouseMoveResponder()   - hover selection area handler

   5. ShowClickHalo() - on-demand, temporary window, invoked
   only by the main thread.

   6. mouseCreateOSDinfoLine() - mouseToolTipGuia; on-demand,
   temporary window. It displays messages for the user, where 
   the mouse is located.

   If the aforementioned windows, from 0 to 4, fail to be created,
   Quick Picto Viewer will throw a warning and offers to exit or
   continue as options.

   The main thread creates on user demand the following AHK windows:

   1. PanelFoldersTree()
      hfdTreeWinGui, fdTreeGuia

   2. PanelQuickSearchMenuOptions()
      hquickMenuSearchWin, QuickMenuSearchGUIA

   3. createSettingsGUI() - generalized panel, it is used by most
   of the panels users can see in QPV. Each panel has an ID,
   assigned to the "AnyWindowOpen" variable.
      hSetWinGui, SettingsGUIA

      It must be noted that some panels are constructed by 
      fakeWinCreator() which uses msgBoxWrapper() to create
      simple panels.

   4. msgBoxWrapper() - custom message boxes of all kinds
      MsgBox2hwnd, WinMsgBox

   5. createGUItoolbar() - custom toolbar
      hQPVtoolbar, OSDguiToolbar

   The main thread shows messages in the viewport using
   CreateOSDinfoLine() wrapped by showTOOLtip().

   The main thread creates all the context menus via
   InitGuiContextMenu(), InitSecondMenu() and others. 
   The menus are displayed with showThisMenu() from
   the main thread.

   The main GUI of the window, created in BuildGUI(),
   contains multiple static text controls. These are used
   as place holders. They are updated with texts pertaining
   to the various viewport elements. The functions that
   update the controls are uiAccess*(). They are invoked from
   the main thread by drawHUDelements() or other associated
   functions. This is meant to help make the viewport more
   accessible for users relying on screen readers.

   The custom controls:
   In the panels created with createSettingsGUI(), many controls,
   even if not actually customized, are wrapped just for the
   sake of improving accessibility for screen readers and add
   tooltips, eg. GuiAddEdit().

   The custom sliders are created with GuiAddSlider() and respond to
   user input via GuiSlidersResponder(). When created, they are
   usually set to invoke the panel's specific UI function prefixed
   with "updateUI*".


h) Input responses
============================================================

   All keyboard shortcuts are «registered» through WM_KEYDOWN and
   WM_SYSKEYDOWN. Both, the main thread and the interface one, register
   these Window Messages. The function invoked by these threads is
   WM_KEYDOWN(). The function is meant to finish execution as
   soon as possible. constructKbdKey() is called to convert the
   virtual keys into readable form. In KeyboardResponder(), main thread,
   is where each keyboard shortcut is actually registered, where the code 
   gets to decide what functions to call based on the keyboard input,
   and the user context, in-app conditions. QPV allows custom defined
   keyboard shortcuts. These are stored as an object:
   "userCustomKeysDefined". The object is initialized by
   loadCustomUserKbds(). In KeyboardResponder(), if the user-pressed
   key is not customized [defined] in the aforementioned object,
   the key is passed to processDefaultKbdCombos().

   Mouse input is mostly handled in the interface thread.
   The Window Messages for mouse buttons (e.g., WM_LBUTTONUP)
   are registered and, broadly speaking, invoke WinClickAction(),
   which is a wrapper to the function with the same name from
   the main thread. The function handles most of the imagined
   responses to mouse clicks, based on user context.

   WM_MOUSEMOVE message is registered in the interface thread 
   and it is associated with the function WM_MOUSEMOVE().
   This function changes mouse cursor to different states,
   based on the user context and calls MouseMoveResponder()
   from the main thread. which handles live viewport updates
   related to hover actions.

   WM_MOUSEMOVE message is registered in the main thread 
   as well, associated with WM_MOUSEMOVE(). Most importantly, 
   it displays tooltips when users hover icons in the QPV toolbar, 
   if it is visible. The toolbar is created by createGUItoolbar(),
   if "ShowAdvToolbar" equals 1.


i) Image live editing
=======================================================================

   The tool panels are created using createSettingsGUI() with the parameter
   "isImgLiveEditor" set to 1. If the panel does indeed open, then 
   "imgEditPanelOpened" global variable is set to 1. These can be invoked 
   by keyboard shortcuts, menus or the toolbar.

   When a live editor panel is opened, it can be collapsed into a small
   widget. The widget is created with CreateCollapsedPanelWidget(). The 
   viewport is also responsive to clicks and keyboard actions specific to
   this mode. The toolbar is also updated with specific icons, based on the
   active tool, via createGUItoolbar() and CoreGUItoolbar(). 

   Such panels have their controls attached via g-labels to a
   function prefixed with "updateUI*", eg. updateUIfillPanel(). Such
   functions update the status of the different available controls: hides,
   shows, disables, or enables controls.

   The APPLY button in these panels is usually attached to
   applyIMGeditFunction(). The function is just a wrapper which invokes 
   a specific function for each tool, eg. BtnDrawShapeSelectedArea(),
   based on the "AnyWindowOpen" value. Most of these functions are named
   with this pattern: "Btn*SelectedArea". These functions invoke the
   actual functions that output the final result, on the image itself.

   The live preview in the viewport is handled by
   corelivePreviewsImageEditing(). This is another wrapper that handles 
   how the live preview is drawn on screen and other things. It invokes 
   specific function for each tool, eg. livePreviewInsertTextinArea().
   based on the "AnyWindowOpen" value. Most live preview functions 
   that render the preview on screen have this prefix: "livePreview*".

   Dedicated efforts have been put into generating live previews that do
   not exceed the viewport area, in order to maintain the performance 
   within acceptable levels, while maintaining fidelity as much as possible 
   with the final output when the apply button is pushed by users. When 
   it is pressed, mergeViewPortEffectsImgEditing() may also be called 
   to apply any activated viewport color adjustments, before the actual 
   tool function applies the modifications to the main bitmap.

   Flood fill and the brush tool, even if labeled as live tools, they do 
   not have live preview functions. The «action» functions are:
   ActFloodFillNow() and ActPaintBrushNow().

   Some tools allow users to paint in the alpha mask, live, eg., fill
   selected area. When the user activates this option, 
   toggleAlphaPaintingMode() is called. The live brush response during
   painting is handled by ActDrawAlphaMaskBrushNow() together with 
   the specific live preview function of the active tool. In this mode,
   one undo level is recorded.

   When images are edited, two images are continually updated:
   "UserMemBMP" and gdiBitmap. "gdiBitmap" is used for the viewport.
   "UserMemBMP" is the edited bitmap.

   When editing images under 536 megapixels, 100 levels are recorded,
   via wrapRecordUndoLevelNow(). Otherwise, one undo level is recorded 
   by recordUndoLevelHugeImagesNow(). The undo/redo actions are handled 
   by ImgUndoAction() and ImgRedoAction(). The array "undoLevelsArray"
   holds the IDs of the different undo states and GDI+ bitmaps.

   When editing images above 536 megapixels, the image data is handled 
   through FreeImage and most of the tools have counterparts that work
   on the FreeImage bitmap. "UserMemBMP" and "gdiBitmap" are not used.
   The array "undoLevelsArray" is also not used with such large bitmaps.
   The image data is accessible via "viewportQPVimage.imgHandle" property
   and the methods of "screenQPVimage" class.

   For images under 536 megapixels, the entire image is recorded for
   every undo level and is always on 32-bits RGBA. But for bigger images,
   only a subsection of the image is recorded, when possible, and it can
   be at a color depth of 24-bits or 32-bits.

   Many of the image editing tools rely on C++ functions invoked 
   via DLL calls from qpvmain.dll written by me.


j) How to enable alpha masking for an image editing live tool
=======================================================================

   1. Add the window ID to isAlphaMaskWindow().
      Window ID is "AnyWindowOpen". The panels are created using createSettingsGUI().
 
   2. Add uiADDalphaMaskTabs(tab-ID-A, tab-ID-B, funcUIpanel) in the function
   creating the panel of the tool, eg., PanelFillSelectedArea(). This will add the 
   specific alpha masking options/controls in the panel.
      tab-ID-A and B are the tab order in the panel created.
      "funcUIpanel" is the reference to the function of the panel used to updatr
      the user interface elements and the viewport, eg., updateUIfillPanel().
 
   3. Add in UItriggerBrushUpdate() a pointer to "funcUIpanel"(), as explained
   previously, based on the "AnyWindowOpen" value.
   Do the same in BtnToggleBrushColors().
 
   4. Add in "funcUIpanel"() calls to updateUIalphaMaskStuff(1) and 
   updateUIalphaMaskStuff(2) based on the "CurrentPanelTab". This will make the 
   alpha mask controls' options to show or hide as expected.
 
   5. Define the "viewportDynamicOBJcoords" object properties: x, y, w, h and zl.
   It must be defined inside the live preview drawing function of the tool itself, 
   eg., livePreviewAdjustColorsArea(). The object is used by MouseMoveResponder().
 
   6. The live preview drawing function must generate a bitmap and then pass it to
   realtimePasteInPlaceAlphaMasker() based on decideAlphaMaskingFeaseable().
   See livePreviewAdjustColorsArea() for an example. Alternatively, when alpha
   mask painting mode is activated, for performance considerations, a direct call to
   QPV_SetAlphaChannel() is suggested, as in livePreviewAdjustColorsArea().
 
   7. Update toggleAlphaPaintingMode(), the commented section «tools with no object
   as reference», and «create new bitmap for these tools». Add the AnyWindowOpen ID
   of the tool to isVarEqualTo(). The user alpha mask bitmap must be created based
   on the selection area dimensions.
